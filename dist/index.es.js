var fr = Object.defineProperty;
var gr = (be, ge, le) => ge in be ? fr(be, ge, { enumerable: !0, configurable: !0, writable: !0, value: le }) : be[ge] = le;
var Zt = (be, ge, le) => (gr(be, typeof ge != "symbol" ? ge + "" : ge, le), le), ni = (be, ge, le) => {
  if (!ge.has(be))
    throw TypeError("Cannot " + le);
};
var Oe = (be, ge, le) => (ni(be, ge, "read from private field"), le ? le.call(be) : ge.get(be)), ot = (be, ge, le) => {
  if (ge.has(be))
    throw TypeError("Cannot add the same private member more than once");
  ge instanceof WeakSet ? ge.add(be) : ge.set(be, le);
}, vt = (be, ge, le, ce) => (ni(be, ge, "write to private field"), ce ? ce.call(be, le) : ge.set(be, le), le), ii = (be, ge, le, ce) => ({
  set _(re) {
    vt(be, ge, re, le);
  },
  get _() {
    return Oe(be, ge, ce);
  }
}), dt = (be, ge, le) => (ni(be, ge, "access private method"), le);
import React, { createContext, PureComponent, createRef, useState, useEffect } from "react";
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(be) {
  return be && be.__esModule && Object.prototype.hasOwnProperty.call(be, "default") ? be.default : be;
}
function getAugmentedNamespace(be) {
  if (be.__esModule)
    return be;
  var ge = be.default;
  if (typeof ge == "function") {
    var le = function ce() {
      if (this instanceof ce) {
        var re = [null];
        re.push.apply(re, arguments);
        var ae = Function.bind.apply(ge, re);
        return new ae();
      }
      return ge.apply(this, arguments);
    };
    le.prototype = ge.prototype;
  } else
    le = {};
  return Object.defineProperty(le, "__esModule", { value: !0 }), Object.keys(be).forEach(function(ce) {
    var re = Object.getOwnPropertyDescriptor(be, ce);
    Object.defineProperty(le, ce, re.get ? re : {
      enumerable: !0,
      get: function() {
        return be[ce];
      }
    });
  }), le;
}
var jsxRuntimeExports = {}, jsxRuntime = {
  get exports() {
    return jsxRuntimeExports;
  },
  set exports(be) {
    jsxRuntimeExports = be;
  }
}, reactJsxRuntime_production_min = {};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var objectAssign, hasRequiredObjectAssign;
function requireObjectAssign() {
  if (hasRequiredObjectAssign)
    return objectAssign;
  hasRequiredObjectAssign = 1;
  var be = Object.getOwnPropertySymbols, ge = Object.prototype.hasOwnProperty, le = Object.prototype.propertyIsEnumerable;
  function ce(ae) {
    if (ae == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(ae);
  }
  function re() {
    try {
      if (!Object.assign)
        return !1;
      var ae = new String("abc");
      if (ae[5] = "de", Object.getOwnPropertyNames(ae)[0] === "5")
        return !1;
      for (var Z = {}, o = 0; o < 10; o++)
        Z["_" + String.fromCharCode(o)] = o;
      var C = Object.getOwnPropertyNames(Z).map(function(a) {
        return Z[a];
      });
      if (C.join("") !== "0123456789")
        return !1;
      var t = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(a) {
        t[a] = a;
      }), Object.keys(Object.assign({}, t)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return objectAssign = re() ? Object.assign : function(ae, Z) {
    for (var o, C = ce(ae), t, a = 1; a < arguments.length; a++) {
      o = Object(arguments[a]);
      for (var v in o)
        ge.call(o, v) && (C[v] = o[v]);
      if (be) {
        t = be(o);
        for (var h = 0; h < t.length; h++)
          le.call(o, t[h]) && (C[t[h]] = o[t[h]]);
      }
    }
    return C;
  }, objectAssign;
}
/** @license React v17.0.2
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min)
    return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1, requireObjectAssign();
  var be = React, ge = 60103;
  if (reactJsxRuntime_production_min.Fragment = 60107, typeof Symbol == "function" && Symbol.for) {
    var le = Symbol.for;
    ge = le("react.element"), reactJsxRuntime_production_min.Fragment = le("react.fragment");
  }
  var ce = be.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, re = Object.prototype.hasOwnProperty, ae = { key: !0, ref: !0, __self: !0, __source: !0 };
  function Z(o, C, t) {
    var a, v = {}, h = null, e = null;
    t !== void 0 && (h = "" + t), C.key !== void 0 && (h = "" + C.key), C.ref !== void 0 && (e = C.ref);
    for (a in C)
      re.call(C, a) && !ae.hasOwnProperty(a) && (v[a] = C[a]);
    if (o && o.defaultProps)
      for (a in C = o.defaultProps, C)
        v[a] === void 0 && (v[a] = C[a]);
    return { $$typeof: ge, type: o, key: h, ref: e, props: v, _owner: ce.current };
  }
  return reactJsxRuntime_production_min.jsx = Z, reactJsxRuntime_production_min.jsxs = Z, reactJsxRuntime_production_min;
}
var reactJsxRuntime_development = {};
/** @license React v17.0.2
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
  return hasRequiredReactJsxRuntime_development || (hasRequiredReactJsxRuntime_development = 1, function(be) {
    process.env.NODE_ENV !== "production" && function() {
      var ge = React, le = requireObjectAssign(), ce = 60103, re = 60106;
      be.Fragment = 60107;
      var ae = 60108, Z = 60114, o = 60109, C = 60110, t = 60112, a = 60113, v = 60120, h = 60115, e = 60116, y = 60121, c = 60122, d = 60117, p = 60129, m = 60131;
      if (typeof Symbol == "function" && Symbol.for) {
        var g = Symbol.for;
        ce = g("react.element"), re = g("react.portal"), be.Fragment = g("react.fragment"), ae = g("react.strict_mode"), Z = g("react.profiler"), o = g("react.provider"), C = g("react.context"), t = g("react.forward_ref"), a = g("react.suspense"), v = g("react.suspense_list"), h = g("react.memo"), e = g("react.lazy"), y = g("react.block"), c = g("react.server.block"), d = g("react.fundamental"), g("react.scope"), g("react.opaque.id"), p = g("react.debug_trace_mode"), g("react.offscreen"), m = g("react.legacy_hidden");
      }
      var n = typeof Symbol == "function" && Symbol.iterator, i = "@@iterator";
      function l(Te) {
        if (Te === null || typeof Te != "object")
          return null;
        var je = n && Te[n] || Te[i];
        return typeof je == "function" ? je : null;
      }
      var u = ge.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function w(Te) {
        {
          for (var je = arguments.length, Ze = new Array(je > 1 ? je - 1 : 0), Me = 1; Me < je; Me++)
            Ze[Me - 1] = arguments[Me];
          _("error", Te, Ze);
        }
      }
      function _(Te, je, Ze) {
        {
          var Me = u.ReactDebugCurrentFrame, at = Me.getStackAddendum();
          at !== "" && (je += "%s", Ze = Ze.concat([at]));
          var rt = Ze.map(function(xt) {
            return "" + xt;
          });
          rt.unshift("Warning: " + je), Function.prototype.apply.call(console[Te], console, rt);
        }
      }
      var b = !1;
      function A(Te) {
        return !!(typeof Te == "string" || typeof Te == "function" || Te === be.Fragment || Te === Z || Te === p || Te === ae || Te === a || Te === v || Te === m || b || typeof Te == "object" && Te !== null && (Te.$$typeof === e || Te.$$typeof === h || Te.$$typeof === o || Te.$$typeof === C || Te.$$typeof === t || Te.$$typeof === d || Te.$$typeof === y || Te[0] === c));
      }
      function Y(Te, je, Ze) {
        var Me = je.displayName || je.name || "";
        return Te.displayName || (Me !== "" ? Ze + "(" + Me + ")" : Ze);
      }
      function j(Te) {
        return Te.displayName || "Context";
      }
      function X(Te) {
        if (Te == null)
          return null;
        if (typeof Te.tag == "number" && w("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue."), typeof Te == "function")
          return Te.displayName || Te.name || null;
        if (typeof Te == "string")
          return Te;
        switch (Te) {
          case be.Fragment:
            return "Fragment";
          case re:
            return "Portal";
          case Z:
            return "Profiler";
          case ae:
            return "StrictMode";
          case a:
            return "Suspense";
          case v:
            return "SuspenseList";
        }
        if (typeof Te == "object")
          switch (Te.$$typeof) {
            case C:
              var je = Te;
              return j(je) + ".Consumer";
            case o:
              var Ze = Te;
              return j(Ze._context) + ".Provider";
            case t:
              return Y(Te, Te.render, "ForwardRef");
            case h:
              return X(Te.type);
            case y:
              return X(Te._render);
            case e: {
              var Me = Te, at = Me._payload, rt = Me._init;
              try {
                return X(rt(at));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var B = 0, R, k, x, f, U, O, S;
      function F() {
      }
      F.__reactDisabledLog = !0;
      function T() {
        {
          if (B === 0) {
            R = console.log, k = console.info, x = console.warn, f = console.error, U = console.group, O = console.groupCollapsed, S = console.groupEnd;
            var Te = {
              configurable: !0,
              enumerable: !0,
              value: F,
              writable: !0
            };
            Object.defineProperties(console, {
              info: Te,
              log: Te,
              warn: Te,
              error: Te,
              group: Te,
              groupCollapsed: Te,
              groupEnd: Te
            });
          }
          B++;
        }
      }
      function I() {
        {
          if (B--, B === 0) {
            var Te = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: le({}, Te, {
                value: R
              }),
              info: le({}, Te, {
                value: k
              }),
              warn: le({}, Te, {
                value: x
              }),
              error: le({}, Te, {
                value: f
              }),
              group: le({}, Te, {
                value: U
              }),
              groupCollapsed: le({}, Te, {
                value: O
              }),
              groupEnd: le({}, Te, {
                value: S
              })
            });
          }
          B < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var M = u.ReactCurrentDispatcher, V;
      function J(Te, je, Ze) {
        {
          if (V === void 0)
            try {
              throw Error();
            } catch (at) {
              var Me = at.stack.trim().match(/\n( *(at )?)/);
              V = Me && Me[1] || "";
            }
          return `
` + V + Te;
        }
      }
      var W = !1, z;
      {
        var G = typeof WeakMap == "function" ? WeakMap : Map;
        z = new G();
      }
      function L(Te, je) {
        if (!Te || W)
          return "";
        {
          var Ze = z.get(Te);
          if (Ze !== void 0)
            return Ze;
        }
        var Me;
        W = !0;
        var at = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var rt;
        rt = M.current, M.current = null, T();
        try {
          if (je) {
            var xt = function() {
              throw Error();
            };
            if (Object.defineProperty(xt.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(xt, []);
              } catch (nt) {
                Me = nt;
              }
              Reflect.construct(Te, [], xt);
            } else {
              try {
                xt.call();
              } catch (nt) {
                Me = nt;
              }
              Te.call(xt.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (nt) {
              Me = nt;
            }
            Te();
          }
        } catch (nt) {
          if (nt && Me && typeof nt.stack == "string") {
            for (var ut = nt.stack.split(`
`), yt = Me.stack.split(`
`), ht = ut.length - 1, Rt = yt.length - 1; ht >= 1 && Rt >= 0 && ut[ht] !== yt[Rt]; )
              Rt--;
            for (; ht >= 1 && Rt >= 0; ht--, Rt--)
              if (ut[ht] !== yt[Rt]) {
                if (ht !== 1 || Rt !== 1)
                  do
                    if (ht--, Rt--, Rt < 0 || ut[ht] !== yt[Rt]) {
                      var Wt = `
` + ut[ht].replace(" at new ", " at ");
                      return typeof Te == "function" && z.set(Te, Wt), Wt;
                    }
                  while (ht >= 1 && Rt >= 0);
                break;
              }
          }
        } finally {
          W = !1, M.current = rt, I(), Error.prepareStackTrace = at;
        }
        var Ke = Te ? Te.displayName || Te.name : "", Ge = Ke ? J(Ke) : "";
        return typeof Te == "function" && z.set(Te, Ge), Ge;
      }
      function K(Te, je, Ze) {
        return L(Te, !1);
      }
      function te(Te) {
        var je = Te.prototype;
        return !!(je && je.isReactComponent);
      }
      function se(Te, je, Ze) {
        if (Te == null)
          return "";
        if (typeof Te == "function")
          return L(Te, te(Te));
        if (typeof Te == "string")
          return J(Te);
        switch (Te) {
          case a:
            return J("Suspense");
          case v:
            return J("SuspenseList");
        }
        if (typeof Te == "object")
          switch (Te.$$typeof) {
            case t:
              return K(Te.render);
            case h:
              return se(Te.type, je, Ze);
            case y:
              return K(Te._render);
            case e: {
              var Me = Te, at = Me._payload, rt = Me._init;
              try {
                return se(rt(at), je, Ze);
              } catch {
              }
            }
          }
        return "";
      }
      var q = {}, N = u.ReactDebugCurrentFrame;
      function Q(Te) {
        if (Te) {
          var je = Te._owner, Ze = se(Te.type, Te._source, je ? je.type : null);
          N.setExtraStackFrame(Ze);
        } else
          N.setExtraStackFrame(null);
      }
      function D(Te, je, Ze, Me, at) {
        {
          var rt = Function.call.bind(Object.prototype.hasOwnProperty);
          for (var xt in Te)
            if (rt(Te, xt)) {
              var ut = void 0;
              try {
                if (typeof Te[xt] != "function") {
                  var yt = Error((Me || "React class") + ": " + Ze + " type `" + xt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Te[xt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw yt.name = "Invariant Violation", yt;
                }
                ut = Te[xt](je, xt, Me, Ze, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ht) {
                ut = ht;
              }
              ut && !(ut instanceof Error) && (Q(at), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Me || "React class", Ze, xt, typeof ut), Q(null)), ut instanceof Error && !(ut.message in q) && (q[ut.message] = !0, Q(at), w("Failed %s type: %s", Ze, ut.message), Q(null));
            }
        }
      }
      var ne = u.ReactCurrentOwner, oe = Object.prototype.hasOwnProperty, ee = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, $, E, H;
      H = {};
      function ie(Te) {
        if (oe.call(Te, "ref")) {
          var je = Object.getOwnPropertyDescriptor(Te, "ref").get;
          if (je && je.isReactWarning)
            return !1;
        }
        return Te.ref !== void 0;
      }
      function ue(Te) {
        if (oe.call(Te, "key")) {
          var je = Object.getOwnPropertyDescriptor(Te, "key").get;
          if (je && je.isReactWarning)
            return !1;
        }
        return Te.key !== void 0;
      }
      function fe(Te, je) {
        if (typeof Te.ref == "string" && ne.current && je && ne.current.stateNode !== je) {
          var Ze = X(ne.current.type);
          H[Ze] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', X(ne.current.type), Te.ref), H[Ze] = !0);
        }
      }
      function de(Te, je) {
        {
          var Ze = function() {
            $ || ($ = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", je));
          };
          Ze.isReactWarning = !0, Object.defineProperty(Te, "key", {
            get: Ze,
            configurable: !0
          });
        }
      }
      function pe(Te, je) {
        {
          var Ze = function() {
            E || (E = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", je));
          };
          Ze.isReactWarning = !0, Object.defineProperty(Te, "ref", {
            get: Ze,
            configurable: !0
          });
        }
      }
      var xe = function(Te, je, Ze, Me, at, rt, xt) {
        var ut = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: ce,
          // Built-in properties that belong on the element
          type: Te,
          key: je,
          ref: Ze,
          props: xt,
          // Record the component responsible for creating this element.
          _owner: rt
        };
        return ut._store = {}, Object.defineProperty(ut._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(ut, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: Me
        }), Object.defineProperty(ut, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: at
        }), Object.freeze && (Object.freeze(ut.props), Object.freeze(ut)), ut;
      };
      function De(Te, je, Ze, Me, at) {
        {
          var rt, xt = {}, ut = null, yt = null;
          Ze !== void 0 && (ut = "" + Ze), ue(je) && (ut = "" + je.key), ie(je) && (yt = je.ref, fe(je, at));
          for (rt in je)
            oe.call(je, rt) && !ee.hasOwnProperty(rt) && (xt[rt] = je[rt]);
          if (Te && Te.defaultProps) {
            var ht = Te.defaultProps;
            for (rt in ht)
              xt[rt] === void 0 && (xt[rt] = ht[rt]);
          }
          if (ut || yt) {
            var Rt = typeof Te == "function" ? Te.displayName || Te.name || "Unknown" : Te;
            ut && de(xt, Rt), yt && pe(xt, Rt);
          }
          return xe(Te, ut, yt, at, Me, ne.current, xt);
        }
      }
      var Ae = u.ReactCurrentOwner, Se = u.ReactDebugCurrentFrame;
      function ke(Te) {
        if (Te) {
          var je = Te._owner, Ze = se(Te.type, Te._source, je ? je.type : null);
          Se.setExtraStackFrame(Ze);
        } else
          Se.setExtraStackFrame(null);
      }
      var ye;
      ye = !1;
      function _e(Te) {
        return typeof Te == "object" && Te !== null && Te.$$typeof === ce;
      }
      function we() {
        {
          if (Ae.current) {
            var Te = X(Ae.current.type);
            if (Te)
              return `

Check the render method of \`` + Te + "`.";
          }
          return "";
        }
      }
      function Ce(Te) {
        {
          if (Te !== void 0) {
            var je = Te.fileName.replace(/^.*[\\\/]/, ""), Ze = Te.lineNumber;
            return `

Check your code at ` + je + ":" + Ze + ".";
          }
          return "";
        }
      }
      var ve = {};
      function Le(Te) {
        {
          var je = we();
          if (!je) {
            var Ze = typeof Te == "string" ? Te : Te.displayName || Te.name;
            Ze && (je = `

Check the top-level render call using <` + Ze + ">.");
          }
          return je;
        }
      }
      function He(Te, je) {
        {
          if (!Te._store || Te._store.validated || Te.key != null)
            return;
          Te._store.validated = !0;
          var Ze = Le(je);
          if (ve[Ze])
            return;
          ve[Ze] = !0;
          var Me = "";
          Te && Te._owner && Te._owner !== Ae.current && (Me = " It was passed a child from " + X(Te._owner.type) + "."), ke(Te), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Ze, Me), ke(null);
        }
      }
      function Qe(Te, je) {
        {
          if (typeof Te != "object")
            return;
          if (Array.isArray(Te))
            for (var Ze = 0; Ze < Te.length; Ze++) {
              var Me = Te[Ze];
              _e(Me) && He(Me, je);
            }
          else if (_e(Te))
            Te._store && (Te._store.validated = !0);
          else if (Te) {
            var at = l(Te);
            if (typeof at == "function" && at !== Te.entries)
              for (var rt = at.call(Te), xt; !(xt = rt.next()).done; )
                _e(xt.value) && He(xt.value, je);
          }
        }
      }
      function Ue(Te) {
        {
          var je = Te.type;
          if (je == null || typeof je == "string")
            return;
          var Ze;
          if (typeof je == "function")
            Ze = je.propTypes;
          else if (typeof je == "object" && (je.$$typeof === t || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          je.$$typeof === h))
            Ze = je.propTypes;
          else
            return;
          if (Ze) {
            var Me = X(je);
            D(Ze, Te.props, "prop", Me, Te);
          } else if (je.PropTypes !== void 0 && !ye) {
            ye = !0;
            var at = X(je);
            w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", at || "Unknown");
          }
          typeof je.getDefaultProps == "function" && !je.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function Ie(Te) {
        {
          for (var je = Object.keys(Te.props), Ze = 0; Ze < je.length; Ze++) {
            var Me = je[Ze];
            if (Me !== "children" && Me !== "key") {
              ke(Te), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Me), ke(null);
              break;
            }
          }
          Te.ref !== null && (ke(Te), w("Invalid attribute `ref` supplied to `React.Fragment`."), ke(null));
        }
      }
      function Ee(Te, je, Ze, Me, at, rt) {
        {
          var xt = A(Te);
          if (!xt) {
            var ut = "";
            (Te === void 0 || typeof Te == "object" && Te !== null && Object.keys(Te).length === 0) && (ut += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
            var yt = Ce(at);
            yt ? ut += yt : ut += we();
            var ht;
            Te === null ? ht = "null" : Array.isArray(Te) ? ht = "array" : Te !== void 0 && Te.$$typeof === ce ? (ht = "<" + (X(Te.type) || "Unknown") + " />", ut = " Did you accidentally export a JSX literal instead of a component?") : ht = typeof Te, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", ht, ut);
          }
          var Rt = De(Te, je, Ze, at, rt);
          if (Rt == null)
            return Rt;
          if (xt) {
            var Wt = je.children;
            if (Wt !== void 0)
              if (Me)
                if (Array.isArray(Wt)) {
                  for (var Ke = 0; Ke < Wt.length; Ke++)
                    Qe(Wt[Ke], Te);
                  Object.freeze && Object.freeze(Wt);
                } else
                  w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
              else
                Qe(Wt, Te);
          }
          return Te === be.Fragment ? Ie(Rt) : Ue(Rt), Rt;
        }
      }
      function et(Te, je, Ze) {
        return Ee(Te, je, Ze, !0);
      }
      function qe(Te, je, Ze) {
        return Ee(Te, je, Ze, !1);
      }
      var tt = qe, ft = et;
      be.jsx = tt, be.jsxs = ft;
    }();
  }(reactJsxRuntime_development)), reactJsxRuntime_development;
}
(function(be) {
  process.env.NODE_ENV === "production" ? be.exports = requireReactJsxRuntime_production_min() : be.exports = requireReactJsxRuntime_development();
})(jsxRuntime);
const jsx = jsxRuntimeExports.jsx, jsxs = jsxRuntimeExports.jsxs, wrapper$4 = "_wrapper_1658j_1", image = "_image_1658j_6", thumbnail$2 = "_thumbnail_1658j_10", s$4 = {
  wrapper: wrapper$4,
  image,
  thumbnail: thumbnail$2
}, ImageViewer = ({ filePath: be, isThumbnail: ge }) => /* @__PURE__ */ jsx("div", { className: s$4.wrapper, children: /* @__PURE__ */ jsx(
  "img",
  {
    className: `${s$4.image} ${ge ? s$4.thumbnail : ""}`,
    src: be,
    alt: "Work sample image"
  }
) });
function commonjsRequire(be) {
  throw new Error('Could not dynamically require "' + be + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var pdfExports = {}, pdf = {
  get exports() {
    return pdfExports;
  },
  set exports(be) {
    pdfExports = be;
  }
};
const __viteBrowserExternal = {}, __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" })), require$$5 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
(function(module, exports) {
  (function(ge, le) {
    module.exports = le();
  })(globalThis, () => (
    /******/
    (() => {
      var __webpack_modules__ = [
        ,
        /* 1 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.VerbosityLevel = ge.Util = ge.UnknownErrorException = ge.UnexpectedResponseException = ge.UNSUPPORTED_FEATURES = ge.TextRenderingMode = ge.StreamType = ge.RenderingIntentFlag = ge.PermissionFlag = ge.PasswordResponses = ge.PasswordException = ge.PageActionEventType = ge.OPS = ge.MissingPDFException = ge.LINE_FACTOR = ge.LINE_DESCENT_FACTOR = ge.InvalidPDFException = ge.ImageKind = ge.IDENTITY_MATRIX = ge.FormatError = ge.FontType = ge.FeatureTest = ge.FONT_IDENTITY_MATRIX = ge.DocumentActionEventType = ge.CMapCompressionType = ge.BaseException = ge.AnnotationType = ge.AnnotationStateModelType = ge.AnnotationReviewState = ge.AnnotationReplyType = ge.AnnotationMode = ge.AnnotationMarkedState = ge.AnnotationFlag = ge.AnnotationFieldFlag = ge.AnnotationEditorType = ge.AnnotationEditorPrefix = ge.AnnotationEditorParamsType = ge.AnnotationBorderStyleType = ge.AnnotationActionEventType = ge.AbortException = void 0, ge.arrayByteLength = N, ge.arraysToBytes = Q, ge.assert = F, ge.bytesToString = se, ge.createPromiseCapability = _e, ge.createValidAbsoluteUrl = I, ge.escapeString = de, ge.getModificationDate = ye, ge.getVerbosityLevel = f, ge.info = U, ge.isArrayBuffer = Se, ge.isArrayEqual = ke, ge.isAscii = pe, ge.objectFromMap = oe, ge.objectSize = ne, ge.setVerbosityLevel = x, ge.shadow = M, ge.string32 = D, ge.stringToBytes = q, ge.stringToPDFString = fe, ge.stringToUTF16BEString = xe, ge.stringToUTF8String = De, ge.unreachable = S, ge.utf8StringToString = Ae, ge.warn = O, le(2);
          const ce = [1, 0, 0, 1, 0, 0];
          ge.IDENTITY_MATRIX = ce;
          const re = [1e-3, 0, 0, 1e-3, 0, 0];
          ge.FONT_IDENTITY_MATRIX = re;
          const ae = 1.35;
          ge.LINE_FACTOR = ae;
          const Z = 0.35;
          ge.LINE_DESCENT_FACTOR = Z;
          const o = {
            ANY: 1,
            DISPLAY: 2,
            PRINT: 4,
            ANNOTATIONS_FORMS: 16,
            ANNOTATIONS_STORAGE: 32,
            ANNOTATIONS_DISABLE: 64,
            OPLIST: 256
          };
          ge.RenderingIntentFlag = o;
          const C = {
            DISABLE: 0,
            ENABLE: 1,
            ENABLE_FORMS: 2,
            ENABLE_STORAGE: 3
          };
          ge.AnnotationMode = C;
          const t = "pdfjs_internal_editor_";
          ge.AnnotationEditorPrefix = t;
          const a = {
            DISABLE: -1,
            NONE: 0,
            FREETEXT: 3,
            INK: 15
          };
          ge.AnnotationEditorType = a;
          const v = {
            FREETEXT_SIZE: 1,
            FREETEXT_COLOR: 2,
            FREETEXT_OPACITY: 3,
            INK_COLOR: 11,
            INK_THICKNESS: 12,
            INK_OPACITY: 13
          };
          ge.AnnotationEditorParamsType = v;
          const h = {
            PRINT: 4,
            MODIFY_CONTENTS: 8,
            COPY: 16,
            MODIFY_ANNOTATIONS: 32,
            FILL_INTERACTIVE_FORMS: 256,
            COPY_FOR_ACCESSIBILITY: 512,
            ASSEMBLE: 1024,
            PRINT_HIGH_QUALITY: 2048
          };
          ge.PermissionFlag = h;
          const e = {
            FILL: 0,
            STROKE: 1,
            FILL_STROKE: 2,
            INVISIBLE: 3,
            FILL_ADD_TO_PATH: 4,
            STROKE_ADD_TO_PATH: 5,
            FILL_STROKE_ADD_TO_PATH: 6,
            ADD_TO_PATH: 7,
            FILL_STROKE_MASK: 3,
            ADD_TO_PATH_FLAG: 4
          };
          ge.TextRenderingMode = e;
          const y = {
            GRAYSCALE_1BPP: 1,
            RGB_24BPP: 2,
            RGBA_32BPP: 3
          };
          ge.ImageKind = y;
          const c = {
            TEXT: 1,
            LINK: 2,
            FREETEXT: 3,
            LINE: 4,
            SQUARE: 5,
            CIRCLE: 6,
            POLYGON: 7,
            POLYLINE: 8,
            HIGHLIGHT: 9,
            UNDERLINE: 10,
            SQUIGGLY: 11,
            STRIKEOUT: 12,
            STAMP: 13,
            CARET: 14,
            INK: 15,
            POPUP: 16,
            FILEATTACHMENT: 17,
            SOUND: 18,
            MOVIE: 19,
            WIDGET: 20,
            SCREEN: 21,
            PRINTERMARK: 22,
            TRAPNET: 23,
            WATERMARK: 24,
            THREED: 25,
            REDACT: 26
          };
          ge.AnnotationType = c;
          const d = {
            MARKED: "Marked",
            REVIEW: "Review"
          };
          ge.AnnotationStateModelType = d;
          const p = {
            MARKED: "Marked",
            UNMARKED: "Unmarked"
          };
          ge.AnnotationMarkedState = p;
          const m = {
            ACCEPTED: "Accepted",
            REJECTED: "Rejected",
            CANCELLED: "Cancelled",
            COMPLETED: "Completed",
            NONE: "None"
          };
          ge.AnnotationReviewState = m;
          const g = {
            GROUP: "Group",
            REPLY: "R"
          };
          ge.AnnotationReplyType = g;
          const n = {
            INVISIBLE: 1,
            HIDDEN: 2,
            PRINT: 4,
            NOZOOM: 8,
            NOROTATE: 16,
            NOVIEW: 32,
            READONLY: 64,
            LOCKED: 128,
            TOGGLENOVIEW: 256,
            LOCKEDCONTENTS: 512
          };
          ge.AnnotationFlag = n;
          const i = {
            READONLY: 1,
            REQUIRED: 2,
            NOEXPORT: 4,
            MULTILINE: 4096,
            PASSWORD: 8192,
            NOTOGGLETOOFF: 16384,
            RADIO: 32768,
            PUSHBUTTON: 65536,
            COMBO: 131072,
            EDIT: 262144,
            SORT: 524288,
            FILESELECT: 1048576,
            MULTISELECT: 2097152,
            DONOTSPELLCHECK: 4194304,
            DONOTSCROLL: 8388608,
            COMB: 16777216,
            RICHTEXT: 33554432,
            RADIOSINUNISON: 33554432,
            COMMITONSELCHANGE: 67108864
          };
          ge.AnnotationFieldFlag = i;
          const l = {
            SOLID: 1,
            DASHED: 2,
            BEVELED: 3,
            INSET: 4,
            UNDERLINE: 5
          };
          ge.AnnotationBorderStyleType = l;
          const u = {
            E: "Mouse Enter",
            X: "Mouse Exit",
            D: "Mouse Down",
            U: "Mouse Up",
            Fo: "Focus",
            Bl: "Blur",
            PO: "PageOpen",
            PC: "PageClose",
            PV: "PageVisible",
            PI: "PageInvisible",
            K: "Keystroke",
            F: "Format",
            V: "Validate",
            C: "Calculate"
          };
          ge.AnnotationActionEventType = u;
          const w = {
            WC: "WillClose",
            WS: "WillSave",
            DS: "DidSave",
            WP: "WillPrint",
            DP: "DidPrint"
          };
          ge.DocumentActionEventType = w;
          const _ = {
            O: "PageOpen",
            C: "PageClose"
          };
          ge.PageActionEventType = _;
          const b = {
            UNKNOWN: "UNKNOWN",
            FLATE: "FLATE",
            LZW: "LZW",
            DCT: "DCT",
            JPX: "JPX",
            JBIG: "JBIG",
            A85: "A85",
            AHX: "AHX",
            CCF: "CCF",
            RLX: "RLX"
          };
          ge.StreamType = b;
          const A = {
            UNKNOWN: "UNKNOWN",
            TYPE1: "TYPE1",
            TYPE1STANDARD: "TYPE1STANDARD",
            TYPE1C: "TYPE1C",
            CIDFONTTYPE0: "CIDFONTTYPE0",
            CIDFONTTYPE0C: "CIDFONTTYPE0C",
            TRUETYPE: "TRUETYPE",
            CIDFONTTYPE2: "CIDFONTTYPE2",
            TYPE3: "TYPE3",
            OPENTYPE: "OPENTYPE",
            TYPE0: "TYPE0",
            MMTYPE1: "MMTYPE1"
          };
          ge.FontType = A;
          const Y = {
            ERRORS: 0,
            WARNINGS: 1,
            INFOS: 5
          };
          ge.VerbosityLevel = Y;
          const j = {
            NONE: 0,
            BINARY: 1,
            STREAM: 2
          };
          ge.CMapCompressionType = j;
          const X = {
            dependency: 1,
            setLineWidth: 2,
            setLineCap: 3,
            setLineJoin: 4,
            setMiterLimit: 5,
            setDash: 6,
            setRenderingIntent: 7,
            setFlatness: 8,
            setGState: 9,
            save: 10,
            restore: 11,
            transform: 12,
            moveTo: 13,
            lineTo: 14,
            curveTo: 15,
            curveTo2: 16,
            curveTo3: 17,
            closePath: 18,
            rectangle: 19,
            stroke: 20,
            closeStroke: 21,
            fill: 22,
            eoFill: 23,
            fillStroke: 24,
            eoFillStroke: 25,
            closeFillStroke: 26,
            closeEOFillStroke: 27,
            endPath: 28,
            clip: 29,
            eoClip: 30,
            beginText: 31,
            endText: 32,
            setCharSpacing: 33,
            setWordSpacing: 34,
            setHScale: 35,
            setLeading: 36,
            setFont: 37,
            setTextRenderingMode: 38,
            setTextRise: 39,
            moveText: 40,
            setLeadingMoveText: 41,
            setTextMatrix: 42,
            nextLine: 43,
            showText: 44,
            showSpacedText: 45,
            nextLineShowText: 46,
            nextLineSetSpacingShowText: 47,
            setCharWidth: 48,
            setCharWidthAndBounds: 49,
            setStrokeColorSpace: 50,
            setFillColorSpace: 51,
            setStrokeColor: 52,
            setStrokeColorN: 53,
            setFillColor: 54,
            setFillColorN: 55,
            setStrokeGray: 56,
            setFillGray: 57,
            setStrokeRGBColor: 58,
            setFillRGBColor: 59,
            setStrokeCMYKColor: 60,
            setFillCMYKColor: 61,
            shadingFill: 62,
            beginInlineImage: 63,
            beginImageData: 64,
            endInlineImage: 65,
            paintXObject: 66,
            markPoint: 67,
            markPointProps: 68,
            beginMarkedContent: 69,
            beginMarkedContentProps: 70,
            endMarkedContent: 71,
            beginCompat: 72,
            endCompat: 73,
            paintFormXObjectBegin: 74,
            paintFormXObjectEnd: 75,
            beginGroup: 76,
            endGroup: 77,
            beginAnnotations: 78,
            endAnnotations: 79,
            beginAnnotation: 80,
            endAnnotation: 81,
            paintJpegXObject: 82,
            paintImageMaskXObject: 83,
            paintImageMaskXObjectGroup: 84,
            paintImageXObject: 85,
            paintInlineImageXObject: 86,
            paintInlineImageXObjectGroup: 87,
            paintImageXObjectRepeat: 88,
            paintImageMaskXObjectRepeat: 89,
            paintSolidColorImageMask: 90,
            constructPath: 91
          };
          ge.OPS = X;
          const B = {
            unknown: "unknown",
            forms: "forms",
            javaScript: "javaScript",
            signatures: "signatures",
            smask: "smask",
            shadingPattern: "shadingPattern",
            font: "font",
            errorTilingPattern: "errorTilingPattern",
            errorExtGState: "errorExtGState",
            errorXObject: "errorXObject",
            errorFontLoadType3: "errorFontLoadType3",
            errorFontState: "errorFontState",
            errorFontMissing: "errorFontMissing",
            errorFontTranslate: "errorFontTranslate",
            errorColorSpace: "errorColorSpace",
            errorOperatorList: "errorOperatorList",
            errorFontToUnicode: "errorFontToUnicode",
            errorFontLoadNative: "errorFontLoadNative",
            errorFontBuildPath: "errorFontBuildPath",
            errorFontGetPath: "errorFontGetPath",
            errorMarkedContent: "errorMarkedContent",
            errorContentSubStream: "errorContentSubStream"
          };
          ge.UNSUPPORTED_FEATURES = B;
          const R = {
            NEED_PASSWORD: 1,
            INCORRECT_PASSWORD: 2
          };
          ge.PasswordResponses = R;
          let k = Y.WARNINGS;
          function x(we) {
            Number.isInteger(we) && (k = we);
          }
          function f() {
            return k;
          }
          function U(we) {
            k >= Y.INFOS && console.log(`Info: ${we}`);
          }
          function O(we) {
            k >= Y.WARNINGS && console.log(`Warning: ${we}`);
          }
          function S(we) {
            throw new Error(we);
          }
          function F(we, Ce) {
            we || S(Ce);
          }
          function T(we) {
            if (!we)
              return !1;
            switch (we.protocol) {
              case "http:":
              case "https:":
              case "ftp:":
              case "mailto:":
              case "tel:":
                return !0;
              default:
                return !1;
            }
          }
          function I(we, Ce = null, ve = null) {
            if (!we)
              return null;
            try {
              if (ve && typeof we == "string") {
                if (ve.addDefaultProtocol && we.startsWith("www.")) {
                  const He = we.match(/\./g);
                  He && He.length >= 2 && (we = `http://${we}`);
                }
                if (ve.tryConvertEncoding)
                  try {
                    we = De(we);
                  } catch {
                  }
              }
              const Le = Ce ? new URL(we, Ce) : new URL(we);
              if (T(Le))
                return Le;
            } catch {
            }
            return null;
          }
          function M(we, Ce, ve) {
            return Object.defineProperty(we, Ce, {
              value: ve,
              enumerable: !0,
              configurable: !0,
              writable: !1
            }), ve;
          }
          const V = function() {
            function Ce(ve, Le) {
              this.constructor === Ce && S("Cannot initialize BaseException."), this.message = ve, this.name = Le;
            }
            return Ce.prototype = new Error(), Ce.constructor = Ce, Ce;
          }();
          ge.BaseException = V;
          class J extends V {
            constructor(Ce, ve) {
              super(Ce, "PasswordException"), this.code = ve;
            }
          }
          ge.PasswordException = J;
          class W extends V {
            constructor(Ce, ve) {
              super(Ce, "UnknownErrorException"), this.details = ve;
            }
          }
          ge.UnknownErrorException = W;
          class z extends V {
            constructor(Ce) {
              super(Ce, "InvalidPDFException");
            }
          }
          ge.InvalidPDFException = z;
          class G extends V {
            constructor(Ce) {
              super(Ce, "MissingPDFException");
            }
          }
          ge.MissingPDFException = G;
          class L extends V {
            constructor(Ce, ve) {
              super(Ce, "UnexpectedResponseException"), this.status = ve;
            }
          }
          ge.UnexpectedResponseException = L;
          class K extends V {
            constructor(Ce) {
              super(Ce, "FormatError");
            }
          }
          ge.FormatError = K;
          class te extends V {
            constructor(Ce) {
              super(Ce, "AbortException");
            }
          }
          ge.AbortException = te;
          function se(we) {
            (typeof we != "object" || we === null || we.length === void 0) && S("Invalid argument for bytesToString");
            const Ce = we.length, ve = 8192;
            if (Ce < ve)
              return String.fromCharCode.apply(null, we);
            const Le = [];
            for (let He = 0; He < Ce; He += ve) {
              const Qe = Math.min(He + ve, Ce), Ue = we.subarray(He, Qe);
              Le.push(String.fromCharCode.apply(null, Ue));
            }
            return Le.join("");
          }
          function q(we) {
            typeof we != "string" && S("Invalid argument for stringToBytes");
            const Ce = we.length, ve = new Uint8Array(Ce);
            for (let Le = 0; Le < Ce; ++Le)
              ve[Le] = we.charCodeAt(Le) & 255;
            return ve;
          }
          function N(we) {
            if (we.length !== void 0)
              return we.length;
            if (we.byteLength !== void 0)
              return we.byteLength;
            S("Invalid argument for arrayByteLength");
          }
          function Q(we) {
            const Ce = we.length;
            if (Ce === 1 && we[0] instanceof Uint8Array)
              return we[0];
            let ve = 0;
            for (let Qe = 0; Qe < Ce; Qe++)
              ve += N(we[Qe]);
            let Le = 0;
            const He = new Uint8Array(ve);
            for (let Qe = 0; Qe < Ce; Qe++) {
              let Ue = we[Qe];
              Ue instanceof Uint8Array || (typeof Ue == "string" ? Ue = q(Ue) : Ue = new Uint8Array(Ue));
              const Ie = Ue.byteLength;
              He.set(Ue, Le), Le += Ie;
            }
            return He;
          }
          function D(we) {
            return String.fromCharCode(we >> 24 & 255, we >> 16 & 255, we >> 8 & 255, we & 255);
          }
          function ne(we) {
            return Object.keys(we).length;
          }
          function oe(we) {
            const Ce = /* @__PURE__ */ Object.create(null);
            for (const [ve, Le] of we)
              Ce[ve] = Le;
            return Ce;
          }
          function ee() {
            const we = new Uint8Array(4);
            return we[0] = 1, new Uint32Array(we.buffer, 0, 1)[0] === 1;
          }
          function $() {
            try {
              return new Function(""), !0;
            } catch {
              return !1;
            }
          }
          class E {
            static get isLittleEndian() {
              return M(this, "isLittleEndian", ee());
            }
            static get isEvalSupported() {
              return M(this, "isEvalSupported", $());
            }
            static get isOffscreenCanvasSupported() {
              return M(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas < "u");
            }
          }
          ge.FeatureTest = E;
          const H = [...Array(256).keys()].map((we) => we.toString(16).padStart(2, "0"));
          class ie {
            static makeHexColor(Ce, ve, Le) {
              return `#${H[Ce]}${H[ve]}${H[Le]}`;
            }
            static scaleMinMax(Ce, ve) {
              let Le;
              Ce[0] ? (Ce[0] < 0 && (Le = ve[0], ve[0] = ve[1], ve[1] = Le), ve[0] *= Ce[0], ve[1] *= Ce[0], Ce[3] < 0 && (Le = ve[2], ve[2] = ve[3], ve[3] = Le), ve[2] *= Ce[3], ve[3] *= Ce[3]) : (Le = ve[0], ve[0] = ve[2], ve[2] = Le, Le = ve[1], ve[1] = ve[3], ve[3] = Le, Ce[1] < 0 && (Le = ve[2], ve[2] = ve[3], ve[3] = Le), ve[2] *= Ce[1], ve[3] *= Ce[1], Ce[2] < 0 && (Le = ve[0], ve[0] = ve[1], ve[1] = Le), ve[0] *= Ce[2], ve[1] *= Ce[2]), ve[0] += Ce[4], ve[1] += Ce[4], ve[2] += Ce[5], ve[3] += Ce[5];
            }
            static transform(Ce, ve) {
              return [Ce[0] * ve[0] + Ce[2] * ve[1], Ce[1] * ve[0] + Ce[3] * ve[1], Ce[0] * ve[2] + Ce[2] * ve[3], Ce[1] * ve[2] + Ce[3] * ve[3], Ce[0] * ve[4] + Ce[2] * ve[5] + Ce[4], Ce[1] * ve[4] + Ce[3] * ve[5] + Ce[5]];
            }
            static applyTransform(Ce, ve) {
              const Le = Ce[0] * ve[0] + Ce[1] * ve[2] + ve[4], He = Ce[0] * ve[1] + Ce[1] * ve[3] + ve[5];
              return [Le, He];
            }
            static applyInverseTransform(Ce, ve) {
              const Le = ve[0] * ve[3] - ve[1] * ve[2], He = (Ce[0] * ve[3] - Ce[1] * ve[2] + ve[2] * ve[5] - ve[4] * ve[3]) / Le, Qe = (-Ce[0] * ve[1] + Ce[1] * ve[0] + ve[4] * ve[1] - ve[5] * ve[0]) / Le;
              return [He, Qe];
            }
            static getAxialAlignedBoundingBox(Ce, ve) {
              const Le = ie.applyTransform(Ce, ve), He = ie.applyTransform(Ce.slice(2, 4), ve), Qe = ie.applyTransform([Ce[0], Ce[3]], ve), Ue = ie.applyTransform([Ce[2], Ce[1]], ve);
              return [Math.min(Le[0], He[0], Qe[0], Ue[0]), Math.min(Le[1], He[1], Qe[1], Ue[1]), Math.max(Le[0], He[0], Qe[0], Ue[0]), Math.max(Le[1], He[1], Qe[1], Ue[1])];
            }
            static inverseTransform(Ce) {
              const ve = Ce[0] * Ce[3] - Ce[1] * Ce[2];
              return [Ce[3] / ve, -Ce[1] / ve, -Ce[2] / ve, Ce[0] / ve, (Ce[2] * Ce[5] - Ce[4] * Ce[3]) / ve, (Ce[4] * Ce[1] - Ce[5] * Ce[0]) / ve];
            }
            static apply3dTransform(Ce, ve) {
              return [Ce[0] * ve[0] + Ce[1] * ve[1] + Ce[2] * ve[2], Ce[3] * ve[0] + Ce[4] * ve[1] + Ce[5] * ve[2], Ce[6] * ve[0] + Ce[7] * ve[1] + Ce[8] * ve[2]];
            }
            static singularValueDecompose2dScale(Ce) {
              const ve = [Ce[0], Ce[2], Ce[1], Ce[3]], Le = Ce[0] * ve[0] + Ce[1] * ve[2], He = Ce[0] * ve[1] + Ce[1] * ve[3], Qe = Ce[2] * ve[0] + Ce[3] * ve[2], Ue = Ce[2] * ve[1] + Ce[3] * ve[3], Ie = (Le + Ue) / 2, Ee = Math.sqrt((Le + Ue) ** 2 - 4 * (Le * Ue - Qe * He)) / 2, et = Ie + Ee || 1, qe = Ie - Ee || 1;
              return [Math.sqrt(et), Math.sqrt(qe)];
            }
            static normalizeRect(Ce) {
              const ve = Ce.slice(0);
              return Ce[0] > Ce[2] && (ve[0] = Ce[2], ve[2] = Ce[0]), Ce[1] > Ce[3] && (ve[1] = Ce[3], ve[3] = Ce[1]), ve;
            }
            static intersect(Ce, ve) {
              const Le = Math.max(Math.min(Ce[0], Ce[2]), Math.min(ve[0], ve[2])), He = Math.min(Math.max(Ce[0], Ce[2]), Math.max(ve[0], ve[2]));
              if (Le > He)
                return null;
              const Qe = Math.max(Math.min(Ce[1], Ce[3]), Math.min(ve[1], ve[3])), Ue = Math.min(Math.max(Ce[1], Ce[3]), Math.max(ve[1], ve[3]));
              return Qe > Ue ? null : [Le, Qe, He, Ue];
            }
            static bezierBoundingBox(Ce, ve, Le, He, Qe, Ue, Ie, Ee) {
              const et = [], qe = [[], []];
              let tt, ft, Te, je, Ze, Me, at, rt;
              for (let ht = 0; ht < 2; ++ht) {
                if (ht === 0 ? (ft = 6 * Ce - 12 * Le + 6 * Qe, tt = -3 * Ce + 9 * Le - 9 * Qe + 3 * Ie, Te = 3 * Le - 3 * Ce) : (ft = 6 * ve - 12 * He + 6 * Ue, tt = -3 * ve + 9 * He - 9 * Ue + 3 * Ee, Te = 3 * He - 3 * ve), Math.abs(tt) < 1e-12) {
                  if (Math.abs(ft) < 1e-12)
                    continue;
                  je = -Te / ft, 0 < je && je < 1 && et.push(je);
                  continue;
                }
                at = ft * ft - 4 * Te * tt, rt = Math.sqrt(at), !(at < 0) && (Ze = (-ft + rt) / (2 * tt), 0 < Ze && Ze < 1 && et.push(Ze), Me = (-ft - rt) / (2 * tt), 0 < Me && Me < 1 && et.push(Me));
              }
              let xt = et.length, ut;
              const yt = xt;
              for (; xt--; )
                je = et[xt], ut = 1 - je, qe[0][xt] = ut * ut * ut * Ce + 3 * ut * ut * je * Le + 3 * ut * je * je * Qe + je * je * je * Ie, qe[1][xt] = ut * ut * ut * ve + 3 * ut * ut * je * He + 3 * ut * je * je * Ue + je * je * je * Ee;
              return qe[0][yt] = Ce, qe[1][yt] = ve, qe[0][yt + 1] = Ie, qe[1][yt + 1] = Ee, qe[0].length = qe[1].length = yt + 2, [Math.min(...qe[0]), Math.min(...qe[1]), Math.max(...qe[0]), Math.max(...qe[1])];
            }
          }
          ge.Util = ie;
          const ue = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
          function fe(we) {
            if (we[0] >= "ï") {
              let ve;
              if (we[0] === "þ" && we[1] === "ÿ" ? ve = "utf-16be" : we[0] === "ÿ" && we[1] === "þ" ? ve = "utf-16le" : we[0] === "ï" && we[1] === "»" && we[2] === "¿" && (ve = "utf-8"), ve)
                try {
                  const Le = new TextDecoder(ve, {
                    fatal: !0
                  }), He = q(we);
                  return Le.decode(He);
                } catch (Le) {
                  O(`stringToPDFString: "${Le}".`);
                }
            }
            const Ce = [];
            for (let ve = 0, Le = we.length; ve < Le; ve++) {
              const He = ue[we.charCodeAt(ve)];
              Ce.push(He ? String.fromCharCode(He) : we.charAt(ve));
            }
            return Ce.join("");
          }
          function de(we) {
            return we.replace(/([()\\\n\r])/g, (Ce) => Ce === `
` ? "\\n" : Ce === "\r" ? "\\r" : `\\${Ce}`);
          }
          function pe(we) {
            return /^[\x00-\x7F]*$/.test(we);
          }
          function xe(we) {
            const Ce = ["þÿ"];
            for (let ve = 0, Le = we.length; ve < Le; ve++) {
              const He = we.charCodeAt(ve);
              Ce.push(String.fromCharCode(He >> 8 & 255), String.fromCharCode(He & 255));
            }
            return Ce.join("");
          }
          function De(we) {
            return decodeURIComponent(escape(we));
          }
          function Ae(we) {
            return unescape(encodeURIComponent(we));
          }
          function Se(we) {
            return typeof we == "object" && we !== null && we.byteLength !== void 0;
          }
          function ke(we, Ce) {
            if (we.length !== Ce.length)
              return !1;
            for (let ve = 0, Le = we.length; ve < Le; ve++)
              if (we[ve] !== Ce[ve])
                return !1;
            return !0;
          }
          function ye(we = new Date()) {
            return [we.getUTCFullYear().toString(), (we.getUTCMonth() + 1).toString().padStart(2, "0"), we.getUTCDate().toString().padStart(2, "0"), we.getUTCHours().toString().padStart(2, "0"), we.getUTCMinutes().toString().padStart(2, "0"), we.getUTCSeconds().toString().padStart(2, "0")].join("");
          }
          function _e() {
            const we = /* @__PURE__ */ Object.create(null);
            let Ce = !1;
            return Object.defineProperty(we, "settled", {
              get() {
                return Ce;
              }
            }), we.promise = new Promise(function(ve, Le) {
              we.resolve = function(He) {
                Ce = !0, ve(He);
              }, we.reject = function(He) {
                Ce = !0, Le(He);
              };
            }), we;
          }
        },
        /* 2 */
        /***/
        (be, ge, le) => {
          le(3);
        },
        /* 3 */
        /***/
        (be, ge) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.isNodeJS = void 0;
          const le = typeof process == "object" && process + "" == "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
          ge.isNodeJS = le;
        },
        /* 4 */
        /***/
        (__unused_webpack_module, exports, __w_pdfjs_require__) => {
          var be, le, ce, re, ae, Z, o, C, t, ri, v, h;
          Object.defineProperty(exports, "__esModule", {
            value: !0
          }), exports.build = exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0, exports.getDocument = getDocument, exports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory, exports.version = void 0;
          var _util = __w_pdfjs_require__(1), _annotation_storage = __w_pdfjs_require__(5), _display_utils = __w_pdfjs_require__(8), _font_loader = __w_pdfjs_require__(11), _canvas = __w_pdfjs_require__(12), _worker_options = __w_pdfjs_require__(15), _is_node = __w_pdfjs_require__(3), _message_handler = __w_pdfjs_require__(16), _metadata = __w_pdfjs_require__(17), _optional_content_config = __w_pdfjs_require__(18), _transport_stream = __w_pdfjs_require__(19), _xfa_text = __w_pdfjs_require__(20);
          const DEFAULT_RANGE_CHUNK_SIZE = 65536, RENDERING_CANCELLED_TIMEOUT = 100;
          let DefaultCanvasFactory = _display_utils.DOMCanvasFactory;
          exports.DefaultCanvasFactory = DefaultCanvasFactory;
          let DefaultCMapReaderFactory = _display_utils.DOMCMapReaderFactory;
          exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;
          let DefaultStandardFontDataFactory = _display_utils.DOMStandardFontDataFactory;
          if (exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory, _is_node.isNodeJS) {
            const {
              NodeCanvasFactory: y,
              NodeCMapReaderFactory: c,
              NodeStandardFontDataFactory: d
            } = __w_pdfjs_require__(21);
            exports.DefaultCanvasFactory = DefaultCanvasFactory = y, exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory = c, exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory = d;
          }
          let createPDFNetworkStream;
          function setPDFNetworkStreamFactory(y) {
            createPDFNetworkStream = y;
          }
          function getDocument(y) {
            const c = new PDFDocumentLoadingTask();
            let d;
            if (typeof y == "string" || y instanceof URL)
              d = {
                url: y
              };
            else if ((0, _util.isArrayBuffer)(y))
              d = {
                data: y
              };
            else if (y instanceof PDFDataRangeTransport)
              d = {
                range: y
              };
            else {
              if (typeof y != "object")
                throw new Error("Invalid parameter in getDocument, need either string, URL, TypedArray, or parameter object.");
              if (!y.url && !y.data && !y.range)
                throw new Error("Invalid parameter object: need either .data, .range or .url");
              d = y;
            }
            const p = /* @__PURE__ */ Object.create(null);
            let m = null, g = null;
            for (const i in d) {
              const l = d[i];
              switch (i) {
                case "url":
                  if (typeof window < "u")
                    try {
                      p[i] = new URL(l, window.location).href;
                      continue;
                    } catch (u) {
                      (0, _util.warn)(`Cannot create valid URL: "${u}".`);
                    }
                  else if (typeof l == "string" || l instanceof URL) {
                    p[i] = l.toString();
                    continue;
                  }
                  throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
                case "range":
                  m = l;
                  continue;
                case "worker":
                  g = l;
                  continue;
                case "data":
                  if (_is_node.isNodeJS && typeof Buffer < "u" && l instanceof Buffer)
                    p[i] = new Uint8Array(l);
                  else {
                    if (l instanceof Uint8Array)
                      break;
                    if (typeof l == "string")
                      p[i] = (0, _util.stringToBytes)(l);
                    else if (typeof l == "object" && l !== null && !isNaN(l.length))
                      p[i] = new Uint8Array(l);
                    else if ((0, _util.isArrayBuffer)(l))
                      p[i] = new Uint8Array(l);
                    else
                      throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
                  }
                  continue;
              }
              p[i] = l;
            }
            if (p.CMapReaderFactory = p.CMapReaderFactory || DefaultCMapReaderFactory, p.StandardFontDataFactory = p.StandardFontDataFactory || DefaultStandardFontDataFactory, p.ignoreErrors = p.stopAtErrors !== !0, p.fontExtraProperties = p.fontExtraProperties === !0, p.pdfBug = p.pdfBug === !0, p.enableXfa = p.enableXfa === !0, (!Number.isInteger(p.rangeChunkSize) || p.rangeChunkSize < 1) && (p.rangeChunkSize = DEFAULT_RANGE_CHUNK_SIZE), (typeof p.docBaseUrl != "string" || (0, _display_utils.isDataScheme)(p.docBaseUrl)) && (p.docBaseUrl = null), (!Number.isInteger(p.maxImageSize) || p.maxImageSize < -1) && (p.maxImageSize = -1), typeof p.cMapUrl != "string" && (p.cMapUrl = null), typeof p.standardFontDataUrl != "string" && (p.standardFontDataUrl = null), typeof p.useWorkerFetch != "boolean" && (p.useWorkerFetch = p.CMapReaderFactory === _display_utils.DOMCMapReaderFactory && p.StandardFontDataFactory === _display_utils.DOMStandardFontDataFactory), typeof p.isEvalSupported != "boolean" && (p.isEvalSupported = !0), typeof p.disableFontFace != "boolean" && (p.disableFontFace = _is_node.isNodeJS), typeof p.useSystemFonts != "boolean" && (p.useSystemFonts = !_is_node.isNodeJS && !p.disableFontFace), (typeof p.ownerDocument != "object" || p.ownerDocument === null) && (p.ownerDocument = globalThis.document), typeof p.disableRange != "boolean" && (p.disableRange = !1), typeof p.disableStream != "boolean" && (p.disableStream = !1), typeof p.disableAutoFetch != "boolean" && (p.disableAutoFetch = !1), (0, _util.setVerbosityLevel)(p.verbosity), !g) {
              const i = {
                verbosity: p.verbosity,
                port: _worker_options.GlobalWorkerOptions.workerPort
              };
              g = i.port ? PDFWorker.fromPort(i) : new PDFWorker(i), c._worker = g;
            }
            const n = c.docId;
            return g.promise.then(function() {
              if (c.destroyed)
                throw new Error("Loading aborted");
              const i = _fetchDocument(g, p, m, n), l = new Promise(function(u) {
                let w;
                m ? w = new _transport_stream.PDFDataTransportStream({
                  length: p.length,
                  initialData: p.initialData,
                  progressiveDone: p.progressiveDone,
                  contentDispositionFilename: p.contentDispositionFilename,
                  disableRange: p.disableRange,
                  disableStream: p.disableStream
                }, m) : p.data || (w = createPDFNetworkStream({
                  url: p.url,
                  length: p.length,
                  httpHeaders: p.httpHeaders,
                  withCredentials: p.withCredentials,
                  rangeChunkSize: p.rangeChunkSize,
                  disableRange: p.disableRange,
                  disableStream: p.disableStream
                })), u(w);
              });
              return Promise.all([i, l]).then(function([u, w]) {
                if (c.destroyed)
                  throw new Error("Loading aborted");
                const _ = new _message_handler.MessageHandler(n, u, g.port), b = new WorkerTransport(_, c, w, p);
                c._transport = b, _.send("Ready", null);
              });
            }).catch(c._capability.reject), c;
          }
          async function _fetchDocument(y, c, d, p) {
            if (y.destroyed)
              throw new Error("Worker was destroyed");
            d && (c.length = d.length, c.initialData = d.initialData, c.progressiveDone = d.progressiveDone, c.contentDispositionFilename = d.contentDispositionFilename);
            const m = await y.messageHandler.sendWithPromise("GetDocRequest", {
              docId: p,
              apiVersion: "2.16.105",
              source: {
                data: c.data,
                url: c.url,
                password: c.password,
                disableAutoFetch: c.disableAutoFetch,
                rangeChunkSize: c.rangeChunkSize,
                length: c.length
              },
              maxImageSize: c.maxImageSize,
              disableFontFace: c.disableFontFace,
              docBaseUrl: c.docBaseUrl,
              ignoreErrors: c.ignoreErrors,
              isEvalSupported: c.isEvalSupported,
              fontExtraProperties: c.fontExtraProperties,
              enableXfa: c.enableXfa,
              useSystemFonts: c.useSystemFonts,
              cMapUrl: c.useWorkerFetch ? c.cMapUrl : null,
              standardFontDataUrl: c.useWorkerFetch ? c.standardFontDataUrl : null
            });
            if (c.data && (c.data = null), y.destroyed)
              throw new Error("Worker was destroyed");
            return m;
          }
          const ge = class {
            constructor() {
              this._capability = (0, _util.createPromiseCapability)(), this._transport = null, this._worker = null, this.docId = `d${ii(ge, be)._++}`, this.destroyed = !1, this.onPassword = null, this.onProgress = null, this.onUnsupportedFeature = null;
            }
            get promise() {
              return this._capability.promise;
            }
            async destroy() {
              var c;
              this.destroyed = !0, await ((c = this._transport) == null ? void 0 : c.destroy()), this._transport = null, this._worker && (this._worker.destroy(), this._worker = null);
            }
          };
          let PDFDocumentLoadingTask = ge;
          be = new WeakMap(), ot(PDFDocumentLoadingTask, be, 0), exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;
          class PDFDataRangeTransport {
            constructor(c, d, p = !1, m = null) {
              this.length = c, this.initialData = d, this.progressiveDone = p, this.contentDispositionFilename = m, this._rangeListeners = [], this._progressListeners = [], this._progressiveReadListeners = [], this._progressiveDoneListeners = [], this._readyCapability = (0, _util.createPromiseCapability)();
            }
            addRangeListener(c) {
              this._rangeListeners.push(c);
            }
            addProgressListener(c) {
              this._progressListeners.push(c);
            }
            addProgressiveReadListener(c) {
              this._progressiveReadListeners.push(c);
            }
            addProgressiveDoneListener(c) {
              this._progressiveDoneListeners.push(c);
            }
            onDataRange(c, d) {
              for (const p of this._rangeListeners)
                p(c, d);
            }
            onDataProgress(c, d) {
              this._readyCapability.promise.then(() => {
                for (const p of this._progressListeners)
                  p(c, d);
              });
            }
            onDataProgressiveRead(c) {
              this._readyCapability.promise.then(() => {
                for (const d of this._progressiveReadListeners)
                  d(c);
              });
            }
            onDataProgressiveDone() {
              this._readyCapability.promise.then(() => {
                for (const c of this._progressiveDoneListeners)
                  c();
              });
            }
            transportReady() {
              this._readyCapability.resolve();
            }
            requestDataRange(c, d) {
              (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
            }
            abort() {
            }
          }
          exports.PDFDataRangeTransport = PDFDataRangeTransport;
          class PDFDocumentProxy {
            constructor(c, d) {
              this._pdfInfo = c, this._transport = d, Object.defineProperty(this, "fingerprint", {
                get() {
                  return (0, _display_utils.deprecated)("`PDFDocumentProxy.fingerprint`, please use `PDFDocumentProxy.fingerprints` instead."), this.fingerprints[0];
                }
              }), Object.defineProperty(this, "getStats", {
                value: async () => ((0, _display_utils.deprecated)("`PDFDocumentProxy.getStats`, please use the `PDFDocumentProxy.stats`-getter instead."), this.stats || {
                  streamTypes: {},
                  fontTypes: {}
                })
              });
            }
            get annotationStorage() {
              return this._transport.annotationStorage;
            }
            get numPages() {
              return this._pdfInfo.numPages;
            }
            get fingerprints() {
              return this._pdfInfo.fingerprints;
            }
            get stats() {
              return this._transport.stats;
            }
            get isPureXfa() {
              return !!this._transport._htmlForXfa;
            }
            get allXfaHtml() {
              return this._transport._htmlForXfa;
            }
            getPage(c) {
              return this._transport.getPage(c);
            }
            getPageIndex(c) {
              return this._transport.getPageIndex(c);
            }
            getDestinations() {
              return this._transport.getDestinations();
            }
            getDestination(c) {
              return this._transport.getDestination(c);
            }
            getPageLabels() {
              return this._transport.getPageLabels();
            }
            getPageLayout() {
              return this._transport.getPageLayout();
            }
            getPageMode() {
              return this._transport.getPageMode();
            }
            getViewerPreferences() {
              return this._transport.getViewerPreferences();
            }
            getOpenAction() {
              return this._transport.getOpenAction();
            }
            getAttachments() {
              return this._transport.getAttachments();
            }
            getJavaScript() {
              return this._transport.getJavaScript();
            }
            getJSActions() {
              return this._transport.getDocJSActions();
            }
            getOutline() {
              return this._transport.getOutline();
            }
            getOptionalContentConfig() {
              return this._transport.getOptionalContentConfig();
            }
            getPermissions() {
              return this._transport.getPermissions();
            }
            getMetadata() {
              return this._transport.getMetadata();
            }
            getMarkInfo() {
              return this._transport.getMarkInfo();
            }
            getData() {
              return this._transport.getData();
            }
            getDownloadInfo() {
              return this._transport.downloadInfoCapability.promise;
            }
            cleanup(c = !1) {
              return this._transport.startCleanup(c || this.isPureXfa);
            }
            destroy() {
              return this.loadingTask.destroy();
            }
            get loadingParams() {
              return this._transport.loadingParams;
            }
            get loadingTask() {
              return this._transport.loadingTask;
            }
            saveDocument() {
              return this._transport.annotationStorage.size <= 0 && (0, _display_utils.deprecated)("saveDocument called while `annotationStorage` is empty, please use the getData-method instead."), this._transport.saveDocument();
            }
            getFieldObjects() {
              return this._transport.getFieldObjects();
            }
            hasJSActions() {
              return this._transport.hasJSActions();
            }
            getCalculationOrderIds() {
              return this._transport.getCalculationOrderIds();
            }
          }
          exports.PDFDocumentProxy = PDFDocumentProxy;
          class PDFPageProxy {
            constructor(c, d, p, m, g = !1) {
              this._pageIndex = c, this._pageInfo = d, this._ownerDocument = m, this._transport = p, this._stats = g ? new _display_utils.StatTimer() : null, this._pdfBug = g, this.commonObjs = p.commonObjs, this.objs = new PDFObjects(), this._bitmaps = /* @__PURE__ */ new Set(), this.cleanupAfterRender = !1, this.pendingCleanup = !1, this._intentStates = /* @__PURE__ */ new Map(), this._annotationPromises = /* @__PURE__ */ new Map(), this.destroyed = !1;
            }
            get pageNumber() {
              return this._pageIndex + 1;
            }
            get rotate() {
              return this._pageInfo.rotate;
            }
            get ref() {
              return this._pageInfo.ref;
            }
            get userUnit() {
              return this._pageInfo.userUnit;
            }
            get view() {
              return this._pageInfo.view;
            }
            getViewport({
              scale: c,
              rotation: d = this.rotate,
              offsetX: p = 0,
              offsetY: m = 0,
              dontFlip: g = !1
            } = {}) {
              return new _display_utils.PageViewport({
                viewBox: this.view,
                scale: c,
                rotation: d,
                offsetX: p,
                offsetY: m,
                dontFlip: g
              });
            }
            getAnnotations({
              intent: c = "display"
            } = {}) {
              const d = this._transport.getRenderingIntent(c);
              let p = this._annotationPromises.get(d.cacheKey);
              return p || (p = this._transport.getAnnotations(this._pageIndex, d.renderingIntent), this._annotationPromises.set(d.cacheKey, p), p = p.then((m) => {
                for (const g of m)
                  g.titleObj !== void 0 && Object.defineProperty(g, "title", {
                    get() {
                      return (0, _display_utils.deprecated)("`title`-property on annotation, please use `titleObj` instead."), g.titleObj.str;
                    }
                  }), g.contentsObj !== void 0 && Object.defineProperty(g, "contents", {
                    get() {
                      return (0, _display_utils.deprecated)("`contents`-property on annotation, please use `contentsObj` instead."), g.contentsObj.str;
                    }
                  });
                return m;
              })), p;
            }
            getJSActions() {
              return this._jsActionsPromise || (this._jsActionsPromise = this._transport.getPageJSActions(this._pageIndex));
            }
            async getXfa() {
              var c;
              return ((c = this._transport._htmlForXfa) == null ? void 0 : c.children[this._pageIndex]) || null;
            }
            render({
              canvasContext: c,
              viewport: d,
              intent: p = "display",
              annotationMode: m = _util.AnnotationMode.ENABLE,
              transform: g = null,
              imageLayer: n = null,
              canvasFactory: i = null,
              background: l = null,
              optionalContentConfigPromise: u = null,
              annotationCanvasMap: w = null,
              pageColors: _ = null,
              printAnnotationStorage: b = null
            }) {
              var x, f;
              ((x = arguments[0]) == null ? void 0 : x.renderInteractiveForms) !== void 0 && ((0, _display_utils.deprecated)("render no longer accepts the `renderInteractiveForms`-option, please use the `annotationMode`-option instead."), arguments[0].renderInteractiveForms === !0 && m === _util.AnnotationMode.ENABLE && (m = _util.AnnotationMode.ENABLE_FORMS)), ((f = arguments[0]) == null ? void 0 : f.includeAnnotationStorage) !== void 0 && ((0, _display_utils.deprecated)("render no longer accepts the `includeAnnotationStorage`-option, please use the `annotationMode`-option instead."), arguments[0].includeAnnotationStorage === !0 && m === _util.AnnotationMode.ENABLE && (m = _util.AnnotationMode.ENABLE_STORAGE)), this._stats && this._stats.time("Overall");
              const A = this._transport.getRenderingIntent(p, m, b);
              this.pendingCleanup = !1, u || (u = this._transport.getOptionalContentConfig());
              let Y = this._intentStates.get(A.cacheKey);
              Y || (Y = /* @__PURE__ */ Object.create(null), this._intentStates.set(A.cacheKey, Y)), Y.streamReaderCancelTimeout && (clearTimeout(Y.streamReaderCancelTimeout), Y.streamReaderCancelTimeout = null);
              const j = i || new DefaultCanvasFactory({
                ownerDocument: this._ownerDocument
              }), X = !!(A.renderingIntent & _util.RenderingIntentFlag.PRINT);
              Y.displayReadyCapability || (Y.displayReadyCapability = (0, _util.createPromiseCapability)(), Y.operatorList = {
                fnArray: [],
                argsArray: [],
                lastChunk: !1,
                separateAnnots: null
              }, this._stats && this._stats.time("Page Request"), this._pumpOperatorList(A));
              const B = (U) => {
                Y.renderTasks.delete(R), (this.cleanupAfterRender || X) && (this.pendingCleanup = !0), this._tryCleanup(), U ? (R.capability.reject(U), this._abortOperatorList({
                  intentState: Y,
                  reason: U instanceof Error ? U : new Error(U)
                })) : R.capability.resolve(), this._stats && (this._stats.timeEnd("Rendering"), this._stats.timeEnd("Overall"));
              }, R = new InternalRenderTask({
                callback: B,
                params: {
                  canvasContext: c,
                  viewport: d,
                  transform: g,
                  imageLayer: n,
                  background: l
                },
                objs: this.objs,
                commonObjs: this.commonObjs,
                annotationCanvasMap: w,
                operatorList: Y.operatorList,
                pageIndex: this._pageIndex,
                canvasFactory: j,
                useRequestAnimationFrame: !X,
                pdfBug: this._pdfBug,
                pageColors: _
              });
              (Y.renderTasks || (Y.renderTasks = /* @__PURE__ */ new Set())).add(R);
              const k = R.task;
              return Promise.all([Y.displayReadyCapability.promise, u]).then(([U, O]) => {
                if (this.pendingCleanup) {
                  B();
                  return;
                }
                this._stats && this._stats.time("Rendering"), R.initializeGraphics({
                  transparency: U,
                  optionalContentConfig: O
                }), R.operatorListChanged();
              }).catch(B), k;
            }
            getOperatorList({
              intent: c = "display",
              annotationMode: d = _util.AnnotationMode.ENABLE,
              printAnnotationStorage: p = null
            } = {}) {
              function m() {
                n.operatorList.lastChunk && (n.opListReadCapability.resolve(n.operatorList), n.renderTasks.delete(i));
              }
              const g = this._transport.getRenderingIntent(c, d, p, !0);
              let n = this._intentStates.get(g.cacheKey);
              n || (n = /* @__PURE__ */ Object.create(null), this._intentStates.set(g.cacheKey, n));
              let i;
              return n.opListReadCapability || (i = /* @__PURE__ */ Object.create(null), i.operatorListChanged = m, n.opListReadCapability = (0, _util.createPromiseCapability)(), (n.renderTasks || (n.renderTasks = /* @__PURE__ */ new Set())).add(i), n.operatorList = {
                fnArray: [],
                argsArray: [],
                lastChunk: !1,
                separateAnnots: null
              }, this._stats && this._stats.time("Page Request"), this._pumpOperatorList(g)), n.opListReadCapability.promise;
            }
            streamTextContent({
              disableCombineTextItems: c = !1,
              includeMarkedContent: d = !1
            } = {}) {
              return this._transport.messageHandler.sendWithStream("GetTextContent", {
                pageIndex: this._pageIndex,
                combineTextItems: c !== !0,
                includeMarkedContent: d === !0
              }, {
                highWaterMark: 100,
                size(m) {
                  return m.items.length;
                }
              });
            }
            getTextContent(c = {}) {
              if (this._transport._htmlForXfa)
                return this.getXfa().then((p) => _xfa_text.XfaText.textContent(p));
              const d = this.streamTextContent(c);
              return new Promise(function(p, m) {
                function g() {
                  n.read().then(function({
                    value: l,
                    done: u
                  }) {
                    if (u) {
                      p(i);
                      return;
                    }
                    Object.assign(i.styles, l.styles), i.items.push(...l.items), g();
                  }, m);
                }
                const n = d.getReader(), i = {
                  items: [],
                  styles: /* @__PURE__ */ Object.create(null)
                };
                g();
              });
            }
            getStructTree() {
              return this._structTreePromise || (this._structTreePromise = this._transport.getStructTree(this._pageIndex));
            }
            _destroy() {
              this.destroyed = !0;
              const c = [];
              for (const d of this._intentStates.values())
                if (this._abortOperatorList({
                  intentState: d,
                  reason: new Error("Page was destroyed."),
                  force: !0
                }), !d.opListReadCapability)
                  for (const p of d.renderTasks)
                    c.push(p.completed), p.cancel();
              this.objs.clear();
              for (const d of this._bitmaps)
                d.close();
              return this._bitmaps.clear(), this._annotationPromises.clear(), this._jsActionsPromise = null, this._structTreePromise = null, this.pendingCleanup = !1, Promise.all(c);
            }
            cleanup(c = !1) {
              return this.pendingCleanup = !0, this._tryCleanup(c);
            }
            _tryCleanup(c = !1) {
              if (!this.pendingCleanup)
                return !1;
              for (const {
                renderTasks: d,
                operatorList: p
              } of this._intentStates.values())
                if (d.size > 0 || !p.lastChunk)
                  return !1;
              this._intentStates.clear(), this.objs.clear(), this._annotationPromises.clear(), this._jsActionsPromise = null, this._structTreePromise = null, c && this._stats && (this._stats = new _display_utils.StatTimer());
              for (const d of this._bitmaps)
                d.close();
              return this._bitmaps.clear(), this.pendingCleanup = !1, !0;
            }
            _startRenderPage(c, d) {
              const p = this._intentStates.get(d);
              p && (this._stats && this._stats.timeEnd("Page Request"), p.displayReadyCapability && p.displayReadyCapability.resolve(c));
            }
            _renderPageChunk(c, d) {
              for (let p = 0, m = c.length; p < m; p++)
                d.operatorList.fnArray.push(c.fnArray[p]), d.operatorList.argsArray.push(c.argsArray[p]);
              d.operatorList.lastChunk = c.lastChunk, d.operatorList.separateAnnots = c.separateAnnots;
              for (const p of d.renderTasks)
                p.operatorListChanged();
              c.lastChunk && this._tryCleanup();
            }
            _pumpOperatorList({
              renderingIntent: c,
              cacheKey: d,
              annotationStorageMap: p
            }) {
              const g = this._transport.messageHandler.sendWithStream("GetOperatorList", {
                pageIndex: this._pageIndex,
                intent: c,
                cacheKey: d,
                annotationStorage: p
              }).getReader(), n = this._intentStates.get(d);
              n.streamReader = g;
              const i = () => {
                g.read().then(({
                  value: l,
                  done: u
                }) => {
                  if (u) {
                    n.streamReader = null;
                    return;
                  }
                  this._transport.destroyed || (this._renderPageChunk(l, n), i());
                }, (l) => {
                  if (n.streamReader = null, !this._transport.destroyed) {
                    if (n.operatorList) {
                      n.operatorList.lastChunk = !0;
                      for (const u of n.renderTasks)
                        u.operatorListChanged();
                      this._tryCleanup();
                    }
                    if (n.displayReadyCapability)
                      n.displayReadyCapability.reject(l);
                    else if (n.opListReadCapability)
                      n.opListReadCapability.reject(l);
                    else
                      throw l;
                  }
                });
              };
              i();
            }
            _abortOperatorList({
              intentState: c,
              reason: d,
              force: p = !1
            }) {
              if (c.streamReader) {
                if (!p) {
                  if (c.renderTasks.size > 0)
                    return;
                  if (d instanceof _display_utils.RenderingCancelledException) {
                    c.streamReaderCancelTimeout = setTimeout(() => {
                      this._abortOperatorList({
                        intentState: c,
                        reason: d,
                        force: !0
                      }), c.streamReaderCancelTimeout = null;
                    }, RENDERING_CANCELLED_TIMEOUT);
                    return;
                  }
                }
                if (c.streamReader.cancel(new _util.AbortException(d.message)).catch(() => {
                }), c.streamReader = null, !this._transport.destroyed) {
                  for (const [m, g] of this._intentStates)
                    if (g === c) {
                      this._intentStates.delete(m);
                      break;
                    }
                  this.cleanup();
                }
              }
            }
            get stats() {
              return this._stats;
            }
          }
          exports.PDFPageProxy = PDFPageProxy;
          class LoopbackPort {
            constructor() {
              this._listeners = [], this._deferred = Promise.resolve();
            }
            postMessage(c, d) {
              const p = {
                data: structuredClone(c, d)
              };
              this._deferred.then(() => {
                for (const m of this._listeners)
                  m.call(this, p);
              });
            }
            addEventListener(c, d) {
              this._listeners.push(d);
            }
            removeEventListener(c, d) {
              const p = this._listeners.indexOf(d);
              this._listeners.splice(p, 1);
            }
            terminate() {
              this._listeners.length = 0;
            }
          }
          exports.LoopbackPort = LoopbackPort;
          const PDFWorkerUtil = {
            isWorkerDisabled: !1,
            fallbackWorkerSrc: null,
            fakeWorkerId: 0
          };
          exports.PDFWorkerUtil = PDFWorkerUtil;
          {
            if (_is_node.isNodeJS && typeof commonjsRequire == "function")
              PDFWorkerUtil.isWorkerDisabled = !0, PDFWorkerUtil.fallbackWorkerSrc = "./pdf.worker.js";
            else if (typeof document == "object") {
              const y = (le = document == null ? void 0 : document.currentScript) == null ? void 0 : le.src;
              y && (PDFWorkerUtil.fallbackWorkerSrc = y.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2"));
            }
            PDFWorkerUtil.isSameOrigin = function(y, c) {
              let d;
              try {
                if (d = new URL(y), !d.origin || d.origin === "null")
                  return !1;
              } catch {
                return !1;
              }
              const p = new URL(c, d);
              return d.origin === p.origin;
            }, PDFWorkerUtil.createCDNWrapper = function(y) {
              const c = `importScripts("${y}");`;
              return URL.createObjectURL(new Blob([c]));
            };
          }
          const _PDFWorker = class {
            constructor({
              name: y = null,
              port: c = null,
              verbosity: d = (0, _util.getVerbosityLevel)()
            } = {}) {
              if (c && Oe(_PDFWorker, ce).has(c))
                throw new Error("Cannot use more than one PDFWorker per port.");
              if (this.name = y, this.destroyed = !1, this.verbosity = d, this._readyCapability = (0, _util.createPromiseCapability)(), this._port = null, this._webWorker = null, this._messageHandler = null, c) {
                Oe(_PDFWorker, ce).set(c, this), this._initializeFromPort(c);
                return;
              }
              this._initialize();
            }
            get promise() {
              return this._readyCapability.promise;
            }
            get port() {
              return this._port;
            }
            get messageHandler() {
              return this._messageHandler;
            }
            _initializeFromPort(y) {
              this._port = y, this._messageHandler = new _message_handler.MessageHandler("main", "worker", y), this._messageHandler.on("ready", function() {
              }), this._readyCapability.resolve();
            }
            _initialize() {
              if (!PDFWorkerUtil.isWorkerDisabled && !_PDFWorker._mainThreadWorkerMessageHandler) {
                let {
                  workerSrc: y
                } = _PDFWorker;
                try {
                  PDFWorkerUtil.isSameOrigin(window.location.href, y) || (y = PDFWorkerUtil.createCDNWrapper(new URL(y, window.location).href));
                  const c = new Worker(y), d = new _message_handler.MessageHandler("main", "worker", c), p = () => {
                    c.removeEventListener("error", m), d.destroy(), c.terminate(), this.destroyed ? this._readyCapability.reject(new Error("Worker was destroyed")) : this._setupFakeWorker();
                  }, m = () => {
                    this._webWorker || p();
                  };
                  c.addEventListener("error", m), d.on("test", (n) => {
                    if (c.removeEventListener("error", m), this.destroyed) {
                      p();
                      return;
                    }
                    n ? (this._messageHandler = d, this._port = c, this._webWorker = c, this._readyCapability.resolve(), d.send("configure", {
                      verbosity: this.verbosity
                    })) : (this._setupFakeWorker(), d.destroy(), c.terminate());
                  }), d.on("ready", (n) => {
                    if (c.removeEventListener("error", m), this.destroyed) {
                      p();
                      return;
                    }
                    try {
                      g();
                    } catch {
                      this._setupFakeWorker();
                    }
                  });
                  const g = () => {
                    const n = new Uint8Array();
                    d.send("test", n, [n.buffer]);
                  };
                  g();
                  return;
                } catch {
                  (0, _util.info)("The worker has been disabled.");
                }
              }
              this._setupFakeWorker();
            }
            _setupFakeWorker() {
              PDFWorkerUtil.isWorkerDisabled || ((0, _util.warn)("Setting up fake worker."), PDFWorkerUtil.isWorkerDisabled = !0), _PDFWorker._setupFakeWorkerGlobal.then((y) => {
                if (this.destroyed) {
                  this._readyCapability.reject(new Error("Worker was destroyed"));
                  return;
                }
                const c = new LoopbackPort();
                this._port = c;
                const d = `fake${PDFWorkerUtil.fakeWorkerId++}`, p = new _message_handler.MessageHandler(d + "_worker", d, c);
                y.setup(p, c);
                const m = new _message_handler.MessageHandler(d, d + "_worker", c);
                this._messageHandler = m, this._readyCapability.resolve(), m.send("configure", {
                  verbosity: this.verbosity
                });
              }).catch((y) => {
                this._readyCapability.reject(new Error(`Setting up fake worker failed: "${y.message}".`));
              });
            }
            destroy() {
              this.destroyed = !0, this._webWorker && (this._webWorker.terminate(), this._webWorker = null), Oe(_PDFWorker, ce).delete(this._port), this._port = null, this._messageHandler && (this._messageHandler.destroy(), this._messageHandler = null);
            }
            static fromPort(y) {
              if (!(y != null && y.port))
                throw new Error("PDFWorker.fromPort - invalid method signature.");
              return Oe(this, ce).has(y.port) ? Oe(this, ce).get(y.port) : new _PDFWorker(y);
            }
            static get workerSrc() {
              if (_worker_options.GlobalWorkerOptions.workerSrc)
                return _worker_options.GlobalWorkerOptions.workerSrc;
              if (PDFWorkerUtil.fallbackWorkerSrc !== null)
                return _is_node.isNodeJS || (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.'), PDFWorkerUtil.fallbackWorkerSrc;
              throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
            }
            static get _mainThreadWorkerMessageHandler() {
              var y;
              try {
                return ((y = globalThis.pdfjsWorker) == null ? void 0 : y.WorkerMessageHandler) || null;
              } catch {
                return null;
              }
            }
            static get _setupFakeWorkerGlobal() {
              const loader = async () => {
                const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler;
                if (mainWorkerMessageHandler)
                  return mainWorkerMessageHandler;
                if (_is_node.isNodeJS && typeof commonjsRequire == "function") {
                  const worker = eval("require")(this.workerSrc);
                  return worker.WorkerMessageHandler;
                }
                return await (0, _display_utils.loadScript)(this.workerSrc), window.pdfjsWorker.WorkerMessageHandler;
              };
              return (0, _util.shadow)(this, "_setupFakeWorkerGlobal", loader());
            }
          };
          let PDFWorker = _PDFWorker;
          ce = new WeakMap(), ot(PDFWorker, ce, /* @__PURE__ */ new WeakMap()), exports.PDFWorker = PDFWorker, PDFWorker.getWorkerSrc = function() {
            return (0, _display_utils.deprecated)("`PDFWorker.getWorkerSrc()`, please use `PDFWorker.workerSrc` instead."), this.workerSrc;
          };
          class WorkerTransport {
            constructor(c, d, p, m) {
              ot(this, re, null);
              ot(this, ae, /* @__PURE__ */ new Map());
              ot(this, Z, /* @__PURE__ */ new Map());
              ot(this, o, null);
              this.messageHandler = c, this.loadingTask = d, this.commonObjs = new PDFObjects(), this.fontLoader = new _font_loader.FontLoader({
                docId: d.docId,
                onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
                ownerDocument: m.ownerDocument,
                styleElement: m.styleElement
              }), this._params = m, m.useWorkerFetch || (this.CMapReaderFactory = new m.CMapReaderFactory({
                baseUrl: m.cMapUrl,
                isCompressed: m.cMapPacked
              }), this.StandardFontDataFactory = new m.StandardFontDataFactory({
                baseUrl: m.standardFontDataUrl
              })), this.destroyed = !1, this.destroyCapability = null, this._passwordCapability = null, this._networkStream = p, this._fullReader = null, this._lastProgress = null, this.downloadInfoCapability = (0, _util.createPromiseCapability)(), this.setupMessageHandler();
            }
            get annotationStorage() {
              return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());
            }
            get stats() {
              return Oe(this, re);
            }
            getRenderingIntent(c, d = _util.AnnotationMode.ENABLE, p = null, m = !1) {
              let g = _util.RenderingIntentFlag.DISPLAY, n = null;
              switch (c) {
                case "any":
                  g = _util.RenderingIntentFlag.ANY;
                  break;
                case "display":
                  break;
                case "print":
                  g = _util.RenderingIntentFlag.PRINT;
                  break;
                default:
                  (0, _util.warn)(`getRenderingIntent - invalid intent: ${c}`);
              }
              switch (d) {
                case _util.AnnotationMode.DISABLE:
                  g += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;
                  break;
                case _util.AnnotationMode.ENABLE:
                  break;
                case _util.AnnotationMode.ENABLE_FORMS:
                  g += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;
                  break;
                case _util.AnnotationMode.ENABLE_STORAGE:
                  g += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE, n = (g & _util.RenderingIntentFlag.PRINT && p instanceof _annotation_storage.PrintAnnotationStorage ? p : this.annotationStorage).serializable;
                  break;
                default:
                  (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${d}`);
              }
              return m && (g += _util.RenderingIntentFlag.OPLIST), {
                renderingIntent: g,
                cacheKey: `${g}_${_annotation_storage.AnnotationStorage.getHash(n)}`,
                annotationStorageMap: n
              };
            }
            destroy() {
              if (this.destroyCapability)
                return this.destroyCapability.promise;
              this.destroyed = !0, this.destroyCapability = (0, _util.createPromiseCapability)(), this._passwordCapability && this._passwordCapability.reject(new Error("Worker was destroyed during onPassword callback"));
              const c = [];
              for (const p of Oe(this, ae).values())
                c.push(p._destroy());
              Oe(this, ae).clear(), Oe(this, Z).clear(), this.hasOwnProperty("annotationStorage") && this.annotationStorage.resetModified();
              const d = this.messageHandler.sendWithPromise("Terminate", null);
              return c.push(d), Promise.all(c).then(() => {
                this.commonObjs.clear(), this.fontLoader.clear(), vt(this, o, null), this._getFieldObjectsPromise = null, this._hasJSActionsPromise = null, this._networkStream && this._networkStream.cancelAllRequests(new _util.AbortException("Worker was terminated.")), this.messageHandler && (this.messageHandler.destroy(), this.messageHandler = null), this.destroyCapability.resolve();
              }, this.destroyCapability.reject), this.destroyCapability.promise;
            }
            setupMessageHandler() {
              const {
                messageHandler: c,
                loadingTask: d
              } = this;
              c.on("GetReader", (p, m) => {
                (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available."), this._fullReader = this._networkStream.getFullReader(), this._fullReader.onProgress = (g) => {
                  this._lastProgress = {
                    loaded: g.loaded,
                    total: g.total
                  };
                }, m.onPull = () => {
                  this._fullReader.read().then(function({
                    value: g,
                    done: n
                  }) {
                    if (n) {
                      m.close();
                      return;
                    }
                    (0, _util.assert)((0, _util.isArrayBuffer)(g), "GetReader - expected an ArrayBuffer."), m.enqueue(new Uint8Array(g), 1, [g]);
                  }).catch((g) => {
                    m.error(g);
                  });
                }, m.onCancel = (g) => {
                  this._fullReader.cancel(g), m.ready.catch((n) => {
                    if (!this.destroyed)
                      throw n;
                  });
                };
              }), c.on("ReaderHeadersReady", (p) => {
                const m = (0, _util.createPromiseCapability)(), g = this._fullReader;
                return g.headersReady.then(() => {
                  var n;
                  (!g.isStreamingSupported || !g.isRangeSupported) && (this._lastProgress && ((n = d.onProgress) == null || n.call(d, this._lastProgress)), g.onProgress = (i) => {
                    var l;
                    (l = d.onProgress) == null || l.call(d, {
                      loaded: i.loaded,
                      total: i.total
                    });
                  }), m.resolve({
                    isStreamingSupported: g.isStreamingSupported,
                    isRangeSupported: g.isRangeSupported,
                    contentLength: g.contentLength
                  });
                }, m.reject), m.promise;
              }), c.on("GetRangeReader", (p, m) => {
                (0, _util.assert)(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
                const g = this._networkStream.getRangeReader(p.begin, p.end);
                if (!g) {
                  m.close();
                  return;
                }
                m.onPull = () => {
                  g.read().then(function({
                    value: n,
                    done: i
                  }) {
                    if (i) {
                      m.close();
                      return;
                    }
                    (0, _util.assert)((0, _util.isArrayBuffer)(n), "GetRangeReader - expected an ArrayBuffer."), m.enqueue(new Uint8Array(n), 1, [n]);
                  }).catch((n) => {
                    m.error(n);
                  });
                }, m.onCancel = (n) => {
                  g.cancel(n), m.ready.catch((i) => {
                    if (!this.destroyed)
                      throw i;
                  });
                };
              }), c.on("GetDoc", ({
                pdfInfo: p
              }) => {
                this._numPages = p.numPages, this._htmlForXfa = p.htmlForXfa, delete p.htmlForXfa, d._capability.resolve(new PDFDocumentProxy(p, this));
              }), c.on("DocException", function(p) {
                let m;
                switch (p.name) {
                  case "PasswordException":
                    m = new _util.PasswordException(p.message, p.code);
                    break;
                  case "InvalidPDFException":
                    m = new _util.InvalidPDFException(p.message);
                    break;
                  case "MissingPDFException":
                    m = new _util.MissingPDFException(p.message);
                    break;
                  case "UnexpectedResponseException":
                    m = new _util.UnexpectedResponseException(p.message, p.status);
                    break;
                  case "UnknownErrorException":
                    m = new _util.UnknownErrorException(p.message, p.details);
                    break;
                  default:
                    (0, _util.unreachable)("DocException - expected a valid Error.");
                }
                d._capability.reject(m);
              }), c.on("PasswordRequest", (p) => {
                if (this._passwordCapability = (0, _util.createPromiseCapability)(), d.onPassword) {
                  const m = (g) => {
                    g instanceof Error ? this._passwordCapability.reject(g) : this._passwordCapability.resolve({
                      password: g
                    });
                  };
                  try {
                    d.onPassword(m, p.code);
                  } catch (g) {
                    this._passwordCapability.reject(g);
                  }
                } else
                  this._passwordCapability.reject(new _util.PasswordException(p.message, p.code));
                return this._passwordCapability.promise;
              }), c.on("DataLoaded", (p) => {
                var m;
                (m = d.onProgress) == null || m.call(d, {
                  loaded: p.length,
                  total: p.length
                }), this.downloadInfoCapability.resolve(p);
              }), c.on("StartRenderPage", (p) => {
                if (this.destroyed)
                  return;
                Oe(this, ae).get(p.pageIndex)._startRenderPage(p.transparency, p.cacheKey);
              }), c.on("commonobj", ([p, m, g]) => {
                var n;
                if (!this.destroyed && !this.commonObjs.has(p))
                  switch (m) {
                    case "Font":
                      const i = this._params;
                      if ("error" in g) {
                        const w = g.error;
                        (0, _util.warn)(`Error during font loading: ${w}`), this.commonObjs.resolve(p, w);
                        break;
                      }
                      let l = null;
                      i.pdfBug && ((n = globalThis.FontInspector) != null && n.enabled) && (l = {
                        registerFont(w, _) {
                          globalThis.FontInspector.fontAdded(w, _);
                        }
                      });
                      const u = new _font_loader.FontFaceObject(g, {
                        isEvalSupported: i.isEvalSupported,
                        disableFontFace: i.disableFontFace,
                        ignoreErrors: i.ignoreErrors,
                        onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
                        fontRegistry: l
                      });
                      this.fontLoader.bind(u).catch((w) => c.sendWithPromise("FontFallback", {
                        id: p
                      })).finally(() => {
                        !i.fontExtraProperties && u.data && (u.data = null), this.commonObjs.resolve(p, u);
                      });
                      break;
                    case "FontPath":
                    case "Image":
                      this.commonObjs.resolve(p, g);
                      break;
                    default:
                      throw new Error(`Got unknown common object type ${m}`);
                  }
              }), c.on("obj", ([p, m, g, n]) => {
                var l;
                if (this.destroyed)
                  return;
                const i = Oe(this, ae).get(m);
                if (!i.objs.has(p))
                  switch (g) {
                    case "Image":
                      i.objs.resolve(p, n);
                      const u = 8e6;
                      if (n) {
                        let w;
                        if (n.bitmap) {
                          const {
                            bitmap: _,
                            width: b,
                            height: A
                          } = n;
                          w = b * A * 4, i._bitmaps.add(_);
                        } else
                          w = ((l = n.data) == null ? void 0 : l.length) || 0;
                        w > u && (i.cleanupAfterRender = !0);
                      }
                      break;
                    case "Pattern":
                      i.objs.resolve(p, n);
                      break;
                    default:
                      throw new Error(`Got unknown object type ${g}`);
                  }
              }), c.on("DocProgress", (p) => {
                var m;
                this.destroyed || (m = d.onProgress) == null || m.call(d, {
                  loaded: p.loaded,
                  total: p.total
                });
              }), c.on("DocStats", (p) => {
                this.destroyed || vt(this, re, Object.freeze({
                  streamTypes: Object.freeze(p.streamTypes),
                  fontTypes: Object.freeze(p.fontTypes)
                }));
              }), c.on("UnsupportedFeature", this._onUnsupportedFeature.bind(this)), c.on("FetchBuiltInCMap", (p) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.CMapReaderFactory ? this.CMapReaderFactory.fetch(p) : Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."))), c.on("FetchStandardFontData", (p) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.StandardFontDataFactory ? this.StandardFontDataFactory.fetch(p) : Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.")));
            }
            _onUnsupportedFeature({
              featureId: c
            }) {
              var d, p;
              this.destroyed || (p = (d = this.loadingTask).onUnsupportedFeature) == null || p.call(d, c);
            }
            getData() {
              return this.messageHandler.sendWithPromise("GetData", null);
            }
            getPage(c) {
              if (!Number.isInteger(c) || c <= 0 || c > this._numPages)
                return Promise.reject(new Error("Invalid page request."));
              const d = c - 1, p = Oe(this, Z).get(d);
              if (p)
                return p;
              const m = this.messageHandler.sendWithPromise("GetPage", {
                pageIndex: d
              }).then((g) => {
                if (this.destroyed)
                  throw new Error("Transport destroyed");
                const n = new PDFPageProxy(d, g, this, this._params.ownerDocument, this._params.pdfBug);
                return Oe(this, ae).set(d, n), n;
              });
              return Oe(this, Z).set(d, m), m;
            }
            getPageIndex(c) {
              return typeof c != "object" || c === null || !Number.isInteger(c.num) || c.num < 0 || !Number.isInteger(c.gen) || c.gen < 0 ? Promise.reject(new Error("Invalid pageIndex request.")) : this.messageHandler.sendWithPromise("GetPageIndex", {
                num: c.num,
                gen: c.gen
              });
            }
            getAnnotations(c, d) {
              return this.messageHandler.sendWithPromise("GetAnnotations", {
                pageIndex: c,
                intent: d
              });
            }
            saveDocument() {
              var c;
              return this.messageHandler.sendWithPromise("SaveDocument", {
                isPureXfa: !!this._htmlForXfa,
                numPages: this._numPages,
                annotationStorage: this.annotationStorage.serializable,
                filename: ((c = this._fullReader) == null ? void 0 : c.filename) ?? null
              }).finally(() => {
                this.annotationStorage.resetModified();
              });
            }
            getFieldObjects() {
              return this._getFieldObjectsPromise || (this._getFieldObjectsPromise = this.messageHandler.sendWithPromise("GetFieldObjects", null));
            }
            hasJSActions() {
              return this._hasJSActionsPromise || (this._hasJSActionsPromise = this.messageHandler.sendWithPromise("HasJSActions", null));
            }
            getCalculationOrderIds() {
              return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
            }
            getDestinations() {
              return this.messageHandler.sendWithPromise("GetDestinations", null);
            }
            getDestination(c) {
              return typeof c != "string" ? Promise.reject(new Error("Invalid destination request.")) : this.messageHandler.sendWithPromise("GetDestination", {
                id: c
              });
            }
            getPageLabels() {
              return this.messageHandler.sendWithPromise("GetPageLabels", null);
            }
            getPageLayout() {
              return this.messageHandler.sendWithPromise("GetPageLayout", null);
            }
            getPageMode() {
              return this.messageHandler.sendWithPromise("GetPageMode", null);
            }
            getViewerPreferences() {
              return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
            }
            getOpenAction() {
              return this.messageHandler.sendWithPromise("GetOpenAction", null);
            }
            getAttachments() {
              return this.messageHandler.sendWithPromise("GetAttachments", null);
            }
            getJavaScript() {
              return this.messageHandler.sendWithPromise("GetJavaScript", null);
            }
            getDocJSActions() {
              return this.messageHandler.sendWithPromise("GetDocJSActions", null);
            }
            getPageJSActions(c) {
              return this.messageHandler.sendWithPromise("GetPageJSActions", {
                pageIndex: c
              });
            }
            getStructTree(c) {
              return this.messageHandler.sendWithPromise("GetStructTree", {
                pageIndex: c
              });
            }
            getOutline() {
              return this.messageHandler.sendWithPromise("GetOutline", null);
            }
            getOptionalContentConfig() {
              return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then((c) => new _optional_content_config.OptionalContentConfig(c));
            }
            getPermissions() {
              return this.messageHandler.sendWithPromise("GetPermissions", null);
            }
            getMetadata() {
              return Oe(this, o) || vt(this, o, this.messageHandler.sendWithPromise("GetMetadata", null).then((c) => {
                var d, p;
                return {
                  info: c[0],
                  metadata: c[1] ? new _metadata.Metadata(c[1]) : null,
                  contentDispositionFilename: ((d = this._fullReader) == null ? void 0 : d.filename) ?? null,
                  contentLength: ((p = this._fullReader) == null ? void 0 : p.contentLength) ?? null
                };
              }));
            }
            getMarkInfo() {
              return this.messageHandler.sendWithPromise("GetMarkInfo", null);
            }
            async startCleanup(c = !1) {
              if (await this.messageHandler.sendWithPromise("Cleanup", null), !this.destroyed) {
                for (const d of Oe(this, ae).values())
                  if (!d.cleanup())
                    throw new Error(`startCleanup: Page ${d.pageNumber} is currently rendering.`);
                this.commonObjs.clear(), c || this.fontLoader.clear(), vt(this, o, null), this._getFieldObjectsPromise = null, this._hasJSActionsPromise = null;
              }
            }
            get loadingParams() {
              const c = this._params;
              return (0, _util.shadow)(this, "loadingParams", {
                disableAutoFetch: c.disableAutoFetch,
                enableXfa: c.enableXfa
              });
            }
          }
          re = new WeakMap(), ae = new WeakMap(), Z = new WeakMap(), o = new WeakMap();
          class PDFObjects {
            constructor() {
              ot(this, t);
              ot(this, C, /* @__PURE__ */ Object.create(null));
            }
            get(c, d = null) {
              if (d) {
                const m = dt(this, t, ri).call(this, c);
                return m.capability.promise.then(() => d(m.data)), null;
              }
              const p = Oe(this, C)[c];
              if (!(p != null && p.capability.settled))
                throw new Error(`Requesting object that isn't resolved yet ${c}.`);
              return p.data;
            }
            has(c) {
              const d = Oe(this, C)[c];
              return (d == null ? void 0 : d.capability.settled) || !1;
            }
            resolve(c, d = null) {
              const p = dt(this, t, ri).call(this, c);
              p.data = d, p.capability.resolve();
            }
            clear() {
              vt(this, C, /* @__PURE__ */ Object.create(null));
            }
          }
          C = new WeakMap(), t = new WeakSet(), ri = function(c) {
            const d = Oe(this, C)[c];
            return d || (Oe(this, C)[c] = {
              capability: (0, _util.createPromiseCapability)(),
              data: null
            });
          };
          class RenderTask {
            constructor(c) {
              ot(this, v, null);
              vt(this, v, c), this.onContinue = null;
            }
            get promise() {
              return Oe(this, v).capability.promise;
            }
            cancel() {
              Oe(this, v).cancel();
            }
            get separateAnnots() {
              const {
                separateAnnots: c
              } = Oe(this, v).operatorList;
              if (!c)
                return !1;
              const {
                annotationCanvasMap: d
              } = Oe(this, v);
              return c.form || c.canvas && (d == null ? void 0 : d.size) > 0;
            }
          }
          v = new WeakMap(), exports.RenderTask = RenderTask;
          const e = class {
            constructor({
              callback: c,
              params: d,
              objs: p,
              commonObjs: m,
              annotationCanvasMap: g,
              operatorList: n,
              pageIndex: i,
              canvasFactory: l,
              useRequestAnimationFrame: u = !1,
              pdfBug: w = !1,
              pageColors: _ = null
            }) {
              this.callback = c, this.params = d, this.objs = p, this.commonObjs = m, this.annotationCanvasMap = g, this.operatorListIdx = null, this.operatorList = n, this._pageIndex = i, this.canvasFactory = l, this._pdfBug = w, this.pageColors = _, this.running = !1, this.graphicsReadyCallback = null, this.graphicsReady = !1, this._useRequestAnimationFrame = u === !0 && typeof window < "u", this.cancelled = !1, this.capability = (0, _util.createPromiseCapability)(), this.task = new RenderTask(this), this._cancelBound = this.cancel.bind(this), this._continueBound = this._continue.bind(this), this._scheduleNextBound = this._scheduleNext.bind(this), this._nextBound = this._next.bind(this), this._canvas = d.canvasContext.canvas;
            }
            get completed() {
              return this.capability.promise.catch(function() {
              });
            }
            initializeGraphics({
              transparency: c = !1,
              optionalContentConfig: d
            }) {
              var l;
              if (this.cancelled)
                return;
              if (this._canvas) {
                if (Oe(e, h).has(this._canvas))
                  throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
                Oe(e, h).add(this._canvas);
              }
              this._pdfBug && ((l = globalThis.StepperManager) != null && l.enabled) && (this.stepper = globalThis.StepperManager.create(this._pageIndex), this.stepper.init(this.operatorList), this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint());
              const {
                canvasContext: p,
                viewport: m,
                transform: g,
                imageLayer: n,
                background: i
              } = this.params;
              this.gfx = new _canvas.CanvasGraphics(p, this.commonObjs, this.objs, this.canvasFactory, n, d, this.annotationCanvasMap, this.pageColors), this.gfx.beginDrawing({
                transform: g,
                viewport: m,
                transparency: c,
                background: i
              }), this.operatorListIdx = 0, this.graphicsReady = !0, this.graphicsReadyCallback && this.graphicsReadyCallback();
            }
            cancel(c = null) {
              this.running = !1, this.cancelled = !0, this.gfx && this.gfx.endDrawing(), this._canvas && Oe(e, h).delete(this._canvas), this.callback(c || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, "canvas"));
            }
            operatorListChanged() {
              if (!this.graphicsReady) {
                this.graphicsReadyCallback || (this.graphicsReadyCallback = this._continueBound);
                return;
              }
              this.stepper && this.stepper.updateOperatorList(this.operatorList), !this.running && this._continue();
            }
            _continue() {
              this.running = !0, !this.cancelled && (this.task.onContinue ? this.task.onContinue(this._scheduleNextBound) : this._scheduleNext());
            }
            _scheduleNext() {
              this._useRequestAnimationFrame ? window.requestAnimationFrame(() => {
                this._nextBound().catch(this._cancelBound);
              }) : Promise.resolve().then(this._nextBound).catch(this._cancelBound);
            }
            async _next() {
              this.cancelled || (this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper), this.operatorListIdx === this.operatorList.argsArray.length && (this.running = !1, this.operatorList.lastChunk && (this.gfx.endDrawing(), this._canvas && Oe(e, h).delete(this._canvas), this.callback())));
            }
          };
          let InternalRenderTask = e;
          h = new WeakMap(), ot(InternalRenderTask, h, /* @__PURE__ */ new WeakSet());
          const version = "2.16.105";
          exports.version = version;
          const build = "172ccdbe5";
          exports.build = build;
        },
        /* 5 */
        /***/
        (be, ge, le) => {
          var C, Di, a;
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.PrintAnnotationStorage = ge.AnnotationStorage = void 0;
          var ce = le(1), re = le(6), ae = le(10);
          class Z {
            constructor() {
              ot(this, C);
              this._storage = /* @__PURE__ */ new Map(), this._modified = !1, this.onSetModified = null, this.onResetModified = null, this.onAnnotationEditor = null;
            }
            getValue(h, e) {
              const y = this._storage.get(h);
              return y === void 0 ? e : Object.assign(e, y);
            }
            getRawValue(h) {
              return this._storage.get(h);
            }
            remove(h) {
              if (this._storage.delete(h), this._storage.size === 0 && this.resetModified(), typeof this.onAnnotationEditor == "function") {
                for (const e of this._storage.values())
                  if (e instanceof re.AnnotationEditor)
                    return;
                this.onAnnotationEditor(null);
              }
            }
            setValue(h, e) {
              const y = this._storage.get(h);
              let c = !1;
              if (y !== void 0)
                for (const [d, p] of Object.entries(e))
                  y[d] !== p && (c = !0, y[d] = p);
              else
                c = !0, this._storage.set(h, e);
              c && dt(this, C, Di).call(this), e instanceof re.AnnotationEditor && typeof this.onAnnotationEditor == "function" && this.onAnnotationEditor(e.constructor._type);
            }
            has(h) {
              return this._storage.has(h);
            }
            getAll() {
              return this._storage.size > 0 ? (0, ce.objectFromMap)(this._storage) : null;
            }
            get size() {
              return this._storage.size;
            }
            resetModified() {
              this._modified && (this._modified = !1, typeof this.onResetModified == "function" && this.onResetModified());
            }
            get print() {
              return new o(this);
            }
            get serializable() {
              if (this._storage.size === 0)
                return null;
              const h = /* @__PURE__ */ new Map();
              for (const [e, y] of this._storage) {
                const c = y instanceof re.AnnotationEditor ? y.serialize() : y;
                c && h.set(e, c);
              }
              return h;
            }
            static getHash(h) {
              if (!h)
                return "";
              const e = new ae.MurmurHash3_64();
              for (const [y, c] of h)
                e.update(`${y}:${JSON.stringify(c)}`);
              return e.hexdigest();
            }
          }
          C = new WeakSet(), Di = function() {
            this._modified || (this._modified = !0, typeof this.onSetModified == "function" && this.onSetModified());
          }, ge.AnnotationStorage = Z;
          class o extends Z {
            constructor(e) {
              super();
              ot(this, a, null);
              vt(this, a, structuredClone(e.serializable));
            }
            get print() {
              (0, ce.unreachable)("Should not call PrintAnnotationStorage.print");
            }
            get serializable() {
              return Oe(this, a);
            }
          }
          a = new WeakMap(), ge.PrintAnnotationStorage = o;
        },
        /* 6 */
        /***/
        (be, ge, le) => {
          var Z, o, C, t, a, v;
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.AnnotationEditor = void 0;
          var ce = le(7), re = le(1);
          const h = class {
            constructor(y) {
              ot(this, Z, this.focusin.bind(this));
              ot(this, o, this.focusout.bind(this));
              ot(this, C, !1);
              ot(this, t, !1);
              ot(this, a, !1);
              ot(this, v, h._zIndex++);
              this.constructor === h && (0, re.unreachable)("Cannot initialize AnnotationEditor."), this.parent = y.parent, this.id = y.id, this.width = this.height = null, this.pageIndex = y.parent.pageIndex, this.name = y.name, this.div = null;
              const [c, d] = this.parent.viewportBaseDimensions;
              this.x = y.x / c, this.y = y.y / d, this.rotation = this.parent.viewport.rotation, this.isAttachedToDOM = !1;
            }
            static get _defaultLineColor() {
              return (0, re.shadow)(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
            }
            setInBackground() {
              this.div.style.zIndex = 0;
            }
            setInForeground() {
              this.div.style.zIndex = Oe(this, v);
            }
            focusin(y) {
              Oe(this, C) ? vt(this, C, !1) : this.parent.setSelected(this);
            }
            focusout(y) {
              if (!this.isAttachedToDOM)
                return;
              const c = y.relatedTarget;
              c != null && c.closest(`#${this.id}`) || (y.preventDefault(), this.parent.isMultipleSelection || this.commitOrRemove());
            }
            commitOrRemove() {
              this.isEmpty() ? this.remove() : this.commit();
            }
            commit() {
              this.parent.addToAnnotationStorage(this);
            }
            dragstart(y) {
              const c = this.parent.div.getBoundingClientRect();
              this.startX = y.clientX - c.x, this.startY = y.clientY - c.y, y.dataTransfer.setData("text/plain", this.id), y.dataTransfer.effectAllowed = "move";
            }
            setAt(y, c, d, p) {
              const [m, g] = this.parent.viewportBaseDimensions;
              [d, p] = this.screenToPageTranslation(d, p), this.x = (y + d) / m, this.y = (c + p) / g, this.div.style.left = `${100 * this.x}%`, this.div.style.top = `${100 * this.y}%`;
            }
            translate(y, c) {
              const [d, p] = this.parent.viewportBaseDimensions;
              [y, c] = this.screenToPageTranslation(y, c), this.x += y / d, this.y += c / p, this.div.style.left = `${100 * this.x}%`, this.div.style.top = `${100 * this.y}%`;
            }
            screenToPageTranslation(y, c) {
              const {
                rotation: d
              } = this.parent.viewport;
              switch (d) {
                case 90:
                  return [c, -y];
                case 180:
                  return [-y, -c];
                case 270:
                  return [-c, y];
                default:
                  return [y, c];
              }
            }
            setDims(y, c) {
              const [d, p] = this.parent.viewportBaseDimensions;
              this.div.style.width = `${100 * y / d}%`, this.div.style.height = `${100 * c / p}%`;
            }
            getInitialTranslation() {
              return [0, 0];
            }
            render() {
              this.div = document.createElement("div"), this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360), this.div.className = this.name, this.div.setAttribute("id", this.id), this.div.setAttribute("tabIndex", 0), this.setInForeground(), this.div.addEventListener("focusin", Oe(this, Z)), this.div.addEventListener("focusout", Oe(this, o));
              const [y, c] = this.getInitialTranslation();
              return this.translate(y, c), (0, ce.bindEvents)(this, this.div, ["dragstart", "pointerdown"]), this.div;
            }
            pointerdown(y) {
              const c = ce.KeyboardManager.platform.isMac;
              if (y.button !== 0 || y.ctrlKey && c) {
                y.preventDefault();
                return;
              }
              y.ctrlKey && !c || y.shiftKey || y.metaKey && c ? this.parent.toggleSelected(this) : this.parent.setSelected(this), vt(this, C, !0);
            }
            getRect(y, c) {
              const [d, p] = this.parent.viewportBaseDimensions, [m, g] = this.parent.pageDimensions, n = m * y / d, i = g * c / p, l = this.x * m, u = this.y * g, w = this.width * m, _ = this.height * g;
              switch (this.rotation) {
                case 0:
                  return [l + n, g - u - i - _, l + n + w, g - u - i];
                case 90:
                  return [l + i, g - u + n, l + i + _, g - u + n + w];
                case 180:
                  return [l - n - w, g - u + i, l - n, g - u + i + _];
                case 270:
                  return [l - i - _, g - u - n - w, l - i, g - u - n];
                default:
                  throw new Error("Invalid rotation");
              }
            }
            getRectInCurrentCoords(y, c) {
              const [d, p, m, g] = y, n = m - d, i = g - p;
              switch (this.rotation) {
                case 0:
                  return [d, c - g, n, i];
                case 90:
                  return [d, c - p, i, n];
                case 180:
                  return [m, c - p, n, i];
                case 270:
                  return [m, c - g, i, n];
                default:
                  throw new Error("Invalid rotation");
              }
            }
            onceAdded() {
            }
            isEmpty() {
              return !1;
            }
            enableEditMode() {
              vt(this, a, !0);
            }
            disableEditMode() {
              vt(this, a, !1);
            }
            isInEditMode() {
              return Oe(this, a);
            }
            shouldGetKeyboardEvents() {
              return !1;
            }
            needsToBeRebuilt() {
              return this.div && !this.isAttachedToDOM;
            }
            rebuild() {
              var y;
              (y = this.div) == null || y.addEventListener("focusin", Oe(this, Z));
            }
            serialize() {
              (0, re.unreachable)("An editor must be serializable");
            }
            static deserialize(y, c) {
              const d = new this.prototype.constructor({
                parent: c,
                id: c.getNextId()
              });
              d.rotation = y.rotation;
              const [p, m] = c.pageDimensions, [g, n, i, l] = d.getRectInCurrentCoords(y.rect, m);
              return d.x = g / p, d.y = n / m, d.width = i / p, d.height = l / m, d;
            }
            remove() {
              this.div.removeEventListener("focusin", Oe(this, Z)), this.div.removeEventListener("focusout", Oe(this, o)), this.isEmpty() || this.commit(), this.parent.remove(this);
            }
            select() {
              var y;
              (y = this.div) == null || y.classList.add("selectedEditor");
            }
            unselect() {
              var y;
              (y = this.div) == null || y.classList.remove("selectedEditor");
            }
            updateParams(y, c) {
            }
            disableEditing() {
            }
            enableEditing() {
            }
            get propertiesToUpdate() {
              return {};
            }
            get contentDiv() {
              return this.div;
            }
            get isEditing() {
              return Oe(this, t);
            }
            set isEditing(y) {
              vt(this, t, y), y ? (this.parent.setSelected(this), this.parent.setActiveEditor(this)) : this.parent.setActiveEditor(null);
            }
          };
          let ae = h;
          Z = new WeakMap(), o = new WeakMap(), C = new WeakMap(), t = new WeakMap(), a = new WeakMap(), v = new WeakMap(), Zt(ae, "_colorManager", new ce.ColorManager()), Zt(ae, "_zIndex", 1), ge.AnnotationEditor = ae;
        },
        /* 7 */
        /***/
        (be, ge, le) => {
          var e, y, c, d, p, m, _i, i, u, w, _, b, A, Y, j, X, B, R, k, x, f, U, O, S, F, T, Ei, M, ai, J, sn, z, $n, L, ki, te, Oi, q, si, Q, Xn, ne, zn;
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.KeyboardManager = ge.CommandManager = ge.ColorManager = ge.AnnotationEditorUIManager = void 0, ge.bindEvents = ae, ge.opacityToHex = Z;
          var ce = le(1), re = le(8);
          function ae($, E, H) {
            for (const ie of H)
              E.addEventListener(ie, $[ie].bind($));
          }
          function Z($) {
            return Math.round(Math.min(255, Math.max(1, 255 * $))).toString(16).padStart(2, "0");
          }
          class o {
            constructor() {
              ot(this, e, 0);
            }
            getId() {
              return `${ce.AnnotationEditorPrefix}${ii(this, e)._++}`;
            }
          }
          e = new WeakMap();
          class C {
            constructor(E = 128) {
              ot(this, y, []);
              ot(this, c, !1);
              ot(this, d, void 0);
              ot(this, p, -1);
              vt(this, d, E);
            }
            add({
              cmd: E,
              undo: H,
              mustExec: ie,
              type: ue = NaN,
              overwriteIfSameType: fe = !1,
              keepUndo: de = !1
            }) {
              if (ie && E(), Oe(this, c))
                return;
              const pe = {
                cmd: E,
                undo: H,
                type: ue
              };
              if (Oe(this, p) === -1) {
                Oe(this, y).length > 0 && (Oe(this, y).length = 0), vt(this, p, 0), Oe(this, y).push(pe);
                return;
              }
              if (fe && Oe(this, y)[Oe(this, p)].type === ue) {
                de && (pe.undo = Oe(this, y)[Oe(this, p)].undo), Oe(this, y)[Oe(this, p)] = pe;
                return;
              }
              const xe = Oe(this, p) + 1;
              xe === Oe(this, d) ? Oe(this, y).splice(0, 1) : (vt(this, p, xe), xe < Oe(this, y).length && Oe(this, y).splice(xe)), Oe(this, y).push(pe);
            }
            undo() {
              Oe(this, p) !== -1 && (vt(this, c, !0), Oe(this, y)[Oe(this, p)].undo(), vt(this, c, !1), vt(this, p, Oe(this, p) - 1));
            }
            redo() {
              Oe(this, p) < Oe(this, y).length - 1 && (vt(this, p, Oe(this, p) + 1), vt(this, c, !0), Oe(this, y)[Oe(this, p)].cmd(), vt(this, c, !1));
            }
            hasSomethingToUndo() {
              return Oe(this, p) !== -1;
            }
            hasSomethingToRedo() {
              return Oe(this, p) < Oe(this, y).length - 1;
            }
            destroy() {
              vt(this, y, null);
            }
          }
          y = new WeakMap(), c = new WeakMap(), d = new WeakMap(), p = new WeakMap(), ge.CommandManager = C;
          const n = class {
            constructor(E) {
              ot(this, m);
              this.buffer = [], this.callbacks = /* @__PURE__ */ new Map(), this.allKeys = /* @__PURE__ */ new Set();
              const H = n.platform.isMac;
              for (const [ie, ue] of E)
                for (const fe of ie) {
                  const de = fe.startsWith("mac+");
                  H && de ? (this.callbacks.set(fe.slice(4), ue), this.allKeys.add(fe.split("+").at(-1))) : !H && !de && (this.callbacks.set(fe, ue), this.allKeys.add(fe.split("+").at(-1)));
                }
            }
            static get platform() {
              const E = typeof navigator < "u" ? navigator.platform : "";
              return (0, ce.shadow)(this, "platform", {
                isWin: E.includes("Win"),
                isMac: E.includes("Mac")
              });
            }
            exec(E, H) {
              if (!this.allKeys.has(H.key))
                return;
              const ie = this.callbacks.get(dt(this, m, _i).call(this, H));
              ie && (ie.bind(E)(), H.stopPropagation(), H.preventDefault());
            }
          };
          let t = n;
          m = new WeakSet(), _i = function(E) {
            E.altKey && this.buffer.push("alt"), E.ctrlKey && this.buffer.push("ctrl"), E.metaKey && this.buffer.push("meta"), E.shiftKey && this.buffer.push("shift"), this.buffer.push(E.key);
            const H = this.buffer.join("+");
            return this.buffer.length = 0, H;
          }, ge.KeyboardManager = t;
          class a {
            constructor() {
              ot(this, i, null);
            }
            copy(E) {
              E && (Array.isArray(E) ? vt(this, i, E.map((H) => H.serialize())) : vt(this, i, [E.serialize()]), vt(this, i, Oe(this, i).filter((H) => !!H)), Oe(this, i).length === 0 && vt(this, i, null));
            }
            paste() {
              return Oe(this, i);
            }
            isEmpty() {
              return Oe(this, i) === null;
            }
            destroy() {
              vt(this, i, null);
            }
          }
          i = new WeakMap();
          const l = class {
            get _colors() {
              const E = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
              return (0, re.getColorValues)(E), (0, ce.shadow)(this, "_colors", E);
            }
            convert(E) {
              const H = (0, re.getRGB)(E);
              if (!window.matchMedia("(forced-colors: active)").matches)
                return H;
              for (const [ie, ue] of this._colors)
                if (ue.every((fe, de) => fe === H[de]))
                  return l._colorsMapping.get(ie);
              return H;
            }
            getHexCode(E) {
              const H = this._colors.get(E);
              return H ? ce.Util.makeHexColor(...H) : E;
            }
          };
          let v = l;
          Zt(v, "_colorsMapping", /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]])), ge.ColorManager = v;
          const ee = class {
            constructor(E, H) {
              ot(this, T);
              ot(this, M);
              ot(this, J);
              ot(this, z);
              ot(this, L);
              ot(this, te);
              ot(this, q);
              ot(this, Q);
              ot(this, ne);
              ot(this, u, null);
              ot(this, w, /* @__PURE__ */ new Map());
              ot(this, _, /* @__PURE__ */ new Map());
              ot(this, b, new a());
              ot(this, A, new C());
              ot(this, Y, 0);
              ot(this, j, null);
              ot(this, X, null);
              ot(this, B, new o());
              ot(this, R, !1);
              ot(this, k, ce.AnnotationEditorType.NONE);
              ot(this, x, /* @__PURE__ */ new Set());
              ot(this, f, this.keydown.bind(this));
              ot(this, U, this.onEditingAction.bind(this));
              ot(this, O, this.onPageChanging.bind(this));
              ot(this, S, {
                isEditing: !1,
                isEmpty: !0,
                hasEmptyClipboard: !0,
                hasSomethingToUndo: !1,
                hasSomethingToRedo: !1,
                hasSelectedEditor: !1
              });
              ot(this, F, null);
              vt(this, F, E), vt(this, X, H), Oe(this, X)._on("editingaction", Oe(this, U)), Oe(this, X)._on("pagechanging", Oe(this, O));
            }
            destroy() {
              dt(this, M, ai).call(this), Oe(this, X)._off("editingaction", Oe(this, U)), Oe(this, X)._off("pagechanging", Oe(this, O));
              for (const E of Oe(this, _).values())
                E.destroy();
              Oe(this, _).clear(), Oe(this, w).clear(), vt(this, u, null), Oe(this, x).clear(), Oe(this, b).destroy(), Oe(this, A).destroy();
            }
            onPageChanging({
              pageNumber: E
            }) {
              vt(this, Y, E - 1);
            }
            focusMainContainer() {
              Oe(this, F).focus();
            }
            keydown(E) {
              var H;
              (H = this.getActive()) != null && H.shouldGetKeyboardEvents() || ee._keyboardManager.exec(this, E);
            }
            onEditingAction(E) {
              ["undo", "redo", "cut", "copy", "paste", "delete", "selectAll"].includes(E.name) && this[E.name]();
            }
            setEditingState(E) {
              E ? (dt(this, T, Ei).call(this), dt(this, J, sn).call(this, {
                isEditing: Oe(this, k) !== ce.AnnotationEditorType.NONE,
                isEmpty: dt(this, Q, Xn).call(this),
                hasSomethingToUndo: Oe(this, A).hasSomethingToUndo(),
                hasSomethingToRedo: Oe(this, A).hasSomethingToRedo(),
                hasSelectedEditor: !1,
                hasEmptyClipboard: Oe(this, b).isEmpty()
              })) : (dt(this, M, ai).call(this), dt(this, J, sn).call(this, {
                isEditing: !1
              }));
            }
            registerEditorTypes(E) {
              vt(this, j, E);
              for (const H of Oe(this, j))
                dt(this, z, $n).call(this, H.defaultPropertiesToUpdate);
            }
            getId() {
              return Oe(this, B).getId();
            }
            addLayer(E) {
              Oe(this, _).set(E.pageIndex, E), Oe(this, R) ? E.enable() : E.disable();
            }
            removeLayer(E) {
              Oe(this, _).delete(E.pageIndex);
            }
            updateMode(E) {
              if (vt(this, k, E), E === ce.AnnotationEditorType.NONE)
                this.setEditingState(!1), dt(this, te, Oi).call(this);
              else {
                this.setEditingState(!0), dt(this, L, ki).call(this);
                for (const H of Oe(this, _).values())
                  H.updateMode(E);
              }
            }
            updateToolbar(E) {
              E !== Oe(this, k) && Oe(this, X).dispatch("switchannotationeditormode", {
                source: this,
                mode: E
              });
            }
            updateParams(E, H) {
              for (const ie of Oe(this, x))
                ie.updateParams(E, H);
              for (const ie of Oe(this, j))
                ie.updateDefaultParams(E, H);
            }
            getEditors(E) {
              const H = [];
              for (const ie of Oe(this, w).values())
                ie.pageIndex === E && H.push(ie);
              return H;
            }
            getEditor(E) {
              return Oe(this, w).get(E);
            }
            addEditor(E) {
              Oe(this, w).set(E.id, E);
            }
            removeEditor(E) {
              Oe(this, w).delete(E.id), this.unselect(E);
            }
            setActiveEditor(E) {
              Oe(this, u) !== E && (vt(this, u, E), E && dt(this, z, $n).call(this, E.propertiesToUpdate));
            }
            toggleSelected(E) {
              if (Oe(this, x).has(E)) {
                Oe(this, x).delete(E), E.unselect(), dt(this, J, sn).call(this, {
                  hasSelectedEditor: this.hasSelection
                });
                return;
              }
              Oe(this, x).add(E), E.select(), dt(this, z, $n).call(this, E.propertiesToUpdate), dt(this, J, sn).call(this, {
                hasSelectedEditor: !0
              });
            }
            setSelected(E) {
              for (const H of Oe(this, x))
                H !== E && H.unselect();
              Oe(this, x).clear(), Oe(this, x).add(E), E.select(), dt(this, z, $n).call(this, E.propertiesToUpdate), dt(this, J, sn).call(this, {
                hasSelectedEditor: !0
              });
            }
            isSelected(E) {
              return Oe(this, x).has(E);
            }
            unselect(E) {
              E.unselect(), Oe(this, x).delete(E), dt(this, J, sn).call(this, {
                hasSelectedEditor: this.hasSelection
              });
            }
            get hasSelection() {
              return Oe(this, x).size !== 0;
            }
            undo() {
              Oe(this, A).undo(), dt(this, J, sn).call(this, {
                hasSomethingToUndo: Oe(this, A).hasSomethingToUndo(),
                hasSomethingToRedo: !0,
                isEmpty: dt(this, Q, Xn).call(this)
              });
            }
            redo() {
              Oe(this, A).redo(), dt(this, J, sn).call(this, {
                hasSomethingToUndo: !0,
                hasSomethingToRedo: Oe(this, A).hasSomethingToRedo(),
                isEmpty: dt(this, Q, Xn).call(this)
              });
            }
            addCommands(E) {
              Oe(this, A).add(E), dt(this, J, sn).call(this, {
                hasSomethingToUndo: !0,
                hasSomethingToRedo: !1,
                isEmpty: dt(this, Q, Xn).call(this)
              });
            }
            delete() {
              if (Oe(this, u) && Oe(this, u).commitOrRemove(), !this.hasSelection)
                return;
              const E = [...Oe(this, x)], H = () => {
                for (const ue of E)
                  ue.remove();
              }, ie = () => {
                for (const ue of E)
                  dt(this, q, si).call(this, ue);
              };
              this.addCommands({
                cmd: H,
                undo: ie,
                mustExec: !0
              });
            }
            copy() {
              if (Oe(this, u) && Oe(this, u).commitOrRemove(), this.hasSelection) {
                const E = [];
                for (const H of Oe(this, x))
                  H.isEmpty() || E.push(H);
                if (E.length === 0)
                  return;
                Oe(this, b).copy(E), dt(this, J, sn).call(this, {
                  hasEmptyClipboard: !1
                });
              }
            }
            cut() {
              this.copy(), this.delete();
            }
            paste() {
              if (Oe(this, b).isEmpty())
                return;
              this.unselectAll();
              const E = Oe(this, _).get(Oe(this, Y)), H = Oe(this, b).paste().map((fe) => E.deserialize(fe)), ie = () => {
                for (const fe of H)
                  dt(this, q, si).call(this, fe);
                dt(this, ne, zn).call(this, H);
              }, ue = () => {
                for (const fe of H)
                  fe.remove();
              };
              this.addCommands({
                cmd: ie,
                undo: ue,
                mustExec: !0
              });
            }
            selectAll() {
              for (const E of Oe(this, x))
                E.commit();
              dt(this, ne, zn).call(this, Oe(this, w).values());
            }
            unselectAll() {
              if (Oe(this, u)) {
                Oe(this, u).commitOrRemove();
                return;
              }
              if (dt(this, ne, zn).size !== 0) {
                for (const E of Oe(this, x))
                  E.unselect();
                Oe(this, x).clear(), dt(this, J, sn).call(this, {
                  hasSelectedEditor: !1
                });
              }
            }
            isActive(E) {
              return Oe(this, u) === E;
            }
            getActive() {
              return Oe(this, u);
            }
            getMode() {
              return Oe(this, k);
            }
          };
          let h = ee;
          u = new WeakMap(), w = new WeakMap(), _ = new WeakMap(), b = new WeakMap(), A = new WeakMap(), Y = new WeakMap(), j = new WeakMap(), X = new WeakMap(), B = new WeakMap(), R = new WeakMap(), k = new WeakMap(), x = new WeakMap(), f = new WeakMap(), U = new WeakMap(), O = new WeakMap(), S = new WeakMap(), F = new WeakMap(), T = new WeakSet(), Ei = function() {
            Oe(this, F).addEventListener("keydown", Oe(this, f));
          }, M = new WeakSet(), ai = function() {
            Oe(this, F).removeEventListener("keydown", Oe(this, f));
          }, J = new WeakSet(), sn = function(E) {
            Object.entries(E).some(([ie, ue]) => Oe(this, S)[ie] !== ue) && Oe(this, X).dispatch("annotationeditorstateschanged", {
              source: this,
              details: Object.assign(Oe(this, S), E)
            });
          }, z = new WeakSet(), $n = function(E) {
            Oe(this, X).dispatch("annotationeditorparamschanged", {
              source: this,
              details: E
            });
          }, L = new WeakSet(), ki = function() {
            if (!Oe(this, R)) {
              vt(this, R, !0);
              for (const E of Oe(this, _).values())
                E.enable();
            }
          }, te = new WeakSet(), Oi = function() {
            if (this.unselectAll(), Oe(this, R)) {
              vt(this, R, !1);
              for (const E of Oe(this, _).values())
                E.disable();
            }
          }, q = new WeakSet(), si = function(E) {
            const H = Oe(this, _).get(E.pageIndex);
            H ? H.addOrRebuild(E) : this.addEditor(E);
          }, Q = new WeakSet(), Xn = function() {
            if (Oe(this, w).size === 0)
              return !0;
            if (Oe(this, w).size === 1)
              for (const E of Oe(this, w).values())
                return E.isEmpty();
            return !1;
          }, ne = new WeakSet(), zn = function(E) {
            Oe(this, x).clear();
            for (const H of E)
              H.isEmpty() || (Oe(this, x).add(H), H.select());
            dt(this, J, sn).call(this, {
              hasSelectedEditor: !0
            });
          }, Zt(h, "_keyboardManager", new t([[["ctrl+a", "mac+meta+a"], ee.prototype.selectAll], [["ctrl+c", "mac+meta+c"], ee.prototype.copy], [["ctrl+v", "mac+meta+v"], ee.prototype.paste], [["ctrl+x", "mac+meta+x"], ee.prototype.cut], [["ctrl+z", "mac+meta+z"], ee.prototype.undo], [["ctrl+y", "ctrl+shift+Z", "mac+meta+shift+Z"], ee.prototype.redo], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete"], ee.prototype.delete], [["Escape", "mac+Escape"], ee.prototype.unselectAll]])), ge.AnnotationEditorUIManager = h;
        },
        /* 8 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.StatTimer = ge.RenderingCancelledException = ge.PixelsPerInch = ge.PageViewport = ge.PDFDateString = ge.DOMStandardFontDataFactory = ge.DOMSVGFactory = ge.DOMCanvasFactory = ge.DOMCMapReaderFactory = ge.AnnotationPrefix = void 0, ge.deprecated = l, ge.getColorValues = A, ge.getCurrentTransform = Y, ge.getCurrentTransformInverse = j, ge.getFilenameFromUrl = p, ge.getPdfFilenameFromUrl = m, ge.getRGB = b, ge.getXfaPageViewport = _, ge.isDataScheme = c, ge.isPdfFile = d, ge.isValidFetchUrl = n, ge.loadScript = i;
          var ce = le(9), re = le(1);
          const ae = "http://www.w3.org/2000/svg", Z = "pdfjs_internal_id_";
          ge.AnnotationPrefix = Z;
          const X = class {
          };
          let o = X;
          Zt(o, "CSS", 96), Zt(o, "PDF", 72), Zt(o, "PDF_TO_CSS_UNITS", X.CSS / X.PDF), ge.PixelsPerInch = o;
          class C extends ce.BaseCanvasFactory {
            constructor({
              ownerDocument: R = globalThis.document
            } = {}) {
              super(), this._document = R;
            }
            _createCanvas(R, k) {
              const x = this._document.createElement("canvas");
              return x.width = R, x.height = k, x;
            }
          }
          ge.DOMCanvasFactory = C;
          async function t(B, R = !1) {
            if (n(B, document.baseURI)) {
              const k = await fetch(B);
              if (!k.ok)
                throw new Error(k.statusText);
              return R ? new Uint8Array(await k.arrayBuffer()) : (0, re.stringToBytes)(await k.text());
            }
            return new Promise((k, x) => {
              const f = new XMLHttpRequest();
              f.open("GET", B, !0), R && (f.responseType = "arraybuffer"), f.onreadystatechange = () => {
                if (f.readyState === XMLHttpRequest.DONE) {
                  if (f.status === 200 || f.status === 0) {
                    let U;
                    if (R && f.response ? U = new Uint8Array(f.response) : !R && f.responseText && (U = (0, re.stringToBytes)(f.responseText)), U) {
                      k(U);
                      return;
                    }
                  }
                  x(new Error(f.statusText));
                }
              }, f.send(null);
            });
          }
          class a extends ce.BaseCMapReaderFactory {
            _fetchData(R, k) {
              return t(R, this.isCompressed).then((x) => ({
                cMapData: x,
                compressionType: k
              }));
            }
          }
          ge.DOMCMapReaderFactory = a;
          class v extends ce.BaseStandardFontDataFactory {
            _fetchData(R) {
              return t(R, !0);
            }
          }
          ge.DOMStandardFontDataFactory = v;
          class h extends ce.BaseSVGFactory {
            _createSVG(R) {
              return document.createElementNS(ae, R);
            }
          }
          ge.DOMSVGFactory = h;
          class e {
            constructor({
              viewBox: R,
              scale: k,
              rotation: x,
              offsetX: f = 0,
              offsetY: U = 0,
              dontFlip: O = !1
            }) {
              this.viewBox = R, this.scale = k, this.rotation = x, this.offsetX = f, this.offsetY = U;
              const S = (R[2] + R[0]) / 2, F = (R[3] + R[1]) / 2;
              let T, I, M, V;
              switch (x %= 360, x < 0 && (x += 360), x) {
                case 180:
                  T = -1, I = 0, M = 0, V = 1;
                  break;
                case 90:
                  T = 0, I = 1, M = 1, V = 0;
                  break;
                case 270:
                  T = 0, I = -1, M = -1, V = 0;
                  break;
                case 0:
                  T = 1, I = 0, M = 0, V = -1;
                  break;
                default:
                  throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
              }
              O && (M = -M, V = -V);
              let J, W, z, G;
              T === 0 ? (J = Math.abs(F - R[1]) * k + f, W = Math.abs(S - R[0]) * k + U, z = Math.abs(R[3] - R[1]) * k, G = Math.abs(R[2] - R[0]) * k) : (J = Math.abs(S - R[0]) * k + f, W = Math.abs(F - R[1]) * k + U, z = Math.abs(R[2] - R[0]) * k, G = Math.abs(R[3] - R[1]) * k), this.transform = [T * k, I * k, M * k, V * k, J - T * k * S - M * k * F, W - I * k * S - V * k * F], this.width = z, this.height = G;
            }
            clone({
              scale: R = this.scale,
              rotation: k = this.rotation,
              offsetX: x = this.offsetX,
              offsetY: f = this.offsetY,
              dontFlip: U = !1
            } = {}) {
              return new e({
                viewBox: this.viewBox.slice(),
                scale: R,
                rotation: k,
                offsetX: x,
                offsetY: f,
                dontFlip: U
              });
            }
            convertToViewportPoint(R, k) {
              return re.Util.applyTransform([R, k], this.transform);
            }
            convertToViewportRectangle(R) {
              const k = re.Util.applyTransform([R[0], R[1]], this.transform), x = re.Util.applyTransform([R[2], R[3]], this.transform);
              return [k[0], k[1], x[0], x[1]];
            }
            convertToPdfPoint(R, k) {
              return re.Util.applyInverseTransform([R, k], this.transform);
            }
          }
          ge.PageViewport = e;
          class y extends re.BaseException {
            constructor(R, k) {
              super(R, "RenderingCancelledException"), this.type = k;
            }
          }
          ge.RenderingCancelledException = y;
          function c(B) {
            const R = B.length;
            let k = 0;
            for (; k < R && B[k].trim() === ""; )
              k++;
            return B.substring(k, k + 5).toLowerCase() === "data:";
          }
          function d(B) {
            return typeof B == "string" && /\.pdf$/i.test(B);
          }
          function p(B) {
            const R = B.indexOf("#"), k = B.indexOf("?"), x = Math.min(R > 0 ? R : B.length, k > 0 ? k : B.length);
            return B.substring(B.lastIndexOf("/", x) + 1, x);
          }
          function m(B, R = "document.pdf") {
            if (typeof B != "string")
              return R;
            if (c(B))
              return (0, re.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.'), R;
            const k = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/, x = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i, f = k.exec(B);
            let U = x.exec(f[1]) || x.exec(f[2]) || x.exec(f[3]);
            if (U && (U = U[0], U.includes("%")))
              try {
                U = x.exec(decodeURIComponent(U))[0];
              } catch {
              }
            return U || R;
          }
          class g {
            constructor() {
              this.started = /* @__PURE__ */ Object.create(null), this.times = [];
            }
            time(R) {
              R in this.started && (0, re.warn)(`Timer is already running for ${R}`), this.started[R] = Date.now();
            }
            timeEnd(R) {
              R in this.started || (0, re.warn)(`Timer has not been started for ${R}`), this.times.push({
                name: R,
                start: this.started[R],
                end: Date.now()
              }), delete this.started[R];
            }
            toString() {
              const R = [];
              let k = 0;
              for (const x of this.times) {
                const f = x.name;
                f.length > k && (k = f.length);
              }
              for (const x of this.times) {
                const f = x.end - x.start;
                R.push(`${x.name.padEnd(k)} ${f}ms
`);
              }
              return R.join("");
            }
          }
          ge.StatTimer = g;
          function n(B, R) {
            try {
              const {
                protocol: k
              } = R ? new URL(B, R) : new URL(B);
              return k === "http:" || k === "https:";
            } catch {
              return !1;
            }
          }
          function i(B, R = !1) {
            return new Promise((k, x) => {
              const f = document.createElement("script");
              f.src = B, f.onload = function(U) {
                R && f.remove(), k(U);
              }, f.onerror = function() {
                x(new Error(`Cannot load script at: ${f.src}`));
              }, (document.head || document.documentElement).append(f);
            });
          }
          function l(B) {
            console.log("Deprecated API usage: " + B);
          }
          let u;
          class w {
            static toDateObject(R) {
              if (!R || typeof R != "string")
                return null;
              u || (u = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"));
              const k = u.exec(R);
              if (!k)
                return null;
              const x = parseInt(k[1], 10);
              let f = parseInt(k[2], 10);
              f = f >= 1 && f <= 12 ? f - 1 : 0;
              let U = parseInt(k[3], 10);
              U = U >= 1 && U <= 31 ? U : 1;
              let O = parseInt(k[4], 10);
              O = O >= 0 && O <= 23 ? O : 0;
              let S = parseInt(k[5], 10);
              S = S >= 0 && S <= 59 ? S : 0;
              let F = parseInt(k[6], 10);
              F = F >= 0 && F <= 59 ? F : 0;
              const T = k[7] || "Z";
              let I = parseInt(k[8], 10);
              I = I >= 0 && I <= 23 ? I : 0;
              let M = parseInt(k[9], 10) || 0;
              return M = M >= 0 && M <= 59 ? M : 0, T === "-" ? (O += I, S += M) : T === "+" && (O -= I, S -= M), new Date(Date.UTC(x, f, U, O, S, F));
            }
          }
          ge.PDFDateString = w;
          function _(B, {
            scale: R = 1,
            rotation: k = 0
          }) {
            const {
              width: x,
              height: f
            } = B.attributes.style, U = [0, 0, parseInt(x), parseInt(f)];
            return new e({
              viewBox: U,
              scale: R,
              rotation: k
            });
          }
          function b(B) {
            if (B.startsWith("#")) {
              const R = parseInt(B.slice(1), 16);
              return [(R & 16711680) >> 16, (R & 65280) >> 8, R & 255];
            }
            return B.startsWith("rgb(") ? B.slice(4, -1).split(",").map((R) => parseInt(R)) : B.startsWith("rgba(") ? B.slice(5, -1).split(",").map((R) => parseInt(R)).slice(0, 3) : ((0, re.warn)(`Not a valid color format: "${B}"`), [0, 0, 0]);
          }
          function A(B) {
            const R = document.createElement("span");
            R.style.visibility = "hidden", document.body.append(R);
            for (const k of B.keys()) {
              R.style.color = k;
              const x = window.getComputedStyle(R).color;
              B.set(k, b(x));
            }
            R.remove();
          }
          function Y(B) {
            const {
              a: R,
              b: k,
              c: x,
              d: f,
              e: U,
              f: O
            } = B.getTransform();
            return [R, k, x, f, U, O];
          }
          function j(B) {
            const {
              a: R,
              b: k,
              c: x,
              d: f,
              e: U,
              f: O
            } = B.getTransform().invertSelf();
            return [R, k, x, f, U, O];
          }
        },
        /* 9 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.BaseStandardFontDataFactory = ge.BaseSVGFactory = ge.BaseCanvasFactory = ge.BaseCMapReaderFactory = void 0;
          var ce = le(1);
          class re {
            constructor() {
              this.constructor === re && (0, ce.unreachable)("Cannot initialize BaseCanvasFactory.");
            }
            create(t, a) {
              if (t <= 0 || a <= 0)
                throw new Error("Invalid canvas size");
              const v = this._createCanvas(t, a);
              return {
                canvas: v,
                context: v.getContext("2d")
              };
            }
            reset(t, a, v) {
              if (!t.canvas)
                throw new Error("Canvas is not specified");
              if (a <= 0 || v <= 0)
                throw new Error("Invalid canvas size");
              t.canvas.width = a, t.canvas.height = v;
            }
            destroy(t) {
              if (!t.canvas)
                throw new Error("Canvas is not specified");
              t.canvas.width = 0, t.canvas.height = 0, t.canvas = null, t.context = null;
            }
            _createCanvas(t, a) {
              (0, ce.unreachable)("Abstract method `_createCanvas` called.");
            }
          }
          ge.BaseCanvasFactory = re;
          class ae {
            constructor({
              baseUrl: t = null,
              isCompressed: a = !1
            }) {
              this.constructor === ae && (0, ce.unreachable)("Cannot initialize BaseCMapReaderFactory."), this.baseUrl = t, this.isCompressed = a;
            }
            async fetch({
              name: t
            }) {
              if (!this.baseUrl)
                throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');
              if (!t)
                throw new Error("CMap name must be specified.");
              const a = this.baseUrl + t + (this.isCompressed ? ".bcmap" : ""), v = this.isCompressed ? ce.CMapCompressionType.BINARY : ce.CMapCompressionType.NONE;
              return this._fetchData(a, v).catch((h) => {
                throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${a}`);
              });
            }
            _fetchData(t, a) {
              (0, ce.unreachable)("Abstract method `_fetchData` called.");
            }
          }
          ge.BaseCMapReaderFactory = ae;
          class Z {
            constructor({
              baseUrl: t = null
            }) {
              this.constructor === Z && (0, ce.unreachable)("Cannot initialize BaseStandardFontDataFactory."), this.baseUrl = t;
            }
            async fetch({
              filename: t
            }) {
              if (!this.baseUrl)
                throw new Error('The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.');
              if (!t)
                throw new Error("Font filename must be specified.");
              const a = `${this.baseUrl}${t}`;
              return this._fetchData(a).catch((v) => {
                throw new Error(`Unable to load font data at: ${a}`);
              });
            }
            _fetchData(t) {
              (0, ce.unreachable)("Abstract method `_fetchData` called.");
            }
          }
          ge.BaseStandardFontDataFactory = Z;
          class o {
            constructor() {
              this.constructor === o && (0, ce.unreachable)("Cannot initialize BaseSVGFactory.");
            }
            create(t, a, v = !1) {
              if (t <= 0 || a <= 0)
                throw new Error("Invalid SVG dimensions");
              const h = this._createSVG("svg:svg");
              return h.setAttribute("version", "1.1"), v || (h.setAttribute("width", `${t}px`), h.setAttribute("height", `${a}px`)), h.setAttribute("preserveAspectRatio", "none"), h.setAttribute("viewBox", `0 0 ${t} ${a}`), h;
            }
            createElement(t) {
              if (typeof t != "string")
                throw new Error("Invalid SVG element type");
              return this._createSVG(t);
            }
            _createSVG(t) {
              (0, ce.unreachable)("Abstract method `_createSVG` called.");
            }
          }
          ge.BaseSVGFactory = o;
        },
        /* 10 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.MurmurHash3_64 = void 0;
          var ce = le(1);
          const re = 3285377520, ae = 4294901760, Z = 65535;
          class o {
            constructor(t) {
              this.h1 = t ? t & 4294967295 : re, this.h2 = t ? t & 4294967295 : re;
            }
            update(t) {
              let a, v;
              if (typeof t == "string") {
                a = new Uint8Array(t.length * 2), v = 0;
                for (let u = 0, w = t.length; u < w; u++) {
                  const _ = t.charCodeAt(u);
                  _ <= 255 ? a[v++] = _ : (a[v++] = _ >>> 8, a[v++] = _ & 255);
                }
              } else if ((0, ce.isArrayBuffer)(t))
                a = t.slice(), v = a.byteLength;
              else
                throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");
              const h = v >> 2, e = v - h * 4, y = new Uint32Array(a.buffer, 0, h);
              let c = 0, d = 0, p = this.h1, m = this.h2;
              const g = 3432918353, n = 461845907, i = g & Z, l = n & Z;
              for (let u = 0; u < h; u++)
                u & 1 ? (c = y[u], c = c * g & ae | c * i & Z, c = c << 15 | c >>> 17, c = c * n & ae | c * l & Z, p ^= c, p = p << 13 | p >>> 19, p = p * 5 + 3864292196) : (d = y[u], d = d * g & ae | d * i & Z, d = d << 15 | d >>> 17, d = d * n & ae | d * l & Z, m ^= d, m = m << 13 | m >>> 19, m = m * 5 + 3864292196);
              switch (c = 0, e) {
                case 3:
                  c ^= a[h * 4 + 2] << 16;
                case 2:
                  c ^= a[h * 4 + 1] << 8;
                case 1:
                  c ^= a[h * 4], c = c * g & ae | c * i & Z, c = c << 15 | c >>> 17, c = c * n & ae | c * l & Z, h & 1 ? p ^= c : m ^= c;
              }
              this.h1 = p, this.h2 = m;
            }
            hexdigest() {
              let t = this.h1, a = this.h2;
              t ^= a >>> 1, t = t * 3981806797 & ae | t * 36045 & Z, a = a * 4283543511 & ae | ((a << 16 | t >>> 16) * 2950163797 & ae) >>> 16, t ^= a >>> 1, t = t * 444984403 & ae | t * 60499 & Z, a = a * 3301882366 & ae | ((a << 16 | t >>> 16) * 3120437893 & ae) >>> 16, t ^= a >>> 1;
              const v = (t >>> 0).toString(16), h = (a >>> 0).toString(16);
              return v.padStart(8, "0") + h.padStart(8, "0");
            }
          }
          ge.MurmurHash3_64 = o;
        },
        /* 11 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.FontLoader = ge.FontFaceObject = void 0;
          var ce = le(1);
          class re {
            constructor({
              docId: C,
              onUnsupportedFeature: t,
              ownerDocument: a = globalThis.document,
              styleElement: v = null
            }) {
              this.constructor === re && (0, ce.unreachable)("Cannot initialize BaseFontLoader."), this.docId = C, this._onUnsupportedFeature = t, this._document = a, this.nativeFontFaces = [], this.styleElement = null;
            }
            addNativeFontFace(C) {
              this.nativeFontFaces.push(C), this._document.fonts.add(C);
            }
            insertRule(C) {
              let t = this.styleElement;
              t || (t = this.styleElement = this._document.createElement("style"), t.id = `PDFJS_FONT_STYLE_TAG_${this.docId}`, this._document.documentElement.getElementsByTagName("head")[0].append(t));
              const a = t.sheet;
              a.insertRule(C, a.cssRules.length);
            }
            clear() {
              for (const C of this.nativeFontFaces)
                this._document.fonts.delete(C);
              this.nativeFontFaces.length = 0, this.styleElement && (this.styleElement.remove(), this.styleElement = null);
            }
            async bind(C) {
              if (C.attached || C.missingFile)
                return;
              if (C.attached = !0, this.isFontLoadingAPISupported) {
                const a = C.createNativeFontFace();
                if (a) {
                  this.addNativeFontFace(a);
                  try {
                    await a.loaded;
                  } catch (v) {
                    throw this._onUnsupportedFeature({
                      featureId: ce.UNSUPPORTED_FEATURES.errorFontLoadNative
                    }), (0, ce.warn)(`Failed to load font '${a.family}': '${v}'.`), C.disableFontFace = !0, v;
                  }
                }
                return;
              }
              const t = C.createFontFaceRule();
              if (t) {
                if (this.insertRule(t), this.isSyncFontLoadingSupported)
                  return;
                await new Promise((a) => {
                  const v = this._queueLoadingCallback(a);
                  this._prepareFontLoadEvent([t], [C], v);
                });
              }
            }
            _queueLoadingCallback(C) {
              (0, ce.unreachable)("Abstract method `_queueLoadingCallback`.");
            }
            get isFontLoadingAPISupported() {
              var t;
              const C = !!((t = this._document) != null && t.fonts);
              return (0, ce.shadow)(this, "isFontLoadingAPISupported", C);
            }
            get isSyncFontLoadingSupported() {
              (0, ce.unreachable)("Abstract method `isSyncFontLoadingSupported`.");
            }
            get _loadTestFont() {
              (0, ce.unreachable)("Abstract method `_loadTestFont`.");
            }
            _prepareFontLoadEvent(C, t, a) {
              (0, ce.unreachable)("Abstract method `_prepareFontLoadEvent`.");
            }
          }
          let ae;
          ge.FontLoader = ae, ge.FontLoader = ae = class extends re {
            constructor(C) {
              super(C), this.loadingContext = {
                requests: [],
                nextRequestId: 0
              }, this.loadTestFontId = 0;
            }
            get isSyncFontLoadingSupported() {
              let C = !1;
              if (typeof navigator > "u")
                C = !0;
              else {
                const t = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(navigator.userAgent);
                (t == null ? void 0 : t[1]) >= 14 && (C = !0);
              }
              return (0, ce.shadow)(this, "isSyncFontLoadingSupported", C);
            }
            _queueLoadingCallback(C) {
              function t() {
                for ((0, ce.assert)(!v.done, "completeRequest() cannot be called twice."), v.done = !0; a.requests.length > 0 && a.requests[0].done; ) {
                  const h = a.requests.shift();
                  setTimeout(h.callback, 0);
                }
              }
              const a = this.loadingContext, v = {
                id: `pdfjs-font-loading-${a.nextRequestId++}`,
                done: !1,
                complete: t,
                callback: C
              };
              return a.requests.push(v), v;
            }
            get _loadTestFont() {
              const C = function() {
                return atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
              };
              return (0, ce.shadow)(this, "_loadTestFont", C());
            }
            _prepareFontLoadEvent(C, t, a) {
              function v(j, X) {
                return j.charCodeAt(X) << 24 | j.charCodeAt(X + 1) << 16 | j.charCodeAt(X + 2) << 8 | j.charCodeAt(X + 3) & 255;
              }
              function h(j, X, B, R) {
                const k = j.substring(0, X), x = j.substring(X + B);
                return k + R + x;
              }
              let e, y;
              const c = this._document.createElement("canvas");
              c.width = 1, c.height = 1;
              const d = c.getContext("2d");
              let p = 0;
              function m(j, X) {
                if (p++, p > 30) {
                  (0, ce.warn)("Load test font never loaded."), X();
                  return;
                }
                if (d.font = "30px " + j, d.fillText(".", 0, 20), d.getImageData(0, 0, 1, 1).data[3] > 0) {
                  X();
                  return;
                }
                setTimeout(m.bind(null, j, X));
              }
              const g = `lt${Date.now()}${this.loadTestFontId++}`;
              let n = this._loadTestFont;
              n = h(n, 976, g.length, g);
              const l = 16, u = 1482184792;
              let w = v(n, l);
              for (e = 0, y = g.length - 3; e < y; e += 4)
                w = w - u + v(g, e) | 0;
              e < g.length && (w = w - u + v(g + "XXX", e) | 0), n = h(n, l, 4, (0, ce.string32)(w));
              const _ = `url(data:font/opentype;base64,${btoa(n)});`, b = `@font-face {font-family:"${g}";src:${_}}`;
              this.insertRule(b);
              const A = [];
              for (const j of t)
                A.push(j.loadedName);
              A.push(g);
              const Y = this._document.createElement("div");
              Y.style.visibility = "hidden", Y.style.width = Y.style.height = "10px", Y.style.position = "absolute", Y.style.top = Y.style.left = "0px";
              for (const j of A) {
                const X = this._document.createElement("span");
                X.textContent = "Hi", X.style.fontFamily = j, Y.append(X);
              }
              this._document.body.append(Y), m(g, () => {
                Y.remove(), a.complete();
              });
            }
          };
          class Z {
            constructor(C, {
              isEvalSupported: t = !0,
              disableFontFace: a = !1,
              ignoreErrors: v = !1,
              onUnsupportedFeature: h,
              fontRegistry: e = null
            }) {
              this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
              for (const y in C)
                this[y] = C[y];
              this.isEvalSupported = t !== !1, this.disableFontFace = a === !0, this.ignoreErrors = v === !0, this._onUnsupportedFeature = h, this.fontRegistry = e;
            }
            createNativeFontFace() {
              if (!this.data || this.disableFontFace)
                return null;
              let C;
              if (!this.cssFontInfo)
                C = new FontFace(this.loadedName, this.data, {});
              else {
                const t = {
                  weight: this.cssFontInfo.fontWeight
                };
                this.cssFontInfo.italicAngle && (t.style = `oblique ${this.cssFontInfo.italicAngle}deg`), C = new FontFace(this.cssFontInfo.fontFamily, this.data, t);
              }
              return this.fontRegistry && this.fontRegistry.registerFont(this), C;
            }
            createFontFaceRule() {
              if (!this.data || this.disableFontFace)
                return null;
              const C = (0, ce.bytesToString)(this.data), t = `url(data:${this.mimetype};base64,${btoa(C)});`;
              let a;
              if (!this.cssFontInfo)
                a = `@font-face {font-family:"${this.loadedName}";src:${t}}`;
              else {
                let v = `font-weight: ${this.cssFontInfo.fontWeight};`;
                this.cssFontInfo.italicAngle && (v += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`), a = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${v}src:${t}}`;
              }
              return this.fontRegistry && this.fontRegistry.registerFont(this, t), a;
            }
            getPathGenerator(C, t) {
              if (this.compiledGlyphs[t] !== void 0)
                return this.compiledGlyphs[t];
              let a;
              try {
                a = C.get(this.loadedName + "_path_" + t);
              } catch (v) {
                if (!this.ignoreErrors)
                  throw v;
                return this._onUnsupportedFeature({
                  featureId: ce.UNSUPPORTED_FEATURES.errorFontGetPath
                }), (0, ce.warn)(`getPathGenerator - ignoring character: "${v}".`), this.compiledGlyphs[t] = function(h, e) {
                };
              }
              if (this.isEvalSupported && ce.FeatureTest.isEvalSupported) {
                const v = [];
                for (const h of a) {
                  const e = h.args !== void 0 ? h.args.join(",") : "";
                  v.push("c.", h.cmd, "(", e, `);
`);
                }
                return this.compiledGlyphs[t] = new Function("c", "size", v.join(""));
              }
              return this.compiledGlyphs[t] = function(v, h) {
                for (const e of a)
                  e.cmd === "scale" && (e.args = [h, -h]), v[e.cmd].apply(v, e.args);
              };
            }
          }
          ge.FontFaceObject = Z;
        },
        /* 12 */
        /***/
        (be, ge, le) => {
          var f, oi;
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.CanvasGraphics = void 0;
          var ce = le(8), re = le(1), ae = le(13), Z = le(14), o = le(3);
          const C = 16, t = 100, a = 4096, v = 15, h = 10, e = o.isNodeJS && typeof Path2D > "u" ? -1 : 1e3, y = 16;
          function c(S, F) {
            if (S._removeMirroring)
              throw new Error("Context is already forwarding operations.");
            S.__originalSave = S.save, S.__originalRestore = S.restore, S.__originalRotate = S.rotate, S.__originalScale = S.scale, S.__originalTranslate = S.translate, S.__originalTransform = S.transform, S.__originalSetTransform = S.setTransform, S.__originalResetTransform = S.resetTransform, S.__originalClip = S.clip, S.__originalMoveTo = S.moveTo, S.__originalLineTo = S.lineTo, S.__originalBezierCurveTo = S.bezierCurveTo, S.__originalRect = S.rect, S.__originalClosePath = S.closePath, S.__originalBeginPath = S.beginPath, S._removeMirroring = () => {
              S.save = S.__originalSave, S.restore = S.__originalRestore, S.rotate = S.__originalRotate, S.scale = S.__originalScale, S.translate = S.__originalTranslate, S.transform = S.__originalTransform, S.setTransform = S.__originalSetTransform, S.resetTransform = S.__originalResetTransform, S.clip = S.__originalClip, S.moveTo = S.__originalMoveTo, S.lineTo = S.__originalLineTo, S.bezierCurveTo = S.__originalBezierCurveTo, S.rect = S.__originalRect, S.closePath = S.__originalClosePath, S.beginPath = S.__originalBeginPath, delete S._removeMirroring;
            }, S.save = function() {
              F.save(), this.__originalSave();
            }, S.restore = function() {
              F.restore(), this.__originalRestore();
            }, S.translate = function(I, M) {
              F.translate(I, M), this.__originalTranslate(I, M);
            }, S.scale = function(I, M) {
              F.scale(I, M), this.__originalScale(I, M);
            }, S.transform = function(I, M, V, J, W, z) {
              F.transform(I, M, V, J, W, z), this.__originalTransform(I, M, V, J, W, z);
            }, S.setTransform = function(I, M, V, J, W, z) {
              F.setTransform(I, M, V, J, W, z), this.__originalSetTransform(I, M, V, J, W, z);
            }, S.resetTransform = function() {
              F.resetTransform(), this.__originalResetTransform();
            }, S.rotate = function(I) {
              F.rotate(I), this.__originalRotate(I);
            }, S.clip = function(I) {
              F.clip(I), this.__originalClip(I);
            }, S.moveTo = function(T, I) {
              F.moveTo(T, I), this.__originalMoveTo(T, I);
            }, S.lineTo = function(T, I) {
              F.lineTo(T, I), this.__originalLineTo(T, I);
            }, S.bezierCurveTo = function(T, I, M, V, J, W) {
              F.bezierCurveTo(T, I, M, V, J, W), this.__originalBezierCurveTo(T, I, M, V, J, W);
            }, S.rect = function(T, I, M, V) {
              F.rect(T, I, M, V), this.__originalRect(T, I, M, V);
            }, S.closePath = function() {
              F.closePath(), this.__originalClosePath();
            }, S.beginPath = function() {
              F.beginPath(), this.__originalBeginPath();
            };
          }
          class d {
            constructor(F) {
              this.canvasFactory = F, this.cache = /* @__PURE__ */ Object.create(null);
            }
            getCanvas(F, T, I) {
              let M;
              return this.cache[F] !== void 0 ? (M = this.cache[F], this.canvasFactory.reset(M, T, I)) : (M = this.canvasFactory.create(T, I), this.cache[F] = M), M;
            }
            delete(F) {
              delete this.cache[F];
            }
            clear() {
              for (const F in this.cache) {
                const T = this.cache[F];
                this.canvasFactory.destroy(T), delete this.cache[F];
              }
            }
          }
          function p(S, F, T, I, M, V, J, W, z, G) {
            const [L, K, te, se, q, N] = (0, ce.getCurrentTransform)(S);
            if (K === 0 && te === 0) {
              const ne = J * L + q, oe = Math.round(ne), ee = W * se + N, $ = Math.round(ee), E = (J + z) * L + q, H = Math.abs(Math.round(E) - oe) || 1, ie = (W + G) * se + N, ue = Math.abs(Math.round(ie) - $) || 1;
              return S.setTransform(Math.sign(L), 0, 0, Math.sign(se), oe, $), S.drawImage(F, T, I, M, V, 0, 0, H, ue), S.setTransform(L, K, te, se, q, N), [H, ue];
            }
            if (L === 0 && se === 0) {
              const ne = W * te + q, oe = Math.round(ne), ee = J * K + N, $ = Math.round(ee), E = (W + G) * te + q, H = Math.abs(Math.round(E) - oe) || 1, ie = (J + z) * K + N, ue = Math.abs(Math.round(ie) - $) || 1;
              return S.setTransform(0, Math.sign(K), Math.sign(te), 0, oe, $), S.drawImage(F, T, I, M, V, 0, 0, ue, H), S.setTransform(L, K, te, se, q, N), [ue, H];
            }
            S.drawImage(F, T, I, M, V, J, W, z, G);
            const Q = Math.hypot(L, K), D = Math.hypot(te, se);
            return [Q * z, D * G];
          }
          function m(S) {
            const {
              width: F,
              height: T
            } = S;
            if (F > e || T > e)
              return null;
            const I = 1e3, M = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]), V = F + 1;
            let J = new Uint8Array(V * (T + 1)), W, z, G;
            const L = F + 7 & -8;
            let K = new Uint8Array(L * T), te = 0;
            for (const D of S.data) {
              let ne = 128;
              for (; ne > 0; )
                K[te++] = D & ne ? 0 : 255, ne >>= 1;
            }
            let se = 0;
            for (te = 0, K[te] !== 0 && (J[0] = 1, ++se), z = 1; z < F; z++)
              K[te] !== K[te + 1] && (J[z] = K[te] ? 2 : 1, ++se), te++;
            for (K[te] !== 0 && (J[z] = 2, ++se), W = 1; W < T; W++) {
              te = W * L, G = W * V, K[te - L] !== K[te] && (J[G] = K[te] ? 1 : 8, ++se);
              let D = (K[te] ? 4 : 0) + (K[te - L] ? 8 : 0);
              for (z = 1; z < F; z++)
                D = (D >> 2) + (K[te + 1] ? 4 : 0) + (K[te - L + 1] ? 8 : 0), M[D] && (J[G + z] = M[D], ++se), te++;
              if (K[te - L] !== K[te] && (J[G + z] = K[te] ? 2 : 4, ++se), se > I)
                return null;
            }
            for (te = L * (T - 1), G = W * V, K[te] !== 0 && (J[G] = 8, ++se), z = 1; z < F; z++)
              K[te] !== K[te + 1] && (J[G + z] = K[te] ? 4 : 8, ++se), te++;
            if (K[te] !== 0 && (J[G + z] = 4, ++se), se > I)
              return null;
            const q = new Int32Array([0, V, -1, 0, -V, 0, 0, 0, 1]), N = new Path2D();
            for (W = 0; se && W <= T; W++) {
              let D = W * V;
              const ne = D + F;
              for (; D < ne && !J[D]; )
                D++;
              if (D === ne)
                continue;
              N.moveTo(D % V, W);
              const oe = D;
              let ee = J[D];
              do {
                const $ = q[ee];
                do
                  D += $;
                while (!J[D]);
                const E = J[D];
                E !== 5 && E !== 10 ? (ee = E, J[D] = 0) : (ee = E & 51 * ee >> 4, J[D] &= ee >> 2 | ee << 2), N.lineTo(D % V, D / V | 0), J[D] || --se;
              } while (oe !== D);
              --W;
            }
            return K = null, J = null, function(D) {
              D.save(), D.scale(1 / F, -1 / T), D.translate(0, -T), D.fill(N), D.beginPath(), D.restore();
            };
          }
          class g {
            constructor(F, T) {
              this.alphaIsShape = !1, this.fontSize = 0, this.fontSizeScale = 1, this.textMatrix = re.IDENTITY_MATRIX, this.textMatrixScale = 1, this.fontMatrix = re.FONT_IDENTITY_MATRIX, this.leading = 0, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRenderingMode = re.TextRenderingMode.FILL, this.textRise = 0, this.fillColor = "#000000", this.strokeColor = "#000000", this.patternFill = !1, this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.activeSMask = null, this.transferMaps = null, this.startNewPathAndClipBox([0, 0, F, T]);
            }
            clone() {
              const F = Object.create(this);
              return F.clipBox = this.clipBox.slice(), F;
            }
            setCurrentPoint(F, T) {
              this.x = F, this.y = T;
            }
            updatePathMinMax(F, T, I) {
              [T, I] = re.Util.applyTransform([T, I], F), this.minX = Math.min(this.minX, T), this.minY = Math.min(this.minY, I), this.maxX = Math.max(this.maxX, T), this.maxY = Math.max(this.maxY, I);
            }
            updateRectMinMax(F, T) {
              const I = re.Util.applyTransform(T, F), M = re.Util.applyTransform(T.slice(2), F);
              this.minX = Math.min(this.minX, I[0], M[0]), this.minY = Math.min(this.minY, I[1], M[1]), this.maxX = Math.max(this.maxX, I[0], M[0]), this.maxY = Math.max(this.maxY, I[1], M[1]);
            }
            updateScalingPathMinMax(F, T) {
              re.Util.scaleMinMax(F, T), this.minX = Math.min(this.minX, T[0]), this.maxX = Math.max(this.maxX, T[1]), this.minY = Math.min(this.minY, T[2]), this.maxY = Math.max(this.maxY, T[3]);
            }
            updateCurvePathMinMax(F, T, I, M, V, J, W, z, G, L) {
              const K = re.Util.bezierBoundingBox(T, I, M, V, J, W, z, G);
              if (L) {
                L[0] = Math.min(L[0], K[0], K[2]), L[1] = Math.max(L[1], K[0], K[2]), L[2] = Math.min(L[2], K[1], K[3]), L[3] = Math.max(L[3], K[1], K[3]);
                return;
              }
              this.updateRectMinMax(F, K);
            }
            getPathBoundingBox(F = ae.PathType.FILL, T = null) {
              const I = [this.minX, this.minY, this.maxX, this.maxY];
              if (F === ae.PathType.STROKE) {
                T || (0, re.unreachable)("Stroke bounding box must include transform.");
                const M = re.Util.singularValueDecompose2dScale(T), V = M[0] * this.lineWidth / 2, J = M[1] * this.lineWidth / 2;
                I[0] -= V, I[1] -= J, I[2] += V, I[3] += J;
              }
              return I;
            }
            updateClipFromPath() {
              const F = re.Util.intersect(this.clipBox, this.getPathBoundingBox());
              this.startNewPathAndClipBox(F || [0, 0, 0, 0]);
            }
            isEmptyClip() {
              return this.minX === 1 / 0;
            }
            startNewPathAndClipBox(F) {
              this.clipBox = F, this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = 0, this.maxY = 0;
            }
            getClippedPathBoundingBox(F = ae.PathType.FILL, T = null) {
              return re.Util.intersect(this.clipBox, this.getPathBoundingBox(F, T));
            }
          }
          function n(S, F, T = null) {
            if (typeof ImageData < "u" && F instanceof ImageData) {
              S.putImageData(F, 0, 0);
              return;
            }
            const I = F.height, M = F.width, V = I % y, J = (I - V) / y, W = V === 0 ? J : J + 1, z = S.createImageData(M, y);
            let G = 0, L;
            const K = F.data, te = z.data;
            let se, q, N, Q, D, ne, oe, ee;
            if (T)
              switch (T.length) {
                case 1:
                  D = T[0], ne = T[0], oe = T[0], ee = T[0];
                  break;
                case 4:
                  D = T[0], ne = T[1], oe = T[2], ee = T[3];
                  break;
              }
            if (F.kind === re.ImageKind.GRAYSCALE_1BPP) {
              const $ = K.byteLength, E = new Uint32Array(te.buffer, 0, te.byteLength >> 2), H = E.length, ie = M + 7 >> 3;
              let ue = 4294967295, fe = re.FeatureTest.isLittleEndian ? 4278190080 : 255;
              for (ee && ee[0] === 255 && ee[255] === 0 && ([ue, fe] = [fe, ue]), se = 0; se < W; se++) {
                for (N = se < J ? y : V, L = 0, q = 0; q < N; q++) {
                  const de = $ - G;
                  let pe = 0;
                  const xe = de > ie ? M : de * 8 - 7, De = xe & -8;
                  let Ae = 0, Se = 0;
                  for (; pe < De; pe += 8)
                    Se = K[G++], E[L++] = Se & 128 ? ue : fe, E[L++] = Se & 64 ? ue : fe, E[L++] = Se & 32 ? ue : fe, E[L++] = Se & 16 ? ue : fe, E[L++] = Se & 8 ? ue : fe, E[L++] = Se & 4 ? ue : fe, E[L++] = Se & 2 ? ue : fe, E[L++] = Se & 1 ? ue : fe;
                  for (; pe < xe; pe++)
                    Ae === 0 && (Se = K[G++], Ae = 128), E[L++] = Se & Ae ? ue : fe, Ae >>= 1;
                }
                for (; L < H; )
                  E[L++] = 0;
                S.putImageData(z, 0, se * y);
              }
            } else if (F.kind === re.ImageKind.RGBA_32BPP) {
              const $ = !!(D || ne || oe);
              for (q = 0, Q = M * y * 4, se = 0; se < J; se++) {
                if (te.set(K.subarray(G, G + Q)), G += Q, $)
                  for (let E = 0; E < Q; E += 4)
                    D && (te[E + 0] = D[te[E + 0]]), ne && (te[E + 1] = ne[te[E + 1]]), oe && (te[E + 2] = oe[te[E + 2]]);
                S.putImageData(z, 0, q), q += y;
              }
              if (se < W) {
                if (Q = M * V * 4, te.set(K.subarray(G, G + Q)), $)
                  for (let E = 0; E < Q; E += 4)
                    D && (te[E + 0] = D[te[E + 0]]), ne && (te[E + 1] = ne[te[E + 1]]), oe && (te[E + 2] = oe[te[E + 2]]);
                S.putImageData(z, 0, q);
              }
            } else if (F.kind === re.ImageKind.RGB_24BPP) {
              const $ = !!(D || ne || oe);
              for (N = y, Q = M * N, se = 0; se < W; se++) {
                for (se >= J && (N = V, Q = M * N), L = 0, q = Q; q--; )
                  te[L++] = K[G++], te[L++] = K[G++], te[L++] = K[G++], te[L++] = 255;
                if ($)
                  for (let E = 0; E < L; E += 4)
                    D && (te[E + 0] = D[te[E + 0]]), ne && (te[E + 1] = ne[te[E + 1]]), oe && (te[E + 2] = oe[te[E + 2]]);
                S.putImageData(z, 0, se * y);
              }
            } else
              throw new Error(`bad image kind: ${F.kind}`);
          }
          function i(S, F) {
            if (F.bitmap) {
              S.drawImage(F.bitmap, 0, 0);
              return;
            }
            const T = F.height, I = F.width, M = T % y, V = (T - M) / y, J = M === 0 ? V : V + 1, W = S.createImageData(I, y);
            let z = 0;
            const G = F.data, L = W.data;
            for (let K = 0; K < J; K++) {
              const te = K < V ? y : M;
              ({
                srcPos: z
              } = (0, Z.applyMaskImageData)({
                src: G,
                srcPos: z,
                dest: L,
                width: I,
                height: te
              })), S.putImageData(W, 0, K * y);
            }
          }
          function l(S, F) {
            const T = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font"];
            for (let I = 0, M = T.length; I < M; I++) {
              const V = T[I];
              S[V] !== void 0 && (F[V] = S[V]);
            }
            S.setLineDash !== void 0 && (F.setLineDash(S.getLineDash()), F.lineDashOffset = S.lineDashOffset);
          }
          function u(S, F) {
            S.strokeStyle = S.fillStyle = F || "#000000", S.fillRule = "nonzero", S.globalAlpha = 1, S.lineWidth = 1, S.lineCap = "butt", S.lineJoin = "miter", S.miterLimit = 10, S.globalCompositeOperation = "source-over", S.font = "10px sans-serif", S.setLineDash !== void 0 && (S.setLineDash([]), S.lineDashOffset = 0);
          }
          function w(S, F, T, I) {
            const M = S.length;
            for (let V = 3; V < M; V += 4) {
              const J = S[V];
              if (J === 0)
                S[V - 3] = F, S[V - 2] = T, S[V - 1] = I;
              else if (J < 255) {
                const W = 255 - J;
                S[V - 3] = S[V - 3] * J + F * W >> 8, S[V - 2] = S[V - 2] * J + T * W >> 8, S[V - 1] = S[V - 1] * J + I * W >> 8;
              }
            }
          }
          function _(S, F, T) {
            const I = S.length, M = 1 / 255;
            for (let V = 3; V < I; V += 4) {
              const J = T ? T[S[V]] : S[V];
              F[V] = F[V] * J * M | 0;
            }
          }
          function b(S, F, T) {
            const I = S.length;
            for (let M = 3; M < I; M += 4) {
              const V = S[M - 3] * 77 + S[M - 2] * 152 + S[M - 1] * 28;
              F[M] = T ? F[M] * T[V >> 8] >> 8 : F[M] * V >> 16;
            }
          }
          function A(S, F, T, I, M, V, J, W, z, G, L) {
            const K = !!V, te = K ? V[0] : 0, se = K ? V[1] : 0, q = K ? V[2] : 0;
            let N;
            M === "Luminosity" ? N = b : N = _;
            const D = Math.min(I, Math.ceil(1048576 / T));
            for (let ne = 0; ne < I; ne += D) {
              const oe = Math.min(D, I - ne), ee = S.getImageData(W - G, ne + (z - L), T, oe), $ = F.getImageData(W, ne + z, T, oe);
              K && w(ee.data, te, se, q), N(ee.data, $.data, J), F.putImageData($, W, ne + z);
            }
          }
          function Y(S, F, T, I) {
            const M = I[0], V = I[1], J = I[2] - M, W = I[3] - V;
            J === 0 || W === 0 || (A(F.context, T, J, W, F.subtype, F.backdrop, F.transferMap, M, V, F.offsetX, F.offsetY), S.save(), S.globalAlpha = 1, S.globalCompositeOperation = "source-over", S.setTransform(1, 0, 0, 1, 0, 0), S.drawImage(T.canvas, 0, 0), S.restore());
          }
          function j(S, F) {
            const T = re.Util.singularValueDecompose2dScale(S);
            T[0] = Math.fround(T[0]), T[1] = Math.fround(T[1]);
            const I = Math.fround((globalThis.devicePixelRatio || 1) * ce.PixelsPerInch.PDF_TO_CSS_UNITS);
            return F !== void 0 ? F : T[0] <= I || T[1] <= I;
          }
          const X = ["butt", "round", "square"], B = ["miter", "round", "bevel"], R = {}, k = {}, O = class {
            constructor(F, T, I, M, V, J, W, z) {
              ot(this, f);
              this.ctx = F, this.current = new g(this.ctx.canvas.width, this.ctx.canvas.height), this.stateStack = [], this.pendingClip = null, this.pendingEOFill = !1, this.res = null, this.xobjs = null, this.commonObjs = T, this.objs = I, this.canvasFactory = M, this.imageLayer = V, this.groupStack = [], this.processingType3 = null, this.baseTransform = null, this.baseTransformStack = [], this.groupLevel = 0, this.smaskStack = [], this.smaskCounter = 0, this.tempSMask = null, this.suspendedCtx = null, this.contentVisible = !0, this.markedContentStack = [], this.optionalContentConfig = J, this.cachedCanvases = new d(this.canvasFactory), this.cachedPatterns = /* @__PURE__ */ new Map(), this.annotationCanvasMap = W, this.viewportScale = 1, this.outputScaleX = 1, this.outputScaleY = 1, this.backgroundColor = (z == null ? void 0 : z.background) || null, this.foregroundColor = (z == null ? void 0 : z.foreground) || null, this._cachedScaleForStroking = null, this._cachedGetSinglePixelWidth = null, this._cachedBitmapsMap = /* @__PURE__ */ new Map();
            }
            getObject(F, T = null) {
              return typeof F == "string" ? F.startsWith("g_") ? this.commonObjs.get(F) : this.objs.get(F) : T;
            }
            beginDrawing({
              transform: F,
              viewport: T,
              transparency: I = !1,
              background: M = null
            }) {
              const V = this.ctx.canvas.width, J = this.ctx.canvas.height, W = M || "#ffffff";
              if (this.ctx.save(), this.foregroundColor && this.backgroundColor) {
                this.ctx.fillStyle = this.foregroundColor;
                const z = this.foregroundColor = this.ctx.fillStyle;
                this.ctx.fillStyle = this.backgroundColor;
                const G = this.backgroundColor = this.ctx.fillStyle;
                let L = !0, K = W;
                if (this.ctx.fillStyle = W, K = this.ctx.fillStyle, L = typeof K == "string" && /^#[0-9A-Fa-f]{6}$/.test(K), z === "#000000" && G === "#ffffff" || z === G || !L)
                  this.foregroundColor = this.backgroundColor = null;
                else {
                  const [te, se, q] = (0, ce.getRGB)(K), N = (D) => (D /= 255, D <= 0.03928 ? D / 12.92 : ((D + 0.055) / 1.055) ** 2.4), Q = Math.round(0.2126 * N(te) + 0.7152 * N(se) + 0.0722 * N(q));
                  this.selectColor = (D, ne, oe) => {
                    const ee = 0.2126 * N(D) + 0.7152 * N(ne) + 0.0722 * N(oe);
                    return Math.round(ee) === Q ? G : z;
                  };
                }
              }
              if (this.ctx.fillStyle = this.backgroundColor || W, this.ctx.fillRect(0, 0, V, J), this.ctx.restore(), I) {
                const z = this.cachedCanvases.getCanvas("transparent", V, J);
                this.compositeCtx = this.ctx, this.transparentCanvas = z.canvas, this.ctx = z.context, this.ctx.save(), this.ctx.transform(...(0, ce.getCurrentTransform)(this.compositeCtx));
              }
              this.ctx.save(), u(this.ctx, this.foregroundColor), F && (this.ctx.transform(...F), this.outputScaleX = F[0], this.outputScaleY = F[0]), this.ctx.transform(...T.transform), this.viewportScale = T.scale, this.baseTransform = (0, ce.getCurrentTransform)(this.ctx), this.imageLayer && ((0, ce.deprecated)("The `imageLayer` functionality will be removed in the future."), this.imageLayer.beginLayout());
            }
            executeOperatorList(F, T, I, M) {
              const V = F.argsArray, J = F.fnArray;
              let W = T || 0;
              const z = V.length;
              if (z === W)
                return W;
              const G = z - W > h && typeof I == "function", L = G ? Date.now() + v : 0;
              let K = 0;
              const te = this.commonObjs, se = this.objs;
              let q;
              for (; ; ) {
                if (M !== void 0 && W === M.nextBreakPoint)
                  return M.breakIt(W, I), W;
                if (q = J[W], q !== re.OPS.dependency)
                  this[q].apply(this, V[W]);
                else
                  for (const N of V[W]) {
                    const Q = N.startsWith("g_") ? te : se;
                    if (!Q.has(N))
                      return Q.get(N, I), W;
                  }
                if (W++, W === z)
                  return W;
                if (G && ++K > h) {
                  if (Date.now() > L)
                    return I(), W;
                  K = 0;
                }
              }
            }
            endDrawing() {
              dt(this, f, oi).call(this), this.cachedCanvases.clear(), this.cachedPatterns.clear();
              for (const F of this._cachedBitmapsMap.values()) {
                for (const T of F.values())
                  typeof HTMLCanvasElement < "u" && T instanceof HTMLCanvasElement && (T.width = T.height = 0);
                F.clear();
              }
              this._cachedBitmapsMap.clear(), this.imageLayer && this.imageLayer.endLayout();
            }
            _scaleImage(F, T) {
              const I = F.width, M = F.height;
              let V = Math.max(Math.hypot(T[0], T[1]), 1), J = Math.max(Math.hypot(T[2], T[3]), 1), W = I, z = M, G = "prescale1", L, K;
              for (; V > 2 && W > 1 || J > 2 && z > 1; ) {
                let te = W, se = z;
                V > 2 && W > 1 && (te = Math.ceil(W / 2), V /= W / te), J > 2 && z > 1 && (se = Math.ceil(z / 2), J /= z / se), L = this.cachedCanvases.getCanvas(G, te, se), K = L.context, K.clearRect(0, 0, te, se), K.drawImage(F, 0, 0, W, z, 0, 0, te, se), F = L.canvas, W = te, z = se, G = G === "prescale1" ? "prescale2" : "prescale1";
              }
              return {
                img: F,
                paintWidth: W,
                paintHeight: z
              };
            }
            _createMaskCanvas(F) {
              const T = this.ctx, {
                width: I,
                height: M
              } = F, V = this.current.fillColor, J = this.current.patternFill, W = (0, ce.getCurrentTransform)(T);
              let z, G, L, K;
              if ((F.bitmap || F.data) && F.count > 1) {
                const H = F.bitmap || F.data.buffer, ie = W.slice(0, 4);
                G = JSON.stringify(J ? ie : [ie, V]), z = this._cachedBitmapsMap.get(H), z || (z = /* @__PURE__ */ new Map(), this._cachedBitmapsMap.set(H, z));
                const ue = z.get(G);
                if (ue && !J) {
                  const fe = Math.round(Math.min(W[0], W[2]) + W[4]), de = Math.round(Math.min(W[1], W[3]) + W[5]);
                  return {
                    canvas: ue,
                    offsetX: fe,
                    offsetY: de
                  };
                }
                L = ue;
              }
              L || (K = this.cachedCanvases.getCanvas("maskCanvas", I, M), i(K.context, F));
              let te = re.Util.transform(W, [1 / I, 0, 0, -1 / M, 0, 0]);
              te = re.Util.transform(te, [1, 0, 0, 1, 0, -M]);
              const se = re.Util.applyTransform([0, 0], te), q = re.Util.applyTransform([I, M], te), N = re.Util.normalizeRect([se[0], se[1], q[0], q[1]]), Q = Math.round(N[2] - N[0]) || 1, D = Math.round(N[3] - N[1]) || 1, ne = this.cachedCanvases.getCanvas("fillCanvas", Q, D), oe = ne.context, ee = Math.min(se[0], q[0]), $ = Math.min(se[1], q[1]);
              oe.translate(-ee, -$), oe.transform(...te), L || (L = this._scaleImage(K.canvas, (0, ce.getCurrentTransformInverse)(oe)), L = L.img, z && J && z.set(G, L)), oe.imageSmoothingEnabled = j((0, ce.getCurrentTransform)(oe), F.interpolate), p(oe, L, 0, 0, L.width, L.height, 0, 0, I, M), oe.globalCompositeOperation = "source-in";
              const E = re.Util.transform((0, ce.getCurrentTransformInverse)(oe), [1, 0, 0, 1, -ee, -$]);
              return oe.fillStyle = J ? V.getPattern(T, this, E, ae.PathType.FILL) : V, oe.fillRect(0, 0, I, M), z && !J && (this.cachedCanvases.delete("fillCanvas"), z.set(G, ne.canvas)), {
                canvas: ne.canvas,
                offsetX: Math.round(ee),
                offsetY: Math.round($)
              };
            }
            setLineWidth(F) {
              F !== this.current.lineWidth && (this._cachedScaleForStroking = null), this.current.lineWidth = F, this.ctx.lineWidth = F;
            }
            setLineCap(F) {
              this.ctx.lineCap = X[F];
            }
            setLineJoin(F) {
              this.ctx.lineJoin = B[F];
            }
            setMiterLimit(F) {
              this.ctx.miterLimit = F;
            }
            setDash(F, T) {
              const I = this.ctx;
              I.setLineDash !== void 0 && (I.setLineDash(F), I.lineDashOffset = T);
            }
            setRenderingIntent(F) {
            }
            setFlatness(F) {
            }
            setGState(F) {
              for (let T = 0, I = F.length; T < I; T++) {
                const M = F[T], V = M[0], J = M[1];
                switch (V) {
                  case "LW":
                    this.setLineWidth(J);
                    break;
                  case "LC":
                    this.setLineCap(J);
                    break;
                  case "LJ":
                    this.setLineJoin(J);
                    break;
                  case "ML":
                    this.setMiterLimit(J);
                    break;
                  case "D":
                    this.setDash(J[0], J[1]);
                    break;
                  case "RI":
                    this.setRenderingIntent(J);
                    break;
                  case "FL":
                    this.setFlatness(J);
                    break;
                  case "Font":
                    this.setFont(J[0], J[1]);
                    break;
                  case "CA":
                    this.current.strokeAlpha = M[1];
                    break;
                  case "ca":
                    this.current.fillAlpha = M[1], this.ctx.globalAlpha = M[1];
                    break;
                  case "BM":
                    this.ctx.globalCompositeOperation = J;
                    break;
                  case "SMask":
                    this.current.activeSMask = J ? this.tempSMask : null, this.tempSMask = null, this.checkSMaskState();
                    break;
                  case "TR":
                    this.current.transferMaps = J;
                }
              }
            }
            get inSMaskMode() {
              return !!this.suspendedCtx;
            }
            checkSMaskState() {
              const F = this.inSMaskMode;
              this.current.activeSMask && !F ? this.beginSMaskMode() : !this.current.activeSMask && F && this.endSMaskMode();
            }
            beginSMaskMode() {
              if (this.inSMaskMode)
                throw new Error("beginSMaskMode called while already in smask mode");
              const F = this.ctx.canvas.width, T = this.ctx.canvas.height, I = "smaskGroupAt" + this.groupLevel, M = this.cachedCanvases.getCanvas(I, F, T);
              this.suspendedCtx = this.ctx, this.ctx = M.context;
              const V = this.ctx;
              V.setTransform(...(0, ce.getCurrentTransform)(this.suspendedCtx)), l(this.suspendedCtx, V), c(V, this.suspendedCtx), this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
            }
            endSMaskMode() {
              if (!this.inSMaskMode)
                throw new Error("endSMaskMode called while not in smask mode");
              this.ctx._removeMirroring(), l(this.ctx, this.suspendedCtx), this.ctx = this.suspendedCtx, this.suspendedCtx = null;
            }
            compose(F) {
              if (!this.current.activeSMask)
                return;
              F ? (F[0] = Math.floor(F[0]), F[1] = Math.floor(F[1]), F[2] = Math.ceil(F[2]), F[3] = Math.ceil(F[3])) : F = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
              const T = this.current.activeSMask, I = this.suspendedCtx;
              Y(I, T, this.ctx, F), this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height), this.ctx.restore();
            }
            save() {
              this.inSMaskMode ? (l(this.ctx, this.suspendedCtx), this.suspendedCtx.save()) : this.ctx.save();
              const F = this.current;
              this.stateStack.push(F), this.current = F.clone();
            }
            restore() {
              this.stateStack.length === 0 && this.inSMaskMode && this.endSMaskMode(), this.stateStack.length !== 0 && (this.current = this.stateStack.pop(), this.inSMaskMode ? (this.suspendedCtx.restore(), l(this.suspendedCtx, this.ctx)) : this.ctx.restore(), this.checkSMaskState(), this.pendingClip = null, this._cachedScaleForStroking = null, this._cachedGetSinglePixelWidth = null);
            }
            transform(F, T, I, M, V, J) {
              this.ctx.transform(F, T, I, M, V, J), this._cachedScaleForStroking = null, this._cachedGetSinglePixelWidth = null;
            }
            constructPath(F, T, I) {
              const M = this.ctx, V = this.current;
              let J = V.x, W = V.y, z, G;
              const L = (0, ce.getCurrentTransform)(M), K = L[0] === 0 && L[3] === 0 || L[1] === 0 && L[2] === 0, te = K ? I.slice(0) : null;
              for (let se = 0, q = 0, N = F.length; se < N; se++)
                switch (F[se] | 0) {
                  case re.OPS.rectangle:
                    J = T[q++], W = T[q++];
                    const Q = T[q++], D = T[q++], ne = J + Q, oe = W + D;
                    M.moveTo(J, W), Q === 0 || D === 0 ? M.lineTo(ne, oe) : (M.lineTo(ne, W), M.lineTo(ne, oe), M.lineTo(J, oe)), K || V.updateRectMinMax(L, [J, W, ne, oe]), M.closePath();
                    break;
                  case re.OPS.moveTo:
                    J = T[q++], W = T[q++], M.moveTo(J, W), K || V.updatePathMinMax(L, J, W);
                    break;
                  case re.OPS.lineTo:
                    J = T[q++], W = T[q++], M.lineTo(J, W), K || V.updatePathMinMax(L, J, W);
                    break;
                  case re.OPS.curveTo:
                    z = J, G = W, J = T[q + 4], W = T[q + 5], M.bezierCurveTo(T[q], T[q + 1], T[q + 2], T[q + 3], J, W), V.updateCurvePathMinMax(L, z, G, T[q], T[q + 1], T[q + 2], T[q + 3], J, W, te), q += 6;
                    break;
                  case re.OPS.curveTo2:
                    z = J, G = W, M.bezierCurveTo(J, W, T[q], T[q + 1], T[q + 2], T[q + 3]), V.updateCurvePathMinMax(L, z, G, J, W, T[q], T[q + 1], T[q + 2], T[q + 3], te), J = T[q + 2], W = T[q + 3], q += 4;
                    break;
                  case re.OPS.curveTo3:
                    z = J, G = W, J = T[q + 2], W = T[q + 3], M.bezierCurveTo(T[q], T[q + 1], J, W, J, W), V.updateCurvePathMinMax(L, z, G, T[q], T[q + 1], J, W, J, W, te), q += 4;
                    break;
                  case re.OPS.closePath:
                    M.closePath();
                    break;
                }
              K && V.updateScalingPathMinMax(L, te), V.setCurrentPoint(J, W);
            }
            closePath() {
              this.ctx.closePath();
            }
            stroke(F) {
              F = typeof F < "u" ? F : !0;
              const T = this.ctx, I = this.current.strokeColor;
              T.globalAlpha = this.current.strokeAlpha, this.contentVisible && (typeof I == "object" && (I != null && I.getPattern) ? (T.save(), T.strokeStyle = I.getPattern(T, this, (0, ce.getCurrentTransformInverse)(T), ae.PathType.STROKE), this.rescaleAndStroke(!1), T.restore()) : this.rescaleAndStroke(!0)), F && this.consumePath(this.current.getClippedPathBoundingBox()), T.globalAlpha = this.current.fillAlpha;
            }
            closeStroke() {
              this.closePath(), this.stroke();
            }
            fill(F) {
              F = typeof F < "u" ? F : !0;
              const T = this.ctx, I = this.current.fillColor, M = this.current.patternFill;
              let V = !1;
              M && (T.save(), T.fillStyle = I.getPattern(T, this, (0, ce.getCurrentTransformInverse)(T), ae.PathType.FILL), V = !0);
              const J = this.current.getClippedPathBoundingBox();
              this.contentVisible && J !== null && (this.pendingEOFill ? (T.fill("evenodd"), this.pendingEOFill = !1) : T.fill()), V && T.restore(), F && this.consumePath(J);
            }
            eoFill() {
              this.pendingEOFill = !0, this.fill();
            }
            fillStroke() {
              this.fill(!1), this.stroke(!1), this.consumePath();
            }
            eoFillStroke() {
              this.pendingEOFill = !0, this.fillStroke();
            }
            closeFillStroke() {
              this.closePath(), this.fillStroke();
            }
            closeEOFillStroke() {
              this.pendingEOFill = !0, this.closePath(), this.fillStroke();
            }
            endPath() {
              this.consumePath();
            }
            clip() {
              this.pendingClip = R;
            }
            eoClip() {
              this.pendingClip = k;
            }
            beginText() {
              this.current.textMatrix = re.IDENTITY_MATRIX, this.current.textMatrixScale = 1, this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
            }
            endText() {
              const F = this.pendingTextPaths, T = this.ctx;
              if (F === void 0) {
                T.beginPath();
                return;
              }
              T.save(), T.beginPath();
              for (const I of F)
                T.setTransform(...I.transform), T.translate(I.x, I.y), I.addToPath(T, I.fontSize);
              T.restore(), T.clip(), T.beginPath(), delete this.pendingTextPaths;
            }
            setCharSpacing(F) {
              this.current.charSpacing = F;
            }
            setWordSpacing(F) {
              this.current.wordSpacing = F;
            }
            setHScale(F) {
              this.current.textHScale = F / 100;
            }
            setLeading(F) {
              this.current.leading = -F;
            }
            setFont(F, T) {
              const I = this.commonObjs.get(F), M = this.current;
              if (!I)
                throw new Error(`Can't find font for ${F}`);
              if (M.fontMatrix = I.fontMatrix || re.FONT_IDENTITY_MATRIX, (M.fontMatrix[0] === 0 || M.fontMatrix[3] === 0) && (0, re.warn)("Invalid font matrix for font " + F), T < 0 ? (T = -T, M.fontDirection = -1) : M.fontDirection = 1, this.current.font = I, this.current.fontSize = T, I.isType3Font)
                return;
              const V = I.loadedName || "sans-serif";
              let J = "normal";
              I.black ? J = "900" : I.bold && (J = "bold");
              const W = I.italic ? "italic" : "normal", z = `"${V}", ${I.fallbackName}`;
              let G = T;
              T < C ? G = C : T > t && (G = t), this.current.fontSizeScale = T / G, this.ctx.font = `${W} ${J} ${G}px ${z}`;
            }
            setTextRenderingMode(F) {
              this.current.textRenderingMode = F;
            }
            setTextRise(F) {
              this.current.textRise = F;
            }
            moveText(F, T) {
              this.current.x = this.current.lineX += F, this.current.y = this.current.lineY += T;
            }
            setLeadingMoveText(F, T) {
              this.setLeading(-T), this.moveText(F, T);
            }
            setTextMatrix(F, T, I, M, V, J) {
              this.current.textMatrix = [F, T, I, M, V, J], this.current.textMatrixScale = Math.hypot(F, T), this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
            }
            nextLine() {
              this.moveText(0, this.current.leading);
            }
            paintChar(F, T, I, M) {
              const V = this.ctx, J = this.current, W = J.font, z = J.textRenderingMode, G = J.fontSize / J.fontSizeScale, L = z & re.TextRenderingMode.FILL_STROKE_MASK, K = !!(z & re.TextRenderingMode.ADD_TO_PATH_FLAG), te = J.patternFill && !W.missingFile;
              let se;
              (W.disableFontFace || K || te) && (se = W.getPathGenerator(this.commonObjs, F)), W.disableFontFace || te ? (V.save(), V.translate(T, I), V.beginPath(), se(V, G), M && V.setTransform(...M), (L === re.TextRenderingMode.FILL || L === re.TextRenderingMode.FILL_STROKE) && V.fill(), (L === re.TextRenderingMode.STROKE || L === re.TextRenderingMode.FILL_STROKE) && V.stroke(), V.restore()) : ((L === re.TextRenderingMode.FILL || L === re.TextRenderingMode.FILL_STROKE) && V.fillText(F, T, I), (L === re.TextRenderingMode.STROKE || L === re.TextRenderingMode.FILL_STROKE) && V.strokeText(F, T, I)), K && (this.pendingTextPaths || (this.pendingTextPaths = [])).push({
                transform: (0, ce.getCurrentTransform)(V),
                x: T,
                y: I,
                fontSize: G,
                addToPath: se
              });
            }
            get isFontSubpixelAAEnabled() {
              const {
                context: F
              } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
              F.scale(1.5, 1), F.fillText("I", 0, 10);
              const T = F.getImageData(0, 0, 10, 10).data;
              let I = !1;
              for (let M = 3; M < T.length; M += 4)
                if (T[M] > 0 && T[M] < 255) {
                  I = !0;
                  break;
                }
              return (0, re.shadow)(this, "isFontSubpixelAAEnabled", I);
            }
            showText(F) {
              const T = this.current, I = T.font;
              if (I.isType3Font)
                return this.showType3Text(F);
              const M = T.fontSize;
              if (M === 0)
                return;
              const V = this.ctx, J = T.fontSizeScale, W = T.charSpacing, z = T.wordSpacing, G = T.fontDirection, L = T.textHScale * G, K = F.length, te = I.vertical, se = te ? 1 : -1, q = I.defaultVMetrics, N = M * T.fontMatrix[0], Q = T.textRenderingMode === re.TextRenderingMode.FILL && !I.disableFontFace && !T.patternFill;
              V.save(), V.transform(...T.textMatrix), V.translate(T.x, T.y + T.textRise), G > 0 ? V.scale(L, -1) : V.scale(L, 1);
              let D;
              if (T.patternFill) {
                V.save();
                const E = T.fillColor.getPattern(V, this, (0, ce.getCurrentTransformInverse)(V), ae.PathType.FILL);
                D = (0, ce.getCurrentTransform)(V), V.restore(), V.fillStyle = E;
              }
              let ne = T.lineWidth;
              const oe = T.textMatrixScale;
              if (oe === 0 || ne === 0) {
                const E = T.textRenderingMode & re.TextRenderingMode.FILL_STROKE_MASK;
                (E === re.TextRenderingMode.STROKE || E === re.TextRenderingMode.FILL_STROKE) && (ne = this.getSinglePixelWidth());
              } else
                ne /= oe;
              J !== 1 && (V.scale(J, J), ne /= J), V.lineWidth = ne;
              let ee = 0, $;
              for ($ = 0; $ < K; ++$) {
                const E = F[$];
                if (typeof E == "number") {
                  ee += se * E * M / 1e3;
                  continue;
                }
                let H = !1;
                const ie = (E.isSpace ? z : 0) + W, ue = E.fontChar, fe = E.accent;
                let de, pe, xe = E.width;
                if (te) {
                  const Ae = E.vmetric || q, Se = -(E.vmetric ? Ae[1] : xe * 0.5) * N, ke = Ae[2] * N;
                  xe = Ae ? -Ae[0] : xe, de = Se / J, pe = (ee + ke) / J;
                } else
                  de = ee / J, pe = 0;
                if (I.remeasure && xe > 0) {
                  const Ae = V.measureText(ue).width * 1e3 / M * J;
                  if (xe < Ae && this.isFontSubpixelAAEnabled) {
                    const Se = xe / Ae;
                    H = !0, V.save(), V.scale(Se, 1), de /= Se;
                  } else
                    xe !== Ae && (de += (xe - Ae) / 2e3 * M / J);
                }
                if (this.contentVisible && (E.isInFont || I.missingFile)) {
                  if (Q && !fe)
                    V.fillText(ue, de, pe);
                  else if (this.paintChar(ue, de, pe, D), fe) {
                    const Ae = de + M * fe.offset.x / J, Se = pe - M * fe.offset.y / J;
                    this.paintChar(fe.fontChar, Ae, Se, D);
                  }
                }
                let De;
                te ? De = xe * N - ie * G : De = xe * N + ie * G, ee += De, H && V.restore();
              }
              te ? T.y -= ee : T.x += ee * L, V.restore(), this.compose();
            }
            showType3Text(F) {
              const T = this.ctx, I = this.current, M = I.font, V = I.fontSize, J = I.fontDirection, W = M.vertical ? 1 : -1, z = I.charSpacing, G = I.wordSpacing, L = I.textHScale * J, K = I.fontMatrix || re.FONT_IDENTITY_MATRIX, te = F.length, se = I.textRenderingMode === re.TextRenderingMode.INVISIBLE;
              let q, N, Q, D;
              if (!(se || V === 0)) {
                for (this._cachedScaleForStroking = null, this._cachedGetSinglePixelWidth = null, T.save(), T.transform(...I.textMatrix), T.translate(I.x, I.y), T.scale(L, J), q = 0; q < te; ++q) {
                  if (N = F[q], typeof N == "number") {
                    D = W * N * V / 1e3, this.ctx.translate(D, 0), I.x += D * L;
                    continue;
                  }
                  const ne = (N.isSpace ? G : 0) + z, oe = M.charProcOperatorList[N.operatorListId];
                  if (!oe) {
                    (0, re.warn)(`Type3 character "${N.operatorListId}" is not available.`);
                    continue;
                  }
                  this.contentVisible && (this.processingType3 = N, this.save(), T.scale(V, V), T.transform(...K), this.executeOperatorList(oe), this.restore()), Q = re.Util.applyTransform([N.width, 0], K)[0] * V + ne, T.translate(Q, 0), I.x += Q * L;
                }
                T.restore(), this.processingType3 = null;
              }
            }
            setCharWidth(F, T) {
            }
            setCharWidthAndBounds(F, T, I, M, V, J) {
              this.ctx.rect(I, M, V - I, J - M), this.ctx.clip(), this.endPath();
            }
            getColorN_Pattern(F) {
              let T;
              if (F[0] === "TilingPattern") {
                const I = F[1], M = this.baseTransform || (0, ce.getCurrentTransform)(this.ctx), V = {
                  createCanvasGraphics: (J) => new O(J, this.commonObjs, this.objs, this.canvasFactory)
                };
                T = new ae.TilingPattern(F, I, this.ctx, V, M);
              } else
                T = this._getPattern(F[1], F[2]);
              return T;
            }
            setStrokeColorN() {
              this.current.strokeColor = this.getColorN_Pattern(arguments);
            }
            setFillColorN() {
              this.current.fillColor = this.getColorN_Pattern(arguments), this.current.patternFill = !0;
            }
            setStrokeRGBColor(F, T, I) {
              var V;
              const M = ((V = this.selectColor) == null ? void 0 : V.call(this, F, T, I)) || re.Util.makeHexColor(F, T, I);
              this.ctx.strokeStyle = M, this.current.strokeColor = M;
            }
            setFillRGBColor(F, T, I) {
              var V;
              const M = ((V = this.selectColor) == null ? void 0 : V.call(this, F, T, I)) || re.Util.makeHexColor(F, T, I);
              this.ctx.fillStyle = M, this.current.fillColor = M, this.current.patternFill = !1;
            }
            _getPattern(F, T = null) {
              let I;
              return this.cachedPatterns.has(F) ? I = this.cachedPatterns.get(F) : (I = (0, ae.getShadingPattern)(this.objs.get(F)), this.cachedPatterns.set(F, I)), T && (I.matrix = T), I;
            }
            shadingFill(F) {
              if (!this.contentVisible)
                return;
              const T = this.ctx;
              this.save();
              const I = this._getPattern(F);
              T.fillStyle = I.getPattern(T, this, (0, ce.getCurrentTransformInverse)(T), ae.PathType.SHADING);
              const M = (0, ce.getCurrentTransformInverse)(T);
              if (M) {
                const V = T.canvas, J = V.width, W = V.height, z = re.Util.applyTransform([0, 0], M), G = re.Util.applyTransform([0, W], M), L = re.Util.applyTransform([J, 0], M), K = re.Util.applyTransform([J, W], M), te = Math.min(z[0], G[0], L[0], K[0]), se = Math.min(z[1], G[1], L[1], K[1]), q = Math.max(z[0], G[0], L[0], K[0]), N = Math.max(z[1], G[1], L[1], K[1]);
                this.ctx.fillRect(te, se, q - te, N - se);
              } else
                this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
              this.compose(this.current.getClippedPathBoundingBox()), this.restore();
            }
            beginInlineImage() {
              (0, re.unreachable)("Should not call beginInlineImage");
            }
            beginImageData() {
              (0, re.unreachable)("Should not call beginImageData");
            }
            paintFormXObjectBegin(F, T) {
              if (this.contentVisible && (this.save(), this.baseTransformStack.push(this.baseTransform), Array.isArray(F) && F.length === 6 && this.transform(...F), this.baseTransform = (0, ce.getCurrentTransform)(this.ctx), T)) {
                const I = T[2] - T[0], M = T[3] - T[1];
                this.ctx.rect(T[0], T[1], I, M), this.current.updateRectMinMax((0, ce.getCurrentTransform)(this.ctx), T), this.clip(), this.endPath();
              }
            }
            paintFormXObjectEnd() {
              this.contentVisible && (this.restore(), this.baseTransform = this.baseTransformStack.pop());
            }
            beginGroup(F) {
              if (!this.contentVisible)
                return;
              this.save(), this.inSMaskMode && (this.endSMaskMode(), this.current.activeSMask = null);
              const T = this.ctx;
              F.isolated || (0, re.info)("TODO: Support non-isolated groups."), F.knockout && (0, re.warn)("Knockout groups not supported.");
              const I = (0, ce.getCurrentTransform)(T);
              if (F.matrix && T.transform(...F.matrix), !F.bbox)
                throw new Error("Bounding box is required.");
              let M = re.Util.getAxialAlignedBoundingBox(F.bbox, (0, ce.getCurrentTransform)(T));
              const V = [0, 0, T.canvas.width, T.canvas.height];
              M = re.Util.intersect(M, V) || [0, 0, 0, 0];
              const J = Math.floor(M[0]), W = Math.floor(M[1]);
              let z = Math.max(Math.ceil(M[2]) - J, 1), G = Math.max(Math.ceil(M[3]) - W, 1), L = 1, K = 1;
              z > a && (L = z / a, z = a), G > a && (K = G / a, G = a), this.current.startNewPathAndClipBox([0, 0, z, G]);
              let te = "groupAt" + this.groupLevel;
              F.smask && (te += "_smask_" + this.smaskCounter++ % 2);
              const se = this.cachedCanvases.getCanvas(te, z, G), q = se.context;
              q.scale(1 / L, 1 / K), q.translate(-J, -W), q.transform(...I), F.smask ? this.smaskStack.push({
                canvas: se.canvas,
                context: q,
                offsetX: J,
                offsetY: W,
                scaleX: L,
                scaleY: K,
                subtype: F.smask.subtype,
                backdrop: F.smask.backdrop,
                transferMap: F.smask.transferMap || null,
                startTransformInverse: null
              }) : (T.setTransform(1, 0, 0, 1, 0, 0), T.translate(J, W), T.scale(L, K), T.save()), l(T, q), this.ctx = q, this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]), this.groupStack.push(T), this.groupLevel++;
            }
            endGroup(F) {
              if (!this.contentVisible)
                return;
              this.groupLevel--;
              const T = this.ctx, I = this.groupStack.pop();
              if (this.ctx = I, this.ctx.imageSmoothingEnabled = !1, F.smask)
                this.tempSMask = this.smaskStack.pop(), this.restore();
              else {
                this.ctx.restore();
                const M = (0, ce.getCurrentTransform)(this.ctx);
                this.restore(), this.ctx.save(), this.ctx.setTransform(...M);
                const V = re.Util.getAxialAlignedBoundingBox([0, 0, T.canvas.width, T.canvas.height], M);
                this.ctx.drawImage(T.canvas, 0, 0), this.ctx.restore(), this.compose(V);
              }
            }
            beginAnnotation(F, T, I, M, V) {
              if (dt(this, f, oi).call(this), u(this.ctx, this.foregroundColor), this.ctx.save(), this.save(), this.baseTransform && this.ctx.setTransform(...this.baseTransform), Array.isArray(T) && T.length === 4) {
                const J = T[2] - T[0], W = T[3] - T[1];
                if (V && this.annotationCanvasMap) {
                  I = I.slice(), I[4] -= T[0], I[5] -= T[1], T = T.slice(), T[0] = T[1] = 0, T[2] = J, T[3] = W;
                  const [z, G] = re.Util.singularValueDecompose2dScale((0, ce.getCurrentTransform)(this.ctx)), {
                    viewportScale: L
                  } = this, K = Math.ceil(J * this.outputScaleX * L), te = Math.ceil(W * this.outputScaleY * L);
                  this.annotationCanvas = this.canvasFactory.create(K, te);
                  const {
                    canvas: se,
                    context: q
                  } = this.annotationCanvas;
                  this.annotationCanvasMap.set(F, se), this.annotationCanvas.savedCtx = this.ctx, this.ctx = q, this.ctx.setTransform(z, 0, 0, -G, 0, W * G), u(this.ctx, this.foregroundColor);
                } else
                  u(this.ctx, this.foregroundColor), this.ctx.rect(T[0], T[1], J, W), this.ctx.clip(), this.endPath();
              }
              this.current = new g(this.ctx.canvas.width, this.ctx.canvas.height), this.transform(...I), this.transform(...M);
            }
            endAnnotation() {
              this.annotationCanvas && (this.ctx = this.annotationCanvas.savedCtx, delete this.annotationCanvas.savedCtx, delete this.annotationCanvas);
            }
            paintImageMaskXObject(F) {
              if (!this.contentVisible)
                return;
              const T = F.count;
              F = this.getObject(F.data, F), F.count = T;
              const I = this.ctx, M = this.processingType3;
              if (M && (M.compiled === void 0 && (M.compiled = m(F)), M.compiled)) {
                M.compiled(I);
                return;
              }
              const V = this._createMaskCanvas(F), J = V.canvas;
              I.save(), I.setTransform(1, 0, 0, 1, 0, 0), I.drawImage(J, V.offsetX, V.offsetY), I.restore(), this.compose();
            }
            paintImageMaskXObjectRepeat(F, T, I = 0, M = 0, V, J) {
              if (!this.contentVisible)
                return;
              F = this.getObject(F.data, F);
              const W = this.ctx;
              W.save();
              const z = (0, ce.getCurrentTransform)(W);
              W.transform(T, I, M, V, 0, 0);
              const G = this._createMaskCanvas(F);
              W.setTransform(1, 0, 0, 1, 0, 0);
              for (let L = 0, K = J.length; L < K; L += 2) {
                const te = re.Util.transform(z, [T, I, M, V, J[L], J[L + 1]]), [se, q] = re.Util.applyTransform([0, 0], te);
                W.drawImage(G.canvas, se, q);
              }
              W.restore(), this.compose();
            }
            paintImageMaskXObjectGroup(F) {
              if (!this.contentVisible)
                return;
              const T = this.ctx, I = this.current.fillColor, M = this.current.patternFill;
              for (const V of F) {
                const {
                  data: J,
                  width: W,
                  height: z,
                  transform: G
                } = V, L = this.cachedCanvases.getCanvas("maskCanvas", W, z), K = L.context;
                K.save();
                const te = this.getObject(J, V);
                i(K, te), K.globalCompositeOperation = "source-in", K.fillStyle = M ? I.getPattern(K, this, (0, ce.getCurrentTransformInverse)(T), ae.PathType.FILL) : I, K.fillRect(0, 0, W, z), K.restore(), T.save(), T.transform(...G), T.scale(1, -1), p(T, L.canvas, 0, 0, W, z, 0, -1, 1, 1), T.restore();
              }
              this.compose();
            }
            paintImageXObject(F) {
              if (!this.contentVisible)
                return;
              const T = this.getObject(F);
              if (!T) {
                (0, re.warn)("Dependent image isn't ready yet");
                return;
              }
              this.paintInlineImageXObject(T);
            }
            paintImageXObjectRepeat(F, T, I, M) {
              if (!this.contentVisible)
                return;
              const V = this.getObject(F);
              if (!V) {
                (0, re.warn)("Dependent image isn't ready yet");
                return;
              }
              const J = V.width, W = V.height, z = [];
              for (let G = 0, L = M.length; G < L; G += 2)
                z.push({
                  transform: [T, 0, 0, I, M[G], M[G + 1]],
                  x: 0,
                  y: 0,
                  w: J,
                  h: W
                });
              this.paintInlineImageXObjectGroup(V, z);
            }
            paintInlineImageXObject(F) {
              if (!this.contentVisible)
                return;
              const T = F.width, I = F.height, M = this.ctx;
              this.save(), M.scale(1 / T, -1 / I);
              let V;
              if (typeof HTMLElement == "function" && F instanceof HTMLElement || !F.data)
                V = F;
              else {
                const G = this.cachedCanvases.getCanvas("inlineImage", T, I), L = G.context;
                n(L, F, this.current.transferMaps), V = G.canvas;
              }
              const J = this._scaleImage(V, (0, ce.getCurrentTransformInverse)(M));
              M.imageSmoothingEnabled = j((0, ce.getCurrentTransform)(M), F.interpolate);
              const [W, z] = p(M, J.img, 0, 0, J.paintWidth, J.paintHeight, 0, -I, T, I);
              if (this.imageLayer) {
                const [G, L] = re.Util.applyTransform([0, -I], (0, ce.getCurrentTransform)(this.ctx));
                this.imageLayer.appendImage({
                  imgData: F,
                  left: G,
                  top: L,
                  width: W,
                  height: z
                });
              }
              this.compose(), this.restore();
            }
            paintInlineImageXObjectGroup(F, T) {
              if (!this.contentVisible)
                return;
              const I = this.ctx, M = F.width, V = F.height, J = this.cachedCanvases.getCanvas("inlineImage", M, V), W = J.context;
              n(W, F, this.current.transferMaps);
              for (const z of T) {
                if (I.save(), I.transform(...z.transform), I.scale(1, -1), p(I, J.canvas, z.x, z.y, z.w, z.h, 0, -1, 1, 1), this.imageLayer) {
                  const [G, L] = re.Util.applyTransform([z.x, z.y], (0, ce.getCurrentTransform)(this.ctx));
                  this.imageLayer.appendImage({
                    imgData: F,
                    left: G,
                    top: L,
                    width: M,
                    height: V
                  });
                }
                I.restore();
              }
              this.compose();
            }
            paintSolidColorImageMask() {
              this.contentVisible && (this.ctx.fillRect(0, 0, 1, 1), this.compose());
            }
            markPoint(F) {
            }
            markPointProps(F, T) {
            }
            beginMarkedContent(F) {
              this.markedContentStack.push({
                visible: !0
              });
            }
            beginMarkedContentProps(F, T) {
              F === "OC" ? this.markedContentStack.push({
                visible: this.optionalContentConfig.isVisible(T)
              }) : this.markedContentStack.push({
                visible: !0
              }), this.contentVisible = this.isContentVisible();
            }
            endMarkedContent() {
              this.markedContentStack.pop(), this.contentVisible = this.isContentVisible();
            }
            beginCompat() {
            }
            endCompat() {
            }
            consumePath(F) {
              const T = this.current.isEmptyClip();
              this.pendingClip && this.current.updateClipFromPath(), this.pendingClip || this.compose(F);
              const I = this.ctx;
              this.pendingClip && (T || (this.pendingClip === k ? I.clip("evenodd") : I.clip()), this.pendingClip = null), this.current.startNewPathAndClipBox(this.current.clipBox), I.beginPath();
            }
            getSinglePixelWidth() {
              if (!this._cachedGetSinglePixelWidth) {
                const F = (0, ce.getCurrentTransform)(this.ctx);
                if (F[1] === 0 && F[2] === 0)
                  this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(F[0]), Math.abs(F[3]));
                else {
                  const T = Math.abs(F[0] * F[3] - F[2] * F[1]), I = Math.hypot(F[0], F[2]), M = Math.hypot(F[1], F[3]);
                  this._cachedGetSinglePixelWidth = Math.max(I, M) / T;
                }
              }
              return this._cachedGetSinglePixelWidth;
            }
            getScaleForStroking() {
              if (!this._cachedScaleForStroking) {
                const {
                  lineWidth: F
                } = this.current, T = (0, ce.getCurrentTransform)(this.ctx);
                let I, M;
                if (T[1] === 0 && T[2] === 0) {
                  const V = Math.abs(T[0]), J = Math.abs(T[3]);
                  if (F === 0)
                    I = 1 / V, M = 1 / J;
                  else {
                    const W = V * F, z = J * F;
                    I = W < 1 ? 1 / W : 1, M = z < 1 ? 1 / z : 1;
                  }
                } else {
                  const V = Math.abs(T[0] * T[3] - T[2] * T[1]), J = Math.hypot(T[0], T[1]), W = Math.hypot(T[2], T[3]);
                  if (F === 0)
                    I = W / V, M = J / V;
                  else {
                    const z = F * V;
                    I = W > z ? W / z : 1, M = J > z ? J / z : 1;
                  }
                }
                this._cachedScaleForStroking = [I, M];
              }
              return this._cachedScaleForStroking;
            }
            rescaleAndStroke(F) {
              const {
                ctx: T
              } = this, {
                lineWidth: I
              } = this.current, [M, V] = this.getScaleForStroking();
              if (T.lineWidth = I || 1, M === 1 && V === 1) {
                T.stroke();
                return;
              }
              let J, W, z;
              F && (J = (0, ce.getCurrentTransform)(T), W = T.getLineDash().slice(), z = T.lineDashOffset), T.scale(M, V);
              const G = Math.max(M, V);
              T.setLineDash(T.getLineDash().map((L) => L / G)), T.lineDashOffset /= G, T.stroke(), F && (T.setTransform(...J), T.setLineDash(W), T.lineDashOffset = z);
            }
            isContentVisible() {
              for (let F = this.markedContentStack.length - 1; F >= 0; F--)
                if (!this.markedContentStack[F].visible)
                  return !1;
              return !0;
            }
          };
          let x = O;
          f = new WeakSet(), oi = function() {
            for (; this.stateStack.length || this.inSMaskMode; )
              this.restore();
            this.ctx.restore(), this.transparentCanvas && (this.ctx = this.compositeCtx, this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.drawImage(this.transparentCanvas, 0, 0), this.ctx.restore(), this.transparentCanvas = null);
          }, ge.CanvasGraphics = x;
          for (const S in re.OPS)
            x.prototype[S] !== void 0 && (x.prototype[re.OPS[S]] = x.prototype[S]);
        },
        /* 13 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.TilingPattern = ge.PathType = void 0, ge.getShadingPattern = y;
          var ce = le(1), re = le(8), ae = le(3);
          const Z = {
            FILL: "Fill",
            STROKE: "Stroke",
            SHADING: "Shading"
          };
          ge.PathType = Z;
          function o(p, m) {
            if (!m || ae.isNodeJS)
              return;
            const g = m[2] - m[0], n = m[3] - m[1], i = new Path2D();
            i.rect(m[0], m[1], g, n), p.clip(i);
          }
          class C {
            constructor() {
              this.constructor === C && (0, ce.unreachable)("Cannot initialize BaseShadingPattern.");
            }
            getPattern() {
              (0, ce.unreachable)("Abstract method `getPattern` called.");
            }
          }
          class t extends C {
            constructor(m) {
              super(), this._type = m[1], this._bbox = m[2], this._colorStops = m[3], this._p0 = m[4], this._p1 = m[5], this._r0 = m[6], this._r1 = m[7], this.matrix = null;
            }
            _createGradient(m) {
              let g;
              this._type === "axial" ? g = m.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]) : this._type === "radial" && (g = m.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1));
              for (const n of this._colorStops)
                g.addColorStop(n[0], n[1]);
              return g;
            }
            getPattern(m, g, n, i) {
              let l;
              if (i === Z.STROKE || i === Z.FILL) {
                const u = g.current.getClippedPathBoundingBox(i, (0, re.getCurrentTransform)(m)) || [0, 0, 0, 0], w = Math.ceil(u[2] - u[0]) || 1, _ = Math.ceil(u[3] - u[1]) || 1, b = g.cachedCanvases.getCanvas("pattern", w, _, !0), A = b.context;
                A.clearRect(0, 0, A.canvas.width, A.canvas.height), A.beginPath(), A.rect(0, 0, A.canvas.width, A.canvas.height), A.translate(-u[0], -u[1]), n = ce.Util.transform(n, [1, 0, 0, 1, u[0], u[1]]), A.transform(...g.baseTransform), this.matrix && A.transform(...this.matrix), o(A, this._bbox), A.fillStyle = this._createGradient(A), A.fill(), l = m.createPattern(b.canvas, "no-repeat");
                const Y = new DOMMatrix(n);
                try {
                  l.setTransform(Y);
                } catch (j) {
                  (0, ce.warn)(`RadialAxialShadingPattern.getPattern: "${j == null ? void 0 : j.message}".`);
                }
              } else
                o(m, this._bbox), l = this._createGradient(m);
              return l;
            }
          }
          function a(p, m, g, n, i, l, u, w) {
            const _ = m.coords, b = m.colors, A = p.data, Y = p.width * 4;
            let j;
            _[g + 1] > _[n + 1] && (j = g, g = n, n = j, j = l, l = u, u = j), _[n + 1] > _[i + 1] && (j = n, n = i, i = j, j = u, u = w, w = j), _[g + 1] > _[n + 1] && (j = g, g = n, n = j, j = l, l = u, u = j);
            const X = (_[g] + m.offsetX) * m.scaleX, B = (_[g + 1] + m.offsetY) * m.scaleY, R = (_[n] + m.offsetX) * m.scaleX, k = (_[n + 1] + m.offsetY) * m.scaleY, x = (_[i] + m.offsetX) * m.scaleX, f = (_[i + 1] + m.offsetY) * m.scaleY;
            if (B >= f)
              return;
            const U = b[l], O = b[l + 1], S = b[l + 2], F = b[u], T = b[u + 1], I = b[u + 2], M = b[w], V = b[w + 1], J = b[w + 2], W = Math.round(B), z = Math.round(f);
            let G, L, K, te, se, q, N, Q;
            for (let D = W; D <= z; D++) {
              if (D < k) {
                let E;
                D < B ? E = 0 : E = (B - D) / (B - k), G = X - (X - R) * E, L = U - (U - F) * E, K = O - (O - T) * E, te = S - (S - I) * E;
              } else {
                let E;
                D > f ? E = 1 : k === f ? E = 0 : E = (k - D) / (k - f), G = R - (R - x) * E, L = F - (F - M) * E, K = T - (T - V) * E, te = I - (I - J) * E;
              }
              let ne;
              D < B ? ne = 0 : D > f ? ne = 1 : ne = (B - D) / (B - f), se = X - (X - x) * ne, q = U - (U - M) * ne, N = O - (O - V) * ne, Q = S - (S - J) * ne;
              const oe = Math.round(Math.min(G, se)), ee = Math.round(Math.max(G, se));
              let $ = Y * D + oe * 4;
              for (let E = oe; E <= ee; E++)
                ne = (G - E) / (G - se), ne < 0 ? ne = 0 : ne > 1 && (ne = 1), A[$++] = L - (L - q) * ne | 0, A[$++] = K - (K - N) * ne | 0, A[$++] = te - (te - Q) * ne | 0, A[$++] = 255;
            }
          }
          function v(p, m, g) {
            const n = m.coords, i = m.colors;
            let l, u;
            switch (m.type) {
              case "lattice":
                const w = m.verticesPerRow, _ = Math.floor(n.length / w) - 1, b = w - 1;
                for (l = 0; l < _; l++) {
                  let A = l * w;
                  for (let Y = 0; Y < b; Y++, A++)
                    a(p, g, n[A], n[A + 1], n[A + w], i[A], i[A + 1], i[A + w]), a(p, g, n[A + w + 1], n[A + 1], n[A + w], i[A + w + 1], i[A + 1], i[A + w]);
                }
                break;
              case "triangles":
                for (l = 0, u = n.length; l < u; l += 3)
                  a(p, g, n[l], n[l + 1], n[l + 2], i[l], i[l + 1], i[l + 2]);
                break;
              default:
                throw new Error("illegal figure");
            }
          }
          class h extends C {
            constructor(m) {
              super(), this._coords = m[2], this._colors = m[3], this._figures = m[4], this._bounds = m[5], this._bbox = m[7], this._background = m[8], this.matrix = null;
            }
            _createMeshCanvas(m, g, n) {
              const w = Math.floor(this._bounds[0]), _ = Math.floor(this._bounds[1]), b = Math.ceil(this._bounds[2]) - w, A = Math.ceil(this._bounds[3]) - _, Y = Math.min(Math.ceil(Math.abs(b * m[0] * 1.1)), 3e3), j = Math.min(Math.ceil(Math.abs(A * m[1] * 1.1)), 3e3), X = b / Y, B = A / j, R = {
                coords: this._coords,
                colors: this._colors,
                offsetX: -w,
                offsetY: -_,
                scaleX: 1 / X,
                scaleY: 1 / B
              }, k = Y + 2 * 2, x = j + 2 * 2, f = n.getCanvas("mesh", k, x, !1), U = f.context, O = U.createImageData(Y, j);
              if (g) {
                const F = O.data;
                for (let T = 0, I = F.length; T < I; T += 4)
                  F[T] = g[0], F[T + 1] = g[1], F[T + 2] = g[2], F[T + 3] = 255;
              }
              for (const F of this._figures)
                v(O, F, R);
              return U.putImageData(O, 2, 2), {
                canvas: f.canvas,
                offsetX: w - 2 * X,
                offsetY: _ - 2 * B,
                scaleX: X,
                scaleY: B
              };
            }
            getPattern(m, g, n, i) {
              o(m, this._bbox);
              let l;
              if (i === Z.SHADING)
                l = ce.Util.singularValueDecompose2dScale((0, re.getCurrentTransform)(m));
              else if (l = ce.Util.singularValueDecompose2dScale(g.baseTransform), this.matrix) {
                const w = ce.Util.singularValueDecompose2dScale(this.matrix);
                l = [l[0] * w[0], l[1] * w[1]];
              }
              const u = this._createMeshCanvas(l, i === Z.SHADING ? null : this._background, g.cachedCanvases);
              return i !== Z.SHADING && (m.setTransform(...g.baseTransform), this.matrix && m.transform(...this.matrix)), m.translate(u.offsetX, u.offsetY), m.scale(u.scaleX, u.scaleY), m.createPattern(u.canvas, "no-repeat");
            }
          }
          class e extends C {
            getPattern() {
              return "hotpink";
            }
          }
          function y(p) {
            switch (p[0]) {
              case "RadialAxial":
                return new t(p);
              case "Mesh":
                return new h(p);
              case "Dummy":
                return new e();
            }
            throw new Error(`Unknown IR type: ${p[0]}`);
          }
          const c = {
            COLORED: 1,
            UNCOLORED: 2
          };
          class d {
            static get MAX_PATTERN_SIZE() {
              return (0, ce.shadow)(this, "MAX_PATTERN_SIZE", 3e3);
            }
            constructor(m, g, n, i, l) {
              this.operatorList = m[2], this.matrix = m[3] || [1, 0, 0, 1, 0, 0], this.bbox = m[4], this.xstep = m[5], this.ystep = m[6], this.paintType = m[7], this.tilingType = m[8], this.color = g, this.ctx = n, this.canvasGraphicsFactory = i, this.baseTransform = l;
            }
            createPatternCanvas(m) {
              const g = this.operatorList, n = this.bbox, i = this.xstep, l = this.ystep, u = this.paintType, w = this.tilingType, _ = this.color, b = this.canvasGraphicsFactory;
              (0, ce.info)("TilingType: " + w);
              const A = n[0], Y = n[1], j = n[2], X = n[3], B = ce.Util.singularValueDecompose2dScale(this.matrix), R = ce.Util.singularValueDecompose2dScale(this.baseTransform), k = [B[0] * R[0], B[1] * R[1]], x = this.getSizeAndScale(i, this.ctx.canvas.width, k[0]), f = this.getSizeAndScale(l, this.ctx.canvas.height, k[1]), U = m.cachedCanvases.getCanvas("pattern", x.size, f.size, !0), O = U.context, S = b.createCanvasGraphics(O);
              S.groupLevel = m.groupLevel, this.setFillAndStrokeStyleToContext(S, u, _);
              let F = A, T = Y, I = j, M = X;
              return A < 0 && (F = 0, I += Math.abs(A)), Y < 0 && (T = 0, M += Math.abs(Y)), O.translate(-(x.scale * F), -(f.scale * T)), S.transform(x.scale, 0, 0, f.scale, 0, 0), O.save(), this.clipBbox(S, F, T, I, M), S.baseTransform = (0, re.getCurrentTransform)(S.ctx), S.executeOperatorList(g), S.endDrawing(), {
                canvas: U.canvas,
                scaleX: x.scale,
                scaleY: f.scale,
                offsetX: F,
                offsetY: T
              };
            }
            getSizeAndScale(m, g, n) {
              m = Math.abs(m);
              const i = Math.max(d.MAX_PATTERN_SIZE, g);
              let l = Math.ceil(m * n);
              return l >= i ? l = i : n = l / m, {
                scale: n,
                size: l
              };
            }
            clipBbox(m, g, n, i, l) {
              const u = i - g, w = l - n;
              m.ctx.rect(g, n, u, w), m.current.updateRectMinMax((0, re.getCurrentTransform)(m.ctx), [g, n, i, l]), m.clip(), m.endPath();
            }
            setFillAndStrokeStyleToContext(m, g, n) {
              const i = m.ctx, l = m.current;
              switch (g) {
                case c.COLORED:
                  const u = this.ctx;
                  i.fillStyle = u.fillStyle, i.strokeStyle = u.strokeStyle, l.fillColor = u.fillStyle, l.strokeColor = u.strokeStyle;
                  break;
                case c.UNCOLORED:
                  const w = ce.Util.makeHexColor(n[0], n[1], n[2]);
                  i.fillStyle = w, i.strokeStyle = w, l.fillColor = w, l.strokeColor = w;
                  break;
                default:
                  throw new ce.FormatError(`Unsupported paint type: ${g}`);
              }
            }
            getPattern(m, g, n, i) {
              let l = n;
              i !== Z.SHADING && (l = ce.Util.transform(l, g.baseTransform), this.matrix && (l = ce.Util.transform(l, this.matrix)));
              const u = this.createPatternCanvas(g);
              let w = new DOMMatrix(l);
              w = w.translate(u.offsetX, u.offsetY), w = w.scale(1 / u.scaleX, 1 / u.scaleY);
              const _ = m.createPattern(u.canvas, "repeat");
              try {
                _.setTransform(w);
              } catch (b) {
                (0, ce.warn)(`TilingPattern.getPattern: "${b == null ? void 0 : b.message}".`);
              }
              return _;
            }
          }
          ge.TilingPattern = d;
        },
        /* 14 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.applyMaskImageData = re;
          var ce = le(1);
          function re({
            src: ae,
            srcPos: Z = 0,
            dest: o,
            destPos: C = 0,
            width: t,
            height: a,
            inverseDecode: v = !1
          }) {
            const h = ce.FeatureTest.isLittleEndian ? 4278190080 : 255, [e, y] = v ? [0, h] : [h, 0], c = t >> 3, d = t & 7, p = ae.length;
            o = new Uint32Array(o.buffer);
            for (let m = 0; m < a; m++) {
              for (const n = Z + c; Z < n; Z++) {
                const i = Z < p ? ae[Z] : 255;
                o[C++] = i & 128 ? y : e, o[C++] = i & 64 ? y : e, o[C++] = i & 32 ? y : e, o[C++] = i & 16 ? y : e, o[C++] = i & 8 ? y : e, o[C++] = i & 4 ? y : e, o[C++] = i & 2 ? y : e, o[C++] = i & 1 ? y : e;
              }
              if (d === 0)
                continue;
              const g = Z < p ? ae[Z++] : 255;
              for (let n = 0; n < d; n++)
                o[C++] = g & 1 << 7 - n ? y : e;
            }
            return {
              srcPos: Z,
              destPos: C
            };
          }
        },
        /* 15 */
        /***/
        (be, ge) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.GlobalWorkerOptions = void 0;
          const le = /* @__PURE__ */ Object.create(null);
          ge.GlobalWorkerOptions = le, le.workerPort = le.workerPort === void 0 ? null : le.workerPort, le.workerSrc = le.workerSrc === void 0 ? "" : le.workerSrc;
        },
        /* 16 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.MessageHandler = void 0;
          var ce = le(1);
          const re = {
            UNKNOWN: 0,
            DATA: 1,
            ERROR: 2
          }, ae = {
            UNKNOWN: 0,
            CANCEL: 1,
            CANCEL_COMPLETE: 2,
            CLOSE: 3,
            ENQUEUE: 4,
            ERROR: 5,
            PULL: 6,
            PULL_COMPLETE: 7,
            START_COMPLETE: 8
          };
          function Z(C) {
            switch (C instanceof Error || typeof C == "object" && C !== null || (0, ce.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), C.name) {
              case "AbortException":
                return new ce.AbortException(C.message);
              case "MissingPDFException":
                return new ce.MissingPDFException(C.message);
              case "PasswordException":
                return new ce.PasswordException(C.message, C.code);
              case "UnexpectedResponseException":
                return new ce.UnexpectedResponseException(C.message, C.status);
              case "UnknownErrorException":
                return new ce.UnknownErrorException(C.message, C.details);
              default:
                return new ce.UnknownErrorException(C.message, C.toString());
            }
          }
          class o {
            constructor(t, a, v) {
              this.sourceName = t, this.targetName = a, this.comObj = v, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), this._onComObjOnMessage = (h) => {
                const e = h.data;
                if (e.targetName !== this.sourceName)
                  return;
                if (e.stream) {
                  this._processStreamMessage(e);
                  return;
                }
                if (e.callback) {
                  const c = e.callbackId, d = this.callbackCapabilities[c];
                  if (!d)
                    throw new Error(`Cannot resolve callback ${c}`);
                  if (delete this.callbackCapabilities[c], e.callback === re.DATA)
                    d.resolve(e.data);
                  else if (e.callback === re.ERROR)
                    d.reject(Z(e.reason));
                  else
                    throw new Error("Unexpected callback case");
                  return;
                }
                const y = this.actionHandler[e.action];
                if (!y)
                  throw new Error(`Unknown action from worker: ${e.action}`);
                if (e.callbackId) {
                  const c = this.sourceName, d = e.sourceName;
                  new Promise(function(p) {
                    p(y(e.data));
                  }).then(function(p) {
                    v.postMessage({
                      sourceName: c,
                      targetName: d,
                      callback: re.DATA,
                      callbackId: e.callbackId,
                      data: p
                    });
                  }, function(p) {
                    v.postMessage({
                      sourceName: c,
                      targetName: d,
                      callback: re.ERROR,
                      callbackId: e.callbackId,
                      reason: Z(p)
                    });
                  });
                  return;
                }
                if (e.streamId) {
                  this._createStreamSink(e);
                  return;
                }
                y(e.data);
              }, v.addEventListener("message", this._onComObjOnMessage);
            }
            on(t, a) {
              const v = this.actionHandler;
              if (v[t])
                throw new Error(`There is already an actionName called "${t}"`);
              v[t] = a;
            }
            send(t, a, v) {
              this.comObj.postMessage({
                sourceName: this.sourceName,
                targetName: this.targetName,
                action: t,
                data: a
              }, v);
            }
            sendWithPromise(t, a, v) {
              const h = this.callbackId++, e = (0, ce.createPromiseCapability)();
              this.callbackCapabilities[h] = e;
              try {
                this.comObj.postMessage({
                  sourceName: this.sourceName,
                  targetName: this.targetName,
                  action: t,
                  callbackId: h,
                  data: a
                }, v);
              } catch (y) {
                e.reject(y);
              }
              return e.promise;
            }
            sendWithStream(t, a, v, h) {
              const e = this.streamId++, y = this.sourceName, c = this.targetName, d = this.comObj;
              return new ReadableStream({
                start: (p) => {
                  const m = (0, ce.createPromiseCapability)();
                  return this.streamControllers[e] = {
                    controller: p,
                    startCall: m,
                    pullCall: null,
                    cancelCall: null,
                    isClosed: !1
                  }, d.postMessage({
                    sourceName: y,
                    targetName: c,
                    action: t,
                    streamId: e,
                    data: a,
                    desiredSize: p.desiredSize
                  }, h), m.promise;
                },
                pull: (p) => {
                  const m = (0, ce.createPromiseCapability)();
                  return this.streamControllers[e].pullCall = m, d.postMessage({
                    sourceName: y,
                    targetName: c,
                    stream: ae.PULL,
                    streamId: e,
                    desiredSize: p.desiredSize
                  }), m.promise;
                },
                cancel: (p) => {
                  (0, ce.assert)(p instanceof Error, "cancel must have a valid reason");
                  const m = (0, ce.createPromiseCapability)();
                  return this.streamControllers[e].cancelCall = m, this.streamControllers[e].isClosed = !0, d.postMessage({
                    sourceName: y,
                    targetName: c,
                    stream: ae.CANCEL,
                    streamId: e,
                    reason: Z(p)
                  }), m.promise;
                }
              }, v);
            }
            _createStreamSink(t) {
              const a = t.streamId, v = this.sourceName, h = t.sourceName, e = this.comObj, y = this, c = this.actionHandler[t.action], d = {
                enqueue(p, m = 1, g) {
                  if (this.isCancelled)
                    return;
                  const n = this.desiredSize;
                  this.desiredSize -= m, n > 0 && this.desiredSize <= 0 && (this.sinkCapability = (0, ce.createPromiseCapability)(), this.ready = this.sinkCapability.promise), e.postMessage({
                    sourceName: v,
                    targetName: h,
                    stream: ae.ENQUEUE,
                    streamId: a,
                    chunk: p
                  }, g);
                },
                close() {
                  this.isCancelled || (this.isCancelled = !0, e.postMessage({
                    sourceName: v,
                    targetName: h,
                    stream: ae.CLOSE,
                    streamId: a
                  }), delete y.streamSinks[a]);
                },
                error(p) {
                  (0, ce.assert)(p instanceof Error, "error must have a valid reason"), !this.isCancelled && (this.isCancelled = !0, e.postMessage({
                    sourceName: v,
                    targetName: h,
                    stream: ae.ERROR,
                    streamId: a,
                    reason: Z(p)
                  }));
                },
                sinkCapability: (0, ce.createPromiseCapability)(),
                onPull: null,
                onCancel: null,
                isCancelled: !1,
                desiredSize: t.desiredSize,
                ready: null
              };
              d.sinkCapability.resolve(), d.ready = d.sinkCapability.promise, this.streamSinks[a] = d, new Promise(function(p) {
                p(c(t.data, d));
              }).then(function() {
                e.postMessage({
                  sourceName: v,
                  targetName: h,
                  stream: ae.START_COMPLETE,
                  streamId: a,
                  success: !0
                });
              }, function(p) {
                e.postMessage({
                  sourceName: v,
                  targetName: h,
                  stream: ae.START_COMPLETE,
                  streamId: a,
                  reason: Z(p)
                });
              });
            }
            _processStreamMessage(t) {
              const a = t.streamId, v = this.sourceName, h = t.sourceName, e = this.comObj, y = this.streamControllers[a], c = this.streamSinks[a];
              switch (t.stream) {
                case ae.START_COMPLETE:
                  t.success ? y.startCall.resolve() : y.startCall.reject(Z(t.reason));
                  break;
                case ae.PULL_COMPLETE:
                  t.success ? y.pullCall.resolve() : y.pullCall.reject(Z(t.reason));
                  break;
                case ae.PULL:
                  if (!c) {
                    e.postMessage({
                      sourceName: v,
                      targetName: h,
                      stream: ae.PULL_COMPLETE,
                      streamId: a,
                      success: !0
                    });
                    break;
                  }
                  c.desiredSize <= 0 && t.desiredSize > 0 && c.sinkCapability.resolve(), c.desiredSize = t.desiredSize, new Promise(function(d) {
                    d(c.onPull && c.onPull());
                  }).then(function() {
                    e.postMessage({
                      sourceName: v,
                      targetName: h,
                      stream: ae.PULL_COMPLETE,
                      streamId: a,
                      success: !0
                    });
                  }, function(d) {
                    e.postMessage({
                      sourceName: v,
                      targetName: h,
                      stream: ae.PULL_COMPLETE,
                      streamId: a,
                      reason: Z(d)
                    });
                  });
                  break;
                case ae.ENQUEUE:
                  if ((0, ce.assert)(y, "enqueue should have stream controller"), y.isClosed)
                    break;
                  y.controller.enqueue(t.chunk);
                  break;
                case ae.CLOSE:
                  if ((0, ce.assert)(y, "close should have stream controller"), y.isClosed)
                    break;
                  y.isClosed = !0, y.controller.close(), this._deleteStreamController(y, a);
                  break;
                case ae.ERROR:
                  (0, ce.assert)(y, "error should have stream controller"), y.controller.error(Z(t.reason)), this._deleteStreamController(y, a);
                  break;
                case ae.CANCEL_COMPLETE:
                  t.success ? y.cancelCall.resolve() : y.cancelCall.reject(Z(t.reason)), this._deleteStreamController(y, a);
                  break;
                case ae.CANCEL:
                  if (!c)
                    break;
                  new Promise(function(d) {
                    d(c.onCancel && c.onCancel(Z(t.reason)));
                  }).then(function() {
                    e.postMessage({
                      sourceName: v,
                      targetName: h,
                      stream: ae.CANCEL_COMPLETE,
                      streamId: a,
                      success: !0
                    });
                  }, function(d) {
                    e.postMessage({
                      sourceName: v,
                      targetName: h,
                      stream: ae.CANCEL_COMPLETE,
                      streamId: a,
                      reason: Z(d)
                    });
                  }), c.sinkCapability.reject(Z(t.reason)), c.isCancelled = !0, delete this.streamSinks[a];
                  break;
                default:
                  throw new Error("Unexpected stream case");
              }
            }
            async _deleteStreamController(t, a) {
              await Promise.allSettled([t.startCall && t.startCall.promise, t.pullCall && t.pullCall.promise, t.cancelCall && t.cancelCall.promise]), delete this.streamControllers[a];
            }
            destroy() {
              this.comObj.removeEventListener("message", this._onComObjOnMessage);
            }
          }
          ge.MessageHandler = o;
        },
        /* 17 */
        /***/
        (be, ge, le) => {
          var ae, Z;
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.Metadata = void 0;
          var ce = le(1);
          class re {
            constructor({
              parsedData: C,
              rawData: t
            }) {
              ot(this, ae, void 0);
              ot(this, Z, void 0);
              vt(this, ae, C), vt(this, Z, t);
            }
            getRaw() {
              return Oe(this, Z);
            }
            get(C) {
              return Oe(this, ae).get(C) ?? null;
            }
            getAll() {
              return (0, ce.objectFromMap)(Oe(this, ae));
            }
            has(C) {
              return Oe(this, ae).has(C);
            }
          }
          ae = new WeakMap(), Z = new WeakMap(), ge.Metadata = re;
        },
        /* 18 */
        /***/
        (be, ge, le) => {
          var o, C, t, a, v, h, ci;
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.OptionalContentConfig = void 0;
          var ce = le(1);
          const re = Symbol("INTERNAL");
          class ae {
            constructor(c, d) {
              ot(this, o, !0);
              this.name = c, this.intent = d;
            }
            get visible() {
              return Oe(this, o);
            }
            _setVisible(c, d) {
              c !== re && (0, ce.unreachable)("Internal method `_setVisible` called."), vt(this, o, d);
            }
          }
          o = new WeakMap();
          class Z {
            constructor(c) {
              ot(this, h);
              ot(this, C, !0);
              ot(this, t, /* @__PURE__ */ new Map());
              ot(this, a, null);
              ot(this, v, null);
              if (this.name = null, this.creator = null, c !== null) {
                this.name = c.name, this.creator = c.creator, vt(this, v, c.order);
                for (const d of c.groups)
                  Oe(this, t).set(d.id, new ae(d.name, d.intent));
                if (c.baseState === "OFF")
                  for (const d of Oe(this, t).values())
                    d._setVisible(re, !1);
                for (const d of c.on)
                  Oe(this, t).get(d)._setVisible(re, !0);
                for (const d of c.off)
                  Oe(this, t).get(d)._setVisible(re, !1);
                vt(this, a, /* @__PURE__ */ new Map());
                for (const [d, p] of Oe(this, t))
                  Oe(this, a).set(d, p.visible);
              }
            }
            isVisible(c) {
              if (Oe(this, t).size === 0)
                return !0;
              if (!c)
                return (0, ce.warn)("Optional content group not defined."), !0;
              if (c.type === "OCG")
                return Oe(this, t).has(c.id) ? Oe(this, t).get(c.id).visible : ((0, ce.warn)(`Optional content group not found: ${c.id}`), !0);
              if (c.type === "OCMD") {
                if (c.expression)
                  return dt(this, h, ci).call(this, c.expression);
                if (!c.policy || c.policy === "AnyOn") {
                  for (const d of c.ids) {
                    if (!Oe(this, t).has(d))
                      return (0, ce.warn)(`Optional content group not found: ${d}`), !0;
                    if (Oe(this, t).get(d).visible)
                      return !0;
                  }
                  return !1;
                } else if (c.policy === "AllOn") {
                  for (const d of c.ids) {
                    if (!Oe(this, t).has(d))
                      return (0, ce.warn)(`Optional content group not found: ${d}`), !0;
                    if (!Oe(this, t).get(d).visible)
                      return !1;
                  }
                  return !0;
                } else if (c.policy === "AnyOff") {
                  for (const d of c.ids) {
                    if (!Oe(this, t).has(d))
                      return (0, ce.warn)(`Optional content group not found: ${d}`), !0;
                    if (!Oe(this, t).get(d).visible)
                      return !0;
                  }
                  return !1;
                } else if (c.policy === "AllOff") {
                  for (const d of c.ids) {
                    if (!Oe(this, t).has(d))
                      return (0, ce.warn)(`Optional content group not found: ${d}`), !0;
                    if (Oe(this, t).get(d).visible)
                      return !1;
                  }
                  return !0;
                }
                return (0, ce.warn)(`Unknown optional content policy ${c.policy}.`), !0;
              }
              return (0, ce.warn)(`Unknown group type ${c.type}.`), !0;
            }
            setVisibility(c, d = !0) {
              if (!Oe(this, t).has(c)) {
                (0, ce.warn)(`Optional content group not found: ${c}`);
                return;
              }
              Oe(this, t).get(c)._setVisible(re, !!d), vt(this, C, null);
            }
            get hasInitialVisibility() {
              if (Oe(this, C) !== null)
                return Oe(this, C);
              for (const [c, d] of Oe(this, t)) {
                const p = Oe(this, a).get(c);
                if (d.visible !== p)
                  return vt(this, C, !1);
              }
              return vt(this, C, !0);
            }
            getOrder() {
              return Oe(this, t).size ? Oe(this, v) ? Oe(this, v).slice() : [...Oe(this, t).keys()] : null;
            }
            getGroups() {
              return Oe(this, t).size > 0 ? (0, ce.objectFromMap)(Oe(this, t)) : null;
            }
            getGroup(c) {
              return Oe(this, t).get(c) || null;
            }
          }
          C = new WeakMap(), t = new WeakMap(), a = new WeakMap(), v = new WeakMap(), h = new WeakSet(), ci = function(c) {
            const d = c.length;
            if (d < 2)
              return !0;
            const p = c[0];
            for (let m = 1; m < d; m++) {
              const g = c[m];
              let n;
              if (Array.isArray(g))
                n = dt(this, h, ci).call(this, g);
              else if (Oe(this, t).has(g))
                n = Oe(this, t).get(g).visible;
              else
                return (0, ce.warn)(`Optional content group not found: ${g}`), !0;
              switch (p) {
                case "And":
                  if (!n)
                    return !1;
                  break;
                case "Or":
                  if (n)
                    return !0;
                  break;
                case "Not":
                  return !n;
                default:
                  return !0;
              }
            }
            return p === "And";
          }, ge.OptionalContentConfig = Z;
        },
        /* 19 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.PDFDataTransportStream = void 0;
          var ce = le(1), re = le(8);
          class ae {
            constructor(t, a) {
              (0, ce.assert)(a, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.'), this._queuedChunks = [], this._progressiveDone = t.progressiveDone || !1, this._contentDispositionFilename = t.contentDispositionFilename || null;
              const v = t.initialData;
              if ((v == null ? void 0 : v.length) > 0) {
                const h = new Uint8Array(v).buffer;
                this._queuedChunks.push(h);
              }
              this._pdfDataRangeTransport = a, this._isStreamingSupported = !t.disableStream, this._isRangeSupported = !t.disableRange, this._contentLength = t.length, this._fullRequestReader = null, this._rangeReaders = [], this._pdfDataRangeTransport.addRangeListener((h, e) => {
                this._onReceiveData({
                  begin: h,
                  chunk: e
                });
              }), this._pdfDataRangeTransport.addProgressListener((h, e) => {
                this._onProgress({
                  loaded: h,
                  total: e
                });
              }), this._pdfDataRangeTransport.addProgressiveReadListener((h) => {
                this._onReceiveData({
                  chunk: h
                });
              }), this._pdfDataRangeTransport.addProgressiveDoneListener(() => {
                this._onProgressiveDone();
              }), this._pdfDataRangeTransport.transportReady();
            }
            _onReceiveData(t) {
              const a = new Uint8Array(t.chunk).buffer;
              if (t.begin === void 0)
                this._fullRequestReader ? this._fullRequestReader._enqueue(a) : this._queuedChunks.push(a);
              else {
                const v = this._rangeReaders.some(function(h) {
                  return h._begin !== t.begin ? !1 : (h._enqueue(a), !0);
                });
                (0, ce.assert)(v, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
              }
            }
            get _progressiveDataLength() {
              var t;
              return ((t = this._fullRequestReader) == null ? void 0 : t._loaded) ?? 0;
            }
            _onProgress(t) {
              if (t.total === void 0) {
                const a = this._rangeReaders[0];
                a != null && a.onProgress && a.onProgress({
                  loaded: t.loaded
                });
              } else {
                const a = this._fullRequestReader;
                a != null && a.onProgress && a.onProgress({
                  loaded: t.loaded,
                  total: t.total
                });
              }
            }
            _onProgressiveDone() {
              this._fullRequestReader && this._fullRequestReader.progressiveDone(), this._progressiveDone = !0;
            }
            _removeRangeReader(t) {
              const a = this._rangeReaders.indexOf(t);
              a >= 0 && this._rangeReaders.splice(a, 1);
            }
            getFullReader() {
              (0, ce.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
              const t = this._queuedChunks;
              return this._queuedChunks = null, new Z(this, t, this._progressiveDone, this._contentDispositionFilename);
            }
            getRangeReader(t, a) {
              if (a <= this._progressiveDataLength)
                return null;
              const v = new o(this, t, a);
              return this._pdfDataRangeTransport.requestDataRange(t, a), this._rangeReaders.push(v), v;
            }
            cancelAllRequests(t) {
              this._fullRequestReader && this._fullRequestReader.cancel(t);
              for (const a of this._rangeReaders.slice(0))
                a.cancel(t);
              this._pdfDataRangeTransport.abort();
            }
          }
          ge.PDFDataTransportStream = ae;
          class Z {
            constructor(t, a, v = !1, h = null) {
              this._stream = t, this._done = v || !1, this._filename = (0, re.isPdfFile)(h) ? h : null, this._queuedChunks = a || [], this._loaded = 0;
              for (const e of this._queuedChunks)
                this._loaded += e.byteLength;
              this._requests = [], this._headersReady = Promise.resolve(), t._fullRequestReader = this, this.onProgress = null;
            }
            _enqueue(t) {
              this._done || (this._requests.length > 0 ? this._requests.shift().resolve({
                value: t,
                done: !1
              }) : this._queuedChunks.push(t), this._loaded += t.byteLength);
            }
            get headersReady() {
              return this._headersReady;
            }
            get filename() {
              return this._filename;
            }
            get isRangeSupported() {
              return this._stream._isRangeSupported;
            }
            get isStreamingSupported() {
              return this._stream._isStreamingSupported;
            }
            get contentLength() {
              return this._stream._contentLength;
            }
            async read() {
              if (this._queuedChunks.length > 0)
                return {
                  value: this._queuedChunks.shift(),
                  done: !1
                };
              if (this._done)
                return {
                  value: void 0,
                  done: !0
                };
              const t = (0, ce.createPromiseCapability)();
              return this._requests.push(t), t.promise;
            }
            cancel(t) {
              this._done = !0;
              for (const a of this._requests)
                a.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0;
            }
            progressiveDone() {
              this._done || (this._done = !0);
            }
          }
          class o {
            constructor(t, a, v) {
              this._stream = t, this._begin = a, this._end = v, this._queuedChunk = null, this._requests = [], this._done = !1, this.onProgress = null;
            }
            _enqueue(t) {
              if (!this._done) {
                if (this._requests.length === 0)
                  this._queuedChunk = t;
                else {
                  this._requests.shift().resolve({
                    value: t,
                    done: !1
                  });
                  for (const v of this._requests)
                    v.resolve({
                      value: void 0,
                      done: !0
                    });
                  this._requests.length = 0;
                }
                this._done = !0, this._stream._removeRangeReader(this);
              }
            }
            get isStreamingSupported() {
              return !1;
            }
            async read() {
              if (this._queuedChunk) {
                const a = this._queuedChunk;
                return this._queuedChunk = null, {
                  value: a,
                  done: !1
                };
              }
              if (this._done)
                return {
                  value: void 0,
                  done: !0
                };
              const t = (0, ce.createPromiseCapability)();
              return this._requests.push(t), t.promise;
            }
            cancel(t) {
              this._done = !0;
              for (const a of this._requests)
                a.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0, this._stream._removeRangeReader(this);
            }
          }
        },
        /* 20 */
        /***/
        (be, ge) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.XfaText = void 0;
          class le {
            static textContent(re) {
              const ae = [], Z = {
                items: ae,
                styles: /* @__PURE__ */ Object.create(null)
              };
              function o(C) {
                var v;
                if (!C)
                  return;
                let t = null;
                const a = C.name;
                if (a === "#text")
                  t = C.value;
                else if (le.shouldBuildText(a))
                  (v = C == null ? void 0 : C.attributes) != null && v.textContent ? t = C.attributes.textContent : C.value && (t = C.value);
                else
                  return;
                if (t !== null && ae.push({
                  str: t
                }), !!C.children)
                  for (const h of C.children)
                    o(h);
              }
              return o(re), Z;
            }
            static shouldBuildText(re) {
              return !(re === "textarea" || re === "input" || re === "option" || re === "select");
            }
          }
          ge.XfaText = le;
        },
        /* 21 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.NodeStandardFontDataFactory = ge.NodeCanvasFactory = ge.NodeCMapReaderFactory = void 0;
          var ce = le(9);
          const re = function(C) {
            return new Promise((t, a) => {
              require$$5.readFile(C, (h, e) => {
                if (h || !e) {
                  a(new Error(h));
                  return;
                }
                t(new Uint8Array(e));
              });
            });
          };
          class ae extends ce.BaseCanvasFactory {
            _createCanvas(t, a) {
              return require$$5.createCanvas(t, a);
            }
          }
          ge.NodeCanvasFactory = ae;
          class Z extends ce.BaseCMapReaderFactory {
            _fetchData(t, a) {
              return re(t).then((v) => ({
                cMapData: v,
                compressionType: a
              }));
            }
          }
          ge.NodeCMapReaderFactory = Z;
          class o extends ce.BaseStandardFontDataFactory {
            _fetchData(t) {
              return re(t);
            }
          }
          ge.NodeStandardFontDataFactory = o;
        },
        /* 22 */
        /***/
        (be, ge, le) => {
          var C, t, a, v, h, e, y, c, d, li, m, Ii, n, ui, l, Pi;
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.AnnotationEditorLayer = void 0;
          var ce = le(7), re = le(1), ae = le(23), Z = le(24);
          const w = class {
            constructor(b) {
              ot(this, d);
              ot(this, m);
              ot(this, n);
              ot(this, l);
              ot(this, C, void 0);
              ot(this, t, !1);
              ot(this, a, this.pointerup.bind(this));
              ot(this, v, this.pointerdown.bind(this));
              ot(this, h, /* @__PURE__ */ new Map());
              ot(this, e, !1);
              ot(this, y, !1);
              ot(this, c, void 0);
              w._initialized || (w._initialized = !0, ae.FreeTextEditor.initialize(b.l10n), Z.InkEditor.initialize(b.l10n), b.uiManager.registerEditorTypes([ae.FreeTextEditor, Z.InkEditor])), vt(this, c, b.uiManager), this.annotationStorage = b.annotationStorage, this.pageIndex = b.pageIndex, this.div = b.div, vt(this, C, b.accessibilityManager), Oe(this, c).addLayer(this);
            }
            updateToolbar(b) {
              Oe(this, c).updateToolbar(b);
            }
            updateMode(b = Oe(this, c).getMode()) {
              dt(this, l, Pi).call(this), b === re.AnnotationEditorType.INK ? (this.addInkEditorIfNeeded(!1), this.disableClick()) : this.enableClick(), Oe(this, c).unselectAll();
            }
            addInkEditorIfNeeded(b) {
              if (!b && Oe(this, c).getMode() !== re.AnnotationEditorType.INK)
                return;
              if (!b) {
                for (const Y of Oe(this, h).values())
                  if (Y.isEmpty()) {
                    Y.setInBackground();
                    return;
                  }
              }
              dt(this, n, ui).call(this, {
                offsetX: 0,
                offsetY: 0
              }).setInBackground();
            }
            setEditingState(b) {
              Oe(this, c).setEditingState(b);
            }
            addCommands(b) {
              Oe(this, c).addCommands(b);
            }
            enable() {
              this.div.style.pointerEvents = "auto";
              for (const b of Oe(this, h).values())
                b.enableEditing();
            }
            disable() {
              this.div.style.pointerEvents = "none";
              for (const b of Oe(this, h).values())
                b.disableEditing();
            }
            setActiveEditor(b) {
              Oe(this, c).getActive() !== b && Oe(this, c).setActiveEditor(b);
            }
            enableClick() {
              this.div.addEventListener("pointerdown", Oe(this, v)), this.div.addEventListener("pointerup", Oe(this, a));
            }
            disableClick() {
              this.div.removeEventListener("pointerdown", Oe(this, v)), this.div.removeEventListener("pointerup", Oe(this, a));
            }
            attach(b) {
              Oe(this, h).set(b.id, b);
            }
            detach(b) {
              var A;
              Oe(this, h).delete(b.id), (A = Oe(this, C)) == null || A.removePointerInTextLayer(b.contentDiv);
            }
            remove(b) {
              Oe(this, c).removeEditor(b), this.detach(b), this.annotationStorage.remove(b.id), b.div.style.display = "none", setTimeout(() => {
                b.div.style.display = "", b.div.remove(), b.isAttachedToDOM = !1, document.activeElement === document.body && Oe(this, c).focusMainContainer();
              }, 0), Oe(this, y) || this.addInkEditorIfNeeded(!1);
            }
            add(b) {
              if (dt(this, d, li).call(this, b), Oe(this, c).addEditor(b), this.attach(b), !b.isAttachedToDOM) {
                const A = b.render();
                this.div.append(A), b.isAttachedToDOM = !0;
              }
              this.moveEditorInDOM(b), b.onceAdded(), this.addToAnnotationStorage(b);
            }
            moveEditorInDOM(b) {
              var A;
              (A = Oe(this, C)) == null || A.moveElementInDOM(this.div, b.div, b.contentDiv, !0);
            }
            addToAnnotationStorage(b) {
              !b.isEmpty() && !this.annotationStorage.has(b.id) && this.annotationStorage.setValue(b.id, b);
            }
            addOrRebuild(b) {
              b.needsToBeRebuilt() ? b.rebuild() : this.add(b);
            }
            addANewEditor(b) {
              const A = () => {
                this.addOrRebuild(b);
              }, Y = () => {
                b.remove();
              };
              this.addCommands({
                cmd: A,
                undo: Y,
                mustExec: !0
              });
            }
            addUndoableEditor(b) {
              const A = () => {
                this.addOrRebuild(b);
              }, Y = () => {
                b.remove();
              };
              this.addCommands({
                cmd: A,
                undo: Y,
                mustExec: !1
              });
            }
            getNextId() {
              return Oe(this, c).getId();
            }
            deserialize(b) {
              switch (b.annotationType) {
                case re.AnnotationEditorType.FREETEXT:
                  return ae.FreeTextEditor.deserialize(b, this);
                case re.AnnotationEditorType.INK:
                  return Z.InkEditor.deserialize(b, this);
              }
              return null;
            }
            setSelected(b) {
              Oe(this, c).setSelected(b);
            }
            toggleSelected(b) {
              Oe(this, c).toggleSelected(b);
            }
            isSelected(b) {
              return Oe(this, c).isSelected(b);
            }
            unselect(b) {
              Oe(this, c).unselect(b);
            }
            pointerup(b) {
              const A = ce.KeyboardManager.platform.isMac;
              if (!(b.button !== 0 || b.ctrlKey && A) && b.target === this.div && Oe(this, e)) {
                if (vt(this, e, !1), !Oe(this, t)) {
                  vt(this, t, !0);
                  return;
                }
                dt(this, n, ui).call(this, b);
              }
            }
            pointerdown(b) {
              const A = ce.KeyboardManager.platform.isMac;
              if (b.button !== 0 || b.ctrlKey && A || b.target !== this.div)
                return;
              vt(this, e, !0);
              const Y = Oe(this, c).getActive();
              vt(this, t, !Y || Y.isEmpty());
            }
            drop(b) {
              const A = b.dataTransfer.getData("text/plain"), Y = Oe(this, c).getEditor(A);
              if (!Y)
                return;
              b.preventDefault(), b.dataTransfer.dropEffect = "move", dt(this, d, li).call(this, Y);
              const j = this.div.getBoundingClientRect(), X = b.clientX - j.x, B = b.clientY - j.y;
              Y.translate(X - Y.startX, B - Y.startY), this.moveEditorInDOM(Y), Y.div.focus();
            }
            dragover(b) {
              b.preventDefault();
            }
            destroy() {
              var b, A;
              ((b = Oe(this, c).getActive()) == null ? void 0 : b.parent) === this && Oe(this, c).setActiveEditor(null);
              for (const Y of Oe(this, h).values())
                (A = Oe(this, C)) == null || A.removePointerInTextLayer(Y.contentDiv), Y.isAttachedToDOM = !1, Y.div.remove(), Y.parent = null;
              this.div = null, Oe(this, h).clear(), Oe(this, c).removeLayer(this);
            }
            render(b) {
              this.viewport = b.viewport, (0, ce.bindEvents)(this, this.div, ["dragover", "drop"]), this.setDimensions();
              for (const A of Oe(this, c).getEditors(this.pageIndex))
                this.add(A);
              this.updateMode();
            }
            update(b) {
              this.viewport = b.viewport, this.setDimensions(), this.updateMode();
            }
            get scaleFactor() {
              return this.viewport.scale;
            }
            get pageDimensions() {
              const [b, A, Y, j] = this.viewport.viewBox, X = Y - b, B = j - A;
              return [X, B];
            }
            get viewportBaseDimensions() {
              const {
                width: b,
                height: A,
                rotation: Y
              } = this.viewport;
              return Y % 180 === 0 ? [b, A] : [A, b];
            }
            setDimensions() {
              const {
                width: b,
                height: A,
                rotation: Y
              } = this.viewport, j = Y % 180 !== 0, X = Math.floor(b) + "px", B = Math.floor(A) + "px";
              this.div.style.width = j ? B : X, this.div.style.height = j ? X : B, this.div.setAttribute("data-main-rotation", Y);
            }
          };
          let o = w;
          C = new WeakMap(), t = new WeakMap(), a = new WeakMap(), v = new WeakMap(), h = new WeakMap(), e = new WeakMap(), y = new WeakMap(), c = new WeakMap(), d = new WeakSet(), li = function(b) {
            var A;
            b.parent !== this && (this.attach(b), b.pageIndex = this.pageIndex, (A = b.parent) == null || A.detach(b), b.parent = this, b.div && b.isAttachedToDOM && (b.div.remove(), this.div.append(b.div)));
          }, m = new WeakSet(), Ii = function(b) {
            switch (Oe(this, c).getMode()) {
              case re.AnnotationEditorType.FREETEXT:
                return new ae.FreeTextEditor(b);
              case re.AnnotationEditorType.INK:
                return new Z.InkEditor(b);
            }
            return null;
          }, n = new WeakSet(), ui = function(b) {
            const A = this.getNextId(), Y = dt(this, m, Ii).call(this, {
              parent: this,
              id: A,
              x: b.offsetX,
              y: b.offsetY
            });
            return Y && this.add(Y), Y;
          }, l = new WeakSet(), Pi = function() {
            vt(this, y, !0);
            for (const b of Oe(this, h).values())
              b.isEmpty() && b.remove();
            vt(this, y, !1);
          }, Zt(o, "_initialized", !1), ge.AnnotationEditorLayer = o;
        },
        /* 23 */
        /***/
        (be, ge, le) => {
          var o, C, t, a, v, h, e, y, Ri, d, Ui, m, Mi, n, hi;
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.FreeTextEditor = void 0;
          var ce = le(1), re = le(7), ae = le(6);
          const l = class extends ae.AnnotationEditor {
            constructor(_) {
              super({
                ..._,
                name: "freeTextEditor"
              });
              ot(this, y);
              ot(this, d);
              ot(this, m);
              ot(this, n);
              ot(this, o, this.editorDivBlur.bind(this));
              ot(this, C, this.editorDivFocus.bind(this));
              ot(this, t, this.editorDivKeydown.bind(this));
              ot(this, a, void 0);
              ot(this, v, "");
              ot(this, h, !1);
              ot(this, e, void 0);
              vt(this, a, _.color || l._defaultColor || ae.AnnotationEditor._defaultLineColor), vt(this, e, _.fontSize || l._defaultFontSize);
            }
            static initialize(_) {
              this._l10nPromise = new Map(["free_text_default_content", "editor_free_text_aria_label"].map((A) => [A, _.get(A)]));
              const b = getComputedStyle(document.documentElement);
              this._internalPadding = parseFloat(b.getPropertyValue("--freetext-padding"));
            }
            static updateDefaultParams(_, b) {
              switch (_) {
                case ce.AnnotationEditorParamsType.FREETEXT_SIZE:
                  l._defaultFontSize = b;
                  break;
                case ce.AnnotationEditorParamsType.FREETEXT_COLOR:
                  l._defaultColor = b;
                  break;
              }
            }
            updateParams(_, b) {
              switch (_) {
                case ce.AnnotationEditorParamsType.FREETEXT_SIZE:
                  dt(this, y, Ri).call(this, b);
                  break;
                case ce.AnnotationEditorParamsType.FREETEXT_COLOR:
                  dt(this, d, Ui).call(this, b);
                  break;
              }
            }
            static get defaultPropertiesToUpdate() {
              return [[ce.AnnotationEditorParamsType.FREETEXT_SIZE, l._defaultFontSize], [ce.AnnotationEditorParamsType.FREETEXT_COLOR, l._defaultColor || ae.AnnotationEditor._defaultLineColor]];
            }
            get propertiesToUpdate() {
              return [[ce.AnnotationEditorParamsType.FREETEXT_SIZE, Oe(this, e)], [ce.AnnotationEditorParamsType.FREETEXT_COLOR, Oe(this, a)]];
            }
            getInitialTranslation() {
              return [-l._internalPadding * this.parent.scaleFactor, -(l._internalPadding + Oe(this, e)) * this.parent.scaleFactor];
            }
            rebuild() {
              super.rebuild(), this.div !== null && (this.isAttachedToDOM || this.parent.add(this));
            }
            enableEditMode() {
              this.isInEditMode() || (this.parent.setEditingState(!1), this.parent.updateToolbar(ce.AnnotationEditorType.FREETEXT), super.enableEditMode(), this.enableEditing(), this.overlayDiv.classList.remove("enabled"), this.editorDiv.contentEditable = !0, this.div.draggable = !1, this.editorDiv.addEventListener("keydown", Oe(this, t)), this.editorDiv.addEventListener("focus", Oe(this, C)), this.editorDiv.addEventListener("blur", Oe(this, o)));
            }
            disableEditMode() {
              this.isInEditMode() && (this.parent.setEditingState(!0), super.disableEditMode(), this.disableEditing(), this.overlayDiv.classList.add("enabled"), this.editorDiv.contentEditable = !1, this.div.draggable = !0, this.editorDiv.removeEventListener("keydown", Oe(this, t)), this.editorDiv.removeEventListener("focus", Oe(this, C)), this.editorDiv.removeEventListener("blur", Oe(this, o)), this.div.focus(), this.isEditing = !1);
            }
            focusin(_) {
              super.focusin(_), _.target !== this.editorDiv && this.editorDiv.focus();
            }
            onceAdded() {
              this.width || (this.enableEditMode(), this.editorDiv.focus());
            }
            isEmpty() {
              return !this.editorDiv || this.editorDiv.innerText.trim() === "";
            }
            remove() {
              this.isEditing = !1, this.parent.setEditingState(!0), super.remove();
            }
            commit() {
              super.commit(), Oe(this, h) || (vt(this, h, !0), this.parent.addUndoableEditor(this)), this.disableEditMode(), vt(this, v, dt(this, m, Mi).call(this).trimEnd()), dt(this, n, hi).call(this);
            }
            shouldGetKeyboardEvents() {
              return this.isInEditMode();
            }
            dblclick(_) {
              this.enableEditMode(), this.editorDiv.focus();
            }
            keydown(_) {
              _.target === this.div && _.key === "Enter" && (this.enableEditMode(), this.editorDiv.focus());
            }
            editorDivKeydown(_) {
              l._keyboardManager.exec(this, _);
            }
            editorDivFocus(_) {
              this.isEditing = !0;
            }
            editorDivBlur(_) {
              this.isEditing = !1;
            }
            disableEditing() {
              this.editorDiv.setAttribute("role", "comment"), this.editorDiv.removeAttribute("aria-multiline");
            }
            enableEditing() {
              this.editorDiv.setAttribute("role", "textbox"), this.editorDiv.setAttribute("aria-multiline", !0);
            }
            render() {
              if (this.div)
                return this.div;
              let _, b;
              this.width && (_ = this.x, b = this.y), super.render(), this.editorDiv = document.createElement("div"), this.editorDiv.className = "internal", this.editorDiv.setAttribute("id", `${this.id}-editor`), this.enableEditing(), l._l10nPromise.get("editor_free_text_aria_label").then((Y) => {
                var j;
                return (j = this.editorDiv) == null ? void 0 : j.setAttribute("aria-label", Y);
              }), l._l10nPromise.get("free_text_default_content").then((Y) => {
                var j;
                return (j = this.editorDiv) == null ? void 0 : j.setAttribute("default-content", Y);
              }), this.editorDiv.contentEditable = !0;
              const {
                style: A
              } = this.editorDiv;
              if (A.fontSize = `calc(${Oe(this, e)}px * var(--scale-factor))`, A.color = Oe(this, a), this.div.append(this.editorDiv), this.overlayDiv = document.createElement("div"), this.overlayDiv.classList.add("overlay", "enabled"), this.div.append(this.overlayDiv), (0, re.bindEvents)(this, this.div, ["dblclick", "keydown"]), this.width) {
                const [Y, j] = this.parent.viewportBaseDimensions;
                this.setAt(_ * Y, b * j, this.width * Y, this.height * j);
                for (const X of Oe(this, v).split(`
`)) {
                  const B = document.createElement("div");
                  B.append(X ? document.createTextNode(X) : document.createElement("br")), this.editorDiv.append(B);
                }
                this.div.draggable = !0, this.editorDiv.contentEditable = !1;
              } else
                this.div.draggable = !1, this.editorDiv.contentEditable = !0;
              return this.div;
            }
            get contentDiv() {
              return this.editorDiv;
            }
            static deserialize(_, b) {
              const A = super.deserialize(_, b);
              return vt(A, e, _.fontSize), vt(A, a, ce.Util.makeHexColor(..._.color)), vt(A, v, _.value), A;
            }
            serialize() {
              if (this.isEmpty())
                return null;
              const _ = l._internalPadding * this.parent.scaleFactor, b = this.getRect(_, _), A = ae.AnnotationEditor._colorManager.convert(getComputedStyle(this.editorDiv).color);
              return {
                annotationType: ce.AnnotationEditorType.FREETEXT,
                color: A,
                fontSize: Oe(this, e),
                value: Oe(this, v),
                pageIndex: this.parent.pageIndex,
                rect: b,
                rotation: this.rotation
              };
            }
          };
          let Z = l;
          o = new WeakMap(), C = new WeakMap(), t = new WeakMap(), a = new WeakMap(), v = new WeakMap(), h = new WeakMap(), e = new WeakMap(), y = new WeakSet(), Ri = function(_) {
            const b = (Y) => {
              this.editorDiv.style.fontSize = `calc(${Y}px * var(--scale-factor))`, this.translate(0, -(Y - Oe(this, e)) * this.parent.scaleFactor), vt(this, e, Y), dt(this, n, hi).call(this);
            }, A = Oe(this, e);
            this.parent.addCommands({
              cmd: () => {
                b(_);
              },
              undo: () => {
                b(A);
              },
              mustExec: !0,
              type: ce.AnnotationEditorParamsType.FREETEXT_SIZE,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }, d = new WeakSet(), Ui = function(_) {
            const b = Oe(this, a);
            this.parent.addCommands({
              cmd: () => {
                vt(this, a, _), this.editorDiv.style.color = _;
              },
              undo: () => {
                vt(this, a, b), this.editorDiv.style.color = b;
              },
              mustExec: !0,
              type: ce.AnnotationEditorParamsType.FREETEXT_COLOR,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }, m = new WeakSet(), Mi = function() {
            const _ = this.editorDiv.getElementsByTagName("div");
            if (_.length === 0)
              return this.editorDiv.innerText;
            const b = [];
            for (let A = 0, Y = _.length; A < Y; A++) {
              const X = _[A].firstChild;
              (X == null ? void 0 : X.nodeName) === "#text" ? b.push(X.data) : b.push("");
            }
            return b.join(`
`);
          }, n = new WeakSet(), hi = function() {
            const [_, b] = this.parent.viewportBaseDimensions, A = this.div.getBoundingClientRect();
            this.width = A.width / _, this.height = A.height / b;
          }, Zt(Z, "_freeTextDefaultContent", ""), Zt(Z, "_l10nPromise"), Zt(Z, "_internalPadding", 0), Zt(Z, "_defaultColor", null), Zt(Z, "_defaultFontSize", 10), Zt(Z, "_keyboardManager", new re.KeyboardManager([[["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], l.prototype.commitOrRemove]])), Zt(Z, "_type", "freetext"), ge.FreeTextEditor = Z;
        },
        /* 24 */
        /***/
        (be, ge, le) => {
          var t, a, v, h, e, y, c, d, p, m, g, n, i, l, u, Bi, _, Li, A, Ni, j, ji, B, di, k, Wi, f, $i, O, Xi, F, un, I, fi, V, Gn, W, Vn, G, Fn, K, gi, se, qn, N, pi, D, Hi, oe, zi, $, Gi, H, mi, ue, Yn, de, Tn, xe, xi;
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.InkEditor = void 0, Object.defineProperty(ge, "fitCurve", {
            enumerable: !0,
            get: function() {
              return ae.fitCurve;
            }
          });
          var ce = le(1), re = le(6), ae = le(25), Z = le(7);
          const o = 16, Ae = class extends re.AnnotationEditor {
            constructor(ye) {
              super({
                ...ye,
                name: "inkEditor"
              });
              ot(this, u);
              ot(this, _);
              ot(this, A);
              ot(this, j);
              ot(this, B);
              ot(this, k);
              ot(this, f);
              ot(this, O);
              ot(this, F);
              ot(this, I);
              ot(this, V);
              ot(this, W);
              ot(this, G);
              ot(this, K);
              ot(this, se);
              ot(this, D);
              ot(this, oe);
              ot(this, $);
              ot(this, H);
              ot(this, ue);
              ot(this, de);
              ot(this, xe);
              ot(this, t, 0);
              ot(this, a, 0);
              ot(this, v, 0);
              ot(this, h, this.canvasPointermove.bind(this));
              ot(this, e, this.canvasPointerleave.bind(this));
              ot(this, y, this.canvasPointerup.bind(this));
              ot(this, c, this.canvasPointerdown.bind(this));
              ot(this, d, !1);
              ot(this, p, !1);
              ot(this, m, null);
              ot(this, g, null);
              ot(this, n, 0);
              ot(this, i, 0);
              ot(this, l, null);
              this.color = ye.color || null, this.thickness = ye.thickness || null, this.opacity = ye.opacity || null, this.paths = [], this.bezierPath2D = [], this.currentPath = [], this.scaleFactor = 1, this.translationX = this.translationY = 0, this.x = 0, this.y = 0;
            }
            static initialize(ye) {
              this._l10nPromise = new Map(["editor_ink_canvas_aria_label", "editor_ink_aria_label"].map((_e) => [_e, ye.get(_e)]));
            }
            static updateDefaultParams(ye, _e) {
              switch (ye) {
                case ce.AnnotationEditorParamsType.INK_THICKNESS:
                  Ae._defaultThickness = _e;
                  break;
                case ce.AnnotationEditorParamsType.INK_COLOR:
                  Ae._defaultColor = _e;
                  break;
                case ce.AnnotationEditorParamsType.INK_OPACITY:
                  Ae._defaultOpacity = _e / 100;
                  break;
              }
            }
            updateParams(ye, _e) {
              switch (ye) {
                case ce.AnnotationEditorParamsType.INK_THICKNESS:
                  dt(this, u, Bi).call(this, _e);
                  break;
                case ce.AnnotationEditorParamsType.INK_COLOR:
                  dt(this, _, Li).call(this, _e);
                  break;
                case ce.AnnotationEditorParamsType.INK_OPACITY:
                  dt(this, A, Ni).call(this, _e);
                  break;
              }
            }
            static get defaultPropertiesToUpdate() {
              return [[ce.AnnotationEditorParamsType.INK_THICKNESS, Ae._defaultThickness], [ce.AnnotationEditorParamsType.INK_COLOR, Ae._defaultColor || re.AnnotationEditor._defaultLineColor], [ce.AnnotationEditorParamsType.INK_OPACITY, Math.round(Ae._defaultOpacity * 100)]];
            }
            get propertiesToUpdate() {
              return [[ce.AnnotationEditorParamsType.INK_THICKNESS, this.thickness || Ae._defaultThickness], [ce.AnnotationEditorParamsType.INK_COLOR, this.color || Ae._defaultColor || re.AnnotationEditor._defaultLineColor], [ce.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * (this.opacity ?? Ae._defaultOpacity))]];
            }
            rebuild() {
              super.rebuild(), this.div !== null && (this.canvas || (dt(this, V, Gn).call(this), dt(this, W, Vn).call(this)), this.isAttachedToDOM || (this.parent.add(this), dt(this, G, Fn).call(this)), dt(this, de, Tn).call(this));
            }
            remove() {
              this.canvas !== null && (this.isEmpty() || this.commit(), this.canvas.width = this.canvas.height = 0, this.canvas.remove(), this.canvas = null, Oe(this, g).disconnect(), vt(this, g, null), super.remove());
            }
            enableEditMode() {
              Oe(this, d) || this.canvas === null || (super.enableEditMode(), this.div.draggable = !1, this.canvas.addEventListener("pointerdown", Oe(this, c)), this.canvas.addEventListener("pointerup", Oe(this, y)));
            }
            disableEditMode() {
              !this.isInEditMode() || this.canvas === null || (super.disableEditMode(), this.div.draggable = !this.isEmpty(), this.div.classList.remove("editing"), this.canvas.removeEventListener("pointerdown", Oe(this, c)), this.canvas.removeEventListener("pointerup", Oe(this, y)));
            }
            onceAdded() {
              this.div.draggable = !this.isEmpty();
            }
            isEmpty() {
              return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;
            }
            commit() {
              Oe(this, d) || (super.commit(), this.isEditing = !1, this.disableEditMode(), this.setInForeground(), vt(this, d, !0), this.div.classList.add("disabled"), dt(this, de, Tn).call(this, !0), this.parent.addInkEditorIfNeeded(!0), this.parent.moveEditorInDOM(this), this.div.focus());
            }
            focusin(ye) {
              super.focusin(ye), this.enableEditMode();
            }
            canvasPointerdown(ye) {
              ye.button !== 0 || !this.isInEditMode() || Oe(this, d) || (this.setInForeground(), ye.type !== "mouse" && this.div.focus(), ye.stopPropagation(), this.canvas.addEventListener("pointerleave", Oe(this, e)), this.canvas.addEventListener("pointermove", Oe(this, h)), dt(this, k, Wi).call(this, ye.offsetX, ye.offsetY));
            }
            canvasPointermove(ye) {
              ye.stopPropagation(), dt(this, f, $i).call(this, ye.offsetX, ye.offsetY);
            }
            canvasPointerup(ye) {
              ye.button === 0 && this.isInEditMode() && this.currentPath.length !== 0 && (ye.stopPropagation(), dt(this, I, fi).call(this, ye), this.setInBackground());
            }
            canvasPointerleave(ye) {
              dt(this, I, fi).call(this, ye), this.setInBackground();
            }
            render() {
              if (this.div)
                return this.div;
              let ye, _e;
              this.width && (ye = this.x, _e = this.y), super.render(), Ae._l10nPromise.get("editor_ink_aria_label").then((He) => {
                var Qe;
                return (Qe = this.div) == null ? void 0 : Qe.setAttribute("aria-label", He);
              });
              const [we, Ce, ve, Le] = dt(this, j, ji).call(this);
              if (this.setAt(we, Ce, 0, 0), this.setDims(ve, Le), dt(this, V, Gn).call(this), this.width) {
                const [He, Qe] = this.parent.viewportBaseDimensions;
                this.setAt(ye * He, _e * Qe, this.width * He, this.height * Qe), vt(this, p, !0), dt(this, G, Fn).call(this), this.setDims(this.width * He, this.height * Qe), dt(this, F, un).call(this), dt(this, xe, xi).call(this), this.div.classList.add("disabled");
              } else
                this.div.classList.add("editing"), this.enableEditMode();
              return dt(this, W, Vn).call(this), this.div;
            }
            setDimensions(ye, _e) {
              const we = Math.round(ye), Ce = Math.round(_e);
              if (Oe(this, n) === we && Oe(this, i) === Ce)
                return;
              vt(this, n, we), vt(this, i, Ce), this.canvas.style.visibility = "hidden", Oe(this, t) && Math.abs(Oe(this, t) - ye / _e) > 0.01 && (_e = Math.ceil(ye / Oe(this, t)), this.setDims(ye, _e));
              const [ve, Le] = this.parent.viewportBaseDimensions;
              this.width = ye / ve, this.height = _e / Le, Oe(this, d) && dt(this, K, gi).call(this, ye, _e), dt(this, G, Fn).call(this), dt(this, F, un).call(this), this.canvas.style.visibility = "visible";
            }
            static deserialize(ye, _e) {
              var Ee, et;
              const we = super.deserialize(ye, _e);
              we.thickness = ye.thickness, we.color = ce.Util.makeHexColor(...ye.color), we.opacity = ye.opacity;
              const [Ce, ve] = _e.pageDimensions, Le = we.width * Ce, He = we.height * ve, Qe = _e.scaleFactor, Ue = ye.thickness / 2;
              vt(we, t, Le / He), vt(we, d, !0), vt(we, n, Math.round(Le)), vt(we, i, Math.round(He));
              for (const {
                bezier: qe
              } of ye.paths) {
                const tt = [];
                we.paths.push(tt);
                let ft = Qe * (qe[0] - Ue), Te = Qe * (He - qe[1] - Ue);
                for (let Ze = 2, Me = qe.length; Ze < Me; Ze += 6) {
                  const at = Qe * (qe[Ze] - Ue), rt = Qe * (He - qe[Ze + 1] - Ue), xt = Qe * (qe[Ze + 2] - Ue), ut = Qe * (He - qe[Ze + 3] - Ue), yt = Qe * (qe[Ze + 4] - Ue), ht = Qe * (He - qe[Ze + 5] - Ue);
                  tt.push([[ft, Te], [at, rt], [xt, ut], [yt, ht]]), ft = yt, Te = ht;
                }
                const je = dt(this, N, pi).call(this, tt);
                we.bezierPath2D.push(je);
              }
              const Ie = dt(Ee = we, H, mi).call(Ee);
              return vt(we, v, Math.max(o, Ie[2] - Ie[0])), vt(we, a, Math.max(o, Ie[3] - Ie[1])), dt(et = we, K, gi).call(et, Le, He), we;
            }
            serialize() {
              if (this.isEmpty())
                return null;
              const ye = this.getRect(0, 0), _e = this.rotation % 180 === 0 ? ye[3] - ye[1] : ye[2] - ye[0], we = re.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);
              return {
                annotationType: ce.AnnotationEditorType.INK,
                color: we,
                thickness: this.thickness,
                opacity: this.opacity,
                paths: dt(this, D, Hi).call(this, this.scaleFactor / this.parent.scaleFactor, this.translationX, this.translationY, _e),
                pageIndex: this.parent.pageIndex,
                rect: ye,
                rotation: this.rotation
              };
            }
          };
          let C = Ae;
          t = new WeakMap(), a = new WeakMap(), v = new WeakMap(), h = new WeakMap(), e = new WeakMap(), y = new WeakMap(), c = new WeakMap(), d = new WeakMap(), p = new WeakMap(), m = new WeakMap(), g = new WeakMap(), n = new WeakMap(), i = new WeakMap(), l = new WeakMap(), u = new WeakSet(), Bi = function(ye) {
            const _e = this.thickness;
            this.parent.addCommands({
              cmd: () => {
                this.thickness = ye, dt(this, de, Tn).call(this);
              },
              undo: () => {
                this.thickness = _e, dt(this, de, Tn).call(this);
              },
              mustExec: !0,
              type: ce.AnnotationEditorParamsType.INK_THICKNESS,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }, _ = new WeakSet(), Li = function(ye) {
            const _e = this.color;
            this.parent.addCommands({
              cmd: () => {
                this.color = ye, dt(this, F, un).call(this);
              },
              undo: () => {
                this.color = _e, dt(this, F, un).call(this);
              },
              mustExec: !0,
              type: ce.AnnotationEditorParamsType.INK_COLOR,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }, A = new WeakSet(), Ni = function(ye) {
            ye /= 100;
            const _e = this.opacity;
            this.parent.addCommands({
              cmd: () => {
                this.opacity = ye, dt(this, F, un).call(this);
              },
              undo: () => {
                this.opacity = _e, dt(this, F, un).call(this);
              },
              mustExec: !0,
              type: ce.AnnotationEditorParamsType.INK_OPACITY,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }, j = new WeakSet(), ji = function() {
            const {
              width: ye,
              height: _e,
              rotation: we
            } = this.parent.viewport;
            switch (we) {
              case 90:
                return [0, ye, ye, _e];
              case 180:
                return [ye, _e, ye, _e];
              case 270:
                return [_e, 0, ye, _e];
              default:
                return [0, 0, ye, _e];
            }
          }, B = new WeakSet(), di = function() {
            this.ctx.lineWidth = this.thickness * this.parent.scaleFactor / this.scaleFactor, this.ctx.lineCap = "round", this.ctx.lineJoin = "round", this.ctx.miterLimit = 10, this.ctx.strokeStyle = `${this.color}${(0, Z.opacityToHex)(this.opacity)}`;
          }, k = new WeakSet(), Wi = function(ye, _e) {
            this.isEditing = !0, Oe(this, p) || (vt(this, p, !0), dt(this, G, Fn).call(this), this.thickness || (this.thickness = Ae._defaultThickness), this.color || (this.color = Ae._defaultColor || re.AnnotationEditor._defaultLineColor), this.opacity ?? (this.opacity = Ae._defaultOpacity)), this.currentPath.push([ye, _e]), vt(this, m, null), dt(this, B, di).call(this), this.ctx.beginPath(), this.ctx.moveTo(ye, _e), vt(this, l, () => {
              Oe(this, l) && (Oe(this, m) && (this.isEmpty() ? (this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)) : dt(this, F, un).call(this), this.ctx.lineTo(...Oe(this, m)), vt(this, m, null), this.ctx.stroke()), window.requestAnimationFrame(Oe(this, l)));
            }), window.requestAnimationFrame(Oe(this, l));
          }, f = new WeakSet(), $i = function(ye, _e) {
            const [we, Ce] = this.currentPath.at(-1);
            ye === we && _e === Ce || (this.currentPath.push([ye, _e]), vt(this, m, [ye, _e]));
          }, O = new WeakSet(), Xi = function(ye, _e) {
            var Ue;
            this.ctx.closePath(), vt(this, l, null), ye = Math.min(Math.max(ye, 0), this.canvas.width), _e = Math.min(Math.max(_e, 0), this.canvas.height);
            const [we, Ce] = this.currentPath.at(-1);
            (ye !== we || _e !== Ce) && this.currentPath.push([ye, _e]);
            let ve;
            if (this.currentPath.length !== 1)
              ve = (0, ae.fitCurve)(this.currentPath, 30, null);
            else {
              const Ie = [ye, _e];
              ve = [[Ie, Ie.slice(), Ie.slice(), Ie]];
            }
            const Le = dt(Ue = Ae, N, pi).call(Ue, ve);
            this.currentPath.length = 0;
            const He = () => {
              this.paths.push(ve), this.bezierPath2D.push(Le), this.rebuild();
            }, Qe = () => {
              this.paths.pop(), this.bezierPath2D.pop(), this.paths.length === 0 ? this.remove() : (this.canvas || (dt(this, V, Gn).call(this), dt(this, W, Vn).call(this)), dt(this, de, Tn).call(this));
            };
            this.parent.addCommands({
              cmd: He,
              undo: Qe,
              mustExec: !0
            });
          }, F = new WeakSet(), un = function() {
            if (this.isEmpty()) {
              dt(this, se, qn).call(this);
              return;
            }
            dt(this, B, di).call(this);
            const {
              canvas: ye,
              ctx: _e
            } = this;
            _e.setTransform(1, 0, 0, 1, 0, 0), _e.clearRect(0, 0, ye.width, ye.height), dt(this, se, qn).call(this);
            for (const we of this.bezierPath2D)
              _e.stroke(we);
          }, I = new WeakSet(), fi = function(ye) {
            dt(this, O, Xi).call(this, ye.offsetX, ye.offsetY), this.canvas.removeEventListener("pointerleave", Oe(this, e)), this.canvas.removeEventListener("pointermove", Oe(this, h)), this.parent.addToAnnotationStorage(this);
          }, V = new WeakSet(), Gn = function() {
            this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = 0, this.canvas.className = "inkEditorCanvas", Ae._l10nPromise.get("editor_ink_canvas_aria_label").then((ye) => {
              var _e;
              return (_e = this.canvas) == null ? void 0 : _e.setAttribute("aria-label", ye);
            }), this.div.append(this.canvas), this.ctx = this.canvas.getContext("2d");
          }, W = new WeakSet(), Vn = function() {
            vt(this, g, new ResizeObserver((ye) => {
              const _e = ye[0].contentRect;
              _e.width && _e.height && this.setDimensions(_e.width, _e.height);
            })), Oe(this, g).observe(this.div);
          }, G = new WeakSet(), Fn = function() {
            if (!Oe(this, p))
              return;
            const [ye, _e] = this.parent.viewportBaseDimensions;
            this.canvas.width = Math.ceil(this.width * ye), this.canvas.height = Math.ceil(this.height * _e), dt(this, se, qn).call(this);
          }, K = new WeakSet(), gi = function(ye, _e) {
            const we = dt(this, ue, Yn).call(this), Ce = (ye - we) / Oe(this, v), ve = (_e - we) / Oe(this, a);
            this.scaleFactor = Math.min(Ce, ve);
          }, se = new WeakSet(), qn = function() {
            const ye = dt(this, ue, Yn).call(this) / 2;
            this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + ye, this.translationY * this.scaleFactor + ye);
          }, N = new WeakSet(), pi = function(ye) {
            const _e = new Path2D();
            for (let we = 0, Ce = ye.length; we < Ce; we++) {
              const [ve, Le, He, Qe] = ye[we];
              we === 0 && _e.moveTo(...ve), _e.bezierCurveTo(Le[0], Le[1], He[0], He[1], Qe[0], Qe[1]);
            }
            return _e;
          }, D = new WeakSet(), Hi = function(ye, _e, we, Ce) {
            const Le = [], He = this.thickness / 2;
            let Qe, Ue;
            for (const Ie of this.paths) {
              Qe = [], Ue = [];
              for (let Ee = 0, et = Ie.length; Ee < et; Ee++) {
                const [qe, tt, ft, Te] = Ie[Ee], je = ye * (qe[0] + _e) + He, Ze = Ce - ye * (qe[1] + we) - He, Me = ye * (tt[0] + _e) + He, at = Ce - ye * (tt[1] + we) - He, rt = ye * (ft[0] + _e) + He, xt = Ce - ye * (ft[1] + we) - He, ut = ye * (Te[0] + _e) + He, yt = Ce - ye * (Te[1] + we) - He;
                Ee === 0 && (Qe.push(je, Ze), Ue.push(je, Ze)), Qe.push(Me, at, rt, xt, ut, yt), dt(this, oe, zi).call(this, je, Ze, Me, at, rt, xt, ut, yt, 4, Ue);
              }
              Le.push({
                bezier: Qe,
                points: Ue
              });
            }
            return Le;
          }, oe = new WeakSet(), zi = function(ye, _e, we, Ce, ve, Le, He, Qe, Ue, Ie) {
            if (dt(this, $, Gi).call(this, ye, _e, we, Ce, ve, Le, He, Qe)) {
              Ie.push(He, Qe);
              return;
            }
            for (let Ee = 1; Ee < Ue - 1; Ee++) {
              const et = Ee / Ue, qe = 1 - et;
              let tt = et * ye + qe * we, ft = et * _e + qe * Ce, Te = et * we + qe * ve, je = et * Ce + qe * Le;
              const Ze = et * ve + qe * He, Me = et * Le + qe * Qe;
              tt = et * tt + qe * Te, ft = et * ft + qe * je, Te = et * Te + qe * Ze, je = et * je + qe * Me, tt = et * tt + qe * Te, ft = et * ft + qe * je, Ie.push(tt, ft);
            }
            Ie.push(He, Qe);
          }, $ = new WeakSet(), Gi = function(ye, _e, we, Ce, ve, Le, He, Qe) {
            const Ie = (3 * we - 2 * ye - He) ** 2, Ee = (3 * Ce - 2 * _e - Qe) ** 2, et = (3 * ve - ye - 2 * He) ** 2, qe = (3 * Le - _e - 2 * Qe) ** 2;
            return Math.max(Ie, et) + Math.max(Ee, qe) <= 10;
          }, H = new WeakSet(), mi = function() {
            let ye = 1 / 0, _e = -1 / 0, we = 1 / 0, Ce = -1 / 0;
            for (const ve of this.paths)
              for (const [Le, He, Qe, Ue] of ve) {
                const Ie = ce.Util.bezierBoundingBox(...Le, ...He, ...Qe, ...Ue);
                ye = Math.min(ye, Ie[0]), we = Math.min(we, Ie[1]), _e = Math.max(_e, Ie[2]), Ce = Math.max(Ce, Ie[3]);
              }
            return [ye, we, _e, Ce];
          }, ue = new WeakSet(), Yn = function() {
            return Oe(this, d) ? Math.ceil(this.thickness * this.parent.scaleFactor) : 0;
          }, de = new WeakSet(), Tn = function(ye = !1) {
            if (this.isEmpty())
              return;
            if (!Oe(this, d)) {
              dt(this, F, un).call(this);
              return;
            }
            const _e = dt(this, H, mi).call(this), we = dt(this, ue, Yn).call(this);
            vt(this, v, Math.max(o, _e[2] - _e[0])), vt(this, a, Math.max(o, _e[3] - _e[1]));
            const Ce = Math.ceil(we + Oe(this, v) * this.scaleFactor), ve = Math.ceil(we + Oe(this, a) * this.scaleFactor), [Le, He] = this.parent.viewportBaseDimensions;
            this.width = Ce / Le, this.height = ve / He, vt(this, t, Ce / ve), dt(this, xe, xi).call(this);
            const Qe = this.translationX, Ue = this.translationY;
            this.translationX = -_e[0], this.translationY = -_e[1], dt(this, G, Fn).call(this), dt(this, F, un).call(this), vt(this, n, Ce), vt(this, i, ve), this.setDims(Ce, ve);
            const Ie = ye ? we / this.scaleFactor / 2 : 0;
            this.translate(Qe - this.translationX - Ie, Ue - this.translationY - Ie);
          }, xe = new WeakSet(), xi = function() {
            const {
              style: ye
            } = this.div;
            Oe(this, t) >= 1 ? (ye.minHeight = `${o}px`, ye.minWidth = `${Math.round(Oe(this, t) * o)}px`) : (ye.minWidth = `${o}px`, ye.minHeight = `${Math.round(o / Oe(this, t))}px`);
          }, ot(C, N), Zt(C, "_defaultColor", null), Zt(C, "_defaultOpacity", 1), Zt(C, "_defaultThickness", 1), Zt(C, "_l10nPromise"), Zt(C, "_type", "ink"), ge.InkEditor = C;
        },
        /* 25 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.fitCurve = void 0;
          const ce = le(26);
          ge.fitCurve = ce;
        },
        /* 26 */
        /***/
        (be) => {
          function ge(y, c, d) {
            if (!Array.isArray(y))
              throw new TypeError("First argument should be an array");
            if (y.forEach((n) => {
              if (!Array.isArray(n) || n.some((i) => typeof i != "number") || n.length !== y[0].length)
                throw Error("Each point should be an array of numbers. Each point should have the same amount of numbers.");
            }), y = y.filter((n, i) => i === 0 || !n.every((l, u) => l === y[i - 1][u])), y.length < 2)
              return [];
            const p = y.length, m = v(y[1], y[0]), g = v(y[p - 2], y[p - 1]);
            return le(y, m, g, c, d);
          }
          function le(y, c, d, p, m) {
            var n, i, l, u, w, _, b, A, Y, j, X, B, R;
            if (y.length === 2)
              return B = h.vectorLen(h.subtract(y[0], y[1])) / 3, n = [y[0], h.addArrays(y[0], h.mulItems(c, B)), h.addArrays(y[1], h.mulItems(d, B)), y[1]], [n];
            if (i = o(y), [n, u, _] = ce(y, i, i, c, d, m), u === 0 || u < p)
              return [n];
            if (u < p * p)
              for (l = i, w = u, b = _, R = 0; R < 20; R++) {
                if (l = ae(n, y, l), [n, u, _] = ce(y, i, l, c, d, m), u < p)
                  return [n];
                if (_ === b) {
                  let k = u / w;
                  if (k > 0.9999 && k < 1.0001)
                    break;
                }
                w = u, b = _;
              }
            return X = [], A = h.subtract(y[_ - 1], y[_ + 1]), A.every((k) => k === 0) && (A = h.subtract(y[_ - 1], y[_]), [A[0], A[1]] = [-A[1], A[0]]), Y = h.normalize(A), j = h.mulItems(Y, -1), X = X.concat(le(y.slice(0, _ + 1), c, Y, p, m)), X = X.concat(le(y.slice(_), j, d, p, m)), X;
          }
          function ce(y, c, d, p, m, g) {
            var n, i, l;
            return n = re(y, d, p, m), [i, l] = C(y, n, c), g && g({
              bez: n,
              points: y,
              params: c,
              maxErr: i,
              maxPoint: l
            }), [n, i, l];
          }
          function re(y, c, d, p) {
            var m, g, n, i, l, u, w, _, b, A, Y, j, X, B, R, k, x, f = y[0], U = y[y.length - 1];
            for (m = [f, null, null, U], g = h.zeros_Xx2x2(c.length), X = 0, B = c.length; X < B; X++)
              k = c[X], x = 1 - k, n = g[X], n[0] = h.mulItems(d, 3 * k * (x * x)), n[1] = h.mulItems(p, 3 * x * (k * k));
            for (i = [[0, 0], [0, 0]], l = [0, 0], X = 0, B = y.length; X < B; X++)
              k = c[X], n = g[X], i[0][0] += h.dot(n[0], n[0]), i[0][1] += h.dot(n[0], n[1]), i[1][0] += h.dot(n[0], n[1]), i[1][1] += h.dot(n[1], n[1]), R = h.subtract(y[X], e.q([f, f, U, U], k)), l[0] += h.dot(n[0], R), l[1] += h.dot(n[1], R);
            return u = i[0][0] * i[1][1] - i[1][0] * i[0][1], w = i[0][0] * l[1] - i[1][0] * l[0], _ = l[0] * i[1][1] - l[1] * i[0][1], b = u === 0 ? 0 : _ / u, A = u === 0 ? 0 : w / u, j = h.vectorLen(h.subtract(f, U)), Y = 1e-6 * j, b < Y || A < Y ? (m[1] = h.addArrays(f, h.mulItems(d, j / 3)), m[2] = h.addArrays(U, h.mulItems(p, j / 3))) : (m[1] = h.addArrays(f, h.mulItems(d, b)), m[2] = h.addArrays(U, h.mulItems(p, A))), m;
          }
          function ae(y, c, d) {
            return d.map((p, m) => Z(y, c[m], p));
          }
          function Z(y, c, d) {
            var p = h.subtract(e.q(y, d), c), m = e.qprime(y, d), g = h.mulMatrix(p, m), n = h.sum(h.squareItems(m)) + 2 * h.mulMatrix(p, e.qprimeprime(y, d));
            return n === 0 ? d : d - g / n;
          }
          function o(y) {
            var c = [], d, p, m;
            return y.forEach((g, n) => {
              d = n ? p + h.vectorLen(h.subtract(g, m)) : 0, c.push(d), p = d, m = g;
            }), c = c.map((g) => g / p), c;
          }
          function C(y, c, d) {
            var p, m, g, n, i, l, u, w;
            m = 0, g = Math.floor(y.length / 2);
            const _ = t(c, 10);
            for (i = 0, l = y.length; i < l; i++)
              u = y[i], w = a(c, d[i], _, 10), n = h.subtract(e.q(c, w), u), p = n[0] * n[0] + n[1] * n[1], p > m && (m = p, g = i);
            return [m, g];
          }
          var t = function(y, c) {
            for (var d, p = [0], m = y[0], g = 0, n = 1; n <= c; n++)
              d = e.q(y, n / c), g += h.vectorLen(h.subtract(d, m)), p.push(g), m = d;
            return p = p.map((i) => i / g), p;
          };
          function a(y, c, d, p) {
            if (c < 0)
              return 0;
            if (c > 1)
              return 1;
            for (var m, g, n, i, l, u = 1; u <= p; u++)
              if (c <= d[u]) {
                i = (u - 1) / p, n = u / p, g = d[u - 1], m = d[u], l = (c - g) / (m - g) * (n - i) + i;
                break;
              }
            return l;
          }
          function v(y, c) {
            return h.normalize(h.subtract(y, c));
          }
          class h {
            static zeros_Xx2x2(c) {
              for (var d = []; c--; )
                d.push([0, 0]);
              return d;
            }
            static mulItems(c, d) {
              return c.map((p) => p * d);
            }
            static mulMatrix(c, d) {
              return c.reduce((p, m, g) => p + m * d[g], 0);
            }
            static subtract(c, d) {
              return c.map((p, m) => p - d[m]);
            }
            static addArrays(c, d) {
              return c.map((p, m) => p + d[m]);
            }
            static addItems(c, d) {
              return c.map((p) => p + d);
            }
            static sum(c) {
              return c.reduce((d, p) => d + p);
            }
            static dot(c, d) {
              return h.mulMatrix(c, d);
            }
            static vectorLen(c) {
              return Math.hypot(...c);
            }
            static divItems(c, d) {
              return c.map((p) => p / d);
            }
            static squareItems(c) {
              return c.map((d) => d * d);
            }
            static normalize(c) {
              return this.divItems(c, this.vectorLen(c));
            }
          }
          class e {
            static q(c, d) {
              var p = 1 - d, m = h.mulItems(c[0], p * p * p), g = h.mulItems(c[1], 3 * p * p * d), n = h.mulItems(c[2], 3 * p * d * d), i = h.mulItems(c[3], d * d * d);
              return h.addArrays(h.addArrays(m, g), h.addArrays(n, i));
            }
            static qprime(c, d) {
              var p = 1 - d, m = h.mulItems(h.subtract(c[1], c[0]), 3 * p * p), g = h.mulItems(h.subtract(c[2], c[1]), 6 * p * d), n = h.mulItems(h.subtract(c[3], c[2]), 3 * d * d);
              return h.addArrays(h.addArrays(m, g), n);
            }
            static qprimeprime(c, d) {
              return h.addArrays(h.mulItems(h.addArrays(h.subtract(c[2], h.mulItems(c[1], 2)), c[0]), 6 * (1 - d)), h.mulItems(h.addArrays(h.subtract(c[3], h.mulItems(c[2], 2)), c[1]), 6 * d));
            }
          }
          be.exports = ge, be.exports.fitCubic = le, be.exports.createTangent = v;
        },
        /* 27 */
        /***/
        (be, ge, le) => {
          var F, bi, I, yi, V, vi;
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.AnnotationLayer = void 0;
          var ce = le(1), re = le(8), ae = le(5), Z = le(28), o = le(29);
          const C = 1e3, t = 9, a = /* @__PURE__ */ new WeakSet();
          function v(z) {
            return {
              width: z[2] - z[0],
              height: z[3] - z[1]
            };
          }
          class h {
            static create(G) {
              switch (G.data.annotationType) {
                case ce.AnnotationType.LINK:
                  return new y(G);
                case ce.AnnotationType.TEXT:
                  return new c(G);
                case ce.AnnotationType.WIDGET:
                  switch (G.data.fieldType) {
                    case "Tx":
                      return new p(G);
                    case "Btn":
                      return G.data.radioButton ? new g(G) : G.data.checkBox ? new m(G) : new n(G);
                    case "Ch":
                      return new i(G);
                  }
                  return new d(G);
                case ce.AnnotationType.POPUP:
                  return new l(G);
                case ce.AnnotationType.FREETEXT:
                  return new w(G);
                case ce.AnnotationType.LINE:
                  return new _(G);
                case ce.AnnotationType.SQUARE:
                  return new b(G);
                case ce.AnnotationType.CIRCLE:
                  return new A(G);
                case ce.AnnotationType.POLYLINE:
                  return new Y(G);
                case ce.AnnotationType.CARET:
                  return new X(G);
                case ce.AnnotationType.INK:
                  return new B(G);
                case ce.AnnotationType.POLYGON:
                  return new j(G);
                case ce.AnnotationType.HIGHLIGHT:
                  return new R(G);
                case ce.AnnotationType.UNDERLINE:
                  return new k(G);
                case ce.AnnotationType.SQUIGGLY:
                  return new x(G);
                case ce.AnnotationType.STRIKEOUT:
                  return new f(G);
                case ce.AnnotationType.STAMP:
                  return new U(G);
                case ce.AnnotationType.FILEATTACHMENT:
                  return new O(G);
                default:
                  return new e(G);
              }
            }
          }
          class e {
            constructor(G, {
              isRenderable: L = !1,
              ignoreBorder: K = !1,
              createQuadrilaterals: te = !1
            } = {}) {
              this.isRenderable = L, this.data = G.data, this.layer = G.layer, this.page = G.page, this.viewport = G.viewport, this.linkService = G.linkService, this.downloadManager = G.downloadManager, this.imageResourcesPath = G.imageResourcesPath, this.renderForms = G.renderForms, this.svgFactory = G.svgFactory, this.annotationStorage = G.annotationStorage, this.enableScripting = G.enableScripting, this.hasJSActions = G.hasJSActions, this._fieldObjects = G.fieldObjects, this._mouseState = G.mouseState, L && (this.container = this._createContainer(K)), te && (this.quadrilaterals = this._createQuadrilaterals(K));
            }
            _createContainer(G = !1) {
              const L = this.data, K = this.page, te = this.viewport, se = document.createElement("section"), {
                width: q,
                height: N
              } = v(L.rect), [Q, D, ne, oe] = te.viewBox, ee = ne - Q, $ = oe - D;
              se.setAttribute("data-annotation-id", L.id);
              const E = ce.Util.normalizeRect([L.rect[0], K.view[3] - L.rect[1] + K.view[1], L.rect[2], K.view[3] - L.rect[3] + K.view[1]]);
              if (!G && L.borderStyle.width > 0) {
                se.style.borderWidth = `${L.borderStyle.width}px`;
                const ie = L.borderStyle.horizontalCornerRadius, ue = L.borderStyle.verticalCornerRadius;
                if (ie > 0 || ue > 0) {
                  const de = `calc(${ie}px * var(--scale-factor)) / calc(${ue}px * var(--scale-factor))`;
                  se.style.borderRadius = de;
                } else if (this instanceof g) {
                  const de = `calc(${q}px * var(--scale-factor)) / calc(${N}px * var(--scale-factor))`;
                  se.style.borderRadius = de;
                }
                switch (L.borderStyle.style) {
                  case ce.AnnotationBorderStyleType.SOLID:
                    se.style.borderStyle = "solid";
                    break;
                  case ce.AnnotationBorderStyleType.DASHED:
                    se.style.borderStyle = "dashed";
                    break;
                  case ce.AnnotationBorderStyleType.BEVELED:
                    (0, ce.warn)("Unimplemented border style: beveled");
                    break;
                  case ce.AnnotationBorderStyleType.INSET:
                    (0, ce.warn)("Unimplemented border style: inset");
                    break;
                  case ce.AnnotationBorderStyleType.UNDERLINE:
                    se.style.borderBottomStyle = "solid";
                    break;
                }
                const fe = L.borderColor || null;
                fe ? se.style.borderColor = ce.Util.makeHexColor(fe[0] | 0, fe[1] | 0, fe[2] | 0) : se.style.borderWidth = 0;
              }
              se.style.left = `${100 * (E[0] - Q) / ee}%`, se.style.top = `${100 * (E[1] - D) / $}%`;
              const {
                rotation: H
              } = L;
              return L.hasOwnCanvas || H === 0 ? (se.style.width = `${100 * q / ee}%`, se.style.height = `${100 * N / $}%`) : this.setRotation(H, se), se;
            }
            setRotation(G, L = this.container) {
              const [K, te, se, q] = this.viewport.viewBox, N = se - K, Q = q - te, {
                width: D,
                height: ne
              } = v(this.data.rect);
              let oe, ee;
              G % 180 === 0 ? (oe = 100 * D / N, ee = 100 * ne / Q) : (oe = 100 * ne / N, ee = 100 * D / Q), L.style.width = `${oe}%`, L.style.height = `${ee}%`, L.setAttribute("data-main-rotation", (360 - G) % 360);
            }
            get _commonActions() {
              const G = (L, K, te) => {
                const se = te.detail[L];
                te.target.style[K] = Z.ColorConverters[`${se[0]}_HTML`](se.slice(1));
              };
              return (0, ce.shadow)(this, "_commonActions", {
                display: (L) => {
                  const K = L.detail.display % 2 === 1;
                  this.container.style.visibility = K ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
                    hidden: K,
                    print: L.detail.display === 0 || L.detail.display === 3
                  });
                },
                print: (L) => {
                  this.annotationStorage.setValue(this.data.id, {
                    print: L.detail.print
                  });
                },
                hidden: (L) => {
                  this.container.style.visibility = L.detail.hidden ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
                    hidden: L.detail.hidden
                  });
                },
                focus: (L) => {
                  setTimeout(() => L.target.focus({
                    preventScroll: !1
                  }), 0);
                },
                userName: (L) => {
                  L.target.title = L.detail.userName;
                },
                readonly: (L) => {
                  L.detail.readonly ? L.target.setAttribute("readonly", "") : L.target.removeAttribute("readonly");
                },
                required: (L) => {
                  this._setRequired(L.target, L.detail.required);
                },
                bgColor: (L) => {
                  G("bgColor", "backgroundColor", L);
                },
                fillColor: (L) => {
                  G("fillColor", "backgroundColor", L);
                },
                fgColor: (L) => {
                  G("fgColor", "color", L);
                },
                textColor: (L) => {
                  G("textColor", "color", L);
                },
                borderColor: (L) => {
                  G("borderColor", "borderColor", L);
                },
                strokeColor: (L) => {
                  G("strokeColor", "borderColor", L);
                },
                rotation: (L) => {
                  const K = L.detail.rotation;
                  this.setRotation(K), this.annotationStorage.setValue(this.data.id, {
                    rotation: K
                  });
                }
              });
            }
            _dispatchEventFromSandbox(G, L) {
              const K = this._commonActions;
              for (const te of Object.keys(L.detail)) {
                const se = G[te] || K[te];
                se && se(L);
              }
            }
            _setDefaultPropertiesFromJS(G) {
              if (!this.enableScripting)
                return;
              const L = this.annotationStorage.getRawValue(this.data.id);
              if (!L)
                return;
              const K = this._commonActions;
              for (const [te, se] of Object.entries(L)) {
                const q = K[te];
                if (q) {
                  const N = {
                    detail: {
                      [te]: se
                    },
                    target: G
                  };
                  q(N), delete L[te];
                }
              }
            }
            _createQuadrilaterals(G = !1) {
              if (!this.data.quadPoints)
                return null;
              const L = [], K = this.data.rect;
              for (const te of this.data.quadPoints)
                this.data.rect = [te[2].x, te[2].y, te[1].x, te[1].y], L.push(this._createContainer(G));
              return this.data.rect = K, L;
            }
            _createPopup(G, L) {
              let K = this.container;
              this.quadrilaterals && (G = G || this.quadrilaterals, K = this.quadrilaterals[0]), G || (G = document.createElement("div"), G.className = "popupTriggerArea", K.append(G));
              const se = new u({
                container: K,
                trigger: G,
                color: L.color,
                titleObj: L.titleObj,
                modificationDate: L.modificationDate,
                contentsObj: L.contentsObj,
                richText: L.richText,
                hideWrapper: !0
              }).render();
              se.style.left = "100%", K.append(se);
            }
            _renderQuadrilaterals(G) {
              for (const L of this.quadrilaterals)
                L.className = G;
              return this.quadrilaterals;
            }
            render() {
              (0, ce.unreachable)("Abstract method `AnnotationElement.render` called");
            }
            _getElementsByName(G, L = null) {
              const K = [];
              if (this._fieldObjects) {
                const te = this._fieldObjects[G];
                if (te)
                  for (const {
                    page: se,
                    id: q,
                    exportValues: N
                  } of te) {
                    if (se === -1 || q === L)
                      continue;
                    const Q = typeof N == "string" ? N : null, D = document.querySelector(`[data-element-id="${q}"]`);
                    if (D && !a.has(D)) {
                      (0, ce.warn)(`_getElementsByName - element not allowed: ${q}`);
                      continue;
                    }
                    K.push({
                      id: q,
                      exportValue: Q,
                      domElement: D
                    });
                  }
                return K;
              }
              for (const te of document.getElementsByName(G)) {
                const {
                  id: se,
                  exportValue: q
                } = te;
                se !== L && a.has(te) && K.push({
                  id: se,
                  exportValue: q,
                  domElement: te
                });
              }
              return K;
            }
            static get platform() {
              const G = typeof navigator < "u" ? navigator.platform : "";
              return (0, ce.shadow)(this, "platform", {
                isWin: G.includes("Win"),
                isMac: G.includes("Mac")
              });
            }
          }
          class y extends e {
            constructor(G, L = null) {
              super(G, {
                isRenderable: !0,
                ignoreBorder: !!(L != null && L.ignoreBorder),
                createQuadrilaterals: !0
              }), this.isTooltipOnly = G.data.isTooltipOnly;
            }
            render() {
              const {
                data: G,
                linkService: L
              } = this, K = document.createElement("a");
              K.setAttribute("data-element-id", G.id);
              let te = !1;
              return G.url ? (L.addLinkAttributes(K, G.url, G.newWindow), te = !0) : G.action ? (this._bindNamedAction(K, G.action), te = !0) : G.dest ? (this._bindLink(K, G.dest), te = !0) : (G.actions && (G.actions.Action || G.actions["Mouse Up"] || G.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions && (this._bindJSAction(K, G), te = !0), G.resetForm ? (this._bindResetFormAction(K, G.resetForm), te = !0) : this.isTooltipOnly && !te && (this._bindLink(K, ""), te = !0)), this.quadrilaterals ? this._renderQuadrilaterals("linkAnnotation").map((se, q) => {
                const N = q === 0 ? K : K.cloneNode();
                return se.append(N), se;
              }) : (this.container.className = "linkAnnotation", te && this.container.append(K), this.container);
            }
            _bindLink(G, L) {
              G.href = this.linkService.getDestinationHash(L), G.onclick = () => (L && this.linkService.goToDestination(L), !1), (L || L === "") && (G.className = "internalLink");
            }
            _bindNamedAction(G, L) {
              G.href = this.linkService.getAnchorUrl(""), G.onclick = () => (this.linkService.executeNamedAction(L), !1), G.className = "internalLink";
            }
            _bindJSAction(G, L) {
              G.href = this.linkService.getAnchorUrl("");
              const K = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
              for (const te of Object.keys(L.actions)) {
                const se = K.get(te);
                se && (G[se] = () => {
                  var q;
                  return (q = this.linkService.eventBus) == null || q.dispatch("dispatcheventinsandbox", {
                    source: this,
                    detail: {
                      id: L.id,
                      name: te
                    }
                  }), !1;
                });
              }
              G.onclick || (G.onclick = () => !1), G.className = "internalLink";
            }
            _bindResetFormAction(G, L) {
              const K = G.onclick;
              if (K || (G.href = this.linkService.getAnchorUrl("")), G.className = "internalLink", !this._fieldObjects) {
                (0, ce.warn)('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.'), K || (G.onclick = () => !1);
                return;
              }
              G.onclick = () => {
                var ne;
                K && K();
                const {
                  fields: te,
                  refs: se,
                  include: q
                } = L, N = [];
                if (te.length !== 0 || se.length !== 0) {
                  const oe = new Set(se);
                  for (const ee of te) {
                    const $ = this._fieldObjects[ee] || [];
                    for (const {
                      id: E
                    } of $)
                      oe.add(E);
                  }
                  for (const ee of Object.values(this._fieldObjects))
                    for (const $ of ee)
                      oe.has($.id) === q && N.push($);
                } else
                  for (const oe of Object.values(this._fieldObjects))
                    N.push(...oe);
                const Q = this.annotationStorage, D = [];
                for (const oe of N) {
                  const {
                    id: ee
                  } = oe;
                  switch (D.push(ee), oe.type) {
                    case "text": {
                      const E = oe.defaultValue || "";
                      Q.setValue(ee, {
                        value: E
                      });
                      break;
                    }
                    case "checkbox":
                    case "radiobutton": {
                      const E = oe.defaultValue === oe.exportValues;
                      Q.setValue(ee, {
                        value: E
                      });
                      break;
                    }
                    case "combobox":
                    case "listbox": {
                      const E = oe.defaultValue || "";
                      Q.setValue(ee, {
                        value: E
                      });
                      break;
                    }
                    default:
                      continue;
                  }
                  const $ = document.querySelector(`[data-element-id="${ee}"]`);
                  if ($) {
                    if (!a.has($)) {
                      (0, ce.warn)(`_bindResetFormAction - element not allowed: ${ee}`);
                      continue;
                    }
                  } else
                    continue;
                  $.dispatchEvent(new Event("resetform"));
                }
                return this.enableScripting && ((ne = this.linkService.eventBus) == null || ne.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: "app",
                    ids: D,
                    name: "ResetForm"
                  }
                })), !1;
              };
            }
          }
          class c extends e {
            constructor(G) {
              var K, te, se;
              const L = !!(G.data.hasPopup || (K = G.data.titleObj) != null && K.str || (te = G.data.contentsObj) != null && te.str || (se = G.data.richText) != null && se.str);
              super(G, {
                isRenderable: L
              });
            }
            render() {
              this.container.className = "textAnnotation";
              const G = document.createElement("img");
              return G.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg", G.alt = "[{{type}} Annotation]", G.dataset.l10nId = "text_annotation_type", G.dataset.l10nArgs = JSON.stringify({
                type: this.data.name
              }), this.data.hasPopup || this._createPopup(G, this.data), this.container.append(G), this.container;
            }
          }
          class d extends e {
            render() {
              return this.data.alternativeText && (this.container.title = this.data.alternativeText), this.container;
            }
            _getKeyModifier(G) {
              const {
                isWin: L,
                isMac: K
              } = e.platform;
              return L && G.ctrlKey || K && G.metaKey;
            }
            _setEventListener(G, L, K, te) {
              L.includes("mouse") ? G.addEventListener(L, (se) => {
                var q;
                (q = this.linkService.eventBus) == null || q.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: this.data.id,
                    name: K,
                    value: te(se),
                    shift: se.shiftKey,
                    modifier: this._getKeyModifier(se)
                  }
                });
              }) : G.addEventListener(L, (se) => {
                var q;
                (q = this.linkService.eventBus) == null || q.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: this.data.id,
                    name: K,
                    value: te(se)
                  }
                });
              });
            }
            _setEventListeners(G, L, K) {
              var te;
              for (const [se, q] of L)
                (q === "Action" || (te = this.data.actions) != null && te[q]) && this._setEventListener(G, se, q, K);
            }
            _setBackgroundColor(G) {
              const L = this.data.backgroundColor || null;
              G.style.backgroundColor = L === null ? "transparent" : ce.Util.makeHexColor(L[0], L[1], L[2]);
            }
            _setTextStyle(G) {
              const L = ["left", "center", "right"], {
                fontColor: K
              } = this.data.defaultAppearanceData, te = this.data.defaultAppearanceData.fontSize || t, se = G.style;
              let q;
              if (this.data.multiLine) {
                const N = Math.abs(this.data.rect[3] - this.data.rect[1]), Q = Math.round(N / (ce.LINE_FACTOR * te)) || 1, D = N / Q;
                q = Math.min(te, Math.round(D / ce.LINE_FACTOR));
              } else {
                const N = Math.abs(this.data.rect[3] - this.data.rect[1]);
                q = Math.min(te, Math.round(N / ce.LINE_FACTOR));
              }
              se.fontSize = `calc(${q}px * var(--scale-factor))`, se.color = ce.Util.makeHexColor(K[0], K[1], K[2]), this.data.textAlignment !== null && (se.textAlign = L[this.data.textAlignment]);
            }
            _setRequired(G, L) {
              L ? G.setAttribute("required", !0) : G.removeAttribute("required"), G.setAttribute("aria-required", L);
            }
          }
          class p extends d {
            constructor(G) {
              const L = G.renderForms || !G.data.hasAppearance && !!G.data.fieldValue;
              super(G, {
                isRenderable: L
              });
            }
            setPropertyOnSiblings(G, L, K, te) {
              const se = this.annotationStorage;
              for (const q of this._getElementsByName(G.name, G.id))
                q.domElement && (q.domElement[L] = K), se.setValue(q.id, {
                  [te]: K
                });
            }
            render() {
              var te;
              const G = this.annotationStorage, L = this.data.id;
              this.container.className = "textWidgetAnnotation";
              let K = null;
              if (this.renderForms) {
                const se = G.getValue(L, {
                  value: this.data.fieldValue
                });
                let q = se.formattedValue || se.value || "";
                const N = G.getValue(L, {
                  charLimit: this.data.maxLen
                }).charLimit;
                N && q.length > N && (q = q.slice(0, N));
                const Q = {
                  userValue: q,
                  formattedValue: null,
                  valueOnFocus: ""
                };
                this.data.multiLine ? (K = document.createElement("textarea"), K.textContent = q, this.data.doNotScroll && (K.style.overflowY = "hidden")) : (K = document.createElement("input"), K.type = "text", K.setAttribute("value", q), this.data.doNotScroll && (K.style.overflowX = "hidden")), a.add(K), K.setAttribute("data-element-id", L), K.disabled = this.data.readOnly, K.name = this.data.fieldName, K.tabIndex = C, this._setRequired(K, this.data.required), N && (K.maxLength = N), K.addEventListener("input", (ne) => {
                  G.setValue(L, {
                    value: ne.target.value
                  }), this.setPropertyOnSiblings(K, "value", ne.target.value, "value");
                }), K.addEventListener("resetform", (ne) => {
                  const oe = this.data.defaultFieldValue ?? "";
                  K.value = Q.userValue = oe, Q.formattedValue = null;
                });
                let D = (ne) => {
                  const {
                    formattedValue: oe
                  } = Q;
                  oe != null && (ne.target.value = oe), ne.target.scrollLeft = 0;
                };
                if (this.enableScripting && this.hasJSActions) {
                  K.addEventListener("focus", (oe) => {
                    Q.userValue && (oe.target.value = Q.userValue), Q.valueOnFocus = oe.target.value;
                  }), K.addEventListener("updatefromsandbox", (oe) => {
                    const ee = {
                      value($) {
                        Q.userValue = $.detail.value ?? "", G.setValue(L, {
                          value: Q.userValue.toString()
                        }), $.target.value = Q.userValue;
                      },
                      formattedValue($) {
                        const {
                          formattedValue: E
                        } = $.detail;
                        Q.formattedValue = E, E != null && $.target !== document.activeElement && ($.target.value = E), G.setValue(L, {
                          formattedValue: E
                        });
                      },
                      selRange($) {
                        $.target.setSelectionRange(...$.detail.selRange);
                      },
                      charLimit: ($) => {
                        var ue;
                        const {
                          charLimit: E
                        } = $.detail, {
                          target: H
                        } = $;
                        if (E === 0) {
                          H.removeAttribute("maxLength");
                          return;
                        }
                        H.setAttribute("maxLength", E);
                        let ie = Q.userValue;
                        !ie || ie.length <= E || (ie = ie.slice(0, E), H.value = Q.userValue = ie, G.setValue(L, {
                          value: ie
                        }), (ue = this.linkService.eventBus) == null || ue.dispatch("dispatcheventinsandbox", {
                          source: this,
                          detail: {
                            id: L,
                            name: "Keystroke",
                            value: ie,
                            willCommit: !0,
                            commitKey: 1,
                            selStart: H.selectionStart,
                            selEnd: H.selectionEnd
                          }
                        }));
                      }
                    };
                    this._dispatchEventFromSandbox(ee, oe);
                  }), K.addEventListener("keydown", (oe) => {
                    var E;
                    let ee = -1;
                    if (oe.key === "Escape" ? ee = 0 : oe.key === "Enter" ? ee = 2 : oe.key === "Tab" && (ee = 3), ee === -1)
                      return;
                    const {
                      value: $
                    } = oe.target;
                    Q.valueOnFocus !== $ && (Q.userValue = $, (E = this.linkService.eventBus) == null || E.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id: L,
                        name: "Keystroke",
                        value: $,
                        willCommit: !0,
                        commitKey: ee,
                        selStart: oe.target.selectionStart,
                        selEnd: oe.target.selectionEnd
                      }
                    }));
                  });
                  const ne = D;
                  D = null, K.addEventListener("blur", (oe) => {
                    var $;
                    const {
                      value: ee
                    } = oe.target;
                    Q.userValue = ee, this._mouseState.isDown && Q.valueOnFocus !== ee && (($ = this.linkService.eventBus) == null || $.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id: L,
                        name: "Keystroke",
                        value: ee,
                        willCommit: !0,
                        commitKey: 1,
                        selStart: oe.target.selectionStart,
                        selEnd: oe.target.selectionEnd
                      }
                    })), ne(oe);
                  }), (te = this.data.actions) != null && te.Keystroke && K.addEventListener("beforeinput", (oe) => {
                    var de;
                    const {
                      data: ee,
                      target: $
                    } = oe, {
                      value: E,
                      selectionStart: H,
                      selectionEnd: ie
                    } = $;
                    let ue = H, fe = ie;
                    switch (oe.inputType) {
                      case "deleteWordBackward": {
                        const pe = E.substring(0, H).match(/\w*[^\w]*$/);
                        pe && (ue -= pe[0].length);
                        break;
                      }
                      case "deleteWordForward": {
                        const pe = E.substring(H).match(/^[^\w]*\w*/);
                        pe && (fe += pe[0].length);
                        break;
                      }
                      case "deleteContentBackward":
                        H === ie && (ue -= 1);
                        break;
                      case "deleteContentForward":
                        H === ie && (fe += 1);
                        break;
                    }
                    oe.preventDefault(), (de = this.linkService.eventBus) == null || de.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id: L,
                        name: "Keystroke",
                        value: E,
                        change: ee || "",
                        willCommit: !1,
                        selStart: ue,
                        selEnd: fe
                      }
                    });
                  }), this._setEventListeners(K, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (oe) => oe.target.value);
                }
                if (D && K.addEventListener("blur", D), this.data.comb) {
                  const oe = (this.data.rect[2] - this.data.rect[0]) / N;
                  K.classList.add("comb"), K.style.letterSpacing = `calc(${oe}px * var(--scale-factor) - 1ch)`;
                }
              } else
                K = document.createElement("div"), K.textContent = this.data.fieldValue, K.style.verticalAlign = "middle", K.style.display = "table-cell";
              return this._setTextStyle(K), this._setBackgroundColor(K), this._setDefaultPropertiesFromJS(K), this.container.append(K), this.container;
            }
          }
          class m extends d {
            constructor(G) {
              super(G, {
                isRenderable: G.renderForms
              });
            }
            render() {
              const G = this.annotationStorage, L = this.data, K = L.id;
              let te = G.getValue(K, {
                value: L.exportValue === L.fieldValue
              }).value;
              typeof te == "string" && (te = te !== "Off", G.setValue(K, {
                value: te
              })), this.container.className = "buttonWidgetAnnotation checkBox";
              const se = document.createElement("input");
              return a.add(se), se.setAttribute("data-element-id", K), se.disabled = L.readOnly, this._setRequired(se, this.data.required), se.type = "checkbox", se.name = L.fieldName, te && se.setAttribute("checked", !0), se.setAttribute("exportValue", L.exportValue), se.tabIndex = C, se.addEventListener("change", (q) => {
                const {
                  name: N,
                  checked: Q
                } = q.target;
                for (const D of this._getElementsByName(N, K)) {
                  const ne = Q && D.exportValue === L.exportValue;
                  D.domElement && (D.domElement.checked = ne), G.setValue(D.id, {
                    value: ne
                  });
                }
                G.setValue(K, {
                  value: Q
                });
              }), se.addEventListener("resetform", (q) => {
                const N = L.defaultFieldValue || "Off";
                q.target.checked = N === L.exportValue;
              }), this.enableScripting && this.hasJSActions && (se.addEventListener("updatefromsandbox", (q) => {
                const N = {
                  value(Q) {
                    Q.target.checked = Q.detail.value !== "Off", G.setValue(K, {
                      value: Q.target.checked
                    });
                  }
                };
                this._dispatchEventFromSandbox(N, q);
              }), this._setEventListeners(se, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (q) => q.target.checked)), this._setBackgroundColor(se), this._setDefaultPropertiesFromJS(se), this.container.append(se), this.container;
            }
          }
          class g extends d {
            constructor(G) {
              super(G, {
                isRenderable: G.renderForms
              });
            }
            render() {
              this.container.className = "buttonWidgetAnnotation radioButton";
              const G = this.annotationStorage, L = this.data, K = L.id;
              let te = G.getValue(K, {
                value: L.fieldValue === L.buttonValue
              }).value;
              typeof te == "string" && (te = te !== L.buttonValue, G.setValue(K, {
                value: te
              }));
              const se = document.createElement("input");
              if (a.add(se), se.setAttribute("data-element-id", K), se.disabled = L.readOnly, this._setRequired(se, this.data.required), se.type = "radio", se.name = L.fieldName, te && se.setAttribute("checked", !0), se.tabIndex = C, se.addEventListener("change", (q) => {
                const {
                  name: N,
                  checked: Q
                } = q.target;
                for (const D of this._getElementsByName(N, K))
                  G.setValue(D.id, {
                    value: !1
                  });
                G.setValue(K, {
                  value: Q
                });
              }), se.addEventListener("resetform", (q) => {
                const N = L.defaultFieldValue;
                q.target.checked = N != null && N === L.buttonValue;
              }), this.enableScripting && this.hasJSActions) {
                const q = L.buttonValue;
                se.addEventListener("updatefromsandbox", (N) => {
                  const Q = {
                    value: (D) => {
                      const ne = q === D.detail.value;
                      for (const oe of this._getElementsByName(D.target.name)) {
                        const ee = ne && oe.id === K;
                        oe.domElement && (oe.domElement.checked = ee), G.setValue(oe.id, {
                          value: ee
                        });
                      }
                    }
                  };
                  this._dispatchEventFromSandbox(Q, N);
                }), this._setEventListeners(se, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (N) => N.target.checked);
              }
              return this._setBackgroundColor(se), this._setDefaultPropertiesFromJS(se), this.container.append(se), this.container;
            }
          }
          class n extends y {
            constructor(G) {
              super(G, {
                ignoreBorder: G.data.hasAppearance
              });
            }
            render() {
              const G = super.render();
              G.className = "buttonWidgetAnnotation pushButton", this.data.alternativeText && (G.title = this.data.alternativeText);
              const L = G.lastChild;
              return this.enableScripting && this.hasJSActions && L && (this._setDefaultPropertiesFromJS(L), L.addEventListener("updatefromsandbox", (K) => {
                this._dispatchEventFromSandbox({}, K);
              })), G;
            }
          }
          class i extends d {
            constructor(G) {
              super(G, {
                isRenderable: G.renderForms
              });
            }
            render() {
              this.container.className = "choiceWidgetAnnotation";
              const G = this.annotationStorage, L = this.data.id, K = G.getValue(L, {
                value: this.data.fieldValue
              }), te = document.createElement("select");
              a.add(te), te.setAttribute("data-element-id", L), te.disabled = this.data.readOnly, this._setRequired(te, this.data.required), te.name = this.data.fieldName, te.tabIndex = C;
              let se = this.data.combo && this.data.options.length > 0;
              this.data.combo || (te.size = this.data.options.length, this.data.multiSelect && (te.multiple = !0)), te.addEventListener("resetform", (D) => {
                const ne = this.data.defaultFieldValue;
                for (const oe of te.options)
                  oe.selected = oe.value === ne;
              });
              for (const D of this.data.options) {
                const ne = document.createElement("option");
                ne.textContent = D.displayValue, ne.value = D.exportValue, K.value.includes(D.exportValue) && (ne.setAttribute("selected", !0), se = !1), te.append(ne);
              }
              let q = null;
              if (se) {
                const D = document.createElement("option");
                D.value = " ", D.setAttribute("hidden", !0), D.setAttribute("selected", !0), te.prepend(D), q = () => {
                  D.remove(), te.removeEventListener("input", q), q = null;
                }, te.addEventListener("input", q);
              }
              const N = (D, ne) => {
                const oe = ne ? "value" : "textContent", ee = D.target.options;
                return D.target.multiple ? Array.prototype.filter.call(ee, ($) => $.selected).map(($) => $[oe]) : ee.selectedIndex === -1 ? null : ee[ee.selectedIndex][oe];
              }, Q = (D) => {
                const ne = D.target.options;
                return Array.prototype.map.call(ne, (oe) => ({
                  displayValue: oe.textContent,
                  exportValue: oe.value
                }));
              };
              return this.enableScripting && this.hasJSActions ? (te.addEventListener("updatefromsandbox", (D) => {
                const ne = {
                  value(oe) {
                    q == null || q();
                    const ee = oe.detail.value, $ = new Set(Array.isArray(ee) ? ee : [ee]);
                    for (const E of te.options)
                      E.selected = $.has(E.value);
                    G.setValue(L, {
                      value: N(oe, !0)
                    });
                  },
                  multipleSelection(oe) {
                    te.multiple = !0;
                  },
                  remove(oe) {
                    const ee = te.options, $ = oe.detail.remove;
                    ee[$].selected = !1, te.remove($), ee.length > 0 && Array.prototype.findIndex.call(ee, (H) => H.selected) === -1 && (ee[0].selected = !0), G.setValue(L, {
                      value: N(oe, !0),
                      items: Q(oe)
                    });
                  },
                  clear(oe) {
                    for (; te.length !== 0; )
                      te.remove(0);
                    G.setValue(L, {
                      value: null,
                      items: []
                    });
                  },
                  insert(oe) {
                    const {
                      index: ee,
                      displayValue: $,
                      exportValue: E
                    } = oe.detail.insert, H = te.children[ee], ie = document.createElement("option");
                    ie.textContent = $, ie.value = E, H ? H.before(ie) : te.append(ie), G.setValue(L, {
                      value: N(oe, !0),
                      items: Q(oe)
                    });
                  },
                  items(oe) {
                    const {
                      items: ee
                    } = oe.detail;
                    for (; te.length !== 0; )
                      te.remove(0);
                    for (const $ of ee) {
                      const {
                        displayValue: E,
                        exportValue: H
                      } = $, ie = document.createElement("option");
                      ie.textContent = E, ie.value = H, te.append(ie);
                    }
                    te.options.length > 0 && (te.options[0].selected = !0), G.setValue(L, {
                      value: N(oe, !0),
                      items: Q(oe)
                    });
                  },
                  indices(oe) {
                    const ee = new Set(oe.detail.indices);
                    for (const $ of oe.target.options)
                      $.selected = ee.has($.index);
                    G.setValue(L, {
                      value: N(oe, !0)
                    });
                  },
                  editable(oe) {
                    oe.target.disabled = !oe.detail.editable;
                  }
                };
                this._dispatchEventFromSandbox(ne, D);
              }), te.addEventListener("input", (D) => {
                var ee;
                const ne = N(D, !0), oe = N(D, !1);
                G.setValue(L, {
                  value: ne
                }), (ee = this.linkService.eventBus) == null || ee.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: L,
                    name: "Keystroke",
                    value: oe,
                    changeEx: ne,
                    willCommit: !0,
                    commitKey: 1,
                    keyDown: !1
                  }
                });
              }), this._setEventListeners(te, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"]], (D) => D.target.checked)) : te.addEventListener("input", function(D) {
                G.setValue(L, {
                  value: N(D, !0)
                });
              }), this.data.combo && this._setTextStyle(te), this._setBackgroundColor(te), this._setDefaultPropertiesFromJS(te), this.container.append(te), this.container;
            }
          }
          class l extends e {
            constructor(G) {
              var K, te, se;
              const L = !!((K = G.data.titleObj) != null && K.str || (te = G.data.contentsObj) != null && te.str || (se = G.data.richText) != null && se.str);
              super(G, {
                isRenderable: L
              });
            }
            render() {
              const G = ["Line", "Square", "Circle", "PolyLine", "Polygon", "Ink"];
              if (this.container.className = "popupAnnotation", G.includes(this.data.parentType))
                return this.container;
              const L = `[data-annotation-id="${this.data.parentId}"]`, K = this.layer.querySelectorAll(L);
              if (K.length === 0)
                return this.container;
              const te = new u({
                container: this.container,
                trigger: Array.from(K),
                color: this.data.color,
                titleObj: this.data.titleObj,
                modificationDate: this.data.modificationDate,
                contentsObj: this.data.contentsObj,
                richText: this.data.richText
              }), se = this.page, q = ce.Util.normalizeRect([this.data.parentRect[0], se.view[3] - this.data.parentRect[1] + se.view[1], this.data.parentRect[2], se.view[3] - this.data.parentRect[3] + se.view[1]]), N = q[0] + this.data.parentRect[2] - this.data.parentRect[0], Q = q[1], [D, ne, oe, ee] = this.viewport.viewBox, $ = oe - D, E = ee - ne;
              return this.container.style.left = `${100 * (N - D) / $}%`, this.container.style.top = `${100 * (Q - ne) / E}%`, this.container.append(te.render()), this.container;
            }
          }
          class u {
            constructor(G) {
              this.container = G.container, this.trigger = G.trigger, this.color = G.color, this.titleObj = G.titleObj, this.modificationDate = G.modificationDate, this.contentsObj = G.contentsObj, this.richText = G.richText, this.hideWrapper = G.hideWrapper || !1, this.pinned = !1;
            }
            render() {
              var N, Q;
              const L = document.createElement("div");
              L.className = "popupWrapper", this.hideElement = this.hideWrapper ? L : this.container, this.hideElement.hidden = !0;
              const K = document.createElement("div");
              K.className = "popup";
              const te = this.color;
              if (te) {
                const D = 0.7 * (255 - te[0]) + te[0], ne = 0.7 * (255 - te[1]) + te[1], oe = 0.7 * (255 - te[2]) + te[2];
                K.style.backgroundColor = ce.Util.makeHexColor(D | 0, ne | 0, oe | 0);
              }
              const se = document.createElement("h1");
              se.dir = this.titleObj.dir, se.textContent = this.titleObj.str, K.append(se);
              const q = re.PDFDateString.toDateObject(this.modificationDate);
              if (q) {
                const D = document.createElement("span");
                D.className = "popupDate", D.textContent = "{{date}}, {{time}}", D.dataset.l10nId = "annotation_date_string", D.dataset.l10nArgs = JSON.stringify({
                  date: q.toLocaleDateString(),
                  time: q.toLocaleTimeString()
                }), K.append(D);
              }
              if ((N = this.richText) != null && N.str && (!((Q = this.contentsObj) != null && Q.str) || this.contentsObj.str === this.richText.str))
                o.XfaLayer.render({
                  xfaHtml: this.richText.html,
                  intent: "richText",
                  div: K
                }), K.lastChild.className = "richText popupContent";
              else {
                const D = this._formatContents(this.contentsObj);
                K.append(D);
              }
              Array.isArray(this.trigger) || (this.trigger = [this.trigger]);
              for (const D of this.trigger)
                D.addEventListener("click", this._toggle.bind(this)), D.addEventListener("mouseover", this._show.bind(this, !1)), D.addEventListener("mouseout", this._hide.bind(this, !1));
              return K.addEventListener("click", this._hide.bind(this, !0)), L.append(K), L;
            }
            _formatContents({
              str: G,
              dir: L
            }) {
              const K = document.createElement("p");
              K.className = "popupContent", K.dir = L;
              const te = G.split(/(?:\r\n?|\n)/);
              for (let se = 0, q = te.length; se < q; ++se) {
                const N = te[se];
                K.append(document.createTextNode(N)), se < q - 1 && K.append(document.createElement("br"));
              }
              return K;
            }
            _toggle() {
              this.pinned ? this._hide(!0) : this._show(!0);
            }
            _show(G = !1) {
              G && (this.pinned = !0), this.hideElement.hidden && (this.hideElement.hidden = !1, this.container.style.zIndex = parseInt(this.container.style.zIndex) + 1e3);
            }
            _hide(G = !0) {
              G && (this.pinned = !1), !this.hideElement.hidden && !this.pinned && (this.hideElement.hidden = !0, this.container.style.zIndex = parseInt(this.container.style.zIndex) - 1e3);
            }
          }
          class w extends e {
            constructor(G) {
              var K, te, se;
              const L = !!(G.data.hasPopup || (K = G.data.titleObj) != null && K.str || (te = G.data.contentsObj) != null && te.str || (se = G.data.richText) != null && se.str);
              super(G, {
                isRenderable: L,
                ignoreBorder: !0
              }), this.textContent = G.data.textContent;
            }
            render() {
              if (this.container.className = "freeTextAnnotation", this.textContent) {
                const G = document.createElement("div");
                G.className = "annotationTextContent", G.setAttribute("role", "comment");
                for (const L of this.textContent) {
                  const K = document.createElement("span");
                  K.textContent = L, G.append(K);
                }
                this.container.append(G);
              }
              return this.data.hasPopup || this._createPopup(null, this.data), this.container;
            }
          }
          class _ extends e {
            constructor(G) {
              var K, te, se;
              const L = !!(G.data.hasPopup || (K = G.data.titleObj) != null && K.str || (te = G.data.contentsObj) != null && te.str || (se = G.data.richText) != null && se.str);
              super(G, {
                isRenderable: L,
                ignoreBorder: !0
              });
            }
            render() {
              this.container.className = "lineAnnotation";
              const G = this.data, {
                width: L,
                height: K
              } = v(G.rect), te = this.svgFactory.create(L, K, !0), se = this.svgFactory.createElement("svg:line");
              return se.setAttribute("x1", G.rect[2] - G.lineCoordinates[0]), se.setAttribute("y1", G.rect[3] - G.lineCoordinates[1]), se.setAttribute("x2", G.rect[2] - G.lineCoordinates[2]), se.setAttribute("y2", G.rect[3] - G.lineCoordinates[3]), se.setAttribute("stroke-width", G.borderStyle.width || 1), se.setAttribute("stroke", "transparent"), se.setAttribute("fill", "transparent"), te.append(se), this.container.append(te), this._createPopup(se, G), this.container;
            }
          }
          class b extends e {
            constructor(G) {
              var K, te, se;
              const L = !!(G.data.hasPopup || (K = G.data.titleObj) != null && K.str || (te = G.data.contentsObj) != null && te.str || (se = G.data.richText) != null && se.str);
              super(G, {
                isRenderable: L,
                ignoreBorder: !0
              });
            }
            render() {
              this.container.className = "squareAnnotation";
              const G = this.data, {
                width: L,
                height: K
              } = v(G.rect), te = this.svgFactory.create(L, K, !0), se = G.borderStyle.width, q = this.svgFactory.createElement("svg:rect");
              return q.setAttribute("x", se / 2), q.setAttribute("y", se / 2), q.setAttribute("width", L - se), q.setAttribute("height", K - se), q.setAttribute("stroke-width", se || 1), q.setAttribute("stroke", "transparent"), q.setAttribute("fill", "transparent"), te.append(q), this.container.append(te), this._createPopup(q, G), this.container;
            }
          }
          class A extends e {
            constructor(G) {
              var K, te, se;
              const L = !!(G.data.hasPopup || (K = G.data.titleObj) != null && K.str || (te = G.data.contentsObj) != null && te.str || (se = G.data.richText) != null && se.str);
              super(G, {
                isRenderable: L,
                ignoreBorder: !0
              });
            }
            render() {
              this.container.className = "circleAnnotation";
              const G = this.data, {
                width: L,
                height: K
              } = v(G.rect), te = this.svgFactory.create(L, K, !0), se = G.borderStyle.width, q = this.svgFactory.createElement("svg:ellipse");
              return q.setAttribute("cx", L / 2), q.setAttribute("cy", K / 2), q.setAttribute("rx", L / 2 - se / 2), q.setAttribute("ry", K / 2 - se / 2), q.setAttribute("stroke-width", se || 1), q.setAttribute("stroke", "transparent"), q.setAttribute("fill", "transparent"), te.append(q), this.container.append(te), this._createPopup(q, G), this.container;
            }
          }
          class Y extends e {
            constructor(G) {
              var K, te, se;
              const L = !!(G.data.hasPopup || (K = G.data.titleObj) != null && K.str || (te = G.data.contentsObj) != null && te.str || (se = G.data.richText) != null && se.str);
              super(G, {
                isRenderable: L,
                ignoreBorder: !0
              }), this.containerClassName = "polylineAnnotation", this.svgElementName = "svg:polyline";
            }
            render() {
              this.container.className = this.containerClassName;
              const G = this.data, {
                width: L,
                height: K
              } = v(G.rect), te = this.svgFactory.create(L, K, !0);
              let se = [];
              for (const N of G.vertices) {
                const Q = N.x - G.rect[0], D = G.rect[3] - N.y;
                se.push(Q + "," + D);
              }
              se = se.join(" ");
              const q = this.svgFactory.createElement(this.svgElementName);
              return q.setAttribute("points", se), q.setAttribute("stroke-width", G.borderStyle.width || 1), q.setAttribute("stroke", "transparent"), q.setAttribute("fill", "transparent"), te.append(q), this.container.append(te), this._createPopup(q, G), this.container;
            }
          }
          class j extends Y {
            constructor(G) {
              super(G), this.containerClassName = "polygonAnnotation", this.svgElementName = "svg:polygon";
            }
          }
          class X extends e {
            constructor(G) {
              var K, te, se;
              const L = !!(G.data.hasPopup || (K = G.data.titleObj) != null && K.str || (te = G.data.contentsObj) != null && te.str || (se = G.data.richText) != null && se.str);
              super(G, {
                isRenderable: L,
                ignoreBorder: !0
              });
            }
            render() {
              return this.container.className = "caretAnnotation", this.data.hasPopup || this._createPopup(null, this.data), this.container;
            }
          }
          class B extends e {
            constructor(G) {
              var K, te, se;
              const L = !!(G.data.hasPopup || (K = G.data.titleObj) != null && K.str || (te = G.data.contentsObj) != null && te.str || (se = G.data.richText) != null && se.str);
              super(G, {
                isRenderable: L,
                ignoreBorder: !0
              }), this.containerClassName = "inkAnnotation", this.svgElementName = "svg:polyline";
            }
            render() {
              this.container.className = this.containerClassName;
              const G = this.data, {
                width: L,
                height: K
              } = v(G.rect), te = this.svgFactory.create(L, K, !0);
              for (const se of G.inkLists) {
                let q = [];
                for (const Q of se) {
                  const D = Q.x - G.rect[0], ne = G.rect[3] - Q.y;
                  q.push(`${D},${ne}`);
                }
                q = q.join(" ");
                const N = this.svgFactory.createElement(this.svgElementName);
                N.setAttribute("points", q), N.setAttribute("stroke-width", G.borderStyle.width || 1), N.setAttribute("stroke", "transparent"), N.setAttribute("fill", "transparent"), this._createPopup(N, G), te.append(N);
              }
              return this.container.append(te), this.container;
            }
          }
          class R extends e {
            constructor(G) {
              var K, te, se;
              const L = !!(G.data.hasPopup || (K = G.data.titleObj) != null && K.str || (te = G.data.contentsObj) != null && te.str || (se = G.data.richText) != null && se.str);
              super(G, {
                isRenderable: L,
                ignoreBorder: !0,
                createQuadrilaterals: !0
              });
            }
            render() {
              return this.data.hasPopup || this._createPopup(null, this.data), this.quadrilaterals ? this._renderQuadrilaterals("highlightAnnotation") : (this.container.className = "highlightAnnotation", this.container);
            }
          }
          class k extends e {
            constructor(G) {
              var K, te, se;
              const L = !!(G.data.hasPopup || (K = G.data.titleObj) != null && K.str || (te = G.data.contentsObj) != null && te.str || (se = G.data.richText) != null && se.str);
              super(G, {
                isRenderable: L,
                ignoreBorder: !0,
                createQuadrilaterals: !0
              });
            }
            render() {
              return this.data.hasPopup || this._createPopup(null, this.data), this.quadrilaterals ? this._renderQuadrilaterals("underlineAnnotation") : (this.container.className = "underlineAnnotation", this.container);
            }
          }
          class x extends e {
            constructor(G) {
              var K, te, se;
              const L = !!(G.data.hasPopup || (K = G.data.titleObj) != null && K.str || (te = G.data.contentsObj) != null && te.str || (se = G.data.richText) != null && se.str);
              super(G, {
                isRenderable: L,
                ignoreBorder: !0,
                createQuadrilaterals: !0
              });
            }
            render() {
              return this.data.hasPopup || this._createPopup(null, this.data), this.quadrilaterals ? this._renderQuadrilaterals("squigglyAnnotation") : (this.container.className = "squigglyAnnotation", this.container);
            }
          }
          class f extends e {
            constructor(G) {
              var K, te, se;
              const L = !!(G.data.hasPopup || (K = G.data.titleObj) != null && K.str || (te = G.data.contentsObj) != null && te.str || (se = G.data.richText) != null && se.str);
              super(G, {
                isRenderable: L,
                ignoreBorder: !0,
                createQuadrilaterals: !0
              });
            }
            render() {
              return this.data.hasPopup || this._createPopup(null, this.data), this.quadrilaterals ? this._renderQuadrilaterals("strikeoutAnnotation") : (this.container.className = "strikeoutAnnotation", this.container);
            }
          }
          class U extends e {
            constructor(G) {
              var K, te, se;
              const L = !!(G.data.hasPopup || (K = G.data.titleObj) != null && K.str || (te = G.data.contentsObj) != null && te.str || (se = G.data.richText) != null && se.str);
              super(G, {
                isRenderable: L,
                ignoreBorder: !0
              });
            }
            render() {
              return this.container.className = "stampAnnotation", this.data.hasPopup || this._createPopup(null, this.data), this.container;
            }
          }
          class O extends e {
            constructor(G) {
              var te;
              super(G, {
                isRenderable: !0
              });
              const {
                filename: L,
                content: K
              } = this.data.file;
              this.filename = (0, re.getFilenameFromUrl)(L), this.content = K, (te = this.linkService.eventBus) == null || te.dispatch("fileattachmentannotation", {
                source: this,
                filename: L,
                content: K
              });
            }
            render() {
              var L, K;
              this.container.className = "fileAttachmentAnnotation";
              const G = document.createElement("div");
              return G.className = "popupTriggerArea", G.addEventListener("dblclick", this._download.bind(this)), !this.data.hasPopup && ((L = this.data.titleObj) != null && L.str || (K = this.data.contentsObj) != null && K.str || this.data.richText) && this._createPopup(G, this.data), this.container.append(G), this.container;
            }
            _download() {
              var G;
              (G = this.downloadManager) == null || G.openOrDownloadData(this.container, this.content, this.filename);
            }
          }
          const W = class {
            static render(G) {
              var N, Q;
              const {
                annotations: L,
                div: K,
                viewport: te,
                accessibilityManager: se
              } = G;
              dt(this, I, yi).call(this, K, te);
              let q = 0;
              for (const D of L) {
                if (D.annotationType !== ce.AnnotationType.POPUP) {
                  const {
                    width: oe,
                    height: ee
                  } = v(D.rect);
                  if (oe <= 0 || ee <= 0)
                    continue;
                }
                const ne = h.create({
                  data: D,
                  layer: K,
                  page: G.page,
                  viewport: te,
                  linkService: G.linkService,
                  downloadManager: G.downloadManager,
                  imageResourcesPath: G.imageResourcesPath || "",
                  renderForms: G.renderForms !== !1,
                  svgFactory: new re.DOMSVGFactory(),
                  annotationStorage: G.annotationStorage || new ae.AnnotationStorage(),
                  enableScripting: G.enableScripting,
                  hasJSActions: G.hasJSActions,
                  fieldObjects: G.fieldObjects,
                  mouseState: G.mouseState || {
                    isDown: !1
                  }
                });
                if (ne.isRenderable) {
                  const oe = ne.render();
                  if (D.hidden && (oe.style.visibility = "hidden"), Array.isArray(oe))
                    for (const ee of oe)
                      ee.style.zIndex = q++, dt(N = W, F, bi).call(N, ee, D.id, K, se);
                  else
                    oe.style.zIndex = q++, ne instanceof l ? K.prepend(oe) : dt(Q = W, F, bi).call(Q, oe, D.id, K, se);
                }
              }
              dt(this, V, vi).call(this, K, G.annotationCanvasMap);
            }
            static update(G) {
              const {
                annotationCanvasMap: L,
                div: K,
                viewport: te
              } = G;
              dt(this, I, yi).call(this, K, te), dt(this, V, vi).call(this, K, L), K.hidden = !1;
            }
          };
          let S = W;
          F = new WeakSet(), bi = function(G, L, K, te) {
            const se = G.firstChild || G;
            se.id = `${re.AnnotationPrefix}${L}`, K.append(G), te == null || te.moveElementInDOM(K, G, se, !1);
          }, I = new WeakSet(), yi = function(G, {
            width: L,
            height: K,
            rotation: te
          }) {
            const {
              style: se
            } = G, q = te % 180 !== 0, N = Math.floor(L) + "px", Q = Math.floor(K) + "px";
            se.width = q ? Q : N, se.height = q ? N : Q, G.setAttribute("data-main-rotation", te);
          }, V = new WeakSet(), vi = function(G, L) {
            if (L) {
              for (const [K, te] of L) {
                const se = G.querySelector(`[data-annotation-id="${K}"]`);
                if (!se)
                  continue;
                const {
                  firstChild: q
                } = se;
                q ? q.nodeName === "CANVAS" ? q.replaceWith(te) : q.before(te) : se.append(te);
              }
              L.clear();
            }
          }, ot(S, F), ot(S, I), ot(S, V), ge.AnnotationLayer = S;
        },
        /* 28 */
        /***/
        (be, ge) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.ColorConverters = void 0;
          function le(re) {
            return Math.floor(Math.max(0, Math.min(1, re)) * 255).toString(16).padStart(2, "0");
          }
          class ce {
            static CMYK_G([ae, Z, o, C]) {
              return ["G", 1 - Math.min(1, 0.3 * ae + 0.59 * o + 0.11 * Z + C)];
            }
            static G_CMYK([ae]) {
              return ["CMYK", 0, 0, 0, 1 - ae];
            }
            static G_RGB([ae]) {
              return ["RGB", ae, ae, ae];
            }
            static G_HTML([ae]) {
              const Z = le(ae);
              return `#${Z}${Z}${Z}`;
            }
            static RGB_G([ae, Z, o]) {
              return ["G", 0.3 * ae + 0.59 * Z + 0.11 * o];
            }
            static RGB_HTML([ae, Z, o]) {
              const C = le(ae), t = le(Z), a = le(o);
              return `#${C}${t}${a}`;
            }
            static T_HTML() {
              return "#00000000";
            }
            static CMYK_RGB([ae, Z, o, C]) {
              return ["RGB", 1 - Math.min(1, ae + C), 1 - Math.min(1, o + C), 1 - Math.min(1, Z + C)];
            }
            static CMYK_HTML(ae) {
              const Z = this.CMYK_RGB(ae).slice(1);
              return this.RGB_HTML(Z);
            }
            static RGB_CMYK([ae, Z, o]) {
              const C = 1 - ae, t = 1 - Z, a = 1 - o, v = Math.min(C, t, a);
              return ["CMYK", C, t, a, v];
            }
          }
          ge.ColorConverters = ce;
        },
        /* 29 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.XfaLayer = void 0;
          var ce = le(20);
          class re {
            static setupStorage(Z, o, C, t, a) {
              const v = t.getValue(o, {
                value: null
              });
              switch (C.name) {
                case "textarea":
                  if (v.value !== null && (Z.textContent = v.value), a === "print")
                    break;
                  Z.addEventListener("input", (h) => {
                    t.setValue(o, {
                      value: h.target.value
                    });
                  });
                  break;
                case "input":
                  if (C.attributes.type === "radio" || C.attributes.type === "checkbox") {
                    if (v.value === C.attributes.xfaOn ? Z.setAttribute("checked", !0) : v.value === C.attributes.xfaOff && Z.removeAttribute("checked"), a === "print")
                      break;
                    Z.addEventListener("change", (h) => {
                      t.setValue(o, {
                        value: h.target.checked ? h.target.getAttribute("xfaOn") : h.target.getAttribute("xfaOff")
                      });
                    });
                  } else {
                    if (v.value !== null && Z.setAttribute("value", v.value), a === "print")
                      break;
                    Z.addEventListener("input", (h) => {
                      t.setValue(o, {
                        value: h.target.value
                      });
                    });
                  }
                  break;
                case "select":
                  if (v.value !== null)
                    for (const h of C.children)
                      h.attributes.value === v.value && (h.attributes.selected = !0);
                  Z.addEventListener("input", (h) => {
                    const e = h.target.options, y = e.selectedIndex === -1 ? "" : e[e.selectedIndex].value;
                    t.setValue(o, {
                      value: y
                    });
                  });
                  break;
              }
            }
            static setAttributes({
              html: Z,
              element: o,
              storage: C = null,
              intent: t,
              linkService: a
            }) {
              const {
                attributes: v
              } = o, h = Z instanceof HTMLAnchorElement;
              v.type === "radio" && (v.name = `${v.name}-${t}`);
              for (const [e, y] of Object.entries(v))
                if (y != null)
                  switch (e) {
                    case "class":
                      y.length && Z.setAttribute(e, y.join(" "));
                      break;
                    case "dataId":
                      break;
                    case "id":
                      Z.setAttribute("data-element-id", y);
                      break;
                    case "style":
                      Object.assign(Z.style, y);
                      break;
                    case "textContent":
                      Z.textContent = y;
                      break;
                    default:
                      (!h || e !== "href" && e !== "newWindow") && Z.setAttribute(e, y);
                  }
              h && a.addLinkAttributes(Z, v.href, v.newWindow), C && v.dataId && this.setupStorage(Z, v.dataId, o, C);
            }
            static render(Z) {
              var c;
              const o = Z.annotationStorage, C = Z.linkService, t = Z.xfaHtml, a = Z.intent || "display", v = document.createElement(t.name);
              t.attributes && this.setAttributes({
                html: v,
                element: t,
                intent: a,
                linkService: C
              });
              const h = [[t, -1, v]], e = Z.div;
              if (e.append(v), Z.viewport) {
                const d = `matrix(${Z.viewport.transform.join(",")})`;
                e.style.transform = d;
              }
              a !== "richText" && e.setAttribute("class", "xfaLayer xfaFont");
              const y = [];
              for (; h.length > 0; ) {
                const [d, p, m] = h.at(-1);
                if (p + 1 === d.children.length) {
                  h.pop();
                  continue;
                }
                const g = d.children[++h.at(-1)[1]];
                if (g === null)
                  continue;
                const {
                  name: n
                } = g;
                if (n === "#text") {
                  const l = document.createTextNode(g.value);
                  y.push(l), m.append(l);
                  continue;
                }
                let i;
                if ((c = g == null ? void 0 : g.attributes) != null && c.xmlns ? i = document.createElementNS(g.attributes.xmlns, n) : i = document.createElement(n), m.append(i), g.attributes && this.setAttributes({
                  html: i,
                  element: g,
                  storage: o,
                  intent: a,
                  linkService: C
                }), g.children && g.children.length > 0)
                  h.push([g, -1, i]);
                else if (g.value) {
                  const l = document.createTextNode(g.value);
                  ce.XfaText.shouldBuildText(n) && y.push(l), i.append(l);
                }
              }
              for (const d of e.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea"))
                d.setAttribute("readOnly", !0);
              return {
                textDivs: y
              };
            }
            static update(Z) {
              const o = `matrix(${Z.viewport.transform.join(",")})`;
              Z.div.style.transform = o, Z.div.hidden = !1;
            }
          }
          ge.XfaLayer = re;
        },
        /* 30 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.TextLayerRenderTask = void 0, ge.renderTextLayer = m;
          var ce = le(1), re = le(8);
          const ae = 1e5, Z = 30, o = 0.8, C = /* @__PURE__ */ new Map(), t = /^\s+$/g;
          function a(g, n) {
            const i = C.get(g);
            if (i)
              return i;
            n.save(), n.font = `${Z}px ${g}`;
            const l = n.measureText("");
            let u = l.fontBoundingBoxAscent, w = Math.abs(l.fontBoundingBoxDescent);
            if (u) {
              n.restore();
              const b = u / (u + w);
              return C.set(g, b), b;
            }
            n.strokeStyle = "red", n.clearRect(0, 0, Z, Z), n.strokeText("g", 0, 0);
            let _ = n.getImageData(0, 0, Z, Z).data;
            w = 0;
            for (let b = _.length - 1 - 3; b >= 0; b -= 4)
              if (_[b] > 0) {
                w = Math.ceil(b / 4 / Z);
                break;
              }
            n.clearRect(0, 0, Z, Z), n.strokeText("A", 0, Z), _ = n.getImageData(0, 0, Z, Z).data, u = 0;
            for (let b = 0, A = _.length; b < A; b += 4)
              if (_[b] > 0) {
                u = Z - Math.floor(b / 4 / Z);
                break;
              }
            if (n.restore(), u) {
              const b = u / (u + w);
              return C.set(g, b), b;
            }
            return C.set(g, o), o;
          }
          function v(g, n, i, l) {
            const u = document.createElement("span"), w = g._enhanceTextSelection ? {
              angle: 0,
              canvasWidth: 0,
              hasText: n.str !== "",
              hasEOL: n.hasEOL,
              originalTransform: null,
              paddingBottom: 0,
              paddingLeft: 0,
              paddingRight: 0,
              paddingTop: 0,
              scale: 1,
              fontSize: 0
            } : {
              angle: 0,
              canvasWidth: 0,
              hasText: n.str !== "",
              hasEOL: n.hasEOL,
              fontSize: 0
            };
            g._textDivs.push(u);
            const _ = ce.Util.transform(g._viewport.transform, n.transform);
            let b = Math.atan2(_[1], _[0]);
            const A = i[n.fontName];
            A.vertical && (b += Math.PI / 2);
            const Y = Math.hypot(_[2], _[3]), j = Y * a(A.fontFamily, l);
            let X, B;
            b === 0 ? (X = _[4], B = _[5] - j) : (X = _[4] + j * Math.sin(b), B = _[5] - j * Math.cos(b)), u.style.left = `${X}px`, u.style.top = `${B}px`, u.style.fontSize = `${Y}px`, u.style.fontFamily = A.fontFamily, w.fontSize = Y, u.setAttribute("role", "presentation"), u.textContent = n.str, u.dir = n.dir, g._fontInspectorEnabled && (u.dataset.fontName = n.fontName), b !== 0 && (w.angle = b * (180 / Math.PI));
            let R = !1;
            if (n.str.length > 1 || g._enhanceTextSelection && t.test(n.str))
              R = !0;
            else if (n.str !== " " && n.transform[0] !== n.transform[3]) {
              const k = Math.abs(n.transform[0]), x = Math.abs(n.transform[3]);
              k !== x && Math.max(k, x) / Math.min(k, x) > 1.5 && (R = !0);
            }
            if (R && (A.vertical ? w.canvasWidth = n.height * g._viewport.scale : w.canvasWidth = n.width * g._viewport.scale), g._textDivProperties.set(u, w), g._textContentStream && g._layoutText(u), g._enhanceTextSelection && w.hasText) {
              let k = 1, x = 0;
              b !== 0 && (k = Math.cos(b), x = Math.sin(b));
              const f = (A.vertical ? n.height : n.width) * g._viewport.scale, U = Y;
              let O, S;
              b !== 0 ? (O = [k, x, -x, k, X, B], S = ce.Util.getAxialAlignedBoundingBox([0, 0, f, U], O)) : S = [X, B, X + f, B + U], g._bounds.push({
                left: S[0],
                top: S[1],
                right: S[2],
                bottom: S[3],
                div: u,
                size: [f, U],
                m: O
              });
            }
          }
          function h(g) {
            if (g._canceled)
              return;
            const n = g._textDivs, i = g._capability, l = n.length;
            if (l > ae) {
              g._renderingDone = !0, i.resolve();
              return;
            }
            if (!g._textContentStream)
              for (let u = 0; u < l; u++)
                g._layoutText(n[u]);
            g._renderingDone = !0, i.resolve();
          }
          function e(g, n, i) {
            let l = 0;
            for (let u = 0; u < i; u++) {
              const w = g[n++];
              w > 0 && (l = l ? Math.min(w, l) : w);
            }
            return l;
          }
          function y(g) {
            const n = g._bounds, i = g._viewport, l = c(i.width, i.height, n);
            for (let u = 0; u < l.length; u++) {
              const w = n[u].div, _ = g._textDivProperties.get(w);
              if (_.angle === 0) {
                _.paddingLeft = n[u].left - l[u].left, _.paddingTop = n[u].top - l[u].top, _.paddingRight = l[u].right - n[u].right, _.paddingBottom = l[u].bottom - n[u].bottom, g._textDivProperties.set(w, _);
                continue;
              }
              const b = l[u], A = n[u], Y = A.m, j = Y[0], X = Y[1], B = [[0, 0], [0, A.size[1]], [A.size[0], 0], A.size], R = new Float64Array(64);
              for (let x = 0, f = B.length; x < f; x++) {
                const U = ce.Util.applyTransform(B[x], Y);
                R[x + 0] = j && (b.left - U[0]) / j, R[x + 4] = X && (b.top - U[1]) / X, R[x + 8] = j && (b.right - U[0]) / j, R[x + 12] = X && (b.bottom - U[1]) / X, R[x + 16] = X && (b.left - U[0]) / -X, R[x + 20] = j && (b.top - U[1]) / j, R[x + 24] = X && (b.right - U[0]) / -X, R[x + 28] = j && (b.bottom - U[1]) / j, R[x + 32] = j && (b.left - U[0]) / -j, R[x + 36] = X && (b.top - U[1]) / -X, R[x + 40] = j && (b.right - U[0]) / -j, R[x + 44] = X && (b.bottom - U[1]) / -X, R[x + 48] = X && (b.left - U[0]) / X, R[x + 52] = j && (b.top - U[1]) / -j, R[x + 56] = X && (b.right - U[0]) / X, R[x + 60] = j && (b.bottom - U[1]) / -j;
              }
              const k = 1 + Math.min(Math.abs(j), Math.abs(X));
              _.paddingLeft = e(R, 32, 16) / k, _.paddingTop = e(R, 48, 16) / k, _.paddingRight = e(R, 0, 16) / k, _.paddingBottom = e(R, 16, 16) / k, g._textDivProperties.set(w, _);
            }
          }
          function c(g, n, i) {
            const l = i.map(function(w, _) {
              return {
                x1: w.left,
                y1: w.top,
                x2: w.right,
                y2: w.bottom,
                index: _,
                x1New: void 0,
                x2New: void 0
              };
            });
            d(g, l);
            const u = new Array(i.length);
            for (const w of l) {
              const _ = w.index;
              u[_] = {
                left: w.x1New,
                top: 0,
                right: w.x2New,
                bottom: 0
              };
            }
            i.map(function(w, _) {
              const b = u[_], A = l[_];
              A.x1 = w.top, A.y1 = g - b.right, A.x2 = w.bottom, A.y2 = g - b.left, A.index = _, A.x1New = void 0, A.x2New = void 0;
            }), d(n, l);
            for (const w of l) {
              const _ = w.index;
              u[_].top = w.x1New, u[_].bottom = w.x2New;
            }
            return u;
          }
          function d(g, n) {
            n.sort(function(u, w) {
              return u.x1 - w.x1 || u.index - w.index;
            });
            const l = [{
              start: -1 / 0,
              end: 1 / 0,
              boundary: {
                x1: -1 / 0,
                y1: -1 / 0,
                x2: 0,
                y2: 1 / 0,
                index: -1,
                x1New: 0,
                x2New: 0
              }
            }];
            for (const u of n) {
              let w = 0;
              for (; w < l.length && l[w].end <= u.y1; )
                w++;
              let _ = l.length - 1;
              for (; _ >= 0 && l[_].start >= u.y2; )
                _--;
              let b, A, Y, j, X = -1 / 0;
              for (Y = w; Y <= _; Y++) {
                b = l[Y], A = b.boundary;
                let k;
                A.x2 > u.x1 ? k = A.index > u.index ? A.x1New : u.x1 : A.x2New === void 0 ? k = (A.x2 + u.x1) / 2 : k = A.x2New, k > X && (X = k);
              }
              for (u.x1New = X, Y = w; Y <= _; Y++)
                b = l[Y], A = b.boundary, A.x2New === void 0 ? A.x2 > u.x1 ? A.index > u.index && (A.x2New = A.x2) : A.x2New = X : A.x2New > X && (A.x2New = Math.max(X, A.x2));
              const B = [];
              let R = null;
              for (Y = w; Y <= _; Y++) {
                b = l[Y], A = b.boundary;
                const k = A.x2 > u.x2 ? A : u;
                R === k ? B.at(-1).end = b.end : (B.push({
                  start: b.start,
                  end: b.end,
                  boundary: k
                }), R = k);
              }
              for (l[w].start < u.y1 && (B[0].start = u.y1, B.unshift({
                start: l[w].start,
                end: u.y1,
                boundary: l[w].boundary
              })), u.y2 < l[_].end && (B.at(-1).end = u.y2, B.push({
                start: u.y2,
                end: l[_].end,
                boundary: l[_].boundary
              })), Y = w; Y <= _; Y++) {
                if (b = l[Y], A = b.boundary, A.x2New !== void 0)
                  continue;
                let k = !1;
                for (j = w - 1; !k && j >= 0 && l[j].start >= A.y1; j--)
                  k = l[j].boundary === A;
                for (j = _ + 1; !k && j < l.length && l[j].end <= A.y2; j++)
                  k = l[j].boundary === A;
                for (j = 0; !k && j < B.length; j++)
                  k = B[j].boundary === A;
                k || (A.x2New = X);
              }
              Array.prototype.splice.apply(l, [w, _ - w + 1, ...B]);
            }
            for (const u of l) {
              const w = u.boundary;
              w.x2New === void 0 && (w.x2New = Math.max(g, w.x2));
            }
          }
          class p {
            constructor({
              textContent: n,
              textContentStream: i,
              container: l,
              viewport: u,
              textDivs: w,
              textContentItemsStr: _,
              enhanceTextSelection: b
            }) {
              var A;
              b && (0, re.deprecated)("The `enhanceTextSelection` functionality will be removed in the future."), this._textContent = n, this._textContentStream = i, this._container = l, this._document = l.ownerDocument, this._viewport = u, this._textDivs = w || [], this._textContentItemsStr = _ || [], this._enhanceTextSelection = !!b, this._fontInspectorEnabled = !!((A = globalThis.FontInspector) != null && A.enabled), this._reader = null, this._layoutTextLastFontSize = null, this._layoutTextLastFontFamily = null, this._layoutTextCtx = null, this._textDivProperties = /* @__PURE__ */ new WeakMap(), this._renderingDone = !1, this._canceled = !1, this._capability = (0, ce.createPromiseCapability)(), this._renderTimer = null, this._bounds = [], this._devicePixelRatio = globalThis.devicePixelRatio || 1, this._capability.promise.finally(() => {
                this._enhanceTextSelection || (this._textDivProperties = null), this._layoutTextCtx && (this._layoutTextCtx.canvas.width = 0, this._layoutTextCtx.canvas.height = 0, this._layoutTextCtx = null);
              }).catch(() => {
              });
            }
            get promise() {
              return this._capability.promise;
            }
            cancel() {
              this._canceled = !0, this._reader && (this._reader.cancel(new ce.AbortException("TextLayer task cancelled.")).catch(() => {
              }), this._reader = null), this._renderTimer !== null && (clearTimeout(this._renderTimer), this._renderTimer = null), this._capability.reject(new Error("TextLayer task cancelled."));
            }
            _processItems(n, i) {
              for (let l = 0, u = n.length; l < u; l++) {
                if (n[l].str === void 0) {
                  if (n[l].type === "beginMarkedContentProps" || n[l].type === "beginMarkedContent") {
                    const w = this._container;
                    this._container = document.createElement("span"), this._container.classList.add("markedContent"), n[l].id !== null && this._container.setAttribute("id", `${n[l].id}`), w.append(this._container);
                  } else
                    n[l].type === "endMarkedContent" && (this._container = this._container.parentNode);
                  continue;
                }
                this._textContentItemsStr.push(n[l].str), v(this, n[l], i, this._layoutTextCtx);
              }
            }
            _layoutText(n) {
              const i = this._textDivProperties.get(n);
              let l = "";
              if (i.canvasWidth !== 0 && i.hasText) {
                const {
                  fontFamily: u
                } = n.style, {
                  fontSize: w
                } = i;
                (w !== this._layoutTextLastFontSize || u !== this._layoutTextLastFontFamily) && (this._layoutTextCtx.font = `${w * this._devicePixelRatio}px ${u}`, this._layoutTextLastFontSize = w, this._layoutTextLastFontFamily = u);
                const {
                  width: _
                } = this._layoutTextCtx.measureText(n.textContent);
                if (_ > 0) {
                  const b = this._devicePixelRatio * i.canvasWidth / _;
                  this._enhanceTextSelection && (i.scale = b), l = `scaleX(${b})`;
                }
              }
              if (i.angle !== 0 && (l = `rotate(${i.angle}deg) ${l}`), l.length > 0 && (this._enhanceTextSelection && (i.originalTransform = l), n.style.transform = l), i.hasText && this._container.append(n), i.hasEOL) {
                const u = document.createElement("br");
                u.setAttribute("role", "presentation"), this._container.append(u);
              }
            }
            _render(n = 0) {
              const i = (0, ce.createPromiseCapability)();
              let l = /* @__PURE__ */ Object.create(null);
              const u = this._document.createElement("canvas");
              if (u.height = u.width = Z, this._layoutTextCtx = u.getContext("2d", {
                alpha: !1
              }), this._textContent) {
                const w = this._textContent.items, _ = this._textContent.styles;
                this._processItems(w, _), i.resolve();
              } else if (this._textContentStream) {
                const w = () => {
                  this._reader.read().then(({
                    value: _,
                    done: b
                  }) => {
                    if (b) {
                      i.resolve();
                      return;
                    }
                    Object.assign(l, _.styles), this._processItems(_.items, l), w();
                  }, i.reject);
                };
                this._reader = this._textContentStream.getReader(), w();
              } else
                throw new Error('Neither "textContent" nor "textContentStream" parameters specified.');
              i.promise.then(() => {
                l = null, n ? this._renderTimer = setTimeout(() => {
                  h(this), this._renderTimer = null;
                }, n) : h(this);
              }, this._capability.reject);
            }
            expandTextDivs(n = !1) {
              if (!this._enhanceTextSelection || !this._renderingDone)
                return;
              this._bounds !== null && (y(this), this._bounds = null);
              const i = [], l = [];
              for (let u = 0, w = this._textDivs.length; u < w; u++) {
                const _ = this._textDivs[u], b = this._textDivProperties.get(_);
                b.hasText && (n ? (i.length = 0, l.length = 0, b.originalTransform && i.push(b.originalTransform), b.paddingTop > 0 ? (l.push(`${b.paddingTop}px`), i.push(`translateY(${-b.paddingTop}px)`)) : l.push(0), b.paddingRight > 0 ? l.push(`${b.paddingRight / b.scale}px`) : l.push(0), b.paddingBottom > 0 ? l.push(`${b.paddingBottom}px`) : l.push(0), b.paddingLeft > 0 ? (l.push(`${b.paddingLeft / b.scale}px`), i.push(`translateX(${-b.paddingLeft / b.scale}px)`)) : l.push(0), _.style.padding = l.join(" "), i.length && (_.style.transform = i.join(" "))) : (_.style.padding = null, _.style.transform = b.originalTransform));
              }
            }
          }
          ge.TextLayerRenderTask = p;
          function m(g) {
            const n = new p({
              textContent: g.textContent,
              textContentStream: g.textContentStream,
              container: g.container,
              viewport: g.viewport,
              textDivs: g.textDivs,
              textContentItemsStr: g.textContentItemsStr,
              enhanceTextSelection: g.enhanceTextSelection
            });
            return n._render(g.timeout), n;
          }
        },
        /* 31 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.SVGGraphics = void 0;
          var ce = le(8), re = le(1), ae = le(3);
          let Z = class {
            constructor() {
              (0, re.unreachable)("Not implemented: SVGGraphics");
            }
          };
          ge.SVGGraphics = Z;
          {
            let c = function(i) {
              let l = [];
              const u = [];
              for (const w of i) {
                if (w.fn === "save") {
                  l.push({
                    fnId: 92,
                    fn: "group",
                    items: []
                  }), u.push(l), l = l.at(-1).items;
                  continue;
                }
                w.fn === "restore" ? l = u.pop() : l.push(w);
              }
              return l;
            }, d = function(i) {
              if (Number.isInteger(i))
                return i.toString();
              const l = i.toFixed(10);
              let u = l.length - 1;
              if (l[u] !== "0")
                return l;
              do
                u--;
              while (l[u] === "0");
              return l.substring(0, l[u] === "." ? u : u + 1);
            }, p = function(i) {
              if (i[4] === 0 && i[5] === 0) {
                if (i[1] === 0 && i[2] === 0)
                  return i[0] === 1 && i[3] === 1 ? "" : `scale(${d(i[0])} ${d(i[3])})`;
                if (i[0] === i[3] && i[1] === -i[2]) {
                  const l = Math.acos(i[0]) * 180 / Math.PI;
                  return `rotate(${d(l)})`;
                }
              } else if (i[0] === 1 && i[1] === 0 && i[2] === 0 && i[3] === 1)
                return `translate(${d(i[4])} ${d(i[5])})`;
              return `matrix(${d(i[0])} ${d(i[1])} ${d(i[2])} ${d(i[3])} ${d(i[4])} ${d(i[5])})`;
            };
            const o = {
              fontStyle: "normal",
              fontWeight: "normal",
              fillColor: "#000000"
            }, C = "http://www.w3.org/XML/1998/namespace", t = "http://www.w3.org/1999/xlink", a = ["butt", "round", "square"], v = ["miter", "round", "bevel"], h = function(i, l = "", u = !1) {
              if (URL.createObjectURL && typeof Blob < "u" && !u)
                return URL.createObjectURL(new Blob([i], {
                  type: l
                }));
              const w = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
              let _ = `data:${l};base64,`;
              for (let b = 0, A = i.length; b < A; b += 3) {
                const Y = i[b] & 255, j = i[b + 1] & 255, X = i[b + 2] & 255, B = Y >> 2, R = (Y & 3) << 4 | j >> 4, k = b + 1 < A ? (j & 15) << 2 | X >> 6 : 64, x = b + 2 < A ? X & 63 : 64;
                _ += w[B] + w[R] + w[k] + w[x];
              }
              return _;
            }, e = function() {
              const i = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]), l = 12, u = new Int32Array(256);
              for (let X = 0; X < 256; X++) {
                let B = X;
                for (let R = 0; R < 8; R++)
                  B & 1 ? B = 3988292384 ^ B >> 1 & 2147483647 : B = B >> 1 & 2147483647;
                u[X] = B;
              }
              function w(X, B, R) {
                let k = -1;
                for (let x = B; x < R; x++) {
                  const f = (k ^ X[x]) & 255, U = u[f];
                  k = k >>> 8 ^ U;
                }
                return k ^ -1;
              }
              function _(X, B, R, k) {
                let x = k;
                const f = B.length;
                R[x] = f >> 24 & 255, R[x + 1] = f >> 16 & 255, R[x + 2] = f >> 8 & 255, R[x + 3] = f & 255, x += 4, R[x] = X.charCodeAt(0) & 255, R[x + 1] = X.charCodeAt(1) & 255, R[x + 2] = X.charCodeAt(2) & 255, R[x + 3] = X.charCodeAt(3) & 255, x += 4, R.set(B, x), x += B.length;
                const U = w(R, k + 4, x);
                R[x] = U >> 24 & 255, R[x + 1] = U >> 16 & 255, R[x + 2] = U >> 8 & 255, R[x + 3] = U & 255;
              }
              function b(X, B, R) {
                let k = 1, x = 0;
                for (let f = B; f < R; ++f)
                  k = (k + (X[f] & 255)) % 65521, x = (x + k) % 65521;
                return x << 16 | k;
              }
              function A(X) {
                if (!ae.isNodeJS)
                  return Y(X);
                try {
                  let B;
                  parseInt(process.versions.node) >= 8 ? B = X : B = Buffer.from(X);
                  const R = require$$5.deflateSync(B, {
                    level: 9
                  });
                  return R instanceof Uint8Array ? R : new Uint8Array(R);
                } catch (B) {
                  (0, re.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + B);
                }
                return Y(X);
              }
              function Y(X) {
                let B = X.length;
                const R = 65535, k = Math.ceil(B / R), x = new Uint8Array(2 + B + k * 5 + 4);
                let f = 0;
                x[f++] = 120, x[f++] = 156;
                let U = 0;
                for (; B > R; )
                  x[f++] = 0, x[f++] = 255, x[f++] = 255, x[f++] = 0, x[f++] = 0, x.set(X.subarray(U, U + R), f), f += R, U += R, B -= R;
                x[f++] = 1, x[f++] = B & 255, x[f++] = B >> 8 & 255, x[f++] = ~B & 65535 & 255, x[f++] = (~B & 65535) >> 8 & 255, x.set(X.subarray(U), f), f += X.length - U;
                const O = b(X, 0, X.length);
                return x[f++] = O >> 24 & 255, x[f++] = O >> 16 & 255, x[f++] = O >> 8 & 255, x[f++] = O & 255, x;
              }
              function j(X, B, R, k) {
                const x = X.width, f = X.height;
                let U, O, S;
                const F = X.data;
                switch (B) {
                  case re.ImageKind.GRAYSCALE_1BPP:
                    O = 0, U = 1, S = x + 7 >> 3;
                    break;
                  case re.ImageKind.RGB_24BPP:
                    O = 2, U = 8, S = x * 3;
                    break;
                  case re.ImageKind.RGBA_32BPP:
                    O = 6, U = 8, S = x * 4;
                    break;
                  default:
                    throw new Error("invalid format");
                }
                const T = new Uint8Array((1 + S) * f);
                let I = 0, M = 0;
                for (let L = 0; L < f; ++L)
                  T[I++] = 0, T.set(F.subarray(M, M + S), I), M += S, I += S;
                if (B === re.ImageKind.GRAYSCALE_1BPP && k) {
                  I = 0;
                  for (let L = 0; L < f; L++) {
                    I++;
                    for (let K = 0; K < S; K++)
                      T[I++] ^= 255;
                  }
                }
                const V = new Uint8Array([x >> 24 & 255, x >> 16 & 255, x >> 8 & 255, x & 255, f >> 24 & 255, f >> 16 & 255, f >> 8 & 255, f & 255, U, O, 0, 0, 0]), J = A(T), W = i.length + l * 3 + V.length + J.length, z = new Uint8Array(W);
                let G = 0;
                return z.set(i, G), G += i.length, _("IHDR", V, z, G), G += l + V.length, _("IDATA", J, z, G), G += l + J.length, _("IEND", new Uint8Array(0), z, G), h(z, "image/png", R);
              }
              return function(B, R, k) {
                const x = B.kind === void 0 ? re.ImageKind.GRAYSCALE_1BPP : B.kind;
                return j(B, x, R, k);
              };
            }();
            class y {
              constructor() {
                this.fontSizeScale = 1, this.fontWeight = o.fontWeight, this.fontSize = 0, this.textMatrix = re.IDENTITY_MATRIX, this.fontMatrix = re.FONT_IDENTITY_MATRIX, this.leading = 0, this.textRenderingMode = re.TextRenderingMode.FILL, this.textMatrixScale = 1, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRise = 0, this.fillColor = o.fillColor, this.strokeColor = "#000000", this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.lineJoin = "", this.lineCap = "", this.miterLimit = 0, this.dashArray = [], this.dashPhase = 0, this.dependencies = [], this.activeClipUrl = null, this.clipGroup = null, this.maskId = "";
              }
              clone() {
                return Object.create(this);
              }
              setCurrentPoint(l, u) {
                this.x = l, this.y = u;
              }
            }
            let m = 0, g = 0, n = 0;
            ge.SVGGraphics = Z = class {
              constructor(i, l, u = !1) {
                (0, ce.deprecated)("The SVG back-end is no longer maintained and *may* be removed in the future."), this.svgFactory = new ce.DOMSVGFactory(), this.current = new y(), this.transformMatrix = re.IDENTITY_MATRIX, this.transformStack = [], this.extraStack = [], this.commonObjs = i, this.objs = l, this.pendingClip = null, this.pendingEOFill = !1, this.embedFonts = !1, this.embeddedFonts = /* @__PURE__ */ Object.create(null), this.cssStyle = null, this.forceDataSchema = !!u, this._operatorIdMapping = [];
                for (const w in re.OPS)
                  this._operatorIdMapping[re.OPS[w]] = w;
              }
              save() {
                this.transformStack.push(this.transformMatrix);
                const i = this.current;
                this.extraStack.push(i), this.current = i.clone();
              }
              restore() {
                this.transformMatrix = this.transformStack.pop(), this.current = this.extraStack.pop(), this.pendingClip = null, this.tgrp = null;
              }
              group(i) {
                this.save(), this.executeOpTree(i), this.restore();
              }
              loadDependencies(i) {
                const l = i.fnArray, u = i.argsArray;
                for (let w = 0, _ = l.length; w < _; w++)
                  if (l[w] === re.OPS.dependency)
                    for (const b of u[w]) {
                      const A = b.startsWith("g_") ? this.commonObjs : this.objs, Y = new Promise((j) => {
                        A.get(b, j);
                      });
                      this.current.dependencies.push(Y);
                    }
                return Promise.all(this.current.dependencies);
              }
              transform(i, l, u, w, _, b) {
                const A = [i, l, u, w, _, b];
                this.transformMatrix = re.Util.transform(this.transformMatrix, A), this.tgrp = null;
              }
              getSVG(i, l) {
                this.viewport = l;
                const u = this._initialize(l);
                return this.loadDependencies(i).then(() => (this.transformMatrix = re.IDENTITY_MATRIX, this.executeOpTree(this.convertOpList(i)), u));
              }
              convertOpList(i) {
                const l = this._operatorIdMapping, u = i.argsArray, w = i.fnArray, _ = [];
                for (let b = 0, A = w.length; b < A; b++) {
                  const Y = w[b];
                  _.push({
                    fnId: Y,
                    fn: l[Y],
                    args: u[b]
                  });
                }
                return c(_);
              }
              executeOpTree(i) {
                for (const l of i) {
                  const u = l.fn, w = l.fnId, _ = l.args;
                  switch (w | 0) {
                    case re.OPS.beginText:
                      this.beginText();
                      break;
                    case re.OPS.dependency:
                      break;
                    case re.OPS.setLeading:
                      this.setLeading(_);
                      break;
                    case re.OPS.setLeadingMoveText:
                      this.setLeadingMoveText(_[0], _[1]);
                      break;
                    case re.OPS.setFont:
                      this.setFont(_);
                      break;
                    case re.OPS.showText:
                      this.showText(_[0]);
                      break;
                    case re.OPS.showSpacedText:
                      this.showText(_[0]);
                      break;
                    case re.OPS.endText:
                      this.endText();
                      break;
                    case re.OPS.moveText:
                      this.moveText(_[0], _[1]);
                      break;
                    case re.OPS.setCharSpacing:
                      this.setCharSpacing(_[0]);
                      break;
                    case re.OPS.setWordSpacing:
                      this.setWordSpacing(_[0]);
                      break;
                    case re.OPS.setHScale:
                      this.setHScale(_[0]);
                      break;
                    case re.OPS.setTextMatrix:
                      this.setTextMatrix(_[0], _[1], _[2], _[3], _[4], _[5]);
                      break;
                    case re.OPS.setTextRise:
                      this.setTextRise(_[0]);
                      break;
                    case re.OPS.setTextRenderingMode:
                      this.setTextRenderingMode(_[0]);
                      break;
                    case re.OPS.setLineWidth:
                      this.setLineWidth(_[0]);
                      break;
                    case re.OPS.setLineJoin:
                      this.setLineJoin(_[0]);
                      break;
                    case re.OPS.setLineCap:
                      this.setLineCap(_[0]);
                      break;
                    case re.OPS.setMiterLimit:
                      this.setMiterLimit(_[0]);
                      break;
                    case re.OPS.setFillRGBColor:
                      this.setFillRGBColor(_[0], _[1], _[2]);
                      break;
                    case re.OPS.setStrokeRGBColor:
                      this.setStrokeRGBColor(_[0], _[1], _[2]);
                      break;
                    case re.OPS.setStrokeColorN:
                      this.setStrokeColorN(_);
                      break;
                    case re.OPS.setFillColorN:
                      this.setFillColorN(_);
                      break;
                    case re.OPS.shadingFill:
                      this.shadingFill(_[0]);
                      break;
                    case re.OPS.setDash:
                      this.setDash(_[0], _[1]);
                      break;
                    case re.OPS.setRenderingIntent:
                      this.setRenderingIntent(_[0]);
                      break;
                    case re.OPS.setFlatness:
                      this.setFlatness(_[0]);
                      break;
                    case re.OPS.setGState:
                      this.setGState(_[0]);
                      break;
                    case re.OPS.fill:
                      this.fill();
                      break;
                    case re.OPS.eoFill:
                      this.eoFill();
                      break;
                    case re.OPS.stroke:
                      this.stroke();
                      break;
                    case re.OPS.fillStroke:
                      this.fillStroke();
                      break;
                    case re.OPS.eoFillStroke:
                      this.eoFillStroke();
                      break;
                    case re.OPS.clip:
                      this.clip("nonzero");
                      break;
                    case re.OPS.eoClip:
                      this.clip("evenodd");
                      break;
                    case re.OPS.paintSolidColorImageMask:
                      this.paintSolidColorImageMask();
                      break;
                    case re.OPS.paintImageXObject:
                      this.paintImageXObject(_[0]);
                      break;
                    case re.OPS.paintInlineImageXObject:
                      this.paintInlineImageXObject(_[0]);
                      break;
                    case re.OPS.paintImageMaskXObject:
                      this.paintImageMaskXObject(_[0]);
                      break;
                    case re.OPS.paintFormXObjectBegin:
                      this.paintFormXObjectBegin(_[0], _[1]);
                      break;
                    case re.OPS.paintFormXObjectEnd:
                      this.paintFormXObjectEnd();
                      break;
                    case re.OPS.closePath:
                      this.closePath();
                      break;
                    case re.OPS.closeStroke:
                      this.closeStroke();
                      break;
                    case re.OPS.closeFillStroke:
                      this.closeFillStroke();
                      break;
                    case re.OPS.closeEOFillStroke:
                      this.closeEOFillStroke();
                      break;
                    case re.OPS.nextLine:
                      this.nextLine();
                      break;
                    case re.OPS.transform:
                      this.transform(_[0], _[1], _[2], _[3], _[4], _[5]);
                      break;
                    case re.OPS.constructPath:
                      this.constructPath(_[0], _[1]);
                      break;
                    case re.OPS.endPath:
                      this.endPath();
                      break;
                    case 92:
                      this.group(l.items);
                      break;
                    default:
                      (0, re.warn)(`Unimplemented operator ${u}`);
                      break;
                  }
                }
              }
              setWordSpacing(i) {
                this.current.wordSpacing = i;
              }
              setCharSpacing(i) {
                this.current.charSpacing = i;
              }
              nextLine() {
                this.moveText(0, this.current.leading);
              }
              setTextMatrix(i, l, u, w, _, b) {
                const A = this.current;
                A.textMatrix = A.lineMatrix = [i, l, u, w, _, b], A.textMatrixScale = Math.hypot(i, l), A.x = A.lineX = 0, A.y = A.lineY = 0, A.xcoords = [], A.ycoords = [], A.tspan = this.svgFactory.createElement("svg:tspan"), A.tspan.setAttributeNS(null, "font-family", A.fontFamily), A.tspan.setAttributeNS(null, "font-size", `${d(A.fontSize)}px`), A.tspan.setAttributeNS(null, "y", d(-A.y)), A.txtElement = this.svgFactory.createElement("svg:text"), A.txtElement.append(A.tspan);
              }
              beginText() {
                const i = this.current;
                i.x = i.lineX = 0, i.y = i.lineY = 0, i.textMatrix = re.IDENTITY_MATRIX, i.lineMatrix = re.IDENTITY_MATRIX, i.textMatrixScale = 1, i.tspan = this.svgFactory.createElement("svg:tspan"), i.txtElement = this.svgFactory.createElement("svg:text"), i.txtgrp = this.svgFactory.createElement("svg:g"), i.xcoords = [], i.ycoords = [];
              }
              moveText(i, l) {
                const u = this.current;
                u.x = u.lineX += i, u.y = u.lineY += l, u.xcoords = [], u.ycoords = [], u.tspan = this.svgFactory.createElement("svg:tspan"), u.tspan.setAttributeNS(null, "font-family", u.fontFamily), u.tspan.setAttributeNS(null, "font-size", `${d(u.fontSize)}px`), u.tspan.setAttributeNS(null, "y", d(-u.y));
              }
              showText(i) {
                const l = this.current, u = l.font, w = l.fontSize;
                if (w === 0)
                  return;
                const _ = l.fontSizeScale, b = l.charSpacing, A = l.wordSpacing, Y = l.fontDirection, j = l.textHScale * Y, X = u.vertical, B = X ? 1 : -1, R = u.defaultVMetrics, k = w * l.fontMatrix[0];
                let x = 0;
                for (const O of i) {
                  if (O === null) {
                    x += Y * A;
                    continue;
                  } else if (typeof O == "number") {
                    x += B * O * w / 1e3;
                    continue;
                  }
                  const S = (O.isSpace ? A : 0) + b, F = O.fontChar;
                  let T, I, M = O.width;
                  if (X) {
                    let J;
                    const W = O.vmetric || R;
                    J = O.vmetric ? W[1] : M * 0.5, J = -J * k;
                    const z = W[2] * k;
                    M = W ? -W[0] : M, T = J / _, I = (x + z) / _;
                  } else
                    T = x / _, I = 0;
                  (O.isInFont || u.missingFile) && (l.xcoords.push(l.x + T), X && l.ycoords.push(-l.y + I), l.tspan.textContent += F);
                  let V;
                  X ? V = M * k - S * Y : V = M * k + S * Y, x += V;
                }
                l.tspan.setAttributeNS(null, "x", l.xcoords.map(d).join(" ")), X ? l.tspan.setAttributeNS(null, "y", l.ycoords.map(d).join(" ")) : l.tspan.setAttributeNS(null, "y", d(-l.y)), X ? l.y -= x : l.x += x * j, l.tspan.setAttributeNS(null, "font-family", l.fontFamily), l.tspan.setAttributeNS(null, "font-size", `${d(l.fontSize)}px`), l.fontStyle !== o.fontStyle && l.tspan.setAttributeNS(null, "font-style", l.fontStyle), l.fontWeight !== o.fontWeight && l.tspan.setAttributeNS(null, "font-weight", l.fontWeight);
                const f = l.textRenderingMode & re.TextRenderingMode.FILL_STROKE_MASK;
                if (f === re.TextRenderingMode.FILL || f === re.TextRenderingMode.FILL_STROKE ? (l.fillColor !== o.fillColor && l.tspan.setAttributeNS(null, "fill", l.fillColor), l.fillAlpha < 1 && l.tspan.setAttributeNS(null, "fill-opacity", l.fillAlpha)) : l.textRenderingMode === re.TextRenderingMode.ADD_TO_PATH ? l.tspan.setAttributeNS(null, "fill", "transparent") : l.tspan.setAttributeNS(null, "fill", "none"), f === re.TextRenderingMode.STROKE || f === re.TextRenderingMode.FILL_STROKE) {
                  const O = 1 / (l.textMatrixScale || 1);
                  this._setStrokeAttributes(l.tspan, O);
                }
                let U = l.textMatrix;
                l.textRise !== 0 && (U = U.slice(), U[5] += l.textRise), l.txtElement.setAttributeNS(null, "transform", `${p(U)} scale(${d(j)}, -1)`), l.txtElement.setAttributeNS(C, "xml:space", "preserve"), l.txtElement.append(l.tspan), l.txtgrp.append(l.txtElement), this._ensureTransformGroup().append(l.txtElement);
              }
              setLeadingMoveText(i, l) {
                this.setLeading(-l), this.moveText(i, l);
              }
              addFontStyle(i) {
                if (!i.data)
                  throw new Error('addFontStyle: No font data available, ensure that the "fontExtraProperties" API parameter is set.');
                this.cssStyle || (this.cssStyle = this.svgFactory.createElement("svg:style"), this.cssStyle.setAttributeNS(null, "type", "text/css"), this.defs.append(this.cssStyle));
                const l = h(i.data, i.mimetype, this.forceDataSchema);
                this.cssStyle.textContent += `@font-face { font-family: "${i.loadedName}"; src: url(${l}); }
`;
              }
              setFont(i) {
                const l = this.current, u = this.commonObjs.get(i[0]);
                let w = i[1];
                l.font = u, this.embedFonts && !u.missingFile && !this.embeddedFonts[u.loadedName] && (this.addFontStyle(u), this.embeddedFonts[u.loadedName] = u), l.fontMatrix = u.fontMatrix || re.FONT_IDENTITY_MATRIX;
                let _ = "normal";
                u.black ? _ = "900" : u.bold && (_ = "bold");
                const b = u.italic ? "italic" : "normal";
                w < 0 ? (w = -w, l.fontDirection = -1) : l.fontDirection = 1, l.fontSize = w, l.fontFamily = u.loadedName, l.fontWeight = _, l.fontStyle = b, l.tspan = this.svgFactory.createElement("svg:tspan"), l.tspan.setAttributeNS(null, "y", d(-l.y)), l.xcoords = [], l.ycoords = [];
              }
              endText() {
                var l;
                const i = this.current;
                i.textRenderingMode & re.TextRenderingMode.ADD_TO_PATH_FLAG && ((l = i.txtElement) != null && l.hasChildNodes()) && (i.element = i.txtElement, this.clip("nonzero"), this.endPath());
              }
              setLineWidth(i) {
                i > 0 && (this.current.lineWidth = i);
              }
              setLineCap(i) {
                this.current.lineCap = a[i];
              }
              setLineJoin(i) {
                this.current.lineJoin = v[i];
              }
              setMiterLimit(i) {
                this.current.miterLimit = i;
              }
              setStrokeAlpha(i) {
                this.current.strokeAlpha = i;
              }
              setStrokeRGBColor(i, l, u) {
                this.current.strokeColor = re.Util.makeHexColor(i, l, u);
              }
              setFillAlpha(i) {
                this.current.fillAlpha = i;
              }
              setFillRGBColor(i, l, u) {
                this.current.fillColor = re.Util.makeHexColor(i, l, u), this.current.tspan = this.svgFactory.createElement("svg:tspan"), this.current.xcoords = [], this.current.ycoords = [];
              }
              setStrokeColorN(i) {
                this.current.strokeColor = this._makeColorN_Pattern(i);
              }
              setFillColorN(i) {
                this.current.fillColor = this._makeColorN_Pattern(i);
              }
              shadingFill(i) {
                const l = this.viewport.width, u = this.viewport.height, w = re.Util.inverseTransform(this.transformMatrix), _ = re.Util.applyTransform([0, 0], w), b = re.Util.applyTransform([0, u], w), A = re.Util.applyTransform([l, 0], w), Y = re.Util.applyTransform([l, u], w), j = Math.min(_[0], b[0], A[0], Y[0]), X = Math.min(_[1], b[1], A[1], Y[1]), B = Math.max(_[0], b[0], A[0], Y[0]), R = Math.max(_[1], b[1], A[1], Y[1]), k = this.svgFactory.createElement("svg:rect");
                k.setAttributeNS(null, "x", j), k.setAttributeNS(null, "y", X), k.setAttributeNS(null, "width", B - j), k.setAttributeNS(null, "height", R - X), k.setAttributeNS(null, "fill", this._makeShadingPattern(i)), this.current.fillAlpha < 1 && k.setAttributeNS(null, "fill-opacity", this.current.fillAlpha), this._ensureTransformGroup().append(k);
              }
              _makeColorN_Pattern(i) {
                return i[0] === "TilingPattern" ? this._makeTilingPattern(i) : this._makeShadingPattern(i);
              }
              _makeTilingPattern(i) {
                const l = i[1], u = i[2], w = i[3] || re.IDENTITY_MATRIX, [_, b, A, Y] = i[4], j = i[5], X = i[6], B = i[7], R = `shading${n++}`, [k, x, f, U] = re.Util.normalizeRect([...re.Util.applyTransform([_, b], w), ...re.Util.applyTransform([A, Y], w)]), [O, S] = re.Util.singularValueDecompose2dScale(w), F = j * O, T = X * S, I = this.svgFactory.createElement("svg:pattern");
                I.setAttributeNS(null, "id", R), I.setAttributeNS(null, "patternUnits", "userSpaceOnUse"), I.setAttributeNS(null, "width", F), I.setAttributeNS(null, "height", T), I.setAttributeNS(null, "x", `${k}`), I.setAttributeNS(null, "y", `${x}`);
                const M = this.svg, V = this.transformMatrix, J = this.current.fillColor, W = this.current.strokeColor, z = this.svgFactory.create(f - k, U - x);
                if (this.svg = z, this.transformMatrix = w, B === 2) {
                  const G = re.Util.makeHexColor(...l);
                  this.current.fillColor = G, this.current.strokeColor = G;
                }
                return this.executeOpTree(this.convertOpList(u)), this.svg = M, this.transformMatrix = V, this.current.fillColor = J, this.current.strokeColor = W, I.append(z.childNodes[0]), this.defs.append(I), `url(#${R})`;
              }
              _makeShadingPattern(i) {
                switch (typeof i == "string" && (i = this.objs.get(i)), i[0]) {
                  case "RadialAxial":
                    const l = `shading${n++}`, u = i[3];
                    let w;
                    switch (i[1]) {
                      case "axial":
                        const _ = i[4], b = i[5];
                        w = this.svgFactory.createElement("svg:linearGradient"), w.setAttributeNS(null, "id", l), w.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), w.setAttributeNS(null, "x1", _[0]), w.setAttributeNS(null, "y1", _[1]), w.setAttributeNS(null, "x2", b[0]), w.setAttributeNS(null, "y2", b[1]);
                        break;
                      case "radial":
                        const A = i[4], Y = i[5], j = i[6], X = i[7];
                        w = this.svgFactory.createElement("svg:radialGradient"), w.setAttributeNS(null, "id", l), w.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), w.setAttributeNS(null, "cx", Y[0]), w.setAttributeNS(null, "cy", Y[1]), w.setAttributeNS(null, "r", X), w.setAttributeNS(null, "fx", A[0]), w.setAttributeNS(null, "fy", A[1]), w.setAttributeNS(null, "fr", j);
                        break;
                      default:
                        throw new Error(`Unknown RadialAxial type: ${i[1]}`);
                    }
                    for (const _ of u) {
                      const b = this.svgFactory.createElement("svg:stop");
                      b.setAttributeNS(null, "offset", _[0]), b.setAttributeNS(null, "stop-color", _[1]), w.append(b);
                    }
                    return this.defs.append(w), `url(#${l})`;
                  case "Mesh":
                    return (0, re.warn)("Unimplemented pattern Mesh"), null;
                  case "Dummy":
                    return "hotpink";
                  default:
                    throw new Error(`Unknown IR type: ${i[0]}`);
                }
              }
              setDash(i, l) {
                this.current.dashArray = i, this.current.dashPhase = l;
              }
              constructPath(i, l) {
                const u = this.current;
                let w = u.x, _ = u.y, b = [], A = 0;
                for (const Y of i)
                  switch (Y | 0) {
                    case re.OPS.rectangle:
                      w = l[A++], _ = l[A++];
                      const j = l[A++], X = l[A++], B = w + j, R = _ + X;
                      b.push("M", d(w), d(_), "L", d(B), d(_), "L", d(B), d(R), "L", d(w), d(R), "Z");
                      break;
                    case re.OPS.moveTo:
                      w = l[A++], _ = l[A++], b.push("M", d(w), d(_));
                      break;
                    case re.OPS.lineTo:
                      w = l[A++], _ = l[A++], b.push("L", d(w), d(_));
                      break;
                    case re.OPS.curveTo:
                      w = l[A + 4], _ = l[A + 5], b.push("C", d(l[A]), d(l[A + 1]), d(l[A + 2]), d(l[A + 3]), d(w), d(_)), A += 6;
                      break;
                    case re.OPS.curveTo2:
                      b.push("C", d(w), d(_), d(l[A]), d(l[A + 1]), d(l[A + 2]), d(l[A + 3])), w = l[A + 2], _ = l[A + 3], A += 4;
                      break;
                    case re.OPS.curveTo3:
                      w = l[A + 2], _ = l[A + 3], b.push("C", d(l[A]), d(l[A + 1]), d(w), d(_), d(w), d(_)), A += 4;
                      break;
                    case re.OPS.closePath:
                      b.push("Z");
                      break;
                  }
                b = b.join(" "), u.path && i.length > 0 && i[0] !== re.OPS.rectangle && i[0] !== re.OPS.moveTo ? b = u.path.getAttributeNS(null, "d") + b : (u.path = this.svgFactory.createElement("svg:path"), this._ensureTransformGroup().append(u.path)), u.path.setAttributeNS(null, "d", b), u.path.setAttributeNS(null, "fill", "none"), u.element = u.path, u.setCurrentPoint(w, _);
              }
              endPath() {
                const i = this.current;
                if (i.path = null, !this.pendingClip)
                  return;
                if (!i.element) {
                  this.pendingClip = null;
                  return;
                }
                const l = `clippath${m++}`, u = this.svgFactory.createElement("svg:clipPath");
                u.setAttributeNS(null, "id", l), u.setAttributeNS(null, "transform", p(this.transformMatrix));
                const w = i.element.cloneNode(!0);
                if (this.pendingClip === "evenodd" ? w.setAttributeNS(null, "clip-rule", "evenodd") : w.setAttributeNS(null, "clip-rule", "nonzero"), this.pendingClip = null, u.append(w), this.defs.append(u), i.activeClipUrl) {
                  i.clipGroup = null;
                  for (const _ of this.extraStack)
                    _.clipGroup = null;
                  u.setAttributeNS(null, "clip-path", i.activeClipUrl);
                }
                i.activeClipUrl = `url(#${l})`, this.tgrp = null;
              }
              clip(i) {
                this.pendingClip = i;
              }
              closePath() {
                const i = this.current;
                if (i.path) {
                  const l = `${i.path.getAttributeNS(null, "d")}Z`;
                  i.path.setAttributeNS(null, "d", l);
                }
              }
              setLeading(i) {
                this.current.leading = -i;
              }
              setTextRise(i) {
                this.current.textRise = i;
              }
              setTextRenderingMode(i) {
                this.current.textRenderingMode = i;
              }
              setHScale(i) {
                this.current.textHScale = i / 100;
              }
              setRenderingIntent(i) {
              }
              setFlatness(i) {
              }
              setGState(i) {
                for (const [l, u] of i)
                  switch (l) {
                    case "LW":
                      this.setLineWidth(u);
                      break;
                    case "LC":
                      this.setLineCap(u);
                      break;
                    case "LJ":
                      this.setLineJoin(u);
                      break;
                    case "ML":
                      this.setMiterLimit(u);
                      break;
                    case "D":
                      this.setDash(u[0], u[1]);
                      break;
                    case "RI":
                      this.setRenderingIntent(u);
                      break;
                    case "FL":
                      this.setFlatness(u);
                      break;
                    case "Font":
                      this.setFont(u);
                      break;
                    case "CA":
                      this.setStrokeAlpha(u);
                      break;
                    case "ca":
                      this.setFillAlpha(u);
                      break;
                    default:
                      (0, re.warn)(`Unimplemented graphic state operator ${l}`);
                      break;
                  }
              }
              fill() {
                const i = this.current;
                i.element && (i.element.setAttributeNS(null, "fill", i.fillColor), i.element.setAttributeNS(null, "fill-opacity", i.fillAlpha), this.endPath());
              }
              stroke() {
                const i = this.current;
                i.element && (this._setStrokeAttributes(i.element), i.element.setAttributeNS(null, "fill", "none"), this.endPath());
              }
              _setStrokeAttributes(i, l = 1) {
                const u = this.current;
                let w = u.dashArray;
                l !== 1 && w.length > 0 && (w = w.map(function(_) {
                  return l * _;
                })), i.setAttributeNS(null, "stroke", u.strokeColor), i.setAttributeNS(null, "stroke-opacity", u.strokeAlpha), i.setAttributeNS(null, "stroke-miterlimit", d(u.miterLimit)), i.setAttributeNS(null, "stroke-linecap", u.lineCap), i.setAttributeNS(null, "stroke-linejoin", u.lineJoin), i.setAttributeNS(null, "stroke-width", d(l * u.lineWidth) + "px"), i.setAttributeNS(null, "stroke-dasharray", w.map(d).join(" ")), i.setAttributeNS(null, "stroke-dashoffset", d(l * u.dashPhase) + "px");
              }
              eoFill() {
                this.current.element && this.current.element.setAttributeNS(null, "fill-rule", "evenodd"), this.fill();
              }
              fillStroke() {
                this.stroke(), this.fill();
              }
              eoFillStroke() {
                this.current.element && this.current.element.setAttributeNS(null, "fill-rule", "evenodd"), this.fillStroke();
              }
              closeStroke() {
                this.closePath(), this.stroke();
              }
              closeFillStroke() {
                this.closePath(), this.fillStroke();
              }
              closeEOFillStroke() {
                this.closePath(), this.eoFillStroke();
              }
              paintSolidColorImageMask() {
                const i = this.svgFactory.createElement("svg:rect");
                i.setAttributeNS(null, "x", "0"), i.setAttributeNS(null, "y", "0"), i.setAttributeNS(null, "width", "1px"), i.setAttributeNS(null, "height", "1px"), i.setAttributeNS(null, "fill", this.current.fillColor), this._ensureTransformGroup().append(i);
              }
              paintImageXObject(i) {
                const l = i.startsWith("g_") ? this.commonObjs.get(i) : this.objs.get(i);
                if (!l) {
                  (0, re.warn)(`Dependent image with object ID ${i} is not ready yet`);
                  return;
                }
                this.paintInlineImageXObject(l);
              }
              paintInlineImageXObject(i, l) {
                const u = i.width, w = i.height, _ = e(i, this.forceDataSchema, !!l), b = this.svgFactory.createElement("svg:rect");
                b.setAttributeNS(null, "x", "0"), b.setAttributeNS(null, "y", "0"), b.setAttributeNS(null, "width", d(u)), b.setAttributeNS(null, "height", d(w)), this.current.element = b, this.clip("nonzero");
                const A = this.svgFactory.createElement("svg:image");
                A.setAttributeNS(t, "xlink:href", _), A.setAttributeNS(null, "x", "0"), A.setAttributeNS(null, "y", d(-w)), A.setAttributeNS(null, "width", d(u) + "px"), A.setAttributeNS(null, "height", d(w) + "px"), A.setAttributeNS(null, "transform", `scale(${d(1 / u)} ${d(-1 / w)})`), l ? l.append(A) : this._ensureTransformGroup().append(A);
              }
              paintImageMaskXObject(i) {
                const l = this.current, u = i.width, w = i.height, _ = l.fillColor;
                l.maskId = `mask${g++}`;
                const b = this.svgFactory.createElement("svg:mask");
                b.setAttributeNS(null, "id", l.maskId);
                const A = this.svgFactory.createElement("svg:rect");
                A.setAttributeNS(null, "x", "0"), A.setAttributeNS(null, "y", "0"), A.setAttributeNS(null, "width", d(u)), A.setAttributeNS(null, "height", d(w)), A.setAttributeNS(null, "fill", _), A.setAttributeNS(null, "mask", `url(#${l.maskId})`), this.defs.append(b), this._ensureTransformGroup().append(A), this.paintInlineImageXObject(i, b);
              }
              paintFormXObjectBegin(i, l) {
                if (Array.isArray(i) && i.length === 6 && this.transform(i[0], i[1], i[2], i[3], i[4], i[5]), l) {
                  const u = l[2] - l[0], w = l[3] - l[1], _ = this.svgFactory.createElement("svg:rect");
                  _.setAttributeNS(null, "x", l[0]), _.setAttributeNS(null, "y", l[1]), _.setAttributeNS(null, "width", d(u)), _.setAttributeNS(null, "height", d(w)), this.current.element = _, this.clip("nonzero"), this.endPath();
                }
              }
              paintFormXObjectEnd() {
              }
              _initialize(i) {
                const l = this.svgFactory.create(i.width, i.height), u = this.svgFactory.createElement("svg:defs");
                l.append(u), this.defs = u;
                const w = this.svgFactory.createElement("svg:g");
                return w.setAttributeNS(null, "transform", p(i.transform)), l.append(w), this.svg = w, l;
              }
              _ensureClipGroup() {
                if (!this.current.clipGroup) {
                  const i = this.svgFactory.createElement("svg:g");
                  i.setAttributeNS(null, "clip-path", this.current.activeClipUrl), this.svg.append(i), this.current.clipGroup = i;
                }
                return this.current.clipGroup;
              }
              _ensureTransformGroup() {
                return this.tgrp || (this.tgrp = this.svgFactory.createElement("svg:g"), this.tgrp.setAttributeNS(null, "transform", p(this.transformMatrix)), this.current.activeClipUrl ? this._ensureClipGroup().append(this.tgrp) : this.svg.append(this.tgrp)), this.tgrp;
              }
            };
          }
        },
        /* 32 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.PDFNodeStream = void 0;
          var ce = le(1), re = le(33);
          const ae = require$$5, Z = require$$5, o = require$$5, C = require$$5, t = /^file:\/\/\/[a-zA-Z]:\//;
          function a(g) {
            const n = C.parse(g);
            return n.protocol === "file:" || n.host ? n : /^[a-z]:[/\\]/i.test(g) ? C.parse(`file:///${g}`) : (n.host || (n.protocol = "file:"), n);
          }
          class v {
            constructor(n) {
              this.source = n, this.url = a(n.url), this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:", this.isFsUrl = this.url.protocol === "file:", this.httpHeaders = this.isHttp && n.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
            }
            get _progressiveDataLength() {
              var n;
              return ((n = this._fullRequestReader) == null ? void 0 : n._loaded) ?? 0;
            }
            getFullReader() {
              return (0, ce.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once."), this._fullRequestReader = this.isFsUrl ? new p(this) : new c(this), this._fullRequestReader;
            }
            getRangeReader(n, i) {
              if (i <= this._progressiveDataLength)
                return null;
              const l = this.isFsUrl ? new m(this, n, i) : new d(this, n, i);
              return this._rangeRequestReaders.push(l), l;
            }
            cancelAllRequests(n) {
              this._fullRequestReader && this._fullRequestReader.cancel(n);
              for (const i of this._rangeRequestReaders.slice(0))
                i.cancel(n);
            }
          }
          ge.PDFNodeStream = v;
          class h {
            constructor(n) {
              this._url = n.url, this._done = !1, this._storedError = null, this.onProgress = null;
              const i = n.source;
              this._contentLength = i.length, this._loaded = 0, this._filename = null, this._disableRange = i.disableRange || !1, this._rangeChunkSize = i.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !i.disableStream, this._isRangeSupported = !i.disableRange, this._readableStream = null, this._readCapability = (0, ce.createPromiseCapability)(), this._headersCapability = (0, ce.createPromiseCapability)();
            }
            get headersReady() {
              return this._headersCapability.promise;
            }
            get filename() {
              return this._filename;
            }
            get contentLength() {
              return this._contentLength;
            }
            get isRangeSupported() {
              return this._isRangeSupported;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            async read() {
              if (await this._readCapability.promise, this._done)
                return {
                  value: void 0,
                  done: !0
                };
              if (this._storedError)
                throw this._storedError;
              const n = this._readableStream.read();
              return n === null ? (this._readCapability = (0, ce.createPromiseCapability)(), this.read()) : (this._loaded += n.length, this.onProgress && this.onProgress({
                loaded: this._loaded,
                total: this._contentLength
              }), {
                value: new Uint8Array(n).buffer,
                done: !1
              });
            }
            cancel(n) {
              if (!this._readableStream) {
                this._error(n);
                return;
              }
              this._readableStream.destroy(n);
            }
            _error(n) {
              this._storedError = n, this._readCapability.resolve();
            }
            _setReadableStream(n) {
              this._readableStream = n, n.on("readable", () => {
                this._readCapability.resolve();
              }), n.on("end", () => {
                n.destroy(), this._done = !0, this._readCapability.resolve();
              }), n.on("error", (i) => {
                this._error(i);
              }), !this._isStreamingSupported && this._isRangeSupported && this._error(new ce.AbortException("streaming is disabled")), this._storedError && this._readableStream.destroy(this._storedError);
            }
          }
          class e {
            constructor(n) {
              this._url = n.url, this._done = !1, this._storedError = null, this.onProgress = null, this._loaded = 0, this._readableStream = null, this._readCapability = (0, ce.createPromiseCapability)();
              const i = n.source;
              this._isStreamingSupported = !i.disableStream;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            async read() {
              if (await this._readCapability.promise, this._done)
                return {
                  value: void 0,
                  done: !0
                };
              if (this._storedError)
                throw this._storedError;
              const n = this._readableStream.read();
              return n === null ? (this._readCapability = (0, ce.createPromiseCapability)(), this.read()) : (this._loaded += n.length, this.onProgress && this.onProgress({
                loaded: this._loaded
              }), {
                value: new Uint8Array(n).buffer,
                done: !1
              });
            }
            cancel(n) {
              if (!this._readableStream) {
                this._error(n);
                return;
              }
              this._readableStream.destroy(n);
            }
            _error(n) {
              this._storedError = n, this._readCapability.resolve();
            }
            _setReadableStream(n) {
              this._readableStream = n, n.on("readable", () => {
                this._readCapability.resolve();
              }), n.on("end", () => {
                n.destroy(), this._done = !0, this._readCapability.resolve();
              }), n.on("error", (i) => {
                this._error(i);
              }), this._storedError && this._readableStream.destroy(this._storedError);
            }
          }
          function y(g, n) {
            return {
              protocol: g.protocol,
              auth: g.auth,
              host: g.hostname,
              port: g.port,
              path: g.path,
              method: "GET",
              headers: n
            };
          }
          class c extends h {
            constructor(n) {
              super(n);
              const i = (l) => {
                if (l.statusCode === 404) {
                  const b = new ce.MissingPDFException(`Missing PDF "${this._url}".`);
                  this._storedError = b, this._headersCapability.reject(b);
                  return;
                }
                this._headersCapability.resolve(), this._setReadableStream(l);
                const u = (b) => this._readableStream.headers[b.toLowerCase()], {
                  allowRangeRequests: w,
                  suggestedLength: _
                } = (0, re.validateRangeRequestCapabilities)({
                  getResponseHeader: u,
                  isHttp: n.isHttp,
                  rangeChunkSize: this._rangeChunkSize,
                  disableRange: this._disableRange
                });
                this._isRangeSupported = w, this._contentLength = _ || this._contentLength, this._filename = (0, re.extractFilenameFromHeader)(u);
              };
              this._request = null, this._url.protocol === "http:" ? this._request = Z.request(y(this._url, n.httpHeaders), i) : this._request = o.request(y(this._url, n.httpHeaders), i), this._request.on("error", (l) => {
                this._storedError = l, this._headersCapability.reject(l);
              }), this._request.end();
            }
          }
          class d extends e {
            constructor(n, i, l) {
              super(n), this._httpHeaders = {};
              for (const w in n.httpHeaders) {
                const _ = n.httpHeaders[w];
                typeof _ > "u" || (this._httpHeaders[w] = _);
              }
              this._httpHeaders.Range = `bytes=${i}-${l - 1}`;
              const u = (w) => {
                if (w.statusCode === 404) {
                  const _ = new ce.MissingPDFException(`Missing PDF "${this._url}".`);
                  this._storedError = _;
                  return;
                }
                this._setReadableStream(w);
              };
              this._request = null, this._url.protocol === "http:" ? this._request = Z.request(y(this._url, this._httpHeaders), u) : this._request = o.request(y(this._url, this._httpHeaders), u), this._request.on("error", (w) => {
                this._storedError = w;
              }), this._request.end();
            }
          }
          class p extends h {
            constructor(n) {
              super(n);
              let i = decodeURIComponent(this._url.path);
              t.test(this._url.href) && (i = i.replace(/^\//, "")), ae.lstat(i, (l, u) => {
                if (l) {
                  l.code === "ENOENT" && (l = new ce.MissingPDFException(`Missing PDF "${i}".`)), this._storedError = l, this._headersCapability.reject(l);
                  return;
                }
                this._contentLength = u.size, this._setReadableStream(ae.createReadStream(i)), this._headersCapability.resolve();
              });
            }
          }
          class m extends e {
            constructor(n, i, l) {
              super(n);
              let u = decodeURIComponent(this._url.path);
              t.test(this._url.href) && (u = u.replace(/^\//, "")), this._setReadableStream(ae.createReadStream(u, {
                start: i,
                end: l - 1
              }));
            }
          }
        },
        /* 33 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.createResponseStatusError = C, ge.extractFilenameFromHeader = o, ge.validateRangeRequestCapabilities = Z, ge.validateResponseStatus = t;
          var ce = le(1), re = le(34), ae = le(8);
          function Z({
            getResponseHeader: a,
            isHttp: v,
            rangeChunkSize: h,
            disableRange: e
          }) {
            const y = {
              allowRangeRequests: !1,
              suggestedLength: void 0
            }, c = parseInt(a("Content-Length"), 10);
            return !Number.isInteger(c) || (y.suggestedLength = c, c <= 2 * h) || e || !v || a("Accept-Ranges") !== "bytes" || (a("Content-Encoding") || "identity") !== "identity" || (y.allowRangeRequests = !0), y;
          }
          function o(a) {
            const v = a("Content-Disposition");
            if (v) {
              let h = (0, re.getFilenameFromContentDispositionHeader)(v);
              if (h.includes("%"))
                try {
                  h = decodeURIComponent(h);
                } catch {
                }
              if ((0, ae.isPdfFile)(h))
                return h;
            }
            return null;
          }
          function C(a, v) {
            return a === 404 || a === 0 && v.startsWith("file:") ? new ce.MissingPDFException('Missing PDF "' + v + '".') : new ce.UnexpectedResponseException(`Unexpected server response (${a}) while retrieving PDF "${v}".`, a);
          }
          function t(a) {
            return a === 200 || a === 206;
          }
        },
        /* 34 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.getFilenameFromContentDispositionHeader = re;
          var ce = le(1);
          function re(ae) {
            let Z = !0, o = C("filename\\*", "i").exec(ae);
            if (o) {
              o = o[1];
              let c = h(o);
              return c = unescape(c), c = e(c), c = y(c), a(c);
            }
            if (o = v(ae), o) {
              const c = y(o);
              return a(c);
            }
            if (o = C("filename", "i").exec(ae), o) {
              o = o[1];
              let c = h(o);
              return c = y(c), a(c);
            }
            function C(c, d) {
              return new RegExp("(?:^|;)\\s*" + c + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', d);
            }
            function t(c, d) {
              if (c) {
                if (!/^[\x00-\xFF]+$/.test(d))
                  return d;
                try {
                  const p = new TextDecoder(c, {
                    fatal: !0
                  }), m = (0, ce.stringToBytes)(d);
                  d = p.decode(m), Z = !1;
                } catch {
                }
              }
              return d;
            }
            function a(c) {
              return Z && /[\x80-\xff]/.test(c) && (c = t("utf-8", c), Z && (c = t("iso-8859-1", c))), c;
            }
            function v(c) {
              const d = [];
              let p;
              const m = C("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
              for (; (p = m.exec(c)) !== null; ) {
                let [, n, i, l] = p;
                if (n = parseInt(n, 10), n in d) {
                  if (n === 0)
                    break;
                  continue;
                }
                d[n] = [i, l];
              }
              const g = [];
              for (let n = 0; n < d.length && n in d; ++n) {
                let [i, l] = d[n];
                l = h(l), i && (l = unescape(l), n === 0 && (l = e(l))), g.push(l);
              }
              return g.join("");
            }
            function h(c) {
              if (c.startsWith('"')) {
                const d = c.slice(1).split('\\"');
                for (let p = 0; p < d.length; ++p) {
                  const m = d[p].indexOf('"');
                  m !== -1 && (d[p] = d[p].slice(0, m), d.length = p + 1), d[p] = d[p].replace(/\\(.)/g, "$1");
                }
                c = d.join('"');
              }
              return c;
            }
            function e(c) {
              const d = c.indexOf("'");
              if (d === -1)
                return c;
              const p = c.slice(0, d), g = c.slice(d + 1).replace(/^[^']*'/, "");
              return t(p, g);
            }
            function y(c) {
              return !c.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(c) ? c : c.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(d, p, m, g) {
                if (m === "q" || m === "Q")
                  return g = g.replace(/_/g, " "), g = g.replace(/=([0-9a-fA-F]{2})/g, function(n, i) {
                    return String.fromCharCode(parseInt(i, 16));
                  }), t(p, g);
                try {
                  g = atob(g);
                } catch {
                }
                return t(p, g);
              });
            }
            return "";
          }
        },
        /* 35 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.PDFNetworkStream = void 0;
          var ce = le(1), re = le(33);
          const ae = 200, Z = 206;
          function o(h) {
            const e = h.response;
            return typeof e != "string" ? e : (0, ce.stringToBytes)(e).buffer;
          }
          class C {
            constructor(e, y = {}) {
              this.url = e, this.isHttp = /^https?:/i.test(e), this.httpHeaders = this.isHttp && y.httpHeaders || /* @__PURE__ */ Object.create(null), this.withCredentials = y.withCredentials || !1, this.getXhr = y.getXhr || function() {
                return new XMLHttpRequest();
              }, this.currXhrId = 0, this.pendingRequests = /* @__PURE__ */ Object.create(null);
            }
            requestRange(e, y, c) {
              const d = {
                begin: e,
                end: y
              };
              for (const p in c)
                d[p] = c[p];
              return this.request(d);
            }
            requestFull(e) {
              return this.request(e);
            }
            request(e) {
              const y = this.getXhr(), c = this.currXhrId++, d = this.pendingRequests[c] = {
                xhr: y
              };
              y.open("GET", this.url), y.withCredentials = this.withCredentials;
              for (const p in this.httpHeaders) {
                const m = this.httpHeaders[p];
                typeof m > "u" || y.setRequestHeader(p, m);
              }
              return this.isHttp && "begin" in e && "end" in e ? (y.setRequestHeader("Range", `bytes=${e.begin}-${e.end - 1}`), d.expectedStatus = Z) : d.expectedStatus = ae, y.responseType = "arraybuffer", e.onError && (y.onerror = function(p) {
                e.onError(y.status);
              }), y.onreadystatechange = this.onStateChange.bind(this, c), y.onprogress = this.onProgress.bind(this, c), d.onHeadersReceived = e.onHeadersReceived, d.onDone = e.onDone, d.onError = e.onError, d.onProgress = e.onProgress, y.send(null), c;
            }
            onProgress(e, y) {
              var d;
              const c = this.pendingRequests[e];
              c && ((d = c.onProgress) == null || d.call(c, y));
            }
            onStateChange(e, y) {
              var n, i, l;
              const c = this.pendingRequests[e];
              if (!c)
                return;
              const d = c.xhr;
              if (d.readyState >= 2 && c.onHeadersReceived && (c.onHeadersReceived(), delete c.onHeadersReceived), d.readyState !== 4 || !(e in this.pendingRequests))
                return;
              if (delete this.pendingRequests[e], d.status === 0 && this.isHttp) {
                (n = c.onError) == null || n.call(c, d.status);
                return;
              }
              const p = d.status || ae;
              if (!(p === ae && c.expectedStatus === Z) && p !== c.expectedStatus) {
                (i = c.onError) == null || i.call(c, d.status);
                return;
              }
              const g = o(d);
              if (p === Z) {
                const u = d.getResponseHeader("Content-Range"), w = /bytes (\d+)-(\d+)\/(\d+)/.exec(u);
                c.onDone({
                  begin: parseInt(w[1], 10),
                  chunk: g
                });
              } else
                g ? c.onDone({
                  begin: 0,
                  chunk: g
                }) : (l = c.onError) == null || l.call(c, d.status);
            }
            getRequestXhr(e) {
              return this.pendingRequests[e].xhr;
            }
            isPendingRequest(e) {
              return e in this.pendingRequests;
            }
            abortRequest(e) {
              const y = this.pendingRequests[e].xhr;
              delete this.pendingRequests[e], y.abort();
            }
          }
          class t {
            constructor(e) {
              this._source = e, this._manager = new C(e.url, {
                httpHeaders: e.httpHeaders,
                withCredentials: e.withCredentials
              }), this._rangeChunkSize = e.rangeChunkSize, this._fullRequestReader = null, this._rangeRequestReaders = [];
            }
            _onRangeRequestReaderClosed(e) {
              const y = this._rangeRequestReaders.indexOf(e);
              y >= 0 && this._rangeRequestReaders.splice(y, 1);
            }
            getFullReader() {
              return (0, ce.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once."), this._fullRequestReader = new a(this._manager, this._source), this._fullRequestReader;
            }
            getRangeReader(e, y) {
              const c = new v(this._manager, e, y);
              return c.onClosed = this._onRangeRequestReaderClosed.bind(this), this._rangeRequestReaders.push(c), c;
            }
            cancelAllRequests(e) {
              var y;
              (y = this._fullRequestReader) == null || y.cancel(e);
              for (const c of this._rangeRequestReaders.slice(0))
                c.cancel(e);
            }
          }
          ge.PDFNetworkStream = t;
          class a {
            constructor(e, y) {
              this._manager = e;
              const c = {
                onHeadersReceived: this._onHeadersReceived.bind(this),
                onDone: this._onDone.bind(this),
                onError: this._onError.bind(this),
                onProgress: this._onProgress.bind(this)
              };
              this._url = y.url, this._fullRequestId = e.requestFull(c), this._headersReceivedCapability = (0, ce.createPromiseCapability)(), this._disableRange = y.disableRange || !1, this._contentLength = y.length, this._rangeChunkSize = y.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !1, this._isRangeSupported = !1, this._cachedChunks = [], this._requests = [], this._done = !1, this._storedError = void 0, this._filename = null, this.onProgress = null;
            }
            _onHeadersReceived() {
              const e = this._fullRequestId, y = this._manager.getRequestXhr(e), c = (m) => y.getResponseHeader(m), {
                allowRangeRequests: d,
                suggestedLength: p
              } = (0, re.validateRangeRequestCapabilities)({
                getResponseHeader: c,
                isHttp: this._manager.isHttp,
                rangeChunkSize: this._rangeChunkSize,
                disableRange: this._disableRange
              });
              d && (this._isRangeSupported = !0), this._contentLength = p || this._contentLength, this._filename = (0, re.extractFilenameFromHeader)(c), this._isRangeSupported && this._manager.abortRequest(e), this._headersReceivedCapability.resolve();
            }
            _onDone(e) {
              if (e && (this._requests.length > 0 ? this._requests.shift().resolve({
                value: e.chunk,
                done: !1
              }) : this._cachedChunks.push(e.chunk)), this._done = !0, !(this._cachedChunks.length > 0)) {
                for (const y of this._requests)
                  y.resolve({
                    value: void 0,
                    done: !0
                  });
                this._requests.length = 0;
              }
            }
            _onError(e) {
              this._storedError = (0, re.createResponseStatusError)(e, this._url), this._headersReceivedCapability.reject(this._storedError);
              for (const y of this._requests)
                y.reject(this._storedError);
              this._requests.length = 0, this._cachedChunks.length = 0;
            }
            _onProgress(e) {
              var y;
              (y = this.onProgress) == null || y.call(this, {
                loaded: e.loaded,
                total: e.lengthComputable ? e.total : this._contentLength
              });
            }
            get filename() {
              return this._filename;
            }
            get isRangeSupported() {
              return this._isRangeSupported;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            get contentLength() {
              return this._contentLength;
            }
            get headersReady() {
              return this._headersReceivedCapability.promise;
            }
            async read() {
              if (this._storedError)
                throw this._storedError;
              if (this._cachedChunks.length > 0)
                return {
                  value: this._cachedChunks.shift(),
                  done: !1
                };
              if (this._done)
                return {
                  value: void 0,
                  done: !0
                };
              const e = (0, ce.createPromiseCapability)();
              return this._requests.push(e), e.promise;
            }
            cancel(e) {
              this._done = !0, this._headersReceivedCapability.reject(e);
              for (const y of this._requests)
                y.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0, this._manager.isPendingRequest(this._fullRequestId) && this._manager.abortRequest(this._fullRequestId), this._fullRequestReader = null;
            }
          }
          class v {
            constructor(e, y, c) {
              this._manager = e;
              const d = {
                onDone: this._onDone.bind(this),
                onError: this._onError.bind(this),
                onProgress: this._onProgress.bind(this)
              };
              this._url = e.url, this._requestId = e.requestRange(y, c, d), this._requests = [], this._queuedChunk = null, this._done = !1, this._storedError = void 0, this.onProgress = null, this.onClosed = null;
            }
            _close() {
              var e;
              (e = this.onClosed) == null || e.call(this, this);
            }
            _onDone(e) {
              const y = e.chunk;
              this._requests.length > 0 ? this._requests.shift().resolve({
                value: y,
                done: !1
              }) : this._queuedChunk = y, this._done = !0;
              for (const c of this._requests)
                c.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0, this._close();
            }
            _onError(e) {
              this._storedError = (0, re.createResponseStatusError)(e, this._url);
              for (const y of this._requests)
                y.reject(this._storedError);
              this._requests.length = 0, this._queuedChunk = null;
            }
            _onProgress(e) {
              var y;
              this.isStreamingSupported || (y = this.onProgress) == null || y.call(this, {
                loaded: e.loaded
              });
            }
            get isStreamingSupported() {
              return !1;
            }
            async read() {
              if (this._storedError)
                throw this._storedError;
              if (this._queuedChunk !== null) {
                const y = this._queuedChunk;
                return this._queuedChunk = null, {
                  value: y,
                  done: !1
                };
              }
              if (this._done)
                return {
                  value: void 0,
                  done: !0
                };
              const e = (0, ce.createPromiseCapability)();
              return this._requests.push(e), e.promise;
            }
            cancel(e) {
              this._done = !0;
              for (const y of this._requests)
                y.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0, this._manager.isPendingRequest(this._requestId) && this._manager.abortRequest(this._requestId), this._close();
            }
          }
        },
        /* 36 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.PDFFetchStream = void 0;
          var ce = le(1), re = le(33);
          function ae(a, v, h) {
            return {
              method: "GET",
              headers: a,
              signal: h.signal,
              mode: "cors",
              credentials: v ? "include" : "same-origin",
              redirect: "follow"
            };
          }
          function Z(a) {
            const v = new Headers();
            for (const h in a) {
              const e = a[h];
              typeof e > "u" || v.append(h, e);
            }
            return v;
          }
          class o {
            constructor(v) {
              this.source = v, this.isHttp = /^https?:/i.test(v.url), this.httpHeaders = this.isHttp && v.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
            }
            get _progressiveDataLength() {
              var v;
              return ((v = this._fullRequestReader) == null ? void 0 : v._loaded) ?? 0;
            }
            getFullReader() {
              return (0, ce.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once."), this._fullRequestReader = new C(this), this._fullRequestReader;
            }
            getRangeReader(v, h) {
              if (h <= this._progressiveDataLength)
                return null;
              const e = new t(this, v, h);
              return this._rangeRequestReaders.push(e), e;
            }
            cancelAllRequests(v) {
              this._fullRequestReader && this._fullRequestReader.cancel(v);
              for (const h of this._rangeRequestReaders.slice(0))
                h.cancel(v);
            }
          }
          ge.PDFFetchStream = o;
          class C {
            constructor(v) {
              this._stream = v, this._reader = null, this._loaded = 0, this._filename = null;
              const h = v.source;
              this._withCredentials = h.withCredentials || !1, this._contentLength = h.length, this._headersCapability = (0, ce.createPromiseCapability)(), this._disableRange = h.disableRange || !1, this._rangeChunkSize = h.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._abortController = new AbortController(), this._isStreamingSupported = !h.disableStream, this._isRangeSupported = !h.disableRange, this._headers = Z(this._stream.httpHeaders);
              const e = h.url;
              fetch(e, ae(this._headers, this._withCredentials, this._abortController)).then((y) => {
                if (!(0, re.validateResponseStatus)(y.status))
                  throw (0, re.createResponseStatusError)(y.status, e);
                this._reader = y.body.getReader(), this._headersCapability.resolve();
                const c = (m) => y.headers.get(m), {
                  allowRangeRequests: d,
                  suggestedLength: p
                } = (0, re.validateRangeRequestCapabilities)({
                  getResponseHeader: c,
                  isHttp: this._stream.isHttp,
                  rangeChunkSize: this._rangeChunkSize,
                  disableRange: this._disableRange
                });
                this._isRangeSupported = d, this._contentLength = p || this._contentLength, this._filename = (0, re.extractFilenameFromHeader)(c), !this._isStreamingSupported && this._isRangeSupported && this.cancel(new ce.AbortException("Streaming is disabled."));
              }).catch(this._headersCapability.reject), this.onProgress = null;
            }
            get headersReady() {
              return this._headersCapability.promise;
            }
            get filename() {
              return this._filename;
            }
            get contentLength() {
              return this._contentLength;
            }
            get isRangeSupported() {
              return this._isRangeSupported;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            async read() {
              await this._headersCapability.promise;
              const {
                value: v,
                done: h
              } = await this._reader.read();
              return h ? {
                value: v,
                done: h
              } : (this._loaded += v.byteLength, this.onProgress && this.onProgress({
                loaded: this._loaded,
                total: this._contentLength
              }), {
                value: new Uint8Array(v).buffer,
                done: !1
              });
            }
            cancel(v) {
              this._reader && this._reader.cancel(v), this._abortController.abort();
            }
          }
          class t {
            constructor(v, h, e) {
              this._stream = v, this._reader = null, this._loaded = 0;
              const y = v.source;
              this._withCredentials = y.withCredentials || !1, this._readCapability = (0, ce.createPromiseCapability)(), this._isStreamingSupported = !y.disableStream, this._abortController = new AbortController(), this._headers = Z(this._stream.httpHeaders), this._headers.append("Range", `bytes=${h}-${e - 1}`);
              const c = y.url;
              fetch(c, ae(this._headers, this._withCredentials, this._abortController)).then((d) => {
                if (!(0, re.validateResponseStatus)(d.status))
                  throw (0, re.createResponseStatusError)(d.status, c);
                this._readCapability.resolve(), this._reader = d.body.getReader();
              }).catch(this._readCapability.reject), this.onProgress = null;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            async read() {
              await this._readCapability.promise;
              const {
                value: v,
                done: h
              } = await this._reader.read();
              return h ? {
                value: v,
                done: h
              } : (this._loaded += v.byteLength, this.onProgress && this.onProgress({
                loaded: this._loaded
              }), {
                value: new Uint8Array(v).buffer,
                done: !1
              });
            }
            cancel(v) {
              this._reader && this._reader.cancel(v), this._abortController.abort();
            }
          }
        }
        /******/
      ], __webpack_module_cache__ = {};
      function __w_pdfjs_require__(be) {
        var ge = __webpack_module_cache__[be];
        if (ge !== void 0)
          return ge.exports;
        var le = __webpack_module_cache__[be] = {
          /******/
          // no module.id needed
          /******/
          // no module.loaded needed
          /******/
          exports: {}
          /******/
        };
        return __webpack_modules__[be](le, le.exports, __w_pdfjs_require__), le.exports;
      }
      var __webpack_exports__ = {};
      return (() => {
        var be = __webpack_exports__;
        Object.defineProperty(be, "__esModule", {
          value: !0
        }), Object.defineProperty(be, "AnnotationEditorLayer", {
          enumerable: !0,
          get: function() {
            return re.AnnotationEditorLayer;
          }
        }), Object.defineProperty(be, "AnnotationEditorParamsType", {
          enumerable: !0,
          get: function() {
            return ge.AnnotationEditorParamsType;
          }
        }), Object.defineProperty(be, "AnnotationEditorType", {
          enumerable: !0,
          get: function() {
            return ge.AnnotationEditorType;
          }
        }), Object.defineProperty(be, "AnnotationEditorUIManager", {
          enumerable: !0,
          get: function() {
            return ae.AnnotationEditorUIManager;
          }
        }), Object.defineProperty(be, "AnnotationLayer", {
          enumerable: !0,
          get: function() {
            return Z.AnnotationLayer;
          }
        }), Object.defineProperty(be, "AnnotationMode", {
          enumerable: !0,
          get: function() {
            return ge.AnnotationMode;
          }
        }), Object.defineProperty(be, "CMapCompressionType", {
          enumerable: !0,
          get: function() {
            return ge.CMapCompressionType;
          }
        }), Object.defineProperty(be, "GlobalWorkerOptions", {
          enumerable: !0,
          get: function() {
            return o.GlobalWorkerOptions;
          }
        }), Object.defineProperty(be, "InvalidPDFException", {
          enumerable: !0,
          get: function() {
            return ge.InvalidPDFException;
          }
        }), Object.defineProperty(be, "LoopbackPort", {
          enumerable: !0,
          get: function() {
            return le.LoopbackPort;
          }
        }), Object.defineProperty(be, "MissingPDFException", {
          enumerable: !0,
          get: function() {
            return ge.MissingPDFException;
          }
        }), Object.defineProperty(be, "OPS", {
          enumerable: !0,
          get: function() {
            return ge.OPS;
          }
        }), Object.defineProperty(be, "PDFDataRangeTransport", {
          enumerable: !0,
          get: function() {
            return le.PDFDataRangeTransport;
          }
        }), Object.defineProperty(be, "PDFDateString", {
          enumerable: !0,
          get: function() {
            return ce.PDFDateString;
          }
        }), Object.defineProperty(be, "PDFWorker", {
          enumerable: !0,
          get: function() {
            return le.PDFWorker;
          }
        }), Object.defineProperty(be, "PasswordResponses", {
          enumerable: !0,
          get: function() {
            return ge.PasswordResponses;
          }
        }), Object.defineProperty(be, "PermissionFlag", {
          enumerable: !0,
          get: function() {
            return ge.PermissionFlag;
          }
        }), Object.defineProperty(be, "PixelsPerInch", {
          enumerable: !0,
          get: function() {
            return ce.PixelsPerInch;
          }
        }), Object.defineProperty(be, "RenderingCancelledException", {
          enumerable: !0,
          get: function() {
            return ce.RenderingCancelledException;
          }
        }), Object.defineProperty(be, "SVGGraphics", {
          enumerable: !0,
          get: function() {
            return a.SVGGraphics;
          }
        }), Object.defineProperty(be, "UNSUPPORTED_FEATURES", {
          enumerable: !0,
          get: function() {
            return ge.UNSUPPORTED_FEATURES;
          }
        }), Object.defineProperty(be, "UnexpectedResponseException", {
          enumerable: !0,
          get: function() {
            return ge.UnexpectedResponseException;
          }
        }), Object.defineProperty(be, "Util", {
          enumerable: !0,
          get: function() {
            return ge.Util;
          }
        }), Object.defineProperty(be, "VerbosityLevel", {
          enumerable: !0,
          get: function() {
            return ge.VerbosityLevel;
          }
        }), Object.defineProperty(be, "XfaLayer", {
          enumerable: !0,
          get: function() {
            return v.XfaLayer;
          }
        }), Object.defineProperty(be, "build", {
          enumerable: !0,
          get: function() {
            return le.build;
          }
        }), Object.defineProperty(be, "createPromiseCapability", {
          enumerable: !0,
          get: function() {
            return ge.createPromiseCapability;
          }
        }), Object.defineProperty(be, "createValidAbsoluteUrl", {
          enumerable: !0,
          get: function() {
            return ge.createValidAbsoluteUrl;
          }
        }), Object.defineProperty(be, "getDocument", {
          enumerable: !0,
          get: function() {
            return le.getDocument;
          }
        }), Object.defineProperty(be, "getFilenameFromUrl", {
          enumerable: !0,
          get: function() {
            return ce.getFilenameFromUrl;
          }
        }), Object.defineProperty(be, "getPdfFilenameFromUrl", {
          enumerable: !0,
          get: function() {
            return ce.getPdfFilenameFromUrl;
          }
        }), Object.defineProperty(be, "getXfaPageViewport", {
          enumerable: !0,
          get: function() {
            return ce.getXfaPageViewport;
          }
        }), Object.defineProperty(be, "isPdfFile", {
          enumerable: !0,
          get: function() {
            return ce.isPdfFile;
          }
        }), Object.defineProperty(be, "loadScript", {
          enumerable: !0,
          get: function() {
            return ce.loadScript;
          }
        }), Object.defineProperty(be, "renderTextLayer", {
          enumerable: !0,
          get: function() {
            return t.renderTextLayer;
          }
        }), Object.defineProperty(be, "shadow", {
          enumerable: !0,
          get: function() {
            return ge.shadow;
          }
        }), Object.defineProperty(be, "version", {
          enumerable: !0,
          get: function() {
            return le.version;
          }
        });
        var ge = __w_pdfjs_require__(1), le = __w_pdfjs_require__(4), ce = __w_pdfjs_require__(8), re = __w_pdfjs_require__(22), ae = __w_pdfjs_require__(7), Z = __w_pdfjs_require__(27), o = __w_pdfjs_require__(15), C = __w_pdfjs_require__(3), t = __w_pdfjs_require__(30), a = __w_pdfjs_require__(31), v = __w_pdfjs_require__(29);
        if (C.isNodeJS) {
          const {
            PDFNodeStream: h
          } = __w_pdfjs_require__(32);
          (0, le.setPDFNetworkStreamFactory)((e) => new h(e));
        } else {
          const {
            PDFNetworkStream: h
          } = __w_pdfjs_require__(35), {
            PDFFetchStream: e
          } = __w_pdfjs_require__(36);
          (0, le.setPDFNetworkStreamFactory)((y) => (0, ce.isValidFetchUrl)(y.url) ? new e(y) : new h(y));
        }
      })(), __webpack_exports__;
    })()
  ));
})(pdf);
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(be) {
    for (var ge = 1; ge < arguments.length; ge++) {
      var le = arguments[ge];
      for (var ce in le)
        Object.prototype.hasOwnProperty.call(le, ce) && (be[ce] = le[ce]);
    }
    return be;
  }, _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(be, ge) {
  if (be == null)
    return {};
  var le = {}, ce = Object.keys(be), re, ae;
  for (ae = 0; ae < ce.length; ae++)
    re = ce[ae], !(ge.indexOf(re) >= 0) && (le[re] = be[re]);
  return le;
}
function _objectWithoutProperties(be, ge) {
  if (be == null)
    return {};
  var le = _objectWithoutPropertiesLoose(be, ge), ce, re;
  if (Object.getOwnPropertySymbols) {
    var ae = Object.getOwnPropertySymbols(be);
    for (re = 0; re < ae.length; re++)
      ce = ae[re], !(ge.indexOf(ce) >= 0) && Object.prototype.propertyIsEnumerable.call(be, ce) && (le[ce] = be[ce]);
  }
  return le;
}
function _typeof(be) {
  return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ge) {
    return typeof ge;
  } : function(ge) {
    return ge && typeof Symbol == "function" && ge.constructor === Symbol && ge !== Symbol.prototype ? "symbol" : typeof ge;
  }, _typeof(be);
}
function _classCallCheck(be, ge) {
  if (!(be instanceof ge))
    throw new TypeError("Cannot call a class as a function");
}
function _toPrimitive(be, ge) {
  if (_typeof(be) !== "object" || be === null)
    return be;
  var le = be[Symbol.toPrimitive];
  if (le !== void 0) {
    var ce = le.call(be, ge || "default");
    if (_typeof(ce) !== "object")
      return ce;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (ge === "string" ? String : Number)(be);
}
function _toPropertyKey(be) {
  var ge = _toPrimitive(be, "string");
  return _typeof(ge) === "symbol" ? ge : String(ge);
}
function _defineProperties(be, ge) {
  for (var le = 0; le < ge.length; le++) {
    var ce = ge[le];
    ce.enumerable = ce.enumerable || !1, ce.configurable = !0, "value" in ce && (ce.writable = !0), Object.defineProperty(be, _toPropertyKey(ce.key), ce);
  }
}
function _createClass(be, ge, le) {
  return ge && _defineProperties(be.prototype, ge), le && _defineProperties(be, le), Object.defineProperty(be, "prototype", {
    writable: !1
  }), be;
}
function _assertThisInitialized(be) {
  if (be === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return be;
}
function _setPrototypeOf(be, ge) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(ce, re) {
    return ce.__proto__ = re, ce;
  }, _setPrototypeOf(be, ge);
}
function _inherits(be, ge) {
  if (typeof ge != "function" && ge !== null)
    throw new TypeError("Super expression must either be null or a function");
  be.prototype = Object.create(ge && ge.prototype, {
    constructor: {
      value: be,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(be, "prototype", {
    writable: !1
  }), ge && _setPrototypeOf(be, ge);
}
function _possibleConstructorReturn(be, ge) {
  if (ge && (_typeof(ge) === "object" || typeof ge == "function"))
    return ge;
  if (ge !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(be);
}
function _getPrototypeOf(be) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(le) {
    return le.__proto__ || Object.getPrototypeOf(le);
  }, _getPrototypeOf(be);
}
function _defineProperty(be, ge, le) {
  return ge = _toPropertyKey(ge), ge in be ? Object.defineProperty(be, ge, {
    value: le,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : be[ge] = le, be;
}
var propTypesExports = {}, propTypes = {
  get exports() {
    return propTypesExports;
  },
  set exports(be) {
    propTypesExports = be;
  }
}, reactIsExports = {}, reactIs = {
  get exports() {
    return reactIsExports;
  },
  set exports(be) {
    reactIsExports = be;
  }
}, reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
  if (hasRequiredReactIs_production_min)
    return reactIs_production_min;
  hasRequiredReactIs_production_min = 1;
  var be = typeof Symbol == "function" && Symbol.for, ge = be ? Symbol.for("react.element") : 60103, le = be ? Symbol.for("react.portal") : 60106, ce = be ? Symbol.for("react.fragment") : 60107, re = be ? Symbol.for("react.strict_mode") : 60108, ae = be ? Symbol.for("react.profiler") : 60114, Z = be ? Symbol.for("react.provider") : 60109, o = be ? Symbol.for("react.context") : 60110, C = be ? Symbol.for("react.async_mode") : 60111, t = be ? Symbol.for("react.concurrent_mode") : 60111, a = be ? Symbol.for("react.forward_ref") : 60112, v = be ? Symbol.for("react.suspense") : 60113, h = be ? Symbol.for("react.suspense_list") : 60120, e = be ? Symbol.for("react.memo") : 60115, y = be ? Symbol.for("react.lazy") : 60116, c = be ? Symbol.for("react.block") : 60121, d = be ? Symbol.for("react.fundamental") : 60117, p = be ? Symbol.for("react.responder") : 60118, m = be ? Symbol.for("react.scope") : 60119;
  function g(i) {
    if (typeof i == "object" && i !== null) {
      var l = i.$$typeof;
      switch (l) {
        case ge:
          switch (i = i.type, i) {
            case C:
            case t:
            case ce:
            case ae:
            case re:
            case v:
              return i;
            default:
              switch (i = i && i.$$typeof, i) {
                case o:
                case a:
                case y:
                case e:
                case Z:
                  return i;
                default:
                  return l;
              }
          }
        case le:
          return l;
      }
    }
  }
  function n(i) {
    return g(i) === t;
  }
  return reactIs_production_min.AsyncMode = C, reactIs_production_min.ConcurrentMode = t, reactIs_production_min.ContextConsumer = o, reactIs_production_min.ContextProvider = Z, reactIs_production_min.Element = ge, reactIs_production_min.ForwardRef = a, reactIs_production_min.Fragment = ce, reactIs_production_min.Lazy = y, reactIs_production_min.Memo = e, reactIs_production_min.Portal = le, reactIs_production_min.Profiler = ae, reactIs_production_min.StrictMode = re, reactIs_production_min.Suspense = v, reactIs_production_min.isAsyncMode = function(i) {
    return n(i) || g(i) === C;
  }, reactIs_production_min.isConcurrentMode = n, reactIs_production_min.isContextConsumer = function(i) {
    return g(i) === o;
  }, reactIs_production_min.isContextProvider = function(i) {
    return g(i) === Z;
  }, reactIs_production_min.isElement = function(i) {
    return typeof i == "object" && i !== null && i.$$typeof === ge;
  }, reactIs_production_min.isForwardRef = function(i) {
    return g(i) === a;
  }, reactIs_production_min.isFragment = function(i) {
    return g(i) === ce;
  }, reactIs_production_min.isLazy = function(i) {
    return g(i) === y;
  }, reactIs_production_min.isMemo = function(i) {
    return g(i) === e;
  }, reactIs_production_min.isPortal = function(i) {
    return g(i) === le;
  }, reactIs_production_min.isProfiler = function(i) {
    return g(i) === ae;
  }, reactIs_production_min.isStrictMode = function(i) {
    return g(i) === re;
  }, reactIs_production_min.isSuspense = function(i) {
    return g(i) === v;
  }, reactIs_production_min.isValidElementType = function(i) {
    return typeof i == "string" || typeof i == "function" || i === ce || i === t || i === ae || i === re || i === v || i === h || typeof i == "object" && i !== null && (i.$$typeof === y || i.$$typeof === e || i.$$typeof === Z || i.$$typeof === o || i.$$typeof === a || i.$$typeof === d || i.$$typeof === p || i.$$typeof === m || i.$$typeof === c);
  }, reactIs_production_min.typeOf = g, reactIs_production_min;
}
var reactIs_development = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_development;
function requireReactIs_development() {
  return hasRequiredReactIs_development || (hasRequiredReactIs_development = 1, process.env.NODE_ENV !== "production" && function() {
    var be = typeof Symbol == "function" && Symbol.for, ge = be ? Symbol.for("react.element") : 60103, le = be ? Symbol.for("react.portal") : 60106, ce = be ? Symbol.for("react.fragment") : 60107, re = be ? Symbol.for("react.strict_mode") : 60108, ae = be ? Symbol.for("react.profiler") : 60114, Z = be ? Symbol.for("react.provider") : 60109, o = be ? Symbol.for("react.context") : 60110, C = be ? Symbol.for("react.async_mode") : 60111, t = be ? Symbol.for("react.concurrent_mode") : 60111, a = be ? Symbol.for("react.forward_ref") : 60112, v = be ? Symbol.for("react.suspense") : 60113, h = be ? Symbol.for("react.suspense_list") : 60120, e = be ? Symbol.for("react.memo") : 60115, y = be ? Symbol.for("react.lazy") : 60116, c = be ? Symbol.for("react.block") : 60121, d = be ? Symbol.for("react.fundamental") : 60117, p = be ? Symbol.for("react.responder") : 60118, m = be ? Symbol.for("react.scope") : 60119;
    function g(L) {
      return typeof L == "string" || typeof L == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      L === ce || L === t || L === ae || L === re || L === v || L === h || typeof L == "object" && L !== null && (L.$$typeof === y || L.$$typeof === e || L.$$typeof === Z || L.$$typeof === o || L.$$typeof === a || L.$$typeof === d || L.$$typeof === p || L.$$typeof === m || L.$$typeof === c);
    }
    function n(L) {
      if (typeof L == "object" && L !== null) {
        var K = L.$$typeof;
        switch (K) {
          case ge:
            var te = L.type;
            switch (te) {
              case C:
              case t:
              case ce:
              case ae:
              case re:
              case v:
                return te;
              default:
                var se = te && te.$$typeof;
                switch (se) {
                  case o:
                  case a:
                  case y:
                  case e:
                  case Z:
                    return se;
                  default:
                    return K;
                }
            }
          case le:
            return K;
        }
      }
    }
    var i = C, l = t, u = o, w = Z, _ = ge, b = a, A = ce, Y = y, j = e, X = le, B = ae, R = re, k = v, x = !1;
    function f(L) {
      return x || (x = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), U(L) || n(L) === C;
    }
    function U(L) {
      return n(L) === t;
    }
    function O(L) {
      return n(L) === o;
    }
    function S(L) {
      return n(L) === Z;
    }
    function F(L) {
      return typeof L == "object" && L !== null && L.$$typeof === ge;
    }
    function T(L) {
      return n(L) === a;
    }
    function I(L) {
      return n(L) === ce;
    }
    function M(L) {
      return n(L) === y;
    }
    function V(L) {
      return n(L) === e;
    }
    function J(L) {
      return n(L) === le;
    }
    function W(L) {
      return n(L) === ae;
    }
    function z(L) {
      return n(L) === re;
    }
    function G(L) {
      return n(L) === v;
    }
    reactIs_development.AsyncMode = i, reactIs_development.ConcurrentMode = l, reactIs_development.ContextConsumer = u, reactIs_development.ContextProvider = w, reactIs_development.Element = _, reactIs_development.ForwardRef = b, reactIs_development.Fragment = A, reactIs_development.Lazy = Y, reactIs_development.Memo = j, reactIs_development.Portal = X, reactIs_development.Profiler = B, reactIs_development.StrictMode = R, reactIs_development.Suspense = k, reactIs_development.isAsyncMode = f, reactIs_development.isConcurrentMode = U, reactIs_development.isContextConsumer = O, reactIs_development.isContextProvider = S, reactIs_development.isElement = F, reactIs_development.isForwardRef = T, reactIs_development.isFragment = I, reactIs_development.isLazy = M, reactIs_development.isMemo = V, reactIs_development.isPortal = J, reactIs_development.isProfiler = W, reactIs_development.isStrictMode = z, reactIs_development.isSuspense = G, reactIs_development.isValidElementType = g, reactIs_development.typeOf = n;
  }()), reactIs_development;
}
var hasRequiredReactIs;
function requireReactIs() {
  return hasRequiredReactIs || (hasRequiredReactIs = 1, function(be) {
    process.env.NODE_ENV === "production" ? be.exports = requireReactIs_production_min() : be.exports = requireReactIs_development();
  }(reactIs)), reactIsExports;
}
var ReactPropTypesSecret_1, hasRequiredReactPropTypesSecret;
function requireReactPropTypesSecret() {
  if (hasRequiredReactPropTypesSecret)
    return ReactPropTypesSecret_1;
  hasRequiredReactPropTypesSecret = 1;
  var be = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return ReactPropTypesSecret_1 = be, ReactPropTypesSecret_1;
}
var has, hasRequiredHas;
function requireHas() {
  return hasRequiredHas || (hasRequiredHas = 1, has = Function.call.bind(Object.prototype.hasOwnProperty)), has;
}
var checkPropTypes_1, hasRequiredCheckPropTypes;
function requireCheckPropTypes() {
  if (hasRequiredCheckPropTypes)
    return checkPropTypes_1;
  hasRequiredCheckPropTypes = 1;
  var be = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var ge = requireReactPropTypesSecret(), le = {}, ce = requireHas();
    be = function(ae) {
      var Z = "Warning: " + ae;
      typeof console < "u" && console.error(Z);
      try {
        throw new Error(Z);
      } catch {
      }
    };
  }
  function re(ae, Z, o, C, t) {
    if (process.env.NODE_ENV !== "production") {
      for (var a in ae)
        if (ce(ae, a)) {
          var v;
          try {
            if (typeof ae[a] != "function") {
              var h = Error(
                (C || "React class") + ": " + o + " type `" + a + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof ae[a] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw h.name = "Invariant Violation", h;
            }
            v = ae[a](Z, a, C, o, null, ge);
          } catch (y) {
            v = y;
          }
          if (v && !(v instanceof Error) && be(
            (C || "React class") + ": type specification of " + o + " `" + a + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof v + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), v instanceof Error && !(v.message in le)) {
            le[v.message] = !0;
            var e = t ? t() : "";
            be(
              "Failed " + o + " type: " + v.message + (e ?? "")
            );
          }
        }
    }
  }
  return re.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (le = {});
  }, checkPropTypes_1 = re, checkPropTypes_1;
}
var factoryWithTypeCheckers, hasRequiredFactoryWithTypeCheckers;
function requireFactoryWithTypeCheckers() {
  if (hasRequiredFactoryWithTypeCheckers)
    return factoryWithTypeCheckers;
  hasRequiredFactoryWithTypeCheckers = 1;
  var be = requireReactIs(), ge = requireObjectAssign(), le = requireReactPropTypesSecret(), ce = requireHas(), re = requireCheckPropTypes(), ae = function() {
  };
  process.env.NODE_ENV !== "production" && (ae = function(o) {
    var C = "Warning: " + o;
    typeof console < "u" && console.error(C);
    try {
      throw new Error(C);
    } catch {
    }
  });
  function Z() {
    return null;
  }
  return factoryWithTypeCheckers = function(o, C) {
    var t = typeof Symbol == "function" && Symbol.iterator, a = "@@iterator";
    function v(U) {
      var O = U && (t && U[t] || U[a]);
      if (typeof O == "function")
        return O;
    }
    var h = "<<anonymous>>", e = {
      array: p("array"),
      bigint: p("bigint"),
      bool: p("boolean"),
      func: p("function"),
      number: p("number"),
      object: p("object"),
      string: p("string"),
      symbol: p("symbol"),
      any: m(),
      arrayOf: g,
      element: n(),
      elementType: i(),
      instanceOf: l,
      node: b(),
      objectOf: w,
      oneOf: u,
      oneOfType: _,
      shape: Y,
      exact: j
    };
    function y(U, O) {
      return U === O ? U !== 0 || 1 / U === 1 / O : U !== U && O !== O;
    }
    function c(U, O) {
      this.message = U, this.data = O && typeof O == "object" ? O : {}, this.stack = "";
    }
    c.prototype = Error.prototype;
    function d(U) {
      if (process.env.NODE_ENV !== "production")
        var O = {}, S = 0;
      function F(I, M, V, J, W, z, G) {
        if (J = J || h, z = z || V, G !== le) {
          if (C) {
            var L = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw L.name = "Invariant Violation", L;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var K = J + ":" + V;
            !O[K] && // Avoid spamming the console because they are often not actionable except for lib authors
            S < 3 && (ae(
              "You are manually calling a React.PropTypes validation function for the `" + z + "` prop on `" + J + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), O[K] = !0, S++);
          }
        }
        return M[V] == null ? I ? M[V] === null ? new c("The " + W + " `" + z + "` is marked as required " + ("in `" + J + "`, but its value is `null`.")) : new c("The " + W + " `" + z + "` is marked as required in " + ("`" + J + "`, but its value is `undefined`.")) : null : U(M, V, J, W, z);
      }
      var T = F.bind(null, !1);
      return T.isRequired = F.bind(null, !0), T;
    }
    function p(U) {
      function O(S, F, T, I, M, V) {
        var J = S[F], W = R(J);
        if (W !== U) {
          var z = k(J);
          return new c(
            "Invalid " + I + " `" + M + "` of type " + ("`" + z + "` supplied to `" + T + "`, expected ") + ("`" + U + "`."),
            { expectedType: U }
          );
        }
        return null;
      }
      return d(O);
    }
    function m() {
      return d(Z);
    }
    function g(U) {
      function O(S, F, T, I, M) {
        if (typeof U != "function")
          return new c("Property `" + M + "` of component `" + T + "` has invalid PropType notation inside arrayOf.");
        var V = S[F];
        if (!Array.isArray(V)) {
          var J = R(V);
          return new c("Invalid " + I + " `" + M + "` of type " + ("`" + J + "` supplied to `" + T + "`, expected an array."));
        }
        for (var W = 0; W < V.length; W++) {
          var z = U(V, W, T, I, M + "[" + W + "]", le);
          if (z instanceof Error)
            return z;
        }
        return null;
      }
      return d(O);
    }
    function n() {
      function U(O, S, F, T, I) {
        var M = O[S];
        if (!o(M)) {
          var V = R(M);
          return new c("Invalid " + T + " `" + I + "` of type " + ("`" + V + "` supplied to `" + F + "`, expected a single ReactElement."));
        }
        return null;
      }
      return d(U);
    }
    function i() {
      function U(O, S, F, T, I) {
        var M = O[S];
        if (!be.isValidElementType(M)) {
          var V = R(M);
          return new c("Invalid " + T + " `" + I + "` of type " + ("`" + V + "` supplied to `" + F + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return d(U);
    }
    function l(U) {
      function O(S, F, T, I, M) {
        if (!(S[F] instanceof U)) {
          var V = U.name || h, J = f(S[F]);
          return new c("Invalid " + I + " `" + M + "` of type " + ("`" + J + "` supplied to `" + T + "`, expected ") + ("instance of `" + V + "`."));
        }
        return null;
      }
      return d(O);
    }
    function u(U) {
      if (!Array.isArray(U))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? ae(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : ae("Invalid argument supplied to oneOf, expected an array.")), Z;
      function O(S, F, T, I, M) {
        for (var V = S[F], J = 0; J < U.length; J++)
          if (y(V, U[J]))
            return null;
        var W = JSON.stringify(U, function(G, L) {
          var K = k(L);
          return K === "symbol" ? String(L) : L;
        });
        return new c("Invalid " + I + " `" + M + "` of value `" + String(V) + "` " + ("supplied to `" + T + "`, expected one of " + W + "."));
      }
      return d(O);
    }
    function w(U) {
      function O(S, F, T, I, M) {
        if (typeof U != "function")
          return new c("Property `" + M + "` of component `" + T + "` has invalid PropType notation inside objectOf.");
        var V = S[F], J = R(V);
        if (J !== "object")
          return new c("Invalid " + I + " `" + M + "` of type " + ("`" + J + "` supplied to `" + T + "`, expected an object."));
        for (var W in V)
          if (ce(V, W)) {
            var z = U(V, W, T, I, M + "." + W, le);
            if (z instanceof Error)
              return z;
          }
        return null;
      }
      return d(O);
    }
    function _(U) {
      if (!Array.isArray(U))
        return process.env.NODE_ENV !== "production" && ae("Invalid argument supplied to oneOfType, expected an instance of array."), Z;
      for (var O = 0; O < U.length; O++) {
        var S = U[O];
        if (typeof S != "function")
          return ae(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + x(S) + " at index " + O + "."
          ), Z;
      }
      function F(T, I, M, V, J) {
        for (var W = [], z = 0; z < U.length; z++) {
          var G = U[z], L = G(T, I, M, V, J, le);
          if (L == null)
            return null;
          L.data && ce(L.data, "expectedType") && W.push(L.data.expectedType);
        }
        var K = W.length > 0 ? ", expected one of type [" + W.join(", ") + "]" : "";
        return new c("Invalid " + V + " `" + J + "` supplied to " + ("`" + M + "`" + K + "."));
      }
      return d(F);
    }
    function b() {
      function U(O, S, F, T, I) {
        return X(O[S]) ? null : new c("Invalid " + T + " `" + I + "` supplied to " + ("`" + F + "`, expected a ReactNode."));
      }
      return d(U);
    }
    function A(U, O, S, F, T) {
      return new c(
        (U || "React class") + ": " + O + " type `" + S + "." + F + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + T + "`."
      );
    }
    function Y(U) {
      function O(S, F, T, I, M) {
        var V = S[F], J = R(V);
        if (J !== "object")
          return new c("Invalid " + I + " `" + M + "` of type `" + J + "` " + ("supplied to `" + T + "`, expected `object`."));
        for (var W in U) {
          var z = U[W];
          if (typeof z != "function")
            return A(T, I, M, W, k(z));
          var G = z(V, W, T, I, M + "." + W, le);
          if (G)
            return G;
        }
        return null;
      }
      return d(O);
    }
    function j(U) {
      function O(S, F, T, I, M) {
        var V = S[F], J = R(V);
        if (J !== "object")
          return new c("Invalid " + I + " `" + M + "` of type `" + J + "` " + ("supplied to `" + T + "`, expected `object`."));
        var W = ge({}, S[F], U);
        for (var z in W) {
          var G = U[z];
          if (ce(U, z) && typeof G != "function")
            return A(T, I, M, z, k(G));
          if (!G)
            return new c(
              "Invalid " + I + " `" + M + "` key `" + z + "` supplied to `" + T + "`.\nBad object: " + JSON.stringify(S[F], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(U), null, "  ")
            );
          var L = G(V, z, T, I, M + "." + z, le);
          if (L)
            return L;
        }
        return null;
      }
      return d(O);
    }
    function X(U) {
      switch (typeof U) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !U;
        case "object":
          if (Array.isArray(U))
            return U.every(X);
          if (U === null || o(U))
            return !0;
          var O = v(U);
          if (O) {
            var S = O.call(U), F;
            if (O !== U.entries) {
              for (; !(F = S.next()).done; )
                if (!X(F.value))
                  return !1;
            } else
              for (; !(F = S.next()).done; ) {
                var T = F.value;
                if (T && !X(T[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function B(U, O) {
      return U === "symbol" ? !0 : O ? O["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && O instanceof Symbol : !1;
    }
    function R(U) {
      var O = typeof U;
      return Array.isArray(U) ? "array" : U instanceof RegExp ? "object" : B(O, U) ? "symbol" : O;
    }
    function k(U) {
      if (typeof U > "u" || U === null)
        return "" + U;
      var O = R(U);
      if (O === "object") {
        if (U instanceof Date)
          return "date";
        if (U instanceof RegExp)
          return "regexp";
      }
      return O;
    }
    function x(U) {
      var O = k(U);
      switch (O) {
        case "array":
        case "object":
          return "an " + O;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + O;
        default:
          return O;
      }
    }
    function f(U) {
      return !U.constructor || !U.constructor.name ? h : U.constructor.name;
    }
    return e.checkPropTypes = re, e.resetWarningCache = re.resetWarningCache, e.PropTypes = e, e;
  }, factoryWithTypeCheckers;
}
var factoryWithThrowingShims, hasRequiredFactoryWithThrowingShims;
function requireFactoryWithThrowingShims() {
  if (hasRequiredFactoryWithThrowingShims)
    return factoryWithThrowingShims;
  hasRequiredFactoryWithThrowingShims = 1;
  var be = requireReactPropTypesSecret();
  function ge() {
  }
  function le() {
  }
  return le.resetWarningCache = ge, factoryWithThrowingShims = function() {
    function ce(Z, o, C, t, a, v) {
      if (v !== be) {
        var h = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw h.name = "Invariant Violation", h;
      }
    }
    ce.isRequired = ce;
    function re() {
      return ce;
    }
    var ae = {
      array: ce,
      bigint: ce,
      bool: ce,
      func: ce,
      number: ce,
      object: ce,
      string: ce,
      symbol: ce,
      any: ce,
      arrayOf: re,
      element: ce,
      elementType: ce,
      instanceOf: re,
      node: ce,
      objectOf: re,
      oneOf: re,
      oneOfType: re,
      shape: re,
      exact: re,
      checkPropTypes: le,
      resetWarningCache: ge
    };
    return ae.PropTypes = ae, ae;
  }, factoryWithThrowingShims;
}
if (process.env.NODE_ENV !== "production") {
  var ReactIs = requireReactIs(), throwOnDirectAccess = !0;
  propTypes.exports = requireFactoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
} else
  propTypes.exports = requireFactoryWithThrowingShims()();
var __spreadArray = globalThis && globalThis.__spreadArray || function(be, ge, le) {
  if (le || arguments.length === 2)
    for (var ce = 0, re = ge.length, ae; ce < re; ce++)
      (ae || !(ce in ge)) && (ae || (ae = Array.prototype.slice.call(ge, 0, ce)), ae[ce] = ge[ce]);
  return be.concat(ae || Array.prototype.slice.call(ge));
}, clipboardEvents = ["onCopy", "onCut", "onPaste"], compositionEvents = [
  "onCompositionEnd",
  "onCompositionStart",
  "onCompositionUpdate"
], keyboardEvents = ["onKeyDown", "onKeyPress", "onKeyUp"], focusEvents = ["onFocus", "onBlur"], formEvents = ["onChange", "onInput", "onInvalid", "onReset", "onSubmit"], genericEvents = ["onError", "onLoad"], mouseEvents = [
  "onClick",
  "onContextMenu",
  "onDoubleClick",
  "onDrag",
  "onDragEnd",
  "onDragEnter",
  "onDragExit",
  "onDragLeave",
  "onDragOver",
  "onDragStart",
  "onDrop",
  "onMouseDown",
  "onMouseEnter",
  "onMouseLeave",
  "onMouseMove",
  "onMouseOut",
  "onMouseOver",
  "onMouseUp"
], pointerEvents = [
  "onPointerDown",
  "onPointerMove",
  "onPointerUp",
  "onPointerCancel",
  "onGotPointerCapture",
  "onLostPointerCapture",
  "onPointerEnter",
  "onPointerLeave",
  "onPointerOver",
  "onPointerOut"
], selectionEvents = ["onSelect"], touchEvents = ["onTouchCancel", "onTouchEnd", "onTouchMove", "onTouchStart"], uiEvents = ["onScroll"], wheelEvents = ["onWheel"], mediaEvents = [
  "onAbort",
  "onCanPlay",
  "onCanPlayThrough",
  "onDurationChange",
  "onEmptied",
  "onEncrypted",
  "onEnded",
  "onError",
  "onLoadedData",
  "onLoadedMetadata",
  "onLoadStart",
  "onPause",
  "onPlay",
  "onPlaying",
  "onProgress",
  "onRateChange",
  "onSeeked",
  "onSeeking",
  "onStalled",
  "onSuspend",
  "onTimeUpdate",
  "onVolumeChange",
  "onWaiting"
], imageEvents = ["onLoad", "onError"], animationEvents = [
  "onAnimationStart",
  "onAnimationEnd",
  "onAnimationIteration"
], transitionEvents = ["onTransitionEnd"], otherEvents = ["onToggle"], allEvents = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], clipboardEvents, !0), compositionEvents, !0), keyboardEvents, !0), focusEvents, !0), formEvents, !0), genericEvents, !0), mouseEvents, !0), pointerEvents, !0), selectionEvents, !0), touchEvents, !0), uiEvents, !0), wheelEvents, !0), mediaEvents, !0), imageEvents, !0), animationEvents, !0), transitionEvents, !0), otherEvents, !0);
function makeEventProps(be, ge) {
  var le = {};
  return allEvents.forEach(function(ce) {
    var re = be[ce];
    if (re) {
      if (!ge) {
        le[ce] = re;
        return;
      }
      le[ce] = function(ae) {
        return re(ae, ge(ce));
      };
    }
  }), le;
}
function makeCancellablePromise(be) {
  var ge = !1, le = new Promise(function(ce, re) {
    be.then(function(ae) {
      return !ge && ce(ae);
    }).catch(function(ae) {
      return !ge && re(ae);
    });
  });
  return {
    promise: le,
    cancel: function() {
      ge = !0;
    }
  };
}
function r(be) {
  var ge, le, ce = "";
  if (typeof be == "string" || typeof be == "number")
    ce += be;
  else if (typeof be == "object")
    if (Array.isArray(be))
      for (ge = 0; ge < be.length; ge++)
        be[ge] && (le = r(be[ge])) && (ce && (ce += " "), ce += le);
    else
      for (ge in be)
        be[ge] && (ce && (ce += " "), ce += ge);
  return ce;
}
function clsx() {
  for (var be, ge, le = 0, ce = ""; le < arguments.length; )
    (be = arguments[le++]) && (ge = r(be)) && (ce && (ce += " "), ce += ge);
  return ce;
}
var isProduction$1 = process.env.NODE_ENV === "production", prefix = "Invariant failed";
function invariant(be, ge) {
  if (!be) {
    if (isProduction$1)
      throw new Error(prefix);
    var le = typeof ge == "function" ? ge() : ge, ce = le ? "".concat(prefix, ": ").concat(le) : prefix;
    throw new Error(ce);
  }
}
var isProduction = process.env.NODE_ENV === "production";
function warning(be, ge) {
  if (!isProduction) {
    if (be)
      return;
    var le = "Warning: " + ge;
    typeof console < "u" && console.warn(le);
    try {
      throw Error(le);
    } catch {
    }
  }
}
const DocumentContext = /* @__PURE__ */ createContext(null);
function Message(be) {
  var ge = be.children, le = be.type;
  return /* @__PURE__ */ React.createElement("div", {
    className: "react-pdf__message react-pdf__message--".concat(le)
  }, ge);
}
Message.propTypes = {
  children: propTypesExports.node,
  type: propTypesExports.oneOf(["error", "loading", "no-data"]).isRequired
};
var DEFAULT_LINK_REL = "noopener noreferrer nofollow", LinkService = /* @__PURE__ */ function() {
  function be() {
    _classCallCheck(this, be), this.externalLinkTarget = null, this.externalLinkRel = null;
  }
  return _createClass(be, [{
    key: "setDocument",
    value: function(le) {
      this.pdfDocument = le;
    }
  }, {
    key: "setViewer",
    value: function(le) {
      this.pdfViewer = le;
    }
  }, {
    key: "setExternalLinkRel",
    value: function(le) {
      this.externalLinkRel = le;
    }
  }, {
    key: "setExternalLinkTarget",
    value: function(le) {
      this.externalLinkTarget = le;
    }
  }, {
    key: "setHistory",
    value: function() {
    }
  }, {
    key: "pagesCount",
    get: function() {
      return this.pdfDocument ? this.pdfDocument.numPages : 0;
    }
  }, {
    key: "page",
    get: function() {
      return this.pdfViewer.currentPageNumber;
    },
    set: function(le) {
      this.pdfViewer.currentPageNumber = le;
    }
  }, {
    key: "rotation",
    get: function() {
      return 0;
    },
    set: function(le) {
    }
  }, {
    key: "goToDestination",
    value: function(le) {
      var ce = this;
      new Promise(function(re) {
        typeof le == "string" ? ce.pdfDocument.getDestination(le).then(re) : Array.isArray(le) ? re(le) : le.then(re);
      }).then(function(re) {
        invariant(Array.isArray(re), '"'.concat(re, '" is not a valid destination array.'));
        var ae = re[0];
        new Promise(function(Z) {
          ae instanceof Object ? ce.pdfDocument.getPageIndex(ae).then(function(o) {
            Z(o);
          }).catch(function() {
            invariant(!1, '"'.concat(ae, '" is not a valid page reference.'));
          }) : typeof ae == "number" ? Z(ae) : invariant(!1, '"'.concat(ae, '" is not a valid destination reference.'));
        }).then(function(Z) {
          var o = Z + 1;
          invariant(o >= 1 && o <= ce.pagesCount, '"'.concat(o, '" is not a valid page number.')), ce.pdfViewer.scrollPageIntoView({
            dest: le,
            pageIndex: Z,
            pageNumber: o
          });
        });
      });
    }
  }, {
    key: "navigateTo",
    value: function(le) {
      this.goToDestination(le);
    }
  }, {
    key: "goToPage",
    value: function() {
    }
  }, {
    key: "addLinkAttributes",
    value: function(le, ce, re) {
      le.href = ce, le.rel = this.externalLinkRel || DEFAULT_LINK_REL, le.target = re ? "_blank" : this.externalLinkTarget || "";
    }
  }, {
    key: "getDestinationHash",
    value: function() {
      return "#";
    }
  }, {
    key: "getAnchorUrl",
    value: function() {
      return "#";
    }
  }, {
    key: "setHash",
    value: function() {
    }
  }, {
    key: "executeNamedAction",
    value: function() {
    }
  }, {
    key: "cachePageRef",
    value: function() {
    }
  }, {
    key: "isPageVisible",
    value: function() {
      return !0;
    }
  }, {
    key: "isPageCached",
    value: function() {
      return !0;
    }
  }]), be;
}(), PasswordResponses = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};
function _arrayWithHoles(be) {
  if (Array.isArray(be))
    return be;
}
function _iterableToArrayLimit(be, ge) {
  var le = be == null ? null : typeof Symbol < "u" && be[Symbol.iterator] || be["@@iterator"];
  if (le != null) {
    var ce, re, ae, Z, o = [], C = !0, t = !1;
    try {
      if (ae = (le = le.call(be)).next, ge === 0) {
        if (Object(le) !== le)
          return;
        C = !1;
      } else
        for (; !(C = (ce = ae.call(le)).done) && (o.push(ce.value), o.length !== ge); C = !0)
          ;
    } catch (a) {
      t = !0, re = a;
    } finally {
      try {
        if (!C && le.return != null && (Z = le.return(), Object(Z) !== Z))
          return;
      } finally {
        if (t)
          throw re;
      }
    }
    return o;
  }
}
function _arrayLikeToArray(be, ge) {
  (ge == null || ge > be.length) && (ge = be.length);
  for (var le = 0, ce = new Array(ge); le < ge; le++)
    ce[le] = be[le];
  return ce;
}
function _unsupportedIterableToArray(be, ge) {
  if (be) {
    if (typeof be == "string")
      return _arrayLikeToArray(be, ge);
    var le = Object.prototype.toString.call(be).slice(8, -1);
    if (le === "Object" && be.constructor && (le = be.constructor.name), le === "Map" || le === "Set")
      return Array.from(be);
    if (le === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(le))
      return _arrayLikeToArray(be, ge);
  }
}
function _nonIterableRest() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _slicedToArray(be, ge) {
  return _arrayWithHoles(be) || _iterableToArrayLimit(be, ge) || _unsupportedIterableToArray(be, ge) || _nonIterableRest();
}
var isBrowser = typeof document < "u", isLocalFileSystem = isBrowser && window.location.protocol === "file:";
function isDefined(be) {
  return typeof be < "u";
}
function isProvided(be) {
  return isDefined(be) && be !== null;
}
function isString(be) {
  return typeof be == "string";
}
function isArrayBuffer(be) {
  return be instanceof ArrayBuffer;
}
function isBlob(be) {
  return invariant(isBrowser, "isBlob can only be used in a browser environment"), be instanceof Blob;
}
function isFile$1(be) {
  return invariant(isBrowser, "isFile can only be used in a browser environment"), be instanceof File;
}
function isDataURI(be) {
  return isString(be) && /^data:/.test(be);
}
function dataURItoByteString(be) {
  invariant(isDataURI(be), "Invalid data URI.");
  var ge = be.split(","), le = _slicedToArray(ge, 2), ce = le[0], re = le[1], ae = ce.split(";");
  return ae.indexOf("base64") !== -1 ? atob(re) : unescape(re);
}
function getDevicePixelRatio() {
  return isBrowser && window.devicePixelRatio || 1;
}
var allowFileAccessFromFilesTip = "On Chromium based browsers, you can use --allow-file-access-from-files flag for debugging purposes.";
function displayCORSWarning() {
  warning(!isLocalFileSystem, "Loading PDF as base64 strings/URLs may not work on protocols other than HTTP/HTTPS. ".concat(allowFileAccessFromFilesTip));
}
function displayWorkerWarning() {
  warning(!isLocalFileSystem, "Loading PDF.js worker may not work on protocols other than HTTP/HTTPS. ".concat(allowFileAccessFromFilesTip));
}
function cancelRunningTask(be) {
  be && be.cancel && be.cancel();
}
function makePageCallback(be, ge) {
  return Object.defineProperty(be, "width", {
    get: function() {
      return this.view[2] * ge;
    },
    configurable: !0
  }), Object.defineProperty(be, "height", {
    get: function() {
      return this.view[3] * ge;
    },
    configurable: !0
  }), Object.defineProperty(be, "originalWidth", {
    get: function() {
      return this.view[2];
    },
    configurable: !0
  }), Object.defineProperty(be, "originalHeight", {
    get: function() {
      return this.view[3];
    },
    configurable: !0
  }), be;
}
function isCancelException(be) {
  return be.name === "RenderingCancelledException";
}
function loadFromFile(be) {
  return new Promise(function(ge, le) {
    var ce = new FileReader();
    return ce.onload = function() {
      return ge(new Uint8Array(ce.result));
    }, ce.onerror = function(re) {
      switch (re.target.error.code) {
        case re.target.error.NOT_FOUND_ERR:
          return le(new Error("Error while reading a file: File not found."));
        case re.target.error.NOT_READABLE_ERR:
          return le(new Error("Error while reading a file: File not readable."));
        case re.target.error.SECURITY_ERR:
          return le(new Error("Error while reading a file: Security error."));
        case re.target.error.ABORT_ERR:
          return le(new Error("Error while reading a file: Aborted."));
        default:
          return le(new Error("Error while reading a file."));
      }
    }, ce.readAsArrayBuffer(be), null;
  });
}
function _arrayWithoutHoles(be) {
  if (Array.isArray(be))
    return _arrayLikeToArray(be);
}
function _iterableToArray(be) {
  if (typeof Symbol < "u" && be[Symbol.iterator] != null || be["@@iterator"] != null)
    return Array.from(be);
}
function _nonIterableSpread() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _toConsumableArray(be) {
  return _arrayWithoutHoles(be) || _iterableToArray(be) || _unsupportedIterableToArray(be) || _nonIterableSpread();
}
var eventProps = function() {
  var be = {};
  return [].concat(_toConsumableArray(mouseEvents), _toConsumableArray(touchEvents), _toConsumableArray(keyboardEvents)).forEach(function(ge) {
    be[ge] = propTypesExports.func;
  }), be;
}(), fileTypes = [propTypesExports.string, propTypesExports.instanceOf(ArrayBuffer), propTypesExports.shape({
  data: propTypesExports.oneOfType([propTypesExports.object, propTypesExports.string]),
  httpHeaders: propTypesExports.object,
  range: propTypesExports.object,
  url: propTypesExports.string,
  withCredentials: propTypesExports.bool
})];
typeof File < "u" && fileTypes.push(propTypesExports.instanceOf(File));
typeof Blob < "u" && fileTypes.push(propTypesExports.instanceOf(Blob));
var isClassName = propTypesExports.oneOfType([propTypesExports.string, propTypesExports.arrayOf(propTypesExports.string)]), isFile = propTypesExports.oneOfType(fileTypes), isLinkService = propTypesExports.instanceOf(LinkService);
propTypesExports.oneOf(["_self", "_blank", "_parent", "_top"]);
var isPage = propTypesExports.shape({
  commonObjs: propTypesExports.shape({}).isRequired,
  getAnnotations: propTypesExports.func.isRequired,
  getTextContent: propTypesExports.func.isRequired,
  getViewport: propTypesExports.func.isRequired,
  render: propTypesExports.func.isRequired
}), isPageIndex = function be(ge, le, ce) {
  var re = ge[le], ae = ge.pageNumber, Z = ge.pdf;
  if (!isDefined(Z))
    return null;
  if (isDefined(re)) {
    if (typeof re != "number")
      return new Error("`".concat(le, "` of type `").concat(_typeof(re), "` supplied to `").concat(ce, "`, expected `number`."));
    if (re < 0)
      return new Error("Expected `".concat(le, "` to be greater or equal to 0."));
    var o = Z.numPages;
    if (re + 1 > o)
      return new Error("Expected `".concat(le, "` to be less or equal to ").concat(o - 1, "."));
  } else if (!isDefined(ae))
    return new Error("`".concat(le, "` not supplied. Either pageIndex or pageNumber must be supplied to `").concat(ce, "`."));
  return null;
}, isPageNumber = function be(ge, le, ce) {
  var re = ge[le], ae = ge.pageIndex, Z = ge.pdf;
  if (!isDefined(Z))
    return null;
  if (isDefined(re)) {
    if (typeof re != "number")
      return new Error("`".concat(le, "` of type `").concat(_typeof(re), "` supplied to `").concat(ce, "`, expected `number`."));
    if (re < 1)
      return new Error("Expected `".concat(le, "` to be greater or equal to 1."));
    var o = Z.numPages;
    if (re > o)
      return new Error("Expected `".concat(le, "` to be less or equal to ").concat(o, "."));
  } else if (!isDefined(ae))
    return new Error("`".concat(le, "` not supplied. Either pageIndex or pageNumber must be supplied to `").concat(ce, "`."));
  return null;
}, isPdf = propTypesExports.oneOfType([propTypesExports.shape({
  getDestination: propTypesExports.func.isRequired,
  getOutline: propTypesExports.func.isRequired,
  getPage: propTypesExports.func.isRequired,
  numPages: propTypesExports.number.isRequired
}), propTypesExports.bool]), isRef = propTypesExports.oneOfType([propTypesExports.func, propTypesExports.shape({
  current: propTypesExports.any
})]), isRenderMode = propTypesExports.oneOf(["canvas", "none", "svg"]), isRotate = propTypesExports.oneOf([0, 90, 180, 270]), _excluded = ["url"];
function ownKeys$3(be, ge) {
  var le = Object.keys(be);
  if (Object.getOwnPropertySymbols) {
    var ce = Object.getOwnPropertySymbols(be);
    ge && (ce = ce.filter(function(re) {
      return Object.getOwnPropertyDescriptor(be, re).enumerable;
    })), le.push.apply(le, ce);
  }
  return le;
}
function _objectSpread$3(be) {
  for (var ge = 1; ge < arguments.length; ge++) {
    var le = arguments[ge] != null ? arguments[ge] : {};
    ge % 2 ? ownKeys$3(Object(le), !0).forEach(function(ce) {
      _defineProperty(be, ce, le[ce]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(be, Object.getOwnPropertyDescriptors(le)) : ownKeys$3(Object(le)).forEach(function(ce) {
      Object.defineProperty(be, ce, Object.getOwnPropertyDescriptor(le, ce));
    });
  }
  return be;
}
function _createSuper$5(be) {
  var ge = _isNativeReflectConstruct$5();
  return function() {
    var ce = _getPrototypeOf(be), re;
    if (ge) {
      var ae = _getPrototypeOf(this).constructor;
      re = Reflect.construct(ce, arguments, ae);
    } else
      re = ce.apply(this, arguments);
    return _possibleConstructorReturn(this, re);
  };
}
function _isNativeReflectConstruct$5() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
var PDFDataRangeTransport = pdfExports.PDFDataRangeTransport, Document = /* @__PURE__ */ function(be) {
  _inherits(le, be);
  var ge = _createSuper$5(le);
  function le() {
    var ce;
    _classCallCheck(this, le);
    for (var re = arguments.length, ae = new Array(re), Z = 0; Z < re; Z++)
      ae[Z] = arguments[Z];
    return ce = ge.call.apply(ge, [this].concat(ae)), _defineProperty(_assertThisInitialized(ce), "state", {
      pdf: null
    }), _defineProperty(_assertThisInitialized(ce), "viewer", {
      scrollPageIntoView: function(C) {
        var t = C.dest, a = C.pageIndex, v = C.pageNumber, h = ce.props.onItemClick;
        if (h) {
          h({
            dest: t,
            pageIndex: a,
            pageNumber: v
          });
          return;
        }
        var e = ce.pages[a];
        if (e) {
          e.scrollIntoView();
          return;
        }
        warning(!1, "An internal link leading to page ".concat(v, " was clicked, but neither <Document> was provided with onItemClick nor it was able to find the page within itself. Either provide onItemClick to <Document> and handle navigating by yourself or ensure that all pages are rendered within <Document>."));
      }
    }), _defineProperty(_assertThisInitialized(ce), "linkService", new LinkService()), _defineProperty(_assertThisInitialized(ce), "loadDocument", function() {
      cancelRunningTask(ce.runningTask), ce.loadingTask && ce.loadingTask.destroy();
      var o = makeCancellablePromise(ce.findDocumentSource());
      ce.runningTask = o, o.promise.then(function(C) {
        if (ce.onSourceSuccess(), !!C) {
          ce.setState(function(y) {
            return y.pdf ? {
              pdf: null
            } : null;
          });
          var t = ce.props, a = t.options, v = t.onLoadProgress, h = t.onPassword, e = pdfExports.getDocument(_objectSpread$3(_objectSpread$3({}, C), a));
          e.onPassword = h, v && (e.onProgress = v), ce.loadingTask = e, e.promise.then(function(y) {
            ce.setState(function(c) {
              return c.pdf && c.pdf.fingerprint === y.fingerprint ? null : {
                pdf: y
              };
            }, ce.onLoadSuccess);
          }).catch(function(y) {
            ce.onLoadError(y);
          });
        }
      }).catch(function(C) {
        ce.onSourceError(C);
      });
    }), _defineProperty(_assertThisInitialized(ce), "setupLinkService", function() {
      var o = ce.props, C = o.externalLinkRel, t = o.externalLinkTarget;
      ce.linkService.setViewer(ce.viewer), ce.linkService.setExternalLinkRel(C), ce.linkService.setExternalLinkTarget(t);
    }), _defineProperty(_assertThisInitialized(ce), "onSourceSuccess", function() {
      var o = ce.props.onSourceSuccess;
      o && o();
    }), _defineProperty(_assertThisInitialized(ce), "onSourceError", function(o) {
      warning(o);
      var C = ce.props.onSourceError;
      C && C(o);
    }), _defineProperty(_assertThisInitialized(ce), "onLoadSuccess", function() {
      var o = ce.props.onLoadSuccess, C = ce.state.pdf;
      o && o(C), ce.pages = new Array(C.numPages), ce.linkService.setDocument(C);
    }), _defineProperty(_assertThisInitialized(ce), "onLoadError", function(o) {
      ce.setState({
        pdf: !1
      }), warning(o);
      var C = ce.props.onLoadError;
      C && C(o);
    }), _defineProperty(_assertThisInitialized(ce), "findDocumentSource", function() {
      return new Promise(function(o) {
        var C = ce.props.file;
        if (C || o(null), typeof C == "string") {
          if (isDataURI(C)) {
            var t = dataURItoByteString(C);
            o({
              data: t
            });
          }
          displayCORSWarning(), o({
            url: C
          });
        }
        if (C instanceof PDFDataRangeTransport && o({
          range: C
        }), isArrayBuffer(C) && o({
          data: C
        }), isBrowser && (isBlob(C) || isFile$1(C))) {
          loadFromFile(C).then(function(e) {
            o({
              data: e
            });
          });
          return;
        }
        if (invariant(_typeof(C) === "object", "Invalid parameter in file, need either Uint8Array, string or a parameter object"), invariant(C.url || C.data || C.range, "Invalid parameter object: need either .data, .range or .url"), typeof C.url == "string") {
          if (isDataURI(C.url)) {
            var a = C.url, v = _objectWithoutProperties(C, _excluded), h = dataURItoByteString(a);
            o(_objectSpread$3({
              data: h
            }, v));
          }
          displayCORSWarning();
        }
        o(C);
      });
    }), _defineProperty(_assertThisInitialized(ce), "registerPage", function(o, C) {
      ce.pages[o] = C;
    }), _defineProperty(_assertThisInitialized(ce), "unregisterPage", function(o) {
      delete ce.pages[o];
    }), ce;
  }
  return _createClass(le, [{
    key: "componentDidMount",
    value: function() {
      this.loadDocument(), this.setupLinkService();
    }
  }, {
    key: "componentDidUpdate",
    value: function(re) {
      var ae = this.props.file;
      ae !== re.file && this.loadDocument();
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      cancelRunningTask(this.runningTask), this.loadingTask && this.loadingTask.destroy();
    }
  }, {
    key: "childContext",
    get: function() {
      var re = this.linkService, ae = this.registerPage, Z = this.unregisterPage, o = this.props, C = o.imageResourcesPath, t = o.renderMode, a = o.rotate, v = this.state.pdf;
      return {
        imageResourcesPath: C,
        linkService: re,
        pdf: v,
        registerPage: ae,
        renderMode: t,
        rotate: a,
        unregisterPage: Z
      };
    }
  }, {
    key: "eventProps",
    get: function() {
      var re = this;
      return makeEventProps(this.props, function() {
        return re.state.pdf;
      });
    }
    /**
     * Called when a document source is resolved correctly
     */
  }, {
    key: "renderChildren",
    value: function() {
      var re = this.props.children;
      return /* @__PURE__ */ React.createElement(DocumentContext.Provider, {
        value: this.childContext
      }, re);
    }
  }, {
    key: "renderContent",
    value: function() {
      var re = this.props.file, ae = this.state.pdf;
      if (!re) {
        var Z = this.props.noData;
        return /* @__PURE__ */ React.createElement(Message, {
          type: "no-data"
        }, typeof Z == "function" ? Z() : Z);
      }
      if (ae === null) {
        var o = this.props.loading;
        return /* @__PURE__ */ React.createElement(Message, {
          type: "loading"
        }, typeof o == "function" ? o() : o);
      }
      if (ae === !1) {
        var C = this.props.error;
        return /* @__PURE__ */ React.createElement(Message, {
          type: "error"
        }, typeof C == "function" ? C() : C);
      }
      return this.renderChildren();
    }
  }, {
    key: "render",
    value: function() {
      var re = this.props, ae = re.className, Z = re.inputRef;
      return /* @__PURE__ */ React.createElement("div", _extends({
        className: clsx("react-pdf__Document", ae),
        ref: Z
      }, this.eventProps), this.renderContent());
    }
  }]), le;
}(PureComponent);
Document.defaultProps = {
  error: "Failed to load PDF file.",
  loading: "Loading PDF…",
  noData: "No PDF file specified.",
  onPassword: function be(ge, le) {
    switch (le) {
      case PasswordResponses.NEED_PASSWORD: {
        var ce = prompt("Enter the password to open this PDF file.");
        ge(ce);
        break;
      }
      case PasswordResponses.INCORRECT_PASSWORD: {
        var re = prompt("Invalid password. Please try again.");
        ge(re);
        break;
      }
    }
  }
};
var isFunctionOrNode$1 = propTypesExports.oneOfType([propTypesExports.func, propTypesExports.node]);
Document.propTypes = _objectSpread$3(_objectSpread$3({}, eventProps), {}, {
  children: propTypesExports.node,
  className: isClassName,
  error: isFunctionOrNode$1,
  externalLinkRel: propTypesExports.string,
  externalLinkTarget: propTypesExports.string,
  file: isFile,
  imageResourcesPath: propTypesExports.string,
  inputRef: isRef,
  loading: isFunctionOrNode$1,
  noData: isFunctionOrNode$1,
  onItemClick: propTypesExports.func,
  onLoadError: propTypesExports.func,
  onLoadProgress: propTypesExports.func,
  onLoadSuccess: propTypesExports.func,
  onPassword: propTypesExports.func,
  onSourceError: propTypesExports.func,
  onSourceSuccess: propTypesExports.func,
  rotate: propTypesExports.number
});
var isDestination = propTypesExports.oneOfType([propTypesExports.string, propTypesExports.arrayOf(propTypesExports.any)]);
propTypesExports.shape({
  dest: isDestination,
  items: propTypesExports.arrayOf(propTypesExports.shape({
    dest: isDestination,
    title: propTypesExports.string
  })),
  title: propTypesExports.string
}).isRequired, propTypesExports.func, isPdf.isRequired;
function ownKeys$2(be, ge) {
  var le = Object.keys(be);
  if (Object.getOwnPropertySymbols) {
    var ce = Object.getOwnPropertySymbols(be);
    ge && (ce = ce.filter(function(re) {
      return Object.getOwnPropertyDescriptor(be, re).enumerable;
    })), le.push.apply(le, ce);
  }
  return le;
}
function _objectSpread$2(be) {
  for (var ge = 1; ge < arguments.length; ge++) {
    var le = arguments[ge] != null ? arguments[ge] : {};
    ge % 2 ? ownKeys$2(Object(le), !0).forEach(function(ce) {
      _defineProperty(be, ce, le[ce]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(be, Object.getOwnPropertyDescriptors(le)) : ownKeys$2(Object(le)).forEach(function(ce) {
      Object.defineProperty(be, ce, Object.getOwnPropertyDescriptor(le, ce));
    });
  }
  return be;
}
_objectSpread$2({
  className: isClassName,
  inputRef: isRef,
  onItemClick: propTypesExports.func,
  onLoadError: propTypesExports.func,
  onLoadSuccess: propTypesExports.func,
  pdf: isPdf
}, eventProps);
function mergeRefs() {
  for (var be = [], ge = 0; ge < arguments.length; ge++)
    be[ge] = arguments[ge];
  var le = be.filter(Boolean);
  if (le.length <= 1) {
    var ce = le[0];
    return ce || null;
  }
  return function(ae) {
    le.forEach(function(Z) {
      typeof Z == "function" ? Z(ae) : Z && (Z.current = ae);
    });
  };
}
const PageContext = /* @__PURE__ */ createContext(null);
function _createSuper$4(be) {
  var ge = _isNativeReflectConstruct$4();
  return function() {
    var ce = _getPrototypeOf(be), re;
    if (ge) {
      var ae = _getPrototypeOf(this).constructor;
      re = Reflect.construct(ce, arguments, ae);
    } else
      re = ce.apply(this, arguments);
    return _possibleConstructorReturn(this, re);
  };
}
function _isNativeReflectConstruct$4() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
var ANNOTATION_MODE = pdfExports.AnnotationMode, PageCanvasInternal = /* @__PURE__ */ function(be) {
  _inherits(le, be);
  var ge = _createSuper$4(le);
  function le() {
    var ce;
    _classCallCheck(this, le);
    for (var re = arguments.length, ae = new Array(re), Z = 0; Z < re; Z++)
      ae[Z] = arguments[Z];
    return ce = ge.call.apply(ge, [this].concat(ae)), _defineProperty(_assertThisInitialized(ce), "canvasElement", /* @__PURE__ */ createRef()), _defineProperty(_assertThisInitialized(ce), "onRenderSuccess", function() {
      ce.renderer = null;
      var o = ce.props, C = o.onRenderSuccess, t = o.page, a = o.scale;
      C && C(makePageCallback(t, a));
    }), _defineProperty(_assertThisInitialized(ce), "onRenderError", function(o) {
      if (!isCancelException(o)) {
        warning(o);
        var C = ce.props.onRenderError;
        C && C(o);
      }
    }), _defineProperty(_assertThisInitialized(ce), "drawPageOnCanvas", function() {
      var o = ce.canvasElement.current;
      if (!o)
        return null;
      var C = _assertThisInitialized(ce), t = C.renderViewport, a = C.viewport, v = ce.props, h = v.canvasBackground, e = v.page, y = v.renderForms;
      o.width = t.width, o.height = t.height, o.style.width = "".concat(Math.floor(a.width), "px"), o.style.height = "".concat(Math.floor(a.height), "px");
      var c = {
        annotationMode: y ? ANNOTATION_MODE.ENABLE_FORMS : ANNOTATION_MODE.ENABLE,
        get canvasContext() {
          return o.getContext("2d", {
            alpha: !1
          });
        },
        viewport: t
      };
      h && (c.background = h), ce.cancelRenderingTask();
      var d = e.render(c);
      return ce.renderer = d, d.promise.then(ce.onRenderSuccess).catch(ce.onRenderError);
    }), ce;
  }
  return _createClass(le, [{
    key: "componentDidMount",
    value: function() {
      this.drawPageOnCanvas();
    }
  }, {
    key: "componentDidUpdate",
    value: function(re) {
      var ae = this.props, Z = ae.canvasBackground, o = ae.devicePixelRatio, C = ae.page, t = ae.renderForms;
      (Z !== re.canvasBackground || o !== re.devicePixelRatio || t !== re.renderForms) && (C.cleanup(), this.drawPageOnCanvas());
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      this.cancelRenderingTask();
      var re = this.canvasElement.current;
      re && (re.width = 0, re.height = 0);
    }
  }, {
    key: "cancelRenderingTask",
    value: function() {
      this.renderer && (this.renderer.cancel(), this.renderer = null);
    }
    /**
     * Called when a page is rendered successfully.
     */
  }, {
    key: "devicePixelRatio",
    get: function() {
      var re = this.props.devicePixelRatio;
      return re || getDevicePixelRatio();
    }
  }, {
    key: "renderViewport",
    get: function() {
      var re = this.devicePixelRatio, ae = this.props, Z = ae.page, o = ae.rotate, C = ae.scale;
      return Z.getViewport({
        scale: C * re,
        rotation: o
      });
    }
  }, {
    key: "viewport",
    get: function() {
      var re = this.props, ae = re.page, Z = re.rotate, o = re.scale;
      return ae.getViewport({
        scale: o,
        rotation: Z
      });
    }
  }, {
    key: "render",
    value: function() {
      var re = this.props.canvasRef;
      return /* @__PURE__ */ React.createElement("canvas", {
        className: "react-pdf__Page__canvas",
        dir: "ltr",
        ref: mergeRefs(re, this.canvasElement),
        style: {
          display: "block",
          userSelect: "none"
        }
      });
    }
  }]), le;
}(PureComponent);
PageCanvasInternal.propTypes = {
  canvasBackground: propTypesExports.string,
  canvasRef: isRef,
  devicePixelRatio: propTypesExports.number,
  onRenderError: propTypesExports.func,
  onRenderSuccess: propTypesExports.func,
  page: isPage.isRequired,
  renderForms: propTypesExports.bool,
  rotate: isRotate,
  scale: propTypesExports.number.isRequired
};
function PageCanvas(be) {
  return /* @__PURE__ */ React.createElement(PageContext.Consumer, null, function(ge) {
    return /* @__PURE__ */ React.createElement(PageCanvasInternal, _extends({}, ge, be));
  });
}
function _createSuper$3(be) {
  var ge = _isNativeReflectConstruct$3();
  return function() {
    var ce = _getPrototypeOf(be), re;
    if (ge) {
      var ae = _getPrototypeOf(this).constructor;
      re = Reflect.construct(ce, arguments, ae);
    } else
      re = ce.apply(this, arguments);
    return _possibleConstructorReturn(this, re);
  };
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
var PageSVGInternal = /* @__PURE__ */ function(be) {
  _inherits(le, be);
  var ge = _createSuper$3(le);
  function le() {
    var ce;
    _classCallCheck(this, le);
    for (var re = arguments.length, ae = new Array(re), Z = 0; Z < re; Z++)
      ae[Z] = arguments[Z];
    return ce = ge.call.apply(ge, [this].concat(ae)), _defineProperty(_assertThisInitialized(ce), "state", {
      svg: null
    }), _defineProperty(_assertThisInitialized(ce), "onRenderSuccess", function() {
      ce.renderer = null;
      var o = ce.props, C = o.onRenderSuccess, t = o.page, a = o.scale;
      C && C(makePageCallback(t, a));
    }), _defineProperty(_assertThisInitialized(ce), "onRenderError", function(o) {
      if (!isCancelException(o)) {
        warning(o);
        var C = ce.props.onRenderError;
        C && C(o);
      }
    }), _defineProperty(_assertThisInitialized(ce), "renderSVG", function() {
      var o = ce.props.page;
      return ce.renderer = o.getOperatorList(), ce.renderer.then(function(C) {
        var t = new pdfExports.SVGGraphics(o.commonObjs, o.objs);
        ce.renderer = t.getSVG(C, ce.viewport).then(function(a) {
          ce.setState({
            svg: a
          }, ce.onRenderSuccess);
        }).catch(ce.onRenderError);
      }).catch(ce.onRenderError);
    }), _defineProperty(_assertThisInitialized(ce), "drawPageOnContainer", function(o) {
      var C = ce.state.svg;
      if (!(!o || !C)) {
        o.firstElementChild || o.appendChild(C);
        var t = ce.viewport, a = t.width, v = t.height;
        C.setAttribute("width", a), C.setAttribute("height", v);
      }
    }), ce;
  }
  return _createClass(le, [{
    key: "componentDidMount",
    value: function() {
      this.renderSVG();
    }
    /**
     * Called when a page is rendered successfully.
     */
  }, {
    key: "viewport",
    get: function() {
      var re = this.props, ae = re.page, Z = re.rotate, o = re.scale;
      return ae.getViewport({
        scale: o,
        rotation: Z
      });
    }
  }, {
    key: "render",
    value: function() {
      var re = this, ae = this.viewport, Z = ae.width, o = ae.height;
      return /* @__PURE__ */ React.createElement("div", {
        className: "react-pdf__Page__svg",
        ref: function(t) {
          return re.drawPageOnContainer(t);
        },
        style: {
          display: "block",
          backgroundColor: "white",
          overflow: "hidden",
          width: Z,
          height: o,
          userSelect: "none"
        }
      });
    }
  }]), le;
}(PureComponent);
PageSVGInternal.propTypes = {
  onRenderError: propTypesExports.func,
  onRenderSuccess: propTypesExports.func,
  page: isPage.isRequired,
  rotate: isRotate,
  scale: propTypesExports.number.isRequired
};
function PageSVG(be) {
  return /* @__PURE__ */ React.createElement(PageContext.Consumer, null, function(ge) {
    return /* @__PURE__ */ React.createElement(PageSVGInternal, _extends({}, ge, be));
  });
}
function ownKeys$1(be, ge) {
  var le = Object.keys(be);
  if (Object.getOwnPropertySymbols) {
    var ce = Object.getOwnPropertySymbols(be);
    ge && (ce = ce.filter(function(re) {
      return Object.getOwnPropertyDescriptor(be, re).enumerable;
    })), le.push.apply(le, ce);
  }
  return le;
}
function _objectSpread$1(be) {
  for (var ge = 1; ge < arguments.length; ge++) {
    var le = arguments[ge] != null ? arguments[ge] : {};
    ge % 2 ? ownKeys$1(Object(le), !0).forEach(function(ce) {
      _defineProperty(be, ce, le[ce]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(be, Object.getOwnPropertyDescriptors(le)) : ownKeys$1(Object(le)).forEach(function(ce) {
      Object.defineProperty(be, ce, Object.getOwnPropertyDescriptor(le, ce));
    });
  }
  return be;
}
function _createSuper$2(be) {
  var ge = _isNativeReflectConstruct$2();
  return function() {
    var ce = _getPrototypeOf(be), re;
    if (ge) {
      var ae = _getPrototypeOf(this).constructor;
      re = Reflect.construct(ce, arguments, ae);
    } else
      re = ce.apply(this, arguments);
    return _possibleConstructorReturn(this, re);
  };
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
var TextLayerInternal = /* @__PURE__ */ function(be) {
  _inherits(le, be);
  var ge = _createSuper$2(le);
  function le() {
    var ce;
    _classCallCheck(this, le);
    for (var re = arguments.length, ae = new Array(re), Z = 0; Z < re; Z++)
      ae[Z] = arguments[Z];
    return ce = ge.call.apply(ge, [this].concat(ae)), _defineProperty(_assertThisInitialized(ce), "state", {
      textContent: null
    }), _defineProperty(_assertThisInitialized(ce), "layerElement", /* @__PURE__ */ createRef()), _defineProperty(_assertThisInitialized(ce), "endElement", /* @__PURE__ */ createRef()), _defineProperty(_assertThisInitialized(ce), "loadTextContent", function() {
      var o = ce.props.page, C = makeCancellablePromise(o.getTextContent());
      ce.runningTask = C, C.promise.then(function(t) {
        ce.setState({
          textContent: t
        }, ce.onLoadSuccess);
      }).catch(function(t) {
        ce.onLoadError(t);
      });
    }), _defineProperty(_assertThisInitialized(ce), "onLoadSuccess", function() {
      var o = ce.props.onGetTextSuccess, C = ce.state.textContent;
      o && o(C);
    }), _defineProperty(_assertThisInitialized(ce), "onLoadError", function(o) {
      ce.setState({
        textItems: !1
      }), warning(o);
      var C = ce.props.onGetTextError;
      C && C(o);
    }), _defineProperty(_assertThisInitialized(ce), "onRenderSuccess", function() {
      var o = ce.props.onRenderTextLayerSuccess;
      o && o();
    }), _defineProperty(_assertThisInitialized(ce), "onRenderError", function(o) {
      warning(o);
      var C = ce.props.onRenderTextLayerError;
      C && C(o);
    }), _defineProperty(_assertThisInitialized(ce), "onMouseDown", function() {
      var o = ce.endElement.current;
      o && o.classList.add("active");
    }), _defineProperty(_assertThisInitialized(ce), "onMouseUp", function() {
      var o = ce.endElement.current;
      o && o.classList.remove("active");
    }), ce;
  }
  return _createClass(le, [{
    key: "componentDidMount",
    value: function() {
      var re = this.props.page;
      invariant(re, "Attempted to load page text content, but no page was specified."), warning(parseInt(window.getComputedStyle(document.body).getPropertyValue("--react-pdf-text-layer"), 10) === 1, "TextLayer styles not found. Read more: https://github.com/wojtekmaj/react-pdf#support-for-text-layer"), this.loadTextContent();
    }
  }, {
    key: "componentDidUpdate",
    value: function(re) {
      var ae = this.props.page;
      re.page && ae !== re.page && this.loadTextContent();
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      cancelRunningTask(this.runningTask);
    }
  }, {
    key: "viewport",
    get: function() {
      var re = this.props, ae = re.page, Z = re.rotate, o = re.scale;
      return ae.getViewport({
        scale: o,
        rotation: Z
      });
    }
  }, {
    key: "unrotatedViewport",
    get: function() {
      var re = this.props, ae = re.page, Z = re.scale;
      return ae.getViewport({
        scale: Z
      });
    }
    /**
     * It might happen that the page is rotated by default. In such cases, we shouldn't rotate
     * text content.
     */
  }, {
    key: "rotate",
    get: function() {
      var re = this.props, ae = re.page, Z = re.rotate;
      return Z - ae.rotate;
    }
  }, {
    key: "renderTextLayer",
    value: function() {
      var re = this, ae = this.state.textContent;
      if (!ae)
        return null;
      var Z = this.layerElement.current, o = this.viewport, C = this.props, t = C.customTextRenderer, a = C.pageIndex, v = C.pageNumber;
      cancelRunningTask(this.runningTask), Z.innerHTML = "";
      var h = {
        container: Z,
        textContent: ae,
        viewport: o
      }, e = pdfExports.renderTextLayer(h);
      this.runningTask = e, e.promise.then(function() {
        var y = document.createElement("div");
        if (y.className = "endOfContent", Z.append(y), re.endElement.current = y, t) {
          var c = 0;
          ae.items.forEach(function(d, p) {
            var m = re.layerElement.current.children[c], g = t(_objectSpread$1({
              pageIndex: a,
              pageNumber: v,
              itemIndex: p
            }, d));
            m.innerHTML = g, c += d.str && d.hasEOL ? 2 : 1;
          });
        }
        re.onRenderSuccess();
      }).catch(function(y) {
        re.onRenderError(y);
      });
    }
  }, {
    key: "render",
    value: function() {
      return (
        // eslint-disable-next-line jsx-a11y/no-static-element-interactions
        /* @__PURE__ */ React.createElement("div", {
          className: "react-pdf__Page__textContent textLayer",
          onMouseUp: this.onMouseUp,
          onMouseDown: this.onMouseDown,
          ref: this.layerElement
        }, this.renderTextLayer())
      );
    }
  }]), le;
}(PureComponent);
TextLayerInternal.propTypes = {
  customTextRenderer: propTypesExports.func,
  onGetTextError: propTypesExports.func,
  onGetTextSuccess: propTypesExports.func,
  onRenderTextLayerError: propTypesExports.func,
  onRenderTextLayerSuccess: propTypesExports.func,
  page: isPage.isRequired,
  pageIndex: propTypesExports.number.isRequired,
  pageNumber: propTypesExports.number.isRequired,
  rotate: isRotate,
  scale: propTypesExports.number
};
function TextLayer(be) {
  return /* @__PURE__ */ React.createElement(PageContext.Consumer, null, function(ge) {
    return /* @__PURE__ */ React.createElement(TextLayerInternal, _extends({}, ge, be));
  });
}
function _createSuper$1(be) {
  var ge = _isNativeReflectConstruct$1();
  return function() {
    var ce = _getPrototypeOf(be), re;
    if (ge) {
      var ae = _getPrototypeOf(this).constructor;
      re = Reflect.construct(ce, arguments, ae);
    } else
      re = ce.apply(this, arguments);
    return _possibleConstructorReturn(this, re);
  };
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
var AnnotationLayerInternal = /* @__PURE__ */ function(be) {
  _inherits(le, be);
  var ge = _createSuper$1(le);
  function le() {
    var ce;
    _classCallCheck(this, le);
    for (var re = arguments.length, ae = new Array(re), Z = 0; Z < re; Z++)
      ae[Z] = arguments[Z];
    return ce = ge.call.apply(ge, [this].concat(ae)), _defineProperty(_assertThisInitialized(ce), "state", {
      annotations: null
    }), _defineProperty(_assertThisInitialized(ce), "layerElement", /* @__PURE__ */ createRef()), _defineProperty(_assertThisInitialized(ce), "loadAnnotations", function() {
      var o = ce.props.page, C = makeCancellablePromise(o.getAnnotations());
      ce.runningTask = C, C.promise.then(function(t) {
        ce.setState({
          annotations: t
        }, ce.onLoadSuccess);
      }).catch(function(t) {
        ce.onLoadError(t);
      });
    }), _defineProperty(_assertThisInitialized(ce), "onLoadSuccess", function() {
      var o = ce.props.onGetAnnotationsSuccess, C = ce.state.annotations;
      o && o(C);
    }), _defineProperty(_assertThisInitialized(ce), "onLoadError", function(o) {
      ce.setState({
        annotations: !1
      }), warning(o);
      var C = ce.props.onGetAnnotationsError;
      C && C(o);
    }), _defineProperty(_assertThisInitialized(ce), "onRenderSuccess", function() {
      var o = ce.props.onRenderAnnotationLayerSuccess;
      o && o();
    }), _defineProperty(_assertThisInitialized(ce), "onRenderError", function(o) {
      warning(o);
      var C = ce.props.onRenderAnnotationLayerError;
      C && C(o);
    }), ce;
  }
  return _createClass(le, [{
    key: "componentDidMount",
    value: function() {
      var re = this.props.page;
      invariant(re, "Attempted to load page annotations, but no page was specified."), warning(parseInt(window.getComputedStyle(document.body).getPropertyValue("--react-pdf-annotation-layer"), 10) === 1, "AnnotationLayer styles not found. Read more: https://github.com/wojtekmaj/react-pdf#support-for-annotations"), this.loadAnnotations();
    }
  }, {
    key: "componentDidUpdate",
    value: function(re) {
      var ae = this.props, Z = ae.page, o = ae.renderForms;
      (re.page && Z !== re.page || o !== re.renderForms) && this.loadAnnotations();
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      cancelRunningTask(this.runningTask);
    }
  }, {
    key: "viewport",
    get: function() {
      var re = this.props, ae = re.page, Z = re.rotate, o = re.scale;
      return ae.getViewport({
        scale: o,
        rotation: Z
      });
    }
  }, {
    key: "renderAnnotationLayer",
    value: function() {
      var re = this.state.annotations;
      if (re) {
        var ae = this.props, Z = ae.imageResourcesPath, o = ae.linkService, C = ae.page, t = ae.renderForms, a = this.viewport.clone({
          dontFlip: !0
        }), v = {
          annotations: re,
          div: this.layerElement.current,
          imageResourcesPath: Z,
          linkService: o,
          page: C,
          renderForms: t,
          viewport: a
        };
        this.layerElement.current.innerHTML = "";
        try {
          pdfExports.AnnotationLayer.render(v), this.onRenderSuccess();
        } catch (h) {
          this.onRenderError(h);
        }
      }
    }
  }, {
    key: "render",
    value: function() {
      return /* @__PURE__ */ React.createElement("div", {
        className: "react-pdf__Page__annotations annotationLayer",
        ref: this.layerElement
      }, this.renderAnnotationLayer());
    }
  }]), le;
}(PureComponent);
AnnotationLayerInternal.propTypes = {
  imageResourcesPath: propTypesExports.string,
  linkService: isLinkService.isRequired,
  onGetAnnotationsError: propTypesExports.func,
  onGetAnnotationsSuccess: propTypesExports.func,
  onRenderAnnotationLayerError: propTypesExports.func,
  onRenderAnnotationLayerSuccess: propTypesExports.func,
  page: isPage,
  renderForms: propTypesExports.bool,
  rotate: isRotate,
  scale: propTypesExports.number
};
var AnnotationLayer = function be(ge) {
  return /* @__PURE__ */ React.createElement(DocumentContext.Consumer, null, function(le) {
    return /* @__PURE__ */ React.createElement(PageContext.Consumer, null, function(ce) {
      return /* @__PURE__ */ React.createElement(AnnotationLayerInternal, _extends({}, le, ce, ge));
    });
  });
};
function ownKeys(be, ge) {
  var le = Object.keys(be);
  if (Object.getOwnPropertySymbols) {
    var ce = Object.getOwnPropertySymbols(be);
    ge && (ce = ce.filter(function(re) {
      return Object.getOwnPropertyDescriptor(be, re).enumerable;
    })), le.push.apply(le, ce);
  }
  return le;
}
function _objectSpread(be) {
  for (var ge = 1; ge < arguments.length; ge++) {
    var le = arguments[ge] != null ? arguments[ge] : {};
    ge % 2 ? ownKeys(Object(le), !0).forEach(function(ce) {
      _defineProperty(be, ce, le[ce]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(be, Object.getOwnPropertyDescriptors(le)) : ownKeys(Object(le)).forEach(function(ce) {
      Object.defineProperty(be, ce, Object.getOwnPropertyDescriptor(le, ce));
    });
  }
  return be;
}
function _createSuper(be) {
  var ge = _isNativeReflectConstruct();
  return function() {
    var ce = _getPrototypeOf(be), re;
    if (ge) {
      var ae = _getPrototypeOf(this).constructor;
      re = Reflect.construct(ce, arguments, ae);
    } else
      re = ce.apply(this, arguments);
    return _possibleConstructorReturn(this, re);
  };
}
function _isNativeReflectConstruct() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
var defaultScale = 1, PageInternal = /* @__PURE__ */ function(be) {
  _inherits(le, be);
  var ge = _createSuper(le);
  function le() {
    var ce;
    _classCallCheck(this, le);
    for (var re = arguments.length, ae = new Array(re), Z = 0; Z < re; Z++)
      ae[Z] = arguments[Z];
    return ce = ge.call.apply(ge, [this].concat(ae)), _defineProperty(_assertThisInitialized(ce), "state", {
      page: null
    }), _defineProperty(_assertThisInitialized(ce), "pageElement", /* @__PURE__ */ createRef()), _defineProperty(_assertThisInitialized(ce), "onLoadSuccess", function() {
      var o = ce.props, C = o.onLoadSuccess, t = o.registerPage, a = ce.state.page;
      C && C(makePageCallback(a, ce.scale)), t && t(ce.pageIndex, ce.pageElement.current);
    }), _defineProperty(_assertThisInitialized(ce), "onLoadError", function(o) {
      ce.setState({
        page: !1
      }), warning(o);
      var C = ce.props.onLoadError;
      C && C(o);
    }), _defineProperty(_assertThisInitialized(ce), "loadPage", function() {
      var o = ce.props.pdf, C = ce.getPageNumber();
      if (C) {
        ce.setState(function(a) {
          return a.page ? {
            page: null
          } : null;
        });
        var t = makeCancellablePromise(o.getPage(C));
        ce.runningTask = t, t.promise.then(function(a) {
          ce.setState({
            page: a
          }, ce.onLoadSuccess);
        }).catch(function(a) {
          ce.onLoadError(a);
        });
      }
    }), ce;
  }
  return _createClass(le, [{
    key: "componentDidMount",
    value: function() {
      var re = this.props.pdf;
      invariant(re, "Attempted to load a page, but no document was specified."), this.loadPage();
    }
  }, {
    key: "componentDidUpdate",
    value: function(re) {
      var ae = this.props.pdf;
      if (re.pdf && ae !== re.pdf || this.getPageNumber() !== this.getPageNumber(re)) {
        var Z = this.props.unregisterPage;
        Z && Z(this.getPageIndex(re)), this.loadPage();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      var re = this.props.unregisterPage;
      re && re(this.pageIndex), cancelRunningTask(this.runningTask);
    }
  }, {
    key: "childContext",
    get: function() {
      var re = this.pageIndex, ae = this.pageNumber, Z = this.state.page;
      if (!Z)
        return {};
      var o = this.props, C = o.canvasBackground, t = o.customTextRenderer, a = o.devicePixelRatio, v = o.onGetAnnotationsError, h = o.onGetAnnotationsSuccess, e = o.onGetTextError, y = o.onGetTextSuccess, c = o.onRenderAnnotationLayerError, d = o.onRenderAnnotationLayerSuccess, p = o.onRenderError, m = o.onRenderSuccess, g = o.onRenderTextLayerError, n = o.onRenderTextLayerSuccess, i = o.renderForms, l = o.renderInteractiveForms;
      return {
        canvasBackground: C,
        customTextRenderer: t,
        devicePixelRatio: a,
        onGetAnnotationsError: v,
        onGetAnnotationsSuccess: h,
        onGetTextError: e,
        onGetTextSuccess: y,
        onRenderAnnotationLayerError: c,
        onRenderAnnotationLayerSuccess: d,
        onRenderError: p,
        onRenderSuccess: m,
        onRenderTextLayerError: g,
        onRenderTextLayerSuccess: n,
        page: Z,
        pageIndex: re,
        pageNumber: ae,
        renderForms: i ?? l,
        // For backward compatibility
        rotate: this.rotate,
        scale: this.scale
      };
    }
    /**
     * Called when a page is loaded successfully
     */
  }, {
    key: "getPageIndex",
    value: function() {
      var re = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.props;
      return isProvided(re.pageNumber) ? re.pageNumber - 1 : isProvided(re.pageIndex) ? re.pageIndex : null;
    }
  }, {
    key: "getPageNumber",
    value: function() {
      var re = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.props;
      return isProvided(re.pageNumber) ? re.pageNumber : isProvided(re.pageIndex) ? re.pageIndex + 1 : null;
    }
  }, {
    key: "pageIndex",
    get: function() {
      return this.getPageIndex();
    }
  }, {
    key: "pageNumber",
    get: function() {
      return this.getPageNumber();
    }
  }, {
    key: "rotate",
    get: function() {
      var re = this.props.rotate;
      if (isProvided(re))
        return re;
      var ae = this.state.page;
      return ae ? ae.rotate : null;
    }
  }, {
    key: "scale",
    get: function() {
      var re = this.state.page;
      if (!re)
        return null;
      var ae = this.props, Z = ae.scale, o = ae.width, C = ae.height, t = this.rotate, a = 1, v = Z === null ? defaultScale : Z;
      if (o || C) {
        var h = re.getViewport({
          scale: 1,
          rotation: t
        });
        a = o ? o / h.width : C / h.height;
      }
      return v * a;
    }
  }, {
    key: "eventProps",
    get: function() {
      var re = this;
      return makeEventProps(this.props, function() {
        var ae = re.state.page;
        return ae && makePageCallback(ae, re.scale);
      });
    }
  }, {
    key: "pageKey",
    get: function() {
      return "".concat(this.pageIndex, "@").concat(this.scale, "/").concat(this.rotate);
    }
  }, {
    key: "pageKeyNoScale",
    get: function() {
      return "".concat(this.pageIndex, "/").concat(this.rotate);
    }
  }, {
    key: "renderMainLayer",
    value: function() {
      var re = this.props, ae = re.canvasRef, Z = re.renderMode;
      switch (Z) {
        case "none":
          return null;
        case "svg":
          return /* @__PURE__ */ React.createElement(PageSVG, {
            key: "".concat(this.pageKeyNoScale, "_svg")
          });
        case "canvas":
        default:
          return /* @__PURE__ */ React.createElement(PageCanvas, {
            key: "".concat(this.pageKey, "_canvas"),
            canvasRef: ae
          });
      }
    }
  }, {
    key: "renderTextLayer",
    value: function() {
      var re = this.props.renderTextLayer;
      return re ? /* @__PURE__ */ React.createElement(TextLayer, {
        key: "".concat(this.pageKey, "_text")
      }) : null;
    }
  }, {
    key: "renderAnnotationLayer",
    value: function() {
      var re = this.props.renderAnnotationLayer;
      return re ? /* @__PURE__ */ React.createElement(AnnotationLayer, {
        key: "".concat(this.pageKey, "_annotations")
      }) : null;
    }
  }, {
    key: "renderChildren",
    value: function() {
      var re = this.props.children;
      return /* @__PURE__ */ React.createElement(PageContext.Provider, {
        value: this.childContext
      }, this.renderMainLayer(), this.renderTextLayer(), this.renderAnnotationLayer(), re);
    }
  }, {
    key: "renderContent",
    value: function() {
      var re = this.pageNumber, ae = this.props.pdf, Z = this.state.page;
      if (!re) {
        var o = this.props.noData;
        return /* @__PURE__ */ React.createElement(Message, {
          type: "no-data"
        }, typeof o == "function" ? o() : o);
      }
      if (ae === null || Z === null) {
        var C = this.props.loading;
        return /* @__PURE__ */ React.createElement(Message, {
          type: "loading"
        }, typeof C == "function" ? C() : C);
      }
      if (ae === !1 || Z === !1) {
        var t = this.props.error;
        return /* @__PURE__ */ React.createElement(Message, {
          type: "error"
        }, typeof t == "function" ? t() : t);
      }
      return this.renderChildren();
    }
  }, {
    key: "render",
    value: function() {
      var re = this.pageNumber, ae = this.props, Z = ae.className, o = ae.inputRef;
      return /* @__PURE__ */ React.createElement("div", _extends({
        className: clsx("react-pdf__Page", Z),
        "data-page-number": re,
        ref: mergeRefs(o, this.pageElement),
        style: {
          position: "relative",
          minWidth: "min-content",
          minHeight: "min-content"
        }
      }, this.eventProps), this.renderContent());
    }
  }]), le;
}(PureComponent);
PageInternal.defaultProps = {
  error: "Failed to load the page.",
  loading: "Loading page…",
  noData: "No page specified.",
  renderAnnotationLayer: !0,
  renderMode: "canvas",
  renderTextLayer: !0,
  scale: defaultScale
};
var isFunctionOrNode = propTypesExports.oneOfType([propTypesExports.func, propTypesExports.node]);
PageInternal.propTypes = _objectSpread(_objectSpread({}, eventProps), {}, {
  canvasBackground: propTypesExports.string,
  children: propTypesExports.node,
  className: isClassName,
  customTextRenderer: propTypesExports.func,
  devicePixelRatio: propTypesExports.number,
  error: isFunctionOrNode,
  height: propTypesExports.number,
  imageResourcesPath: propTypesExports.string,
  inputRef: isRef,
  loading: isFunctionOrNode,
  noData: isFunctionOrNode,
  onGetTextError: propTypesExports.func,
  onGetTextSuccess: propTypesExports.func,
  onLoadError: propTypesExports.func,
  onLoadSuccess: propTypesExports.func,
  onRenderError: propTypesExports.func,
  onRenderSuccess: propTypesExports.func,
  onRenderTextLayerError: propTypesExports.func,
  onRenderTextLayerSuccess: propTypesExports.func,
  pageIndex: isPageIndex,
  pageNumber: isPageNumber,
  pdf: isPdf,
  registerPage: propTypesExports.func,
  renderAnnotationLayer: propTypesExports.bool,
  renderForms: propTypesExports.bool,
  renderInteractiveForms: propTypesExports.bool,
  // For backward compatibility
  renderMode: isRenderMode,
  renderTextLayer: propTypesExports.bool,
  rotate: isRotate,
  scale: propTypesExports.number,
  unregisterPage: propTypesExports.func,
  width: propTypesExports.number
});
function Page(be, ge) {
  return /* @__PURE__ */ React.createElement(DocumentContext.Consumer, null, function(le) {
    return /* @__PURE__ */ React.createElement(PageInternal, _extends({
      ref: ge
    }, le, be));
  });
}
const Page$1 = /* @__PURE__ */ React.forwardRef(Page);
displayWorkerWarning();
pdfExports.GlobalWorkerOptions.workerSrc = "pdf.worker.js";
var pdf_worker_entry = {}, pdf_workerExports = {}, pdf_worker = {
  get exports() {
    return pdf_workerExports;
  },
  set exports(be) {
    pdf_workerExports = be;
  }
};
(function(be, ge) {
  (function(ce, re) {
    be.exports = re();
  })(globalThis, () => (
    /******/
    (() => {
      var le = [
        ,
        /* 1 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.WorkerTask = o.WorkerMessageHandler = void 0;
          var t = C(2), a = C(5), v = C(6), h = C(8), e = C(71), y = C(65), c = C(4), d = C(102), p = C(103);
          class m {
            constructor(l) {
              this.name = l, this.terminated = !1, this._capability = (0, t.createPromiseCapability)();
            }
            get finished() {
              return this._capability.promise;
            }
            finish() {
              this._capability.resolve();
            }
            terminate() {
              this.terminated = !0;
            }
            ensureNotTerminated() {
              if (this.terminated)
                throw new Error("Worker task was terminated");
            }
          }
          o.WorkerTask = m;
          class g {
            static setup(l, u) {
              let w = !1;
              l.on("test", function(b) {
                w || (w = !0, l.send("test", b instanceof Uint8Array));
              }), l.on("configure", function(b) {
                (0, t.setVerbosityLevel)(b.verbosity);
              }), l.on("GetDocRequest", function(b) {
                return g.createDocumentHandler(b, u);
              });
            }
            static createDocumentHandler(l, u) {
              let w, _ = !1, b = null;
              const A = [], Y = (0, t.getVerbosityLevel)(), j = l.apiVersion, X = "2.16.105";
              if (j !== X)
                throw new Error(`The API version "${j}" does not match the Worker version "${X}".`);
              const B = [];
              for (const M in [])
                B.push(M);
              if (B.length)
                throw new Error("The `Array.prototype` contains unexpected enumerable properties: " + B.join(", ") + "; thus breaking e.g. `for...in` iteration of `Array`s.");
              if (typeof ReadableStream > "u") {
                const M = "The browser/environment lacks native support for critical functionality used by the PDF.js library (e.g. `ReadableStream`); ";
                throw c.isNodeJS ? new Error(M + "please use a `legacy`-build instead.") : new Error(M + "please update to a supported browser.");
              }
              const R = l.docId, k = l.docBaseUrl, x = l.docId + "_worker";
              let f = new d.MessageHandler(x, R, u);
              function U() {
                if (_)
                  throw new Error("Worker was terminated");
              }
              function O(M) {
                A.push(M);
              }
              function S(M) {
                M.finish();
                const V = A.indexOf(M);
                A.splice(V, 1);
              }
              async function F(M) {
                await w.ensureDoc("checkHeader"), await w.ensureDoc("parseStartXRef"), await w.ensureDoc("parse", [M]), await w.ensureDoc("checkFirstPage", [M]), await w.ensureDoc("checkLastPage", [M]);
                const V = await w.ensureDoc("isPureXfa");
                if (V) {
                  const G = new m("loadXfaFonts");
                  O(G), await Promise.all([w.loadXfaFonts(f, G).catch((L) => {
                  }).then(() => S(G)), w.loadXfaImages()]);
                }
                const [J, W] = await Promise.all([w.ensureDoc("numPages"), w.ensureDoc("fingerprints")]), z = V ? await w.ensureDoc("htmlForXfa") : null;
                return {
                  numPages: J,
                  fingerprints: W,
                  htmlForXfa: z
                };
              }
              function T(M, V, J) {
                const W = (0, t.createPromiseCapability)();
                let z;
                const G = M.source;
                if (G.data) {
                  try {
                    z = new h.LocalPdfManager(R, G.data, G.password, f, V, J, k), W.resolve(z);
                  } catch (Q) {
                    W.reject(Q);
                  }
                  return W.promise;
                }
                let L, K = [];
                try {
                  L = new p.PDFWorkerStream(f);
                } catch (Q) {
                  return W.reject(Q), W.promise;
                }
                const te = L.getFullReader();
                te.headersReady.then(function() {
                  if (!te.isRangeSupported)
                    return;
                  const Q = G.disableAutoFetch || te.isStreamingSupported;
                  z = new h.NetworkPdfManager(R, L, {
                    msgHandler: f,
                    password: G.password,
                    length: te.contentLength,
                    disableAutoFetch: Q,
                    rangeChunkSize: G.rangeChunkSize
                  }, V, J, k);
                  for (const D of K)
                    z.sendProgressiveData(D);
                  K = [], W.resolve(z), b = null;
                }).catch(function(Q) {
                  W.reject(Q), b = null;
                });
                let se = 0;
                const q = function() {
                  const Q = (0, t.arraysToBytes)(K);
                  G.length && Q.length !== G.length && (0, t.warn)("reported HTTP length is different from actual");
                  try {
                    z = new h.LocalPdfManager(R, Q, G.password, f, V, J, k), W.resolve(z);
                  } catch (D) {
                    W.reject(D);
                  }
                  K = [];
                };
                return new Promise(function(Q, D) {
                  const ne = function({
                    value: oe,
                    done: ee
                  }) {
                    try {
                      if (U(), ee) {
                        z || q(), b = null;
                        return;
                      }
                      se += (0, t.arrayByteLength)(oe), te.isStreamingSupported || f.send("DocProgress", {
                        loaded: se,
                        total: Math.max(se, te.contentLength || 0)
                      }), z ? z.sendProgressiveData(oe) : K.push(oe), te.read().then(ne, D);
                    } catch ($) {
                      D($);
                    }
                  };
                  te.read().then(ne, D);
                }).catch(function(Q) {
                  W.reject(Q), b = null;
                }), b = function(Q) {
                  L.cancelAllRequests(Q);
                }, W.promise;
              }
              function I(M) {
                function V(G) {
                  U(), f.send("GetDoc", {
                    pdfInfo: G
                  });
                }
                function J(G) {
                  if (U(), G instanceof t.PasswordException) {
                    const L = new m(`PasswordException: response ${G.code}`);
                    O(L), f.sendWithPromise("PasswordRequest", G).then(function({
                      password: K
                    }) {
                      S(L), w.updatePassword(K), W();
                    }).catch(function() {
                      S(L), f.send("DocException", G);
                    });
                  } else
                    G instanceof t.InvalidPDFException || G instanceof t.MissingPDFException || G instanceof t.UnexpectedResponseException || G instanceof t.UnknownErrorException ? f.send("DocException", G) : f.send("DocException", new t.UnknownErrorException(G.message, G.toString()));
                }
                function W() {
                  U(), F(!1).then(V, function(G) {
                    if (U(), !(G instanceof v.XRefParseException)) {
                      J(G);
                      return;
                    }
                    w.requestLoadedStream(), w.onLoadedStream().then(function() {
                      U(), F(!0).then(V, J);
                    });
                  });
                }
                U();
                const z = {
                  maxImageSize: M.maxImageSize,
                  disableFontFace: M.disableFontFace,
                  ignoreErrors: M.ignoreErrors,
                  isEvalSupported: M.isEvalSupported,
                  fontExtraProperties: M.fontExtraProperties,
                  useSystemFonts: M.useSystemFonts,
                  cMapUrl: M.cMapUrl,
                  standardFontDataUrl: M.standardFontDataUrl
                };
                T(M, z, M.enableXfa).then(function(G) {
                  if (_)
                    throw G.terminate(new t.AbortException("Worker was terminated.")), new Error("Worker was terminated");
                  w = G, w.onLoadedStream().then(function(L) {
                    f.send("DataLoaded", {
                      length: L.bytes.byteLength
                    });
                  });
                }).then(W, J);
              }
              return f.on("GetPage", function(V) {
                return w.getPage(V.pageIndex).then(function(J) {
                  return Promise.all([w.ensure(J, "rotate"), w.ensure(J, "ref"), w.ensure(J, "userUnit"), w.ensure(J, "view")]).then(function([W, z, G, L]) {
                    return {
                      rotate: W,
                      ref: z,
                      userUnit: G,
                      view: L
                    };
                  });
                });
              }), f.on("GetPageIndex", function(V) {
                const J = a.Ref.get(V.num, V.gen);
                return w.ensureCatalog("getPageIndex", [J]);
              }), f.on("GetDestinations", function(V) {
                return w.ensureCatalog("destinations");
              }), f.on("GetDestination", function(V) {
                return w.ensureCatalog("getDestination", [V.id]);
              }), f.on("GetPageLabels", function(V) {
                return w.ensureCatalog("pageLabels");
              }), f.on("GetPageLayout", function(V) {
                return w.ensureCatalog("pageLayout");
              }), f.on("GetPageMode", function(V) {
                return w.ensureCatalog("pageMode");
              }), f.on("GetViewerPreferences", function(M) {
                return w.ensureCatalog("viewerPreferences");
              }), f.on("GetOpenAction", function(M) {
                return w.ensureCatalog("openAction");
              }), f.on("GetAttachments", function(V) {
                return w.ensureCatalog("attachments");
              }), f.on("GetJavaScript", function(V) {
                return w.ensureCatalog("javaScript");
              }), f.on("GetDocJSActions", function(V) {
                return w.ensureCatalog("jsActions");
              }), f.on("GetPageJSActions", function({
                pageIndex: M
              }) {
                return w.getPage(M).then(function(V) {
                  return w.ensure(V, "jsActions");
                });
              }), f.on("GetOutline", function(V) {
                return w.ensureCatalog("documentOutline");
              }), f.on("GetOptionalContentConfig", function(M) {
                return w.ensureCatalog("optionalContentConfig");
              }), f.on("GetPermissions", function(M) {
                return w.ensureCatalog("permissions");
              }), f.on("GetMetadata", function(V) {
                return Promise.all([w.ensureDoc("documentInfo"), w.ensureCatalog("metadata")]);
              }), f.on("GetMarkInfo", function(V) {
                return w.ensureCatalog("markInfo");
              }), f.on("GetData", function(V) {
                return w.requestLoadedStream(), w.onLoadedStream().then(function(J) {
                  return J.bytes;
                });
              }), f.on("GetAnnotations", function({
                pageIndex: M,
                intent: V
              }) {
                return w.getPage(M).then(function(J) {
                  const W = new m(`GetAnnotations: page ${M}`);
                  return O(W), J.getAnnotationsData(f, W, V).then((z) => (S(W), z), (z) => {
                    S(W);
                  });
                });
              }), f.on("GetFieldObjects", function(M) {
                return w.ensureDoc("fieldObjects");
              }), f.on("HasJSActions", function(M) {
                return w.ensureDoc("hasJSActions");
              }), f.on("GetCalculationOrderIds", function(M) {
                return w.ensureDoc("calculationOrderIds");
              }), f.on("SaveDocument", function({
                isPureXfa: M,
                numPages: V,
                annotationStorage: J,
                filename: W
              }) {
                w.requestLoadedStream();
                const z = M ? null : (0, v.getNewAnnotationsMap)(J), G = [w.onLoadedStream(), w.ensureCatalog("acroForm"), w.ensureCatalog("acroFormRef"), w.ensureDoc("xref"), w.ensureDoc("startXRef")];
                if (z)
                  for (const [L, K] of z)
                    G.push(w.getPage(L).then((te) => {
                      const se = new m(`Save (editor): page ${L}`);
                      return te.saveNewAnnotations(f, se, K).finally(function() {
                        S(se);
                      });
                    }));
                if (M)
                  G.push(w.serializeXfaData(J));
                else
                  for (let L = 0; L < V; L++)
                    G.push(w.getPage(L).then(function(K) {
                      const te = new m(`Save: page ${L}`);
                      return K.save(f, te, J).finally(function() {
                        S(te);
                      });
                    }));
                return Promise.all(G).then(function([L, K, te, se, q, ...N]) {
                  let Q = [], D = null;
                  if (M) {
                    if (D = N[0], !D)
                      return L.bytes;
                  } else if (Q = N.flat(2), Q.length === 0)
                    return L.bytes;
                  const ne = K instanceof a.Dict && K.get("XFA") || null;
                  let oe = null, ee = !1;
                  if (Array.isArray(ne)) {
                    for (let E = 0, H = ne.length; E < H; E += 2)
                      ne[E] === "datasets" && (oe = ne[E + 1], te = null, ee = !0);
                    oe === null && (oe = se.getNewRef());
                  } else
                    ne && (te = null, (0, t.warn)("Unsupported XFA type."));
                  let $ = /* @__PURE__ */ Object.create(null);
                  if (se.trailer) {
                    const E = /* @__PURE__ */ Object.create(null), H = se.trailer.get("Info") || null;
                    H instanceof a.Dict && H.forEach((ie, ue) => {
                      typeof ue == "string" && (E[ie] = (0, t.stringToPDFString)(ue));
                    }), $ = {
                      rootRef: se.trailer.getRaw("Root") || null,
                      encryptRef: se.trailer.getRaw("Encrypt") || null,
                      newRef: se.getNewRef(),
                      infoRef: se.trailer.getRaw("Info") || null,
                      info: E,
                      fileIds: se.trailer.get("ID") || null,
                      startXRef: q,
                      filename: W
                    };
                  }
                  return se.resetNewRef(), (0, y.incrementalUpdate)({
                    originalData: L.bytes,
                    xrefInfo: $,
                    newRefs: Q,
                    xref: se,
                    hasXfa: !!ne,
                    xfaDatasetsRef: oe,
                    hasXfaDatasetsEntry: ee,
                    acroFormRef: te,
                    acroForm: K,
                    xfaData: D
                  });
                });
              }), f.on("GetOperatorList", function(V, J) {
                const W = V.pageIndex;
                w.getPage(W).then(function(z) {
                  const G = new m(`GetOperatorList: page ${W}`);
                  O(G);
                  const L = Y >= t.VerbosityLevel.INFOS ? Date.now() : 0;
                  z.getOperatorList({
                    handler: f,
                    sink: J,
                    task: G,
                    intent: V.intent,
                    cacheKey: V.cacheKey,
                    annotationStorage: V.annotationStorage
                  }).then(function(K) {
                    S(G), L && (0, t.info)(`page=${W + 1} - getOperatorList: time=${Date.now() - L}ms, len=${K.length}`), J.close();
                  }, function(K) {
                    S(G), !G.terminated && (f.send("UnsupportedFeature", {
                      featureId: t.UNSUPPORTED_FEATURES.errorOperatorList
                    }), J.error(K));
                  });
                });
              }), f.on("GetTextContent", function(V, J) {
                const W = V.pageIndex;
                w.getPage(W).then(function(z) {
                  const G = new m("GetTextContent: page " + W);
                  O(G);
                  const L = Y >= t.VerbosityLevel.INFOS ? Date.now() : 0;
                  z.extractTextContent({
                    handler: f,
                    task: G,
                    sink: J,
                    includeMarkedContent: V.includeMarkedContent,
                    combineTextItems: V.combineTextItems
                  }).then(function() {
                    S(G), L && (0, t.info)(`page=${W + 1} - getTextContent: time=${Date.now() - L}ms`), J.close();
                  }, function(K) {
                    S(G), !G.terminated && J.error(K);
                  });
                });
              }), f.on("GetStructTree", function(V) {
                return w.getPage(V.pageIndex).then(function(J) {
                  return w.ensure(J, "getStructTree");
                });
              }), f.on("FontFallback", function(M) {
                return w.fontFallback(M.id, f);
              }), f.on("Cleanup", function(V) {
                return w.cleanup(!0);
              }), f.on("Terminate", function(V) {
                _ = !0;
                const J = [];
                if (w) {
                  w.terminate(new t.AbortException("Worker was terminated."));
                  const W = w.cleanup();
                  J.push(W), w = null;
                } else
                  (0, e.clearGlobalCaches)();
                b && b(new t.AbortException("Worker was terminated."));
                for (const W of A)
                  J.push(W.finished), W.terminate();
                return Promise.all(J).then(function() {
                  f.destroy(), f = null;
                });
              }), f.on("Ready", function(V) {
                I(l), l = null;
              }), x;
            }
            static initializeFromPort(l) {
              const u = new d.MessageHandler("worker", "main", l);
              g.setup(u, l), u.send("ready", null);
            }
          }
          o.WorkerMessageHandler = g;
          function n(i) {
            return typeof i.postMessage == "function" && "onmessage" in i;
          }
          typeof window > "u" && !c.isNodeJS && typeof self < "u" && n(self) && g.initializeFromPort(self);
        },
        /* 2 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.VerbosityLevel = o.Util = o.UnknownErrorException = o.UnexpectedResponseException = o.UNSUPPORTED_FEATURES = o.TextRenderingMode = o.StreamType = o.RenderingIntentFlag = o.PermissionFlag = o.PasswordResponses = o.PasswordException = o.PageActionEventType = o.OPS = o.MissingPDFException = o.LINE_FACTOR = o.LINE_DESCENT_FACTOR = o.InvalidPDFException = o.ImageKind = o.IDENTITY_MATRIX = o.FormatError = o.FontType = o.FeatureTest = o.FONT_IDENTITY_MATRIX = o.DocumentActionEventType = o.CMapCompressionType = o.BaseException = o.AnnotationType = o.AnnotationStateModelType = o.AnnotationReviewState = o.AnnotationReplyType = o.AnnotationMode = o.AnnotationMarkedState = o.AnnotationFlag = o.AnnotationFieldFlag = o.AnnotationEditorType = o.AnnotationEditorPrefix = o.AnnotationEditorParamsType = o.AnnotationBorderStyleType = o.AnnotationActionEventType = o.AbortException = void 0, o.arrayByteLength = $, o.arraysToBytes = E, o.assert = W, o.bytesToString = oe, o.createPromiseCapability = Qe, o.createValidAbsoluteUrl = G, o.escapeString = ke, o.getModificationDate = He, o.getVerbosityLevel = I, o.info = M, o.isArrayBuffer = ve, o.isArrayEqual = Le, o.isAscii = ye, o.objectFromMap = ue, o.objectSize = ie, o.setVerbosityLevel = T, o.shadow = L, o.string32 = H, o.stringToBytes = ee, o.stringToPDFString = Se, o.stringToUTF16BEString = _e, o.stringToUTF8String = we, o.unreachable = J, o.utf8StringToString = Ce, o.warn = V, C(3);
          const t = [1, 0, 0, 1, 0, 0];
          o.IDENTITY_MATRIX = t;
          const a = [1e-3, 0, 0, 1e-3, 0, 0];
          o.FONT_IDENTITY_MATRIX = a;
          const v = 1.35;
          o.LINE_FACTOR = v;
          const h = 0.35;
          o.LINE_DESCENT_FACTOR = h;
          const e = {
            ANY: 1,
            DISPLAY: 2,
            PRINT: 4,
            ANNOTATIONS_FORMS: 16,
            ANNOTATIONS_STORAGE: 32,
            ANNOTATIONS_DISABLE: 64,
            OPLIST: 256
          };
          o.RenderingIntentFlag = e;
          const y = {
            DISABLE: 0,
            ENABLE: 1,
            ENABLE_FORMS: 2,
            ENABLE_STORAGE: 3
          };
          o.AnnotationMode = y;
          const c = "pdfjs_internal_editor_";
          o.AnnotationEditorPrefix = c;
          const d = {
            DISABLE: -1,
            NONE: 0,
            FREETEXT: 3,
            INK: 15
          };
          o.AnnotationEditorType = d;
          const p = {
            FREETEXT_SIZE: 1,
            FREETEXT_COLOR: 2,
            FREETEXT_OPACITY: 3,
            INK_COLOR: 11,
            INK_THICKNESS: 12,
            INK_OPACITY: 13
          };
          o.AnnotationEditorParamsType = p;
          const m = {
            PRINT: 4,
            MODIFY_CONTENTS: 8,
            COPY: 16,
            MODIFY_ANNOTATIONS: 32,
            FILL_INTERACTIVE_FORMS: 256,
            COPY_FOR_ACCESSIBILITY: 512,
            ASSEMBLE: 1024,
            PRINT_HIGH_QUALITY: 2048
          };
          o.PermissionFlag = m;
          const g = {
            FILL: 0,
            STROKE: 1,
            FILL_STROKE: 2,
            INVISIBLE: 3,
            FILL_ADD_TO_PATH: 4,
            STROKE_ADD_TO_PATH: 5,
            FILL_STROKE_ADD_TO_PATH: 6,
            ADD_TO_PATH: 7,
            FILL_STROKE_MASK: 3,
            ADD_TO_PATH_FLAG: 4
          };
          o.TextRenderingMode = g;
          const n = {
            GRAYSCALE_1BPP: 1,
            RGB_24BPP: 2,
            RGBA_32BPP: 3
          };
          o.ImageKind = n;
          const i = {
            TEXT: 1,
            LINK: 2,
            FREETEXT: 3,
            LINE: 4,
            SQUARE: 5,
            CIRCLE: 6,
            POLYGON: 7,
            POLYLINE: 8,
            HIGHLIGHT: 9,
            UNDERLINE: 10,
            SQUIGGLY: 11,
            STRIKEOUT: 12,
            STAMP: 13,
            CARET: 14,
            INK: 15,
            POPUP: 16,
            FILEATTACHMENT: 17,
            SOUND: 18,
            MOVIE: 19,
            WIDGET: 20,
            SCREEN: 21,
            PRINTERMARK: 22,
            TRAPNET: 23,
            WATERMARK: 24,
            THREED: 25,
            REDACT: 26
          };
          o.AnnotationType = i;
          const l = {
            MARKED: "Marked",
            REVIEW: "Review"
          };
          o.AnnotationStateModelType = l;
          const u = {
            MARKED: "Marked",
            UNMARKED: "Unmarked"
          };
          o.AnnotationMarkedState = u;
          const w = {
            ACCEPTED: "Accepted",
            REJECTED: "Rejected",
            CANCELLED: "Cancelled",
            COMPLETED: "Completed",
            NONE: "None"
          };
          o.AnnotationReviewState = w;
          const _ = {
            GROUP: "Group",
            REPLY: "R"
          };
          o.AnnotationReplyType = _;
          const b = {
            INVISIBLE: 1,
            HIDDEN: 2,
            PRINT: 4,
            NOZOOM: 8,
            NOROTATE: 16,
            NOVIEW: 32,
            READONLY: 64,
            LOCKED: 128,
            TOGGLENOVIEW: 256,
            LOCKEDCONTENTS: 512
          };
          o.AnnotationFlag = b;
          const A = {
            READONLY: 1,
            REQUIRED: 2,
            NOEXPORT: 4,
            MULTILINE: 4096,
            PASSWORD: 8192,
            NOTOGGLETOOFF: 16384,
            RADIO: 32768,
            PUSHBUTTON: 65536,
            COMBO: 131072,
            EDIT: 262144,
            SORT: 524288,
            FILESELECT: 1048576,
            MULTISELECT: 2097152,
            DONOTSPELLCHECK: 4194304,
            DONOTSCROLL: 8388608,
            COMB: 16777216,
            RICHTEXT: 33554432,
            RADIOSINUNISON: 33554432,
            COMMITONSELCHANGE: 67108864
          };
          o.AnnotationFieldFlag = A;
          const Y = {
            SOLID: 1,
            DASHED: 2,
            BEVELED: 3,
            INSET: 4,
            UNDERLINE: 5
          };
          o.AnnotationBorderStyleType = Y;
          const j = {
            E: "Mouse Enter",
            X: "Mouse Exit",
            D: "Mouse Down",
            U: "Mouse Up",
            Fo: "Focus",
            Bl: "Blur",
            PO: "PageOpen",
            PC: "PageClose",
            PV: "PageVisible",
            PI: "PageInvisible",
            K: "Keystroke",
            F: "Format",
            V: "Validate",
            C: "Calculate"
          };
          o.AnnotationActionEventType = j;
          const X = {
            WC: "WillClose",
            WS: "WillSave",
            DS: "DidSave",
            WP: "WillPrint",
            DP: "DidPrint"
          };
          o.DocumentActionEventType = X;
          const B = {
            O: "PageOpen",
            C: "PageClose"
          };
          o.PageActionEventType = B;
          const R = {
            UNKNOWN: "UNKNOWN",
            FLATE: "FLATE",
            LZW: "LZW",
            DCT: "DCT",
            JPX: "JPX",
            JBIG: "JBIG",
            A85: "A85",
            AHX: "AHX",
            CCF: "CCF",
            RLX: "RLX"
          };
          o.StreamType = R;
          const k = {
            UNKNOWN: "UNKNOWN",
            TYPE1: "TYPE1",
            TYPE1STANDARD: "TYPE1STANDARD",
            TYPE1C: "TYPE1C",
            CIDFONTTYPE0: "CIDFONTTYPE0",
            CIDFONTTYPE0C: "CIDFONTTYPE0C",
            TRUETYPE: "TRUETYPE",
            CIDFONTTYPE2: "CIDFONTTYPE2",
            TYPE3: "TYPE3",
            OPENTYPE: "OPENTYPE",
            TYPE0: "TYPE0",
            MMTYPE1: "MMTYPE1"
          };
          o.FontType = k;
          const x = {
            ERRORS: 0,
            WARNINGS: 1,
            INFOS: 5
          };
          o.VerbosityLevel = x;
          const f = {
            NONE: 0,
            BINARY: 1,
            STREAM: 2
          };
          o.CMapCompressionType = f;
          const U = {
            dependency: 1,
            setLineWidth: 2,
            setLineCap: 3,
            setLineJoin: 4,
            setMiterLimit: 5,
            setDash: 6,
            setRenderingIntent: 7,
            setFlatness: 8,
            setGState: 9,
            save: 10,
            restore: 11,
            transform: 12,
            moveTo: 13,
            lineTo: 14,
            curveTo: 15,
            curveTo2: 16,
            curveTo3: 17,
            closePath: 18,
            rectangle: 19,
            stroke: 20,
            closeStroke: 21,
            fill: 22,
            eoFill: 23,
            fillStroke: 24,
            eoFillStroke: 25,
            closeFillStroke: 26,
            closeEOFillStroke: 27,
            endPath: 28,
            clip: 29,
            eoClip: 30,
            beginText: 31,
            endText: 32,
            setCharSpacing: 33,
            setWordSpacing: 34,
            setHScale: 35,
            setLeading: 36,
            setFont: 37,
            setTextRenderingMode: 38,
            setTextRise: 39,
            moveText: 40,
            setLeadingMoveText: 41,
            setTextMatrix: 42,
            nextLine: 43,
            showText: 44,
            showSpacedText: 45,
            nextLineShowText: 46,
            nextLineSetSpacingShowText: 47,
            setCharWidth: 48,
            setCharWidthAndBounds: 49,
            setStrokeColorSpace: 50,
            setFillColorSpace: 51,
            setStrokeColor: 52,
            setStrokeColorN: 53,
            setFillColor: 54,
            setFillColorN: 55,
            setStrokeGray: 56,
            setFillGray: 57,
            setStrokeRGBColor: 58,
            setFillRGBColor: 59,
            setStrokeCMYKColor: 60,
            setFillCMYKColor: 61,
            shadingFill: 62,
            beginInlineImage: 63,
            beginImageData: 64,
            endInlineImage: 65,
            paintXObject: 66,
            markPoint: 67,
            markPointProps: 68,
            beginMarkedContent: 69,
            beginMarkedContentProps: 70,
            endMarkedContent: 71,
            beginCompat: 72,
            endCompat: 73,
            paintFormXObjectBegin: 74,
            paintFormXObjectEnd: 75,
            beginGroup: 76,
            endGroup: 77,
            beginAnnotations: 78,
            endAnnotations: 79,
            beginAnnotation: 80,
            endAnnotation: 81,
            paintJpegXObject: 82,
            paintImageMaskXObject: 83,
            paintImageMaskXObjectGroup: 84,
            paintImageXObject: 85,
            paintInlineImageXObject: 86,
            paintInlineImageXObjectGroup: 87,
            paintImageXObjectRepeat: 88,
            paintImageMaskXObjectRepeat: 89,
            paintSolidColorImageMask: 90,
            constructPath: 91
          };
          o.OPS = U;
          const O = {
            unknown: "unknown",
            forms: "forms",
            javaScript: "javaScript",
            signatures: "signatures",
            smask: "smask",
            shadingPattern: "shadingPattern",
            font: "font",
            errorTilingPattern: "errorTilingPattern",
            errorExtGState: "errorExtGState",
            errorXObject: "errorXObject",
            errorFontLoadType3: "errorFontLoadType3",
            errorFontState: "errorFontState",
            errorFontMissing: "errorFontMissing",
            errorFontTranslate: "errorFontTranslate",
            errorColorSpace: "errorColorSpace",
            errorOperatorList: "errorOperatorList",
            errorFontToUnicode: "errorFontToUnicode",
            errorFontLoadNative: "errorFontLoadNative",
            errorFontBuildPath: "errorFontBuildPath",
            errorFontGetPath: "errorFontGetPath",
            errorMarkedContent: "errorMarkedContent",
            errorContentSubStream: "errorContentSubStream"
          };
          o.UNSUPPORTED_FEATURES = O;
          const S = {
            NEED_PASSWORD: 1,
            INCORRECT_PASSWORD: 2
          };
          o.PasswordResponses = S;
          let F = x.WARNINGS;
          function T(Ue) {
            Number.isInteger(Ue) && (F = Ue);
          }
          function I() {
            return F;
          }
          function M(Ue) {
            F >= x.INFOS && console.log(`Info: ${Ue}`);
          }
          function V(Ue) {
            F >= x.WARNINGS && console.log(`Warning: ${Ue}`);
          }
          function J(Ue) {
            throw new Error(Ue);
          }
          function W(Ue, Ie) {
            Ue || J(Ie);
          }
          function z(Ue) {
            if (!Ue)
              return !1;
            switch (Ue.protocol) {
              case "http:":
              case "https:":
              case "ftp:":
              case "mailto:":
              case "tel:":
                return !0;
              default:
                return !1;
            }
          }
          function G(Ue, Ie = null, Ee = null) {
            if (!Ue)
              return null;
            try {
              if (Ee && typeof Ue == "string") {
                if (Ee.addDefaultProtocol && Ue.startsWith("www.")) {
                  const qe = Ue.match(/\./g);
                  qe && qe.length >= 2 && (Ue = `http://${Ue}`);
                }
                if (Ee.tryConvertEncoding)
                  try {
                    Ue = we(Ue);
                  } catch {
                  }
              }
              const et = Ie ? new URL(Ue, Ie) : new URL(Ue);
              if (z(et))
                return et;
            } catch {
            }
            return null;
          }
          function L(Ue, Ie, Ee) {
            return Object.defineProperty(Ue, Ie, {
              value: Ee,
              enumerable: !0,
              configurable: !0,
              writable: !1
            }), Ee;
          }
          const K = function() {
            function Ie(Ee, et) {
              this.constructor === Ie && J("Cannot initialize BaseException."), this.message = Ee, this.name = et;
            }
            return Ie.prototype = new Error(), Ie.constructor = Ie, Ie;
          }();
          o.BaseException = K;
          class te extends K {
            constructor(Ie, Ee) {
              super(Ie, "PasswordException"), this.code = Ee;
            }
          }
          o.PasswordException = te;
          class se extends K {
            constructor(Ie, Ee) {
              super(Ie, "UnknownErrorException"), this.details = Ee;
            }
          }
          o.UnknownErrorException = se;
          class q extends K {
            constructor(Ie) {
              super(Ie, "InvalidPDFException");
            }
          }
          o.InvalidPDFException = q;
          class N extends K {
            constructor(Ie) {
              super(Ie, "MissingPDFException");
            }
          }
          o.MissingPDFException = N;
          class Q extends K {
            constructor(Ie, Ee) {
              super(Ie, "UnexpectedResponseException"), this.status = Ee;
            }
          }
          o.UnexpectedResponseException = Q;
          class D extends K {
            constructor(Ie) {
              super(Ie, "FormatError");
            }
          }
          o.FormatError = D;
          class ne extends K {
            constructor(Ie) {
              super(Ie, "AbortException");
            }
          }
          o.AbortException = ne;
          function oe(Ue) {
            (typeof Ue != "object" || Ue === null || Ue.length === void 0) && J("Invalid argument for bytesToString");
            const Ie = Ue.length, Ee = 8192;
            if (Ie < Ee)
              return String.fromCharCode.apply(null, Ue);
            const et = [];
            for (let qe = 0; qe < Ie; qe += Ee) {
              const tt = Math.min(qe + Ee, Ie), ft = Ue.subarray(qe, tt);
              et.push(String.fromCharCode.apply(null, ft));
            }
            return et.join("");
          }
          function ee(Ue) {
            typeof Ue != "string" && J("Invalid argument for stringToBytes");
            const Ie = Ue.length, Ee = new Uint8Array(Ie);
            for (let et = 0; et < Ie; ++et)
              Ee[et] = Ue.charCodeAt(et) & 255;
            return Ee;
          }
          function $(Ue) {
            if (Ue.length !== void 0)
              return Ue.length;
            if (Ue.byteLength !== void 0)
              return Ue.byteLength;
            J("Invalid argument for arrayByteLength");
          }
          function E(Ue) {
            const Ie = Ue.length;
            if (Ie === 1 && Ue[0] instanceof Uint8Array)
              return Ue[0];
            let Ee = 0;
            for (let tt = 0; tt < Ie; tt++)
              Ee += $(Ue[tt]);
            let et = 0;
            const qe = new Uint8Array(Ee);
            for (let tt = 0; tt < Ie; tt++) {
              let ft = Ue[tt];
              ft instanceof Uint8Array || (typeof ft == "string" ? ft = ee(ft) : ft = new Uint8Array(ft));
              const Te = ft.byteLength;
              qe.set(ft, et), et += Te;
            }
            return qe;
          }
          function H(Ue) {
            return String.fromCharCode(Ue >> 24 & 255, Ue >> 16 & 255, Ue >> 8 & 255, Ue & 255);
          }
          function ie(Ue) {
            return Object.keys(Ue).length;
          }
          function ue(Ue) {
            const Ie = /* @__PURE__ */ Object.create(null);
            for (const [Ee, et] of Ue)
              Ie[Ee] = et;
            return Ie;
          }
          function fe() {
            const Ue = new Uint8Array(4);
            return Ue[0] = 1, new Uint32Array(Ue.buffer, 0, 1)[0] === 1;
          }
          function de() {
            try {
              return new Function(""), !0;
            } catch {
              return !1;
            }
          }
          class pe {
            static get isLittleEndian() {
              return L(this, "isLittleEndian", fe());
            }
            static get isEvalSupported() {
              return L(this, "isEvalSupported", de());
            }
            static get isOffscreenCanvasSupported() {
              return L(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas < "u");
            }
          }
          o.FeatureTest = pe;
          const xe = [...Array(256).keys()].map((Ue) => Ue.toString(16).padStart(2, "0"));
          class De {
            static makeHexColor(Ie, Ee, et) {
              return `#${xe[Ie]}${xe[Ee]}${xe[et]}`;
            }
            static scaleMinMax(Ie, Ee) {
              let et;
              Ie[0] ? (Ie[0] < 0 && (et = Ee[0], Ee[0] = Ee[1], Ee[1] = et), Ee[0] *= Ie[0], Ee[1] *= Ie[0], Ie[3] < 0 && (et = Ee[2], Ee[2] = Ee[3], Ee[3] = et), Ee[2] *= Ie[3], Ee[3] *= Ie[3]) : (et = Ee[0], Ee[0] = Ee[2], Ee[2] = et, et = Ee[1], Ee[1] = Ee[3], Ee[3] = et, Ie[1] < 0 && (et = Ee[2], Ee[2] = Ee[3], Ee[3] = et), Ee[2] *= Ie[1], Ee[3] *= Ie[1], Ie[2] < 0 && (et = Ee[0], Ee[0] = Ee[1], Ee[1] = et), Ee[0] *= Ie[2], Ee[1] *= Ie[2]), Ee[0] += Ie[4], Ee[1] += Ie[4], Ee[2] += Ie[5], Ee[3] += Ie[5];
            }
            static transform(Ie, Ee) {
              return [Ie[0] * Ee[0] + Ie[2] * Ee[1], Ie[1] * Ee[0] + Ie[3] * Ee[1], Ie[0] * Ee[2] + Ie[2] * Ee[3], Ie[1] * Ee[2] + Ie[3] * Ee[3], Ie[0] * Ee[4] + Ie[2] * Ee[5] + Ie[4], Ie[1] * Ee[4] + Ie[3] * Ee[5] + Ie[5]];
            }
            static applyTransform(Ie, Ee) {
              const et = Ie[0] * Ee[0] + Ie[1] * Ee[2] + Ee[4], qe = Ie[0] * Ee[1] + Ie[1] * Ee[3] + Ee[5];
              return [et, qe];
            }
            static applyInverseTransform(Ie, Ee) {
              const et = Ee[0] * Ee[3] - Ee[1] * Ee[2], qe = (Ie[0] * Ee[3] - Ie[1] * Ee[2] + Ee[2] * Ee[5] - Ee[4] * Ee[3]) / et, tt = (-Ie[0] * Ee[1] + Ie[1] * Ee[0] + Ee[4] * Ee[1] - Ee[5] * Ee[0]) / et;
              return [qe, tt];
            }
            static getAxialAlignedBoundingBox(Ie, Ee) {
              const et = De.applyTransform(Ie, Ee), qe = De.applyTransform(Ie.slice(2, 4), Ee), tt = De.applyTransform([Ie[0], Ie[3]], Ee), ft = De.applyTransform([Ie[2], Ie[1]], Ee);
              return [Math.min(et[0], qe[0], tt[0], ft[0]), Math.min(et[1], qe[1], tt[1], ft[1]), Math.max(et[0], qe[0], tt[0], ft[0]), Math.max(et[1], qe[1], tt[1], ft[1])];
            }
            static inverseTransform(Ie) {
              const Ee = Ie[0] * Ie[3] - Ie[1] * Ie[2];
              return [Ie[3] / Ee, -Ie[1] / Ee, -Ie[2] / Ee, Ie[0] / Ee, (Ie[2] * Ie[5] - Ie[4] * Ie[3]) / Ee, (Ie[4] * Ie[1] - Ie[5] * Ie[0]) / Ee];
            }
            static apply3dTransform(Ie, Ee) {
              return [Ie[0] * Ee[0] + Ie[1] * Ee[1] + Ie[2] * Ee[2], Ie[3] * Ee[0] + Ie[4] * Ee[1] + Ie[5] * Ee[2], Ie[6] * Ee[0] + Ie[7] * Ee[1] + Ie[8] * Ee[2]];
            }
            static singularValueDecompose2dScale(Ie) {
              const Ee = [Ie[0], Ie[2], Ie[1], Ie[3]], et = Ie[0] * Ee[0] + Ie[1] * Ee[2], qe = Ie[0] * Ee[1] + Ie[1] * Ee[3], tt = Ie[2] * Ee[0] + Ie[3] * Ee[2], ft = Ie[2] * Ee[1] + Ie[3] * Ee[3], Te = (et + ft) / 2, je = Math.sqrt((et + ft) ** 2 - 4 * (et * ft - tt * qe)) / 2, Ze = Te + je || 1, Me = Te - je || 1;
              return [Math.sqrt(Ze), Math.sqrt(Me)];
            }
            static normalizeRect(Ie) {
              const Ee = Ie.slice(0);
              return Ie[0] > Ie[2] && (Ee[0] = Ie[2], Ee[2] = Ie[0]), Ie[1] > Ie[3] && (Ee[1] = Ie[3], Ee[3] = Ie[1]), Ee;
            }
            static intersect(Ie, Ee) {
              const et = Math.max(Math.min(Ie[0], Ie[2]), Math.min(Ee[0], Ee[2])), qe = Math.min(Math.max(Ie[0], Ie[2]), Math.max(Ee[0], Ee[2]));
              if (et > qe)
                return null;
              const tt = Math.max(Math.min(Ie[1], Ie[3]), Math.min(Ee[1], Ee[3])), ft = Math.min(Math.max(Ie[1], Ie[3]), Math.max(Ee[1], Ee[3]));
              return tt > ft ? null : [et, tt, qe, ft];
            }
            static bezierBoundingBox(Ie, Ee, et, qe, tt, ft, Te, je) {
              const Ze = [], Me = [[], []];
              let at, rt, xt, ut, yt, ht, Rt, Wt;
              for (let it = 0; it < 2; ++it) {
                if (it === 0 ? (rt = 6 * Ie - 12 * et + 6 * tt, at = -3 * Ie + 9 * et - 9 * tt + 3 * Te, xt = 3 * et - 3 * Ie) : (rt = 6 * Ee - 12 * qe + 6 * ft, at = -3 * Ee + 9 * qe - 9 * ft + 3 * je, xt = 3 * qe - 3 * Ee), Math.abs(at) < 1e-12) {
                  if (Math.abs(rt) < 1e-12)
                    continue;
                  ut = -xt / rt, 0 < ut && ut < 1 && Ze.push(ut);
                  continue;
                }
                Rt = rt * rt - 4 * xt * at, Wt = Math.sqrt(Rt), !(Rt < 0) && (yt = (-rt + Wt) / (2 * at), 0 < yt && yt < 1 && Ze.push(yt), ht = (-rt - Wt) / (2 * at), 0 < ht && ht < 1 && Ze.push(ht));
              }
              let Ke = Ze.length, Ge;
              const nt = Ke;
              for (; Ke--; )
                ut = Ze[Ke], Ge = 1 - ut, Me[0][Ke] = Ge * Ge * Ge * Ie + 3 * Ge * Ge * ut * et + 3 * Ge * ut * ut * tt + ut * ut * ut * Te, Me[1][Ke] = Ge * Ge * Ge * Ee + 3 * Ge * Ge * ut * qe + 3 * Ge * ut * ut * ft + ut * ut * ut * je;
              return Me[0][nt] = Ie, Me[1][nt] = Ee, Me[0][nt + 1] = Te, Me[1][nt + 1] = je, Me[0].length = Me[1].length = nt + 2, [Math.min(...Me[0]), Math.min(...Me[1]), Math.max(...Me[0]), Math.max(...Me[1])];
            }
          }
          o.Util = De;
          const Ae = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
          function Se(Ue) {
            if (Ue[0] >= "ï") {
              let Ee;
              if (Ue[0] === "þ" && Ue[1] === "ÿ" ? Ee = "utf-16be" : Ue[0] === "ÿ" && Ue[1] === "þ" ? Ee = "utf-16le" : Ue[0] === "ï" && Ue[1] === "»" && Ue[2] === "¿" && (Ee = "utf-8"), Ee)
                try {
                  const et = new TextDecoder(Ee, {
                    fatal: !0
                  }), qe = ee(Ue);
                  return et.decode(qe);
                } catch (et) {
                  V(`stringToPDFString: "${et}".`);
                }
            }
            const Ie = [];
            for (let Ee = 0, et = Ue.length; Ee < et; Ee++) {
              const qe = Ae[Ue.charCodeAt(Ee)];
              Ie.push(qe ? String.fromCharCode(qe) : Ue.charAt(Ee));
            }
            return Ie.join("");
          }
          function ke(Ue) {
            return Ue.replace(/([()\\\n\r])/g, (Ie) => Ie === `
` ? "\\n" : Ie === "\r" ? "\\r" : `\\${Ie}`);
          }
          function ye(Ue) {
            return /^[\x00-\x7F]*$/.test(Ue);
          }
          function _e(Ue) {
            const Ie = ["þÿ"];
            for (let Ee = 0, et = Ue.length; Ee < et; Ee++) {
              const qe = Ue.charCodeAt(Ee);
              Ie.push(String.fromCharCode(qe >> 8 & 255), String.fromCharCode(qe & 255));
            }
            return Ie.join("");
          }
          function we(Ue) {
            return decodeURIComponent(escape(Ue));
          }
          function Ce(Ue) {
            return unescape(encodeURIComponent(Ue));
          }
          function ve(Ue) {
            return typeof Ue == "object" && Ue !== null && Ue.byteLength !== void 0;
          }
          function Le(Ue, Ie) {
            if (Ue.length !== Ie.length)
              return !1;
            for (let Ee = 0, et = Ue.length; Ee < et; Ee++)
              if (Ue[Ee] !== Ie[Ee])
                return !1;
            return !0;
          }
          function He(Ue = new Date()) {
            return [Ue.getUTCFullYear().toString(), (Ue.getUTCMonth() + 1).toString().padStart(2, "0"), Ue.getUTCDate().toString().padStart(2, "0"), Ue.getUTCHours().toString().padStart(2, "0"), Ue.getUTCMinutes().toString().padStart(2, "0"), Ue.getUTCSeconds().toString().padStart(2, "0")].join("");
          }
          function Qe() {
            const Ue = /* @__PURE__ */ Object.create(null);
            let Ie = !1;
            return Object.defineProperty(Ue, "settled", {
              get() {
                return Ie;
              }
            }), Ue.promise = new Promise(function(Ee, et) {
              Ue.resolve = function(qe) {
                Ie = !0, Ee(qe);
              }, Ue.reject = function(qe) {
                Ie = !0, et(qe);
              };
            }), Ue;
          }
        },
        /* 3 */
        /***/
        (Z, o, C) => {
          C(4);
        },
        /* 4 */
        /***/
        (Z, o) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.isNodeJS = void 0;
          const C = typeof process == "object" && process + "" == "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
          o.isNodeJS = C;
        },
        /* 5 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.RefSetCache = o.RefSet = o.Ref = o.Name = o.EOF = o.Dict = o.Cmd = o.CIRCULAR_REF = void 0, o.clearPrimitiveCaches = u, o.isCmd = n, o.isDict = i, o.isName = g, o.isRefsEqual = l;
          var t = C(2);
          const a = Symbol("CIRCULAR_REF");
          o.CIRCULAR_REF = a;
          const v = Symbol("EOF");
          o.EOF = v;
          const h = function() {
            let _ = /* @__PURE__ */ Object.create(null);
            class b {
              constructor(Y) {
                this.name = Y;
              }
              static get(Y) {
                return _[Y] || (_[Y] = new b(Y));
              }
              static _clearCache() {
                _ = /* @__PURE__ */ Object.create(null);
              }
            }
            return b;
          }();
          o.Name = h;
          const e = function() {
            let _ = /* @__PURE__ */ Object.create(null);
            class b {
              constructor(Y) {
                this.cmd = Y;
              }
              static get(Y) {
                return _[Y] || (_[Y] = new b(Y));
              }
              static _clearCache() {
                _ = /* @__PURE__ */ Object.create(null);
              }
            }
            return b;
          }();
          o.Cmd = e;
          const y = function() {
            return y;
          };
          class c {
            constructor(_ = null) {
              this._map = /* @__PURE__ */ Object.create(null), this.xref = _, this.objId = null, this.suppressEncryption = !1, this.__nonSerializable__ = y;
            }
            assignXref(_) {
              this.xref = _;
            }
            get size() {
              return Object.keys(this._map).length;
            }
            get(_, b, A) {
              let Y = this._map[_];
              return Y === void 0 && b !== void 0 && (Y = this._map[b], Y === void 0 && A !== void 0 && (Y = this._map[A])), Y instanceof d && this.xref ? this.xref.fetch(Y, this.suppressEncryption) : Y;
            }
            async getAsync(_, b, A) {
              let Y = this._map[_];
              return Y === void 0 && b !== void 0 && (Y = this._map[b], Y === void 0 && A !== void 0 && (Y = this._map[A])), Y instanceof d && this.xref ? this.xref.fetchAsync(Y, this.suppressEncryption) : Y;
            }
            getArray(_, b, A) {
              let Y = this._map[_];
              if (Y === void 0 && b !== void 0 && (Y = this._map[b], Y === void 0 && A !== void 0 && (Y = this._map[A])), Y instanceof d && this.xref && (Y = this.xref.fetch(Y, this.suppressEncryption)), Array.isArray(Y)) {
                Y = Y.slice();
                for (let j = 0, X = Y.length; j < X; j++)
                  Y[j] instanceof d && this.xref && (Y[j] = this.xref.fetch(Y[j], this.suppressEncryption));
              }
              return Y;
            }
            getRaw(_) {
              return this._map[_];
            }
            getKeys() {
              return Object.keys(this._map);
            }
            getRawValues() {
              return Object.values(this._map);
            }
            set(_, b) {
              this._map[_] = b;
            }
            has(_) {
              return this._map[_] !== void 0;
            }
            forEach(_) {
              for (const b in this._map)
                _(b, this.get(b));
            }
            static get empty() {
              const _ = new c(null);
              return _.set = (b, A) => {
                (0, t.unreachable)("Should not call `set` on the empty dictionary.");
              }, (0, t.shadow)(this, "empty", _);
            }
            static merge({
              xref: _,
              dictArray: b,
              mergeSubDicts: A = !1
            }) {
              const Y = new c(_), j = /* @__PURE__ */ new Map();
              for (const X of b)
                if (X instanceof c)
                  for (const [B, R] of Object.entries(X._map)) {
                    let k = j.get(B);
                    if (k === void 0)
                      k = [], j.set(B, k);
                    else if (!A || !(R instanceof c))
                      continue;
                    k.push(R);
                  }
              for (const [X, B] of j) {
                if (B.length === 1 || !(B[0] instanceof c)) {
                  Y._map[X] = B[0];
                  continue;
                }
                const R = new c(_);
                for (const k of B)
                  for (const [x, f] of Object.entries(k._map))
                    R._map[x] === void 0 && (R._map[x] = f);
                R.size > 0 && (Y._map[X] = R);
              }
              return j.clear(), Y.size > 0 ? Y : c.empty;
            }
          }
          o.Dict = c;
          const d = function() {
            let _ = /* @__PURE__ */ Object.create(null);
            class b {
              constructor(Y, j) {
                this.num = Y, this.gen = j;
              }
              toString() {
                return this.gen === 0 ? `${this.num}R` : `${this.num}R${this.gen}`;
              }
              static get(Y, j) {
                const X = j === 0 ? `${Y}R` : `${Y}R${j}`;
                return _[X] || (_[X] = new b(Y, j));
              }
              static _clearCache() {
                _ = /* @__PURE__ */ Object.create(null);
              }
            }
            return b;
          }();
          o.Ref = d;
          class p {
            constructor(_ = null) {
              this._set = new Set(_ && _._set);
            }
            has(_) {
              return this._set.has(_.toString());
            }
            put(_) {
              this._set.add(_.toString());
            }
            remove(_) {
              this._set.delete(_.toString());
            }
            [Symbol.iterator]() {
              return this._set.values();
            }
            clear() {
              this._set.clear();
            }
          }
          o.RefSet = p;
          class m {
            constructor() {
              this._map = /* @__PURE__ */ new Map();
            }
            get size() {
              return this._map.size;
            }
            get(_) {
              return this._map.get(_.toString());
            }
            has(_) {
              return this._map.has(_.toString());
            }
            put(_, b) {
              this._map.set(_.toString(), b);
            }
            putAlias(_, b) {
              this._map.set(_.toString(), this.get(b));
            }
            [Symbol.iterator]() {
              return this._map.values();
            }
            clear() {
              this._map.clear();
            }
          }
          o.RefSetCache = m;
          function g(w, _) {
            return w instanceof h && (_ === void 0 || w.name === _);
          }
          function n(w, _) {
            return w instanceof e && (_ === void 0 || w.cmd === _);
          }
          function i(w, _) {
            return w instanceof c && (_ === void 0 || g(w.get("Type"), _));
          }
          function l(w, _) {
            return w.num === _.num && w.gen === _.gen;
          }
          function u() {
            e._clearCache(), h._clearCache(), d._clearCache();
          }
        },
        /* 6 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.XRefParseException = o.XRefEntryException = o.ParserEOFException = o.MissingDataException = o.DocStats = void 0, o.collectActions = X, o.encodeToXmlString = R, o.escapePDFName = Y, o.getArrayLookupTableFactory = e, o.getInheritableProperty = g, o.getLookupTableFactory = h, o.getNewAnnotationsMap = U, o.isWhiteSpace = b, o.log2 = l, o.numberToString = f, o.parseXFAPath = A, o.readInt8 = u, o.readUint16 = w, o.readUint32 = _, o.recoverJsURL = x, o.toRomanNumerals = i, o.validateCSSFont = k;
          var t = C(2), a = C(5), v = C(7);
          function h(O) {
            let S;
            return function() {
              return O && (S = /* @__PURE__ */ Object.create(null), O(S), O = null), S;
            };
          }
          function e(O) {
            let S;
            return function() {
              if (O) {
                let F = O();
                O = null, S = /* @__PURE__ */ Object.create(null);
                for (let T = 0, I = F.length; T < I; T += 2)
                  S[F[T]] = F[T + 1];
                F = null;
              }
              return S;
            };
          }
          class y extends t.BaseException {
            constructor(S, F) {
              super(`Missing data [${S}, ${F})`, "MissingDataException"), this.begin = S, this.end = F;
            }
          }
          o.MissingDataException = y;
          class c extends t.BaseException {
            constructor(S) {
              super(S, "ParserEOFException");
            }
          }
          o.ParserEOFException = c;
          class d extends t.BaseException {
            constructor(S) {
              super(S, "XRefEntryException");
            }
          }
          o.XRefEntryException = d;
          class p extends t.BaseException {
            constructor(S) {
              super(S, "XRefParseException");
            }
          }
          o.XRefParseException = p;
          class m {
            constructor(S) {
              this._handler = S, this._streamTypes = /* @__PURE__ */ new Set(), this._fontTypes = /* @__PURE__ */ new Set();
            }
            _send() {
              const S = /* @__PURE__ */ Object.create(null), F = /* @__PURE__ */ Object.create(null);
              for (const T of this._streamTypes)
                S[T] = !0;
              for (const T of this._fontTypes)
                F[T] = !0;
              this._handler.send("DocStats", {
                streamTypes: S,
                fontTypes: F
              });
            }
            addStreamType(S) {
              this._streamTypes.has(S) || (this._streamTypes.add(S), this._send());
            }
            addFontType(S) {
              this._fontTypes.has(S) || (this._fontTypes.add(S), this._send());
            }
          }
          o.DocStats = m;
          function g({
            dict: O,
            key: S,
            getArray: F = !1,
            stopWhenFound: T = !0
          }) {
            let I;
            const M = new a.RefSet();
            for (; O instanceof a.Dict && !(O.objId && M.has(O.objId)); ) {
              O.objId && M.put(O.objId);
              const V = F ? O.getArray(S) : O.get(S);
              if (V !== void 0) {
                if (T)
                  return V;
                I || (I = []), I.push(V);
              }
              O = O.get("Parent");
            }
            return I;
          }
          const n = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
          function i(O, S = !1) {
            (0, t.assert)(Number.isInteger(O) && O > 0, "The number should be a positive integer.");
            const F = [];
            let T;
            for (; O >= 1e3; )
              O -= 1e3, F.push("M");
            T = O / 100 | 0, O %= 100, F.push(n[T]), T = O / 10 | 0, O %= 10, F.push(n[10 + T]), F.push(n[20 + O]);
            const I = F.join("");
            return S ? I.toLowerCase() : I;
          }
          function l(O) {
            return O <= 0 ? 0 : Math.ceil(Math.log2(O));
          }
          function u(O, S) {
            return O[S] << 24 >> 24;
          }
          function w(O, S) {
            return O[S] << 8 | O[S + 1];
          }
          function _(O, S) {
            return (O[S] << 24 | O[S + 1] << 16 | O[S + 2] << 8 | O[S + 3]) >>> 0;
          }
          function b(O) {
            return O === 32 || O === 9 || O === 13 || O === 10;
          }
          function A(O) {
            const S = /(.+)\[(\d+)\]$/;
            return O.split(".").map((F) => {
              const T = F.match(S);
              return T ? {
                name: T[1],
                pos: parseInt(T[2], 10)
              } : {
                name: F,
                pos: 0
              };
            });
          }
          function Y(O) {
            const S = [];
            let F = 0;
            for (let T = 0, I = O.length; T < I; T++) {
              const M = O.charCodeAt(T);
              (M < 33 || M > 126 || M === 35 || M === 40 || M === 41 || M === 60 || M === 62 || M === 91 || M === 93 || M === 123 || M === 125 || M === 47 || M === 37) && (F < T && S.push(O.substring(F, T)), S.push(`#${M.toString(16)}`), F = T + 1);
            }
            return S.length === 0 ? O : (F < O.length && S.push(O.substring(F, O.length)), S.join(""));
          }
          function j(O, S, F, T) {
            if (!O)
              return;
            let I = null;
            if (O instanceof a.Ref) {
              if (T.has(O))
                return;
              I = O, T.put(I), O = S.fetch(O);
            }
            if (Array.isArray(O))
              for (const M of O)
                j(M, S, F, T);
            else if (O instanceof a.Dict) {
              if ((0, a.isName)(O.get("S"), "JavaScript")) {
                const M = O.get("JS");
                let V;
                M instanceof v.BaseStream ? V = M.getString() : typeof M == "string" && (V = M), V = V && (0, t.stringToPDFString)(V).replace(/\u0000/g, ""), V && F.push(V);
              }
              j(O.getRaw("Next"), S, F, T);
            }
            I && T.remove(I);
          }
          function X(O, S, F) {
            const T = /* @__PURE__ */ Object.create(null), I = g({
              dict: S,
              key: "AA",
              stopWhenFound: !1
            });
            if (I)
              for (let M = I.length - 1; M >= 0; M--) {
                const V = I[M];
                if (V instanceof a.Dict)
                  for (const J of V.getKeys()) {
                    const W = F[J];
                    if (!W)
                      continue;
                    const z = V.getRaw(J), G = new a.RefSet(), L = [];
                    j(z, O, L, G), L.length > 0 && (T[W] = L);
                  }
              }
            if (S.has("A")) {
              const M = S.get("A"), V = new a.RefSet(), J = [];
              j(M, O, J, V), J.length > 0 && (T.Action = J);
            }
            return (0, t.objectSize)(T) > 0 ? T : null;
          }
          const B = {
            60: "&lt;",
            62: "&gt;",
            38: "&amp;",
            34: "&quot;",
            39: "&apos;"
          };
          function R(O) {
            const S = [];
            let F = 0;
            for (let T = 0, I = O.length; T < I; T++) {
              const M = O.codePointAt(T);
              if (32 <= M && M <= 126) {
                const V = B[M];
                V && (F < T && S.push(O.substring(F, T)), S.push(V), F = T + 1);
              } else
                F < T && S.push(O.substring(F, T)), S.push(`&#x${M.toString(16).toUpperCase()};`), M > 55295 && (M < 57344 || M > 65533) && T++, F = T + 1;
            }
            return S.length === 0 ? O : (F < O.length && S.push(O.substring(F, O.length)), S.join(""));
          }
          function k(O) {
            const S = "14", F = "400", T = /* @__PURE__ */ new Set(["100", "200", "300", "400", "500", "600", "700", "800", "900", "1000", "normal", "bold", "bolder", "lighter"]), {
              fontFamily: I,
              fontWeight: M,
              italicAngle: V
            } = O;
            if (/^".*"$/.test(I)) {
              if (/[^\\]"/.test(I.slice(1, I.length - 1)))
                return (0, t.warn)(`XFA - FontFamily contains some unescaped ": ${I}.`), !1;
            } else if (/^'.*'$/.test(I)) {
              if (/[^\\]'/.test(I.slice(1, I.length - 1)))
                return (0, t.warn)(`XFA - FontFamily contains some unescaped ': ${I}.`), !1;
            } else
              for (const z of I.split(/[ \t]+/))
                if (/^(\d|(-(\d|-)))/.test(z) || !/^[\w-\\]+$/.test(z))
                  return (0, t.warn)(`XFA - FontFamily contains some invalid <custom-ident>: ${I}.`), !1;
            const J = M ? M.toString() : "";
            O.fontWeight = T.has(J) ? J : F;
            const W = parseFloat(V);
            return O.italicAngle = isNaN(W) || W < -90 || W > 90 ? S : V.toString(), !0;
          }
          function x(O) {
            const S = ["app.launchURL", "window.open", "xfa.host.gotoURL"], T = new RegExp("^\\s*(" + S.join("|").split(".").join("\\.") + `)\\((?:'|")([^'"]*)(?:'|")(?:,\\s*(\\w+)\\)|\\))`, "i").exec(O);
            if (T && T[2]) {
              const I = T[2];
              let M = !1;
              return T[3] === "true" && T[1] === "app.launchURL" && (M = !0), {
                url: I,
                newWindow: M
              };
            }
            return null;
          }
          function f(O) {
            if (Number.isInteger(O))
              return O.toString();
            const S = Math.round(O * 100);
            return S % 100 === 0 ? (S / 100).toString() : S % 10 === 0 ? O.toFixed(1) : O.toFixed(2);
          }
          function U(O) {
            if (!O)
              return null;
            const S = /* @__PURE__ */ new Map();
            for (const [F, T] of O) {
              if (!F.startsWith(t.AnnotationEditorPrefix))
                continue;
              let I = S.get(T.pageIndex);
              I || (I = [], S.set(T.pageIndex, I)), I.push(T);
            }
            return S.size > 0 ? S : null;
          }
        },
        /* 7 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.BaseStream = void 0;
          var t = C(2);
          class a {
            constructor() {
              this.constructor === a && (0, t.unreachable)("Cannot initialize BaseStream.");
            }
            get length() {
              (0, t.unreachable)("Abstract getter `length` accessed");
            }
            get isEmpty() {
              (0, t.unreachable)("Abstract getter `isEmpty` accessed");
            }
            get isDataLoaded() {
              return (0, t.shadow)(this, "isDataLoaded", !0);
            }
            getByte() {
              (0, t.unreachable)("Abstract method `getByte` called");
            }
            getBytes(h) {
              (0, t.unreachable)("Abstract method `getBytes` called");
            }
            peekByte() {
              const h = this.getByte();
              return h !== -1 && this.pos--, h;
            }
            peekBytes(h) {
              const e = this.getBytes(h);
              return this.pos -= e.length, e;
            }
            getUint16() {
              const h = this.getByte(), e = this.getByte();
              return h === -1 || e === -1 ? -1 : (h << 8) + e;
            }
            getInt32() {
              const h = this.getByte(), e = this.getByte(), y = this.getByte(), c = this.getByte();
              return (h << 24) + (e << 16) + (y << 8) + c;
            }
            getByteRange(h, e) {
              (0, t.unreachable)("Abstract method `getByteRange` called");
            }
            getString(h) {
              return (0, t.bytesToString)(this.getBytes(h));
            }
            skip(h) {
              this.pos += h || 1;
            }
            reset() {
              (0, t.unreachable)("Abstract method `reset` called");
            }
            moveStart() {
              (0, t.unreachable)("Abstract method `moveStart` called");
            }
            makeSubStream(h, e, y = null) {
              (0, t.unreachable)("Abstract method `makeSubStream` called");
            }
            getBaseStreams() {
              return null;
            }
          }
          o.BaseStream = a;
        },
        /* 8 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.NetworkPdfManager = o.LocalPdfManager = void 0;
          var t = C(2), a = C(9), v = C(6), h = C(11), e = C(10);
          function y(m) {
            if (m) {
              const g = (0, t.createValidAbsoluteUrl)(m);
              if (g)
                return g.href;
              (0, t.warn)(`Invalid absolute docBaseUrl: "${m}".`);
            }
            return null;
          }
          class c {
            constructor() {
              this.constructor === c && (0, t.unreachable)("Cannot initialize BasePdfManager.");
            }
            get docId() {
              return this._docId;
            }
            get password() {
              return this._password;
            }
            get docBaseUrl() {
              const g = this.pdfDocument.catalog;
              return (0, t.shadow)(this, "docBaseUrl", g.baseUrl || this._docBaseUrl);
            }
            onLoadedStream() {
              (0, t.unreachable)("Abstract method `onLoadedStream` called");
            }
            ensureDoc(g, n) {
              return this.ensure(this.pdfDocument, g, n);
            }
            ensureXRef(g, n) {
              return this.ensure(this.pdfDocument.xref, g, n);
            }
            ensureCatalog(g, n) {
              return this.ensure(this.pdfDocument.catalog, g, n);
            }
            getPage(g) {
              return this.pdfDocument.getPage(g);
            }
            fontFallback(g, n) {
              return this.pdfDocument.fontFallback(g, n);
            }
            loadXfaFonts(g, n) {
              return this.pdfDocument.loadXfaFonts(g, n);
            }
            loadXfaImages() {
              return this.pdfDocument.loadXfaImages();
            }
            serializeXfaData(g) {
              return this.pdfDocument.serializeXfaData(g);
            }
            cleanup(g = !1) {
              return this.pdfDocument.cleanup(g);
            }
            async ensure(g, n, i) {
              (0, t.unreachable)("Abstract method `ensure` called");
            }
            requestRange(g, n) {
              (0, t.unreachable)("Abstract method `requestRange` called");
            }
            requestLoadedStream() {
              (0, t.unreachable)("Abstract method `requestLoadedStream` called");
            }
            sendProgressiveData(g) {
              (0, t.unreachable)("Abstract method `sendProgressiveData` called");
            }
            updatePassword(g) {
              this._password = g;
            }
            terminate(g) {
              (0, t.unreachable)("Abstract method `terminate` called");
            }
          }
          class d extends c {
            constructor(g, n, i, l, u, w, _) {
              super(), this._docId = g, this._password = i, this._docBaseUrl = y(_), this.msgHandler = l, this.evaluatorOptions = u, this.enableXfa = w;
              const b = new e.Stream(n);
              this.pdfDocument = new h.PDFDocument(this, b), this._loadedStreamPromise = Promise.resolve(b);
            }
            async ensure(g, n, i) {
              const l = g[n];
              return typeof l == "function" ? l.apply(g, i) : l;
            }
            requestRange(g, n) {
              return Promise.resolve();
            }
            requestLoadedStream() {
            }
            onLoadedStream() {
              return this._loadedStreamPromise;
            }
            terminate(g) {
            }
          }
          o.LocalPdfManager = d;
          class p extends c {
            constructor(g, n, i, l, u, w) {
              super(), this._docId = g, this._password = i.password, this._docBaseUrl = y(w), this.msgHandler = i.msgHandler, this.evaluatorOptions = l, this.enableXfa = u, this.streamManager = new a.ChunkedStreamManager(n, {
                msgHandler: i.msgHandler,
                length: i.length,
                disableAutoFetch: i.disableAutoFetch,
                rangeChunkSize: i.rangeChunkSize
              }), this.pdfDocument = new h.PDFDocument(this, this.streamManager.getStream());
            }
            async ensure(g, n, i) {
              try {
                const l = g[n];
                return typeof l == "function" ? l.apply(g, i) : l;
              } catch (l) {
                if (!(l instanceof v.MissingDataException))
                  throw l;
                return await this.requestRange(l.begin, l.end), this.ensure(g, n, i);
              }
            }
            requestRange(g, n) {
              return this.streamManager.requestRange(g, n);
            }
            requestLoadedStream() {
              this.streamManager.requestAllChunks();
            }
            sendProgressiveData(g) {
              this.streamManager.onReceiveData({
                chunk: g
              });
            }
            onLoadedStream() {
              return this.streamManager.onLoadedStream();
            }
            terminate(g) {
              this.streamManager.abort(g);
            }
          }
          o.NetworkPdfManager = p;
        },
        /* 9 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.ChunkedStreamManager = o.ChunkedStream = void 0;
          var t = C(2), a = C(6), v = C(10);
          class h extends v.Stream {
            constructor(c, d, p) {
              super(new Uint8Array(c), 0, c, null), this.chunkSize = d, this._loadedChunks = /* @__PURE__ */ new Set(), this.numChunks = Math.ceil(c / d), this.manager = p, this.progressiveDataLength = 0, this.lastSuccessfulEnsureByteChunk = -1;
            }
            getMissingChunks() {
              const c = [];
              for (let d = 0, p = this.numChunks; d < p; ++d)
                this._loadedChunks.has(d) || c.push(d);
              return c;
            }
            get numChunksLoaded() {
              return this._loadedChunks.size;
            }
            get isDataLoaded() {
              return this.numChunksLoaded === this.numChunks;
            }
            onReceiveData(c, d) {
              const p = this.chunkSize;
              if (c % p !== 0)
                throw new Error(`Bad begin offset: ${c}`);
              const m = c + d.byteLength;
              if (m % p !== 0 && m !== this.bytes.length)
                throw new Error(`Bad end offset: ${m}`);
              this.bytes.set(new Uint8Array(d), c);
              const g = Math.floor(c / p), n = Math.floor((m - 1) / p) + 1;
              for (let i = g; i < n; ++i)
                this._loadedChunks.add(i);
            }
            onReceiveProgressiveData(c) {
              let d = this.progressiveDataLength;
              const p = Math.floor(d / this.chunkSize);
              this.bytes.set(new Uint8Array(c), d), d += c.byteLength, this.progressiveDataLength = d;
              const m = d >= this.end ? this.numChunks : Math.floor(d / this.chunkSize);
              for (let g = p; g < m; ++g)
                this._loadedChunks.add(g);
            }
            ensureByte(c) {
              if (c < this.progressiveDataLength)
                return;
              const d = Math.floor(c / this.chunkSize);
              if (!(d > this.numChunks) && d !== this.lastSuccessfulEnsureByteChunk) {
                if (!this._loadedChunks.has(d))
                  throw new a.MissingDataException(c, c + 1);
                this.lastSuccessfulEnsureByteChunk = d;
              }
            }
            ensureRange(c, d) {
              if (c >= d || d <= this.progressiveDataLength)
                return;
              const p = Math.floor(c / this.chunkSize);
              if (p > this.numChunks)
                return;
              const m = Math.min(Math.floor((d - 1) / this.chunkSize) + 1, this.numChunks);
              for (let g = p; g < m; ++g)
                if (!this._loadedChunks.has(g))
                  throw new a.MissingDataException(c, d);
            }
            nextEmptyChunk(c) {
              const d = this.numChunks;
              for (let p = 0; p < d; ++p) {
                const m = (c + p) % d;
                if (!this._loadedChunks.has(m))
                  return m;
              }
              return null;
            }
            hasChunk(c) {
              return this._loadedChunks.has(c);
            }
            getByte() {
              const c = this.pos;
              return c >= this.end ? -1 : (c >= this.progressiveDataLength && this.ensureByte(c), this.bytes[this.pos++]);
            }
            getBytes(c) {
              const d = this.bytes, p = this.pos, m = this.end;
              if (!c)
                return m > this.progressiveDataLength && this.ensureRange(p, m), d.subarray(p, m);
              let g = p + c;
              return g > m && (g = m), g > this.progressiveDataLength && this.ensureRange(p, g), this.pos = g, d.subarray(p, g);
            }
            getByteRange(c, d) {
              return c < 0 && (c = 0), d > this.end && (d = this.end), d > this.progressiveDataLength && this.ensureRange(c, d), this.bytes.subarray(c, d);
            }
            makeSubStream(c, d, p = null) {
              d ? c + d > this.progressiveDataLength && this.ensureRange(c, c + d) : c >= this.progressiveDataLength && this.ensureByte(c);
              function m() {
              }
              m.prototype = Object.create(this), m.prototype.getMissingChunks = function() {
                const n = this.chunkSize, i = Math.floor(this.start / n), l = Math.floor((this.end - 1) / n) + 1, u = [];
                for (let w = i; w < l; ++w)
                  this._loadedChunks.has(w) || u.push(w);
                return u;
              }, Object.defineProperty(m.prototype, "isDataLoaded", {
                get() {
                  return this.numChunksLoaded === this.numChunks ? !0 : this.getMissingChunks().length === 0;
                },
                configurable: !0
              });
              const g = new m();
              return g.pos = g.start = c, g.end = c + d || this.end, g.dict = p, g;
            }
            getBaseStreams() {
              return [this];
            }
          }
          o.ChunkedStream = h;
          class e {
            constructor(c, d) {
              this.length = d.length, this.chunkSize = d.rangeChunkSize, this.stream = new h(this.length, this.chunkSize, this), this.pdfNetworkStream = c, this.disableAutoFetch = d.disableAutoFetch, this.msgHandler = d.msgHandler, this.currRequestId = 0, this._chunksNeededByRequest = /* @__PURE__ */ new Map(), this._requestsByChunk = /* @__PURE__ */ new Map(), this._promisesByRequest = /* @__PURE__ */ new Map(), this.progressiveDataLength = 0, this.aborted = !1, this._loadedStreamCapability = (0, t.createPromiseCapability)();
            }
            onLoadedStream() {
              return this._loadedStreamCapability.promise;
            }
            sendRequest(c, d) {
              const p = this.pdfNetworkStream.getRangeReader(c, d);
              p.isStreamingSupported || (p.onProgress = this.onProgress.bind(this));
              let m = [], g = 0;
              return new Promise((n, i) => {
                const l = (u) => {
                  try {
                    if (!u.done) {
                      const _ = u.value;
                      m.push(_), g += (0, t.arrayByteLength)(_), p.isStreamingSupported && this.onProgress({
                        loaded: g
                      }), p.read().then(l, i);
                      return;
                    }
                    const w = (0, t.arraysToBytes)(m);
                    m = null, n(w);
                  } catch (w) {
                    i(w);
                  }
                };
                p.read().then(l, i);
              }).then((n) => {
                this.aborted || this.onReceiveData({
                  chunk: n,
                  begin: c
                });
              });
            }
            requestAllChunks() {
              const c = this.stream.getMissingChunks();
              return this._requestChunks(c), this._loadedStreamCapability.promise;
            }
            _requestChunks(c) {
              const d = this.currRequestId++, p = /* @__PURE__ */ new Set();
              this._chunksNeededByRequest.set(d, p);
              for (const n of c)
                this.stream.hasChunk(n) || p.add(n);
              if (p.size === 0)
                return Promise.resolve();
              const m = (0, t.createPromiseCapability)();
              this._promisesByRequest.set(d, m);
              const g = [];
              for (const n of p) {
                let i = this._requestsByChunk.get(n);
                i || (i = [], this._requestsByChunk.set(n, i), g.push(n)), i.push(d);
              }
              if (g.length > 0) {
                const n = this.groupChunks(g);
                for (const i of n) {
                  const l = i.beginChunk * this.chunkSize, u = Math.min(i.endChunk * this.chunkSize, this.length);
                  this.sendRequest(l, u).catch(m.reject);
                }
              }
              return m.promise.catch((n) => {
                if (!this.aborted)
                  throw n;
              });
            }
            getStream() {
              return this.stream;
            }
            requestRange(c, d) {
              d = Math.min(d, this.length);
              const p = this.getBeginChunk(c), m = this.getEndChunk(d), g = [];
              for (let n = p; n < m; ++n)
                g.push(n);
              return this._requestChunks(g);
            }
            requestRanges(c = []) {
              const d = [];
              for (const p of c) {
                const m = this.getBeginChunk(p.begin), g = this.getEndChunk(p.end);
                for (let n = m; n < g; ++n)
                  d.includes(n) || d.push(n);
              }
              return d.sort(function(p, m) {
                return p - m;
              }), this._requestChunks(d);
            }
            groupChunks(c) {
              const d = [];
              let p = -1, m = -1;
              for (let g = 0, n = c.length; g < n; ++g) {
                const i = c[g];
                p < 0 && (p = i), m >= 0 && m + 1 !== i && (d.push({
                  beginChunk: p,
                  endChunk: m + 1
                }), p = i), g + 1 === c.length && d.push({
                  beginChunk: p,
                  endChunk: i + 1
                }), m = i;
              }
              return d;
            }
            onProgress(c) {
              this.msgHandler.send("DocProgress", {
                loaded: this.stream.numChunksLoaded * this.chunkSize + c.loaded,
                total: this.length
              });
            }
            onReceiveData(c) {
              const d = c.chunk, p = c.begin === void 0, m = p ? this.progressiveDataLength : c.begin, g = m + d.byteLength, n = Math.floor(m / this.chunkSize), i = g < this.length ? Math.floor(g / this.chunkSize) : Math.ceil(g / this.chunkSize);
              p ? (this.stream.onReceiveProgressiveData(d), this.progressiveDataLength = g) : this.stream.onReceiveData(m, d), this.stream.isDataLoaded && this._loadedStreamCapability.resolve(this.stream);
              const l = [];
              for (let u = n; u < i; ++u) {
                const w = this._requestsByChunk.get(u);
                if (w) {
                  this._requestsByChunk.delete(u);
                  for (const _ of w) {
                    const b = this._chunksNeededByRequest.get(_);
                    b.has(u) && b.delete(u), !(b.size > 0) && l.push(_);
                  }
                }
              }
              if (!this.disableAutoFetch && this._requestsByChunk.size === 0) {
                let u;
                if (this.stream.numChunksLoaded === 1) {
                  const w = this.stream.numChunks - 1;
                  this.stream.hasChunk(w) || (u = w);
                } else
                  u = this.stream.nextEmptyChunk(i);
                Number.isInteger(u) && this._requestChunks([u]);
              }
              for (const u of l) {
                const w = this._promisesByRequest.get(u);
                this._promisesByRequest.delete(u), w.resolve();
              }
              this.msgHandler.send("DocProgress", {
                loaded: this.stream.numChunksLoaded * this.chunkSize,
                total: this.length
              });
            }
            onError(c) {
              this._loadedStreamCapability.reject(c);
            }
            getBeginChunk(c) {
              return Math.floor(c / this.chunkSize);
            }
            getEndChunk(c) {
              return Math.floor((c - 1) / this.chunkSize) + 1;
            }
            abort(c) {
              this.aborted = !0, this.pdfNetworkStream && this.pdfNetworkStream.cancelAllRequests(c);
              for (const d of this._promisesByRequest.values())
                d.reject(c);
            }
          }
          o.ChunkedStreamManager = e;
        },
        /* 10 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.StringStream = o.Stream = o.NullStream = void 0;
          var t = C(7), a = C(2);
          class v extends t.BaseStream {
            constructor(c, d, p, m) {
              super(), this.bytes = c instanceof Uint8Array ? c : new Uint8Array(c), this.start = d || 0, this.pos = this.start, this.end = d + p || this.bytes.length, this.dict = m;
            }
            get length() {
              return this.end - this.start;
            }
            get isEmpty() {
              return this.length === 0;
            }
            getByte() {
              return this.pos >= this.end ? -1 : this.bytes[this.pos++];
            }
            getBytes(c) {
              const d = this.bytes, p = this.pos, m = this.end;
              if (!c)
                return d.subarray(p, m);
              let g = p + c;
              return g > m && (g = m), this.pos = g, d.subarray(p, g);
            }
            getByteRange(c, d) {
              return c < 0 && (c = 0), d > this.end && (d = this.end), this.bytes.subarray(c, d);
            }
            reset() {
              this.pos = this.start;
            }
            moveStart() {
              this.start = this.pos;
            }
            makeSubStream(c, d, p = null) {
              return new v(this.bytes.buffer, c, d, p);
            }
          }
          o.Stream = v;
          class h extends v {
            constructor(c) {
              super((0, a.stringToBytes)(c));
            }
          }
          o.StringStream = h;
          class e extends v {
            constructor() {
              super(new Uint8Array(0));
            }
          }
          o.NullStream = e;
        },
        /* 11 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.Page = o.PDFDocument = void 0;
          var t = C(12), a = C(2), v = C(6), h = C(5), e = C(51), y = C(7), c = C(67), d = C(69), p = C(71), m = C(100), g = C(17), n = C(10), i = C(75), l = C(62), u = C(15), w = C(19), _ = C(74), b = C(65), A = C(76), Y = C(101);
          const j = 1, X = [0, 0, 612, 792];
          class B {
            constructor({
              pdfManager: I,
              xref: M,
              pageIndex: V,
              pageDict: J,
              ref: W,
              globalIdFactory: z,
              fontCache: G,
              builtInCMapCache: L,
              standardFontDataCache: K,
              globalImageCache: te,
              nonBlendModesSet: se,
              xfaFactory: q
            }) {
              this.pdfManager = I, this.pageIndex = V, this.pageDict = J, this.xref = M, this.ref = W, this.fontCache = G, this.builtInCMapCache = L, this.standardFontDataCache = K, this.globalImageCache = te, this.nonBlendModesSet = se, this.evaluatorOptions = I.evaluatorOptions, this.resourcesPromise = null, this.xfaFactory = q;
              const N = {
                obj: 0
              };
              this._localIdFactory = class extends z {
                static createObjId() {
                  return `p${V}_${++N.obj}`;
                }
                static getPageObjId() {
                  return `page${W.toString()}`;
                }
              };
            }
            _getInheritableProperty(I, M = !1) {
              const V = (0, v.getInheritableProperty)({
                dict: this.pageDict,
                key: I,
                getArray: M,
                stopWhenFound: !1
              });
              return Array.isArray(V) ? V.length === 1 || !(V[0] instanceof h.Dict) ? V[0] : h.Dict.merge({
                xref: this.xref,
                dictArray: V
              }) : V;
            }
            get content() {
              return this.pageDict.getArray("Contents");
            }
            get resources() {
              const I = this._getInheritableProperty("Resources");
              return (0, a.shadow)(this, "resources", I instanceof h.Dict ? I : h.Dict.empty);
            }
            _getBoundingBox(I) {
              if (this.xfaData)
                return this.xfaData.bbox;
              const M = this._getInheritableProperty(I, !0);
              if (Array.isArray(M) && M.length === 4) {
                if (M[2] - M[0] !== 0 && M[3] - M[1] !== 0)
                  return M;
                (0, a.warn)(`Empty /${I} entry.`);
              }
              return null;
            }
            get mediaBox() {
              return (0, a.shadow)(this, "mediaBox", this._getBoundingBox("MediaBox") || X);
            }
            get cropBox() {
              return (0, a.shadow)(this, "cropBox", this._getBoundingBox("CropBox") || this.mediaBox);
            }
            get userUnit() {
              let I = this.pageDict.get("UserUnit");
              return (typeof I != "number" || I <= 0) && (I = j), (0, a.shadow)(this, "userUnit", I);
            }
            get view() {
              const {
                cropBox: I,
                mediaBox: M
              } = this;
              let V;
              if (I === M || (0, a.isArrayEqual)(I, M))
                V = M;
              else {
                const J = a.Util.intersect(I, M);
                J && J[2] - J[0] !== 0 && J[3] - J[1] !== 0 ? V = J : (0, a.warn)("Empty /CropBox and /MediaBox intersection.");
              }
              return (0, a.shadow)(this, "view", V || M);
            }
            get rotate() {
              let I = this._getInheritableProperty("Rotate") || 0;
              return I % 90 !== 0 ? I = 0 : I >= 360 ? I %= 360 : I < 0 && (I = (I % 360 + 360) % 360), (0, a.shadow)(this, "rotate", I);
            }
            _onSubStreamError(I, M, V) {
              if (this.evaluatorOptions.ignoreErrors) {
                I.send("UnsupportedFeature", {
                  featureId: a.UNSUPPORTED_FEATURES.errorContentSubStream
                }), (0, a.warn)(`getContentStream - ignoring sub-stream (${V}): "${M}".`);
                return;
              }
              throw M;
            }
            getContentStream(I) {
              return this.pdfManager.ensure(this, "content").then((M) => M instanceof y.BaseStream ? M : Array.isArray(M) ? new w.StreamsSequenceStream(M, this._onSubStreamError.bind(this, I)) : new n.NullStream());
            }
            get xfaData() {
              return (0, a.shadow)(this, "xfaData", this.xfaFactory ? {
                bbox: this.xfaFactory.getBoundingBox(this.pageIndex)
              } : null);
            }
            async saveNewAnnotations(I, M, V) {
              if (this.xfaFactory)
                throw new Error("XFA: Cannot save new annotations.");
              const J = new u.PartialEvaluator({
                xref: this.xref,
                handler: I,
                pageIndex: this.pageIndex,
                idFactory: this._localIdFactory,
                fontCache: this.fontCache,
                builtInCMapCache: this.builtInCMapCache,
                standardFontDataCache: this.standardFontDataCache,
                globalImageCache: this.globalImageCache,
                options: this.evaluatorOptions
              }), W = this.pageDict, z = this.annotations.slice(), G = await t.AnnotationFactory.saveNewAnnotations(J, M, V);
              for (const {
                ref: q
              } of G.annotations)
                z.push(q);
              const L = W.get("Annots");
              W.set("Annots", z);
              const K = [];
              let te = null;
              this.xref.encrypt && (te = this.xref.encrypt.createCipherTransform(this.ref.num, this.ref.gen)), (0, b.writeObject)(this.ref, W, K, te), L && W.set("Annots", L);
              const se = G.dependencies;
              return se.push({
                ref: this.ref,
                data: K.join("")
              }, ...G.annotations), se;
            }
            save(I, M, V) {
              const J = new u.PartialEvaluator({
                xref: this.xref,
                handler: I,
                pageIndex: this.pageIndex,
                idFactory: this._localIdFactory,
                fontCache: this.fontCache,
                builtInCMapCache: this.builtInCMapCache,
                standardFontDataCache: this.standardFontDataCache,
                globalImageCache: this.globalImageCache,
                options: this.evaluatorOptions
              });
              return this._parsedAnnotations.then(function(W) {
                const z = [];
                for (const G of W)
                  G.mustBePrinted(V) && z.push(G.save(J, M, V).catch(function(L) {
                    return (0, a.warn)(`save - ignoring annotation data during "${M.name}" task: "${L}".`), null;
                  }));
                return Promise.all(z).then(function(G) {
                  return G.filter((L) => !!L);
                });
              });
            }
            loadResources(I) {
              return this.resourcesPromise || (this.resourcesPromise = this.pdfManager.ensure(this, "resources")), this.resourcesPromise.then(() => new i.ObjectLoader(this.resources, I, this.xref).load());
            }
            getOperatorList({
              handler: I,
              sink: M,
              task: V,
              intent: J,
              cacheKey: W,
              annotationStorage: z = null
            }) {
              const G = this.getContentStream(I), L = this.loadResources(["ColorSpace", "ExtGState", "Font", "Pattern", "Properties", "Shading", "XObject"]), K = new u.PartialEvaluator({
                xref: this.xref,
                handler: I,
                pageIndex: this.pageIndex,
                idFactory: this._localIdFactory,
                fontCache: this.fontCache,
                builtInCMapCache: this.builtInCMapCache,
                standardFontDataCache: this.standardFontDataCache,
                globalImageCache: this.globalImageCache,
                options: this.evaluatorOptions
              }), te = this.xfaFactory ? null : (0, v.getNewAnnotationsMap)(z);
              let se = Promise.resolve(null);
              if (te) {
                const Q = te.get(this.pageIndex);
                Q && (se = t.AnnotationFactory.printNewAnnotations(K, V, Q));
              }
              const N = Promise.all([G, L]).then(([Q]) => {
                const D = new l.OperatorList(J, M);
                return I.send("StartRenderPage", {
                  transparency: K.hasBlendModes(this.resources, this.nonBlendModesSet),
                  pageIndex: this.pageIndex,
                  cacheKey: W
                }), K.getOperatorList({
                  stream: Q,
                  task: V,
                  resources: this.resources,
                  operatorList: D
                }).then(function() {
                  return D;
                });
              });
              return Promise.all([N, this._parsedAnnotations, se]).then(function([Q, D, ne]) {
                if (ne && (D = D.concat(ne)), D.length === 0 || J & a.RenderingIntentFlag.ANNOTATIONS_DISABLE)
                  return Q.flush(!0), {
                    length: Q.totalLength
                  };
                const oe = !!(J & a.RenderingIntentFlag.ANNOTATIONS_FORMS), ee = !!(J & a.RenderingIntentFlag.ANY), $ = !!(J & a.RenderingIntentFlag.DISPLAY), E = !!(J & a.RenderingIntentFlag.PRINT), H = [];
                for (const ie of D)
                  (ee || $ && ie.mustBeViewed(z) || E && ie.mustBePrinted(z)) && H.push(ie.getOperatorList(K, V, J, oe, z).catch(function(ue) {
                    return (0, a.warn)(`getOperatorList - ignoring annotation data during "${V.name}" task: "${ue}".`), null;
                  }));
                return Promise.all(H).then(function(ie) {
                  let ue = !1, fe = !1;
                  for (const {
                    opList: de,
                    separateForm: pe,
                    separateCanvas: xe
                  } of ie)
                    Q.addOpList(de), pe && (ue = pe), xe && (fe = xe);
                  return Q.flush(!0, {
                    form: ue,
                    canvas: fe
                  }), {
                    length: Q.totalLength
                  };
                });
              });
            }
            extractTextContent({
              handler: I,
              task: M,
              includeMarkedContent: V,
              sink: J,
              combineTextItems: W
            }) {
              const z = this.getContentStream(I), G = this.loadResources(["ExtGState", "Font", "Properties", "XObject"]);
              return Promise.all([z, G]).then(([K]) => new u.PartialEvaluator({
                xref: this.xref,
                handler: I,
                pageIndex: this.pageIndex,
                idFactory: this._localIdFactory,
                fontCache: this.fontCache,
                builtInCMapCache: this.builtInCMapCache,
                standardFontDataCache: this.standardFontDataCache,
                globalImageCache: this.globalImageCache,
                options: this.evaluatorOptions
              }).getTextContent({
                stream: K,
                task: M,
                resources: this.resources,
                includeMarkedContent: V,
                combineTextItems: W,
                sink: J,
                viewBox: this.view
              }));
            }
            async getStructTree() {
              const I = await this.pdfManager.ensureCatalog("structTreeRoot");
              return I ? (await this.pdfManager.ensure(this, "_parseStructTree", [I])).serializable : null;
            }
            _parseStructTree(I) {
              const M = new _.StructTreePage(I, this.pageDict);
              return M.parse(), M;
            }
            async getAnnotationsData(I, M, V) {
              const J = await this._parsedAnnotations;
              if (J.length === 0)
                return [];
              const W = [], z = [];
              let G;
              const L = !!(V & a.RenderingIntentFlag.ANY), K = !!(V & a.RenderingIntentFlag.DISPLAY), te = !!(V & a.RenderingIntentFlag.PRINT);
              for (const se of J) {
                const q = L || K && se.viewable;
                (q || te && se.printable) && z.push(se.data), se.hasTextContent && q && (G || (G = new u.PartialEvaluator({
                  xref: this.xref,
                  handler: I,
                  pageIndex: this.pageIndex,
                  idFactory: this._localIdFactory,
                  fontCache: this.fontCache,
                  builtInCMapCache: this.builtInCMapCache,
                  standardFontDataCache: this.standardFontDataCache,
                  globalImageCache: this.globalImageCache,
                  options: this.evaluatorOptions
                })), W.push(se.extractTextContent(G, M, this.view).catch(function(N) {
                  (0, a.warn)(`getAnnotationsData - ignoring textContent during "${M.name}" task: "${N}".`);
                })));
              }
              return await Promise.all(W), z;
            }
            get annotations() {
              const I = this._getInheritableProperty("Annots");
              return (0, a.shadow)(this, "annotations", Array.isArray(I) ? I : []);
            }
            get _parsedAnnotations() {
              const I = this.pdfManager.ensure(this, "annotations").then(() => {
                const M = [];
                for (const V of this.annotations)
                  M.push(t.AnnotationFactory.create(this.xref, V, this.pdfManager, this._localIdFactory, !1).catch(function(J) {
                    return (0, a.warn)(`_parsedAnnotations: "${J}".`), null;
                  }));
                return Promise.all(M).then(function(V) {
                  if (V.length === 0)
                    return V;
                  const J = [];
                  let W;
                  for (const z of V)
                    if (z) {
                      if (z instanceof t.PopupAnnotation) {
                        W || (W = []), W.push(z);
                        continue;
                      }
                      J.push(z);
                    }
                  return W && J.push(...W), J;
                });
              });
              return (0, a.shadow)(this, "_parsedAnnotations", I);
            }
            get jsActions() {
              const I = (0, v.collectActions)(this.xref, this.pageDict, a.PageActionEventType);
              return (0, a.shadow)(this, "jsActions", I);
            }
          }
          o.Page = B;
          const R = new Uint8Array([37, 80, 68, 70, 45]), k = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]), x = new Uint8Array([101, 110, 100, 111, 98, 106]), f = 1024, U = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", O = /^[1-9]\.\d$/;
          function S(T, I, M = 1024, V = !1) {
            const J = I.length, W = T.peekBytes(M), z = W.length - J;
            if (z <= 0)
              return !1;
            if (V) {
              const G = J - 1;
              let L = W.length - 1;
              for (; L >= G; ) {
                let K = 0;
                for (; K < J && W[L - K] === I[G - K]; )
                  K++;
                if (K >= J)
                  return T.pos += L - G, !0;
                L--;
              }
            } else {
              let G = 0;
              for (; G <= z; ) {
                let L = 0;
                for (; L < J && W[G + L] === I[L]; )
                  L++;
                if (L >= J)
                  return T.pos += G, !0;
                G++;
              }
            }
            return !1;
          }
          class F {
            constructor(I, M) {
              if (M.length <= 0)
                throw new a.InvalidPDFException("The PDF file is empty, i.e. its size is zero bytes.");
              this.pdfManager = I, this.stream = M, this.xref = new Y.XRef(M, I), this._pagePromises = /* @__PURE__ */ new Map(), this._version = null;
              const V = {
                font: 0
              };
              this._globalIdFactory = class {
                static getDocId() {
                  return `g_${I.docId}`;
                }
                static createFontId() {
                  return `f${++V.font}`;
                }
                static createObjId() {
                  (0, a.unreachable)("Abstract method `createObjId` called.");
                }
                static getPageObjId() {
                  (0, a.unreachable)("Abstract method `getPageObjId` called.");
                }
              };
            }
            parse(I) {
              this.xref.parse(I), this.catalog = new d.Catalog(this.pdfManager, this.xref), this.catalog.version && (this._version = this.catalog.version);
            }
            get linearization() {
              let I = null;
              try {
                I = g.Linearization.create(this.stream);
              } catch (M) {
                if (M instanceof v.MissingDataException)
                  throw M;
                (0, a.info)(M);
              }
              return (0, a.shadow)(this, "linearization", I);
            }
            get startXRef() {
              const I = this.stream;
              let M = 0;
              if (this.linearization)
                I.reset(), S(I, x) && (M = I.pos + 6 - I.start);
              else {
                const J = k.length;
                let W = !1, z = I.end;
                for (; !W && z > 0; )
                  z -= 1024 - J, z < 0 && (z = 0), I.pos = z, W = S(I, k, 1024, !0);
                if (W) {
                  I.skip(9);
                  let G;
                  do
                    G = I.getByte();
                  while ((0, v.isWhiteSpace)(G));
                  let L = "";
                  for (; G >= 32 && G <= 57; )
                    L += String.fromCharCode(G), G = I.getByte();
                  M = parseInt(L, 10), isNaN(M) && (M = 0);
                }
              }
              return (0, a.shadow)(this, "startXRef", M);
            }
            checkHeader() {
              const I = this.stream;
              if (I.reset(), !S(I, R))
                return;
              I.moveStart();
              const M = 12;
              let V = "", J;
              for (; (J = I.getByte()) > 32 && !(V.length >= M); )
                V += String.fromCharCode(J);
              this._version || (this._version = V.substring(5));
            }
            parseStartXRef() {
              this.xref.setStartXRef(this.startXRef);
            }
            get numPages() {
              let I = 0;
              return this.catalog.hasActualNumPages ? I = this.catalog.numPages : this.xfaFactory ? I = this.xfaFactory.getNumPages() : this.linearization ? I = this.linearization.numPages : I = this.catalog.numPages, (0, a.shadow)(this, "numPages", I);
            }
            _hasOnlyDocumentSignatures(I, M = 0) {
              return Array.isArray(I) ? I.every((J) => {
                if (J = this.xref.fetchIfRef(J), !(J instanceof h.Dict))
                  return !1;
                if (J.has("Kids"))
                  return ++M > 10 ? ((0, a.warn)("_hasOnlyDocumentSignatures: maximum recursion depth reached"), !1) : this._hasOnlyDocumentSignatures(J.get("Kids"), M);
                const W = (0, h.isName)(J.get("FT"), "Sig"), z = J.get("Rect"), G = Array.isArray(z) && z.every((L) => L === 0);
                return W && G;
              }) : !1;
            }
            get _xfaStreams() {
              const I = this.catalog.acroForm;
              if (!I)
                return null;
              const M = I.get("XFA"), V = {
                "xdp:xdp": "",
                template: "",
                datasets: "",
                config: "",
                connectionSet: "",
                localeSet: "",
                stylesheet: "",
                "/xdp:xdp": ""
              };
              if (M instanceof y.BaseStream && !M.isEmpty)
                return V["xdp:xdp"] = M, V;
              if (!Array.isArray(M) || M.length === 0)
                return null;
              for (let J = 0, W = M.length; J < W; J += 2) {
                let z;
                if (J === 0 ? z = "xdp:xdp" : J === W - 2 ? z = "/xdp:xdp" : z = M[J], !V.hasOwnProperty(z))
                  continue;
                const G = this.xref.fetchIfRef(M[J + 1]);
                !(G instanceof y.BaseStream) || G.isEmpty || (V[z] = G);
              }
              return V;
            }
            get xfaDatasets() {
              const I = this._xfaStreams;
              if (!I)
                return (0, a.shadow)(this, "xfaDatasets", null);
              for (const M of ["datasets", "xdp:xdp"]) {
                const V = I[M];
                if (V)
                  try {
                    const J = (0, a.stringToUTF8String)(V.getString()), W = {
                      [M]: J
                    };
                    return (0, a.shadow)(this, "xfaDatasets", new m.DatasetReader(W));
                  } catch {
                    (0, a.warn)("XFA - Invalid utf-8 string.");
                    break;
                  }
              }
              return (0, a.shadow)(this, "xfaDatasets", null);
            }
            get xfaData() {
              const I = this._xfaStreams;
              if (!I)
                return null;
              const M = /* @__PURE__ */ Object.create(null);
              for (const [V, J] of Object.entries(I))
                if (J)
                  try {
                    M[V] = (0, a.stringToUTF8String)(J.getString());
                  } catch {
                    return (0, a.warn)("XFA - Invalid utf-8 string."), null;
                  }
              return M;
            }
            get xfaFactory() {
              let I;
              return this.pdfManager.enableXfa && this.catalog.needsRendering && this.formInfo.hasXfa && !this.formInfo.hasAcroForm && (I = this.xfaData), (0, a.shadow)(this, "xfaFactory", I ? new A.XFAFactory(I) : null);
            }
            get isPureXfa() {
              return this.xfaFactory ? this.xfaFactory.isValid() : !1;
            }
            get htmlForXfa() {
              return this.xfaFactory ? this.xfaFactory.getPages() : null;
            }
            async loadXfaImages() {
              const I = await this.pdfManager.ensureCatalog("xfaImages");
              if (!I)
                return;
              const M = I.getKeys();
              await new i.ObjectLoader(I, M, this.xref).load();
              const J = /* @__PURE__ */ new Map();
              for (const W of M) {
                const z = I.get(W);
                z instanceof y.BaseStream && J.set(W, z.getBytes());
              }
              this.xfaFactory.setImages(J);
            }
            async loadXfaFonts(I, M) {
              const V = await this.pdfManager.ensureCatalog("acroForm");
              if (!V)
                return;
              const J = await V.getAsync("DR");
              if (!(J instanceof h.Dict))
                return;
              await new i.ObjectLoader(J, ["Font"], this.xref).load();
              const z = J.get("Font");
              if (!(z instanceof h.Dict))
                return;
              const G = Object.assign(/* @__PURE__ */ Object.create(null), this.pdfManager.evaluatorOptions);
              G.useSystemFonts = !1;
              const L = new u.PartialEvaluator({
                xref: this.xref,
                handler: I,
                pageIndex: -1,
                idFactory: this._globalIdFactory,
                fontCache: this.catalog.fontCache,
                builtInCMapCache: this.catalog.builtInCMapCache,
                standardFontDataCache: this.catalog.standardFontDataCache,
                options: G
              }), K = new l.OperatorList(), te = [], se = {
                get font() {
                  return te.at(-1);
                },
                set font(ne) {
                  te.push(ne);
                },
                clone() {
                  return this;
                }
              }, q = /* @__PURE__ */ new Map();
              z.forEach((ne, oe) => {
                q.set(ne, oe);
              });
              const N = [];
              for (const [ne, oe] of q) {
                const ee = oe.get("FontDescriptor");
                if (!(ee instanceof h.Dict))
                  continue;
                let $ = ee.get("FontFamily");
                $ = $.replace(/[ ]+(\d)/g, "$1");
                const E = ee.get("FontWeight"), H = -ee.get("ItalicAngle"), ie = {
                  fontFamily: $,
                  fontWeight: E,
                  italicAngle: H
                };
                (0, v.validateCSSFont)(ie) && N.push(L.handleSetFont(J, [h.Name.get(ne), 1], null, K, M, se, null, ie).catch(function(ue) {
                  return (0, a.warn)(`loadXfaFonts: "${ue}".`), null;
                }));
              }
              await Promise.all(N);
              const Q = this.xfaFactory.setFonts(te);
              if (!Q)
                return;
              G.ignoreErrors = !0, N.length = 0, te.length = 0;
              const D = /* @__PURE__ */ new Set();
              for (const ne of Q)
                (0, e.getXfaFontName)(`${ne}-Regular`) || D.add(ne);
              D.size && Q.push("PdfJS-Fallback");
              for (const ne of Q)
                if (!D.has(ne))
                  for (const oe of [{
                    name: "Regular",
                    fontWeight: 400,
                    italicAngle: 0
                  }, {
                    name: "Bold",
                    fontWeight: 700,
                    italicAngle: 0
                  }, {
                    name: "Italic",
                    fontWeight: 400,
                    italicAngle: 12
                  }, {
                    name: "BoldItalic",
                    fontWeight: 700,
                    italicAngle: 12
                  }]) {
                    const ee = `${ne}-${oe.name}`, $ = (0, e.getXfaFontDict)(ee);
                    N.push(L.handleSetFont(J, [h.Name.get(ee), 1], null, K, M, se, $, {
                      fontFamily: ne,
                      fontWeight: oe.fontWeight,
                      italicAngle: oe.italicAngle
                    }).catch(function(E) {
                      return (0, a.warn)(`loadXfaFonts: "${E}".`), null;
                    }));
                  }
              await Promise.all(N), this.xfaFactory.appendFonts(te, D);
            }
            async serializeXfaData(I) {
              return this.xfaFactory ? this.xfaFactory.serializeData(I) : null;
            }
            get formInfo() {
              const I = {
                hasFields: !1,
                hasAcroForm: !1,
                hasXfa: !1,
                hasSignatures: !1
              }, M = this.catalog.acroForm;
              if (!M)
                return (0, a.shadow)(this, "formInfo", I);
              try {
                const V = M.get("Fields"), J = Array.isArray(V) && V.length > 0;
                I.hasFields = J;
                const W = M.get("XFA");
                I.hasXfa = Array.isArray(W) && W.length > 0 || W instanceof y.BaseStream && !W.isEmpty;
                const G = !!(M.get("SigFlags") & 1), L = G && this._hasOnlyDocumentSignatures(V);
                I.hasAcroForm = J && !L, I.hasSignatures = G;
              } catch (V) {
                if (V instanceof v.MissingDataException)
                  throw V;
                (0, a.warn)(`Cannot fetch form information: "${V}".`);
              }
              return (0, a.shadow)(this, "formInfo", I);
            }
            get documentInfo() {
              let I = this._version;
              (typeof I != "string" || !O.test(I)) && ((0, a.warn)(`Invalid PDF header version number: ${I}`), I = null);
              const M = {
                PDFFormatVersion: I,
                Language: this.catalog.lang,
                EncryptFilterName: this.xref.encrypt ? this.xref.encrypt.filterName : null,
                IsLinearized: !!this.linearization,
                IsAcroFormPresent: this.formInfo.hasAcroForm,
                IsXFAPresent: this.formInfo.hasXfa,
                IsCollectionPresent: !!this.catalog.collection,
                IsSignaturesPresent: this.formInfo.hasSignatures
              };
              let V;
              try {
                V = this.xref.trailer.get("Info");
              } catch (J) {
                if (J instanceof v.MissingDataException)
                  throw J;
                (0, a.info)("The document information dictionary is invalid.");
              }
              if (!(V instanceof h.Dict))
                return (0, a.shadow)(this, "documentInfo", M);
              for (const J of V.getKeys()) {
                const W = V.get(J);
                switch (J) {
                  case "Title":
                  case "Author":
                  case "Subject":
                  case "Keywords":
                  case "Creator":
                  case "Producer":
                  case "CreationDate":
                  case "ModDate":
                    if (typeof W == "string") {
                      M[J] = (0, a.stringToPDFString)(W);
                      continue;
                    }
                    break;
                  case "Trapped":
                    if (W instanceof h.Name) {
                      M[J] = W;
                      continue;
                    }
                    break;
                  default:
                    let z;
                    switch (typeof W) {
                      case "string":
                        z = (0, a.stringToPDFString)(W);
                        break;
                      case "number":
                      case "boolean":
                        z = W;
                        break;
                      default:
                        W instanceof h.Name && (z = W);
                        break;
                    }
                    if (z === void 0) {
                      (0, a.warn)(`Bad value, for custom key "${J}", in Info: ${W}.`);
                      continue;
                    }
                    M.Custom || (M.Custom = /* @__PURE__ */ Object.create(null)), M.Custom[J] = z;
                    continue;
                }
                (0, a.warn)(`Bad value, for key "${J}", in Info: ${W}.`);
              }
              return (0, a.shadow)(this, "documentInfo", M);
            }
            get fingerprints() {
              function I(z) {
                return typeof z == "string" && z.length > 0 && z !== U;
              }
              function M(z) {
                const G = [];
                for (let L = 0, K = z.length; L < K; L++) {
                  const te = z[L].toString(16);
                  G.push(te.padStart(2, "0"));
                }
                return G.join("");
              }
              const V = this.xref.trailer.get("ID");
              let J, W;
              return Array.isArray(V) && I(V[0]) ? (J = (0, a.stringToBytes)(V[0]), V[1] !== V[0] && I(V[1]) && (W = (0, a.stringToBytes)(V[1]))) : J = (0, c.calculateMD5)(this.stream.getByteRange(0, f), 0, f), (0, a.shadow)(this, "fingerprints", [M(J), W ? M(W) : null]);
            }
            async _getLinearizationPage(I) {
              const {
                catalog: M,
                linearization: V,
                xref: J
              } = this, W = h.Ref.get(V.objectNumberFirst, 0);
              try {
                const z = await J.fetchAsync(W);
                if (z instanceof h.Dict) {
                  let G = z.getRaw("Type");
                  if (G instanceof h.Ref && (G = await J.fetchAsync(G)), (0, h.isName)(G, "Page") || !z.has("Type") && !z.has("Kids"))
                    return M.pageKidsCountCache.has(W) || M.pageKidsCountCache.put(W, 1), M.pageIndexCache.has(W) || M.pageIndexCache.put(W, 0), [z, W];
                }
                throw new a.FormatError("The Linearization dictionary doesn't point to a valid Page dictionary.");
              } catch (z) {
                return (0, a.warn)(`_getLinearizationPage: "${z.message}".`), M.getPageDict(I);
              }
            }
            getPage(I) {
              const M = this._pagePromises.get(I);
              if (M)
                return M;
              const {
                catalog: V,
                linearization: J,
                xfaFactory: W
              } = this;
              let z;
              return W ? z = Promise.resolve([h.Dict.empty, null]) : J && J.pageFirst === I ? z = this._getLinearizationPage(I) : z = V.getPageDict(I), z = z.then(([G, L]) => new B({
                pdfManager: this.pdfManager,
                xref: this.xref,
                pageIndex: I,
                pageDict: G,
                ref: L,
                globalIdFactory: this._globalIdFactory,
                fontCache: V.fontCache,
                builtInCMapCache: V.builtInCMapCache,
                standardFontDataCache: V.standardFontDataCache,
                globalImageCache: V.globalImageCache,
                nonBlendModesSet: V.nonBlendModesSet,
                xfaFactory: W
              })), this._pagePromises.set(I, z), z;
            }
            async checkFirstPage(I = !1) {
              if (!I)
                try {
                  await this.getPage(0);
                } catch (M) {
                  if (M instanceof v.XRefEntryException)
                    throw this._pagePromises.delete(0), await this.cleanup(), new v.XRefParseException();
                }
            }
            async checkLastPage(I = !1) {
              const {
                catalog: M,
                pdfManager: V
              } = this;
              M.setActualNumPages();
              let J;
              try {
                if (await Promise.all([V.ensureDoc("xfaFactory"), V.ensureDoc("linearization"), V.ensureCatalog("numPages")]), this.xfaFactory)
                  return;
                if (this.linearization ? J = this.linearization.numPages : J = M.numPages, Number.isInteger(J)) {
                  if (J <= 1)
                    return;
                } else
                  throw new a.FormatError("Page count is not an integer.");
                await this.getPage(J - 1);
              } catch (W) {
                if (this._pagePromises.delete(J - 1), await this.cleanup(), W instanceof v.XRefEntryException && !I)
                  throw new v.XRefParseException();
                (0, a.warn)(`checkLastPage - invalid /Pages tree /Count: ${J}.`);
                let z;
                try {
                  z = await M.getAllPageDicts(I);
                } catch (G) {
                  if (G instanceof v.XRefEntryException && !I)
                    throw new v.XRefParseException();
                  M.setActualNumPages(1);
                  return;
                }
                for (const [G, [L, K]] of z) {
                  let te;
                  L instanceof Error ? (te = Promise.reject(L), te.catch(() => {
                  })) : te = Promise.resolve(new B({
                    pdfManager: V,
                    xref: this.xref,
                    pageIndex: G,
                    pageDict: L,
                    ref: K,
                    globalIdFactory: this._globalIdFactory,
                    fontCache: M.fontCache,
                    builtInCMapCache: M.builtInCMapCache,
                    standardFontDataCache: M.standardFontDataCache,
                    globalImageCache: M.globalImageCache,
                    nonBlendModesSet: M.nonBlendModesSet,
                    xfaFactory: null
                  })), this._pagePromises.set(G, te);
                }
                M.setActualNumPages(z.size);
              }
            }
            fontFallback(I, M) {
              return this.catalog.fontFallback(I, M);
            }
            async cleanup(I = !1) {
              return this.catalog ? this.catalog.cleanup(I) : (0, p.clearGlobalCaches)();
            }
            _collectFieldObjects(I, M, V) {
              const J = this.xref.fetchIfRef(M);
              if (J.has("T")) {
                const W = (0, a.stringToPDFString)(J.get("T"));
                I === "" ? I = W : I = `${I}.${W}`;
              }
              if (V.has(I) || V.set(I, []), V.get(I).push(t.AnnotationFactory.create(this.xref, M, this.pdfManager, this._localIdFactory, !0).then((W) => W && W.getFieldObject()).catch(function(W) {
                return (0, a.warn)(`_collectFieldObjects: "${W}".`), null;
              })), J.has("Kids")) {
                const W = J.get("Kids");
                for (const z of W)
                  this._collectFieldObjects(I, z, V);
              }
            }
            get fieldObjects() {
              if (!this.formInfo.hasFields)
                return (0, a.shadow)(this, "fieldObjects", Promise.resolve(null));
              const I = /* @__PURE__ */ Object.create(null), M = /* @__PURE__ */ new Map();
              for (const J of this.catalog.acroForm.get("Fields"))
                this._collectFieldObjects("", J, M);
              const V = [];
              for (const [J, W] of M)
                V.push(Promise.all(W).then((z) => {
                  z = z.filter((G) => !!G), z.length > 0 && (I[J] = z);
                }));
              return (0, a.shadow)(this, "fieldObjects", Promise.all(V).then(() => I));
            }
            get hasJSActions() {
              const I = this.pdfManager.ensureDoc("_parseHasJSActions");
              return (0, a.shadow)(this, "hasJSActions", I);
            }
            async _parseHasJSActions() {
              const [I, M] = await Promise.all([this.pdfManager.ensureCatalog("jsActions"), this.pdfManager.ensureDoc("fieldObjects")]);
              return I ? !0 : M ? Object.values(M).some((V) => V.some((J) => J.actions !== null)) : !1;
            }
            get calculationOrderIds() {
              const I = this.catalog.acroForm;
              if (!I || !I.has("CO"))
                return (0, a.shadow)(this, "calculationOrderIds", null);
              const M = I.get("CO");
              if (!Array.isArray(M) || M.length === 0)
                return (0, a.shadow)(this, "calculationOrderIds", null);
              const V = [];
              for (const J of M)
                J instanceof h.Ref && V.push(J.toString());
              return V.length === 0 ? (0, a.shadow)(this, "calculationOrderIds", null) : (0, a.shadow)(this, "calculationOrderIds", V);
            }
          }
          o.PDFDocument = F;
        },
        /* 12 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.PopupAnnotation = o.MarkupAnnotation = o.AnnotationFactory = o.AnnotationBorderStyle = o.Annotation = void 0, o.getQuadPoints = _;
          var t = C(2), a = C(6), v = C(13), h = C(5), e = C(65), y = C(7), c = C(60), d = C(69), p = C(14), m = C(72), g = C(75), n = C(62), i = C(10), l = C(76);
          class u {
            static create(N, Q, D, ne, oe) {
              return Promise.all([D.ensureCatalog("acroForm"), D.ensureCatalog("baseUrl"), D.ensureDoc("xfaDatasets"), oe ? this._getPageIndex(N, Q, D) : -1]).then(([ee, $, E, H]) => D.ensure(this, "_create", [N, Q, D, ne, ee, E, oe, H]));
            }
            static _create(N, Q, D, ne, oe, ee, $, E = -1) {
              const H = N.fetchIfRef(Q);
              if (!(H instanceof h.Dict))
                return;
              const ie = Q instanceof h.Ref ? Q.toString() : `annot_${ne.createObjId()}`;
              let ue = H.get("Subtype");
              ue = ue instanceof h.Name ? ue.name : null;
              const fe = {
                xref: N,
                ref: Q,
                dict: H,
                subtype: ue,
                id: ie,
                pdfManager: D,
                acroForm: oe instanceof h.Dict ? oe : h.Dict.empty,
                xfaDatasets: ee,
                collectFields: $,
                pageIndex: E
              };
              switch (ue) {
                case "Link":
                  return new U(fe);
                case "Text":
                  return new f(fe);
                case "Widget":
                  let de = (0, a.getInheritableProperty)({
                    dict: H,
                    key: "FT"
                  });
                  switch (de = de instanceof h.Name ? de.name : null, de) {
                    case "Tx":
                      return new B(fe);
                    case "Btn":
                      return new R(fe);
                    case "Ch":
                      return new k(fe);
                    case "Sig":
                      return new x(fe);
                  }
                  return (0, t.warn)(`Unimplemented widget field type "${de}", falling back to base field type.`), new X(fe);
                case "Popup":
                  return new O(fe);
                case "FreeText":
                  return new S(fe);
                case "Line":
                  return new F(fe);
                case "Square":
                  return new T(fe);
                case "Circle":
                  return new I(fe);
                case "PolyLine":
                  return new M(fe);
                case "Polygon":
                  return new V(fe);
                case "Caret":
                  return new J(fe);
                case "Ink":
                  return new W(fe);
                case "Highlight":
                  return new z(fe);
                case "Underline":
                  return new G(fe);
                case "Squiggly":
                  return new L(fe);
                case "StrikeOut":
                  return new K(fe);
                case "Stamp":
                  return new te(fe);
                case "FileAttachment":
                  return new se(fe);
                default:
                  return $ || (ue ? (0, t.warn)(`Unimplemented annotation type "${ue}", falling back to base annotation.`) : (0, t.warn)("Annotation is missing the required /Subtype.")), new A(fe);
              }
            }
            static async _getPageIndex(N, Q, D) {
              try {
                const ne = await N.fetchIfRefAsync(Q);
                if (!(ne instanceof h.Dict))
                  return -1;
                const oe = ne.getRaw("P");
                return oe instanceof h.Ref ? await D.ensureCatalog("getPageIndex", [oe]) : -1;
              } catch (ne) {
                return (0, t.warn)(`_getPageIndex: "${ne}".`), -1;
              }
            }
            static async saveNewAnnotations(N, Q, D) {
              const ne = N.xref;
              let oe;
              const ee = [], $ = [];
              for (const E of D)
                switch (E.annotationType) {
                  case t.AnnotationEditorType.FREETEXT:
                    if (!oe) {
                      const H = new h.Dict(ne);
                      H.set("BaseFont", h.Name.get("Helvetica")), H.set("Type", h.Name.get("Font")), H.set("Subtype", h.Name.get("Type1")), H.set("Encoding", h.Name.get("WinAnsiEncoding"));
                      const ie = [];
                      oe = ne.getNewRef(), (0, e.writeObject)(oe, H, ie, null), ee.push({
                        ref: oe,
                        data: ie.join("")
                      });
                    }
                    $.push(S.createNewAnnotation(ne, E, ee, {
                      evaluator: N,
                      task: Q,
                      baseFontRef: oe
                    }));
                    break;
                  case t.AnnotationEditorType.INK:
                    $.push(W.createNewAnnotation(ne, E, ee));
                }
              return {
                annotations: await Promise.all($),
                dependencies: ee
              };
            }
            static async printNewAnnotations(N, Q, D) {
              if (!D)
                return null;
              const ne = N.xref, oe = [];
              for (const ee of D)
                switch (ee.annotationType) {
                  case t.AnnotationEditorType.FREETEXT:
                    oe.push(S.createNewPrintAnnotation(ne, ee, {
                      evaluator: N,
                      task: Q
                    }));
                    break;
                  case t.AnnotationEditorType.INK:
                    oe.push(W.createNewPrintAnnotation(ne, ee));
                    break;
                }
              return Promise.all(oe);
            }
          }
          o.AnnotationFactory = u;
          function w(q, N = new Uint8ClampedArray(3)) {
            if (!Array.isArray(q))
              return N;
            const Q = N || new Uint8ClampedArray(3);
            switch (q.length) {
              case 0:
                return null;
              case 1:
                return p.ColorSpace.singletons.gray.getRgbItem(q, 0, Q, 0), Q;
              case 3:
                return p.ColorSpace.singletons.rgb.getRgbItem(q, 0, Q, 0), Q;
              case 4:
                return p.ColorSpace.singletons.cmyk.getRgbItem(q, 0, Q, 0), Q;
              default:
                return N;
            }
          }
          function _(q, N) {
            if (!q.has("QuadPoints"))
              return null;
            const Q = q.getArray("QuadPoints");
            if (!Array.isArray(Q) || Q.length === 0 || Q.length % 8 > 0)
              return null;
            const D = [];
            for (let ne = 0, oe = Q.length / 8; ne < oe; ne++) {
              D.push([]);
              for (let ee = ne * 8, $ = ne * 8 + 8; ee < $; ee += 2) {
                const E = Q[ee], H = Q[ee + 1];
                if (N !== null && (E < N[0] || E > N[2] || H < N[1] || H > N[3]))
                  return null;
                D[ne].push({
                  x: E,
                  y: H
                });
              }
            }
            return D.map((ne) => {
              const [oe, ee, $, E] = ne.reduce(([H, ie, ue, fe], de) => [Math.min(H, de.x), Math.max(ie, de.x), Math.min(ue, de.y), Math.max(fe, de.y)], [Number.MAX_VALUE, Number.MIN_VALUE, Number.MAX_VALUE, Number.MIN_VALUE]);
              return [{
                x: oe,
                y: E
              }, {
                x: ee,
                y: E
              }, {
                x: oe,
                y: $
              }, {
                x: ee,
                y: $
              }];
            });
          }
          function b(q, N, Q) {
            const [D, ne, oe, ee] = t.Util.getAxialAlignedBoundingBox(N, Q);
            if (D === oe || ne === ee)
              return [1, 0, 0, 1, q[0], q[1]];
            const $ = (q[2] - q[0]) / (oe - D), E = (q[3] - q[1]) / (ee - ne);
            return [$, 0, 0, E, q[0] - D * $, q[1] - ne * E];
          }
          class A {
            constructor(N) {
              const Q = N.dict;
              this.setTitle(Q.get("T")), this.setContents(Q.get("Contents")), this.setModificationDate(Q.get("M")), this.setFlags(Q.get("F")), this.setRectangle(Q.getArray("Rect")), this.setColor(Q.getArray("C")), this.setBorderStyle(Q), this.setAppearance(Q), this.setOptionalContent(Q);
              const D = Q.get("MK");
              if (this.setBorderAndBackgroundColors(D), this.setRotation(D), this._streams = [], this.appearance && this._streams.push(this.appearance), this.data = {
                annotationFlags: this.flags,
                borderStyle: this.borderStyle,
                color: this.color,
                backgroundColor: this.backgroundColor,
                borderColor: this.borderColor,
                rotation: this.rotation,
                contentsObj: this._contents,
                hasAppearance: !!this.appearance,
                id: N.id,
                modificationDate: this.modificationDate,
                rect: this.rectangle,
                subtype: N.subtype,
                hasOwnCanvas: !1
              }, N.collectFields) {
                const ne = Q.get("Kids");
                if (Array.isArray(ne)) {
                  const oe = [];
                  for (const ee of ne)
                    ee instanceof h.Ref && oe.push(ee.toString());
                  oe.length !== 0 && (this.data.kidIds = oe);
                }
                this.data.actions = (0, a.collectActions)(N.xref, Q, t.AnnotationActionEventType), this.data.fieldName = this._constructFieldName(Q), this.data.pageIndex = N.pageIndex;
              }
              this._fallbackFontDict = null;
            }
            _hasFlag(N, Q) {
              return !!(N & Q);
            }
            _isViewable(N) {
              return !this._hasFlag(N, t.AnnotationFlag.INVISIBLE) && !this._hasFlag(N, t.AnnotationFlag.NOVIEW);
            }
            _isPrintable(N) {
              return this._hasFlag(N, t.AnnotationFlag.PRINT) && !this._hasFlag(N, t.AnnotationFlag.INVISIBLE);
            }
            mustBeViewed(N) {
              const Q = N && N.get(this.data.id);
              return Q && Q.hidden !== void 0 ? !Q.hidden : this.viewable && !this._hasFlag(this.flags, t.AnnotationFlag.HIDDEN);
            }
            mustBePrinted(N) {
              const Q = N && N.get(this.data.id);
              return Q && Q.print !== void 0 ? Q.print : this.printable;
            }
            get viewable() {
              return this.data.quadPoints === null ? !1 : this.flags === 0 ? !0 : this._isViewable(this.flags);
            }
            get printable() {
              return this.data.quadPoints === null || this.flags === 0 ? !1 : this._isPrintable(this.flags);
            }
            _parseStringHelper(N) {
              const Q = typeof N == "string" ? (0, t.stringToPDFString)(N) : "", D = Q && (0, c.bidi)(Q).dir === "rtl" ? "rtl" : "ltr";
              return {
                str: Q,
                dir: D
              };
            }
            setTitle(N) {
              this._title = this._parseStringHelper(N);
            }
            setContents(N) {
              this._contents = this._parseStringHelper(N);
            }
            setModificationDate(N) {
              this.modificationDate = typeof N == "string" ? N : null;
            }
            setFlags(N) {
              this.flags = Number.isInteger(N) && N > 0 ? N : 0;
            }
            hasFlag(N) {
              return this._hasFlag(this.flags, N);
            }
            setRectangle(N) {
              Array.isArray(N) && N.length === 4 ? this.rectangle = t.Util.normalizeRect(N) : this.rectangle = [0, 0, 0, 0];
            }
            setColor(N) {
              this.color = w(N);
            }
            setLineEndings(N) {
              if (this.lineEndings = ["None", "None"], Array.isArray(N) && N.length === 2)
                for (let Q = 0; Q < 2; Q++) {
                  const D = N[Q];
                  if (D instanceof h.Name)
                    switch (D.name) {
                      case "None":
                        continue;
                      case "Square":
                      case "Circle":
                      case "Diamond":
                      case "OpenArrow":
                      case "ClosedArrow":
                      case "Butt":
                      case "ROpenArrow":
                      case "RClosedArrow":
                      case "Slash":
                        this.lineEndings[Q] = D.name;
                        continue;
                    }
                  (0, t.warn)(`Ignoring invalid lineEnding: ${D}`);
                }
            }
            setRotation(N) {
              if (this.rotation = 0, N instanceof h.Dict) {
                let Q = N.get("R") || 0;
                Number.isInteger(Q) && Q !== 0 && (Q %= 360, Q < 0 && (Q += 360), Q % 90 === 0 && (this.rotation = Q));
              }
            }
            setBorderAndBackgroundColors(N) {
              N instanceof h.Dict ? (this.borderColor = w(N.getArray("BC"), null), this.backgroundColor = w(N.getArray("BG"), null)) : this.borderColor = this.backgroundColor = null;
            }
            setBorderStyle(N) {
              if (this.borderStyle = new Y(), N instanceof h.Dict)
                if (N.has("BS")) {
                  const Q = N.get("BS"), D = Q.get("Type");
                  (!D || (0, h.isName)(D, "Border")) && (this.borderStyle.setWidth(Q.get("W"), this.rectangle), this.borderStyle.setStyle(Q.get("S")), this.borderStyle.setDashArray(Q.getArray("D")));
                } else if (N.has("Border")) {
                  const Q = N.getArray("Border");
                  Array.isArray(Q) && Q.length >= 3 && (this.borderStyle.setHorizontalCornerRadius(Q[0]), this.borderStyle.setVerticalCornerRadius(Q[1]), this.borderStyle.setWidth(Q[2], this.rectangle), Q.length === 4 && this.borderStyle.setDashArray(Q[3], !0));
                } else
                  this.borderStyle.setWidth(0);
            }
            setAppearance(N) {
              this.appearance = null;
              const Q = N.get("AP");
              if (!(Q instanceof h.Dict))
                return;
              const D = Q.get("N");
              if (D instanceof y.BaseStream) {
                this.appearance = D;
                return;
              }
              if (!(D instanceof h.Dict))
                return;
              const ne = N.get("AS");
              !(ne instanceof h.Name) || !D.has(ne.name) || (this.appearance = D.get(ne.name));
            }
            setOptionalContent(N) {
              this.oc = null;
              const Q = N.get("OC");
              Q instanceof h.Name ? (0, t.warn)("setOptionalContent: Support for /Name-entry is not implemented.") : Q instanceof h.Dict && (this.oc = Q);
            }
            loadResources(N, Q) {
              return Q.dict.getAsync("Resources").then((D) => D ? new g.ObjectLoader(D, N, D.xref).load().then(function() {
                return D;
              }) : void 0);
            }
            async getOperatorList(N, Q, D, ne, oe) {
              const ee = this.data;
              let $ = this.appearance;
              const E = !!(this.data.hasOwnCanvas && D & t.RenderingIntentFlag.DISPLAY);
              if (!$) {
                if (!E)
                  return {
                    opList: new n.OperatorList(),
                    separateForm: !1,
                    separateCanvas: !1
                  };
                $ = new i.StringStream(""), $.dict = new h.Dict();
              }
              const H = $.dict, ie = await this.loadResources(["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"], $), ue = H.getArray("BBox") || [0, 0, 1, 1], fe = H.getArray("Matrix") || [1, 0, 0, 1, 0, 0], de = b(ee.rect, ue, fe), pe = new n.OperatorList();
              let xe;
              return this.oc && (xe = await N.parseMarkedContentProps(this.oc, null)), xe !== void 0 && pe.addOp(t.OPS.beginMarkedContentProps, ["OC", xe]), pe.addOp(t.OPS.beginAnnotation, [ee.id, ee.rect, de, fe, E]), await N.getOperatorList({
                stream: $,
                task: Q,
                resources: ie,
                operatorList: pe,
                fallbackFontDict: this._fallbackFontDict
              }), pe.addOp(t.OPS.endAnnotation, []), xe !== void 0 && pe.addOp(t.OPS.endMarkedContent, []), this.reset(), {
                opList: pe,
                separateForm: !1,
                separateCanvas: E
              };
            }
            async save(N, Q, D) {
              return null;
            }
            get hasTextContent() {
              return !1;
            }
            async extractTextContent(N, Q, D) {
              if (!this.appearance)
                return;
              const ne = await this.loadResources(["ExtGState", "Font", "Properties", "XObject"], this.appearance), oe = [], ee = [], $ = {
                desiredSize: Math.Infinity,
                ready: !0,
                enqueue(E, H) {
                  for (const ie of E.items)
                    ee.push(ie.str), ie.hasEOL && (oe.push(ee.join("")), ee.length = 0);
                }
              };
              await N.getTextContent({
                stream: this.appearance,
                task: Q,
                resources: ne,
                includeMarkedContent: !0,
                combineTextItems: !0,
                sink: $,
                viewBox: D
              }), this.reset(), ee.length && oe.push(ee.join("")), oe.length > 0 && (this.data.textContent = oe);
            }
            getFieldObject() {
              return this.data.kidIds ? {
                id: this.data.id,
                actions: this.data.actions,
                name: this.data.fieldName,
                strokeColor: this.data.borderColor,
                fillColor: this.data.backgroundColor,
                type: "",
                kidIds: this.data.kidIds,
                page: this.data.pageIndex,
                rotation: this.rotation
              } : null;
            }
            reset() {
              for (const N of this._streams)
                N.reset();
            }
            _constructFieldName(N) {
              if (!N.has("T") && !N.has("Parent"))
                return (0, t.warn)("Unknown field name, falling back to empty field name."), "";
              if (!N.has("Parent"))
                return (0, t.stringToPDFString)(N.get("T"));
              const Q = [];
              N.has("T") && Q.unshift((0, t.stringToPDFString)(N.get("T")));
              let D = N;
              const ne = new h.RefSet();
              for (N.objId && ne.put(N.objId); D.has("Parent") && (D = D.get("Parent"), !(!(D instanceof h.Dict) || D.objId && ne.has(D.objId))); )
                D.objId && ne.put(D.objId), D.has("T") && Q.unshift((0, t.stringToPDFString)(D.get("T")));
              return Q.join(".");
            }
          }
          o.Annotation = A;
          class Y {
            constructor() {
              this.width = 1, this.style = t.AnnotationBorderStyleType.SOLID, this.dashArray = [3], this.horizontalCornerRadius = 0, this.verticalCornerRadius = 0;
            }
            setWidth(N, Q = [0, 0, 0, 0]) {
              if (N instanceof h.Name) {
                this.width = 0;
                return;
              }
              if (typeof N == "number") {
                if (N > 0) {
                  const D = (Q[2] - Q[0]) / 2, ne = (Q[3] - Q[1]) / 2;
                  D > 0 && ne > 0 && (N > D || N > ne) && ((0, t.warn)(`AnnotationBorderStyle.setWidth - ignoring width: ${N}`), N = 1);
                }
                this.width = N;
              }
            }
            setStyle(N) {
              if (N instanceof h.Name)
                switch (N.name) {
                  case "S":
                    this.style = t.AnnotationBorderStyleType.SOLID;
                    break;
                  case "D":
                    this.style = t.AnnotationBorderStyleType.DASHED;
                    break;
                  case "B":
                    this.style = t.AnnotationBorderStyleType.BEVELED;
                    break;
                  case "I":
                    this.style = t.AnnotationBorderStyleType.INSET;
                    break;
                  case "U":
                    this.style = t.AnnotationBorderStyleType.UNDERLINE;
                    break;
                }
            }
            setDashArray(N, Q = !1) {
              if (Array.isArray(N) && N.length > 0) {
                let D = !0, ne = !0;
                for (const oe of N)
                  if (+oe >= 0)
                    oe > 0 && (ne = !1);
                  else {
                    D = !1;
                    break;
                  }
                D && !ne ? (this.dashArray = N, Q && this.setStyle(h.Name.get("D"))) : this.width = 0;
              } else
                N && (this.width = 0);
            }
            setHorizontalCornerRadius(N) {
              Number.isInteger(N) && (this.horizontalCornerRadius = N);
            }
            setVerticalCornerRadius(N) {
              Number.isInteger(N) && (this.verticalCornerRadius = N);
            }
          }
          o.AnnotationBorderStyle = Y;
          class j extends A {
            constructor(N) {
              super(N);
              const Q = N.dict;
              if (Q.has("IRT")) {
                const D = Q.getRaw("IRT");
                this.data.inReplyTo = D instanceof h.Ref ? D.toString() : null;
                const ne = Q.get("RT");
                this.data.replyType = ne instanceof h.Name ? ne.name : t.AnnotationReplyType.REPLY;
              }
              if (this.data.replyType === t.AnnotationReplyType.GROUP) {
                const D = Q.get("IRT");
                this.setTitle(D.get("T")), this.data.titleObj = this._title, this.setContents(D.get("Contents")), this.data.contentsObj = this._contents, D.has("CreationDate") ? (this.setCreationDate(D.get("CreationDate")), this.data.creationDate = this.creationDate) : this.data.creationDate = null, D.has("M") ? (this.setModificationDate(D.get("M")), this.data.modificationDate = this.modificationDate) : this.data.modificationDate = null, this.data.hasPopup = D.has("Popup"), D.has("C") ? (this.setColor(D.getArray("C")), this.data.color = this.color) : this.data.color = null;
              } else
                this.data.titleObj = this._title, this.setCreationDate(Q.get("CreationDate")), this.data.creationDate = this.creationDate, this.data.hasPopup = Q.has("Popup"), Q.has("C") || (this.data.color = null);
              Q.has("RC") && (this.data.richText = l.XFAFactory.getRichTextAsHtml(Q.get("RC")));
            }
            setCreationDate(N) {
              this.creationDate = typeof N == "string" ? N : null;
            }
            _setDefaultAppearance({
              xref: N,
              extra: Q,
              strokeColor: D,
              fillColor: ne,
              blendMode: oe,
              strokeAlpha: ee,
              fillAlpha: $,
              pointsCallback: E
            }) {
              let H = Number.MAX_VALUE, ie = Number.MAX_VALUE, ue = Number.MIN_VALUE, fe = Number.MIN_VALUE;
              const de = ["q"];
              Q && de.push(Q), D && de.push(`${D[0]} ${D[1]} ${D[2]} RG`), ne && de.push(`${ne[0]} ${ne[1]} ${ne[2]} rg`);
              let pe = this.data.quadPoints;
              pe || (pe = [[{
                x: this.rectangle[0],
                y: this.rectangle[3]
              }, {
                x: this.rectangle[2],
                y: this.rectangle[3]
              }, {
                x: this.rectangle[0],
                y: this.rectangle[1]
              }, {
                x: this.rectangle[2],
                y: this.rectangle[1]
              }]]);
              for (const Ce of pe) {
                const [ve, Le, He, Qe] = E(de, Ce);
                H = Math.min(H, ve), ue = Math.max(ue, Le), ie = Math.min(ie, He), fe = Math.max(fe, Qe);
              }
              de.push("Q");
              const xe = new h.Dict(N), De = new h.Dict(N);
              De.set("Subtype", h.Name.get("Form"));
              const Ae = new i.StringStream(de.join(" "));
              Ae.dict = De, xe.set("Fm0", Ae);
              const Se = new h.Dict(N);
              oe && Se.set("BM", h.Name.get(oe)), typeof ee == "number" && Se.set("CA", ee), typeof $ == "number" && Se.set("ca", $);
              const ke = new h.Dict(N);
              ke.set("GS0", Se);
              const ye = new h.Dict(N);
              ye.set("ExtGState", ke), ye.set("XObject", xe);
              const _e = new h.Dict(N);
              _e.set("Resources", ye);
              const we = this.data.rect = [H, ie, ue, fe];
              _e.set("BBox", we), this.appearance = new i.StringStream("/GS0 gs /Fm0 Do"), this.appearance.dict = _e, this._streams.push(this.appearance, Ae);
            }
            static async createNewAnnotation(N, Q, D, ne) {
              const oe = N.getNewRef(), ee = N.getNewRef(), $ = this.createNewDict(Q, N, {
                apRef: ee
              }), E = await this.createNewAppearanceStream(Q, N, ne), H = [];
              let ie = N.encrypt ? N.encrypt.createCipherTransform(ee.num, ee.gen) : null;
              return (0, e.writeObject)(ee, E, H, ie), D.push({
                ref: ee,
                data: H.join("")
              }), H.length = 0, ie = N.encrypt ? N.encrypt.createCipherTransform(oe.num, oe.gen) : null, (0, e.writeObject)(oe, $, H, ie), {
                ref: oe,
                data: H.join("")
              };
            }
            static async createNewPrintAnnotation(N, Q, D) {
              const ne = await this.createNewAppearanceStream(Q, N, D), oe = this.createNewDict(Q, N, {
                ap: ne
              });
              return new this.prototype.constructor({
                dict: oe,
                xref: N
              });
            }
          }
          o.MarkupAnnotation = j;
          class X extends A {
            constructor(N) {
              super(N);
              const Q = N.dict, D = this.data;
              this.ref = N.ref, D.annotationType = t.AnnotationType.WIDGET, D.fieldName === void 0 && (D.fieldName = this._constructFieldName(Q)), D.actions === void 0 && (D.actions = (0, a.collectActions)(N.xref, Q, t.AnnotationActionEventType));
              let ne = (0, a.getInheritableProperty)({
                dict: Q,
                key: "V",
                getArray: !0
              });
              D.fieldValue = this._decodeFormValue(ne);
              const oe = (0, a.getInheritableProperty)({
                dict: Q,
                key: "DV",
                getArray: !0
              });
              if (D.defaultFieldValue = this._decodeFormValue(oe), ne === void 0 && N.xfaDatasets) {
                const ue = this._title.str;
                ue && (this._hasValueFromXFA = !0, D.fieldValue = ne = N.xfaDatasets.getValue(ue));
              }
              ne === void 0 && D.defaultFieldValue !== null && (D.fieldValue = D.defaultFieldValue), D.alternativeText = (0, t.stringToPDFString)(Q.get("TU") || "");
              const ee = (0, a.getInheritableProperty)({
                dict: Q,
                key: "DA"
              }) || N.acroForm.get("DA");
              this._defaultAppearance = typeof ee == "string" ? ee : "", D.defaultAppearanceData = (0, v.parseDefaultAppearance)(this._defaultAppearance);
              const $ = (0, a.getInheritableProperty)({
                dict: Q,
                key: "FT"
              });
              D.fieldType = $ instanceof h.Name ? $.name : null;
              const E = (0, a.getInheritableProperty)({
                dict: Q,
                key: "DR"
              }), H = N.acroForm.get("DR"), ie = this.appearance && this.appearance.dict.get("Resources");
              this._fieldResources = {
                localResources: E,
                acroFormResources: H,
                appearanceResources: ie,
                mergedResources: h.Dict.merge({
                  xref: N.xref,
                  dictArray: [E, ie, H],
                  mergeSubDicts: !0
                })
              }, D.fieldFlags = (0, a.getInheritableProperty)({
                dict: Q,
                key: "Ff"
              }), (!Number.isInteger(D.fieldFlags) || D.fieldFlags < 0) && (D.fieldFlags = 0), D.readOnly = this.hasFieldFlag(t.AnnotationFieldFlag.READONLY), D.required = this.hasFieldFlag(t.AnnotationFieldFlag.REQUIRED), D.hidden = this._hasFlag(D.annotationFlags, t.AnnotationFlag.HIDDEN);
            }
            _decodeFormValue(N) {
              return Array.isArray(N) ? N.filter((Q) => typeof Q == "string").map((Q) => (0, t.stringToPDFString)(Q)) : N instanceof h.Name ? (0, t.stringToPDFString)(N.name) : typeof N == "string" ? (0, t.stringToPDFString)(N) : null;
            }
            hasFieldFlag(N) {
              return !!(this.data.fieldFlags & N);
            }
            static _getRotationMatrix(N, Q, D) {
              switch (N) {
                case 90:
                  return [0, 1, -1, 0, Q, 0];
                case 180:
                  return [-1, 0, 0, -1, Q, D];
                case 270:
                  return [0, -1, 1, 0, 0, D];
                default:
                  throw new Error("Invalid rotation");
              }
            }
            getRotationMatrix(N) {
              const Q = N ? N.get(this.data.id) : void 0;
              let D = Q && Q.rotation;
              if (D === void 0 && (D = this.rotation), D === 0)
                return t.IDENTITY_MATRIX;
              const ne = this.data.rect[2] - this.data.rect[0], oe = this.data.rect[3] - this.data.rect[1];
              return X._getRotationMatrix(D, ne, oe);
            }
            getBorderAndBackgroundAppearances(N) {
              const Q = N ? N.get(this.data.id) : void 0;
              let D = Q && Q.rotation;
              if (D === void 0 && (D = this.rotation), !this.backgroundColor && !this.borderColor)
                return "";
              const ne = this.data.rect[2] - this.data.rect[0], oe = this.data.rect[3] - this.data.rect[1], ee = D === 0 || D === 180 ? `0 0 ${ne} ${oe} re` : `0 0 ${oe} ${ne} re`;
              let $ = "";
              if (this.backgroundColor && ($ = `${(0, v.getPdfColor)(this.backgroundColor, !0)} ${ee} f `), this.borderColor) {
                const E = this.borderStyle.width || 1;
                $ += `${E} w ${(0, v.getPdfColor)(this.borderColor, !1)} ${ee} S `;
              }
              return $;
            }
            async getOperatorList(N, Q, D, ne, oe) {
              if (ne && !(this instanceof x))
                return {
                  opList: new n.OperatorList(),
                  separateForm: !0,
                  separateCanvas: !1
                };
              if (!this._hasText)
                return super.getOperatorList(N, Q, D, ne, oe);
              const ee = await this._getAppearance(N, Q, oe);
              if (this.appearance && ee === null)
                return super.getOperatorList(N, Q, D, ne, oe);
              const $ = new n.OperatorList();
              if (!this._defaultAppearance || ee === null)
                return {
                  opList: $,
                  separateForm: !1,
                  separateCanvas: !1
                };
              const E = [1, 0, 0, 1, 0, 0], H = [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]], ie = b(this.data.rect, H, E);
              let ue;
              this.oc && (ue = await N.parseMarkedContentProps(this.oc, null)), ue !== void 0 && $.addOp(t.OPS.beginMarkedContentProps, ["OC", ue]), $.addOp(t.OPS.beginAnnotation, [this.data.id, this.data.rect, ie, this.getRotationMatrix(oe), !1]);
              const fe = new i.StringStream(ee);
              return await N.getOperatorList({
                stream: fe,
                task: Q,
                resources: this._fieldResources.mergedResources,
                operatorList: $
              }), $.addOp(t.OPS.endAnnotation, []), ue !== void 0 && $.addOp(t.OPS.endMarkedContent, []), {
                opList: $,
                separateForm: !1,
                separateCanvas: !1
              };
            }
            _getMKDict(N) {
              const Q = new h.Dict(null);
              return N && Q.set("R", N), this.borderColor && Q.set("BC", Array.from(this.borderColor).map((D) => D / 255)), this.backgroundColor && Q.set("BG", Array.from(this.backgroundColor).map((D) => D / 255)), Q.size > 0 ? Q : null;
            }
            async save(N, Q, D) {
              const ne = D ? D.get(this.data.id) : void 0;
              let oe = ne && ne.value, ee = ne && ne.rotation;
              if (oe === this.data.fieldValue || oe === void 0) {
                if (!this._hasValueFromXFA && ee === void 0)
                  return null;
                oe = oe || this.data.fieldValue;
              }
              if (ee === void 0 && !this._hasValueFromXFA && Array.isArray(oe) && Array.isArray(this.data.fieldValue) && oe.length === this.data.fieldValue.length && oe.every((Ce, ve) => Ce === this.data.fieldValue[ve]))
                return null;
              ee === void 0 && (ee = this.rotation);
              let $ = await this._getAppearance(N, Q, D);
              if ($ === null)
                return null;
              const {
                xref: E
              } = N, H = E.fetchIfRef(this.ref);
              if (!(H instanceof h.Dict))
                return null;
              const ie = [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]], ue = {
                path: (0, t.stringToPDFString)(H.get("T") || ""),
                value: oe
              }, fe = E.getNewRef(), de = new h.Dict(E);
              de.set("N", fe);
              const pe = E.encrypt;
              let xe = null, De = null;
              pe && (xe = pe.createCipherTransform(this.ref.num, this.ref.gen), De = pe.createCipherTransform(fe.num, fe.gen), $ = De.encryptString($));
              const Ae = (Ce) => (0, t.isAscii)(Ce) ? Ce : (0, t.stringToUTF16BEString)(Ce);
              H.set("V", Array.isArray(oe) ? oe.map(Ae) : Ae(oe)), H.set("AP", de), H.set("M", `D:${(0, t.getModificationDate)()}`);
              const Se = this._getMKDict(ee);
              Se && H.set("MK", Se);
              const ke = new h.Dict(E);
              ke.set("Length", $.length), ke.set("Subtype", h.Name.get("Form")), ke.set("Resources", this._getSaveFieldResources(E)), ke.set("BBox", ie);
              const ye = this.getRotationMatrix(D);
              ye !== t.IDENTITY_MATRIX && ke.set("Matrix", ye);
              const _e = [`${this.ref.num} ${this.ref.gen} obj
`];
              (0, e.writeDict)(H, _e, xe), _e.push(`
endobj
`);
              const we = [`${fe.num} ${fe.gen} obj
`];
              return (0, e.writeDict)(ke, we, De), we.push(` stream
`, $, `
endstream
endobj
`), [{
                ref: this.ref,
                data: _e.join(""),
                xfa: ue
              }, {
                ref: fe,
                data: we.join(""),
                xfa: null
              }];
            }
            async _getAppearance(N, Q, D) {
              if (this.hasFieldFlag(t.AnnotationFieldFlag.PASSWORD))
                return null;
              const oe = D ? D.get(this.data.id) : void 0;
              let ee, $;
              if (oe && (ee = oe.formattedValue || oe.value, $ = oe.rotation), $ === void 0 && ee === void 0 && (!this._hasValueFromXFA || this.appearance))
                return null;
              if (ee === void 0 && (ee = this.data.fieldValue, !ee) || (Array.isArray(ee) && ee.length === 1 && (ee = ee[0]), (0, t.assert)(typeof ee == "string", "Expected `value` to be a string."), ee = ee.trim(), ee === ""))
                return "";
              $ === void 0 && ($ = this.rotation);
              let E = -1;
              this.data.multiLine && (E = ee.split(/\r\n|\r|\n/).length);
              const H = 2, ie = H;
              let ue = this.data.rect[3] - this.data.rect[1], fe = this.data.rect[2] - this.data.rect[0];
              ($ === 90 || $ === 270) && ([fe, ue] = [ue, fe]), this._defaultAppearance || (this.data.defaultAppearanceData = (0, v.parseDefaultAppearance)(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
              const de = await X._getFontData(N, Q, this.data.defaultAppearanceData, this._fieldResources.mergedResources), [pe, xe] = this._computeFontSize(ue - H, fe - 2 * ie, ee, de, E);
              let De = de.descent;
              isNaN(De) && (De = 0);
              const Se = Math.min(Math.floor((ue - xe) / 2), H) + Math.abs(De) * xe, ke = this.data.textAlignment;
              if (this.data.multiLine)
                return this._getMultilineAppearance(pe, ee, de, xe, fe, ue, ke, ie, Se, D);
              const ye = de.encodeString(ee).join("");
              if (this.data.comb)
                return this._getCombAppearance(pe, de, ye, fe, ie, Se, D);
              const _e = this.getBorderAndBackgroundAppearances(D);
              if (ke === 0 || ke > 2)
                return `/Tx BMC q ${_e}BT ` + pe + ` 1 0 0 1 ${ie} ${Se} Tm (${(0, t.escapeString)(ye)}) Tj ET Q EMC`;
              const we = this._renderText(ye, de, xe, fe, ke, ie, Se);
              return `/Tx BMC q ${_e}BT ` + pe + ` 1 0 0 1 0 0 Tm ${we} ET Q EMC`;
            }
            static async _getFontData(N, Q, D, ne) {
              const oe = new n.OperatorList(), ee = {
                font: null,
                clone() {
                  return this;
                }
              }, {
                fontName: $,
                fontSize: E
              } = D;
              return await N.handleSetFont(ne, [$ && h.Name.get($), E], null, oe, Q, ee, null), ee.font;
            }
            _getTextWidth(N, Q) {
              return Q.charsToGlyphs(N).reduce((D, ne) => D + ne.width, 0) / 1e3;
            }
            _computeFontSize(N, Q, D, ne, oe) {
              let {
                fontSize: ee
              } = this.data.defaultAppearanceData;
              if (!ee) {
                const $ = (ie) => Math.floor(ie * 100) / 100;
                if (oe === -1) {
                  const ie = this._getTextWidth(D, ne);
                  ee = $(Math.min(N / t.LINE_FACTOR, Q / ie));
                } else {
                  const ie = D.split(/\r\n?|\n/), ue = [];
                  for (const xe of ie) {
                    const De = ne.encodeString(xe).join(""), Ae = ne.charsToGlyphs(De), Se = ne.getCharPositions(De);
                    ue.push({
                      line: De,
                      glyphs: Ae,
                      positions: Se
                    });
                  }
                  const fe = (xe) => {
                    let De = 0;
                    for (const Ae of ue) {
                      const Se = this._splitLine(null, ne, xe, Q, Ae);
                      if (De += Se.length * xe, De > N)
                        return !0;
                    }
                    return !1;
                  };
                  ee = 12;
                  let de = ee * t.LINE_FACTOR, pe = Math.round(N / de);
                  for (pe = Math.max(pe, oe); ; ) {
                    if (de = N / pe, ee = $(de / t.LINE_FACTOR), fe(ee)) {
                      pe++;
                      continue;
                    }
                    break;
                  }
                }
                const {
                  fontName: E,
                  fontColor: H
                } = this.data.defaultAppearanceData;
                this._defaultAppearance = (0, v.createDefaultAppearance)({
                  fontSize: ee,
                  fontName: E,
                  fontColor: H
                });
              }
              return [this._defaultAppearance, ee];
            }
            _renderText(N, Q, D, ne, oe, ee, $) {
              let E;
              if (oe === 1) {
                const H = this._getTextWidth(N, Q) * D;
                E = (ne - H) / 2;
              } else if (oe === 2) {
                const H = this._getTextWidth(N, Q) * D;
                E = ne - H - ee;
              } else
                E = ee;
              return E = (0, a.numberToString)(E), $ = (0, a.numberToString)($), `${E} ${$} Td (${(0, t.escapeString)(N)}) Tj`;
            }
            _getSaveFieldResources(N) {
              const {
                localResources: Q,
                appearanceResources: D,
                acroFormResources: ne
              } = this._fieldResources, oe = this.data.defaultAppearanceData && this.data.defaultAppearanceData.fontName;
              if (!oe)
                return Q || h.Dict.empty;
              for (const ee of [Q, D])
                if (ee instanceof h.Dict) {
                  const $ = ee.get("Font");
                  if ($ instanceof h.Dict && $.has(oe))
                    return ee;
                }
              if (ne instanceof h.Dict) {
                const ee = ne.get("Font");
                if (ee instanceof h.Dict && ee.has(oe)) {
                  const $ = new h.Dict(N);
                  $.set(oe, ee.getRaw(oe));
                  const E = new h.Dict(N);
                  return E.set("Font", $), h.Dict.merge({
                    xref: N,
                    dictArray: [E, Q],
                    mergeSubDicts: !0
                  });
                }
              }
              return Q || h.Dict.empty;
            }
            getFieldObject() {
              return null;
            }
          }
          class B extends X {
            constructor(N) {
              super(N), this._hasText = !0;
              const Q = N.dict;
              typeof this.data.fieldValue != "string" && (this.data.fieldValue = "");
              let D = (0, a.getInheritableProperty)({
                dict: Q,
                key: "Q"
              });
              (!Number.isInteger(D) || D < 0 || D > 2) && (D = null), this.data.textAlignment = D;
              let ne = (0, a.getInheritableProperty)({
                dict: Q,
                key: "MaxLen"
              });
              (!Number.isInteger(ne) || ne < 0) && (ne = 0), this.data.maxLen = ne, this.data.multiLine = this.hasFieldFlag(t.AnnotationFieldFlag.MULTILINE), this.data.comb = this.hasFieldFlag(t.AnnotationFieldFlag.COMB) && !this.hasFieldFlag(t.AnnotationFieldFlag.MULTILINE) && !this.hasFieldFlag(t.AnnotationFieldFlag.PASSWORD) && !this.hasFieldFlag(t.AnnotationFieldFlag.FILESELECT) && this.data.maxLen !== 0, this.data.doNotScroll = this.hasFieldFlag(t.AnnotationFieldFlag.DONOTSCROLL);
            }
            _getCombAppearance(N, Q, D, ne, oe, ee, $) {
              const E = (0, a.numberToString)(ne / this.data.maxLen), H = [], ie = Q.getCharPositions(D);
              for (const [de, pe] of ie)
                H.push(`(${(0, t.escapeString)(D.substring(de, pe))}) Tj`);
              const ue = this.getBorderAndBackgroundAppearances($), fe = H.join(` ${E} 0 Td `);
              return `/Tx BMC q ${ue}BT ` + N + ` 1 0 0 1 ${oe} ${ee} Tm ${fe} ET Q EMC`;
            }
            _getMultilineAppearance(N, Q, D, ne, oe, ee, $, E, H, ie) {
              const ue = Q.split(/\r\n?|\n/), fe = [], de = oe - 2 * E;
              for (const De of ue) {
                const Ae = this._splitLine(De, D, ne, de);
                for (const Se of Ae) {
                  const ke = fe.length === 0 ? E : 0;
                  fe.push(this._renderText(Se, D, ne, oe, $, ke, -ne));
                }
              }
              const pe = fe.join(`
`);
              return `/Tx BMC q ${this.getBorderAndBackgroundAppearances(ie)}BT ` + N + ` 1 0 0 1 0 ${ee} Tm ${pe} ET Q EMC`;
            }
            _splitLine(N, Q, D, ne, oe = {}) {
              N = oe.line || Q.encodeString(N).join("");
              const ee = oe.glyphs || Q.charsToGlyphs(N);
              if (ee.length <= 1)
                return [N];
              const $ = oe.positions || Q.getCharPositions(N), E = D / 1e3, H = [];
              let ie = -1, ue = -1, fe = -1, de = 0, pe = 0;
              for (let xe = 0, De = ee.length; xe < De; xe++) {
                const [Ae, Se] = $[xe], ke = ee[xe], ye = ke.width * E;
                ke.unicode === " " ? pe + ye > ne ? (H.push(N.substring(de, Ae)), de = Ae, pe = ye, ie = -1, fe = -1) : (pe += ye, ie = Ae, ue = Se, fe = xe) : pe + ye > ne ? ie !== -1 ? (H.push(N.substring(de, ue)), de = ue, xe = fe + 1, ie = -1, pe = 0) : (H.push(N.substring(de, Ae)), de = Ae, pe = ye) : pe += ye;
              }
              return de < N.length && H.push(N.substring(de, N.length)), H;
            }
            getFieldObject() {
              return {
                id: this.data.id,
                value: this.data.fieldValue,
                defaultValue: this.data.defaultFieldValue || "",
                multiline: this.data.multiLine,
                password: this.hasFieldFlag(t.AnnotationFieldFlag.PASSWORD),
                charLimit: this.data.maxLen,
                comb: this.data.comb,
                editable: !this.data.readOnly,
                hidden: this.data.hidden,
                name: this.data.fieldName,
                rect: this.data.rect,
                actions: this.data.actions,
                page: this.data.pageIndex,
                strokeColor: this.data.borderColor,
                fillColor: this.data.backgroundColor,
                rotation: this.rotation,
                type: "text"
              };
            }
          }
          class R extends X {
            constructor(N) {
              super(N), this.checkedAppearance = null, this.uncheckedAppearance = null, this.data.checkBox = !this.hasFieldFlag(t.AnnotationFieldFlag.RADIO) && !this.hasFieldFlag(t.AnnotationFieldFlag.PUSHBUTTON), this.data.radioButton = this.hasFieldFlag(t.AnnotationFieldFlag.RADIO) && !this.hasFieldFlag(t.AnnotationFieldFlag.PUSHBUTTON), this.data.pushButton = this.hasFieldFlag(t.AnnotationFieldFlag.PUSHBUTTON), this.data.isTooltipOnly = !1, this.data.checkBox ? this._processCheckBox(N) : this.data.radioButton ? this._processRadioButton(N) : this.data.pushButton ? (this.data.hasOwnCanvas = !0, this._processPushButton(N)) : (0, t.warn)("Invalid field flags for button widget annotation");
            }
            async getOperatorList(N, Q, D, ne, oe) {
              if (this.data.pushButton)
                return super.getOperatorList(N, Q, D, !1, oe);
              let ee = null, $ = null;
              if (oe) {
                const H = oe.get(this.data.id);
                ee = H ? H.value : null, $ = H ? H.rotation : null;
              }
              if (ee === null && this.appearance)
                return super.getOperatorList(N, Q, D, ne, oe);
              ee == null && (this.data.checkBox ? ee = this.data.fieldValue === this.data.exportValue : ee = this.data.fieldValue === this.data.buttonValue);
              const E = ee ? this.checkedAppearance : this.uncheckedAppearance;
              if (E) {
                const H = this.appearance, ie = E.dict.getArray("Matrix") || t.IDENTITY_MATRIX;
                $ && E.dict.set("Matrix", this.getRotationMatrix(oe)), this.appearance = E;
                const ue = super.getOperatorList(N, Q, D, ne, oe);
                return this.appearance = H, E.dict.set("Matrix", ie), ue;
              }
              return {
                opList: new n.OperatorList(),
                separateForm: !1,
                separateCanvas: !1
              };
            }
            async save(N, Q, D) {
              return this.data.checkBox ? this._saveCheckbox(N, Q, D) : this.data.radioButton ? this._saveRadioButton(N, Q, D) : null;
            }
            async _saveCheckbox(N, Q, D) {
              if (!D)
                return null;
              const ne = D.get(this.data.id);
              let oe = ne && ne.rotation, ee = ne && ne.value;
              if (oe === void 0 && (ee === void 0 || this.data.fieldValue === this.data.exportValue === ee))
                return null;
              const $ = N.xref.fetchIfRef(this.ref);
              if (!($ instanceof h.Dict))
                return null;
              oe === void 0 && (oe = this.rotation), ee === void 0 && (ee = this.data.fieldValue === this.data.exportValue);
              const E = {
                path: (0, t.stringToPDFString)($.get("T") || ""),
                value: ee ? this.data.exportValue : ""
              }, H = h.Name.get(ee ? this.data.exportValue : "Off");
              $.set("V", H), $.set("AS", H), $.set("M", `D:${(0, t.getModificationDate)()}`);
              const ie = this._getMKDict(oe);
              ie && $.set("MK", ie);
              const ue = N.xref.encrypt;
              let fe = null;
              ue && (fe = ue.createCipherTransform(this.ref.num, this.ref.gen));
              const de = [`${this.ref.num} ${this.ref.gen} obj
`];
              return (0, e.writeDict)($, de, fe), de.push(`
endobj
`), [{
                ref: this.ref,
                data: de.join(""),
                xfa: E
              }];
            }
            async _saveRadioButton(N, Q, D) {
              if (!D)
                return null;
              const ne = D.get(this.data.id);
              let oe = ne && ne.rotation, ee = ne && ne.value;
              if (oe === void 0 && (ee === void 0 || this.data.fieldValue === this.data.buttonValue === ee))
                return null;
              const $ = N.xref.fetchIfRef(this.ref);
              if (!($ instanceof h.Dict))
                return null;
              ee === void 0 && (ee = this.data.fieldValue === this.data.buttonValue), oe === void 0 && (oe = this.rotation);
              const E = {
                path: (0, t.stringToPDFString)($.get("T") || ""),
                value: ee ? this.data.buttonValue : ""
              }, H = h.Name.get(ee ? this.data.buttonValue : "Off");
              let ie = null;
              const ue = N.xref.encrypt;
              if (ee)
                if (this.parent instanceof h.Ref) {
                  const De = N.xref.fetch(this.parent);
                  let Ae = null;
                  ue && (Ae = ue.createCipherTransform(this.parent.num, this.parent.gen)), De.set("V", H), ie = [`${this.parent.num} ${this.parent.gen} obj
`], (0, e.writeDict)(De, ie, Ae), ie.push(`
endobj
`);
                } else
                  this.parent instanceof h.Dict && this.parent.set("V", H);
              $.set("AS", H), $.set("M", `D:${(0, t.getModificationDate)()}`);
              const fe = this._getMKDict(oe);
              fe && $.set("MK", fe);
              let de = null;
              ue && (de = ue.createCipherTransform(this.ref.num, this.ref.gen));
              const pe = [`${this.ref.num} ${this.ref.gen} obj
`];
              (0, e.writeDict)($, pe, de), pe.push(`
endobj
`);
              const xe = [{
                ref: this.ref,
                data: pe.join(""),
                xfa: E
              }];
              return ie !== null && xe.push({
                ref: this.parent,
                data: ie.join(""),
                xfa: null
              }), xe;
            }
            _getDefaultCheckedAppearance(N, Q) {
              const D = this.data.rect[2] - this.data.rect[0], ne = this.data.rect[3] - this.data.rect[1], oe = [0, 0, D, ne], ee = 0.8, $ = Math.min(D, ne) * ee;
              let E, H;
              Q === "check" ? (E = {
                width: 0.755 * $,
                height: 0.705 * $
              }, H = "3") : Q === "disc" ? (E = {
                width: 0.791 * $,
                height: 0.705 * $
              }, H = "l") : (0, t.unreachable)(`_getDefaultCheckedAppearance - unsupported type: ${Q}`);
              const ie = (0, a.numberToString)((D - E.width) / 2), ue = (0, a.numberToString)((ne - E.height) / 2), fe = `q BT /PdfJsZaDb ${$} Tf 0 g ${ie} ${ue} Td (${H}) Tj ET Q`, de = new h.Dict(N.xref);
              de.set("FormType", 1), de.set("Subtype", h.Name.get("Form")), de.set("Type", h.Name.get("XObject")), de.set("BBox", oe), de.set("Matrix", [1, 0, 0, 1, 0, 0]), de.set("Length", fe.length);
              const pe = new h.Dict(N.xref), xe = new h.Dict(N.xref);
              xe.set("PdfJsZaDb", this.fallbackFontDict), pe.set("Font", xe), de.set("Resources", pe), this.checkedAppearance = new i.StringStream(fe), this.checkedAppearance.dict = de, this._streams.push(this.checkedAppearance);
            }
            _processCheckBox(N) {
              const Q = N.dict.get("AP");
              if (!(Q instanceof h.Dict))
                return;
              const D = Q.get("N");
              if (!(D instanceof h.Dict))
                return;
              const ne = this._decodeFormValue(N.dict.get("AS"));
              typeof ne == "string" && (this.data.fieldValue = ne);
              const oe = this.data.fieldValue !== null && this.data.fieldValue !== "Off" ? this.data.fieldValue : "Yes", ee = D.getKeys();
              if (ee.length === 0)
                ee.push("Off", oe);
              else if (ee.length === 1)
                ee[0] === "Off" ? ee.push(oe) : ee.unshift("Off");
              else if (ee.includes(oe))
                ee.length = 0, ee.push("Off", oe);
              else {
                const $ = ee.find((E) => E !== "Off");
                ee.length = 0, ee.push("Off", $);
              }
              ee.includes(this.data.fieldValue) || (this.data.fieldValue = "Off"), this.data.exportValue = ee[1], this.checkedAppearance = D.get(this.data.exportValue) || null, this.uncheckedAppearance = D.get("Off") || null, this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(N, "check"), this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance), this._fallbackFontDict = this.fallbackFontDict;
            }
            _processRadioButton(N) {
              this.data.fieldValue = this.data.buttonValue = null;
              const Q = N.dict.get("Parent");
              if (Q instanceof h.Dict) {
                this.parent = N.dict.getRaw("Parent");
                const oe = Q.get("V");
                oe instanceof h.Name && (this.data.fieldValue = this._decodeFormValue(oe));
              }
              const D = N.dict.get("AP");
              if (!(D instanceof h.Dict))
                return;
              const ne = D.get("N");
              if (ne instanceof h.Dict) {
                for (const oe of ne.getKeys())
                  if (oe !== "Off") {
                    this.data.buttonValue = this._decodeFormValue(oe);
                    break;
                  }
                this.checkedAppearance = ne.get(this.data.buttonValue) || null, this.uncheckedAppearance = ne.get("Off") || null, this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(N, "disc"), this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance), this._fallbackFontDict = this.fallbackFontDict;
              }
            }
            _processPushButton(N) {
              if (!N.dict.has("A") && !N.dict.has("AA") && !this.data.alternativeText) {
                (0, t.warn)("Push buttons without action dictionaries are not supported");
                return;
              }
              this.data.isTooltipOnly = !N.dict.has("A") && !N.dict.has("AA"), d.Catalog.parseDestDictionary({
                destDict: N.dict,
                resultObj: this.data,
                docBaseUrl: N.pdfManager.docBaseUrl
              });
            }
            getFieldObject() {
              let N = "button", Q;
              return this.data.checkBox ? (N = "checkbox", Q = this.data.exportValue) : this.data.radioButton && (N = "radiobutton", Q = this.data.buttonValue), {
                id: this.data.id,
                value: this.data.fieldValue || "Off",
                defaultValue: this.data.defaultFieldValue,
                exportValues: Q,
                editable: !this.data.readOnly,
                name: this.data.fieldName,
                rect: this.data.rect,
                hidden: this.data.hidden,
                actions: this.data.actions,
                page: this.data.pageIndex,
                strokeColor: this.data.borderColor,
                fillColor: this.data.backgroundColor,
                rotation: this.rotation,
                type: N
              };
            }
            get fallbackFontDict() {
              const N = new h.Dict();
              return N.set("BaseFont", h.Name.get("ZapfDingbats")), N.set("Type", h.Name.get("FallbackType")), N.set("Subtype", h.Name.get("FallbackType")), N.set("Encoding", h.Name.get("ZapfDingbatsEncoding")), (0, t.shadow)(this, "fallbackFontDict", N);
            }
          }
          class k extends X {
            constructor(N) {
              super(N), this.data.options = [];
              const Q = (0, a.getInheritableProperty)({
                dict: N.dict,
                key: "Opt"
              });
              if (Array.isArray(Q)) {
                const D = N.xref;
                for (let ne = 0, oe = Q.length; ne < oe; ne++) {
                  const ee = D.fetchIfRef(Q[ne]), $ = Array.isArray(ee);
                  this.data.options[ne] = {
                    exportValue: this._decodeFormValue($ ? D.fetchIfRef(ee[0]) : ee),
                    displayValue: this._decodeFormValue($ ? D.fetchIfRef(ee[1]) : ee)
                  };
                }
              }
              typeof this.data.fieldValue == "string" ? this.data.fieldValue = [this.data.fieldValue] : this.data.fieldValue || (this.data.fieldValue = []), this.data.combo = this.hasFieldFlag(t.AnnotationFieldFlag.COMBO), this.data.multiSelect = this.hasFieldFlag(t.AnnotationFieldFlag.MULTISELECT), this._hasText = !0;
            }
            getFieldObject() {
              const N = this.data.combo ? "combobox" : "listbox", Q = this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
              return {
                id: this.data.id,
                value: Q,
                defaultValue: this.data.defaultFieldValue,
                editable: !this.data.readOnly,
                name: this.data.fieldName,
                rect: this.data.rect,
                numItems: this.data.fieldValue.length,
                multipleSelection: this.data.multiSelect,
                hidden: this.data.hidden,
                actions: this.data.actions,
                items: this.data.options,
                page: this.data.pageIndex,
                strokeColor: this.data.borderColor,
                fillColor: this.data.backgroundColor,
                rotation: this.rotation,
                type: N
              };
            }
            async _getAppearance(N, Q, D) {
              if (this.data.combo)
                return super._getAppearance(N, Q, D);
              if (!D)
                return null;
              const ne = D.get(this.data.id);
              if (!ne)
                return null;
              const oe = ne.rotation;
              let ee = ne.value;
              if (oe === void 0 && ee === void 0)
                return null;
              ee === void 0 ? ee = this.data.fieldValue : Array.isArray(ee) || (ee = [ee]);
              const $ = 2, E = $;
              let H = this.data.rect[3] - this.data.rect[1], ie = this.data.rect[2] - this.data.rect[0];
              (oe === 90 || oe === 270) && ([ie, H] = [H, ie]);
              const ue = this.data.options.length, fe = [];
              for (let we = 0; we < ue; we++) {
                const {
                  exportValue: Ce
                } = this.data.options[we];
                ee.includes(Ce) && fe.push(we);
              }
              this._defaultAppearance || (this.data.defaultAppearanceData = (0, v.parseDefaultAppearance)(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
              const de = await X._getFontData(N, Q, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
              let pe, {
                fontSize: xe
              } = this.data.defaultAppearanceData;
              if (xe)
                pe = this._defaultAppearance;
              else {
                const we = (H - $) / ue;
                let Ce = -1, ve;
                for (const {
                  displayValue: Le
                } of this.data.options) {
                  const He = this._getTextWidth(Le, de);
                  He > Ce && (Ce = He, ve = Le);
                }
                [pe, xe] = this._computeFontSize(we, ie - 2 * E, ve, de, -1);
              }
              const De = xe * t.LINE_FACTOR, Ae = (De - xe) / 2, Se = Math.floor(H / De);
              let ke;
              if (fe.length === 1) {
                const we = fe[0], Ce = we % Se;
                ke = we - Ce;
              } else
                ke = fe.length ? fe[0] : 0;
              const ye = Math.min(ke + Se + 1, ue), _e = ["/Tx BMC q", `1 1 ${ie} ${H} re W n`];
              if (fe.length) {
                _e.push("0.600006 0.756866 0.854904 rg");
                for (const we of fe)
                  ke <= we && we < ye && _e.push(`1 ${H - (we - ke + 1) * De} ${ie} ${De} re f`);
              }
              _e.push("BT", pe, `1 0 0 1 0 ${H} Tm`);
              for (let we = ke; we < ye; we++) {
                const {
                  displayValue: Ce
                } = this.data.options[we], ve = we === ke ? E : 0, Le = we === ke ? Ae : 0;
                _e.push(this._renderText(Ce, de, xe, ie, 0, ve, -De + Le));
              }
              return _e.push("ET Q EMC"), _e.join(`
`);
            }
          }
          class x extends X {
            constructor(N) {
              super(N), this.data.fieldValue = null;
            }
            getFieldObject() {
              return {
                id: this.data.id,
                value: null,
                page: this.data.pageIndex,
                type: "signature"
              };
            }
          }
          class f extends j {
            constructor(N) {
              super(N);
              const D = N.dict;
              this.data.annotationType = t.AnnotationType.TEXT, this.data.hasAppearance ? this.data.name = "NoIcon" : (this.data.rect[1] = this.data.rect[3] - 22, this.data.rect[2] = this.data.rect[0] + 22, this.data.name = D.has("Name") ? D.get("Name").name : "Note"), D.has("State") ? (this.data.state = D.get("State") || null, this.data.stateModel = D.get("StateModel") || null) : (this.data.state = null, this.data.stateModel = null);
            }
          }
          class U extends A {
            constructor(N) {
              super(N), this.data.annotationType = t.AnnotationType.LINK;
              const Q = _(N.dict, this.rectangle);
              Q && (this.data.quadPoints = Q), this.data.borderColor = this.data.borderColor || this.data.color, d.Catalog.parseDestDictionary({
                destDict: N.dict,
                resultObj: this.data,
                docBaseUrl: N.pdfManager.docBaseUrl
              });
            }
          }
          class O extends A {
            constructor(N) {
              super(N), this.data.annotationType = t.AnnotationType.POPUP;
              let Q = N.dict.get("Parent");
              if (!Q) {
                (0, t.warn)("Popup annotation has a missing or invalid parent annotation.");
                return;
              }
              const D = Q.get("Subtype");
              this.data.parentType = D instanceof h.Name ? D.name : null;
              const ne = N.dict.getRaw("Parent");
              this.data.parentId = ne instanceof h.Ref ? ne.toString() : null;
              const oe = Q.getArray("Rect");
              Array.isArray(oe) && oe.length === 4 ? this.data.parentRect = t.Util.normalizeRect(oe) : this.data.parentRect = [0, 0, 0, 0];
              const ee = Q.get("RT");
              if ((0, h.isName)(ee, t.AnnotationReplyType.GROUP) && (Q = Q.get("IRT")), Q.has("M") ? (this.setModificationDate(Q.get("M")), this.data.modificationDate = this.modificationDate) : this.data.modificationDate = null, Q.has("C") ? (this.setColor(Q.getArray("C")), this.data.color = this.color) : this.data.color = null, !this.viewable) {
                const $ = Q.get("F");
                this._isViewable($) && this.setFlags($);
              }
              this.setTitle(Q.get("T")), this.data.titleObj = this._title, this.setContents(Q.get("Contents")), this.data.contentsObj = this._contents, Q.has("RC") && (this.data.richText = l.XFAFactory.getRichTextAsHtml(Q.get("RC")));
            }
          }
          o.PopupAnnotation = O;
          class S extends j {
            constructor(N) {
              super(N), this.data.annotationType = t.AnnotationType.FREETEXT;
            }
            get hasTextContent() {
              return !!this.appearance;
            }
            static createNewDict(N, Q, {
              apRef: D,
              ap: ne
            }) {
              const {
                color: oe,
                fontSize: ee,
                rect: $,
                rotation: E,
                user: H,
                value: ie
              } = N, ue = new h.Dict(Q);
              ue.set("Type", h.Name.get("Annot")), ue.set("Subtype", h.Name.get("FreeText")), ue.set("CreationDate", `D:${(0, t.getModificationDate)()}`), ue.set("Rect", $);
              const fe = `/Helv ${ee} Tf ${(0, v.getPdfColor)(oe, !0)}`;
              ue.set("DA", fe), ue.set("Contents", ie), ue.set("F", 4), ue.set("Border", [0, 0, 0]), ue.set("Rotate", E), H && ue.set("T", (0, t.stringToUTF8String)(H));
              const de = new h.Dict(Q);
              return ue.set("AP", de), D ? de.set("N", D) : de.set("N", ne), ue;
            }
            static async createNewAppearanceStream(N, Q, D) {
              const {
                baseFontRef: ne,
                evaluator: oe,
                task: ee
              } = D, {
                color: $,
                fontSize: E,
                rect: H,
                rotation: ie,
                value: ue
              } = N, fe = new h.Dict(Q), de = new h.Dict(Q);
              if (ne)
                de.set("Helv", ne);
              else {
                const Ze = new h.Dict(Q);
                Ze.set("BaseFont", h.Name.get("Helvetica")), Ze.set("Type", h.Name.get("Font")), Ze.set("Subtype", h.Name.get("Type1")), Ze.set("Encoding", h.Name.get("WinAnsiEncoding")), de.set("Helv", Ze);
              }
              fe.set("Font", de);
              const pe = await X._getFontData(oe, ee, {
                fontName: "Helvetica",
                fontSize: E
              }, fe), [xe, De, Ae, Se] = H;
              let ke = Ae - xe, ye = Se - De;
              ie % 180 !== 0 && ([ke, ye] = [ye, ke]);
              const _e = ue.split(`
`), we = E / 1e3;
              let Ce = -1 / 0;
              const ve = [];
              for (let Ze of _e) {
                Ze = pe.encodeString(Ze).join(""), ve.push(Ze);
                let Me = 0;
                const at = pe.charsToGlyphs(Ze);
                for (const rt of at)
                  Me += rt.width * we;
                Ce = Math.max(Ce, Me);
              }
              let Le = 1;
              Ce > ke && (Le = ke / Ce);
              let He = 1;
              const Qe = t.LINE_FACTOR * E, Ue = t.LINE_DESCENT_FACTOR * E, Ie = Qe * _e.length;
              Ie > ye && (He = ye / Ie);
              const Ee = Math.min(Le, He), et = E * Ee, qe = ["q", `0 0 ${(0, a.numberToString)(ke)} ${(0, a.numberToString)(ye)} re W n`, "BT", `1 0 0 1 0 ${(0, a.numberToString)(ye + Ue)} Tm 0 Tc ${(0, v.getPdfColor)($, !0)}`, `/Helv ${(0, a.numberToString)(et)} Tf`], tt = (0, a.numberToString)(Qe);
              for (const Ze of ve)
                qe.push(`0 -${tt} Td (${(0, t.escapeString)(Ze)}) Tj`);
              qe.push("ET", "Q");
              const ft = qe.join(`
`), Te = new h.Dict(Q);
              if (Te.set("FormType", 1), Te.set("Subtype", h.Name.get("Form")), Te.set("Type", h.Name.get("XObject")), Te.set("BBox", [0, 0, ke, ye]), Te.set("Length", ft.length), Te.set("Resources", fe), ie) {
                const Ze = X._getRotationMatrix(ie, ke, ye);
                Te.set("Matrix", Ze);
              }
              const je = new i.StringStream(ft);
              return je.dict = Te, je;
            }
          }
          class F extends j {
            constructor(N) {
              super(N);
              const {
                dict: Q
              } = N;
              this.data.annotationType = t.AnnotationType.LINE;
              const D = Q.getArray("L");
              if (this.data.lineCoordinates = t.Util.normalizeRect(D), this.setLineEndings(Q.getArray("LE")), this.data.lineEndings = this.lineEndings, !this.appearance) {
                const ne = this.color ? Array.from(this.color).map((fe) => fe / 255) : [0, 0, 0], oe = Q.get("CA");
                let ee = null, $ = Q.getArray("IC");
                $ && ($ = w($, null), ee = $ ? Array.from($).map((fe) => fe / 255) : null);
                const E = ee ? oe : null, H = this.borderStyle.width || 1, ie = 2 * H, ue = [this.data.lineCoordinates[0] - ie, this.data.lineCoordinates[1] - ie, this.data.lineCoordinates[2] + ie, this.data.lineCoordinates[3] + ie];
                t.Util.intersect(this.rectangle, ue) || (this.rectangle = ue), this._setDefaultAppearance({
                  xref: N.xref,
                  extra: `${H} w`,
                  strokeColor: ne,
                  fillColor: ee,
                  strokeAlpha: oe,
                  fillAlpha: E,
                  pointsCallback: (fe, de) => (fe.push(`${D[0]} ${D[1]} m`, `${D[2]} ${D[3]} l`, "S"), [de[0].x - H, de[1].x + H, de[3].y - H, de[1].y + H])
                });
              }
            }
          }
          class T extends j {
            constructor(N) {
              if (super(N), this.data.annotationType = t.AnnotationType.SQUARE, !this.appearance) {
                const Q = this.color ? Array.from(this.color).map(($) => $ / 255) : [0, 0, 0], D = N.dict.get("CA");
                let ne = null, oe = N.dict.getArray("IC");
                oe && (oe = w(oe, null), ne = oe ? Array.from(oe).map(($) => $ / 255) : null);
                const ee = ne ? D : null;
                if (this.borderStyle.width === 0 && !ne)
                  return;
                this._setDefaultAppearance({
                  xref: N.xref,
                  extra: `${this.borderStyle.width} w`,
                  strokeColor: Q,
                  fillColor: ne,
                  strokeAlpha: D,
                  fillAlpha: ee,
                  pointsCallback: ($, E) => {
                    const H = E[2].x + this.borderStyle.width / 2, ie = E[2].y + this.borderStyle.width / 2, ue = E[3].x - E[2].x - this.borderStyle.width, fe = E[1].y - E[3].y - this.borderStyle.width;
                    return $.push(`${H} ${ie} ${ue} ${fe} re`), ne ? $.push("B") : $.push("S"), [E[0].x, E[1].x, E[3].y, E[1].y];
                  }
                });
              }
            }
          }
          class I extends j {
            constructor(N) {
              if (super(N), this.data.annotationType = t.AnnotationType.CIRCLE, !this.appearance) {
                const Q = this.color ? Array.from(this.color).map((E) => E / 255) : [0, 0, 0], D = N.dict.get("CA");
                let ne = null, oe = N.dict.getArray("IC");
                oe && (oe = w(oe, null), ne = oe ? Array.from(oe).map((E) => E / 255) : null);
                const ee = ne ? D : null;
                if (this.borderStyle.width === 0 && !ne)
                  return;
                const $ = 4 / 3 * Math.tan(Math.PI / (2 * 4));
                this._setDefaultAppearance({
                  xref: N.xref,
                  extra: `${this.borderStyle.width} w`,
                  strokeColor: Q,
                  fillColor: ne,
                  strokeAlpha: D,
                  fillAlpha: ee,
                  pointsCallback: (E, H) => {
                    const ie = H[0].x + this.borderStyle.width / 2, ue = H[0].y - this.borderStyle.width / 2, fe = H[3].x - this.borderStyle.width / 2, de = H[3].y + this.borderStyle.width / 2, pe = ie + (fe - ie) / 2, xe = ue + (de - ue) / 2, De = (fe - ie) / 2 * $, Ae = (de - ue) / 2 * $;
                    return E.push(`${pe} ${de} m`, `${pe + De} ${de} ${fe} ${xe + Ae} ${fe} ${xe} c`, `${fe} ${xe - Ae} ${pe + De} ${ue} ${pe} ${ue} c`, `${pe - De} ${ue} ${ie} ${xe - Ae} ${ie} ${xe} c`, `${ie} ${xe + Ae} ${pe - De} ${de} ${pe} ${de} c`, "h"), ne ? E.push("B") : E.push("S"), [H[0].x, H[1].x, H[3].y, H[1].y];
                  }
                });
              }
            }
          }
          class M extends j {
            constructor(N) {
              super(N);
              const {
                dict: Q
              } = N;
              this.data.annotationType = t.AnnotationType.POLYLINE, this.data.vertices = [], this instanceof V || (this.setLineEndings(Q.getArray("LE")), this.data.lineEndings = this.lineEndings);
              const D = Q.getArray("Vertices");
              if (Array.isArray(D)) {
                for (let ne = 0, oe = D.length; ne < oe; ne += 2)
                  this.data.vertices.push({
                    x: D[ne],
                    y: D[ne + 1]
                  });
                if (!this.appearance) {
                  const ne = this.color ? Array.from(this.color).map((H) => H / 255) : [0, 0, 0], oe = Q.get("CA"), ee = this.borderStyle.width || 1, $ = 2 * ee, E = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                  for (const H of this.data.vertices)
                    E[0] = Math.min(E[0], H.x - $), E[1] = Math.min(E[1], H.y - $), E[2] = Math.max(E[2], H.x + $), E[3] = Math.max(E[3], H.y + $);
                  t.Util.intersect(this.rectangle, E) || (this.rectangle = E), this._setDefaultAppearance({
                    xref: N.xref,
                    extra: `${ee} w`,
                    strokeColor: ne,
                    strokeAlpha: oe,
                    pointsCallback: (H, ie) => {
                      const ue = this.data.vertices;
                      for (let fe = 0, de = ue.length; fe < de; fe++)
                        H.push(`${ue[fe].x} ${ue[fe].y} ${fe === 0 ? "m" : "l"}`);
                      return H.push("S"), [ie[0].x, ie[1].x, ie[3].y, ie[1].y];
                    }
                  });
                }
              }
            }
          }
          class V extends M {
            constructor(N) {
              super(N), this.data.annotationType = t.AnnotationType.POLYGON;
            }
          }
          class J extends j {
            constructor(N) {
              super(N), this.data.annotationType = t.AnnotationType.CARET;
            }
          }
          class W extends j {
            constructor(N) {
              super(N), this.data.annotationType = t.AnnotationType.INK, this.data.inkLists = [];
              const Q = N.dict.getArray("InkList");
              if (!Array.isArray(Q))
                return;
              const D = N.xref;
              for (let ne = 0, oe = Q.length; ne < oe; ++ne) {
                this.data.inkLists.push([]);
                for (let ee = 0, $ = Q[ne].length; ee < $; ee += 2)
                  this.data.inkLists[ne].push({
                    x: D.fetchIfRef(Q[ne][ee]),
                    y: D.fetchIfRef(Q[ne][ee + 1])
                  });
              }
              if (!this.appearance) {
                const ne = this.color ? Array.from(this.color).map((H) => H / 255) : [0, 0, 0], oe = N.dict.get("CA"), ee = this.borderStyle.width || 1, $ = 2 * ee, E = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                for (const H of this.data.inkLists)
                  for (const ie of H)
                    E[0] = Math.min(E[0], ie.x - $), E[1] = Math.min(E[1], ie.y - $), E[2] = Math.max(E[2], ie.x + $), E[3] = Math.max(E[3], ie.y + $);
                t.Util.intersect(this.rectangle, E) || (this.rectangle = E), this._setDefaultAppearance({
                  xref: N.xref,
                  extra: `${ee} w`,
                  strokeColor: ne,
                  strokeAlpha: oe,
                  pointsCallback: (H, ie) => {
                    for (const ue of this.data.inkLists) {
                      for (let fe = 0, de = ue.length; fe < de; fe++)
                        H.push(`${ue[fe].x} ${ue[fe].y} ${fe === 0 ? "m" : "l"}`);
                      H.push("S");
                    }
                    return [ie[0].x, ie[1].x, ie[3].y, ie[1].y];
                  }
                });
              }
            }
            static createNewDict(N, Q, {
              apRef: D,
              ap: ne
            }) {
              const {
                paths: oe,
                rect: ee,
                rotation: $
              } = N, E = new h.Dict(Q);
              E.set("Type", h.Name.get("Annot")), E.set("Subtype", h.Name.get("Ink")), E.set("CreationDate", `D:${(0, t.getModificationDate)()}`), E.set("Rect", ee), E.set("InkList", oe.map((ie) => ie.points)), E.set("F", 4), E.set("Border", [0, 0, 0]), E.set("Rotate", $);
              const H = new h.Dict(Q);
              return E.set("AP", H), D ? H.set("N", D) : H.set("N", ne), E;
            }
            static async createNewAppearanceStream(N, Q, D) {
              const {
                color: ne,
                rect: oe,
                rotation: ee,
                paths: $,
                thickness: E,
                opacity: H
              } = N, [ie, ue, fe, de] = oe;
              let pe = fe - ie, xe = de - ue;
              ee % 180 !== 0 && ([pe, xe] = [xe, pe]);
              const De = [`${E} w 1 J 1 j`, `${(0, v.getPdfColor)(ne, !1)}`];
              H !== 1 && De.push("/R0 gs");
              const Ae = [];
              for (const {
                bezier: _e
              } of $) {
                Ae.length = 0, Ae.push(`${(0, a.numberToString)(_e[0])} ${(0, a.numberToString)(_e[1])} m`);
                for (let we = 2, Ce = _e.length; we < Ce; we += 6) {
                  const ve = _e.slice(we, we + 6).map(a.numberToString).join(" ");
                  Ae.push(`${ve} c`);
                }
                Ae.push("S"), De.push(Ae.join(`
`));
              }
              const Se = De.join(`
`), ke = new h.Dict(Q);
              if (ke.set("FormType", 1), ke.set("Subtype", h.Name.get("Form")), ke.set("Type", h.Name.get("XObject")), ke.set("BBox", [0, 0, pe, xe]), ke.set("Length", Se.length), ee) {
                const _e = X._getRotationMatrix(ee, pe, xe);
                ke.set("Matrix", _e);
              }
              if (H !== 1) {
                const _e = new h.Dict(Q), we = new h.Dict(Q), Ce = new h.Dict(Q);
                Ce.set("CA", H), Ce.set("Type", h.Name.get("ExtGState")), we.set("R0", Ce), _e.set("ExtGState", we), ke.set("Resources", _e);
              }
              const ye = new i.StringStream(Se);
              return ye.dict = ke, ye;
            }
          }
          class z extends j {
            constructor(N) {
              if (super(N), this.data.annotationType = t.AnnotationType.HIGHLIGHT, this.data.quadPoints = _(N.dict, null)) {
                const D = this.appearance && this.appearance.dict.get("Resources");
                if (!this.appearance || !(D && D.has("ExtGState"))) {
                  this.appearance && (0, t.warn)("HighlightAnnotation - ignoring built-in appearance stream.");
                  const ne = this.color ? Array.from(this.color).map((ee) => ee / 255) : [1, 1, 0], oe = N.dict.get("CA");
                  this._setDefaultAppearance({
                    xref: N.xref,
                    fillColor: ne,
                    blendMode: "Multiply",
                    fillAlpha: oe,
                    pointsCallback: (ee, $) => (ee.push(`${$[0].x} ${$[0].y} m`, `${$[1].x} ${$[1].y} l`, `${$[3].x} ${$[3].y} l`, `${$[2].x} ${$[2].y} l`, "f"), [$[0].x, $[1].x, $[3].y, $[1].y])
                  });
                }
              } else
                this.data.hasPopup = !1;
            }
          }
          class G extends j {
            constructor(N) {
              if (super(N), this.data.annotationType = t.AnnotationType.UNDERLINE, this.data.quadPoints = _(N.dict, null)) {
                if (!this.appearance) {
                  const D = this.color ? Array.from(this.color).map((oe) => oe / 255) : [0, 0, 0], ne = N.dict.get("CA");
                  this._setDefaultAppearance({
                    xref: N.xref,
                    extra: "[] 0 d 1 w",
                    strokeColor: D,
                    strokeAlpha: ne,
                    pointsCallback: (oe, ee) => (oe.push(`${ee[2].x} ${ee[2].y} m`, `${ee[3].x} ${ee[3].y} l`, "S"), [ee[0].x, ee[1].x, ee[3].y, ee[1].y])
                  });
                }
              } else
                this.data.hasPopup = !1;
            }
          }
          class L extends j {
            constructor(N) {
              if (super(N), this.data.annotationType = t.AnnotationType.SQUIGGLY, this.data.quadPoints = _(N.dict, null)) {
                if (!this.appearance) {
                  const D = this.color ? Array.from(this.color).map((oe) => oe / 255) : [0, 0, 0], ne = N.dict.get("CA");
                  this._setDefaultAppearance({
                    xref: N.xref,
                    extra: "[] 0 d 1 w",
                    strokeColor: D,
                    strokeAlpha: ne,
                    pointsCallback: (oe, ee) => {
                      const $ = (ee[0].y - ee[2].y) / 6;
                      let E = $, H = ee[2].x;
                      const ie = ee[2].y, ue = ee[3].x;
                      oe.push(`${H} ${ie + E} m`);
                      do
                        H += 2, E = E === 0 ? $ : 0, oe.push(`${H} ${ie + E} l`);
                      while (H < ue);
                      return oe.push("S"), [ee[2].x, ue, ie - 2 * $, ie + 2 * $];
                    }
                  });
                }
              } else
                this.data.hasPopup = !1;
            }
          }
          class K extends j {
            constructor(N) {
              if (super(N), this.data.annotationType = t.AnnotationType.STRIKEOUT, this.data.quadPoints = _(N.dict, null)) {
                if (!this.appearance) {
                  const D = this.color ? Array.from(this.color).map((oe) => oe / 255) : [0, 0, 0], ne = N.dict.get("CA");
                  this._setDefaultAppearance({
                    xref: N.xref,
                    extra: "[] 0 d 1 w",
                    strokeColor: D,
                    strokeAlpha: ne,
                    pointsCallback: (oe, ee) => (oe.push(`${(ee[0].x + ee[2].x) / 2} ${(ee[0].y + ee[2].y) / 2} m`, `${(ee[1].x + ee[3].x) / 2} ${(ee[1].y + ee[3].y) / 2} l`, "S"), [ee[0].x, ee[1].x, ee[3].y, ee[1].y])
                  });
                }
              } else
                this.data.hasPopup = !1;
            }
          }
          class te extends j {
            constructor(N) {
              super(N), this.data.annotationType = t.AnnotationType.STAMP;
            }
          }
          class se extends j {
            constructor(N) {
              super(N);
              const Q = new m.FileSpec(N.dict.get("FS"), N.xref);
              this.data.annotationType = t.AnnotationType.FILEATTACHMENT, this.data.file = Q.serializable;
            }
          }
        },
        /* 13 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.createDefaultAppearance = m, o.getPdfColor = p, o.parseDefaultAppearance = d;
          var t = C(6), a = C(2), v = C(14), h = C(15), e = C(5), y = C(10);
          class c extends h.EvaluatorPreprocessor {
            constructor(n) {
              super(new y.StringStream(n));
            }
            parse() {
              const n = {
                fn: 0,
                args: []
              }, i = {
                fontSize: 0,
                fontName: "",
                fontColor: new Uint8ClampedArray(3)
              };
              try {
                for (; n.args.length = 0, !!this.read(n); ) {
                  if (this.savedStatesDepth !== 0)
                    continue;
                  const {
                    fn: l,
                    args: u
                  } = n;
                  switch (l | 0) {
                    case a.OPS.setFont:
                      const [w, _] = u;
                      w instanceof e.Name && (i.fontName = w.name), typeof _ == "number" && _ > 0 && (i.fontSize = _);
                      break;
                    case a.OPS.setFillRGBColor:
                      v.ColorSpace.singletons.rgb.getRgbItem(u, 0, i.fontColor, 0);
                      break;
                    case a.OPS.setFillGray:
                      v.ColorSpace.singletons.gray.getRgbItem(u, 0, i.fontColor, 0);
                      break;
                    case a.OPS.setFillColorSpace:
                      v.ColorSpace.singletons.cmyk.getRgbItem(u, 0, i.fontColor, 0);
                      break;
                  }
                }
              } catch (l) {
                (0, a.warn)(`parseDefaultAppearance - ignoring errors: "${l}".`);
              }
              return i;
            }
          }
          function d(g) {
            return new c(g).parse();
          }
          function p(g, n) {
            if (g[0] === g[1] && g[1] === g[2]) {
              const i = g[0] / 255;
              return `${(0, t.numberToString)(i)} ${n ? "g" : "G"}`;
            }
            return Array.from(g).map((i) => (0, t.numberToString)(i / 255)).join(" ") + ` ${n ? "rg" : "RG"}`;
          }
          function m({
            fontSize: g,
            fontName: n,
            fontColor: i
          }) {
            return `/${(0, t.escapePDFName)(n)} ${g} Tf ${p(i, !0)}`;
          }
        },
        /* 14 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.ColorSpace = void 0;
          var t = C(2), a = C(5), v = C(7), h = C(6);
          function e(w, _, b, A, Y, j, X) {
            X = X !== 1 ? 0 : X;
            const R = b / Y, k = A / j;
            let x = 0, f;
            const U = new Uint16Array(Y), O = b * 3;
            for (let S = 0; S < Y; S++)
              U[S] = Math.floor(S * R) * 3;
            for (let S = 0; S < j; S++) {
              const F = Math.floor(S * k) * O;
              for (let T = 0; T < Y; T++)
                f = F + U[T], _[x++] = w[f++], _[x++] = w[f++], _[x++] = w[f++], x += X;
            }
          }
          class y {
            constructor(_, b) {
              this.constructor === y && (0, t.unreachable)("Cannot initialize ColorSpace."), this.name = _, this.numComps = b;
            }
            getRgb(_, b) {
              const A = new Uint8ClampedArray(3);
              return this.getRgbItem(_, b, A, 0), A;
            }
            getRgbItem(_, b, A, Y) {
              (0, t.unreachable)("Should not call ColorSpace.getRgbItem");
            }
            getRgbBuffer(_, b, A, Y, j, X, B) {
              (0, t.unreachable)("Should not call ColorSpace.getRgbBuffer");
            }
            getOutputLength(_, b) {
              (0, t.unreachable)("Should not call ColorSpace.getOutputLength");
            }
            isPassthrough(_) {
              return !1;
            }
            isDefaultDecode(_, b) {
              return y.isDefaultDecode(_, this.numComps);
            }
            fillRgb(_, b, A, Y, j, X, B, R, k) {
              const x = b * A;
              let f = null;
              const U = 1 << B, O = A !== j || b !== Y;
              if (this.isPassthrough(B))
                f = R;
              else if (this.numComps === 1 && x > U && this.name !== "DeviceGray" && this.name !== "DeviceRGB") {
                const S = B <= 8 ? new Uint8Array(U) : new Uint16Array(U);
                for (let T = 0; T < U; T++)
                  S[T] = T;
                const F = new Uint8ClampedArray(U * 3);
                if (this.getRgbBuffer(S, 0, U, F, 0, B, 0), O) {
                  f = new Uint8Array(x * 3);
                  let T = 0;
                  for (let I = 0; I < x; ++I) {
                    const M = R[I] * 3;
                    f[T++] = F[M], f[T++] = F[M + 1], f[T++] = F[M + 2];
                  }
                } else {
                  let T = 0;
                  for (let I = 0; I < x; ++I) {
                    const M = R[I] * 3;
                    _[T++] = F[M], _[T++] = F[M + 1], _[T++] = F[M + 2], T += k;
                  }
                }
              } else
                O ? (f = new Uint8ClampedArray(x * 3), this.getRgbBuffer(R, 0, x, f, 0, B, 0)) : this.getRgbBuffer(R, 0, Y * X, _, 0, B, k);
              if (f)
                if (O)
                  e(f, _, b, A, Y, j, k);
                else {
                  let S = 0, F = 0;
                  for (let T = 0, I = Y * X; T < I; T++)
                    _[S++] = f[F++], _[S++] = f[F++], _[S++] = f[F++], S += k;
                }
            }
            get usesZeroToOneRange() {
              return (0, t.shadow)(this, "usesZeroToOneRange", !0);
            }
            static _cache(_, b, A, Y) {
              if (!A)
                throw new Error('ColorSpace._cache - expected "localColorSpaceCache" argument.');
              if (!Y)
                throw new Error('ColorSpace._cache - expected "parsedColorSpace" argument.');
              let j, X;
              _ instanceof a.Ref && (X = _, _ = b.fetch(_)), _ instanceof a.Name && (j = _.name), (j || X) && A.set(j, X, Y);
            }
            static getCached(_, b, A) {
              if (!A)
                throw new Error('ColorSpace.getCached - expected "localColorSpaceCache" argument.');
              if (_ instanceof a.Ref) {
                const Y = A.getByRef(_);
                if (Y)
                  return Y;
                try {
                  _ = b.fetch(_);
                } catch (j) {
                  if (j instanceof h.MissingDataException)
                    throw j;
                }
              }
              if (_ instanceof a.Name) {
                const Y = A.getByName(_.name);
                if (Y)
                  return Y;
              }
              return null;
            }
            static async parseAsync({
              cs: _,
              xref: b,
              resources: A = null,
              pdfFunctionFactory: Y,
              localColorSpaceCache: j
            }) {
              const X = this._parse(_, b, A, Y);
              return this._cache(_, b, j, X), X;
            }
            static parse({
              cs: _,
              xref: b,
              resources: A = null,
              pdfFunctionFactory: Y,
              localColorSpaceCache: j
            }) {
              const X = this.getCached(_, b, j);
              if (X)
                return X;
              const B = this._parse(_, b, A, Y);
              return this._cache(_, b, j, B), B;
            }
            static _parse(_, b, A = null, Y) {
              if (_ = b.fetchIfRef(_), _ instanceof a.Name)
                switch (_.name) {
                  case "G":
                  case "DeviceGray":
                    return this.singletons.gray;
                  case "RGB":
                  case "DeviceRGB":
                    return this.singletons.rgb;
                  case "CMYK":
                  case "DeviceCMYK":
                    return this.singletons.cmyk;
                  case "Pattern":
                    return new d(null);
                  default:
                    if (A instanceof a.Dict) {
                      const j = A.get("ColorSpace");
                      if (j instanceof a.Dict) {
                        const X = j.get(_.name);
                        if (X) {
                          if (X instanceof a.Name)
                            return this._parse(X, b, A, Y);
                          _ = X;
                          break;
                        }
                      }
                    }
                    throw new t.FormatError(`Unrecognized ColorSpace: ${_.name}`);
                }
              if (Array.isArray(_)) {
                const j = b.fetchIfRef(_[0]).name;
                let X, B, R, k, x, f;
                switch (j) {
                  case "G":
                  case "DeviceGray":
                    return this.singletons.gray;
                  case "RGB":
                  case "DeviceRGB":
                    return this.singletons.rgb;
                  case "CMYK":
                  case "DeviceCMYK":
                    return this.singletons.cmyk;
                  case "CalGray":
                    return X = b.fetchIfRef(_[1]), k = X.getArray("WhitePoint"), x = X.getArray("BlackPoint"), f = X.get("Gamma"), new i(k, x, f);
                  case "CalRGB":
                    X = b.fetchIfRef(_[1]), k = X.getArray("WhitePoint"), x = X.getArray("BlackPoint"), f = X.getArray("Gamma");
                    const U = X.getArray("Matrix");
                    return new l(k, x, f, U);
                  case "ICCBased":
                    const S = b.fetchIfRef(_[1]).dict;
                    B = S.get("N");
                    const F = S.get("Alternate");
                    if (F) {
                      const W = this._parse(F, b, A, Y);
                      if (W.numComps === B)
                        return W;
                      (0, t.warn)("ICCBased color space: Ignoring incorrect /Alternate entry.");
                    }
                    if (B === 1)
                      return this.singletons.gray;
                    if (B === 3)
                      return this.singletons.rgb;
                    if (B === 4)
                      return this.singletons.cmyk;
                    break;
                  case "Pattern":
                    return R = _[1] || null, R && (R = this._parse(R, b, A, Y)), new d(R);
                  case "I":
                  case "Indexed":
                    R = this._parse(_[1], b, A, Y);
                    const T = b.fetchIfRef(_[2]) + 1, I = b.fetchIfRef(_[3]);
                    return new p(R, T, I);
                  case "Separation":
                  case "DeviceN":
                    const M = b.fetchIfRef(_[1]);
                    B = Array.isArray(M) ? M.length : 1, R = this._parse(_[2], b, A, Y);
                    const V = Y.create(_[3]);
                    return new c(B, R, V);
                  case "Lab":
                    X = b.fetchIfRef(_[1]), k = X.getArray("WhitePoint"), x = X.getArray("BlackPoint");
                    const J = X.getArray("Range");
                    return new u(k, x, J);
                  default:
                    throw new t.FormatError(`Unimplemented ColorSpace object: ${j}`);
                }
              }
              throw new t.FormatError(`Unrecognized ColorSpace object: ${_}`);
            }
            static isDefaultDecode(_, b) {
              if (!Array.isArray(_))
                return !0;
              if (b * 2 !== _.length)
                return (0, t.warn)("The decode map is not the correct length"), !0;
              for (let A = 0, Y = _.length; A < Y; A += 2)
                if (_[A] !== 0 || _[A + 1] !== 1)
                  return !1;
              return !0;
            }
            static get singletons() {
              return (0, t.shadow)(this, "singletons", {
                get gray() {
                  return (0, t.shadow)(this, "gray", new m());
                },
                get rgb() {
                  return (0, t.shadow)(this, "rgb", new g());
                },
                get cmyk() {
                  return (0, t.shadow)(this, "cmyk", new n());
                }
              });
            }
          }
          o.ColorSpace = y;
          class c extends y {
            constructor(_, b, A) {
              super("Alternate", _), this.base = b, this.tintFn = A, this.tmpBuf = new Float32Array(b.numComps);
            }
            getRgbItem(_, b, A, Y) {
              const j = this.tmpBuf;
              this.tintFn(_, b, j, 0), this.base.getRgbItem(j, 0, A, Y);
            }
            getRgbBuffer(_, b, A, Y, j, X, B) {
              const R = this.tintFn, k = this.base, x = 1 / ((1 << X) - 1), f = k.numComps, U = k.usesZeroToOneRange, O = (k.isPassthrough(8) || !U) && B === 0;
              let S = O ? j : 0;
              const F = O ? Y : new Uint8ClampedArray(f * A), T = this.numComps, I = new Float32Array(T), M = new Float32Array(f);
              let V, J;
              for (V = 0; V < A; V++) {
                for (J = 0; J < T; J++)
                  I[J] = _[b++] * x;
                if (R(I, 0, M, 0), U)
                  for (J = 0; J < f; J++)
                    F[S++] = M[J] * 255;
                else
                  k.getRgbItem(M, 0, F, S), S += f;
              }
              O || k.getRgbBuffer(F, 0, A, Y, j, 8, B);
            }
            getOutputLength(_, b) {
              return this.base.getOutputLength(_ * this.base.numComps / this.numComps, b);
            }
          }
          class d extends y {
            constructor(_) {
              super("Pattern", null), this.base = _;
            }
            isDefaultDecode(_, b) {
              (0, t.unreachable)("Should not call PatternCS.isDefaultDecode");
            }
          }
          class p extends y {
            constructor(_, b, A) {
              super("Indexed", 1), this.base = _, this.highVal = b;
              const Y = _.numComps * b;
              if (this.lookup = new Uint8Array(Y), A instanceof v.BaseStream) {
                const j = A.getBytes(Y);
                this.lookup.set(j);
              } else if (typeof A == "string")
                for (let j = 0; j < Y; ++j)
                  this.lookup[j] = A.charCodeAt(j) & 255;
              else
                throw new t.FormatError(`IndexedCS - unrecognized lookup table: ${A}`);
            }
            getRgbItem(_, b, A, Y) {
              const j = this.base.numComps, X = _[b] * j;
              this.base.getRgbBuffer(this.lookup, X, 1, A, Y, 8, 0);
            }
            getRgbBuffer(_, b, A, Y, j, X, B) {
              const R = this.base, k = R.numComps, x = R.getOutputLength(k, B), f = this.lookup;
              for (let U = 0; U < A; ++U) {
                const O = _[b++] * k;
                R.getRgbBuffer(f, O, 1, Y, j, 8, B), j += x;
              }
            }
            getOutputLength(_, b) {
              return this.base.getOutputLength(_ * this.base.numComps, b);
            }
            isDefaultDecode(_, b) {
              return Array.isArray(_) ? _.length !== 2 ? ((0, t.warn)("Decode map length is not correct"), !0) : !Number.isInteger(b) || b < 1 ? ((0, t.warn)("Bits per component is not correct"), !0) : _[0] === 0 && _[1] === (1 << b) - 1 : !0;
            }
          }
          class m extends y {
            constructor() {
              super("DeviceGray", 1);
            }
            getRgbItem(_, b, A, Y) {
              const j = _[b] * 255;
              A[Y] = A[Y + 1] = A[Y + 2] = j;
            }
            getRgbBuffer(_, b, A, Y, j, X, B) {
              const R = 255 / ((1 << X) - 1);
              let k = b, x = j;
              for (let f = 0; f < A; ++f) {
                const U = R * _[k++];
                Y[x++] = U, Y[x++] = U, Y[x++] = U, x += B;
              }
            }
            getOutputLength(_, b) {
              return _ * (3 + b);
            }
          }
          class g extends y {
            constructor() {
              super("DeviceRGB", 3);
            }
            getRgbItem(_, b, A, Y) {
              A[Y] = _[b] * 255, A[Y + 1] = _[b + 1] * 255, A[Y + 2] = _[b + 2] * 255;
            }
            getRgbBuffer(_, b, A, Y, j, X, B) {
              if (X === 8 && B === 0) {
                Y.set(_.subarray(b, b + A * 3), j);
                return;
              }
              const R = 255 / ((1 << X) - 1);
              let k = b, x = j;
              for (let f = 0; f < A; ++f)
                Y[x++] = R * _[k++], Y[x++] = R * _[k++], Y[x++] = R * _[k++], x += B;
            }
            getOutputLength(_, b) {
              return _ * (3 + b) / 3 | 0;
            }
            isPassthrough(_) {
              return _ === 8;
            }
          }
          const n = function() {
            function _(A, Y, j, X, B) {
              const R = A[Y] * j, k = A[Y + 1] * j, x = A[Y + 2] * j, f = A[Y + 3] * j;
              X[B] = 255 + R * (-4.387332384609988 * R + 54.48615194189176 * k + 18.82290502165302 * x + 212.25662451639585 * f + -285.2331026137004) + k * (1.7149763477362134 * k - 5.6096736904047315 * x + -17.873870861415444 * f - 5.497006427196366) + x * (-2.5217340131683033 * x - 21.248923337353073 * f + 17.5119270841813) + f * (-21.86122147463605 * f - 189.48180835922747), X[B + 1] = 255 + R * (8.841041422036149 * R + 60.118027045597366 * k + 6.871425592049007 * x + 31.159100130055922 * f + -79.2970844816548) + k * (-15.310361306967817 * k + 17.575251261109482 * x + 131.35250912493976 * f - 190.9453302588951) + x * (4.444339102852739 * x + 9.8632861493405 * f - 24.86741582555878) + f * (-20.737325471181034 * f - 187.80453709719578), X[B + 2] = 255 + R * (0.8842522430003296 * R + 8.078677503112928 * k + 30.89978309703729 * x - 0.23883238689178934 * f + -14.183576799673286) + k * (10.49593273432072 * k + 63.02378494754052 * x + 50.606957656360734 * f - 112.23884253719248) + x * (0.03296041114873217 * x + 115.60384449646641 * f + -193.58209356861505) + f * (-22.33816807309886 * f - 180.12613974708367);
            }
            class b extends y {
              constructor() {
                super("DeviceCMYK", 4);
              }
              getRgbItem(Y, j, X, B) {
                _(Y, j, 1, X, B);
              }
              getRgbBuffer(Y, j, X, B, R, k, x) {
                const f = 1 / ((1 << k) - 1);
                for (let U = 0; U < X; U++)
                  _(Y, j, f, B, R), j += 4, R += 3 + x;
              }
              getOutputLength(Y, j) {
                return Y / 4 * (3 + j) | 0;
              }
            }
            return b;
          }(), i = function() {
            function _(A, Y, j, X, B, R) {
              const x = (Y[j] * R) ** A.G, f = A.YW * x, U = Math.max(295.8 * f ** 0.3333333333333333 - 40.8, 0);
              X[B] = U, X[B + 1] = U, X[B + 2] = U;
            }
            class b extends y {
              constructor(Y, j, X) {
                if (super("CalGray", 1), !Y)
                  throw new t.FormatError("WhitePoint missing - required for color space CalGray");
                if (j = j || [0, 0, 0], X = X || 1, this.XW = Y[0], this.YW = Y[1], this.ZW = Y[2], this.XB = j[0], this.YB = j[1], this.ZB = j[2], this.G = X, this.XW < 0 || this.ZW < 0 || this.YW !== 1)
                  throw new t.FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
                (this.XB < 0 || this.YB < 0 || this.ZB < 0) && ((0, t.info)(`Invalid BlackPoint for ${this.name}, falling back to default.`), this.XB = this.YB = this.ZB = 0), (this.XB !== 0 || this.YB !== 0 || this.ZB !== 0) && (0, t.warn)(`${this.name}, BlackPoint: XB: ${this.XB}, YB: ${this.YB}, ZB: ${this.ZB}, only default values are supported.`), this.G < 1 && ((0, t.info)(`Invalid Gamma: ${this.G} for ${this.name}, falling back to default.`), this.G = 1);
              }
              getRgbItem(Y, j, X, B) {
                _(this, Y, j, X, B, 1);
              }
              getRgbBuffer(Y, j, X, B, R, k, x) {
                const f = 1 / ((1 << k) - 1);
                for (let U = 0; U < X; ++U)
                  _(this, Y, j, B, R, f), j += 1, R += 3 + x;
              }
              getOutputLength(Y, j) {
                return Y * (3 + j);
              }
            }
            return b;
          }(), l = function() {
            const _ = new Float32Array([0.8951, 0.2664, -0.1614, -0.7502, 1.7135, 0.0367, 0.0389, -0.0685, 1.0296]), b = new Float32Array([0.9869929, -0.1470543, 0.1599627, 0.4323053, 0.5183603, 0.0492912, -85287e-7, 0.0400428, 0.9684867]), A = new Float32Array([3.2404542, -1.5371385, -0.4985314, -0.969266, 1.8760108, 0.041556, 0.0556434, -0.2040259, 1.0572252]), Y = new Float32Array([1, 1, 1]), j = new Float32Array(3), X = new Float32Array(3), B = new Float32Array(3), R = ((8 + 16) / 116) ** 3 / 8;
            function k(J, W, z) {
              z[0] = J[0] * W[0] + J[1] * W[1] + J[2] * W[2], z[1] = J[3] * W[0] + J[4] * W[1] + J[5] * W[2], z[2] = J[6] * W[0] + J[7] * W[1] + J[8] * W[2];
            }
            function x(J, W, z) {
              z[0] = W[0] * 1 / J[0], z[1] = W[1] * 1 / J[1], z[2] = W[2] * 1 / J[2];
            }
            function f(J, W, z) {
              z[0] = W[0] * 0.95047 / J[0], z[1] = W[1] * 1 / J[1], z[2] = W[2] * 1.08883 / J[2];
            }
            function U(J) {
              return J <= 31308e-7 ? O(0, 1, 12.92 * J) : J >= 0.99554525 ? 1 : O(0, 1, (1 + 0.055) * J ** (1 / 2.4) - 0.055);
            }
            function O(J, W, z) {
              return Math.max(J, Math.min(W, z));
            }
            function S(J) {
              return J < 0 ? -S(-J) : J > 8 ? ((J + 16) / 116) ** 3 : J * R;
            }
            function F(J, W, z) {
              if (J[0] === 0 && J[1] === 0 && J[2] === 0) {
                z[0] = W[0], z[1] = W[1], z[2] = W[2];
                return;
              }
              const G = S(0), L = G, K = S(J[0]), te = G, se = S(J[1]), q = G, N = S(J[2]), Q = (1 - L) / (1 - K), D = 1 - Q, ne = (1 - te) / (1 - se), oe = 1 - ne, ee = (1 - q) / (1 - N), $ = 1 - ee;
              z[0] = W[0] * Q + D, z[1] = W[1] * ne + oe, z[2] = W[2] * ee + $;
            }
            function T(J, W, z) {
              if (J[0] === 1 && J[2] === 1) {
                z[0] = W[0], z[1] = W[1], z[2] = W[2];
                return;
              }
              const G = z;
              k(_, W, G);
              const L = j;
              x(J, G, L), k(b, L, z);
            }
            function I(J, W, z) {
              const G = z;
              k(_, W, G);
              const L = j;
              f(J, G, L), k(b, L, z);
            }
            function M(J, W, z, G, L, K) {
              const te = O(0, 1, W[z] * K), se = O(0, 1, W[z + 1] * K), q = O(0, 1, W[z + 2] * K), N = te === 1 ? 1 : te ** J.GR, Q = se === 1 ? 1 : se ** J.GG, D = q === 1 ? 1 : q ** J.GB, ne = J.MXA * N + J.MXB * Q + J.MXC * D, oe = J.MYA * N + J.MYB * Q + J.MYC * D, ee = J.MZA * N + J.MZB * Q + J.MZC * D, $ = X;
              $[0] = ne, $[1] = oe, $[2] = ee;
              const E = B;
              T(J.whitePoint, $, E);
              const H = X;
              F(J.blackPoint, E, H);
              const ie = B;
              I(Y, H, ie);
              const ue = X;
              k(A, ie, ue), G[L] = U(ue[0]) * 255, G[L + 1] = U(ue[1]) * 255, G[L + 2] = U(ue[2]) * 255;
            }
            class V extends y {
              constructor(W, z, G, L) {
                if (super("CalRGB", 3), !W)
                  throw new t.FormatError("WhitePoint missing - required for color space CalRGB");
                z = z || new Float32Array(3), G = G || new Float32Array([1, 1, 1]), L = L || new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
                const K = W[0], te = W[1], se = W[2];
                this.whitePoint = W;
                const q = z[0], N = z[1], Q = z[2];
                if (this.blackPoint = z, this.GR = G[0], this.GG = G[1], this.GB = G[2], this.MXA = L[0], this.MYA = L[1], this.MZA = L[2], this.MXB = L[3], this.MYB = L[4], this.MZB = L[5], this.MXC = L[6], this.MYC = L[7], this.MZC = L[8], K < 0 || se < 0 || te !== 1)
                  throw new t.FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
                (q < 0 || N < 0 || Q < 0) && ((0, t.info)(`Invalid BlackPoint for ${this.name} [${q}, ${N}, ${Q}], falling back to default.`), this.blackPoint = new Float32Array(3)), (this.GR < 0 || this.GG < 0 || this.GB < 0) && ((0, t.info)(`Invalid Gamma [${this.GR}, ${this.GG}, ${this.GB}] for ${this.name}, falling back to default.`), this.GR = this.GG = this.GB = 1);
              }
              getRgbItem(W, z, G, L) {
                M(this, W, z, G, L, 1);
              }
              getRgbBuffer(W, z, G, L, K, te, se) {
                const q = 1 / ((1 << te) - 1);
                for (let N = 0; N < G; ++N)
                  M(this, W, z, L, K, q), z += 3, K += 3 + se;
              }
              getOutputLength(W, z) {
                return W * (3 + z) / 3 | 0;
              }
            }
            return V;
          }(), u = function() {
            function _(j) {
              let X;
              return j >= 6 / 29 ? X = j ** 3 : X = 108 / 841 * (j - 4 / 29), X;
            }
            function b(j, X, B, R) {
              return B + j * (R - B) / X;
            }
            function A(j, X, B, R, k, x) {
              let f = X[B], U = X[B + 1], O = X[B + 2];
              R !== !1 && (f = b(f, R, 0, 100), U = b(U, R, j.amin, j.amax), O = b(O, R, j.bmin, j.bmax)), U > j.amax ? U = j.amax : U < j.amin && (U = j.amin), O > j.bmax ? O = j.bmax : O < j.bmin && (O = j.bmin);
              const S = (f + 16) / 116, F = S + U / 500, T = S - O / 200, I = j.XW * _(F), M = j.YW * _(S), V = j.ZW * _(T);
              let J, W, z;
              j.ZW < 1 ? (J = I * 3.1339 + M * -1.617 + V * -0.4906, W = I * -0.9785 + M * 1.916 + V * 0.0333, z = I * 0.072 + M * -0.229 + V * 1.4057) : (J = I * 3.2406 + M * -1.5372 + V * -0.4986, W = I * -0.9689 + M * 1.8758 + V * 0.0415, z = I * 0.0557 + M * -0.204 + V * 1.057), k[x] = Math.sqrt(J) * 255, k[x + 1] = Math.sqrt(W) * 255, k[x + 2] = Math.sqrt(z) * 255;
            }
            class Y extends y {
              constructor(X, B, R) {
                if (super("Lab", 3), !X)
                  throw new t.FormatError("WhitePoint missing - required for color space Lab");
                if (B = B || [0, 0, 0], R = R || [-100, 100, -100, 100], this.XW = X[0], this.YW = X[1], this.ZW = X[2], this.amin = R[0], this.amax = R[1], this.bmin = R[2], this.bmax = R[3], this.XB = B[0], this.YB = B[1], this.ZB = B[2], this.XW < 0 || this.ZW < 0 || this.YW !== 1)
                  throw new t.FormatError("Invalid WhitePoint components, no fallback available");
                (this.XB < 0 || this.YB < 0 || this.ZB < 0) && ((0, t.info)("Invalid BlackPoint, falling back to default"), this.XB = this.YB = this.ZB = 0), (this.amin > this.amax || this.bmin > this.bmax) && ((0, t.info)("Invalid Range, falling back to defaults"), this.amin = -100, this.amax = 100, this.bmin = -100, this.bmax = 100);
              }
              getRgbItem(X, B, R, k) {
                A(this, X, B, !1, R, k);
              }
              getRgbBuffer(X, B, R, k, x, f, U) {
                const O = (1 << f) - 1;
                for (let S = 0; S < R; S++)
                  A(this, X, B, O, k, x), B += 3, x += 3 + U;
              }
              getOutputLength(X, B) {
                return X * (3 + B) / 3 | 0;
              }
              isDefaultDecode(X, B) {
                return !0;
              }
              get usesZeroToOneRange() {
                return (0, t.shadow)(this, "usesZeroToOneRange", !1);
              }
            }
            return Y;
          }();
        },
        /* 15 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.PartialEvaluator = o.EvaluatorPreprocessor = void 0;
          var t = C(2), a = C(16), v = C(5), h = C(34), e = C(38), y = C(37), c = C(41), d = C(40), p = C(50), m = C(51), g = C(42), n = C(57), i = C(17), l = C(59), u = C(10), w = C(7), _ = C(60), b = C(14), A = C(19), Y = C(39), j = C(6), X = C(45), B = C(61), R = C(62), k = C(63);
          const x = Object.freeze({
            maxImageSize: -1,
            disableFontFace: !1,
            ignoreErrors: !1,
            isEvalSupported: !0,
            fontExtraProperties: !1,
            useSystemFonts: !0,
            cMapUrl: null,
            standardFontDataUrl: null
          }), f = {
            TILING: 1,
            SHADING: 2
          }, U = 10, O = Promise.resolve();
          function S(G, L = !1) {
            if (Array.isArray(G)) {
              for (let K = 0, te = G.length; K < te; K++) {
                const se = S(G[K], !0);
                if (se)
                  return se;
              }
              return (0, t.warn)(`Unsupported blend mode Array: ${G}`), "source-over";
            }
            if (!(G instanceof v.Name))
              return L ? null : "source-over";
            switch (G.name) {
              case "Normal":
              case "Compatible":
                return "source-over";
              case "Multiply":
                return "multiply";
              case "Screen":
                return "screen";
              case "Overlay":
                return "overlay";
              case "Darken":
                return "darken";
              case "Lighten":
                return "lighten";
              case "ColorDodge":
                return "color-dodge";
              case "ColorBurn":
                return "color-burn";
              case "HardLight":
                return "hard-light";
              case "SoftLight":
                return "soft-light";
              case "Difference":
                return "difference";
              case "Exclusion":
                return "exclusion";
              case "Hue":
                return "hue";
              case "Saturation":
                return "saturation";
              case "Color":
                return "color";
              case "Luminosity":
                return "luminosity";
            }
            return L ? null : ((0, t.warn)(`Unsupported blend mode: ${G.name}`), "source-over");
          }
          function F(G) {
            G.fn === t.OPS.paintImageMaskXObject && G.args[0] && G.args[0].count > 0 && G.args[0].count++;
          }
          class T {
            static get TIME_SLOT_DURATION_MS() {
              return (0, t.shadow)(this, "TIME_SLOT_DURATION_MS", 20);
            }
            static get CHECK_TIME_EVERY() {
              return (0, t.shadow)(this, "CHECK_TIME_EVERY", 100);
            }
            constructor() {
              this.reset();
            }
            check() {
              return ++this.checked < T.CHECK_TIME_EVERY ? !1 : (this.checked = 0, this.endTime <= Date.now());
            }
            reset() {
              this.endTime = Date.now() + T.TIME_SLOT_DURATION_MS, this.checked = 0;
            }
          }
          class I {
            constructor({
              xref: L,
              handler: K,
              pageIndex: te,
              idFactory: se,
              fontCache: q,
              builtInCMapCache: N,
              standardFontDataCache: Q,
              globalImageCache: D,
              options: ne = null
            }) {
              this.xref = L, this.handler = K, this.pageIndex = te, this.idFactory = se, this.fontCache = q, this.builtInCMapCache = N, this.standardFontDataCache = Q, this.globalImageCache = D, this.options = ne || x, this.parsingType3Font = !1, this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);
            }
            get _pdfFunctionFactory() {
              const L = new n.PDFFunctionFactory({
                xref: this.xref,
                isEvalSupported: this.options.isEvalSupported
              });
              return (0, t.shadow)(this, "_pdfFunctionFactory", L);
            }
            clone(L = null) {
              const K = Object.create(this);
              return K.options = Object.assign(/* @__PURE__ */ Object.create(null), this.options, L), K;
            }
            hasBlendModes(L, K) {
              if (!(L instanceof v.Dict) || L.objId && K.has(L.objId))
                return !1;
              const te = new v.RefSet(K);
              L.objId && te.put(L.objId);
              const se = [L], q = this.xref;
              for (; se.length; ) {
                const N = se.shift(), Q = N.get("ExtGState");
                if (Q instanceof v.Dict)
                  for (let ne of Q.getRawValues()) {
                    if (ne instanceof v.Ref) {
                      if (te.has(ne))
                        continue;
                      try {
                        ne = q.fetch(ne);
                      } catch (ee) {
                        te.put(ne), (0, t.info)(`hasBlendModes - ignoring ExtGState: "${ee}".`);
                        continue;
                      }
                    }
                    if (!(ne instanceof v.Dict))
                      continue;
                    ne.objId && te.put(ne.objId);
                    const oe = ne.get("BM");
                    if (oe instanceof v.Name) {
                      if (oe.name !== "Normal")
                        return !0;
                      continue;
                    }
                    if (oe !== void 0 && Array.isArray(oe)) {
                      for (const ee of oe)
                        if (ee instanceof v.Name && ee.name !== "Normal")
                          return !0;
                    }
                  }
                const D = N.get("XObject");
                if (D instanceof v.Dict)
                  for (let ne of D.getRawValues()) {
                    if (ne instanceof v.Ref) {
                      if (te.has(ne))
                        continue;
                      try {
                        ne = q.fetch(ne);
                      } catch (ee) {
                        te.put(ne), (0, t.info)(`hasBlendModes - ignoring XObject: "${ee}".`);
                        continue;
                      }
                    }
                    if (!(ne instanceof w.BaseStream))
                      continue;
                    ne.dict.objId && te.put(ne.dict.objId);
                    const oe = ne.dict.get("Resources");
                    oe instanceof v.Dict && (oe.objId && te.has(oe.objId) || (se.push(oe), oe.objId && te.put(oe.objId)));
                  }
              }
              for (const N of te)
                K.put(N);
              return !1;
            }
            async fetchBuiltInCMap(L) {
              const K = this.builtInCMapCache.get(L);
              if (K)
                return K;
              let te;
              if (this.options.cMapUrl !== null) {
                const se = `${this.options.cMapUrl}${L}.bcmap`, q = await fetch(se);
                if (!q.ok)
                  throw new Error(`fetchBuiltInCMap: failed to fetch file "${se}" with "${q.statusText}".`);
                te = {
                  cMapData: new Uint8Array(await q.arrayBuffer()),
                  compressionType: t.CMapCompressionType.BINARY
                };
              } else
                te = await this.handler.sendWithPromise("FetchBuiltInCMap", {
                  name: L
                });
              return te.compressionType !== t.CMapCompressionType.NONE && this.builtInCMapCache.set(L, te), te;
            }
            async fetchStandardFontData(L) {
              const K = this.standardFontDataCache.get(L);
              if (K)
                return new u.Stream(K);
              if (this.options.useSystemFonts && L !== "Symbol" && L !== "ZapfDingbats")
                return null;
              const te = (0, c.getFontNameToFileMap)(), se = te[L];
              let q;
              if (this.options.standardFontDataUrl !== null) {
                const N = `${this.options.standardFontDataUrl}${se}`, Q = await fetch(N);
                Q.ok ? q = await Q.arrayBuffer() : (0, t.warn)(`fetchStandardFontData: failed to fetch file "${N}" with "${Q.statusText}".`);
              } else
                try {
                  q = await this.handler.sendWithPromise("FetchStandardFontData", {
                    filename: se
                  });
                } catch (N) {
                  (0, t.warn)(`fetchStandardFontData: failed to fetch file "${se}" with "${N}".`);
                }
              return q ? (this.standardFontDataCache.set(L, q), new u.Stream(q)) : null;
            }
            async buildFormXObject(L, K, te, se, q, N, Q) {
              const D = K.dict, ne = D.getArray("Matrix");
              let oe = D.getArray("BBox");
              Array.isArray(oe) && oe.length === 4 ? oe = t.Util.normalizeRect(oe) : oe = null;
              let ee, $;
              D.has("OC") && (ee = await this.parseMarkedContentProps(D.get("OC"), L)), ee !== void 0 && se.addOp(t.OPS.beginMarkedContentProps, ["OC", ee]);
              const E = D.get("Group");
              if (E) {
                $ = {
                  matrix: ne,
                  bbox: oe,
                  smask: te,
                  isolated: !1,
                  knockout: !1
                };
                const ie = E.get("S");
                let ue = null;
                if ((0, v.isName)(ie, "Transparency") && ($.isolated = E.get("I") || !1, $.knockout = E.get("K") || !1, E.has("CS"))) {
                  const fe = E.getRaw("CS"), de = b.ColorSpace.getCached(fe, this.xref, Q);
                  de ? ue = de : ue = await this.parseColorSpace({
                    cs: fe,
                    resources: L,
                    localColorSpaceCache: Q
                  });
                }
                te && te.backdrop && (ue = ue || b.ColorSpace.singletons.rgb, te.backdrop = ue.getRgb(te.backdrop, 0)), se.addOp(t.OPS.beginGroup, [$]);
              }
              const H = E ? [ne, null] : [ne, oe];
              return se.addOp(t.OPS.paintFormXObjectBegin, H), this.getOperatorList({
                stream: K,
                task: q,
                resources: D.get("Resources") || L,
                operatorList: se,
                initialState: N
              }).then(function() {
                se.addOp(t.OPS.paintFormXObjectEnd, []), E && se.addOp(t.OPS.endGroup, [$]), ee !== void 0 && se.addOp(t.OPS.endMarkedContent, []);
              });
            }
            _sendImgData(L, K, te = !1) {
              const se = K ? [K.bitmap || K.data.buffer] : null;
              return this.parsingType3Font || te ? this.handler.send("commonobj", [L, "Image", K], se) : this.handler.send("obj", [L, this.pageIndex, "Image", K], se);
            }
            async buildPaintImageXObject({
              resources: L,
              image: K,
              isInline: te = !1,
              operatorList: se,
              cacheKey: q,
              localImageCache: N,
              localColorSpaceCache: Q
            }) {
              const D = K.dict, ne = D.objId, oe = D.get("W", "Width"), ee = D.get("H", "Height");
              if (!(oe && typeof oe == "number") || !(ee && typeof ee == "number")) {
                (0, t.warn)("Image dimensions are missing, or not numbers.");
                return;
              }
              const $ = this.options.maxImageSize;
              if ($ !== -1 && oe * ee > $) {
                const Ae = "Image exceeded maximum allowed size and was removed.";
                if (this.options.ignoreErrors) {
                  (0, t.warn)(Ae);
                  return;
                }
                throw new Error(Ae);
              }
              let E;
              D.has("OC") && (E = await this.parseMarkedContentProps(D.get("OC"), L));
              const H = D.get("IM", "ImageMask") || !1;
              let ie, ue;
              if (H) {
                const Ae = D.get("I", "Interpolate"), Se = oe + 7 >> 3, ke = K.getBytes(Se * ee), ye = D.getArray("D", "Decode");
                if (this.parsingType3Font) {
                  ie = k.PDFImage.createRawMask({
                    imgArray: ke,
                    width: oe,
                    height: ee,
                    imageIsFromDecodeStream: K instanceof A.DecodeStream,
                    inverseDecode: !!ye && ye[0] > 0,
                    interpolate: Ae
                  }), ie.cached = !!q, ue = [ie], se.addImageOps(t.OPS.paintImageMaskXObject, ue, E), q && N.set(q, ne, {
                    fn: t.OPS.paintImageMaskXObject,
                    args: ue,
                    optionalContent: E
                  });
                  return;
                }
                if (ie = k.PDFImage.createMask({
                  imgArray: ke,
                  width: oe,
                  height: ee,
                  imageIsFromDecodeStream: K instanceof A.DecodeStream,
                  inverseDecode: !!ye && ye[0] > 0,
                  interpolate: Ae
                }), ie.isSingleOpaquePixel) {
                  se.addImageOps(t.OPS.paintSolidColorImageMask, [], E), q && N.set(q, ne, {
                    fn: t.OPS.paintSolidColorImageMask,
                    args: [],
                    optionalContent: E
                  });
                  return;
                }
                const _e = `mask_${this.idFactory.createObjId()}`;
                se.addDependency(_e), this._sendImgData(_e, ie), ue = [{
                  data: _e,
                  width: ie.width,
                  height: ie.height,
                  interpolate: ie.interpolate,
                  count: 1
                }], se.addImageOps(t.OPS.paintImageMaskXObject, ue, E), q && N.set(q, ne, {
                  fn: t.OPS.paintImageMaskXObject,
                  args: ue,
                  optionalContent: E
                });
                return;
              }
              const fe = D.get("SM", "SMask") || !1, de = D.get("Mask") || !1, pe = 200;
              if (te && !fe && !de && oe + ee < pe) {
                ie = new k.PDFImage({
                  xref: this.xref,
                  res: L,
                  image: K,
                  isInline: te,
                  pdfFunctionFactory: this._pdfFunctionFactory,
                  localColorSpaceCache: Q
                }).createImageData(!0), se.addImageOps(t.OPS.paintInlineImageXObject, [ie], E);
                return;
              }
              let xe = `img_${this.idFactory.createObjId()}`, De = !1;
              this.parsingType3Font ? xe = `${this.idFactory.getDocId()}_type3_${xe}` : ne && (De = this.globalImageCache.shouldCache(ne, this.pageIndex), De && (xe = `${this.idFactory.getDocId()}_${xe}`)), se.addDependency(xe), ue = [xe, oe, ee], k.PDFImage.buildImage({
                xref: this.xref,
                res: L,
                image: K,
                isInline: te,
                pdfFunctionFactory: this._pdfFunctionFactory,
                localColorSpaceCache: Q
              }).then((Ae) => (ie = Ae.createImageData(!1), q && ne && De && this.globalImageCache.addByteSize(ne, ie.data.length), this._sendImgData(xe, ie, De))).catch((Ae) => ((0, t.warn)(`Unable to decode image "${xe}": "${Ae}".`), this._sendImgData(xe, null, De))), se.addImageOps(t.OPS.paintImageXObject, ue, E), q && (N.set(q, ne, {
                fn: t.OPS.paintImageXObject,
                args: ue,
                optionalContent: E
              }), ne && ((0, t.assert)(!te, "Cannot cache an inline image globally."), this.globalImageCache.addPageIndex(ne, this.pageIndex), De && this.globalImageCache.setData(ne, {
                objId: xe,
                fn: t.OPS.paintImageXObject,
                args: ue,
                optionalContent: E,
                byteSize: 0
              })));
            }
            handleSMask(L, K, te, se, q, N) {
              const Q = L.get("G"), D = {
                subtype: L.get("S").name,
                backdrop: L.get("BC")
              }, ne = L.get("TR");
              if ((0, n.isPDFFunction)(ne)) {
                const oe = this._pdfFunctionFactory.create(ne), ee = new Uint8Array(256), $ = new Float32Array(1);
                for (let E = 0; E < 256; E++)
                  $[0] = E / 255, oe($, 0, $, 0), ee[E] = $[0] * 255 | 0;
                D.transferMap = ee;
              }
              return this.buildFormXObject(K, Q, D, te, se, q.state.clone(), N);
            }
            handleTransferFunction(L) {
              let K;
              if (Array.isArray(L))
                K = L;
              else if ((0, n.isPDFFunction)(L))
                K = [L];
              else
                return null;
              const te = [];
              let se = 0, q = 0;
              for (const N of K) {
                const Q = this.xref.fetchIfRef(N);
                if (se++, (0, v.isName)(Q, "Identity")) {
                  te.push(null);
                  continue;
                } else if (!(0, n.isPDFFunction)(Q))
                  return null;
                const D = this._pdfFunctionFactory.create(Q), ne = new Uint8Array(256), oe = new Float32Array(1);
                for (let ee = 0; ee < 256; ee++)
                  oe[0] = ee / 255, D(oe, 0, oe, 0), ne[ee] = oe[0] * 255 | 0;
                te.push(ne), q++;
              }
              return !(se === 1 || se === 4) || q === 0 ? null : te;
            }
            handleTilingType(L, K, te, se, q, N, Q, D) {
              const ne = new R.OperatorList(), oe = v.Dict.merge({
                xref: this.xref,
                dictArray: [q.get("Resources"), te]
              });
              return this.getOperatorList({
                stream: se,
                task: Q,
                resources: oe,
                operatorList: ne
              }).then(function() {
                const ee = ne.getIR(), $ = (0, p.getTilingPatternIR)(ee, q, K);
                N.addDependencies(ne.dependencies), N.addOp(L, $), q.objId && D.set(null, q.objId, {
                  operatorListIR: ee,
                  dict: q
                });
              }).catch((ee) => {
                if (!(ee instanceof t.AbortException)) {
                  if (this.options.ignoreErrors) {
                    this.handler.send("UnsupportedFeature", {
                      featureId: t.UNSUPPORTED_FEATURES.errorTilingPattern
                    }), (0, t.warn)(`handleTilingType - ignoring pattern: "${ee}".`);
                    return;
                  }
                  throw ee;
                }
              });
            }
            handleSetFont(L, K, te, se, q, N, Q = null, D = null) {
              const ne = K && K[0] instanceof v.Name ? K[0].name : null;
              return this.loadFont(ne, te, L, Q, D).then((oe) => oe.font.isType3Font ? oe.loadType3Data(this, L, q).then(function() {
                return se.addDependencies(oe.type3Dependencies), oe;
              }).catch((ee) => (this.handler.send("UnsupportedFeature", {
                featureId: t.UNSUPPORTED_FEATURES.errorFontLoadType3
              }), new M({
                loadedName: "g_font_error",
                font: new h.ErrorFont(`Type3 font load error: ${ee}`),
                dict: oe.font,
                evaluatorOptions: this.options
              }))) : oe).then((oe) => (N.font = oe.font, oe.send(this.handler), oe.loadedName));
            }
            handleText(L, K) {
              const te = K.font, se = te.charsToGlyphs(L);
              return te.data && (K.textRenderingMode & t.TextRenderingMode.ADD_TO_PATH_FLAG || K.fillColorSpace.name === "Pattern" || te.disableFontFace || this.options.disableFontFace) && I.buildFontPaths(te, se, this.handler, this.options), se;
            }
            ensureStateFont(L) {
              if (L.font)
                return;
              const K = new t.FormatError("Missing setFont (Tf) operator before text rendering operator.");
              if (this.options.ignoreErrors) {
                this.handler.send("UnsupportedFeature", {
                  featureId: t.UNSUPPORTED_FEATURES.errorFontState
                }), (0, t.warn)(`ensureStateFont: "${K}".`);
                return;
              }
              throw K;
            }
            async setGState({
              resources: L,
              gState: K,
              operatorList: te,
              cacheKey: se,
              task: q,
              stateManager: N,
              localGStateCache: Q,
              localColorSpaceCache: D
            }) {
              const ne = K.objId;
              let oe = !0;
              const ee = [], $ = K.getKeys();
              let E = Promise.resolve();
              for (let H = 0, ie = $.length; H < ie; H++) {
                const ue = $[H], fe = K.get(ue);
                switch (ue) {
                  case "Type":
                    break;
                  case "LW":
                  case "LC":
                  case "LJ":
                  case "ML":
                  case "D":
                  case "RI":
                  case "FL":
                  case "CA":
                  case "ca":
                    ee.push([ue, fe]);
                    break;
                  case "Font":
                    oe = !1, E = E.then(() => this.handleSetFont(L, null, fe[0], te, q, N.state).then(function(pe) {
                      te.addDependency(pe), ee.push([ue, [pe, fe[1]]]);
                    }));
                    break;
                  case "BM":
                    ee.push([ue, S(fe)]);
                    break;
                  case "SMask":
                    if ((0, v.isName)(fe, "None")) {
                      ee.push([ue, !1]);
                      break;
                    }
                    fe instanceof v.Dict ? (oe = !1, E = E.then(() => this.handleSMask(fe, L, te, q, N, D)), ee.push([ue, !0])) : (0, t.warn)("Unsupported SMask type");
                    break;
                  case "TR":
                    const de = this.handleTransferFunction(fe);
                    ee.push([ue, de]);
                    break;
                  case "OP":
                  case "op":
                  case "OPM":
                  case "BG":
                  case "BG2":
                  case "UCR":
                  case "UCR2":
                  case "TR2":
                  case "HT":
                  case "SM":
                  case "SA":
                  case "AIS":
                  case "TK":
                    (0, t.info)("graphic state operator " + ue);
                    break;
                  default:
                    (0, t.info)("Unknown graphic state operator " + ue);
                    break;
                }
              }
              return E.then(function() {
                ee.length > 0 && te.addOp(t.OPS.setGState, [ee]), oe && Q.set(se, ne, ee);
              });
            }
            loadFont(L, K, te, se = null, q = null) {
              const N = async () => new M({
                loadedName: "g_font_error",
                font: new h.ErrorFont(`Font "${L}" is not available.`),
                dict: K,
                evaluatorOptions: this.options
              }), Q = this.xref;
              let D;
              if (K)
                K instanceof v.Ref && (D = K);
              else {
                const ie = te.get("Font");
                ie && (D = ie.getRaw(L));
              }
              if (!D) {
                const ie = `Font "${L || K && K.toString()}" is not available`;
                if (!this.options.ignoreErrors && !this.parsingType3Font)
                  return (0, t.warn)(`${ie}.`), N();
                this.handler.send("UnsupportedFeature", {
                  featureId: t.UNSUPPORTED_FEATURES.errorFontMissing
                }), (0, t.warn)(`${ie} -- attempting to fallback to a default font.`), se ? D = se : D = I.fallbackFontDict;
              }
              if (this.parsingType3Font && this.type3FontRefs.has(D))
                return N();
              if (this.fontCache.has(D))
                return this.fontCache.get(D);
              if (K = Q.fetchIfRef(D), !(K instanceof v.Dict))
                return N();
              if (K.cacheKey && this.fontCache.has(K.cacheKey))
                return this.fontCache.get(K.cacheKey);
              const ne = (0, t.createPromiseCapability)();
              let oe;
              try {
                oe = this.preEvaluateFont(K), oe.cssFontInfo = q;
              } catch (ie) {
                return (0, t.warn)(`loadFont - preEvaluateFont failed: "${ie}".`), N();
              }
              const {
                descriptor: ee,
                hash: $
              } = oe, E = D instanceof v.Ref;
              let H;
              if (E && (H = `f${D.toString()}`), $ && ee instanceof v.Dict) {
                ee.fontAliases || (ee.fontAliases = /* @__PURE__ */ Object.create(null));
                const ie = ee.fontAliases;
                if (ie[$]) {
                  const ue = ie[$].aliasRef;
                  if (E && ue && this.fontCache.has(ue))
                    return this.fontCache.putAlias(D, ue), this.fontCache.get(D);
                } else
                  ie[$] = {
                    fontID: this.idFactory.createFontId()
                  };
                E && (ie[$].aliasRef = D), H = ie[$].fontID;
              }
              return E ? this.fontCache.put(D, ne.promise) : (H || (H = this.idFactory.createFontId()), K.cacheKey = `cacheKey_${H}`, this.fontCache.put(K.cacheKey, ne.promise)), (0, t.assert)(H && H.startsWith("f"), 'The "fontID" must be (correctly) defined.'), K.loadedName = `${this.idFactory.getDocId()}_${H}`, this.translateFont(oe).then((ie) => {
                ie.fontType !== void 0 && Q.stats.addFontType(ie.fontType), ne.resolve(new M({
                  loadedName: K.loadedName,
                  font: ie,
                  dict: K,
                  evaluatorOptions: this.options
                }));
              }).catch((ie) => {
                this.handler.send("UnsupportedFeature", {
                  featureId: t.UNSUPPORTED_FEATURES.errorFontTranslate
                }), (0, t.warn)(`loadFont - translateFont failed: "${ie}".`);
                try {
                  const ue = ee && ee.get("FontFile3"), fe = ue && ue.get("Subtype"), de = (0, e.getFontType)(oe.type, fe && fe.name);
                  de !== void 0 && Q.stats.addFontType(de);
                } catch {
                }
                ne.resolve(new M({
                  loadedName: K.loadedName,
                  font: new h.ErrorFont(ie instanceof Error ? ie.message : ie),
                  dict: K,
                  evaluatorOptions: this.options
                }));
              }), ne.promise;
            }
            buildPath(L, K, te, se = !1) {
              const q = L.length - 1;
              te || (te = []);
              let N;
              if (q < 0 || L.fnArray[q] !== t.OPS.constructPath)
                se && ((0, t.warn)(`Encountered path operator "${K}" inside of a text object.`), L.addOp(t.OPS.save, null)), N = [1 / 0, -1 / 0, 1 / 0, -1 / 0], L.addOp(t.OPS.constructPath, [[K], te, N]), se && L.addOp(t.OPS.restore, null);
              else {
                const Q = L.argsArray[q];
                Q[0].push(K), Array.prototype.push.apply(Q[1], te), N = Q[2];
              }
              switch (K) {
                case t.OPS.rectangle:
                  N[0] = Math.min(N[0], te[0], te[0] + te[2]), N[1] = Math.max(N[1], te[0], te[0] + te[2]), N[2] = Math.min(N[2], te[1], te[1] + te[3]), N[3] = Math.max(N[3], te[1], te[1] + te[3]);
                  break;
                case t.OPS.moveTo:
                case t.OPS.lineTo:
                  N[0] = Math.min(N[0], te[0]), N[1] = Math.max(N[1], te[0]), N[2] = Math.min(N[2], te[1]), N[3] = Math.max(N[3], te[1]);
                  break;
              }
            }
            parseColorSpace({
              cs: L,
              resources: K,
              localColorSpaceCache: te
            }) {
              return b.ColorSpace.parseAsync({
                cs: L,
                xref: this.xref,
                resources: K,
                pdfFunctionFactory: this._pdfFunctionFactory,
                localColorSpaceCache: te
              }).catch((se) => {
                if (se instanceof t.AbortException)
                  return null;
                if (this.options.ignoreErrors)
                  return this.handler.send("UnsupportedFeature", {
                    featureId: t.UNSUPPORTED_FEATURES.errorColorSpace
                  }), (0, t.warn)(`parseColorSpace - ignoring ColorSpace: "${se}".`), null;
                throw se;
              });
            }
            parseShading({
              shading: L,
              resources: K,
              localColorSpaceCache: te,
              localShadingPatternCache: se
            }) {
              let q = se.get(L);
              if (!q) {
                var N = p.Pattern.parseShading(L, this.xref, K, this.handler, this._pdfFunctionFactory, te);
                const Q = N.getIR();
                q = `pattern_${this.idFactory.createObjId()}`, se.set(L, q), this.handler.send("obj", [q, this.pageIndex, "Pattern", Q]);
              }
              return q;
            }
            handleColorN(L, K, te, se, q, N, Q, D, ne, oe) {
              const ee = te.pop();
              if (ee instanceof v.Name) {
                const $ = q.getRaw(ee.name), E = $ instanceof v.Ref && ne.getByRef($);
                if (E)
                  try {
                    const ie = se.base ? se.base.getRgb(te, 0) : null, ue = (0, p.getTilingPatternIR)(E.operatorListIR, E.dict, ie);
                    L.addOp(K, ue);
                    return;
                  } catch {
                  }
                const H = this.xref.fetchIfRef($);
                if (H) {
                  const ie = H instanceof w.BaseStream ? H.dict : H, ue = ie.get("PatternType");
                  if (ue === f.TILING) {
                    const fe = se.base ? se.base.getRgb(te, 0) : null;
                    return this.handleTilingType(K, fe, N, H, ie, L, Q, ne);
                  } else if (ue === f.SHADING) {
                    const fe = ie.get("Shading"), de = ie.getArray("Matrix"), pe = this.parseShading({
                      shading: fe,
                      resources: N,
                      localColorSpaceCache: D,
                      localShadingPatternCache: oe
                    });
                    L.addOp(K, ["Shading", pe, de]);
                    return;
                  }
                  throw new t.FormatError(`Unknown PatternType: ${ue}`);
                }
              }
              throw new t.FormatError(`Unknown PatternName: ${ee}`);
            }
            _parseVisibilityExpression(L, K, te) {
              if (++K > 10) {
                (0, t.warn)("Visibility expression is too deeply nested");
                return;
              }
              const q = L.length, N = this.xref.fetchIfRef(L[0]);
              if (q < 2 || !(N instanceof v.Name)) {
                (0, t.warn)("Invalid visibility expression");
                return;
              }
              switch (N.name) {
                case "And":
                case "Or":
                case "Not":
                  te.push(N.name);
                  break;
                default:
                  (0, t.warn)(`Invalid operator ${N.name} in visibility expression`);
                  return;
              }
              for (let Q = 1; Q < q; Q++) {
                const D = L[Q], ne = this.xref.fetchIfRef(D);
                if (Array.isArray(ne)) {
                  const oe = [];
                  te.push(oe), this._parseVisibilityExpression(ne, K, oe);
                } else
                  D instanceof v.Ref && te.push(D.toString());
              }
            }
            async parseMarkedContentProps(L, K) {
              let te;
              if (L instanceof v.Name)
                te = K.get("Properties").get(L.name);
              else if (L instanceof v.Dict)
                te = L;
              else
                throw new t.FormatError("Optional content properties malformed.");
              const se = te.get("Type").name;
              if (se === "OCG")
                return {
                  type: se,
                  id: te.objId
                };
              if (se === "OCMD") {
                const q = te.get("VE");
                if (Array.isArray(q)) {
                  const Q = [];
                  if (this._parseVisibilityExpression(q, 0, Q), Q.length > 0)
                    return {
                      type: "OCMD",
                      expression: Q
                    };
                }
                const N = te.get("OCGs");
                if (Array.isArray(N) || N instanceof v.Dict) {
                  const Q = [];
                  if (Array.isArray(N))
                    for (const D of N)
                      Q.push(D.toString());
                  else
                    Q.push(N.objId);
                  return {
                    type: se,
                    ids: Q,
                    policy: te.get("P") instanceof v.Name ? te.get("P").name : null,
                    expression: null
                  };
                } else if (N instanceof v.Ref)
                  return {
                    type: se,
                    id: N.toString()
                  };
              }
              return null;
            }
            getOperatorList({
              stream: L,
              task: K,
              resources: te,
              operatorList: se,
              initialState: q = null,
              fallbackFontDict: N = null
            }) {
              if (te = te || v.Dict.empty, q = q || new W(), !se)
                throw new Error('getOperatorList: missing "operatorList" parameter');
              const Q = this, D = this.xref;
              let ne = !1;
              const oe = new l.LocalImageCache(), ee = new l.LocalColorSpaceCache(), $ = new l.LocalGStateCache(), E = new l.LocalTilingPatternCache(), H = /* @__PURE__ */ new Map(), ie = te.get("XObject") || v.Dict.empty, ue = te.get("Pattern") || v.Dict.empty, fe = new V(q), de = new z(L, D, fe), pe = new T();
              function xe(De) {
                for (let Ae = 0, Se = de.savedStatesDepth; Ae < Se; Ae++)
                  se.addOp(t.OPS.restore, []);
              }
              return new Promise(function De(Ae, Se) {
                const ke = function(Te) {
                  Promise.all([Te, se.ready]).then(function() {
                    try {
                      De(Ae, Se);
                    } catch (je) {
                      Se(je);
                    }
                  }, Se);
                };
                K.ensureNotTerminated(), pe.reset();
                const ye = {};
                let _e, we, Ce, ve, Le, He;
                for (; !(_e = pe.check()) && (ye.args = null, !!de.read(ye)); ) {
                  let Te = ye.args, je = ye.fn;
                  switch (je | 0) {
                    case t.OPS.paintXObject:
                      if (He = Te[0] instanceof v.Name, Le = Te[0].name, He) {
                        const Me = oe.getByName(Le);
                        if (Me) {
                          se.addImageOps(Me.fn, Me.args, Me.optionalContent), F(Me), Te = null;
                          continue;
                        }
                      }
                      ke(new Promise(function(Me, at) {
                        if (!He)
                          throw new t.FormatError("XObject must be referred to by name.");
                        let rt = ie.getRaw(Le);
                        if (rt instanceof v.Ref) {
                          const ut = oe.getByRef(rt);
                          if (ut) {
                            se.addImageOps(ut.fn, ut.args, ut.optionalContent), F(ut), Me();
                            return;
                          }
                          const yt = Q.globalImageCache.getData(rt, Q.pageIndex);
                          if (yt) {
                            se.addDependency(yt.objId), se.addImageOps(yt.fn, yt.args, yt.optionalContent), Me();
                            return;
                          }
                          rt = D.fetch(rt);
                        }
                        if (!(rt instanceof w.BaseStream))
                          throw new t.FormatError("XObject should be a stream");
                        const xt = rt.dict.get("Subtype");
                        if (!(xt instanceof v.Name))
                          throw new t.FormatError("XObject should have a Name subtype");
                        if (xt.name === "Form") {
                          fe.save(), Q.buildFormXObject(te, rt, null, se, K, fe.state.clone(), ee).then(function() {
                            fe.restore(), Me();
                          }, at);
                          return;
                        } else if (xt.name === "Image") {
                          Q.buildPaintImageXObject({
                            resources: te,
                            image: rt,
                            operatorList: se,
                            cacheKey: Le,
                            localImageCache: oe,
                            localColorSpaceCache: ee
                          }).then(Me, at);
                          return;
                        } else if (xt.name === "PS")
                          (0, t.info)("Ignored XObject subtype PS");
                        else
                          throw new t.FormatError(`Unhandled XObject subtype ${xt.name}`);
                        Me();
                      }).catch(function(Me) {
                        if (!(Me instanceof t.AbortException)) {
                          if (Q.options.ignoreErrors) {
                            Q.handler.send("UnsupportedFeature", {
                              featureId: t.UNSUPPORTED_FEATURES.errorXObject
                            }), (0, t.warn)(`getOperatorList - ignoring XObject: "${Me}".`);
                            return;
                          }
                          throw Me;
                        }
                      }));
                      return;
                    case t.OPS.setFont:
                      var Qe = Te[1];
                      ke(Q.handleSetFont(te, Te, null, se, K, fe.state, N).then(function(Me) {
                        se.addDependency(Me), se.addOp(t.OPS.setFont, [Me, Qe]);
                      }));
                      return;
                    case t.OPS.beginText:
                      ne = !0;
                      break;
                    case t.OPS.endText:
                      ne = !1;
                      break;
                    case t.OPS.endInlineImage:
                      var Ue = Te[0].cacheKey;
                      if (Ue) {
                        const Me = oe.getByName(Ue);
                        if (Me) {
                          se.addImageOps(Me.fn, Me.args, Me.optionalContent), F(Me), Te = null;
                          continue;
                        }
                      }
                      ke(Q.buildPaintImageXObject({
                        resources: te,
                        image: Te[0],
                        isInline: !0,
                        operatorList: se,
                        cacheKey: Ue,
                        localImageCache: oe,
                        localColorSpaceCache: ee
                      }));
                      return;
                    case t.OPS.showText:
                      if (!fe.state.font) {
                        Q.ensureStateFont(fe.state);
                        continue;
                      }
                      Te[0] = Q.handleText(Te[0], fe.state);
                      break;
                    case t.OPS.showSpacedText:
                      if (!fe.state.font) {
                        Q.ensureStateFont(fe.state);
                        continue;
                      }
                      var Ie = Te[0], Ee = [], et = Ie.length, qe = fe.state;
                      for (we = 0; we < et; ++we) {
                        const Me = Ie[we];
                        typeof Me == "string" ? Array.prototype.push.apply(Ee, Q.handleText(Me, qe)) : typeof Me == "number" && Ee.push(Me);
                      }
                      Te[0] = Ee, je = t.OPS.showText;
                      break;
                    case t.OPS.nextLineShowText:
                      if (!fe.state.font) {
                        Q.ensureStateFont(fe.state);
                        continue;
                      }
                      se.addOp(t.OPS.nextLine), Te[0] = Q.handleText(Te[0], fe.state), je = t.OPS.showText;
                      break;
                    case t.OPS.nextLineSetSpacingShowText:
                      if (!fe.state.font) {
                        Q.ensureStateFont(fe.state);
                        continue;
                      }
                      se.addOp(t.OPS.nextLine), se.addOp(t.OPS.setWordSpacing, [Te.shift()]), se.addOp(t.OPS.setCharSpacing, [Te.shift()]), Te[0] = Q.handleText(Te[0], fe.state), je = t.OPS.showText;
                      break;
                    case t.OPS.setTextRenderingMode:
                      fe.state.textRenderingMode = Te[0];
                      break;
                    case t.OPS.setFillColorSpace: {
                      const Me = b.ColorSpace.getCached(Te[0], D, ee);
                      if (Me) {
                        fe.state.fillColorSpace = Me;
                        continue;
                      }
                      ke(Q.parseColorSpace({
                        cs: Te[0],
                        resources: te,
                        localColorSpaceCache: ee
                      }).then(function(at) {
                        at && (fe.state.fillColorSpace = at);
                      }));
                      return;
                    }
                    case t.OPS.setStrokeColorSpace: {
                      const Me = b.ColorSpace.getCached(Te[0], D, ee);
                      if (Me) {
                        fe.state.strokeColorSpace = Me;
                        continue;
                      }
                      ke(Q.parseColorSpace({
                        cs: Te[0],
                        resources: te,
                        localColorSpaceCache: ee
                      }).then(function(at) {
                        at && (fe.state.strokeColorSpace = at);
                      }));
                      return;
                    }
                    case t.OPS.setFillColor:
                      ve = fe.state.fillColorSpace, Te = ve.getRgb(Te, 0), je = t.OPS.setFillRGBColor;
                      break;
                    case t.OPS.setStrokeColor:
                      ve = fe.state.strokeColorSpace, Te = ve.getRgb(Te, 0), je = t.OPS.setStrokeRGBColor;
                      break;
                    case t.OPS.setFillGray:
                      fe.state.fillColorSpace = b.ColorSpace.singletons.gray, Te = b.ColorSpace.singletons.gray.getRgb(Te, 0), je = t.OPS.setFillRGBColor;
                      break;
                    case t.OPS.setStrokeGray:
                      fe.state.strokeColorSpace = b.ColorSpace.singletons.gray, Te = b.ColorSpace.singletons.gray.getRgb(Te, 0), je = t.OPS.setStrokeRGBColor;
                      break;
                    case t.OPS.setFillCMYKColor:
                      fe.state.fillColorSpace = b.ColorSpace.singletons.cmyk, Te = b.ColorSpace.singletons.cmyk.getRgb(Te, 0), je = t.OPS.setFillRGBColor;
                      break;
                    case t.OPS.setStrokeCMYKColor:
                      fe.state.strokeColorSpace = b.ColorSpace.singletons.cmyk, Te = b.ColorSpace.singletons.cmyk.getRgb(Te, 0), je = t.OPS.setStrokeRGBColor;
                      break;
                    case t.OPS.setFillRGBColor:
                      fe.state.fillColorSpace = b.ColorSpace.singletons.rgb, Te = b.ColorSpace.singletons.rgb.getRgb(Te, 0);
                      break;
                    case t.OPS.setStrokeRGBColor:
                      fe.state.strokeColorSpace = b.ColorSpace.singletons.rgb, Te = b.ColorSpace.singletons.rgb.getRgb(Te, 0);
                      break;
                    case t.OPS.setFillColorN:
                      if (ve = fe.state.fillColorSpace, ve.name === "Pattern") {
                        ke(Q.handleColorN(se, t.OPS.setFillColorN, Te, ve, ue, te, K, ee, E, H));
                        return;
                      }
                      Te = ve.getRgb(Te, 0), je = t.OPS.setFillRGBColor;
                      break;
                    case t.OPS.setStrokeColorN:
                      if (ve = fe.state.strokeColorSpace, ve.name === "Pattern") {
                        ke(Q.handleColorN(se, t.OPS.setStrokeColorN, Te, ve, ue, te, K, ee, E, H));
                        return;
                      }
                      Te = ve.getRgb(Te, 0), je = t.OPS.setStrokeRGBColor;
                      break;
                    case t.OPS.shadingFill:
                      var tt = te.get("Shading");
                      if (!tt)
                        throw new t.FormatError("No shading resource found");
                      var ft = tt.get(Te[0].name);
                      if (!ft)
                        throw new t.FormatError("No shading object found");
                      Te = [Q.parseShading({
                        shading: ft,
                        resources: te,
                        localColorSpaceCache: ee,
                        localShadingPatternCache: H
                      })], je = t.OPS.shadingFill;
                      break;
                    case t.OPS.setGState:
                      if (He = Te[0] instanceof v.Name, Le = Te[0].name, He) {
                        const Me = $.getByName(Le);
                        if (Me) {
                          Me.length > 0 && se.addOp(t.OPS.setGState, [Me]), Te = null;
                          continue;
                        }
                      }
                      ke(new Promise(function(Me, at) {
                        if (!He)
                          throw new t.FormatError("GState must be referred to by name.");
                        const rt = te.get("ExtGState");
                        if (!(rt instanceof v.Dict))
                          throw new t.FormatError("ExtGState should be a dictionary.");
                        const xt = rt.get(Le);
                        if (!(xt instanceof v.Dict))
                          throw new t.FormatError("GState should be a dictionary.");
                        Q.setGState({
                          resources: te,
                          gState: xt,
                          operatorList: se,
                          cacheKey: Le,
                          task: K,
                          stateManager: fe,
                          localGStateCache: $,
                          localColorSpaceCache: ee
                        }).then(Me, at);
                      }).catch(function(Me) {
                        if (!(Me instanceof t.AbortException)) {
                          if (Q.options.ignoreErrors) {
                            Q.handler.send("UnsupportedFeature", {
                              featureId: t.UNSUPPORTED_FEATURES.errorExtGState
                            }), (0, t.warn)(`getOperatorList - ignoring ExtGState: "${Me}".`);
                            return;
                          }
                          throw Me;
                        }
                      }));
                      return;
                    case t.OPS.moveTo:
                    case t.OPS.lineTo:
                    case t.OPS.curveTo:
                    case t.OPS.curveTo2:
                    case t.OPS.curveTo3:
                    case t.OPS.closePath:
                    case t.OPS.rectangle:
                      Q.buildPath(se, je, Te, ne);
                      continue;
                    case t.OPS.markPoint:
                    case t.OPS.markPointProps:
                    case t.OPS.beginCompat:
                    case t.OPS.endCompat:
                      continue;
                    case t.OPS.beginMarkedContentProps:
                      if (!(Te[0] instanceof v.Name)) {
                        (0, t.warn)(`Expected name for beginMarkedContentProps arg0=${Te[0]}`);
                        continue;
                      }
                      if (Te[0].name === "OC") {
                        ke(Q.parseMarkedContentProps(Te[1], te).then((Me) => {
                          se.addOp(t.OPS.beginMarkedContentProps, ["OC", Me]);
                        }).catch((Me) => {
                          if (!(Me instanceof t.AbortException)) {
                            if (Q.options.ignoreErrors) {
                              Q.handler.send("UnsupportedFeature", {
                                featureId: t.UNSUPPORTED_FEATURES.errorMarkedContent
                              }), (0, t.warn)(`getOperatorList - ignoring beginMarkedContentProps: "${Me}".`);
                              return;
                            }
                            throw Me;
                          }
                        }));
                        return;
                      }
                      Te = [Te[0].name, Te[1] instanceof v.Dict ? Te[1].get("MCID") : null];
                      break;
                    case t.OPS.beginMarkedContent:
                    case t.OPS.endMarkedContent:
                    default:
                      if (Te !== null) {
                        for (we = 0, Ce = Te.length; we < Ce && !(Te[we] instanceof v.Dict); we++)
                          ;
                        if (we < Ce) {
                          (0, t.warn)("getOperatorList - ignoring operator: " + je);
                          continue;
                        }
                      }
                  }
                  se.addOp(je, Te);
                }
                if (_e) {
                  ke(O);
                  return;
                }
                xe(), Ae();
              }).catch((De) => {
                if (!(De instanceof t.AbortException)) {
                  if (this.options.ignoreErrors) {
                    this.handler.send("UnsupportedFeature", {
                      featureId: t.UNSUPPORTED_FEATURES.errorOperatorList
                    }), (0, t.warn)(`getOperatorList - ignoring errors during "${K.name}" task: "${De}".`), xe();
                    return;
                  }
                  throw De;
                }
              });
            }
            getTextContent({
              stream: L,
              task: K,
              resources: te,
              stateManager: se = null,
              combineTextItems: q = !1,
              includeMarkedContent: N = !1,
              sink: Q,
              seenStyles: D = /* @__PURE__ */ new Set(),
              viewBox: ne
            }) {
              te = te || v.Dict.empty, se = se || new V(new J());
              const oe = (0, d.getNormalizedUnicodes)(), ee = {
                items: [],
                styles: /* @__PURE__ */ Object.create(null)
              }, $ = {
                initialized: !1,
                str: [],
                totalWidth: 0,
                totalHeight: 0,
                width: 0,
                height: 0,
                vertical: !1,
                prevTransform: null,
                textAdvanceScale: 0,
                spaceInFlowMin: 0,
                spaceInFlowMax: 0,
                trackingSpaceMin: 1 / 0,
                negativeSpaceMax: -1 / 0,
                notASpace: -1 / 0,
                transform: null,
                fontName: null,
                hasEOL: !1
              }, E = [" ", " "];
              let H = 0;
              function ie(Me) {
                const at = (H + 1) % 2, rt = E[H] !== " " && E[at] === " ";
                return E[H] = Me, H = at, rt;
              }
              function ue() {
                E[0] = E[1] = " ", H = 0;
              }
              const fe = 0.1, de = 0.03, pe = -0.2, xe = 0.1, De = 0.6, Ae = this, Se = this.xref, ke = [];
              let ye = null;
              const _e = new l.LocalImageCache(), we = new l.LocalGStateCache(), Ce = new z(L, Se, se);
              let ve;
              function Le() {
                const Me = ve.font, at = [ve.fontSize * ve.textHScale, 0, 0, ve.fontSize, 0, ve.textRise];
                if (Me.isType3Font && (ve.fontSize <= 1 || Me.isCharBBox) && !(0, t.isArrayEqual)(ve.fontMatrix, t.FONT_IDENTITY_MATRIX)) {
                  const rt = Me.bbox[3] - Me.bbox[1];
                  rt > 0 && (at[3] *= rt * ve.fontMatrix[3]);
                }
                return t.Util.transform(ve.ctm, t.Util.transform(ve.textMatrix, at));
              }
              function He() {
                if ($.initialized)
                  return $;
                const Me = ve.font, at = Me.loadedName;
                D.has(at) || (D.add(at), ee.styles[at] = {
                  fontFamily: Me.fallbackName,
                  ascent: Me.ascent,
                  descent: Me.descent,
                  vertical: Me.vertical
                }), $.fontName = at;
                const rt = $.transform = Le();
                Me.vertical ? ($.width = $.totalWidth = Math.hypot(rt[0], rt[1]), $.height = $.totalHeight = 0, $.vertical = !0) : ($.width = $.totalWidth = 0, $.height = $.totalHeight = Math.hypot(rt[2], rt[3]), $.vertical = !1);
                const xt = Math.hypot(ve.textLineMatrix[0], ve.textLineMatrix[1]), ut = Math.hypot(ve.ctm[0], ve.ctm[1]);
                return $.textAdvanceScale = ut * xt, $.trackingSpaceMin = ve.fontSize * fe, $.notASpace = ve.fontSize * de, $.negativeSpaceMax = ve.fontSize * pe, $.spaceInFlowMin = ve.fontSize * xe, $.spaceInFlowMax = ve.fontSize * De, $.hasEOL = !1, $.initialized = !0, $;
              }
              function Qe() {
                if (!$.initialized)
                  return;
                const Me = Math.hypot(ve.textLineMatrix[0], ve.textLineMatrix[1]), rt = Math.hypot(ve.ctm[0], ve.ctm[1]) * Me;
                rt !== $.textAdvanceScale && ($.vertical ? ($.totalHeight += $.height * $.textAdvanceScale, $.height = 0) : ($.totalWidth += $.width * $.textAdvanceScale, $.width = 0), $.textAdvanceScale = rt);
              }
              function Ue(Me) {
                const at = Me.str.join(""), rt = (0, _.bidi)(at, -1, Me.vertical);
                return {
                  str: rt.str,
                  dir: rt.dir,
                  width: Math.abs(Me.totalWidth),
                  height: Math.abs(Me.totalHeight),
                  transform: Me.transform,
                  fontName: Me.fontName,
                  hasEOL: Me.hasEOL
                };
              }
              function Ie(Me, at) {
                return Ae.loadFont(Me, at, te).then(function(rt) {
                  return rt.font.isType3Font ? rt.loadType3Data(Ae, te, K).catch(function() {
                  }).then(function() {
                    return rt;
                  }) : rt;
                }).then(function(rt) {
                  ve.font = rt.font, ve.fontMatrix = rt.font.fontMatrix || t.FONT_IDENTITY_MATRIX;
                });
              }
              function Ee(Me, at, rt) {
                const xt = Math.hypot(rt[0], rt[1]);
                return [(rt[0] * Me + rt[1] * at) / xt, (rt[2] * Me + rt[3] * at) / xt];
              }
              function et() {
                const Me = Le();
                let at = Me[4], rt = Me[5];
                const xt = at - ne[0], ut = rt - ne[1];
                if (xt < 0 || xt > ne[2] || ut < 0 || ut > ne[3])
                  return !1;
                if (!q || !ve.font || !$.prevTransform)
                  return !0;
                let yt = $.prevTransform[4], ht = $.prevTransform[5];
                if (yt === at && ht === rt)
                  return !0;
                let Rt = -1;
                switch (Me[0] && Me[1] === 0 && Me[2] === 0 ? Rt = Me[0] > 0 ? 0 : 180 : Me[1] && Me[0] === 0 && Me[3] === 0 && (Rt = Me[1] > 0 ? 90 : 270), Rt) {
                  case 0:
                    break;
                  case 90:
                    [at, rt] = [rt, at], [yt, ht] = [ht, yt];
                    break;
                  case 180:
                    [at, rt, yt, ht] = [-at, -rt, -yt, -ht];
                    break;
                  case 270:
                    [at, rt] = [-rt, -at], [yt, ht] = [-ht, -yt];
                    break;
                  default:
                    [at, rt] = Ee(at, rt, Me), [yt, ht] = Ee(yt, ht, $.prevTransform);
                }
                if (ve.font.vertical) {
                  const nt = (ht - rt) / $.textAdvanceScale, it = at - yt, pt = Math.sign($.height);
                  return nt < pt * $.negativeSpaceMax ? Math.abs(it) > 0.5 * $.width ? (tt(), !0) : (ue(), Te(), !0) : Math.abs(it) > $.width ? (tt(), !0) : (nt <= pt * $.notASpace && ue(), nt <= pt * $.trackingSpaceMin ? $.height += nt : ft(nt, $.prevTransform, pt) || ($.str.length === 0 ? (ue(), ee.items.push({
                    str: " ",
                    dir: "ltr",
                    width: 0,
                    height: Math.abs(nt),
                    transform: $.prevTransform,
                    fontName: $.fontName,
                    hasEOL: !1
                  })) : $.height += nt), !0);
                }
                const Wt = (at - yt) / $.textAdvanceScale, Ke = rt - ht, Ge = Math.sign($.width);
                return Wt < Ge * $.negativeSpaceMax ? Math.abs(Ke) > 0.5 * $.height ? (tt(), !0) : (ue(), Te(), !0) : Math.abs(Ke) > $.height ? (tt(), !0) : (Wt <= Ge * $.notASpace && ue(), Wt <= Ge * $.trackingSpaceMin ? $.width += Wt : ft(Wt, $.prevTransform, Ge) || ($.str.length === 0 ? (ue(), ee.items.push({
                  str: " ",
                  dir: "ltr",
                  width: Math.abs(Wt),
                  height: 0,
                  transform: $.prevTransform,
                  fontName: $.fontName,
                  hasEOL: !1
                })) : $.width += Wt), !0);
              }
              function qe({
                chars: Me,
                extraSpacing: at
              }) {
                const rt = ve.font;
                if (!Me) {
                  const yt = ve.charSpacing + at;
                  yt && (rt.vertical ? ve.translateTextMatrix(0, -yt) : ve.translateTextMatrix(yt * ve.textHScale, 0));
                  return;
                }
                const xt = rt.charsToGlyphs(Me), ut = ve.fontMatrix[0] * ve.fontSize;
                for (let yt = 0, ht = xt.length; yt < ht; yt++) {
                  const Rt = xt[yt];
                  if (Rt.isInvisibleFormatMark)
                    continue;
                  let Wt = ve.charSpacing + (yt + 1 === ht ? at : 0), Ke = Rt.width;
                  rt.vertical && (Ke = Rt.vmetric ? Rt.vmetric[0] : -Ke);
                  let Ge = Ke * ut;
                  if (Rt.isWhitespace) {
                    rt.vertical ? (Wt += -Ge + ve.wordSpacing, ve.translateTextMatrix(0, -Wt)) : (Wt += Ge + ve.wordSpacing, ve.translateTextMatrix(Wt * ve.textHScale, 0)), ie(" ");
                    continue;
                  }
                  if (!et())
                    continue;
                  const nt = He();
                  Rt.isZeroWidthDiacritic && (Ge = 0), rt.vertical ? (ve.translateTextMatrix(0, Ge), Ge = Math.abs(Ge), nt.height += Ge) : (Ge *= ve.textHScale, ve.translateTextMatrix(Ge, 0), nt.width += Ge), Ge && (nt.prevTransform = Le());
                  let it = Rt.unicode;
                  it = oe[it] || it, it = (0, d.reverseIfRtl)(it), ie(it) && nt.str.push(" "), nt.str.push(it), Wt && (rt.vertical ? ve.translateTextMatrix(0, -Wt) : ve.translateTextMatrix(Wt * ve.textHScale, 0));
                }
              }
              function tt() {
                ue(), $.initialized ? ($.hasEOL = !0, Te()) : ee.items.push({
                  str: "",
                  dir: "ltr",
                  width: 0,
                  height: 0,
                  transform: Le(),
                  fontName: ve.font.loadedName,
                  hasEOL: !0
                });
              }
              function ft(Me, at, rt) {
                if (rt * $.spaceInFlowMin <= Me && Me <= rt * $.spaceInFlowMax)
                  return $.initialized && (ue(), $.str.push(" ")), !1;
                const xt = $.fontName;
                let ut = 0;
                return $.vertical && (ut = Me, Me = 0), Te(), ue(), ee.items.push({
                  str: " ",
                  dir: "ltr",
                  width: Math.abs(Me),
                  height: Math.abs(ut),
                  transform: at || Le(),
                  fontName: xt,
                  hasEOL: !1
                }), !0;
              }
              function Te() {
                !$.initialized || !$.str || ($.vertical ? $.totalHeight += $.height * $.textAdvanceScale : $.totalWidth += $.width * $.textAdvanceScale, ee.items.push(Ue($)), $.initialized = !1, $.str.length = 0);
              }
              function je(Me = !1) {
                const at = ee.items.length;
                at !== 0 && (Me && at < U || (Q.enqueue(ee, at), ee.items = [], ee.styles = /* @__PURE__ */ Object.create(null)));
              }
              const Ze = new T();
              return new Promise(function Me(at, rt) {
                const xt = function(nt) {
                  je(!0), Promise.all([nt, Q.ready]).then(function() {
                    try {
                      Me(at, rt);
                    } catch (it) {
                      rt(it);
                    }
                  }, rt);
                };
                K.ensureNotTerminated(), Ze.reset();
                const ut = {};
                let yt, ht = [];
                for (; !(yt = Ze.check()) && (ht.length = 0, ut.args = ht, !!Ce.read(ut)); ) {
                  ve = se.state;
                  const nt = ut.fn;
                  switch (ht = ut.args, nt | 0) {
                    case t.OPS.setFont:
                      var Rt = ht[0].name, Wt = ht[1];
                      if (ve.font && Rt === ve.fontName && Wt === ve.fontSize)
                        break;
                      Te(), ve.fontName = Rt, ve.fontSize = Wt, xt(Ie(Rt, null));
                      return;
                    case t.OPS.setTextRise:
                      ve.textRise = ht[0];
                      break;
                    case t.OPS.setHScale:
                      ve.textHScale = ht[0] / 100;
                      break;
                    case t.OPS.setLeading:
                      ve.leading = ht[0];
                      break;
                    case t.OPS.moveText:
                      ve.translateTextLineMatrix(ht[0], ht[1]), ve.textMatrix = ve.textLineMatrix.slice();
                      break;
                    case t.OPS.setLeadingMoveText:
                      ve.leading = -ht[1], ve.translateTextLineMatrix(ht[0], ht[1]), ve.textMatrix = ve.textLineMatrix.slice();
                      break;
                    case t.OPS.nextLine:
                      ve.carriageReturn();
                      break;
                    case t.OPS.setTextMatrix:
                      ve.setTextMatrix(ht[0], ht[1], ht[2], ht[3], ht[4], ht[5]), ve.setTextLineMatrix(ht[0], ht[1], ht[2], ht[3], ht[4], ht[5]), Qe();
                      break;
                    case t.OPS.setCharSpacing:
                      ve.charSpacing = ht[0];
                      break;
                    case t.OPS.setWordSpacing:
                      ve.wordSpacing = ht[0];
                      break;
                    case t.OPS.beginText:
                      ve.textMatrix = t.IDENTITY_MATRIX.slice(), ve.textLineMatrix = t.IDENTITY_MATRIX.slice();
                      break;
                    case t.OPS.showSpacedText:
                      if (!se.state.font) {
                        Ae.ensureStateFont(se.state);
                        continue;
                      }
                      const it = (ve.font.vertical ? 1 : -1) * ve.fontSize / 1e3, pt = ht[0];
                      for (let mt = 0, ct = pt.length; mt < ct - 1; mt++) {
                        const bt = pt[mt];
                        if (typeof bt == "string")
                          ke.push(bt);
                        else if (typeof bt == "number" && bt !== 0) {
                          const wt = ke.join("");
                          ke.length = 0, qe({
                            chars: wt,
                            extraSpacing: bt * it
                          });
                        }
                      }
                      const Ft = pt.at(-1);
                      if (typeof Ft == "string" && ke.push(Ft), ke.length > 0) {
                        const mt = ke.join("");
                        ke.length = 0, qe({
                          chars: mt,
                          extraSpacing: 0
                        });
                      }
                      break;
                    case t.OPS.showText:
                      if (!se.state.font) {
                        Ae.ensureStateFont(se.state);
                        continue;
                      }
                      qe({
                        chars: ht[0],
                        extraSpacing: 0
                      });
                      break;
                    case t.OPS.nextLineShowText:
                      if (!se.state.font) {
                        Ae.ensureStateFont(se.state);
                        continue;
                      }
                      ve.carriageReturn(), qe({
                        chars: ht[0],
                        extraSpacing: 0
                      });
                      break;
                    case t.OPS.nextLineSetSpacingShowText:
                      if (!se.state.font) {
                        Ae.ensureStateFont(se.state);
                        continue;
                      }
                      ve.wordSpacing = ht[0], ve.charSpacing = ht[1], ve.carriageReturn(), qe({
                        chars: ht[2],
                        extraSpacing: 0
                      });
                      break;
                    case t.OPS.paintXObject:
                      Te(), ye || (ye = te.get("XObject") || v.Dict.empty);
                      var Ke = ht[0] instanceof v.Name, Ge = ht[0].name;
                      if (Ke && _e.getByName(Ge))
                        break;
                      xt(new Promise(function(mt, ct) {
                        if (!Ke)
                          throw new t.FormatError("XObject must be referred to by name.");
                        let bt = ye.getRaw(Ge);
                        if (bt instanceof v.Ref) {
                          if (_e.getByRef(bt)) {
                            mt();
                            return;
                          }
                          if (Ae.globalImageCache.getData(bt, Ae.pageIndex)) {
                            mt();
                            return;
                          }
                          bt = Se.fetch(bt);
                        }
                        if (!(bt instanceof w.BaseStream))
                          throw new t.FormatError("XObject should be a stream");
                        const wt = bt.dict.get("Subtype");
                        if (!(wt instanceof v.Name))
                          throw new t.FormatError("XObject should have a Name subtype");
                        if (wt.name !== "Form") {
                          _e.set(Ge, bt.dict.objId, !0), mt();
                          return;
                        }
                        const Ot = se.state.clone(), Et = new V(Ot), St = bt.dict.getArray("Matrix");
                        Array.isArray(St) && St.length === 6 && Et.transform(St), je();
                        const Pe = {
                          enqueueInvoked: !1,
                          enqueue(We, Je) {
                            this.enqueueInvoked = !0, Q.enqueue(We, Je);
                          },
                          get desiredSize() {
                            return Q.desiredSize;
                          },
                          get ready() {
                            return Q.ready;
                          }
                        };
                        Ae.getTextContent({
                          stream: bt,
                          task: K,
                          resources: bt.dict.get("Resources") || te,
                          stateManager: Et,
                          combineTextItems: q,
                          includeMarkedContent: N,
                          sink: Pe,
                          seenStyles: D,
                          viewBox: ne
                        }).then(function() {
                          Pe.enqueueInvoked || _e.set(Ge, bt.dict.objId, !0), mt();
                        }, ct);
                      }).catch(function(mt) {
                        if (!(mt instanceof t.AbortException)) {
                          if (Ae.options.ignoreErrors) {
                            (0, t.warn)(`getTextContent - ignoring XObject: "${mt}".`);
                            return;
                          }
                          throw mt;
                        }
                      }));
                      return;
                    case t.OPS.setGState:
                      if (Ke = ht[0] instanceof v.Name, Ge = ht[0].name, Ke && we.getByName(Ge))
                        break;
                      xt(new Promise(function(mt, ct) {
                        if (!Ke)
                          throw new t.FormatError("GState must be referred to by name.");
                        const bt = te.get("ExtGState");
                        if (!(bt instanceof v.Dict))
                          throw new t.FormatError("ExtGState should be a dictionary.");
                        const wt = bt.get(Ge);
                        if (!(wt instanceof v.Dict))
                          throw new t.FormatError("GState should be a dictionary.");
                        const Ot = wt.get("Font");
                        if (!Ot) {
                          we.set(Ge, wt.objId, !0), mt();
                          return;
                        }
                        Te(), ve.fontName = null, ve.fontSize = Ot[1], Ie(null, Ot[0]).then(mt, ct);
                      }).catch(function(mt) {
                        if (!(mt instanceof t.AbortException)) {
                          if (Ae.options.ignoreErrors) {
                            (0, t.warn)(`getTextContent - ignoring ExtGState: "${mt}".`);
                            return;
                          }
                          throw mt;
                        }
                      }));
                      return;
                    case t.OPS.beginMarkedContent:
                      Te(), N && ee.items.push({
                        type: "beginMarkedContent",
                        tag: ht[0] instanceof v.Name ? ht[0].name : null
                      });
                      break;
                    case t.OPS.beginMarkedContentProps:
                      if (Te(), N) {
                        let mt = null;
                        ht[1] instanceof v.Dict && (mt = ht[1].get("MCID")), ee.items.push({
                          type: "beginMarkedContentProps",
                          id: Number.isInteger(mt) ? `${Ae.idFactory.getPageObjId()}_mcid${mt}` : null,
                          tag: ht[0] instanceof v.Name ? ht[0].name : null
                        });
                      }
                      break;
                    case t.OPS.endMarkedContent:
                      Te(), N && ee.items.push({
                        type: "endMarkedContent"
                      });
                      break;
                  }
                  if (ee.items.length >= Q.desiredSize) {
                    yt = !0;
                    break;
                  }
                }
                if (yt) {
                  xt(O);
                  return;
                }
                Te(), je(), at();
              }).catch((Me) => {
                if (!(Me instanceof t.AbortException)) {
                  if (this.options.ignoreErrors) {
                    (0, t.warn)(`getTextContent - ignoring errors during "${K.name}" task: "${Me}".`), Te(), je();
                    return;
                  }
                  throw Me;
                }
              });
            }
            extractDataStructures(L, K, te) {
              const se = this.xref;
              let q;
              const N = this.readToUnicode(te.toUnicode || L.get("ToUnicode") || K.get("ToUnicode"));
              if (te.composite) {
                const oe = L.get("CIDSystemInfo");
                oe instanceof v.Dict && (te.cidSystemInfo = {
                  registry: (0, t.stringToPDFString)(oe.get("Registry")),
                  ordering: (0, t.stringToPDFString)(oe.get("Ordering")),
                  supplement: oe.get("Supplement")
                });
                try {
                  const ee = L.get("CIDToGIDMap");
                  ee instanceof w.BaseStream && (q = ee.getBytes());
                } catch (ee) {
                  if (!this.options.ignoreErrors)
                    throw ee;
                  (0, t.warn)(`extractDataStructures - ignoring CIDToGIDMap data: "${ee}".`);
                }
              }
              const Q = [];
              let D = null, ne;
              if (L.has("Encoding")) {
                if (ne = L.get("Encoding"), ne instanceof v.Dict) {
                  if (D = ne.get("BaseEncoding"), D = D instanceof v.Name ? D.name : null, ne.has("Differences")) {
                    const oe = ne.get("Differences");
                    let ee = 0;
                    for (let $ = 0, E = oe.length; $ < E; $++) {
                      const H = se.fetchIfRef(oe[$]);
                      if (typeof H == "number")
                        ee = H;
                      else if (H instanceof v.Name)
                        Q[ee++] = H.name;
                      else
                        throw new t.FormatError(`Invalid entry in 'Differences' array: ${H}`);
                    }
                  }
                } else if (ne instanceof v.Name)
                  D = ne.name;
                else {
                  const oe = "Encoding is not a Name nor a Dict";
                  if (!this.options.ignoreErrors)
                    throw new t.FormatError(oe);
                  (0, t.warn)(oe);
                }
                D !== "MacRomanEncoding" && D !== "MacExpertEncoding" && D !== "WinAnsiEncoding" && (D = null);
              }
              if (D)
                te.defaultEncoding = (0, y.getEncoding)(D);
              else {
                const oe = !!(te.flags & e.FontFlags.Symbolic), ee = !!(te.flags & e.FontFlags.Nonsymbolic);
                ne = y.StandardEncoding, te.type === "TrueType" && !ee && (ne = y.WinAnsiEncoding), oe && (ne = y.MacRomanEncoding, (!te.file || te.isInternalFont) && (/Symbol/i.test(te.name) ? ne = y.SymbolSetEncoding : /Dingbats|Wingdings/i.test(te.name) && (ne = y.ZapfDingbatsEncoding))), te.defaultEncoding = ne;
              }
              return te.differences = Q, te.baseEncodingName = D, te.hasEncoding = !!D || Q.length > 0, te.dict = L, N.then((oe) => (te.toUnicode = oe, this.buildToUnicode(te))).then((oe) => (te.toUnicode = oe, q && (te.cidToGidMap = this.readCidToGidMap(q, oe)), te));
            }
            _simpleFontToUnicode(L, K = !1) {
              (0, t.assert)(!L.composite, "Must be a simple font.");
              const te = [], se = L.defaultEncoding.slice(), q = L.baseEncodingName, N = L.differences;
              for (const D in N) {
                const ne = N[D];
                ne !== ".notdef" && (se[D] = ne);
              }
              const Q = (0, Y.getGlyphsUnicode)();
              for (const D in se) {
                let ne = se[D];
                if (ne !== "") {
                  if (Q[ne] === void 0) {
                    let oe = 0;
                    switch (ne[0]) {
                      case "G":
                        ne.length === 3 && (oe = parseInt(ne.substring(1), 16));
                        break;
                      case "g":
                        ne.length === 5 && (oe = parseInt(ne.substring(1), 16));
                        break;
                      case "C":
                      case "c":
                        if (ne.length >= 3 && ne.length <= 4) {
                          const $ = ne.substring(1);
                          if (K) {
                            oe = parseInt($, 16);
                            break;
                          }
                          if (oe = +$, Number.isNaN(oe) && Number.isInteger(parseInt($, 16)))
                            return this._simpleFontToUnicode(L, !0);
                        }
                        break;
                      default:
                        const ee = (0, d.getUnicodeForGlyph)(ne, Q);
                        ee !== -1 && (oe = ee);
                    }
                    if (oe > 0 && oe <= 1114111 && Number.isInteger(oe)) {
                      if (q && oe === +D) {
                        const ee = (0, y.getEncoding)(q);
                        if (ee && (ne = ee[D])) {
                          te[D] = String.fromCharCode(Q[ne]);
                          continue;
                        }
                      }
                      te[D] = String.fromCodePoint(oe);
                    }
                    continue;
                  }
                  te[D] = String.fromCharCode(Q[ne]);
                }
              }
              return te;
            }
            async buildToUnicode(L) {
              if (L.hasIncludedToUnicodeMap = !!L.toUnicode && L.toUnicode.length > 0, L.hasIncludedToUnicodeMap)
                return !L.composite && L.hasEncoding && (L.fallbackToUnicode = this._simpleFontToUnicode(L)), L.toUnicode;
              if (!L.composite)
                return new g.ToUnicodeMap(this._simpleFontToUnicode(L));
              if (L.composite && (L.cMap.builtInCMap && !(L.cMap instanceof a.IdentityCMap) || L.cidSystemInfo.registry === "Adobe" && (L.cidSystemInfo.ordering === "GB1" || L.cidSystemInfo.ordering === "CNS1" || L.cidSystemInfo.ordering === "Japan1" || L.cidSystemInfo.ordering === "Korea1"))) {
                const {
                  registry: K,
                  ordering: te
                } = L.cidSystemInfo, se = v.Name.get(`${K}-${te}-UCS2`), q = await a.CMapFactory.create({
                  encoding: se,
                  fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                  useCMap: null
                }), N = [];
                return L.cMap.forEach(function(Q, D) {
                  if (D > 65535)
                    throw new t.FormatError("Max size of CID is 65,535");
                  const ne = q.lookup(D);
                  ne && (N[Q] = String.fromCharCode((ne.charCodeAt(0) << 8) + ne.charCodeAt(1)));
                }), new g.ToUnicodeMap(N);
              }
              return new g.IdentityToUnicodeMap(L.firstChar, L.lastChar);
            }
            readToUnicode(L) {
              return L ? L instanceof v.Name ? a.CMapFactory.create({
                encoding: L,
                fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                useCMap: null
              }).then(function(K) {
                return K instanceof a.IdentityCMap ? new g.IdentityToUnicodeMap(0, 65535) : new g.ToUnicodeMap(K.getMap());
              }) : L instanceof w.BaseStream ? a.CMapFactory.create({
                encoding: L,
                fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                useCMap: null
              }).then(function(K) {
                if (K instanceof a.IdentityCMap)
                  return new g.IdentityToUnicodeMap(0, 65535);
                const te = new Array(K.length);
                return K.forEach(function(se, q) {
                  if (typeof q == "number") {
                    te[se] = String.fromCodePoint(q);
                    return;
                  }
                  const N = [];
                  for (let Q = 0; Q < q.length; Q += 2) {
                    const D = q.charCodeAt(Q) << 8 | q.charCodeAt(Q + 1);
                    if ((D & 63488) !== 55296) {
                      N.push(D);
                      continue;
                    }
                    Q += 2;
                    const ne = q.charCodeAt(Q) << 8 | q.charCodeAt(Q + 1);
                    N.push(((D & 1023) << 10) + (ne & 1023) + 65536);
                  }
                  te[se] = String.fromCodePoint(...N);
                }), new g.ToUnicodeMap(te);
              }, (K) => {
                if (K instanceof t.AbortException)
                  return null;
                if (this.options.ignoreErrors)
                  return this.handler.send("UnsupportedFeature", {
                    featureId: t.UNSUPPORTED_FEATURES.errorFontToUnicode
                  }), (0, t.warn)(`readToUnicode - ignoring ToUnicode data: "${K}".`), null;
                throw K;
              }) : Promise.resolve(null) : Promise.resolve(null);
            }
            readCidToGidMap(L, K) {
              const te = [];
              for (let se = 0, q = L.length; se < q; se++) {
                const N = L[se++] << 8 | L[se], Q = se >> 1;
                N === 0 && !K.has(Q) || (te[Q] = N);
              }
              return te;
            }
            extractWidths(L, K, te) {
              const se = this.xref;
              let q = [], N = 0;
              const Q = [];
              let D, ne, oe, ee, $, E, H, ie;
              if (te.composite) {
                if (N = L.has("DW") ? L.get("DW") : 1e3, ie = L.get("W"), ie)
                  for (ne = 0, oe = ie.length; ne < oe; ne++)
                    if (E = se.fetchIfRef(ie[ne++]), H = se.fetchIfRef(ie[ne]), Array.isArray(H))
                      for (ee = 0, $ = H.length; ee < $; ee++)
                        q[E++] = se.fetchIfRef(H[ee]);
                    else {
                      const de = se.fetchIfRef(ie[++ne]);
                      for (ee = E; ee <= H; ee++)
                        q[ee] = de;
                    }
                if (te.vertical) {
                  let de = L.getArray("DW2") || [880, -1e3];
                  if (D = [de[1], N * 0.5, de[0]], de = L.get("W2"), de)
                    for (ne = 0, oe = de.length; ne < oe; ne++)
                      if (E = se.fetchIfRef(de[ne++]), H = se.fetchIfRef(de[ne]), Array.isArray(H))
                        for (ee = 0, $ = H.length; ee < $; ee++)
                          Q[E++] = [se.fetchIfRef(H[ee++]), se.fetchIfRef(H[ee++]), se.fetchIfRef(H[ee])];
                      else {
                        const pe = [se.fetchIfRef(de[++ne]), se.fetchIfRef(de[++ne]), se.fetchIfRef(de[++ne])];
                        for (ee = E; ee <= H; ee++)
                          Q[ee] = pe;
                      }
                }
              } else {
                const de = te.firstChar;
                if (ie = L.get("Widths"), ie) {
                  for (ee = de, ne = 0, oe = ie.length; ne < oe; ne++)
                    q[ee++] = se.fetchIfRef(ie[ne]);
                  N = parseFloat(K.get("MissingWidth")) || 0;
                } else {
                  const pe = L.get("BaseFont");
                  if (pe instanceof v.Name) {
                    const xe = this.getBaseFontMetrics(pe.name);
                    q = this.buildCharCodeToWidth(xe.widths, te), N = xe.defaultWidth;
                  }
                }
              }
              let ue = !0, fe = N;
              for (const de in q) {
                const pe = q[de];
                if (pe) {
                  if (!fe) {
                    fe = pe;
                    continue;
                  }
                  if (fe !== pe) {
                    ue = !1;
                    break;
                  }
                }
              }
              ue && (te.flags |= e.FontFlags.FixedPitch), te.defaultWidth = N, te.widths = q, te.defaultVMetrics = D, te.vmetrics = Q;
            }
            isSerifFont(L) {
              const K = L.split("-")[0];
              return K in (0, c.getSerifFonts)() || K.search(/serif/gi) !== -1;
            }
            getBaseFontMetrics(L) {
              let K = 0, te = /* @__PURE__ */ Object.create(null), se = !1, N = (0, c.getStdFontMap)()[L] || L;
              const Q = (0, X.getMetrics)();
              N in Q || (this.isSerifFont(L) ? N = "Times-Roman" : N = "Helvetica");
              const D = Q[N];
              return typeof D == "number" ? (K = D, se = !0) : te = D(), {
                defaultWidth: K,
                monospace: se,
                widths: te
              };
            }
            buildCharCodeToWidth(L, K) {
              const te = /* @__PURE__ */ Object.create(null), se = K.differences, q = K.defaultEncoding;
              for (let N = 0; N < 256; N++) {
                if (N in se && L[se[N]]) {
                  te[N] = L[se[N]];
                  continue;
                }
                if (N in q && L[q[N]]) {
                  te[N] = L[q[N]];
                  continue;
                }
              }
              return te;
            }
            preEvaluateFont(L) {
              const K = L;
              let te = L.get("Subtype");
              if (!(te instanceof v.Name))
                throw new t.FormatError("invalid font Subtype");
              let se = !1, q, N;
              if (te.name === "Type0") {
                const oe = L.get("DescendantFonts");
                if (!oe)
                  throw new t.FormatError("Descendant fonts are not specified");
                if (L = Array.isArray(oe) ? this.xref.fetchIfRef(oe[0]) : oe, !(L instanceof v.Dict))
                  throw new t.FormatError("Descendant font is not a dictionary.");
                if (te = L.get("Subtype"), !(te instanceof v.Name))
                  throw new t.FormatError("invalid font Subtype");
                se = !0;
              }
              const Q = L.get("FirstChar") || 0, D = L.get("LastChar") || (se ? 65535 : 255), ne = L.get("FontDescriptor");
              if (ne) {
                q = new B.MurmurHash3_64();
                const oe = K.getRaw("Encoding");
                if (oe instanceof v.Name)
                  q.update(oe.name);
                else if (oe instanceof v.Ref)
                  q.update(oe.toString());
                else if (oe instanceof v.Dict) {
                  for (const $ of oe.getRawValues())
                    if ($ instanceof v.Name)
                      q.update($.name);
                    else if ($ instanceof v.Ref)
                      q.update($.toString());
                    else if (Array.isArray($)) {
                      const E = $.length, H = new Array(E);
                      for (let ie = 0; ie < E; ie++) {
                        const ue = $[ie];
                        ue instanceof v.Name ? H[ie] = ue.name : (typeof ue == "number" || ue instanceof v.Ref) && (H[ie] = ue.toString());
                      }
                      q.update(H.join());
                    }
                }
                if (q.update(`${Q}-${D}`), N = L.get("ToUnicode") || K.get("ToUnicode"), N instanceof w.BaseStream) {
                  const $ = N.str || N, E = $.buffer ? new Uint8Array($.buffer.buffer, 0, $.bufferLength) : new Uint8Array($.bytes.buffer, $.start, $.end - $.start);
                  q.update(E);
                } else
                  N instanceof v.Name && q.update(N.name);
                const ee = L.get("Widths") || K.get("Widths");
                if (Array.isArray(ee)) {
                  const $ = [];
                  for (const E of ee)
                    (typeof E == "number" || E instanceof v.Ref) && $.push(E.toString());
                  q.update($.join());
                }
                if (se) {
                  q.update("compositeFont");
                  const $ = L.get("W") || K.get("W");
                  if (Array.isArray($)) {
                    const H = [];
                    for (const ie of $)
                      if (typeof ie == "number" || ie instanceof v.Ref)
                        H.push(ie.toString());
                      else if (Array.isArray(ie)) {
                        const ue = [];
                        for (const fe of ie)
                          (typeof fe == "number" || fe instanceof v.Ref) && ue.push(fe.toString());
                        H.push(`[${ue.join()}]`);
                      }
                    q.update(H.join());
                  }
                  const E = L.getRaw("CIDToGIDMap") || K.getRaw("CIDToGIDMap");
                  E instanceof v.Name ? q.update(E.name) : E instanceof v.Ref ? q.update(E.toString()) : E instanceof w.BaseStream && q.update(E.peekBytes());
                }
              }
              return {
                descriptor: ne,
                dict: L,
                baseDict: K,
                composite: se,
                type: te.name,
                firstChar: Q,
                lastChar: D,
                toUnicode: N,
                hash: q ? q.hexdigest() : ""
              };
            }
            async translateFont({
              descriptor: L,
              dict: K,
              baseDict: te,
              composite: se,
              type: q,
              firstChar: N,
              lastChar: Q,
              toUnicode: D,
              cssFontInfo: ne
            }) {
              const oe = q === "Type3";
              let ee;
              if (!L)
                if (oe)
                  L = new v.Dict(null), L.set("FontName", v.Name.get(q)), L.set("FontBBox", K.getArray("FontBBox") || [0, 0, 0, 0]);
                else {
                  let Ae = K.get("BaseFont");
                  if (!(Ae instanceof v.Name))
                    throw new t.FormatError("Base font is not specified");
                  Ae = Ae.name.replace(/[,_]/g, "-");
                  const Se = this.getBaseFontMetrics(Ae), ke = Ae.split("-")[0], ye = (this.isSerifFont(ke) ? e.FontFlags.Serif : 0) | (Se.monospace ? e.FontFlags.FixedPitch : 0) | ((0, c.getSymbolsFonts)()[ke] ? e.FontFlags.Symbolic : e.FontFlags.Nonsymbolic);
                  ee = {
                    type: q,
                    name: Ae,
                    loadedName: te.loadedName,
                    widths: Se.widths,
                    defaultWidth: Se.defaultWidth,
                    isSimulatedFlags: !0,
                    flags: ye,
                    firstChar: N,
                    lastChar: Q,
                    toUnicode: D,
                    xHeight: 0,
                    capHeight: 0,
                    italicAngle: 0,
                    isType3Font: oe
                  };
                  const _e = K.get("Widths"), we = (0, c.getStandardFontName)(Ae);
                  let Ce = null;
                  return we && (ee.isStandardFont = !0, Ce = await this.fetchStandardFontData(we), ee.isInternalFont = !!Ce), this.extractDataStructures(K, K, ee).then((ve) => {
                    if (_e) {
                      const Le = [];
                      let He = N;
                      for (let Qe = 0, Ue = _e.length; Qe < Ue; Qe++)
                        Le[He++] = this.xref.fetchIfRef(_e[Qe]);
                      ve.widths = Le;
                    } else
                      ve.widths = this.buildCharCodeToWidth(Se.widths, ve);
                    return new h.Font(Ae, Ce, ve);
                  });
                }
              let $ = L.get("FontName"), E = K.get("BaseFont");
              if (typeof $ == "string" && ($ = v.Name.get($)), typeof E == "string" && (E = v.Name.get(E)), !oe) {
                const Ae = $ && $.name, Se = E && E.name;
                Ae !== Se && ((0, t.info)(`The FontDescriptor's FontName is "${Ae}" but should be the same as the Font's BaseFont "${Se}".`), Ae && Se && Se.startsWith(Ae) && ($ = E));
              }
              if ($ = $ || E, !($ instanceof v.Name))
                throw new t.FormatError("invalid font name");
              let H, ie, ue, fe, de;
              try {
                H = L.get("FontFile", "FontFile2", "FontFile3");
              } catch (Ae) {
                if (!this.options.ignoreErrors)
                  throw Ae;
                (0, t.warn)(`translateFont - fetching "${$.name}" font file: "${Ae}".`), H = new u.NullStream();
              }
              let pe = !1, xe = !1, De = null;
              if (H) {
                if (H.dict) {
                  const Ae = H.dict.get("Subtype");
                  Ae instanceof v.Name && (ie = Ae.name), ue = H.dict.get("Length1"), fe = H.dict.get("Length2"), de = H.dict.get("Length3");
                }
              } else if (ne) {
                const Ae = (0, m.getXfaFontName)($.name);
                Ae && (ne.fontFamily = `${ne.fontFamily}-PdfJS-XFA`, ne.metrics = Ae.metrics || null, De = Ae.factors || null, H = await this.fetchStandardFontData(Ae.name), xe = !!H, te = K = (0, m.getXfaFontDict)($.name), se = !0);
              } else if (!oe) {
                const Ae = (0, c.getStandardFontName)($.name);
                Ae && (pe = !0, H = await this.fetchStandardFontData(Ae), xe = !!H);
              }
              if (ee = {
                type: q,
                name: $.name,
                subtype: ie,
                file: H,
                length1: ue,
                length2: fe,
                length3: de,
                isStandardFont: pe,
                isInternalFont: xe,
                loadedName: te.loadedName,
                composite: se,
                fixedPitch: !1,
                fontMatrix: K.getArray("FontMatrix") || t.FONT_IDENTITY_MATRIX,
                firstChar: N,
                lastChar: Q,
                toUnicode: D,
                bbox: L.getArray("FontBBox") || K.getArray("FontBBox"),
                ascent: L.get("Ascent"),
                descent: L.get("Descent"),
                xHeight: L.get("XHeight") || 0,
                capHeight: L.get("CapHeight") || 0,
                flags: L.get("Flags"),
                italicAngle: L.get("ItalicAngle") || 0,
                isType3Font: oe,
                cssFontInfo: ne,
                scaleFactors: De
              }, se) {
                const Ae = te.get("Encoding");
                Ae instanceof v.Name && (ee.cidEncoding = Ae.name);
                const Se = await a.CMapFactory.create({
                  encoding: Ae,
                  fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                  useCMap: null
                });
                ee.cMap = Se, ee.vertical = ee.cMap.vertical;
              }
              return this.extractDataStructures(K, te, ee).then((Ae) => (this.extractWidths(K, L, Ae), new h.Font($.name, H, Ae)));
            }
            static buildFontPaths(L, K, te, se) {
              function q(N) {
                const Q = `${L.loadedName}_path_${N}`;
                try {
                  if (L.renderer.hasBuiltPath(N))
                    return;
                  te.send("commonobj", [Q, "FontPath", L.renderer.getPathJs(N)]);
                } catch (D) {
                  if (se.ignoreErrors) {
                    te.send("UnsupportedFeature", {
                      featureId: t.UNSUPPORTED_FEATURES.errorFontBuildPath
                    }), (0, t.warn)(`buildFontPaths - ignoring ${Q} glyph: "${D}".`);
                    return;
                  }
                  throw D;
                }
              }
              for (const N of K) {
                q(N.fontChar);
                const Q = N.accent;
                Q && Q.fontChar && q(Q.fontChar);
              }
            }
            static get fallbackFontDict() {
              const L = new v.Dict();
              return L.set("BaseFont", v.Name.get("PDFJS-FallbackFont")), L.set("Type", v.Name.get("FallbackType")), L.set("Subtype", v.Name.get("FallbackType")), L.set("Encoding", v.Name.get("WinAnsiEncoding")), (0, t.shadow)(this, "fallbackFontDict", L);
            }
          }
          o.PartialEvaluator = I;
          class M {
            constructor({
              loadedName: L,
              font: K,
              dict: te,
              evaluatorOptions: se
            }) {
              this.loadedName = L, this.font = K, this.dict = te, this._evaluatorOptions = se || x, this.type3Loaded = null, this.type3Dependencies = K.isType3Font ? /* @__PURE__ */ new Set() : null, this.sent = !1;
            }
            send(L) {
              this.sent || (this.sent = !0, L.send("commonobj", [this.loadedName, "Font", this.font.exportData(this._evaluatorOptions.fontExtraProperties)]));
            }
            fallback(L) {
              this.font.data && (this.font.disableFontFace = !0, I.buildFontPaths(this.font, this.font.glyphCacheValues, L, this._evaluatorOptions));
            }
            loadType3Data(L, K, te) {
              if (this.type3Loaded)
                return this.type3Loaded;
              if (!this.font.isType3Font)
                throw new Error("Must be a Type3 font.");
              const se = L.clone({
                ignoreErrors: !1
              });
              se.parsingType3Font = !0;
              const q = new v.RefSet(L.type3FontRefs);
              this.dict.objId && !q.has(this.dict.objId) && q.put(this.dict.objId), se.type3FontRefs = q;
              const N = this.font, Q = this.type3Dependencies;
              let D = Promise.resolve();
              const ne = this.dict.get("CharProcs"), oe = this.dict.get("Resources") || K, ee = /* @__PURE__ */ Object.create(null), $ = t.Util.normalizeRect(N.bbox || [0, 0, 0, 0]), E = $[2] - $[0], H = $[3] - $[1], ie = Math.hypot(E, H);
              for (const ue of ne.getKeys())
                D = D.then(() => {
                  const fe = ne.get(ue), de = new R.OperatorList();
                  return se.getOperatorList({
                    stream: fe,
                    task: te,
                    resources: oe,
                    operatorList: de
                  }).then(() => {
                    de.fnArray[0] === t.OPS.setCharWidthAndBounds && this._removeType3ColorOperators(de, ie), ee[ue] = de.getIR();
                    for (const pe of de.dependencies)
                      Q.add(pe);
                  }).catch(function(pe) {
                    (0, t.warn)(`Type3 font resource "${ue}" is not available.`);
                    const xe = new R.OperatorList();
                    ee[ue] = xe.getIR();
                  });
                });
              return this.type3Loaded = D.then(() => {
                N.charProcOperatorList = ee, this._bbox && (N.isCharBBox = !0, N.bbox = this._bbox);
              }), this.type3Loaded;
            }
            _removeType3ColorOperators(L, K = NaN) {
              const te = t.Util.normalizeRect(L.argsArray[0].slice(2)), se = te[2] - te[0], q = te[3] - te[1], N = Math.hypot(se, q);
              se === 0 || q === 0 ? (L.fnArray.splice(0, 1), L.argsArray.splice(0, 1)) : (K === 0 || Math.round(N / K) >= 10) && (this._bbox || (this._bbox = [1 / 0, 1 / 0, -1 / 0, -1 / 0]), this._bbox[0] = Math.min(this._bbox[0], te[0]), this._bbox[1] = Math.min(this._bbox[1], te[1]), this._bbox[2] = Math.max(this._bbox[2], te[2]), this._bbox[3] = Math.max(this._bbox[3], te[3]));
              let Q = 0, D = L.length;
              for (; Q < D; ) {
                switch (L.fnArray[Q]) {
                  case t.OPS.setCharWidthAndBounds:
                    break;
                  case t.OPS.setStrokeColorSpace:
                  case t.OPS.setFillColorSpace:
                  case t.OPS.setStrokeColor:
                  case t.OPS.setStrokeColorN:
                  case t.OPS.setFillColor:
                  case t.OPS.setFillColorN:
                  case t.OPS.setStrokeGray:
                  case t.OPS.setFillGray:
                  case t.OPS.setStrokeRGBColor:
                  case t.OPS.setFillRGBColor:
                  case t.OPS.setStrokeCMYKColor:
                  case t.OPS.setFillCMYKColor:
                  case t.OPS.shadingFill:
                  case t.OPS.setRenderingIntent:
                    L.fnArray.splice(Q, 1), L.argsArray.splice(Q, 1), D--;
                    continue;
                  case t.OPS.setGState:
                    const [ne] = L.argsArray[Q];
                    let oe = 0, ee = ne.length;
                    for (; oe < ee; ) {
                      const [$] = ne[oe];
                      switch ($) {
                        case "TR":
                        case "TR2":
                        case "HT":
                        case "BG":
                        case "BG2":
                        case "UCR":
                        case "UCR2":
                          ne.splice(oe, 1), ee--;
                          continue;
                      }
                      oe++;
                    }
                    break;
                }
                Q++;
              }
            }
          }
          class V {
            constructor(L = new W()) {
              this.state = L, this.stateStack = [];
            }
            save() {
              const L = this.state;
              this.stateStack.push(this.state), this.state = L.clone();
            }
            restore() {
              const L = this.stateStack.pop();
              L && (this.state = L);
            }
            transform(L) {
              this.state.ctm = t.Util.transform(this.state.ctm, L);
            }
          }
          class J {
            constructor() {
              this.ctm = new Float32Array(t.IDENTITY_MATRIX), this.fontName = null, this.fontSize = 0, this.font = null, this.fontMatrix = t.FONT_IDENTITY_MATRIX, this.textMatrix = t.IDENTITY_MATRIX.slice(), this.textLineMatrix = t.IDENTITY_MATRIX.slice(), this.charSpacing = 0, this.wordSpacing = 0, this.leading = 0, this.textHScale = 1, this.textRise = 0;
            }
            setTextMatrix(L, K, te, se, q, N) {
              const Q = this.textMatrix;
              Q[0] = L, Q[1] = K, Q[2] = te, Q[3] = se, Q[4] = q, Q[5] = N;
            }
            setTextLineMatrix(L, K, te, se, q, N) {
              const Q = this.textLineMatrix;
              Q[0] = L, Q[1] = K, Q[2] = te, Q[3] = se, Q[4] = q, Q[5] = N;
            }
            translateTextMatrix(L, K) {
              const te = this.textMatrix;
              te[4] = te[0] * L + te[2] * K + te[4], te[5] = te[1] * L + te[3] * K + te[5];
            }
            translateTextLineMatrix(L, K) {
              const te = this.textLineMatrix;
              te[4] = te[0] * L + te[2] * K + te[4], te[5] = te[1] * L + te[3] * K + te[5];
            }
            carriageReturn() {
              this.translateTextLineMatrix(0, -this.leading), this.textMatrix = this.textLineMatrix.slice();
            }
            clone() {
              const L = Object.create(this);
              return L.textMatrix = this.textMatrix.slice(), L.textLineMatrix = this.textLineMatrix.slice(), L.fontMatrix = this.fontMatrix.slice(), L;
            }
          }
          class W {
            constructor() {
              this.ctm = new Float32Array(t.IDENTITY_MATRIX), this.font = null, this.textRenderingMode = t.TextRenderingMode.FILL, this.fillColorSpace = b.ColorSpace.singletons.gray, this.strokeColorSpace = b.ColorSpace.singletons.gray;
            }
            clone() {
              return Object.create(this);
            }
          }
          class z {
            static get opMap() {
              const L = (0, j.getLookupTableFactory)(function(K) {
                K.w = {
                  id: t.OPS.setLineWidth,
                  numArgs: 1,
                  variableArgs: !1
                }, K.J = {
                  id: t.OPS.setLineCap,
                  numArgs: 1,
                  variableArgs: !1
                }, K.j = {
                  id: t.OPS.setLineJoin,
                  numArgs: 1,
                  variableArgs: !1
                }, K.M = {
                  id: t.OPS.setMiterLimit,
                  numArgs: 1,
                  variableArgs: !1
                }, K.d = {
                  id: t.OPS.setDash,
                  numArgs: 2,
                  variableArgs: !1
                }, K.ri = {
                  id: t.OPS.setRenderingIntent,
                  numArgs: 1,
                  variableArgs: !1
                }, K.i = {
                  id: t.OPS.setFlatness,
                  numArgs: 1,
                  variableArgs: !1
                }, K.gs = {
                  id: t.OPS.setGState,
                  numArgs: 1,
                  variableArgs: !1
                }, K.q = {
                  id: t.OPS.save,
                  numArgs: 0,
                  variableArgs: !1
                }, K.Q = {
                  id: t.OPS.restore,
                  numArgs: 0,
                  variableArgs: !1
                }, K.cm = {
                  id: t.OPS.transform,
                  numArgs: 6,
                  variableArgs: !1
                }, K.m = {
                  id: t.OPS.moveTo,
                  numArgs: 2,
                  variableArgs: !1
                }, K.l = {
                  id: t.OPS.lineTo,
                  numArgs: 2,
                  variableArgs: !1
                }, K.c = {
                  id: t.OPS.curveTo,
                  numArgs: 6,
                  variableArgs: !1
                }, K.v = {
                  id: t.OPS.curveTo2,
                  numArgs: 4,
                  variableArgs: !1
                }, K.y = {
                  id: t.OPS.curveTo3,
                  numArgs: 4,
                  variableArgs: !1
                }, K.h = {
                  id: t.OPS.closePath,
                  numArgs: 0,
                  variableArgs: !1
                }, K.re = {
                  id: t.OPS.rectangle,
                  numArgs: 4,
                  variableArgs: !1
                }, K.S = {
                  id: t.OPS.stroke,
                  numArgs: 0,
                  variableArgs: !1
                }, K.s = {
                  id: t.OPS.closeStroke,
                  numArgs: 0,
                  variableArgs: !1
                }, K.f = {
                  id: t.OPS.fill,
                  numArgs: 0,
                  variableArgs: !1
                }, K.F = {
                  id: t.OPS.fill,
                  numArgs: 0,
                  variableArgs: !1
                }, K["f*"] = {
                  id: t.OPS.eoFill,
                  numArgs: 0,
                  variableArgs: !1
                }, K.B = {
                  id: t.OPS.fillStroke,
                  numArgs: 0,
                  variableArgs: !1
                }, K["B*"] = {
                  id: t.OPS.eoFillStroke,
                  numArgs: 0,
                  variableArgs: !1
                }, K.b = {
                  id: t.OPS.closeFillStroke,
                  numArgs: 0,
                  variableArgs: !1
                }, K["b*"] = {
                  id: t.OPS.closeEOFillStroke,
                  numArgs: 0,
                  variableArgs: !1
                }, K.n = {
                  id: t.OPS.endPath,
                  numArgs: 0,
                  variableArgs: !1
                }, K.W = {
                  id: t.OPS.clip,
                  numArgs: 0,
                  variableArgs: !1
                }, K["W*"] = {
                  id: t.OPS.eoClip,
                  numArgs: 0,
                  variableArgs: !1
                }, K.BT = {
                  id: t.OPS.beginText,
                  numArgs: 0,
                  variableArgs: !1
                }, K.ET = {
                  id: t.OPS.endText,
                  numArgs: 0,
                  variableArgs: !1
                }, K.Tc = {
                  id: t.OPS.setCharSpacing,
                  numArgs: 1,
                  variableArgs: !1
                }, K.Tw = {
                  id: t.OPS.setWordSpacing,
                  numArgs: 1,
                  variableArgs: !1
                }, K.Tz = {
                  id: t.OPS.setHScale,
                  numArgs: 1,
                  variableArgs: !1
                }, K.TL = {
                  id: t.OPS.setLeading,
                  numArgs: 1,
                  variableArgs: !1
                }, K.Tf = {
                  id: t.OPS.setFont,
                  numArgs: 2,
                  variableArgs: !1
                }, K.Tr = {
                  id: t.OPS.setTextRenderingMode,
                  numArgs: 1,
                  variableArgs: !1
                }, K.Ts = {
                  id: t.OPS.setTextRise,
                  numArgs: 1,
                  variableArgs: !1
                }, K.Td = {
                  id: t.OPS.moveText,
                  numArgs: 2,
                  variableArgs: !1
                }, K.TD = {
                  id: t.OPS.setLeadingMoveText,
                  numArgs: 2,
                  variableArgs: !1
                }, K.Tm = {
                  id: t.OPS.setTextMatrix,
                  numArgs: 6,
                  variableArgs: !1
                }, K["T*"] = {
                  id: t.OPS.nextLine,
                  numArgs: 0,
                  variableArgs: !1
                }, K.Tj = {
                  id: t.OPS.showText,
                  numArgs: 1,
                  variableArgs: !1
                }, K.TJ = {
                  id: t.OPS.showSpacedText,
                  numArgs: 1,
                  variableArgs: !1
                }, K["'"] = {
                  id: t.OPS.nextLineShowText,
                  numArgs: 1,
                  variableArgs: !1
                }, K['"'] = {
                  id: t.OPS.nextLineSetSpacingShowText,
                  numArgs: 3,
                  variableArgs: !1
                }, K.d0 = {
                  id: t.OPS.setCharWidth,
                  numArgs: 2,
                  variableArgs: !1
                }, K.d1 = {
                  id: t.OPS.setCharWidthAndBounds,
                  numArgs: 6,
                  variableArgs: !1
                }, K.CS = {
                  id: t.OPS.setStrokeColorSpace,
                  numArgs: 1,
                  variableArgs: !1
                }, K.cs = {
                  id: t.OPS.setFillColorSpace,
                  numArgs: 1,
                  variableArgs: !1
                }, K.SC = {
                  id: t.OPS.setStrokeColor,
                  numArgs: 4,
                  variableArgs: !0
                }, K.SCN = {
                  id: t.OPS.setStrokeColorN,
                  numArgs: 33,
                  variableArgs: !0
                }, K.sc = {
                  id: t.OPS.setFillColor,
                  numArgs: 4,
                  variableArgs: !0
                }, K.scn = {
                  id: t.OPS.setFillColorN,
                  numArgs: 33,
                  variableArgs: !0
                }, K.G = {
                  id: t.OPS.setStrokeGray,
                  numArgs: 1,
                  variableArgs: !1
                }, K.g = {
                  id: t.OPS.setFillGray,
                  numArgs: 1,
                  variableArgs: !1
                }, K.RG = {
                  id: t.OPS.setStrokeRGBColor,
                  numArgs: 3,
                  variableArgs: !1
                }, K.rg = {
                  id: t.OPS.setFillRGBColor,
                  numArgs: 3,
                  variableArgs: !1
                }, K.K = {
                  id: t.OPS.setStrokeCMYKColor,
                  numArgs: 4,
                  variableArgs: !1
                }, K.k = {
                  id: t.OPS.setFillCMYKColor,
                  numArgs: 4,
                  variableArgs: !1
                }, K.sh = {
                  id: t.OPS.shadingFill,
                  numArgs: 1,
                  variableArgs: !1
                }, K.BI = {
                  id: t.OPS.beginInlineImage,
                  numArgs: 0,
                  variableArgs: !1
                }, K.ID = {
                  id: t.OPS.beginImageData,
                  numArgs: 0,
                  variableArgs: !1
                }, K.EI = {
                  id: t.OPS.endInlineImage,
                  numArgs: 1,
                  variableArgs: !1
                }, K.Do = {
                  id: t.OPS.paintXObject,
                  numArgs: 1,
                  variableArgs: !1
                }, K.MP = {
                  id: t.OPS.markPoint,
                  numArgs: 1,
                  variableArgs: !1
                }, K.DP = {
                  id: t.OPS.markPointProps,
                  numArgs: 2,
                  variableArgs: !1
                }, K.BMC = {
                  id: t.OPS.beginMarkedContent,
                  numArgs: 1,
                  variableArgs: !1
                }, K.BDC = {
                  id: t.OPS.beginMarkedContentProps,
                  numArgs: 2,
                  variableArgs: !1
                }, K.EMC = {
                  id: t.OPS.endMarkedContent,
                  numArgs: 0,
                  variableArgs: !1
                }, K.BX = {
                  id: t.OPS.beginCompat,
                  numArgs: 0,
                  variableArgs: !1
                }, K.EX = {
                  id: t.OPS.endCompat,
                  numArgs: 0,
                  variableArgs: !1
                }, K.BM = null, K.BD = null, K.true = null, K.fa = null, K.fal = null, K.fals = null, K.false = null, K.nu = null, K.nul = null, K.null = null;
              });
              return (0, t.shadow)(this, "opMap", L());
            }
            static get MAX_INVALID_PATH_OPS() {
              return (0, t.shadow)(this, "MAX_INVALID_PATH_OPS", 10);
            }
            constructor(L, K, te = new V()) {
              this.parser = new i.Parser({
                lexer: new i.Lexer(L, z.opMap),
                xref: K
              }), this.stateManager = te, this.nonProcessedArgs = [], this._isPathOp = !1, this._numInvalidPathOPS = 0;
            }
            get savedStatesDepth() {
              return this.stateManager.stateStack.length;
            }
            read(L) {
              let K = L.args;
              for (; ; ) {
                const te = this.parser.getObj();
                if (te instanceof v.Cmd) {
                  const se = te.cmd, q = z.opMap[se];
                  if (!q) {
                    (0, t.warn)(`Unknown command "${se}".`);
                    continue;
                  }
                  const N = q.id, Q = q.numArgs;
                  let D = K !== null ? K.length : 0;
                  if (this._isPathOp || (this._numInvalidPathOPS = 0), this._isPathOp = N >= t.OPS.moveTo && N <= t.OPS.endPath, q.variableArgs)
                    D > Q && (0, t.info)(`Command ${se}: expected [0, ${Q}] args, but received ${D} args.`);
                  else {
                    if (D !== Q) {
                      const ne = this.nonProcessedArgs;
                      for (; D > Q; )
                        ne.push(K.shift()), D--;
                      for (; D < Q && ne.length !== 0; )
                        K === null && (K = []), K.unshift(ne.pop()), D++;
                    }
                    if (D < Q) {
                      const ne = `command ${se}: expected ${Q} args, but received ${D} args.`;
                      if (this._isPathOp && ++this._numInvalidPathOPS > z.MAX_INVALID_PATH_OPS)
                        throw new t.FormatError(`Invalid ${ne}`);
                      (0, t.warn)(`Skipping ${ne}`), K !== null && (K.length = 0);
                      continue;
                    }
                  }
                  return this.preprocessCommand(N, K), L.fn = N, L.args = K, !0;
                }
                if (te === v.EOF)
                  return !1;
                if (te !== null && (K === null && (K = []), K.push(te), K.length > 33))
                  throw new t.FormatError("Too many arguments");
              }
            }
            preprocessCommand(L, K) {
              switch (L | 0) {
                case t.OPS.save:
                  this.stateManager.save();
                  break;
                case t.OPS.restore:
                  this.stateManager.restore();
                  break;
                case t.OPS.transform:
                  this.stateManager.transform(K);
                  break;
              }
            }
          }
          o.EvaluatorPreprocessor = z;
        },
        /* 16 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.IdentityCMap = o.CMapFactory = o.CMap = void 0;
          var t = C(2), a = C(5), v = C(7), h = C(17), e = C(6), y = C(10);
          const c = ["Adobe-GB1-UCS2", "Adobe-CNS1-UCS2", "Adobe-Japan1-UCS2", "Adobe-Korea1-UCS2", "78-EUC-H", "78-EUC-V", "78-H", "78-RKSJ-H", "78-RKSJ-V", "78-V", "78ms-RKSJ-H", "78ms-RKSJ-V", "83pv-RKSJ-H", "90ms-RKSJ-H", "90ms-RKSJ-V", "90msp-RKSJ-H", "90msp-RKSJ-V", "90pv-RKSJ-H", "90pv-RKSJ-V", "Add-H", "Add-RKSJ-H", "Add-RKSJ-V", "Add-V", "Adobe-CNS1-0", "Adobe-CNS1-1", "Adobe-CNS1-2", "Adobe-CNS1-3", "Adobe-CNS1-4", "Adobe-CNS1-5", "Adobe-CNS1-6", "Adobe-GB1-0", "Adobe-GB1-1", "Adobe-GB1-2", "Adobe-GB1-3", "Adobe-GB1-4", "Adobe-GB1-5", "Adobe-Japan1-0", "Adobe-Japan1-1", "Adobe-Japan1-2", "Adobe-Japan1-3", "Adobe-Japan1-4", "Adobe-Japan1-5", "Adobe-Japan1-6", "Adobe-Korea1-0", "Adobe-Korea1-1", "Adobe-Korea1-2", "B5-H", "B5-V", "B5pc-H", "B5pc-V", "CNS-EUC-H", "CNS-EUC-V", "CNS1-H", "CNS1-V", "CNS2-H", "CNS2-V", "ETHK-B5-H", "ETHK-B5-V", "ETen-B5-H", "ETen-B5-V", "ETenms-B5-H", "ETenms-B5-V", "EUC-H", "EUC-V", "Ext-H", "Ext-RKSJ-H", "Ext-RKSJ-V", "Ext-V", "GB-EUC-H", "GB-EUC-V", "GB-H", "GB-V", "GBK-EUC-H", "GBK-EUC-V", "GBK2K-H", "GBK2K-V", "GBKp-EUC-H", "GBKp-EUC-V", "GBT-EUC-H", "GBT-EUC-V", "GBT-H", "GBT-V", "GBTpc-EUC-H", "GBTpc-EUC-V", "GBpc-EUC-H", "GBpc-EUC-V", "H", "HKdla-B5-H", "HKdla-B5-V", "HKdlb-B5-H", "HKdlb-B5-V", "HKgccs-B5-H", "HKgccs-B5-V", "HKm314-B5-H", "HKm314-B5-V", "HKm471-B5-H", "HKm471-B5-V", "HKscs-B5-H", "HKscs-B5-V", "Hankaku", "Hiragana", "KSC-EUC-H", "KSC-EUC-V", "KSC-H", "KSC-Johab-H", "KSC-Johab-V", "KSC-V", "KSCms-UHC-H", "KSCms-UHC-HW-H", "KSCms-UHC-HW-V", "KSCms-UHC-V", "KSCpc-EUC-H", "KSCpc-EUC-V", "Katakana", "NWP-H", "NWP-V", "RKSJ-H", "RKSJ-V", "Roman", "UniCNS-UCS2-H", "UniCNS-UCS2-V", "UniCNS-UTF16-H", "UniCNS-UTF16-V", "UniCNS-UTF32-H", "UniCNS-UTF32-V", "UniCNS-UTF8-H", "UniCNS-UTF8-V", "UniGB-UCS2-H", "UniGB-UCS2-V", "UniGB-UTF16-H", "UniGB-UTF16-V", "UniGB-UTF32-H", "UniGB-UTF32-V", "UniGB-UTF8-H", "UniGB-UTF8-V", "UniJIS-UCS2-H", "UniJIS-UCS2-HW-H", "UniJIS-UCS2-HW-V", "UniJIS-UCS2-V", "UniJIS-UTF16-H", "UniJIS-UTF16-V", "UniJIS-UTF32-H", "UniJIS-UTF32-V", "UniJIS-UTF8-H", "UniJIS-UTF8-V", "UniJIS2004-UTF16-H", "UniJIS2004-UTF16-V", "UniJIS2004-UTF32-H", "UniJIS2004-UTF32-V", "UniJIS2004-UTF8-H", "UniJIS2004-UTF8-V", "UniJISPro-UCS2-HW-V", "UniJISPro-UCS2-V", "UniJISPro-UTF8-V", "UniJISX0213-UTF32-H", "UniJISX0213-UTF32-V", "UniJISX02132004-UTF32-H", "UniJISX02132004-UTF32-V", "UniKS-UCS2-H", "UniKS-UCS2-V", "UniKS-UTF16-H", "UniKS-UTF16-V", "UniKS-UTF32-H", "UniKS-UTF32-V", "UniKS-UTF8-H", "UniKS-UTF8-V", "V", "WP-Symbol"], d = 2 ** 24 - 1;
          class p {
            constructor(l = !1) {
              this.codespaceRanges = [[], [], [], []], this.numCodespaceRanges = 0, this._map = [], this.name = "", this.vertical = !1, this.useCMap = null, this.builtInCMap = l;
            }
            addCodespaceRange(l, u, w) {
              this.codespaceRanges[l - 1].push(u, w), this.numCodespaceRanges++;
            }
            mapCidRange(l, u, w) {
              if (u - l > d)
                throw new Error("mapCidRange - ignoring data above MAX_MAP_RANGE.");
              for (; l <= u; )
                this._map[l++] = w++;
            }
            mapBfRange(l, u, w) {
              if (u - l > d)
                throw new Error("mapBfRange - ignoring data above MAX_MAP_RANGE.");
              const _ = w.length - 1;
              for (; l <= u; ) {
                this._map[l++] = w;
                const b = w.charCodeAt(_) + 1;
                if (b > 255) {
                  w = w.substring(0, _ - 1) + String.fromCharCode(w.charCodeAt(_ - 1) + 1) + "\0";
                  continue;
                }
                w = w.substring(0, _) + String.fromCharCode(b);
              }
            }
            mapBfRangeToArray(l, u, w) {
              if (u - l > d)
                throw new Error("mapBfRangeToArray - ignoring data above MAX_MAP_RANGE.");
              const _ = w.length;
              let b = 0;
              for (; l <= u && b < _; )
                this._map[l] = w[b++], ++l;
            }
            mapOne(l, u) {
              this._map[l] = u;
            }
            lookup(l) {
              return this._map[l];
            }
            contains(l) {
              return this._map[l] !== void 0;
            }
            forEach(l) {
              const u = this._map, w = u.length;
              if (w <= 65536)
                for (let _ = 0; _ < w; _++)
                  u[_] !== void 0 && l(_, u[_]);
              else
                for (const _ in u)
                  l(_, u[_]);
            }
            charCodeOf(l) {
              const u = this._map;
              if (u.length <= 65536)
                return u.indexOf(l);
              for (const w in u)
                if (u[w] === l)
                  return w | 0;
              return -1;
            }
            getMap() {
              return this._map;
            }
            readCharCode(l, u, w) {
              let _ = 0;
              const b = this.codespaceRanges;
              for (let A = 0, Y = b.length; A < Y; A++) {
                _ = (_ << 8 | l.charCodeAt(u + A)) >>> 0;
                const j = b[A];
                for (let X = 0, B = j.length; X < B; ) {
                  const R = j[X++], k = j[X++];
                  if (_ >= R && _ <= k) {
                    w.charcode = _, w.length = A + 1;
                    return;
                  }
                }
              }
              w.charcode = 0, w.length = 1;
            }
            getCharCodeLength(l) {
              const u = this.codespaceRanges;
              for (let w = 0, _ = u.length; w < _; w++) {
                const b = u[w];
                for (let A = 0, Y = b.length; A < Y; ) {
                  const j = b[A++], X = b[A++];
                  if (l >= j && l <= X)
                    return w + 1;
                }
              }
              return 1;
            }
            get length() {
              return this._map.length;
            }
            get isIdentityCMap() {
              if (!(this.name === "Identity-H" || this.name === "Identity-V") || this._map.length !== 65536)
                return !1;
              for (let l = 0; l < 65536; l++)
                if (this._map[l] !== l)
                  return !1;
              return !0;
            }
          }
          o.CMap = p;
          class m extends p {
            constructor(l, u) {
              super(), this.vertical = l, this.addCodespaceRange(u, 0, 65535);
            }
            mapCidRange(l, u, w) {
              (0, t.unreachable)("should not call mapCidRange");
            }
            mapBfRange(l, u, w) {
              (0, t.unreachable)("should not call mapBfRange");
            }
            mapBfRangeToArray(l, u, w) {
              (0, t.unreachable)("should not call mapBfRangeToArray");
            }
            mapOne(l, u) {
              (0, t.unreachable)("should not call mapCidOne");
            }
            lookup(l) {
              return Number.isInteger(l) && l <= 65535 ? l : void 0;
            }
            contains(l) {
              return Number.isInteger(l) && l <= 65535;
            }
            forEach(l) {
              for (let u = 0; u <= 65535; u++)
                l(u, u);
            }
            charCodeOf(l) {
              return Number.isInteger(l) && l <= 65535 ? l : -1;
            }
            getMap() {
              const l = new Array(65536);
              for (let u = 0; u <= 65535; u++)
                l[u] = u;
              return l;
            }
            get length() {
              return 65536;
            }
            get isIdentityCMap() {
              (0, t.unreachable)("should not access .isIdentityCMap");
            }
          }
          o.IdentityCMap = m;
          const g = function() {
            function l(X, B) {
              let R = 0;
              for (let k = 0; k <= B; k++)
                R = R << 8 | X[k];
              return R >>> 0;
            }
            function u(X, B) {
              return B === 1 ? String.fromCharCode(X[0], X[1]) : B === 3 ? String.fromCharCode(X[0], X[1], X[2], X[3]) : String.fromCharCode.apply(null, X.subarray(0, B + 1));
            }
            function w(X, B, R) {
              let k = 0;
              for (let x = R; x >= 0; x--)
                k += X[x] + B[x], X[x] = k & 255, k >>= 8;
            }
            function _(X, B) {
              let R = 1;
              for (let k = B; k >= 0 && R > 0; k--)
                R += X[k], X[k] = R & 255, R >>= 8;
            }
            const b = 16, A = 19;
            class Y {
              constructor(B) {
                this.buffer = B, this.pos = 0, this.end = B.length, this.tmpBuf = new Uint8Array(A);
              }
              readByte() {
                return this.pos >= this.end ? -1 : this.buffer[this.pos++];
              }
              readNumber() {
                let B = 0, R;
                do {
                  const k = this.readByte();
                  if (k < 0)
                    throw new t.FormatError("unexpected EOF in bcmap");
                  R = !(k & 128), B = B << 7 | k & 127;
                } while (!R);
                return B;
              }
              readSigned() {
                const B = this.readNumber();
                return B & 1 ? ~(B >>> 1) : B >>> 1;
              }
              readHex(B, R) {
                B.set(this.buffer.subarray(this.pos, this.pos + R + 1)), this.pos += R + 1;
              }
              readHexNumber(B, R) {
                let k;
                const x = this.tmpBuf;
                let f = 0;
                do {
                  const F = this.readByte();
                  if (F < 0)
                    throw new t.FormatError("unexpected EOF in bcmap");
                  k = !(F & 128), x[f++] = F & 127;
                } while (!k);
                let U = R, O = 0, S = 0;
                for (; U >= 0; ) {
                  for (; S < 8 && x.length > 0; )
                    O |= x[--f] << S, S += 7;
                  B[U] = O & 255, U--, O >>= 8, S -= 8;
                }
              }
              readHexSigned(B, R) {
                this.readHexNumber(B, R);
                const k = B[R] & 1 ? 255 : 0;
                let x = 0;
                for (let f = 0; f <= R; f++)
                  x = (x & 1) << 8 | B[f], B[f] = x >> 1 ^ k;
              }
              readString() {
                const B = this.readNumber();
                let R = "";
                for (let k = 0; k < B; k++)
                  R += String.fromCharCode(this.readNumber());
                return R;
              }
            }
            class j {
              async process(B, R, k) {
                const x = new Y(B), f = x.readByte();
                R.vertical = !!(f & 1);
                let U = null;
                const O = new Uint8Array(b), S = new Uint8Array(b), F = new Uint8Array(b), T = new Uint8Array(b), I = new Uint8Array(b);
                let M, V;
                for (; (V = x.readByte()) >= 0; ) {
                  const J = V >> 5;
                  if (J === 7) {
                    switch (V & 31) {
                      case 0:
                        x.readString();
                        break;
                      case 1:
                        U = x.readString();
                        break;
                    }
                    continue;
                  }
                  const W = !!(V & 16), z = V & 15;
                  if (z + 1 > b)
                    throw new Error("BinaryCMapReader.process: Invalid dataSize.");
                  const G = 1, L = x.readNumber();
                  switch (J) {
                    case 0:
                      x.readHex(O, z), x.readHexNumber(S, z), w(S, O, z), R.addCodespaceRange(z + 1, l(O, z), l(S, z));
                      for (let K = 1; K < L; K++)
                        _(S, z), x.readHexNumber(O, z), w(O, S, z), x.readHexNumber(S, z), w(S, O, z), R.addCodespaceRange(z + 1, l(O, z), l(S, z));
                      break;
                    case 1:
                      x.readHex(O, z), x.readHexNumber(S, z), w(S, O, z), x.readNumber();
                      for (let K = 1; K < L; K++)
                        _(S, z), x.readHexNumber(O, z), w(O, S, z), x.readHexNumber(S, z), w(S, O, z), x.readNumber();
                      break;
                    case 2:
                      x.readHex(F, z), M = x.readNumber(), R.mapOne(l(F, z), M);
                      for (let K = 1; K < L; K++)
                        _(F, z), W || (x.readHexNumber(I, z), w(F, I, z)), M = x.readSigned() + (M + 1), R.mapOne(l(F, z), M);
                      break;
                    case 3:
                      x.readHex(O, z), x.readHexNumber(S, z), w(S, O, z), M = x.readNumber(), R.mapCidRange(l(O, z), l(S, z), M);
                      for (let K = 1; K < L; K++)
                        _(S, z), W ? O.set(S) : (x.readHexNumber(O, z), w(O, S, z)), x.readHexNumber(S, z), w(S, O, z), M = x.readNumber(), R.mapCidRange(l(O, z), l(S, z), M);
                      break;
                    case 4:
                      x.readHex(F, G), x.readHex(T, z), R.mapOne(l(F, G), u(T, z));
                      for (let K = 1; K < L; K++)
                        _(F, G), W || (x.readHexNumber(I, G), w(F, I, G)), _(T, z), x.readHexSigned(I, z), w(T, I, z), R.mapOne(l(F, G), u(T, z));
                      break;
                    case 5:
                      x.readHex(O, G), x.readHexNumber(S, G), w(S, O, G), x.readHex(T, z), R.mapBfRange(l(O, G), l(S, G), u(T, z));
                      for (let K = 1; K < L; K++)
                        _(S, G), W ? O.set(S) : (x.readHexNumber(O, G), w(O, S, G)), x.readHexNumber(S, G), w(S, O, G), x.readHex(T, z), R.mapBfRange(l(O, G), l(S, G), u(T, z));
                      break;
                    default:
                      throw new Error(`BinaryCMapReader.process - unknown type: ${J}`);
                  }
                }
                return U ? k(U) : R;
              }
            }
            return j;
          }(), n = function() {
            function l(f) {
              let U = 0;
              for (let O = 0; O < f.length; O++)
                U = U << 8 | f.charCodeAt(O);
              return U >>> 0;
            }
            function u(f) {
              if (typeof f != "string")
                throw new t.FormatError("Malformed CMap: expected string.");
            }
            function w(f) {
              if (!Number.isInteger(f))
                throw new t.FormatError("Malformed CMap: expected int.");
            }
            function _(f, U) {
              for (; ; ) {
                let O = U.getObj();
                if (O === a.EOF)
                  break;
                if ((0, a.isCmd)(O, "endbfchar"))
                  return;
                u(O);
                const S = l(O);
                O = U.getObj(), u(O);
                const F = O;
                f.mapOne(S, F);
              }
            }
            function b(f, U) {
              for (; ; ) {
                let O = U.getObj();
                if (O === a.EOF)
                  break;
                if ((0, a.isCmd)(O, "endbfrange"))
                  return;
                u(O);
                const S = l(O);
                O = U.getObj(), u(O);
                const F = l(O);
                if (O = U.getObj(), Number.isInteger(O) || typeof O == "string") {
                  const T = Number.isInteger(O) ? String.fromCharCode(O) : O;
                  f.mapBfRange(S, F, T);
                } else if ((0, a.isCmd)(O, "[")) {
                  O = U.getObj();
                  const T = [];
                  for (; !(0, a.isCmd)(O, "]") && O !== a.EOF; )
                    T.push(O), O = U.getObj();
                  f.mapBfRangeToArray(S, F, T);
                } else
                  break;
              }
              throw new t.FormatError("Invalid bf range.");
            }
            function A(f, U) {
              for (; ; ) {
                let O = U.getObj();
                if (O === a.EOF)
                  break;
                if ((0, a.isCmd)(O, "endcidchar"))
                  return;
                u(O);
                const S = l(O);
                O = U.getObj(), w(O);
                const F = O;
                f.mapOne(S, F);
              }
            }
            function Y(f, U) {
              for (; ; ) {
                let O = U.getObj();
                if (O === a.EOF)
                  break;
                if ((0, a.isCmd)(O, "endcidrange"))
                  return;
                u(O);
                const S = l(O);
                O = U.getObj(), u(O);
                const F = l(O);
                O = U.getObj(), w(O);
                const T = O;
                f.mapCidRange(S, F, T);
              }
            }
            function j(f, U) {
              for (; ; ) {
                let O = U.getObj();
                if (O === a.EOF)
                  break;
                if ((0, a.isCmd)(O, "endcodespacerange"))
                  return;
                if (typeof O != "string")
                  break;
                const S = l(O);
                if (O = U.getObj(), typeof O != "string")
                  break;
                const F = l(O);
                f.addCodespaceRange(O.length, S, F);
              }
              throw new t.FormatError("Invalid codespace range.");
            }
            function X(f, U) {
              const O = U.getObj();
              Number.isInteger(O) && (f.vertical = !!O);
            }
            function B(f, U) {
              const O = U.getObj();
              O instanceof a.Name && (f.name = O.name);
            }
            async function R(f, U, O, S) {
              let F, T;
              e:
                for (; ; )
                  try {
                    const I = U.getObj();
                    if (I === a.EOF)
                      break;
                    if (I instanceof a.Name)
                      I.name === "WMode" ? X(f, U) : I.name === "CMapName" && B(f, U), F = I;
                    else if (I instanceof a.Cmd)
                      switch (I.cmd) {
                        case "endcmap":
                          break e;
                        case "usecmap":
                          F instanceof a.Name && (T = F.name);
                          break;
                        case "begincodespacerange":
                          j(f, U);
                          break;
                        case "beginbfchar":
                          _(f, U);
                          break;
                        case "begincidchar":
                          A(f, U);
                          break;
                        case "beginbfrange":
                          b(f, U);
                          break;
                        case "begincidrange":
                          Y(f, U);
                          break;
                      }
                  } catch (I) {
                    if (I instanceof e.MissingDataException)
                      throw I;
                    (0, t.warn)("Invalid cMap data: " + I);
                    continue;
                  }
              return !S && T && (S = T), S ? k(f, O, S) : f;
            }
            async function k(f, U, O) {
              if (f.useCMap = await x(O, U), f.numCodespaceRanges === 0) {
                const S = f.useCMap.codespaceRanges;
                for (let F = 0; F < S.length; F++)
                  f.codespaceRanges[F] = S[F].slice();
                f.numCodespaceRanges = f.useCMap.numCodespaceRanges;
              }
              return f.useCMap.forEach(function(S, F) {
                f.contains(S) || f.mapOne(S, f.useCMap.lookup(S));
              }), f;
            }
            async function x(f, U) {
              if (f === "Identity-H")
                return new m(!1, 2);
              if (f === "Identity-V")
                return new m(!0, 2);
              if (!c.includes(f))
                throw new Error("Unknown CMap name: " + f);
              if (!U)
                throw new Error("Built-in CMap parameters are not provided.");
              const {
                cMapData: O,
                compressionType: S
              } = await U(f), F = new p(!0);
              if (S === t.CMapCompressionType.BINARY)
                return new g().process(O, F, (T) => k(F, U, T));
              if (S === t.CMapCompressionType.NONE) {
                const T = new h.Lexer(new y.Stream(O));
                return R(F, T, U, null);
              }
              throw new Error("TODO: Only BINARY/NONE CMap compression is currently supported.");
            }
            return {
              async create(f) {
                const U = f.encoding, O = f.fetchBuiltInCMap, S = f.useCMap;
                if (U instanceof a.Name)
                  return x(U.name, O);
                if (U instanceof v.BaseStream) {
                  const F = await R(new p(), new h.Lexer(U), O, S);
                  return F.isIdentityCMap ? x(F.name, O) : F;
                }
                throw new Error("Encoding required.");
              }
            };
          }();
          o.CMapFactory = n;
        },
        /* 17 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.Parser = o.Linearization = o.Lexer = void 0;
          var t = C(2), a = C(5), v = C(6), h = C(18), e = C(20), y = C(21), c = C(23), d = C(24), p = C(27), m = C(29), g = C(31), n = C(10), i = C(32), l = C(33);
          const u = 1e3, w = 5552;
          function _(B) {
            const R = B.length;
            let k = 1, x = 0;
            for (let f = 0; f < R; ++f)
              k += B[f] & 255, x += k;
            return x % 65521 << 16 | k % 65521;
          }
          class b {
            constructor({
              lexer: R,
              xref: k,
              allowStreams: x = !1,
              recoveryMode: f = !1
            }) {
              this.lexer = R, this.xref = k, this.allowStreams = x, this.recoveryMode = f, this.imageCache = /* @__PURE__ */ Object.create(null), this.refill();
            }
            refill() {
              this.buf1 = this.lexer.getObj(), this.buf2 = this.lexer.getObj();
            }
            shift() {
              this.buf2 instanceof a.Cmd && this.buf2.cmd === "ID" ? (this.buf1 = this.buf2, this.buf2 = null) : (this.buf1 = this.buf2, this.buf2 = this.lexer.getObj());
            }
            tryShift() {
              try {
                return this.shift(), !0;
              } catch (R) {
                if (R instanceof v.MissingDataException)
                  throw R;
                return !1;
              }
            }
            getObj(R = null) {
              const k = this.buf1;
              if (this.shift(), k instanceof a.Cmd)
                switch (k.cmd) {
                  case "BI":
                    return this.makeInlineImage(R);
                  case "[":
                    const x = [];
                    for (; !(0, a.isCmd)(this.buf1, "]") && this.buf1 !== a.EOF; )
                      x.push(this.getObj(R));
                    if (this.buf1 === a.EOF) {
                      if (this.recoveryMode)
                        return x;
                      throw new v.ParserEOFException("End of file inside array.");
                    }
                    return this.shift(), x;
                  case "<<":
                    const f = new a.Dict(this.xref);
                    for (; !(0, a.isCmd)(this.buf1, ">>") && this.buf1 !== a.EOF; ) {
                      if (!(this.buf1 instanceof a.Name)) {
                        (0, t.info)("Malformed dictionary: key must be a name object"), this.shift();
                        continue;
                      }
                      const U = this.buf1.name;
                      if (this.shift(), this.buf1 === a.EOF)
                        break;
                      f.set(U, this.getObj(R));
                    }
                    if (this.buf1 === a.EOF) {
                      if (this.recoveryMode)
                        return f;
                      throw new v.ParserEOFException("End of file inside dictionary.");
                    }
                    return (0, a.isCmd)(this.buf2, "stream") ? this.allowStreams ? this.makeStream(f, R) : f : (this.shift(), f);
                  default:
                    return k;
                }
              if (Number.isInteger(k)) {
                if (Number.isInteger(this.buf1) && (0, a.isCmd)(this.buf2, "R")) {
                  const x = a.Ref.get(k, this.buf1);
                  return this.shift(), this.shift(), x;
                }
                return k;
              }
              return typeof k == "string" && R ? R.decryptString(k) : k;
            }
            findDefaultInlineStreamEnd(R) {
              const F = this.lexer, T = R.pos, I = 10;
              let M = 0, V, J;
              for (; (V = R.getByte()) !== -1; )
                if (M === 0)
                  M = V === 69 ? 1 : 0;
                else if (M === 1)
                  M = V === 73 ? 2 : 0;
                else if ((0, t.assert)(M === 2, "findDefaultInlineStreamEnd - invalid state."), V === 32 || V === 10 || V === 13) {
                  J = R.pos;
                  const z = R.peekBytes(I);
                  for (let G = 0, L = z.length; G < L; G++)
                    if (V = z[G], !(V === 0 && z[G + 1] !== 0) && V !== 10 && V !== 13 && (V < 32 || V > 127)) {
                      M = 0;
                      break;
                    }
                  if (M !== 2)
                    continue;
                  if (F.knownCommands) {
                    const G = F.peekObj();
                    G instanceof a.Cmd && !F.knownCommands[G.cmd] && (M = 0);
                  } else
                    (0, t.warn)("findDefaultInlineStreamEnd - `lexer.knownCommands` is undefined.");
                  if (M === 2)
                    break;
                } else
                  M = 0;
              V === -1 && ((0, t.warn)("findDefaultInlineStreamEnd: Reached the end of the stream without finding a valid EI marker"), J && ((0, t.warn)('... trying to recover by using the last "EI" occurrence.'), R.skip(-(R.pos - J))));
              let W = 4;
              return R.skip(-W), V = R.peekByte(), R.skip(W), (0, v.isWhiteSpace)(V) || W--, R.pos - W - T;
            }
            findDCTDecodeInlineStreamEnd(R) {
              const k = R.pos;
              let x = !1, f, U;
              for (; (f = R.getByte()) !== -1; )
                if (f === 255) {
                  switch (R.getByte()) {
                    case 0:
                      break;
                    case 255:
                      R.skip(-1);
                      break;
                    case 217:
                      x = !0;
                      break;
                    case 192:
                    case 193:
                    case 194:
                    case 195:
                    case 197:
                    case 198:
                    case 199:
                    case 201:
                    case 202:
                    case 203:
                    case 205:
                    case 206:
                    case 207:
                    case 196:
                    case 204:
                    case 218:
                    case 219:
                    case 220:
                    case 221:
                    case 222:
                    case 223:
                    case 224:
                    case 225:
                    case 226:
                    case 227:
                    case 228:
                    case 229:
                    case 230:
                    case 231:
                    case 232:
                    case 233:
                    case 234:
                    case 235:
                    case 236:
                    case 237:
                    case 238:
                    case 239:
                    case 254:
                      U = R.getUint16(), U > 2 ? R.skip(U - 2) : R.skip(-2);
                      break;
                  }
                  if (x)
                    break;
                }
              const O = R.pos - k;
              return f === -1 ? ((0, t.warn)("Inline DCTDecode image stream: EOI marker not found, searching for /EI/ instead."), R.skip(-O), this.findDefaultInlineStreamEnd(R)) : (this.inlineStreamSkipEI(R), O);
            }
            findASCII85DecodeInlineStreamEnd(R) {
              const f = R.pos;
              let U;
              for (; (U = R.getByte()) !== -1; )
                if (U === 126) {
                  const S = R.pos;
                  for (U = R.peekByte(); (0, v.isWhiteSpace)(U); )
                    R.skip(), U = R.peekByte();
                  if (U === 62) {
                    R.skip();
                    break;
                  }
                  if (R.pos > S) {
                    const F = R.peekBytes(2);
                    if (F[0] === 69 && F[1] === 73)
                      break;
                  }
                }
              const O = R.pos - f;
              return U === -1 ? ((0, t.warn)("Inline ASCII85Decode image stream: EOD marker not found, searching for /EI/ instead."), R.skip(-O), this.findDefaultInlineStreamEnd(R)) : (this.inlineStreamSkipEI(R), O);
            }
            findASCIIHexDecodeInlineStreamEnd(R) {
              const x = R.pos;
              let f;
              for (; (f = R.getByte()) !== -1 && f !== 62; )
                ;
              const U = R.pos - x;
              return f === -1 ? ((0, t.warn)("Inline ASCIIHexDecode image stream: EOD marker not found, searching for /EI/ instead."), R.skip(-U), this.findDefaultInlineStreamEnd(R)) : (this.inlineStreamSkipEI(R), U);
            }
            inlineStreamSkipEI(R) {
              let f = 0, U;
              for (; (U = R.getByte()) !== -1; )
                if (f === 0)
                  f = U === 69 ? 1 : 0;
                else if (f === 1)
                  f = U === 73 ? 2 : 0;
                else if (f === 2)
                  break;
            }
            makeInlineImage(R) {
              const k = this.lexer, x = k.stream, f = new a.Dict(this.xref);
              let U;
              for (; !(0, a.isCmd)(this.buf1, "ID") && this.buf1 !== a.EOF; ) {
                if (!(this.buf1 instanceof a.Name))
                  throw new t.FormatError("Dictionary key must be a name object");
                const V = this.buf1.name;
                if (this.shift(), this.buf1 === a.EOF)
                  break;
                f.set(V, this.getObj(R));
              }
              k.beginInlineImagePos !== -1 && (U = x.pos - k.beginInlineImagePos);
              const O = f.get("F", "Filter");
              let S;
              if (O instanceof a.Name)
                S = O.name;
              else if (Array.isArray(O)) {
                const V = this.xref.fetchIfRef(O[0]);
                V instanceof a.Name && (S = V.name);
              }
              const F = x.pos;
              let T;
              switch (S) {
                case "DCT":
                case "DCTDecode":
                  T = this.findDCTDecodeInlineStreamEnd(x);
                  break;
                case "A85":
                case "ASCII85Decode":
                  T = this.findASCII85DecodeInlineStreamEnd(x);
                  break;
                case "AHx":
                case "ASCIIHexDecode":
                  T = this.findASCIIHexDecodeInlineStreamEnd(x);
                  break;
                default:
                  T = this.findDefaultInlineStreamEnd(x);
              }
              let I = x.makeSubStream(F, T, f), M;
              if (T < u && U < w) {
                const V = I.getBytes();
                I.reset();
                const J = x.pos;
                x.pos = k.beginInlineImagePos;
                const W = x.getBytes(U);
                x.pos = J, M = _(V) + "_" + _(W);
                const z = this.imageCache[M];
                if (z !== void 0)
                  return this.buf2 = a.Cmd.get("EI"), this.shift(), z.reset(), z;
              }
              return R && (I = R.createStream(I, T)), I = this.filter(I, f, T), I.dict = f, M !== void 0 && (I.cacheKey = `inline_${T}_${M}`, this.imageCache[M] = I), this.buf2 = a.Cmd.get("EI"), this.shift(), I;
            }
            _findStreamLength(R, k) {
              const {
                stream: x
              } = this.lexer;
              x.pos = R;
              const f = 2048, U = k.length;
              for (; x.pos < x.end; ) {
                const O = x.peekBytes(f), S = O.length - U;
                if (S <= 0)
                  break;
                let F = 0;
                for (; F < S; ) {
                  let T = 0;
                  for (; T < U && O[F + T] === k[T]; )
                    T++;
                  if (T >= U)
                    return x.pos += F, x.pos - R;
                  F++;
                }
                x.pos += S;
              }
              return -1;
            }
            makeStream(R, k) {
              const x = this.lexer;
              let f = x.stream;
              x.skipToNextLine();
              const U = f.pos - 1;
              let O = R.get("Length");
              if (Number.isInteger(O) || ((0, t.info)(`Bad length "${O && O.toString()}" in stream.`), O = 0), f.pos = U + O, x.nextChar(), this.tryShift() && (0, a.isCmd)(this.buf2, "endstream"))
                this.shift();
              else {
                const S = new Uint8Array([101, 110, 100, 115, 116, 114, 101, 97, 109]);
                let F = this._findStreamLength(U, S);
                if (F < 0) {
                  for (let I = 1; I <= 1; I++) {
                    const M = S.length - I, V = S.slice(0, M), J = this._findStreamLength(U, V);
                    if (J >= 0) {
                      const W = f.peekBytes(M + 1)[M];
                      if (!(0, v.isWhiteSpace)(W))
                        break;
                      (0, t.info)(`Found "${(0, t.bytesToString)(V)}" when searching for endstream command.`), F = J;
                      break;
                    }
                  }
                  if (F < 0)
                    throw new t.FormatError("Missing endstream command.");
                }
                O = F, x.nextChar(), this.shift(), this.shift();
              }
              return this.shift(), f = f.makeSubStream(U, O, R), k && (f = k.createStream(f, O)), f = this.filter(f, R, O), f.dict = R, f;
            }
            filter(R, k, x) {
              let f = k.get("F", "Filter"), U = k.get("DP", "DecodeParms");
              if (f instanceof a.Name)
                return Array.isArray(U) && (0, t.warn)("/DecodeParms should not be an Array, when /Filter is a Name."), this.makeFilter(R, f.name, x, U);
              let O = x;
              if (Array.isArray(f)) {
                const S = f, F = U;
                for (let T = 0, I = S.length; T < I; ++T) {
                  if (f = this.xref.fetchIfRef(S[T]), !(f instanceof a.Name))
                    throw new t.FormatError(`Bad filter name "${f}"`);
                  U = null, Array.isArray(F) && T in F && (U = this.xref.fetchIfRef(F[T])), R = this.makeFilter(R, f.name, O, U), O = null;
                }
              }
              return R;
            }
            makeFilter(R, k, x, f) {
              if (x === 0)
                return (0, t.warn)(`Empty "${k}" stream.`), new n.NullStream();
              const U = this.xref.stats;
              try {
                switch (k) {
                  case "Fl":
                  case "FlateDecode":
                    return U.addStreamType(t.StreamType.FLATE), f ? new i.PredictorStream(new c.FlateStream(R, x), x, f) : new c.FlateStream(R, x);
                  case "LZW":
                  case "LZWDecode":
                    U.addStreamType(t.StreamType.LZW);
                    let O = 1;
                    return f ? (f.has("EarlyChange") && (O = f.get("EarlyChange")), new i.PredictorStream(new g.LZWStream(R, x, O), x, f)) : new g.LZWStream(R, x, O);
                  case "DCT":
                  case "DCTDecode":
                    return U.addStreamType(t.StreamType.DCT), new p.JpegStream(R, x, f);
                  case "JPX":
                  case "JPXDecode":
                    return U.addStreamType(t.StreamType.JPX), new m.JpxStream(R, x, f);
                  case "A85":
                  case "ASCII85Decode":
                    return U.addStreamType(t.StreamType.A85), new h.Ascii85Stream(R, x);
                  case "AHx":
                  case "ASCIIHexDecode":
                    return U.addStreamType(t.StreamType.AHX), new e.AsciiHexStream(R, x);
                  case "CCF":
                  case "CCITTFaxDecode":
                    return U.addStreamType(t.StreamType.CCF), new y.CCITTFaxStream(R, x, f);
                  case "RL":
                  case "RunLengthDecode":
                    return U.addStreamType(t.StreamType.RLX), new l.RunLengthStream(R, x);
                  case "JBIG2Decode":
                    return U.addStreamType(t.StreamType.JBIG), new d.Jbig2Stream(R, x, f);
                }
                return (0, t.warn)(`Filter "${k}" is not supported.`), R;
              } catch (O) {
                if (O instanceof v.MissingDataException)
                  throw O;
                return (0, t.warn)(`Invalid stream: "${O}"`), new n.NullStream();
              }
            }
          }
          o.Parser = b;
          const A = [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          function Y(B) {
            return B >= 48 && B <= 57 ? B & 15 : B >= 65 && B <= 70 || B >= 97 && B <= 102 ? (B & 15) + 9 : -1;
          }
          class j {
            constructor(R, k = null) {
              this.stream = R, this.nextChar(), this.strBuf = [], this.knownCommands = k, this._hexStringNumWarn = 0, this.beginInlineImagePos = -1;
            }
            nextChar() {
              return this.currentChar = this.stream.getByte();
            }
            peekChar() {
              return this.stream.peekByte();
            }
            getNumber() {
              let R = this.currentChar, k = !1, x = 0, f = 0;
              if (R === 45 ? (f = -1, R = this.nextChar(), R === 45 && (R = this.nextChar())) : R === 43 && (f = 1, R = this.nextChar()), R === 10 || R === 13)
                do
                  R = this.nextChar();
                while (R === 10 || R === 13);
              if (R === 46 && (x = 10, R = this.nextChar()), R < 48 || R > 57) {
                if ((0, v.isWhiteSpace)(R) || R === -1) {
                  if (x === 10 && f === 0)
                    return (0, t.warn)("Lexer.getNumber - treating a single decimal point as zero."), 0;
                  if (x === 0 && f === -1)
                    return (0, t.warn)("Lexer.getNumber - treating a single minus sign as zero."), 0;
                }
                throw new t.FormatError(`Invalid number: ${String.fromCharCode(R)} (charCode ${R})`);
              }
              f = f || 1;
              let U = R - 48, O = 0, S = 1;
              for (; (R = this.nextChar()) >= 0; )
                if (R >= 48 && R <= 57) {
                  const F = R - 48;
                  k ? O = O * 10 + F : (x !== 0 && (x *= 10), U = U * 10 + F);
                } else if (R === 46)
                  if (x === 0)
                    x = 1;
                  else
                    break;
                else if (R === 45)
                  (0, t.warn)("Badly formatted number: minus sign in the middle");
                else if (R === 69 || R === 101) {
                  if (R = this.peekChar(), R === 43 || R === 45)
                    S = R === 45 ? -1 : 1, this.nextChar();
                  else if (R < 48 || R > 57)
                    break;
                  k = !0;
                } else
                  break;
              return x !== 0 && (U /= x), k && (U *= 10 ** (S * O)), f * U;
            }
            getString() {
              let R = 1, k = !1;
              const x = this.strBuf;
              x.length = 0;
              let f = this.nextChar();
              for (; ; ) {
                let U = !1;
                switch (f | 0) {
                  case -1:
                    (0, t.warn)("Unterminated string"), k = !0;
                    break;
                  case 40:
                    ++R, x.push("(");
                    break;
                  case 41:
                    --R === 0 ? (this.nextChar(), k = !0) : x.push(")");
                    break;
                  case 92:
                    switch (f = this.nextChar(), f) {
                      case -1:
                        (0, t.warn)("Unterminated string"), k = !0;
                        break;
                      case 110:
                        x.push(`
`);
                        break;
                      case 114:
                        x.push("\r");
                        break;
                      case 116:
                        x.push("	");
                        break;
                      case 98:
                        x.push("\b");
                        break;
                      case 102:
                        x.push("\f");
                        break;
                      case 92:
                      case 40:
                      case 41:
                        x.push(String.fromCharCode(f));
                        break;
                      case 48:
                      case 49:
                      case 50:
                      case 51:
                      case 52:
                      case 53:
                      case 54:
                      case 55:
                        let O = f & 15;
                        f = this.nextChar(), U = !0, f >= 48 && f <= 55 && (O = (O << 3) + (f & 15), f = this.nextChar(), f >= 48 && f <= 55 && (U = !1, O = (O << 3) + (f & 15))), x.push(String.fromCharCode(O));
                        break;
                      case 13:
                        this.peekChar() === 10 && this.nextChar();
                        break;
                      case 10:
                        break;
                      default:
                        x.push(String.fromCharCode(f));
                        break;
                    }
                    break;
                  default:
                    x.push(String.fromCharCode(f));
                    break;
                }
                if (k)
                  break;
                U || (f = this.nextChar());
              }
              return x.join("");
            }
            getName() {
              let R, k;
              const x = this.strBuf;
              for (x.length = 0; (R = this.nextChar()) >= 0 && !A[R]; )
                if (R === 35) {
                  if (R = this.nextChar(), A[R]) {
                    (0, t.warn)("Lexer_getName: NUMBER SIGN (#) should be followed by a hexadecimal number."), x.push("#");
                    break;
                  }
                  const f = Y(R);
                  if (f !== -1) {
                    k = R, R = this.nextChar();
                    const U = Y(R);
                    if (U === -1) {
                      if ((0, t.warn)(`Lexer_getName: Illegal digit (${String.fromCharCode(R)}) in hexadecimal number.`), x.push("#", String.fromCharCode(k)), A[R])
                        break;
                      x.push(String.fromCharCode(R));
                      continue;
                    }
                    x.push(String.fromCharCode(f << 4 | U));
                  } else
                    x.push("#", String.fromCharCode(R));
                } else
                  x.push(String.fromCharCode(R));
              return x.length > 127 && (0, t.warn)(`Name token is longer than allowed by the spec: ${x.length}`), a.Name.get(x.join(""));
            }
            _hexStringWarn(R) {
              if (this._hexStringNumWarn++ === 5) {
                (0, t.warn)("getHexString - ignoring additional invalid characters.");
                return;
              }
              this._hexStringNumWarn > 5 || (0, t.warn)(`getHexString - ignoring invalid character: ${R}`);
            }
            getHexString() {
              const R = this.strBuf;
              R.length = 0;
              let k = this.currentChar, x = !0, f, U;
              for (this._hexStringNumWarn = 0; ; )
                if (k < 0) {
                  (0, t.warn)("Unterminated hex string");
                  break;
                } else if (k === 62) {
                  this.nextChar();
                  break;
                } else if (A[k] === 1) {
                  k = this.nextChar();
                  continue;
                } else {
                  if (x) {
                    if (f = Y(k), f === -1) {
                      this._hexStringWarn(k), k = this.nextChar();
                      continue;
                    }
                  } else {
                    if (U = Y(k), U === -1) {
                      this._hexStringWarn(k), k = this.nextChar();
                      continue;
                    }
                    R.push(String.fromCharCode(f << 4 | U));
                  }
                  x = !x, k = this.nextChar();
                }
              return R.join("");
            }
            getObj() {
              let R = !1, k = this.currentChar;
              for (; ; ) {
                if (k < 0)
                  return a.EOF;
                if (R)
                  (k === 10 || k === 13) && (R = !1);
                else if (k === 37)
                  R = !0;
                else if (A[k] !== 1)
                  break;
                k = this.nextChar();
              }
              switch (k | 0) {
                case 48:
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                case 43:
                case 45:
                case 46:
                  return this.getNumber();
                case 40:
                  return this.getString();
                case 47:
                  return this.getName();
                case 91:
                  return this.nextChar(), a.Cmd.get("[");
                case 93:
                  return this.nextChar(), a.Cmd.get("]");
                case 60:
                  return k = this.nextChar(), k === 60 ? (this.nextChar(), a.Cmd.get("<<")) : this.getHexString();
                case 62:
                  return k = this.nextChar(), k === 62 ? (this.nextChar(), a.Cmd.get(">>")) : a.Cmd.get(">");
                case 123:
                  return this.nextChar(), a.Cmd.get("{");
                case 125:
                  return this.nextChar(), a.Cmd.get("}");
                case 41:
                  throw this.nextChar(), new t.FormatError(`Illegal character: ${k}`);
              }
              let x = String.fromCharCode(k);
              if (k < 32 || k > 127) {
                const O = this.peekChar();
                if (O >= 32 && O <= 127)
                  return this.nextChar(), a.Cmd.get(x);
              }
              const f = this.knownCommands;
              let U = f && f[x] !== void 0;
              for (; (k = this.nextChar()) >= 0 && !A[k]; ) {
                const O = x + String.fromCharCode(k);
                if (U && f[O] === void 0)
                  break;
                if (x.length === 128)
                  throw new t.FormatError(`Command token too long: ${x.length}`);
                x = O, U = f && f[x] !== void 0;
              }
              return x === "true" ? !0 : x === "false" ? !1 : x === "null" ? null : (x === "BI" && (this.beginInlineImagePos = this.stream.pos), a.Cmd.get(x));
            }
            peekObj() {
              const R = this.stream.pos, k = this.currentChar, x = this.beginInlineImagePos;
              let f;
              try {
                f = this.getObj();
              } catch (U) {
                if (U instanceof v.MissingDataException)
                  throw U;
                (0, t.warn)(`peekObj: ${U}`);
              }
              return this.stream.pos = R, this.currentChar = k, this.beginInlineImagePos = x, f;
            }
            skipToNextLine() {
              let R = this.currentChar;
              for (; R >= 0; ) {
                if (R === 13) {
                  R = this.nextChar(), R === 10 && this.nextChar();
                  break;
                } else if (R === 10) {
                  this.nextChar();
                  break;
                }
                R = this.nextChar();
              }
            }
          }
          o.Lexer = j;
          class X {
            static create(R) {
              function k(M, V, J = !1) {
                const W = M.get(V);
                if (Number.isInteger(W) && (J ? W >= 0 : W > 0))
                  return W;
                throw new Error(`The "${V}" parameter in the linearization dictionary is invalid.`);
              }
              function x(M) {
                const V = M.get("H");
                let J;
                if (Array.isArray(V) && ((J = V.length) === 2 || J === 4)) {
                  for (let W = 0; W < J; W++) {
                    const z = V[W];
                    if (!(Number.isInteger(z) && z > 0))
                      throw new Error(`Hint (${W}) in the linearization dictionary is invalid.`);
                  }
                  return V;
                }
                throw new Error("Hint array in the linearization dictionary is invalid.");
              }
              const f = new b({
                lexer: new j(R),
                xref: null
              }), U = f.getObj(), O = f.getObj(), S = f.getObj(), F = f.getObj();
              let T, I;
              if (Number.isInteger(U) && Number.isInteger(O) && (0, a.isCmd)(S, "obj") && F instanceof a.Dict && typeof (T = F.get("Linearized")) == "number" && T > 0) {
                if ((I = k(F, "L")) !== R.length)
                  throw new Error('The "L" parameter in the linearization dictionary does not equal the stream length.');
              } else
                return null;
              return {
                length: I,
                hints: x(F),
                objectNumberFirst: k(F, "O"),
                endFirst: k(F, "E"),
                numPages: k(F, "N"),
                mainXRefEntriesOffset: k(F, "T"),
                pageFirst: F.has("P") ? k(F, "P", !0) : 0
              };
            }
          }
          o.Linearization = X;
        },
        /* 18 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.Ascii85Stream = void 0;
          var t = C(19), a = C(6);
          class v extends t.DecodeStream {
            constructor(e, y) {
              y && (y *= 0.8), super(y), this.str = e, this.dict = e.dict, this.input = new Uint8Array(5);
            }
            readBlock() {
              const d = this.str;
              let p = d.getByte();
              for (; (0, a.isWhiteSpace)(p); )
                p = d.getByte();
              if (p === -1 || p === 126) {
                this.eof = !0;
                return;
              }
              const m = this.bufferLength;
              let g, n;
              if (p === 122) {
                for (g = this.ensureBuffer(m + 4), n = 0; n < 4; ++n)
                  g[m + n] = 0;
                this.bufferLength += 4;
              } else {
                const i = this.input;
                for (i[0] = p, n = 1; n < 5; ++n) {
                  for (p = d.getByte(); (0, a.isWhiteSpace)(p); )
                    p = d.getByte();
                  if (i[n] = p, p === -1 || p === 126)
                    break;
                }
                if (g = this.ensureBuffer(m + n - 1), this.bufferLength += n - 1, n < 5) {
                  for (; n < 5; ++n)
                    i[n] = 117;
                  this.eof = !0;
                }
                let l = 0;
                for (n = 0; n < 5; ++n)
                  l = l * 85 + (i[n] - 33);
                for (n = 3; n >= 0; --n)
                  g[m + n] = l & 255, l >>= 8;
              }
            }
          }
          o.Ascii85Stream = v;
        },
        /* 19 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.StreamsSequenceStream = o.DecodeStream = void 0;
          var t = C(7), a = C(10);
          const v = new Uint8Array(0);
          class h extends t.BaseStream {
            constructor(c) {
              if (super(), this._rawMinBufferLength = c || 0, this.pos = 0, this.bufferLength = 0, this.eof = !1, this.buffer = v, this.minBufferLength = 512, c)
                for (; this.minBufferLength < c; )
                  this.minBufferLength *= 2;
            }
            get isEmpty() {
              for (; !this.eof && this.bufferLength === 0; )
                this.readBlock();
              return this.bufferLength === 0;
            }
            ensureBuffer(c) {
              const d = this.buffer;
              if (c <= d.byteLength)
                return d;
              let p = this.minBufferLength;
              for (; p < c; )
                p *= 2;
              const m = new Uint8Array(p);
              return m.set(d), this.buffer = m;
            }
            getByte() {
              const c = this.pos;
              for (; this.bufferLength <= c; ) {
                if (this.eof)
                  return -1;
                this.readBlock();
              }
              return this.buffer[this.pos++];
            }
            getBytes(c) {
              const d = this.pos;
              let p;
              if (c) {
                for (this.ensureBuffer(d + c), p = d + c; !this.eof && this.bufferLength < p; )
                  this.readBlock();
                const m = this.bufferLength;
                p > m && (p = m);
              } else {
                for (; !this.eof; )
                  this.readBlock();
                p = this.bufferLength;
              }
              return this.pos = p, this.buffer.subarray(d, p);
            }
            reset() {
              this.pos = 0;
            }
            makeSubStream(c, d, p = null) {
              if (d === void 0)
                for (; !this.eof; )
                  this.readBlock();
              else {
                const m = c + d;
                for (; this.bufferLength <= m && !this.eof; )
                  this.readBlock();
              }
              return new a.Stream(this.buffer, c, d, p);
            }
            getBaseStreams() {
              return this.str ? this.str.getBaseStreams() : null;
            }
          }
          o.DecodeStream = h;
          class e extends h {
            constructor(c, d = null) {
              let p = 0;
              for (const m of c)
                p += m instanceof h ? m._rawMinBufferLength : m.length;
              super(p), this.streams = c, this._onError = d;
            }
            readBlock() {
              const c = this.streams;
              if (c.length === 0) {
                this.eof = !0;
                return;
              }
              const d = c.shift();
              let p;
              try {
                p = d.getBytes();
              } catch (i) {
                if (this._onError) {
                  this._onError(i, d.dict && d.dict.objId);
                  return;
                }
                throw i;
              }
              const m = this.bufferLength, g = m + p.length;
              this.ensureBuffer(g).set(p, m), this.bufferLength = g;
            }
            getBaseStreams() {
              const c = [];
              for (const d of this.streams) {
                const p = d.getBaseStreams();
                p && c.push(...p);
              }
              return c.length > 0 ? c : null;
            }
          }
          o.StreamsSequenceStream = e;
        },
        /* 20 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.AsciiHexStream = void 0;
          var t = C(19);
          class a extends t.DecodeStream {
            constructor(h, e) {
              e && (e *= 0.5), super(e), this.str = h, this.dict = h.dict, this.firstDigit = -1;
            }
            readBlock() {
              const e = this.str.getBytes(8e3);
              if (!e.length) {
                this.eof = !0;
                return;
              }
              const y = e.length + 1 >> 1, c = this.ensureBuffer(this.bufferLength + y);
              let d = this.bufferLength, p = this.firstDigit;
              for (const m of e) {
                let g;
                if (m >= 48 && m <= 57)
                  g = m & 15;
                else if (m >= 65 && m <= 70 || m >= 97 && m <= 102)
                  g = (m & 15) + 9;
                else if (m === 62) {
                  this.eof = !0;
                  break;
                } else
                  continue;
                p < 0 ? p = g : (c[d++] = p << 4 | g, p = -1);
              }
              p >= 0 && this.eof && (c[d++] = p << 4, p = -1), this.firstDigit = p, this.bufferLength = d;
            }
          }
          o.AsciiHexStream = a;
        },
        /* 21 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.CCITTFaxStream = void 0;
          var t = C(22), a = C(19), v = C(5);
          class h extends a.DecodeStream {
            constructor(y, c, d) {
              super(c), this.str = y, this.dict = y.dict, d instanceof v.Dict || (d = v.Dict.empty);
              const p = {
                next() {
                  return y.getByte();
                }
              };
              this.ccittFaxDecoder = new t.CCITTFaxDecoder(p, {
                K: d.get("K"),
                EndOfLine: d.get("EndOfLine"),
                EncodedByteAlign: d.get("EncodedByteAlign"),
                Columns: d.get("Columns"),
                Rows: d.get("Rows"),
                EndOfBlock: d.get("EndOfBlock"),
                BlackIs1: d.get("BlackIs1")
              });
            }
            readBlock() {
              for (; !this.eof; ) {
                const y = this.ccittFaxDecoder.readNextChar();
                if (y === -1) {
                  this.eof = !0;
                  return;
                }
                this.ensureBuffer(this.bufferLength + 1), this.buffer[this.bufferLength++] = y;
              }
            }
          }
          o.CCITTFaxStream = h;
        },
        /* 22 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.CCITTFaxDecoder = void 0;
          var t = C(2);
          const a = -2, v = -1, h = 0, e = 1, y = 2, c = 3, d = 4, p = 5, m = 6, g = 7, n = 8, i = [[-1, -1], [-1, -1], [7, n], [7, g], [6, m], [6, m], [6, p], [6, p], [4, h], [4, h], [4, h], [4, h], [4, h], [4, h], [4, h], [4, h], [3, e], [3, e], [3, e], [3, e], [3, e], [3, e], [3, e], [3, e], [3, e], [3, e], [3, e], [3, e], [3, e], [3, e], [3, e], [3, e], [3, d], [3, d], [3, d], [3, d], [3, d], [3, d], [3, d], [3, d], [3, d], [3, d], [3, d], [3, d], [3, d], [3, d], [3, d], [3, d], [3, c], [3, c], [3, c], [3, c], [3, c], [3, c], [3, c], [3, c], [3, c], [3, c], [3, c], [3, c], [3, c], [3, c], [3, c], [3, c], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y]], l = [[-1, -1], [12, a], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [12, 1984], [12, 2048], [12, 2112], [12, 2176], [12, 2240], [12, 2304], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [12, 2368], [12, 2432], [12, 2496], [12, 2560]], u = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [8, 29], [8, 29], [8, 30], [8, 30], [8, 45], [8, 45], [8, 46], [8, 46], [7, 22], [7, 22], [7, 22], [7, 22], [7, 23], [7, 23], [7, 23], [7, 23], [8, 47], [8, 47], [8, 48], [8, 48], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [7, 20], [7, 20], [7, 20], [7, 20], [8, 33], [8, 33], [8, 34], [8, 34], [8, 35], [8, 35], [8, 36], [8, 36], [8, 37], [8, 37], [8, 38], [8, 38], [7, 19], [7, 19], [7, 19], [7, 19], [8, 31], [8, 31], [8, 32], [8, 32], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [8, 53], [8, 53], [8, 54], [8, 54], [7, 26], [7, 26], [7, 26], [7, 26], [8, 39], [8, 39], [8, 40], [8, 40], [8, 41], [8, 41], [8, 42], [8, 42], [8, 43], [8, 43], [8, 44], [8, 44], [7, 21], [7, 21], [7, 21], [7, 21], [7, 28], [7, 28], [7, 28], [7, 28], [8, 61], [8, 61], [8, 62], [8, 62], [8, 63], [8, 63], [8, 0], [8, 0], [8, 320], [8, 320], [8, 384], [8, 384], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [7, 27], [7, 27], [7, 27], [7, 27], [8, 59], [8, 59], [8, 60], [8, 60], [9, 1472], [9, 1536], [9, 1600], [9, 1728], [7, 18], [7, 18], [7, 18], [7, 18], [7, 24], [7, 24], [7, 24], [7, 24], [8, 49], [8, 49], [8, 50], [8, 50], [8, 51], [8, 51], [8, 52], [8, 52], [7, 25], [7, 25], [7, 25], [7, 25], [8, 55], [8, 55], [8, 56], [8, 56], [8, 57], [8, 57], [8, 58], [8, 58], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [8, 448], [8, 448], [8, 512], [8, 512], [9, 704], [9, 768], [8, 640], [8, 640], [8, 576], [8, 576], [9, 832], [9, 896], [9, 960], [9, 1024], [9, 1088], [9, 1152], [9, 1216], [9, 1280], [9, 1344], [9, 1408], [7, 256], [7, 256], [7, 256], [7, 256], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7]], w = [[-1, -1], [-1, -1], [12, a], [12, a], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [11, 1792], [11, 1792], [12, 1984], [12, 1984], [12, 2048], [12, 2048], [12, 2112], [12, 2112], [12, 2176], [12, 2176], [12, 2240], [12, 2240], [12, 2304], [12, 2304], [11, 1856], [11, 1856], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [11, 1920], [11, 1920], [12, 2368], [12, 2368], [12, 2432], [12, 2432], [12, 2496], [12, 2496], [12, 2560], [12, 2560], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [12, 52], [12, 52], [13, 640], [13, 704], [13, 768], [13, 832], [12, 55], [12, 55], [12, 56], [12, 56], [13, 1280], [13, 1344], [13, 1408], [13, 1472], [12, 59], [12, 59], [12, 60], [12, 60], [13, 1536], [13, 1600], [11, 24], [11, 24], [11, 24], [11, 24], [11, 25], [11, 25], [11, 25], [11, 25], [13, 1664], [13, 1728], [12, 320], [12, 320], [12, 384], [12, 384], [12, 448], [12, 448], [13, 512], [13, 576], [12, 53], [12, 53], [12, 54], [12, 54], [13, 896], [13, 960], [13, 1024], [13, 1088], [13, 1152], [13, 1216], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64]], _ = [[8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [11, 23], [11, 23], [12, 50], [12, 51], [12, 44], [12, 45], [12, 46], [12, 47], [12, 57], [12, 58], [12, 61], [12, 256], [10, 16], [10, 16], [10, 16], [10, 16], [10, 17], [10, 17], [10, 17], [10, 17], [12, 48], [12, 49], [12, 62], [12, 63], [12, 30], [12, 31], [12, 32], [12, 33], [12, 40], [12, 41], [11, 22], [11, 22], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [12, 128], [12, 192], [12, 26], [12, 27], [12, 28], [12, 29], [11, 19], [11, 19], [11, 20], [11, 20], [12, 34], [12, 35], [12, 36], [12, 37], [12, 38], [12, 39], [11, 21], [11, 21], [12, 42], [12, 43], [10, 0], [10, 0], [10, 0], [10, 0], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12]], b = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [6, 9], [6, 8], [5, 7], [5, 7], [4, 6], [4, 6], [4, 6], [4, 6], [4, 5], [4, 5], [4, 5], [4, 5], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2]];
          class A {
            constructor(j, X = {}) {
              if (!j || typeof j.next != "function")
                throw new Error('CCITTFaxDecoder - invalid "source" parameter.');
              this.source = j, this.eof = !1, this.encoding = X.K || 0, this.eoline = X.EndOfLine || !1, this.byteAlign = X.EncodedByteAlign || !1, this.columns = X.Columns || 1728, this.rows = X.Rows || 0;
              let B = X.EndOfBlock;
              B == null && (B = !0), this.eoblock = B, this.black = X.BlackIs1 || !1, this.codingLine = new Uint32Array(this.columns + 1), this.refLine = new Uint32Array(this.columns + 2), this.codingLine[0] = this.columns, this.codingPos = 0, this.row = 0, this.nextLine2D = this.encoding < 0, this.inputBits = 0, this.inputBuf = 0, this.outputBits = 0, this.rowsDone = !1;
              let R;
              for (; (R = this._lookBits(12)) === 0; )
                this._eatBits(1);
              R === 1 && this._eatBits(12), this.encoding > 0 && (this.nextLine2D = !this._lookBits(1), this._eatBits(1));
            }
            readNextChar() {
              if (this.eof)
                return -1;
              const j = this.refLine, X = this.codingLine, B = this.columns;
              let R, k, x, f;
              if (this.outputBits === 0) {
                if (this.rowsDone && (this.eof = !0), this.eof)
                  return -1;
                this.err = !1;
                let O, S, F;
                if (this.nextLine2D) {
                  for (f = 0; X[f] < B; ++f)
                    j[f] = X[f];
                  for (j[f++] = B, j[f] = B, X[0] = 0, this.codingPos = 0, R = 0, k = 0; X[this.codingPos] < B; )
                    switch (O = this._getTwoDimCode(), O) {
                      case h:
                        this._addPixels(j[R + 1], k), j[R + 1] < B && (R += 2);
                        break;
                      case e:
                        if (O = S = 0, k) {
                          do
                            O += F = this._getBlackCode();
                          while (F >= 64);
                          do
                            S += F = this._getWhiteCode();
                          while (F >= 64);
                        } else {
                          do
                            O += F = this._getWhiteCode();
                          while (F >= 64);
                          do
                            S += F = this._getBlackCode();
                          while (F >= 64);
                        }
                        for (this._addPixels(X[this.codingPos] + O, k), X[this.codingPos] < B && this._addPixels(X[this.codingPos] + S, k ^ 1); j[R] <= X[this.codingPos] && j[R] < B; )
                          R += 2;
                        break;
                      case g:
                        if (this._addPixels(j[R] + 3, k), k ^= 1, X[this.codingPos] < B)
                          for (++R; j[R] <= X[this.codingPos] && j[R] < B; )
                            R += 2;
                        break;
                      case p:
                        if (this._addPixels(j[R] + 2, k), k ^= 1, X[this.codingPos] < B)
                          for (++R; j[R] <= X[this.codingPos] && j[R] < B; )
                            R += 2;
                        break;
                      case c:
                        if (this._addPixels(j[R] + 1, k), k ^= 1, X[this.codingPos] < B)
                          for (++R; j[R] <= X[this.codingPos] && j[R] < B; )
                            R += 2;
                        break;
                      case y:
                        if (this._addPixels(j[R], k), k ^= 1, X[this.codingPos] < B)
                          for (++R; j[R] <= X[this.codingPos] && j[R] < B; )
                            R += 2;
                        break;
                      case n:
                        if (this._addPixelsNeg(j[R] - 3, k), k ^= 1, X[this.codingPos] < B)
                          for (R > 0 ? --R : ++R; j[R] <= X[this.codingPos] && j[R] < B; )
                            R += 2;
                        break;
                      case m:
                        if (this._addPixelsNeg(j[R] - 2, k), k ^= 1, X[this.codingPos] < B)
                          for (R > 0 ? --R : ++R; j[R] <= X[this.codingPos] && j[R] < B; )
                            R += 2;
                        break;
                      case d:
                        if (this._addPixelsNeg(j[R] - 1, k), k ^= 1, X[this.codingPos] < B)
                          for (R > 0 ? --R : ++R; j[R] <= X[this.codingPos] && j[R] < B; )
                            R += 2;
                        break;
                      case v:
                        this._addPixels(B, 0), this.eof = !0;
                        break;
                      default:
                        (0, t.info)("bad 2d code"), this._addPixels(B, 0), this.err = !0;
                    }
                } else
                  for (X[0] = 0, this.codingPos = 0, k = 0; X[this.codingPos] < B; ) {
                    if (O = 0, k)
                      do
                        O += F = this._getBlackCode();
                      while (F >= 64);
                    else
                      do
                        O += F = this._getWhiteCode();
                      while (F >= 64);
                    this._addPixels(X[this.codingPos] + O, k), k ^= 1;
                  }
                let T = !1;
                if (this.byteAlign && (this.inputBits &= -8), !this.eoblock && this.row === this.rows - 1)
                  this.rowsDone = !0;
                else {
                  if (O = this._lookBits(12), this.eoline)
                    for (; O !== v && O !== 1; )
                      this._eatBits(1), O = this._lookBits(12);
                  else
                    for (; O === 0; )
                      this._eatBits(1), O = this._lookBits(12);
                  O === 1 ? (this._eatBits(12), T = !0) : O === v && (this.eof = !0);
                }
                if (!this.eof && this.encoding > 0 && !this.rowsDone && (this.nextLine2D = !this._lookBits(1), this._eatBits(1)), this.eoblock && T && this.byteAlign) {
                  if (O = this._lookBits(12), O === 1) {
                    if (this._eatBits(12), this.encoding > 0 && (this._lookBits(1), this._eatBits(1)), this.encoding >= 0)
                      for (f = 0; f < 4; ++f)
                        O = this._lookBits(12), O !== 1 && (0, t.info)("bad rtc code: " + O), this._eatBits(12), this.encoding > 0 && (this._lookBits(1), this._eatBits(1));
                    this.eof = !0;
                  }
                } else if (this.err && this.eoline) {
                  for (; ; ) {
                    if (O = this._lookBits(13), O === v)
                      return this.eof = !0, -1;
                    if (O >> 1 === 1)
                      break;
                    this._eatBits(1);
                  }
                  this._eatBits(12), this.encoding > 0 && (this._eatBits(1), this.nextLine2D = !(O & 1));
                }
                X[0] > 0 ? this.outputBits = X[this.codingPos = 0] : this.outputBits = X[this.codingPos = 1], this.row++;
              }
              let U;
              if (this.outputBits >= 8)
                U = this.codingPos & 1 ? 0 : 255, this.outputBits -= 8, this.outputBits === 0 && X[this.codingPos] < B && (this.codingPos++, this.outputBits = X[this.codingPos] - X[this.codingPos - 1]);
              else {
                x = 8, U = 0;
                do {
                  if (typeof this.outputBits != "number")
                    throw new t.FormatError('Invalid /CCITTFaxDecode data, "outputBits" must be a number.');
                  this.outputBits > x ? (U <<= x, this.codingPos & 1 || (U |= 255 >> 8 - x), this.outputBits -= x, x = 0) : (U <<= this.outputBits, this.codingPos & 1 || (U |= 255 >> 8 - this.outputBits), x -= this.outputBits, this.outputBits = 0, X[this.codingPos] < B ? (this.codingPos++, this.outputBits = X[this.codingPos] - X[this.codingPos - 1]) : x > 0 && (U <<= x, x = 0));
                } while (x);
              }
              return this.black && (U ^= 255), U;
            }
            _addPixels(j, X) {
              const B = this.codingLine;
              let R = this.codingPos;
              j > B[R] && (j > this.columns && ((0, t.info)("row is wrong length"), this.err = !0, j = this.columns), R & 1 ^ X && ++R, B[R] = j), this.codingPos = R;
            }
            _addPixelsNeg(j, X) {
              const B = this.codingLine;
              let R = this.codingPos;
              if (j > B[R])
                j > this.columns && ((0, t.info)("row is wrong length"), this.err = !0, j = this.columns), R & 1 ^ X && ++R, B[R] = j;
              else if (j < B[R]) {
                for (j < 0 && ((0, t.info)("invalid code"), this.err = !0, j = 0); R > 0 && j < B[R - 1]; )
                  --R;
                B[R] = j;
              }
              this.codingPos = R;
            }
            _findTableCode(j, X, B, R) {
              const k = R || 0;
              for (let x = j; x <= X; ++x) {
                let f = this._lookBits(x);
                if (f === v)
                  return [!0, 1, !1];
                if (x < X && (f <<= X - x), !k || f >= k) {
                  const U = B[f - k];
                  if (U[0] === x)
                    return this._eatBits(x), [!0, U[1], !0];
                }
              }
              return [!1, 0, !1];
            }
            _getTwoDimCode() {
              let j = 0, X;
              if (this.eoblock) {
                if (j = this._lookBits(7), X = i[j], X && X[0] > 0)
                  return this._eatBits(X[0]), X[1];
              } else {
                const B = this._findTableCode(1, 7, i);
                if (B[0] && B[2])
                  return B[1];
              }
              return (0, t.info)("Bad two dim code"), v;
            }
            _getWhiteCode() {
              let j = 0, X;
              if (this.eoblock) {
                if (j = this._lookBits(12), j === v)
                  return 1;
                if (j >> 5 ? X = u[j >> 3] : X = l[j], X[0] > 0)
                  return this._eatBits(X[0]), X[1];
              } else {
                let B = this._findTableCode(1, 9, u);
                if (B[0] || (B = this._findTableCode(11, 12, l), B[0]))
                  return B[1];
              }
              return (0, t.info)("bad white code"), this._eatBits(1), 1;
            }
            _getBlackCode() {
              let j, X;
              if (this.eoblock) {
                if (j = this._lookBits(13), j === v)
                  return 1;
                if (j >> 7 ? !(j >> 9) && j >> 7 ? X = _[(j >> 1) - 64] : X = b[j >> 7] : X = w[j], X[0] > 0)
                  return this._eatBits(X[0]), X[1];
              } else {
                let B = this._findTableCode(2, 6, b);
                if (B[0] || (B = this._findTableCode(7, 12, _, 64), B[0]) || (B = this._findTableCode(10, 13, w), B[0]))
                  return B[1];
              }
              return (0, t.info)("bad black code"), this._eatBits(1), 1;
            }
            _lookBits(j) {
              let X;
              for (; this.inputBits < j; ) {
                if ((X = this.source.next()) === -1)
                  return this.inputBits === 0 ? v : this.inputBuf << j - this.inputBits & 65535 >> 16 - j;
                this.inputBuf = this.inputBuf << 8 | X, this.inputBits += 8;
              }
              return this.inputBuf >> this.inputBits - j & 65535 >> 16 - j;
            }
            _eatBits(j) {
              (this.inputBits -= j) < 0 && (this.inputBits = 0);
            }
          }
          o.CCITTFaxDecoder = A;
        },
        /* 23 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.FlateStream = void 0;
          var t = C(19), a = C(2);
          const v = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), h = new Int32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]), e = new Int32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353, 876545]), y = [new Int32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9], c = [new Int32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5];
          class d extends t.DecodeStream {
            constructor(m, g) {
              super(g), this.str = m, this.dict = m.dict;
              const n = m.getByte(), i = m.getByte();
              if (n === -1 || i === -1)
                throw new a.FormatError(`Invalid header in flate stream: ${n}, ${i}`);
              if ((n & 15) !== 8)
                throw new a.FormatError(`Unknown compression method in flate stream: ${n}, ${i}`);
              if (((n << 8) + i) % 31 !== 0)
                throw new a.FormatError(`Bad FCHECK in flate stream: ${n}, ${i}`);
              if (i & 32)
                throw new a.FormatError(`FDICT bit set in flate stream: ${n}, ${i}`);
              this.codeSize = 0, this.codeBuf = 0;
            }
            getBits(m) {
              const g = this.str;
              let n = this.codeSize, i = this.codeBuf, l;
              for (; n < m; ) {
                if ((l = g.getByte()) === -1)
                  throw new a.FormatError("Bad encoding in flate stream");
                i |= l << n, n += 8;
              }
              return l = i & (1 << m) - 1, this.codeBuf = i >> m, this.codeSize = n -= m, l;
            }
            getCode(m) {
              const g = this.str, n = m[0], i = m[1];
              let l = this.codeSize, u = this.codeBuf, w;
              for (; l < i && (w = g.getByte()) !== -1; )
                u |= w << l, l += 8;
              const _ = n[u & (1 << i) - 1], b = _ >> 16, A = _ & 65535;
              if (b < 1 || l < b)
                throw new a.FormatError("Bad encoding in flate stream");
              return this.codeBuf = u >> b, this.codeSize = l - b, A;
            }
            generateHuffmanTable(m) {
              const g = m.length;
              let n = 0, i;
              for (i = 0; i < g; ++i)
                m[i] > n && (n = m[i]);
              const l = 1 << n, u = new Int32Array(l);
              for (let w = 1, _ = 0, b = 2; w <= n; ++w, _ <<= 1, b <<= 1)
                for (let A = 0; A < g; ++A)
                  if (m[A] === w) {
                    let Y = 0, j = _;
                    for (i = 0; i < w; ++i)
                      Y = Y << 1 | j & 1, j >>= 1;
                    for (i = Y; i < l; i += b)
                      u[i] = w << 16 | A;
                    ++_;
                  }
              return [u, n];
            }
            readBlock() {
              let m, g;
              const n = this.str;
              let i = this.getBits(3);
              if (i & 1 && (this.eof = !0), i >>= 1, i === 0) {
                let b;
                if ((b = n.getByte()) === -1)
                  throw new a.FormatError("Bad block header in flate stream");
                let A = b;
                if ((b = n.getByte()) === -1)
                  throw new a.FormatError("Bad block header in flate stream");
                if (A |= b << 8, (b = n.getByte()) === -1)
                  throw new a.FormatError("Bad block header in flate stream");
                let Y = b;
                if ((b = n.getByte()) === -1)
                  throw new a.FormatError("Bad block header in flate stream");
                if (Y |= b << 8, Y !== (~A & 65535) && (A !== 0 || Y !== 0))
                  throw new a.FormatError("Bad uncompressed block length in flate stream");
                this.codeBuf = 0, this.codeSize = 0;
                const j = this.bufferLength, X = j + A;
                if (m = this.ensureBuffer(X), this.bufferLength = X, A === 0)
                  n.peekByte() === -1 && (this.eof = !0);
                else {
                  const B = n.getBytes(A);
                  m.set(B, j), B.length < A && (this.eof = !0);
                }
                return;
              }
              let l, u;
              if (i === 1)
                l = y, u = c;
              else if (i === 2) {
                const b = this.getBits(5) + 257, A = this.getBits(5) + 1, Y = this.getBits(4) + 4, j = new Uint8Array(v.length);
                let X;
                for (X = 0; X < Y; ++X)
                  j[v[X]] = this.getBits(3);
                const B = this.generateHuffmanTable(j);
                g = 0, X = 0;
                const R = b + A, k = new Uint8Array(R);
                let x, f, U;
                for (; X < R; ) {
                  const O = this.getCode(B);
                  if (O === 16)
                    x = 2, f = 3, U = g;
                  else if (O === 17)
                    x = 3, f = 3, U = g = 0;
                  else if (O === 18)
                    x = 7, f = 11, U = g = 0;
                  else {
                    k[X++] = g = O;
                    continue;
                  }
                  let S = this.getBits(x) + f;
                  for (; S-- > 0; )
                    k[X++] = U;
                }
                l = this.generateHuffmanTable(k.subarray(0, b)), u = this.generateHuffmanTable(k.subarray(b, R));
              } else
                throw new a.FormatError("Unknown block type in flate stream");
              m = this.buffer;
              let w = m ? m.length : 0, _ = this.bufferLength;
              for (; ; ) {
                let b = this.getCode(l);
                if (b < 256) {
                  _ + 1 >= w && (m = this.ensureBuffer(_ + 1), w = m.length), m[_++] = b;
                  continue;
                }
                if (b === 256) {
                  this.bufferLength = _;
                  return;
                }
                b -= 257, b = h[b];
                let A = b >> 16;
                A > 0 && (A = this.getBits(A)), g = (b & 65535) + A, b = this.getCode(u), b = e[b], A = b >> 16, A > 0 && (A = this.getBits(A));
                const Y = (b & 65535) + A;
                _ + g >= w && (m = this.ensureBuffer(_ + g), w = m.length);
                for (let j = 0; j < g; ++j, ++_)
                  m[_] = m[_ - Y];
              }
            }
          }
          o.FlateStream = d;
        },
        /* 24 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.Jbig2Stream = void 0;
          var t = C(7), a = C(19), v = C(5), h = C(25), e = C(2);
          class y extends a.DecodeStream {
            constructor(d, p, m) {
              super(p), this.stream = d, this.dict = d.dict, this.maybeLength = p, this.params = m;
            }
            get bytes() {
              return (0, e.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
            }
            ensureBuffer(d) {
            }
            readBlock() {
              if (this.eof)
                return;
              const d = new h.Jbig2Image(), p = [];
              if (this.params instanceof v.Dict) {
                const n = this.params.get("JBIG2Globals");
                if (n instanceof t.BaseStream) {
                  const i = n.getBytes();
                  p.push({
                    data: i,
                    start: 0,
                    end: i.length
                  });
                }
              }
              p.push({
                data: this.bytes,
                start: 0,
                end: this.bytes.length
              });
              const m = d.parseChunks(p), g = m.length;
              for (let n = 0; n < g; n++)
                m[n] ^= 255;
              this.buffer = m, this.bufferLength = g, this.eof = !0;
            }
          }
          o.Jbig2Stream = y;
        },
        /* 25 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.Jbig2Image = void 0;
          var t = C(2), a = C(6), v = C(26), h = C(22);
          class e extends t.BaseException {
            constructor(q) {
              super(`JBIG2 error: ${q}`, "Jbig2Error");
            }
          }
          class y {
            getContexts(q) {
              return q in this ? this[q] : this[q] = new Int8Array(65536);
            }
          }
          class c {
            constructor(q, N, Q) {
              this.data = q, this.start = N, this.end = Q;
            }
            get decoder() {
              const q = new v.ArithmeticDecoder(this.data, this.start, this.end);
              return (0, t.shadow)(this, "decoder", q);
            }
            get contextCache() {
              const q = new y();
              return (0, t.shadow)(this, "contextCache", q);
            }
          }
          function d(se, q, N) {
            const Q = se.getContexts(q);
            let D = 1;
            function ne($) {
              let E = 0;
              for (let H = 0; H < $; H++) {
                const ie = N.readBit(Q, D);
                D = D < 256 ? D << 1 | ie : (D << 1 | ie) & 511 | 256, E = E << 1 | ie;
              }
              return E >>> 0;
            }
            const oe = ne(1), ee = ne(1) ? ne(1) ? ne(1) ? ne(1) ? ne(1) ? ne(32) + 4436 : ne(12) + 340 : ne(8) + 84 : ne(6) + 20 : ne(4) + 4 : ne(2);
            return oe === 0 ? ee : ee > 0 ? -ee : null;
          }
          function p(se, q, N) {
            const Q = se.getContexts("IAID");
            let D = 1;
            for (let ne = 0; ne < N; ne++) {
              const oe = q.readBit(Q, D);
              D = D << 1 | oe;
            }
            return N < 31 ? D & (1 << N) - 1 : D & 2147483647;
          }
          const m = ["SymbolDictionary", null, null, null, "IntermediateTextRegion", null, "ImmediateTextRegion", "ImmediateLosslessTextRegion", null, null, null, null, null, null, null, null, "PatternDictionary", null, null, null, "IntermediateHalftoneRegion", null, "ImmediateHalftoneRegion", "ImmediateLosslessHalftoneRegion", null, null, null, null, null, null, null, null, null, null, null, null, "IntermediateGenericRegion", null, "ImmediateGenericRegion", "ImmediateLosslessGenericRegion", "IntermediateGenericRefinementRegion", null, "ImmediateGenericRefinementRegion", "ImmediateLosslessGenericRefinementRegion", null, null, null, null, "PageInformation", "EndOfPage", "EndOfStripe", "EndOfFile", "Profiles", "Tables", null, null, null, null, null, null, null, null, "Extension"], g = [[{
            x: -1,
            y: -2
          }, {
            x: 0,
            y: -2
          }, {
            x: 1,
            y: -2
          }, {
            x: -2,
            y: -1
          }, {
            x: -1,
            y: -1
          }, {
            x: 0,
            y: -1
          }, {
            x: 1,
            y: -1
          }, {
            x: 2,
            y: -1
          }, {
            x: -4,
            y: 0
          }, {
            x: -3,
            y: 0
          }, {
            x: -2,
            y: 0
          }, {
            x: -1,
            y: 0
          }], [{
            x: -1,
            y: -2
          }, {
            x: 0,
            y: -2
          }, {
            x: 1,
            y: -2
          }, {
            x: 2,
            y: -2
          }, {
            x: -2,
            y: -1
          }, {
            x: -1,
            y: -1
          }, {
            x: 0,
            y: -1
          }, {
            x: 1,
            y: -1
          }, {
            x: 2,
            y: -1
          }, {
            x: -3,
            y: 0
          }, {
            x: -2,
            y: 0
          }, {
            x: -1,
            y: 0
          }], [{
            x: -1,
            y: -2
          }, {
            x: 0,
            y: -2
          }, {
            x: 1,
            y: -2
          }, {
            x: -2,
            y: -1
          }, {
            x: -1,
            y: -1
          }, {
            x: 0,
            y: -1
          }, {
            x: 1,
            y: -1
          }, {
            x: -2,
            y: 0
          }, {
            x: -1,
            y: 0
          }], [{
            x: -3,
            y: -1
          }, {
            x: -2,
            y: -1
          }, {
            x: -1,
            y: -1
          }, {
            x: 0,
            y: -1
          }, {
            x: 1,
            y: -1
          }, {
            x: -4,
            y: 0
          }, {
            x: -3,
            y: 0
          }, {
            x: -2,
            y: 0
          }, {
            x: -1,
            y: 0
          }]], n = [{
            coding: [{
              x: 0,
              y: -1
            }, {
              x: 1,
              y: -1
            }, {
              x: -1,
              y: 0
            }],
            reference: [{
              x: 0,
              y: -1
            }, {
              x: 1,
              y: -1
            }, {
              x: -1,
              y: 0
            }, {
              x: 0,
              y: 0
            }, {
              x: 1,
              y: 0
            }, {
              x: -1,
              y: 1
            }, {
              x: 0,
              y: 1
            }, {
              x: 1,
              y: 1
            }]
          }, {
            coding: [{
              x: -1,
              y: -1
            }, {
              x: 0,
              y: -1
            }, {
              x: 1,
              y: -1
            }, {
              x: -1,
              y: 0
            }],
            reference: [{
              x: 0,
              y: -1
            }, {
              x: -1,
              y: 0
            }, {
              x: 0,
              y: 0
            }, {
              x: 1,
              y: 0
            }, {
              x: 0,
              y: 1
            }, {
              x: 1,
              y: 1
            }]
          }], i = [39717, 1941, 229, 405], l = [32, 8];
          function u(se, q, N) {
            const Q = N.decoder, D = N.contextCache.getContexts("GB"), ne = [];
            let oe, ee, $, E, H, ie, ue;
            const fe = 31735;
            for (ee = 0; ee < q; ee++)
              for (H = ne[ee] = new Uint8Array(se), ie = ee < 1 ? H : ne[ee - 1], ue = ee < 2 ? H : ne[ee - 2], oe = ue[0] << 13 | ue[1] << 12 | ue[2] << 11 | ie[0] << 7 | ie[1] << 6 | ie[2] << 5 | ie[3] << 4, $ = 0; $ < se; $++)
                H[$] = E = Q.readBit(D, oe), oe = (oe & fe) << 1 | ($ + 3 < se ? ue[$ + 3] << 11 : 0) | ($ + 4 < se ? ie[$ + 4] << 4 : 0) | E;
            return ne;
          }
          function w(se, q, N, Q, D, ne, oe, ee) {
            if (se) {
              const Me = new J(ee.data, ee.start, ee.end);
              return K(Me, q, N, !1);
            }
            if (Q === 0 && !ne && !D && oe.length === 4 && oe[0].x === 3 && oe[0].y === -1 && oe[1].x === -3 && oe[1].y === -1 && oe[2].x === 2 && oe[2].y === -2 && oe[3].x === -2 && oe[3].y === -2)
              return u(q, N, ee);
            const $ = !!ne, E = g[Q].concat(oe);
            E.sort(function(Me, at) {
              return Me.y - at.y || Me.x - at.x;
            });
            const H = E.length, ie = new Int8Array(H), ue = new Int8Array(H), fe = [];
            let de = 0, pe = 0, xe = 0, De = 0, Ae, Se;
            for (Se = 0; Se < H; Se++)
              ie[Se] = E[Se].x, ue[Se] = E[Se].y, pe = Math.min(pe, E[Se].x), xe = Math.max(xe, E[Se].x), De = Math.min(De, E[Se].y), Se < H - 1 && E[Se].y === E[Se + 1].y && E[Se].x === E[Se + 1].x - 1 ? de |= 1 << H - 1 - Se : fe.push(Se);
            const ke = fe.length, ye = new Int8Array(ke), _e = new Int8Array(ke), we = new Uint16Array(ke);
            for (Ae = 0; Ae < ke; Ae++)
              Se = fe[Ae], ye[Ae] = E[Se].x, _e[Ae] = E[Se].y, we[Ae] = 1 << H - 1 - Se;
            const Ce = -pe, ve = -De, Le = q - xe, He = i[Q];
            let Qe = new Uint8Array(q);
            const Ue = [], Ie = ee.decoder, Ee = ee.contextCache.getContexts("GB");
            let et = 0, qe, tt, ft, Te = 0, je, Ze;
            for (let Me = 0; Me < N; Me++) {
              if (D) {
                const at = Ie.readBit(Ee, He);
                if (et ^= at, et) {
                  Ue.push(Qe);
                  continue;
                }
              }
              for (Qe = new Uint8Array(Qe), Ue.push(Qe), qe = 0; qe < q; qe++) {
                if ($ && ne[Me][qe]) {
                  Qe[qe] = 0;
                  continue;
                }
                if (qe >= Ce && qe < Le && Me >= ve)
                  for (Te = Te << 1 & de, Se = 0; Se < ke; Se++)
                    tt = Me + _e[Se], ft = qe + ye[Se], je = Ue[tt][ft], je && (je = we[Se], Te |= je);
                else
                  for (Te = 0, Ze = H - 1, Se = 0; Se < H; Se++, Ze--)
                    ft = qe + ie[Se], ft >= 0 && ft < q && (tt = Me + ue[Se], tt >= 0 && (je = Ue[tt][ft], je && (Te |= je << Ze)));
                const at = Ie.readBit(Ee, Te);
                Qe[qe] = at;
              }
            }
            return Ue;
          }
          function _(se, q, N, Q, D, ne, oe, ee, $) {
            let E = n[N].coding;
            N === 0 && (E = E.concat([ee[0]]));
            const H = E.length, ie = new Int32Array(H), ue = new Int32Array(H);
            let fe;
            for (fe = 0; fe < H; fe++)
              ie[fe] = E[fe].x, ue[fe] = E[fe].y;
            let de = n[N].reference;
            N === 0 && (de = de.concat([ee[1]]));
            const pe = de.length, xe = new Int32Array(pe), De = new Int32Array(pe);
            for (fe = 0; fe < pe; fe++)
              xe[fe] = de[fe].x, De[fe] = de[fe].y;
            const Ae = Q[0].length, Se = Q.length, ke = l[N], ye = [], _e = $.decoder, we = $.contextCache.getContexts("GR");
            let Ce = 0;
            for (let ve = 0; ve < q; ve++) {
              if (oe) {
                const He = _e.readBit(we, ke);
                if (Ce ^= He, Ce)
                  throw new e("prediction is not supported");
              }
              const Le = new Uint8Array(se);
              ye.push(Le);
              for (let He = 0; He < se; He++) {
                let Qe, Ue, Ie = 0;
                for (fe = 0; fe < H; fe++)
                  Qe = ve + ue[fe], Ue = He + ie[fe], Qe < 0 || Ue < 0 || Ue >= se ? Ie <<= 1 : Ie = Ie << 1 | ye[Qe][Ue];
                for (fe = 0; fe < pe; fe++)
                  Qe = ve + De[fe] - ne, Ue = He + xe[fe] - D, Qe < 0 || Qe >= Se || Ue < 0 || Ue >= Ae ? Ie <<= 1 : Ie = Ie << 1 | Q[Qe][Ue];
                const Ee = _e.readBit(we, Ie);
                Le[He] = Ee;
              }
            }
            return ye;
          }
          function b(se, q, N, Q, D, ne, oe, ee, $, E, H, ie) {
            if (se && q)
              throw new e("symbol refinement with Huffman is not supported");
            const ue = [];
            let fe = 0, de = (0, a.log2)(N.length + Q);
            const pe = H.decoder, xe = H.contextCache;
            let De, Ae;
            for (se && (De = V(1), Ae = [], de = Math.max(de, 1)); ue.length < Q; ) {
              const ve = se ? ne.tableDeltaHeight.decode(ie) : d(xe, "IADH", pe);
              fe += ve;
              let Le = 0, He = 0;
              const Qe = se ? Ae.length : 0;
              for (; ; ) {
                const Ue = se ? ne.tableDeltaWidth.decode(ie) : d(xe, "IADW", pe);
                if (Ue === null)
                  break;
                Le += Ue, He += Le;
                let Ie;
                if (q) {
                  const Ee = d(xe, "IAAI", pe);
                  if (Ee > 1)
                    Ie = A(se, q, Le, fe, 0, Ee, 1, N.concat(ue), de, 0, 0, 1, 0, ne, $, E, H, 0, ie);
                  else {
                    const et = p(xe, pe, de), qe = d(xe, "IARDX", pe), tt = d(xe, "IARDY", pe), ft = et < N.length ? N[et] : ue[et - N.length];
                    Ie = _(Le, fe, $, ft, qe, tt, !1, E, H);
                  }
                  ue.push(Ie);
                } else
                  se ? Ae.push(Le) : (Ie = w(!1, Le, fe, oe, !1, null, ee, H), ue.push(Ie));
              }
              if (se && !q) {
                const Ue = ne.tableBitmapSize.decode(ie);
                ie.byteAlign();
                let Ie;
                if (Ue === 0)
                  Ie = L(ie, He, fe);
                else {
                  const et = ie.end, qe = ie.position + Ue;
                  ie.end = qe, Ie = K(ie, He, fe, !1), ie.end = et, ie.position = qe;
                }
                const Ee = Ae.length;
                if (Qe === Ee - 1)
                  ue.push(Ie);
                else {
                  let et, qe, tt = 0, ft, Te, je;
                  for (et = Qe; et < Ee; et++) {
                    for (Te = Ae[et], ft = tt + Te, je = [], qe = 0; qe < fe; qe++)
                      je.push(Ie[qe].subarray(tt, ft));
                    ue.push(je), tt = ft;
                  }
                }
              }
            }
            const Se = [], ke = [];
            let ye = !1, _e, we;
            const Ce = N.length + Q;
            for (; ke.length < Ce; ) {
              let ve = se ? De.decode(ie) : d(xe, "IAEX", pe);
              for (; ve--; )
                ke.push(ye);
              ye = !ye;
            }
            for (_e = 0, we = N.length; _e < we; _e++)
              ke[_e] && Se.push(N[_e]);
            for (let ve = 0; ve < Q; _e++, ve++)
              ke[_e] && Se.push(ue[ve]);
            return Se;
          }
          function A(se, q, N, Q, D, ne, oe, ee, $, E, H, ie, ue, fe, de, pe, xe, De, Ae) {
            if (se && q)
              throw new e("refinement with Huffman is not supported");
            const Se = [];
            let ke, ye;
            for (ke = 0; ke < Q; ke++) {
              if (ye = new Uint8Array(N), D)
                for (let Le = 0; Le < N; Le++)
                  ye[Le] = D;
              Se.push(ye);
            }
            const _e = xe.decoder, we = xe.contextCache;
            let Ce = se ? -fe.tableDeltaT.decode(Ae) : -d(we, "IADT", _e), ve = 0;
            for (ke = 0; ke < ne; ) {
              const Le = se ? fe.tableDeltaT.decode(Ae) : d(we, "IADT", _e);
              Ce += Le;
              const He = se ? fe.tableFirstS.decode(Ae) : d(we, "IAFS", _e);
              ve += He;
              let Qe = ve;
              do {
                let Ue = 0;
                oe > 1 && (Ue = se ? Ae.readBits(De) : d(we, "IAIT", _e));
                const Ie = oe * Ce + Ue, Ee = se ? fe.symbolIDTable.decode(Ae) : p(we, _e, $), et = q && (se ? Ae.readBit() : d(we, "IARI", _e));
                let qe = ee[Ee], tt = qe[0].length, ft = qe.length;
                if (et) {
                  const xt = d(we, "IARDW", _e), ut = d(we, "IARDH", _e), yt = d(we, "IARDX", _e), ht = d(we, "IARDY", _e);
                  tt += xt, ft += ut, qe = _(tt, ft, de, qe, (xt >> 1) + yt, (ut >> 1) + ht, !1, pe, xe);
                }
                const Te = Ie - (ie & 1 ? 0 : ft - 1), je = Qe - (ie & 2 ? tt - 1 : 0);
                let Ze, Me, at;
                if (E) {
                  for (Ze = 0; Ze < ft; Ze++) {
                    if (ye = Se[je + Ze], !ye)
                      continue;
                    at = qe[Ze];
                    const xt = Math.min(N - Te, tt);
                    switch (ue) {
                      case 0:
                        for (Me = 0; Me < xt; Me++)
                          ye[Te + Me] |= at[Me];
                        break;
                      case 2:
                        for (Me = 0; Me < xt; Me++)
                          ye[Te + Me] ^= at[Me];
                        break;
                      default:
                        throw new e(`operator ${ue} is not supported`);
                    }
                  }
                  Qe += ft - 1;
                } else {
                  for (Me = 0; Me < ft; Me++)
                    if (ye = Se[Te + Me], !!ye)
                      switch (at = qe[Me], ue) {
                        case 0:
                          for (Ze = 0; Ze < tt; Ze++)
                            ye[je + Ze] |= at[Ze];
                          break;
                        case 2:
                          for (Ze = 0; Ze < tt; Ze++)
                            ye[je + Ze] ^= at[Ze];
                          break;
                        default:
                          throw new e(`operator ${ue} is not supported`);
                      }
                  Qe += tt - 1;
                }
                ke++;
                const rt = se ? fe.tableDeltaS.decode(Ae) : d(we, "IADS", _e);
                if (rt === null)
                  break;
                Qe += rt + H;
              } while (!0);
            }
            return Se;
          }
          function Y(se, q, N, Q, D, ne) {
            const oe = [];
            se || (oe.push({
              x: -q,
              y: 0
            }), D === 0 && oe.push({
              x: -3,
              y: -1
            }, {
              x: 2,
              y: -2
            }, {
              x: -2,
              y: -2
            }));
            const ee = (Q + 1) * q, $ = w(se, ee, N, D, !1, null, oe, ne), E = [];
            for (let H = 0; H <= Q; H++) {
              const ie = [], ue = q * H, fe = ue + q;
              for (let de = 0; de < N; de++)
                ie.push($[de].subarray(ue, fe));
              E.push(ie);
            }
            return E;
          }
          function j(se, q, N, Q, D, ne, oe, ee, $, E, H, ie, ue, fe, de) {
            if (oe)
              throw new e("skip is not supported");
            if (ee !== 0)
              throw new e(`operator "${ee}" is not supported in halftone region`);
            const xe = [];
            let De, Ae, Se;
            for (De = 0; De < D; De++) {
              if (Se = new Uint8Array(Q), ne)
                for (Ae = 0; Ae < Q; Ae++)
                  Se[Ae] = ne;
              xe.push(Se);
            }
            const ke = q.length, ye = q[0], _e = ye[0].length, we = ye.length, Ce = (0, a.log2)(ke), ve = [];
            se || (ve.push({
              x: N <= 1 ? 3 : 2,
              y: -1
            }), N === 0 && ve.push({
              x: -3,
              y: -1
            }, {
              x: 2,
              y: -2
            }, {
              x: -2,
              y: -2
            }));
            const Le = [];
            let He, Qe;
            for (se && (He = new J(de.data, de.start, de.end)), De = Ce - 1; De >= 0; De--)
              se ? Qe = K(He, $, E, !0) : Qe = w(!1, $, E, N, !1, null, ve, de), Le[De] = Qe;
            let Ue, Ie, Ee, et, qe, tt, ft, Te, je;
            for (Ue = 0; Ue < E; Ue++)
              for (Ie = 0; Ie < $; Ie++) {
                for (Ee = 0, et = 0, Ae = Ce - 1; Ae >= 0; Ae--)
                  Ee ^= Le[Ae][Ue][Ie], et |= Ee << Ae;
                if (qe = q[et], tt = H + Ue * fe + Ie * ue >> 8, ft = ie + Ue * ue - Ie * fe >> 8, tt >= 0 && tt + _e <= Q && ft >= 0 && ft + we <= D)
                  for (De = 0; De < we; De++)
                    for (je = xe[ft + De], Te = qe[De], Ae = 0; Ae < _e; Ae++)
                      je[tt + Ae] |= Te[Ae];
                else {
                  let Ze, Me;
                  for (De = 0; De < we; De++)
                    if (Me = ft + De, !(Me < 0 || Me >= D))
                      for (je = xe[Me], Te = qe[De], Ae = 0; Ae < _e; Ae++)
                        Ze = tt + Ae, Ze >= 0 && Ze < Q && (je[Ze] |= Te[Ae]);
                }
              }
            return xe;
          }
          function X(se, q) {
            const N = {};
            N.number = (0, a.readUint32)(se, q);
            const Q = se[q + 4], D = Q & 63;
            if (!m[D])
              throw new e("invalid segment type: " + D);
            N.type = D, N.typeName = m[D], N.deferredNonRetain = !!(Q & 128);
            const ne = !!(Q & 64), oe = se[q + 5];
            let ee = oe >> 5 & 7;
            const $ = [oe & 31];
            let E = q + 6;
            if (oe === 7) {
              ee = (0, a.readUint32)(se, E - 1) & 536870911, E += 3;
              let de = ee + 7 >> 3;
              for ($[0] = se[E++]; --de > 0; )
                $.push(se[E++]);
            } else if (oe === 5 || oe === 6)
              throw new e("invalid referred-to flags");
            N.retainBits = $;
            let H = 4;
            N.number <= 256 ? H = 1 : N.number <= 65536 && (H = 2);
            const ie = [];
            let ue, fe;
            for (ue = 0; ue < ee; ue++) {
              let de;
              H === 1 ? de = se[E] : H === 2 ? de = (0, a.readUint16)(se, E) : de = (0, a.readUint32)(se, E), ie.push(de), E += H;
            }
            if (N.referredTo = ie, ne ? (N.pageAssociation = (0, a.readUint32)(se, E), E += 4) : N.pageAssociation = se[E++], N.length = (0, a.readUint32)(se, E), E += 4, N.length === 4294967295)
              if (D === 38) {
                const de = R(se, E), xe = !!(se[E + k] & 1), De = 6, Ae = new Uint8Array(De);
                for (xe || (Ae[0] = 255, Ae[1] = 172), Ae[2] = de.height >>> 24 & 255, Ae[3] = de.height >> 16 & 255, Ae[4] = de.height >> 8 & 255, Ae[5] = de.height & 255, ue = E, fe = se.length; ue < fe; ue++) {
                  let Se = 0;
                  for (; Se < De && Ae[Se] === se[ue + Se]; )
                    Se++;
                  if (Se === De) {
                    N.length = ue + De;
                    break;
                  }
                }
                if (N.length === 4294967295)
                  throw new e("segment end was not found");
              } else
                throw new e("invalid unknown segment length");
            return N.headerEnd = E, N;
          }
          function B(se, q, N, Q) {
            const D = [];
            let ne = N;
            for (; ne < Q; ) {
              const oe = X(q, ne);
              ne = oe.headerEnd;
              const ee = {
                header: oe,
                data: q
              };
              if (se.randomAccess || (ee.start = ne, ne += oe.length, ee.end = ne), D.push(ee), oe.type === 51)
                break;
            }
            if (se.randomAccess)
              for (let oe = 0, ee = D.length; oe < ee; oe++)
                D[oe].start = ne, ne += D[oe].header.length, D[oe].end = ne;
            return D;
          }
          function R(se, q) {
            return {
              width: (0, a.readUint32)(se, q),
              height: (0, a.readUint32)(se, q + 4),
              x: (0, a.readUint32)(se, q + 8),
              y: (0, a.readUint32)(se, q + 12),
              combinationOperator: se[q + 16] & 7
            };
          }
          const k = 17;
          function x(se, q) {
            const N = se.header, Q = se.data, D = se.end;
            let ne = se.start, oe, ee, $, E;
            switch (N.type) {
              case 0:
                const ie = {}, ue = (0, a.readUint16)(Q, ne);
                if (ie.huffman = !!(ue & 1), ie.refinement = !!(ue & 2), ie.huffmanDHSelector = ue >> 2 & 3, ie.huffmanDWSelector = ue >> 4 & 3, ie.bitmapSizeSelector = ue >> 6 & 1, ie.aggregationInstancesSelector = ue >> 7 & 1, ie.bitmapCodingContextUsed = !!(ue & 256), ie.bitmapCodingContextRetained = !!(ue & 512), ie.template = ue >> 10 & 3, ie.refinementTemplate = ue >> 12 & 1, ne += 2, !ie.huffman) {
                  for (E = ie.template === 0 ? 4 : 1, ee = [], $ = 0; $ < E; $++)
                    ee.push({
                      x: (0, a.readInt8)(Q, ne),
                      y: (0, a.readInt8)(Q, ne + 1)
                    }), ne += 2;
                  ie.at = ee;
                }
                if (ie.refinement && !ie.refinementTemplate) {
                  for (ee = [], $ = 0; $ < 2; $++)
                    ee.push({
                      x: (0, a.readInt8)(Q, ne),
                      y: (0, a.readInt8)(Q, ne + 1)
                    }), ne += 2;
                  ie.refinementAt = ee;
                }
                ie.numberOfExportedSymbols = (0, a.readUint32)(Q, ne), ne += 4, ie.numberOfNewSymbols = (0, a.readUint32)(Q, ne), ne += 4, oe = [ie, N.number, N.referredTo, Q, ne, D];
                break;
              case 6:
              case 7:
                const fe = {};
                fe.info = R(Q, ne), ne += k;
                const de = (0, a.readUint16)(Q, ne);
                if (ne += 2, fe.huffman = !!(de & 1), fe.refinement = !!(de & 2), fe.logStripSize = de >> 2 & 3, fe.stripSize = 1 << fe.logStripSize, fe.referenceCorner = de >> 4 & 3, fe.transposed = !!(de & 64), fe.combinationOperator = de >> 7 & 3, fe.defaultPixelValue = de >> 9 & 1, fe.dsOffset = de << 17 >> 27, fe.refinementTemplate = de >> 15 & 1, fe.huffman) {
                  const we = (0, a.readUint16)(Q, ne);
                  ne += 2, fe.huffmanFS = we & 3, fe.huffmanDS = we >> 2 & 3, fe.huffmanDT = we >> 4 & 3, fe.huffmanRefinementDW = we >> 6 & 3, fe.huffmanRefinementDH = we >> 8 & 3, fe.huffmanRefinementDX = we >> 10 & 3, fe.huffmanRefinementDY = we >> 12 & 3, fe.huffmanRefinementSizeSelector = !!(we & 16384);
                }
                if (fe.refinement && !fe.refinementTemplate) {
                  for (ee = [], $ = 0; $ < 2; $++)
                    ee.push({
                      x: (0, a.readInt8)(Q, ne),
                      y: (0, a.readInt8)(Q, ne + 1)
                    }), ne += 2;
                  fe.refinementAt = ee;
                }
                fe.numberOfSymbolInstances = (0, a.readUint32)(Q, ne), ne += 4, oe = [fe, N.referredTo, Q, ne, D];
                break;
              case 16:
                const pe = {}, xe = Q[ne++];
                pe.mmr = !!(xe & 1), pe.template = xe >> 1 & 3, pe.patternWidth = Q[ne++], pe.patternHeight = Q[ne++], pe.maxPatternIndex = (0, a.readUint32)(Q, ne), ne += 4, oe = [pe, N.number, Q, ne, D];
                break;
              case 22:
              case 23:
                const De = {};
                De.info = R(Q, ne), ne += k;
                const Ae = Q[ne++];
                De.mmr = !!(Ae & 1), De.template = Ae >> 1 & 3, De.enableSkip = !!(Ae & 8), De.combinationOperator = Ae >> 4 & 7, De.defaultPixelValue = Ae >> 7 & 1, De.gridWidth = (0, a.readUint32)(Q, ne), ne += 4, De.gridHeight = (0, a.readUint32)(Q, ne), ne += 4, De.gridOffsetX = (0, a.readUint32)(Q, ne) & 4294967295, ne += 4, De.gridOffsetY = (0, a.readUint32)(Q, ne) & 4294967295, ne += 4, De.gridVectorX = (0, a.readUint16)(Q, ne), ne += 2, De.gridVectorY = (0, a.readUint16)(Q, ne), ne += 2, oe = [De, N.referredTo, Q, ne, D];
                break;
              case 38:
              case 39:
                const Se = {};
                Se.info = R(Q, ne), ne += k;
                const ke = Q[ne++];
                if (Se.mmr = !!(ke & 1), Se.template = ke >> 1 & 3, Se.prediction = !!(ke & 8), !Se.mmr) {
                  for (E = Se.template === 0 ? 4 : 1, ee = [], $ = 0; $ < E; $++)
                    ee.push({
                      x: (0, a.readInt8)(Q, ne),
                      y: (0, a.readInt8)(Q, ne + 1)
                    }), ne += 2;
                  Se.at = ee;
                }
                oe = [Se, Q, ne, D];
                break;
              case 48:
                const ye = {
                  width: (0, a.readUint32)(Q, ne),
                  height: (0, a.readUint32)(Q, ne + 4),
                  resolutionX: (0, a.readUint32)(Q, ne + 8),
                  resolutionY: (0, a.readUint32)(Q, ne + 12)
                };
                ye.height === 4294967295 && delete ye.height;
                const _e = Q[ne + 16];
                (0, a.readUint16)(Q, ne + 17), ye.lossless = !!(_e & 1), ye.refinement = !!(_e & 2), ye.defaultPixelValue = _e >> 2 & 1, ye.combinationOperator = _e >> 3 & 3, ye.requiresBuffer = !!(_e & 32), ye.combinationOperatorOverride = !!(_e & 64), oe = [ye];
                break;
              case 49:
                break;
              case 50:
                break;
              case 51:
                break;
              case 53:
                oe = [N.number, Q, ne, D];
                break;
              case 62:
                break;
              default:
                throw new e(`segment type ${N.typeName}(${N.type}) is not implemented`);
            }
            const H = "on" + N.typeName;
            H in q && q[H].apply(q, oe);
          }
          function f(se, q) {
            for (let N = 0, Q = se.length; N < Q; N++)
              x(se[N], q);
          }
          function U(se) {
            const q = new O();
            for (let N = 0, Q = se.length; N < Q; N++) {
              const D = se[N], ne = B({}, D.data, D.start, D.end);
              f(ne, q);
            }
            return q.buffer;
          }
          class O {
            onPageInformation(q) {
              this.currentPageInfo = q;
              const N = q.width + 7 >> 3, Q = new Uint8ClampedArray(N * q.height);
              q.defaultPixelValue && Q.fill(255), this.buffer = Q;
            }
            drawBitmap(q, N) {
              const Q = this.currentPageInfo, D = q.width, ne = q.height, oe = Q.width + 7 >> 3, ee = Q.combinationOperatorOverride ? q.combinationOperator : Q.combinationOperator, $ = this.buffer, E = 128 >> (q.x & 7);
              let H = q.y * oe + (q.x >> 3), ie, ue, fe, de;
              switch (ee) {
                case 0:
                  for (ie = 0; ie < ne; ie++) {
                    for (fe = E, de = H, ue = 0; ue < D; ue++)
                      N[ie][ue] && ($[de] |= fe), fe >>= 1, fe || (fe = 128, de++);
                    H += oe;
                  }
                  break;
                case 2:
                  for (ie = 0; ie < ne; ie++) {
                    for (fe = E, de = H, ue = 0; ue < D; ue++)
                      N[ie][ue] && ($[de] ^= fe), fe >>= 1, fe || (fe = 128, de++);
                    H += oe;
                  }
                  break;
                default:
                  throw new e(`operator ${ee} is not supported`);
              }
            }
            onImmediateGenericRegion(q, N, Q, D) {
              const ne = q.info, oe = new c(N, Q, D), ee = w(q.mmr, ne.width, ne.height, q.template, q.prediction, null, q.at, oe);
              this.drawBitmap(ne, ee);
            }
            onImmediateLosslessGenericRegion() {
              this.onImmediateGenericRegion(...arguments);
            }
            onSymbolDictionary(q, N, Q, D, ne, oe) {
              let ee, $;
              q.huffman && (ee = G(q, Q, this.customTables), $ = new J(D, ne, oe));
              let E = this.symbols;
              E || (this.symbols = E = {});
              const H = [];
              for (const ue of Q) {
                const fe = E[ue];
                fe && H.push(...fe);
              }
              const ie = new c(D, ne, oe);
              E[N] = b(q.huffman, q.refinement, H, q.numberOfNewSymbols, q.numberOfExportedSymbols, ee, q.template, q.at, q.refinementTemplate, q.refinementAt, ie, $);
            }
            onImmediateTextRegion(q, N, Q, D, ne) {
              const oe = q.info;
              let ee, $;
              const E = this.symbols, H = [];
              for (const de of N) {
                const pe = E[de];
                pe && H.push(...pe);
              }
              const ie = (0, a.log2)(H.length);
              q.huffman && ($ = new J(Q, D, ne), ee = z(q, N, this.customTables, H.length, $));
              const ue = new c(Q, D, ne), fe = A(q.huffman, q.refinement, oe.width, oe.height, q.defaultPixelValue, q.numberOfSymbolInstances, q.stripSize, H, ie, q.transposed, q.dsOffset, q.referenceCorner, q.combinationOperator, ee, q.refinementTemplate, q.refinementAt, ue, q.logStripSize, $);
              this.drawBitmap(oe, fe);
            }
            onImmediateLosslessTextRegion() {
              this.onImmediateTextRegion(...arguments);
            }
            onPatternDictionary(q, N, Q, D, ne) {
              let oe = this.patterns;
              oe || (this.patterns = oe = {});
              const ee = new c(Q, D, ne);
              oe[N] = Y(q.mmr, q.patternWidth, q.patternHeight, q.maxPatternIndex, q.template, ee);
            }
            onImmediateHalftoneRegion(q, N, Q, D, ne) {
              const oe = this.patterns[N[0]], ee = q.info, $ = new c(Q, D, ne), E = j(q.mmr, oe, q.template, ee.width, ee.height, q.defaultPixelValue, q.enableSkip, q.combinationOperator, q.gridWidth, q.gridHeight, q.gridOffsetX, q.gridOffsetY, q.gridVectorX, q.gridVectorY, $);
              this.drawBitmap(ee, E);
            }
            onImmediateLosslessHalftoneRegion() {
              this.onImmediateHalftoneRegion(...arguments);
            }
            onTables(q, N, Q, D) {
              let ne = this.customTables;
              ne || (this.customTables = ne = {}), ne[q] = I(N, Q, D);
            }
          }
          class S {
            constructor(q) {
              q.length === 2 ? (this.isOOB = !0, this.rangeLow = 0, this.prefixLength = q[0], this.rangeLength = 0, this.prefixCode = q[1], this.isLowerRange = !1) : (this.isOOB = !1, this.rangeLow = q[0], this.prefixLength = q[1], this.rangeLength = q[2], this.prefixCode = q[3], this.isLowerRange = q[4] === "lower");
            }
          }
          class F {
            constructor(q) {
              this.children = [], q ? (this.isLeaf = !0, this.rangeLength = q.rangeLength, this.rangeLow = q.rangeLow, this.isLowerRange = q.isLowerRange, this.isOOB = q.isOOB) : this.isLeaf = !1;
            }
            buildTree(q, N) {
              const Q = q.prefixCode >> N & 1;
              if (N <= 0)
                this.children[Q] = new F(q);
              else {
                let D = this.children[Q];
                D || (this.children[Q] = D = new F(null)), D.buildTree(q, N - 1);
              }
            }
            decodeNode(q) {
              if (this.isLeaf) {
                if (this.isOOB)
                  return null;
                const Q = q.readBits(this.rangeLength);
                return this.rangeLow + (this.isLowerRange ? -Q : Q);
              }
              const N = this.children[q.readBit()];
              if (!N)
                throw new e("invalid Huffman data");
              return N.decodeNode(q);
            }
          }
          class T {
            constructor(q, N) {
              N || this.assignPrefixCodes(q), this.rootNode = new F(null);
              for (let Q = 0, D = q.length; Q < D; Q++) {
                const ne = q[Q];
                ne.prefixLength > 0 && this.rootNode.buildTree(ne, ne.prefixLength - 1);
              }
            }
            decode(q) {
              return this.rootNode.decodeNode(q);
            }
            assignPrefixCodes(q) {
              const N = q.length;
              let Q = 0;
              for (let H = 0; H < N; H++)
                Q = Math.max(Q, q[H].prefixLength);
              const D = new Uint32Array(Q + 1);
              for (let H = 0; H < N; H++)
                D[q[H].prefixLength]++;
              let ne = 1, oe = 0, ee, $, E;
              for (D[0] = 0; ne <= Q; ) {
                for (oe = oe + D[ne - 1] << 1, ee = oe, $ = 0; $ < N; )
                  E = q[$], E.prefixLength === ne && (E.prefixCode = ee, ee++), $++;
                ne++;
              }
            }
          }
          function I(se, q, N) {
            const Q = se[q], D = (0, a.readUint32)(se, q + 1) & 4294967295, ne = (0, a.readUint32)(se, q + 5) & 4294967295, oe = new J(se, q + 9, N), ee = (Q >> 1 & 7) + 1, $ = (Q >> 4 & 7) + 1, E = [];
            let H, ie, ue = D;
            do
              H = oe.readBits(ee), ie = oe.readBits($), E.push(new S([ue, H, ie, 0])), ue += 1 << ie;
            while (ue < ne);
            return H = oe.readBits(ee), E.push(new S([D - 1, H, 32, 0, "lower"])), H = oe.readBits(ee), E.push(new S([ne, H, 32, 0])), Q & 1 && (H = oe.readBits(ee), E.push(new S([H, 0]))), new T(E, !1);
          }
          const M = {};
          function V(se) {
            let q = M[se];
            if (q)
              return q;
            let N;
            switch (se) {
              case 1:
                N = [[0, 1, 4, 0], [16, 2, 8, 2], [272, 3, 16, 6], [65808, 3, 32, 7]];
                break;
              case 2:
                N = [[0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [75, 6, 32, 62], [6, 63]];
                break;
              case 3:
                N = [[-256, 8, 8, 254], [0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [-257, 8, 32, 255, "lower"], [75, 7, 32, 126], [6, 62]];
                break;
              case 4:
                N = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [76, 5, 32, 31]];
                break;
              case 5:
                N = [[-255, 7, 8, 126], [1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [-256, 7, 32, 127, "lower"], [76, 6, 32, 62]];
                break;
              case 6:
                N = [[-2048, 5, 10, 28], [-1024, 4, 9, 8], [-512, 4, 8, 9], [-256, 4, 7, 10], [-128, 5, 6, 29], [-64, 5, 5, 30], [-32, 4, 5, 11], [0, 2, 7, 0], [128, 3, 7, 2], [256, 3, 8, 3], [512, 4, 9, 12], [1024, 4, 10, 13], [-2049, 6, 32, 62, "lower"], [2048, 6, 32, 63]];
                break;
              case 7:
                N = [[-1024, 4, 9, 8], [-512, 3, 8, 0], [-256, 4, 7, 9], [-128, 5, 6, 26], [-64, 5, 5, 27], [-32, 4, 5, 10], [0, 4, 5, 11], [32, 5, 5, 28], [64, 5, 6, 29], [128, 4, 7, 12], [256, 3, 8, 1], [512, 3, 9, 2], [1024, 3, 10, 3], [-1025, 5, 32, 30, "lower"], [2048, 5, 32, 31]];
                break;
              case 8:
                N = [[-15, 8, 3, 252], [-7, 9, 1, 508], [-5, 8, 1, 253], [-3, 9, 0, 509], [-2, 7, 0, 124], [-1, 4, 0, 10], [0, 2, 1, 0], [2, 5, 0, 26], [3, 6, 0, 58], [4, 3, 4, 4], [20, 6, 1, 59], [22, 4, 4, 11], [38, 4, 5, 12], [70, 5, 6, 27], [134, 5, 7, 28], [262, 6, 7, 60], [390, 7, 8, 125], [646, 6, 10, 61], [-16, 9, 32, 510, "lower"], [1670, 9, 32, 511], [2, 1]];
                break;
              case 9:
                N = [[-31, 8, 4, 252], [-15, 9, 2, 508], [-11, 8, 2, 253], [-7, 9, 1, 509], [-5, 7, 1, 124], [-3, 4, 1, 10], [-1, 3, 1, 2], [1, 3, 1, 3], [3, 5, 1, 26], [5, 6, 1, 58], [7, 3, 5, 4], [39, 6, 2, 59], [43, 4, 5, 11], [75, 4, 6, 12], [139, 5, 7, 27], [267, 5, 8, 28], [523, 6, 8, 60], [779, 7, 9, 125], [1291, 6, 11, 61], [-32, 9, 32, 510, "lower"], [3339, 9, 32, 511], [2, 0]];
                break;
              case 10:
                N = [[-21, 7, 4, 122], [-5, 8, 0, 252], [-4, 7, 0, 123], [-3, 5, 0, 24], [-2, 2, 2, 0], [2, 5, 0, 25], [3, 6, 0, 54], [4, 7, 0, 124], [5, 8, 0, 253], [6, 2, 6, 1], [70, 5, 5, 26], [102, 6, 5, 55], [134, 6, 6, 56], [198, 6, 7, 57], [326, 6, 8, 58], [582, 6, 9, 59], [1094, 6, 10, 60], [2118, 7, 11, 125], [-22, 8, 32, 254, "lower"], [4166, 8, 32, 255], [2, 2]];
                break;
              case 11:
                N = [[1, 1, 0, 0], [2, 2, 1, 2], [4, 4, 0, 12], [5, 4, 1, 13], [7, 5, 1, 28], [9, 5, 2, 29], [13, 6, 2, 60], [17, 7, 2, 122], [21, 7, 3, 123], [29, 7, 4, 124], [45, 7, 5, 125], [77, 7, 6, 126], [141, 7, 32, 127]];
                break;
              case 12:
                N = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 1, 6], [5, 5, 0, 28], [6, 5, 1, 29], [8, 6, 1, 60], [10, 7, 0, 122], [11, 7, 1, 123], [13, 7, 2, 124], [17, 7, 3, 125], [25, 7, 4, 126], [41, 8, 5, 254], [73, 8, 32, 255]];
                break;
              case 13:
                N = [[1, 1, 0, 0], [2, 3, 0, 4], [3, 4, 0, 12], [4, 5, 0, 28], [5, 4, 1, 13], [7, 3, 3, 5], [15, 6, 1, 58], [17, 6, 2, 59], [21, 6, 3, 60], [29, 6, 4, 61], [45, 6, 5, 62], [77, 7, 6, 126], [141, 7, 32, 127]];
                break;
              case 14:
                N = [[-2, 3, 0, 4], [-1, 3, 0, 5], [0, 1, 0, 0], [1, 3, 0, 6], [2, 3, 0, 7]];
                break;
              case 15:
                N = [[-24, 7, 4, 124], [-8, 6, 2, 60], [-4, 5, 1, 28], [-2, 4, 0, 12], [-1, 3, 0, 4], [0, 1, 0, 0], [1, 3, 0, 5], [2, 4, 0, 13], [3, 5, 1, 29], [5, 6, 2, 61], [9, 7, 4, 125], [-25, 7, 32, 126, "lower"], [25, 7, 32, 127]];
                break;
              default:
                throw new e(`standard table B.${se} does not exist`);
            }
            for (let Q = 0, D = N.length; Q < D; Q++)
              N[Q] = new S(N[Q]);
            return q = new T(N, !0), M[se] = q, q;
          }
          class J {
            constructor(q, N, Q) {
              this.data = q, this.start = N, this.end = Q, this.position = N, this.shift = -1, this.currentByte = 0;
            }
            readBit() {
              if (this.shift < 0) {
                if (this.position >= this.end)
                  throw new e("end of data while reading bit");
                this.currentByte = this.data[this.position++], this.shift = 7;
              }
              const q = this.currentByte >> this.shift & 1;
              return this.shift--, q;
            }
            readBits(q) {
              let N = 0, Q;
              for (Q = q - 1; Q >= 0; Q--)
                N |= this.readBit() << Q;
              return N;
            }
            byteAlign() {
              this.shift = -1;
            }
            next() {
              return this.position >= this.end ? -1 : this.data[this.position++];
            }
          }
          function W(se, q, N) {
            let Q = 0;
            for (let D = 0, ne = q.length; D < ne; D++) {
              const oe = N[q[D]];
              if (oe) {
                if (se === Q)
                  return oe;
                Q++;
              }
            }
            throw new e("can't find custom Huffman table");
          }
          function z(se, q, N, Q, D) {
            const ne = [];
            for (let ue = 0; ue <= 34; ue++) {
              const fe = D.readBits(4);
              ne.push(new S([ue, fe, 0, 0]));
            }
            const oe = new T(ne, !1);
            ne.length = 0;
            for (let ue = 0; ue < Q; ) {
              const fe = oe.decode(D);
              if (fe >= 32) {
                let de, pe, xe;
                switch (fe) {
                  case 32:
                    if (ue === 0)
                      throw new e("no previous value in symbol ID table");
                    pe = D.readBits(2) + 3, de = ne[ue - 1].prefixLength;
                    break;
                  case 33:
                    pe = D.readBits(3) + 3, de = 0;
                    break;
                  case 34:
                    pe = D.readBits(7) + 11, de = 0;
                    break;
                  default:
                    throw new e("invalid code length in symbol ID table");
                }
                for (xe = 0; xe < pe; xe++)
                  ne.push(new S([ue, de, 0, 0])), ue++;
              } else
                ne.push(new S([ue, fe, 0, 0])), ue++;
            }
            D.byteAlign();
            const ee = new T(ne, !1);
            let $ = 0, E, H, ie;
            switch (se.huffmanFS) {
              case 0:
              case 1:
                E = V(se.huffmanFS + 6);
                break;
              case 3:
                E = W($, q, N), $++;
                break;
              default:
                throw new e("invalid Huffman FS selector");
            }
            switch (se.huffmanDS) {
              case 0:
              case 1:
              case 2:
                H = V(se.huffmanDS + 8);
                break;
              case 3:
                H = W($, q, N), $++;
                break;
              default:
                throw new e("invalid Huffman DS selector");
            }
            switch (se.huffmanDT) {
              case 0:
              case 1:
              case 2:
                ie = V(se.huffmanDT + 11);
                break;
              case 3:
                ie = W($, q, N), $++;
                break;
              default:
                throw new e("invalid Huffman DT selector");
            }
            if (se.refinement)
              throw new e("refinement with Huffman is not supported");
            return {
              symbolIDTable: ee,
              tableFirstS: E,
              tableDeltaS: H,
              tableDeltaT: ie
            };
          }
          function G(se, q, N) {
            let Q = 0, D, ne;
            switch (se.huffmanDHSelector) {
              case 0:
              case 1:
                D = V(se.huffmanDHSelector + 4);
                break;
              case 3:
                D = W(Q, q, N), Q++;
                break;
              default:
                throw new e("invalid Huffman DH selector");
            }
            switch (se.huffmanDWSelector) {
              case 0:
              case 1:
                ne = V(se.huffmanDWSelector + 2);
                break;
              case 3:
                ne = W(Q, q, N), Q++;
                break;
              default:
                throw new e("invalid Huffman DW selector");
            }
            let oe, ee;
            return se.bitmapSizeSelector ? (oe = W(Q, q, N), Q++) : oe = V(1), se.aggregationInstancesSelector ? ee = W(Q, q, N) : ee = V(1), {
              tableDeltaHeight: D,
              tableDeltaWidth: ne,
              tableBitmapSize: oe,
              tableAggregateInstances: ee
            };
          }
          function L(se, q, N) {
            const Q = [];
            for (let D = 0; D < N; D++) {
              const ne = new Uint8Array(q);
              Q.push(ne);
              for (let oe = 0; oe < q; oe++)
                ne[oe] = se.readBit();
              se.byteAlign();
            }
            return Q;
          }
          function K(se, q, N, Q) {
            const D = {
              K: -1,
              Columns: q,
              Rows: N,
              BlackIs1: !0,
              EndOfBlock: Q
            }, ne = new h.CCITTFaxDecoder(se, D), oe = [];
            let ee, $ = !1;
            for (let E = 0; E < N; E++) {
              const H = new Uint8Array(q);
              oe.push(H);
              let ie = -1;
              for (let ue = 0; ue < q; ue++)
                ie < 0 && (ee = ne.readNextChar(), ee === -1 && (ee = 0, $ = !0), ie = 7), H[ue] = ee >> ie & 1, ie--;
            }
            if (Q && !$)
              for (let H = 0; H < 5 && ne.readNextChar() !== -1; H++)
                ;
            return oe;
          }
          class te {
            parseChunks(q) {
              return U(q);
            }
            parse(q) {
              throw new Error("Not implemented: Jbig2Image.parse");
            }
          }
          o.Jbig2Image = te;
        },
        /* 26 */
        /***/
        (Z, o) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.ArithmeticDecoder = void 0;
          const C = [{
            qe: 22017,
            nmps: 1,
            nlps: 1,
            switchFlag: 1
          }, {
            qe: 13313,
            nmps: 2,
            nlps: 6,
            switchFlag: 0
          }, {
            qe: 6145,
            nmps: 3,
            nlps: 9,
            switchFlag: 0
          }, {
            qe: 2753,
            nmps: 4,
            nlps: 12,
            switchFlag: 0
          }, {
            qe: 1313,
            nmps: 5,
            nlps: 29,
            switchFlag: 0
          }, {
            qe: 545,
            nmps: 38,
            nlps: 33,
            switchFlag: 0
          }, {
            qe: 22017,
            nmps: 7,
            nlps: 6,
            switchFlag: 1
          }, {
            qe: 21505,
            nmps: 8,
            nlps: 14,
            switchFlag: 0
          }, {
            qe: 18433,
            nmps: 9,
            nlps: 14,
            switchFlag: 0
          }, {
            qe: 14337,
            nmps: 10,
            nlps: 14,
            switchFlag: 0
          }, {
            qe: 12289,
            nmps: 11,
            nlps: 17,
            switchFlag: 0
          }, {
            qe: 9217,
            nmps: 12,
            nlps: 18,
            switchFlag: 0
          }, {
            qe: 7169,
            nmps: 13,
            nlps: 20,
            switchFlag: 0
          }, {
            qe: 5633,
            nmps: 29,
            nlps: 21,
            switchFlag: 0
          }, {
            qe: 22017,
            nmps: 15,
            nlps: 14,
            switchFlag: 1
          }, {
            qe: 21505,
            nmps: 16,
            nlps: 14,
            switchFlag: 0
          }, {
            qe: 20737,
            nmps: 17,
            nlps: 15,
            switchFlag: 0
          }, {
            qe: 18433,
            nmps: 18,
            nlps: 16,
            switchFlag: 0
          }, {
            qe: 14337,
            nmps: 19,
            nlps: 17,
            switchFlag: 0
          }, {
            qe: 13313,
            nmps: 20,
            nlps: 18,
            switchFlag: 0
          }, {
            qe: 12289,
            nmps: 21,
            nlps: 19,
            switchFlag: 0
          }, {
            qe: 10241,
            nmps: 22,
            nlps: 19,
            switchFlag: 0
          }, {
            qe: 9217,
            nmps: 23,
            nlps: 20,
            switchFlag: 0
          }, {
            qe: 8705,
            nmps: 24,
            nlps: 21,
            switchFlag: 0
          }, {
            qe: 7169,
            nmps: 25,
            nlps: 22,
            switchFlag: 0
          }, {
            qe: 6145,
            nmps: 26,
            nlps: 23,
            switchFlag: 0
          }, {
            qe: 5633,
            nmps: 27,
            nlps: 24,
            switchFlag: 0
          }, {
            qe: 5121,
            nmps: 28,
            nlps: 25,
            switchFlag: 0
          }, {
            qe: 4609,
            nmps: 29,
            nlps: 26,
            switchFlag: 0
          }, {
            qe: 4353,
            nmps: 30,
            nlps: 27,
            switchFlag: 0
          }, {
            qe: 2753,
            nmps: 31,
            nlps: 28,
            switchFlag: 0
          }, {
            qe: 2497,
            nmps: 32,
            nlps: 29,
            switchFlag: 0
          }, {
            qe: 2209,
            nmps: 33,
            nlps: 30,
            switchFlag: 0
          }, {
            qe: 1313,
            nmps: 34,
            nlps: 31,
            switchFlag: 0
          }, {
            qe: 1089,
            nmps: 35,
            nlps: 32,
            switchFlag: 0
          }, {
            qe: 673,
            nmps: 36,
            nlps: 33,
            switchFlag: 0
          }, {
            qe: 545,
            nmps: 37,
            nlps: 34,
            switchFlag: 0
          }, {
            qe: 321,
            nmps: 38,
            nlps: 35,
            switchFlag: 0
          }, {
            qe: 273,
            nmps: 39,
            nlps: 36,
            switchFlag: 0
          }, {
            qe: 133,
            nmps: 40,
            nlps: 37,
            switchFlag: 0
          }, {
            qe: 73,
            nmps: 41,
            nlps: 38,
            switchFlag: 0
          }, {
            qe: 37,
            nmps: 42,
            nlps: 39,
            switchFlag: 0
          }, {
            qe: 21,
            nmps: 43,
            nlps: 40,
            switchFlag: 0
          }, {
            qe: 9,
            nmps: 44,
            nlps: 41,
            switchFlag: 0
          }, {
            qe: 5,
            nmps: 45,
            nlps: 42,
            switchFlag: 0
          }, {
            qe: 1,
            nmps: 45,
            nlps: 43,
            switchFlag: 0
          }, {
            qe: 22017,
            nmps: 46,
            nlps: 46,
            switchFlag: 0
          }];
          class t {
            constructor(v, h, e) {
              this.data = v, this.bp = h, this.dataEnd = e, this.chigh = v[h], this.clow = 0, this.byteIn(), this.chigh = this.chigh << 7 & 65535 | this.clow >> 9 & 127, this.clow = this.clow << 7 & 65535, this.ct -= 7, this.a = 32768;
            }
            byteIn() {
              const v = this.data;
              let h = this.bp;
              v[h] === 255 ? v[h + 1] > 143 ? (this.clow += 65280, this.ct = 8) : (h++, this.clow += v[h] << 9, this.ct = 7, this.bp = h) : (h++, this.clow += h < this.dataEnd ? v[h] << 8 : 65280, this.ct = 8, this.bp = h), this.clow > 65535 && (this.chigh += this.clow >> 16, this.clow &= 65535);
            }
            readBit(v, h) {
              let e = v[h] >> 1, y = v[h] & 1;
              const c = C[e], d = c.qe;
              let p, m = this.a - d;
              if (this.chigh < d)
                m < d ? (m = d, p = y, e = c.nmps) : (m = d, p = 1 ^ y, c.switchFlag === 1 && (y = p), e = c.nlps);
              else {
                if (this.chigh -= d, m & 32768)
                  return this.a = m, y;
                m < d ? (p = 1 ^ y, c.switchFlag === 1 && (y = p), e = c.nlps) : (p = y, e = c.nmps);
              }
              do
                this.ct === 0 && this.byteIn(), m <<= 1, this.chigh = this.chigh << 1 & 65535 | this.clow >> 15 & 1, this.clow = this.clow << 1 & 65535, this.ct--;
              while (!(m & 32768));
              return this.a = m, v[h] = e << 1 | y, p;
            }
          }
          o.ArithmeticDecoder = t;
        },
        /* 27 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.JpegStream = void 0;
          var t = C(19), a = C(5), v = C(28), h = C(2);
          class e extends t.DecodeStream {
            constructor(c, d, p) {
              let m;
              for (; (m = c.getByte()) !== -1; )
                if (m === 255) {
                  c.skip(-1);
                  break;
                }
              super(d), this.stream = c, this.dict = c.dict, this.maybeLength = d, this.params = p;
            }
            get bytes() {
              return (0, h.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
            }
            ensureBuffer(c) {
            }
            readBlock() {
              if (this.eof)
                return;
              const c = {
                decodeTransform: void 0,
                colorTransform: void 0
              }, d = this.dict.getArray("D", "Decode");
              if (this.forceRGB && Array.isArray(d)) {
                const g = this.dict.get("BPC", "BitsPerComponent") || 8, n = d.length, i = new Int32Array(n);
                let l = !1;
                const u = (1 << g) - 1;
                for (let w = 0; w < n; w += 2)
                  i[w] = (d[w + 1] - d[w]) * 256 | 0, i[w + 1] = d[w] * u | 0, (i[w] !== 256 || i[w + 1] !== 0) && (l = !0);
                l && (c.decodeTransform = i);
              }
              if (this.params instanceof a.Dict) {
                const g = this.params.get("ColorTransform");
                Number.isInteger(g) && (c.colorTransform = g);
              }
              const p = new v.JpegImage(c);
              p.parse(this.bytes);
              const m = p.getData({
                width: this.drawWidth,
                height: this.drawHeight,
                forceRGB: this.forceRGB,
                isSourcePDF: !0
              });
              this.buffer = m, this.bufferLength = m.length, this.eof = !0;
            }
          }
          o.JpegStream = e;
        },
        /* 28 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.JpegImage = void 0;
          var t = C(2), a = C(6);
          class v extends t.BaseException {
            constructor(B) {
              super(`JPEG error: ${B}`, "JpegError");
            }
          }
          class h extends t.BaseException {
            constructor(B, R) {
              super(B, "DNLMarkerError"), this.scanLines = R;
            }
          }
          class e extends t.BaseException {
            constructor(B) {
              super(B, "EOIMarkerError");
            }
          }
          const y = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), c = 4017, d = 799, p = 3406, m = 2276, g = 1567, n = 3784, i = 5793, l = 2896;
          function u(X, B) {
            let R = 0, k, x, f = 16;
            for (; f > 0 && !X[f - 1]; )
              f--;
            const U = [{
              children: [],
              index: 0
            }];
            let O = U[0], S;
            for (k = 0; k < f; k++) {
              for (x = 0; x < X[k]; x++) {
                for (O = U.pop(), O.children[O.index] = B[R]; O.index > 0; )
                  O = U.pop();
                for (O.index++, U.push(O); U.length <= k; )
                  U.push(S = {
                    children: [],
                    index: 0
                  }), O.children[O.index] = S.children, O = S;
                R++;
              }
              k + 1 < f && (U.push(S = {
                children: [],
                index: 0
              }), O.children[O.index] = S.children, O = S);
            }
            return U[0].children;
          }
          function w(X, B, R) {
            return 64 * ((X.blocksPerLine + 1) * B + R);
          }
          function _(X, B, R, k, x, f, U, O, S, F = !1) {
            const T = R.mcusPerLine, I = R.progressive, M = B;
            let V = 0, J = 0;
            function W() {
              if (J > 0)
                return J--, V >> J & 1;
              if (V = X[B++], V === 255) {
                const ye = X[B++];
                if (ye) {
                  if (ye === 220 && F) {
                    B += 2;
                    const _e = (0, a.readUint16)(X, B);
                    if (B += 2, _e > 0 && _e !== R.scanLines)
                      throw new h("Found DNL marker (0xFFDC) while parsing scan data", _e);
                  } else if (ye === 217) {
                    if (F) {
                      const _e = oe * (R.precision === 8 ? 8 : 0);
                      if (_e > 0 && Math.round(R.scanLines / _e) >= 10)
                        throw new h("Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter", _e);
                    }
                    throw new e("Found EOI marker (0xFFD9) while parsing scan data");
                  }
                  throw new v(`unexpected marker ${(V << 8 | ye).toString(16)}`);
                }
              }
              return J = 7, V >>> 7;
            }
            function z(ye) {
              let _e = ye;
              for (; ; ) {
                switch (_e = _e[W()], typeof _e) {
                  case "number":
                    return _e;
                  case "object":
                    continue;
                }
                throw new v("invalid huffman sequence");
              }
            }
            function G(ye) {
              let _e = 0;
              for (; ye > 0; )
                _e = _e << 1 | W(), ye--;
              return _e;
            }
            function L(ye) {
              if (ye === 1)
                return W() === 1 ? 1 : -1;
              const _e = G(ye);
              return _e >= 1 << ye - 1 ? _e : _e + (-1 << ye) + 1;
            }
            function K(ye, _e) {
              const we = z(ye.huffmanTableDC), Ce = we === 0 ? 0 : L(we);
              ye.blockData[_e] = ye.pred += Ce;
              let ve = 1;
              for (; ve < 64; ) {
                const Le = z(ye.huffmanTableAC), He = Le & 15, Qe = Le >> 4;
                if (He === 0) {
                  if (Qe < 15)
                    break;
                  ve += 16;
                  continue;
                }
                ve += Qe;
                const Ue = y[ve];
                ye.blockData[_e + Ue] = L(He), ve++;
              }
            }
            function te(ye, _e) {
              const we = z(ye.huffmanTableDC), Ce = we === 0 ? 0 : L(we) << S;
              ye.blockData[_e] = ye.pred += Ce;
            }
            function se(ye, _e) {
              ye.blockData[_e] |= W() << S;
            }
            let q = 0;
            function N(ye, _e) {
              if (q > 0) {
                q--;
                return;
              }
              let we = f;
              const Ce = U;
              for (; we <= Ce; ) {
                const ve = z(ye.huffmanTableAC), Le = ve & 15, He = ve >> 4;
                if (Le === 0) {
                  if (He < 15) {
                    q = G(He) + (1 << He) - 1;
                    break;
                  }
                  we += 16;
                  continue;
                }
                we += He;
                const Qe = y[we];
                ye.blockData[_e + Qe] = L(Le) * (1 << S), we++;
              }
            }
            let Q = 0, D;
            function ne(ye, _e) {
              let we = f;
              const Ce = U;
              let ve = 0, Le, He;
              for (; we <= Ce; ) {
                const Qe = _e + y[we], Ue = ye.blockData[Qe] < 0 ? -1 : 1;
                switch (Q) {
                  case 0:
                    if (He = z(ye.huffmanTableAC), Le = He & 15, ve = He >> 4, Le === 0)
                      ve < 15 ? (q = G(ve) + (1 << ve), Q = 4) : (ve = 16, Q = 1);
                    else {
                      if (Le !== 1)
                        throw new v("invalid ACn encoding");
                      D = L(Le), Q = ve ? 2 : 3;
                    }
                    continue;
                  case 1:
                  case 2:
                    ye.blockData[Qe] ? ye.blockData[Qe] += Ue * (W() << S) : (ve--, ve === 0 && (Q = Q === 2 ? 3 : 0));
                    break;
                  case 3:
                    ye.blockData[Qe] ? ye.blockData[Qe] += Ue * (W() << S) : (ye.blockData[Qe] = D << S, Q = 0);
                    break;
                  case 4:
                    ye.blockData[Qe] && (ye.blockData[Qe] += Ue * (W() << S));
                    break;
                }
                we++;
              }
              Q === 4 && (q--, q === 0 && (Q = 0));
            }
            let oe = 0;
            function ee(ye, _e, we, Ce, ve) {
              const Le = we / T | 0, He = we % T;
              oe = Le * ye.v + Ce;
              const Qe = He * ye.h + ve, Ue = w(ye, oe, Qe);
              _e(ye, Ue);
            }
            function $(ye, _e, we) {
              oe = we / ye.blocksPerLine | 0;
              const Ce = we % ye.blocksPerLine, ve = w(ye, oe, Ce);
              _e(ye, ve);
            }
            const E = k.length;
            let H, ie, ue, fe, de, pe;
            I ? f === 0 ? pe = O === 0 ? te : se : pe = O === 0 ? N : ne : pe = K;
            let xe = 0, De, Ae;
            E === 1 ? Ae = k[0].blocksPerLine * k[0].blocksPerColumn : Ae = T * R.mcusPerColumn;
            let Se, ke;
            for (; xe <= Ae; ) {
              const ye = x ? Math.min(Ae - xe, x) : Ae;
              if (ye > 0) {
                for (ie = 0; ie < E; ie++)
                  k[ie].pred = 0;
                if (q = 0, E === 1)
                  for (H = k[0], de = 0; de < ye; de++)
                    $(H, pe, xe), xe++;
                else
                  for (de = 0; de < ye; de++) {
                    for (ie = 0; ie < E; ie++)
                      for (H = k[ie], Se = H.h, ke = H.v, ue = 0; ue < ke; ue++)
                        for (fe = 0; fe < Se; fe++)
                          ee(H, pe, xe, ue, fe);
                    xe++;
                  }
              }
              if (J = 0, De = Y(X, B), !De)
                break;
              if (De.invalid) {
                const _e = ye > 0 ? "unexpected" : "excessive";
                (0, t.warn)(`decodeScan - ${_e} MCU data, current marker is: ${De.invalid}`), B = De.offset;
              }
              if (De.marker >= 65488 && De.marker <= 65495)
                B += 2;
              else
                break;
            }
            return B - M;
          }
          function b(X, B, R) {
            const k = X.quantizationTable, x = X.blockData;
            let f, U, O, S, F, T, I, M, V, J, W, z, G, L, K, te, se;
            if (!k)
              throw new v("missing required Quantization Table.");
            for (let q = 0; q < 64; q += 8) {
              if (V = x[B + q], J = x[B + q + 1], W = x[B + q + 2], z = x[B + q + 3], G = x[B + q + 4], L = x[B + q + 5], K = x[B + q + 6], te = x[B + q + 7], V *= k[q], !(J | W | z | G | L | K | te)) {
                se = i * V + 512 >> 10, R[q] = se, R[q + 1] = se, R[q + 2] = se, R[q + 3] = se, R[q + 4] = se, R[q + 5] = se, R[q + 6] = se, R[q + 7] = se;
                continue;
              }
              J *= k[q + 1], W *= k[q + 2], z *= k[q + 3], G *= k[q + 4], L *= k[q + 5], K *= k[q + 6], te *= k[q + 7], f = i * V + 128 >> 8, U = i * G + 128 >> 8, O = W, S = K, F = l * (J - te) + 128 >> 8, M = l * (J + te) + 128 >> 8, T = z << 4, I = L << 4, f = f + U + 1 >> 1, U = f - U, se = O * n + S * g + 128 >> 8, O = O * g - S * n + 128 >> 8, S = se, F = F + I + 1 >> 1, I = F - I, M = M + T + 1 >> 1, T = M - T, f = f + S + 1 >> 1, S = f - S, U = U + O + 1 >> 1, O = U - O, se = F * m + M * p + 2048 >> 12, F = F * p - M * m + 2048 >> 12, M = se, se = T * d + I * c + 2048 >> 12, T = T * c - I * d + 2048 >> 12, I = se, R[q] = f + M, R[q + 7] = f - M, R[q + 1] = U + I, R[q + 6] = U - I, R[q + 2] = O + T, R[q + 5] = O - T, R[q + 3] = S + F, R[q + 4] = S - F;
            }
            for (let q = 0; q < 8; ++q) {
              if (V = R[q], J = R[q + 8], W = R[q + 16], z = R[q + 24], G = R[q + 32], L = R[q + 40], K = R[q + 48], te = R[q + 56], !(J | W | z | G | L | K | te)) {
                se = i * V + 8192 >> 14, se < -2040 ? se = 0 : se >= 2024 ? se = 255 : se = se + 2056 >> 4, x[B + q] = se, x[B + q + 8] = se, x[B + q + 16] = se, x[B + q + 24] = se, x[B + q + 32] = se, x[B + q + 40] = se, x[B + q + 48] = se, x[B + q + 56] = se;
                continue;
              }
              f = i * V + 2048 >> 12, U = i * G + 2048 >> 12, O = W, S = K, F = l * (J - te) + 2048 >> 12, M = l * (J + te) + 2048 >> 12, T = z, I = L, f = (f + U + 1 >> 1) + 4112, U = f - U, se = O * n + S * g + 2048 >> 12, O = O * g - S * n + 2048 >> 12, S = se, F = F + I + 1 >> 1, I = F - I, M = M + T + 1 >> 1, T = M - T, f = f + S + 1 >> 1, S = f - S, U = U + O + 1 >> 1, O = U - O, se = F * m + M * p + 2048 >> 12, F = F * p - M * m + 2048 >> 12, M = se, se = T * d + I * c + 2048 >> 12, T = T * c - I * d + 2048 >> 12, I = se, V = f + M, te = f - M, J = U + I, K = U - I, W = O + T, L = O - T, z = S + F, G = S - F, V < 16 ? V = 0 : V >= 4080 ? V = 255 : V >>= 4, J < 16 ? J = 0 : J >= 4080 ? J = 255 : J >>= 4, W < 16 ? W = 0 : W >= 4080 ? W = 255 : W >>= 4, z < 16 ? z = 0 : z >= 4080 ? z = 255 : z >>= 4, G < 16 ? G = 0 : G >= 4080 ? G = 255 : G >>= 4, L < 16 ? L = 0 : L >= 4080 ? L = 255 : L >>= 4, K < 16 ? K = 0 : K >= 4080 ? K = 255 : K >>= 4, te < 16 ? te = 0 : te >= 4080 ? te = 255 : te >>= 4, x[B + q] = V, x[B + q + 8] = J, x[B + q + 16] = W, x[B + q + 24] = z, x[B + q + 32] = G, x[B + q + 40] = L, x[B + q + 48] = K, x[B + q + 56] = te;
            }
          }
          function A(X, B) {
            const R = B.blocksPerLine, k = B.blocksPerColumn, x = new Int16Array(64);
            for (let f = 0; f < k; f++)
              for (let U = 0; U < R; U++) {
                const O = w(B, f, U);
                b(B, O, x);
              }
            return B.blockData;
          }
          function Y(X, B, R = B) {
            const k = X.length - 1;
            let x = R < B ? R : B;
            if (B >= k)
              return null;
            const f = (0, a.readUint16)(X, B);
            if (f >= 65472 && f <= 65534)
              return {
                invalid: null,
                marker: f,
                offset: B
              };
            let U = (0, a.readUint16)(X, x);
            for (; !(U >= 65472 && U <= 65534); ) {
              if (++x >= k)
                return null;
              U = (0, a.readUint16)(X, x);
            }
            return {
              invalid: f.toString(16),
              marker: U,
              offset: x
            };
          }
          class j {
            constructor({
              decodeTransform: B = null,
              colorTransform: R = -1
            } = {}) {
              this._decodeTransform = B, this._colorTransform = R;
            }
            parse(B, {
              dnlScanLines: R = null
            } = {}) {
              function k() {
                const W = (0, a.readUint16)(B, f);
                f += 2;
                let z = f + W - 2;
                const G = Y(B, z, f);
                G && G.invalid && ((0, t.warn)("readDataBlock - incorrect length, current marker is: " + G.invalid), z = G.offset);
                const L = B.subarray(f, z);
                return f += L.length, L;
              }
              function x(W) {
                const z = Math.ceil(W.samplesPerLine / 8 / W.maxH), G = Math.ceil(W.scanLines / 8 / W.maxV);
                for (let L = 0, K = W.components.length; L < K; L++) {
                  const te = W.components[L], se = Math.ceil(Math.ceil(W.samplesPerLine / 8) * te.h / W.maxH), q = Math.ceil(Math.ceil(W.scanLines / 8) * te.v / W.maxV), N = z * te.h, D = 64 * (G * te.v) * (N + 1);
                  te.blockData = new Int16Array(D), te.blocksPerLine = se, te.blocksPerColumn = q;
                }
                W.mcusPerLine = z, W.mcusPerColumn = G;
              }
              let f = 0, U = null, O = null, S, F, T = 0;
              const I = [], M = [], V = [];
              let J = (0, a.readUint16)(B, f);
              if (f += 2, J !== 65496)
                throw new v("SOI not found");
              J = (0, a.readUint16)(B, f), f += 2;
              e:
                for (; J !== 65497; ) {
                  let W, z, G;
                  switch (J) {
                    case 65504:
                    case 65505:
                    case 65506:
                    case 65507:
                    case 65508:
                    case 65509:
                    case 65510:
                    case 65511:
                    case 65512:
                    case 65513:
                    case 65514:
                    case 65515:
                    case 65516:
                    case 65517:
                    case 65518:
                    case 65519:
                    case 65534:
                      const L = k();
                      J === 65504 && L[0] === 74 && L[1] === 70 && L[2] === 73 && L[3] === 70 && L[4] === 0 && (U = {
                        version: {
                          major: L[5],
                          minor: L[6]
                        },
                        densityUnits: L[7],
                        xDensity: L[8] << 8 | L[9],
                        yDensity: L[10] << 8 | L[11],
                        thumbWidth: L[12],
                        thumbHeight: L[13],
                        thumbData: L.subarray(14, 14 + 3 * L[12] * L[13])
                      }), J === 65518 && L[0] === 65 && L[1] === 100 && L[2] === 111 && L[3] === 98 && L[4] === 101 && (O = {
                        version: L[5] << 8 | L[6],
                        flags0: L[7] << 8 | L[8],
                        flags1: L[9] << 8 | L[10],
                        transformCode: L[11]
                      });
                      break;
                    case 65499:
                      const K = (0, a.readUint16)(B, f);
                      f += 2;
                      const te = K + f - 2;
                      let se;
                      for (; f < te; ) {
                        const fe = B[f++], de = new Uint16Array(64);
                        if (fe >> 4)
                          if (fe >> 4 === 1)
                            for (z = 0; z < 64; z++)
                              se = y[z], de[se] = (0, a.readUint16)(B, f), f += 2;
                          else
                            throw new v("DQT - invalid table spec");
                        else
                          for (z = 0; z < 64; z++)
                            se = y[z], de[se] = B[f++];
                        I[fe & 15] = de;
                      }
                      break;
                    case 65472:
                    case 65473:
                    case 65474:
                      if (S)
                        throw new v("Only single frame JPEGs supported");
                      f += 2, S = {}, S.extended = J === 65473, S.progressive = J === 65474, S.precision = B[f++];
                      const q = (0, a.readUint16)(B, f);
                      f += 2, S.scanLines = R || q, S.samplesPerLine = (0, a.readUint16)(B, f), f += 2, S.components = [], S.componentIds = {};
                      const N = B[f++];
                      let Q = 0, D = 0;
                      for (W = 0; W < N; W++) {
                        const fe = B[f], de = B[f + 1] >> 4, pe = B[f + 1] & 15;
                        Q < de && (Q = de), D < pe && (D = pe);
                        const xe = B[f + 2];
                        G = S.components.push({
                          h: de,
                          v: pe,
                          quantizationId: xe,
                          quantizationTable: null
                        }), S.componentIds[fe] = G - 1, f += 3;
                      }
                      S.maxH = Q, S.maxV = D, x(S);
                      break;
                    case 65476:
                      const ne = (0, a.readUint16)(B, f);
                      for (f += 2, W = 2; W < ne; ) {
                        const fe = B[f++], de = new Uint8Array(16);
                        let pe = 0;
                        for (z = 0; z < 16; z++, f++)
                          pe += de[z] = B[f];
                        const xe = new Uint8Array(pe);
                        for (z = 0; z < pe; z++, f++)
                          xe[z] = B[f];
                        W += 17 + pe, (fe >> 4 ? M : V)[fe & 15] = u(de, xe);
                      }
                      break;
                    case 65501:
                      f += 2, F = (0, a.readUint16)(B, f), f += 2;
                      break;
                    case 65498:
                      const oe = ++T === 1 && !R;
                      f += 2;
                      const ee = B[f++], $ = [];
                      for (W = 0; W < ee; W++) {
                        const fe = B[f++], de = S.componentIds[fe], pe = S.components[de];
                        pe.index = fe;
                        const xe = B[f++];
                        pe.huffmanTableDC = V[xe >> 4], pe.huffmanTableAC = M[xe & 15], $.push(pe);
                      }
                      const E = B[f++], H = B[f++], ie = B[f++];
                      try {
                        const fe = _(B, f, S, $, F, E, H, ie >> 4, ie & 15, oe);
                        f += fe;
                      } catch (fe) {
                        if (fe instanceof h)
                          return (0, t.warn)(`${fe.message} -- attempting to re-parse the JPEG image.`), this.parse(B, {
                            dnlScanLines: fe.scanLines
                          });
                        if (fe instanceof e) {
                          (0, t.warn)(`${fe.message} -- ignoring the rest of the image data.`);
                          break e;
                        }
                        throw fe;
                      }
                      break;
                    case 65500:
                      f += 4;
                      break;
                    case 65535:
                      B[f] !== 255 && f--;
                      break;
                    default:
                      const ue = Y(B, f - 2, f - 3);
                      if (ue && ue.invalid) {
                        (0, t.warn)("JpegImage.parse - unexpected data, current marker is: " + ue.invalid), f = ue.offset;
                        break;
                      }
                      if (!ue || f >= B.length - 1) {
                        (0, t.warn)("JpegImage.parse - reached the end of the image data without finding an EOI marker (0xFFD9).");
                        break e;
                      }
                      throw new v("JpegImage.parse - unknown marker: " + J.toString(16));
                  }
                  J = (0, a.readUint16)(B, f), f += 2;
                }
              this.width = S.samplesPerLine, this.height = S.scanLines, this.jfif = U, this.adobe = O, this.components = [];
              for (let W = 0, z = S.components.length; W < z; W++) {
                const G = S.components[W], L = I[G.quantizationId];
                L && (G.quantizationTable = L), this.components.push({
                  index: G.index,
                  output: A(S, G),
                  scaleX: G.h / S.maxH,
                  scaleY: G.v / S.maxV,
                  blocksPerLine: G.blocksPerLine,
                  blocksPerColumn: G.blocksPerColumn
                });
              }
              this.numComponents = this.components.length;
            }
            _getLinearizedBlockData(B, R, k = !1) {
              const x = this.width / B, f = this.height / R;
              let U, O, S, F, T, I, M, V, J, W, z = 0, G;
              const L = this.components.length, K = B * R * L, te = new Uint8ClampedArray(K), se = new Uint32Array(B), q = 4294967288;
              let N;
              for (M = 0; M < L; M++) {
                if (U = this.components[M], O = U.scaleX * x, S = U.scaleY * f, z = M, G = U.output, F = U.blocksPerLine + 1 << 3, O !== N) {
                  for (T = 0; T < B; T++)
                    V = 0 | T * O, se[T] = (V & q) << 3 | V & 7;
                  N = O;
                }
                for (I = 0; I < R; I++)
                  for (V = 0 | I * S, W = F * (V & q) | (V & 7) << 3, T = 0; T < B; T++)
                    te[z] = G[W + se[T]], z += L;
              }
              let Q = this._decodeTransform;
              if (!k && L === 4 && !Q && (Q = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255])), Q)
                for (M = 0; M < K; )
                  for (V = 0, J = 0; V < L; V++, M++, J += 2)
                    te[M] = (te[M] * Q[J] >> 8) + Q[J + 1];
              return te;
            }
            get _isColorConversionNeeded() {
              return this.adobe ? !!this.adobe.transformCode : this.numComponents === 3 ? this._colorTransform === 0 ? !1 : !(this.components[0].index === 82 && this.components[1].index === 71 && this.components[2].index === 66) : this._colorTransform === 1;
            }
            _convertYccToRgb(B) {
              let R, k, x;
              for (let f = 0, U = B.length; f < U; f += 3)
                R = B[f], k = B[f + 1], x = B[f + 2], B[f] = R - 179.456 + 1.402 * x, B[f + 1] = R + 135.459 - 0.344 * k - 0.714 * x, B[f + 2] = R - 226.816 + 1.772 * k;
              return B;
            }
            _convertYcckToRgb(B) {
              let R, k, x, f, U = 0;
              for (let O = 0, S = B.length; O < S; O += 4)
                R = B[O], k = B[O + 1], x = B[O + 2], f = B[O + 3], B[U++] = -122.67195406894 + k * (-660635669420364e-19 * k + 437130475926232e-18 * x - 54080610064599e-18 * R + 48449797120281e-17 * f - 0.154362151871126) + x * (-957964378445773e-18 * x + 817076911346625e-18 * R - 0.00477271405408747 * f + 1.53380253221734) + R * (961250184130688e-18 * R - 0.00266257332283933 * f + 0.48357088451265) + f * (-336197177618394e-18 * f + 0.484791561490776), B[U++] = 107.268039397724 + k * (219927104525741e-19 * k - 640992018297945e-18 * x + 659397001245577e-18 * R + 426105652938837e-18 * f - 0.176491792462875) + x * (-778269941513683e-18 * x + 0.00130872261408275 * R + 770482631801132e-18 * f - 0.151051492775562) + R * (0.00126935368114843 * R - 0.00265090189010898 * f + 0.25802910206845) + f * (-318913117588328e-18 * f - 0.213742400323665), B[U++] = -20.810012546947 + k * (-570115196973677e-18 * k - 263409051004589e-19 * x + 0.0020741088115012 * R - 0.00288260236853442 * f + 0.814272968359295) + x * (-153496057440975e-19 * x - 132689043961446e-18 * R + 560833691242812e-18 * f - 0.195152027534049) + R * (0.00174418132927582 * R - 0.00255243321439347 * f + 0.116935020465145) + f * (-343531996510555e-18 * f + 0.24165260232407);
              return B.subarray(0, U);
            }
            _convertYcckToCmyk(B) {
              let R, k, x;
              for (let f = 0, U = B.length; f < U; f += 4)
                R = B[f], k = B[f + 1], x = B[f + 2], B[f] = 434.456 - R - 1.402 * x, B[f + 1] = 119.541 - R + 0.344 * k + 0.714 * x, B[f + 2] = 481.816 - R - 1.772 * k;
              return B;
            }
            _convertCmykToRgb(B) {
              let R, k, x, f, U = 0;
              for (let O = 0, S = B.length; O < S; O += 4)
                R = B[O], k = B[O + 1], x = B[O + 2], f = B[O + 3], B[U++] = 255 + R * (-6747147073602441e-20 * R + 8379262121013727e-19 * k + 2894718188643294e-19 * x + 0.003264231057537806 * f - 1.1185611867203937) + k * (26374107616089405e-21 * k - 8626949158638572e-20 * x - 2748769067499491e-19 * f - 0.02155688794978967) + x * (-3878099212869363e-20 * x - 3267808279485286e-19 * f + 0.0686742238595345) - f * (3361971776183937e-19 * f + 0.7430659151342254), B[U++] = 255 + R * (13596372813588848e-20 * R + 924537132573585e-18 * k + 10567359618683593e-20 * x + 4791864687436512e-19 * f - 0.3109689587515875) + k * (-23545346108370344e-20 * k + 2702845253534714e-19 * x + 0.0020200308977307156 * f - 0.7488052167015494) + x * (6834815998235662e-20 * x + 15168452363460973e-20 * f - 0.09751927774728933) - f * (3189131175883281e-19 * f + 0.7364883807733168), B[U++] = 255 + R * (13598650411385307e-21 * R + 12423956175490851e-20 * k + 4751985097583589e-19 * x - 36729317476630422e-22 * f - 0.05562186980264034) + k * (16141380598724676e-20 * k + 9692239130725186e-19 * x + 7782692450036253e-19 * f - 0.44015232367526463) + x * (5068882914068769e-22 * x + 0.0017778369011375071 * f - 0.7591454649749609) - f * (3435319965105553e-19 * f + 0.7063770186160144);
              return B.subarray(0, U);
            }
            getData({
              width: B,
              height: R,
              forceRGB: k = !1,
              isSourcePDF: x = !1
            }) {
              if (this.numComponents > 4)
                throw new v("Unsupported color mode");
              const f = this._getLinearizedBlockData(B, R, x);
              if (this.numComponents === 1 && k) {
                const U = f.length, O = new Uint8ClampedArray(U * 3);
                let S = 0;
                for (let F = 0; F < U; F++) {
                  const T = f[F];
                  O[S++] = T, O[S++] = T, O[S++] = T;
                }
                return O;
              } else {
                if (this.numComponents === 3 && this._isColorConversionNeeded)
                  return this._convertYccToRgb(f);
                if (this.numComponents === 4) {
                  if (this._isColorConversionNeeded)
                    return k ? this._convertYcckToRgb(f) : this._convertYcckToCmyk(f);
                  if (k)
                    return this._convertCmykToRgb(f);
                }
              }
              return f;
            }
          }
          o.JpegImage = j;
        },
        /* 29 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.JpxStream = void 0;
          var t = C(19), a = C(30), v = C(2);
          class h extends t.DecodeStream {
            constructor(y, c, d) {
              super(c), this.stream = y, this.dict = y.dict, this.maybeLength = c, this.params = d;
            }
            get bytes() {
              return (0, v.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
            }
            ensureBuffer(y) {
            }
            readBlock() {
              if (this.eof)
                return;
              const y = new a.JpxImage();
              y.parse(this.bytes);
              const c = y.width, d = y.height, p = y.componentsCount, m = y.tiles.length;
              if (m === 1)
                this.buffer = y.tiles[0].items;
              else {
                const g = new Uint8ClampedArray(c * d * p);
                for (let n = 0; n < m; n++) {
                  const i = y.tiles[n], l = i.width, u = i.height, w = i.left, _ = i.top, b = i.items;
                  let A = 0, Y = (c * _ + w) * p;
                  const j = c * p, X = l * p;
                  for (let B = 0; B < u; B++) {
                    const R = b.subarray(A, A + X);
                    g.set(R, Y), A += X, Y += j;
                  }
                }
                this.buffer = g;
              }
              this.bufferLength = this.buffer.length, this.eof = !0;
            }
          }
          o.JpxStream = h;
        },
        /* 30 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.JpxImage = void 0;
          var t = C(2), a = C(6), v = C(26);
          class h extends t.BaseException {
            constructor(I) {
              super(`JPX error: ${I}`, "JpxError");
            }
          }
          const e = {
            LL: 0,
            LH: 1,
            HL: 1,
            HH: 2
          };
          class y {
            constructor() {
              this.failOnCorruptedImage = !1;
            }
            parse(I) {
              if ((0, a.readUint16)(I, 0) === 65359) {
                this.parseCodestream(I, 0, I.length);
                return;
              }
              const V = I.length;
              let J = 0;
              for (; J < V; ) {
                let W = 8, z = (0, a.readUint32)(I, J);
                const G = (0, a.readUint32)(I, J + 4);
                if (J += W, z === 1 && (z = (0, a.readUint32)(I, J) * 4294967296 + (0, a.readUint32)(I, J + 4), J += 8, W += 8), z === 0 && (z = V - J + W), z < W)
                  throw new h("Invalid box field size");
                const L = z - W;
                let K = !0;
                switch (G) {
                  case 1785737832:
                    K = !1;
                    break;
                  case 1668246642:
                    const te = I[J];
                    if (te === 1) {
                      const q = (0, a.readUint32)(I, J + 3);
                      switch (q) {
                        case 16:
                        case 17:
                        case 18:
                          break;
                        default:
                          (0, t.warn)("Unknown colorspace " + q);
                          break;
                      }
                    } else
                      te === 2 && (0, t.info)("ICC profile not supported");
                    break;
                  case 1785737827:
                    this.parseCodestream(I, J, J + L);
                    break;
                  case 1783636e3:
                    (0, a.readUint32)(I, J) !== 218793738 && (0, t.warn)("Invalid JP2 signature");
                    break;
                  case 1783634458:
                  case 1718909296:
                  case 1920099697:
                  case 1919251232:
                  case 1768449138:
                    break;
                  default:
                    const se = String.fromCharCode(G >> 24 & 255, G >> 16 & 255, G >> 8 & 255, G & 255);
                    (0, t.warn)(`Unsupported header type ${G} (${se}).`);
                    break;
                }
                K && (J += L);
              }
            }
            parseImageProperties(I) {
              let M = I.getByte();
              for (; M >= 0; ) {
                const V = M;
                if (M = I.getByte(), (V << 8 | M) === 65361) {
                  I.skip(4);
                  const W = I.getInt32() >>> 0, z = I.getInt32() >>> 0, G = I.getInt32() >>> 0, L = I.getInt32() >>> 0;
                  I.skip(16);
                  const K = I.getUint16();
                  this.width = W - G, this.height = z - L, this.componentsCount = K, this.bitsPerComponent = 8;
                  return;
                }
              }
              throw new h("No size marker found in JPX stream");
            }
            parseCodestream(I, M, V) {
              const J = {};
              let W = !1;
              try {
                let z = M;
                for (; z + 1 < V; ) {
                  const G = (0, a.readUint16)(I, z);
                  z += 2;
                  let L = 0, K, te, se, q, N, Q;
                  switch (G) {
                    case 65359:
                      J.mainHeader = !0;
                      break;
                    case 65497:
                      break;
                    case 65361:
                      L = (0, a.readUint16)(I, z);
                      const D = {};
                      D.Xsiz = (0, a.readUint32)(I, z + 4), D.Ysiz = (0, a.readUint32)(I, z + 8), D.XOsiz = (0, a.readUint32)(I, z + 12), D.YOsiz = (0, a.readUint32)(I, z + 16), D.XTsiz = (0, a.readUint32)(I, z + 20), D.YTsiz = (0, a.readUint32)(I, z + 24), D.XTOsiz = (0, a.readUint32)(I, z + 28), D.YTOsiz = (0, a.readUint32)(I, z + 32);
                      const ne = (0, a.readUint16)(I, z + 36);
                      D.Csiz = ne;
                      const oe = [];
                      K = z + 38;
                      for (let de = 0; de < ne; de++) {
                        const pe = {
                          precision: (I[K] & 127) + 1,
                          isSigned: !!(I[K] & 128),
                          XRsiz: I[K + 1],
                          YRsiz: I[K + 2]
                        };
                        K += 3, c(pe, D), oe.push(pe);
                      }
                      J.SIZ = D, J.components = oe, d(J, oe), J.QCC = [], J.COC = [];
                      break;
                    case 65372:
                      L = (0, a.readUint16)(I, z);
                      const ee = {};
                      switch (K = z + 2, te = I[K++], te & 31) {
                        case 0:
                          q = 8, N = !0;
                          break;
                        case 1:
                          q = 16, N = !1;
                          break;
                        case 2:
                          q = 16, N = !0;
                          break;
                        default:
                          throw new Error("Invalid SQcd value " + te);
                      }
                      for (ee.noQuantization = q === 8, ee.scalarExpounded = N, ee.guardBits = te >> 5, se = []; K < L + z; ) {
                        const de = {};
                        q === 8 ? (de.epsilon = I[K++] >> 3, de.mu = 0) : (de.epsilon = I[K] >> 3, de.mu = (I[K] & 7) << 8 | I[K + 1], K += 2), se.push(de);
                      }
                      ee.SPqcds = se, J.mainHeader ? J.QCD = ee : (J.currentTile.QCD = ee, J.currentTile.QCC = []);
                      break;
                    case 65373:
                      L = (0, a.readUint16)(I, z);
                      const $ = {};
                      K = z + 2;
                      let E;
                      switch (J.SIZ.Csiz < 257 ? E = I[K++] : (E = (0, a.readUint16)(I, K), K += 2), te = I[K++], te & 31) {
                        case 0:
                          q = 8, N = !0;
                          break;
                        case 1:
                          q = 16, N = !1;
                          break;
                        case 2:
                          q = 16, N = !0;
                          break;
                        default:
                          throw new Error("Invalid SQcd value " + te);
                      }
                      for ($.noQuantization = q === 8, $.scalarExpounded = N, $.guardBits = te >> 5, se = []; K < L + z; ) {
                        const de = {};
                        q === 8 ? (de.epsilon = I[K++] >> 3, de.mu = 0) : (de.epsilon = I[K] >> 3, de.mu = (I[K] & 7) << 8 | I[K + 1], K += 2), se.push(de);
                      }
                      $.SPqcds = se, J.mainHeader ? J.QCC[E] = $ : J.currentTile.QCC[E] = $;
                      break;
                    case 65362:
                      L = (0, a.readUint16)(I, z);
                      const H = {};
                      K = z + 2;
                      const ie = I[K++];
                      H.entropyCoderWithCustomPrecincts = !!(ie & 1), H.sopMarkerUsed = !!(ie & 2), H.ephMarkerUsed = !!(ie & 4), H.progressionOrder = I[K++], H.layersCount = (0, a.readUint16)(I, K), K += 2, H.multipleComponentTransform = I[K++], H.decompositionLevelsCount = I[K++], H.xcb = (I[K++] & 15) + 2, H.ycb = (I[K++] & 15) + 2;
                      const ue = I[K++];
                      if (H.selectiveArithmeticCodingBypass = !!(ue & 1), H.resetContextProbabilities = !!(ue & 2), H.terminationOnEachCodingPass = !!(ue & 4), H.verticallyStripe = !!(ue & 8), H.predictableTermination = !!(ue & 16), H.segmentationSymbolUsed = !!(ue & 32), H.reversibleTransformation = I[K++], H.entropyCoderWithCustomPrecincts) {
                        const de = [];
                        for (; K < L + z; ) {
                          const pe = I[K++];
                          de.push({
                            PPx: pe & 15,
                            PPy: pe >> 4
                          });
                        }
                        H.precinctsSizes = de;
                      }
                      const fe = [];
                      H.selectiveArithmeticCodingBypass && fe.push("selectiveArithmeticCodingBypass"), H.terminationOnEachCodingPass && fe.push("terminationOnEachCodingPass"), H.verticallyStripe && fe.push("verticallyStripe"), H.predictableTermination && fe.push("predictableTermination"), fe.length > 0 && (W = !0, (0, t.warn)(`JPX: Unsupported COD options (${fe.join(", ")}).`)), J.mainHeader ? J.COD = H : (J.currentTile.COD = H, J.currentTile.COC = []);
                      break;
                    case 65424:
                      L = (0, a.readUint16)(I, z), Q = {}, Q.index = (0, a.readUint16)(I, z + 2), Q.length = (0, a.readUint32)(I, z + 4), Q.dataEnd = Q.length + z - 2, Q.partIndex = I[z + 8], Q.partsCount = I[z + 9], J.mainHeader = !1, Q.partIndex === 0 && (Q.COD = J.COD, Q.COC = J.COC.slice(0), Q.QCD = J.QCD, Q.QCC = J.QCC.slice(0)), J.currentTile = Q;
                      break;
                    case 65427:
                      Q = J.currentTile, Q.partIndex === 0 && (k(J, Q.index), Y(J)), L = Q.dataEnd - z, j(J, I, z, L);
                      break;
                    case 65363:
                      (0, t.warn)("JPX: Codestream code 0xFF53 (COC) is not implemented.");
                    case 65365:
                    case 65367:
                    case 65368:
                    case 65380:
                      L = (0, a.readUint16)(I, z);
                      break;
                    default:
                      throw new Error("Unknown codestream code: " + G.toString(16));
                  }
                  z += L;
                }
              } catch (z) {
                if (W || this.failOnCorruptedImage)
                  throw new h(z.message);
                (0, t.warn)(`JPX: Trying to recover from: "${z.message}".`);
              }
              this.tiles = R(J), this.width = J.SIZ.Xsiz - J.SIZ.XOsiz, this.height = J.SIZ.Ysiz - J.SIZ.YOsiz, this.componentsCount = J.SIZ.Csiz;
            }
          }
          o.JpxImage = y;
          function c(T, I) {
            T.x0 = Math.ceil(I.XOsiz / T.XRsiz), T.x1 = Math.ceil(I.Xsiz / T.XRsiz), T.y0 = Math.ceil(I.YOsiz / T.YRsiz), T.y1 = Math.ceil(I.Ysiz / T.YRsiz), T.width = T.x1 - T.x0, T.height = T.y1 - T.y0;
          }
          function d(T, I) {
            const M = T.SIZ, V = [];
            let J;
            const W = Math.ceil((M.Xsiz - M.XTOsiz) / M.XTsiz), z = Math.ceil((M.Ysiz - M.YTOsiz) / M.YTsiz);
            for (let L = 0; L < z; L++)
              for (let K = 0; K < W; K++)
                J = {}, J.tx0 = Math.max(M.XTOsiz + K * M.XTsiz, M.XOsiz), J.ty0 = Math.max(M.YTOsiz + L * M.YTsiz, M.YOsiz), J.tx1 = Math.min(M.XTOsiz + (K + 1) * M.XTsiz, M.Xsiz), J.ty1 = Math.min(M.YTOsiz + (L + 1) * M.YTsiz, M.Ysiz), J.width = J.tx1 - J.tx0, J.height = J.ty1 - J.ty0, J.components = [], V.push(J);
            T.tiles = V;
            const G = M.Csiz;
            for (let L = 0, K = G; L < K; L++) {
              const te = I[L];
              for (let se = 0, q = V.length; se < q; se++) {
                const N = {};
                J = V[se], N.tcx0 = Math.ceil(J.tx0 / te.XRsiz), N.tcy0 = Math.ceil(J.ty0 / te.YRsiz), N.tcx1 = Math.ceil(J.tx1 / te.XRsiz), N.tcy1 = Math.ceil(J.ty1 / te.YRsiz), N.width = N.tcx1 - N.tcx0, N.height = N.tcy1 - N.tcy0, J.components[L] = N;
              }
            }
          }
          function p(T, I, M) {
            const V = I.codingStyleParameters, J = {};
            return V.entropyCoderWithCustomPrecincts ? (J.PPx = V.precinctsSizes[M].PPx, J.PPy = V.precinctsSizes[M].PPy) : (J.PPx = 15, J.PPy = 15), J.xcb_ = M > 0 ? Math.min(V.xcb, J.PPx - 1) : Math.min(V.xcb, J.PPx), J.ycb_ = M > 0 ? Math.min(V.ycb, J.PPy - 1) : Math.min(V.ycb, J.PPy), J;
          }
          function m(T, I, M) {
            const V = 1 << M.PPx, J = 1 << M.PPy, W = I.resLevel === 0, z = 1 << M.PPx + (W ? 0 : -1), G = 1 << M.PPy + (W ? 0 : -1), L = I.trx1 > I.trx0 ? Math.ceil(I.trx1 / V) - Math.floor(I.trx0 / V) : 0, K = I.try1 > I.try0 ? Math.ceil(I.try1 / J) - Math.floor(I.try0 / J) : 0, te = L * K;
            I.precinctParameters = {
              precinctWidth: V,
              precinctHeight: J,
              numprecinctswide: L,
              numprecinctshigh: K,
              numprecincts: te,
              precinctWidthInSubband: z,
              precinctHeightInSubband: G
            };
          }
          function g(T, I, M) {
            const V = M.xcb_, J = M.ycb_, W = 1 << V, z = 1 << J, G = I.tbx0 >> V, L = I.tby0 >> J, K = I.tbx1 + W - 1 >> V, te = I.tby1 + z - 1 >> J, se = I.resolution.precinctParameters, q = [], N = [];
            let Q, D, ne, oe;
            for (D = L; D < te; D++)
              for (Q = G; Q < K; Q++) {
                ne = {
                  cbx: Q,
                  cby: D,
                  tbx0: W * Q,
                  tby0: z * D,
                  tbx1: W * (Q + 1),
                  tby1: z * (D + 1)
                }, ne.tbx0_ = Math.max(I.tbx0, ne.tbx0), ne.tby0_ = Math.max(I.tby0, ne.tby0), ne.tbx1_ = Math.min(I.tbx1, ne.tbx1), ne.tby1_ = Math.min(I.tby1, ne.tby1);
                const ee = Math.floor((ne.tbx0_ - I.tbx0) / se.precinctWidthInSubband), $ = Math.floor((ne.tby0_ - I.tby0) / se.precinctHeightInSubband);
                if (oe = ee + $ * se.numprecinctswide, ne.precinctNumber = oe, ne.subbandType = I.type, ne.Lblock = 3, ne.tbx1_ <= ne.tbx0_ || ne.tby1_ <= ne.tby0_)
                  continue;
                q.push(ne);
                let E = N[oe];
                E !== void 0 ? (Q < E.cbxMin ? E.cbxMin = Q : Q > E.cbxMax && (E.cbxMax = Q), D < E.cbyMin ? E.cbxMin = D : D > E.cbyMax && (E.cbyMax = D)) : N[oe] = E = {
                  cbxMin: Q,
                  cbyMin: D,
                  cbxMax: Q,
                  cbyMax: D
                }, ne.precinct = E;
              }
            I.codeblockParameters = {
              codeblockWidth: V,
              codeblockHeight: J,
              numcodeblockwide: K - G + 1,
              numcodeblockhigh: te - L + 1
            }, I.codeblocks = q, I.precincts = N;
          }
          function n(T, I, M) {
            const V = [], J = T.subbands;
            for (let W = 0, z = J.length; W < z; W++) {
              const L = J[W].codeblocks;
              for (let K = 0, te = L.length; K < te; K++) {
                const se = L[K];
                se.precinctNumber === I && V.push(se);
              }
            }
            return {
              layerNumber: M,
              codeblocks: V
            };
          }
          function i(T) {
            const I = T.SIZ, M = T.currentTile.index, V = T.tiles[M], J = V.codingStyleDefaultParameters.layersCount, W = I.Csiz;
            let z = 0;
            for (let se = 0; se < W; se++)
              z = Math.max(z, V.components[se].codingStyleParameters.decompositionLevelsCount);
            let G = 0, L = 0, K = 0, te = 0;
            this.nextPacket = function() {
              for (; G < J; G++) {
                for (; L <= z; L++) {
                  for (; K < W; K++) {
                    const q = V.components[K];
                    if (L > q.codingStyleParameters.decompositionLevelsCount)
                      continue;
                    const N = q.resolutions[L], Q = N.precinctParameters.numprecincts;
                    for (; te < Q; ) {
                      const D = n(N, te, G);
                      return te++, D;
                    }
                    te = 0;
                  }
                  K = 0;
                }
                L = 0;
              }
              throw new h("Out of packets");
            };
          }
          function l(T) {
            const I = T.SIZ, M = T.currentTile.index, V = T.tiles[M], J = V.codingStyleDefaultParameters.layersCount, W = I.Csiz;
            let z = 0;
            for (let se = 0; se < W; se++)
              z = Math.max(z, V.components[se].codingStyleParameters.decompositionLevelsCount);
            let G = 0, L = 0, K = 0, te = 0;
            this.nextPacket = function() {
              for (; G <= z; G++) {
                for (; L < J; L++) {
                  for (; K < W; K++) {
                    const q = V.components[K];
                    if (G > q.codingStyleParameters.decompositionLevelsCount)
                      continue;
                    const N = q.resolutions[G], Q = N.precinctParameters.numprecincts;
                    for (; te < Q; ) {
                      const D = n(N, te, L);
                      return te++, D;
                    }
                    te = 0;
                  }
                  K = 0;
                }
                L = 0;
              }
              throw new h("Out of packets");
            };
          }
          function u(T) {
            const I = T.SIZ, M = T.currentTile.index, V = T.tiles[M], J = V.codingStyleDefaultParameters.layersCount, W = I.Csiz;
            let z, G, L, K, te = 0;
            for (L = 0; L < W; L++) {
              const q = V.components[L];
              te = Math.max(te, q.codingStyleParameters.decompositionLevelsCount);
            }
            const se = new Int32Array(te + 1);
            for (G = 0; G <= te; ++G) {
              let q = 0;
              for (L = 0; L < W; ++L) {
                const N = V.components[L].resolutions;
                G < N.length && (q = Math.max(q, N[G].precinctParameters.numprecincts));
              }
              se[G] = q;
            }
            z = 0, G = 0, L = 0, K = 0, this.nextPacket = function() {
              for (; G <= te; G++) {
                for (; K < se[G]; K++) {
                  for (; L < W; L++) {
                    const N = V.components[L];
                    if (G > N.codingStyleParameters.decompositionLevelsCount)
                      continue;
                    const Q = N.resolutions[G], D = Q.precinctParameters.numprecincts;
                    if (!(K >= D)) {
                      for (; z < J; ) {
                        const ne = n(Q, K, z);
                        return z++, ne;
                      }
                      z = 0;
                    }
                  }
                  L = 0;
                }
                K = 0;
              }
              throw new h("Out of packets");
            };
          }
          function w(T) {
            const I = T.SIZ, M = T.currentTile.index, V = T.tiles[M], J = V.codingStyleDefaultParameters.layersCount, W = I.Csiz, z = A(V), G = z;
            let L = 0, K = 0, te = 0, se = 0, q = 0;
            this.nextPacket = function() {
              for (; q < G.maxNumHigh; q++) {
                for (; se < G.maxNumWide; se++) {
                  for (; te < W; te++) {
                    const Q = V.components[te], D = Q.codingStyleParameters.decompositionLevelsCount;
                    for (; K <= D; K++) {
                      const ne = Q.resolutions[K], oe = z.components[te].resolutions[K], ee = b(se, q, oe, G, ne);
                      if (ee !== null) {
                        for (; L < J; ) {
                          const $ = n(ne, ee, L);
                          return L++, $;
                        }
                        L = 0;
                      }
                    }
                    K = 0;
                  }
                  te = 0;
                }
                se = 0;
              }
              throw new h("Out of packets");
            };
          }
          function _(T) {
            const I = T.SIZ, M = T.currentTile.index, V = T.tiles[M], J = V.codingStyleDefaultParameters.layersCount, W = I.Csiz, z = A(V);
            let G = 0, L = 0, K = 0, te = 0, se = 0;
            this.nextPacket = function() {
              for (; K < W; ++K) {
                const N = V.components[K], Q = z.components[K], D = N.codingStyleParameters.decompositionLevelsCount;
                for (; se < Q.maxNumHigh; se++) {
                  for (; te < Q.maxNumWide; te++) {
                    for (; L <= D; L++) {
                      const ne = N.resolutions[L], oe = Q.resolutions[L], ee = b(te, se, oe, Q, ne);
                      if (ee !== null) {
                        for (; G < J; ) {
                          const $ = n(ne, ee, G);
                          return G++, $;
                        }
                        G = 0;
                      }
                    }
                    L = 0;
                  }
                  te = 0;
                }
                se = 0;
              }
              throw new h("Out of packets");
            };
          }
          function b(T, I, M, V, J) {
            const W = T * V.minWidth, z = I * V.minHeight;
            if (W % M.width !== 0 || z % M.height !== 0)
              return null;
            const G = z / M.width * J.precinctParameters.numprecinctswide;
            return W / M.height + G;
          }
          function A(T) {
            const I = T.components.length;
            let M = Number.MAX_VALUE, V = Number.MAX_VALUE, J = 0, W = 0;
            const z = new Array(I);
            for (let G = 0; G < I; G++) {
              const L = T.components[G], K = L.codingStyleParameters.decompositionLevelsCount, te = new Array(K + 1);
              let se = Number.MAX_VALUE, q = Number.MAX_VALUE, N = 0, Q = 0, D = 1;
              for (let ne = K; ne >= 0; --ne) {
                const oe = L.resolutions[ne], ee = D * oe.precinctParameters.precinctWidth, $ = D * oe.precinctParameters.precinctHeight;
                se = Math.min(se, ee), q = Math.min(q, $), N = Math.max(N, oe.precinctParameters.numprecinctswide), Q = Math.max(Q, oe.precinctParameters.numprecinctshigh), te[ne] = {
                  width: ee,
                  height: $
                }, D <<= 1;
              }
              M = Math.min(M, se), V = Math.min(V, q), J = Math.max(J, N), W = Math.max(W, Q), z[G] = {
                resolutions: te,
                minWidth: se,
                minHeight: q,
                maxNumWide: N,
                maxNumHigh: Q
              };
            }
            return {
              components: z,
              minWidth: M,
              minHeight: V,
              maxNumWide: J,
              maxNumHigh: W
            };
          }
          function Y(T) {
            const I = T.SIZ, M = T.currentTile.index, V = T.tiles[M], J = I.Csiz;
            for (let z = 0; z < J; z++) {
              const G = V.components[z], L = G.codingStyleParameters.decompositionLevelsCount, K = [], te = [];
              for (let se = 0; se <= L; se++) {
                const q = p(T, G, se), N = {}, Q = 1 << L - se;
                N.trx0 = Math.ceil(G.tcx0 / Q), N.try0 = Math.ceil(G.tcy0 / Q), N.trx1 = Math.ceil(G.tcx1 / Q), N.try1 = Math.ceil(G.tcy1 / Q), N.resLevel = se, m(T, N, q), K.push(N);
                let D;
                if (se === 0)
                  D = {}, D.type = "LL", D.tbx0 = Math.ceil(G.tcx0 / Q), D.tby0 = Math.ceil(G.tcy0 / Q), D.tbx1 = Math.ceil(G.tcx1 / Q), D.tby1 = Math.ceil(G.tcy1 / Q), D.resolution = N, g(T, D, q), te.push(D), N.subbands = [D];
                else {
                  const ne = 1 << L - se + 1, oe = [];
                  D = {}, D.type = "HL", D.tbx0 = Math.ceil(G.tcx0 / ne - 0.5), D.tby0 = Math.ceil(G.tcy0 / ne), D.tbx1 = Math.ceil(G.tcx1 / ne - 0.5), D.tby1 = Math.ceil(G.tcy1 / ne), D.resolution = N, g(T, D, q), te.push(D), oe.push(D), D = {}, D.type = "LH", D.tbx0 = Math.ceil(G.tcx0 / ne), D.tby0 = Math.ceil(G.tcy0 / ne - 0.5), D.tbx1 = Math.ceil(G.tcx1 / ne), D.tby1 = Math.ceil(G.tcy1 / ne - 0.5), D.resolution = N, g(T, D, q), te.push(D), oe.push(D), D = {}, D.type = "HH", D.tbx0 = Math.ceil(G.tcx0 / ne - 0.5), D.tby0 = Math.ceil(G.tcy0 / ne - 0.5), D.tbx1 = Math.ceil(G.tcx1 / ne - 0.5), D.tby1 = Math.ceil(G.tcy1 / ne - 0.5), D.resolution = N, g(T, D, q), te.push(D), oe.push(D), N.subbands = oe;
                }
              }
              G.resolutions = K, G.subbands = te;
            }
            const W = V.codingStyleDefaultParameters.progressionOrder;
            switch (W) {
              case 0:
                V.packetsIterator = new i(T);
                break;
              case 1:
                V.packetsIterator = new l(T);
                break;
              case 2:
                V.packetsIterator = new u(T);
                break;
              case 3:
                V.packetsIterator = new w(T);
                break;
              case 4:
                V.packetsIterator = new _(T);
                break;
              default:
                throw new h(`Unsupported progression order ${W}`);
            }
          }
          function j(T, I, M, V) {
            let J = 0, W, z = 0, G = !1;
            function L(ee) {
              for (; z < ee; ) {
                const $ = I[M + J];
                J++, G ? (W = W << 7 | $, z += 7, G = !1) : (W = W << 8 | $, z += 8), $ === 255 && (G = !0);
              }
              return z -= ee, W >>> z & (1 << ee) - 1;
            }
            function K(ee) {
              return I[M + J - 1] === 255 && I[M + J] === ee ? (te(1), !0) : I[M + J] === 255 && I[M + J + 1] === ee ? (te(2), !0) : !1;
            }
            function te(ee) {
              J += ee;
            }
            function se() {
              z = 0, G && (J++, G = !1);
            }
            function q() {
              if (L(1) === 0)
                return 1;
              if (L(1) === 0)
                return 2;
              let ee = L(2);
              return ee < 3 ? ee + 3 : (ee = L(5), ee < 31 ? ee + 6 : (ee = L(7), ee + 37));
            }
            const N = T.currentTile.index, Q = T.tiles[N], D = T.COD.sopMarkerUsed, ne = T.COD.ephMarkerUsed, oe = Q.packetsIterator;
            for (; J < V; ) {
              se(), D && K(145) && te(4);
              const ee = oe.nextPacket();
              if (!L(1))
                continue;
              const $ = ee.layerNumber, E = [];
              let H;
              for (let ie = 0, ue = ee.codeblocks.length; ie < ue; ie++) {
                H = ee.codeblocks[ie];
                let fe = H.precinct;
                const de = H.cbx - fe.cbxMin, pe = H.cby - fe.cbyMin;
                let xe = !1, De = !1, Ae, Se;
                if (H.included !== void 0)
                  xe = !!L(1);
                else {
                  fe = H.precinct;
                  let Ce;
                  if (fe.inclusionTree !== void 0)
                    Ce = fe.inclusionTree;
                  else {
                    const ve = fe.cbxMax - fe.cbxMin + 1, Le = fe.cbyMax - fe.cbyMin + 1;
                    Ce = new f(ve, Le, $), Se = new x(ve, Le), fe.inclusionTree = Ce, fe.zeroBitPlanesTree = Se;
                    for (let He = 0; He < $; He++)
                      if (L(1) !== 0)
                        throw new h("Invalid tag tree");
                  }
                  if (Ce.reset(de, pe, $))
                    for (; ; )
                      if (L(1)) {
                        if (Ae = !Ce.nextLevel(), Ae) {
                          H.included = !0, xe = De = !0;
                          break;
                        }
                      } else {
                        Ce.incrementValue($);
                        break;
                      }
                }
                if (!xe)
                  continue;
                if (De) {
                  for (Se = fe.zeroBitPlanesTree, Se.reset(de, pe); ; )
                    if (L(1)) {
                      if (Ae = !Se.nextLevel(), Ae)
                        break;
                    } else
                      Se.incrementValue();
                  H.zeroBitPlanes = Se.value;
                }
                const ke = q();
                for (; L(1); )
                  H.Lblock++;
                const ye = (0, a.log2)(ke), _e = (ke < 1 << ye ? ye - 1 : ye) + H.Lblock, we = L(_e);
                E.push({
                  codeblock: H,
                  codingpasses: ke,
                  dataLength: we
                });
              }
              for (se(), ne && K(146); E.length > 0; ) {
                const ie = E.shift();
                H = ie.codeblock, H.data === void 0 && (H.data = []), H.data.push({
                  data: I,
                  start: M + J,
                  end: M + J + ie.dataLength,
                  codingpasses: ie.codingpasses
                }), J += ie.dataLength;
              }
            }
            return J;
          }
          function X(T, I, M, V, J, W, z, G, L) {
            const K = V.tbx0, te = V.tby0, se = V.tbx1 - V.tbx0, q = V.codeblocks, N = V.type.charAt(0) === "H" ? 1 : 0, Q = V.type.charAt(1) === "H" ? I : 0;
            for (let D = 0, ne = q.length; D < ne; ++D) {
              const oe = q[D], ee = oe.tbx1_ - oe.tbx0_, $ = oe.tby1_ - oe.tby0_;
              if (ee === 0 || $ === 0 || oe.data === void 0)
                continue;
              const E = new U(ee, $, oe.subbandType, oe.zeroBitPlanes, W);
              let H = 2;
              const ie = oe.data;
              let ue = 0, fe = 0, de, pe, xe;
              for (de = 0, pe = ie.length; de < pe; de++)
                xe = ie[de], ue += xe.end - xe.start, fe += xe.codingpasses;
              const De = new Uint8Array(ue);
              let Ae = 0;
              for (de = 0, pe = ie.length; de < pe; de++) {
                xe = ie[de];
                const Ue = xe.data.subarray(xe.start, xe.end);
                De.set(Ue, Ae), Ae += Ue.length;
              }
              const Se = new v.ArithmeticDecoder(De, 0, ue);
              for (E.setDecoder(Se), de = 0; de < fe; de++) {
                switch (H) {
                  case 0:
                    E.runSignificancePropagationPass();
                    break;
                  case 1:
                    E.runMagnitudeRefinementPass();
                    break;
                  case 2:
                    E.runCleanupPass(), G && E.checkSegmentationSymbol();
                    break;
                }
                L && E.reset(), H = (H + 1) % 3;
              }
              let ke = oe.tbx0_ - K + (oe.tby0_ - te) * se;
              const ye = E.coefficentsSign, _e = E.coefficentsMagnitude, we = E.bitsDecoded, Ce = z ? 0 : 0.5;
              let ve, Le, He;
              Ae = 0;
              const Qe = V.type !== "LL";
              for (de = 0; de < $; de++) {
                const Ie = 2 * (ke / se | 0) * (I - se) + N + Q;
                for (ve = 0; ve < ee; ve++) {
                  if (Le = _e[Ae], Le !== 0) {
                    Le = (Le + Ce) * J, ye[Ae] !== 0 && (Le = -Le), He = we[Ae];
                    const Ee = Qe ? Ie + (ke << 1) : ke;
                    z && He >= W ? T[Ee] = Le : T[Ee] = Le * (1 << W - He);
                  }
                  ke++, Ae++;
                }
                ke += se - ee;
              }
            }
          }
          function B(T, I, M) {
            const V = I.components[M], J = V.codingStyleParameters, W = V.quantizationParameters, z = J.decompositionLevelsCount, G = W.SPqcds, L = W.scalarExpounded, K = W.guardBits, te = J.segmentationSymbolUsed, se = J.resetContextProbabilities, q = T.components[M].precision, N = J.reversibleTransformation, Q = N ? new F() : new S(), D = [];
            let ne = 0;
            for (let ee = 0; ee <= z; ee++) {
              const $ = V.resolutions[ee], E = $.trx1 - $.trx0, H = $.try1 - $.try0, ie = new Float32Array(E * H);
              for (let ue = 0, fe = $.subbands.length; ue < fe; ue++) {
                let de, pe;
                L ? (de = G[ne].mu, pe = G[ne].epsilon, ne++) : (de = G[0].mu, pe = G[0].epsilon + (ee > 0 ? 1 - ee : 0));
                const xe = $.subbands[ue], De = e[xe.type], Ae = N ? 1 : 2 ** (q + De - pe) * (1 + de / 2048), Se = K + pe - 1;
                X(ie, E, H, xe, Ae, Se, N, te, se);
              }
              D.push({
                width: E,
                height: H,
                items: ie
              });
            }
            const oe = Q.calculate(D, V.tcx0, V.tcy0);
            return {
              left: V.tcx0,
              top: V.tcy0,
              width: oe.width,
              height: oe.height,
              items: oe.items
            };
          }
          function R(T) {
            const I = T.SIZ, M = T.components, V = I.Csiz, J = [];
            for (let W = 0, z = T.tiles.length; W < z; W++) {
              const G = T.tiles[W], L = [];
              for (let E = 0; E < V; E++)
                L[E] = B(T, G, E);
              const K = L[0], te = new Uint8ClampedArray(K.items.length * V), se = {
                left: K.left,
                top: K.top,
                width: K.width,
                height: K.height,
                items: te
              };
              let q, N, Q = 0, D, ne, oe, ee, $;
              if (G.codingStyleDefaultParameters.multipleComponentTransform) {
                const E = V === 4, H = L[0].items, ie = L[1].items, ue = L[2].items, fe = E ? L[3].items : null;
                q = M[0].precision - 8, N = (128 << q) + 0.5;
                const de = G.components[0], pe = V - 3;
                if (ne = H.length, de.codingStyleParameters.reversibleTransformation)
                  for (D = 0; D < ne; D++, Q += pe) {
                    oe = H[D] + N, ee = ie[D], $ = ue[D];
                    const xe = oe - ($ + ee >> 2);
                    te[Q++] = xe + $ >> q, te[Q++] = xe >> q, te[Q++] = xe + ee >> q;
                  }
                else
                  for (D = 0; D < ne; D++, Q += pe)
                    oe = H[D] + N, ee = ie[D], $ = ue[D], te[Q++] = oe + 1.402 * $ >> q, te[Q++] = oe - 0.34413 * ee - 0.71414 * $ >> q, te[Q++] = oe + 1.772 * ee >> q;
                if (E)
                  for (D = 0, Q = 3; D < ne; D++, Q += 4)
                    te[Q] = fe[D] + N >> q;
              } else
                for (let E = 0; E < V; E++) {
                  const H = L[E].items;
                  for (q = M[E].precision - 8, N = (128 << q) + 0.5, Q = E, D = 0, ne = H.length; D < ne; D++)
                    te[Q] = H[D] + N >> q, Q += V;
                }
              J.push(se);
            }
            return J;
          }
          function k(T, I) {
            const V = T.SIZ.Csiz, J = T.tiles[I];
            for (let W = 0; W < V; W++) {
              const z = J.components[W], G = T.currentTile.QCC[W] !== void 0 ? T.currentTile.QCC[W] : T.currentTile.QCD;
              z.quantizationParameters = G;
              const L = T.currentTile.COC[W] !== void 0 ? T.currentTile.COC[W] : T.currentTile.COD;
              z.codingStyleParameters = L;
            }
            J.codingStyleDefaultParameters = T.currentTile.COD;
          }
          class x {
            constructor(I, M) {
              const V = (0, a.log2)(Math.max(I, M)) + 1;
              this.levels = [];
              for (let J = 0; J < V; J++) {
                const W = {
                  width: I,
                  height: M,
                  items: []
                };
                this.levels.push(W), I = Math.ceil(I / 2), M = Math.ceil(M / 2);
              }
            }
            reset(I, M) {
              let V = 0, J = 0, W;
              for (; V < this.levels.length; ) {
                W = this.levels[V];
                const z = I + M * W.width;
                if (W.items[z] !== void 0) {
                  J = W.items[z];
                  break;
                }
                W.index = z, I >>= 1, M >>= 1, V++;
              }
              V--, W = this.levels[V], W.items[W.index] = J, this.currentLevel = V, delete this.value;
            }
            incrementValue() {
              const I = this.levels[this.currentLevel];
              I.items[I.index]++;
            }
            nextLevel() {
              let I = this.currentLevel, M = this.levels[I];
              const V = M.items[M.index];
              return I--, I < 0 ? (this.value = V, !1) : (this.currentLevel = I, M = this.levels[I], M.items[M.index] = V, !0);
            }
          }
          class f {
            constructor(I, M, V) {
              const J = (0, a.log2)(Math.max(I, M)) + 1;
              this.levels = [];
              for (let W = 0; W < J; W++) {
                const z = new Uint8Array(I * M);
                for (let L = 0, K = z.length; L < K; L++)
                  z[L] = V;
                const G = {
                  width: I,
                  height: M,
                  items: z
                };
                this.levels.push(G), I = Math.ceil(I / 2), M = Math.ceil(M / 2);
              }
            }
            reset(I, M, V) {
              let J = 0;
              for (; J < this.levels.length; ) {
                const W = this.levels[J], z = I + M * W.width;
                W.index = z;
                const G = W.items[z];
                if (G === 255)
                  break;
                if (G > V)
                  return this.currentLevel = J, this.propagateValues(), !1;
                I >>= 1, M >>= 1, J++;
              }
              return this.currentLevel = J - 1, !0;
            }
            incrementValue(I) {
              const M = this.levels[this.currentLevel];
              M.items[M.index] = I + 1, this.propagateValues();
            }
            propagateValues() {
              let I = this.currentLevel, M = this.levels[I];
              const V = M.items[M.index];
              for (; --I >= 0; )
                M = this.levels[I], M.items[M.index] = V;
            }
            nextLevel() {
              let I = this.currentLevel, M = this.levels[I];
              const V = M.items[M.index];
              return M.items[M.index] = 255, I--, I < 0 ? !1 : (this.currentLevel = I, M = this.levels[I], M.items[M.index] = V, !0);
            }
          }
          const U = function() {
            const V = new Uint8Array([0, 5, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 1, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8]), J = new Uint8Array([0, 3, 4, 0, 5, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 1, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8]), W = new Uint8Array([0, 1, 2, 0, 1, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 3, 4, 5, 0, 4, 5, 5, 0, 5, 5, 5, 0, 0, 0, 0, 0, 6, 7, 7, 0, 7, 7, 7, 0, 7, 7, 7, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8]);
            class z {
              constructor(L, K, te, se, q) {
                this.width = L, this.height = K;
                let N;
                te === "HH" ? N = W : te === "HL" ? N = J : N = V, this.contextLabelTable = N;
                const Q = L * K;
                this.neighborsSignificance = new Uint8Array(Q), this.coefficentsSign = new Uint8Array(Q);
                let D;
                q > 14 ? D = new Uint32Array(Q) : q > 6 ? D = new Uint16Array(Q) : D = new Uint8Array(Q), this.coefficentsMagnitude = D, this.processingFlags = new Uint8Array(Q);
                const ne = new Uint8Array(Q);
                if (se !== 0)
                  for (let oe = 0; oe < Q; oe++)
                    ne[oe] = se;
                this.bitsDecoded = ne, this.reset();
              }
              setDecoder(L) {
                this.decoder = L;
              }
              reset() {
                this.contexts = new Int8Array(19), this.contexts[0] = 4 << 1 | 0, this.contexts[17] = 46 << 1 | 0, this.contexts[18] = 3 << 1 | 0;
              }
              setNeighborsSignificance(L, K, te) {
                const se = this.neighborsSignificance, q = this.width, N = this.height, Q = K > 0, D = K + 1 < q;
                let ne;
                L > 0 && (ne = te - q, Q && (se[ne - 1] += 16), D && (se[ne + 1] += 16), se[ne] += 4), L + 1 < N && (ne = te + q, Q && (se[ne - 1] += 16), D && (se[ne + 1] += 16), se[ne] += 4), Q && (se[te - 1] += 1), D && (se[te + 1] += 1), se[te] |= 128;
              }
              runSignificancePropagationPass() {
                const L = this.decoder, K = this.width, te = this.height, se = this.coefficentsMagnitude, q = this.coefficentsSign, N = this.neighborsSignificance, Q = this.processingFlags, D = this.contexts, ne = this.contextLabelTable, oe = this.bitsDecoded, ee = -2, $ = 1, E = 2;
                for (let H = 0; H < te; H += 4)
                  for (let ie = 0; ie < K; ie++) {
                    let ue = H * K + ie;
                    for (let fe = 0; fe < 4; fe++, ue += K) {
                      const de = H + fe;
                      if (de >= te)
                        break;
                      if (Q[ue] &= ee, se[ue] || !N[ue])
                        continue;
                      const pe = ne[N[ue]];
                      if (L.readBit(D, pe)) {
                        const De = this.decodeSignBit(de, ie, ue);
                        q[ue] = De, se[ue] = 1, this.setNeighborsSignificance(de, ie, ue), Q[ue] |= E;
                      }
                      oe[ue]++, Q[ue] |= $;
                    }
                  }
              }
              decodeSignBit(L, K, te) {
                const se = this.width, q = this.height, N = this.coefficentsMagnitude, Q = this.coefficentsSign;
                let D, ne, oe, ee, $, E;
                ee = K > 0 && N[te - 1] !== 0, K + 1 < se && N[te + 1] !== 0 ? (oe = Q[te + 1], ee ? (ne = Q[te - 1], D = 1 - oe - ne) : D = 1 - oe - oe) : ee ? (ne = Q[te - 1], D = 1 - ne - ne) : D = 0;
                const H = 3 * D;
                return ee = L > 0 && N[te - se] !== 0, L + 1 < q && N[te + se] !== 0 ? (oe = Q[te + se], ee ? (ne = Q[te - se], D = 1 - oe - ne + H) : D = 1 - oe - oe + H) : ee ? (ne = Q[te - se], D = 1 - ne - ne + H) : D = H, D >= 0 ? ($ = 9 + D, E = this.decoder.readBit(this.contexts, $)) : ($ = 9 - D, E = this.decoder.readBit(this.contexts, $) ^ 1), E;
              }
              runMagnitudeRefinementPass() {
                const L = this.decoder, K = this.width, te = this.height, se = this.coefficentsMagnitude, q = this.neighborsSignificance, N = this.contexts, Q = this.bitsDecoded, D = this.processingFlags, ne = 1, oe = 2, ee = K * te, $ = K * 4;
                for (let E = 0, H; E < ee; E = H) {
                  H = Math.min(ee, E + $);
                  for (let ie = 0; ie < K; ie++)
                    for (let ue = E + ie; ue < H; ue += K) {
                      if (!se[ue] || D[ue] & ne)
                        continue;
                      let fe = 16;
                      D[ue] & oe && (D[ue] ^= oe, fe = (q[ue] & 127) === 0 ? 15 : 14);
                      const de = L.readBit(N, fe);
                      se[ue] = se[ue] << 1 | de, Q[ue]++, D[ue] |= ne;
                    }
                }
              }
              runCleanupPass() {
                const L = this.decoder, K = this.width, te = this.height, se = this.neighborsSignificance, q = this.coefficentsMagnitude, N = this.coefficentsSign, Q = this.contexts, D = this.contextLabelTable, ne = this.bitsDecoded, oe = this.processingFlags, ee = 1, $ = 2, E = K, H = K * 2, ie = K * 3;
                let ue;
                for (let fe = 0; fe < te; fe = ue) {
                  ue = Math.min(fe + 4, te);
                  const de = fe * K, pe = fe + 3 < te;
                  for (let xe = 0; xe < K; xe++) {
                    const De = de + xe, Ae = pe && oe[De] === 0 && oe[De + E] === 0 && oe[De + H] === 0 && oe[De + ie] === 0 && se[De] === 0 && se[De + E] === 0 && se[De + H] === 0 && se[De + ie] === 0;
                    let Se = 0, ke = De, ye = fe, _e;
                    if (Ae) {
                      if (!L.readBit(Q, 18)) {
                        ne[De]++, ne[De + E]++, ne[De + H]++, ne[De + ie]++;
                        continue;
                      }
                      Se = L.readBit(Q, 17) << 1 | L.readBit(Q, 17), Se !== 0 && (ye = fe + Se, ke += Se * K), _e = this.decodeSignBit(ye, xe, ke), N[ke] = _e, q[ke] = 1, this.setNeighborsSignificance(ye, xe, ke), oe[ke] |= $, ke = De;
                      for (let Ce = fe; Ce <= ye; Ce++, ke += K)
                        ne[ke]++;
                      Se++;
                    }
                    for (ye = fe + Se; ye < ue; ye++, ke += K) {
                      if (q[ke] || oe[ke] & ee)
                        continue;
                      const we = D[se[ke]];
                      L.readBit(Q, we) === 1 && (_e = this.decodeSignBit(ye, xe, ke), N[ke] = _e, q[ke] = 1, this.setNeighborsSignificance(ye, xe, ke), oe[ke] |= $), ne[ke]++;
                    }
                  }
                }
              }
              checkSegmentationSymbol() {
                const L = this.decoder, K = this.contexts;
                if ((L.readBit(K, 17) << 3 | L.readBit(K, 17) << 2 | L.readBit(K, 17) << 1 | L.readBit(K, 17)) !== 10)
                  throw new h("Invalid segmentation symbol");
              }
            }
            return z;
          }();
          class O {
            constructor() {
              this.constructor === O && (0, t.unreachable)("Cannot initialize Transform.");
            }
            calculate(I, M, V) {
              let J = I[0];
              for (let W = 1, z = I.length; W < z; W++)
                J = this.iterate(J, I[W], M, V);
              return J;
            }
            extend(I, M, V) {
              let J = M - 1, W = M + 1, z = M + V - 2, G = M + V;
              I[J--] = I[W++], I[G++] = I[z--], I[J--] = I[W++], I[G++] = I[z--], I[J--] = I[W++], I[G++] = I[z--], I[J] = I[W], I[G] = I[z];
            }
            filter(I, M, V) {
              (0, t.unreachable)("Abstract method `filter` called");
            }
            iterate(I, M, V, J) {
              const W = I.width, z = I.height;
              let G = I.items;
              const L = M.width, K = M.height, te = M.items;
              let se, q, N, Q, D, ne;
              for (N = 0, se = 0; se < z; se++)
                for (Q = se * 2 * L, q = 0; q < W; q++, N++, Q += 2)
                  te[Q] = G[N];
              G = I.items = null;
              const oe = 4, ee = new Float32Array(L + 2 * oe);
              if (L === 1) {
                if (V & 1)
                  for (ne = 0, N = 0; ne < K; ne++, N += L)
                    te[N] *= 0.5;
              } else
                for (ne = 0, N = 0; ne < K; ne++, N += L)
                  ee.set(te.subarray(N, N + L), oe), this.extend(ee, oe, L), this.filter(ee, oe, L), te.set(ee.subarray(oe, oe + L), N);
              let $ = 16;
              const E = [];
              for (se = 0; se < $; se++)
                E.push(new Float32Array(K + 2 * oe));
              let H, ie = 0;
              if (I = oe + K, K === 1) {
                if (J & 1)
                  for (D = 0; D < L; D++)
                    te[D] *= 0.5;
              } else
                for (D = 0; D < L; D++) {
                  if (ie === 0) {
                    for ($ = Math.min(L - D, $), N = D, Q = oe; Q < I; N += L, Q++)
                      for (H = 0; H < $; H++)
                        E[H][Q] = te[N + H];
                    ie = $;
                  }
                  ie--;
                  const ue = E[ie];
                  if (this.extend(ue, oe, K), this.filter(ue, oe, K), ie === 0)
                    for (N = D - $ + 1, Q = oe; Q < I; N += L, Q++)
                      for (H = 0; H < $; H++)
                        te[N + H] = E[H][Q];
                }
              return {
                width: L,
                height: K,
                items: te
              };
            }
          }
          class S extends O {
            filter(I, M, V) {
              const J = V >> 1;
              M |= 0;
              let W, z, G, L;
              const K = -1.586134342059924, te = -0.052980118572961, se = 0.882911075530934, q = 0.443506852043971, N = 1.230174104914001, Q = 1 / N;
              for (W = M - 3, z = J + 4; z--; W += 2)
                I[W] *= Q;
              for (W = M - 2, G = q * I[W - 1], z = J + 3; z-- && (L = q * I[W + 1], I[W] = N * I[W] - G - L, z--); W += 2)
                W += 2, G = q * I[W + 1], I[W] = N * I[W] - G - L;
              for (W = M - 1, G = se * I[W - 1], z = J + 2; z-- && (L = se * I[W + 1], I[W] -= G + L, z--); W += 2)
                W += 2, G = se * I[W + 1], I[W] -= G + L;
              for (W = M, G = te * I[W - 1], z = J + 1; z-- && (L = te * I[W + 1], I[W] -= G + L, z--); W += 2)
                W += 2, G = te * I[W + 1], I[W] -= G + L;
              if (J !== 0)
                for (W = M + 1, G = K * I[W - 1], z = J; z-- && (L = K * I[W + 1], I[W] -= G + L, z--); W += 2)
                  W += 2, G = K * I[W + 1], I[W] -= G + L;
            }
          }
          class F extends O {
            filter(I, M, V) {
              const J = V >> 1;
              M |= 0;
              let W, z;
              for (W = M, z = J + 1; z--; W += 2)
                I[W] -= I[W - 1] + I[W + 1] + 2 >> 2;
              for (W = M + 1, z = J; z--; W += 2)
                I[W] += I[W - 1] + I[W + 1] >> 1;
            }
          }
        },
        /* 31 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.LZWStream = void 0;
          var t = C(19);
          class a extends t.DecodeStream {
            constructor(h, e, y) {
              super(e), this.str = h, this.dict = h.dict, this.cachedData = 0, this.bitsCached = 0;
              const c = 4096, d = {
                earlyChange: y,
                codeLength: 9,
                nextCode: 258,
                dictionaryValues: new Uint8Array(c),
                dictionaryLengths: new Uint16Array(c),
                dictionaryPrevCodes: new Uint16Array(c),
                currentSequence: new Uint8Array(c),
                currentSequenceLength: 0
              };
              for (let p = 0; p < 256; ++p)
                d.dictionaryValues[p] = p, d.dictionaryLengths[p] = 1;
              this.lzwState = d;
            }
            readBits(h) {
              let e = this.bitsCached, y = this.cachedData;
              for (; e < h; ) {
                const c = this.str.getByte();
                if (c === -1)
                  return this.eof = !0, null;
                y = y << 8 | c, e += 8;
              }
              return this.bitsCached = e -= h, this.cachedData = y, this.lastCode = null, y >>> e & (1 << h) - 1;
            }
            readBlock() {
              let y = 1024, c, d, p;
              const m = this.lzwState;
              if (!m)
                return;
              const g = m.earlyChange;
              let n = m.nextCode;
              const i = m.dictionaryValues, l = m.dictionaryLengths, u = m.dictionaryPrevCodes;
              let w = m.codeLength, _ = m.prevCode;
              const b = m.currentSequence;
              let A = m.currentSequenceLength, Y = 0, j = this.bufferLength, X = this.ensureBuffer(this.bufferLength + y);
              for (c = 0; c < 512; c++) {
                const B = this.readBits(w), R = A > 0;
                if (B < 256)
                  b[0] = B, A = 1;
                else if (B >= 258)
                  if (B < n)
                    for (A = l[B], d = A - 1, p = B; d >= 0; d--)
                      b[d] = i[p], p = u[p];
                  else
                    b[A++] = b[0];
                else if (B === 256) {
                  w = 9, n = 258, A = 0;
                  continue;
                } else {
                  this.eof = !0, delete this.lzwState;
                  break;
                }
                if (R && (u[n] = _, l[n] = l[_] + 1, i[n] = b[0], n++, w = n + g & n + g - 1 ? w : Math.min(Math.log(n + g) / 0.6931471805599453 + 1, 12) | 0), _ = B, Y += A, y < Y) {
                  do
                    y += 512;
                  while (y < Y);
                  X = this.ensureBuffer(this.bufferLength + y);
                }
                for (d = 0; d < A; d++)
                  X[j++] = b[d];
              }
              m.nextCode = n, m.codeLength = w, m.prevCode = _, m.currentSequenceLength = A, this.bufferLength = j;
            }
          }
          o.LZWStream = a;
        },
        /* 32 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.PredictorStream = void 0;
          var t = C(19), a = C(5), v = C(2);
          class h extends t.DecodeStream {
            constructor(y, c, d) {
              if (super(c), !(d instanceof a.Dict))
                return y;
              const p = this.predictor = d.get("Predictor") || 1;
              if (p <= 1)
                return y;
              if (p !== 2 && (p < 10 || p > 15))
                throw new v.FormatError(`Unsupported predictor: ${p}`);
              p === 2 ? this.readBlock = this.readBlockTiff : this.readBlock = this.readBlockPng, this.str = y, this.dict = y.dict;
              const m = this.colors = d.get("Colors") || 1, g = this.bits = d.get("BPC", "BitsPerComponent") || 8, n = this.columns = d.get("Columns") || 1;
              return this.pixBytes = m * g + 7 >> 3, this.rowBytes = n * m * g + 7 >> 3, this;
            }
            readBlockTiff() {
              const y = this.rowBytes, c = this.bufferLength, d = this.ensureBuffer(c + y), p = this.bits, m = this.colors, g = this.str.getBytes(y);
              if (this.eof = !g.length, this.eof)
                return;
              let n = 0, i = 0, l = 0, u = 0, w = c, _;
              if (p === 1 && m === 1)
                for (_ = 0; _ < y; ++_) {
                  let b = g[_] ^ n;
                  b ^= b >> 1, b ^= b >> 2, b ^= b >> 4, n = (b & 1) << 7, d[w++] = b;
                }
              else if (p === 8) {
                for (_ = 0; _ < m; ++_)
                  d[w++] = g[_];
                for (; _ < y; ++_)
                  d[w] = d[w - m] + g[_], w++;
              } else if (p === 16) {
                const b = m * 2;
                for (_ = 0; _ < b; ++_)
                  d[w++] = g[_];
                for (; _ < y; _ += 2) {
                  const A = ((g[_] & 255) << 8) + (g[_ + 1] & 255) + ((d[w - b] & 255) << 8) + (d[w - b + 1] & 255);
                  d[w++] = A >> 8 & 255, d[w++] = A & 255;
                }
              } else {
                const b = new Uint8Array(m + 1), A = (1 << p) - 1;
                let Y = 0, j = c;
                const X = this.columns;
                for (_ = 0; _ < X; ++_)
                  for (let B = 0; B < m; ++B)
                    l < p && (n = n << 8 | g[Y++] & 255, l += 8), b[B] = b[B] + (n >> l - p) & A, l -= p, i = i << p | b[B], u += p, u >= 8 && (d[j++] = i >> u - 8 & 255, u -= 8);
                u > 0 && (d[j++] = (i << 8 - u) + (n & (1 << 8 - u) - 1));
              }
              this.bufferLength += y;
            }
            readBlockPng() {
              const y = this.rowBytes, c = this.pixBytes, d = this.str.getByte(), p = this.str.getBytes(y);
              if (this.eof = !p.length, this.eof)
                return;
              const m = this.bufferLength, g = this.ensureBuffer(m + y);
              let n = g.subarray(m - y, m);
              n.length === 0 && (n = new Uint8Array(y));
              let i, l = m, u, w;
              switch (d) {
                case 0:
                  for (i = 0; i < y; ++i)
                    g[l++] = p[i];
                  break;
                case 1:
                  for (i = 0; i < c; ++i)
                    g[l++] = p[i];
                  for (; i < y; ++i)
                    g[l] = g[l - c] + p[i] & 255, l++;
                  break;
                case 2:
                  for (i = 0; i < y; ++i)
                    g[l++] = n[i] + p[i] & 255;
                  break;
                case 3:
                  for (i = 0; i < c; ++i)
                    g[l++] = (n[i] >> 1) + p[i];
                  for (; i < y; ++i)
                    g[l] = (n[i] + g[l - c] >> 1) + p[i] & 255, l++;
                  break;
                case 4:
                  for (i = 0; i < c; ++i)
                    u = n[i], w = p[i], g[l++] = u + w;
                  for (; i < y; ++i) {
                    u = n[i];
                    const _ = n[i - c], b = g[l - c], A = b + u - _;
                    let Y = A - b;
                    Y < 0 && (Y = -Y);
                    let j = A - u;
                    j < 0 && (j = -j);
                    let X = A - _;
                    X < 0 && (X = -X), w = p[i], Y <= j && Y <= X ? g[l++] = b + w : j <= X ? g[l++] = u + w : g[l++] = _ + w;
                  }
                  break;
                default:
                  throw new v.FormatError(`Unsupported predictor: ${d}`);
              }
              this.bufferLength += y;
            }
          }
          o.PredictorStream = h;
        },
        /* 33 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.RunLengthStream = void 0;
          var t = C(19);
          class a extends t.DecodeStream {
            constructor(h, e) {
              super(e), this.str = h, this.dict = h.dict;
            }
            readBlock() {
              const h = this.str.getBytes(2);
              if (!h || h.length < 2 || h[0] === 128) {
                this.eof = !0;
                return;
              }
              let e, y = this.bufferLength, c = h[0];
              if (c < 128) {
                if (e = this.ensureBuffer(y + c + 1), e[y++] = h[1], c > 0) {
                  const d = this.str.getBytes(c);
                  e.set(d, y), y += c;
                }
              } else {
                c = 257 - c;
                const d = h[1];
                e = this.ensureBuffer(y + c + 1);
                for (let p = 0; p < c; p++)
                  e[y++] = d;
              }
              this.bufferLength = y;
            }
          }
          o.RunLengthStream = a;
        },
        /* 34 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.Font = o.ErrorFont = void 0;
          var t = C(2), a = C(35), v = C(38), h = C(40), e = C(39), y = C(37), c = C(41), d = C(42), p = C(43), m = C(44), g = C(45), n = C(46), i = C(16), l = C(47), u = C(6), w = C(10), _ = C(48);
          const b = [[57344, 63743], [1048576, 1114109]], A = 1e3, Y = ["ascent", "bbox", "black", "bold", "charProcOperatorList", "composite", "cssFontInfo", "data", "defaultVMetrics", "defaultWidth", "descent", "fallbackName", "fontMatrix", "fontType", "isType3Font", "italic", "loadedName", "mimetype", "missingFile", "name", "remeasure", "subtype", "type", "vertical"], j = ["cMap", "defaultEncoding", "differences", "isMonospace", "isSerifFont", "isSymbolicFont", "seacMap", "toFontChar", "toUnicode", "vmetrics", "widths"];
          function X($) {
            if (!$.fontMatrix || $.fontMatrix[0] === t.FONT_IDENTITY_MATRIX[0])
              return;
            const E = 1e-3 / $.fontMatrix[0], H = $.widths;
            for (const ie in H)
              H[ie] *= E;
            $.defaultWidth *= E;
          }
          function B($, E) {
            if ($.isInternalFont || E === $.defaultEncoding || $.toUnicode instanceof d.IdentityToUnicodeMap)
              return;
            const H = [], ie = (0, e.getGlyphsUnicode)();
            for (const ue in E) {
              if ($.hasIncludedToUnicodeMap) {
                if ($.toUnicode.has(ue))
                  continue;
              } else if ($.hasEncoding && ($.differences.length === 0 || $.differences[ue] !== void 0))
                continue;
              const fe = E[ue], de = (0, h.getUnicodeForGlyph)(fe, ie);
              de !== -1 && (H[ue] = String.fromCharCode(de));
            }
            H.length > 0 && $.toUnicode.amend(H);
          }
          function R($) {
            if (!$.fallbackToUnicode || $.toUnicode instanceof d.IdentityToUnicodeMap)
              return;
            const E = [];
            for (const H in $.fallbackToUnicode)
              $.toUnicode.has(H) || (E[H] = $.fallbackToUnicode[H]);
            E.length > 0 && $.toUnicode.amend(E);
          }
          class k {
            constructor(E, H, ie, ue, fe, de, pe, xe, De) {
              this.originalCharCode = E, this.fontChar = H, this.unicode = ie, this.accent = ue, this.width = fe, this.vmetric = de, this.operatorListId = pe, this.isSpace = xe, this.isInFont = De;
              const Ae = (0, h.getCharUnicodeCategory)(ie);
              this.isWhitespace = Ae.isWhitespace, this.isZeroWidthDiacritic = Ae.isZeroWidthDiacritic, this.isInvisibleFormatMark = Ae.isInvisibleFormatMark;
            }
            matchesForCache(E, H, ie, ue, fe, de, pe, xe, De) {
              return this.originalCharCode === E && this.fontChar === H && this.unicode === ie && this.accent === ue && this.width === fe && this.vmetric === de && this.operatorListId === pe && this.isSpace === xe && this.isInFont === De;
            }
          }
          function x($, E) {
            return ($ << 8) + E;
          }
          function f($, E, H) {
            $[E + 1] = H, $[E] = H >>> 8;
          }
          function U($, E) {
            const H = ($ << 8) + E;
            return H & 32768 ? H - 65536 : H;
          }
          function O($, E, H, ie) {
            return ($ << 24) + (E << 16) + (H << 8) + ie;
          }
          function S($) {
            return String.fromCharCode($ >> 8 & 255, $ & 255);
          }
          function F($) {
            return $ > 32767 ? $ = 32767 : $ < -32768 && ($ = -32768), String.fromCharCode($ >> 8 & 255, $ & 255);
          }
          function T($) {
            const E = $.peekBytes(4);
            return (0, u.readUint32)(E, 0) === 65536 || (0, t.bytesToString)(E) === "true";
          }
          function I($) {
            const E = $.peekBytes(4);
            return (0, t.bytesToString)(E) === "ttcf";
          }
          function M($) {
            const E = $.peekBytes(4);
            return (0, t.bytesToString)(E) === "OTTO";
          }
          function V($) {
            const E = $.peekBytes(2);
            return E[0] === 37 && E[1] === 33 || E[0] === 128 && E[1] === 1;
          }
          function J($) {
            const E = $.peekBytes(4);
            return E[0] >= 1 && E[3] >= 1 && E[3] <= 4;
          }
          function W($, {
            type: E,
            subtype: H,
            composite: ie
          }) {
            let ue, fe;
            return T($) || I($) ? ie ? ue = "CIDFontType2" : ue = "TrueType" : M($) ? ie ? ue = "CIDFontType2" : ue = "OpenType" : V($) ? ie ? ue = "CIDFontType0" : ue = E === "MMType1" ? "MMType1" : "Type1" : J($) ? ie ? (ue = "CIDFontType0", fe = "CIDFontType0C") : (ue = E === "MMType1" ? "MMType1" : "Type1", fe = "Type1C") : ((0, t.warn)("getFontFileType: Unable to detect correct font file Type/Subtype."), ue = E, fe = H), [ue, fe];
          }
          function z($, E) {
            for (const H in E)
              $[+H] = E[H];
          }
          function G($, E, H) {
            const ie = [];
            let ue;
            for (let fe = 0, de = $.length; fe < de; fe++)
              ue = (0, h.getUnicodeForGlyph)($[fe], E), ue !== -1 && (ie[fe] = ue);
            for (const fe in H)
              ue = (0, h.getUnicodeForGlyph)(H[fe], E), ue !== -1 && (ie[+fe] = ue);
            return ie;
          }
          function L($, E, H = !1) {
            switch (E.length) {
              case 1:
                return E.charCodeAt(0);
              case 2:
                return E.charCodeAt(0) << 8 | E.charCodeAt(1);
            }
            const ie = `Unsupported CID string (charCode ${$}): "${E}".`;
            if (H)
              throw new t.FormatError(ie);
            return (0, t.warn)(ie), E;
          }
          function K($, E, H, ie) {
            const ue = /* @__PURE__ */ Object.create(null), fe = /* @__PURE__ */ new Map(), de = [], pe = /* @__PURE__ */ new Set();
            let xe = 0;
            const De = b[xe][0];
            let Ae = De, Se = b[xe][1];
            for (let ke in $) {
              ke |= 0;
              let ye = $[ke];
              if (!E(ye))
                continue;
              if (Ae > Se) {
                if (xe++, xe >= b.length) {
                  (0, t.warn)("Ran out of space in font private use area.");
                  break;
                }
                Ae = b[xe][0], Se = b[xe][1];
              }
              const _e = Ae++;
              ye === 0 && (ye = H);
              let we = ie.get(ke);
              typeof we == "string" && (we = we.codePointAt(0)), we && we < De && !pe.has(ye) && (fe.set(we, ye), pe.add(ye)), ue[_e] = ye, de[ke] = _e;
            }
            return {
              toFontChar: de,
              charCodeToGlyphId: ue,
              toUnicodeExtraMap: fe,
              nextAvailableFontCharCode: Ae
            };
          }
          function te($, E, H) {
            const ie = [];
            for (const de in $)
              $[de] >= H || ie.push({
                fontCharCode: de | 0,
                glyphId: $[de]
              });
            if (E)
              for (const [de, pe] of E)
                pe >= H || ie.push({
                  fontCharCode: de,
                  glyphId: pe
                });
            ie.length === 0 && ie.push({
              fontCharCode: 0,
              glyphId: 0
            }), ie.sort(function(pe, xe) {
              return pe.fontCharCode - xe.fontCharCode;
            });
            const ue = [], fe = ie.length;
            for (let de = 0; de < fe; ) {
              const pe = ie[de].fontCharCode, xe = [ie[de].glyphId];
              ++de;
              let De = pe;
              for (; de < fe && De + 1 === ie[de].fontCharCode && (xe.push(ie[de].glyphId), ++De, ++de, De !== 65535); )
                ;
              ue.push([pe, De, xe]);
            }
            return ue;
          }
          function se($, E, H) {
            const ie = te($, E, H), ue = ie.at(-1)[1] > 65535 ? 2 : 1;
            let fe = "\0\0" + S(ue) + "\0\0" + (0, t.string32)(4 + ue * 8), de, pe, xe, De;
            for (de = ie.length - 1; de >= 0 && !(ie[de][0] <= 65535); --de)
              ;
            const Ae = de + 1;
            ie[de][0] < 65535 && ie[de][1] === 65535 && (ie[de][1] = 65534);
            const Se = ie[de][1] < 65535 ? 1 : 0, ke = Ae + Se, ye = l.OpenTypeFileBuilder.getSearchParams(ke, 2);
            let _e = "", we = "", Ce = "", ve = "", Le = "", He = 0, Qe, Ue, Ie, Ee;
            for (de = 0, pe = Ae; de < pe; de++) {
              Qe = ie[de], Ue = Qe[0], Ie = Qe[1], _e += S(Ue), we += S(Ie), Ee = Qe[2];
              let ft = !0;
              for (xe = 1, De = Ee.length; xe < De; ++xe)
                if (Ee[xe] !== Ee[xe - 1] + 1) {
                  ft = !1;
                  break;
                }
              if (ft) {
                const Te = Ee[0];
                Ce += S(Te - Ue & 65535), ve += S(0);
              } else {
                const Te = (ke - de) * 2 + He * 2;
                for (He += Ie - Ue + 1, Ce += S(0), ve += S(Te), xe = 0, De = Ee.length; xe < De; ++xe)
                  Le += S(Ee[xe]);
              }
            }
            Se > 0 && (we += "ÿÿ", _e += "ÿÿ", Ce += "\0", ve += "\0\0");
            const et = "\0\0" + S(2 * ke) + S(ye.range) + S(ye.entry) + S(ye.rangeShift) + we + "\0\0" + _e + Ce + ve + Le;
            let qe = "", tt = "";
            if (ue > 1) {
              for (fe += `\0\0
` + (0, t.string32)(4 + ue * 8 + 4 + et.length), qe = "", de = 0, pe = ie.length; de < pe; de++) {
                Qe = ie[de], Ue = Qe[0], Ee = Qe[2];
                let ft = Ee[0];
                for (xe = 1, De = Ee.length; xe < De; ++xe)
                  Ee[xe] !== Ee[xe - 1] + 1 && (Ie = Qe[0] + xe - 1, qe += (0, t.string32)(Ue) + (0, t.string32)(Ie) + (0, t.string32)(ft), Ue = Ie + 1, ft = Ee[xe]);
                qe += (0, t.string32)(Ue) + (0, t.string32)(Qe[1]) + (0, t.string32)(ft);
              }
              tt = "\0\f\0\0" + (0, t.string32)(qe.length + 16) + "\0\0\0\0" + (0, t.string32)(qe.length / 12);
            }
            return fe + "\0" + S(et.length + 4) + et + tt + qe;
          }
          function q($, E) {
            E.pos = (E.start || 0) + $.offset;
            const H = E.getUint16();
            E.skip(60);
            const ie = E.getUint16();
            if (H < 4 && ie & 768)
              return !1;
            const ue = E.getUint16(), fe = E.getUint16();
            return ue > fe || (E.skip(6), E.getUint16() === 0) ? !1 : ($.data[8] = $.data[9] = 0, !0);
          }
          function N($, E, H) {
            H = H || {
              unitsPerEm: 0,
              yMax: 0,
              yMin: 0,
              ascent: 0,
              descent: 0
            };
            let ie = 0, ue = 0, fe = 0, de = 0, pe = null, xe = 0;
            if (E) {
              for (let Ce in E) {
                Ce |= 0, (pe > Ce || !pe) && (pe = Ce), xe < Ce && (xe = Ce);
                const ve = (0, h.getUnicodeRangeFor)(Ce);
                if (ve < 32)
                  ie |= 1 << ve;
                else if (ve < 64)
                  ue |= 1 << ve - 32;
                else if (ve < 96)
                  fe |= 1 << ve - 64;
                else if (ve < 123)
                  de |= 1 << ve - 96;
                else
                  throw new t.FormatError("Unicode ranges Bits > 123 are reserved for internal usage");
              }
              xe > 65535 && (xe = 65535);
            } else
              pe = 0, xe = 255;
            const De = $.bbox || [0, 0, 0, 0], Ae = H.unitsPerEm || 1 / ($.fontMatrix || t.FONT_IDENTITY_MATRIX)[0], Se = $.ascentScaled ? 1 : Ae / A, ke = H.ascent || Math.round(Se * ($.ascent || De[3]));
            let ye = H.descent || Math.round(Se * ($.descent || De[1]));
            ye > 0 && $.descent > 0 && De[1] < 0 && (ye = -ye);
            const _e = H.yMax || ke, we = -H.yMin || -ye;
            return "\0$ô\0\0\0»\0\0\0»\0\0ß\x001\0\0\0\0" + String.fromCharCode($.fixedPitch ? 9 : 0) + "\0\0\0\0\0\0" + (0, t.string32)(ie) + (0, t.string32)(ue) + (0, t.string32)(fe) + (0, t.string32)(de) + "*21*" + S($.italicAngle ? 1 : 0) + S(pe || $.firstChar) + S(xe || $.lastChar) + S(ke) + S(ye) + "\0d" + S(_e) + S(we) + "\0\0\0\0\0\0\0\0" + S($.xHeight) + S($.capHeight) + S(0) + S(pe || $.firstChar) + "\0";
          }
          function Q($) {
            const E = Math.floor($.italicAngle * 65536);
            return "\0\0\0" + (0, t.string32)(E) + "\0\0\0\0" + (0, t.string32)($.fixedPitch ? 1 : 0) + "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
          }
          function D($) {
            return $.replace(/[^\x21-\x7E]|[[\](){}<>/%]/g, "").slice(0, 63);
          }
          function ne($, E) {
            E || (E = [[], []]);
            const H = [E[0][0] || "Original licence", E[0][1] || $, E[0][2] || "Unknown", E[0][3] || "uniqueID", E[0][4] || $, E[0][5] || "Version 0.11", E[0][6] || D($), E[0][7] || "Unknown", E[0][8] || "Unknown", E[0][9] || "Unknown"], ie = [];
            let ue, fe, de, pe, xe;
            for (ue = 0, fe = H.length; ue < fe; ue++) {
              xe = E[1][ue] || H[ue];
              const Ce = [];
              for (de = 0, pe = xe.length; de < pe; de++)
                Ce.push(S(xe.charCodeAt(de)));
              ie.push(Ce.join(""));
            }
            const De = [H, ie], Ae = ["\0", "\0"], Se = ["\0\0", "\0"], ke = ["\0\0", "	"], ye = H.length * Ae.length;
            let _e = "\0\0" + S(ye) + S(ye * 12 + 6), we = 0;
            for (ue = 0, fe = Ae.length; ue < fe; ue++) {
              const Ce = De[ue];
              for (de = 0, pe = Ce.length; de < pe; de++) {
                xe = Ce[de];
                const ve = Ae[ue] + Se[ue] + ke[ue] + S(de) + S(xe.length) + S(we);
                _e += ve, we += xe.length;
              }
            }
            return _e += H.join("") + ie.join(""), _e;
          }
          class oe {
            constructor(E, H, ie) {
              this.name = E, this.psName = null, this.mimetype = null, this.disableFontFace = !1, this.loadedName = ie.loadedName, this.isType3Font = ie.isType3Font, this.missingFile = !1, this.cssFontInfo = ie.cssFontInfo, this._charsCache = /* @__PURE__ */ Object.create(null), this._glyphCache = /* @__PURE__ */ Object.create(null);
              let ue = !!(ie.flags & v.FontFlags.Serif);
              if (!ue && !ie.isSimulatedFlags) {
                const De = E.replace(/[,_]/g, "-").split("-")[0], Ae = (0, c.getSerifFonts)();
                for (const Se of De.split("+"))
                  if (Ae[Se]) {
                    ue = !0;
                    break;
                  }
              }
              this.isSerifFont = ue, this.isSymbolicFont = !!(ie.flags & v.FontFlags.Symbolic), this.isMonospace = !!(ie.flags & v.FontFlags.FixedPitch);
              let fe = ie.type, de = ie.subtype;
              this.type = fe, this.subtype = de;
              let pe = "sans-serif";
              if (this.isMonospace ? pe = "monospace" : this.isSerifFont && (pe = "serif"), this.fallbackName = pe, this.differences = ie.differences, this.widths = ie.widths, this.defaultWidth = ie.defaultWidth, this.composite = ie.composite, this.cMap = ie.cMap, this.capHeight = ie.capHeight / A, this.ascent = ie.ascent / A, this.descent = ie.descent / A, this.lineHeight = this.ascent - this.descent, this.fontMatrix = ie.fontMatrix, this.bbox = ie.bbox, this.defaultEncoding = ie.defaultEncoding, this.toUnicode = ie.toUnicode, this.toFontChar = [], ie.type === "Type3") {
                for (let De = 0; De < 256; De++)
                  this.toFontChar[De] = this.differences[De] || ie.defaultEncoding[De];
                this.fontType = t.FontType.TYPE3;
                return;
              }
              if (this.cidEncoding = ie.cidEncoding || "", this.vertical = !!ie.vertical, this.vertical && (this.vmetrics = ie.vmetrics, this.defaultVMetrics = ie.defaultVMetrics), !H || H.isEmpty) {
                H && (0, t.warn)('Font file is empty in "' + E + '" (' + this.loadedName + ")"), this.fallbackToSystemFont(ie);
                return;
              }
              [fe, de] = W(H, ie), (fe !== this.type || de !== this.subtype) && (0, t.info)(`Inconsistent font file Type/SubType, expected: ${this.type}/${this.subtype} but found: ${fe}/${de}.`);
              let xe;
              try {
                switch (fe) {
                  case "MMType1":
                    (0, t.info)("MMType1 font (" + E + "), falling back to Type1.");
                  case "Type1":
                  case "CIDFontType0":
                    this.mimetype = "font/opentype";
                    const De = de === "Type1C" || de === "CIDFontType0C" ? new p.CFFFont(H, ie) : new _.Type1Font(E, H, ie);
                    X(ie), xe = this.convert(E, De, ie);
                    break;
                  case "OpenType":
                  case "TrueType":
                  case "CIDFontType2":
                    this.mimetype = "font/opentype", xe = this.checkAndRepair(E, H, ie), this.isOpenType && (X(ie), fe = "OpenType");
                    break;
                  default:
                    throw new t.FormatError(`Font ${fe} is not supported`);
                }
              } catch (De) {
                (0, t.warn)(De), this.fallbackToSystemFont(ie);
                return;
              }
              R(ie), this.data = xe, this.fontType = (0, v.getFontType)(fe, de, ie.isStandardFont), this.fontMatrix = ie.fontMatrix, this.widths = ie.widths, this.defaultWidth = ie.defaultWidth, this.toUnicode = ie.toUnicode, this.seacMap = ie.seacMap;
            }
            get renderer() {
              const E = m.FontRendererFactory.create(this, v.SEAC_ANALYSIS_ENABLED);
              return (0, t.shadow)(this, "renderer", E);
            }
            exportData(E = !1) {
              const H = E ? [...Y, ...j] : Y, ie = /* @__PURE__ */ Object.create(null);
              let ue, fe;
              for (ue of H)
                fe = this[ue], fe !== void 0 && (ie[ue] = fe);
              return ie;
            }
            fallbackToSystemFont(E) {
              this.missingFile = !0;
              const H = this.name, ie = this.type, ue = this.subtype;
              let fe = (0, v.normalizeFontName)(H);
              const de = (0, c.getStdFontMap)(), pe = (0, c.getNonStdFontMap)(), xe = !!de[fe], De = !!(pe[fe] && de[pe[fe]]);
              fe = de[fe] || pe[fe] || fe;
              const Se = (0, g.getFontBasicMetrics)()[fe];
              Se && (isNaN(this.ascent) && (this.ascent = Se.ascent / A), isNaN(this.descent) && (this.descent = Se.descent / A), isNaN(this.capHeight) && (this.capHeight = Se.capHeight / A)), this.bold = fe.search(/bold/gi) !== -1, this.italic = fe.search(/oblique/gi) !== -1 || fe.search(/italic/gi) !== -1, this.black = H.search(/Black/g) !== -1;
              const ke = H.search(/Narrow/g) !== -1;
              if (this.remeasure = (!xe || ke) && Object.keys(this.widths).length > 0, (xe || De) && ie === "CIDFontType2" && this.cidEncoding.startsWith("Identity-")) {
                const ye = E.cidToGidMap, _e = [];
                if (z(_e, (0, c.getGlyphMapForStandardFonts)()), /Arial-?Black/i.test(H) ? z(_e, (0, c.getSupplementalGlyphMapForArialBlack)()) : /Calibri/i.test(H) && z(_e, (0, c.getSupplementalGlyphMapForCalibri)()), ye) {
                  for (const we in _e) {
                    const Ce = _e[we];
                    ye[Ce] !== void 0 && (_e[+we] = ye[Ce]);
                  }
                  ye.length !== this.toUnicode.length && E.hasIncludedToUnicodeMap && this.toUnicode instanceof d.IdentityToUnicodeMap && this.toUnicode.forEach(function(we, Ce) {
                    const ve = _e[we];
                    ye[ve] === void 0 && (_e[+we] = Ce);
                  });
                }
                this.toUnicode instanceof d.IdentityToUnicodeMap || this.toUnicode.forEach(function(we, Ce) {
                  _e[+we] = Ce;
                }), this.toFontChar = _e, this.toUnicode = new d.ToUnicodeMap(_e);
              } else if (/Symbol/i.test(fe))
                this.toFontChar = G(y.SymbolSetEncoding, (0, e.getGlyphsUnicode)(), this.differences);
              else if (/Dingbats/i.test(fe))
                /Wingdings/i.test(H) && (0, t.warn)("Non-embedded Wingdings font, falling back to ZapfDingbats."), this.toFontChar = G(y.ZapfDingbatsEncoding, (0, e.getDingbatsGlyphsUnicode)(), this.differences);
              else if (xe) {
                const ye = G(this.defaultEncoding, (0, e.getGlyphsUnicode)(), this.differences);
                ie === "CIDFontType2" && !this.cidEncoding.startsWith("Identity-") && !(this.toUnicode instanceof d.IdentityToUnicodeMap) && this.toUnicode.forEach(function(_e, we) {
                  ye[+_e] = we;
                }), this.toFontChar = ye;
              } else {
                const ye = (0, e.getGlyphsUnicode)(), _e = [];
                this.toUnicode.forEach((we, Ce) => {
                  if (!this.composite) {
                    const ve = this.differences[we] || this.defaultEncoding[we], Le = (0, h.getUnicodeForGlyph)(ve, ye);
                    Le !== -1 && (Ce = Le);
                  }
                  _e[+we] = Ce;
                }), this.composite && this.toUnicode instanceof d.IdentityToUnicodeMap && /Verdana/i.test(H) && z(_e, (0, c.getGlyphMapForStandardFonts)()), this.toFontChar = _e;
              }
              R(E), this.loadedName = fe.split("-")[0], this.fontType = (0, v.getFontType)(ie, ue, E.isStandardFont);
            }
            checkAndRepair(E, H, ie) {
              const ue = ["OS/2", "cmap", "head", "hhea", "hmtx", "maxp", "name", "post", "loca", "glyf", "fpgm", "prep", "cvt ", "CFF "];
              function fe(Ke, Ge) {
                const nt = /* @__PURE__ */ Object.create(null);
                nt["OS/2"] = null, nt.cmap = null, nt.head = null, nt.hhea = null, nt.hmtx = null, nt.maxp = null, nt.name = null, nt.post = null;
                for (let it = 0; it < Ge; it++) {
                  const pt = de(Ke);
                  ue.includes(pt.tag) && pt.length !== 0 && (nt[pt.tag] = pt);
                }
                return nt;
              }
              function de(Ke) {
                const Ge = Ke.getString(4), nt = Ke.getInt32() >>> 0, it = Ke.getInt32() >>> 0, pt = Ke.getInt32() >>> 0, Ft = Ke.pos;
                Ke.pos = Ke.start || 0, Ke.skip(it);
                const mt = Ke.getBytes(pt);
                return Ke.pos = Ft, Ge === "head" && (mt[8] = mt[9] = mt[10] = mt[11] = 0, mt[17] |= 32), {
                  tag: Ge,
                  checksum: nt,
                  length: pt,
                  offset: it,
                  data: mt
                };
              }
              function pe(Ke) {
                return {
                  version: Ke.getString(4),
                  numTables: Ke.getUint16(),
                  searchRange: Ke.getUint16(),
                  entrySelector: Ke.getUint16(),
                  rangeShift: Ke.getUint16()
                };
              }
              function xe(Ke) {
                const Ge = Ke.getString(4);
                (0, t.assert)(Ge === "ttcf", "Must be a TrueType Collection font.");
                const nt = Ke.getUint16(), it = Ke.getUint16(), pt = Ke.getInt32() >>> 0, Ft = [];
                for (let ct = 0; ct < pt; ct++)
                  Ft.push(Ke.getInt32() >>> 0);
                const mt = {
                  ttcTag: Ge,
                  majorVersion: nt,
                  minorVersion: it,
                  numFonts: pt,
                  offsetTable: Ft
                };
                switch (nt) {
                  case 1:
                    return mt;
                  case 2:
                    return mt.dsigTag = Ke.getInt32() >>> 0, mt.dsigLength = Ke.getInt32() >>> 0, mt.dsigOffset = Ke.getInt32() >>> 0, mt;
                }
                throw new t.FormatError(`Invalid TrueType Collection majorVersion: ${nt}.`);
              }
              function De(Ke, Ge) {
                const {
                  numFonts: nt,
                  offsetTable: it
                } = xe(Ke), pt = Ge.split("+");
                let Ft;
                for (let mt = 0; mt < nt; mt++) {
                  Ke.pos = (Ke.start || 0) + it[mt];
                  const ct = pe(Ke), bt = fe(Ke, ct.numTables);
                  if (!bt.name)
                    throw new t.FormatError('TrueType Collection font must contain a "name" table.');
                  const wt = Ce(bt.name);
                  for (let Ot = 0, Et = wt.length; Ot < Et; Ot++)
                    for (let St = 0, Pe = wt[Ot].length; St < Pe; St++) {
                      const We = wt[Ot][St] && wt[Ot][St].replace(/\s/g, "");
                      if (We) {
                        if (We === Ge)
                          return {
                            header: ct,
                            tables: bt
                          };
                        if (!(pt.length < 2))
                          for (const Je of pt)
                            We === Je && (Ft = {
                              name: Je,
                              header: ct,
                              tables: bt
                            });
                      }
                    }
                }
                if (Ft)
                  return (0, t.warn)(`TrueType Collection does not contain "${Ge}" font, falling back to "${Ft.name}" font instead.`), {
                    header: Ft.header,
                    tables: Ft.tables
                  };
                throw new t.FormatError(`TrueType Collection does not contain "${Ge}" font.`);
              }
              function Ae(Ke, Ge, nt, it) {
                if (!Ke)
                  return (0, t.warn)("No cmap table available."), {
                    platformId: -1,
                    encodingId: -1,
                    mappings: [],
                    hasShortCmap: !1
                  };
                let pt, Ft = (Ge.start || 0) + Ke.offset;
                Ge.pos = Ft, Ge.skip(2);
                const mt = Ge.getUint16();
                let ct, bt = !1;
                for (let We = 0; We < mt; We++) {
                  const Je = Ge.getUint16(), Ye = Ge.getUint16(), gt = Ge.getInt32() >>> 0;
                  let Dt = !1;
                  if (!(ct && ct.platformId === Je && ct.encodingId === Ye)) {
                    if (Je === 0 && (Ye === 0 || Ye === 1 || Ye === 3))
                      Dt = !0;
                    else if (Je === 1 && Ye === 0)
                      Dt = !0;
                    else if (Je === 3 && Ye === 1 && (it || !ct))
                      Dt = !0, nt || (bt = !0);
                    else if (nt && Je === 3 && Ye === 0) {
                      Dt = !0;
                      let Xt = !0;
                      if (We < mt - 1) {
                        const kt = Ge.peekBytes(2);
                        x(kt[0], kt[1]) < Je && (Xt = !1);
                      }
                      Xt && (bt = !0);
                    }
                    if (Dt && (ct = {
                      platformId: Je,
                      encodingId: Ye,
                      offset: gt
                    }), bt)
                      break;
                  }
                }
                if (ct && (Ge.pos = Ft + ct.offset), !ct || Ge.peekByte() === -1)
                  return (0, t.warn)("Could not find a preferred cmap table."), {
                    platformId: -1,
                    encodingId: -1,
                    mappings: [],
                    hasShortCmap: !1
                  };
                const wt = Ge.getUint16();
                let Ot = !1;
                const Et = [];
                let St, Pe;
                if (wt === 0) {
                  for (Ge.skip(4), St = 0; St < 256; St++) {
                    const We = Ge.getByte();
                    We && Et.push({
                      charCode: St,
                      glyphId: We
                    });
                  }
                  Ot = !0;
                } else if (wt === 2) {
                  Ge.skip(4);
                  const We = [];
                  let Je = 0;
                  for (let gt = 0; gt < 256; gt++) {
                    const Dt = Ge.getUint16() >> 3;
                    We.push(Dt), Je = Math.max(Dt, Je);
                  }
                  const Ye = [];
                  for (let gt = 0; gt <= Je; gt++)
                    Ye.push({
                      firstCode: Ge.getUint16(),
                      entryCount: Ge.getUint16(),
                      idDelta: U(Ge.getByte(), Ge.getByte()),
                      idRangePos: Ge.pos + Ge.getUint16()
                    });
                  for (let gt = 0; gt < 256; gt++)
                    if (We[gt] === 0)
                      Ge.pos = Ye[0].idRangePos + 2 * gt, Pe = Ge.getUint16(), Et.push({
                        charCode: gt,
                        glyphId: Pe
                      });
                    else {
                      const Dt = Ye[We[gt]];
                      for (St = 0; St < Dt.entryCount; St++) {
                        const Xt = (gt << 8) + St + Dt.firstCode;
                        Ge.pos = Dt.idRangePos + 2 * St, Pe = Ge.getUint16(), Pe !== 0 && (Pe = (Pe + Dt.idDelta) % 65536), Et.push({
                          charCode: Xt,
                          glyphId: Pe
                        });
                      }
                    }
                } else if (wt === 4) {
                  Ge.skip(4);
                  const We = Ge.getUint16() >> 1;
                  Ge.skip(6);
                  const Je = [];
                  let Ye;
                  for (Ye = 0; Ye < We; Ye++)
                    Je.push({
                      end: Ge.getUint16()
                    });
                  for (Ge.skip(2), Ye = 0; Ye < We; Ye++)
                    Je[Ye].start = Ge.getUint16();
                  for (Ye = 0; Ye < We; Ye++)
                    Je[Ye].delta = Ge.getUint16();
                  let gt = 0, Dt;
                  for (Ye = 0; Ye < We; Ye++) {
                    pt = Je[Ye];
                    const kt = Ge.getUint16();
                    if (!kt) {
                      pt.offsetIndex = -1;
                      continue;
                    }
                    Dt = (kt >> 1) - (We - Ye), pt.offsetIndex = Dt, gt = Math.max(gt, Dt + pt.end - pt.start + 1);
                  }
                  const Xt = [];
                  for (St = 0; St < gt; St++)
                    Xt.push(Ge.getUint16());
                  for (Ye = 0; Ye < We; Ye++) {
                    pt = Je[Ye], Ft = pt.start;
                    const kt = pt.end, Pt = pt.delta;
                    for (Dt = pt.offsetIndex, St = Ft; St <= kt; St++)
                      St !== 65535 && (Pe = Dt < 0 ? St : Xt[Dt + St - Ft], Pe = Pe + Pt & 65535, Et.push({
                        charCode: St,
                        glyphId: Pe
                      }));
                  }
                } else if (wt === 6) {
                  Ge.skip(4);
                  const We = Ge.getUint16(), Je = Ge.getUint16();
                  for (St = 0; St < Je; St++) {
                    Pe = Ge.getUint16();
                    const Ye = We + St;
                    Et.push({
                      charCode: Ye,
                      glyphId: Pe
                    });
                  }
                } else if (wt === 12) {
                  Ge.skip(10);
                  const We = Ge.getInt32() >>> 0;
                  for (St = 0; St < We; St++) {
                    const Je = Ge.getInt32() >>> 0, Ye = Ge.getInt32() >>> 0;
                    let gt = Ge.getInt32() >>> 0;
                    for (let Dt = Je; Dt <= Ye; Dt++)
                      Et.push({
                        charCode: Dt,
                        glyphId: gt++
                      });
                  }
                } else
                  return (0, t.warn)("cmap table has unsupported format: " + wt), {
                    platformId: -1,
                    encodingId: -1,
                    mappings: [],
                    hasShortCmap: !1
                  };
                Et.sort(function(We, Je) {
                  return We.charCode - Je.charCode;
                });
                for (let We = 1; We < Et.length; We++)
                  Et[We - 1].charCode === Et[We].charCode && (Et.splice(We, 1), We--);
                return {
                  platformId: ct.platformId,
                  encodingId: ct.encodingId,
                  mappings: Et,
                  hasShortCmap: Ot
                };
              }
              function Se(Ke, Ge, nt, it, pt, Ft) {
                if (!Ge) {
                  nt && (nt.data = null);
                  return;
                }
                Ke.pos = (Ke.start || 0) + Ge.offset, Ke.pos += 4, Ke.pos += 2, Ke.pos += 2, Ke.pos += 2, Ke.pos += 2, Ke.pos += 2, Ke.pos += 2, Ke.pos += 2, Ke.pos += 2, Ke.pos += 2;
                const mt = Ke.getUint16();
                Ke.pos += 8, Ke.pos += 2;
                let ct = Ke.getUint16();
                mt !== 0 && (x(it.data[44], it.data[45]) & 2 || (Ge.data[22] = 0, Ge.data[23] = 0)), ct > pt && ((0, t.info)(`The numOfMetrics (${ct}) should not be greater than the numGlyphs (${pt}).`), ct = pt, Ge.data[34] = (ct & 65280) >> 8, Ge.data[35] = ct & 255);
                const wt = pt - ct - (nt.length - ct * 4 >> 1);
                if (wt > 0) {
                  const Ot = new Uint8Array(nt.length + wt * 2);
                  Ot.set(nt.data), Ft && (Ot[nt.length] = nt.data[2], Ot[nt.length + 1] = nt.data[3]), nt.data = Ot;
                }
              }
              function ke(Ke, Ge, nt, it, pt, Ft) {
                const mt = {
                  length: 0,
                  sizeOfInstructions: 0
                };
                if (nt - Ge <= 12)
                  return mt;
                const ct = Ke.subarray(Ge, nt);
                let bt = U(ct[0], ct[1]);
                if (bt < 0)
                  return bt = -1, f(ct, 0, bt), it.set(ct, pt), mt.length = ct.length, mt;
                let wt, Ot = 10, Et = 0;
                for (wt = 0; wt < bt; wt++)
                  Et = (ct[Ot] << 8 | ct[Ot + 1]) + 1, Ot += 2;
                const St = Ot, Pe = ct[Ot] << 8 | ct[Ot + 1];
                mt.sizeOfInstructions = Pe, Ot += 2 + Pe;
                const We = Ot;
                let Je = 0;
                for (wt = 0; wt < Et; wt++) {
                  const gt = ct[Ot++];
                  gt & 192 && (ct[Ot - 1] = gt & 63);
                  let Dt = 2;
                  gt & 2 ? Dt = 1 : gt & 16 && (Dt = 0);
                  let Xt = 2;
                  gt & 4 ? Xt = 1 : gt & 32 && (Xt = 0);
                  const kt = Dt + Xt;
                  if (Je += kt, gt & 8) {
                    const Pt = ct[Ot++];
                    wt += Pt, Je += Pt * kt;
                  }
                }
                if (Je === 0)
                  return mt;
                let Ye = Ot + Je;
                return Ye > ct.length ? mt : !Ft && Pe > 0 ? (it.set(ct.subarray(0, St), pt), it.set([0, 0], pt + St), it.set(ct.subarray(We, Ye), pt + St + 2), Ye -= Pe, ct.length - Ye > 3 && (Ye = Ye + 3 & -4), mt.length = Ye, mt) : ct.length - Ye > 3 ? (Ye = Ye + 3 & -4, it.set(ct.subarray(0, Ye), pt), mt.length = Ye, mt) : (it.set(ct, pt), mt.length = ct.length, mt);
              }
              function ye(Ke, Ge, nt) {
                const it = Ke.data, pt = O(it[0], it[1], it[2], it[3]);
                pt >> 16 !== 1 && ((0, t.info)("Attempting to fix invalid version in head table: " + pt), it[0] = 0, it[1] = 1, it[2] = 0, it[3] = 0);
                const Ft = x(it[50], it[51]);
                if (Ft < 0 || Ft > 1) {
                  (0, t.info)("Attempting to fix invalid indexToLocFormat in head table: " + Ft);
                  const mt = Ge + 1;
                  if (nt === mt << 1)
                    it[50] = 0, it[51] = 0;
                  else if (nt === mt << 2)
                    it[50] = 0, it[51] = 1;
                  else
                    throw new t.FormatError("Could not fix indexToLocFormat: " + Ft);
                }
              }
              function _e(Ke, Ge, nt, it, pt, Ft, mt) {
                let ct, bt, wt;
                it ? (ct = 4, bt = function(zt, Yt) {
                  return zt[Yt] << 24 | zt[Yt + 1] << 16 | zt[Yt + 2] << 8 | zt[Yt + 3];
                }, wt = function(zt, Yt, an) {
                  zt[Yt] = an >>> 24 & 255, zt[Yt + 1] = an >> 16 & 255, zt[Yt + 2] = an >> 8 & 255, zt[Yt + 3] = an & 255;
                }) : (ct = 2, bt = function(zt, Yt) {
                  return zt[Yt] << 9 | zt[Yt + 1] << 1;
                }, wt = function(zt, Yt, an) {
                  zt[Yt] = an >> 9 & 255, zt[Yt + 1] = an >> 1 & 255;
                });
                const Ot = Ft ? nt + 1 : nt, Et = ct * (1 + Ot), St = new Uint8Array(Et);
                St.set(Ke.data.subarray(0, Et)), Ke.data = St;
                const Pe = Ge.data, We = Pe.length, Je = new Uint8Array(We);
                let Ye, gt;
                const Dt = [];
                for (Ye = 0, gt = 0; Ye < nt + 1; Ye++, gt += ct) {
                  let Pt = bt(St, gt);
                  Pt > We && (Pt = We), Dt.push({
                    index: Ye,
                    offset: Pt,
                    endOffset: 0
                  });
                }
                for (Dt.sort((Pt, zt) => Pt.offset - zt.offset), Ye = 0; Ye < nt; Ye++)
                  Dt[Ye].endOffset = Dt[Ye + 1].offset;
                for (Dt.sort((Pt, zt) => Pt.index - zt.index), Ye = 0; Ye < nt; Ye++) {
                  const {
                    offset: Pt,
                    endOffset: zt
                  } = Dt[Ye];
                  if (Pt !== 0 || zt !== 0)
                    break;
                  const Yt = Dt[Ye + 1].offset;
                  if (Yt !== 0) {
                    Dt[Ye].endOffset = Yt;
                    break;
                  }
                }
                const Xt = /* @__PURE__ */ Object.create(null);
                let kt = 0;
                for (wt(St, 0, kt), Ye = 0, gt = ct; Ye < nt; Ye++, gt += ct) {
                  const Pt = ke(Pe, Dt[Ye].offset, Dt[Ye].endOffset, Je, kt, pt), zt = Pt.length;
                  zt === 0 && (Xt[Ye] = !0), Pt.sizeOfInstructions > mt && (mt = Pt.sizeOfInstructions), kt += zt, wt(St, gt, kt);
                }
                if (kt === 0) {
                  const Pt = new Uint8Array([0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0]);
                  for (Ye = 0, gt = ct; Ye < Ot; Ye++, gt += ct)
                    wt(St, gt, Pt.length);
                  Ge.data = Pt;
                } else if (Ft) {
                  const Pt = bt(St, ct);
                  Je.length > Pt + kt ? Ge.data = Je.subarray(0, Pt + kt) : (Ge.data = new Uint8Array(Pt + kt), Ge.data.set(Je.subarray(0, kt))), Ge.data.set(Je.subarray(0, Pt), kt), wt(Ke.data, St.length - ct, kt + Pt);
                } else
                  Ge.data = Je.subarray(0, kt);
                return {
                  missingGlyphs: Xt,
                  maxSizeOfInstructions: mt
                };
              }
              function we(Ke, Ge, nt) {
                const it = (H.start || 0) + Ke.offset;
                H.pos = it;
                const pt = Ke.length, Ft = it + pt, mt = H.getInt32();
                H.skip(28);
                let ct, bt = !0, wt;
                switch (mt) {
                  case 65536:
                    ct = v.MacStandardGlyphOrdering;
                    break;
                  case 131072:
                    const Ot = H.getUint16();
                    if (Ot !== nt) {
                      bt = !1;
                      break;
                    }
                    const Et = [];
                    for (wt = 0; wt < Ot; ++wt) {
                      const We = H.getUint16();
                      if (We >= 32768) {
                        bt = !1;
                        break;
                      }
                      Et.push(We);
                    }
                    if (!bt)
                      break;
                    const St = [], Pe = [];
                    for (; H.pos < Ft; ) {
                      const We = H.getByte();
                      for (Pe.length = We, wt = 0; wt < We; ++wt)
                        Pe[wt] = String.fromCharCode(H.getByte());
                      St.push(Pe.join(""));
                    }
                    for (ct = [], wt = 0; wt < Ot; ++wt) {
                      const We = Et[wt];
                      if (We < 258) {
                        ct.push(v.MacStandardGlyphOrdering[We]);
                        continue;
                      }
                      ct.push(St[We - 258]);
                    }
                    break;
                  case 196608:
                    break;
                  default:
                    (0, t.warn)("Unknown/unsupported post table version " + mt), bt = !1, Ge.defaultEncoding && (ct = Ge.defaultEncoding);
                    break;
                }
                return Ge.glyphNames = ct, bt;
              }
              function Ce(Ke) {
                const Ge = (H.start || 0) + Ke.offset;
                H.pos = Ge;
                const nt = [[], []], it = Ke.length, pt = Ge + it;
                if (H.getUint16() !== 0 || it < 6)
                  return nt;
                const ct = H.getUint16(), bt = H.getUint16(), wt = [], Ot = 12;
                let Et, St;
                for (Et = 0; Et < ct && H.pos + Ot <= pt; Et++) {
                  const Pe = {
                    platform: H.getUint16(),
                    encoding: H.getUint16(),
                    language: H.getUint16(),
                    name: H.getUint16(),
                    length: H.getUint16(),
                    offset: H.getUint16()
                  };
                  (Pe.platform === 1 && Pe.encoding === 0 && Pe.language === 0 || Pe.platform === 3 && Pe.encoding === 1 && Pe.language === 1033) && wt.push(Pe);
                }
                for (Et = 0, St = wt.length; Et < St; Et++) {
                  const Pe = wt[Et];
                  if (Pe.length <= 0)
                    continue;
                  const We = Ge + bt + Pe.offset;
                  if (We + Pe.length > pt)
                    continue;
                  H.pos = We;
                  const Je = Pe.name;
                  if (Pe.encoding) {
                    let Ye = "";
                    for (let gt = 0, Dt = Pe.length; gt < Dt; gt += 2)
                      Ye += String.fromCharCode(H.getUint16());
                    nt[1][Je] = Ye;
                  } else
                    nt[0][Je] = H.getString(Pe.length);
                }
                return nt;
              }
              const ve = [0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1, 0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2, 0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1, -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];
              function Le(Ke, Ge) {
                let nt = Ke.data, it = 0, pt, Ft, mt, ct, bt, wt = 0, Ot = 0;
                const Et = [], St = [], Pe = [];
                let We = Ge.tooComplexToFollowFunctions, Je = !1, Ye = 0, gt = 0;
                for (let Xt = nt.length; it < Xt; ) {
                  const kt = nt[it++];
                  if (kt === 64)
                    if (Ft = nt[it++], Je || gt)
                      it += Ft;
                    else
                      for (pt = 0; pt < Ft; pt++)
                        Et.push(nt[it++]);
                  else if (kt === 65)
                    if (Ft = nt[it++], Je || gt)
                      it += Ft * 2;
                    else
                      for (pt = 0; pt < Ft; pt++)
                        mt = nt[it++], Et.push(mt << 8 | nt[it++]);
                  else if ((kt & 248) === 176)
                    if (Ft = kt - 176 + 1, Je || gt)
                      it += Ft;
                    else
                      for (pt = 0; pt < Ft; pt++)
                        Et.push(nt[it++]);
                  else if ((kt & 248) === 184)
                    if (Ft = kt - 184 + 1, Je || gt)
                      it += Ft * 2;
                    else
                      for (pt = 0; pt < Ft; pt++)
                        mt = nt[it++], Et.push(mt << 8 | nt[it++]);
                  else if (kt === 43 && !We) {
                    if (!Je && !gt) {
                      if (ct = Et.at(-1), isNaN(ct))
                        (0, t.info)("TT: CALL empty stack (or invalid entry).");
                      else if (Ge.functionsUsed[ct] = !0, ct in Ge.functionsStackDeltas) {
                        const Pt = Et.length + Ge.functionsStackDeltas[ct];
                        if (Pt < 0) {
                          (0, t.warn)("TT: CALL invalid functions stack delta."), Ge.hintsValid = !1;
                          return;
                        }
                        Et.length = Pt;
                      } else if (ct in Ge.functionsDefined && !Pe.includes(ct)) {
                        if (St.push({
                          data: nt,
                          i: it,
                          stackTop: Et.length - 1
                        }), Pe.push(ct), bt = Ge.functionsDefined[ct], !bt) {
                          (0, t.warn)("TT: CALL non-existent function"), Ge.hintsValid = !1;
                          return;
                        }
                        nt = bt.data, it = bt.i;
                      }
                    }
                  } else if (kt === 44 && !We)
                    (Je || gt) && ((0, t.warn)("TT: nested FDEFs not allowed"), We = !0), Je = !0, Ot = it, ct = Et.pop(), Ge.functionsDefined[ct] = {
                      data: nt,
                      i: it
                    };
                  else if (kt === 45)
                    if (Je)
                      Je = !1, wt = it;
                    else {
                      if (bt = St.pop(), !bt) {
                        (0, t.warn)("TT: ENDF bad stack"), Ge.hintsValid = !1;
                        return;
                      }
                      ct = Pe.pop(), nt = bt.data, it = bt.i, Ge.functionsStackDeltas[ct] = Et.length - bt.stackTop;
                    }
                  else if (kt === 137)
                    (Je || gt) && ((0, t.warn)("TT: nested IDEFs not allowed"), We = !0), Je = !0, Ot = it;
                  else if (kt === 88)
                    ++Ye;
                  else if (kt === 27)
                    gt = Ye;
                  else if (kt === 89)
                    gt === Ye && (gt = 0), --Ye;
                  else if (kt === 28 && !Je && !gt) {
                    const Pt = Et.at(-1);
                    Pt > 0 && (it += Pt - 1);
                  }
                  if (!Je && !gt) {
                    let Pt = 0;
                    for (kt <= 142 ? Pt = ve[kt] : kt >= 192 && kt <= 223 ? Pt = -1 : kt >= 224 && (Pt = -2), kt >= 113 && kt <= 117 && (Ft = Et.pop(), isNaN(Ft) || (Pt = -Ft * 2)); Pt < 0 && Et.length > 0; )
                      Et.pop(), Pt++;
                    for (; Pt > 0; )
                      Et.push(NaN), Pt--;
                  }
                }
                Ge.tooComplexToFollowFunctions = We;
                const Dt = [nt];
                it > nt.length && Dt.push(new Uint8Array(it - nt.length)), Ot > wt && ((0, t.warn)("TT: complementing a missing function tail"), Dt.push(new Uint8Array([34, 45]))), Qe(Ke, Dt);
              }
              function He(Ke, Ge) {
                if (!Ke.tooComplexToFollowFunctions) {
                  if (Ke.functionsDefined.length > Ge) {
                    (0, t.warn)("TT: more functions defined than expected"), Ke.hintsValid = !1;
                    return;
                  }
                  for (let nt = 0, it = Ke.functionsUsed.length; nt < it; nt++) {
                    if (nt > Ge) {
                      (0, t.warn)("TT: invalid function id: " + nt), Ke.hintsValid = !1;
                      return;
                    }
                    if (Ke.functionsUsed[nt] && !Ke.functionsDefined[nt]) {
                      (0, t.warn)("TT: undefined function: " + nt), Ke.hintsValid = !1;
                      return;
                    }
                  }
                }
              }
              function Qe(Ke, Ge) {
                if (Ge.length > 1) {
                  let nt = 0, it, pt;
                  for (it = 0, pt = Ge.length; it < pt; it++)
                    nt += Ge[it].length;
                  nt = nt + 3 & -4;
                  const Ft = new Uint8Array(nt);
                  let mt = 0;
                  for (it = 0, pt = Ge.length; it < pt; it++)
                    Ft.set(Ge[it], mt), mt += Ge[it].length;
                  Ke.data = Ft, Ke.length = nt;
                }
              }
              function Ue(Ke, Ge, nt, it) {
                const pt = {
                  functionsDefined: [],
                  functionsUsed: [],
                  functionsStackDeltas: [],
                  tooComplexToFollowFunctions: !1,
                  hintsValid: !0
                };
                if (Ke && Le(Ke, pt), Ge && Le(Ge, pt), Ke && He(pt, it), nt && nt.length & 1) {
                  const Ft = new Uint8Array(nt.length + 1);
                  Ft.set(nt.data), nt.data = Ft;
                }
                return pt.hintsValid;
              }
              H = new w.Stream(new Uint8Array(H.getBytes()));
              let Ie, Ee;
              if (I(H)) {
                const Ke = De(H, this.name);
                Ie = Ke.header, Ee = Ke.tables;
              } else
                Ie = pe(H), Ee = fe(H, Ie.numTables);
              let et, qe;
              const tt = !Ee["CFF "];
              if (tt) {
                if (!Ee.loca)
                  throw new t.FormatError('Required "loca" table is not found');
                Ee.glyf || ((0, t.warn)('Required "glyf" table is not found -- trying to recover.'), Ee.glyf = {
                  tag: "glyf",
                  data: new Uint8Array(0)
                }), this.isOpenType = !1;
              } else {
                const Ke = ie.composite && ((ie.cidToGidMap || []).length > 0 || !(ie.cMap instanceof i.IdentityCMap));
                if (Ie.version === "OTTO" && !Ke || !Ee.head || !Ee.hhea || !Ee.maxp || !Ee.post)
                  return qe = new w.Stream(Ee["CFF "].data), et = new p.CFFFont(qe, ie), X(ie), this.convert(E, et, ie);
                delete Ee.glyf, delete Ee.loca, delete Ee.fpgm, delete Ee.prep, delete Ee["cvt "], this.isOpenType = !0;
              }
              if (!Ee.maxp)
                throw new t.FormatError('Required "maxp" table is not found');
              H.pos = (H.start || 0) + Ee.maxp.offset;
              const ft = H.getInt32(), Te = H.getUint16();
              if (ie.scaleFactors && ie.scaleFactors.length === Te && tt) {
                const {
                  scaleFactors: Ke
                } = ie, Ge = x(Ee.head.data[50], Ee.head.data[51]), nt = new n.GlyfTable({
                  glyfTable: Ee.glyf.data,
                  isGlyphLocationsLong: Ge,
                  locaTable: Ee.loca.data,
                  numGlyphs: Te
                });
                nt.scale(Ke);
                const {
                  glyf: it,
                  loca: pt,
                  isLocationLong: Ft
                } = nt.write();
                Ee.glyf.data = it, Ee.loca.data = pt, Ft !== !!Ge && (Ee.head.data[50] = 0, Ee.head.data[51] = Ft ? 1 : 0);
                const mt = Ee.hmtx.data;
                for (let ct = 0; ct < Te; ct++) {
                  const bt = 4 * ct, wt = Math.round(Ke[ct] * x(mt[bt], mt[bt + 1]));
                  mt[bt] = wt >> 8 & 255, mt[bt + 1] = wt & 255;
                  const Ot = Math.round(Ke[ct] * U(mt[bt + 2], mt[bt + 3]));
                  f(mt, bt + 2, Ot);
                }
              }
              let je = Te + 1, Ze = !0;
              je > 65535 && (Ze = !1, je = Te, (0, t.warn)("Not enough space in glyfs to duplicate first glyph."));
              let Me = 0, at = 0;
              ft >= 65536 && Ee.maxp.length >= 22 && (H.pos += 8, H.getUint16() > 2 && (Ee.maxp.data[14] = 0, Ee.maxp.data[15] = 2), H.pos += 4, Me = H.getUint16(), H.pos += 4, at = H.getUint16()), Ee.maxp.data[4] = je >> 8, Ee.maxp.data[5] = je & 255;
              const rt = Ue(Ee.fpgm, Ee.prep, Ee["cvt "], Me);
              if (rt || (delete Ee.fpgm, delete Ee.prep, delete Ee["cvt "]), Se(H, Ee.hhea, Ee.hmtx, Ee.head, je, Ze), !Ee.head)
                throw new t.FormatError('Required "head" table is not found');
              ye(Ee.head, Te, tt ? Ee.loca.length : 0);
              let xt = /* @__PURE__ */ Object.create(null);
              if (tt) {
                const Ke = x(Ee.head.data[50], Ee.head.data[51]), Ge = _e(Ee.loca, Ee.glyf, Te, Ke, rt, Ze, at);
                xt = Ge.missingGlyphs, ft >= 65536 && Ee.maxp.length >= 22 && (Ee.maxp.data[26] = Ge.maxSizeOfInstructions >> 8, Ee.maxp.data[27] = Ge.maxSizeOfInstructions & 255);
              }
              if (!Ee.hhea)
                throw new t.FormatError('Required "hhea" table is not found');
              Ee.hhea.data[10] === 0 && Ee.hhea.data[11] === 0 && (Ee.hhea.data[10] = 255, Ee.hhea.data[11] = 255);
              const ut = {
                unitsPerEm: x(Ee.head.data[18], Ee.head.data[19]),
                yMax: x(Ee.head.data[42], Ee.head.data[43]),
                yMin: U(Ee.head.data[38], Ee.head.data[39]),
                ascent: U(Ee.hhea.data[4], Ee.hhea.data[5]),
                descent: U(Ee.hhea.data[6], Ee.hhea.data[7]),
                lineGap: U(Ee.hhea.data[8], Ee.hhea.data[9])
              };
              this.ascent = ut.ascent / ut.unitsPerEm, this.descent = ut.descent / ut.unitsPerEm, this.lineGap = ut.lineGap / ut.unitsPerEm, this.cssFontInfo && this.cssFontInfo.lineHeight ? (this.lineHeight = this.cssFontInfo.metrics.lineHeight, this.lineGap = this.cssFontInfo.metrics.lineGap) : this.lineHeight = this.ascent - this.descent + this.lineGap, Ee.post && we(Ee.post, ie, Te), Ee.post = {
                tag: "post",
                data: Q(ie)
              };
              const yt = [];
              function ht(Ke) {
                return !xt[Ke];
              }
              if (ie.composite) {
                const Ke = ie.cidToGidMap || [], Ge = Ke.length === 0;
                ie.cMap.forEach(function(nt, it) {
                  if (typeof it == "string" && (it = L(nt, it, !0)), it > 65535)
                    throw new t.FormatError("Max size of CID is 65,535");
                  let pt = -1;
                  Ge ? pt = it : Ke[it] !== void 0 && (pt = Ke[it]), pt >= 0 && pt < Te && ht(pt) && (yt[nt] = pt);
                });
              } else {
                const Ke = Ae(Ee.cmap, H, this.isSymbolicFont, ie.hasEncoding), Ge = Ke.platformId, nt = Ke.encodingId, it = Ke.mappings, pt = it.length;
                let Ft = [], mt = !1;
                if (ie.hasEncoding && (ie.baseEncodingName === "MacRomanEncoding" || ie.baseEncodingName === "WinAnsiEncoding") && (Ft = (0, y.getEncoding)(ie.baseEncodingName)), ie.hasEncoding && !this.isSymbolicFont && (Ge === 3 && nt === 1 || Ge === 1 && nt === 0)) {
                  const ct = (0, e.getGlyphsUnicode)();
                  for (let bt = 0; bt < 256; bt++) {
                    let wt;
                    if (this.differences[bt] !== void 0 ? wt = this.differences[bt] : Ft.length && Ft[bt] !== "" ? wt = Ft[bt] : wt = y.StandardEncoding[bt], !wt)
                      continue;
                    const Ot = (0, v.recoverGlyphName)(wt, ct);
                    let Et;
                    if (Ge === 3 && nt === 1 ? Et = ct[Ot] : Ge === 1 && nt === 0 && (Et = y.MacRomanEncoding.indexOf(Ot)), Et === void 0) {
                      if (!ie.glyphNames && ie.hasIncludedToUnicodeMap && !(this.toUnicode instanceof d.IdentityToUnicodeMap)) {
                        const St = this.toUnicode.get(bt);
                        St && (Et = St.codePointAt(0));
                      }
                      if (Et === void 0)
                        continue;
                    }
                    for (let St = 0; St < pt; ++St)
                      if (it[St].charCode === Et) {
                        yt[bt] = it[St].glyphId;
                        break;
                      }
                  }
                } else if (Ge === 0) {
                  for (let ct = 0; ct < pt; ++ct)
                    yt[it[ct].charCode] = it[ct].glyphId;
                  mt = !0;
                } else
                  for (let ct = 0; ct < pt; ++ct) {
                    let bt = it[ct].charCode;
                    Ge === 3 && bt >= 61440 && bt <= 61695 && (bt &= 255), yt[bt] = it[ct].glyphId;
                  }
                if (ie.glyphNames && (Ft.length || this.differences.length))
                  for (let ct = 0; ct < 256; ++ct) {
                    if (!mt && yt[ct] !== void 0)
                      continue;
                    const bt = this.differences[ct] || Ft[ct];
                    if (!bt)
                      continue;
                    const wt = ie.glyphNames.indexOf(bt);
                    wt > 0 && ht(wt) && (yt[ct] = wt);
                  }
              }
              yt.length === 0 && (yt[0] = 0);
              let Rt = je - 1;
              if (Ze || (Rt = 0), !ie.cssFontInfo) {
                const Ke = K(yt, ht, Rt, this.toUnicode);
                this.toFontChar = Ke.toFontChar, Ee.cmap = {
                  tag: "cmap",
                  data: se(Ke.charCodeToGlyphId, Ke.toUnicodeExtraMap, je)
                }, (!Ee["OS/2"] || !q(Ee["OS/2"], H)) && (Ee["OS/2"] = {
                  tag: "OS/2",
                  data: N(ie, Ke.charCodeToGlyphId, ut)
                });
              }
              if (!tt)
                try {
                  qe = new w.Stream(Ee["CFF "].data), et = new a.CFFParser(qe, ie, v.SEAC_ANALYSIS_ENABLED).parse(), et.duplicateFirstGlyph();
                  const Ge = new a.CFFCompiler(et);
                  Ee["CFF "].data = Ge.compile();
                } catch {
                  (0, t.warn)("Failed to compile font " + ie.loadedName);
                }
              if (!Ee.name)
                Ee.name = {
                  tag: "name",
                  data: ne(this.name)
                };
              else {
                const Ke = Ce(Ee.name);
                Ee.name.data = ne(E, Ke), this.psName = Ke[0][6] || null;
              }
              const Wt = new l.OpenTypeFileBuilder(Ie.version);
              for (const Ke in Ee)
                Wt.addTable(Ke, Ee[Ke].data);
              return Wt.toArray();
            }
            convert(E, H, ie) {
              ie.fixedPitch = !1, ie.builtInEncoding && B(ie, ie.builtInEncoding);
              let ue = 1;
              H instanceof p.CFFFont && (ue = H.numGlyphs - 1);
              const fe = H.getGlyphMapping(ie);
              let de = null, pe = fe, xe = null;
              ie.cssFontInfo || (de = K(fe, H.hasGlyphId.bind(H), ue, this.toUnicode), this.toFontChar = de.toFontChar, pe = de.charCodeToGlyphId, xe = de.toUnicodeExtraMap);
              const De = H.numGlyphs;
              function Ae(we, Ce) {
                let ve = null;
                for (const Le in we)
                  Ce === we[Le] && (ve || (ve = []), ve.push(Le | 0));
                return ve;
              }
              function Se(we, Ce) {
                for (const ve in we)
                  if (Ce === we[ve])
                    return ve | 0;
                return de.charCodeToGlyphId[de.nextAvailableFontCharCode] = Ce, de.nextAvailableFontCharCode++;
              }
              const ke = H.seacs;
              if (de && v.SEAC_ANALYSIS_ENABLED && ke && ke.length) {
                const we = ie.fontMatrix || t.FONT_IDENTITY_MATRIX, Ce = H.getCharset(), ve = /* @__PURE__ */ Object.create(null);
                for (let Le in ke) {
                  Le |= 0;
                  const He = ke[Le], Qe = y.StandardEncoding[He[2]], Ue = y.StandardEncoding[He[3]], Ie = Ce.indexOf(Qe), Ee = Ce.indexOf(Ue);
                  if (Ie < 0 || Ee < 0)
                    continue;
                  const et = {
                    x: He[0] * we[0] + He[1] * we[2] + we[4],
                    y: He[0] * we[1] + He[1] * we[3] + we[5]
                  }, qe = Ae(fe, Le);
                  if (qe)
                    for (let tt = 0, ft = qe.length; tt < ft; tt++) {
                      const Te = qe[tt], je = de.charCodeToGlyphId, Ze = Se(je, Ie), Me = Se(je, Ee);
                      ve[Te] = {
                        baseFontCharCode: Ze,
                        accentFontCharCode: Me,
                        accentOffset: et
                      };
                    }
                }
                ie.seacMap = ve;
              }
              const ye = 1 / (ie.fontMatrix || t.FONT_IDENTITY_MATRIX)[0], _e = new l.OpenTypeFileBuilder("OTTO");
              return _e.addTable("CFF ", H.data), _e.addTable("OS/2", N(ie, pe)), _e.addTable("cmap", se(pe, xe, De)), _e.addTable("head", "\0\0\0\0\0\0\0\0\0\0_<õ\0\0" + F(ye) + "\0\0\0\0\v~'\0\0\0\0\v~'\0\0" + F(ie.descent) + "ÿ" + F(ie.ascent) + S(ie.italicAngle ? 2 : 0) + "\0\0\0\0\0\0\0"), _e.addTable("hhea", "\0\0\0" + F(ie.ascent) + F(ie.descent) + "\0\0ÿÿ\0\0\0\0\0\0" + F(ie.capHeight) + F(Math.tan(ie.italicAngle) * ie.xHeight) + "\0\0\0\0\0\0\0\0\0\0\0\0" + S(De)), _e.addTable("hmtx", function() {
                const Ce = H.charstrings, ve = H.cff ? H.cff.widths : null;
                let Le = "\0\0\0\0";
                for (let He = 1, Qe = De; He < Qe; He++) {
                  let Ue = 0;
                  if (Ce) {
                    const Ie = Ce[He - 1];
                    Ue = "width" in Ie ? Ie.width : 0;
                  } else
                    ve && (Ue = Math.ceil(ve[He] || 0));
                  Le += S(Ue) + S(0);
                }
                return Le;
              }()), _e.addTable("maxp", "\0\0P\0" + S(De)), _e.addTable("name", ne(E)), _e.addTable("post", Q(ie)), _e.toArray();
            }
            get spaceWidth() {
              const E = ["space", "minus", "one", "i", "I"];
              let H;
              for (let ie = 0, ue = E.length; ie < ue; ie++) {
                const fe = E[ie];
                if (fe in this.widths) {
                  H = this.widths[fe];
                  break;
                }
                const pe = (0, e.getGlyphsUnicode)()[fe];
                let xe = 0;
                if (this.composite && this.cMap.contains(pe) && (xe = this.cMap.lookup(pe), typeof xe == "string" && (xe = L(pe, xe))), !xe && this.toUnicode && (xe = this.toUnicode.charCodeOf(pe)), xe <= 0 && (xe = pe), H = this.widths[xe], H)
                  break;
              }
              return H = H || this.defaultWidth, (0, t.shadow)(this, "spaceWidth", H);
            }
            _charToGlyph(E, H = !1) {
              let ie, ue, fe, de = E;
              this.cMap && this.cMap.contains(E) && (de = this.cMap.lookup(E), typeof de == "string" && (de = L(E, de))), ue = this.widths[de], typeof ue != "number" && (ue = this.defaultWidth);
              const pe = this.vmetrics && this.vmetrics[de];
              let xe = this.toUnicode.get(E) || E;
              typeof xe == "number" && (xe = String.fromCharCode(xe));
              let De = this.toFontChar[E] !== void 0;
              if (ie = this.toFontChar[E] || E, this.missingFile) {
                const ye = this.differences[E] || this.defaultEncoding[E];
                (ye === ".notdef" || ye === "") && this.type === "Type1" && (ie = 32), ie = (0, h.mapSpecialUnicodeValues)(ie);
              }
              this.isType3Font && (fe = ie);
              let Ae = null;
              if (this.seacMap && this.seacMap[E]) {
                De = !0;
                const ye = this.seacMap[E];
                ie = ye.baseFontCharCode, Ae = {
                  fontChar: String.fromCodePoint(ye.accentFontCharCode),
                  offset: ye.accentOffset
                };
              }
              let Se = "";
              typeof ie == "number" && (ie <= 1114111 ? Se = String.fromCodePoint(ie) : (0, t.warn)(`charToGlyph - invalid fontCharCode: ${ie}`));
              let ke = this._glyphCache[E];
              return (!ke || !ke.matchesForCache(E, Se, xe, Ae, ue, pe, fe, H, De)) && (ke = new k(E, Se, xe, Ae, ue, pe, fe, H, De), this._glyphCache[E] = ke), ke;
            }
            charsToGlyphs(E) {
              let H = this._charsCache[E];
              if (H)
                return H;
              if (H = [], this.cMap) {
                const ie = /* @__PURE__ */ Object.create(null), ue = E.length;
                let fe = 0;
                for (; fe < ue; ) {
                  this.cMap.readCharCode(E, fe, ie);
                  const {
                    charcode: de,
                    length: pe
                  } = ie;
                  fe += pe;
                  const xe = this._charToGlyph(de, pe === 1 && E.charCodeAt(fe - 1) === 32);
                  H.push(xe);
                }
              } else
                for (let ie = 0, ue = E.length; ie < ue; ++ie) {
                  const fe = E.charCodeAt(ie), de = this._charToGlyph(fe, fe === 32);
                  H.push(de);
                }
              return this._charsCache[E] = H;
            }
            getCharPositions(E) {
              const H = [];
              if (this.cMap) {
                const ie = /* @__PURE__ */ Object.create(null);
                let ue = 0;
                for (; ue < E.length; ) {
                  this.cMap.readCharCode(E, ue, ie);
                  const fe = ie.length;
                  H.push([ue, ue + fe]), ue += fe;
                }
              } else
                for (let ie = 0, ue = E.length; ie < ue; ++ie)
                  H.push([ie, ie + 1]);
              return H;
            }
            get glyphCacheValues() {
              return Object.values(this._glyphCache);
            }
            encodeString(E) {
              const H = [], ie = [], ue = () => H.length % 2 === 1, fe = this.toUnicode instanceof d.IdentityToUnicodeMap ? (de) => this.toUnicode.charCodeOf(de) : (de) => this.toUnicode.charCodeOf(String.fromCodePoint(de));
              for (let de = 0, pe = E.length; de < pe; de++) {
                const xe = E.codePointAt(de);
                if (xe > 55295 && (xe < 57344 || xe > 65533) && de++, this.toUnicode) {
                  const De = fe(xe);
                  if (De !== -1) {
                    ue() && (H.push(ie.join("")), ie.length = 0);
                    const Ae = this.cMap ? this.cMap.getCharCodeLength(De) : 1;
                    for (let Se = Ae - 1; Se >= 0; Se--)
                      ie.push(String.fromCharCode(De >> 8 * Se & 255));
                    continue;
                  }
                }
                ue() || (H.push(ie.join("")), ie.length = 0), ie.push(String.fromCodePoint(xe));
              }
              return H.push(ie.join("")), H;
            }
          }
          o.Font = oe;
          class ee {
            constructor(E) {
              this.error = E, this.loadedName = "g_font_error", this.missingFile = !0;
            }
            charsToGlyphs() {
              return [];
            }
            encodeString(E) {
              return [E];
            }
            exportData(E = !1) {
              return {
                error: this.error
              };
            }
          }
          o.ErrorFont = ee;
        },
        /* 35 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.CFFTopDict = o.CFFStrings = o.CFFStandardStrings = o.CFFPrivateDict = o.CFFParser = o.CFFIndex = o.CFFHeader = o.CFFFDSelect = o.CFFCompiler = o.CFFCharset = o.CFF = void 0;
          var t = C(2), a = C(36), v = C(37);
          const h = 10, e = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"];
          o.CFFStandardStrings = e;
          const y = 391, c = [null, {
            id: "hstem",
            min: 2,
            stackClearing: !0,
            stem: !0
          }, null, {
            id: "vstem",
            min: 2,
            stackClearing: !0,
            stem: !0
          }, {
            id: "vmoveto",
            min: 1,
            stackClearing: !0
          }, {
            id: "rlineto",
            min: 2,
            resetStack: !0
          }, {
            id: "hlineto",
            min: 1,
            resetStack: !0
          }, {
            id: "vlineto",
            min: 1,
            resetStack: !0
          }, {
            id: "rrcurveto",
            min: 6,
            resetStack: !0
          }, null, {
            id: "callsubr",
            min: 1,
            undefStack: !0
          }, {
            id: "return",
            min: 0,
            undefStack: !0
          }, null, null, {
            id: "endchar",
            min: 0,
            stackClearing: !0
          }, null, null, null, {
            id: "hstemhm",
            min: 2,
            stackClearing: !0,
            stem: !0
          }, {
            id: "hintmask",
            min: 0,
            stackClearing: !0
          }, {
            id: "cntrmask",
            min: 0,
            stackClearing: !0
          }, {
            id: "rmoveto",
            min: 2,
            stackClearing: !0
          }, {
            id: "hmoveto",
            min: 1,
            stackClearing: !0
          }, {
            id: "vstemhm",
            min: 2,
            stackClearing: !0,
            stem: !0
          }, {
            id: "rcurveline",
            min: 8,
            resetStack: !0
          }, {
            id: "rlinecurve",
            min: 8,
            resetStack: !0
          }, {
            id: "vvcurveto",
            min: 4,
            resetStack: !0
          }, {
            id: "hhcurveto",
            min: 4,
            resetStack: !0
          }, null, {
            id: "callgsubr",
            min: 1,
            undefStack: !0
          }, {
            id: "vhcurveto",
            min: 4,
            resetStack: !0
          }, {
            id: "hvcurveto",
            min: 4,
            resetStack: !0
          }], d = [null, null, null, {
            id: "and",
            min: 2,
            stackDelta: -1
          }, {
            id: "or",
            min: 2,
            stackDelta: -1
          }, {
            id: "not",
            min: 1,
            stackDelta: 0
          }, null, null, null, {
            id: "abs",
            min: 1,
            stackDelta: 0
          }, {
            id: "add",
            min: 2,
            stackDelta: -1,
            stackFn(k, x) {
              k[x - 2] = k[x - 2] + k[x - 1];
            }
          }, {
            id: "sub",
            min: 2,
            stackDelta: -1,
            stackFn(k, x) {
              k[x - 2] = k[x - 2] - k[x - 1];
            }
          }, {
            id: "div",
            min: 2,
            stackDelta: -1,
            stackFn(k, x) {
              k[x - 2] = k[x - 2] / k[x - 1];
            }
          }, null, {
            id: "neg",
            min: 1,
            stackDelta: 0,
            stackFn(k, x) {
              k[x - 1] = -k[x - 1];
            }
          }, {
            id: "eq",
            min: 2,
            stackDelta: -1
          }, null, null, {
            id: "drop",
            min: 1,
            stackDelta: -1
          }, null, {
            id: "put",
            min: 2,
            stackDelta: -2
          }, {
            id: "get",
            min: 1,
            stackDelta: 0
          }, {
            id: "ifelse",
            min: 4,
            stackDelta: -3
          }, {
            id: "random",
            min: 0,
            stackDelta: 1
          }, {
            id: "mul",
            min: 2,
            stackDelta: -1,
            stackFn(k, x) {
              k[x - 2] = k[x - 2] * k[x - 1];
            }
          }, null, {
            id: "sqrt",
            min: 1,
            stackDelta: 0
          }, {
            id: "dup",
            min: 1,
            stackDelta: 1
          }, {
            id: "exch",
            min: 2,
            stackDelta: 0
          }, {
            id: "index",
            min: 2,
            stackDelta: 0
          }, {
            id: "roll",
            min: 3,
            stackDelta: -2
          }, null, null, null, {
            id: "hflex",
            min: 7,
            resetStack: !0
          }, {
            id: "flex",
            min: 13,
            resetStack: !0
          }, {
            id: "hflex1",
            min: 9,
            resetStack: !0
          }, {
            id: "flex1",
            min: 11,
            resetStack: !0
          }];
          class p {
            constructor(x, f, U) {
              this.bytes = x.getBytes(), this.properties = f, this.seacAnalysisEnabled = !!U;
            }
            parse() {
              const x = this.properties, f = new m();
              this.cff = f;
              const U = this.parseHeader(), O = this.parseIndex(U.endPos), S = this.parseIndex(O.endPos), F = this.parseIndex(S.endPos), T = this.parseIndex(F.endPos), I = this.parseDict(S.obj.get(0)), M = this.createDict(w, I, f.strings);
              f.header = U.obj, f.names = this.parseNameIndex(O.obj), f.strings = this.parseStringIndex(F.obj), f.topDict = M, f.globalSubrIndex = T.obj, this.parsePrivateDict(f.topDict), f.isCIDFont = M.hasName("ROS");
              const V = M.getByName("CharStrings"), J = this.parseIndex(V).obj, W = M.getByName("FontMatrix");
              W && (x.fontMatrix = W);
              const z = M.getByName("FontBBox");
              z && (x.ascent = Math.max(z[3], z[1]), x.descent = Math.min(z[1], z[3]), x.ascentScaled = !0);
              let G, L;
              if (f.isCIDFont) {
                const te = this.parseIndex(M.getByName("FDArray")).obj;
                for (let se = 0, q = te.count; se < q; ++se) {
                  const N = te.get(se), Q = this.createDict(w, this.parseDict(N), f.strings);
                  this.parsePrivateDict(Q), f.fdArray.push(Q);
                }
                L = null, G = this.parseCharsets(M.getByName("charset"), J.count, f.strings, !0), f.fdSelect = this.parseFDSelect(M.getByName("FDSelect"), J.count);
              } else
                G = this.parseCharsets(M.getByName("charset"), J.count, f.strings, !1), L = this.parseEncoding(M.getByName("Encoding"), x, f.strings, G.charset);
              f.charset = G, f.encoding = L;
              const K = this.parseCharStrings({
                charStrings: J,
                localSubrIndex: M.privateDict.subrsIndex,
                globalSubrIndex: T.obj,
                fdSelect: f.fdSelect,
                fdArray: f.fdArray,
                privateDict: M.privateDict
              });
              return f.charStrings = K.charStrings, f.seacs = K.seacs, f.widths = K.widths, f;
            }
            parseHeader() {
              let x = this.bytes;
              const f = x.length;
              let U = 0;
              for (; U < f && x[U] !== 1; )
                ++U;
              if (U >= f)
                throw new t.FormatError("Invalid CFF header");
              U !== 0 && ((0, t.info)("cff data is shifted"), x = x.subarray(U), this.bytes = x);
              const O = x[0], S = x[1], F = x[2], T = x[3];
              return {
                obj: new g(O, S, F, T),
                endPos: F
              };
            }
            parseDict(x) {
              let f = 0;
              function U() {
                let I = x[f++];
                return I === 30 ? O() : I === 28 ? (I = x[f++], I = (I << 24 | x[f++] << 16) >> 16, I) : I === 29 ? (I = x[f++], I = I << 8 | x[f++], I = I << 8 | x[f++], I = I << 8 | x[f++], I) : I >= 32 && I <= 246 ? I - 139 : I >= 247 && I <= 250 ? (I - 247) * 256 + x[f++] + 108 : I >= 251 && I <= 254 ? -((I - 251) * 256) - x[f++] - 108 : ((0, t.warn)('CFFParser_parseDict: "' + I + '" is a reserved command.'), NaN);
              }
              function O() {
                let I = "";
                const V = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"], J = x.length;
                for (; f < J; ) {
                  const W = x[f++], z = W >> 4, G = W & 15;
                  if (z === 15 || (I += V[z], G === 15))
                    break;
                  I += V[G];
                }
                return parseFloat(I);
              }
              let S = [];
              const F = [];
              f = 0;
              const T = x.length;
              for (; f < T; ) {
                let I = x[f];
                I <= 21 ? (I === 12 && (I = I << 8 | x[++f]), F.push([I, S]), S = [], ++f) : S.push(U());
              }
              return F;
            }
            parseIndex(x) {
              const f = new i(), U = this.bytes, O = U[x++] << 8 | U[x++], S = [];
              let F = x, T, I;
              if (O !== 0) {
                const M = U[x++], V = x + (O + 1) * M - 1;
                for (T = 0, I = O + 1; T < I; ++T) {
                  let J = 0;
                  for (let W = 0; W < M; ++W)
                    J <<= 8, J += U[x++];
                  S.push(V + J);
                }
                F = S[O];
              }
              for (T = 0, I = S.length - 1; T < I; ++T) {
                const M = S[T], V = S[T + 1];
                f.add(U.subarray(M, V));
              }
              return {
                obj: f,
                endPos: F
              };
            }
            parseNameIndex(x) {
              const f = [];
              for (let U = 0, O = x.count; U < O; ++U) {
                const S = x.get(U);
                f.push((0, t.bytesToString)(S));
              }
              return f;
            }
            parseStringIndex(x) {
              const f = new n();
              for (let U = 0, O = x.count; U < O; ++U) {
                const S = x.get(U);
                f.add((0, t.bytesToString)(S));
              }
              return f;
            }
            createDict(x, f, U) {
              const O = new x(U);
              for (let S = 0, F = f.length; S < F; ++S) {
                const T = f[S], I = T[0], M = T[1];
                O.setByKey(I, M);
              }
              return O;
            }
            parseCharString(x, f, U, O) {
              if (!f || x.callDepth > h)
                return !1;
              let S = x.stackSize;
              const F = x.stack, T = f.length;
              for (let I = 0; I < T; ) {
                const M = f[I++];
                let V = null;
                if (M === 12) {
                  const J = f[I++];
                  J === 0 ? (f[I - 2] = 139, f[I - 1] = 22, S = 0) : V = d[J];
                } else if (M === 28)
                  F[S] = (f[I] << 24 | f[I + 1] << 16) >> 16, I += 2, S++;
                else if (M === 14) {
                  if (S >= 4 && (S -= 4, this.seacAnalysisEnabled))
                    return x.seac = F.slice(S, S + 4), !1;
                  V = c[M];
                } else if (M >= 32 && M <= 246)
                  F[S] = M - 139, S++;
                else if (M >= 247 && M <= 254)
                  F[S] = M < 251 ? (M - 247 << 8) + f[I] + 108 : -(M - 251 << 8) - f[I] - 108, I++, S++;
                else if (M === 255)
                  F[S] = (f[I] << 24 | f[I + 1] << 16 | f[I + 2] << 8 | f[I + 3]) / 65536, I += 4, S++;
                else if (M === 19 || M === 20)
                  x.hints += S >> 1, I += x.hints + 7 >> 3, S %= 2, V = c[M];
                else if (M === 10 || M === 29) {
                  let J;
                  if (M === 10 ? J = U : J = O, !J)
                    return V = c[M], (0, t.warn)("Missing subrsIndex for " + V.id), !1;
                  let W = 32768;
                  J.count < 1240 ? W = 107 : J.count < 33900 && (W = 1131);
                  const z = F[--S] + W;
                  if (z < 0 || z >= J.count || isNaN(z))
                    return V = c[M], (0, t.warn)("Out of bounds subrIndex for " + V.id), !1;
                  if (x.stackSize = S, x.callDepth++, !this.parseCharString(x, J.get(z), U, O))
                    return !1;
                  x.callDepth--, S = x.stackSize;
                  continue;
                } else {
                  if (M === 11)
                    return x.stackSize = S, !0;
                  M === 0 && I === f.length ? (f[I - 1] = 14, V = c[14]) : V = c[M];
                }
                if (V) {
                  if (V.stem && (x.hints += S >> 1, M === 3 || M === 23 ? x.hasVStems = !0 : x.hasVStems && (M === 1 || M === 18) && ((0, t.warn)("CFF stem hints are in wrong order"), f[I - 1] = M === 1 ? 3 : 23)), "min" in V && !x.undefStack && S < V.min)
                    return (0, t.warn)("Not enough parameters for " + V.id + "; actual: " + S + ", expected: " + V.min), S === 0 ? (f[I - 1] = 14, !0) : !1;
                  x.firstStackClearing && V.stackClearing && (x.firstStackClearing = !1, S -= V.min, S >= 2 && V.stem ? S %= 2 : S > 1 && (0, t.warn)("Found too many parameters for stack-clearing command"), S > 0 && (x.width = F[S - 1])), "stackDelta" in V ? ("stackFn" in V && V.stackFn(F, S), S += V.stackDelta) : V.stackClearing ? S = 0 : V.resetStack ? (S = 0, x.undefStack = !1) : V.undefStack && (S = 0, x.undefStack = !0, x.firstStackClearing = !1);
                }
              }
              return x.stackSize = S, !0;
            }
            parseCharStrings({
              charStrings: x,
              localSubrIndex: f,
              globalSubrIndex: U,
              fdSelect: O,
              fdArray: S,
              privateDict: F
            }) {
              const T = [], I = [], M = x.count;
              for (let V = 0; V < M; V++) {
                const J = x.get(V), W = {
                  callDepth: 0,
                  stackSize: 0,
                  stack: [],
                  undefStack: !0,
                  hints: 0,
                  firstStackClearing: !0,
                  seac: null,
                  width: null,
                  hasVStems: !1
                };
                let z = !0, G = null, L = F;
                if (O && S.length) {
                  const K = O.getFDIndex(V);
                  K === -1 && ((0, t.warn)("Glyph index is not in fd select."), z = !1), K >= S.length && ((0, t.warn)("Invalid fd index for glyph index."), z = !1), z && (L = S[K].privateDict, G = L.subrsIndex);
                } else
                  f && (G = f);
                if (z && (z = this.parseCharString(W, J, G, U)), W.width !== null) {
                  const K = L.getByName("nominalWidthX");
                  I[V] = K + W.width;
                } else {
                  const K = L.getByName("defaultWidthX");
                  I[V] = K;
                }
                W.seac !== null && (T[V] = W.seac), z || x.set(V, new Uint8Array([14]));
              }
              return {
                charStrings: x,
                seacs: T,
                widths: I
              };
            }
            emptyPrivateDictionary(x) {
              const f = this.createDict(b, [], x.strings);
              x.setByKey(18, [0, 0]), x.privateDict = f;
            }
            parsePrivateDict(x) {
              if (!x.hasName("Private")) {
                this.emptyPrivateDictionary(x);
                return;
              }
              const f = x.getByName("Private");
              if (!Array.isArray(f) || f.length !== 2) {
                x.removeByName("Private");
                return;
              }
              const U = f[0], O = f[1];
              if (U === 0 || O >= this.bytes.length) {
                this.emptyPrivateDictionary(x);
                return;
              }
              const S = O + U, F = this.bytes.subarray(O, S), T = this.parseDict(F), I = this.createDict(b, T, x.strings);
              if (x.privateDict = I, !I.getByName("Subrs"))
                return;
              const M = I.getByName("Subrs"), V = O + M;
              if (M === 0 || V >= this.bytes.length) {
                this.emptyPrivateDictionary(x);
                return;
              }
              const J = this.parseIndex(V);
              I.subrsIndex = J.obj;
            }
            parseCharsets(x, f, U, O) {
              if (x === 0)
                return new Y(!0, A.ISO_ADOBE, a.ISOAdobeCharset);
              if (x === 1)
                return new Y(!0, A.EXPERT, a.ExpertCharset);
              if (x === 2)
                return new Y(!0, A.EXPERT_SUBSET, a.ExpertSubsetCharset);
              const S = this.bytes, F = x, T = S[x++], I = [O ? 0 : ".notdef"];
              let M, V, J;
              switch (f -= 1, T) {
                case 0:
                  for (J = 0; J < f; J++)
                    M = S[x++] << 8 | S[x++], I.push(O ? M : U.get(M));
                  break;
                case 1:
                  for (; I.length <= f; )
                    for (M = S[x++] << 8 | S[x++], V = S[x++], J = 0; J <= V; J++)
                      I.push(O ? M++ : U.get(M++));
                  break;
                case 2:
                  for (; I.length <= f; )
                    for (M = S[x++] << 8 | S[x++], V = S[x++] << 8 | S[x++], J = 0; J <= V; J++)
                      I.push(O ? M++ : U.get(M++));
                  break;
                default:
                  throw new t.FormatError("Unknown charset format");
              }
              const W = x, z = S.subarray(F, W);
              return new Y(!1, T, I, z);
            }
            parseEncoding(x, f, U, O) {
              const S = /* @__PURE__ */ Object.create(null), F = this.bytes;
              let T = !1, I, M, V, J = null;
              function W() {
                const z = F[x++];
                for (M = 0; M < z; M++) {
                  const G = F[x++], L = (F[x++] << 8) + (F[x++] & 255);
                  S[G] = O.indexOf(U.get(L));
                }
              }
              if (x === 0 || x === 1) {
                T = !0, I = x;
                const z = x ? v.ExpertEncoding : v.StandardEncoding;
                for (M = 0, V = O.length; M < V; M++) {
                  const G = z.indexOf(O[M]);
                  G !== -1 && (S[G] = M);
                }
              } else {
                const z = x;
                switch (I = F[x++], I & 127) {
                  case 0:
                    const L = F[x++];
                    for (M = 1; M <= L; M++)
                      S[F[x++]] = M;
                    break;
                  case 1:
                    const K = F[x++];
                    let te = 1;
                    for (M = 0; M < K; M++) {
                      const se = F[x++], q = F[x++];
                      for (let N = se; N <= se + q; N++)
                        S[N] = te++;
                    }
                    break;
                  default:
                    throw new t.FormatError(`Unknown encoding format: ${I} in CFF`);
                }
                const G = x;
                I & 128 && (F[z] &= 127, W()), J = F.subarray(z, G);
              }
              return I &= 127, new j(T, I, S, J);
            }
            parseFDSelect(x, f) {
              const U = this.bytes, O = U[x++], S = [];
              let F;
              switch (O) {
                case 0:
                  for (F = 0; F < f; ++F) {
                    const I = U[x++];
                    S.push(I);
                  }
                  break;
                case 3:
                  const T = U[x++] << 8 | U[x++];
                  for (F = 0; F < T; ++F) {
                    let I = U[x++] << 8 | U[x++];
                    F === 0 && I !== 0 && ((0, t.warn)("parseFDSelect: The first range must have a first GID of 0 -- trying to recover."), I = 0);
                    const M = U[x++], V = U[x] << 8 | U[x + 1];
                    for (let J = I; J < V; ++J)
                      S.push(M);
                  }
                  x += 2;
                  break;
                default:
                  throw new t.FormatError(`parseFDSelect: Unknown format "${O}".`);
              }
              if (S.length !== f)
                throw new t.FormatError("parseFDSelect: Invalid font data.");
              return new X(O, S);
            }
          }
          o.CFFParser = p;
          class m {
            constructor() {
              this.header = null, this.names = [], this.topDict = null, this.strings = new n(), this.globalSubrIndex = null, this.encoding = null, this.charset = null, this.charStrings = null, this.fdArray = [], this.fdSelect = null, this.isCIDFont = !1;
            }
            duplicateFirstGlyph() {
              if (this.charStrings.count >= 65535) {
                (0, t.warn)("Not enough space in charstrings to duplicate first glyph.");
                return;
              }
              const x = this.charStrings.get(0);
              this.charStrings.add(x), this.isCIDFont && this.fdSelect.fdSelect.push(this.fdSelect.fdSelect[0]);
            }
            hasGlyphId(x) {
              return x < 0 || x >= this.charStrings.count ? !1 : this.charStrings.get(x).length > 0;
            }
          }
          o.CFF = m;
          class g {
            constructor(x, f, U, O) {
              this.major = x, this.minor = f, this.hdrSize = U, this.offSize = O;
            }
          }
          o.CFFHeader = g;
          class n {
            constructor() {
              this.strings = [];
            }
            get(x) {
              return x >= 0 && x <= y - 1 ? e[x] : x - y <= this.strings.length ? this.strings[x - y] : e[0];
            }
            getSID(x) {
              let f = e.indexOf(x);
              return f !== -1 ? f : (f = this.strings.indexOf(x), f !== -1 ? f + y : -1);
            }
            add(x) {
              this.strings.push(x);
            }
            get count() {
              return this.strings.length;
            }
          }
          o.CFFStrings = n;
          class i {
            constructor() {
              this.objects = [], this.length = 0;
            }
            add(x) {
              this.length += x.length, this.objects.push(x);
            }
            set(x, f) {
              this.length += f.length - this.objects[x].length, this.objects[x] = f;
            }
            get(x) {
              return this.objects[x];
            }
            get count() {
              return this.objects.length;
            }
          }
          o.CFFIndex = i;
          class l {
            constructor(x, f) {
              this.keyToNameMap = x.keyToNameMap, this.nameToKeyMap = x.nameToKeyMap, this.defaults = x.defaults, this.types = x.types, this.opcodes = x.opcodes, this.order = x.order, this.strings = f, this.values = /* @__PURE__ */ Object.create(null);
            }
            setByKey(x, f) {
              if (!(x in this.keyToNameMap))
                return !1;
              const U = f.length;
              if (U === 0)
                return !0;
              for (let S = 0; S < U; S++)
                if (isNaN(f[S]))
                  return (0, t.warn)('Invalid CFFDict value: "' + f + '" for key "' + x + '".'), !0;
              const O = this.types[x];
              return (O === "num" || O === "sid" || O === "offset") && (f = f[0]), this.values[x] = f, !0;
            }
            setByName(x, f) {
              if (!(x in this.nameToKeyMap))
                throw new t.FormatError(`Invalid dictionary name "${x}"`);
              this.values[this.nameToKeyMap[x]] = f;
            }
            hasName(x) {
              return this.nameToKeyMap[x] in this.values;
            }
            getByName(x) {
              if (!(x in this.nameToKeyMap))
                throw new t.FormatError(`Invalid dictionary name ${x}"`);
              const f = this.nameToKeyMap[x];
              return f in this.values ? this.values[f] : this.defaults[f];
            }
            removeByName(x) {
              delete this.values[this.nameToKeyMap[x]];
            }
            static createTables(x) {
              const f = {
                keyToNameMap: {},
                nameToKeyMap: {},
                defaults: {},
                types: {},
                opcodes: {},
                order: []
              };
              for (let U = 0, O = x.length; U < O; ++U) {
                const S = x[U], F = Array.isArray(S[0]) ? (S[0][0] << 8) + S[0][1] : S[0];
                f.keyToNameMap[F] = S[1], f.nameToKeyMap[S[1]] = F, f.types[F] = S[2], f.defaults[F] = S[3], f.opcodes[F] = Array.isArray(S[0]) ? S[0] : [S[0]], f.order.push(F);
              }
              return f;
            }
          }
          const u = [[[12, 30], "ROS", ["sid", "sid", "num"], null], [[12, 20], "SyntheticBase", "num", null], [0, "version", "sid", null], [1, "Notice", "sid", null], [[12, 0], "Copyright", "sid", null], [2, "FullName", "sid", null], [3, "FamilyName", "sid", null], [4, "Weight", "sid", null], [[12, 1], "isFixedPitch", "num", 0], [[12, 2], "ItalicAngle", "num", 0], [[12, 3], "UnderlinePosition", "num", -100], [[12, 4], "UnderlineThickness", "num", 50], [[12, 5], "PaintType", "num", 0], [[12, 6], "CharstringType", "num", 2], [[12, 7], "FontMatrix", ["num", "num", "num", "num", "num", "num"], [1e-3, 0, 0, 1e-3, 0, 0]], [13, "UniqueID", "num", null], [5, "FontBBox", ["num", "num", "num", "num"], [0, 0, 0, 0]], [[12, 8], "StrokeWidth", "num", 0], [14, "XUID", "array", null], [15, "charset", "offset", 0], [16, "Encoding", "offset", 0], [17, "CharStrings", "offset", 0], [18, "Private", ["offset", "offset"], null], [[12, 21], "PostScript", "sid", null], [[12, 22], "BaseFontName", "sid", null], [[12, 23], "BaseFontBlend", "delta", null], [[12, 31], "CIDFontVersion", "num", 0], [[12, 32], "CIDFontRevision", "num", 0], [[12, 33], "CIDFontType", "num", 0], [[12, 34], "CIDCount", "num", 8720], [[12, 35], "UIDBase", "num", null], [[12, 37], "FDSelect", "offset", null], [[12, 36], "FDArray", "offset", null], [[12, 38], "FontName", "sid", null]];
          class w extends l {
            static get tables() {
              return (0, t.shadow)(this, "tables", this.createTables(u));
            }
            constructor(x) {
              super(w.tables, x), this.privateDict = null;
            }
          }
          o.CFFTopDict = w;
          const _ = [[6, "BlueValues", "delta", null], [7, "OtherBlues", "delta", null], [8, "FamilyBlues", "delta", null], [9, "FamilyOtherBlues", "delta", null], [[12, 9], "BlueScale", "num", 0.039625], [[12, 10], "BlueShift", "num", 7], [[12, 11], "BlueFuzz", "num", 1], [10, "StdHW", "num", null], [11, "StdVW", "num", null], [[12, 12], "StemSnapH", "delta", null], [[12, 13], "StemSnapV", "delta", null], [[12, 14], "ForceBold", "num", 0], [[12, 17], "LanguageGroup", "num", 0], [[12, 18], "ExpansionFactor", "num", 0.06], [[12, 19], "initialRandomSeed", "num", 0], [20, "defaultWidthX", "num", 0], [21, "nominalWidthX", "num", 0], [19, "Subrs", "offset", null]];
          class b extends l {
            static get tables() {
              return (0, t.shadow)(this, "tables", this.createTables(_));
            }
            constructor(x) {
              super(b.tables, x), this.subrsIndex = null;
            }
          }
          o.CFFPrivateDict = b;
          const A = {
            ISO_ADOBE: 0,
            EXPERT: 1,
            EXPERT_SUBSET: 2
          };
          class Y {
            constructor(x, f, U, O) {
              this.predefined = x, this.format = f, this.charset = U, this.raw = O;
            }
          }
          o.CFFCharset = Y;
          class j {
            constructor(x, f, U, O) {
              this.predefined = x, this.format = f, this.encoding = U, this.raw = O;
            }
          }
          class X {
            constructor(x, f) {
              this.format = x, this.fdSelect = f;
            }
            getFDIndex(x) {
              return x < 0 || x >= this.fdSelect.length ? -1 : this.fdSelect[x];
            }
          }
          o.CFFFDSelect = X;
          class B {
            constructor() {
              this.offsets = /* @__PURE__ */ Object.create(null);
            }
            isTracking(x) {
              return x in this.offsets;
            }
            track(x, f) {
              if (x in this.offsets)
                throw new t.FormatError(`Already tracking location of ${x}`);
              this.offsets[x] = f;
            }
            offset(x) {
              for (const f in this.offsets)
                this.offsets[f] += x;
            }
            setEntryLocation(x, f, U) {
              if (!(x in this.offsets))
                throw new t.FormatError(`Not tracking location of ${x}`);
              const O = U.data, S = this.offsets[x], F = 5;
              for (let T = 0, I = f.length; T < I; ++T) {
                const M = T * F + S, V = M + 1, J = M + 2, W = M + 3, z = M + 4;
                if (O[M] !== 29 || O[V] !== 0 || O[J] !== 0 || O[W] !== 0 || O[z] !== 0)
                  throw new t.FormatError("writing to an offset that is not empty");
                const G = f[T];
                O[M] = 29, O[V] = G >> 24 & 255, O[J] = G >> 16 & 255, O[W] = G >> 8 & 255, O[z] = G & 255;
              }
            }
          }
          class R {
            constructor(x) {
              this.cff = x;
            }
            compile() {
              const x = this.cff, f = {
                data: [],
                length: 0,
                add(W) {
                  this.data = this.data.concat(W), this.length = this.data.length;
                }
              }, U = this.compileHeader(x.header);
              f.add(U);
              const O = this.compileNameIndex(x.names);
              if (f.add(O), x.isCIDFont && x.topDict.hasName("FontMatrix")) {
                const W = x.topDict.getByName("FontMatrix");
                x.topDict.removeByName("FontMatrix");
                for (let z = 0, G = x.fdArray.length; z < G; z++) {
                  const L = x.fdArray[z];
                  let K = W.slice(0);
                  L.hasName("FontMatrix") && (K = t.Util.transform(K, L.getByName("FontMatrix"))), L.setByName("FontMatrix", K);
                }
              }
              const S = x.topDict.getByName("XUID");
              S && S.length > 16 && x.topDict.removeByName("XUID"), x.topDict.setByName("charset", 0);
              let F = this.compileTopDicts([x.topDict], f.length, x.isCIDFont);
              f.add(F.output);
              const T = F.trackers[0], I = this.compileStringIndex(x.strings.strings);
              f.add(I);
              const M = this.compileIndex(x.globalSubrIndex);
              if (f.add(M), x.encoding && x.topDict.hasName("Encoding"))
                if (x.encoding.predefined)
                  T.setEntryLocation("Encoding", [x.encoding.format], f);
                else {
                  const W = this.compileEncoding(x.encoding);
                  T.setEntryLocation("Encoding", [f.length], f), f.add(W);
                }
              const V = this.compileCharset(x.charset, x.charStrings.count, x.strings, x.isCIDFont);
              T.setEntryLocation("charset", [f.length], f), f.add(V);
              const J = this.compileCharStrings(x.charStrings);
              if (T.setEntryLocation("CharStrings", [f.length], f), f.add(J), x.isCIDFont) {
                T.setEntryLocation("FDSelect", [f.length], f);
                const W = this.compileFDSelect(x.fdSelect);
                f.add(W), F = this.compileTopDicts(x.fdArray, f.length, !0), T.setEntryLocation("FDArray", [f.length], f), f.add(F.output);
                const z = F.trackers;
                this.compilePrivateDicts(x.fdArray, z, f);
              }
              return this.compilePrivateDicts([x.topDict], [T], f), f.add([0]), f.data;
            }
            encodeNumber(x) {
              return Number.isInteger(x) ? this.encodeInteger(x) : this.encodeFloat(x);
            }
            static get EncodeFloatRegExp() {
              return (0, t.shadow)(this, "EncodeFloatRegExp", /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/);
            }
            encodeFloat(x) {
              let f = x.toString();
              const U = R.EncodeFloatRegExp.exec(f);
              if (U) {
                const I = parseFloat("1e" + ((U[2] ? +U[2] : 0) + U[1].length));
                f = (Math.round(x * I) / I).toString();
              }
              let O = "", S, F;
              for (S = 0, F = f.length; S < F; ++S) {
                const I = f[S];
                I === "e" ? O += f[++S] === "-" ? "c" : "b" : I === "." ? O += "a" : I === "-" ? O += "e" : O += I;
              }
              O += O.length & 1 ? "f" : "ff";
              const T = [30];
              for (S = 0, F = O.length; S < F; S += 2)
                T.push(parseInt(O.substring(S, S + 2), 16));
              return T;
            }
            encodeInteger(x) {
              let f;
              return x >= -107 && x <= 107 ? f = [x + 139] : x >= 108 && x <= 1131 ? (x -= 108, f = [(x >> 8) + 247, x & 255]) : x >= -1131 && x <= -108 ? (x = -x - 108, f = [(x >> 8) + 251, x & 255]) : x >= -32768 && x <= 32767 ? f = [28, x >> 8 & 255, x & 255] : f = [29, x >> 24 & 255, x >> 16 & 255, x >> 8 & 255, x & 255], f;
            }
            compileHeader(x) {
              return [x.major, x.minor, 4, x.offSize];
            }
            compileNameIndex(x) {
              const f = new i();
              for (let U = 0, O = x.length; U < O; ++U) {
                const S = x[U], F = Math.min(S.length, 127);
                let T = new Array(F);
                for (let I = 0; I < F; I++) {
                  let M = S[I];
                  (M < "!" || M > "~" || M === "[" || M === "]" || M === "(" || M === ")" || M === "{" || M === "}" || M === "<" || M === ">" || M === "/" || M === "%") && (M = "_"), T[I] = M;
                }
                T = T.join(""), T === "" && (T = "Bad_Font_Name"), f.add((0, t.stringToBytes)(T));
              }
              return this.compileIndex(f);
            }
            compileTopDicts(x, f, U) {
              const O = [];
              let S = new i();
              for (let F = 0, T = x.length; F < T; ++F) {
                const I = x[F];
                U && (I.removeByName("CIDFontVersion"), I.removeByName("CIDFontRevision"), I.removeByName("CIDFontType"), I.removeByName("CIDCount"), I.removeByName("UIDBase"));
                const M = new B(), V = this.compileDict(I, M);
                O.push(M), S.add(V), M.offset(f);
              }
              return S = this.compileIndex(S, O), {
                trackers: O,
                output: S
              };
            }
            compilePrivateDicts(x, f, U) {
              for (let O = 0, S = x.length; O < S; ++O) {
                const F = x[O], T = F.privateDict;
                if (!T || !F.hasName("Private"))
                  throw new t.FormatError("There must be a private dictionary.");
                const I = new B(), M = this.compileDict(T, I);
                let V = U.length;
                if (I.offset(V), M.length || (V = 0), f[O].setEntryLocation("Private", [M.length, V], U), U.add(M), T.subrsIndex && T.hasName("Subrs")) {
                  const J = this.compileIndex(T.subrsIndex);
                  I.setEntryLocation("Subrs", [M.length], U), U.add(J);
                }
              }
            }
            compileDict(x, f) {
              const U = [];
              for (const O of x.order) {
                if (!(O in x.values))
                  continue;
                let S = x.values[O], F = x.types[O];
                if (Array.isArray(F) || (F = [F]), Array.isArray(S) || (S = [S]), S.length !== 0) {
                  for (let T = 0, I = F.length; T < I; ++T) {
                    const M = F[T], V = S[T];
                    switch (M) {
                      case "num":
                      case "sid":
                        U.push(...this.encodeNumber(V));
                        break;
                      case "offset":
                        const J = x.keyToNameMap[O];
                        f.isTracking(J) || f.track(J, U.length), U.push(29, 0, 0, 0, 0);
                        break;
                      case "array":
                      case "delta":
                        U.push(...this.encodeNumber(V));
                        for (let W = 1, z = S.length; W < z; ++W)
                          U.push(...this.encodeNumber(S[W]));
                        break;
                      default:
                        throw new t.FormatError(`Unknown data type of ${M}`);
                    }
                  }
                  U.push(...x.opcodes[O]);
                }
              }
              return U;
            }
            compileStringIndex(x) {
              const f = new i();
              for (let U = 0, O = x.length; U < O; ++U)
                f.add((0, t.stringToBytes)(x[U]));
              return this.compileIndex(f);
            }
            compileGlobalSubrIndex() {
              const x = this.cff.globalSubrIndex;
              this.out.writeByteArray(this.compileIndex(x));
            }
            compileCharStrings(x) {
              const f = new i();
              for (let U = 0; U < x.count; U++) {
                const O = x.get(U);
                if (O.length === 0) {
                  f.add(new Uint8Array([139, 14]));
                  continue;
                }
                f.add(O);
              }
              return this.compileIndex(f);
            }
            compileCharset(x, f, U, O) {
              let S;
              const F = f - 1;
              if (O)
                S = new Uint8Array([2, 0, 0, F >> 8 & 255, F & 255]);
              else {
                const T = 1 + F * 2;
                S = new Uint8Array(T), S[0] = 0;
                let I = 0;
                const M = x.charset.length;
                let V = !1;
                for (let J = 1; J < S.length; J += 2) {
                  let W = 0;
                  if (I < M) {
                    const z = x.charset[I++];
                    W = U.getSID(z), W === -1 && (W = 0, V || (V = !0, (0, t.warn)(`Couldn't find ${z} in CFF strings`)));
                  }
                  S[J] = W >> 8 & 255, S[J + 1] = W & 255;
                }
              }
              return this.compileTypedArray(S);
            }
            compileEncoding(x) {
              return this.compileTypedArray(x.raw);
            }
            compileFDSelect(x) {
              const f = x.format;
              let U, O;
              switch (f) {
                case 0:
                  for (U = new Uint8Array(1 + x.fdSelect.length), U[0] = f, O = 0; O < x.fdSelect.length; O++)
                    U[O + 1] = x.fdSelect[O];
                  break;
                case 3:
                  const S = 0;
                  let F = x.fdSelect[0];
                  const T = [f, 0, 0, S >> 8 & 255, S & 255, F];
                  for (O = 1; O < x.fdSelect.length; O++) {
                    const M = x.fdSelect[O];
                    M !== F && (T.push(O >> 8 & 255, O & 255, M), F = M);
                  }
                  const I = (T.length - 3) / 3;
                  T[1] = I >> 8 & 255, T[2] = I & 255, T.push(O >> 8 & 255, O & 255), U = new Uint8Array(T);
                  break;
              }
              return this.compileTypedArray(U);
            }
            compileTypedArray(x) {
              const f = [];
              for (let U = 0, O = x.length; U < O; ++U)
                f[U] = x[U];
              return f;
            }
            compileIndex(x, f = []) {
              const U = x.objects, O = U.length;
              if (O === 0)
                return [0, 0];
              const S = [O >> 8 & 255, O & 255];
              let F = 1, T;
              for (T = 0; T < O; ++T)
                F += U[T].length;
              let I;
              F < 256 ? I = 1 : F < 65536 ? I = 2 : F < 16777216 ? I = 3 : I = 4, S.push(I);
              let M = 1;
              for (T = 0; T < O + 1; T++)
                I === 1 ? S.push(M & 255) : I === 2 ? S.push(M >> 8 & 255, M & 255) : I === 3 ? S.push(M >> 16 & 255, M >> 8 & 255, M & 255) : S.push(M >>> 24 & 255, M >> 16 & 255, M >> 8 & 255, M & 255), U[T] && (M += U[T].length);
              for (T = 0; T < O; T++) {
                f[T] && f[T].offset(S.length);
                for (let V = 0, J = U[T].length; V < J; V++)
                  S.push(U[T][V]);
              }
              return S;
            }
          }
          o.CFFCompiler = R;
        },
        /* 36 */
        /***/
        (Z, o) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.ISOAdobeCharset = o.ExpertSubsetCharset = o.ExpertCharset = void 0;
          const C = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron"];
          o.ISOAdobeCharset = C;
          const t = [".notdef", "space", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
          o.ExpertCharset = t;
          const a = [".notdef", "space", "dollaroldstyle", "dollarsuperior", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "hyphensuperior", "colonmonetary", "onefitted", "rupiah", "centoldstyle", "figuredash", "hypheninferior", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior"];
          o.ExpertSubsetCharset = a;
        },
        /* 37 */
        /***/
        (Z, o) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.ZapfDingbatsEncoding = o.WinAnsiEncoding = o.SymbolSetEncoding = o.StandardEncoding = o.MacRomanEncoding = o.ExpertEncoding = void 0, o.getEncoding = c;
          const C = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
          o.ExpertEncoding = C;
          const t = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "centoldstyle", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "", "threequartersemdash", "", "questionsmall", "", "", "", "", "Ethsmall", "", "", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "", "", "", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hypheninferior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "asuperior", "centsuperior", "", "", "", "", "Aacutesmall", "Agravesmall", "Acircumflexsmall", "Adieresissmall", "Atildesmall", "Aringsmall", "Ccedillasmall", "Eacutesmall", "Egravesmall", "Ecircumflexsmall", "Edieresissmall", "Iacutesmall", "Igravesmall", "Icircumflexsmall", "Idieresissmall", "Ntildesmall", "Oacutesmall", "Ogravesmall", "Ocircumflexsmall", "Odieresissmall", "Otildesmall", "Uacutesmall", "Ugravesmall", "Ucircumflexsmall", "Udieresissmall", "", "eightsuperior", "fourinferior", "threeinferior", "sixinferior", "eightinferior", "seveninferior", "Scaronsmall", "", "centinferior", "twoinferior", "", "Dieresissmall", "", "Caronsmall", "osuperior", "fiveinferior", "", "commainferior", "periodinferior", "Yacutesmall", "", "dollarinferior", "", "", "Thornsmall", "", "nineinferior", "zeroinferior", "Zcaronsmall", "AEsmall", "Oslashsmall", "questiondownsmall", "oneinferior", "Lslashsmall", "", "", "", "", "", "", "Cedillasmall", "", "", "", "", "", "OEsmall", "figuredash", "hyphensuperior", "", "", "", "", "exclamdownsmall", "", "Ydieresissmall", "", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "ninesuperior", "zerosuperior", "", "esuperior", "rsuperior", "tsuperior", "", "", "isuperior", "ssuperior", "dsuperior", "", "", "", "", "", "lsuperior", "Ogoneksmall", "Brevesmall", "Macronsmall", "bsuperior", "nsuperior", "msuperior", "commasuperior", "periodsuperior", "Dotaccentsmall", "Ringsmall", "", "", "", ""], a = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "space", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron"];
          o.MacRomanEncoding = a;
          const v = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls", "", "", "", ""];
          o.StandardEncoding = v;
          const h = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "bullet", "Euro", "bullet", "quotesinglbase", "florin", "quotedblbase", "ellipsis", "dagger", "daggerdbl", "circumflex", "perthousand", "Scaron", "guilsinglleft", "OE", "bullet", "Zcaron", "bullet", "bullet", "quoteleft", "quoteright", "quotedblleft", "quotedblright", "bullet", "endash", "emdash", "tilde", "trademark", "scaron", "guilsinglright", "oe", "bullet", "zcaron", "Ydieresis", "space", "exclamdown", "cent", "sterling", "currency", "yen", "brokenbar", "section", "dieresis", "copyright", "ordfeminine", "guillemotleft", "logicalnot", "hyphen", "registered", "macron", "degree", "plusminus", "twosuperior", "threesuperior", "acute", "mu", "paragraph", "periodcentered", "cedilla", "onesuperior", "ordmasculine", "guillemotright", "onequarter", "onehalf", "threequarters", "questiondown", "Agrave", "Aacute", "Acircumflex", "Atilde", "Adieresis", "Aring", "AE", "Ccedilla", "Egrave", "Eacute", "Ecircumflex", "Edieresis", "Igrave", "Iacute", "Icircumflex", "Idieresis", "Eth", "Ntilde", "Ograve", "Oacute", "Ocircumflex", "Otilde", "Odieresis", "multiply", "Oslash", "Ugrave", "Uacute", "Ucircumflex", "Udieresis", "Yacute", "Thorn", "germandbls", "agrave", "aacute", "acircumflex", "atilde", "adieresis", "aring", "ae", "ccedilla", "egrave", "eacute", "ecircumflex", "edieresis", "igrave", "iacute", "icircumflex", "idieresis", "eth", "ntilde", "ograve", "oacute", "ocircumflex", "otilde", "odieresis", "divide", "oslash", "ugrave", "uacute", "ucircumflex", "udieresis", "yacute", "thorn", "ydieresis"];
          o.WinAnsiEncoding = h;
          const e = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "universal", "numbersign", "existential", "percent", "ampersand", "suchthat", "parenleft", "parenright", "asteriskmath", "plus", "comma", "minus", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "congruent", "Alpha", "Beta", "Chi", "Delta", "Epsilon", "Phi", "Gamma", "Eta", "Iota", "theta1", "Kappa", "Lambda", "Mu", "Nu", "Omicron", "Pi", "Theta", "Rho", "Sigma", "Tau", "Upsilon", "sigma1", "Omega", "Xi", "Psi", "Zeta", "bracketleft", "therefore", "bracketright", "perpendicular", "underscore", "radicalex", "alpha", "beta", "chi", "delta", "epsilon", "phi", "gamma", "eta", "iota", "phi1", "kappa", "lambda", "mu", "nu", "omicron", "pi", "theta", "rho", "sigma", "tau", "upsilon", "omega1", "omega", "xi", "psi", "zeta", "braceleft", "bar", "braceright", "similar", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Euro", "Upsilon1", "minute", "lessequal", "fraction", "infinity", "florin", "club", "diamond", "heart", "spade", "arrowboth", "arrowleft", "arrowup", "arrowright", "arrowdown", "degree", "plusminus", "second", "greaterequal", "multiply", "proportional", "partialdiff", "bullet", "divide", "notequal", "equivalence", "approxequal", "ellipsis", "arrowvertex", "arrowhorizex", "carriagereturn", "aleph", "Ifraktur", "Rfraktur", "weierstrass", "circlemultiply", "circleplus", "emptyset", "intersection", "union", "propersuperset", "reflexsuperset", "notsubset", "propersubset", "reflexsubset", "element", "notelement", "angle", "gradient", "registerserif", "copyrightserif", "trademarkserif", "product", "radical", "dotmath", "logicalnot", "logicaland", "logicalor", "arrowdblboth", "arrowdblleft", "arrowdblup", "arrowdblright", "arrowdbldown", "lozenge", "angleleft", "registersans", "copyrightsans", "trademarksans", "summation", "parenlefttp", "parenleftex", "parenleftbt", "bracketlefttp", "bracketleftex", "bracketleftbt", "bracelefttp", "braceleftmid", "braceleftbt", "braceex", "", "angleright", "integral", "integraltp", "integralex", "integralbt", "parenrighttp", "parenrightex", "parenrightbt", "bracketrighttp", "bracketrightex", "bracketrightbt", "bracerighttp", "bracerightmid", "bracerightbt", ""];
          o.SymbolSetEncoding = e;
          const y = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "a1", "a2", "a202", "a3", "a4", "a5", "a119", "a118", "a117", "a11", "a12", "a13", "a14", "a15", "a16", "a105", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24", "a25", "a26", "a27", "a28", "a6", "a7", "a8", "a9", "a10", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36", "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48", "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60", "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72", "a73", "a74", "a203", "a75", "a204", "a76", "a77", "a78", "a79", "a81", "a82", "a83", "a84", "a97", "a98", "a99", "a100", "", "a89", "a90", "a93", "a94", "a91", "a92", "a205", "a85", "a206", "a86", "a87", "a88", "a95", "a96", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "a101", "a102", "a103", "a104", "a106", "a107", "a108", "a112", "a111", "a110", "a109", "a120", "a121", "a122", "a123", "a124", "a125", "a126", "a127", "a128", "a129", "a130", "a131", "a132", "a133", "a134", "a135", "a136", "a137", "a138", "a139", "a140", "a141", "a142", "a143", "a144", "a145", "a146", "a147", "a148", "a149", "a150", "a151", "a152", "a153", "a154", "a155", "a156", "a157", "a158", "a159", "a160", "a161", "a163", "a164", "a196", "a165", "a192", "a166", "a167", "a168", "a169", "a170", "a171", "a172", "a173", "a162", "a174", "a175", "a176", "a177", "a178", "a179", "a193", "a180", "a199", "a181", "a200", "a182", "", "a201", "a183", "a184", "a197", "a185", "a194", "a198", "a186", "a195", "a187", "a188", "a189", "a190", "a191", ""];
          o.ZapfDingbatsEncoding = y;
          function c(d) {
            switch (d) {
              case "WinAnsiEncoding":
                return h;
              case "StandardEncoding":
                return v;
              case "MacRomanEncoding":
                return a;
              case "SymbolSetEncoding":
                return e;
              case "ZapfDingbatsEncoding":
                return y;
              case "ExpertEncoding":
                return C;
              case "MacExpertEncoding":
                return t;
              default:
                return null;
            }
          }
        },
        /* 38 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.SEAC_ANALYSIS_ENABLED = o.MacStandardGlyphOrdering = o.FontFlags = void 0, o.getFontType = d, o.normalizeFontName = g, o.recoverGlyphName = p, o.type1FontGlyphMapping = m;
          var t = C(2), a = C(37), v = C(39), h = C(40);
          const e = !0;
          o.SEAC_ANALYSIS_ENABLED = e;
          const y = {
            FixedPitch: 1,
            Serif: 2,
            Symbolic: 4,
            Script: 8,
            Nonsymbolic: 32,
            Italic: 64,
            AllCap: 65536,
            SmallCap: 131072,
            ForceBold: 262144
          };
          o.FontFlags = y;
          const c = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];
          o.MacStandardGlyphOrdering = c;
          function d(n, i, l = !1) {
            switch (n) {
              case "Type1":
                return l ? t.FontType.TYPE1STANDARD : i === "Type1C" ? t.FontType.TYPE1C : t.FontType.TYPE1;
              case "CIDFontType0":
                return i === "CIDFontType0C" ? t.FontType.CIDFONTTYPE0C : t.FontType.CIDFONTTYPE0;
              case "OpenType":
                return t.FontType.OPENTYPE;
              case "TrueType":
                return t.FontType.TRUETYPE;
              case "CIDFontType2":
                return t.FontType.CIDFONTTYPE2;
              case "MMType1":
                return t.FontType.MMTYPE1;
              case "Type0":
                return t.FontType.TYPE0;
              default:
                return t.FontType.UNKNOWN;
            }
          }
          function p(n, i) {
            if (i[n] !== void 0)
              return n;
            const l = (0, h.getUnicodeForGlyph)(n, i);
            if (l !== -1) {
              for (const u in i)
                if (i[u] === l)
                  return u;
            }
            return (0, t.info)("Unable to recover a standard glyph name for: " + n), n;
          }
          function m(n, i, l) {
            const u = /* @__PURE__ */ Object.create(null);
            let w, _, b;
            const A = !!(n.flags & y.Symbolic);
            if (n.isInternalFont)
              for (b = i, _ = 0; _ < b.length; _++)
                w = l.indexOf(b[_]), w >= 0 ? u[_] = w : u[_] = 0;
            else if (n.baseEncodingName)
              for (b = (0, a.getEncoding)(n.baseEncodingName), _ = 0; _ < b.length; _++)
                w = l.indexOf(b[_]), w >= 0 ? u[_] = w : u[_] = 0;
            else if (A)
              for (_ in i)
                u[_] = i[_];
            else
              for (b = a.StandardEncoding, _ = 0; _ < b.length; _++)
                w = l.indexOf(b[_]), w >= 0 ? u[_] = w : u[_] = 0;
            const Y = n.differences;
            let j;
            if (Y)
              for (_ in Y) {
                const X = Y[_];
                if (w = l.indexOf(X), w === -1) {
                  j || (j = (0, v.getGlyphsUnicode)());
                  const B = p(X, j);
                  B !== X && (w = l.indexOf(B));
                }
                w >= 0 ? u[_] = w : u[_] = 0;
              }
            return u;
          }
          function g(n) {
            return n.replace(/[,_]/g, "-").replace(/\s/g, "");
          }
        },
        /* 39 */
        /***/
        (Z, o, C) => {
          C.r(o), C.d(o, {
            /* harmony export */
            getDingbatsGlyphsUnicode: () => (
              /* binding */
              v
            ),
            /* harmony export */
            getGlyphsUnicode: () => (
              /* binding */
              a
            )
            /* harmony export */
          });
          var t = C(6);
          const a = (0, t.getArrayLookupTableFactory)(function() {
            return [
              "A",
              65,
              "AE",
              198,
              "AEacute",
              508,
              "AEmacron",
              482,
              "AEsmall",
              63462,
              "Aacute",
              193,
              "Aacutesmall",
              63457,
              "Abreve",
              258,
              "Abreveacute",
              7854,
              "Abrevecyrillic",
              1232,
              "Abrevedotbelow",
              7862,
              "Abrevegrave",
              7856,
              "Abrevehookabove",
              7858,
              "Abrevetilde",
              7860,
              "Acaron",
              461,
              "Acircle",
              9398,
              "Acircumflex",
              194,
              "Acircumflexacute",
              7844,
              "Acircumflexdotbelow",
              7852,
              "Acircumflexgrave",
              7846,
              "Acircumflexhookabove",
              7848,
              "Acircumflexsmall",
              63458,
              "Acircumflextilde",
              7850,
              "Acute",
              63177,
              "Acutesmall",
              63412,
              "Acyrillic",
              1040,
              "Adblgrave",
              512,
              "Adieresis",
              196,
              "Adieresiscyrillic",
              1234,
              "Adieresismacron",
              478,
              "Adieresissmall",
              63460,
              "Adotbelow",
              7840,
              "Adotmacron",
              480,
              "Agrave",
              192,
              "Agravesmall",
              63456,
              "Ahookabove",
              7842,
              "Aiecyrillic",
              1236,
              "Ainvertedbreve",
              514,
              "Alpha",
              913,
              "Alphatonos",
              902,
              "Amacron",
              256,
              "Amonospace",
              65313,
              "Aogonek",
              260,
              "Aring",
              197,
              "Aringacute",
              506,
              "Aringbelow",
              7680,
              "Aringsmall",
              63461,
              "Asmall",
              63329,
              "Atilde",
              195,
              "Atildesmall",
              63459,
              "Aybarmenian",
              1329,
              "B",
              66,
              "Bcircle",
              9399,
              "Bdotaccent",
              7682,
              "Bdotbelow",
              7684,
              "Becyrillic",
              1041,
              "Benarmenian",
              1330,
              "Beta",
              914,
              "Bhook",
              385,
              "Blinebelow",
              7686,
              "Bmonospace",
              65314,
              "Brevesmall",
              63220,
              "Bsmall",
              63330,
              "Btopbar",
              386,
              "C",
              67,
              "Caarmenian",
              1342,
              "Cacute",
              262,
              "Caron",
              63178,
              "Caronsmall",
              63221,
              "Ccaron",
              268,
              "Ccedilla",
              199,
              "Ccedillaacute",
              7688,
              "Ccedillasmall",
              63463,
              "Ccircle",
              9400,
              "Ccircumflex",
              264,
              "Cdot",
              266,
              "Cdotaccent",
              266,
              "Cedillasmall",
              63416,
              "Chaarmenian",
              1353,
              "Cheabkhasiancyrillic",
              1212,
              "Checyrillic",
              1063,
              "Chedescenderabkhasiancyrillic",
              1214,
              "Chedescendercyrillic",
              1206,
              "Chedieresiscyrillic",
              1268,
              "Cheharmenian",
              1347,
              "Chekhakassiancyrillic",
              1227,
              "Cheverticalstrokecyrillic",
              1208,
              "Chi",
              935,
              "Chook",
              391,
              "Circumflexsmall",
              63222,
              "Cmonospace",
              65315,
              "Coarmenian",
              1361,
              "Csmall",
              63331,
              "D",
              68,
              "DZ",
              497,
              "DZcaron",
              452,
              "Daarmenian",
              1332,
              "Dafrican",
              393,
              "Dcaron",
              270,
              "Dcedilla",
              7696,
              "Dcircle",
              9401,
              "Dcircumflexbelow",
              7698,
              "Dcroat",
              272,
              "Ddotaccent",
              7690,
              "Ddotbelow",
              7692,
              "Decyrillic",
              1044,
              "Deicoptic",
              1006,
              "Delta",
              8710,
              "Deltagreek",
              916,
              "Dhook",
              394,
              "Dieresis",
              63179,
              "DieresisAcute",
              63180,
              "DieresisGrave",
              63181,
              "Dieresissmall",
              63400,
              "Digammagreek",
              988,
              "Djecyrillic",
              1026,
              "Dlinebelow",
              7694,
              "Dmonospace",
              65316,
              "Dotaccentsmall",
              63223,
              "Dslash",
              272,
              "Dsmall",
              63332,
              "Dtopbar",
              395,
              "Dz",
              498,
              "Dzcaron",
              453,
              "Dzeabkhasiancyrillic",
              1248,
              "Dzecyrillic",
              1029,
              "Dzhecyrillic",
              1039,
              "E",
              69,
              "Eacute",
              201,
              "Eacutesmall",
              63465,
              "Ebreve",
              276,
              "Ecaron",
              282,
              "Ecedillabreve",
              7708,
              "Echarmenian",
              1333,
              "Ecircle",
              9402,
              "Ecircumflex",
              202,
              "Ecircumflexacute",
              7870,
              "Ecircumflexbelow",
              7704,
              "Ecircumflexdotbelow",
              7878,
              "Ecircumflexgrave",
              7872,
              "Ecircumflexhookabove",
              7874,
              "Ecircumflexsmall",
              63466,
              "Ecircumflextilde",
              7876,
              "Ecyrillic",
              1028,
              "Edblgrave",
              516,
              "Edieresis",
              203,
              "Edieresissmall",
              63467,
              "Edot",
              278,
              "Edotaccent",
              278,
              "Edotbelow",
              7864,
              "Efcyrillic",
              1060,
              "Egrave",
              200,
              "Egravesmall",
              63464,
              "Eharmenian",
              1335,
              "Ehookabove",
              7866,
              "Eightroman",
              8551,
              "Einvertedbreve",
              518,
              "Eiotifiedcyrillic",
              1124,
              "Elcyrillic",
              1051,
              "Elevenroman",
              8554,
              "Emacron",
              274,
              "Emacronacute",
              7702,
              "Emacrongrave",
              7700,
              "Emcyrillic",
              1052,
              "Emonospace",
              65317,
              "Encyrillic",
              1053,
              "Endescendercyrillic",
              1186,
              "Eng",
              330,
              "Enghecyrillic",
              1188,
              "Enhookcyrillic",
              1223,
              "Eogonek",
              280,
              "Eopen",
              400,
              "Epsilon",
              917,
              "Epsilontonos",
              904,
              "Ercyrillic",
              1056,
              "Ereversed",
              398,
              "Ereversedcyrillic",
              1069,
              "Escyrillic",
              1057,
              "Esdescendercyrillic",
              1194,
              "Esh",
              425,
              "Esmall",
              63333,
              "Eta",
              919,
              "Etarmenian",
              1336,
              "Etatonos",
              905,
              "Eth",
              208,
              "Ethsmall",
              63472,
              "Etilde",
              7868,
              "Etildebelow",
              7706,
              "Euro",
              8364,
              "Ezh",
              439,
              "Ezhcaron",
              494,
              "Ezhreversed",
              440,
              "F",
              70,
              "Fcircle",
              9403,
              "Fdotaccent",
              7710,
              "Feharmenian",
              1366,
              "Feicoptic",
              996,
              "Fhook",
              401,
              "Fitacyrillic",
              1138,
              "Fiveroman",
              8548,
              "Fmonospace",
              65318,
              "Fourroman",
              8547,
              "Fsmall",
              63334,
              "G",
              71,
              "GBsquare",
              13191,
              "Gacute",
              500,
              "Gamma",
              915,
              "Gammaafrican",
              404,
              "Gangiacoptic",
              1002,
              "Gbreve",
              286,
              "Gcaron",
              486,
              "Gcedilla",
              290,
              "Gcircle",
              9404,
              "Gcircumflex",
              284,
              "Gcommaaccent",
              290,
              "Gdot",
              288,
              "Gdotaccent",
              288,
              "Gecyrillic",
              1043,
              "Ghadarmenian",
              1346,
              "Ghemiddlehookcyrillic",
              1172,
              "Ghestrokecyrillic",
              1170,
              "Gheupturncyrillic",
              1168,
              "Ghook",
              403,
              "Gimarmenian",
              1331,
              "Gjecyrillic",
              1027,
              "Gmacron",
              7712,
              "Gmonospace",
              65319,
              "Grave",
              63182,
              "Gravesmall",
              63328,
              "Gsmall",
              63335,
              "Gsmallhook",
              667,
              "Gstroke",
              484,
              "H",
              72,
              "H18533",
              9679,
              "H18543",
              9642,
              "H18551",
              9643,
              "H22073",
              9633,
              "HPsquare",
              13259,
              "Haabkhasiancyrillic",
              1192,
              "Hadescendercyrillic",
              1202,
              "Hardsigncyrillic",
              1066,
              "Hbar",
              294,
              "Hbrevebelow",
              7722,
              "Hcedilla",
              7720,
              "Hcircle",
              9405,
              "Hcircumflex",
              292,
              "Hdieresis",
              7718,
              "Hdotaccent",
              7714,
              "Hdotbelow",
              7716,
              "Hmonospace",
              65320,
              "Hoarmenian",
              1344,
              "Horicoptic",
              1e3,
              "Hsmall",
              63336,
              "Hungarumlaut",
              63183,
              "Hungarumlautsmall",
              63224,
              "Hzsquare",
              13200,
              "I",
              73,
              "IAcyrillic",
              1071,
              "IJ",
              306,
              "IUcyrillic",
              1070,
              "Iacute",
              205,
              "Iacutesmall",
              63469,
              "Ibreve",
              300,
              "Icaron",
              463,
              "Icircle",
              9406,
              "Icircumflex",
              206,
              "Icircumflexsmall",
              63470,
              "Icyrillic",
              1030,
              "Idblgrave",
              520,
              "Idieresis",
              207,
              "Idieresisacute",
              7726,
              "Idieresiscyrillic",
              1252,
              "Idieresissmall",
              63471,
              "Idot",
              304,
              "Idotaccent",
              304,
              "Idotbelow",
              7882,
              "Iebrevecyrillic",
              1238,
              "Iecyrillic",
              1045,
              "Ifraktur",
              8465,
              "Igrave",
              204,
              "Igravesmall",
              63468,
              "Ihookabove",
              7880,
              "Iicyrillic",
              1048,
              "Iinvertedbreve",
              522,
              "Iishortcyrillic",
              1049,
              "Imacron",
              298,
              "Imacroncyrillic",
              1250,
              "Imonospace",
              65321,
              "Iniarmenian",
              1339,
              "Iocyrillic",
              1025,
              "Iogonek",
              302,
              "Iota",
              921,
              "Iotaafrican",
              406,
              "Iotadieresis",
              938,
              "Iotatonos",
              906,
              "Ismall",
              63337,
              "Istroke",
              407,
              "Itilde",
              296,
              "Itildebelow",
              7724,
              "Izhitsacyrillic",
              1140,
              "Izhitsadblgravecyrillic",
              1142,
              "J",
              74,
              "Jaarmenian",
              1345,
              "Jcircle",
              9407,
              "Jcircumflex",
              308,
              "Jecyrillic",
              1032,
              "Jheharmenian",
              1355,
              "Jmonospace",
              65322,
              "Jsmall",
              63338,
              "K",
              75,
              "KBsquare",
              13189,
              "KKsquare",
              13261,
              "Kabashkircyrillic",
              1184,
              "Kacute",
              7728,
              "Kacyrillic",
              1050,
              "Kadescendercyrillic",
              1178,
              "Kahookcyrillic",
              1219,
              "Kappa",
              922,
              "Kastrokecyrillic",
              1182,
              "Kaverticalstrokecyrillic",
              1180,
              "Kcaron",
              488,
              "Kcedilla",
              310,
              "Kcircle",
              9408,
              "Kcommaaccent",
              310,
              "Kdotbelow",
              7730,
              "Keharmenian",
              1364,
              "Kenarmenian",
              1343,
              "Khacyrillic",
              1061,
              "Kheicoptic",
              998,
              "Khook",
              408,
              "Kjecyrillic",
              1036,
              "Klinebelow",
              7732,
              "Kmonospace",
              65323,
              "Koppacyrillic",
              1152,
              "Koppagreek",
              990,
              "Ksicyrillic",
              1134,
              "Ksmall",
              63339,
              "L",
              76,
              "LJ",
              455,
              "LL",
              63167,
              "Lacute",
              313,
              "Lambda",
              923,
              "Lcaron",
              317,
              "Lcedilla",
              315,
              "Lcircle",
              9409,
              "Lcircumflexbelow",
              7740,
              "Lcommaaccent",
              315,
              "Ldot",
              319,
              "Ldotaccent",
              319,
              "Ldotbelow",
              7734,
              "Ldotbelowmacron",
              7736,
              "Liwnarmenian",
              1340,
              "Lj",
              456,
              "Ljecyrillic",
              1033,
              "Llinebelow",
              7738,
              "Lmonospace",
              65324,
              "Lslash",
              321,
              "Lslashsmall",
              63225,
              "Lsmall",
              63340,
              "M",
              77,
              "MBsquare",
              13190,
              "Macron",
              63184,
              "Macronsmall",
              63407,
              "Macute",
              7742,
              "Mcircle",
              9410,
              "Mdotaccent",
              7744,
              "Mdotbelow",
              7746,
              "Menarmenian",
              1348,
              "Mmonospace",
              65325,
              "Msmall",
              63341,
              "Mturned",
              412,
              "Mu",
              924,
              "N",
              78,
              "NJ",
              458,
              "Nacute",
              323,
              "Ncaron",
              327,
              "Ncedilla",
              325,
              "Ncircle",
              9411,
              "Ncircumflexbelow",
              7754,
              "Ncommaaccent",
              325,
              "Ndotaccent",
              7748,
              "Ndotbelow",
              7750,
              "Nhookleft",
              413,
              "Nineroman",
              8552,
              "Nj",
              459,
              "Njecyrillic",
              1034,
              "Nlinebelow",
              7752,
              "Nmonospace",
              65326,
              "Nowarmenian",
              1350,
              "Nsmall",
              63342,
              "Ntilde",
              209,
              "Ntildesmall",
              63473,
              "Nu",
              925,
              "O",
              79,
              "OE",
              338,
              "OEsmall",
              63226,
              "Oacute",
              211,
              "Oacutesmall",
              63475,
              "Obarredcyrillic",
              1256,
              "Obarreddieresiscyrillic",
              1258,
              "Obreve",
              334,
              "Ocaron",
              465,
              "Ocenteredtilde",
              415,
              "Ocircle",
              9412,
              "Ocircumflex",
              212,
              "Ocircumflexacute",
              7888,
              "Ocircumflexdotbelow",
              7896,
              "Ocircumflexgrave",
              7890,
              "Ocircumflexhookabove",
              7892,
              "Ocircumflexsmall",
              63476,
              "Ocircumflextilde",
              7894,
              "Ocyrillic",
              1054,
              "Odblacute",
              336,
              "Odblgrave",
              524,
              "Odieresis",
              214,
              "Odieresiscyrillic",
              1254,
              "Odieresissmall",
              63478,
              "Odotbelow",
              7884,
              "Ogoneksmall",
              63227,
              "Ograve",
              210,
              "Ogravesmall",
              63474,
              "Oharmenian",
              1365,
              "Ohm",
              8486,
              "Ohookabove",
              7886,
              "Ohorn",
              416,
              "Ohornacute",
              7898,
              "Ohorndotbelow",
              7906,
              "Ohorngrave",
              7900,
              "Ohornhookabove",
              7902,
              "Ohorntilde",
              7904,
              "Ohungarumlaut",
              336,
              "Oi",
              418,
              "Oinvertedbreve",
              526,
              "Omacron",
              332,
              "Omacronacute",
              7762,
              "Omacrongrave",
              7760,
              "Omega",
              8486,
              "Omegacyrillic",
              1120,
              "Omegagreek",
              937,
              "Omegaroundcyrillic",
              1146,
              "Omegatitlocyrillic",
              1148,
              "Omegatonos",
              911,
              "Omicron",
              927,
              "Omicrontonos",
              908,
              "Omonospace",
              65327,
              "Oneroman",
              8544,
              "Oogonek",
              490,
              "Oogonekmacron",
              492,
              "Oopen",
              390,
              "Oslash",
              216,
              "Oslashacute",
              510,
              "Oslashsmall",
              63480,
              "Osmall",
              63343,
              "Ostrokeacute",
              510,
              "Otcyrillic",
              1150,
              "Otilde",
              213,
              "Otildeacute",
              7756,
              "Otildedieresis",
              7758,
              "Otildesmall",
              63477,
              "P",
              80,
              "Pacute",
              7764,
              "Pcircle",
              9413,
              "Pdotaccent",
              7766,
              "Pecyrillic",
              1055,
              "Peharmenian",
              1354,
              "Pemiddlehookcyrillic",
              1190,
              "Phi",
              934,
              "Phook",
              420,
              "Pi",
              928,
              "Piwrarmenian",
              1363,
              "Pmonospace",
              65328,
              "Psi",
              936,
              "Psicyrillic",
              1136,
              "Psmall",
              63344,
              "Q",
              81,
              "Qcircle",
              9414,
              "Qmonospace",
              65329,
              "Qsmall",
              63345,
              "R",
              82,
              "Raarmenian",
              1356,
              "Racute",
              340,
              "Rcaron",
              344,
              "Rcedilla",
              342,
              "Rcircle",
              9415,
              "Rcommaaccent",
              342,
              "Rdblgrave",
              528,
              "Rdotaccent",
              7768,
              "Rdotbelow",
              7770,
              "Rdotbelowmacron",
              7772,
              "Reharmenian",
              1360,
              "Rfraktur",
              8476,
              "Rho",
              929,
              "Ringsmall",
              63228,
              "Rinvertedbreve",
              530,
              "Rlinebelow",
              7774,
              "Rmonospace",
              65330,
              "Rsmall",
              63346,
              "Rsmallinverted",
              641,
              "Rsmallinvertedsuperior",
              694,
              "S",
              83,
              "SF010000",
              9484,
              "SF020000",
              9492,
              "SF030000",
              9488,
              "SF040000",
              9496,
              "SF050000",
              9532,
              "SF060000",
              9516,
              "SF070000",
              9524,
              "SF080000",
              9500,
              "SF090000",
              9508,
              "SF100000",
              9472,
              "SF110000",
              9474,
              "SF190000",
              9569,
              "SF200000",
              9570,
              "SF210000",
              9558,
              "SF220000",
              9557,
              "SF230000",
              9571,
              "SF240000",
              9553,
              "SF250000",
              9559,
              "SF260000",
              9565,
              "SF270000",
              9564,
              "SF280000",
              9563,
              "SF360000",
              9566,
              "SF370000",
              9567,
              "SF380000",
              9562,
              "SF390000",
              9556,
              "SF400000",
              9577,
              "SF410000",
              9574,
              "SF420000",
              9568,
              "SF430000",
              9552,
              "SF440000",
              9580,
              "SF450000",
              9575,
              "SF460000",
              9576,
              "SF470000",
              9572,
              "SF480000",
              9573,
              "SF490000",
              9561,
              "SF500000",
              9560,
              "SF510000",
              9554,
              "SF520000",
              9555,
              "SF530000",
              9579,
              "SF540000",
              9578,
              "Sacute",
              346,
              "Sacutedotaccent",
              7780,
              "Sampigreek",
              992,
              "Scaron",
              352,
              "Scarondotaccent",
              7782,
              "Scaronsmall",
              63229,
              "Scedilla",
              350,
              "Schwa",
              399,
              "Schwacyrillic",
              1240,
              "Schwadieresiscyrillic",
              1242,
              "Scircle",
              9416,
              "Scircumflex",
              348,
              "Scommaaccent",
              536,
              "Sdotaccent",
              7776,
              "Sdotbelow",
              7778,
              "Sdotbelowdotaccent",
              7784,
              "Seharmenian",
              1357,
              "Sevenroman",
              8550,
              "Shaarmenian",
              1351,
              "Shacyrillic",
              1064,
              "Shchacyrillic",
              1065,
              "Sheicoptic",
              994,
              "Shhacyrillic",
              1210,
              "Shimacoptic",
              1004,
              "Sigma",
              931,
              "Sixroman",
              8549,
              "Smonospace",
              65331,
              "Softsigncyrillic",
              1068,
              "Ssmall",
              63347,
              "Stigmagreek",
              986,
              "T",
              84,
              "Tau",
              932,
              "Tbar",
              358,
              "Tcaron",
              356,
              "Tcedilla",
              354,
              "Tcircle",
              9417,
              "Tcircumflexbelow",
              7792,
              "Tcommaaccent",
              354,
              "Tdotaccent",
              7786,
              "Tdotbelow",
              7788,
              "Tecyrillic",
              1058,
              "Tedescendercyrillic",
              1196,
              "Tenroman",
              8553,
              "Tetsecyrillic",
              1204,
              "Theta",
              920,
              "Thook",
              428,
              "Thorn",
              222,
              "Thornsmall",
              63486,
              "Threeroman",
              8546,
              "Tildesmall",
              63230,
              "Tiwnarmenian",
              1359,
              "Tlinebelow",
              7790,
              "Tmonospace",
              65332,
              "Toarmenian",
              1337,
              "Tonefive",
              444,
              "Tonesix",
              388,
              "Tonetwo",
              423,
              "Tretroflexhook",
              430,
              "Tsecyrillic",
              1062,
              "Tshecyrillic",
              1035,
              "Tsmall",
              63348,
              "Twelveroman",
              8555,
              "Tworoman",
              8545,
              "U",
              85,
              "Uacute",
              218,
              "Uacutesmall",
              63482,
              "Ubreve",
              364,
              "Ucaron",
              467,
              "Ucircle",
              9418,
              "Ucircumflex",
              219,
              "Ucircumflexbelow",
              7798,
              "Ucircumflexsmall",
              63483,
              "Ucyrillic",
              1059,
              "Udblacute",
              368,
              "Udblgrave",
              532,
              "Udieresis",
              220,
              "Udieresisacute",
              471,
              "Udieresisbelow",
              7794,
              "Udieresiscaron",
              473,
              "Udieresiscyrillic",
              1264,
              "Udieresisgrave",
              475,
              "Udieresismacron",
              469,
              "Udieresissmall",
              63484,
              "Udotbelow",
              7908,
              "Ugrave",
              217,
              "Ugravesmall",
              63481,
              "Uhookabove",
              7910,
              "Uhorn",
              431,
              "Uhornacute",
              7912,
              "Uhorndotbelow",
              7920,
              "Uhorngrave",
              7914,
              "Uhornhookabove",
              7916,
              "Uhorntilde",
              7918,
              "Uhungarumlaut",
              368,
              "Uhungarumlautcyrillic",
              1266,
              "Uinvertedbreve",
              534,
              "Ukcyrillic",
              1144,
              "Umacron",
              362,
              "Umacroncyrillic",
              1262,
              "Umacrondieresis",
              7802,
              "Umonospace",
              65333,
              "Uogonek",
              370,
              "Upsilon",
              933,
              "Upsilon1",
              978,
              "Upsilonacutehooksymbolgreek",
              979,
              "Upsilonafrican",
              433,
              "Upsilondieresis",
              939,
              "Upsilondieresishooksymbolgreek",
              980,
              "Upsilonhooksymbol",
              978,
              "Upsilontonos",
              910,
              "Uring",
              366,
              "Ushortcyrillic",
              1038,
              "Usmall",
              63349,
              "Ustraightcyrillic",
              1198,
              "Ustraightstrokecyrillic",
              1200,
              "Utilde",
              360,
              "Utildeacute",
              7800,
              "Utildebelow",
              7796,
              "V",
              86,
              "Vcircle",
              9419,
              "Vdotbelow",
              7806,
              "Vecyrillic",
              1042,
              "Vewarmenian",
              1358,
              "Vhook",
              434,
              "Vmonospace",
              65334,
              "Voarmenian",
              1352,
              "Vsmall",
              63350,
              "Vtilde",
              7804,
              "W",
              87,
              "Wacute",
              7810,
              "Wcircle",
              9420,
              "Wcircumflex",
              372,
              "Wdieresis",
              7812,
              "Wdotaccent",
              7814,
              "Wdotbelow",
              7816,
              "Wgrave",
              7808,
              "Wmonospace",
              65335,
              "Wsmall",
              63351,
              "X",
              88,
              "Xcircle",
              9421,
              "Xdieresis",
              7820,
              "Xdotaccent",
              7818,
              "Xeharmenian",
              1341,
              "Xi",
              926,
              "Xmonospace",
              65336,
              "Xsmall",
              63352,
              "Y",
              89,
              "Yacute",
              221,
              "Yacutesmall",
              63485,
              "Yatcyrillic",
              1122,
              "Ycircle",
              9422,
              "Ycircumflex",
              374,
              "Ydieresis",
              376,
              "Ydieresissmall",
              63487,
              "Ydotaccent",
              7822,
              "Ydotbelow",
              7924,
              "Yericyrillic",
              1067,
              "Yerudieresiscyrillic",
              1272,
              "Ygrave",
              7922,
              "Yhook",
              435,
              "Yhookabove",
              7926,
              "Yiarmenian",
              1349,
              "Yicyrillic",
              1031,
              "Yiwnarmenian",
              1362,
              "Ymonospace",
              65337,
              "Ysmall",
              63353,
              "Ytilde",
              7928,
              "Yusbigcyrillic",
              1130,
              "Yusbigiotifiedcyrillic",
              1132,
              "Yuslittlecyrillic",
              1126,
              "Yuslittleiotifiedcyrillic",
              1128,
              "Z",
              90,
              "Zaarmenian",
              1334,
              "Zacute",
              377,
              "Zcaron",
              381,
              "Zcaronsmall",
              63231,
              "Zcircle",
              9423,
              "Zcircumflex",
              7824,
              "Zdot",
              379,
              "Zdotaccent",
              379,
              "Zdotbelow",
              7826,
              "Zecyrillic",
              1047,
              "Zedescendercyrillic",
              1176,
              "Zedieresiscyrillic",
              1246,
              "Zeta",
              918,
              "Zhearmenian",
              1338,
              "Zhebrevecyrillic",
              1217,
              "Zhecyrillic",
              1046,
              "Zhedescendercyrillic",
              1174,
              "Zhedieresiscyrillic",
              1244,
              "Zlinebelow",
              7828,
              "Zmonospace",
              65338,
              "Zsmall",
              63354,
              "Zstroke",
              437,
              "a",
              97,
              "aabengali",
              2438,
              "aacute",
              225,
              "aadeva",
              2310,
              "aagujarati",
              2694,
              "aagurmukhi",
              2566,
              "aamatragurmukhi",
              2622,
              "aarusquare",
              13059,
              "aavowelsignbengali",
              2494,
              "aavowelsigndeva",
              2366,
              "aavowelsigngujarati",
              2750,
              "abbreviationmarkarmenian",
              1375,
              "abbreviationsigndeva",
              2416,
              "abengali",
              2437,
              "abopomofo",
              12570,
              "abreve",
              259,
              "abreveacute",
              7855,
              "abrevecyrillic",
              1233,
              "abrevedotbelow",
              7863,
              "abrevegrave",
              7857,
              "abrevehookabove",
              7859,
              "abrevetilde",
              7861,
              "acaron",
              462,
              "acircle",
              9424,
              "acircumflex",
              226,
              "acircumflexacute",
              7845,
              "acircumflexdotbelow",
              7853,
              "acircumflexgrave",
              7847,
              "acircumflexhookabove",
              7849,
              "acircumflextilde",
              7851,
              "acute",
              180,
              "acutebelowcmb",
              791,
              "acutecmb",
              769,
              "acutecomb",
              769,
              "acutedeva",
              2388,
              "acutelowmod",
              719,
              "acutetonecmb",
              833,
              "acyrillic",
              1072,
              "adblgrave",
              513,
              "addakgurmukhi",
              2673,
              "adeva",
              2309,
              "adieresis",
              228,
              "adieresiscyrillic",
              1235,
              "adieresismacron",
              479,
              "adotbelow",
              7841,
              "adotmacron",
              481,
              "ae",
              230,
              "aeacute",
              509,
              "aekorean",
              12624,
              "aemacron",
              483,
              "afii00208",
              8213,
              "afii08941",
              8356,
              "afii10017",
              1040,
              "afii10018",
              1041,
              "afii10019",
              1042,
              "afii10020",
              1043,
              "afii10021",
              1044,
              "afii10022",
              1045,
              "afii10023",
              1025,
              "afii10024",
              1046,
              "afii10025",
              1047,
              "afii10026",
              1048,
              "afii10027",
              1049,
              "afii10028",
              1050,
              "afii10029",
              1051,
              "afii10030",
              1052,
              "afii10031",
              1053,
              "afii10032",
              1054,
              "afii10033",
              1055,
              "afii10034",
              1056,
              "afii10035",
              1057,
              "afii10036",
              1058,
              "afii10037",
              1059,
              "afii10038",
              1060,
              "afii10039",
              1061,
              "afii10040",
              1062,
              "afii10041",
              1063,
              "afii10042",
              1064,
              "afii10043",
              1065,
              "afii10044",
              1066,
              "afii10045",
              1067,
              "afii10046",
              1068,
              "afii10047",
              1069,
              "afii10048",
              1070,
              "afii10049",
              1071,
              "afii10050",
              1168,
              "afii10051",
              1026,
              "afii10052",
              1027,
              "afii10053",
              1028,
              "afii10054",
              1029,
              "afii10055",
              1030,
              "afii10056",
              1031,
              "afii10057",
              1032,
              "afii10058",
              1033,
              "afii10059",
              1034,
              "afii10060",
              1035,
              "afii10061",
              1036,
              "afii10062",
              1038,
              "afii10063",
              63172,
              "afii10064",
              63173,
              "afii10065",
              1072,
              "afii10066",
              1073,
              "afii10067",
              1074,
              "afii10068",
              1075,
              "afii10069",
              1076,
              "afii10070",
              1077,
              "afii10071",
              1105,
              "afii10072",
              1078,
              "afii10073",
              1079,
              "afii10074",
              1080,
              "afii10075",
              1081,
              "afii10076",
              1082,
              "afii10077",
              1083,
              "afii10078",
              1084,
              "afii10079",
              1085,
              "afii10080",
              1086,
              "afii10081",
              1087,
              "afii10082",
              1088,
              "afii10083",
              1089,
              "afii10084",
              1090,
              "afii10085",
              1091,
              "afii10086",
              1092,
              "afii10087",
              1093,
              "afii10088",
              1094,
              "afii10089",
              1095,
              "afii10090",
              1096,
              "afii10091",
              1097,
              "afii10092",
              1098,
              "afii10093",
              1099,
              "afii10094",
              1100,
              "afii10095",
              1101,
              "afii10096",
              1102,
              "afii10097",
              1103,
              "afii10098",
              1169,
              "afii10099",
              1106,
              "afii10100",
              1107,
              "afii10101",
              1108,
              "afii10102",
              1109,
              "afii10103",
              1110,
              "afii10104",
              1111,
              "afii10105",
              1112,
              "afii10106",
              1113,
              "afii10107",
              1114,
              "afii10108",
              1115,
              "afii10109",
              1116,
              "afii10110",
              1118,
              "afii10145",
              1039,
              "afii10146",
              1122,
              "afii10147",
              1138,
              "afii10148",
              1140,
              "afii10192",
              63174,
              "afii10193",
              1119,
              "afii10194",
              1123,
              "afii10195",
              1139,
              "afii10196",
              1141,
              "afii10831",
              63175,
              "afii10832",
              63176,
              "afii10846",
              1241,
              "afii299",
              8206,
              "afii300",
              8207,
              "afii301",
              8205,
              "afii57381",
              1642,
              "afii57388",
              1548,
              "afii57392",
              1632,
              "afii57393",
              1633,
              "afii57394",
              1634,
              "afii57395",
              1635,
              "afii57396",
              1636,
              "afii57397",
              1637,
              "afii57398",
              1638,
              "afii57399",
              1639,
              "afii57400",
              1640,
              "afii57401",
              1641,
              "afii57403",
              1563,
              "afii57407",
              1567,
              "afii57409",
              1569,
              "afii57410",
              1570,
              "afii57411",
              1571,
              "afii57412",
              1572,
              "afii57413",
              1573,
              "afii57414",
              1574,
              "afii57415",
              1575,
              "afii57416",
              1576,
              "afii57417",
              1577,
              "afii57418",
              1578,
              "afii57419",
              1579,
              "afii57420",
              1580,
              "afii57421",
              1581,
              "afii57422",
              1582,
              "afii57423",
              1583,
              "afii57424",
              1584,
              "afii57425",
              1585,
              "afii57426",
              1586,
              "afii57427",
              1587,
              "afii57428",
              1588,
              "afii57429",
              1589,
              "afii57430",
              1590,
              "afii57431",
              1591,
              "afii57432",
              1592,
              "afii57433",
              1593,
              "afii57434",
              1594,
              "afii57440",
              1600,
              "afii57441",
              1601,
              "afii57442",
              1602,
              "afii57443",
              1603,
              "afii57444",
              1604,
              "afii57445",
              1605,
              "afii57446",
              1606,
              "afii57448",
              1608,
              "afii57449",
              1609,
              "afii57450",
              1610,
              "afii57451",
              1611,
              "afii57452",
              1612,
              "afii57453",
              1613,
              "afii57454",
              1614,
              "afii57455",
              1615,
              "afii57456",
              1616,
              "afii57457",
              1617,
              "afii57458",
              1618,
              "afii57470",
              1607,
              "afii57505",
              1700,
              "afii57506",
              1662,
              "afii57507",
              1670,
              "afii57508",
              1688,
              "afii57509",
              1711,
              "afii57511",
              1657,
              "afii57512",
              1672,
              "afii57513",
              1681,
              "afii57514",
              1722,
              "afii57519",
              1746,
              "afii57534",
              1749,
              "afii57636",
              8362,
              "afii57645",
              1470,
              "afii57658",
              1475,
              "afii57664",
              1488,
              "afii57665",
              1489,
              "afii57666",
              1490,
              "afii57667",
              1491,
              "afii57668",
              1492,
              "afii57669",
              1493,
              "afii57670",
              1494,
              "afii57671",
              1495,
              "afii57672",
              1496,
              "afii57673",
              1497,
              "afii57674",
              1498,
              "afii57675",
              1499,
              "afii57676",
              1500,
              "afii57677",
              1501,
              "afii57678",
              1502,
              "afii57679",
              1503,
              "afii57680",
              1504,
              "afii57681",
              1505,
              "afii57682",
              1506,
              "afii57683",
              1507,
              "afii57684",
              1508,
              "afii57685",
              1509,
              "afii57686",
              1510,
              "afii57687",
              1511,
              "afii57688",
              1512,
              "afii57689",
              1513,
              "afii57690",
              1514,
              "afii57694",
              64298,
              "afii57695",
              64299,
              "afii57700",
              64331,
              "afii57705",
              64287,
              "afii57716",
              1520,
              "afii57717",
              1521,
              "afii57718",
              1522,
              "afii57723",
              64309,
              "afii57793",
              1460,
              "afii57794",
              1461,
              "afii57795",
              1462,
              "afii57796",
              1467,
              "afii57797",
              1464,
              "afii57798",
              1463,
              "afii57799",
              1456,
              "afii57800",
              1458,
              "afii57801",
              1457,
              "afii57802",
              1459,
              "afii57803",
              1474,
              "afii57804",
              1473,
              "afii57806",
              1465,
              "afii57807",
              1468,
              "afii57839",
              1469,
              "afii57841",
              1471,
              "afii57842",
              1472,
              "afii57929",
              700,
              "afii61248",
              8453,
              "afii61289",
              8467,
              "afii61352",
              8470,
              "afii61573",
              8236,
              "afii61574",
              8237,
              "afii61575",
              8238,
              "afii61664",
              8204,
              "afii63167",
              1645,
              "afii64937",
              701,
              "agrave",
              224,
              "agujarati",
              2693,
              "agurmukhi",
              2565,
              "ahiragana",
              12354,
              "ahookabove",
              7843,
              "aibengali",
              2448,
              "aibopomofo",
              12574,
              "aideva",
              2320,
              "aiecyrillic",
              1237,
              "aigujarati",
              2704,
              "aigurmukhi",
              2576,
              "aimatragurmukhi",
              2632,
              "ainarabic",
              1593,
              "ainfinalarabic",
              65226,
              "aininitialarabic",
              65227,
              "ainmedialarabic",
              65228,
              "ainvertedbreve",
              515,
              "aivowelsignbengali",
              2504,
              "aivowelsigndeva",
              2376,
              "aivowelsigngujarati",
              2760,
              "akatakana",
              12450,
              "akatakanahalfwidth",
              65393,
              "akorean",
              12623,
              "alef",
              1488,
              "alefarabic",
              1575,
              "alefdageshhebrew",
              64304,
              "aleffinalarabic",
              65166,
              "alefhamzaabovearabic",
              1571,
              "alefhamzaabovefinalarabic",
              65156,
              "alefhamzabelowarabic",
              1573,
              "alefhamzabelowfinalarabic",
              65160,
              "alefhebrew",
              1488,
              "aleflamedhebrew",
              64335,
              "alefmaddaabovearabic",
              1570,
              "alefmaddaabovefinalarabic",
              65154,
              "alefmaksuraarabic",
              1609,
              "alefmaksurafinalarabic",
              65264,
              "alefmaksurainitialarabic",
              65267,
              "alefmaksuramedialarabic",
              65268,
              "alefpatahhebrew",
              64302,
              "alefqamatshebrew",
              64303,
              "aleph",
              8501,
              "allequal",
              8780,
              "alpha",
              945,
              "alphatonos",
              940,
              "amacron",
              257,
              "amonospace",
              65345,
              "ampersand",
              38,
              "ampersandmonospace",
              65286,
              "ampersandsmall",
              63270,
              "amsquare",
              13250,
              "anbopomofo",
              12578,
              "angbopomofo",
              12580,
              "angbracketleft",
              12296,
              "angbracketright",
              12297,
              "angkhankhuthai",
              3674,
              "angle",
              8736,
              "anglebracketleft",
              12296,
              "anglebracketleftvertical",
              65087,
              "anglebracketright",
              12297,
              "anglebracketrightvertical",
              65088,
              "angleleft",
              9001,
              "angleright",
              9002,
              "angstrom",
              8491,
              "anoteleia",
              903,
              "anudattadeva",
              2386,
              "anusvarabengali",
              2434,
              "anusvaradeva",
              2306,
              "anusvaragujarati",
              2690,
              "aogonek",
              261,
              "apaatosquare",
              13056,
              "aparen",
              9372,
              "apostrophearmenian",
              1370,
              "apostrophemod",
              700,
              "apple",
              63743,
              "approaches",
              8784,
              "approxequal",
              8776,
              "approxequalorimage",
              8786,
              "approximatelyequal",
              8773,
              "araeaekorean",
              12686,
              "araeakorean",
              12685,
              "arc",
              8978,
              "arighthalfring",
              7834,
              "aring",
              229,
              "aringacute",
              507,
              "aringbelow",
              7681,
              "arrowboth",
              8596,
              "arrowdashdown",
              8675,
              "arrowdashleft",
              8672,
              "arrowdashright",
              8674,
              "arrowdashup",
              8673,
              "arrowdblboth",
              8660,
              "arrowdbldown",
              8659,
              "arrowdblleft",
              8656,
              "arrowdblright",
              8658,
              "arrowdblup",
              8657,
              "arrowdown",
              8595,
              "arrowdownleft",
              8601,
              "arrowdownright",
              8600,
              "arrowdownwhite",
              8681,
              "arrowheaddownmod",
              709,
              "arrowheadleftmod",
              706,
              "arrowheadrightmod",
              707,
              "arrowheadupmod",
              708,
              "arrowhorizex",
              63719,
              "arrowleft",
              8592,
              "arrowleftdbl",
              8656,
              "arrowleftdblstroke",
              8653,
              "arrowleftoverright",
              8646,
              "arrowleftwhite",
              8678,
              "arrowright",
              8594,
              "arrowrightdblstroke",
              8655,
              "arrowrightheavy",
              10142,
              "arrowrightoverleft",
              8644,
              "arrowrightwhite",
              8680,
              "arrowtableft",
              8676,
              "arrowtabright",
              8677,
              "arrowup",
              8593,
              "arrowupdn",
              8597,
              "arrowupdnbse",
              8616,
              "arrowupdownbase",
              8616,
              "arrowupleft",
              8598,
              "arrowupleftofdown",
              8645,
              "arrowupright",
              8599,
              "arrowupwhite",
              8679,
              "arrowvertex",
              63718,
              "asciicircum",
              94,
              "asciicircummonospace",
              65342,
              "asciitilde",
              126,
              "asciitildemonospace",
              65374,
              "ascript",
              593,
              "ascriptturned",
              594,
              "asmallhiragana",
              12353,
              "asmallkatakana",
              12449,
              "asmallkatakanahalfwidth",
              65383,
              "asterisk",
              42,
              "asteriskaltonearabic",
              1645,
              "asteriskarabic",
              1645,
              "asteriskmath",
              8727,
              "asteriskmonospace",
              65290,
              "asterisksmall",
              65121,
              "asterism",
              8258,
              "asuperior",
              63209,
              "asymptoticallyequal",
              8771,
              "at",
              64,
              "atilde",
              227,
              "atmonospace",
              65312,
              "atsmall",
              65131,
              "aturned",
              592,
              "aubengali",
              2452,
              "aubopomofo",
              12576,
              "audeva",
              2324,
              "augujarati",
              2708,
              "augurmukhi",
              2580,
              "aulengthmarkbengali",
              2519,
              "aumatragurmukhi",
              2636,
              "auvowelsignbengali",
              2508,
              "auvowelsigndeva",
              2380,
              "auvowelsigngujarati",
              2764,
              "avagrahadeva",
              2365,
              "aybarmenian",
              1377,
              "ayin",
              1506,
              "ayinaltonehebrew",
              64288,
              "ayinhebrew",
              1506,
              "b",
              98,
              "babengali",
              2476,
              "backslash",
              92,
              "backslashmonospace",
              65340,
              "badeva",
              2348,
              "bagujarati",
              2732,
              "bagurmukhi",
              2604,
              "bahiragana",
              12400,
              "bahtthai",
              3647,
              "bakatakana",
              12496,
              "bar",
              124,
              "barmonospace",
              65372,
              "bbopomofo",
              12549,
              "bcircle",
              9425,
              "bdotaccent",
              7683,
              "bdotbelow",
              7685,
              "beamedsixteenthnotes",
              9836,
              "because",
              8757,
              "becyrillic",
              1073,
              "beharabic",
              1576,
              "behfinalarabic",
              65168,
              "behinitialarabic",
              65169,
              "behiragana",
              12409,
              "behmedialarabic",
              65170,
              "behmeeminitialarabic",
              64671,
              "behmeemisolatedarabic",
              64520,
              "behnoonfinalarabic",
              64621,
              "bekatakana",
              12505,
              "benarmenian",
              1378,
              "bet",
              1489,
              "beta",
              946,
              "betasymbolgreek",
              976,
              "betdagesh",
              64305,
              "betdageshhebrew",
              64305,
              "bethebrew",
              1489,
              "betrafehebrew",
              64332,
              "bhabengali",
              2477,
              "bhadeva",
              2349,
              "bhagujarati",
              2733,
              "bhagurmukhi",
              2605,
              "bhook",
              595,
              "bihiragana",
              12403,
              "bikatakana",
              12499,
              "bilabialclick",
              664,
              "bindigurmukhi",
              2562,
              "birusquare",
              13105,
              "blackcircle",
              9679,
              "blackdiamond",
              9670,
              "blackdownpointingtriangle",
              9660,
              "blackleftpointingpointer",
              9668,
              "blackleftpointingtriangle",
              9664,
              "blacklenticularbracketleft",
              12304,
              "blacklenticularbracketleftvertical",
              65083,
              "blacklenticularbracketright",
              12305,
              "blacklenticularbracketrightvertical",
              65084,
              "blacklowerlefttriangle",
              9699,
              "blacklowerrighttriangle",
              9698,
              "blackrectangle",
              9644,
              "blackrightpointingpointer",
              9658,
              "blackrightpointingtriangle",
              9654,
              "blacksmallsquare",
              9642,
              "blacksmilingface",
              9787,
              "blacksquare",
              9632,
              "blackstar",
              9733,
              "blackupperlefttriangle",
              9700,
              "blackupperrighttriangle",
              9701,
              "blackuppointingsmalltriangle",
              9652,
              "blackuppointingtriangle",
              9650,
              "blank",
              9251,
              "blinebelow",
              7687,
              "block",
              9608,
              "bmonospace",
              65346,
              "bobaimaithai",
              3610,
              "bohiragana",
              12412,
              "bokatakana",
              12508,
              "bparen",
              9373,
              "bqsquare",
              13251,
              "braceex",
              63732,
              "braceleft",
              123,
              "braceleftbt",
              63731,
              "braceleftmid",
              63730,
              "braceleftmonospace",
              65371,
              "braceleftsmall",
              65115,
              "bracelefttp",
              63729,
              "braceleftvertical",
              65079,
              "braceright",
              125,
              "bracerightbt",
              63742,
              "bracerightmid",
              63741,
              "bracerightmonospace",
              65373,
              "bracerightsmall",
              65116,
              "bracerighttp",
              63740,
              "bracerightvertical",
              65080,
              "bracketleft",
              91,
              "bracketleftbt",
              63728,
              "bracketleftex",
              63727,
              "bracketleftmonospace",
              65339,
              "bracketlefttp",
              63726,
              "bracketright",
              93,
              "bracketrightbt",
              63739,
              "bracketrightex",
              63738,
              "bracketrightmonospace",
              65341,
              "bracketrighttp",
              63737,
              "breve",
              728,
              "brevebelowcmb",
              814,
              "brevecmb",
              774,
              "breveinvertedbelowcmb",
              815,
              "breveinvertedcmb",
              785,
              "breveinverteddoublecmb",
              865,
              "bridgebelowcmb",
              810,
              "bridgeinvertedbelowcmb",
              826,
              "brokenbar",
              166,
              "bstroke",
              384,
              "bsuperior",
              63210,
              "btopbar",
              387,
              "buhiragana",
              12406,
              "bukatakana",
              12502,
              "bullet",
              8226,
              "bulletinverse",
              9688,
              "bulletoperator",
              8729,
              "bullseye",
              9678,
              "c",
              99,
              "caarmenian",
              1390,
              "cabengali",
              2458,
              "cacute",
              263,
              "cadeva",
              2330,
              "cagujarati",
              2714,
              "cagurmukhi",
              2586,
              "calsquare",
              13192,
              "candrabindubengali",
              2433,
              "candrabinducmb",
              784,
              "candrabindudeva",
              2305,
              "candrabindugujarati",
              2689,
              "capslock",
              8682,
              "careof",
              8453,
              "caron",
              711,
              "caronbelowcmb",
              812,
              "caroncmb",
              780,
              "carriagereturn",
              8629,
              "cbopomofo",
              12568,
              "ccaron",
              269,
              "ccedilla",
              231,
              "ccedillaacute",
              7689,
              "ccircle",
              9426,
              "ccircumflex",
              265,
              "ccurl",
              597,
              "cdot",
              267,
              "cdotaccent",
              267,
              "cdsquare",
              13253,
              "cedilla",
              184,
              "cedillacmb",
              807,
              "cent",
              162,
              "centigrade",
              8451,
              "centinferior",
              63199,
              "centmonospace",
              65504,
              "centoldstyle",
              63394,
              "centsuperior",
              63200,
              "chaarmenian",
              1401,
              "chabengali",
              2459,
              "chadeva",
              2331,
              "chagujarati",
              2715,
              "chagurmukhi",
              2587,
              "chbopomofo",
              12564,
              "cheabkhasiancyrillic",
              1213,
              "checkmark",
              10003,
              "checyrillic",
              1095,
              "chedescenderabkhasiancyrillic",
              1215,
              "chedescendercyrillic",
              1207,
              "chedieresiscyrillic",
              1269,
              "cheharmenian",
              1395,
              "chekhakassiancyrillic",
              1228,
              "cheverticalstrokecyrillic",
              1209,
              "chi",
              967,
              "chieuchacirclekorean",
              12919,
              "chieuchaparenkorean",
              12823,
              "chieuchcirclekorean",
              12905,
              "chieuchkorean",
              12618,
              "chieuchparenkorean",
              12809,
              "chochangthai",
              3594,
              "chochanthai",
              3592,
              "chochingthai",
              3593,
              "chochoethai",
              3596,
              "chook",
              392,
              "cieucacirclekorean",
              12918,
              "cieucaparenkorean",
              12822,
              "cieuccirclekorean",
              12904,
              "cieuckorean",
              12616,
              "cieucparenkorean",
              12808,
              "cieucuparenkorean",
              12828,
              "circle",
              9675,
              "circlecopyrt",
              169,
              "circlemultiply",
              8855,
              "circleot",
              8857,
              "circleplus",
              8853,
              "circlepostalmark",
              12342,
              "circlewithlefthalfblack",
              9680,
              "circlewithrighthalfblack",
              9681,
              "circumflex",
              710,
              "circumflexbelowcmb",
              813,
              "circumflexcmb",
              770,
              "clear",
              8999,
              "clickalveolar",
              450,
              "clickdental",
              448,
              "clicklateral",
              449,
              "clickretroflex",
              451,
              "club",
              9827,
              "clubsuitblack",
              9827,
              "clubsuitwhite",
              9831,
              "cmcubedsquare",
              13220,
              "cmonospace",
              65347,
              "cmsquaredsquare",
              13216,
              "coarmenian",
              1409,
              "colon",
              58,
              "colonmonetary",
              8353,
              "colonmonospace",
              65306,
              "colonsign",
              8353,
              "colonsmall",
              65109,
              "colontriangularhalfmod",
              721,
              "colontriangularmod",
              720,
              "comma",
              44,
              "commaabovecmb",
              787,
              "commaaboverightcmb",
              789,
              "commaaccent",
              63171,
              "commaarabic",
              1548,
              "commaarmenian",
              1373,
              "commainferior",
              63201,
              "commamonospace",
              65292,
              "commareversedabovecmb",
              788,
              "commareversedmod",
              701,
              "commasmall",
              65104,
              "commasuperior",
              63202,
              "commaturnedabovecmb",
              786,
              "commaturnedmod",
              699,
              "compass",
              9788,
              "congruent",
              8773,
              "contourintegral",
              8750,
              "control",
              8963,
              "controlACK",
              6,
              "controlBEL",
              7,
              "controlBS",
              8,
              "controlCAN",
              24,
              "controlCR",
              13,
              "controlDC1",
              17,
              "controlDC2",
              18,
              "controlDC3",
              19,
              "controlDC4",
              20,
              "controlDEL",
              127,
              "controlDLE",
              16,
              "controlEM",
              25,
              "controlENQ",
              5,
              "controlEOT",
              4,
              "controlESC",
              27,
              "controlETB",
              23,
              "controlETX",
              3,
              "controlFF",
              12,
              "controlFS",
              28,
              "controlGS",
              29,
              "controlHT",
              9,
              "controlLF",
              10,
              "controlNAK",
              21,
              "controlNULL",
              0,
              "controlRS",
              30,
              "controlSI",
              15,
              "controlSO",
              14,
              "controlSOT",
              2,
              "controlSTX",
              1,
              "controlSUB",
              26,
              "controlSYN",
              22,
              "controlUS",
              31,
              "controlVT",
              11,
              "copyright",
              169,
              "copyrightsans",
              63721,
              "copyrightserif",
              63193,
              "cornerbracketleft",
              12300,
              "cornerbracketlefthalfwidth",
              65378,
              "cornerbracketleftvertical",
              65089,
              "cornerbracketright",
              12301,
              "cornerbracketrighthalfwidth",
              65379,
              "cornerbracketrightvertical",
              65090,
              "corporationsquare",
              13183,
              "cosquare",
              13255,
              "coverkgsquare",
              13254,
              "cparen",
              9374,
              "cruzeiro",
              8354,
              "cstretched",
              663,
              "curlyand",
              8911,
              "curlyor",
              8910,
              "currency",
              164,
              "cyrBreve",
              63185,
              "cyrFlex",
              63186,
              "cyrbreve",
              63188,
              "cyrflex",
              63189,
              "d",
              100,
              "daarmenian",
              1380,
              "dabengali",
              2470,
              "dadarabic",
              1590,
              "dadeva",
              2342,
              "dadfinalarabic",
              65214,
              "dadinitialarabic",
              65215,
              "dadmedialarabic",
              65216,
              "dagesh",
              1468,
              "dageshhebrew",
              1468,
              "dagger",
              8224,
              "daggerdbl",
              8225,
              "dagujarati",
              2726,
              "dagurmukhi",
              2598,
              "dahiragana",
              12384,
              "dakatakana",
              12480,
              "dalarabic",
              1583,
              "dalet",
              1491,
              "daletdagesh",
              64307,
              "daletdageshhebrew",
              64307,
              "dalethebrew",
              1491,
              "dalfinalarabic",
              65194,
              "dammaarabic",
              1615,
              "dammalowarabic",
              1615,
              "dammatanaltonearabic",
              1612,
              "dammatanarabic",
              1612,
              "danda",
              2404,
              "dargahebrew",
              1447,
              "dargalefthebrew",
              1447,
              "dasiapneumatacyrilliccmb",
              1157,
              "dblGrave",
              63187,
              "dblanglebracketleft",
              12298,
              "dblanglebracketleftvertical",
              65085,
              "dblanglebracketright",
              12299,
              "dblanglebracketrightvertical",
              65086,
              "dblarchinvertedbelowcmb",
              811,
              "dblarrowleft",
              8660,
              "dblarrowright",
              8658,
              "dbldanda",
              2405,
              "dblgrave",
              63190,
              "dblgravecmb",
              783,
              "dblintegral",
              8748,
              "dbllowline",
              8215,
              "dbllowlinecmb",
              819,
              "dbloverlinecmb",
              831,
              "dblprimemod",
              698,
              "dblverticalbar",
              8214,
              "dblverticallineabovecmb",
              782,
              "dbopomofo",
              12553,
              "dbsquare",
              13256,
              "dcaron",
              271,
              "dcedilla",
              7697,
              "dcircle",
              9427,
              "dcircumflexbelow",
              7699,
              "dcroat",
              273,
              "ddabengali",
              2465,
              "ddadeva",
              2337,
              "ddagujarati",
              2721,
              "ddagurmukhi",
              2593,
              "ddalarabic",
              1672,
              "ddalfinalarabic",
              64393,
              "dddhadeva",
              2396,
              "ddhabengali",
              2466,
              "ddhadeva",
              2338,
              "ddhagujarati",
              2722,
              "ddhagurmukhi",
              2594,
              "ddotaccent",
              7691,
              "ddotbelow",
              7693,
              "decimalseparatorarabic",
              1643,
              "decimalseparatorpersian",
              1643,
              "decyrillic",
              1076,
              "degree",
              176,
              "dehihebrew",
              1453,
              "dehiragana",
              12391,
              "deicoptic",
              1007,
              "dekatakana",
              12487,
              "deleteleft",
              9003,
              "deleteright",
              8998,
              "delta",
              948,
              "deltaturned",
              397,
              "denominatorminusonenumeratorbengali",
              2552,
              "dezh",
              676,
              "dhabengali",
              2471,
              "dhadeva",
              2343,
              "dhagujarati",
              2727,
              "dhagurmukhi",
              2599,
              "dhook",
              599,
              "dialytikatonos",
              901,
              "dialytikatonoscmb",
              836,
              "diamond",
              9830,
              "diamondsuitwhite",
              9826,
              "dieresis",
              168,
              "dieresisacute",
              63191,
              "dieresisbelowcmb",
              804,
              "dieresiscmb",
              776,
              "dieresisgrave",
              63192,
              "dieresistonos",
              901,
              "dihiragana",
              12386,
              "dikatakana",
              12482,
              "dittomark",
              12291,
              "divide",
              247,
              "divides",
              8739,
              "divisionslash",
              8725,
              "djecyrillic",
              1106,
              "dkshade",
              9619,
              "dlinebelow",
              7695,
              "dlsquare",
              13207,
              "dmacron",
              273,
              "dmonospace",
              65348,
              "dnblock",
              9604,
              "dochadathai",
              3598,
              "dodekthai",
              3604,
              "dohiragana",
              12393,
              "dokatakana",
              12489,
              "dollar",
              36,
              "dollarinferior",
              63203,
              "dollarmonospace",
              65284,
              "dollaroldstyle",
              63268,
              "dollarsmall",
              65129,
              "dollarsuperior",
              63204,
              "dong",
              8363,
              "dorusquare",
              13094,
              "dotaccent",
              729,
              "dotaccentcmb",
              775,
              "dotbelowcmb",
              803,
              "dotbelowcomb",
              803,
              "dotkatakana",
              12539,
              "dotlessi",
              305,
              "dotlessj",
              63166,
              "dotlessjstrokehook",
              644,
              "dotmath",
              8901,
              "dottedcircle",
              9676,
              "doubleyodpatah",
              64287,
              "doubleyodpatahhebrew",
              64287,
              "downtackbelowcmb",
              798,
              "downtackmod",
              725,
              "dparen",
              9375,
              "dsuperior",
              63211,
              "dtail",
              598,
              "dtopbar",
              396,
              "duhiragana",
              12389,
              "dukatakana",
              12485,
              "dz",
              499,
              "dzaltone",
              675,
              "dzcaron",
              454,
              "dzcurl",
              677,
              "dzeabkhasiancyrillic",
              1249,
              "dzecyrillic",
              1109,
              "dzhecyrillic",
              1119,
              "e",
              101,
              "eacute",
              233,
              "earth",
              9793,
              "ebengali",
              2447,
              "ebopomofo",
              12572,
              "ebreve",
              277,
              "ecandradeva",
              2317,
              "ecandragujarati",
              2701,
              "ecandravowelsigndeva",
              2373,
              "ecandravowelsigngujarati",
              2757,
              "ecaron",
              283,
              "ecedillabreve",
              7709,
              "echarmenian",
              1381,
              "echyiwnarmenian",
              1415,
              "ecircle",
              9428,
              "ecircumflex",
              234,
              "ecircumflexacute",
              7871,
              "ecircumflexbelow",
              7705,
              "ecircumflexdotbelow",
              7879,
              "ecircumflexgrave",
              7873,
              "ecircumflexhookabove",
              7875,
              "ecircumflextilde",
              7877,
              "ecyrillic",
              1108,
              "edblgrave",
              517,
              "edeva",
              2319,
              "edieresis",
              235,
              "edot",
              279,
              "edotaccent",
              279,
              "edotbelow",
              7865,
              "eegurmukhi",
              2575,
              "eematragurmukhi",
              2631,
              "efcyrillic",
              1092,
              "egrave",
              232,
              "egujarati",
              2703,
              "eharmenian",
              1383,
              "ehbopomofo",
              12573,
              "ehiragana",
              12360,
              "ehookabove",
              7867,
              "eibopomofo",
              12575,
              "eight",
              56,
              "eightarabic",
              1640,
              "eightbengali",
              2542,
              "eightcircle",
              9319,
              "eightcircleinversesansserif",
              10129,
              "eightdeva",
              2414,
              "eighteencircle",
              9329,
              "eighteenparen",
              9349,
              "eighteenperiod",
              9369,
              "eightgujarati",
              2798,
              "eightgurmukhi",
              2670,
              "eighthackarabic",
              1640,
              "eighthangzhou",
              12328,
              "eighthnotebeamed",
              9835,
              "eightideographicparen",
              12839,
              "eightinferior",
              8328,
              "eightmonospace",
              65304,
              "eightoldstyle",
              63288,
              "eightparen",
              9339,
              "eightperiod",
              9359,
              "eightpersian",
              1784,
              "eightroman",
              8567,
              "eightsuperior",
              8312,
              "eightthai",
              3672,
              "einvertedbreve",
              519,
              "eiotifiedcyrillic",
              1125,
              "ekatakana",
              12456,
              "ekatakanahalfwidth",
              65396,
              "ekonkargurmukhi",
              2676,
              "ekorean",
              12628,
              "elcyrillic",
              1083,
              "element",
              8712,
              "elevencircle",
              9322,
              "elevenparen",
              9342,
              "elevenperiod",
              9362,
              "elevenroman",
              8570,
              "ellipsis",
              8230,
              "ellipsisvertical",
              8942,
              "emacron",
              275,
              "emacronacute",
              7703,
              "emacrongrave",
              7701,
              "emcyrillic",
              1084,
              "emdash",
              8212,
              "emdashvertical",
              65073,
              "emonospace",
              65349,
              "emphasismarkarmenian",
              1371,
              "emptyset",
              8709,
              "enbopomofo",
              12579,
              "encyrillic",
              1085,
              "endash",
              8211,
              "endashvertical",
              65074,
              "endescendercyrillic",
              1187,
              "eng",
              331,
              "engbopomofo",
              12581,
              "enghecyrillic",
              1189,
              "enhookcyrillic",
              1224,
              "enspace",
              8194,
              "eogonek",
              281,
              "eokorean",
              12627,
              "eopen",
              603,
              "eopenclosed",
              666,
              "eopenreversed",
              604,
              "eopenreversedclosed",
              606,
              "eopenreversedhook",
              605,
              "eparen",
              9376,
              "epsilon",
              949,
              "epsilontonos",
              941,
              "equal",
              61,
              "equalmonospace",
              65309,
              "equalsmall",
              65126,
              "equalsuperior",
              8316,
              "equivalence",
              8801,
              "erbopomofo",
              12582,
              "ercyrillic",
              1088,
              "ereversed",
              600,
              "ereversedcyrillic",
              1101,
              "escyrillic",
              1089,
              "esdescendercyrillic",
              1195,
              "esh",
              643,
              "eshcurl",
              646,
              "eshortdeva",
              2318,
              "eshortvowelsigndeva",
              2374,
              "eshreversedloop",
              426,
              "eshsquatreversed",
              645,
              "esmallhiragana",
              12359,
              "esmallkatakana",
              12455,
              "esmallkatakanahalfwidth",
              65386,
              "estimated",
              8494,
              "esuperior",
              63212,
              "eta",
              951,
              "etarmenian",
              1384,
              "etatonos",
              942,
              "eth",
              240,
              "etilde",
              7869,
              "etildebelow",
              7707,
              "etnahtafoukhhebrew",
              1425,
              "etnahtafoukhlefthebrew",
              1425,
              "etnahtahebrew",
              1425,
              "etnahtalefthebrew",
              1425,
              "eturned",
              477,
              "eukorean",
              12641,
              "euro",
              8364,
              "evowelsignbengali",
              2503,
              "evowelsigndeva",
              2375,
              "evowelsigngujarati",
              2759,
              "exclam",
              33,
              "exclamarmenian",
              1372,
              "exclamdbl",
              8252,
              "exclamdown",
              161,
              "exclamdownsmall",
              63393,
              "exclammonospace",
              65281,
              "exclamsmall",
              63265,
              "existential",
              8707,
              "ezh",
              658,
              "ezhcaron",
              495,
              "ezhcurl",
              659,
              "ezhreversed",
              441,
              "ezhtail",
              442,
              "f",
              102,
              "fadeva",
              2398,
              "fagurmukhi",
              2654,
              "fahrenheit",
              8457,
              "fathaarabic",
              1614,
              "fathalowarabic",
              1614,
              "fathatanarabic",
              1611,
              "fbopomofo",
              12552,
              "fcircle",
              9429,
              "fdotaccent",
              7711,
              "feharabic",
              1601,
              "feharmenian",
              1414,
              "fehfinalarabic",
              65234,
              "fehinitialarabic",
              65235,
              "fehmedialarabic",
              65236,
              "feicoptic",
              997,
              "female",
              9792,
              "ff",
              64256,
              "f_f",
              64256,
              "ffi",
              64259,
              "ffl",
              64260,
              "fi",
              64257,
              "fifteencircle",
              9326,
              "fifteenparen",
              9346,
              "fifteenperiod",
              9366,
              "figuredash",
              8210,
              "filledbox",
              9632,
              "filledrect",
              9644,
              "finalkaf",
              1498,
              "finalkafdagesh",
              64314,
              "finalkafdageshhebrew",
              64314,
              "finalkafhebrew",
              1498,
              "finalmem",
              1501,
              "finalmemhebrew",
              1501,
              "finalnun",
              1503,
              "finalnunhebrew",
              1503,
              "finalpe",
              1507,
              "finalpehebrew",
              1507,
              "finaltsadi",
              1509,
              "finaltsadihebrew",
              1509,
              "firsttonechinese",
              713,
              "fisheye",
              9673,
              "fitacyrillic",
              1139,
              "five",
              53,
              "fivearabic",
              1637,
              "fivebengali",
              2539,
              "fivecircle",
              9316,
              "fivecircleinversesansserif",
              10126,
              "fivedeva",
              2411,
              "fiveeighths",
              8541,
              "fivegujarati",
              2795,
              "fivegurmukhi",
              2667,
              "fivehackarabic",
              1637,
              "fivehangzhou",
              12325,
              "fiveideographicparen",
              12836,
              "fiveinferior",
              8325,
              "fivemonospace",
              65301,
              "fiveoldstyle",
              63285,
              "fiveparen",
              9336,
              "fiveperiod",
              9356,
              "fivepersian",
              1781,
              "fiveroman",
              8564,
              "fivesuperior",
              8309,
              "fivethai",
              3669,
              "fl",
              64258,
              "florin",
              402,
              "fmonospace",
              65350,
              "fmsquare",
              13209,
              "fofanthai",
              3615,
              "fofathai",
              3613,
              "fongmanthai",
              3663,
              "forall",
              8704,
              "four",
              52,
              "fourarabic",
              1636,
              "fourbengali",
              2538,
              "fourcircle",
              9315,
              "fourcircleinversesansserif",
              10125,
              "fourdeva",
              2410,
              "fourgujarati",
              2794,
              "fourgurmukhi",
              2666,
              "fourhackarabic",
              1636,
              "fourhangzhou",
              12324,
              "fourideographicparen",
              12835,
              "fourinferior",
              8324,
              "fourmonospace",
              65300,
              "fournumeratorbengali",
              2551,
              "fouroldstyle",
              63284,
              "fourparen",
              9335,
              "fourperiod",
              9355,
              "fourpersian",
              1780,
              "fourroman",
              8563,
              "foursuperior",
              8308,
              "fourteencircle",
              9325,
              "fourteenparen",
              9345,
              "fourteenperiod",
              9365,
              "fourthai",
              3668,
              "fourthtonechinese",
              715,
              "fparen",
              9377,
              "fraction",
              8260,
              "franc",
              8355,
              "g",
              103,
              "gabengali",
              2455,
              "gacute",
              501,
              "gadeva",
              2327,
              "gafarabic",
              1711,
              "gaffinalarabic",
              64403,
              "gafinitialarabic",
              64404,
              "gafmedialarabic",
              64405,
              "gagujarati",
              2711,
              "gagurmukhi",
              2583,
              "gahiragana",
              12364,
              "gakatakana",
              12460,
              "gamma",
              947,
              "gammalatinsmall",
              611,
              "gammasuperior",
              736,
              "gangiacoptic",
              1003,
              "gbopomofo",
              12557,
              "gbreve",
              287,
              "gcaron",
              487,
              "gcedilla",
              291,
              "gcircle",
              9430,
              "gcircumflex",
              285,
              "gcommaaccent",
              291,
              "gdot",
              289,
              "gdotaccent",
              289,
              "gecyrillic",
              1075,
              "gehiragana",
              12370,
              "gekatakana",
              12466,
              "geometricallyequal",
              8785,
              "gereshaccenthebrew",
              1436,
              "gereshhebrew",
              1523,
              "gereshmuqdamhebrew",
              1437,
              "germandbls",
              223,
              "gershayimaccenthebrew",
              1438,
              "gershayimhebrew",
              1524,
              "getamark",
              12307,
              "ghabengali",
              2456,
              "ghadarmenian",
              1394,
              "ghadeva",
              2328,
              "ghagujarati",
              2712,
              "ghagurmukhi",
              2584,
              "ghainarabic",
              1594,
              "ghainfinalarabic",
              65230,
              "ghaininitialarabic",
              65231,
              "ghainmedialarabic",
              65232,
              "ghemiddlehookcyrillic",
              1173,
              "ghestrokecyrillic",
              1171,
              "gheupturncyrillic",
              1169,
              "ghhadeva",
              2394,
              "ghhagurmukhi",
              2650,
              "ghook",
              608,
              "ghzsquare",
              13203,
              "gihiragana",
              12366,
              "gikatakana",
              12462,
              "gimarmenian",
              1379,
              "gimel",
              1490,
              "gimeldagesh",
              64306,
              "gimeldageshhebrew",
              64306,
              "gimelhebrew",
              1490,
              "gjecyrillic",
              1107,
              "glottalinvertedstroke",
              446,
              "glottalstop",
              660,
              "glottalstopinverted",
              662,
              "glottalstopmod",
              704,
              "glottalstopreversed",
              661,
              "glottalstopreversedmod",
              705,
              "glottalstopreversedsuperior",
              740,
              "glottalstopstroke",
              673,
              "glottalstopstrokereversed",
              674,
              "gmacron",
              7713,
              "gmonospace",
              65351,
              "gohiragana",
              12372,
              "gokatakana",
              12468,
              "gparen",
              9378,
              "gpasquare",
              13228,
              "gradient",
              8711,
              "grave",
              96,
              "gravebelowcmb",
              790,
              "gravecmb",
              768,
              "gravecomb",
              768,
              "gravedeva",
              2387,
              "gravelowmod",
              718,
              "gravemonospace",
              65344,
              "gravetonecmb",
              832,
              "greater",
              62,
              "greaterequal",
              8805,
              "greaterequalorless",
              8923,
              "greatermonospace",
              65310,
              "greaterorequivalent",
              8819,
              "greaterorless",
              8823,
              "greateroverequal",
              8807,
              "greatersmall",
              65125,
              "gscript",
              609,
              "gstroke",
              485,
              "guhiragana",
              12368,
              "guillemotleft",
              171,
              "guillemotright",
              187,
              "guilsinglleft",
              8249,
              "guilsinglright",
              8250,
              "gukatakana",
              12464,
              "guramusquare",
              13080,
              "gysquare",
              13257,
              "h",
              104,
              "haabkhasiancyrillic",
              1193,
              "haaltonearabic",
              1729,
              "habengali",
              2489,
              "hadescendercyrillic",
              1203,
              "hadeva",
              2361,
              "hagujarati",
              2745,
              "hagurmukhi",
              2617,
              "haharabic",
              1581,
              "hahfinalarabic",
              65186,
              "hahinitialarabic",
              65187,
              "hahiragana",
              12399,
              "hahmedialarabic",
              65188,
              "haitusquare",
              13098,
              "hakatakana",
              12495,
              "hakatakanahalfwidth",
              65418,
              "halantgurmukhi",
              2637,
              "hamzaarabic",
              1569,
              "hamzalowarabic",
              1569,
              "hangulfiller",
              12644,
              "hardsigncyrillic",
              1098,
              "harpoonleftbarbup",
              8636,
              "harpoonrightbarbup",
              8640,
              "hasquare",
              13258,
              "hatafpatah",
              1458,
              "hatafpatah16",
              1458,
              "hatafpatah23",
              1458,
              "hatafpatah2f",
              1458,
              "hatafpatahhebrew",
              1458,
              "hatafpatahnarrowhebrew",
              1458,
              "hatafpatahquarterhebrew",
              1458,
              "hatafpatahwidehebrew",
              1458,
              "hatafqamats",
              1459,
              "hatafqamats1b",
              1459,
              "hatafqamats28",
              1459,
              "hatafqamats34",
              1459,
              "hatafqamatshebrew",
              1459,
              "hatafqamatsnarrowhebrew",
              1459,
              "hatafqamatsquarterhebrew",
              1459,
              "hatafqamatswidehebrew",
              1459,
              "hatafsegol",
              1457,
              "hatafsegol17",
              1457,
              "hatafsegol24",
              1457,
              "hatafsegol30",
              1457,
              "hatafsegolhebrew",
              1457,
              "hatafsegolnarrowhebrew",
              1457,
              "hatafsegolquarterhebrew",
              1457,
              "hatafsegolwidehebrew",
              1457,
              "hbar",
              295,
              "hbopomofo",
              12559,
              "hbrevebelow",
              7723,
              "hcedilla",
              7721,
              "hcircle",
              9431,
              "hcircumflex",
              293,
              "hdieresis",
              7719,
              "hdotaccent",
              7715,
              "hdotbelow",
              7717,
              "he",
              1492,
              "heart",
              9829,
              "heartsuitblack",
              9829,
              "heartsuitwhite",
              9825,
              "hedagesh",
              64308,
              "hedageshhebrew",
              64308,
              "hehaltonearabic",
              1729,
              "heharabic",
              1607,
              "hehebrew",
              1492,
              "hehfinalaltonearabic",
              64423,
              "hehfinalalttwoarabic",
              65258,
              "hehfinalarabic",
              65258,
              "hehhamzaabovefinalarabic",
              64421,
              "hehhamzaaboveisolatedarabic",
              64420,
              "hehinitialaltonearabic",
              64424,
              "hehinitialarabic",
              65259,
              "hehiragana",
              12408,
              "hehmedialaltonearabic",
              64425,
              "hehmedialarabic",
              65260,
              "heiseierasquare",
              13179,
              "hekatakana",
              12504,
              "hekatakanahalfwidth",
              65421,
              "hekutaarusquare",
              13110,
              "henghook",
              615,
              "herutusquare",
              13113,
              "het",
              1495,
              "hethebrew",
              1495,
              "hhook",
              614,
              "hhooksuperior",
              689,
              "hieuhacirclekorean",
              12923,
              "hieuhaparenkorean",
              12827,
              "hieuhcirclekorean",
              12909,
              "hieuhkorean",
              12622,
              "hieuhparenkorean",
              12813,
              "hihiragana",
              12402,
              "hikatakana",
              12498,
              "hikatakanahalfwidth",
              65419,
              "hiriq",
              1460,
              "hiriq14",
              1460,
              "hiriq21",
              1460,
              "hiriq2d",
              1460,
              "hiriqhebrew",
              1460,
              "hiriqnarrowhebrew",
              1460,
              "hiriqquarterhebrew",
              1460,
              "hiriqwidehebrew",
              1460,
              "hlinebelow",
              7830,
              "hmonospace",
              65352,
              "hoarmenian",
              1392,
              "hohipthai",
              3627,
              "hohiragana",
              12411,
              "hokatakana",
              12507,
              "hokatakanahalfwidth",
              65422,
              "holam",
              1465,
              "holam19",
              1465,
              "holam26",
              1465,
              "holam32",
              1465,
              "holamhebrew",
              1465,
              "holamnarrowhebrew",
              1465,
              "holamquarterhebrew",
              1465,
              "holamwidehebrew",
              1465,
              "honokhukthai",
              3630,
              "hookabovecomb",
              777,
              "hookcmb",
              777,
              "hookpalatalizedbelowcmb",
              801,
              "hookretroflexbelowcmb",
              802,
              "hoonsquare",
              13122,
              "horicoptic",
              1001,
              "horizontalbar",
              8213,
              "horncmb",
              795,
              "hotsprings",
              9832,
              "house",
              8962,
              "hparen",
              9379,
              "hsuperior",
              688,
              "hturned",
              613,
              "huhiragana",
              12405,
              "huiitosquare",
              13107,
              "hukatakana",
              12501,
              "hukatakanahalfwidth",
              65420,
              "hungarumlaut",
              733,
              "hungarumlautcmb",
              779,
              "hv",
              405,
              "hyphen",
              45,
              "hypheninferior",
              63205,
              "hyphenmonospace",
              65293,
              "hyphensmall",
              65123,
              "hyphensuperior",
              63206,
              "hyphentwo",
              8208,
              "i",
              105,
              "iacute",
              237,
              "iacyrillic",
              1103,
              "ibengali",
              2439,
              "ibopomofo",
              12583,
              "ibreve",
              301,
              "icaron",
              464,
              "icircle",
              9432,
              "icircumflex",
              238,
              "icyrillic",
              1110,
              "idblgrave",
              521,
              "ideographearthcircle",
              12943,
              "ideographfirecircle",
              12939,
              "ideographicallianceparen",
              12863,
              "ideographiccallparen",
              12858,
              "ideographiccentrecircle",
              12965,
              "ideographicclose",
              12294,
              "ideographiccomma",
              12289,
              "ideographiccommaleft",
              65380,
              "ideographiccongratulationparen",
              12855,
              "ideographiccorrectcircle",
              12963,
              "ideographicearthparen",
              12847,
              "ideographicenterpriseparen",
              12861,
              "ideographicexcellentcircle",
              12957,
              "ideographicfestivalparen",
              12864,
              "ideographicfinancialcircle",
              12950,
              "ideographicfinancialparen",
              12854,
              "ideographicfireparen",
              12843,
              "ideographichaveparen",
              12850,
              "ideographichighcircle",
              12964,
              "ideographiciterationmark",
              12293,
              "ideographiclaborcircle",
              12952,
              "ideographiclaborparen",
              12856,
              "ideographicleftcircle",
              12967,
              "ideographiclowcircle",
              12966,
              "ideographicmedicinecircle",
              12969,
              "ideographicmetalparen",
              12846,
              "ideographicmoonparen",
              12842,
              "ideographicnameparen",
              12852,
              "ideographicperiod",
              12290,
              "ideographicprintcircle",
              12958,
              "ideographicreachparen",
              12867,
              "ideographicrepresentparen",
              12857,
              "ideographicresourceparen",
              12862,
              "ideographicrightcircle",
              12968,
              "ideographicsecretcircle",
              12953,
              "ideographicselfparen",
              12866,
              "ideographicsocietyparen",
              12851,
              "ideographicspace",
              12288,
              "ideographicspecialparen",
              12853,
              "ideographicstockparen",
              12849,
              "ideographicstudyparen",
              12859,
              "ideographicsunparen",
              12848,
              "ideographicsuperviseparen",
              12860,
              "ideographicwaterparen",
              12844,
              "ideographicwoodparen",
              12845,
              "ideographiczero",
              12295,
              "ideographmetalcircle",
              12942,
              "ideographmooncircle",
              12938,
              "ideographnamecircle",
              12948,
              "ideographsuncircle",
              12944,
              "ideographwatercircle",
              12940,
              "ideographwoodcircle",
              12941,
              "ideva",
              2311,
              "idieresis",
              239,
              "idieresisacute",
              7727,
              "idieresiscyrillic",
              1253,
              "idotbelow",
              7883,
              "iebrevecyrillic",
              1239,
              "iecyrillic",
              1077,
              "ieungacirclekorean",
              12917,
              "ieungaparenkorean",
              12821,
              "ieungcirclekorean",
              12903,
              "ieungkorean",
              12615,
              "ieungparenkorean",
              12807,
              "igrave",
              236,
              "igujarati",
              2695,
              "igurmukhi",
              2567,
              "ihiragana",
              12356,
              "ihookabove",
              7881,
              "iibengali",
              2440,
              "iicyrillic",
              1080,
              "iideva",
              2312,
              "iigujarati",
              2696,
              "iigurmukhi",
              2568,
              "iimatragurmukhi",
              2624,
              "iinvertedbreve",
              523,
              "iishortcyrillic",
              1081,
              "iivowelsignbengali",
              2496,
              "iivowelsigndeva",
              2368,
              "iivowelsigngujarati",
              2752,
              "ij",
              307,
              "ikatakana",
              12452,
              "ikatakanahalfwidth",
              65394,
              "ikorean",
              12643,
              "ilde",
              732,
              "iluyhebrew",
              1452,
              "imacron",
              299,
              "imacroncyrillic",
              1251,
              "imageorapproximatelyequal",
              8787,
              "imatragurmukhi",
              2623,
              "imonospace",
              65353,
              "increment",
              8710,
              "infinity",
              8734,
              "iniarmenian",
              1387,
              "integral",
              8747,
              "integralbottom",
              8993,
              "integralbt",
              8993,
              "integralex",
              63733,
              "integraltop",
              8992,
              "integraltp",
              8992,
              "intersection",
              8745,
              "intisquare",
              13061,
              "invbullet",
              9688,
              "invcircle",
              9689,
              "invsmileface",
              9787,
              "iocyrillic",
              1105,
              "iogonek",
              303,
              "iota",
              953,
              "iotadieresis",
              970,
              "iotadieresistonos",
              912,
              "iotalatin",
              617,
              "iotatonos",
              943,
              "iparen",
              9380,
              "irigurmukhi",
              2674,
              "ismallhiragana",
              12355,
              "ismallkatakana",
              12451,
              "ismallkatakanahalfwidth",
              65384,
              "issharbengali",
              2554,
              "istroke",
              616,
              "isuperior",
              63213,
              "iterationhiragana",
              12445,
              "iterationkatakana",
              12541,
              "itilde",
              297,
              "itildebelow",
              7725,
              "iubopomofo",
              12585,
              "iucyrillic",
              1102,
              "ivowelsignbengali",
              2495,
              "ivowelsigndeva",
              2367,
              "ivowelsigngujarati",
              2751,
              "izhitsacyrillic",
              1141,
              "izhitsadblgravecyrillic",
              1143,
              "j",
              106,
              "jaarmenian",
              1393,
              "jabengali",
              2460,
              "jadeva",
              2332,
              "jagujarati",
              2716,
              "jagurmukhi",
              2588,
              "jbopomofo",
              12560,
              "jcaron",
              496,
              "jcircle",
              9433,
              "jcircumflex",
              309,
              "jcrossedtail",
              669,
              "jdotlessstroke",
              607,
              "jecyrillic",
              1112,
              "jeemarabic",
              1580,
              "jeemfinalarabic",
              65182,
              "jeeminitialarabic",
              65183,
              "jeemmedialarabic",
              65184,
              "jeharabic",
              1688,
              "jehfinalarabic",
              64395,
              "jhabengali",
              2461,
              "jhadeva",
              2333,
              "jhagujarati",
              2717,
              "jhagurmukhi",
              2589,
              "jheharmenian",
              1403,
              "jis",
              12292,
              "jmonospace",
              65354,
              "jparen",
              9381,
              "jsuperior",
              690,
              "k",
              107,
              "kabashkircyrillic",
              1185,
              "kabengali",
              2453,
              "kacute",
              7729,
              "kacyrillic",
              1082,
              "kadescendercyrillic",
              1179,
              "kadeva",
              2325,
              "kaf",
              1499,
              "kafarabic",
              1603,
              "kafdagesh",
              64315,
              "kafdageshhebrew",
              64315,
              "kaffinalarabic",
              65242,
              "kafhebrew",
              1499,
              "kafinitialarabic",
              65243,
              "kafmedialarabic",
              65244,
              "kafrafehebrew",
              64333,
              "kagujarati",
              2709,
              "kagurmukhi",
              2581,
              "kahiragana",
              12363,
              "kahookcyrillic",
              1220,
              "kakatakana",
              12459,
              "kakatakanahalfwidth",
              65398,
              "kappa",
              954,
              "kappasymbolgreek",
              1008,
              "kapyeounmieumkorean",
              12657,
              "kapyeounphieuphkorean",
              12676,
              "kapyeounpieupkorean",
              12664,
              "kapyeounssangpieupkorean",
              12665,
              "karoriisquare",
              13069,
              "kashidaautoarabic",
              1600,
              "kashidaautonosidebearingarabic",
              1600,
              "kasmallkatakana",
              12533,
              "kasquare",
              13188,
              "kasraarabic",
              1616,
              "kasratanarabic",
              1613,
              "kastrokecyrillic",
              1183,
              "katahiraprolongmarkhalfwidth",
              65392,
              "kaverticalstrokecyrillic",
              1181,
              "kbopomofo",
              12558,
              "kcalsquare",
              13193,
              "kcaron",
              489,
              "kcedilla",
              311,
              "kcircle",
              9434,
              "kcommaaccent",
              311,
              "kdotbelow",
              7731,
              "keharmenian",
              1412,
              "kehiragana",
              12369,
              "kekatakana",
              12465,
              "kekatakanahalfwidth",
              65401,
              "kenarmenian",
              1391,
              "kesmallkatakana",
              12534,
              "kgreenlandic",
              312,
              "khabengali",
              2454,
              "khacyrillic",
              1093,
              "khadeva",
              2326,
              "khagujarati",
              2710,
              "khagurmukhi",
              2582,
              "khaharabic",
              1582,
              "khahfinalarabic",
              65190,
              "khahinitialarabic",
              65191,
              "khahmedialarabic",
              65192,
              "kheicoptic",
              999,
              "khhadeva",
              2393,
              "khhagurmukhi",
              2649,
              "khieukhacirclekorean",
              12920,
              "khieukhaparenkorean",
              12824,
              "khieukhcirclekorean",
              12906,
              "khieukhkorean",
              12619,
              "khieukhparenkorean",
              12810,
              "khokhaithai",
              3586,
              "khokhonthai",
              3589,
              "khokhuatthai",
              3587,
              "khokhwaithai",
              3588,
              "khomutthai",
              3675,
              "khook",
              409,
              "khorakhangthai",
              3590,
              "khzsquare",
              13201,
              "kihiragana",
              12365,
              "kikatakana",
              12461,
              "kikatakanahalfwidth",
              65399,
              "kiroguramusquare",
              13077,
              "kiromeetorusquare",
              13078,
              "kirosquare",
              13076,
              "kiyeokacirclekorean",
              12910,
              "kiyeokaparenkorean",
              12814,
              "kiyeokcirclekorean",
              12896,
              "kiyeokkorean",
              12593,
              "kiyeokparenkorean",
              12800,
              "kiyeoksioskorean",
              12595,
              "kjecyrillic",
              1116,
              "klinebelow",
              7733,
              "klsquare",
              13208,
              "kmcubedsquare",
              13222,
              "kmonospace",
              65355,
              "kmsquaredsquare",
              13218,
              "kohiragana",
              12371,
              "kohmsquare",
              13248,
              "kokaithai",
              3585,
              "kokatakana",
              12467,
              "kokatakanahalfwidth",
              65402,
              "kooposquare",
              13086,
              "koppacyrillic",
              1153,
              "koreanstandardsymbol",
              12927,
              "koroniscmb",
              835,
              "kparen",
              9382,
              "kpasquare",
              13226,
              "ksicyrillic",
              1135,
              "ktsquare",
              13263,
              "kturned",
              670,
              "kuhiragana",
              12367,
              "kukatakana",
              12463,
              "kukatakanahalfwidth",
              65400,
              "kvsquare",
              13240,
              "kwsquare",
              13246,
              "l",
              108,
              "labengali",
              2482,
              "lacute",
              314,
              "ladeva",
              2354,
              "lagujarati",
              2738,
              "lagurmukhi",
              2610,
              "lakkhangyaothai",
              3653,
              "lamaleffinalarabic",
              65276,
              "lamalefhamzaabovefinalarabic",
              65272,
              "lamalefhamzaaboveisolatedarabic",
              65271,
              "lamalefhamzabelowfinalarabic",
              65274,
              "lamalefhamzabelowisolatedarabic",
              65273,
              "lamalefisolatedarabic",
              65275,
              "lamalefmaddaabovefinalarabic",
              65270,
              "lamalefmaddaaboveisolatedarabic",
              65269,
              "lamarabic",
              1604,
              "lambda",
              955,
              "lambdastroke",
              411,
              "lamed",
              1500,
              "lameddagesh",
              64316,
              "lameddageshhebrew",
              64316,
              "lamedhebrew",
              1500,
              "lamfinalarabic",
              65246,
              "lamhahinitialarabic",
              64714,
              "laminitialarabic",
              65247,
              "lamjeeminitialarabic",
              64713,
              "lamkhahinitialarabic",
              64715,
              "lamlamhehisolatedarabic",
              65010,
              "lammedialarabic",
              65248,
              "lammeemhahinitialarabic",
              64904,
              "lammeeminitialarabic",
              64716,
              "largecircle",
              9711,
              "lbar",
              410,
              "lbelt",
              620,
              "lbopomofo",
              12556,
              "lcaron",
              318,
              "lcedilla",
              316,
              "lcircle",
              9435,
              "lcircumflexbelow",
              7741,
              "lcommaaccent",
              316,
              "ldot",
              320,
              "ldotaccent",
              320,
              "ldotbelow",
              7735,
              "ldotbelowmacron",
              7737,
              "leftangleabovecmb",
              794,
              "lefttackbelowcmb",
              792,
              "less",
              60,
              "lessequal",
              8804,
              "lessequalorgreater",
              8922,
              "lessmonospace",
              65308,
              "lessorequivalent",
              8818,
              "lessorgreater",
              8822,
              "lessoverequal",
              8806,
              "lesssmall",
              65124,
              "lezh",
              622,
              "lfblock",
              9612,
              "lhookretroflex",
              621,
              "lira",
              8356,
              "liwnarmenian",
              1388,
              "lj",
              457,
              "ljecyrillic",
              1113,
              "ll",
              63168,
              "lladeva",
              2355,
              "llagujarati",
              2739,
              "llinebelow",
              7739,
              "llladeva",
              2356,
              "llvocalicbengali",
              2529,
              "llvocalicdeva",
              2401,
              "llvocalicvowelsignbengali",
              2531,
              "llvocalicvowelsigndeva",
              2403,
              "lmiddletilde",
              619,
              "lmonospace",
              65356,
              "lmsquare",
              13264,
              "lochulathai",
              3628,
              "logicaland",
              8743,
              "logicalnot",
              172,
              "logicalnotreversed",
              8976,
              "logicalor",
              8744,
              "lolingthai",
              3621,
              "longs",
              383,
              "lowlinecenterline",
              65102,
              "lowlinecmb",
              818,
              "lowlinedashed",
              65101,
              "lozenge",
              9674,
              "lparen",
              9383,
              "lslash",
              322,
              "lsquare",
              8467,
              "lsuperior",
              63214,
              "ltshade",
              9617,
              "luthai",
              3622,
              "lvocalicbengali",
              2444,
              "lvocalicdeva",
              2316,
              "lvocalicvowelsignbengali",
              2530,
              "lvocalicvowelsigndeva",
              2402,
              "lxsquare",
              13267,
              "m",
              109,
              "mabengali",
              2478,
              "macron",
              175,
              "macronbelowcmb",
              817,
              "macroncmb",
              772,
              "macronlowmod",
              717,
              "macronmonospace",
              65507,
              "macute",
              7743,
              "madeva",
              2350,
              "magujarati",
              2734,
              "magurmukhi",
              2606,
              "mahapakhhebrew",
              1444,
              "mahapakhlefthebrew",
              1444,
              "mahiragana",
              12414,
              "maichattawalowleftthai",
              63637,
              "maichattawalowrightthai",
              63636,
              "maichattawathai",
              3659,
              "maichattawaupperleftthai",
              63635,
              "maieklowleftthai",
              63628,
              "maieklowrightthai",
              63627,
              "maiekthai",
              3656,
              "maiekupperleftthai",
              63626,
              "maihanakatleftthai",
              63620,
              "maihanakatthai",
              3633,
              "maitaikhuleftthai",
              63625,
              "maitaikhuthai",
              3655,
              "maitholowleftthai",
              63631,
              "maitholowrightthai",
              63630,
              "maithothai",
              3657,
              "maithoupperleftthai",
              63629,
              "maitrilowleftthai",
              63634,
              "maitrilowrightthai",
              63633,
              "maitrithai",
              3658,
              "maitriupperleftthai",
              63632,
              "maiyamokthai",
              3654,
              "makatakana",
              12510,
              "makatakanahalfwidth",
              65423,
              "male",
              9794,
              "mansyonsquare",
              13127,
              "maqafhebrew",
              1470,
              "mars",
              9794,
              "masoracirclehebrew",
              1455,
              "masquare",
              13187,
              "mbopomofo",
              12551,
              "mbsquare",
              13268,
              "mcircle",
              9436,
              "mcubedsquare",
              13221,
              "mdotaccent",
              7745,
              "mdotbelow",
              7747,
              "meemarabic",
              1605,
              "meemfinalarabic",
              65250,
              "meeminitialarabic",
              65251,
              "meemmedialarabic",
              65252,
              "meemmeeminitialarabic",
              64721,
              "meemmeemisolatedarabic",
              64584,
              "meetorusquare",
              13133,
              "mehiragana",
              12417,
              "meizierasquare",
              13182,
              "mekatakana",
              12513,
              "mekatakanahalfwidth",
              65426,
              "mem",
              1502,
              "memdagesh",
              64318,
              "memdageshhebrew",
              64318,
              "memhebrew",
              1502,
              "menarmenian",
              1396,
              "merkhahebrew",
              1445,
              "merkhakefulahebrew",
              1446,
              "merkhakefulalefthebrew",
              1446,
              "merkhalefthebrew",
              1445,
              "mhook",
              625,
              "mhzsquare",
              13202,
              "middledotkatakanahalfwidth",
              65381,
              "middot",
              183,
              "mieumacirclekorean",
              12914,
              "mieumaparenkorean",
              12818,
              "mieumcirclekorean",
              12900,
              "mieumkorean",
              12609,
              "mieumpansioskorean",
              12656,
              "mieumparenkorean",
              12804,
              "mieumpieupkorean",
              12654,
              "mieumsioskorean",
              12655,
              "mihiragana",
              12415,
              "mikatakana",
              12511,
              "mikatakanahalfwidth",
              65424,
              "minus",
              8722,
              "minusbelowcmb",
              800,
              "minuscircle",
              8854,
              "minusmod",
              727,
              "minusplus",
              8723,
              "minute",
              8242,
              "miribaarusquare",
              13130,
              "mirisquare",
              13129,
              "mlonglegturned",
              624,
              "mlsquare",
              13206,
              "mmcubedsquare",
              13219,
              "mmonospace",
              65357,
              "mmsquaredsquare",
              13215,
              "mohiragana",
              12418,
              "mohmsquare",
              13249,
              "mokatakana",
              12514,
              "mokatakanahalfwidth",
              65427,
              "molsquare",
              13270,
              "momathai",
              3617,
              "moverssquare",
              13223,
              "moverssquaredsquare",
              13224,
              "mparen",
              9384,
              "mpasquare",
              13227,
              "mssquare",
              13235,
              "msuperior",
              63215,
              "mturned",
              623,
              "mu",
              181,
              "mu1",
              181,
              "muasquare",
              13186,
              "muchgreater",
              8811,
              "muchless",
              8810,
              "mufsquare",
              13196,
              "mugreek",
              956,
              "mugsquare",
              13197,
              "muhiragana",
              12416,
              "mukatakana",
              12512,
              "mukatakanahalfwidth",
              65425,
              "mulsquare",
              13205,
              "multiply",
              215,
              "mumsquare",
              13211,
              "munahhebrew",
              1443,
              "munahlefthebrew",
              1443,
              "musicalnote",
              9834,
              "musicalnotedbl",
              9835,
              "musicflatsign",
              9837,
              "musicsharpsign",
              9839,
              "mussquare",
              13234,
              "muvsquare",
              13238,
              "muwsquare",
              13244,
              "mvmegasquare",
              13241,
              "mvsquare",
              13239,
              "mwmegasquare",
              13247,
              "mwsquare",
              13245,
              "n",
              110,
              "nabengali",
              2472,
              "nabla",
              8711,
              "nacute",
              324,
              "nadeva",
              2344,
              "nagujarati",
              2728,
              "nagurmukhi",
              2600,
              "nahiragana",
              12394,
              "nakatakana",
              12490,
              "nakatakanahalfwidth",
              65413,
              "napostrophe",
              329,
              "nasquare",
              13185,
              "nbopomofo",
              12555,
              "nbspace",
              160,
              "ncaron",
              328,
              "ncedilla",
              326,
              "ncircle",
              9437,
              "ncircumflexbelow",
              7755,
              "ncommaaccent",
              326,
              "ndotaccent",
              7749,
              "ndotbelow",
              7751,
              "nehiragana",
              12397,
              "nekatakana",
              12493,
              "nekatakanahalfwidth",
              65416,
              "newsheqelsign",
              8362,
              "nfsquare",
              13195,
              "ngabengali",
              2457,
              "ngadeva",
              2329,
              "ngagujarati",
              2713,
              "ngagurmukhi",
              2585,
              "ngonguthai",
              3591,
              "nhiragana",
              12435,
              "nhookleft",
              626,
              "nhookretroflex",
              627,
              "nieunacirclekorean",
              12911,
              "nieunaparenkorean",
              12815,
              "nieuncieuckorean",
              12597,
              "nieuncirclekorean",
              12897,
              "nieunhieuhkorean",
              12598,
              "nieunkorean",
              12596,
              "nieunpansioskorean",
              12648,
              "nieunparenkorean",
              12801,
              "nieunsioskorean",
              12647,
              "nieuntikeutkorean",
              12646,
              "nihiragana",
              12395,
              "nikatakana",
              12491,
              "nikatakanahalfwidth",
              65414,
              "nikhahitleftthai",
              63641,
              "nikhahitthai",
              3661,
              "nine",
              57,
              "ninearabic",
              1641,
              "ninebengali",
              2543,
              "ninecircle",
              9320,
              "ninecircleinversesansserif",
              10130,
              "ninedeva",
              2415,
              "ninegujarati",
              2799,
              "ninegurmukhi",
              2671,
              "ninehackarabic",
              1641,
              "ninehangzhou",
              12329,
              "nineideographicparen",
              12840,
              "nineinferior",
              8329,
              "ninemonospace",
              65305,
              "nineoldstyle",
              63289,
              "nineparen",
              9340,
              "nineperiod",
              9360,
              "ninepersian",
              1785,
              "nineroman",
              8568,
              "ninesuperior",
              8313,
              "nineteencircle",
              9330,
              "nineteenparen",
              9350,
              "nineteenperiod",
              9370,
              "ninethai",
              3673,
              "nj",
              460,
              "njecyrillic",
              1114,
              "nkatakana",
              12531,
              "nkatakanahalfwidth",
              65437,
              "nlegrightlong",
              414,
              "nlinebelow",
              7753,
              "nmonospace",
              65358,
              "nmsquare",
              13210,
              "nnabengali",
              2467,
              "nnadeva",
              2339,
              "nnagujarati",
              2723,
              "nnagurmukhi",
              2595,
              "nnnadeva",
              2345,
              "nohiragana",
              12398,
              "nokatakana",
              12494,
              "nokatakanahalfwidth",
              65417,
              "nonbreakingspace",
              160,
              "nonenthai",
              3603,
              "nonuthai",
              3609,
              "noonarabic",
              1606,
              "noonfinalarabic",
              65254,
              "noonghunnaarabic",
              1722,
              "noonghunnafinalarabic",
              64415,
              "nooninitialarabic",
              65255,
              "noonjeeminitialarabic",
              64722,
              "noonjeemisolatedarabic",
              64587,
              "noonmedialarabic",
              65256,
              "noonmeeminitialarabic",
              64725,
              "noonmeemisolatedarabic",
              64590,
              "noonnoonfinalarabic",
              64653,
              "notcontains",
              8716,
              "notelement",
              8713,
              "notelementof",
              8713,
              "notequal",
              8800,
              "notgreater",
              8815,
              "notgreaternorequal",
              8817,
              "notgreaternorless",
              8825,
              "notidentical",
              8802,
              "notless",
              8814,
              "notlessnorequal",
              8816,
              "notparallel",
              8742,
              "notprecedes",
              8832,
              "notsubset",
              8836,
              "notsucceeds",
              8833,
              "notsuperset",
              8837,
              "nowarmenian",
              1398,
              "nparen",
              9385,
              "nssquare",
              13233,
              "nsuperior",
              8319,
              "ntilde",
              241,
              "nu",
              957,
              "nuhiragana",
              12396,
              "nukatakana",
              12492,
              "nukatakanahalfwidth",
              65415,
              "nuktabengali",
              2492,
              "nuktadeva",
              2364,
              "nuktagujarati",
              2748,
              "nuktagurmukhi",
              2620,
              "numbersign",
              35,
              "numbersignmonospace",
              65283,
              "numbersignsmall",
              65119,
              "numeralsigngreek",
              884,
              "numeralsignlowergreek",
              885,
              "numero",
              8470,
              "nun",
              1504,
              "nundagesh",
              64320,
              "nundageshhebrew",
              64320,
              "nunhebrew",
              1504,
              "nvsquare",
              13237,
              "nwsquare",
              13243,
              "nyabengali",
              2462,
              "nyadeva",
              2334,
              "nyagujarati",
              2718,
              "nyagurmukhi",
              2590,
              "o",
              111,
              "oacute",
              243,
              "oangthai",
              3629,
              "obarred",
              629,
              "obarredcyrillic",
              1257,
              "obarreddieresiscyrillic",
              1259,
              "obengali",
              2451,
              "obopomofo",
              12571,
              "obreve",
              335,
              "ocandradeva",
              2321,
              "ocandragujarati",
              2705,
              "ocandravowelsigndeva",
              2377,
              "ocandravowelsigngujarati",
              2761,
              "ocaron",
              466,
              "ocircle",
              9438,
              "ocircumflex",
              244,
              "ocircumflexacute",
              7889,
              "ocircumflexdotbelow",
              7897,
              "ocircumflexgrave",
              7891,
              "ocircumflexhookabove",
              7893,
              "ocircumflextilde",
              7895,
              "ocyrillic",
              1086,
              "odblacute",
              337,
              "odblgrave",
              525,
              "odeva",
              2323,
              "odieresis",
              246,
              "odieresiscyrillic",
              1255,
              "odotbelow",
              7885,
              "oe",
              339,
              "oekorean",
              12634,
              "ogonek",
              731,
              "ogonekcmb",
              808,
              "ograve",
              242,
              "ogujarati",
              2707,
              "oharmenian",
              1413,
              "ohiragana",
              12362,
              "ohookabove",
              7887,
              "ohorn",
              417,
              "ohornacute",
              7899,
              "ohorndotbelow",
              7907,
              "ohorngrave",
              7901,
              "ohornhookabove",
              7903,
              "ohorntilde",
              7905,
              "ohungarumlaut",
              337,
              "oi",
              419,
              "oinvertedbreve",
              527,
              "okatakana",
              12458,
              "okatakanahalfwidth",
              65397,
              "okorean",
              12631,
              "olehebrew",
              1451,
              "omacron",
              333,
              "omacronacute",
              7763,
              "omacrongrave",
              7761,
              "omdeva",
              2384,
              "omega",
              969,
              "omega1",
              982,
              "omegacyrillic",
              1121,
              "omegalatinclosed",
              631,
              "omegaroundcyrillic",
              1147,
              "omegatitlocyrillic",
              1149,
              "omegatonos",
              974,
              "omgujarati",
              2768,
              "omicron",
              959,
              "omicrontonos",
              972,
              "omonospace",
              65359,
              "one",
              49,
              "onearabic",
              1633,
              "onebengali",
              2535,
              "onecircle",
              9312,
              "onecircleinversesansserif",
              10122,
              "onedeva",
              2407,
              "onedotenleader",
              8228,
              "oneeighth",
              8539,
              "onefitted",
              63196,
              "onegujarati",
              2791,
              "onegurmukhi",
              2663,
              "onehackarabic",
              1633,
              "onehalf",
              189,
              "onehangzhou",
              12321,
              "oneideographicparen",
              12832,
              "oneinferior",
              8321,
              "onemonospace",
              65297,
              "onenumeratorbengali",
              2548,
              "oneoldstyle",
              63281,
              "oneparen",
              9332,
              "oneperiod",
              9352,
              "onepersian",
              1777,
              "onequarter",
              188,
              "oneroman",
              8560,
              "onesuperior",
              185,
              "onethai",
              3665,
              "onethird",
              8531,
              "oogonek",
              491,
              "oogonekmacron",
              493,
              "oogurmukhi",
              2579,
              "oomatragurmukhi",
              2635,
              "oopen",
              596,
              "oparen",
              9386,
              "openbullet",
              9702,
              "option",
              8997,
              "ordfeminine",
              170,
              "ordmasculine",
              186,
              "orthogonal",
              8735,
              "oshortdeva",
              2322,
              "oshortvowelsigndeva",
              2378,
              "oslash",
              248,
              "oslashacute",
              511,
              "osmallhiragana",
              12361,
              "osmallkatakana",
              12457,
              "osmallkatakanahalfwidth",
              65387,
              "ostrokeacute",
              511,
              "osuperior",
              63216,
              "otcyrillic",
              1151,
              "otilde",
              245,
              "otildeacute",
              7757,
              "otildedieresis",
              7759,
              "oubopomofo",
              12577,
              "overline",
              8254,
              "overlinecenterline",
              65098,
              "overlinecmb",
              773,
              "overlinedashed",
              65097,
              "overlinedblwavy",
              65100,
              "overlinewavy",
              65099,
              "overscore",
              175,
              "ovowelsignbengali",
              2507,
              "ovowelsigndeva",
              2379,
              "ovowelsigngujarati",
              2763,
              "p",
              112,
              "paampssquare",
              13184,
              "paasentosquare",
              13099,
              "pabengali",
              2474,
              "pacute",
              7765,
              "padeva",
              2346,
              "pagedown",
              8671,
              "pageup",
              8670,
              "pagujarati",
              2730,
              "pagurmukhi",
              2602,
              "pahiragana",
              12401,
              "paiyannoithai",
              3631,
              "pakatakana",
              12497,
              "palatalizationcyrilliccmb",
              1156,
              "palochkacyrillic",
              1216,
              "pansioskorean",
              12671,
              "paragraph",
              182,
              "parallel",
              8741,
              "parenleft",
              40,
              "parenleftaltonearabic",
              64830,
              "parenleftbt",
              63725,
              "parenleftex",
              63724,
              "parenleftinferior",
              8333,
              "parenleftmonospace",
              65288,
              "parenleftsmall",
              65113,
              "parenleftsuperior",
              8317,
              "parenlefttp",
              63723,
              "parenleftvertical",
              65077,
              "parenright",
              41,
              "parenrightaltonearabic",
              64831,
              "parenrightbt",
              63736,
              "parenrightex",
              63735,
              "parenrightinferior",
              8334,
              "parenrightmonospace",
              65289,
              "parenrightsmall",
              65114,
              "parenrightsuperior",
              8318,
              "parenrighttp",
              63734,
              "parenrightvertical",
              65078,
              "partialdiff",
              8706,
              "paseqhebrew",
              1472,
              "pashtahebrew",
              1433,
              "pasquare",
              13225,
              "patah",
              1463,
              "patah11",
              1463,
              "patah1d",
              1463,
              "patah2a",
              1463,
              "patahhebrew",
              1463,
              "patahnarrowhebrew",
              1463,
              "patahquarterhebrew",
              1463,
              "patahwidehebrew",
              1463,
              "pazerhebrew",
              1441,
              "pbopomofo",
              12550,
              "pcircle",
              9439,
              "pdotaccent",
              7767,
              "pe",
              1508,
              "pecyrillic",
              1087,
              "pedagesh",
              64324,
              "pedageshhebrew",
              64324,
              "peezisquare",
              13115,
              "pefinaldageshhebrew",
              64323,
              "peharabic",
              1662,
              "peharmenian",
              1402,
              "pehebrew",
              1508,
              "pehfinalarabic",
              64343,
              "pehinitialarabic",
              64344,
              "pehiragana",
              12410,
              "pehmedialarabic",
              64345,
              "pekatakana",
              12506,
              "pemiddlehookcyrillic",
              1191,
              "perafehebrew",
              64334,
              "percent",
              37,
              "percentarabic",
              1642,
              "percentmonospace",
              65285,
              "percentsmall",
              65130,
              "period",
              46,
              "periodarmenian",
              1417,
              "periodcentered",
              183,
              "periodhalfwidth",
              65377,
              "periodinferior",
              63207,
              "periodmonospace",
              65294,
              "periodsmall",
              65106,
              "periodsuperior",
              63208,
              "perispomenigreekcmb",
              834,
              "perpendicular",
              8869,
              "perthousand",
              8240,
              "peseta",
              8359,
              "pfsquare",
              13194,
              "phabengali",
              2475,
              "phadeva",
              2347,
              "phagujarati",
              2731,
              "phagurmukhi",
              2603,
              "phi",
              966,
              "phi1",
              981,
              "phieuphacirclekorean",
              12922,
              "phieuphaparenkorean",
              12826,
              "phieuphcirclekorean",
              12908,
              "phieuphkorean",
              12621,
              "phieuphparenkorean",
              12812,
              "philatin",
              632,
              "phinthuthai",
              3642,
              "phisymbolgreek",
              981,
              "phook",
              421,
              "phophanthai",
              3614,
              "phophungthai",
              3612,
              "phosamphaothai",
              3616,
              "pi",
              960,
              "pieupacirclekorean",
              12915,
              "pieupaparenkorean",
              12819,
              "pieupcieuckorean",
              12662,
              "pieupcirclekorean",
              12901,
              "pieupkiyeokkorean",
              12658,
              "pieupkorean",
              12610,
              "pieupparenkorean",
              12805,
              "pieupsioskiyeokkorean",
              12660,
              "pieupsioskorean",
              12612,
              "pieupsiostikeutkorean",
              12661,
              "pieupthieuthkorean",
              12663,
              "pieuptikeutkorean",
              12659,
              "pihiragana",
              12404,
              "pikatakana",
              12500,
              "pisymbolgreek",
              982,
              "piwrarmenian",
              1411,
              "plus",
              43,
              "plusbelowcmb",
              799,
              "pluscircle",
              8853,
              "plusminus",
              177,
              "plusmod",
              726,
              "plusmonospace",
              65291,
              "plussmall",
              65122,
              "plussuperior",
              8314,
              "pmonospace",
              65360,
              "pmsquare",
              13272,
              "pohiragana",
              12413,
              "pointingindexdownwhite",
              9759,
              "pointingindexleftwhite",
              9756,
              "pointingindexrightwhite",
              9758,
              "pointingindexupwhite",
              9757,
              "pokatakana",
              12509,
              "poplathai",
              3611,
              "postalmark",
              12306,
              "postalmarkface",
              12320,
              "pparen",
              9387,
              "precedes",
              8826,
              "prescription",
              8478,
              "primemod",
              697,
              "primereversed",
              8245,
              "product",
              8719,
              "projective",
              8965,
              "prolongedkana",
              12540,
              "propellor",
              8984,
              "propersubset",
              8834,
              "propersuperset",
              8835,
              "proportion",
              8759,
              "proportional",
              8733,
              "psi",
              968,
              "psicyrillic",
              1137,
              "psilipneumatacyrilliccmb",
              1158,
              "pssquare",
              13232,
              "puhiragana",
              12407,
              "pukatakana",
              12503,
              "pvsquare",
              13236,
              "pwsquare",
              13242,
              "q",
              113,
              "qadeva",
              2392,
              "qadmahebrew",
              1448,
              "qafarabic",
              1602,
              "qaffinalarabic",
              65238,
              "qafinitialarabic",
              65239,
              "qafmedialarabic",
              65240,
              "qamats",
              1464,
              "qamats10",
              1464,
              "qamats1a",
              1464,
              "qamats1c",
              1464,
              "qamats27",
              1464,
              "qamats29",
              1464,
              "qamats33",
              1464,
              "qamatsde",
              1464,
              "qamatshebrew",
              1464,
              "qamatsnarrowhebrew",
              1464,
              "qamatsqatanhebrew",
              1464,
              "qamatsqatannarrowhebrew",
              1464,
              "qamatsqatanquarterhebrew",
              1464,
              "qamatsqatanwidehebrew",
              1464,
              "qamatsquarterhebrew",
              1464,
              "qamatswidehebrew",
              1464,
              "qarneyparahebrew",
              1439,
              "qbopomofo",
              12561,
              "qcircle",
              9440,
              "qhook",
              672,
              "qmonospace",
              65361,
              "qof",
              1511,
              "qofdagesh",
              64327,
              "qofdageshhebrew",
              64327,
              "qofhebrew",
              1511,
              "qparen",
              9388,
              "quarternote",
              9833,
              "qubuts",
              1467,
              "qubuts18",
              1467,
              "qubuts25",
              1467,
              "qubuts31",
              1467,
              "qubutshebrew",
              1467,
              "qubutsnarrowhebrew",
              1467,
              "qubutsquarterhebrew",
              1467,
              "qubutswidehebrew",
              1467,
              "question",
              63,
              "questionarabic",
              1567,
              "questionarmenian",
              1374,
              "questiondown",
              191,
              "questiondownsmall",
              63423,
              "questiongreek",
              894,
              "questionmonospace",
              65311,
              "questionsmall",
              63295,
              "quotedbl",
              34,
              "quotedblbase",
              8222,
              "quotedblleft",
              8220,
              "quotedblmonospace",
              65282,
              "quotedblprime",
              12318,
              "quotedblprimereversed",
              12317,
              "quotedblright",
              8221,
              "quoteleft",
              8216,
              "quoteleftreversed",
              8219,
              "quotereversed",
              8219,
              "quoteright",
              8217,
              "quoterightn",
              329,
              "quotesinglbase",
              8218,
              "quotesingle",
              39,
              "quotesinglemonospace",
              65287,
              "r",
              114,
              "raarmenian",
              1404,
              "rabengali",
              2480,
              "racute",
              341,
              "radeva",
              2352,
              "radical",
              8730,
              "radicalex",
              63717,
              "radoverssquare",
              13230,
              "radoverssquaredsquare",
              13231,
              "radsquare",
              13229,
              "rafe",
              1471,
              "rafehebrew",
              1471,
              "ragujarati",
              2736,
              "ragurmukhi",
              2608,
              "rahiragana",
              12425,
              "rakatakana",
              12521,
              "rakatakanahalfwidth",
              65431,
              "ralowerdiagonalbengali",
              2545,
              "ramiddlediagonalbengali",
              2544,
              "ramshorn",
              612,
              "ratio",
              8758,
              "rbopomofo",
              12566,
              "rcaron",
              345,
              "rcedilla",
              343,
              "rcircle",
              9441,
              "rcommaaccent",
              343,
              "rdblgrave",
              529,
              "rdotaccent",
              7769,
              "rdotbelow",
              7771,
              "rdotbelowmacron",
              7773,
              "referencemark",
              8251,
              "reflexsubset",
              8838,
              "reflexsuperset",
              8839,
              "registered",
              174,
              "registersans",
              63720,
              "registerserif",
              63194,
              "reharabic",
              1585,
              "reharmenian",
              1408,
              "rehfinalarabic",
              65198,
              "rehiragana",
              12428,
              "rekatakana",
              12524,
              "rekatakanahalfwidth",
              65434,
              "resh",
              1512,
              "reshdageshhebrew",
              64328,
              "reshhebrew",
              1512,
              "reversedtilde",
              8765,
              "reviahebrew",
              1431,
              "reviamugrashhebrew",
              1431,
              "revlogicalnot",
              8976,
              "rfishhook",
              638,
              "rfishhookreversed",
              639,
              "rhabengali",
              2525,
              "rhadeva",
              2397,
              "rho",
              961,
              "rhook",
              637,
              "rhookturned",
              635,
              "rhookturnedsuperior",
              693,
              "rhosymbolgreek",
              1009,
              "rhotichookmod",
              734,
              "rieulacirclekorean",
              12913,
              "rieulaparenkorean",
              12817,
              "rieulcirclekorean",
              12899,
              "rieulhieuhkorean",
              12608,
              "rieulkiyeokkorean",
              12602,
              "rieulkiyeoksioskorean",
              12649,
              "rieulkorean",
              12601,
              "rieulmieumkorean",
              12603,
              "rieulpansioskorean",
              12652,
              "rieulparenkorean",
              12803,
              "rieulphieuphkorean",
              12607,
              "rieulpieupkorean",
              12604,
              "rieulpieupsioskorean",
              12651,
              "rieulsioskorean",
              12605,
              "rieulthieuthkorean",
              12606,
              "rieultikeutkorean",
              12650,
              "rieulyeorinhieuhkorean",
              12653,
              "rightangle",
              8735,
              "righttackbelowcmb",
              793,
              "righttriangle",
              8895,
              "rihiragana",
              12426,
              "rikatakana",
              12522,
              "rikatakanahalfwidth",
              65432,
              "ring",
              730,
              "ringbelowcmb",
              805,
              "ringcmb",
              778,
              "ringhalfleft",
              703,
              "ringhalfleftarmenian",
              1369,
              "ringhalfleftbelowcmb",
              796,
              "ringhalfleftcentered",
              723,
              "ringhalfright",
              702,
              "ringhalfrightbelowcmb",
              825,
              "ringhalfrightcentered",
              722,
              "rinvertedbreve",
              531,
              "rittorusquare",
              13137,
              "rlinebelow",
              7775,
              "rlongleg",
              636,
              "rlonglegturned",
              634,
              "rmonospace",
              65362,
              "rohiragana",
              12429,
              "rokatakana",
              12525,
              "rokatakanahalfwidth",
              65435,
              "roruathai",
              3619,
              "rparen",
              9389,
              "rrabengali",
              2524,
              "rradeva",
              2353,
              "rragurmukhi",
              2652,
              "rreharabic",
              1681,
              "rrehfinalarabic",
              64397,
              "rrvocalicbengali",
              2528,
              "rrvocalicdeva",
              2400,
              "rrvocalicgujarati",
              2784,
              "rrvocalicvowelsignbengali",
              2500,
              "rrvocalicvowelsigndeva",
              2372,
              "rrvocalicvowelsigngujarati",
              2756,
              "rsuperior",
              63217,
              "rtblock",
              9616,
              "rturned",
              633,
              "rturnedsuperior",
              692,
              "ruhiragana",
              12427,
              "rukatakana",
              12523,
              "rukatakanahalfwidth",
              65433,
              "rupeemarkbengali",
              2546,
              "rupeesignbengali",
              2547,
              "rupiah",
              63197,
              "ruthai",
              3620,
              "rvocalicbengali",
              2443,
              "rvocalicdeva",
              2315,
              "rvocalicgujarati",
              2699,
              "rvocalicvowelsignbengali",
              2499,
              "rvocalicvowelsigndeva",
              2371,
              "rvocalicvowelsigngujarati",
              2755,
              "s",
              115,
              "sabengali",
              2488,
              "sacute",
              347,
              "sacutedotaccent",
              7781,
              "sadarabic",
              1589,
              "sadeva",
              2360,
              "sadfinalarabic",
              65210,
              "sadinitialarabic",
              65211,
              "sadmedialarabic",
              65212,
              "sagujarati",
              2744,
              "sagurmukhi",
              2616,
              "sahiragana",
              12373,
              "sakatakana",
              12469,
              "sakatakanahalfwidth",
              65403,
              "sallallahoualayhewasallamarabic",
              65018,
              "samekh",
              1505,
              "samekhdagesh",
              64321,
              "samekhdageshhebrew",
              64321,
              "samekhhebrew",
              1505,
              "saraaathai",
              3634,
              "saraaethai",
              3649,
              "saraaimaimalaithai",
              3652,
              "saraaimaimuanthai",
              3651,
              "saraamthai",
              3635,
              "saraathai",
              3632,
              "saraethai",
              3648,
              "saraiileftthai",
              63622,
              "saraiithai",
              3637,
              "saraileftthai",
              63621,
              "saraithai",
              3636,
              "saraothai",
              3650,
              "saraueeleftthai",
              63624,
              "saraueethai",
              3639,
              "saraueleftthai",
              63623,
              "sarauethai",
              3638,
              "sarauthai",
              3640,
              "sarauuthai",
              3641,
              "sbopomofo",
              12569,
              "scaron",
              353,
              "scarondotaccent",
              7783,
              "scedilla",
              351,
              "schwa",
              601,
              "schwacyrillic",
              1241,
              "schwadieresiscyrillic",
              1243,
              "schwahook",
              602,
              "scircle",
              9442,
              "scircumflex",
              349,
              "scommaaccent",
              537,
              "sdotaccent",
              7777,
              "sdotbelow",
              7779,
              "sdotbelowdotaccent",
              7785,
              "seagullbelowcmb",
              828,
              "second",
              8243,
              "secondtonechinese",
              714,
              "section",
              167,
              "seenarabic",
              1587,
              "seenfinalarabic",
              65202,
              "seeninitialarabic",
              65203,
              "seenmedialarabic",
              65204,
              "segol",
              1462,
              "segol13",
              1462,
              "segol1f",
              1462,
              "segol2c",
              1462,
              "segolhebrew",
              1462,
              "segolnarrowhebrew",
              1462,
              "segolquarterhebrew",
              1462,
              "segoltahebrew",
              1426,
              "segolwidehebrew",
              1462,
              "seharmenian",
              1405,
              "sehiragana",
              12379,
              "sekatakana",
              12475,
              "sekatakanahalfwidth",
              65406,
              "semicolon",
              59,
              "semicolonarabic",
              1563,
              "semicolonmonospace",
              65307,
              "semicolonsmall",
              65108,
              "semivoicedmarkkana",
              12444,
              "semivoicedmarkkanahalfwidth",
              65439,
              "sentisquare",
              13090,
              "sentosquare",
              13091,
              "seven",
              55,
              "sevenarabic",
              1639,
              "sevenbengali",
              2541,
              "sevencircle",
              9318,
              "sevencircleinversesansserif",
              10128,
              "sevendeva",
              2413,
              "seveneighths",
              8542,
              "sevengujarati",
              2797,
              "sevengurmukhi",
              2669,
              "sevenhackarabic",
              1639,
              "sevenhangzhou",
              12327,
              "sevenideographicparen",
              12838,
              "seveninferior",
              8327,
              "sevenmonospace",
              65303,
              "sevenoldstyle",
              63287,
              "sevenparen",
              9338,
              "sevenperiod",
              9358,
              "sevenpersian",
              1783,
              "sevenroman",
              8566,
              "sevensuperior",
              8311,
              "seventeencircle",
              9328,
              "seventeenparen",
              9348,
              "seventeenperiod",
              9368,
              "seventhai",
              3671,
              "sfthyphen",
              173,
              "shaarmenian",
              1399,
              "shabengali",
              2486,
              "shacyrillic",
              1096,
              "shaddaarabic",
              1617,
              "shaddadammaarabic",
              64609,
              "shaddadammatanarabic",
              64606,
              "shaddafathaarabic",
              64608,
              "shaddakasraarabic",
              64610,
              "shaddakasratanarabic",
              64607,
              "shade",
              9618,
              "shadedark",
              9619,
              "shadelight",
              9617,
              "shademedium",
              9618,
              "shadeva",
              2358,
              "shagujarati",
              2742,
              "shagurmukhi",
              2614,
              "shalshelethebrew",
              1427,
              "shbopomofo",
              12565,
              "shchacyrillic",
              1097,
              "sheenarabic",
              1588,
              "sheenfinalarabic",
              65206,
              "sheeninitialarabic",
              65207,
              "sheenmedialarabic",
              65208,
              "sheicoptic",
              995,
              "sheqel",
              8362,
              "sheqelhebrew",
              8362,
              "sheva",
              1456,
              "sheva115",
              1456,
              "sheva15",
              1456,
              "sheva22",
              1456,
              "sheva2e",
              1456,
              "shevahebrew",
              1456,
              "shevanarrowhebrew",
              1456,
              "shevaquarterhebrew",
              1456,
              "shevawidehebrew",
              1456,
              "shhacyrillic",
              1211,
              "shimacoptic",
              1005,
              "shin",
              1513,
              "shindagesh",
              64329,
              "shindageshhebrew",
              64329,
              "shindageshshindot",
              64300,
              "shindageshshindothebrew",
              64300,
              "shindageshsindot",
              64301,
              "shindageshsindothebrew",
              64301,
              "shindothebrew",
              1473,
              "shinhebrew",
              1513,
              "shinshindot",
              64298,
              "shinshindothebrew",
              64298,
              "shinsindot",
              64299,
              "shinsindothebrew",
              64299,
              "shook",
              642,
              "sigma",
              963,
              "sigma1",
              962,
              "sigmafinal",
              962,
              "sigmalunatesymbolgreek",
              1010,
              "sihiragana",
              12375,
              "sikatakana",
              12471,
              "sikatakanahalfwidth",
              65404,
              "siluqhebrew",
              1469,
              "siluqlefthebrew",
              1469,
              "similar",
              8764,
              "sindothebrew",
              1474,
              "siosacirclekorean",
              12916,
              "siosaparenkorean",
              12820,
              "sioscieuckorean",
              12670,
              "sioscirclekorean",
              12902,
              "sioskiyeokkorean",
              12666,
              "sioskorean",
              12613,
              "siosnieunkorean",
              12667,
              "siosparenkorean",
              12806,
              "siospieupkorean",
              12669,
              "siostikeutkorean",
              12668,
              "six",
              54,
              "sixarabic",
              1638,
              "sixbengali",
              2540,
              "sixcircle",
              9317,
              "sixcircleinversesansserif",
              10127,
              "sixdeva",
              2412,
              "sixgujarati",
              2796,
              "sixgurmukhi",
              2668,
              "sixhackarabic",
              1638,
              "sixhangzhou",
              12326,
              "sixideographicparen",
              12837,
              "sixinferior",
              8326,
              "sixmonospace",
              65302,
              "sixoldstyle",
              63286,
              "sixparen",
              9337,
              "sixperiod",
              9357,
              "sixpersian",
              1782,
              "sixroman",
              8565,
              "sixsuperior",
              8310,
              "sixteencircle",
              9327,
              "sixteencurrencydenominatorbengali",
              2553,
              "sixteenparen",
              9347,
              "sixteenperiod",
              9367,
              "sixthai",
              3670,
              "slash",
              47,
              "slashmonospace",
              65295,
              "slong",
              383,
              "slongdotaccent",
              7835,
              "smileface",
              9786,
              "smonospace",
              65363,
              "sofpasuqhebrew",
              1475,
              "softhyphen",
              173,
              "softsigncyrillic",
              1100,
              "sohiragana",
              12381,
              "sokatakana",
              12477,
              "sokatakanahalfwidth",
              65407,
              "soliduslongoverlaycmb",
              824,
              "solidusshortoverlaycmb",
              823,
              "sorusithai",
              3625,
              "sosalathai",
              3624,
              "sosothai",
              3595,
              "sosuathai",
              3626,
              "space",
              32,
              "spacehackarabic",
              32,
              "spade",
              9824,
              "spadesuitblack",
              9824,
              "spadesuitwhite",
              9828,
              "sparen",
              9390,
              "squarebelowcmb",
              827,
              "squarecc",
              13252,
              "squarecm",
              13213,
              "squarediagonalcrosshatchfill",
              9641,
              "squarehorizontalfill",
              9636,
              "squarekg",
              13199,
              "squarekm",
              13214,
              "squarekmcapital",
              13262,
              "squareln",
              13265,
              "squarelog",
              13266,
              "squaremg",
              13198,
              "squaremil",
              13269,
              "squaremm",
              13212,
              "squaremsquared",
              13217,
              "squareorthogonalcrosshatchfill",
              9638,
              "squareupperlefttolowerrightfill",
              9639,
              "squareupperrighttolowerleftfill",
              9640,
              "squareverticalfill",
              9637,
              "squarewhitewithsmallblack",
              9635,
              "srsquare",
              13275,
              "ssabengali",
              2487,
              "ssadeva",
              2359,
              "ssagujarati",
              2743,
              "ssangcieuckorean",
              12617,
              "ssanghieuhkorean",
              12677,
              "ssangieungkorean",
              12672,
              "ssangkiyeokkorean",
              12594,
              "ssangnieunkorean",
              12645,
              "ssangpieupkorean",
              12611,
              "ssangsioskorean",
              12614,
              "ssangtikeutkorean",
              12600,
              "ssuperior",
              63218,
              "sterling",
              163,
              "sterlingmonospace",
              65505,
              "strokelongoverlaycmb",
              822,
              "strokeshortoverlaycmb",
              821,
              "subset",
              8834,
              "subsetnotequal",
              8842,
              "subsetorequal",
              8838,
              "succeeds",
              8827,
              "suchthat",
              8715,
              "suhiragana",
              12377,
              "sukatakana",
              12473,
              "sukatakanahalfwidth",
              65405,
              "sukunarabic",
              1618,
              "summation",
              8721,
              "sun",
              9788,
              "superset",
              8835,
              "supersetnotequal",
              8843,
              "supersetorequal",
              8839,
              "svsquare",
              13276,
              "syouwaerasquare",
              13180,
              "t",
              116,
              "tabengali",
              2468,
              "tackdown",
              8868,
              "tackleft",
              8867,
              "tadeva",
              2340,
              "tagujarati",
              2724,
              "tagurmukhi",
              2596,
              "taharabic",
              1591,
              "tahfinalarabic",
              65218,
              "tahinitialarabic",
              65219,
              "tahiragana",
              12383,
              "tahmedialarabic",
              65220,
              "taisyouerasquare",
              13181,
              "takatakana",
              12479,
              "takatakanahalfwidth",
              65408,
              "tatweelarabic",
              1600,
              "tau",
              964,
              "tav",
              1514,
              "tavdages",
              64330,
              "tavdagesh",
              64330,
              "tavdageshhebrew",
              64330,
              "tavhebrew",
              1514,
              "tbar",
              359,
              "tbopomofo",
              12554,
              "tcaron",
              357,
              "tccurl",
              680,
              "tcedilla",
              355,
              "tcheharabic",
              1670,
              "tchehfinalarabic",
              64379,
              "tchehinitialarabic",
              64380,
              "tchehmedialarabic",
              64381,
              "tcircle",
              9443,
              "tcircumflexbelow",
              7793,
              "tcommaaccent",
              355,
              "tdieresis",
              7831,
              "tdotaccent",
              7787,
              "tdotbelow",
              7789,
              "tecyrillic",
              1090,
              "tedescendercyrillic",
              1197,
              "teharabic",
              1578,
              "tehfinalarabic",
              65174,
              "tehhahinitialarabic",
              64674,
              "tehhahisolatedarabic",
              64524,
              "tehinitialarabic",
              65175,
              "tehiragana",
              12390,
              "tehjeeminitialarabic",
              64673,
              "tehjeemisolatedarabic",
              64523,
              "tehmarbutaarabic",
              1577,
              "tehmarbutafinalarabic",
              65172,
              "tehmedialarabic",
              65176,
              "tehmeeminitialarabic",
              64676,
              "tehmeemisolatedarabic",
              64526,
              "tehnoonfinalarabic",
              64627,
              "tekatakana",
              12486,
              "tekatakanahalfwidth",
              65411,
              "telephone",
              8481,
              "telephoneblack",
              9742,
              "telishagedolahebrew",
              1440,
              "telishaqetanahebrew",
              1449,
              "tencircle",
              9321,
              "tenideographicparen",
              12841,
              "tenparen",
              9341,
              "tenperiod",
              9361,
              "tenroman",
              8569,
              "tesh",
              679,
              "tet",
              1496,
              "tetdagesh",
              64312,
              "tetdageshhebrew",
              64312,
              "tethebrew",
              1496,
              "tetsecyrillic",
              1205,
              "tevirhebrew",
              1435,
              "tevirlefthebrew",
              1435,
              "thabengali",
              2469,
              "thadeva",
              2341,
              "thagujarati",
              2725,
              "thagurmukhi",
              2597,
              "thalarabic",
              1584,
              "thalfinalarabic",
              65196,
              "thanthakhatlowleftthai",
              63640,
              "thanthakhatlowrightthai",
              63639,
              "thanthakhatthai",
              3660,
              "thanthakhatupperleftthai",
              63638,
              "theharabic",
              1579,
              "thehfinalarabic",
              65178,
              "thehinitialarabic",
              65179,
              "thehmedialarabic",
              65180,
              "thereexists",
              8707,
              "therefore",
              8756,
              "theta",
              952,
              "theta1",
              977,
              "thetasymbolgreek",
              977,
              "thieuthacirclekorean",
              12921,
              "thieuthaparenkorean",
              12825,
              "thieuthcirclekorean",
              12907,
              "thieuthkorean",
              12620,
              "thieuthparenkorean",
              12811,
              "thirteencircle",
              9324,
              "thirteenparen",
              9344,
              "thirteenperiod",
              9364,
              "thonangmonthothai",
              3601,
              "thook",
              429,
              "thophuthaothai",
              3602,
              "thorn",
              254,
              "thothahanthai",
              3607,
              "thothanthai",
              3600,
              "thothongthai",
              3608,
              "thothungthai",
              3606,
              "thousandcyrillic",
              1154,
              "thousandsseparatorarabic",
              1644,
              "thousandsseparatorpersian",
              1644,
              "three",
              51,
              "threearabic",
              1635,
              "threebengali",
              2537,
              "threecircle",
              9314,
              "threecircleinversesansserif",
              10124,
              "threedeva",
              2409,
              "threeeighths",
              8540,
              "threegujarati",
              2793,
              "threegurmukhi",
              2665,
              "threehackarabic",
              1635,
              "threehangzhou",
              12323,
              "threeideographicparen",
              12834,
              "threeinferior",
              8323,
              "threemonospace",
              65299,
              "threenumeratorbengali",
              2550,
              "threeoldstyle",
              63283,
              "threeparen",
              9334,
              "threeperiod",
              9354,
              "threepersian",
              1779,
              "threequarters",
              190,
              "threequartersemdash",
              63198,
              "threeroman",
              8562,
              "threesuperior",
              179,
              "threethai",
              3667,
              "thzsquare",
              13204,
              "tihiragana",
              12385,
              "tikatakana",
              12481,
              "tikatakanahalfwidth",
              65409,
              "tikeutacirclekorean",
              12912,
              "tikeutaparenkorean",
              12816,
              "tikeutcirclekorean",
              12898,
              "tikeutkorean",
              12599,
              "tikeutparenkorean",
              12802,
              "tilde",
              732,
              "tildebelowcmb",
              816,
              "tildecmb",
              771,
              "tildecomb",
              771,
              "tildedoublecmb",
              864,
              "tildeoperator",
              8764,
              "tildeoverlaycmb",
              820,
              "tildeverticalcmb",
              830,
              "timescircle",
              8855,
              "tipehahebrew",
              1430,
              "tipehalefthebrew",
              1430,
              "tippigurmukhi",
              2672,
              "titlocyrilliccmb",
              1155,
              "tiwnarmenian",
              1407,
              "tlinebelow",
              7791,
              "tmonospace",
              65364,
              "toarmenian",
              1385,
              "tohiragana",
              12392,
              "tokatakana",
              12488,
              "tokatakanahalfwidth",
              65412,
              "tonebarextrahighmod",
              741,
              "tonebarextralowmod",
              745,
              "tonebarhighmod",
              742,
              "tonebarlowmod",
              744,
              "tonebarmidmod",
              743,
              "tonefive",
              445,
              "tonesix",
              389,
              "tonetwo",
              424,
              "tonos",
              900,
              "tonsquare",
              13095,
              "topatakthai",
              3599,
              "tortoiseshellbracketleft",
              12308,
              "tortoiseshellbracketleftsmall",
              65117,
              "tortoiseshellbracketleftvertical",
              65081,
              "tortoiseshellbracketright",
              12309,
              "tortoiseshellbracketrightsmall",
              65118,
              "tortoiseshellbracketrightvertical",
              65082,
              "totaothai",
              3605,
              "tpalatalhook",
              427,
              "tparen",
              9391,
              "trademark",
              8482,
              "trademarksans",
              63722,
              "trademarkserif",
              63195,
              "tretroflexhook",
              648,
              "triagdn",
              9660,
              "triaglf",
              9668,
              "triagrt",
              9658,
              "triagup",
              9650,
              "ts",
              678,
              "tsadi",
              1510,
              "tsadidagesh",
              64326,
              "tsadidageshhebrew",
              64326,
              "tsadihebrew",
              1510,
              "tsecyrillic",
              1094,
              "tsere",
              1461,
              "tsere12",
              1461,
              "tsere1e",
              1461,
              "tsere2b",
              1461,
              "tserehebrew",
              1461,
              "tserenarrowhebrew",
              1461,
              "tserequarterhebrew",
              1461,
              "tserewidehebrew",
              1461,
              "tshecyrillic",
              1115,
              "tsuperior",
              63219,
              "ttabengali",
              2463,
              "ttadeva",
              2335,
              "ttagujarati",
              2719,
              "ttagurmukhi",
              2591,
              "tteharabic",
              1657,
              "ttehfinalarabic",
              64359,
              "ttehinitialarabic",
              64360,
              "ttehmedialarabic",
              64361,
              "tthabengali",
              2464,
              "tthadeva",
              2336,
              "tthagujarati",
              2720,
              "tthagurmukhi",
              2592,
              "tturned",
              647,
              "tuhiragana",
              12388,
              "tukatakana",
              12484,
              "tukatakanahalfwidth",
              65410,
              "tusmallhiragana",
              12387,
              "tusmallkatakana",
              12483,
              "tusmallkatakanahalfwidth",
              65391,
              "twelvecircle",
              9323,
              "twelveparen",
              9343,
              "twelveperiod",
              9363,
              "twelveroman",
              8571,
              "twentycircle",
              9331,
              "twentyhangzhou",
              21316,
              "twentyparen",
              9351,
              "twentyperiod",
              9371,
              "two",
              50,
              "twoarabic",
              1634,
              "twobengali",
              2536,
              "twocircle",
              9313,
              "twocircleinversesansserif",
              10123,
              "twodeva",
              2408,
              "twodotenleader",
              8229,
              "twodotleader",
              8229,
              "twodotleadervertical",
              65072,
              "twogujarati",
              2792,
              "twogurmukhi",
              2664,
              "twohackarabic",
              1634,
              "twohangzhou",
              12322,
              "twoideographicparen",
              12833,
              "twoinferior",
              8322,
              "twomonospace",
              65298,
              "twonumeratorbengali",
              2549,
              "twooldstyle",
              63282,
              "twoparen",
              9333,
              "twoperiod",
              9353,
              "twopersian",
              1778,
              "tworoman",
              8561,
              "twostroke",
              443,
              "twosuperior",
              178,
              "twothai",
              3666,
              "twothirds",
              8532,
              "u",
              117,
              "uacute",
              250,
              "ubar",
              649,
              "ubengali",
              2441,
              "ubopomofo",
              12584,
              "ubreve",
              365,
              "ucaron",
              468,
              "ucircle",
              9444,
              "ucircumflex",
              251,
              "ucircumflexbelow",
              7799,
              "ucyrillic",
              1091,
              "udattadeva",
              2385,
              "udblacute",
              369,
              "udblgrave",
              533,
              "udeva",
              2313,
              "udieresis",
              252,
              "udieresisacute",
              472,
              "udieresisbelow",
              7795,
              "udieresiscaron",
              474,
              "udieresiscyrillic",
              1265,
              "udieresisgrave",
              476,
              "udieresismacron",
              470,
              "udotbelow",
              7909,
              "ugrave",
              249,
              "ugujarati",
              2697,
              "ugurmukhi",
              2569,
              "uhiragana",
              12358,
              "uhookabove",
              7911,
              "uhorn",
              432,
              "uhornacute",
              7913,
              "uhorndotbelow",
              7921,
              "uhorngrave",
              7915,
              "uhornhookabove",
              7917,
              "uhorntilde",
              7919,
              "uhungarumlaut",
              369,
              "uhungarumlautcyrillic",
              1267,
              "uinvertedbreve",
              535,
              "ukatakana",
              12454,
              "ukatakanahalfwidth",
              65395,
              "ukcyrillic",
              1145,
              "ukorean",
              12636,
              "umacron",
              363,
              "umacroncyrillic",
              1263,
              "umacrondieresis",
              7803,
              "umatragurmukhi",
              2625,
              "umonospace",
              65365,
              "underscore",
              95,
              "underscoredbl",
              8215,
              "underscoremonospace",
              65343,
              "underscorevertical",
              65075,
              "underscorewavy",
              65103,
              "union",
              8746,
              "universal",
              8704,
              "uogonek",
              371,
              "uparen",
              9392,
              "upblock",
              9600,
              "upperdothebrew",
              1476,
              "upsilon",
              965,
              "upsilondieresis",
              971,
              "upsilondieresistonos",
              944,
              "upsilonlatin",
              650,
              "upsilontonos",
              973,
              "uptackbelowcmb",
              797,
              "uptackmod",
              724,
              "uragurmukhi",
              2675,
              "uring",
              367,
              "ushortcyrillic",
              1118,
              "usmallhiragana",
              12357,
              "usmallkatakana",
              12453,
              "usmallkatakanahalfwidth",
              65385,
              "ustraightcyrillic",
              1199,
              "ustraightstrokecyrillic",
              1201,
              "utilde",
              361,
              "utildeacute",
              7801,
              "utildebelow",
              7797,
              "uubengali",
              2442,
              "uudeva",
              2314,
              "uugujarati",
              2698,
              "uugurmukhi",
              2570,
              "uumatragurmukhi",
              2626,
              "uuvowelsignbengali",
              2498,
              "uuvowelsigndeva",
              2370,
              "uuvowelsigngujarati",
              2754,
              "uvowelsignbengali",
              2497,
              "uvowelsigndeva",
              2369,
              "uvowelsigngujarati",
              2753,
              "v",
              118,
              "vadeva",
              2357,
              "vagujarati",
              2741,
              "vagurmukhi",
              2613,
              "vakatakana",
              12535,
              "vav",
              1493,
              "vavdagesh",
              64309,
              "vavdagesh65",
              64309,
              "vavdageshhebrew",
              64309,
              "vavhebrew",
              1493,
              "vavholam",
              64331,
              "vavholamhebrew",
              64331,
              "vavvavhebrew",
              1520,
              "vavyodhebrew",
              1521,
              "vcircle",
              9445,
              "vdotbelow",
              7807,
              "vecyrillic",
              1074,
              "veharabic",
              1700,
              "vehfinalarabic",
              64363,
              "vehinitialarabic",
              64364,
              "vehmedialarabic",
              64365,
              "vekatakana",
              12537,
              "venus",
              9792,
              "verticalbar",
              124,
              "verticallineabovecmb",
              781,
              "verticallinebelowcmb",
              809,
              "verticallinelowmod",
              716,
              "verticallinemod",
              712,
              "vewarmenian",
              1406,
              "vhook",
              651,
              "vikatakana",
              12536,
              "viramabengali",
              2509,
              "viramadeva",
              2381,
              "viramagujarati",
              2765,
              "visargabengali",
              2435,
              "visargadeva",
              2307,
              "visargagujarati",
              2691,
              "vmonospace",
              65366,
              "voarmenian",
              1400,
              "voicediterationhiragana",
              12446,
              "voicediterationkatakana",
              12542,
              "voicedmarkkana",
              12443,
              "voicedmarkkanahalfwidth",
              65438,
              "vokatakana",
              12538,
              "vparen",
              9393,
              "vtilde",
              7805,
              "vturned",
              652,
              "vuhiragana",
              12436,
              "vukatakana",
              12532,
              "w",
              119,
              "wacute",
              7811,
              "waekorean",
              12633,
              "wahiragana",
              12431,
              "wakatakana",
              12527,
              "wakatakanahalfwidth",
              65436,
              "wakorean",
              12632,
              "wasmallhiragana",
              12430,
              "wasmallkatakana",
              12526,
              "wattosquare",
              13143,
              "wavedash",
              12316,
              "wavyunderscorevertical",
              65076,
              "wawarabic",
              1608,
              "wawfinalarabic",
              65262,
              "wawhamzaabovearabic",
              1572,
              "wawhamzaabovefinalarabic",
              65158,
              "wbsquare",
              13277,
              "wcircle",
              9446,
              "wcircumflex",
              373,
              "wdieresis",
              7813,
              "wdotaccent",
              7815,
              "wdotbelow",
              7817,
              "wehiragana",
              12433,
              "weierstrass",
              8472,
              "wekatakana",
              12529,
              "wekorean",
              12638,
              "weokorean",
              12637,
              "wgrave",
              7809,
              "whitebullet",
              9702,
              "whitecircle",
              9675,
              "whitecircleinverse",
              9689,
              "whitecornerbracketleft",
              12302,
              "whitecornerbracketleftvertical",
              65091,
              "whitecornerbracketright",
              12303,
              "whitecornerbracketrightvertical",
              65092,
              "whitediamond",
              9671,
              "whitediamondcontainingblacksmalldiamond",
              9672,
              "whitedownpointingsmalltriangle",
              9663,
              "whitedownpointingtriangle",
              9661,
              "whiteleftpointingsmalltriangle",
              9667,
              "whiteleftpointingtriangle",
              9665,
              "whitelenticularbracketleft",
              12310,
              "whitelenticularbracketright",
              12311,
              "whiterightpointingsmalltriangle",
              9657,
              "whiterightpointingtriangle",
              9655,
              "whitesmallsquare",
              9643,
              "whitesmilingface",
              9786,
              "whitesquare",
              9633,
              "whitestar",
              9734,
              "whitetelephone",
              9743,
              "whitetortoiseshellbracketleft",
              12312,
              "whitetortoiseshellbracketright",
              12313,
              "whiteuppointingsmalltriangle",
              9653,
              "whiteuppointingtriangle",
              9651,
              "wihiragana",
              12432,
              "wikatakana",
              12528,
              "wikorean",
              12639,
              "wmonospace",
              65367,
              "wohiragana",
              12434,
              "wokatakana",
              12530,
              "wokatakanahalfwidth",
              65382,
              "won",
              8361,
              "wonmonospace",
              65510,
              "wowaenthai",
              3623,
              "wparen",
              9394,
              "wring",
              7832,
              "wsuperior",
              695,
              "wturned",
              653,
              "wynn",
              447,
              "x",
              120,
              "xabovecmb",
              829,
              "xbopomofo",
              12562,
              "xcircle",
              9447,
              "xdieresis",
              7821,
              "xdotaccent",
              7819,
              "xeharmenian",
              1389,
              "xi",
              958,
              "xmonospace",
              65368,
              "xparen",
              9395,
              "xsuperior",
              739,
              "y",
              121,
              "yaadosquare",
              13134,
              "yabengali",
              2479,
              "yacute",
              253,
              "yadeva",
              2351,
              "yaekorean",
              12626,
              "yagujarati",
              2735,
              "yagurmukhi",
              2607,
              "yahiragana",
              12420,
              "yakatakana",
              12516,
              "yakatakanahalfwidth",
              65428,
              "yakorean",
              12625,
              "yamakkanthai",
              3662,
              "yasmallhiragana",
              12419,
              "yasmallkatakana",
              12515,
              "yasmallkatakanahalfwidth",
              65388,
              "yatcyrillic",
              1123,
              "ycircle",
              9448,
              "ycircumflex",
              375,
              "ydieresis",
              255,
              "ydotaccent",
              7823,
              "ydotbelow",
              7925,
              "yeharabic",
              1610,
              "yehbarreearabic",
              1746,
              "yehbarreefinalarabic",
              64431,
              "yehfinalarabic",
              65266,
              "yehhamzaabovearabic",
              1574,
              "yehhamzaabovefinalarabic",
              65162,
              "yehhamzaaboveinitialarabic",
              65163,
              "yehhamzaabovemedialarabic",
              65164,
              "yehinitialarabic",
              65267,
              "yehmedialarabic",
              65268,
              "yehmeeminitialarabic",
              64733,
              "yehmeemisolatedarabic",
              64600,
              "yehnoonfinalarabic",
              64660,
              "yehthreedotsbelowarabic",
              1745,
              "yekorean",
              12630,
              "yen",
              165,
              "yenmonospace",
              65509,
              "yeokorean",
              12629,
              "yeorinhieuhkorean",
              12678,
              "yerahbenyomohebrew",
              1450,
              "yerahbenyomolefthebrew",
              1450,
              "yericyrillic",
              1099,
              "yerudieresiscyrillic",
              1273,
              "yesieungkorean",
              12673,
              "yesieungpansioskorean",
              12675,
              "yesieungsioskorean",
              12674,
              "yetivhebrew",
              1434,
              "ygrave",
              7923,
              "yhook",
              436,
              "yhookabove",
              7927,
              "yiarmenian",
              1397,
              "yicyrillic",
              1111,
              "yikorean",
              12642,
              "yinyang",
              9775,
              "yiwnarmenian",
              1410,
              "ymonospace",
              65369,
              "yod",
              1497,
              "yoddagesh",
              64313,
              "yoddageshhebrew",
              64313,
              "yodhebrew",
              1497,
              "yodyodhebrew",
              1522,
              "yodyodpatahhebrew",
              64287,
              "yohiragana",
              12424,
              "yoikorean",
              12681,
              "yokatakana",
              12520,
              "yokatakanahalfwidth",
              65430,
              "yokorean",
              12635,
              "yosmallhiragana",
              12423,
              "yosmallkatakana",
              12519,
              "yosmallkatakanahalfwidth",
              65390,
              "yotgreek",
              1011,
              "yoyaekorean",
              12680,
              "yoyakorean",
              12679,
              "yoyakthai",
              3618,
              "yoyingthai",
              3597,
              "yparen",
              9396,
              "ypogegrammeni",
              890,
              "ypogegrammenigreekcmb",
              837,
              "yr",
              422,
              "yring",
              7833,
              "ysuperior",
              696,
              "ytilde",
              7929,
              "yturned",
              654,
              "yuhiragana",
              12422,
              "yuikorean",
              12684,
              "yukatakana",
              12518,
              "yukatakanahalfwidth",
              65429,
              "yukorean",
              12640,
              "yusbigcyrillic",
              1131,
              "yusbigiotifiedcyrillic",
              1133,
              "yuslittlecyrillic",
              1127,
              "yuslittleiotifiedcyrillic",
              1129,
              "yusmallhiragana",
              12421,
              "yusmallkatakana",
              12517,
              "yusmallkatakanahalfwidth",
              65389,
              "yuyekorean",
              12683,
              "yuyeokorean",
              12682,
              "yyabengali",
              2527,
              "yyadeva",
              2399,
              "z",
              122,
              "zaarmenian",
              1382,
              "zacute",
              378,
              "zadeva",
              2395,
              "zagurmukhi",
              2651,
              "zaharabic",
              1592,
              "zahfinalarabic",
              65222,
              "zahinitialarabic",
              65223,
              "zahiragana",
              12374,
              "zahmedialarabic",
              65224,
              "zainarabic",
              1586,
              "zainfinalarabic",
              65200,
              "zakatakana",
              12470,
              "zaqefgadolhebrew",
              1429,
              "zaqefqatanhebrew",
              1428,
              "zarqahebrew",
              1432,
              "zayin",
              1494,
              "zayindagesh",
              64310,
              "zayindageshhebrew",
              64310,
              "zayinhebrew",
              1494,
              "zbopomofo",
              12567,
              "zcaron",
              382,
              "zcircle",
              9449,
              "zcircumflex",
              7825,
              "zcurl",
              657,
              "zdot",
              380,
              "zdotaccent",
              380,
              "zdotbelow",
              7827,
              "zecyrillic",
              1079,
              "zedescendercyrillic",
              1177,
              "zedieresiscyrillic",
              1247,
              "zehiragana",
              12380,
              "zekatakana",
              12476,
              "zero",
              48,
              "zeroarabic",
              1632,
              "zerobengali",
              2534,
              "zerodeva",
              2406,
              "zerogujarati",
              2790,
              "zerogurmukhi",
              2662,
              "zerohackarabic",
              1632,
              "zeroinferior",
              8320,
              "zeromonospace",
              65296,
              "zerooldstyle",
              63280,
              "zeropersian",
              1776,
              "zerosuperior",
              8304,
              "zerothai",
              3664,
              "zerowidthjoiner",
              65279,
              "zerowidthnonjoiner",
              8204,
              "zerowidthspace",
              8203,
              "zeta",
              950,
              "zhbopomofo",
              12563,
              "zhearmenian",
              1386,
              "zhebrevecyrillic",
              1218,
              "zhecyrillic",
              1078,
              "zhedescendercyrillic",
              1175,
              "zhedieresiscyrillic",
              1245,
              "zihiragana",
              12376,
              "zikatakana",
              12472,
              "zinorhebrew",
              1454,
              "zlinebelow",
              7829,
              "zmonospace",
              65370,
              "zohiragana",
              12382,
              "zokatakana",
              12478,
              "zparen",
              9397,
              "zretroflexhook",
              656,
              "zstroke",
              438,
              "zuhiragana",
              12378,
              "zukatakana",
              12474,
              ".notdef",
              0,
              "angbracketleftbig",
              9001,
              "angbracketleftBig",
              9001,
              "angbracketleftbigg",
              9001,
              "angbracketleftBigg",
              9001,
              "angbracketrightBig",
              9002,
              "angbracketrightbig",
              9002,
              "angbracketrightBigg",
              9002,
              "angbracketrightbigg",
              9002,
              "arrowhookleft",
              8618,
              "arrowhookright",
              8617,
              "arrowlefttophalf",
              8636,
              "arrowleftbothalf",
              8637,
              "arrownortheast",
              8599,
              "arrownorthwest",
              8598,
              "arrowrighttophalf",
              8640,
              "arrowrightbothalf",
              8641,
              "arrowsoutheast",
              8600,
              "arrowsouthwest",
              8601,
              "backslashbig",
              8726,
              "backslashBig",
              8726,
              "backslashBigg",
              8726,
              "backslashbigg",
              8726,
              "bardbl",
              8214,
              "bracehtipdownleft",
              65079,
              "bracehtipdownright",
              65079,
              "bracehtipupleft",
              65080,
              "bracehtipupright",
              65080,
              "braceleftBig",
              123,
              "braceleftbig",
              123,
              "braceleftbigg",
              123,
              "braceleftBigg",
              123,
              "bracerightBig",
              125,
              "bracerightbig",
              125,
              "bracerightbigg",
              125,
              "bracerightBigg",
              125,
              "bracketleftbig",
              91,
              "bracketleftBig",
              91,
              "bracketleftbigg",
              91,
              "bracketleftBigg",
              91,
              "bracketrightBig",
              93,
              "bracketrightbig",
              93,
              "bracketrightbigg",
              93,
              "bracketrightBigg",
              93,
              "ceilingleftbig",
              8968,
              "ceilingleftBig",
              8968,
              "ceilingleftBigg",
              8968,
              "ceilingleftbigg",
              8968,
              "ceilingrightbig",
              8969,
              "ceilingrightBig",
              8969,
              "ceilingrightbigg",
              8969,
              "ceilingrightBigg",
              8969,
              "circledotdisplay",
              8857,
              "circledottext",
              8857,
              "circlemultiplydisplay",
              8855,
              "circlemultiplytext",
              8855,
              "circleplusdisplay",
              8853,
              "circleplustext",
              8853,
              "contintegraldisplay",
              8750,
              "contintegraltext",
              8750,
              "coproductdisplay",
              8720,
              "coproducttext",
              8720,
              "floorleftBig",
              8970,
              "floorleftbig",
              8970,
              "floorleftbigg",
              8970,
              "floorleftBigg",
              8970,
              "floorrightbig",
              8971,
              "floorrightBig",
              8971,
              "floorrightBigg",
              8971,
              "floorrightbigg",
              8971,
              "hatwide",
              770,
              "hatwider",
              770,
              "hatwidest",
              770,
              "intercal",
              7488,
              "integraldisplay",
              8747,
              "integraltext",
              8747,
              "intersectiondisplay",
              8898,
              "intersectiontext",
              8898,
              "logicalanddisplay",
              8743,
              "logicalandtext",
              8743,
              "logicalordisplay",
              8744,
              "logicalortext",
              8744,
              "parenleftBig",
              40,
              "parenleftbig",
              40,
              "parenleftBigg",
              40,
              "parenleftbigg",
              40,
              "parenrightBig",
              41,
              "parenrightbig",
              41,
              "parenrightBigg",
              41,
              "parenrightbigg",
              41,
              "prime",
              8242,
              "productdisplay",
              8719,
              "producttext",
              8719,
              "radicalbig",
              8730,
              "radicalBig",
              8730,
              "radicalBigg",
              8730,
              "radicalbigg",
              8730,
              "radicalbt",
              8730,
              "radicaltp",
              8730,
              "radicalvertex",
              8730,
              "slashbig",
              47,
              "slashBig",
              47,
              "slashBigg",
              47,
              "slashbigg",
              47,
              "summationdisplay",
              8721,
              "summationtext",
              8721,
              "tildewide",
              732,
              "tildewider",
              732,
              "tildewidest",
              732,
              "uniondisplay",
              8899,
              "unionmultidisplay",
              8846,
              "unionmultitext",
              8846,
              "unionsqdisplay",
              8852,
              "unionsqtext",
              8852,
              "uniontext",
              8899,
              "vextenddouble",
              8741,
              "vextendsingle",
              8739
            ];
          }), v = (0, t.getArrayLookupTableFactory)(function() {
            return [
              "space",
              32,
              "a1",
              9985,
              "a2",
              9986,
              "a202",
              9987,
              "a3",
              9988,
              "a4",
              9742,
              "a5",
              9990,
              "a119",
              9991,
              "a118",
              9992,
              "a117",
              9993,
              "a11",
              9755,
              "a12",
              9758,
              "a13",
              9996,
              "a14",
              9997,
              "a15",
              9998,
              "a16",
              9999,
              "a105",
              1e4,
              "a17",
              10001,
              "a18",
              10002,
              "a19",
              10003,
              "a20",
              10004,
              "a21",
              10005,
              "a22",
              10006,
              "a23",
              10007,
              "a24",
              10008,
              "a25",
              10009,
              "a26",
              10010,
              "a27",
              10011,
              "a28",
              10012,
              "a6",
              10013,
              "a7",
              10014,
              "a8",
              10015,
              "a9",
              10016,
              "a10",
              10017,
              "a29",
              10018,
              "a30",
              10019,
              "a31",
              10020,
              "a32",
              10021,
              "a33",
              10022,
              "a34",
              10023,
              "a35",
              9733,
              "a36",
              10025,
              "a37",
              10026,
              "a38",
              10027,
              "a39",
              10028,
              "a40",
              10029,
              "a41",
              10030,
              "a42",
              10031,
              "a43",
              10032,
              "a44",
              10033,
              "a45",
              10034,
              "a46",
              10035,
              "a47",
              10036,
              "a48",
              10037,
              "a49",
              10038,
              "a50",
              10039,
              "a51",
              10040,
              "a52",
              10041,
              "a53",
              10042,
              "a54",
              10043,
              "a55",
              10044,
              "a56",
              10045,
              "a57",
              10046,
              "a58",
              10047,
              "a59",
              10048,
              "a60",
              10049,
              "a61",
              10050,
              "a62",
              10051,
              "a63",
              10052,
              "a64",
              10053,
              "a65",
              10054,
              "a66",
              10055,
              "a67",
              10056,
              "a68",
              10057,
              "a69",
              10058,
              "a70",
              10059,
              "a71",
              9679,
              "a72",
              10061,
              "a73",
              9632,
              "a74",
              10063,
              "a203",
              10064,
              "a75",
              10065,
              "a204",
              10066,
              "a76",
              9650,
              "a77",
              9660,
              "a78",
              9670,
              "a79",
              10070,
              "a81",
              9687,
              "a82",
              10072,
              "a83",
              10073,
              "a84",
              10074,
              "a97",
              10075,
              "a98",
              10076,
              "a99",
              10077,
              "a100",
              10078,
              "a101",
              10081,
              "a102",
              10082,
              "a103",
              10083,
              "a104",
              10084,
              "a106",
              10085,
              "a107",
              10086,
              "a108",
              10087,
              "a112",
              9827,
              "a111",
              9830,
              "a110",
              9829,
              "a109",
              9824,
              "a120",
              9312,
              "a121",
              9313,
              "a122",
              9314,
              "a123",
              9315,
              "a124",
              9316,
              "a125",
              9317,
              "a126",
              9318,
              "a127",
              9319,
              "a128",
              9320,
              "a129",
              9321,
              "a130",
              10102,
              "a131",
              10103,
              "a132",
              10104,
              "a133",
              10105,
              "a134",
              10106,
              "a135",
              10107,
              "a136",
              10108,
              "a137",
              10109,
              "a138",
              10110,
              "a139",
              10111,
              "a140",
              10112,
              "a141",
              10113,
              "a142",
              10114,
              "a143",
              10115,
              "a144",
              10116,
              "a145",
              10117,
              "a146",
              10118,
              "a147",
              10119,
              "a148",
              10120,
              "a149",
              10121,
              "a150",
              10122,
              "a151",
              10123,
              "a152",
              10124,
              "a153",
              10125,
              "a154",
              10126,
              "a155",
              10127,
              "a156",
              10128,
              "a157",
              10129,
              "a158",
              10130,
              "a159",
              10131,
              "a160",
              10132,
              "a161",
              8594,
              "a163",
              8596,
              "a164",
              8597,
              "a196",
              10136,
              "a165",
              10137,
              "a192",
              10138,
              "a166",
              10139,
              "a167",
              10140,
              "a168",
              10141,
              "a169",
              10142,
              "a170",
              10143,
              "a171",
              10144,
              "a172",
              10145,
              "a173",
              10146,
              "a162",
              10147,
              "a174",
              10148,
              "a175",
              10149,
              "a176",
              10150,
              "a177",
              10151,
              "a178",
              10152,
              "a179",
              10153,
              "a193",
              10154,
              "a180",
              10155,
              "a199",
              10156,
              "a181",
              10157,
              "a200",
              10158,
              "a182",
              10159,
              "a201",
              10161,
              "a183",
              10162,
              "a184",
              10163,
              "a197",
              10164,
              "a185",
              10165,
              "a194",
              10166,
              "a198",
              10167,
              "a186",
              10168,
              "a195",
              10169,
              "a187",
              10170,
              "a188",
              10171,
              "a189",
              10172,
              "a190",
              10173,
              "a191",
              10174,
              "a89",
              10088,
              "a90",
              10089,
              "a93",
              10090,
              "a94",
              10091,
              "a91",
              10092,
              "a92",
              10093,
              "a205",
              10094,
              "a85",
              10095,
              "a206",
              10096,
              "a86",
              10097,
              "a87",
              10098,
              "a88",
              10099,
              "a95",
              10100,
              "a96",
              10101,
              ".notdef",
              0
            ];
          });
        },
        /* 40 */
        /***/
        (Z, o, C) => {
          C.r(o), C.d(o, {
            /* harmony export */
            clearUnicodeCaches: () => (
              /* binding */
              i
            ),
            /* harmony export */
            getCharUnicodeCategory: () => (
              /* binding */
              n
            ),
            /* harmony export */
            getNormalizedUnicodes: () => (
              /* binding */
              d
            ),
            /* harmony export */
            getUnicodeForGlyph: () => (
              /* binding */
              h
            ),
            /* harmony export */
            getUnicodeRangeFor: () => (
              /* binding */
              y
            ),
            /* harmony export */
            mapSpecialUnicodeValues: () => (
              /* binding */
              v
            ),
            /* harmony export */
            reverseIfRtl: () => (
              /* binding */
              p
            )
            /* harmony export */
          });
          var t = C(6);
          const a = (0, t.getLookupTableFactory)(function(l) {
            l[63721] = 169, l[63193] = 169, l[63720] = 174, l[63194] = 174, l[63722] = 8482, l[63195] = 8482, l[63729] = 9127, l[63730] = 9128, l[63731] = 9129, l[63740] = 9131, l[63741] = 9132, l[63742] = 9133, l[63726] = 9121, l[63727] = 9122, l[63728] = 9123, l[63737] = 9124, l[63738] = 9125, l[63739] = 9126, l[63723] = 9115, l[63724] = 9116, l[63725] = 9117, l[63734] = 9118, l[63735] = 9119, l[63736] = 9120;
          });
          function v(l) {
            return l >= 65520 && l <= 65535 ? 0 : l >= 62976 && l <= 63743 ? a()[l] || l : l === 173 ? 45 : l;
          }
          function h(l, u) {
            let w = u[l];
            if (w !== void 0)
              return w;
            if (!l)
              return -1;
            if (l[0] === "u") {
              const _ = l.length;
              let b;
              if (_ === 7 && l[1] === "n" && l[2] === "i")
                b = l.substring(3);
              else if (_ >= 5 && _ <= 7)
                b = l.substring(1);
              else
                return -1;
              if (b === b.toUpperCase() && (w = parseInt(b, 16), w >= 0))
                return w;
            }
            return -1;
          }
          const e = [
            {
              begin: 0,
              end: 127
            },
            {
              begin: 128,
              end: 255
            },
            {
              begin: 256,
              end: 383
            },
            {
              begin: 384,
              end: 591
            },
            {
              begin: 592,
              end: 687
            },
            {
              begin: 688,
              end: 767
            },
            {
              begin: 768,
              end: 879
            },
            {
              begin: 880,
              end: 1023
            },
            {
              begin: 11392,
              end: 11519
            },
            {
              begin: 1024,
              end: 1279
            },
            {
              begin: 1328,
              end: 1423
            },
            {
              begin: 1424,
              end: 1535
            },
            {
              begin: 42240,
              end: 42559
            },
            {
              begin: 1536,
              end: 1791
            },
            {
              begin: 1984,
              end: 2047
            },
            {
              begin: 2304,
              end: 2431
            },
            {
              begin: 2432,
              end: 2559
            },
            {
              begin: 2560,
              end: 2687
            },
            {
              begin: 2688,
              end: 2815
            },
            {
              begin: 2816,
              end: 2943
            },
            {
              begin: 2944,
              end: 3071
            },
            {
              begin: 3072,
              end: 3199
            },
            {
              begin: 3200,
              end: 3327
            },
            {
              begin: 3328,
              end: 3455
            },
            {
              begin: 3584,
              end: 3711
            },
            {
              begin: 3712,
              end: 3839
            },
            {
              begin: 4256,
              end: 4351
            },
            {
              begin: 6912,
              end: 7039
            },
            {
              begin: 4352,
              end: 4607
            },
            {
              begin: 7680,
              end: 7935
            },
            {
              begin: 7936,
              end: 8191
            },
            {
              begin: 8192,
              end: 8303
            },
            {
              begin: 8304,
              end: 8351
            },
            {
              begin: 8352,
              end: 8399
            },
            {
              begin: 8400,
              end: 8447
            },
            {
              begin: 8448,
              end: 8527
            },
            {
              begin: 8528,
              end: 8591
            },
            {
              begin: 8592,
              end: 8703
            },
            {
              begin: 8704,
              end: 8959
            },
            {
              begin: 8960,
              end: 9215
            },
            {
              begin: 9216,
              end: 9279
            },
            {
              begin: 9280,
              end: 9311
            },
            {
              begin: 9312,
              end: 9471
            },
            {
              begin: 9472,
              end: 9599
            },
            {
              begin: 9600,
              end: 9631
            },
            {
              begin: 9632,
              end: 9727
            },
            {
              begin: 9728,
              end: 9983
            },
            {
              begin: 9984,
              end: 10175
            },
            {
              begin: 12288,
              end: 12351
            },
            {
              begin: 12352,
              end: 12447
            },
            {
              begin: 12448,
              end: 12543
            },
            {
              begin: 12544,
              end: 12591
            },
            {
              begin: 12592,
              end: 12687
            },
            {
              begin: 43072,
              end: 43135
            },
            {
              begin: 12800,
              end: 13055
            },
            {
              begin: 13056,
              end: 13311
            },
            {
              begin: 44032,
              end: 55215
            },
            {
              begin: 55296,
              end: 57343
            },
            {
              begin: 67840,
              end: 67871
            },
            {
              begin: 19968,
              end: 40959
            },
            {
              begin: 57344,
              end: 63743
            },
            {
              begin: 12736,
              end: 12783
            },
            {
              begin: 64256,
              end: 64335
            },
            {
              begin: 64336,
              end: 65023
            },
            {
              begin: 65056,
              end: 65071
            },
            {
              begin: 65040,
              end: 65055
            },
            {
              begin: 65104,
              end: 65135
            },
            {
              begin: 65136,
              end: 65279
            },
            {
              begin: 65280,
              end: 65519
            },
            {
              begin: 65520,
              end: 65535
            },
            {
              begin: 3840,
              end: 4095
            },
            {
              begin: 1792,
              end: 1871
            },
            {
              begin: 1920,
              end: 1983
            },
            {
              begin: 3456,
              end: 3583
            },
            {
              begin: 4096,
              end: 4255
            },
            {
              begin: 4608,
              end: 4991
            },
            {
              begin: 5024,
              end: 5119
            },
            {
              begin: 5120,
              end: 5759
            },
            {
              begin: 5760,
              end: 5791
            },
            {
              begin: 5792,
              end: 5887
            },
            {
              begin: 6016,
              end: 6143
            },
            {
              begin: 6144,
              end: 6319
            },
            {
              begin: 10240,
              end: 10495
            },
            {
              begin: 40960,
              end: 42127
            },
            {
              begin: 5888,
              end: 5919
            },
            {
              begin: 66304,
              end: 66351
            },
            {
              begin: 66352,
              end: 66383
            },
            {
              begin: 66560,
              end: 66639
            },
            {
              begin: 118784,
              end: 119039
            },
            {
              begin: 119808,
              end: 120831
            },
            {
              begin: 1044480,
              end: 1048573
            },
            {
              begin: 65024,
              end: 65039
            },
            {
              begin: 917504,
              end: 917631
            },
            {
              begin: 6400,
              end: 6479
            },
            {
              begin: 6480,
              end: 6527
            },
            {
              begin: 6528,
              end: 6623
            },
            {
              begin: 6656,
              end: 6687
            },
            {
              begin: 11264,
              end: 11359
            },
            {
              begin: 11568,
              end: 11647
            },
            {
              begin: 19904,
              end: 19967
            },
            {
              begin: 43008,
              end: 43055
            },
            {
              begin: 65536,
              end: 65663
            },
            {
              begin: 65856,
              end: 65935
            },
            {
              begin: 66432,
              end: 66463
            },
            {
              begin: 66464,
              end: 66527
            },
            {
              begin: 66640,
              end: 66687
            },
            {
              begin: 66688,
              end: 66735
            },
            {
              begin: 67584,
              end: 67647
            },
            {
              begin: 68096,
              end: 68191
            },
            {
              begin: 119552,
              end: 119647
            },
            {
              begin: 73728,
              end: 74751
            },
            {
              begin: 119648,
              end: 119679
            },
            {
              begin: 7040,
              end: 7103
            },
            {
              begin: 7168,
              end: 7247
            },
            {
              begin: 7248,
              end: 7295
            },
            {
              begin: 43136,
              end: 43231
            },
            {
              begin: 43264,
              end: 43311
            },
            {
              begin: 43312,
              end: 43359
            },
            {
              begin: 43520,
              end: 43615
            },
            {
              begin: 65936,
              end: 65999
            },
            {
              begin: 66e3,
              end: 66047
            },
            {
              begin: 66208,
              end: 66271
            },
            {
              begin: 127024,
              end: 127135
            }
          ];
          function y(l) {
            for (let u = 0, w = e.length; u < w; u++) {
              const _ = e[u];
              if (l >= _.begin && l < _.end)
                return u;
            }
            return -1;
          }
          function c(l) {
            let u = e[13];
            return l >= u.begin && l < u.end || (u = e[11], l >= u.begin && l < u.end);
          }
          const d = (0, t.getArrayLookupTableFactory)(function() {
            return [
              "¨",
              " ̈",
              "¯",
              " ̄",
              "´",
              " ́",
              "µ",
              "μ",
              "¸",
              " ̧",
              "Ĳ",
              "IJ",
              "ĳ",
              "ij",
              "Ŀ",
              "L·",
              "ŀ",
              "l·",
              "ŉ",
              "ʼn",
              "ſ",
              "s",
              "Ǆ",
              "DŽ",
              "ǅ",
              "Dž",
              "ǆ",
              "dž",
              "Ǉ",
              "LJ",
              "ǈ",
              "Lj",
              "ǉ",
              "lj",
              "Ǌ",
              "NJ",
              "ǋ",
              "Nj",
              "ǌ",
              "nj",
              "Ǳ",
              "DZ",
              "ǲ",
              "Dz",
              "ǳ",
              "dz",
              "˘",
              " ̆",
              "˙",
              " ̇",
              "˚",
              " ̊",
              "˛",
              " ̨",
              "˜",
              " ̃",
              "˝",
              " ̋",
              "ͺ",
              " ͅ",
              "΄",
              " ́",
              "ϐ",
              "β",
              "ϑ",
              "θ",
              "ϒ",
              "Υ",
              "ϕ",
              "φ",
              "ϖ",
              "π",
              "ϰ",
              "κ",
              "ϱ",
              "ρ",
              "ϲ",
              "ς",
              "ϴ",
              "Θ",
              "ϵ",
              "ε",
              "Ϲ",
              "Σ",
              "և",
              "եւ",
              "ٵ",
              "اٴ",
              "ٶ",
              "وٴ",
              "ٷ",
              "ۇٴ",
              "ٸ",
              "يٴ",
              "ำ",
              "ํา",
              "ຳ",
              "ໍາ",
              "ໜ",
              "ຫນ",
              "ໝ",
              "ຫມ",
              "ཷ",
              "ྲཱྀ",
              "ཹ",
              "ླཱྀ",
              "ẚ",
              "aʾ",
              "᾽",
              " ̓",
              "᾿",
              " ̓",
              "῀",
              " ͂",
              "῾",
              " ̔",
              " ",
              " ",
              " ",
              " ",
              " ",
              " ",
              " ",
              " ",
              " ",
              " ",
              " ",
              " ",
              " ",
              " ",
              " ",
              " ",
              "‗",
              " ̳",
              "․",
              ".",
              "‥",
              "..",
              "…",
              "...",
              "″",
              "′′",
              "‴",
              "′′′",
              "‶",
              "‵‵",
              "‷",
              "‵‵‵",
              "‼",
              "!!",
              "‾",
              " ̅",
              "⁇",
              "??",
              "⁈",
              "?!",
              "⁉",
              "!?",
              "⁗",
              "′′′′",
              " ",
              " ",
              "₨",
              "Rs",
              "℀",
              "a/c",
              "℁",
              "a/s",
              "℃",
              "°C",
              "℅",
              "c/o",
              "℆",
              "c/u",
              "ℇ",
              "Ɛ",
              "℉",
              "°F",
              "№",
              "No",
              "℡",
              "TEL",
              "ℵ",
              "א",
              "ℶ",
              "ב",
              "ℷ",
              "ג",
              "ℸ",
              "ד",
              "℻",
              "FAX",
              "Ⅰ",
              "I",
              "Ⅱ",
              "II",
              "Ⅲ",
              "III",
              "Ⅳ",
              "IV",
              "Ⅴ",
              "V",
              "Ⅵ",
              "VI",
              "Ⅶ",
              "VII",
              "Ⅷ",
              "VIII",
              "Ⅸ",
              "IX",
              "Ⅹ",
              "X",
              "Ⅺ",
              "XI",
              "Ⅻ",
              "XII",
              "Ⅼ",
              "L",
              "Ⅽ",
              "C",
              "Ⅾ",
              "D",
              "Ⅿ",
              "M",
              "ⅰ",
              "i",
              "ⅱ",
              "ii",
              "ⅲ",
              "iii",
              "ⅳ",
              "iv",
              "ⅴ",
              "v",
              "ⅵ",
              "vi",
              "ⅶ",
              "vii",
              "ⅷ",
              "viii",
              "ⅸ",
              "ix",
              "ⅹ",
              "x",
              "ⅺ",
              "xi",
              "ⅻ",
              "xii",
              "ⅼ",
              "l",
              "ⅽ",
              "c",
              "ⅾ",
              "d",
              "ⅿ",
              "m",
              "∬",
              "∫∫",
              "∭",
              "∫∫∫",
              "∯",
              "∮∮",
              "∰",
              "∮∮∮",
              "⑴",
              "(1)",
              "⑵",
              "(2)",
              "⑶",
              "(3)",
              "⑷",
              "(4)",
              "⑸",
              "(5)",
              "⑹",
              "(6)",
              "⑺",
              "(7)",
              "⑻",
              "(8)",
              "⑼",
              "(9)",
              "⑽",
              "(10)",
              "⑾",
              "(11)",
              "⑿",
              "(12)",
              "⒀",
              "(13)",
              "⒁",
              "(14)",
              "⒂",
              "(15)",
              "⒃",
              "(16)",
              "⒄",
              "(17)",
              "⒅",
              "(18)",
              "⒆",
              "(19)",
              "⒇",
              "(20)",
              "⒈",
              "1.",
              "⒉",
              "2.",
              "⒊",
              "3.",
              "⒋",
              "4.",
              "⒌",
              "5.",
              "⒍",
              "6.",
              "⒎",
              "7.",
              "⒏",
              "8.",
              "⒐",
              "9.",
              "⒑",
              "10.",
              "⒒",
              "11.",
              "⒓",
              "12.",
              "⒔",
              "13.",
              "⒕",
              "14.",
              "⒖",
              "15.",
              "⒗",
              "16.",
              "⒘",
              "17.",
              "⒙",
              "18.",
              "⒚",
              "19.",
              "⒛",
              "20.",
              "⒜",
              "(a)",
              "⒝",
              "(b)",
              "⒞",
              "(c)",
              "⒟",
              "(d)",
              "⒠",
              "(e)",
              "⒡",
              "(f)",
              "⒢",
              "(g)",
              "⒣",
              "(h)",
              "⒤",
              "(i)",
              "⒥",
              "(j)",
              "⒦",
              "(k)",
              "⒧",
              "(l)",
              "⒨",
              "(m)",
              "⒩",
              "(n)",
              "⒪",
              "(o)",
              "⒫",
              "(p)",
              "⒬",
              "(q)",
              "⒭",
              "(r)",
              "⒮",
              "(s)",
              "⒯",
              "(t)",
              "⒰",
              "(u)",
              "⒱",
              "(v)",
              "⒲",
              "(w)",
              "⒳",
              "(x)",
              "⒴",
              "(y)",
              "⒵",
              "(z)",
              "⨌",
              "∫∫∫∫",
              "⩴",
              "::=",
              "⩵",
              "==",
              "⩶",
              "===",
              "⺟",
              "母",
              "⻳",
              "龟",
              "⼀",
              "一",
              "⼁",
              "丨",
              "⼂",
              "丶",
              "⼃",
              "丿",
              "⼄",
              "乙",
              "⼅",
              "亅",
              "⼆",
              "二",
              "⼇",
              "亠",
              "⼈",
              "人",
              "⼉",
              "儿",
              "⼊",
              "入",
              "⼋",
              "八",
              "⼌",
              "冂",
              "⼍",
              "冖",
              "⼎",
              "冫",
              "⼏",
              "几",
              "⼐",
              "凵",
              "⼑",
              "刀",
              "⼒",
              "力",
              "⼓",
              "勹",
              "⼔",
              "匕",
              "⼕",
              "匚",
              "⼖",
              "匸",
              "⼗",
              "十",
              "⼘",
              "卜",
              "⼙",
              "卩",
              "⼚",
              "厂",
              "⼛",
              "厶",
              "⼜",
              "又",
              "⼝",
              "口",
              "⼞",
              "囗",
              "⼟",
              "土",
              "⼠",
              "士",
              "⼡",
              "夂",
              "⼢",
              "夊",
              "⼣",
              "夕",
              "⼤",
              "大",
              "⼥",
              "女",
              "⼦",
              "子",
              "⼧",
              "宀",
              "⼨",
              "寸",
              "⼩",
              "小",
              "⼪",
              "尢",
              "⼫",
              "尸",
              "⼬",
              "屮",
              "⼭",
              "山",
              "⼮",
              "巛",
              "⼯",
              "工",
              "⼰",
              "己",
              "⼱",
              "巾",
              "⼲",
              "干",
              "⼳",
              "幺",
              "⼴",
              "广",
              "⼵",
              "廴",
              "⼶",
              "廾",
              "⼷",
              "弋",
              "⼸",
              "弓",
              "⼹",
              "彐",
              "⼺",
              "彡",
              "⼻",
              "彳",
              "⼼",
              "心",
              "⼽",
              "戈",
              "⼾",
              "戶",
              "⼿",
              "手",
              "⽀",
              "支",
              "⽁",
              "攴",
              "⽂",
              "文",
              "⽃",
              "斗",
              "⽄",
              "斤",
              "⽅",
              "方",
              "⽆",
              "无",
              "⽇",
              "日",
              "⽈",
              "曰",
              "⽉",
              "月",
              "⽊",
              "木",
              "⽋",
              "欠",
              "⽌",
              "止",
              "⽍",
              "歹",
              "⽎",
              "殳",
              "⽏",
              "毋",
              "⽐",
              "比",
              "⽑",
              "毛",
              "⽒",
              "氏",
              "⽓",
              "气",
              "⽔",
              "水",
              "⽕",
              "火",
              "⽖",
              "爪",
              "⽗",
              "父",
              "⽘",
              "爻",
              "⽙",
              "爿",
              "⽚",
              "片",
              "⽛",
              "牙",
              "⽜",
              "牛",
              "⽝",
              "犬",
              "⽞",
              "玄",
              "⽟",
              "玉",
              "⽠",
              "瓜",
              "⽡",
              "瓦",
              "⽢",
              "甘",
              "⽣",
              "生",
              "⽤",
              "用",
              "⽥",
              "田",
              "⽦",
              "疋",
              "⽧",
              "疒",
              "⽨",
              "癶",
              "⽩",
              "白",
              "⽪",
              "皮",
              "⽫",
              "皿",
              "⽬",
              "目",
              "⽭",
              "矛",
              "⽮",
              "矢",
              "⽯",
              "石",
              "⽰",
              "示",
              "⽱",
              "禸",
              "⽲",
              "禾",
              "⽳",
              "穴",
              "⽴",
              "立",
              "⽵",
              "竹",
              "⽶",
              "米",
              "⽷",
              "糸",
              "⽸",
              "缶",
              "⽹",
              "网",
              "⽺",
              "羊",
              "⽻",
              "羽",
              "⽼",
              "老",
              "⽽",
              "而",
              "⽾",
              "耒",
              "⽿",
              "耳",
              "⾀",
              "聿",
              "⾁",
              "肉",
              "⾂",
              "臣",
              "⾃",
              "自",
              "⾄",
              "至",
              "⾅",
              "臼",
              "⾆",
              "舌",
              "⾇",
              "舛",
              "⾈",
              "舟",
              "⾉",
              "艮",
              "⾊",
              "色",
              "⾋",
              "艸",
              "⾌",
              "虍",
              "⾍",
              "虫",
              "⾎",
              "血",
              "⾏",
              "行",
              "⾐",
              "衣",
              "⾑",
              "襾",
              "⾒",
              "見",
              "⾓",
              "角",
              "⾔",
              "言",
              "⾕",
              "谷",
              "⾖",
              "豆",
              "⾗",
              "豕",
              "⾘",
              "豸",
              "⾙",
              "貝",
              "⾚",
              "赤",
              "⾛",
              "走",
              "⾜",
              "足",
              "⾝",
              "身",
              "⾞",
              "車",
              "⾟",
              "辛",
              "⾠",
              "辰",
              "⾡",
              "辵",
              "⾢",
              "邑",
              "⾣",
              "酉",
              "⾤",
              "釆",
              "⾥",
              "里",
              "⾦",
              "金",
              "⾧",
              "長",
              "⾨",
              "門",
              "⾩",
              "阜",
              "⾪",
              "隶",
              "⾫",
              "隹",
              "⾬",
              "雨",
              "⾭",
              "靑",
              "⾮",
              "非",
              "⾯",
              "面",
              "⾰",
              "革",
              "⾱",
              "韋",
              "⾲",
              "韭",
              "⾳",
              "音",
              "⾴",
              "頁",
              "⾵",
              "風",
              "⾶",
              "飛",
              "⾷",
              "食",
              "⾸",
              "首",
              "⾹",
              "香",
              "⾺",
              "馬",
              "⾻",
              "骨",
              "⾼",
              "高",
              "⾽",
              "髟",
              "⾾",
              "鬥",
              "⾿",
              "鬯",
              "⿀",
              "鬲",
              "⿁",
              "鬼",
              "⿂",
              "魚",
              "⿃",
              "鳥",
              "⿄",
              "鹵",
              "⿅",
              "鹿",
              "⿆",
              "麥",
              "⿇",
              "麻",
              "⿈",
              "黃",
              "⿉",
              "黍",
              "⿊",
              "黑",
              "⿋",
              "黹",
              "⿌",
              "黽",
              "⿍",
              "鼎",
              "⿎",
              "鼓",
              "⿏",
              "鼠",
              "⿐",
              "鼻",
              "⿑",
              "齊",
              "⿒",
              "齒",
              "⿓",
              "龍",
              "⿔",
              "龜",
              "⿕",
              "龠",
              "〶",
              "〒",
              "〸",
              "十",
              "〹",
              "卄",
              "〺",
              "卅",
              "゛",
              " ゙",
              "゜",
              " ゚",
              "ㄱ",
              "ᄀ",
              "ㄲ",
              "ᄁ",
              "ㄳ",
              "ᆪ",
              "ㄴ",
              "ᄂ",
              "ㄵ",
              "ᆬ",
              "ㄶ",
              "ᆭ",
              "ㄷ",
              "ᄃ",
              "ㄸ",
              "ᄄ",
              "ㄹ",
              "ᄅ",
              "ㄺ",
              "ᆰ",
              "ㄻ",
              "ᆱ",
              "ㄼ",
              "ᆲ",
              "ㄽ",
              "ᆳ",
              "ㄾ",
              "ᆴ",
              "ㄿ",
              "ᆵ",
              "ㅀ",
              "ᄚ",
              "ㅁ",
              "ᄆ",
              "ㅂ",
              "ᄇ",
              "ㅃ",
              "ᄈ",
              "ㅄ",
              "ᄡ",
              "ㅅ",
              "ᄉ",
              "ㅆ",
              "ᄊ",
              "ㅇ",
              "ᄋ",
              "ㅈ",
              "ᄌ",
              "ㅉ",
              "ᄍ",
              "ㅊ",
              "ᄎ",
              "ㅋ",
              "ᄏ",
              "ㅌ",
              "ᄐ",
              "ㅍ",
              "ᄑ",
              "ㅎ",
              "ᄒ",
              "ㅏ",
              "ᅡ",
              "ㅐ",
              "ᅢ",
              "ㅑ",
              "ᅣ",
              "ㅒ",
              "ᅤ",
              "ㅓ",
              "ᅥ",
              "ㅔ",
              "ᅦ",
              "ㅕ",
              "ᅧ",
              "ㅖ",
              "ᅨ",
              "ㅗ",
              "ᅩ",
              "ㅘ",
              "ᅪ",
              "ㅙ",
              "ᅫ",
              "ㅚ",
              "ᅬ",
              "ㅛ",
              "ᅭ",
              "ㅜ",
              "ᅮ",
              "ㅝ",
              "ᅯ",
              "ㅞ",
              "ᅰ",
              "ㅟ",
              "ᅱ",
              "ㅠ",
              "ᅲ",
              "ㅡ",
              "ᅳ",
              "ㅢ",
              "ᅴ",
              "ㅣ",
              "ᅵ",
              "ㅤ",
              "ᅠ",
              "ㅥ",
              "ᄔ",
              "ㅦ",
              "ᄕ",
              "ㅧ",
              "ᇇ",
              "ㅨ",
              "ᇈ",
              "ㅩ",
              "ᇌ",
              "ㅪ",
              "ᇎ",
              "ㅫ",
              "ᇓ",
              "ㅬ",
              "ᇗ",
              "ㅭ",
              "ᇙ",
              "ㅮ",
              "ᄜ",
              "ㅯ",
              "ᇝ",
              "ㅰ",
              "ᇟ",
              "ㅱ",
              "ᄝ",
              "ㅲ",
              "ᄞ",
              "ㅳ",
              "ᄠ",
              "ㅴ",
              "ᄢ",
              "ㅵ",
              "ᄣ",
              "ㅶ",
              "ᄧ",
              "ㅷ",
              "ᄩ",
              "ㅸ",
              "ᄫ",
              "ㅹ",
              "ᄬ",
              "ㅺ",
              "ᄭ",
              "ㅻ",
              "ᄮ",
              "ㅼ",
              "ᄯ",
              "ㅽ",
              "ᄲ",
              "ㅾ",
              "ᄶ",
              "ㅿ",
              "ᅀ",
              "ㆀ",
              "ᅇ",
              "ㆁ",
              "ᅌ",
              "ㆂ",
              "ᇱ",
              "ㆃ",
              "ᇲ",
              "ㆄ",
              "ᅗ",
              "ㆅ",
              "ᅘ",
              "ㆆ",
              "ᅙ",
              "ㆇ",
              "ᆄ",
              "ㆈ",
              "ᆅ",
              "ㆉ",
              "ᆈ",
              "ㆊ",
              "ᆑ",
              "ㆋ",
              "ᆒ",
              "ㆌ",
              "ᆔ",
              "ㆍ",
              "ᆞ",
              "ㆎ",
              "ᆡ",
              "㈀",
              "(ᄀ)",
              "㈁",
              "(ᄂ)",
              "㈂",
              "(ᄃ)",
              "㈃",
              "(ᄅ)",
              "㈄",
              "(ᄆ)",
              "㈅",
              "(ᄇ)",
              "㈆",
              "(ᄉ)",
              "㈇",
              "(ᄋ)",
              "㈈",
              "(ᄌ)",
              "㈉",
              "(ᄎ)",
              "㈊",
              "(ᄏ)",
              "㈋",
              "(ᄐ)",
              "㈌",
              "(ᄑ)",
              "㈍",
              "(ᄒ)",
              "㈎",
              "(가)",
              "㈏",
              "(나)",
              "㈐",
              "(다)",
              "㈑",
              "(라)",
              "㈒",
              "(마)",
              "㈓",
              "(바)",
              "㈔",
              "(사)",
              "㈕",
              "(아)",
              "㈖",
              "(자)",
              "㈗",
              "(차)",
              "㈘",
              "(카)",
              "㈙",
              "(타)",
              "㈚",
              "(파)",
              "㈛",
              "(하)",
              "㈜",
              "(주)",
              "㈝",
              "(오전)",
              "㈞",
              "(오후)",
              "㈠",
              "(一)",
              "㈡",
              "(二)",
              "㈢",
              "(三)",
              "㈣",
              "(四)",
              "㈤",
              "(五)",
              "㈥",
              "(六)",
              "㈦",
              "(七)",
              "㈧",
              "(八)",
              "㈨",
              "(九)",
              "㈩",
              "(十)",
              "㈪",
              "(月)",
              "㈫",
              "(火)",
              "㈬",
              "(水)",
              "㈭",
              "(木)",
              "㈮",
              "(金)",
              "㈯",
              "(土)",
              "㈰",
              "(日)",
              "㈱",
              "(株)",
              "㈲",
              "(有)",
              "㈳",
              "(社)",
              "㈴",
              "(名)",
              "㈵",
              "(特)",
              "㈶",
              "(財)",
              "㈷",
              "(祝)",
              "㈸",
              "(労)",
              "㈹",
              "(代)",
              "㈺",
              "(呼)",
              "㈻",
              "(学)",
              "㈼",
              "(監)",
              "㈽",
              "(企)",
              "㈾",
              "(資)",
              "㈿",
              "(協)",
              "㉀",
              "(祭)",
              "㉁",
              "(休)",
              "㉂",
              "(自)",
              "㉃",
              "(至)",
              "㋀",
              "1月",
              "㋁",
              "2月",
              "㋂",
              "3月",
              "㋃",
              "4月",
              "㋄",
              "5月",
              "㋅",
              "6月",
              "㋆",
              "7月",
              "㋇",
              "8月",
              "㋈",
              "9月",
              "㋉",
              "10月",
              "㋊",
              "11月",
              "㋋",
              "12月",
              "㍘",
              "0点",
              "㍙",
              "1点",
              "㍚",
              "2点",
              "㍛",
              "3点",
              "㍜",
              "4点",
              "㍝",
              "5点",
              "㍞",
              "6点",
              "㍟",
              "7点",
              "㍠",
              "8点",
              "㍡",
              "9点",
              "㍢",
              "10点",
              "㍣",
              "11点",
              "㍤",
              "12点",
              "㍥",
              "13点",
              "㍦",
              "14点",
              "㍧",
              "15点",
              "㍨",
              "16点",
              "㍩",
              "17点",
              "㍪",
              "18点",
              "㍫",
              "19点",
              "㍬",
              "20点",
              "㍭",
              "21点",
              "㍮",
              "22点",
              "㍯",
              "23点",
              "㍰",
              "24点",
              "㏠",
              "1日",
              "㏡",
              "2日",
              "㏢",
              "3日",
              "㏣",
              "4日",
              "㏤",
              "5日",
              "㏥",
              "6日",
              "㏦",
              "7日",
              "㏧",
              "8日",
              "㏨",
              "9日",
              "㏩",
              "10日",
              "㏪",
              "11日",
              "㏫",
              "12日",
              "㏬",
              "13日",
              "㏭",
              "14日",
              "㏮",
              "15日",
              "㏯",
              "16日",
              "㏰",
              "17日",
              "㏱",
              "18日",
              "㏲",
              "19日",
              "㏳",
              "20日",
              "㏴",
              "21日",
              "㏵",
              "22日",
              "㏶",
              "23日",
              "㏷",
              "24日",
              "㏸",
              "25日",
              "㏹",
              "26日",
              "㏺",
              "27日",
              "㏻",
              "28日",
              "㏼",
              "29日",
              "㏽",
              "30日",
              "㏾",
              "31日",
              "ﬀ",
              "ff",
              "ﬁ",
              "fi",
              "ﬂ",
              "fl",
              "ﬃ",
              "ffi",
              "ﬄ",
              "ffl",
              "ﬅ",
              "ſt",
              "ﬆ",
              "st",
              "ﬓ",
              "մն",
              "ﬔ",
              "մե",
              "ﬕ",
              "մի",
              "ﬖ",
              "վն",
              "ﬗ",
              "մխ",
              "ﭏ",
              "אל",
              "ﭐ",
              "ٱ",
              "ﭑ",
              "ٱ",
              "ﭒ",
              "ٻ",
              "ﭓ",
              "ٻ",
              "ﭔ",
              "ٻ",
              "ﭕ",
              "ٻ",
              "ﭖ",
              "پ",
              "ﭗ",
              "پ",
              "ﭘ",
              "پ",
              "ﭙ",
              "پ",
              "ﭚ",
              "ڀ",
              "ﭛ",
              "ڀ",
              "ﭜ",
              "ڀ",
              "ﭝ",
              "ڀ",
              "ﭞ",
              "ٺ",
              "ﭟ",
              "ٺ",
              "ﭠ",
              "ٺ",
              "ﭡ",
              "ٺ",
              "ﭢ",
              "ٿ",
              "ﭣ",
              "ٿ",
              "ﭤ",
              "ٿ",
              "ﭥ",
              "ٿ",
              "ﭦ",
              "ٹ",
              "ﭧ",
              "ٹ",
              "ﭨ",
              "ٹ",
              "ﭩ",
              "ٹ",
              "ﭪ",
              "ڤ",
              "ﭫ",
              "ڤ",
              "ﭬ",
              "ڤ",
              "ﭭ",
              "ڤ",
              "ﭮ",
              "ڦ",
              "ﭯ",
              "ڦ",
              "ﭰ",
              "ڦ",
              "ﭱ",
              "ڦ",
              "ﭲ",
              "ڄ",
              "ﭳ",
              "ڄ",
              "ﭴ",
              "ڄ",
              "ﭵ",
              "ڄ",
              "ﭶ",
              "ڃ",
              "ﭷ",
              "ڃ",
              "ﭸ",
              "ڃ",
              "ﭹ",
              "ڃ",
              "ﭺ",
              "چ",
              "ﭻ",
              "چ",
              "ﭼ",
              "چ",
              "ﭽ",
              "چ",
              "ﭾ",
              "ڇ",
              "ﭿ",
              "ڇ",
              "ﮀ",
              "ڇ",
              "ﮁ",
              "ڇ",
              "ﮂ",
              "ڍ",
              "ﮃ",
              "ڍ",
              "ﮄ",
              "ڌ",
              "ﮅ",
              "ڌ",
              "ﮆ",
              "ڎ",
              "ﮇ",
              "ڎ",
              "ﮈ",
              "ڈ",
              "ﮉ",
              "ڈ",
              "ﮊ",
              "ژ",
              "ﮋ",
              "ژ",
              "ﮌ",
              "ڑ",
              "ﮍ",
              "ڑ",
              "ﮎ",
              "ک",
              "ﮏ",
              "ک",
              "ﮐ",
              "ک",
              "ﮑ",
              "ک",
              "ﮒ",
              "گ",
              "ﮓ",
              "گ",
              "ﮔ",
              "گ",
              "ﮕ",
              "گ",
              "ﮖ",
              "ڳ",
              "ﮗ",
              "ڳ",
              "ﮘ",
              "ڳ",
              "ﮙ",
              "ڳ",
              "ﮚ",
              "ڱ",
              "ﮛ",
              "ڱ",
              "ﮜ",
              "ڱ",
              "ﮝ",
              "ڱ",
              "ﮞ",
              "ں",
              "ﮟ",
              "ں",
              "ﮠ",
              "ڻ",
              "ﮡ",
              "ڻ",
              "ﮢ",
              "ڻ",
              "ﮣ",
              "ڻ",
              "ﮤ",
              "ۀ",
              "ﮥ",
              "ۀ",
              "ﮦ",
              "ہ",
              "ﮧ",
              "ہ",
              "ﮨ",
              "ہ",
              "ﮩ",
              "ہ",
              "ﮪ",
              "ھ",
              "ﮫ",
              "ھ",
              "ﮬ",
              "ھ",
              "ﮭ",
              "ھ",
              "ﮮ",
              "ے",
              "ﮯ",
              "ے",
              "ﮰ",
              "ۓ",
              "ﮱ",
              "ۓ",
              "ﯓ",
              "ڭ",
              "ﯔ",
              "ڭ",
              "ﯕ",
              "ڭ",
              "ﯖ",
              "ڭ",
              "ﯗ",
              "ۇ",
              "ﯘ",
              "ۇ",
              "ﯙ",
              "ۆ",
              "ﯚ",
              "ۆ",
              "ﯛ",
              "ۈ",
              "ﯜ",
              "ۈ",
              "ﯝ",
              "ٷ",
              "ﯞ",
              "ۋ",
              "ﯟ",
              "ۋ",
              "ﯠ",
              "ۅ",
              "ﯡ",
              "ۅ",
              "ﯢ",
              "ۉ",
              "ﯣ",
              "ۉ",
              "ﯤ",
              "ې",
              "ﯥ",
              "ې",
              "ﯦ",
              "ې",
              "ﯧ",
              "ې",
              "ﯨ",
              "ى",
              "ﯩ",
              "ى",
              "ﯪ",
              "ئا",
              "ﯫ",
              "ئا",
              "ﯬ",
              "ئە",
              "ﯭ",
              "ئە",
              "ﯮ",
              "ئو",
              "ﯯ",
              "ئو",
              "ﯰ",
              "ئۇ",
              "ﯱ",
              "ئۇ",
              "ﯲ",
              "ئۆ",
              "ﯳ",
              "ئۆ",
              "ﯴ",
              "ئۈ",
              "ﯵ",
              "ئۈ",
              "ﯶ",
              "ئې",
              "ﯷ",
              "ئې",
              "ﯸ",
              "ئې",
              "ﯹ",
              "ئى",
              "ﯺ",
              "ئى",
              "ﯻ",
              "ئى",
              "ﯼ",
              "ی",
              "ﯽ",
              "ی",
              "ﯾ",
              "ی",
              "ﯿ",
              "ی",
              "ﰀ",
              "ئج",
              "ﰁ",
              "ئح",
              "ﰂ",
              "ئم",
              "ﰃ",
              "ئى",
              "ﰄ",
              "ئي",
              "ﰅ",
              "بج",
              "ﰆ",
              "بح",
              "ﰇ",
              "بخ",
              "ﰈ",
              "بم",
              "ﰉ",
              "بى",
              "ﰊ",
              "بي",
              "ﰋ",
              "تج",
              "ﰌ",
              "تح",
              "ﰍ",
              "تخ",
              "ﰎ",
              "تم",
              "ﰏ",
              "تى",
              "ﰐ",
              "تي",
              "ﰑ",
              "ثج",
              "ﰒ",
              "ثم",
              "ﰓ",
              "ثى",
              "ﰔ",
              "ثي",
              "ﰕ",
              "جح",
              "ﰖ",
              "جم",
              "ﰗ",
              "حج",
              "ﰘ",
              "حم",
              "ﰙ",
              "خج",
              "ﰚ",
              "خح",
              "ﰛ",
              "خم",
              "ﰜ",
              "سج",
              "ﰝ",
              "سح",
              "ﰞ",
              "سخ",
              "ﰟ",
              "سم",
              "ﰠ",
              "صح",
              "ﰡ",
              "صم",
              "ﰢ",
              "ضج",
              "ﰣ",
              "ضح",
              "ﰤ",
              "ضخ",
              "ﰥ",
              "ضم",
              "ﰦ",
              "طح",
              "ﰧ",
              "طم",
              "ﰨ",
              "ظم",
              "ﰩ",
              "عج",
              "ﰪ",
              "عم",
              "ﰫ",
              "غج",
              "ﰬ",
              "غم",
              "ﰭ",
              "فج",
              "ﰮ",
              "فح",
              "ﰯ",
              "فخ",
              "ﰰ",
              "فم",
              "ﰱ",
              "فى",
              "ﰲ",
              "في",
              "ﰳ",
              "قح",
              "ﰴ",
              "قم",
              "ﰵ",
              "قى",
              "ﰶ",
              "قي",
              "ﰷ",
              "كا",
              "ﰸ",
              "كج",
              "ﰹ",
              "كح",
              "ﰺ",
              "كخ",
              "ﰻ",
              "كل",
              "ﰼ",
              "كم",
              "ﰽ",
              "كى",
              "ﰾ",
              "كي",
              "ﰿ",
              "لج",
              "ﱀ",
              "لح",
              "ﱁ",
              "لخ",
              "ﱂ",
              "لم",
              "ﱃ",
              "لى",
              "ﱄ",
              "لي",
              "ﱅ",
              "مج",
              "ﱆ",
              "مح",
              "ﱇ",
              "مخ",
              "ﱈ",
              "مم",
              "ﱉ",
              "مى",
              "ﱊ",
              "مي",
              "ﱋ",
              "نج",
              "ﱌ",
              "نح",
              "ﱍ",
              "نخ",
              "ﱎ",
              "نم",
              "ﱏ",
              "نى",
              "ﱐ",
              "ني",
              "ﱑ",
              "هج",
              "ﱒ",
              "هم",
              "ﱓ",
              "هى",
              "ﱔ",
              "هي",
              "ﱕ",
              "يج",
              "ﱖ",
              "يح",
              "ﱗ",
              "يخ",
              "ﱘ",
              "يم",
              "ﱙ",
              "يى",
              "ﱚ",
              "يي",
              "ﱛ",
              "ذٰ",
              "ﱜ",
              "رٰ",
              "ﱝ",
              "ىٰ",
              "ﱞ",
              " ٌّ",
              "ﱟ",
              " ٍّ",
              "ﱠ",
              " َّ",
              "ﱡ",
              " ُّ",
              "ﱢ",
              " ِّ",
              "ﱣ",
              " ّٰ",
              "ﱤ",
              "ئر",
              "ﱥ",
              "ئز",
              "ﱦ",
              "ئم",
              "ﱧ",
              "ئن",
              "ﱨ",
              "ئى",
              "ﱩ",
              "ئي",
              "ﱪ",
              "بر",
              "ﱫ",
              "بز",
              "ﱬ",
              "بم",
              "ﱭ",
              "بن",
              "ﱮ",
              "بى",
              "ﱯ",
              "بي",
              "ﱰ",
              "تر",
              "ﱱ",
              "تز",
              "ﱲ",
              "تم",
              "ﱳ",
              "تن",
              "ﱴ",
              "تى",
              "ﱵ",
              "تي",
              "ﱶ",
              "ثر",
              "ﱷ",
              "ثز",
              "ﱸ",
              "ثم",
              "ﱹ",
              "ثن",
              "ﱺ",
              "ثى",
              "ﱻ",
              "ثي",
              "ﱼ",
              "فى",
              "ﱽ",
              "في",
              "ﱾ",
              "قى",
              "ﱿ",
              "قي",
              "ﲀ",
              "كا",
              "ﲁ",
              "كل",
              "ﲂ",
              "كم",
              "ﲃ",
              "كى",
              "ﲄ",
              "كي",
              "ﲅ",
              "لم",
              "ﲆ",
              "لى",
              "ﲇ",
              "لي",
              "ﲈ",
              "ما",
              "ﲉ",
              "مم",
              "ﲊ",
              "نر",
              "ﲋ",
              "نز",
              "ﲌ",
              "نم",
              "ﲍ",
              "نن",
              "ﲎ",
              "نى",
              "ﲏ",
              "ني",
              "ﲐ",
              "ىٰ",
              "ﲑ",
              "ير",
              "ﲒ",
              "يز",
              "ﲓ",
              "يم",
              "ﲔ",
              "ين",
              "ﲕ",
              "يى",
              "ﲖ",
              "يي",
              "ﲗ",
              "ئج",
              "ﲘ",
              "ئح",
              "ﲙ",
              "ئخ",
              "ﲚ",
              "ئم",
              "ﲛ",
              "ئه",
              "ﲜ",
              "بج",
              "ﲝ",
              "بح",
              "ﲞ",
              "بخ",
              "ﲟ",
              "بم",
              "ﲠ",
              "به",
              "ﲡ",
              "تج",
              "ﲢ",
              "تح",
              "ﲣ",
              "تخ",
              "ﲤ",
              "تم",
              "ﲥ",
              "ته",
              "ﲦ",
              "ثم",
              "ﲧ",
              "جح",
              "ﲨ",
              "جم",
              "ﲩ",
              "حج",
              "ﲪ",
              "حم",
              "ﲫ",
              "خج",
              "ﲬ",
              "خم",
              "ﲭ",
              "سج",
              "ﲮ",
              "سح",
              "ﲯ",
              "سخ",
              "ﲰ",
              "سم",
              "ﲱ",
              "صح",
              "ﲲ",
              "صخ",
              "ﲳ",
              "صم",
              "ﲴ",
              "ضج",
              "ﲵ",
              "ضح",
              "ﲶ",
              "ضخ",
              "ﲷ",
              "ضم",
              "ﲸ",
              "طح",
              "ﲹ",
              "ظم",
              "ﲺ",
              "عج",
              "ﲻ",
              "عم",
              "ﲼ",
              "غج",
              "ﲽ",
              "غم",
              "ﲾ",
              "فج",
              "ﲿ",
              "فح",
              "ﳀ",
              "فخ",
              "ﳁ",
              "فم",
              "ﳂ",
              "قح",
              "ﳃ",
              "قم",
              "ﳄ",
              "كج",
              "ﳅ",
              "كح",
              "ﳆ",
              "كخ",
              "ﳇ",
              "كل",
              "ﳈ",
              "كم",
              "ﳉ",
              "لج",
              "ﳊ",
              "لح",
              "ﳋ",
              "لخ",
              "ﳌ",
              "لم",
              "ﳍ",
              "له",
              "ﳎ",
              "مج",
              "ﳏ",
              "مح",
              "ﳐ",
              "مخ",
              "ﳑ",
              "مم",
              "ﳒ",
              "نج",
              "ﳓ",
              "نح",
              "ﳔ",
              "نخ",
              "ﳕ",
              "نم",
              "ﳖ",
              "نه",
              "ﳗ",
              "هج",
              "ﳘ",
              "هم",
              "ﳙ",
              "هٰ",
              "ﳚ",
              "يج",
              "ﳛ",
              "يح",
              "ﳜ",
              "يخ",
              "ﳝ",
              "يم",
              "ﳞ",
              "يه",
              "ﳟ",
              "ئم",
              "ﳠ",
              "ئه",
              "ﳡ",
              "بم",
              "ﳢ",
              "به",
              "ﳣ",
              "تم",
              "ﳤ",
              "ته",
              "ﳥ",
              "ثم",
              "ﳦ",
              "ثه",
              "ﳧ",
              "سم",
              "ﳨ",
              "سه",
              "ﳩ",
              "شم",
              "ﳪ",
              "شه",
              "ﳫ",
              "كل",
              "ﳬ",
              "كم",
              "ﳭ",
              "لم",
              "ﳮ",
              "نم",
              "ﳯ",
              "نه",
              "ﳰ",
              "يم",
              "ﳱ",
              "يه",
              "ﳲ",
              "ـَّ",
              "ﳳ",
              "ـُّ",
              "ﳴ",
              "ـِّ",
              "ﳵ",
              "طى",
              "ﳶ",
              "طي",
              "ﳷ",
              "عى",
              "ﳸ",
              "عي",
              "ﳹ",
              "غى",
              "ﳺ",
              "غي",
              "ﳻ",
              "سى",
              "ﳼ",
              "سي",
              "ﳽ",
              "شى",
              "ﳾ",
              "شي",
              "ﳿ",
              "حى",
              "ﴀ",
              "حي",
              "ﴁ",
              "جى",
              "ﴂ",
              "جي",
              "ﴃ",
              "خى",
              "ﴄ",
              "خي",
              "ﴅ",
              "صى",
              "ﴆ",
              "صي",
              "ﴇ",
              "ضى",
              "ﴈ",
              "ضي",
              "ﴉ",
              "شج",
              "ﴊ",
              "شح",
              "ﴋ",
              "شخ",
              "ﴌ",
              "شم",
              "ﴍ",
              "شر",
              "ﴎ",
              "سر",
              "ﴏ",
              "صر",
              "ﴐ",
              "ضر",
              "ﴑ",
              "طى",
              "ﴒ",
              "طي",
              "ﴓ",
              "عى",
              "ﴔ",
              "عي",
              "ﴕ",
              "غى",
              "ﴖ",
              "غي",
              "ﴗ",
              "سى",
              "ﴘ",
              "سي",
              "ﴙ",
              "شى",
              "ﴚ",
              "شي",
              "ﴛ",
              "حى",
              "ﴜ",
              "حي",
              "ﴝ",
              "جى",
              "ﴞ",
              "جي",
              "ﴟ",
              "خى",
              "ﴠ",
              "خي",
              "ﴡ",
              "صى",
              "ﴢ",
              "صي",
              "ﴣ",
              "ضى",
              "ﴤ",
              "ضي",
              "ﴥ",
              "شج",
              "ﴦ",
              "شح",
              "ﴧ",
              "شخ",
              "ﴨ",
              "شم",
              "ﴩ",
              "شر",
              "ﴪ",
              "سر",
              "ﴫ",
              "صر",
              "ﴬ",
              "ضر",
              "ﴭ",
              "شج",
              "ﴮ",
              "شح",
              "ﴯ",
              "شخ",
              "ﴰ",
              "شم",
              "ﴱ",
              "سه",
              "ﴲ",
              "شه",
              "ﴳ",
              "طم",
              "ﴴ",
              "سج",
              "ﴵ",
              "سح",
              "ﴶ",
              "سخ",
              "ﴷ",
              "شج",
              "ﴸ",
              "شح",
              "ﴹ",
              "شخ",
              "ﴺ",
              "طم",
              "ﴻ",
              "ظم",
              "ﴼ",
              "اً",
              "ﴽ",
              "اً",
              "ﵐ",
              "تجم",
              "ﵑ",
              "تحج",
              "ﵒ",
              "تحج",
              "ﵓ",
              "تحم",
              "ﵔ",
              "تخم",
              "ﵕ",
              "تمج",
              "ﵖ",
              "تمح",
              "ﵗ",
              "تمخ",
              "ﵘ",
              "جمح",
              "ﵙ",
              "جمح",
              "ﵚ",
              "حمي",
              "ﵛ",
              "حمى",
              "ﵜ",
              "سحج",
              "ﵝ",
              "سجح",
              "ﵞ",
              "سجى",
              "ﵟ",
              "سمح",
              "ﵠ",
              "سمح",
              "ﵡ",
              "سمج",
              "ﵢ",
              "سمم",
              "ﵣ",
              "سمم",
              "ﵤ",
              "صحح",
              "ﵥ",
              "صحح",
              "ﵦ",
              "صمم",
              "ﵧ",
              "شحم",
              "ﵨ",
              "شحم",
              "ﵩ",
              "شجي",
              "ﵪ",
              "شمخ",
              "ﵫ",
              "شمخ",
              "ﵬ",
              "شمم",
              "ﵭ",
              "شمم",
              "ﵮ",
              "ضحى",
              "ﵯ",
              "ضخم",
              "ﵰ",
              "ضخم",
              "ﵱ",
              "طمح",
              "ﵲ",
              "طمح",
              "ﵳ",
              "طمم",
              "ﵴ",
              "طمي",
              "ﵵ",
              "عجم",
              "ﵶ",
              "عمم",
              "ﵷ",
              "عمم",
              "ﵸ",
              "عمى",
              "ﵹ",
              "غمم",
              "ﵺ",
              "غمي",
              "ﵻ",
              "غمى",
              "ﵼ",
              "فخم",
              "ﵽ",
              "فخم",
              "ﵾ",
              "قمح",
              "ﵿ",
              "قمم",
              "ﶀ",
              "لحم",
              "ﶁ",
              "لحي",
              "ﶂ",
              "لحى",
              "ﶃ",
              "لجج",
              "ﶄ",
              "لجج",
              "ﶅ",
              "لخم",
              "ﶆ",
              "لخم",
              "ﶇ",
              "لمح",
              "ﶈ",
              "لمح",
              "ﶉ",
              "محج",
              "ﶊ",
              "محم",
              "ﶋ",
              "محي",
              "ﶌ",
              "مجح",
              "ﶍ",
              "مجم",
              "ﶎ",
              "مخج",
              "ﶏ",
              "مخم",
              "ﶒ",
              "مجخ",
              "ﶓ",
              "همج",
              "ﶔ",
              "همم",
              "ﶕ",
              "نحم",
              "ﶖ",
              "نحى",
              "ﶗ",
              "نجم",
              "ﶘ",
              "نجم",
              "ﶙ",
              "نجى",
              "ﶚ",
              "نمي",
              "ﶛ",
              "نمى",
              "ﶜ",
              "يمم",
              "ﶝ",
              "يمم",
              "ﶞ",
              "بخي",
              "ﶟ",
              "تجي",
              "ﶠ",
              "تجى",
              "ﶡ",
              "تخي",
              "ﶢ",
              "تخى",
              "ﶣ",
              "تمي",
              "ﶤ",
              "تمى",
              "ﶥ",
              "جمي",
              "ﶦ",
              "جحى",
              "ﶧ",
              "جمى",
              "ﶨ",
              "سخى",
              "ﶩ",
              "صحي",
              "ﶪ",
              "شحي",
              "ﶫ",
              "ضحي",
              "ﶬ",
              "لجي",
              "ﶭ",
              "لمي",
              "ﶮ",
              "يحي",
              "ﶯ",
              "يجي",
              "ﶰ",
              "يمي",
              "ﶱ",
              "ممي",
              "ﶲ",
              "قمي",
              "ﶳ",
              "نحي",
              "ﶴ",
              "قمح",
              "ﶵ",
              "لحم",
              "ﶶ",
              "عمي",
              "ﶷ",
              "كمي",
              "ﶸ",
              "نجح",
              "ﶹ",
              "مخي",
              "ﶺ",
              "لجم",
              "ﶻ",
              "كمم",
              "ﶼ",
              "لجم",
              "ﶽ",
              "نجح",
              "ﶾ",
              "جحي",
              "ﶿ",
              "حجي",
              "ﷀ",
              "مجي",
              "ﷁ",
              "فمي",
              "ﷂ",
              "بحي",
              "ﷃ",
              "كمم",
              "ﷄ",
              "عجم",
              "ﷅ",
              "صمم",
              "ﷆ",
              "سخي",
              "ﷇ",
              "نجي",
              "﹉",
              "‾",
              "﹊",
              "‾",
              "﹋",
              "‾",
              "﹌",
              "‾",
              "﹍",
              "_",
              "﹎",
              "_",
              "﹏",
              "_",
              "ﺀ",
              "ء",
              "ﺁ",
              "آ",
              "ﺂ",
              "آ",
              "ﺃ",
              "أ",
              "ﺄ",
              "أ",
              "ﺅ",
              "ؤ",
              "ﺆ",
              "ؤ",
              "ﺇ",
              "إ",
              "ﺈ",
              "إ",
              "ﺉ",
              "ئ",
              "ﺊ",
              "ئ",
              "ﺋ",
              "ئ",
              "ﺌ",
              "ئ",
              "ﺍ",
              "ا",
              "ﺎ",
              "ا",
              "ﺏ",
              "ب",
              "ﺐ",
              "ب",
              "ﺑ",
              "ب",
              "ﺒ",
              "ب",
              "ﺓ",
              "ة",
              "ﺔ",
              "ة",
              "ﺕ",
              "ت",
              "ﺖ",
              "ت",
              "ﺗ",
              "ت",
              "ﺘ",
              "ت",
              "ﺙ",
              "ث",
              "ﺚ",
              "ث",
              "ﺛ",
              "ث",
              "ﺜ",
              "ث",
              "ﺝ",
              "ج",
              "ﺞ",
              "ج",
              "ﺟ",
              "ج",
              "ﺠ",
              "ج",
              "ﺡ",
              "ح",
              "ﺢ",
              "ح",
              "ﺣ",
              "ح",
              "ﺤ",
              "ح",
              "ﺥ",
              "خ",
              "ﺦ",
              "خ",
              "ﺧ",
              "خ",
              "ﺨ",
              "خ",
              "ﺩ",
              "د",
              "ﺪ",
              "د",
              "ﺫ",
              "ذ",
              "ﺬ",
              "ذ",
              "ﺭ",
              "ر",
              "ﺮ",
              "ر",
              "ﺯ",
              "ز",
              "ﺰ",
              "ز",
              "ﺱ",
              "س",
              "ﺲ",
              "س",
              "ﺳ",
              "س",
              "ﺴ",
              "س",
              "ﺵ",
              "ش",
              "ﺶ",
              "ش",
              "ﺷ",
              "ش",
              "ﺸ",
              "ش",
              "ﺹ",
              "ص",
              "ﺺ",
              "ص",
              "ﺻ",
              "ص",
              "ﺼ",
              "ص",
              "ﺽ",
              "ض",
              "ﺾ",
              "ض",
              "ﺿ",
              "ض",
              "ﻀ",
              "ض",
              "ﻁ",
              "ط",
              "ﻂ",
              "ط",
              "ﻃ",
              "ط",
              "ﻄ",
              "ط",
              "ﻅ",
              "ظ",
              "ﻆ",
              "ظ",
              "ﻇ",
              "ظ",
              "ﻈ",
              "ظ",
              "ﻉ",
              "ع",
              "ﻊ",
              "ع",
              "ﻋ",
              "ع",
              "ﻌ",
              "ع",
              "ﻍ",
              "غ",
              "ﻎ",
              "غ",
              "ﻏ",
              "غ",
              "ﻐ",
              "غ",
              "ﻑ",
              "ف",
              "ﻒ",
              "ف",
              "ﻓ",
              "ف",
              "ﻔ",
              "ف",
              "ﻕ",
              "ق",
              "ﻖ",
              "ق",
              "ﻗ",
              "ق",
              "ﻘ",
              "ق",
              "ﻙ",
              "ك",
              "ﻚ",
              "ك",
              "ﻛ",
              "ك",
              "ﻜ",
              "ك",
              "ﻝ",
              "ل",
              "ﻞ",
              "ل",
              "ﻟ",
              "ل",
              "ﻠ",
              "ل",
              "ﻡ",
              "م",
              "ﻢ",
              "م",
              "ﻣ",
              "م",
              "ﻤ",
              "م",
              "ﻥ",
              "ن",
              "ﻦ",
              "ن",
              "ﻧ",
              "ن",
              "ﻨ",
              "ن",
              "ﻩ",
              "ه",
              "ﻪ",
              "ه",
              "ﻫ",
              "ه",
              "ﻬ",
              "ه",
              "ﻭ",
              "و",
              "ﻮ",
              "و",
              "ﻯ",
              "ى",
              "ﻰ",
              "ى",
              "ﻱ",
              "ي",
              "ﻲ",
              "ي",
              "ﻳ",
              "ي",
              "ﻴ",
              "ي",
              "ﻵ",
              "لآ",
              "ﻶ",
              "لآ",
              "ﻷ",
              "لأ",
              "ﻸ",
              "لأ",
              "ﻹ",
              "لإ",
              "ﻺ",
              "لإ",
              "ﻻ",
              "لا",
              "ﻼ",
              "لا"
            ];
          });
          function p(l) {
            const u = l.length;
            if (u <= 1 || !c(l.charCodeAt(0)))
              return l;
            const w = [];
            for (let _ = u - 1; _ >= 0; _--)
              w.push(l[_]);
            return w.join("");
          }
          const m = new RegExp("^(\\s)|(\\p{Mn})|(\\p{Cf})$", "u"), g = /* @__PURE__ */ new Map();
          function n(l) {
            const u = g.get(l);
            if (u)
              return u;
            const w = l.match(m), _ = {
              isWhitespace: !!(w && w[1]),
              isZeroWidthDiacritic: !!(w && w[2]),
              isInvisibleFormatMark: !!(w && w[3])
            };
            return g.set(l, _), _;
          }
          function i() {
            g.clear();
          }
        },
        /* 41 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.getSerifFonts = o.getNonStdFontMap = o.getGlyphMapForStandardFonts = o.getFontNameToFileMap = void 0, o.getStandardFontName = g, o.getSymbolsFonts = o.getSupplementalGlyphMapForCalibri = o.getSupplementalGlyphMapForArialBlack = o.getStdFontMap = void 0;
          var t = C(6), a = C(38);
          const v = (0, t.getLookupTableFactory)(function(n) {
            n["Times-Roman"] = "Times-Roman", n.Helvetica = "Helvetica", n.Courier = "Courier", n.Symbol = "Symbol", n["Times-Bold"] = "Times-Bold", n["Helvetica-Bold"] = "Helvetica-Bold", n["Courier-Bold"] = "Courier-Bold", n.ZapfDingbats = "ZapfDingbats", n["Times-Italic"] = "Times-Italic", n["Helvetica-Oblique"] = "Helvetica-Oblique", n["Courier-Oblique"] = "Courier-Oblique", n["Times-BoldItalic"] = "Times-BoldItalic", n["Helvetica-BoldOblique"] = "Helvetica-BoldOblique", n["Courier-BoldOblique"] = "Courier-BoldOblique", n.ArialNarrow = "Helvetica", n["ArialNarrow-Bold"] = "Helvetica-Bold", n["ArialNarrow-BoldItalic"] = "Helvetica-BoldOblique", n["ArialNarrow-Italic"] = "Helvetica-Oblique", n.ArialBlack = "Helvetica", n["ArialBlack-Bold"] = "Helvetica-Bold", n["ArialBlack-BoldItalic"] = "Helvetica-BoldOblique", n["ArialBlack-Italic"] = "Helvetica-Oblique", n["Arial-Black"] = "Helvetica", n["Arial-Black-Bold"] = "Helvetica-Bold", n["Arial-Black-BoldItalic"] = "Helvetica-BoldOblique", n["Arial-Black-Italic"] = "Helvetica-Oblique", n.Arial = "Helvetica", n["Arial-Bold"] = "Helvetica-Bold", n["Arial-BoldItalic"] = "Helvetica-BoldOblique", n["Arial-Italic"] = "Helvetica-Oblique", n.ArialMT = "Helvetica", n["Arial-BoldItalicMT"] = "Helvetica-BoldOblique", n["Arial-BoldMT"] = "Helvetica-Bold", n["Arial-ItalicMT"] = "Helvetica-Oblique", n.ArialUnicodeMS = "Helvetica", n["ArialUnicodeMS-Bold"] = "Helvetica-Bold", n["ArialUnicodeMS-BoldItalic"] = "Helvetica-BoldOblique", n["ArialUnicodeMS-Italic"] = "Helvetica-Oblique", n["Courier-BoldItalic"] = "Courier-BoldOblique", n["Courier-Italic"] = "Courier-Oblique", n.CourierNew = "Courier", n["CourierNew-Bold"] = "Courier-Bold", n["CourierNew-BoldItalic"] = "Courier-BoldOblique", n["CourierNew-Italic"] = "Courier-Oblique", n["CourierNewPS-BoldItalicMT"] = "Courier-BoldOblique", n["CourierNewPS-BoldMT"] = "Courier-Bold", n["CourierNewPS-ItalicMT"] = "Courier-Oblique", n.CourierNewPSMT = "Courier", n["Helvetica-BoldItalic"] = "Helvetica-BoldOblique", n["Helvetica-Italic"] = "Helvetica-Oblique", n["Symbol-Bold"] = "Symbol", n["Symbol-BoldItalic"] = "Symbol", n["Symbol-Italic"] = "Symbol", n.TimesNewRoman = "Times-Roman", n["TimesNewRoman-Bold"] = "Times-Bold", n["TimesNewRoman-BoldItalic"] = "Times-BoldItalic", n["TimesNewRoman-Italic"] = "Times-Italic", n.TimesNewRomanPS = "Times-Roman", n["TimesNewRomanPS-Bold"] = "Times-Bold", n["TimesNewRomanPS-BoldItalic"] = "Times-BoldItalic", n["TimesNewRomanPS-BoldItalicMT"] = "Times-BoldItalic", n["TimesNewRomanPS-BoldMT"] = "Times-Bold", n["TimesNewRomanPS-Italic"] = "Times-Italic", n["TimesNewRomanPS-ItalicMT"] = "Times-Italic", n.TimesNewRomanPSMT = "Times-Roman", n["TimesNewRomanPSMT-Bold"] = "Times-Bold", n["TimesNewRomanPSMT-BoldItalic"] = "Times-BoldItalic", n["TimesNewRomanPSMT-Italic"] = "Times-Italic";
          });
          o.getStdFontMap = v;
          const h = (0, t.getLookupTableFactory)(function(n) {
            n.Courier = "FoxitFixed.pfb", n["Courier-Bold"] = "FoxitFixedBold.pfb", n["Courier-BoldOblique"] = "FoxitFixedBoldItalic.pfb", n["Courier-Oblique"] = "FoxitFixedItalic.pfb", n.Helvetica = "FoxitSans.pfb", n["Helvetica-Bold"] = "FoxitSansBold.pfb", n["Helvetica-BoldOblique"] = "FoxitSansBoldItalic.pfb", n["Helvetica-Oblique"] = "FoxitSansItalic.pfb", n["Times-Roman"] = "FoxitSerif.pfb", n["Times-Bold"] = "FoxitSerifBold.pfb", n["Times-BoldItalic"] = "FoxitSerifBoldItalic.pfb", n["Times-Italic"] = "FoxitSerifItalic.pfb", n.Symbol = "FoxitSymbol.pfb", n.ZapfDingbats = "FoxitDingbats.pfb", n["LiberationSans-Regular"] = "LiberationSans-Regular.ttf", n["LiberationSans-Bold"] = "LiberationSans-Bold.ttf", n["LiberationSans-Italic"] = "LiberationSans-Italic.ttf", n["LiberationSans-BoldItalic"] = "LiberationSans-BoldItalic.ttf";
          });
          o.getFontNameToFileMap = h;
          const e = (0, t.getLookupTableFactory)(function(n) {
            n.Calibri = "Helvetica", n["Calibri-Bold"] = "Helvetica-Bold", n["Calibri-BoldItalic"] = "Helvetica-BoldOblique", n["Calibri-Italic"] = "Helvetica-Oblique", n.CenturyGothic = "Helvetica", n["CenturyGothic-Bold"] = "Helvetica-Bold", n["CenturyGothic-BoldItalic"] = "Helvetica-BoldOblique", n["CenturyGothic-Italic"] = "Helvetica-Oblique", n.ComicSansMS = "Comic Sans MS", n["ComicSansMS-Bold"] = "Comic Sans MS-Bold", n["ComicSansMS-BoldItalic"] = "Comic Sans MS-BoldItalic", n["ComicSansMS-Italic"] = "Comic Sans MS-Italic", n["ItcSymbol-Bold"] = "Helvetica-Bold", n["ItcSymbol-BoldItalic"] = "Helvetica-BoldOblique", n["ItcSymbol-Book"] = "Helvetica", n["ItcSymbol-BookItalic"] = "Helvetica-Oblique", n["ItcSymbol-Medium"] = "Helvetica", n["ItcSymbol-MediumItalic"] = "Helvetica-Oblique", n.LucidaConsole = "Courier", n["LucidaConsole-Bold"] = "Courier-Bold", n["LucidaConsole-BoldItalic"] = "Courier-BoldOblique", n["LucidaConsole-Italic"] = "Courier-Oblique", n["LucidaSans-Demi"] = "Helvetica-Bold", n["MS-Gothic"] = "MS Gothic", n["MS-Gothic-Bold"] = "MS Gothic-Bold", n["MS-Gothic-BoldItalic"] = "MS Gothic-BoldItalic", n["MS-Gothic-Italic"] = "MS Gothic-Italic", n["MS-Mincho"] = "MS Mincho", n["MS-Mincho-Bold"] = "MS Mincho-Bold", n["MS-Mincho-BoldItalic"] = "MS Mincho-BoldItalic", n["MS-Mincho-Italic"] = "MS Mincho-Italic", n["MS-PGothic"] = "MS PGothic", n["MS-PGothic-Bold"] = "MS PGothic-Bold", n["MS-PGothic-BoldItalic"] = "MS PGothic-BoldItalic", n["MS-PGothic-Italic"] = "MS PGothic-Italic", n["MS-PMincho"] = "MS PMincho", n["MS-PMincho-Bold"] = "MS PMincho-Bold", n["MS-PMincho-BoldItalic"] = "MS PMincho-BoldItalic", n["MS-PMincho-Italic"] = "MS PMincho-Italic", n.NuptialScript = "Times-Italic", n.SegoeUISymbol = "Helvetica", n.Wingdings = "ZapfDingbats", n["Wingdings-Regular"] = "ZapfDingbats";
          });
          o.getNonStdFontMap = e;
          const y = (0, t.getLookupTableFactory)(function(n) {
            n["Adobe Jenson"] = !0, n["Adobe Text"] = !0, n.Albertus = !0, n.Aldus = !0, n.Alexandria = !0, n.Algerian = !0, n["American Typewriter"] = !0, n.Antiqua = !0, n.Apex = !0, n.Arno = !0, n.Aster = !0, n.Aurora = !0, n.Baskerville = !0, n.Bell = !0, n.Bembo = !0, n["Bembo Schoolbook"] = !0, n.Benguiat = !0, n["Berkeley Old Style"] = !0, n["Bernhard Modern"] = !0, n["Berthold City"] = !0, n.Bodoni = !0, n["Bauer Bodoni"] = !0, n["Book Antiqua"] = !0, n.Bookman = !0, n["Bordeaux Roman"] = !0, n["Californian FB"] = !0, n.Calisto = !0, n.Calvert = !0, n.Capitals = !0, n.Cambria = !0, n.Cartier = !0, n.Caslon = !0, n.Catull = !0, n.Centaur = !0, n["Century Old Style"] = !0, n["Century Schoolbook"] = !0, n.Chaparral = !0, n["Charis SIL"] = !0, n.Cheltenham = !0, n["Cholla Slab"] = !0, n.Clarendon = !0, n.Clearface = !0, n.Cochin = !0, n.Colonna = !0, n["Computer Modern"] = !0, n["Concrete Roman"] = !0, n.Constantia = !0, n["Cooper Black"] = !0, n.Corona = !0, n.Ecotype = !0, n.Egyptienne = !0, n.Elephant = !0, n.Excelsior = !0, n.Fairfield = !0, n["FF Scala"] = !0, n.Folkard = !0, n.Footlight = !0, n.FreeSerif = !0, n["Friz Quadrata"] = !0, n.Garamond = !0, n.Gentium = !0, n.Georgia = !0, n.Gloucester = !0, n["Goudy Old Style"] = !0, n["Goudy Schoolbook"] = !0, n["Goudy Pro Font"] = !0, n.Granjon = !0, n["Guardian Egyptian"] = !0, n.Heather = !0, n.Hercules = !0, n["High Tower Text"] = !0, n.Hiroshige = !0, n["Hoefler Text"] = !0, n["Humana Serif"] = !0, n.Imprint = !0, n["Ionic No. 5"] = !0, n.Janson = !0, n.Joanna = !0, n.Korinna = !0, n.Lexicon = !0, n.LiberationSerif = !0, n["Liberation Serif"] = !0, n["Linux Libertine"] = !0, n.Literaturnaya = !0, n.Lucida = !0, n["Lucida Bright"] = !0, n.Melior = !0, n.Memphis = !0, n.Miller = !0, n.Minion = !0, n.Modern = !0, n["Mona Lisa"] = !0, n["Mrs Eaves"] = !0, n["MS Serif"] = !0, n["Museo Slab"] = !0, n["New York"] = !0, n["Nimbus Roman"] = !0, n["NPS Rawlinson Roadway"] = !0, n.NuptialScript = !0, n.Palatino = !0, n.Perpetua = !0, n.Plantin = !0, n["Plantin Schoolbook"] = !0, n.Playbill = !0, n["Poor Richard"] = !0, n["Rawlinson Roadway"] = !0, n.Renault = !0, n.Requiem = !0, n.Rockwell = !0, n.Roman = !0, n["Rotis Serif"] = !0, n.Sabon = !0, n.Scala = !0, n.Seagull = !0, n.Sistina = !0, n.Souvenir = !0, n.STIX = !0, n["Stone Informal"] = !0, n["Stone Serif"] = !0, n.Sylfaen = !0, n.Times = !0, n.Trajan = !0, n.Trinité = !0, n["Trump Mediaeval"] = !0, n.Utopia = !0, n["Vale Type"] = !0, n["Bitstream Vera"] = !0, n["Vera Serif"] = !0, n.Versailles = !0, n.Wanted = !0, n.Weiss = !0, n["Wide Latin"] = !0, n.Windsor = !0, n.XITS = !0;
          });
          o.getSerifFonts = y;
          const c = (0, t.getLookupTableFactory)(function(n) {
            n.Dingbats = !0, n.Symbol = !0, n.ZapfDingbats = !0;
          });
          o.getSymbolsFonts = c;
          const d = (0, t.getLookupTableFactory)(function(n) {
            n[2] = 10, n[3] = 32, n[4] = 33, n[5] = 34, n[6] = 35, n[7] = 36, n[8] = 37, n[9] = 38, n[10] = 39, n[11] = 40, n[12] = 41, n[13] = 42, n[14] = 43, n[15] = 44, n[16] = 45, n[17] = 46, n[18] = 47, n[19] = 48, n[20] = 49, n[21] = 50, n[22] = 51, n[23] = 52, n[24] = 53, n[25] = 54, n[26] = 55, n[27] = 56, n[28] = 57, n[29] = 58, n[30] = 894, n[31] = 60, n[32] = 61, n[33] = 62, n[34] = 63, n[35] = 64, n[36] = 65, n[37] = 66, n[38] = 67, n[39] = 68, n[40] = 69, n[41] = 70, n[42] = 71, n[43] = 72, n[44] = 73, n[45] = 74, n[46] = 75, n[47] = 76, n[48] = 77, n[49] = 78, n[50] = 79, n[51] = 80, n[52] = 81, n[53] = 82, n[54] = 83, n[55] = 84, n[56] = 85, n[57] = 86, n[58] = 87, n[59] = 88, n[60] = 89, n[61] = 90, n[62] = 91, n[63] = 92, n[64] = 93, n[65] = 94, n[66] = 95, n[67] = 96, n[68] = 97, n[69] = 98, n[70] = 99, n[71] = 100, n[72] = 101, n[73] = 102, n[74] = 103, n[75] = 104, n[76] = 105, n[77] = 106, n[78] = 107, n[79] = 108, n[80] = 109, n[81] = 110, n[82] = 111, n[83] = 112, n[84] = 113, n[85] = 114, n[86] = 115, n[87] = 116, n[88] = 117, n[89] = 118, n[90] = 119, n[91] = 120, n[92] = 121, n[93] = 122, n[94] = 123, n[95] = 124, n[96] = 125, n[97] = 126, n[98] = 196, n[99] = 197, n[100] = 199, n[101] = 201, n[102] = 209, n[103] = 214, n[104] = 220, n[105] = 225, n[106] = 224, n[107] = 226, n[108] = 228, n[109] = 227, n[110] = 229, n[111] = 231, n[112] = 233, n[113] = 232, n[114] = 234, n[115] = 235, n[116] = 237, n[117] = 236, n[118] = 238, n[119] = 239, n[120] = 241, n[121] = 243, n[122] = 242, n[123] = 244, n[124] = 246, n[125] = 245, n[126] = 250, n[127] = 249, n[128] = 251, n[129] = 252, n[130] = 8224, n[131] = 176, n[132] = 162, n[133] = 163, n[134] = 167, n[135] = 8226, n[136] = 182, n[137] = 223, n[138] = 174, n[139] = 169, n[140] = 8482, n[141] = 180, n[142] = 168, n[143] = 8800, n[144] = 198, n[145] = 216, n[146] = 8734, n[147] = 177, n[148] = 8804, n[149] = 8805, n[150] = 165, n[151] = 181, n[152] = 8706, n[153] = 8721, n[154] = 8719, n[156] = 8747, n[157] = 170, n[158] = 186, n[159] = 8486, n[160] = 230, n[161] = 248, n[162] = 191, n[163] = 161, n[164] = 172, n[165] = 8730, n[166] = 402, n[167] = 8776, n[168] = 8710, n[169] = 171, n[170] = 187, n[171] = 8230, n[200] = 193, n[203] = 205, n[210] = 218, n[223] = 711, n[224] = 321, n[225] = 322, n[226] = 352, n[227] = 353, n[228] = 381, n[229] = 382, n[233] = 221, n[234] = 253, n[252] = 263, n[253] = 268, n[254] = 269, n[258] = 258, n[260] = 260, n[261] = 261, n[265] = 280, n[266] = 281, n[267] = 282, n[268] = 283, n[269] = 313, n[275] = 323, n[276] = 324, n[278] = 328, n[283] = 344, n[284] = 345, n[285] = 346, n[286] = 347, n[292] = 367, n[295] = 377, n[296] = 378, n[298] = 380, n[305] = 963, n[306] = 964, n[307] = 966, n[308] = 8215, n[309] = 8252, n[310] = 8319, n[311] = 8359, n[312] = 8592, n[313] = 8593, n[337] = 9552, n[493] = 1039, n[494] = 1040, n[672] = 1488, n[673] = 1489, n[674] = 1490, n[675] = 1491, n[676] = 1492, n[677] = 1493, n[678] = 1494, n[679] = 1495, n[680] = 1496, n[681] = 1497, n[682] = 1498, n[683] = 1499, n[684] = 1500, n[685] = 1501, n[686] = 1502, n[687] = 1503, n[688] = 1504, n[689] = 1505, n[690] = 1506, n[691] = 1507, n[692] = 1508, n[693] = 1509, n[694] = 1510, n[695] = 1511, n[696] = 1512, n[697] = 1513, n[698] = 1514, n[705] = 1524, n[706] = 8362, n[710] = 64288, n[711] = 64298, n[759] = 1617, n[761] = 1776, n[763] = 1778, n[775] = 1652, n[777] = 1764, n[778] = 1780, n[779] = 1781, n[780] = 1782, n[782] = 771, n[783] = 64726, n[786] = 8363, n[788] = 8532, n[790] = 768, n[791] = 769, n[792] = 768, n[795] = 803, n[797] = 64336, n[798] = 64337, n[799] = 64342, n[800] = 64343, n[801] = 64344, n[802] = 64345, n[803] = 64362, n[804] = 64363, n[805] = 64364, n[2424] = 7821, n[2425] = 7822, n[2426] = 7823, n[2427] = 7824, n[2428] = 7825, n[2429] = 7826, n[2430] = 7827, n[2433] = 7682, n[2678] = 8045, n[2679] = 8046, n[2830] = 1552, n[2838] = 686, n[2840] = 751, n[2842] = 753, n[2843] = 754, n[2844] = 755, n[2846] = 757, n[2856] = 767, n[2857] = 848, n[2858] = 849, n[2862] = 853, n[2863] = 854, n[2864] = 855, n[2865] = 861, n[2866] = 862, n[2906] = 7460, n[2908] = 7462, n[2909] = 7463, n[2910] = 7464, n[2912] = 7466, n[2913] = 7467, n[2914] = 7468, n[2916] = 7470, n[2917] = 7471, n[2918] = 7472, n[2920] = 7474, n[2921] = 7475, n[2922] = 7476, n[2924] = 7478, n[2925] = 7479, n[2926] = 7480, n[2928] = 7482, n[2929] = 7483, n[2930] = 7484, n[2932] = 7486, n[2933] = 7487, n[2934] = 7488, n[2936] = 7490, n[2937] = 7491, n[2938] = 7492, n[2940] = 7494, n[2941] = 7495, n[2942] = 7496, n[2944] = 7498, n[2946] = 7500, n[2948] = 7502, n[2950] = 7504, n[2951] = 7505, n[2952] = 7506, n[2954] = 7508, n[2955] = 7509, n[2956] = 7510, n[2958] = 7512, n[2959] = 7513, n[2960] = 7514, n[2962] = 7516, n[2963] = 7517, n[2964] = 7518, n[2966] = 7520, n[2967] = 7521, n[2968] = 7522, n[2970] = 7524, n[2971] = 7525, n[2972] = 7526, n[2974] = 7528, n[2975] = 7529, n[2976] = 7530, n[2978] = 1537, n[2979] = 1538, n[2980] = 1539, n[2982] = 1549, n[2983] = 1551, n[2984] = 1552, n[2986] = 1554, n[2987] = 1555, n[2988] = 1556, n[2990] = 1623, n[2991] = 1624, n[2995] = 1775, n[2999] = 1791, n[3002] = 64290, n[3003] = 64291, n[3004] = 64292, n[3006] = 64294, n[3007] = 64295, n[3008] = 64296, n[3011] = 1900, n[3014] = 8223, n[3015] = 8244, n[3017] = 7532, n[3018] = 7533, n[3019] = 7534, n[3075] = 7590, n[3076] = 7591, n[3079] = 7594, n[3080] = 7595, n[3083] = 7598, n[3084] = 7599, n[3087] = 7602, n[3088] = 7603, n[3091] = 7606, n[3092] = 7607, n[3095] = 7610, n[3096] = 7611, n[3099] = 7614, n[3100] = 7615, n[3103] = 7618, n[3104] = 7619, n[3107] = 8337, n[3108] = 8338, n[3116] = 1884, n[3119] = 1885, n[3120] = 1885, n[3123] = 1886, n[3124] = 1886, n[3127] = 1887, n[3128] = 1887, n[3131] = 1888, n[3132] = 1888, n[3135] = 1889, n[3136] = 1889, n[3139] = 1890, n[3140] = 1890, n[3143] = 1891, n[3144] = 1891, n[3147] = 1892, n[3148] = 1892, n[3153] = 580, n[3154] = 581, n[3157] = 584, n[3158] = 585, n[3161] = 588, n[3162] = 589, n[3165] = 891, n[3166] = 892, n[3169] = 1274, n[3170] = 1275, n[3173] = 1278, n[3174] = 1279, n[3181] = 7622, n[3182] = 7623, n[3282] = 11799, n[3316] = 578, n[3379] = 42785, n[3393] = 1159, n[3416] = 8377;
          });
          o.getGlyphMapForStandardFonts = d;
          const p = (0, t.getLookupTableFactory)(function(n) {
            n[227] = 322, n[264] = 261, n[291] = 346;
          });
          o.getSupplementalGlyphMapForArialBlack = p;
          const m = (0, t.getLookupTableFactory)(function(n) {
            n[1] = 32, n[4] = 65, n[6] = 193, n[17] = 66, n[18] = 67, n[21] = 268, n[24] = 68, n[28] = 69, n[30] = 201, n[32] = 282, n[38] = 70, n[39] = 71, n[44] = 72, n[47] = 73, n[49] = 205, n[58] = 74, n[60] = 75, n[62] = 76, n[68] = 77, n[69] = 78, n[75] = 79, n[87] = 80, n[89] = 81, n[90] = 82, n[92] = 344, n[94] = 83, n[97] = 352, n[100] = 84, n[104] = 85, n[115] = 86, n[116] = 87, n[121] = 88, n[122] = 89, n[124] = 221, n[127] = 90, n[129] = 381, n[258] = 97, n[260] = 225, n[268] = 261, n[271] = 98, n[272] = 99, n[273] = 263, n[275] = 269, n[282] = 100, n[286] = 101, n[288] = 233, n[290] = 283, n[295] = 281, n[296] = 102, n[336] = 103, n[346] = 104, n[349] = 105, n[351] = 237, n[361] = 106, n[364] = 107, n[367] = 108, n[371] = 322, n[373] = 109, n[374] = 110, n[381] = 111, n[383] = 243, n[393] = 112, n[395] = 113, n[396] = 114, n[398] = 345, n[400] = 115, n[401] = 347, n[403] = 353, n[410] = 116, n[437] = 117, n[448] = 118, n[449] = 119, n[454] = 120, n[455] = 121, n[457] = 253, n[460] = 122, n[462] = 382, n[463] = 380, n[853] = 44, n[855] = 58, n[856] = 46, n[876] = 47, n[878] = 45, n[882] = 45, n[894] = 40, n[895] = 41, n[896] = 91, n[897] = 93, n[923] = 64, n[1004] = 48, n[1005] = 49, n[1006] = 50, n[1007] = 51, n[1008] = 52, n[1009] = 53, n[1010] = 54, n[1011] = 55, n[1012] = 56, n[1013] = 57, n[1081] = 37, n[1085] = 43, n[1086] = 45;
          });
          o.getSupplementalGlyphMapForCalibri = m;
          function g(n) {
            const i = (0, a.normalizeFontName)(n);
            return v()[i];
          }
        },
        /* 42 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.ToUnicodeMap = o.IdentityToUnicodeMap = void 0;
          var t = C(2);
          class a {
            constructor(e = []) {
              this._map = e;
            }
            get length() {
              return this._map.length;
            }
            forEach(e) {
              for (const y in this._map)
                e(y, this._map[y].charCodeAt(0));
            }
            has(e) {
              return this._map[e] !== void 0;
            }
            get(e) {
              return this._map[e];
            }
            charCodeOf(e) {
              const y = this._map;
              if (y.length <= 65536)
                return y.indexOf(e);
              for (const c in y)
                if (y[c] === e)
                  return c | 0;
              return -1;
            }
            amend(e) {
              for (const y in e)
                this._map[y] = e[y];
            }
          }
          o.ToUnicodeMap = a;
          class v {
            constructor(e, y) {
              this.firstChar = e, this.lastChar = y;
            }
            get length() {
              return this.lastChar + 1 - this.firstChar;
            }
            forEach(e) {
              for (let y = this.firstChar, c = this.lastChar; y <= c; y++)
                e(y, y);
            }
            has(e) {
              return this.firstChar <= e && e <= this.lastChar;
            }
            get(e) {
              if (this.firstChar <= e && e <= this.lastChar)
                return String.fromCharCode(e);
            }
            charCodeOf(e) {
              return Number.isInteger(e) && e >= this.firstChar && e <= this.lastChar ? e : -1;
            }
            amend(e) {
              (0, t.unreachable)("Should not call amend()");
            }
          }
          o.IdentityToUnicodeMap = v;
        },
        /* 43 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.CFFFont = void 0;
          var t = C(35), a = C(38), v = C(2);
          class h {
            constructor(y, c) {
              this.properties = c;
              const d = new t.CFFParser(y, c, a.SEAC_ANALYSIS_ENABLED);
              this.cff = d.parse(), this.cff.duplicateFirstGlyph();
              const p = new t.CFFCompiler(this.cff);
              this.seacs = this.cff.seacs;
              try {
                this.data = p.compile();
              } catch {
                (0, v.warn)("Failed to compile font " + c.loadedName), this.data = y;
              }
              this._createBuiltInEncoding();
            }
            get numGlyphs() {
              return this.cff.charStrings.count;
            }
            getCharset() {
              return this.cff.charset.charset;
            }
            getGlyphMapping() {
              const y = this.cff, c = this.properties, d = y.charset.charset;
              let p, m;
              if (c.composite) {
                p = /* @__PURE__ */ Object.create(null);
                let n;
                if (y.isCIDFont)
                  for (m = 0; m < d.length; m++) {
                    const i = d[m];
                    n = c.cMap.charCodeOf(i), p[n] = m;
                  }
                else
                  for (m = 0; m < y.charStrings.count; m++)
                    n = c.cMap.charCodeOf(m), p[n] = m;
                return p;
              }
              let g = y.encoding ? y.encoding.encoding : null;
              return c.isInternalFont && (g = c.defaultEncoding), p = (0, a.type1FontGlyphMapping)(c, g, d), p;
            }
            hasGlyphId(y) {
              return this.cff.hasGlyphId(y);
            }
            _createBuiltInEncoding() {
              const {
                charset: y,
                encoding: c
              } = this.cff;
              if (!y || !c)
                return;
              const d = y.charset, p = c.encoding, m = [];
              for (const g in p) {
                const n = p[g];
                if (n >= 0) {
                  const i = d[n];
                  i && (m[g] = i);
                }
              }
              m.length > 0 && (this.properties.builtInEncoding = m);
            }
          }
          o.CFFFont = h;
        },
        /* 44 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.FontRendererFactory = void 0;
          var t = C(2), a = C(35), v = C(39), h = C(37), e = C(10);
          function y(B, R) {
            return (B[R] << 24 | B[R + 1] << 16 | B[R + 2] << 8 | B[R + 3]) >>> 0;
          }
          function c(B, R) {
            return B[R] << 8 | B[R + 1];
          }
          function d(B, R) {
            return (B[R] << 24 | B[R + 1] << 16) >> 16;
          }
          function p(B, R) {
            return B[R] << 24 >> 24;
          }
          function m(B, R) {
            return d(B, R) / 16384;
          }
          function g(B) {
            const R = B.length;
            let k = 32768;
            return R < 1240 ? k = 107 : R < 33900 && (k = 1131), k;
          }
          function n(B, R, k) {
            const x = c(B, R + 2) === 1 ? y(B, R + 8) : y(B, R + 16), f = c(B, R + x);
            let U, O, S;
            if (f === 4) {
              c(B, R + x + 2);
              const F = c(B, R + x + 6) >> 1;
              for (O = R + x + 14, U = [], S = 0; S < F; S++, O += 2)
                U[S] = {
                  end: c(B, O)
                };
              for (O += 2, S = 0; S < F; S++, O += 2)
                U[S].start = c(B, O);
              for (S = 0; S < F; S++, O += 2)
                U[S].idDelta = c(B, O);
              for (S = 0; S < F; S++, O += 2) {
                let T = c(B, O);
                if (T !== 0) {
                  U[S].ids = [];
                  for (let I = 0, M = U[S].end - U[S].start + 1; I < M; I++)
                    U[S].ids[I] = c(B, O + T), T += 2;
                }
              }
              return U;
            } else if (f === 12) {
              const F = y(B, R + x + 12);
              for (O = R + x + 16, U = [], S = 0; S < F; S++)
                R = y(B, O), U.push({
                  start: R,
                  end: y(B, O + 4),
                  idDelta: y(B, O + 8) - R
                }), O += 12;
              return U;
            }
            throw new t.FormatError(`unsupported cmap: ${f}`);
          }
          function i(B, R, k, x) {
            const f = {}, O = new a.CFFParser(new e.Stream(B, R, k - R), f, x).parse();
            return {
              glyphs: O.charStrings.objects,
              subrs: O.topDict.privateDict && O.topDict.privateDict.subrsIndex && O.topDict.privateDict.subrsIndex.objects,
              gsubrs: O.globalSubrIndex && O.globalSubrIndex.objects,
              isCFFCIDFont: O.isCIDFont,
              fdSelect: O.fdSelect,
              fdArray: O.fdArray
            };
          }
          function l(B, R, k) {
            let x, f;
            k ? (x = 4, f = y) : (x = 2, f = (S, F) => 2 * c(S, F));
            const U = [];
            let O = f(R, 0);
            for (let S = x; S < R.length; S += x) {
              const F = f(R, S);
              U.push(B.subarray(O, F)), O = F;
            }
            return U;
          }
          function u(B, R) {
            const k = R.codePointAt(0);
            let x = 0, f = 0, U = B.length - 1;
            for (; f < U; ) {
              const O = f + U + 1 >> 1;
              k < B[O].start ? U = O - 1 : f = O;
            }
            return B[f].start <= k && k <= B[f].end && (x = B[f].idDelta + (B[f].ids ? B[f].ids[k - B[f].start] : k) & 65535), {
              charCode: k,
              glyphId: x
            };
          }
          function w(B, R, k) {
            function x(M, V) {
              R.push({
                cmd: "moveTo",
                args: [M, V]
              });
            }
            function f(M, V) {
              R.push({
                cmd: "lineTo",
                args: [M, V]
              });
            }
            function U(M, V, J, W) {
              R.push({
                cmd: "quadraticCurveTo",
                args: [M, V, J, W]
              });
            }
            let O = 0;
            const S = d(B, O);
            let F, T = 0, I = 0;
            if (O += 10, S < 0)
              do {
                F = c(B, O);
                const M = c(B, O + 2);
                O += 4;
                let V, J;
                F & 1 ? (F & 2 ? (V = d(B, O), J = d(B, O + 2)) : (V = c(B, O), J = c(B, O + 2)), O += 4) : F & 2 ? (V = p(B, O++), J = p(B, O++)) : (V = B[O++], J = B[O++]), F & 2 ? (T = V, I = J) : (T = 0, I = 0);
                let W = 1, z = 1, G = 0, L = 0;
                F & 8 ? (W = z = m(B, O), O += 2) : F & 64 ? (W = m(B, O), z = m(B, O + 2), O += 4) : F & 128 && (W = m(B, O), G = m(B, O + 2), L = m(B, O + 4), z = m(B, O + 6), O += 8);
                const K = k.glyphs[M];
                K && (R.push({
                  cmd: "save"
                }, {
                  cmd: "transform",
                  args: [W, G, L, z, T, I]
                }), w(K, R, k), R.push({
                  cmd: "restore"
                }));
              } while (F & 32);
            else {
              const M = [];
              let V, J;
              for (V = 0; V < S; V++)
                M.push(c(B, O)), O += 2;
              const W = c(B, O);
              O += 2 + W;
              const z = M.at(-1) + 1, G = [];
              for (; G.length < z; ) {
                F = B[O++];
                let K = 1;
                for (F & 8 && (K += B[O++]); K-- > 0; )
                  G.push({
                    flags: F
                  });
              }
              for (V = 0; V < z; V++) {
                switch (G[V].flags & 18) {
                  case 0:
                    T += d(B, O), O += 2;
                    break;
                  case 2:
                    T -= B[O++];
                    break;
                  case 18:
                    T += B[O++];
                    break;
                }
                G[V].x = T;
              }
              for (V = 0; V < z; V++) {
                switch (G[V].flags & 36) {
                  case 0:
                    I += d(B, O), O += 2;
                    break;
                  case 4:
                    I -= B[O++];
                    break;
                  case 36:
                    I += B[O++];
                    break;
                }
                G[V].y = I;
              }
              let L = 0;
              for (O = 0; O < S; O++) {
                const K = M[O], te = G.slice(L, K + 1);
                if (te[0].flags & 1)
                  te.push(te[0]);
                else if (te.at(-1).flags & 1)
                  te.unshift(te.at(-1));
                else {
                  const se = {
                    flags: 1,
                    x: (te[0].x + te.at(-1).x) / 2,
                    y: (te[0].y + te.at(-1).y) / 2
                  };
                  te.unshift(se), te.push(se);
                }
                for (x(te[0].x, te[0].y), V = 1, J = te.length; V < J; V++)
                  te[V].flags & 1 ? f(te[V].x, te[V].y) : te[V + 1].flags & 1 ? (U(te[V].x, te[V].y, te[V + 1].x, te[V + 1].y), V++) : U(te[V].x, te[V].y, (te[V].x + te[V + 1].x) / 2, (te[V].y + te[V + 1].y) / 2);
                L = K + 1;
              }
            }
          }
          function _(B, R, k, x) {
            function f(V, J) {
              R.push({
                cmd: "moveTo",
                args: [V, J]
              });
            }
            function U(V, J) {
              R.push({
                cmd: "lineTo",
                args: [V, J]
              });
            }
            function O(V, J, W, z, G, L) {
              R.push({
                cmd: "bezierCurveTo",
                args: [V, J, W, z, G, L]
              });
            }
            const S = [];
            let F = 0, T = 0, I = 0;
            function M(V) {
              let J = 0;
              for (; J < V.length; ) {
                let W = !1, z = V[J++], G, L, K, te, se, q, N, Q, D;
                switch (z) {
                  case 1:
                    I += S.length >> 1, W = !0;
                    break;
                  case 3:
                    I += S.length >> 1, W = !0;
                    break;
                  case 4:
                    T += S.pop(), f(F, T), W = !0;
                    break;
                  case 5:
                    for (; S.length > 0; )
                      F += S.shift(), T += S.shift(), U(F, T);
                    break;
                  case 6:
                    for (; S.length > 0 && (F += S.shift(), U(F, T), S.length !== 0); )
                      T += S.shift(), U(F, T);
                    break;
                  case 7:
                    for (; S.length > 0 && (T += S.shift(), U(F, T), S.length !== 0); )
                      F += S.shift(), U(F, T);
                    break;
                  case 8:
                    for (; S.length > 0; )
                      G = F + S.shift(), K = T + S.shift(), L = G + S.shift(), te = K + S.shift(), F = L + S.shift(), T = te + S.shift(), O(G, K, L, te, F, T);
                    break;
                  case 10:
                    if (Q = S.pop(), D = null, k.isCFFCIDFont) {
                      const ne = k.fdSelect.getFDIndex(x);
                      if (ne >= 0 && ne < k.fdArray.length) {
                        const oe = k.fdArray[ne];
                        let ee;
                        oe.privateDict && oe.privateDict.subrsIndex && (ee = oe.privateDict.subrsIndex.objects), ee && (Q += g(ee), D = ee[Q]);
                      } else
                        (0, t.warn)("Invalid fd index for glyph index.");
                    } else
                      D = k.subrs[Q + k.subrsBias];
                    D && M(D);
                    break;
                  case 11:
                    return;
                  case 12:
                    switch (z = V[J++], z) {
                      case 34:
                        G = F + S.shift(), L = G + S.shift(), se = T + S.shift(), F = L + S.shift(), O(G, T, L, se, F, se), G = F + S.shift(), L = G + S.shift(), F = L + S.shift(), O(G, se, L, T, F, T);
                        break;
                      case 35:
                        G = F + S.shift(), K = T + S.shift(), L = G + S.shift(), te = K + S.shift(), F = L + S.shift(), T = te + S.shift(), O(G, K, L, te, F, T), G = F + S.shift(), K = T + S.shift(), L = G + S.shift(), te = K + S.shift(), F = L + S.shift(), T = te + S.shift(), O(G, K, L, te, F, T), S.pop();
                        break;
                      case 36:
                        G = F + S.shift(), se = T + S.shift(), L = G + S.shift(), q = se + S.shift(), F = L + S.shift(), O(G, se, L, q, F, q), G = F + S.shift(), L = G + S.shift(), N = q + S.shift(), F = L + S.shift(), O(G, q, L, N, F, T);
                        break;
                      case 37:
                        const ne = F, oe = T;
                        G = F + S.shift(), K = T + S.shift(), L = G + S.shift(), te = K + S.shift(), F = L + S.shift(), T = te + S.shift(), O(G, K, L, te, F, T), G = F + S.shift(), K = T + S.shift(), L = G + S.shift(), te = K + S.shift(), F = L, T = te, Math.abs(F - ne) > Math.abs(T - oe) ? F += S.shift() : T += S.shift(), O(G, K, L, te, F, T);
                        break;
                      default:
                        throw new t.FormatError(`unknown operator: 12 ${z}`);
                    }
                    break;
                  case 14:
                    if (S.length >= 4) {
                      const ne = S.pop(), oe = S.pop();
                      T = S.pop(), F = S.pop(), R.push({
                        cmd: "save"
                      }, {
                        cmd: "translate",
                        args: [F, T]
                      });
                      let ee = u(k.cmap, String.fromCharCode(k.glyphNameMap[h.StandardEncoding[ne]]));
                      _(k.glyphs[ee.glyphId], R, k, ee.glyphId), R.push({
                        cmd: "restore"
                      }), ee = u(k.cmap, String.fromCharCode(k.glyphNameMap[h.StandardEncoding[oe]])), _(k.glyphs[ee.glyphId], R, k, ee.glyphId);
                    }
                    return;
                  case 18:
                    I += S.length >> 1, W = !0;
                    break;
                  case 19:
                    I += S.length >> 1, J += I + 7 >> 3, W = !0;
                    break;
                  case 20:
                    I += S.length >> 1, J += I + 7 >> 3, W = !0;
                    break;
                  case 21:
                    T += S.pop(), F += S.pop(), f(F, T), W = !0;
                    break;
                  case 22:
                    F += S.pop(), f(F, T), W = !0;
                    break;
                  case 23:
                    I += S.length >> 1, W = !0;
                    break;
                  case 24:
                    for (; S.length > 2; )
                      G = F + S.shift(), K = T + S.shift(), L = G + S.shift(), te = K + S.shift(), F = L + S.shift(), T = te + S.shift(), O(G, K, L, te, F, T);
                    F += S.shift(), T += S.shift(), U(F, T);
                    break;
                  case 25:
                    for (; S.length > 6; )
                      F += S.shift(), T += S.shift(), U(F, T);
                    G = F + S.shift(), K = T + S.shift(), L = G + S.shift(), te = K + S.shift(), F = L + S.shift(), T = te + S.shift(), O(G, K, L, te, F, T);
                    break;
                  case 26:
                    for (S.length % 2 && (F += S.shift()); S.length > 0; )
                      G = F, K = T + S.shift(), L = G + S.shift(), te = K + S.shift(), F = L, T = te + S.shift(), O(G, K, L, te, F, T);
                    break;
                  case 27:
                    for (S.length % 2 && (T += S.shift()); S.length > 0; )
                      G = F + S.shift(), K = T, L = G + S.shift(), te = K + S.shift(), F = L + S.shift(), T = te, O(G, K, L, te, F, T);
                    break;
                  case 28:
                    S.push((V[J] << 24 | V[J + 1] << 16) >> 16), J += 2;
                    break;
                  case 29:
                    Q = S.pop() + k.gsubrsBias, D = k.gsubrs[Q], D && M(D);
                    break;
                  case 30:
                    for (; S.length > 0 && (G = F, K = T + S.shift(), L = G + S.shift(), te = K + S.shift(), F = L + S.shift(), T = te + (S.length === 1 ? S.shift() : 0), O(G, K, L, te, F, T), S.length !== 0); )
                      G = F + S.shift(), K = T, L = G + S.shift(), te = K + S.shift(), T = te + S.shift(), F = L + (S.length === 1 ? S.shift() : 0), O(G, K, L, te, F, T);
                    break;
                  case 31:
                    for (; S.length > 0 && (G = F + S.shift(), K = T, L = G + S.shift(), te = K + S.shift(), T = te + S.shift(), F = L + (S.length === 1 ? S.shift() : 0), O(G, K, L, te, F, T), S.length !== 0); )
                      G = F, K = T + S.shift(), L = G + S.shift(), te = K + S.shift(), F = L + S.shift(), T = te + (S.length === 1 ? S.shift() : 0), O(G, K, L, te, F, T);
                    break;
                  default:
                    if (z < 32)
                      throw new t.FormatError(`unknown operator: ${z}`);
                    z < 247 ? S.push(z - 139) : z < 251 ? S.push((z - 247) * 256 + V[J++] + 108) : z < 255 ? S.push(-(z - 251) * 256 - V[J++] - 108) : (S.push((V[J] << 24 | V[J + 1] << 16 | V[J + 2] << 8 | V[J + 3]) / 65536), J += 4);
                    break;
                }
                W && (S.length = 0);
              }
            }
            M(B);
          }
          const b = [];
          class A {
            constructor(R) {
              this.constructor === A && (0, t.unreachable)("Cannot initialize CompiledFont."), this.fontMatrix = R, this.compiledGlyphs = /* @__PURE__ */ Object.create(null), this.compiledCharCodeToGlyphId = /* @__PURE__ */ Object.create(null);
            }
            getPathJs(R) {
              const {
                charCode: k,
                glyphId: x
              } = u(this.cmap, R);
              let f = this.compiledGlyphs[x];
              if (!f)
                try {
                  f = this.compileGlyph(this.glyphs[x], x), this.compiledGlyphs[x] = f;
                } catch (U) {
                  throw this.compiledGlyphs[x] = b, this.compiledCharCodeToGlyphId[k] === void 0 && (this.compiledCharCodeToGlyphId[k] = x), U;
                }
              return this.compiledCharCodeToGlyphId[k] === void 0 && (this.compiledCharCodeToGlyphId[k] = x), f;
            }
            compileGlyph(R, k) {
              if (!R || R.length === 0 || R[0] === 14)
                return b;
              let x = this.fontMatrix;
              if (this.isCFFCIDFont) {
                const U = this.fdSelect.getFDIndex(k);
                U >= 0 && U < this.fdArray.length ? x = this.fdArray[U].getByName("FontMatrix") || t.FONT_IDENTITY_MATRIX : (0, t.warn)("Invalid fd index for glyph index.");
              }
              const f = [{
                cmd: "save"
              }, {
                cmd: "transform",
                args: x.slice()
              }, {
                cmd: "scale",
                args: ["size", "-size"]
              }];
              return this.compileGlyphImpl(R, f, k), f.push({
                cmd: "restore"
              }), f;
            }
            compileGlyphImpl() {
              (0, t.unreachable)("Children classes should implement this.");
            }
            hasBuiltPath(R) {
              const {
                charCode: k,
                glyphId: x
              } = u(this.cmap, R);
              return this.compiledGlyphs[x] !== void 0 && this.compiledCharCodeToGlyphId[k] !== void 0;
            }
          }
          class Y extends A {
            constructor(R, k, x) {
              super(x || [488e-6, 0, 0, 488e-6, 0, 0]), this.glyphs = R, this.cmap = k;
            }
            compileGlyphImpl(R, k) {
              w(R, k, this);
            }
          }
          class j extends A {
            constructor(R, k, x, f) {
              super(x || [1e-3, 0, 0, 1e-3, 0, 0]), this.glyphs = R.glyphs, this.gsubrs = R.gsubrs || [], this.subrs = R.subrs || [], this.cmap = k, this.glyphNameMap = f || (0, v.getGlyphsUnicode)(), this.gsubrsBias = g(this.gsubrs), this.subrsBias = g(this.subrs), this.isCFFCIDFont = R.isCFFCIDFont, this.fdSelect = R.fdSelect, this.fdArray = R.fdArray;
            }
            compileGlyphImpl(R, k, x) {
              _(R, k, this, x);
            }
          }
          class X {
            static create(R, k) {
              const x = new Uint8Array(R.data);
              let f, U, O, S, F, T;
              const I = c(x, 4);
              for (let M = 0, V = 12; M < I; M++, V += 16) {
                const J = (0, t.bytesToString)(x.subarray(V, V + 4)), W = y(x, V + 8), z = y(x, V + 12);
                switch (J) {
                  case "cmap":
                    f = n(x, W);
                    break;
                  case "glyf":
                    U = x.subarray(W, W + z);
                    break;
                  case "loca":
                    O = x.subarray(W, W + z);
                    break;
                  case "head":
                    T = c(x, W + 18), F = c(x, W + 50);
                    break;
                  case "CFF ":
                    S = i(x, W, W + z, k);
                    break;
                }
              }
              if (U) {
                const M = T ? [1 / T, 0, 0, 1 / T, 0, 0] : R.fontMatrix;
                return new Y(l(U, O, F), f, M);
              }
              return new j(S, f, R.fontMatrix, R.glyphNameMap);
            }
          }
          o.FontRendererFactory = X;
        },
        /* 45 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.getMetrics = o.getFontBasicMetrics = void 0;
          var t = C(6);
          const a = (0, t.getLookupTableFactory)(function(h) {
            h.Courier = 600, h["Courier-Bold"] = 600, h["Courier-BoldOblique"] = 600, h["Courier-Oblique"] = 600, h.Helvetica = (0, t.getLookupTableFactory)(function(e) {
              e.space = 278, e.exclam = 278, e.quotedbl = 355, e.numbersign = 556, e.dollar = 556, e.percent = 889, e.ampersand = 667, e.quoteright = 222, e.parenleft = 333, e.parenright = 333, e.asterisk = 389, e.plus = 584, e.comma = 278, e.hyphen = 333, e.period = 278, e.slash = 278, e.zero = 556, e.one = 556, e.two = 556, e.three = 556, e.four = 556, e.five = 556, e.six = 556, e.seven = 556, e.eight = 556, e.nine = 556, e.colon = 278, e.semicolon = 278, e.less = 584, e.equal = 584, e.greater = 584, e.question = 556, e.at = 1015, e.A = 667, e.B = 667, e.C = 722, e.D = 722, e.E = 667, e.F = 611, e.G = 778, e.H = 722, e.I = 278, e.J = 500, e.K = 667, e.L = 556, e.M = 833, e.N = 722, e.O = 778, e.P = 667, e.Q = 778, e.R = 722, e.S = 667, e.T = 611, e.U = 722, e.V = 667, e.W = 944, e.X = 667, e.Y = 667, e.Z = 611, e.bracketleft = 278, e.backslash = 278, e.bracketright = 278, e.asciicircum = 469, e.underscore = 556, e.quoteleft = 222, e.a = 556, e.b = 556, e.c = 500, e.d = 556, e.e = 556, e.f = 278, e.g = 556, e.h = 556, e.i = 222, e.j = 222, e.k = 500, e.l = 222, e.m = 833, e.n = 556, e.o = 556, e.p = 556, e.q = 556, e.r = 333, e.s = 500, e.t = 278, e.u = 556, e.v = 500, e.w = 722, e.x = 500, e.y = 500, e.z = 500, e.braceleft = 334, e.bar = 260, e.braceright = 334, e.asciitilde = 584, e.exclamdown = 333, e.cent = 556, e.sterling = 556, e.fraction = 167, e.yen = 556, e.florin = 556, e.section = 556, e.currency = 556, e.quotesingle = 191, e.quotedblleft = 333, e.guillemotleft = 556, e.guilsinglleft = 333, e.guilsinglright = 333, e.fi = 500, e.fl = 500, e.endash = 556, e.dagger = 556, e.daggerdbl = 556, e.periodcentered = 278, e.paragraph = 537, e.bullet = 350, e.quotesinglbase = 222, e.quotedblbase = 333, e.quotedblright = 333, e.guillemotright = 556, e.ellipsis = 1e3, e.perthousand = 1e3, e.questiondown = 611, e.grave = 333, e.acute = 333, e.circumflex = 333, e.tilde = 333, e.macron = 333, e.breve = 333, e.dotaccent = 333, e.dieresis = 333, e.ring = 333, e.cedilla = 333, e.hungarumlaut = 333, e.ogonek = 333, e.caron = 333, e.emdash = 1e3, e.AE = 1e3, e.ordfeminine = 370, e.Lslash = 556, e.Oslash = 778, e.OE = 1e3, e.ordmasculine = 365, e.ae = 889, e.dotlessi = 278, e.lslash = 222, e.oslash = 611, e.oe = 944, e.germandbls = 611, e.Idieresis = 278, e.eacute = 556, e.abreve = 556, e.uhungarumlaut = 556, e.ecaron = 556, e.Ydieresis = 667, e.divide = 584, e.Yacute = 667, e.Acircumflex = 667, e.aacute = 556, e.Ucircumflex = 722, e.yacute = 500, e.scommaaccent = 500, e.ecircumflex = 556, e.Uring = 722, e.Udieresis = 722, e.aogonek = 556, e.Uacute = 722, e.uogonek = 556, e.Edieresis = 667, e.Dcroat = 722, e.commaaccent = 250, e.copyright = 737, e.Emacron = 667, e.ccaron = 500, e.aring = 556, e.Ncommaaccent = 722, e.lacute = 222, e.agrave = 556, e.Tcommaaccent = 611, e.Cacute = 722, e.atilde = 556, e.Edotaccent = 667, e.scaron = 500, e.scedilla = 500, e.iacute = 278, e.lozenge = 471, e.Rcaron = 722, e.Gcommaaccent = 778, e.ucircumflex = 556, e.acircumflex = 556, e.Amacron = 667, e.rcaron = 333, e.ccedilla = 500, e.Zdotaccent = 611, e.Thorn = 667, e.Omacron = 778, e.Racute = 722, e.Sacute = 667, e.dcaron = 643, e.Umacron = 722, e.uring = 556, e.threesuperior = 333, e.Ograve = 778, e.Agrave = 667, e.Abreve = 667, e.multiply = 584, e.uacute = 556, e.Tcaron = 611, e.partialdiff = 476, e.ydieresis = 500, e.Nacute = 722, e.icircumflex = 278, e.Ecircumflex = 667, e.adieresis = 556, e.edieresis = 556, e.cacute = 500, e.nacute = 556, e.umacron = 556, e.Ncaron = 722, e.Iacute = 278, e.plusminus = 584, e.brokenbar = 260, e.registered = 737, e.Gbreve = 778, e.Idotaccent = 278, e.summation = 600, e.Egrave = 667, e.racute = 333, e.omacron = 556, e.Zacute = 611, e.Zcaron = 611, e.greaterequal = 549, e.Eth = 722, e.Ccedilla = 722, e.lcommaaccent = 222, e.tcaron = 317, e.eogonek = 556, e.Uogonek = 722, e.Aacute = 667, e.Adieresis = 667, e.egrave = 556, e.zacute = 500, e.iogonek = 222, e.Oacute = 778, e.oacute = 556, e.amacron = 556, e.sacute = 500, e.idieresis = 278, e.Ocircumflex = 778, e.Ugrave = 722, e.Delta = 612, e.thorn = 556, e.twosuperior = 333, e.Odieresis = 778, e.mu = 556, e.igrave = 278, e.ohungarumlaut = 556, e.Eogonek = 667, e.dcroat = 556, e.threequarters = 834, e.Scedilla = 667, e.lcaron = 299, e.Kcommaaccent = 667, e.Lacute = 556, e.trademark = 1e3, e.edotaccent = 556, e.Igrave = 278, e.Imacron = 278, e.Lcaron = 556, e.onehalf = 834, e.lessequal = 549, e.ocircumflex = 556, e.ntilde = 556, e.Uhungarumlaut = 722, e.Eacute = 667, e.emacron = 556, e.gbreve = 556, e.onequarter = 834, e.Scaron = 667, e.Scommaaccent = 667, e.Ohungarumlaut = 778, e.degree = 400, e.ograve = 556, e.Ccaron = 722, e.ugrave = 556, e.radical = 453, e.Dcaron = 722, e.rcommaaccent = 333, e.Ntilde = 722, e.otilde = 556, e.Rcommaaccent = 722, e.Lcommaaccent = 556, e.Atilde = 667, e.Aogonek = 667, e.Aring = 667, e.Otilde = 778, e.zdotaccent = 500, e.Ecaron = 667, e.Iogonek = 278, e.kcommaaccent = 500, e.minus = 584, e.Icircumflex = 278, e.ncaron = 556, e.tcommaaccent = 278, e.logicalnot = 584, e.odieresis = 556, e.udieresis = 556, e.notequal = 549, e.gcommaaccent = 556, e.eth = 556, e.zcaron = 500, e.ncommaaccent = 556, e.onesuperior = 333, e.imacron = 278, e.Euro = 556;
            }), h["Helvetica-Bold"] = (0, t.getLookupTableFactory)(function(e) {
              e.space = 278, e.exclam = 333, e.quotedbl = 474, e.numbersign = 556, e.dollar = 556, e.percent = 889, e.ampersand = 722, e.quoteright = 278, e.parenleft = 333, e.parenright = 333, e.asterisk = 389, e.plus = 584, e.comma = 278, e.hyphen = 333, e.period = 278, e.slash = 278, e.zero = 556, e.one = 556, e.two = 556, e.three = 556, e.four = 556, e.five = 556, e.six = 556, e.seven = 556, e.eight = 556, e.nine = 556, e.colon = 333, e.semicolon = 333, e.less = 584, e.equal = 584, e.greater = 584, e.question = 611, e.at = 975, e.A = 722, e.B = 722, e.C = 722, e.D = 722, e.E = 667, e.F = 611, e.G = 778, e.H = 722, e.I = 278, e.J = 556, e.K = 722, e.L = 611, e.M = 833, e.N = 722, e.O = 778, e.P = 667, e.Q = 778, e.R = 722, e.S = 667, e.T = 611, e.U = 722, e.V = 667, e.W = 944, e.X = 667, e.Y = 667, e.Z = 611, e.bracketleft = 333, e.backslash = 278, e.bracketright = 333, e.asciicircum = 584, e.underscore = 556, e.quoteleft = 278, e.a = 556, e.b = 611, e.c = 556, e.d = 611, e.e = 556, e.f = 333, e.g = 611, e.h = 611, e.i = 278, e.j = 278, e.k = 556, e.l = 278, e.m = 889, e.n = 611, e.o = 611, e.p = 611, e.q = 611, e.r = 389, e.s = 556, e.t = 333, e.u = 611, e.v = 556, e.w = 778, e.x = 556, e.y = 556, e.z = 500, e.braceleft = 389, e.bar = 280, e.braceright = 389, e.asciitilde = 584, e.exclamdown = 333, e.cent = 556, e.sterling = 556, e.fraction = 167, e.yen = 556, e.florin = 556, e.section = 556, e.currency = 556, e.quotesingle = 238, e.quotedblleft = 500, e.guillemotleft = 556, e.guilsinglleft = 333, e.guilsinglright = 333, e.fi = 611, e.fl = 611, e.endash = 556, e.dagger = 556, e.daggerdbl = 556, e.periodcentered = 278, e.paragraph = 556, e.bullet = 350, e.quotesinglbase = 278, e.quotedblbase = 500, e.quotedblright = 500, e.guillemotright = 556, e.ellipsis = 1e3, e.perthousand = 1e3, e.questiondown = 611, e.grave = 333, e.acute = 333, e.circumflex = 333, e.tilde = 333, e.macron = 333, e.breve = 333, e.dotaccent = 333, e.dieresis = 333, e.ring = 333, e.cedilla = 333, e.hungarumlaut = 333, e.ogonek = 333, e.caron = 333, e.emdash = 1e3, e.AE = 1e3, e.ordfeminine = 370, e.Lslash = 611, e.Oslash = 778, e.OE = 1e3, e.ordmasculine = 365, e.ae = 889, e.dotlessi = 278, e.lslash = 278, e.oslash = 611, e.oe = 944, e.germandbls = 611, e.Idieresis = 278, e.eacute = 556, e.abreve = 556, e.uhungarumlaut = 611, e.ecaron = 556, e.Ydieresis = 667, e.divide = 584, e.Yacute = 667, e.Acircumflex = 722, e.aacute = 556, e.Ucircumflex = 722, e.yacute = 556, e.scommaaccent = 556, e.ecircumflex = 556, e.Uring = 722, e.Udieresis = 722, e.aogonek = 556, e.Uacute = 722, e.uogonek = 611, e.Edieresis = 667, e.Dcroat = 722, e.commaaccent = 250, e.copyright = 737, e.Emacron = 667, e.ccaron = 556, e.aring = 556, e.Ncommaaccent = 722, e.lacute = 278, e.agrave = 556, e.Tcommaaccent = 611, e.Cacute = 722, e.atilde = 556, e.Edotaccent = 667, e.scaron = 556, e.scedilla = 556, e.iacute = 278, e.lozenge = 494, e.Rcaron = 722, e.Gcommaaccent = 778, e.ucircumflex = 611, e.acircumflex = 556, e.Amacron = 722, e.rcaron = 389, e.ccedilla = 556, e.Zdotaccent = 611, e.Thorn = 667, e.Omacron = 778, e.Racute = 722, e.Sacute = 667, e.dcaron = 743, e.Umacron = 722, e.uring = 611, e.threesuperior = 333, e.Ograve = 778, e.Agrave = 722, e.Abreve = 722, e.multiply = 584, e.uacute = 611, e.Tcaron = 611, e.partialdiff = 494, e.ydieresis = 556, e.Nacute = 722, e.icircumflex = 278, e.Ecircumflex = 667, e.adieresis = 556, e.edieresis = 556, e.cacute = 556, e.nacute = 611, e.umacron = 611, e.Ncaron = 722, e.Iacute = 278, e.plusminus = 584, e.brokenbar = 280, e.registered = 737, e.Gbreve = 778, e.Idotaccent = 278, e.summation = 600, e.Egrave = 667, e.racute = 389, e.omacron = 611, e.Zacute = 611, e.Zcaron = 611, e.greaterequal = 549, e.Eth = 722, e.Ccedilla = 722, e.lcommaaccent = 278, e.tcaron = 389, e.eogonek = 556, e.Uogonek = 722, e.Aacute = 722, e.Adieresis = 722, e.egrave = 556, e.zacute = 500, e.iogonek = 278, e.Oacute = 778, e.oacute = 611, e.amacron = 556, e.sacute = 556, e.idieresis = 278, e.Ocircumflex = 778, e.Ugrave = 722, e.Delta = 612, e.thorn = 611, e.twosuperior = 333, e.Odieresis = 778, e.mu = 611, e.igrave = 278, e.ohungarumlaut = 611, e.Eogonek = 667, e.dcroat = 611, e.threequarters = 834, e.Scedilla = 667, e.lcaron = 400, e.Kcommaaccent = 722, e.Lacute = 611, e.trademark = 1e3, e.edotaccent = 556, e.Igrave = 278, e.Imacron = 278, e.Lcaron = 611, e.onehalf = 834, e.lessequal = 549, e.ocircumflex = 611, e.ntilde = 611, e.Uhungarumlaut = 722, e.Eacute = 667, e.emacron = 556, e.gbreve = 611, e.onequarter = 834, e.Scaron = 667, e.Scommaaccent = 667, e.Ohungarumlaut = 778, e.degree = 400, e.ograve = 611, e.Ccaron = 722, e.ugrave = 611, e.radical = 549, e.Dcaron = 722, e.rcommaaccent = 389, e.Ntilde = 722, e.otilde = 611, e.Rcommaaccent = 722, e.Lcommaaccent = 611, e.Atilde = 722, e.Aogonek = 722, e.Aring = 722, e.Otilde = 778, e.zdotaccent = 500, e.Ecaron = 667, e.Iogonek = 278, e.kcommaaccent = 556, e.minus = 584, e.Icircumflex = 278, e.ncaron = 611, e.tcommaaccent = 333, e.logicalnot = 584, e.odieresis = 611, e.udieresis = 611, e.notequal = 549, e.gcommaaccent = 611, e.eth = 611, e.zcaron = 500, e.ncommaaccent = 611, e.onesuperior = 333, e.imacron = 278, e.Euro = 556;
            }), h["Helvetica-BoldOblique"] = (0, t.getLookupTableFactory)(function(e) {
              e.space = 278, e.exclam = 333, e.quotedbl = 474, e.numbersign = 556, e.dollar = 556, e.percent = 889, e.ampersand = 722, e.quoteright = 278, e.parenleft = 333, e.parenright = 333, e.asterisk = 389, e.plus = 584, e.comma = 278, e.hyphen = 333, e.period = 278, e.slash = 278, e.zero = 556, e.one = 556, e.two = 556, e.three = 556, e.four = 556, e.five = 556, e.six = 556, e.seven = 556, e.eight = 556, e.nine = 556, e.colon = 333, e.semicolon = 333, e.less = 584, e.equal = 584, e.greater = 584, e.question = 611, e.at = 975, e.A = 722, e.B = 722, e.C = 722, e.D = 722, e.E = 667, e.F = 611, e.G = 778, e.H = 722, e.I = 278, e.J = 556, e.K = 722, e.L = 611, e.M = 833, e.N = 722, e.O = 778, e.P = 667, e.Q = 778, e.R = 722, e.S = 667, e.T = 611, e.U = 722, e.V = 667, e.W = 944, e.X = 667, e.Y = 667, e.Z = 611, e.bracketleft = 333, e.backslash = 278, e.bracketright = 333, e.asciicircum = 584, e.underscore = 556, e.quoteleft = 278, e.a = 556, e.b = 611, e.c = 556, e.d = 611, e.e = 556, e.f = 333, e.g = 611, e.h = 611, e.i = 278, e.j = 278, e.k = 556, e.l = 278, e.m = 889, e.n = 611, e.o = 611, e.p = 611, e.q = 611, e.r = 389, e.s = 556, e.t = 333, e.u = 611, e.v = 556, e.w = 778, e.x = 556, e.y = 556, e.z = 500, e.braceleft = 389, e.bar = 280, e.braceright = 389, e.asciitilde = 584, e.exclamdown = 333, e.cent = 556, e.sterling = 556, e.fraction = 167, e.yen = 556, e.florin = 556, e.section = 556, e.currency = 556, e.quotesingle = 238, e.quotedblleft = 500, e.guillemotleft = 556, e.guilsinglleft = 333, e.guilsinglright = 333, e.fi = 611, e.fl = 611, e.endash = 556, e.dagger = 556, e.daggerdbl = 556, e.periodcentered = 278, e.paragraph = 556, e.bullet = 350, e.quotesinglbase = 278, e.quotedblbase = 500, e.quotedblright = 500, e.guillemotright = 556, e.ellipsis = 1e3, e.perthousand = 1e3, e.questiondown = 611, e.grave = 333, e.acute = 333, e.circumflex = 333, e.tilde = 333, e.macron = 333, e.breve = 333, e.dotaccent = 333, e.dieresis = 333, e.ring = 333, e.cedilla = 333, e.hungarumlaut = 333, e.ogonek = 333, e.caron = 333, e.emdash = 1e3, e.AE = 1e3, e.ordfeminine = 370, e.Lslash = 611, e.Oslash = 778, e.OE = 1e3, e.ordmasculine = 365, e.ae = 889, e.dotlessi = 278, e.lslash = 278, e.oslash = 611, e.oe = 944, e.germandbls = 611, e.Idieresis = 278, e.eacute = 556, e.abreve = 556, e.uhungarumlaut = 611, e.ecaron = 556, e.Ydieresis = 667, e.divide = 584, e.Yacute = 667, e.Acircumflex = 722, e.aacute = 556, e.Ucircumflex = 722, e.yacute = 556, e.scommaaccent = 556, e.ecircumflex = 556, e.Uring = 722, e.Udieresis = 722, e.aogonek = 556, e.Uacute = 722, e.uogonek = 611, e.Edieresis = 667, e.Dcroat = 722, e.commaaccent = 250, e.copyright = 737, e.Emacron = 667, e.ccaron = 556, e.aring = 556, e.Ncommaaccent = 722, e.lacute = 278, e.agrave = 556, e.Tcommaaccent = 611, e.Cacute = 722, e.atilde = 556, e.Edotaccent = 667, e.scaron = 556, e.scedilla = 556, e.iacute = 278, e.lozenge = 494, e.Rcaron = 722, e.Gcommaaccent = 778, e.ucircumflex = 611, e.acircumflex = 556, e.Amacron = 722, e.rcaron = 389, e.ccedilla = 556, e.Zdotaccent = 611, e.Thorn = 667, e.Omacron = 778, e.Racute = 722, e.Sacute = 667, e.dcaron = 743, e.Umacron = 722, e.uring = 611, e.threesuperior = 333, e.Ograve = 778, e.Agrave = 722, e.Abreve = 722, e.multiply = 584, e.uacute = 611, e.Tcaron = 611, e.partialdiff = 494, e.ydieresis = 556, e.Nacute = 722, e.icircumflex = 278, e.Ecircumflex = 667, e.adieresis = 556, e.edieresis = 556, e.cacute = 556, e.nacute = 611, e.umacron = 611, e.Ncaron = 722, e.Iacute = 278, e.plusminus = 584, e.brokenbar = 280, e.registered = 737, e.Gbreve = 778, e.Idotaccent = 278, e.summation = 600, e.Egrave = 667, e.racute = 389, e.omacron = 611, e.Zacute = 611, e.Zcaron = 611, e.greaterequal = 549, e.Eth = 722, e.Ccedilla = 722, e.lcommaaccent = 278, e.tcaron = 389, e.eogonek = 556, e.Uogonek = 722, e.Aacute = 722, e.Adieresis = 722, e.egrave = 556, e.zacute = 500, e.iogonek = 278, e.Oacute = 778, e.oacute = 611, e.amacron = 556, e.sacute = 556, e.idieresis = 278, e.Ocircumflex = 778, e.Ugrave = 722, e.Delta = 612, e.thorn = 611, e.twosuperior = 333, e.Odieresis = 778, e.mu = 611, e.igrave = 278, e.ohungarumlaut = 611, e.Eogonek = 667, e.dcroat = 611, e.threequarters = 834, e.Scedilla = 667, e.lcaron = 400, e.Kcommaaccent = 722, e.Lacute = 611, e.trademark = 1e3, e.edotaccent = 556, e.Igrave = 278, e.Imacron = 278, e.Lcaron = 611, e.onehalf = 834, e.lessequal = 549, e.ocircumflex = 611, e.ntilde = 611, e.Uhungarumlaut = 722, e.Eacute = 667, e.emacron = 556, e.gbreve = 611, e.onequarter = 834, e.Scaron = 667, e.Scommaaccent = 667, e.Ohungarumlaut = 778, e.degree = 400, e.ograve = 611, e.Ccaron = 722, e.ugrave = 611, e.radical = 549, e.Dcaron = 722, e.rcommaaccent = 389, e.Ntilde = 722, e.otilde = 611, e.Rcommaaccent = 722, e.Lcommaaccent = 611, e.Atilde = 722, e.Aogonek = 722, e.Aring = 722, e.Otilde = 778, e.zdotaccent = 500, e.Ecaron = 667, e.Iogonek = 278, e.kcommaaccent = 556, e.minus = 584, e.Icircumflex = 278, e.ncaron = 611, e.tcommaaccent = 333, e.logicalnot = 584, e.odieresis = 611, e.udieresis = 611, e.notequal = 549, e.gcommaaccent = 611, e.eth = 611, e.zcaron = 500, e.ncommaaccent = 611, e.onesuperior = 333, e.imacron = 278, e.Euro = 556;
            }), h["Helvetica-Oblique"] = (0, t.getLookupTableFactory)(function(e) {
              e.space = 278, e.exclam = 278, e.quotedbl = 355, e.numbersign = 556, e.dollar = 556, e.percent = 889, e.ampersand = 667, e.quoteright = 222, e.parenleft = 333, e.parenright = 333, e.asterisk = 389, e.plus = 584, e.comma = 278, e.hyphen = 333, e.period = 278, e.slash = 278, e.zero = 556, e.one = 556, e.two = 556, e.three = 556, e.four = 556, e.five = 556, e.six = 556, e.seven = 556, e.eight = 556, e.nine = 556, e.colon = 278, e.semicolon = 278, e.less = 584, e.equal = 584, e.greater = 584, e.question = 556, e.at = 1015, e.A = 667, e.B = 667, e.C = 722, e.D = 722, e.E = 667, e.F = 611, e.G = 778, e.H = 722, e.I = 278, e.J = 500, e.K = 667, e.L = 556, e.M = 833, e.N = 722, e.O = 778, e.P = 667, e.Q = 778, e.R = 722, e.S = 667, e.T = 611, e.U = 722, e.V = 667, e.W = 944, e.X = 667, e.Y = 667, e.Z = 611, e.bracketleft = 278, e.backslash = 278, e.bracketright = 278, e.asciicircum = 469, e.underscore = 556, e.quoteleft = 222, e.a = 556, e.b = 556, e.c = 500, e.d = 556, e.e = 556, e.f = 278, e.g = 556, e.h = 556, e.i = 222, e.j = 222, e.k = 500, e.l = 222, e.m = 833, e.n = 556, e.o = 556, e.p = 556, e.q = 556, e.r = 333, e.s = 500, e.t = 278, e.u = 556, e.v = 500, e.w = 722, e.x = 500, e.y = 500, e.z = 500, e.braceleft = 334, e.bar = 260, e.braceright = 334, e.asciitilde = 584, e.exclamdown = 333, e.cent = 556, e.sterling = 556, e.fraction = 167, e.yen = 556, e.florin = 556, e.section = 556, e.currency = 556, e.quotesingle = 191, e.quotedblleft = 333, e.guillemotleft = 556, e.guilsinglleft = 333, e.guilsinglright = 333, e.fi = 500, e.fl = 500, e.endash = 556, e.dagger = 556, e.daggerdbl = 556, e.periodcentered = 278, e.paragraph = 537, e.bullet = 350, e.quotesinglbase = 222, e.quotedblbase = 333, e.quotedblright = 333, e.guillemotright = 556, e.ellipsis = 1e3, e.perthousand = 1e3, e.questiondown = 611, e.grave = 333, e.acute = 333, e.circumflex = 333, e.tilde = 333, e.macron = 333, e.breve = 333, e.dotaccent = 333, e.dieresis = 333, e.ring = 333, e.cedilla = 333, e.hungarumlaut = 333, e.ogonek = 333, e.caron = 333, e.emdash = 1e3, e.AE = 1e3, e.ordfeminine = 370, e.Lslash = 556, e.Oslash = 778, e.OE = 1e3, e.ordmasculine = 365, e.ae = 889, e.dotlessi = 278, e.lslash = 222, e.oslash = 611, e.oe = 944, e.germandbls = 611, e.Idieresis = 278, e.eacute = 556, e.abreve = 556, e.uhungarumlaut = 556, e.ecaron = 556, e.Ydieresis = 667, e.divide = 584, e.Yacute = 667, e.Acircumflex = 667, e.aacute = 556, e.Ucircumflex = 722, e.yacute = 500, e.scommaaccent = 500, e.ecircumflex = 556, e.Uring = 722, e.Udieresis = 722, e.aogonek = 556, e.Uacute = 722, e.uogonek = 556, e.Edieresis = 667, e.Dcroat = 722, e.commaaccent = 250, e.copyright = 737, e.Emacron = 667, e.ccaron = 500, e.aring = 556, e.Ncommaaccent = 722, e.lacute = 222, e.agrave = 556, e.Tcommaaccent = 611, e.Cacute = 722, e.atilde = 556, e.Edotaccent = 667, e.scaron = 500, e.scedilla = 500, e.iacute = 278, e.lozenge = 471, e.Rcaron = 722, e.Gcommaaccent = 778, e.ucircumflex = 556, e.acircumflex = 556, e.Amacron = 667, e.rcaron = 333, e.ccedilla = 500, e.Zdotaccent = 611, e.Thorn = 667, e.Omacron = 778, e.Racute = 722, e.Sacute = 667, e.dcaron = 643, e.Umacron = 722, e.uring = 556, e.threesuperior = 333, e.Ograve = 778, e.Agrave = 667, e.Abreve = 667, e.multiply = 584, e.uacute = 556, e.Tcaron = 611, e.partialdiff = 476, e.ydieresis = 500, e.Nacute = 722, e.icircumflex = 278, e.Ecircumflex = 667, e.adieresis = 556, e.edieresis = 556, e.cacute = 500, e.nacute = 556, e.umacron = 556, e.Ncaron = 722, e.Iacute = 278, e.plusminus = 584, e.brokenbar = 260, e.registered = 737, e.Gbreve = 778, e.Idotaccent = 278, e.summation = 600, e.Egrave = 667, e.racute = 333, e.omacron = 556, e.Zacute = 611, e.Zcaron = 611, e.greaterequal = 549, e.Eth = 722, e.Ccedilla = 722, e.lcommaaccent = 222, e.tcaron = 317, e.eogonek = 556, e.Uogonek = 722, e.Aacute = 667, e.Adieresis = 667, e.egrave = 556, e.zacute = 500, e.iogonek = 222, e.Oacute = 778, e.oacute = 556, e.amacron = 556, e.sacute = 500, e.idieresis = 278, e.Ocircumflex = 778, e.Ugrave = 722, e.Delta = 612, e.thorn = 556, e.twosuperior = 333, e.Odieresis = 778, e.mu = 556, e.igrave = 278, e.ohungarumlaut = 556, e.Eogonek = 667, e.dcroat = 556, e.threequarters = 834, e.Scedilla = 667, e.lcaron = 299, e.Kcommaaccent = 667, e.Lacute = 556, e.trademark = 1e3, e.edotaccent = 556, e.Igrave = 278, e.Imacron = 278, e.Lcaron = 556, e.onehalf = 834, e.lessequal = 549, e.ocircumflex = 556, e.ntilde = 556, e.Uhungarumlaut = 722, e.Eacute = 667, e.emacron = 556, e.gbreve = 556, e.onequarter = 834, e.Scaron = 667, e.Scommaaccent = 667, e.Ohungarumlaut = 778, e.degree = 400, e.ograve = 556, e.Ccaron = 722, e.ugrave = 556, e.radical = 453, e.Dcaron = 722, e.rcommaaccent = 333, e.Ntilde = 722, e.otilde = 556, e.Rcommaaccent = 722, e.Lcommaaccent = 556, e.Atilde = 667, e.Aogonek = 667, e.Aring = 667, e.Otilde = 778, e.zdotaccent = 500, e.Ecaron = 667, e.Iogonek = 278, e.kcommaaccent = 500, e.minus = 584, e.Icircumflex = 278, e.ncaron = 556, e.tcommaaccent = 278, e.logicalnot = 584, e.odieresis = 556, e.udieresis = 556, e.notequal = 549, e.gcommaaccent = 556, e.eth = 556, e.zcaron = 500, e.ncommaaccent = 556, e.onesuperior = 333, e.imacron = 278, e.Euro = 556;
            }), h.Symbol = (0, t.getLookupTableFactory)(function(e) {
              e.space = 250, e.exclam = 333, e.universal = 713, e.numbersign = 500, e.existential = 549, e.percent = 833, e.ampersand = 778, e.suchthat = 439, e.parenleft = 333, e.parenright = 333, e.asteriskmath = 500, e.plus = 549, e.comma = 250, e.minus = 549, e.period = 250, e.slash = 278, e.zero = 500, e.one = 500, e.two = 500, e.three = 500, e.four = 500, e.five = 500, e.six = 500, e.seven = 500, e.eight = 500, e.nine = 500, e.colon = 278, e.semicolon = 278, e.less = 549, e.equal = 549, e.greater = 549, e.question = 444, e.congruent = 549, e.Alpha = 722, e.Beta = 667, e.Chi = 722, e.Delta = 612, e.Epsilon = 611, e.Phi = 763, e.Gamma = 603, e.Eta = 722, e.Iota = 333, e.theta1 = 631, e.Kappa = 722, e.Lambda = 686, e.Mu = 889, e.Nu = 722, e.Omicron = 722, e.Pi = 768, e.Theta = 741, e.Rho = 556, e.Sigma = 592, e.Tau = 611, e.Upsilon = 690, e.sigma1 = 439, e.Omega = 768, e.Xi = 645, e.Psi = 795, e.Zeta = 611, e.bracketleft = 333, e.therefore = 863, e.bracketright = 333, e.perpendicular = 658, e.underscore = 500, e.radicalex = 500, e.alpha = 631, e.beta = 549, e.chi = 549, e.delta = 494, e.epsilon = 439, e.phi = 521, e.gamma = 411, e.eta = 603, e.iota = 329, e.phi1 = 603, e.kappa = 549, e.lambda = 549, e.mu = 576, e.nu = 521, e.omicron = 549, e.pi = 549, e.theta = 521, e.rho = 549, e.sigma = 603, e.tau = 439, e.upsilon = 576, e.omega1 = 713, e.omega = 686, e.xi = 493, e.psi = 686, e.zeta = 494, e.braceleft = 480, e.bar = 200, e.braceright = 480, e.similar = 549, e.Euro = 750, e.Upsilon1 = 620, e.minute = 247, e.lessequal = 549, e.fraction = 167, e.infinity = 713, e.florin = 500, e.club = 753, e.diamond = 753, e.heart = 753, e.spade = 753, e.arrowboth = 1042, e.arrowleft = 987, e.arrowup = 603, e.arrowright = 987, e.arrowdown = 603, e.degree = 400, e.plusminus = 549, e.second = 411, e.greaterequal = 549, e.multiply = 549, e.proportional = 713, e.partialdiff = 494, e.bullet = 460, e.divide = 549, e.notequal = 549, e.equivalence = 549, e.approxequal = 549, e.ellipsis = 1e3, e.arrowvertex = 603, e.arrowhorizex = 1e3, e.carriagereturn = 658, e.aleph = 823, e.Ifraktur = 686, e.Rfraktur = 795, e.weierstrass = 987, e.circlemultiply = 768, e.circleplus = 768, e.emptyset = 823, e.intersection = 768, e.union = 768, e.propersuperset = 713, e.reflexsuperset = 713, e.notsubset = 713, e.propersubset = 713, e.reflexsubset = 713, e.element = 713, e.notelement = 713, e.angle = 768, e.gradient = 713, e.registerserif = 790, e.copyrightserif = 790, e.trademarkserif = 890, e.product = 823, e.radical = 549, e.dotmath = 250, e.logicalnot = 713, e.logicaland = 603, e.logicalor = 603, e.arrowdblboth = 1042, e.arrowdblleft = 987, e.arrowdblup = 603, e.arrowdblright = 987, e.arrowdbldown = 603, e.lozenge = 494, e.angleleft = 329, e.registersans = 790, e.copyrightsans = 790, e.trademarksans = 786, e.summation = 713, e.parenlefttp = 384, e.parenleftex = 384, e.parenleftbt = 384, e.bracketlefttp = 384, e.bracketleftex = 384, e.bracketleftbt = 384, e.bracelefttp = 494, e.braceleftmid = 494, e.braceleftbt = 494, e.braceex = 494, e.angleright = 329, e.integral = 274, e.integraltp = 686, e.integralex = 686, e.integralbt = 686, e.parenrighttp = 384, e.parenrightex = 384, e.parenrightbt = 384, e.bracketrighttp = 384, e.bracketrightex = 384, e.bracketrightbt = 384, e.bracerighttp = 494, e.bracerightmid = 494, e.bracerightbt = 494, e.apple = 790;
            }), h["Times-Roman"] = (0, t.getLookupTableFactory)(function(e) {
              e.space = 250, e.exclam = 333, e.quotedbl = 408, e.numbersign = 500, e.dollar = 500, e.percent = 833, e.ampersand = 778, e.quoteright = 333, e.parenleft = 333, e.parenright = 333, e.asterisk = 500, e.plus = 564, e.comma = 250, e.hyphen = 333, e.period = 250, e.slash = 278, e.zero = 500, e.one = 500, e.two = 500, e.three = 500, e.four = 500, e.five = 500, e.six = 500, e.seven = 500, e.eight = 500, e.nine = 500, e.colon = 278, e.semicolon = 278, e.less = 564, e.equal = 564, e.greater = 564, e.question = 444, e.at = 921, e.A = 722, e.B = 667, e.C = 667, e.D = 722, e.E = 611, e.F = 556, e.G = 722, e.H = 722, e.I = 333, e.J = 389, e.K = 722, e.L = 611, e.M = 889, e.N = 722, e.O = 722, e.P = 556, e.Q = 722, e.R = 667, e.S = 556, e.T = 611, e.U = 722, e.V = 722, e.W = 944, e.X = 722, e.Y = 722, e.Z = 611, e.bracketleft = 333, e.backslash = 278, e.bracketright = 333, e.asciicircum = 469, e.underscore = 500, e.quoteleft = 333, e.a = 444, e.b = 500, e.c = 444, e.d = 500, e.e = 444, e.f = 333, e.g = 500, e.h = 500, e.i = 278, e.j = 278, e.k = 500, e.l = 278, e.m = 778, e.n = 500, e.o = 500, e.p = 500, e.q = 500, e.r = 333, e.s = 389, e.t = 278, e.u = 500, e.v = 500, e.w = 722, e.x = 500, e.y = 500, e.z = 444, e.braceleft = 480, e.bar = 200, e.braceright = 480, e.asciitilde = 541, e.exclamdown = 333, e.cent = 500, e.sterling = 500, e.fraction = 167, e.yen = 500, e.florin = 500, e.section = 500, e.currency = 500, e.quotesingle = 180, e.quotedblleft = 444, e.guillemotleft = 500, e.guilsinglleft = 333, e.guilsinglright = 333, e.fi = 556, e.fl = 556, e.endash = 500, e.dagger = 500, e.daggerdbl = 500, e.periodcentered = 250, e.paragraph = 453, e.bullet = 350, e.quotesinglbase = 333, e.quotedblbase = 444, e.quotedblright = 444, e.guillemotright = 500, e.ellipsis = 1e3, e.perthousand = 1e3, e.questiondown = 444, e.grave = 333, e.acute = 333, e.circumflex = 333, e.tilde = 333, e.macron = 333, e.breve = 333, e.dotaccent = 333, e.dieresis = 333, e.ring = 333, e.cedilla = 333, e.hungarumlaut = 333, e.ogonek = 333, e.caron = 333, e.emdash = 1e3, e.AE = 889, e.ordfeminine = 276, e.Lslash = 611, e.Oslash = 722, e.OE = 889, e.ordmasculine = 310, e.ae = 667, e.dotlessi = 278, e.lslash = 278, e.oslash = 500, e.oe = 722, e.germandbls = 500, e.Idieresis = 333, e.eacute = 444, e.abreve = 444, e.uhungarumlaut = 500, e.ecaron = 444, e.Ydieresis = 722, e.divide = 564, e.Yacute = 722, e.Acircumflex = 722, e.aacute = 444, e.Ucircumflex = 722, e.yacute = 500, e.scommaaccent = 389, e.ecircumflex = 444, e.Uring = 722, e.Udieresis = 722, e.aogonek = 444, e.Uacute = 722, e.uogonek = 500, e.Edieresis = 611, e.Dcroat = 722, e.commaaccent = 250, e.copyright = 760, e.Emacron = 611, e.ccaron = 444, e.aring = 444, e.Ncommaaccent = 722, e.lacute = 278, e.agrave = 444, e.Tcommaaccent = 611, e.Cacute = 667, e.atilde = 444, e.Edotaccent = 611, e.scaron = 389, e.scedilla = 389, e.iacute = 278, e.lozenge = 471, e.Rcaron = 667, e.Gcommaaccent = 722, e.ucircumflex = 500, e.acircumflex = 444, e.Amacron = 722, e.rcaron = 333, e.ccedilla = 444, e.Zdotaccent = 611, e.Thorn = 556, e.Omacron = 722, e.Racute = 667, e.Sacute = 556, e.dcaron = 588, e.Umacron = 722, e.uring = 500, e.threesuperior = 300, e.Ograve = 722, e.Agrave = 722, e.Abreve = 722, e.multiply = 564, e.uacute = 500, e.Tcaron = 611, e.partialdiff = 476, e.ydieresis = 500, e.Nacute = 722, e.icircumflex = 278, e.Ecircumflex = 611, e.adieresis = 444, e.edieresis = 444, e.cacute = 444, e.nacute = 500, e.umacron = 500, e.Ncaron = 722, e.Iacute = 333, e.plusminus = 564, e.brokenbar = 200, e.registered = 760, e.Gbreve = 722, e.Idotaccent = 333, e.summation = 600, e.Egrave = 611, e.racute = 333, e.omacron = 500, e.Zacute = 611, e.Zcaron = 611, e.greaterequal = 549, e.Eth = 722, e.Ccedilla = 667, e.lcommaaccent = 278, e.tcaron = 326, e.eogonek = 444, e.Uogonek = 722, e.Aacute = 722, e.Adieresis = 722, e.egrave = 444, e.zacute = 444, e.iogonek = 278, e.Oacute = 722, e.oacute = 500, e.amacron = 444, e.sacute = 389, e.idieresis = 278, e.Ocircumflex = 722, e.Ugrave = 722, e.Delta = 612, e.thorn = 500, e.twosuperior = 300, e.Odieresis = 722, e.mu = 500, e.igrave = 278, e.ohungarumlaut = 500, e.Eogonek = 611, e.dcroat = 500, e.threequarters = 750, e.Scedilla = 556, e.lcaron = 344, e.Kcommaaccent = 722, e.Lacute = 611, e.trademark = 980, e.edotaccent = 444, e.Igrave = 333, e.Imacron = 333, e.Lcaron = 611, e.onehalf = 750, e.lessequal = 549, e.ocircumflex = 500, e.ntilde = 500, e.Uhungarumlaut = 722, e.Eacute = 611, e.emacron = 444, e.gbreve = 500, e.onequarter = 750, e.Scaron = 556, e.Scommaaccent = 556, e.Ohungarumlaut = 722, e.degree = 400, e.ograve = 500, e.Ccaron = 667, e.ugrave = 500, e.radical = 453, e.Dcaron = 722, e.rcommaaccent = 333, e.Ntilde = 722, e.otilde = 500, e.Rcommaaccent = 667, e.Lcommaaccent = 611, e.Atilde = 722, e.Aogonek = 722, e.Aring = 722, e.Otilde = 722, e.zdotaccent = 444, e.Ecaron = 611, e.Iogonek = 333, e.kcommaaccent = 500, e.minus = 564, e.Icircumflex = 333, e.ncaron = 500, e.tcommaaccent = 278, e.logicalnot = 564, e.odieresis = 500, e.udieresis = 500, e.notequal = 549, e.gcommaaccent = 500, e.eth = 500, e.zcaron = 444, e.ncommaaccent = 500, e.onesuperior = 300, e.imacron = 278, e.Euro = 500;
            }), h["Times-Bold"] = (0, t.getLookupTableFactory)(function(e) {
              e.space = 250, e.exclam = 333, e.quotedbl = 555, e.numbersign = 500, e.dollar = 500, e.percent = 1e3, e.ampersand = 833, e.quoteright = 333, e.parenleft = 333, e.parenright = 333, e.asterisk = 500, e.plus = 570, e.comma = 250, e.hyphen = 333, e.period = 250, e.slash = 278, e.zero = 500, e.one = 500, e.two = 500, e.three = 500, e.four = 500, e.five = 500, e.six = 500, e.seven = 500, e.eight = 500, e.nine = 500, e.colon = 333, e.semicolon = 333, e.less = 570, e.equal = 570, e.greater = 570, e.question = 500, e.at = 930, e.A = 722, e.B = 667, e.C = 722, e.D = 722, e.E = 667, e.F = 611, e.G = 778, e.H = 778, e.I = 389, e.J = 500, e.K = 778, e.L = 667, e.M = 944, e.N = 722, e.O = 778, e.P = 611, e.Q = 778, e.R = 722, e.S = 556, e.T = 667, e.U = 722, e.V = 722, e.W = 1e3, e.X = 722, e.Y = 722, e.Z = 667, e.bracketleft = 333, e.backslash = 278, e.bracketright = 333, e.asciicircum = 581, e.underscore = 500, e.quoteleft = 333, e.a = 500, e.b = 556, e.c = 444, e.d = 556, e.e = 444, e.f = 333, e.g = 500, e.h = 556, e.i = 278, e.j = 333, e.k = 556, e.l = 278, e.m = 833, e.n = 556, e.o = 500, e.p = 556, e.q = 556, e.r = 444, e.s = 389, e.t = 333, e.u = 556, e.v = 500, e.w = 722, e.x = 500, e.y = 500, e.z = 444, e.braceleft = 394, e.bar = 220, e.braceright = 394, e.asciitilde = 520, e.exclamdown = 333, e.cent = 500, e.sterling = 500, e.fraction = 167, e.yen = 500, e.florin = 500, e.section = 500, e.currency = 500, e.quotesingle = 278, e.quotedblleft = 500, e.guillemotleft = 500, e.guilsinglleft = 333, e.guilsinglright = 333, e.fi = 556, e.fl = 556, e.endash = 500, e.dagger = 500, e.daggerdbl = 500, e.periodcentered = 250, e.paragraph = 540, e.bullet = 350, e.quotesinglbase = 333, e.quotedblbase = 500, e.quotedblright = 500, e.guillemotright = 500, e.ellipsis = 1e3, e.perthousand = 1e3, e.questiondown = 500, e.grave = 333, e.acute = 333, e.circumflex = 333, e.tilde = 333, e.macron = 333, e.breve = 333, e.dotaccent = 333, e.dieresis = 333, e.ring = 333, e.cedilla = 333, e.hungarumlaut = 333, e.ogonek = 333, e.caron = 333, e.emdash = 1e3, e.AE = 1e3, e.ordfeminine = 300, e.Lslash = 667, e.Oslash = 778, e.OE = 1e3, e.ordmasculine = 330, e.ae = 722, e.dotlessi = 278, e.lslash = 278, e.oslash = 500, e.oe = 722, e.germandbls = 556, e.Idieresis = 389, e.eacute = 444, e.abreve = 500, e.uhungarumlaut = 556, e.ecaron = 444, e.Ydieresis = 722, e.divide = 570, e.Yacute = 722, e.Acircumflex = 722, e.aacute = 500, e.Ucircumflex = 722, e.yacute = 500, e.scommaaccent = 389, e.ecircumflex = 444, e.Uring = 722, e.Udieresis = 722, e.aogonek = 500, e.Uacute = 722, e.uogonek = 556, e.Edieresis = 667, e.Dcroat = 722, e.commaaccent = 250, e.copyright = 747, e.Emacron = 667, e.ccaron = 444, e.aring = 500, e.Ncommaaccent = 722, e.lacute = 278, e.agrave = 500, e.Tcommaaccent = 667, e.Cacute = 722, e.atilde = 500, e.Edotaccent = 667, e.scaron = 389, e.scedilla = 389, e.iacute = 278, e.lozenge = 494, e.Rcaron = 722, e.Gcommaaccent = 778, e.ucircumflex = 556, e.acircumflex = 500, e.Amacron = 722, e.rcaron = 444, e.ccedilla = 444, e.Zdotaccent = 667, e.Thorn = 611, e.Omacron = 778, e.Racute = 722, e.Sacute = 556, e.dcaron = 672, e.Umacron = 722, e.uring = 556, e.threesuperior = 300, e.Ograve = 778, e.Agrave = 722, e.Abreve = 722, e.multiply = 570, e.uacute = 556, e.Tcaron = 667, e.partialdiff = 494, e.ydieresis = 500, e.Nacute = 722, e.icircumflex = 278, e.Ecircumflex = 667, e.adieresis = 500, e.edieresis = 444, e.cacute = 444, e.nacute = 556, e.umacron = 556, e.Ncaron = 722, e.Iacute = 389, e.plusminus = 570, e.brokenbar = 220, e.registered = 747, e.Gbreve = 778, e.Idotaccent = 389, e.summation = 600, e.Egrave = 667, e.racute = 444, e.omacron = 500, e.Zacute = 667, e.Zcaron = 667, e.greaterequal = 549, e.Eth = 722, e.Ccedilla = 722, e.lcommaaccent = 278, e.tcaron = 416, e.eogonek = 444, e.Uogonek = 722, e.Aacute = 722, e.Adieresis = 722, e.egrave = 444, e.zacute = 444, e.iogonek = 278, e.Oacute = 778, e.oacute = 500, e.amacron = 500, e.sacute = 389, e.idieresis = 278, e.Ocircumflex = 778, e.Ugrave = 722, e.Delta = 612, e.thorn = 556, e.twosuperior = 300, e.Odieresis = 778, e.mu = 556, e.igrave = 278, e.ohungarumlaut = 500, e.Eogonek = 667, e.dcroat = 556, e.threequarters = 750, e.Scedilla = 556, e.lcaron = 394, e.Kcommaaccent = 778, e.Lacute = 667, e.trademark = 1e3, e.edotaccent = 444, e.Igrave = 389, e.Imacron = 389, e.Lcaron = 667, e.onehalf = 750, e.lessequal = 549, e.ocircumflex = 500, e.ntilde = 556, e.Uhungarumlaut = 722, e.Eacute = 667, e.emacron = 444, e.gbreve = 500, e.onequarter = 750, e.Scaron = 556, e.Scommaaccent = 556, e.Ohungarumlaut = 778, e.degree = 400, e.ograve = 500, e.Ccaron = 722, e.ugrave = 556, e.radical = 549, e.Dcaron = 722, e.rcommaaccent = 444, e.Ntilde = 722, e.otilde = 500, e.Rcommaaccent = 722, e.Lcommaaccent = 667, e.Atilde = 722, e.Aogonek = 722, e.Aring = 722, e.Otilde = 778, e.zdotaccent = 444, e.Ecaron = 667, e.Iogonek = 389, e.kcommaaccent = 556, e.minus = 570, e.Icircumflex = 389, e.ncaron = 556, e.tcommaaccent = 333, e.logicalnot = 570, e.odieresis = 500, e.udieresis = 556, e.notequal = 549, e.gcommaaccent = 500, e.eth = 500, e.zcaron = 444, e.ncommaaccent = 556, e.onesuperior = 300, e.imacron = 278, e.Euro = 500;
            }), h["Times-BoldItalic"] = (0, t.getLookupTableFactory)(function(e) {
              e.space = 250, e.exclam = 389, e.quotedbl = 555, e.numbersign = 500, e.dollar = 500, e.percent = 833, e.ampersand = 778, e.quoteright = 333, e.parenleft = 333, e.parenright = 333, e.asterisk = 500, e.plus = 570, e.comma = 250, e.hyphen = 333, e.period = 250, e.slash = 278, e.zero = 500, e.one = 500, e.two = 500, e.three = 500, e.four = 500, e.five = 500, e.six = 500, e.seven = 500, e.eight = 500, e.nine = 500, e.colon = 333, e.semicolon = 333, e.less = 570, e.equal = 570, e.greater = 570, e.question = 500, e.at = 832, e.A = 667, e.B = 667, e.C = 667, e.D = 722, e.E = 667, e.F = 667, e.G = 722, e.H = 778, e.I = 389, e.J = 500, e.K = 667, e.L = 611, e.M = 889, e.N = 722, e.O = 722, e.P = 611, e.Q = 722, e.R = 667, e.S = 556, e.T = 611, e.U = 722, e.V = 667, e.W = 889, e.X = 667, e.Y = 611, e.Z = 611, e.bracketleft = 333, e.backslash = 278, e.bracketright = 333, e.asciicircum = 570, e.underscore = 500, e.quoteleft = 333, e.a = 500, e.b = 500, e.c = 444, e.d = 500, e.e = 444, e.f = 333, e.g = 500, e.h = 556, e.i = 278, e.j = 278, e.k = 500, e.l = 278, e.m = 778, e.n = 556, e.o = 500, e.p = 500, e.q = 500, e.r = 389, e.s = 389, e.t = 278, e.u = 556, e.v = 444, e.w = 667, e.x = 500, e.y = 444, e.z = 389, e.braceleft = 348, e.bar = 220, e.braceright = 348, e.asciitilde = 570, e.exclamdown = 389, e.cent = 500, e.sterling = 500, e.fraction = 167, e.yen = 500, e.florin = 500, e.section = 500, e.currency = 500, e.quotesingle = 278, e.quotedblleft = 500, e.guillemotleft = 500, e.guilsinglleft = 333, e.guilsinglright = 333, e.fi = 556, e.fl = 556, e.endash = 500, e.dagger = 500, e.daggerdbl = 500, e.periodcentered = 250, e.paragraph = 500, e.bullet = 350, e.quotesinglbase = 333, e.quotedblbase = 500, e.quotedblright = 500, e.guillemotright = 500, e.ellipsis = 1e3, e.perthousand = 1e3, e.questiondown = 500, e.grave = 333, e.acute = 333, e.circumflex = 333, e.tilde = 333, e.macron = 333, e.breve = 333, e.dotaccent = 333, e.dieresis = 333, e.ring = 333, e.cedilla = 333, e.hungarumlaut = 333, e.ogonek = 333, e.caron = 333, e.emdash = 1e3, e.AE = 944, e.ordfeminine = 266, e.Lslash = 611, e.Oslash = 722, e.OE = 944, e.ordmasculine = 300, e.ae = 722, e.dotlessi = 278, e.lslash = 278, e.oslash = 500, e.oe = 722, e.germandbls = 500, e.Idieresis = 389, e.eacute = 444, e.abreve = 500, e.uhungarumlaut = 556, e.ecaron = 444, e.Ydieresis = 611, e.divide = 570, e.Yacute = 611, e.Acircumflex = 667, e.aacute = 500, e.Ucircumflex = 722, e.yacute = 444, e.scommaaccent = 389, e.ecircumflex = 444, e.Uring = 722, e.Udieresis = 722, e.aogonek = 500, e.Uacute = 722, e.uogonek = 556, e.Edieresis = 667, e.Dcroat = 722, e.commaaccent = 250, e.copyright = 747, e.Emacron = 667, e.ccaron = 444, e.aring = 500, e.Ncommaaccent = 722, e.lacute = 278, e.agrave = 500, e.Tcommaaccent = 611, e.Cacute = 667, e.atilde = 500, e.Edotaccent = 667, e.scaron = 389, e.scedilla = 389, e.iacute = 278, e.lozenge = 494, e.Rcaron = 667, e.Gcommaaccent = 722, e.ucircumflex = 556, e.acircumflex = 500, e.Amacron = 667, e.rcaron = 389, e.ccedilla = 444, e.Zdotaccent = 611, e.Thorn = 611, e.Omacron = 722, e.Racute = 667, e.Sacute = 556, e.dcaron = 608, e.Umacron = 722, e.uring = 556, e.threesuperior = 300, e.Ograve = 722, e.Agrave = 667, e.Abreve = 667, e.multiply = 570, e.uacute = 556, e.Tcaron = 611, e.partialdiff = 494, e.ydieresis = 444, e.Nacute = 722, e.icircumflex = 278, e.Ecircumflex = 667, e.adieresis = 500, e.edieresis = 444, e.cacute = 444, e.nacute = 556, e.umacron = 556, e.Ncaron = 722, e.Iacute = 389, e.plusminus = 570, e.brokenbar = 220, e.registered = 747, e.Gbreve = 722, e.Idotaccent = 389, e.summation = 600, e.Egrave = 667, e.racute = 389, e.omacron = 500, e.Zacute = 611, e.Zcaron = 611, e.greaterequal = 549, e.Eth = 722, e.Ccedilla = 667, e.lcommaaccent = 278, e.tcaron = 366, e.eogonek = 444, e.Uogonek = 722, e.Aacute = 667, e.Adieresis = 667, e.egrave = 444, e.zacute = 389, e.iogonek = 278, e.Oacute = 722, e.oacute = 500, e.amacron = 500, e.sacute = 389, e.idieresis = 278, e.Ocircumflex = 722, e.Ugrave = 722, e.Delta = 612, e.thorn = 500, e.twosuperior = 300, e.Odieresis = 722, e.mu = 576, e.igrave = 278, e.ohungarumlaut = 500, e.Eogonek = 667, e.dcroat = 500, e.threequarters = 750, e.Scedilla = 556, e.lcaron = 382, e.Kcommaaccent = 667, e.Lacute = 611, e.trademark = 1e3, e.edotaccent = 444, e.Igrave = 389, e.Imacron = 389, e.Lcaron = 611, e.onehalf = 750, e.lessequal = 549, e.ocircumflex = 500, e.ntilde = 556, e.Uhungarumlaut = 722, e.Eacute = 667, e.emacron = 444, e.gbreve = 500, e.onequarter = 750, e.Scaron = 556, e.Scommaaccent = 556, e.Ohungarumlaut = 722, e.degree = 400, e.ograve = 500, e.Ccaron = 667, e.ugrave = 556, e.radical = 549, e.Dcaron = 722, e.rcommaaccent = 389, e.Ntilde = 722, e.otilde = 500, e.Rcommaaccent = 667, e.Lcommaaccent = 611, e.Atilde = 667, e.Aogonek = 667, e.Aring = 667, e.Otilde = 722, e.zdotaccent = 389, e.Ecaron = 667, e.Iogonek = 389, e.kcommaaccent = 500, e.minus = 606, e.Icircumflex = 389, e.ncaron = 556, e.tcommaaccent = 278, e.logicalnot = 606, e.odieresis = 500, e.udieresis = 556, e.notequal = 549, e.gcommaaccent = 500, e.eth = 500, e.zcaron = 389, e.ncommaaccent = 556, e.onesuperior = 300, e.imacron = 278, e.Euro = 500;
            }), h["Times-Italic"] = (0, t.getLookupTableFactory)(function(e) {
              e.space = 250, e.exclam = 333, e.quotedbl = 420, e.numbersign = 500, e.dollar = 500, e.percent = 833, e.ampersand = 778, e.quoteright = 333, e.parenleft = 333, e.parenright = 333, e.asterisk = 500, e.plus = 675, e.comma = 250, e.hyphen = 333, e.period = 250, e.slash = 278, e.zero = 500, e.one = 500, e.two = 500, e.three = 500, e.four = 500, e.five = 500, e.six = 500, e.seven = 500, e.eight = 500, e.nine = 500, e.colon = 333, e.semicolon = 333, e.less = 675, e.equal = 675, e.greater = 675, e.question = 500, e.at = 920, e.A = 611, e.B = 611, e.C = 667, e.D = 722, e.E = 611, e.F = 611, e.G = 722, e.H = 722, e.I = 333, e.J = 444, e.K = 667, e.L = 556, e.M = 833, e.N = 667, e.O = 722, e.P = 611, e.Q = 722, e.R = 611, e.S = 500, e.T = 556, e.U = 722, e.V = 611, e.W = 833, e.X = 611, e.Y = 556, e.Z = 556, e.bracketleft = 389, e.backslash = 278, e.bracketright = 389, e.asciicircum = 422, e.underscore = 500, e.quoteleft = 333, e.a = 500, e.b = 500, e.c = 444, e.d = 500, e.e = 444, e.f = 278, e.g = 500, e.h = 500, e.i = 278, e.j = 278, e.k = 444, e.l = 278, e.m = 722, e.n = 500, e.o = 500, e.p = 500, e.q = 500, e.r = 389, e.s = 389, e.t = 278, e.u = 500, e.v = 444, e.w = 667, e.x = 444, e.y = 444, e.z = 389, e.braceleft = 400, e.bar = 275, e.braceright = 400, e.asciitilde = 541, e.exclamdown = 389, e.cent = 500, e.sterling = 500, e.fraction = 167, e.yen = 500, e.florin = 500, e.section = 500, e.currency = 500, e.quotesingle = 214, e.quotedblleft = 556, e.guillemotleft = 500, e.guilsinglleft = 333, e.guilsinglright = 333, e.fi = 500, e.fl = 500, e.endash = 500, e.dagger = 500, e.daggerdbl = 500, e.periodcentered = 250, e.paragraph = 523, e.bullet = 350, e.quotesinglbase = 333, e.quotedblbase = 556, e.quotedblright = 556, e.guillemotright = 500, e.ellipsis = 889, e.perthousand = 1e3, e.questiondown = 500, e.grave = 333, e.acute = 333, e.circumflex = 333, e.tilde = 333, e.macron = 333, e.breve = 333, e.dotaccent = 333, e.dieresis = 333, e.ring = 333, e.cedilla = 333, e.hungarumlaut = 333, e.ogonek = 333, e.caron = 333, e.emdash = 889, e.AE = 889, e.ordfeminine = 276, e.Lslash = 556, e.Oslash = 722, e.OE = 944, e.ordmasculine = 310, e.ae = 667, e.dotlessi = 278, e.lslash = 278, e.oslash = 500, e.oe = 667, e.germandbls = 500, e.Idieresis = 333, e.eacute = 444, e.abreve = 500, e.uhungarumlaut = 500, e.ecaron = 444, e.Ydieresis = 556, e.divide = 675, e.Yacute = 556, e.Acircumflex = 611, e.aacute = 500, e.Ucircumflex = 722, e.yacute = 444, e.scommaaccent = 389, e.ecircumflex = 444, e.Uring = 722, e.Udieresis = 722, e.aogonek = 500, e.Uacute = 722, e.uogonek = 500, e.Edieresis = 611, e.Dcroat = 722, e.commaaccent = 250, e.copyright = 760, e.Emacron = 611, e.ccaron = 444, e.aring = 500, e.Ncommaaccent = 667, e.lacute = 278, e.agrave = 500, e.Tcommaaccent = 556, e.Cacute = 667, e.atilde = 500, e.Edotaccent = 611, e.scaron = 389, e.scedilla = 389, e.iacute = 278, e.lozenge = 471, e.Rcaron = 611, e.Gcommaaccent = 722, e.ucircumflex = 500, e.acircumflex = 500, e.Amacron = 611, e.rcaron = 389, e.ccedilla = 444, e.Zdotaccent = 556, e.Thorn = 611, e.Omacron = 722, e.Racute = 611, e.Sacute = 500, e.dcaron = 544, e.Umacron = 722, e.uring = 500, e.threesuperior = 300, e.Ograve = 722, e.Agrave = 611, e.Abreve = 611, e.multiply = 675, e.uacute = 500, e.Tcaron = 556, e.partialdiff = 476, e.ydieresis = 444, e.Nacute = 667, e.icircumflex = 278, e.Ecircumflex = 611, e.adieresis = 500, e.edieresis = 444, e.cacute = 444, e.nacute = 500, e.umacron = 500, e.Ncaron = 667, e.Iacute = 333, e.plusminus = 675, e.brokenbar = 275, e.registered = 760, e.Gbreve = 722, e.Idotaccent = 333, e.summation = 600, e.Egrave = 611, e.racute = 389, e.omacron = 500, e.Zacute = 556, e.Zcaron = 556, e.greaterequal = 549, e.Eth = 722, e.Ccedilla = 667, e.lcommaaccent = 278, e.tcaron = 300, e.eogonek = 444, e.Uogonek = 722, e.Aacute = 611, e.Adieresis = 611, e.egrave = 444, e.zacute = 389, e.iogonek = 278, e.Oacute = 722, e.oacute = 500, e.amacron = 500, e.sacute = 389, e.idieresis = 278, e.Ocircumflex = 722, e.Ugrave = 722, e.Delta = 612, e.thorn = 500, e.twosuperior = 300, e.Odieresis = 722, e.mu = 500, e.igrave = 278, e.ohungarumlaut = 500, e.Eogonek = 611, e.dcroat = 500, e.threequarters = 750, e.Scedilla = 500, e.lcaron = 300, e.Kcommaaccent = 667, e.Lacute = 556, e.trademark = 980, e.edotaccent = 444, e.Igrave = 333, e.Imacron = 333, e.Lcaron = 611, e.onehalf = 750, e.lessequal = 549, e.ocircumflex = 500, e.ntilde = 500, e.Uhungarumlaut = 722, e.Eacute = 611, e.emacron = 444, e.gbreve = 500, e.onequarter = 750, e.Scaron = 500, e.Scommaaccent = 500, e.Ohungarumlaut = 722, e.degree = 400, e.ograve = 500, e.Ccaron = 667, e.ugrave = 500, e.radical = 453, e.Dcaron = 722, e.rcommaaccent = 389, e.Ntilde = 667, e.otilde = 500, e.Rcommaaccent = 611, e.Lcommaaccent = 556, e.Atilde = 611, e.Aogonek = 611, e.Aring = 611, e.Otilde = 722, e.zdotaccent = 389, e.Ecaron = 611, e.Iogonek = 333, e.kcommaaccent = 444, e.minus = 675, e.Icircumflex = 333, e.ncaron = 500, e.tcommaaccent = 278, e.logicalnot = 675, e.odieresis = 500, e.udieresis = 500, e.notequal = 549, e.gcommaaccent = 500, e.eth = 500, e.zcaron = 389, e.ncommaaccent = 500, e.onesuperior = 300, e.imacron = 278, e.Euro = 500;
            }), h.ZapfDingbats = (0, t.getLookupTableFactory)(function(e) {
              e.space = 278, e.a1 = 974, e.a2 = 961, e.a202 = 974, e.a3 = 980, e.a4 = 719, e.a5 = 789, e.a119 = 790, e.a118 = 791, e.a117 = 690, e.a11 = 960, e.a12 = 939, e.a13 = 549, e.a14 = 855, e.a15 = 911, e.a16 = 933, e.a105 = 911, e.a17 = 945, e.a18 = 974, e.a19 = 755, e.a20 = 846, e.a21 = 762, e.a22 = 761, e.a23 = 571, e.a24 = 677, e.a25 = 763, e.a26 = 760, e.a27 = 759, e.a28 = 754, e.a6 = 494, e.a7 = 552, e.a8 = 537, e.a9 = 577, e.a10 = 692, e.a29 = 786, e.a30 = 788, e.a31 = 788, e.a32 = 790, e.a33 = 793, e.a34 = 794, e.a35 = 816, e.a36 = 823, e.a37 = 789, e.a38 = 841, e.a39 = 823, e.a40 = 833, e.a41 = 816, e.a42 = 831, e.a43 = 923, e.a44 = 744, e.a45 = 723, e.a46 = 749, e.a47 = 790, e.a48 = 792, e.a49 = 695, e.a50 = 776, e.a51 = 768, e.a52 = 792, e.a53 = 759, e.a54 = 707, e.a55 = 708, e.a56 = 682, e.a57 = 701, e.a58 = 826, e.a59 = 815, e.a60 = 789, e.a61 = 789, e.a62 = 707, e.a63 = 687, e.a64 = 696, e.a65 = 689, e.a66 = 786, e.a67 = 787, e.a68 = 713, e.a69 = 791, e.a70 = 785, e.a71 = 791, e.a72 = 873, e.a73 = 761, e.a74 = 762, e.a203 = 762, e.a75 = 759, e.a204 = 759, e.a76 = 892, e.a77 = 892, e.a78 = 788, e.a79 = 784, e.a81 = 438, e.a82 = 138, e.a83 = 277, e.a84 = 415, e.a97 = 392, e.a98 = 392, e.a99 = 668, e.a100 = 668, e.a89 = 390, e.a90 = 390, e.a93 = 317, e.a94 = 317, e.a91 = 276, e.a92 = 276, e.a205 = 509, e.a85 = 509, e.a206 = 410, e.a86 = 410, e.a87 = 234, e.a88 = 234, e.a95 = 334, e.a96 = 334, e.a101 = 732, e.a102 = 544, e.a103 = 544, e.a104 = 910, e.a106 = 667, e.a107 = 760, e.a108 = 760, e.a112 = 776, e.a111 = 595, e.a110 = 694, e.a109 = 626, e.a120 = 788, e.a121 = 788, e.a122 = 788, e.a123 = 788, e.a124 = 788, e.a125 = 788, e.a126 = 788, e.a127 = 788, e.a128 = 788, e.a129 = 788, e.a130 = 788, e.a131 = 788, e.a132 = 788, e.a133 = 788, e.a134 = 788, e.a135 = 788, e.a136 = 788, e.a137 = 788, e.a138 = 788, e.a139 = 788, e.a140 = 788, e.a141 = 788, e.a142 = 788, e.a143 = 788, e.a144 = 788, e.a145 = 788, e.a146 = 788, e.a147 = 788, e.a148 = 788, e.a149 = 788, e.a150 = 788, e.a151 = 788, e.a152 = 788, e.a153 = 788, e.a154 = 788, e.a155 = 788, e.a156 = 788, e.a157 = 788, e.a158 = 788, e.a159 = 788, e.a160 = 894, e.a161 = 838, e.a163 = 1016, e.a164 = 458, e.a196 = 748, e.a165 = 924, e.a192 = 748, e.a166 = 918, e.a167 = 927, e.a168 = 928, e.a169 = 928, e.a170 = 834, e.a171 = 873, e.a172 = 828, e.a173 = 924, e.a162 = 924, e.a174 = 917, e.a175 = 930, e.a176 = 931, e.a177 = 463, e.a178 = 883, e.a179 = 836, e.a193 = 836, e.a180 = 867, e.a199 = 867, e.a181 = 696, e.a200 = 696, e.a182 = 874, e.a201 = 874, e.a183 = 760, e.a184 = 946, e.a197 = 771, e.a185 = 865, e.a194 = 771, e.a198 = 888, e.a186 = 967, e.a195 = 888, e.a187 = 831, e.a188 = 873, e.a189 = 927, e.a190 = 970, e.a191 = 918;
            });
          });
          o.getMetrics = a;
          const v = (0, t.getLookupTableFactory)(function(h) {
            h.Courier = {
              ascent: 629,
              descent: -157,
              capHeight: 562,
              xHeight: -426
            }, h["Courier-Bold"] = {
              ascent: 629,
              descent: -157,
              capHeight: 562,
              xHeight: 439
            }, h["Courier-Oblique"] = {
              ascent: 629,
              descent: -157,
              capHeight: 562,
              xHeight: 426
            }, h["Courier-BoldOblique"] = {
              ascent: 629,
              descent: -157,
              capHeight: 562,
              xHeight: 426
            }, h.Helvetica = {
              ascent: 718,
              descent: -207,
              capHeight: 718,
              xHeight: 523
            }, h["Helvetica-Bold"] = {
              ascent: 718,
              descent: -207,
              capHeight: 718,
              xHeight: 532
            }, h["Helvetica-Oblique"] = {
              ascent: 718,
              descent: -207,
              capHeight: 718,
              xHeight: 523
            }, h["Helvetica-BoldOblique"] = {
              ascent: 718,
              descent: -207,
              capHeight: 718,
              xHeight: 532
            }, h["Times-Roman"] = {
              ascent: 683,
              descent: -217,
              capHeight: 662,
              xHeight: 450
            }, h["Times-Bold"] = {
              ascent: 683,
              descent: -217,
              capHeight: 676,
              xHeight: 461
            }, h["Times-Italic"] = {
              ascent: 683,
              descent: -217,
              capHeight: 653,
              xHeight: 441
            }, h["Times-BoldItalic"] = {
              ascent: 683,
              descent: -217,
              capHeight: 669,
              xHeight: 462
            }, h.Symbol = {
              ascent: Math.NaN,
              descent: Math.NaN,
              capHeight: Math.NaN,
              xHeight: Math.NaN
            }, h.ZapfDingbats = {
              ascent: Math.NaN,
              descent: Math.NaN,
              capHeight: Math.NaN,
              xHeight: Math.NaN
            };
          });
          o.getFontBasicMetrics = v;
        },
        /* 46 */
        /***/
        (Z, o) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.GlyfTable = void 0;
          const C = 1 << 0, t = 1 << 1, a = 1 << 2, v = 1 << 3, h = 1 << 4, e = 1 << 5, y = 1 << 6, c = 1 << 0, d = 1 << 1, p = 1 << 3, m = 1 << 5, g = 1 << 6, n = 1 << 7, i = 1 << 8;
          class l {
            constructor({
              glyfTable: j,
              isGlyphLocationsLong: X,
              locaTable: B,
              numGlyphs: R
            }) {
              this.glyphs = [];
              const k = new DataView(B.buffer, B.byteOffset, B.byteLength), x = new DataView(j.buffer, j.byteOffset, j.byteLength), f = X ? 4 : 2;
              let U = X ? k.getUint32(0) : 2 * k.getUint16(0), O = 0;
              for (let S = 0; S < R; S++) {
                O += f;
                const F = X ? k.getUint32(O) : 2 * k.getUint16(O);
                if (F === U) {
                  this.glyphs.push(new u({}));
                  continue;
                }
                const T = u.parse(U, x);
                this.glyphs.push(T), U = F;
              }
            }
            getSize() {
              return this.glyphs.reduce((j, X) => {
                const B = X.getSize();
                return j + (B + 3 & -4);
              }, 0);
            }
            write() {
              const j = this.getSize(), X = new DataView(new ArrayBuffer(j)), B = j > 131070, R = B ? 4 : 2, k = new DataView(new ArrayBuffer((this.glyphs.length + 1) * R));
              B ? k.setUint32(0, 0) : k.setUint16(0, 0);
              let x = 0, f = 0;
              for (const U of this.glyphs)
                x += U.write(x, X), x = x + 3 & -4, f += R, B ? k.setUint32(f, x) : k.setUint16(f, x >> 1);
              return {
                isLocationLong: B,
                loca: new Uint8Array(k.buffer),
                glyf: new Uint8Array(X.buffer)
              };
            }
            scale(j) {
              for (let X = 0, B = this.glyphs.length; X < B; X++)
                this.glyphs[X].scale(j[X]);
            }
          }
          o.GlyfTable = l;
          class u {
            constructor({
              header: j = null,
              simple: X = null,
              composites: B = null
            }) {
              this.header = j, this.simple = X, this.composites = B;
            }
            static parse(j, X) {
              const [B, R] = w.parse(j, X);
              if (j += B, R.numberOfContours < 0) {
                const x = [];
                for (; ; ) {
                  const [f, U] = A.parse(j, X);
                  if (j += f, x.push(U), !(U.flags & m))
                    break;
                }
                return new u({
                  header: R,
                  composites: x
                });
              }
              const k = b.parse(j, X, R.numberOfContours);
              return new u({
                header: R,
                simple: k
              });
            }
            getSize() {
              if (!this.header)
                return 0;
              const j = this.simple ? this.simple.getSize() : this.composites.reduce((X, B) => X + B.getSize(), 0);
              return this.header.getSize() + j;
            }
            write(j, X) {
              if (!this.header)
                return 0;
              const B = j;
              if (j += this.header.write(j, X), this.simple)
                j += this.simple.write(j, X);
              else
                for (const R of this.composites)
                  j += R.write(j, X);
              return j - B;
            }
            scale(j) {
              if (!this.header)
                return;
              const X = (this.header.xMin + this.header.xMax) / 2;
              if (this.header.scale(X, j), this.simple)
                this.simple.scale(X, j);
              else
                for (const B of this.composites)
                  B.scale(X, j);
            }
          }
          class w {
            constructor({
              numberOfContours: j,
              xMin: X,
              yMin: B,
              xMax: R,
              yMax: k
            }) {
              this.numberOfContours = j, this.xMin = X, this.yMin = B, this.xMax = R, this.yMax = k;
            }
            static parse(j, X) {
              return [10, new w({
                numberOfContours: X.getInt16(j),
                xMin: X.getInt16(j + 2),
                yMin: X.getInt16(j + 4),
                xMax: X.getInt16(j + 6),
                yMax: X.getInt16(j + 8)
              })];
            }
            getSize() {
              return 10;
            }
            write(j, X) {
              return X.setInt16(j, this.numberOfContours), X.setInt16(j + 2, this.xMin), X.setInt16(j + 4, this.yMin), X.setInt16(j + 6, this.xMax), X.setInt16(j + 8, this.yMax), 10;
            }
            scale(j, X) {
              this.xMin = Math.round(j + (this.xMin - j) * X), this.xMax = Math.round(j + (this.xMax - j) * X);
            }
          }
          class _ {
            constructor({
              flags: j,
              xCoordinates: X,
              yCoordinates: B
            }) {
              this.xCoordinates = X, this.yCoordinates = B, this.flags = j;
            }
          }
          class b {
            constructor({
              contours: j,
              instructions: X
            }) {
              this.contours = j, this.instructions = X;
            }
            static parse(j, X, B) {
              const R = [];
              for (let J = 0; J < B; J++) {
                const W = X.getUint16(j);
                j += 2, R.push(W);
              }
              const k = R[B - 1] + 1, x = X.getUint16(j);
              j += 2;
              const f = new Uint8Array(X).slice(j, j + x);
              j += x;
              const U = [];
              for (let J = 0; J < k; j++, J++) {
                let W = X.getUint8(j);
                if (U.push(W), W & v) {
                  const z = X.getUint8(++j);
                  W ^= v;
                  for (let G = 0; G < z; G++)
                    U.push(W);
                  J += z;
                }
              }
              const O = [];
              let S = [], F = [], T = [];
              const I = [];
              let M = 0, V = 0;
              for (let J = 0; J < k; J++) {
                const W = U[J];
                if (W & t) {
                  const z = X.getUint8(j++);
                  V += W & h ? z : -z, S.push(V);
                } else
                  W & h || (V += X.getInt16(j), j += 2), S.push(V);
                R[M] === J && (M++, O.push(S), S = []);
              }
              V = 0, M = 0;
              for (let J = 0; J < k; J++) {
                const W = U[J];
                if (W & a) {
                  const z = X.getUint8(j++);
                  V += W & e ? z : -z, F.push(V);
                } else
                  W & e || (V += X.getInt16(j), j += 2), F.push(V);
                T.push(W & C | W & y), R[M] === J && (S = O[M], M++, I.push(new _({
                  flags: T,
                  xCoordinates: S,
                  yCoordinates: F
                })), F = [], T = []);
              }
              return new b({
                contours: I,
                instructions: f
              });
            }
            getSize() {
              let j = this.contours.length * 2 + 2 + this.instructions.length, X = 0, B = 0;
              for (const R of this.contours) {
                j += R.flags.length;
                for (let k = 0, x = R.xCoordinates.length; k < x; k++) {
                  const f = R.xCoordinates[k], U = R.yCoordinates[k];
                  let O = Math.abs(f - X);
                  O > 255 ? j += 2 : O > 0 && (j += 1), X = f, O = Math.abs(U - B), O > 255 ? j += 2 : O > 0 && (j += 1), B = U;
                }
              }
              return j;
            }
            write(j, X) {
              const B = j, R = [], k = [], x = [];
              let f = 0, U = 0;
              for (const O of this.contours) {
                for (let S = 0, F = O.xCoordinates.length; S < F; S++) {
                  let T = O.flags[S];
                  const I = O.xCoordinates[S];
                  let M = I - f;
                  if (M === 0)
                    T |= h, R.push(0);
                  else {
                    const J = Math.abs(M);
                    J <= 255 ? (T |= M >= 0 ? t | h : t, R.push(J)) : R.push(M);
                  }
                  f = I;
                  const V = O.yCoordinates[S];
                  if (M = V - U, M === 0)
                    T |= e, k.push(0);
                  else {
                    const J = Math.abs(M);
                    J <= 255 ? (T |= M >= 0 ? a | e : a, k.push(J)) : k.push(M);
                  }
                  U = V, x.push(T);
                }
                X.setUint16(j, R.length - 1), j += 2;
              }
              X.setUint16(j, this.instructions.length), j += 2, this.instructions.length && (new Uint8Array(X.buffer, 0, X.buffer.byteLength).set(this.instructions, j), j += this.instructions.length);
              for (const O of x)
                X.setUint8(j++, O);
              for (let O = 0, S = R.length; O < S; O++) {
                const F = R[O], T = x[O];
                T & t ? X.setUint8(j++, F) : T & h || (X.setInt16(j, F), j += 2);
              }
              for (let O = 0, S = k.length; O < S; O++) {
                const F = k[O], T = x[O];
                T & a ? X.setUint8(j++, F) : T & e || (X.setInt16(j, F), j += 2);
              }
              return j - B;
            }
            scale(j, X) {
              for (const B of this.contours)
                if (B.xCoordinates.length !== 0)
                  for (let R = 0, k = B.xCoordinates.length; R < k; R++)
                    B.xCoordinates[R] = Math.round(j + (B.xCoordinates[R] - j) * X);
            }
          }
          class A {
            constructor({
              flags: j,
              glyphIndex: X,
              argument1: B,
              argument2: R,
              transf: k,
              instructions: x
            }) {
              this.flags = j, this.glyphIndex = X, this.argument1 = B, this.argument2 = R, this.transf = k, this.instructions = x;
            }
            static parse(j, X) {
              const B = j, R = [];
              let k = X.getUint16(j);
              const x = X.getUint16(j + 2);
              j += 4;
              let f, U;
              k & c ? (k & d ? (f = X.getInt16(j), U = X.getInt16(j + 2)) : (f = X.getUint16(j), U = X.getUint16(j + 2)), j += 4, k ^= c) : (k & d ? (f = X.getInt8(j), U = X.getInt8(j + 1)) : (f = X.getUint8(j), U = X.getUint8(j + 1)), j += 2), k & p ? (R.push(X.getUint16(j)), j += 2) : k & g ? (R.push(X.getUint16(j), X.getUint16(j + 2)), j += 4) : k & n && (R.push(X.getUint16(j), X.getUint16(j + 2), X.getUint16(j + 4), X.getUint16(j + 6)), j += 8);
              let O = null;
              if (k & i) {
                const S = X.getUint16(j);
                j += 2, O = new Uint8Array(X).slice(j, j + S), j += S;
              }
              return [j - B, new A({
                flags: k,
                glyphIndex: x,
                argument1: f,
                argument2: U,
                transf: R,
                instructions: O
              })];
            }
            getSize() {
              let j = 4 + this.transf.length * 2;
              return this.flags & i && (j += 2 + this.instructions.length), j += 2, this.flags & 2 ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (j += 2) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (j += 2), j;
            }
            write(j, X) {
              const B = j;
              return this.flags & d ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (this.flags |= c) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (this.flags |= c), X.setUint16(j, this.flags), X.setUint16(j + 2, this.glyphIndex), j += 4, this.flags & c ? (this.flags & d ? (X.setInt16(j, this.argument1), X.setInt16(j + 2, this.argument2)) : (X.setUint16(j, this.argument1), X.setUint16(j + 2, this.argument2)), j += 4) : (X.setUint8(j, this.argument1), X.setUint8(j + 1, this.argument2), j += 2), this.flags & i && (X.setUint16(j, this.instructions.length), j += 2, this.instructions.length && (new Uint8Array(X.buffer, 0, X.buffer.byteLength).set(this.instructions, j), j += this.instructions.length)), j - B;
            }
            scale(j, X) {
            }
          }
        },
        /* 47 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.OpenTypeFileBuilder = void 0;
          var t = C(6), a = C(2);
          function v(p, m, g) {
            p[m] = g >> 8 & 255, p[m + 1] = g & 255;
          }
          function h(p, m, g) {
            p[m] = g >> 24 & 255, p[m + 1] = g >> 16 & 255, p[m + 2] = g >> 8 & 255, p[m + 3] = g & 255;
          }
          function e(p, m, g) {
            if (g instanceof Uint8Array)
              p.set(g, m);
            else if (typeof g == "string")
              for (let n = 0, i = g.length; n < i; n++)
                p[m++] = g.charCodeAt(n) & 255;
            else
              for (let n = 0, i = g.length; n < i; n++)
                p[m++] = g[n] & 255;
          }
          const y = 12, c = 16;
          class d {
            constructor(m) {
              this.sfnt = m, this.tables = /* @__PURE__ */ Object.create(null);
            }
            static getSearchParams(m, g) {
              let n = 1, i = 0;
              for (; (n ^ m) > n; )
                n <<= 1, i++;
              const l = n * g;
              return {
                range: l,
                entry: i,
                rangeShift: g * m - l
              };
            }
            toArray() {
              let m = this.sfnt;
              const g = this.tables, n = Object.keys(g);
              n.sort();
              const i = n.length;
              let l, u, w, _, b, A = y + i * c;
              const Y = [A];
              for (l = 0; l < i; l++) {
                _ = g[n[l]];
                const B = (_.length + 3 & -4) >>> 0;
                A += B, Y.push(A);
              }
              const j = new Uint8Array(A);
              for (l = 0; l < i; l++)
                _ = g[n[l]], e(j, Y[l], _);
              m === "true" && (m = (0, a.string32)(65536)), j[0] = m.charCodeAt(0) & 255, j[1] = m.charCodeAt(1) & 255, j[2] = m.charCodeAt(2) & 255, j[3] = m.charCodeAt(3) & 255, v(j, 4, i);
              const X = d.getSearchParams(i, 16);
              for (v(j, 6, X.range), v(j, 8, X.entry), v(j, 10, X.rangeShift), A = y, l = 0; l < i; l++) {
                b = n[l], j[A] = b.charCodeAt(0) & 255, j[A + 1] = b.charCodeAt(1) & 255, j[A + 2] = b.charCodeAt(2) & 255, j[A + 3] = b.charCodeAt(3) & 255;
                let B = 0;
                for (u = Y[l], w = Y[l + 1]; u < w; u += 4) {
                  const R = (0, t.readUint32)(j, u);
                  B = B + R >>> 0;
                }
                h(j, A + 4, B), h(j, A + 8, Y[l]), h(j, A + 12, g[b].length), A += c;
              }
              return j;
            }
            addTable(m, g) {
              if (m in this.tables)
                throw new Error("Table " + m + " already exists");
              this.tables[m] = g;
            }
          }
          o.OpenTypeFileBuilder = d;
        },
        /* 48 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.Type1Font = void 0;
          var t = C(35), a = C(38), v = C(6), h = C(10), e = C(49), y = C(2);
          function c(g, n, i) {
            const l = g.length, u = n.length, w = l - u;
            let _ = i, b = !1;
            for (; _ < w; ) {
              let A = 0;
              for (; A < u && g[_ + A] === n[A]; )
                A++;
              if (A >= u) {
                for (_ += A; _ < l && (0, v.isWhiteSpace)(g[_]); )
                  _++;
                b = !0;
                break;
              }
              _++;
            }
            return {
              found: b,
              length: _
            };
          }
          function d(g, n) {
            const i = [101, 101, 120, 101, 99], l = g.pos;
            let u, w, _;
            try {
              u = g.getBytes(n), w = u.length;
            } catch {
            }
            if (w === n && (_ = c(u, i, n - 2 * i.length), _.found && _.length === n))
              return {
                stream: new h.Stream(u),
                length: n
              };
            (0, y.warn)('Invalid "Length1" property in Type1 font -- trying to recover.'), g.pos = l;
            const b = 2048;
            let A;
            for (; ; ) {
              const Y = g.peekBytes(b);
              if (_ = c(Y, i, 0), _.length === 0)
                break;
              if (g.pos += _.length, _.found) {
                A = g.pos - l;
                break;
              }
            }
            return g.pos = l, A ? {
              stream: new h.Stream(g.getBytes(A)),
              length: A
            } : ((0, y.warn)('Unable to recover "Length1" property in Type1 font -- using as is.'), {
              stream: new h.Stream(g.getBytes(n)),
              length: n
            });
          }
          function p(g, n) {
            const i = g.getBytes();
            return {
              stream: new h.Stream(i),
              length: i.length
            };
          }
          class m {
            constructor(n, i, l) {
              let w = l.length1;
              l.length2;
              let _ = i.peekBytes(6);
              const b = _[0] === 128 && _[1] === 1;
              b && (i.skip(6), w = _[5] << 24 | _[4] << 16 | _[3] << 8 | _[2]);
              const A = d(i, w);
              new e.Type1Parser(A.stream, !1, a.SEAC_ANALYSIS_ENABLED).extractFontHeader(l), b && (_ = i.getBytes(6), _[5] << 24 | _[4] << 16 | _[3] << 8 | _[2]);
              const j = p(i), B = new e.Type1Parser(j.stream, !0, a.SEAC_ANALYSIS_ENABLED).extractFontProgram(l);
              for (const f in B.properties)
                l[f] = B.properties[f];
              const R = B.charstrings, k = this.getType2Charstrings(R), x = this.getType2Subrs(B.subrs);
              this.charstrings = R, this.data = this.wrap(n, k, this.charstrings, x, l), this.seacs = this.getSeacs(B.charstrings);
            }
            get numGlyphs() {
              return this.charstrings.length + 1;
            }
            getCharset() {
              const n = [".notdef"];
              for (const {
                glyphName: i
              } of this.charstrings)
                n.push(i);
              return n;
            }
            getGlyphMapping(n) {
              const i = this.charstrings;
              if (n.composite) {
                const b = /* @__PURE__ */ Object.create(null);
                for (let A = 0, Y = i.length; A < Y; A++) {
                  const j = n.cMap.charCodeOf(A);
                  b[j] = A + 1;
                }
                return b;
              }
              const l = [".notdef"];
              let u, w;
              for (w = 0; w < i.length; w++)
                l.push(i[w].glyphName);
              const _ = n.builtInEncoding;
              if (_) {
                u = /* @__PURE__ */ Object.create(null);
                for (const b in _)
                  w = l.indexOf(_[b]), w >= 0 && (u[b] = w);
              }
              return (0, a.type1FontGlyphMapping)(n, u, l);
            }
            hasGlyphId(n) {
              return n < 0 || n >= this.numGlyphs ? !1 : n === 0 ? !0 : this.charstrings[n - 1].charstring.length > 0;
            }
            getSeacs(n) {
              const i = [];
              for (let l = 0, u = n.length; l < u; l++) {
                const w = n[l];
                w.seac && (i[l + 1] = w.seac);
              }
              return i;
            }
            getType2Charstrings(n) {
              const i = [];
              for (let l = 0, u = n.length; l < u; l++)
                i.push(n[l].charstring);
              return i;
            }
            getType2Subrs(n) {
              let i = 0;
              const l = n.length;
              l < 1133 ? i = 107 : l < 33769 ? i = 1131 : i = 32768;
              const u = [];
              let w;
              for (w = 0; w < i; w++)
                u.push([11]);
              for (w = 0; w < l; w++)
                u.push(n[w]);
              return u;
            }
            wrap(n, i, l, u, w) {
              const _ = new t.CFF();
              _.header = new t.CFFHeader(1, 0, 4, 4), _.names = [n];
              const b = new t.CFFTopDict();
              b.setByName("version", 391), b.setByName("Notice", 392), b.setByName("FullName", 393), b.setByName("FamilyName", 394), b.setByName("Weight", 395), b.setByName("Encoding", null), b.setByName("FontMatrix", w.fontMatrix), b.setByName("FontBBox", w.bbox), b.setByName("charset", null), b.setByName("CharStrings", null), b.setByName("Private", null), _.topDict = b;
              const A = new t.CFFStrings();
              A.add("Version 0.11"), A.add("See original notice"), A.add(n), A.add(n), A.add("Medium"), _.strings = A, _.globalSubrIndex = new t.CFFIndex();
              const Y = i.length, j = [".notdef"];
              let X, B;
              for (X = 0; X < Y; X++) {
                const O = l[X].glyphName;
                t.CFFStandardStrings.indexOf(O) === -1 && A.add(O), j.push(O);
              }
              _.charset = new t.CFFCharset(!1, 0, j);
              const R = new t.CFFIndex();
              for (R.add([139, 14]), X = 0; X < Y; X++)
                R.add(i[X]);
              _.charStrings = R;
              const k = new t.CFFPrivateDict();
              k.setByName("Subrs", null);
              const x = ["BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StemSnapH", "StemSnapV", "BlueShift", "BlueFuzz", "BlueScale", "LanguageGroup", "ExpansionFactor", "ForceBold", "StdHW", "StdVW"];
              for (X = 0, B = x.length; X < B; X++) {
                const O = x[X];
                if (!(O in w.privateData))
                  continue;
                const S = w.privateData[O];
                if (Array.isArray(S))
                  for (let F = S.length - 1; F > 0; F--)
                    S[F] -= S[F - 1];
                k.setByName(O, S);
              }
              _.topDict.privateDict = k;
              const f = new t.CFFIndex();
              for (X = 0, B = u.length; X < B; X++)
                f.add(u[X]);
              return k.subrsIndex = f, new t.CFFCompiler(_).compile();
            }
          }
          o.Type1Font = m;
        },
        /* 49 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.Type1Parser = void 0;
          var t = C(37), a = C(6), v = C(10), h = C(2);
          const e = !1, y = {
            hstem: [1],
            vstem: [3],
            vmoveto: [4],
            rlineto: [5],
            hlineto: [6],
            vlineto: [7],
            rrcurveto: [8],
            callsubr: [10],
            flex: [12, 35],
            drop: [12, 18],
            endchar: [14],
            rmoveto: [21],
            hmoveto: [22],
            vhcurveto: [30],
            hvcurveto: [31]
          };
          class c {
            constructor() {
              this.width = 0, this.lsb = 0, this.flexing = !1, this.output = [], this.stack = [];
            }
            convert(w, _, b) {
              const A = w.length;
              let Y = !1, j, X, B;
              for (let R = 0; R < A; R++) {
                let k = w[R];
                if (k < 32) {
                  switch (k === 12 && (k = (k << 8) + w[++R]), k) {
                    case 1: {
                      this.stack = [];
                      break;
                    }
                    case 3: {
                      this.stack = [];
                      break;
                    }
                    case 4:
                      if (this.flexing) {
                        if (this.stack.length < 1) {
                          Y = !0;
                          break;
                        }
                        const S = this.stack.pop();
                        this.stack.push(0, S);
                        break;
                      }
                      Y = this.executeCommand(1, y.vmoveto);
                      break;
                    case 5:
                      Y = this.executeCommand(2, y.rlineto);
                      break;
                    case 6:
                      Y = this.executeCommand(1, y.hlineto);
                      break;
                    case 7:
                      Y = this.executeCommand(1, y.vlineto);
                      break;
                    case 8:
                      Y = this.executeCommand(6, y.rrcurveto);
                      break;
                    case 9:
                      this.stack = [];
                      break;
                    case 10:
                      if (this.stack.length < 1) {
                        Y = !0;
                        break;
                      }
                      if (B = this.stack.pop(), !_[B]) {
                        Y = !0;
                        break;
                      }
                      Y = this.convert(_[B], _, b);
                      break;
                    case 11:
                      return Y;
                    case 13:
                      if (this.stack.length < 2) {
                        Y = !0;
                        break;
                      }
                      j = this.stack.pop(), X = this.stack.pop(), this.lsb = X, this.width = j, this.stack.push(j, X), Y = this.executeCommand(2, y.hmoveto);
                      break;
                    case 14:
                      this.output.push(y.endchar[0]);
                      break;
                    case 21:
                      if (this.flexing)
                        break;
                      Y = this.executeCommand(2, y.rmoveto);
                      break;
                    case 22:
                      if (this.flexing) {
                        this.stack.push(0);
                        break;
                      }
                      Y = this.executeCommand(1, y.hmoveto);
                      break;
                    case 30:
                      Y = this.executeCommand(4, y.vhcurveto);
                      break;
                    case 31:
                      Y = this.executeCommand(4, y.hvcurveto);
                      break;
                    case 3072:
                      this.stack = [];
                      break;
                    case 3073: {
                      this.stack = [];
                      break;
                    }
                    case 3074: {
                      this.stack = [];
                      break;
                    }
                    case 3078:
                      if (b) {
                        const S = this.stack.at(-5);
                        this.seac = this.stack.splice(-4, 4), this.seac[0] += this.lsb - S, Y = this.executeCommand(0, y.endchar);
                      } else
                        Y = this.executeCommand(4, y.endchar);
                      break;
                    case 3079:
                      if (this.stack.length < 4) {
                        Y = !0;
                        break;
                      }
                      this.stack.pop(), j = this.stack.pop();
                      const x = this.stack.pop();
                      X = this.stack.pop(), this.lsb = X, this.width = j, this.stack.push(j, X, x), Y = this.executeCommand(3, y.rmoveto);
                      break;
                    case 3084:
                      if (this.stack.length < 2) {
                        Y = !0;
                        break;
                      }
                      const f = this.stack.pop(), U = this.stack.pop();
                      this.stack.push(U / f);
                      break;
                    case 3088:
                      if (this.stack.length < 2) {
                        Y = !0;
                        break;
                      }
                      B = this.stack.pop();
                      const O = this.stack.pop();
                      if (B === 0 && O === 3) {
                        const S = this.stack.splice(this.stack.length - 17, 17);
                        this.stack.push(S[2] + S[0], S[3] + S[1], S[4], S[5], S[6], S[7], S[8], S[9], S[10], S[11], S[12], S[13], S[14]), Y = this.executeCommand(13, y.flex, !0), this.flexing = !1, this.stack.push(S[15], S[16]);
                      } else
                        B === 1 && O === 0 && (this.flexing = !0);
                      break;
                    case 3089:
                      break;
                    case 3105:
                      this.stack = [];
                      break;
                    default:
                      (0, h.warn)('Unknown type 1 charstring command of "' + k + '"');
                      break;
                  }
                  if (Y)
                    break;
                  continue;
                } else
                  k <= 246 ? k -= 139 : k <= 250 ? k = (k - 247) * 256 + w[++R] + 108 : k <= 254 ? k = -((k - 251) * 256) - w[++R] - 108 : k = (w[++R] & 255) << 24 | (w[++R] & 255) << 16 | (w[++R] & 255) << 8 | (w[++R] & 255) << 0;
                this.stack.push(k);
              }
              return Y;
            }
            executeCommand(w, _, b) {
              const A = this.stack.length;
              if (w > A)
                return !0;
              const Y = A - w;
              for (let j = Y; j < A; j++) {
                let X = this.stack[j];
                Number.isInteger(X) ? this.output.push(28, X >> 8 & 255, X & 255) : (X = 65536 * X | 0, this.output.push(255, X >> 24 & 255, X >> 16 & 255, X >> 8 & 255, X & 255));
              }
              return this.output.push(..._), b ? this.stack.splice(Y, w) : this.stack.length = 0, !1;
            }
          }
          const d = 55665, p = 4330;
          function m(u) {
            return u >= 48 && u <= 57 || u >= 65 && u <= 70 || u >= 97 && u <= 102;
          }
          function g(u, w, _) {
            if (_ >= u.length)
              return new Uint8Array(0);
            const b = 52845, A = 22719;
            let Y = w | 0, j, X;
            for (j = 0; j < _; j++)
              Y = (u[j] + Y) * b + A & 65535;
            const B = u.length - _, R = new Uint8Array(B);
            for (j = _, X = 0; X < B; j++, X++) {
              const k = u[j];
              R[X] = k ^ Y >> 8, Y = (k + Y) * b + A & 65535;
            }
            return R;
          }
          function n(u, w, _) {
            let Y = w | 0;
            const j = u.length, X = j >>> 1, B = new Uint8Array(X);
            let R, k;
            for (R = 0, k = 0; R < j; R++) {
              const x = u[R];
              if (!m(x))
                continue;
              R++;
              let f;
              for (; R < j && !m(f = u[R]); )
                R++;
              if (R < j) {
                const U = parseInt(String.fromCharCode(x, f), 16);
                B[k++] = U ^ Y >> 8, Y = (U + Y) * 52845 + 22719 & 65535;
              }
            }
            return B.slice(_, k);
          }
          function i(u) {
            return u === 47 || u === 91 || u === 93 || u === 123 || u === 125 || u === 40 || u === 41;
          }
          class l {
            constructor(w, _, b) {
              if (_) {
                const A = w.getBytes(), Y = !((m(A[0]) || (0, a.isWhiteSpace)(A[0])) && m(A[1]) && m(A[2]) && m(A[3]) && m(A[4]) && m(A[5]) && m(A[6]) && m(A[7]));
                w = new v.Stream(Y ? g(A, d, 4) : n(A, d, 4));
              }
              this.seacAnalysisEnabled = !!b, this.stream = w, this.nextChar();
            }
            readNumberArray() {
              this.getToken();
              const w = [];
              for (; ; ) {
                const _ = this.getToken();
                if (_ === null || _ === "]" || _ === "}")
                  break;
                w.push(parseFloat(_ || 0));
              }
              return w;
            }
            readNumber() {
              const w = this.getToken();
              return parseFloat(w || 0);
            }
            readInt() {
              const w = this.getToken();
              return parseInt(w || 0, 10) | 0;
            }
            readBoolean() {
              return this.getToken() === "true" ? 1 : 0;
            }
            nextChar() {
              return this.currentChar = this.stream.getByte();
            }
            prevChar() {
              return this.stream.skip(-2), this.currentChar = this.stream.getByte();
            }
            getToken() {
              let w = !1, _ = this.currentChar;
              for (; ; ) {
                if (_ === -1)
                  return null;
                if (w)
                  (_ === 10 || _ === 13) && (w = !1);
                else if (_ === 37)
                  w = !0;
                else if (!(0, a.isWhiteSpace)(_))
                  break;
                _ = this.nextChar();
              }
              if (i(_))
                return this.nextChar(), String.fromCharCode(_);
              let b = "";
              do
                b += String.fromCharCode(_), _ = this.nextChar();
              while (_ >= 0 && !(0, a.isWhiteSpace)(_) && !i(_));
              return b;
            }
            readCharStrings(w, _) {
              return _ === -1 ? w : g(w, p, _);
            }
            extractFontProgram(w) {
              const _ = this.stream, b = [], A = [], Y = /* @__PURE__ */ Object.create(null);
              Y.lenIV = 4;
              const j = {
                subrs: [],
                charstrings: [],
                properties: {
                  privateData: Y
                }
              };
              let X, B, R, k;
              for (; (X = this.getToken()) !== null; )
                if (X === "/")
                  switch (X = this.getToken(), X) {
                    case "CharStrings":
                      for (this.getToken(), this.getToken(), this.getToken(), this.getToken(); X = this.getToken(), !(X === null || X === "end"); ) {
                        if (X !== "/")
                          continue;
                        const f = this.getToken();
                        B = this.readInt(), this.getToken(), R = B > 0 ? _.getBytes(B) : new Uint8Array(0), k = j.properties.privateData.lenIV;
                        const U = this.readCharStrings(R, k);
                        this.nextChar(), X = this.getToken(), X === "noaccess" ? this.getToken() : X === "/" && this.prevChar(), A.push({
                          glyph: f,
                          encoded: U
                        });
                      }
                      break;
                    case "Subrs":
                      for (this.readInt(), this.getToken(); this.getToken() === "dup"; ) {
                        const f = this.readInt();
                        B = this.readInt(), this.getToken(), R = B > 0 ? _.getBytes(B) : new Uint8Array(0), k = j.properties.privateData.lenIV;
                        const U = this.readCharStrings(R, k);
                        this.nextChar(), X = this.getToken(), X === "noaccess" && this.getToken(), b[f] = U;
                      }
                      break;
                    case "BlueValues":
                    case "OtherBlues":
                    case "FamilyBlues":
                    case "FamilyOtherBlues":
                      const x = this.readNumberArray();
                      x.length > 0 && x.length % 2 === 0 && e && (j.properties.privateData[X] = x);
                      break;
                    case "StemSnapH":
                    case "StemSnapV":
                      j.properties.privateData[X] = this.readNumberArray();
                      break;
                    case "StdHW":
                    case "StdVW":
                      j.properties.privateData[X] = this.readNumberArray()[0];
                      break;
                    case "BlueShift":
                    case "lenIV":
                    case "BlueFuzz":
                    case "BlueScale":
                    case "LanguageGroup":
                    case "ExpansionFactor":
                      j.properties.privateData[X] = this.readNumber();
                      break;
                    case "ForceBold":
                      j.properties.privateData[X] = this.readBoolean();
                      break;
                  }
              for (const {
                encoded: x,
                glyph: f
              } of A) {
                const U = new c(), O = U.convert(x, b, this.seacAnalysisEnabled);
                let S = U.output;
                O && (S = [14]);
                const F = {
                  glyphName: f,
                  charstring: S,
                  width: U.width,
                  lsb: U.lsb,
                  seac: U.seac
                };
                if (f === ".notdef" ? j.charstrings.unshift(F) : j.charstrings.push(F), w.builtInEncoding) {
                  const T = w.builtInEncoding.indexOf(f);
                  T > -1 && w.widths[T] === void 0 && T >= w.firstChar && T <= w.lastChar && (w.widths[T] = U.width);
                }
              }
              return j;
            }
            extractFontHeader(w) {
              let _;
              for (; (_ = this.getToken()) !== null; )
                if (_ === "/")
                  switch (_ = this.getToken(), _) {
                    case "FontMatrix":
                      const b = this.readNumberArray();
                      w.fontMatrix = b;
                      break;
                    case "Encoding":
                      const A = this.getToken();
                      let Y;
                      if (!/^\d+$/.test(A))
                        Y = (0, t.getEncoding)(A);
                      else {
                        Y = [];
                        const X = parseInt(A, 10) | 0;
                        this.getToken();
                        for (let B = 0; B < X; B++) {
                          for (_ = this.getToken(); _ !== "dup" && _ !== "def"; )
                            if (_ = this.getToken(), _ === null)
                              return;
                          if (_ === "def")
                            break;
                          const R = this.readInt();
                          this.getToken();
                          const k = this.getToken();
                          Y[R] = k, this.getToken();
                        }
                      }
                      w.builtInEncoding = Y;
                      break;
                    case "FontBBox":
                      const j = this.readNumberArray();
                      w.ascent = Math.max(j[3], j[1]), w.descent = Math.min(j[1], j[3]), w.ascentScaled = !0;
                      break;
                  }
            }
          }
          o.Type1Parser = l;
        },
        /* 50 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.Pattern = void 0, o.getTilingPatternIR = i;
          var t = C(2), a = C(7), v = C(14), h = C(6);
          const e = {
            FUNCTION_BASED: 1,
            AXIAL: 2,
            RADIAL: 3,
            FREE_FORM_MESH: 4,
            LATTICE_FORM_MESH: 5,
            COONS_PATCH_MESH: 6,
            TENSOR_PATCH_MESH: 7
          };
          class y {
            constructor() {
              (0, t.unreachable)("Cannot initialize Pattern.");
            }
            static parseShading(u, w, _, b, A, Y) {
              const j = u instanceof a.BaseStream ? u.dict : u, X = j.get("ShadingType");
              try {
                switch (X) {
                  case e.AXIAL:
                  case e.RADIAL:
                    return new d(j, w, _, A, Y);
                  case e.FREE_FORM_MESH:
                  case e.LATTICE_FORM_MESH:
                  case e.COONS_PATCH_MESH:
                  case e.TENSOR_PATCH_MESH:
                    return new g(u, w, _, A, Y);
                  default:
                    throw new t.FormatError("Unsupported ShadingType: " + X);
                }
              } catch (B) {
                if (B instanceof h.MissingDataException)
                  throw B;
                return b.send("UnsupportedFeature", {
                  featureId: t.UNSUPPORTED_FEATURES.shadingPattern
                }), (0, t.warn)(B), new n();
              }
            }
          }
          o.Pattern = y;
          class c {
            static get SMALL_NUMBER() {
              return (0, t.shadow)(this, "SMALL_NUMBER", 1e-6);
            }
            constructor() {
              this.constructor === c && (0, t.unreachable)("Cannot initialize BaseShading.");
            }
            getIR() {
              (0, t.unreachable)("Abstract method `getIR` called.");
            }
          }
          class d extends c {
            constructor(u, w, _, b, A) {
              super(), this.coordsArr = u.getArray("Coords"), this.shadingType = u.get("ShadingType");
              const Y = v.ColorSpace.parse({
                cs: u.getRaw("CS") || u.getRaw("ColorSpace"),
                xref: w,
                resources: _,
                pdfFunctionFactory: b,
                localColorSpaceCache: A
              }), j = u.getArray("BBox");
              Array.isArray(j) && j.length === 4 ? this.bbox = t.Util.normalizeRect(j) : this.bbox = null;
              let X = 0, B = 1;
              if (u.has("Domain")) {
                const V = u.getArray("Domain");
                X = V[0], B = V[1];
              }
              let R = !1, k = !1;
              if (u.has("Extend")) {
                const V = u.getArray("Extend");
                R = V[0], k = V[1];
              }
              if (this.shadingType === e.RADIAL && (!R || !k)) {
                const [V, J, W, z, G, L] = this.coordsArr, K = Math.hypot(V - z, J - G);
                W <= L + K && L <= W + K && (0, t.warn)("Unsupported radial gradient.");
              }
              this.extendStart = R, this.extendEnd = k;
              const x = u.getRaw("Function"), f = b.createFromArray(x), U = 10, O = (B - X) / U, S = this.colorStops = [];
              if (X >= B || O <= 0) {
                (0, t.info)("Bad shading domain.");
                return;
              }
              const F = new Float32Array(Y.numComps), T = new Float32Array(1);
              let I;
              for (let V = 0; V <= U; V++) {
                T[0] = X + V * O, f(T, 0, F, 0), I = Y.getRgb(F, 0);
                const J = t.Util.makeHexColor(I[0], I[1], I[2]);
                S.push([V / U, J]);
              }
              let M = "transparent";
              u.has("Background") && (I = Y.getRgb(u.get("Background"), 0), M = t.Util.makeHexColor(I[0], I[1], I[2])), R || (S.unshift([0, M]), S[1][0] += c.SMALL_NUMBER), k || (S.at(-1)[0] -= c.SMALL_NUMBER, S.push([1, M])), this.colorStops = S;
            }
            getIR() {
              const u = this.coordsArr, w = this.shadingType;
              let _, b, A, Y, j;
              return w === e.AXIAL ? (b = [u[0], u[1]], A = [u[2], u[3]], Y = null, j = null, _ = "axial") : w === e.RADIAL ? (b = [u[0], u[1]], A = [u[3], u[4]], Y = u[2], j = u[5], _ = "radial") : (0, t.unreachable)(`getPattern type unknown: ${w}`), ["RadialAxial", _, this.bbox, this.colorStops, b, A, Y, j];
            }
          }
          class p {
            constructor(u, w) {
              this.stream = u, this.context = w, this.buffer = 0, this.bufferLength = 0;
              const _ = w.numComps;
              this.tmpCompsBuf = new Float32Array(_);
              const b = w.colorSpace.numComps;
              this.tmpCsCompsBuf = w.colorFn ? new Float32Array(b) : this.tmpCompsBuf;
            }
            get hasData() {
              if (this.stream.end)
                return this.stream.pos < this.stream.end;
              if (this.bufferLength > 0)
                return !0;
              const u = this.stream.getByte();
              return u < 0 ? !1 : (this.buffer = u, this.bufferLength = 8, !0);
            }
            readBits(u) {
              let w = this.buffer, _ = this.bufferLength;
              if (u === 32) {
                if (_ === 0)
                  return (this.stream.getByte() << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte()) >>> 0;
                w = w << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte();
                const b = this.stream.getByte();
                return this.buffer = b & (1 << _) - 1, (w << 8 - _ | (b & 255) >> _) >>> 0;
              }
              if (u === 8 && _ === 0)
                return this.stream.getByte();
              for (; _ < u; )
                w = w << 8 | this.stream.getByte(), _ += 8;
              return _ -= u, this.bufferLength = _, this.buffer = w & (1 << _) - 1, w >> _;
            }
            align() {
              this.buffer = 0, this.bufferLength = 0;
            }
            readFlag() {
              return this.readBits(this.context.bitsPerFlag);
            }
            readCoordinate() {
              const u = this.context.bitsPerCoordinate, w = this.readBits(u), _ = this.readBits(u), b = this.context.decode, A = u < 32 ? 1 / ((1 << u) - 1) : 23283064365386963e-26;
              return [w * A * (b[1] - b[0]) + b[0], _ * A * (b[3] - b[2]) + b[2]];
            }
            readComponents() {
              const u = this.context.numComps, w = this.context.bitsPerComponent, _ = w < 32 ? 1 / ((1 << w) - 1) : 23283064365386963e-26, b = this.context.decode, A = this.tmpCompsBuf;
              for (let j = 0, X = 4; j < u; j++, X += 2) {
                const B = this.readBits(w);
                A[j] = B * _ * (b[X + 1] - b[X]) + b[X];
              }
              const Y = this.tmpCsCompsBuf;
              return this.context.colorFn && this.context.colorFn(A, 0, Y, 0), this.context.colorSpace.getRgb(Y, 0);
            }
          }
          const m = function() {
            function u(_) {
              const b = [];
              for (let A = 0; A <= _; A++) {
                const Y = A / _, j = 1 - Y;
                b.push(new Float32Array([j * j * j, 3 * Y * j * j, 3 * Y * Y * j, Y * Y * Y]));
              }
              return b;
            }
            const w = [];
            return function(_) {
              return w[_] || (w[_] = u(_)), w[_];
            };
          }();
          class g extends c {
            static get MIN_SPLIT_PATCH_CHUNKS_AMOUNT() {
              return (0, t.shadow)(this, "MIN_SPLIT_PATCH_CHUNKS_AMOUNT", 3);
            }
            static get MAX_SPLIT_PATCH_CHUNKS_AMOUNT() {
              return (0, t.shadow)(this, "MAX_SPLIT_PATCH_CHUNKS_AMOUNT", 20);
            }
            static get TRIANGLE_DENSITY() {
              return (0, t.shadow)(this, "TRIANGLE_DENSITY", 20);
            }
            constructor(u, w, _, b, A) {
              if (super(), !(u instanceof a.BaseStream))
                throw new t.FormatError("Mesh data is not a stream");
              const Y = u.dict;
              this.shadingType = Y.get("ShadingType");
              const j = Y.getArray("BBox");
              Array.isArray(j) && j.length === 4 ? this.bbox = t.Util.normalizeRect(j) : this.bbox = null;
              const X = v.ColorSpace.parse({
                cs: Y.getRaw("CS") || Y.getRaw("ColorSpace"),
                xref: w,
                resources: _,
                pdfFunctionFactory: b,
                localColorSpaceCache: A
              });
              this.background = Y.has("Background") ? X.getRgb(Y.get("Background"), 0) : null;
              const B = Y.getRaw("Function"), R = B ? b.createFromArray(B) : null;
              this.coords = [], this.colors = [], this.figures = [];
              const k = {
                bitsPerCoordinate: Y.get("BitsPerCoordinate"),
                bitsPerComponent: Y.get("BitsPerComponent"),
                bitsPerFlag: Y.get("BitsPerFlag"),
                decode: Y.getArray("Decode"),
                colorFn: R,
                colorSpace: X,
                numComps: R ? 1 : X.numComps
              }, x = new p(u, k);
              let f = !1;
              switch (this.shadingType) {
                case e.FREE_FORM_MESH:
                  this._decodeType4Shading(x);
                  break;
                case e.LATTICE_FORM_MESH:
                  const U = Y.get("VerticesPerRow") | 0;
                  if (U < 2)
                    throw new t.FormatError("Invalid VerticesPerRow");
                  this._decodeType5Shading(x, U);
                  break;
                case e.COONS_PATCH_MESH:
                  this._decodeType6Shading(x), f = !0;
                  break;
                case e.TENSOR_PATCH_MESH:
                  this._decodeType7Shading(x), f = !0;
                  break;
                default:
                  (0, t.unreachable)("Unsupported mesh type.");
                  break;
              }
              if (f) {
                this._updateBounds();
                for (let U = 0, O = this.figures.length; U < O; U++)
                  this._buildFigureFromPatch(U);
              }
              this._updateBounds(), this._packData();
            }
            _decodeType4Shading(u) {
              const w = this.coords, _ = this.colors, b = [];
              let A = 0;
              for (; u.hasData; ) {
                const Y = u.readFlag(), j = u.readCoordinate(), X = u.readComponents();
                if (A === 0) {
                  if (!(0 <= Y && Y <= 2))
                    throw new t.FormatError("Unknown type4 flag");
                  switch (Y) {
                    case 0:
                      A = 3;
                      break;
                    case 1:
                      b.push(b.at(-2), b.at(-1)), A = 1;
                      break;
                    case 2:
                      b.push(b.at(-3), b.at(-1)), A = 1;
                      break;
                  }
                }
                b.push(w.length), w.push(j), _.push(X), A--, u.align();
              }
              this.figures.push({
                type: "triangles",
                coords: new Int32Array(b),
                colors: new Int32Array(b)
              });
            }
            _decodeType5Shading(u, w) {
              const _ = this.coords, b = this.colors, A = [];
              for (; u.hasData; ) {
                const Y = u.readCoordinate(), j = u.readComponents();
                A.push(_.length), _.push(Y), b.push(j);
              }
              this.figures.push({
                type: "lattice",
                coords: new Int32Array(A),
                colors: new Int32Array(A),
                verticesPerRow: w
              });
            }
            _decodeType6Shading(u) {
              const w = this.coords, _ = this.colors, b = new Int32Array(16), A = new Int32Array(4);
              for (; u.hasData; ) {
                const Y = u.readFlag();
                if (!(0 <= Y && Y <= 3))
                  throw new t.FormatError("Unknown type6 flag");
                const j = w.length;
                for (let f = 0, U = Y !== 0 ? 8 : 12; f < U; f++)
                  w.push(u.readCoordinate());
                const X = _.length;
                for (let f = 0, U = Y !== 0 ? 2 : 4; f < U; f++)
                  _.push(u.readComponents());
                let B, R, k, x;
                switch (Y) {
                  case 0:
                    b[12] = j + 3, b[13] = j + 4, b[14] = j + 5, b[15] = j + 6, b[8] = j + 2, b[11] = j + 7, b[4] = j + 1, b[7] = j + 8, b[0] = j, b[1] = j + 11, b[2] = j + 10, b[3] = j + 9, A[2] = X + 1, A[3] = X + 2, A[0] = X, A[1] = X + 3;
                    break;
                  case 1:
                    B = b[12], R = b[13], k = b[14], x = b[15], b[12] = x, b[13] = j + 0, b[14] = j + 1, b[15] = j + 2, b[8] = k, b[11] = j + 3, b[4] = R, b[7] = j + 4, b[0] = B, b[1] = j + 7, b[2] = j + 6, b[3] = j + 5, B = A[2], R = A[3], A[2] = R, A[3] = X, A[0] = B, A[1] = X + 1;
                    break;
                  case 2:
                    B = b[15], R = b[11], b[12] = b[3], b[13] = j + 0, b[14] = j + 1, b[15] = j + 2, b[8] = b[7], b[11] = j + 3, b[4] = R, b[7] = j + 4, b[0] = B, b[1] = j + 7, b[2] = j + 6, b[3] = j + 5, B = A[3], A[2] = A[1], A[3] = X, A[0] = B, A[1] = X + 1;
                    break;
                  case 3:
                    b[12] = b[0], b[13] = j + 0, b[14] = j + 1, b[15] = j + 2, b[8] = b[1], b[11] = j + 3, b[4] = b[2], b[7] = j + 4, b[0] = b[3], b[1] = j + 7, b[2] = j + 6, b[3] = j + 5, A[2] = A[0], A[3] = X, A[0] = A[1], A[1] = X + 1;
                    break;
                }
                b[5] = w.length, w.push([(-4 * w[b[0]][0] - w[b[15]][0] + 6 * (w[b[4]][0] + w[b[1]][0]) - 2 * (w[b[12]][0] + w[b[3]][0]) + 3 * (w[b[13]][0] + w[b[7]][0])) / 9, (-4 * w[b[0]][1] - w[b[15]][1] + 6 * (w[b[4]][1] + w[b[1]][1]) - 2 * (w[b[12]][1] + w[b[3]][1]) + 3 * (w[b[13]][1] + w[b[7]][1])) / 9]), b[6] = w.length, w.push([(-4 * w[b[3]][0] - w[b[12]][0] + 6 * (w[b[2]][0] + w[b[7]][0]) - 2 * (w[b[0]][0] + w[b[15]][0]) + 3 * (w[b[4]][0] + w[b[14]][0])) / 9, (-4 * w[b[3]][1] - w[b[12]][1] + 6 * (w[b[2]][1] + w[b[7]][1]) - 2 * (w[b[0]][1] + w[b[15]][1]) + 3 * (w[b[4]][1] + w[b[14]][1])) / 9]), b[9] = w.length, w.push([(-4 * w[b[12]][0] - w[b[3]][0] + 6 * (w[b[8]][0] + w[b[13]][0]) - 2 * (w[b[0]][0] + w[b[15]][0]) + 3 * (w[b[11]][0] + w[b[1]][0])) / 9, (-4 * w[b[12]][1] - w[b[3]][1] + 6 * (w[b[8]][1] + w[b[13]][1]) - 2 * (w[b[0]][1] + w[b[15]][1]) + 3 * (w[b[11]][1] + w[b[1]][1])) / 9]), b[10] = w.length, w.push([(-4 * w[b[15]][0] - w[b[0]][0] + 6 * (w[b[11]][0] + w[b[14]][0]) - 2 * (w[b[12]][0] + w[b[3]][0]) + 3 * (w[b[2]][0] + w[b[8]][0])) / 9, (-4 * w[b[15]][1] - w[b[0]][1] + 6 * (w[b[11]][1] + w[b[14]][1]) - 2 * (w[b[12]][1] + w[b[3]][1]) + 3 * (w[b[2]][1] + w[b[8]][1])) / 9]), this.figures.push({
                  type: "patch",
                  coords: new Int32Array(b),
                  colors: new Int32Array(A)
                });
              }
            }
            _decodeType7Shading(u) {
              const w = this.coords, _ = this.colors, b = new Int32Array(16), A = new Int32Array(4);
              for (; u.hasData; ) {
                const Y = u.readFlag();
                if (!(0 <= Y && Y <= 3))
                  throw new t.FormatError("Unknown type7 flag");
                const j = w.length;
                for (let f = 0, U = Y !== 0 ? 12 : 16; f < U; f++)
                  w.push(u.readCoordinate());
                const X = _.length;
                for (let f = 0, U = Y !== 0 ? 2 : 4; f < U; f++)
                  _.push(u.readComponents());
                let B, R, k, x;
                switch (Y) {
                  case 0:
                    b[12] = j + 3, b[13] = j + 4, b[14] = j + 5, b[15] = j + 6, b[8] = j + 2, b[9] = j + 13, b[10] = j + 14, b[11] = j + 7, b[4] = j + 1, b[5] = j + 12, b[6] = j + 15, b[7] = j + 8, b[0] = j, b[1] = j + 11, b[2] = j + 10, b[3] = j + 9, A[2] = X + 1, A[3] = X + 2, A[0] = X, A[1] = X + 3;
                    break;
                  case 1:
                    B = b[12], R = b[13], k = b[14], x = b[15], b[12] = x, b[13] = j + 0, b[14] = j + 1, b[15] = j + 2, b[8] = k, b[9] = j + 9, b[10] = j + 10, b[11] = j + 3, b[4] = R, b[5] = j + 8, b[6] = j + 11, b[7] = j + 4, b[0] = B, b[1] = j + 7, b[2] = j + 6, b[3] = j + 5, B = A[2], R = A[3], A[2] = R, A[3] = X, A[0] = B, A[1] = X + 1;
                    break;
                  case 2:
                    B = b[15], R = b[11], b[12] = b[3], b[13] = j + 0, b[14] = j + 1, b[15] = j + 2, b[8] = b[7], b[9] = j + 9, b[10] = j + 10, b[11] = j + 3, b[4] = R, b[5] = j + 8, b[6] = j + 11, b[7] = j + 4, b[0] = B, b[1] = j + 7, b[2] = j + 6, b[3] = j + 5, B = A[3], A[2] = A[1], A[3] = X, A[0] = B, A[1] = X + 1;
                    break;
                  case 3:
                    b[12] = b[0], b[13] = j + 0, b[14] = j + 1, b[15] = j + 2, b[8] = b[1], b[9] = j + 9, b[10] = j + 10, b[11] = j + 3, b[4] = b[2], b[5] = j + 8, b[6] = j + 11, b[7] = j + 4, b[0] = b[3], b[1] = j + 7, b[2] = j + 6, b[3] = j + 5, A[2] = A[0], A[3] = X, A[0] = A[1], A[1] = X + 1;
                    break;
                }
                this.figures.push({
                  type: "patch",
                  coords: new Int32Array(b),
                  colors: new Int32Array(A)
                });
              }
            }
            _buildFigureFromPatch(u) {
              const w = this.figures[u];
              (0, t.assert)(w.type === "patch", "Unexpected patch mesh figure");
              const _ = this.coords, b = this.colors, A = w.coords, Y = w.colors, j = Math.min(_[A[0]][0], _[A[3]][0], _[A[12]][0], _[A[15]][0]), X = Math.min(_[A[0]][1], _[A[3]][1], _[A[12]][1], _[A[15]][1]), B = Math.max(_[A[0]][0], _[A[3]][0], _[A[12]][0], _[A[15]][0]), R = Math.max(_[A[0]][1], _[A[3]][1], _[A[12]][1], _[A[15]][1]);
              let k = Math.ceil((B - j) * g.TRIANGLE_DENSITY / (this.bounds[2] - this.bounds[0]));
              k = Math.max(g.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(g.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, k));
              let x = Math.ceil((R - X) * g.TRIANGLE_DENSITY / (this.bounds[3] - this.bounds[1]));
              x = Math.max(g.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(g.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, x));
              const f = k + 1, U = new Int32Array((x + 1) * f), O = new Int32Array((x + 1) * f);
              let S = 0;
              const F = new Uint8Array(3), T = new Uint8Array(3), I = b[Y[0]], M = b[Y[1]], V = b[Y[2]], J = b[Y[3]], W = m(x), z = m(k);
              for (let G = 0; G <= x; G++) {
                F[0] = (I[0] * (x - G) + V[0] * G) / x | 0, F[1] = (I[1] * (x - G) + V[1] * G) / x | 0, F[2] = (I[2] * (x - G) + V[2] * G) / x | 0, T[0] = (M[0] * (x - G) + J[0] * G) / x | 0, T[1] = (M[1] * (x - G) + J[1] * G) / x | 0, T[2] = (M[2] * (x - G) + J[2] * G) / x | 0;
                for (let L = 0; L <= k; L++, S++) {
                  if ((G === 0 || G === x) && (L === 0 || L === k))
                    continue;
                  let K = 0, te = 0, se = 0;
                  for (let N = 0; N <= 3; N++)
                    for (let Q = 0; Q <= 3; Q++, se++) {
                      const D = W[G][N] * z[L][Q];
                      K += _[A[se]][0] * D, te += _[A[se]][1] * D;
                    }
                  U[S] = _.length, _.push([K, te]), O[S] = b.length;
                  const q = new Uint8Array(3);
                  q[0] = (F[0] * (k - L) + T[0] * L) / k | 0, q[1] = (F[1] * (k - L) + T[1] * L) / k | 0, q[2] = (F[2] * (k - L) + T[2] * L) / k | 0, b.push(q);
                }
              }
              U[0] = A[0], O[0] = Y[0], U[k] = A[3], O[k] = Y[1], U[f * x] = A[12], O[f * x] = Y[2], U[f * x + k] = A[15], O[f * x + k] = Y[3], this.figures[u] = {
                type: "lattice",
                coords: U,
                colors: O,
                verticesPerRow: f
              };
            }
            _updateBounds() {
              let u = this.coords[0][0], w = this.coords[0][1], _ = u, b = w;
              for (let A = 1, Y = this.coords.length; A < Y; A++) {
                const j = this.coords[A][0], X = this.coords[A][1];
                u = u > j ? j : u, w = w > X ? X : w, _ = _ < j ? j : _, b = b < X ? X : b;
              }
              this.bounds = [u, w, _, b];
            }
            _packData() {
              let u, w, _, b;
              const A = this.coords, Y = new Float32Array(A.length * 2);
              for (u = 0, _ = 0, w = A.length; u < w; u++) {
                const R = A[u];
                Y[_++] = R[0], Y[_++] = R[1];
              }
              this.coords = Y;
              const j = this.colors, X = new Uint8Array(j.length * 3);
              for (u = 0, _ = 0, w = j.length; u < w; u++) {
                const R = j[u];
                X[_++] = R[0], X[_++] = R[1], X[_++] = R[2];
              }
              this.colors = X;
              const B = this.figures;
              for (u = 0, w = B.length; u < w; u++) {
                const R = B[u], k = R.coords, x = R.colors;
                for (_ = 0, b = k.length; _ < b; _++)
                  k[_] *= 2, x[_] *= 3;
              }
            }
            getIR() {
              return ["Mesh", this.shadingType, this.coords, this.colors, this.figures, this.bounds, this.bbox, this.background];
            }
          }
          class n extends c {
            getIR() {
              return ["Dummy"];
            }
          }
          function i(l, u, w) {
            const _ = u.getArray("Matrix"), b = t.Util.normalizeRect(u.getArray("BBox")), A = u.get("XStep"), Y = u.get("YStep"), j = u.get("PaintType"), X = u.get("TilingType");
            if (b[2] - b[0] === 0 || b[3] - b[1] === 0)
              throw new t.FormatError(`Invalid getTilingPatternIR /BBox array: [${b}].`);
            return ["TilingPattern", w, l, _, b, A, Y, j, X];
          }
        },
        /* 51 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.getXfaFontDict = n, o.getXfaFontName = m;
          var t = C(52), a = C(5), v = C(53), h = C(54), e = C(55), y = C(56), c = C(6), d = C(38);
          const p = (0, c.getLookupTableFactory)(function(i) {
            i["MyriadPro-Regular"] = i["PdfJS-Fallback-Regular"] = {
              name: "LiberationSans-Regular",
              factors: e.MyriadProRegularFactors,
              baseWidths: h.LiberationSansRegularWidths,
              baseMapping: h.LiberationSansRegularMapping,
              metrics: e.MyriadProRegularMetrics
            }, i["MyriadPro-Bold"] = i["PdfJS-Fallback-Bold"] = {
              name: "LiberationSans-Bold",
              factors: e.MyriadProBoldFactors,
              baseWidths: h.LiberationSansBoldWidths,
              baseMapping: h.LiberationSansBoldMapping,
              metrics: e.MyriadProBoldMetrics
            }, i["MyriadPro-It"] = i["MyriadPro-Italic"] = i["PdfJS-Fallback-Italic"] = {
              name: "LiberationSans-Italic",
              factors: e.MyriadProItalicFactors,
              baseWidths: h.LiberationSansItalicWidths,
              baseMapping: h.LiberationSansItalicMapping,
              metrics: e.MyriadProItalicMetrics
            }, i["MyriadPro-BoldIt"] = i["MyriadPro-BoldItalic"] = i["PdfJS-Fallback-BoldItalic"] = {
              name: "LiberationSans-BoldItalic",
              factors: e.MyriadProBoldItalicFactors,
              baseWidths: h.LiberationSansBoldItalicWidths,
              baseMapping: h.LiberationSansBoldItalicMapping,
              metrics: e.MyriadProBoldItalicMetrics
            }, i.ArialMT = i.Arial = i["Arial-Regular"] = {
              name: "LiberationSans-Regular",
              baseWidths: h.LiberationSansRegularWidths,
              baseMapping: h.LiberationSansRegularMapping
            }, i["Arial-BoldMT"] = i["Arial-Bold"] = {
              name: "LiberationSans-Bold",
              baseWidths: h.LiberationSansBoldWidths,
              baseMapping: h.LiberationSansBoldMapping
            }, i["Arial-ItalicMT"] = i["Arial-Italic"] = {
              name: "LiberationSans-Italic",
              baseWidths: h.LiberationSansItalicWidths,
              baseMapping: h.LiberationSansItalicMapping
            }, i["Arial-BoldItalicMT"] = i["Arial-BoldItalic"] = {
              name: "LiberationSans-BoldItalic",
              baseWidths: h.LiberationSansBoldItalicWidths,
              baseMapping: h.LiberationSansBoldItalicMapping
            }, i["Calibri-Regular"] = {
              name: "LiberationSans-Regular",
              factors: t.CalibriRegularFactors,
              baseWidths: h.LiberationSansRegularWidths,
              baseMapping: h.LiberationSansRegularMapping,
              metrics: t.CalibriRegularMetrics
            }, i["Calibri-Bold"] = {
              name: "LiberationSans-Bold",
              factors: t.CalibriBoldFactors,
              baseWidths: h.LiberationSansBoldWidths,
              baseMapping: h.LiberationSansBoldMapping,
              metrics: t.CalibriBoldMetrics
            }, i["Calibri-Italic"] = {
              name: "LiberationSans-Italic",
              factors: t.CalibriItalicFactors,
              baseWidths: h.LiberationSansItalicWidths,
              baseMapping: h.LiberationSansItalicMapping,
              metrics: t.CalibriItalicMetrics
            }, i["Calibri-BoldItalic"] = {
              name: "LiberationSans-BoldItalic",
              factors: t.CalibriBoldItalicFactors,
              baseWidths: h.LiberationSansBoldItalicWidths,
              baseMapping: h.LiberationSansBoldItalicMapping,
              metrics: t.CalibriBoldItalicMetrics
            }, i["Segoeui-Regular"] = {
              name: "LiberationSans-Regular",
              factors: y.SegoeuiRegularFactors,
              baseWidths: h.LiberationSansRegularWidths,
              baseMapping: h.LiberationSansRegularMapping,
              metrics: y.SegoeuiRegularMetrics
            }, i["Segoeui-Bold"] = {
              name: "LiberationSans-Bold",
              factors: y.SegoeuiBoldFactors,
              baseWidths: h.LiberationSansBoldWidths,
              baseMapping: h.LiberationSansBoldMapping,
              metrics: y.SegoeuiBoldMetrics
            }, i["Segoeui-Italic"] = {
              name: "LiberationSans-Italic",
              factors: y.SegoeuiItalicFactors,
              baseWidths: h.LiberationSansItalicWidths,
              baseMapping: h.LiberationSansItalicMapping,
              metrics: y.SegoeuiItalicMetrics
            }, i["Segoeui-BoldItalic"] = {
              name: "LiberationSans-BoldItalic",
              factors: y.SegoeuiBoldItalicFactors,
              baseWidths: h.LiberationSansBoldItalicWidths,
              baseMapping: h.LiberationSansBoldItalicMapping,
              metrics: y.SegoeuiBoldItalicMetrics
            }, i["Helvetica-Regular"] = i.Helvetica = {
              name: "LiberationSans-Regular",
              factors: v.HelveticaRegularFactors,
              baseWidths: h.LiberationSansRegularWidths,
              baseMapping: h.LiberationSansRegularMapping,
              metrics: v.HelveticaRegularMetrics
            }, i["Helvetica-Bold"] = {
              name: "LiberationSans-Bold",
              factors: v.HelveticaBoldFactors,
              baseWidths: h.LiberationSansBoldWidths,
              baseMapping: h.LiberationSansBoldMapping,
              metrics: v.HelveticaBoldMetrics
            }, i["Helvetica-Italic"] = {
              name: "LiberationSans-Italic",
              factors: v.HelveticaItalicFactors,
              baseWidths: h.LiberationSansItalicWidths,
              baseMapping: h.LiberationSansItalicMapping,
              metrics: v.HelveticaItalicMetrics
            }, i["Helvetica-BoldItalic"] = {
              name: "LiberationSans-BoldItalic",
              factors: v.HelveticaBoldItalicFactors,
              baseWidths: h.LiberationSansBoldItalicWidths,
              baseMapping: h.LiberationSansBoldItalicMapping,
              metrics: v.HelveticaBoldItalicMetrics
            };
          });
          function m(i) {
            const l = (0, d.normalizeFontName)(i);
            return p()[l];
          }
          function g(i) {
            const l = m(i);
            if (!l)
              return null;
            const {
              baseWidths: u,
              baseMapping: w,
              factors: _
            } = l;
            let b;
            _ ? b = u.map((X, B) => X * _[B]) : b = u;
            let A = -2, Y;
            const j = [];
            for (const [X, B] of w.map((R, k) => [R, k]).sort(([R], [k]) => R - k))
              X !== -1 && (X === A + 1 ? (Y.push(b[B]), A += 1) : (A = X, Y = [b[B]], j.push(X, Y)));
            return j;
          }
          function n(i) {
            const l = g(i), u = new a.Dict(null);
            u.set("BaseFont", a.Name.get(i)), u.set("Type", a.Name.get("Font")), u.set("Subtype", a.Name.get("CIDFontType2")), u.set("Encoding", a.Name.get("Identity-H")), u.set("CIDToGIDMap", a.Name.get("Identity")), u.set("W", l), u.set("FirstChar", l[0]), u.set("LastChar", l.at(-2) + l.at(-1).length - 1);
            const w = new a.Dict(null);
            u.set("FontDescriptor", w);
            const _ = new a.Dict(null);
            return _.set("Ordering", "Identity"), _.set("Registry", "Adobe"), _.set("Supplement", 0), u.set("CIDSystemInfo", _), u;
          }
        },
        /* 52 */
        /***/
        (Z, o) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.CalibriRegularMetrics = o.CalibriRegularFactors = o.CalibriItalicMetrics = o.CalibriItalicFactors = o.CalibriBoldMetrics = o.CalibriBoldItalicMetrics = o.CalibriBoldItalicFactors = o.CalibriBoldFactors = void 0;
          const C = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.54657, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.73293, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.9121, 0.86943, 0.79795, 0.88198, 0.77958, 0.70864, 0.81055, 0.90399, 0.88653, 0.96017, 0.82577, 0.77892, 0.78257, 0.97507, 1.54657, 0.97507, 0.85284, 0.89552, 0.90176, 0.88762, 0.8785, 0.75241, 0.8785, 0.90518, 0.95015, 0.77618, 0.8785, 0.88401, 0.91916, 0.86304, 0.88401, 0.91488, 0.8785, 0.8801, 0.8785, 0.8785, 0.91343, 0.7173, 1.04106, 0.8785, 0.85075, 0.95794, 0.82616, 0.85162, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.12401, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.73293, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.9121, 0.86943, 0.86943, 0.86943, 0.86943, 0.86943, 0.85284, 0.87508, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.8715, 0.75241, 0.90518, 0.90518, 0.90518, 0.90518, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.8785, 0.8801, 0.8801, 0.8801, 0.8801, 0.8801, 0.90747, 0.89049, 0.8785, 0.8785, 0.8785, 0.8785, 0.85162, 0.8785, 0.85162, 0.83908, 0.88762, 0.83908, 0.88762, 0.83908, 0.88762, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.87289, 0.83016, 0.88506, 0.93125, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.81921, 0.77618, 0.81921, 0.77618, 0.81921, 0.77618, 1, 1, 0.87356, 0.8785, 0.91075, 0.89608, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76229, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.79468, 0.91926, 0.88175, 0.70823, 0.94903, 0.9121, 0.8785, 1, 1, 0.9121, 0.8785, 0.87802, 0.88656, 0.8785, 0.86943, 0.8801, 0.86943, 0.8801, 0.86943, 0.8801, 0.87402, 0.89291, 0.77958, 0.91343, 1, 1, 0.77958, 0.91343, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.96017, 0.95794, 0.77892, 0.85162, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.88762, 0.77539, 0.8715, 0.87508, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70674, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.06303, 0.83908, 0.80352, 0.57184, 0.6965, 0.56289, 0.82001, 0.56029, 0.81235, 1.02988, 0.83908, 0.7762, 0.68156, 0.80367, 0.73133, 0.78257, 0.87356, 0.86943, 0.95958, 0.75727, 0.89019, 1.04924, 0.9121, 0.7648, 0.86943, 0.87356, 0.79795, 0.78275, 0.81055, 0.77892, 0.9762, 0.82577, 0.99819, 0.84896, 0.95958, 0.77892, 0.96108, 1.01407, 0.89049, 1.02988, 0.94211, 0.96108, 0.8936, 0.84021, 0.87842, 0.96399, 0.79109, 0.89049, 1.00813, 1.02988, 0.86077, 0.87445, 0.92099, 0.84723, 0.86513, 0.8801, 0.75638, 0.85714, 0.78216, 0.79586, 0.87965, 0.94211, 0.97747, 0.78287, 0.97926, 0.84971, 1.02988, 0.94211, 0.8801, 0.94211, 0.84971, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90264, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90518, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90548, 1, 1, 1, 1, 1, 1, 0.96017, 0.95794, 0.96017, 0.95794, 0.96017, 0.95794, 0.77892, 0.85162, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.92794, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71143, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.93835, 0.83406, 0.91133, 0.84107, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90527, 1.81055, 0.90527, 1.81055, 1.31006, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          o.CalibriBoldFactors = C;
          const t = {
            lineHeight: 1.2207,
            lineGap: 0.2207
          };
          o.CalibriBoldMetrics = t;
          const a = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.56239, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.71805, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.90872, 0.85938, 0.79795, 0.87068, 0.77958, 0.69766, 0.81055, 0.90399, 0.88653, 0.96068, 0.82577, 0.77892, 0.78257, 0.97507, 1.529, 0.97507, 0.85284, 0.89552, 0.90176, 0.94908, 0.86411, 0.74012, 0.86411, 0.88323, 0.95015, 0.86411, 0.86331, 0.88401, 0.91916, 0.86304, 0.88401, 0.9039, 0.86331, 0.86331, 0.86411, 0.86411, 0.90464, 0.70852, 1.04106, 0.86331, 0.84372, 0.95794, 0.82616, 0.84548, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.19129, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.71805, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.90872, 0.85938, 0.85938, 0.85938, 0.85938, 0.85938, 0.85284, 0.87068, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.85887, 0.74012, 0.88323, 0.88323, 0.88323, 0.88323, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.90747, 0.89049, 0.86331, 0.86331, 0.86331, 0.86331, 0.84548, 0.86411, 0.84548, 0.83908, 0.94908, 0.83908, 0.94908, 0.83908, 0.94908, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.87289, 0.79538, 0.88506, 0.92726, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.81921, 0.86411, 0.81921, 0.86411, 0.81921, 0.86411, 1, 1, 0.87356, 0.86331, 0.91075, 0.8777, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76467, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.77312, 0.91926, 0.88175, 0.70823, 0.94903, 0.90872, 0.86331, 1, 1, 0.90872, 0.86331, 0.86906, 0.88116, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.87402, 0.86549, 0.77958, 0.90464, 1, 1, 0.77958, 0.90464, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.96068, 0.95794, 0.77892, 0.84548, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.94908, 0.77539, 0.85887, 0.87068, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70088, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.48387, 0.83908, 0.80352, 0.57118, 0.6965, 0.56347, 0.79179, 0.55853, 0.80346, 1.02988, 0.83908, 0.7762, 0.67174, 0.86036, 0.73133, 0.78257, 0.87356, 0.86441, 0.95958, 0.75727, 0.89019, 1.04924, 0.90872, 0.74889, 0.85938, 0.87891, 0.79795, 0.7957, 0.81055, 0.77892, 0.97447, 0.82577, 0.97466, 0.87179, 0.95958, 0.77892, 0.94252, 0.95612, 0.8753, 1.02988, 0.92733, 0.94252, 0.87411, 0.84021, 0.8728, 0.95612, 0.74081, 0.8753, 1.02189, 1.02988, 0.84814, 0.87445, 0.91822, 0.84723, 0.85668, 0.86331, 0.81344, 0.87581, 0.76422, 0.82046, 0.96057, 0.92733, 0.99375, 0.78022, 0.95452, 0.86015, 1.02988, 0.92733, 0.86331, 0.92733, 0.86015, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90631, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88323, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85174, 1, 1, 1, 1, 1, 1, 0.96068, 0.95794, 0.96068, 0.95794, 0.96068, 0.95794, 0.77892, 0.84548, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.89807, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71094, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.92972, 0.83406, 0.91133, 0.83326, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90616, 1.81055, 0.90527, 1.81055, 1.3107, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          o.CalibriBoldItalicFactors = a;
          const v = {
            lineHeight: 1.2207,
            lineGap: 0.2207
          };
          o.CalibriBoldItalicMetrics = v;
          const h = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39543, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.72346, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89249, 0.84118, 0.77452, 0.85374, 0.75186, 0.67789, 0.79776, 0.88844, 0.85066, 0.94309, 0.77818, 0.7306, 0.76659, 1.10369, 1.38313, 1.10369, 1.06139, 0.89552, 0.8739, 0.9245, 0.9245, 0.83203, 0.9245, 0.85865, 1.09842, 0.9245, 0.9245, 1.03297, 1.07692, 0.90918, 1.03297, 0.94959, 0.9245, 0.92274, 0.9245, 0.9245, 1.02933, 0.77832, 1.20562, 0.9245, 0.8916, 0.98986, 0.86621, 0.89453, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.16359, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.72346, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89249, 0.84118, 0.84118, 0.84118, 0.84118, 0.84118, 0.85284, 0.84557, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.84843, 0.83203, 0.85865, 0.85865, 0.85865, 0.85865, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.9245, 0.92274, 0.92274, 0.92274, 0.92274, 0.92274, 0.90747, 0.86651, 0.9245, 0.9245, 0.9245, 0.9245, 0.89453, 0.9245, 0.89453, 0.8675, 0.9245, 0.8675, 0.9245, 0.8675, 0.9245, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.85193, 0.8875, 0.86477, 0.99034, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.81105, 0.9245, 0.81105, 0.9245, 0.81105, 0.9245, 1, 1, 0.86275, 0.9245, 0.90872, 0.93591, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77896, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.9375, 0.98156, 0.93407, 0.77261, 1.11429, 0.89249, 0.9245, 1, 1, 0.89249, 0.9245, 0.92534, 0.86698, 0.9245, 0.84118, 0.92274, 0.84118, 0.92274, 0.84118, 0.92274, 0.8667, 0.86291, 0.75186, 1.02933, 1, 1, 0.75186, 1.02933, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 1, 1, 0.79776, 0.97655, 0.79776, 1.23023, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.94309, 0.98986, 0.7306, 0.89453, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.9245, 0.76318, 0.84843, 0.84557, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67009, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.8675, 0.90861, 0.6192, 0.7363, 0.64824, 0.82411, 0.56321, 0.85696, 1.23516, 0.8675, 0.81552, 0.7286, 0.84134, 0.73206, 0.76659, 0.86275, 0.84369, 0.90685, 0.77892, 0.85871, 1.02638, 0.89249, 0.75828, 0.84118, 0.85984, 0.77452, 0.76466, 0.79776, 0.7306, 0.90782, 0.77818, 0.903, 0.87291, 0.90685, 0.7306, 0.99058, 1.03667, 0.94635, 1.23516, 0.9849, 0.99058, 0.92393, 0.8916, 0.942, 1.03667, 0.75026, 0.94635, 1.0297, 1.23516, 0.90918, 0.94048, 0.98217, 0.89746, 0.84153, 0.92274, 0.82507, 0.88832, 0.84438, 0.88178, 1.03525, 0.9849, 1.00225, 0.78086, 0.97248, 0.89404, 1.23516, 0.9849, 0.92274, 0.9849, 0.89404, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89693, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85865, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90933, 1, 1, 1, 1, 1, 1, 0.94309, 0.98986, 0.94309, 0.98986, 0.94309, 0.98986, 0.7306, 0.89453, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.68994, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.97858, 0.82616, 0.91133, 0.83437, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90572, 1.81055, 0.90749, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85284, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          o.CalibriItalicFactors = h;
          const e = {
            lineHeight: 1.2207,
            lineGap: 0.2207
          };
          o.CalibriItalicMetrics = e;
          const y = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39016, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.73834, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89385, 0.85122, 0.77452, 0.86503, 0.75186, 0.68887, 0.79776, 0.88844, 0.85066, 0.94258, 0.77818, 0.7306, 0.76659, 1.10369, 1.39016, 1.10369, 1.06139, 0.89552, 0.8739, 0.86128, 0.94469, 0.8457, 0.94469, 0.89464, 1.09842, 0.84636, 0.94469, 1.03297, 1.07692, 0.90918, 1.03297, 0.95897, 0.94469, 0.9482, 0.94469, 0.94469, 1.04692, 0.78223, 1.20562, 0.94469, 0.90332, 0.98986, 0.86621, 0.90527, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.08707, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.73834, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89385, 0.85122, 0.85122, 0.85122, 0.85122, 0.85122, 0.85284, 0.85311, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.8693, 0.8457, 0.89464, 0.89464, 0.89464, 0.89464, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.94469, 0.9482, 0.9482, 0.9482, 0.9482, 0.9482, 0.90747, 0.86651, 0.94469, 0.94469, 0.94469, 0.94469, 0.90527, 0.94469, 0.90527, 0.8675, 0.86128, 0.8675, 0.86128, 0.8675, 0.86128, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.85193, 0.92454, 0.86477, 0.9921, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.81105, 0.84636, 0.81105, 0.84636, 0.81105, 0.84636, 1, 1, 0.86275, 0.94469, 0.90872, 0.95786, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77741, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.90452, 0.98156, 1.11842, 0.77261, 1.11429, 0.89385, 0.94469, 1, 1, 0.89385, 0.94469, 0.95877, 0.86901, 0.94469, 0.85122, 0.9482, 0.85122, 0.9482, 0.85122, 0.9482, 0.8667, 0.90016, 0.75186, 1.04692, 1, 1, 0.75186, 1.04692, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 1, 1, 0.79776, 0.92188, 0.79776, 1.23023, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.94258, 0.98986, 0.7306, 0.90527, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.86128, 0.76318, 0.8693, 0.85311, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67742, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.86686, 0.90861, 0.62267, 0.74359, 0.65649, 0.85498, 0.56963, 0.88254, 1.23516, 0.8675, 0.81552, 0.75443, 0.84503, 0.73206, 0.76659, 0.86275, 0.85122, 0.90685, 0.77892, 0.85746, 1.02638, 0.89385, 0.75657, 0.85122, 0.86275, 0.77452, 0.74171, 0.79776, 0.7306, 0.95165, 0.77818, 0.89772, 0.88831, 0.90685, 0.7306, 0.98142, 1.02191, 0.96576, 1.23516, 0.99018, 0.98142, 0.9236, 0.89258, 0.94035, 1.02191, 0.78848, 0.96576, 0.9561, 1.23516, 0.90918, 0.92578, 0.95424, 0.89746, 0.83969, 0.9482, 0.80113, 0.89442, 0.85208, 0.86155, 0.98022, 0.99018, 1.00452, 0.81209, 0.99247, 0.89181, 1.23516, 0.99018, 0.9482, 0.99018, 0.89181, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88844, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89464, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96766, 1, 1, 1, 1, 1, 1, 0.94258, 0.98986, 0.94258, 0.98986, 0.94258, 0.98986, 0.7306, 0.90527, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.69043, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.99331, 0.82616, 0.91133, 0.84286, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90527, 1.81055, 0.90527, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1.07185, 0.99413, 0.96334, 1.08065, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          o.CalibriRegularFactors = y;
          const c = {
            lineHeight: 1.2207,
            lineGap: 0.2207
          };
          o.CalibriRegularMetrics = c;
        },
        /* 53 */
        /***/
        (Z, o) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.HelveticaRegularMetrics = o.HelveticaRegularFactors = o.HelveticaItalicMetrics = o.HelveticaItalicFactors = o.HelveticaBoldMetrics = o.HelveticaBoldItalicMetrics = o.HelveticaBoldItalicFactors = o.HelveticaBoldFactors = void 0;
          const C = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.03374, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.00042, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.03828, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00034, 0.99977, 1, 0.99997, 1.00026, 1.00078, 1.00036, 0.99973, 1.00013, 1.0006, 0.99977, 0.99977, 0.99988, 0.85148, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 1.00069, 1.00022, 0.99977, 1.00001, 0.99984, 1.00026, 1.00001, 1.00024, 1.00001, 0.9999, 1, 1.0006, 1.00001, 1.00041, 0.99962, 1.00026, 1.0006, 0.99995, 1.00041, 0.99942, 0.99973, 0.99927, 1.00082, 0.99902, 1.00026, 1.00087, 1.0006, 1.00069, 0.99973, 0.99867, 0.99973, 0.9993, 1.00026, 1.00049, 1.00056, 1, 0.99988, 0.99935, 0.99995, 0.99954, 1.00055, 0.99945, 1.00032, 1.0006, 0.99995, 1.00026, 0.99995, 1.00032, 1.00001, 1.00008, 0.99971, 1.00019, 0.9994, 1.00001, 1.0006, 1.00044, 0.99973, 1.00023, 1.00047, 1, 0.99942, 0.99561, 0.99989, 1.00035, 0.99977, 1.00035, 0.99977, 1.00019, 0.99944, 1.00001, 1.00021, 0.99926, 1.00035, 1.00035, 0.99942, 1.00048, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.99989, 1.00057, 1.00001, 0.99936, 1.00052, 1.00012, 0.99996, 1.00043, 1, 1.00035, 0.9994, 0.99976, 1.00035, 0.99973, 1.00052, 1.00041, 1.00119, 1.00037, 0.99973, 1.00002, 0.99986, 1.00041, 1.00041, 0.99902, 0.9996, 1.00034, 0.99999, 1.00026, 0.99999, 1.00026, 0.99973, 1.00052, 0.99973, 1, 0.99973, 1.00041, 1.00075, 0.9994, 1.0003, 0.99999, 1, 1.00041, 0.99955, 1, 0.99915, 0.99973, 0.99973, 1.00026, 1.00119, 0.99955, 0.99973, 1.0006, 0.99911, 1.0006, 1.00026, 0.99972, 1.00026, 0.99902, 1.00041, 0.99973, 0.99999, 1, 1, 1.00038, 1.0005, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 1.00047, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          o.HelveticaBoldFactors = C;
          const t = {
            lineHeight: 1.2,
            lineGap: 0.2
          };
          o.HelveticaBoldMetrics = t;
          const a = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.0044, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99971, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.01011, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99977, 1, 1, 1.00026, 0.99969, 0.99972, 0.99981, 0.9998, 1.0006, 0.99977, 0.99977, 1.00022, 0.91155, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 0.99966, 1.00022, 1.00032, 1.00001, 0.99944, 1.00026, 1.00001, 0.99968, 1.00001, 1.00047, 1, 1.0006, 1.00001, 0.99981, 1.00101, 1.00026, 1.0006, 0.99948, 0.99981, 1.00064, 0.99973, 0.99942, 1.00101, 1.00061, 1.00026, 1.00069, 1.0006, 1.00014, 0.99973, 1.01322, 0.99973, 1.00065, 1.00026, 1.00012, 0.99923, 1, 1.00064, 1.00076, 0.99948, 1.00055, 1.00063, 1.00007, 0.99943, 1.0006, 0.99948, 1.00026, 0.99948, 0.99943, 1.00001, 1.00001, 1.00029, 1.00038, 1.00035, 1.00001, 1.0006, 1.0006, 0.99973, 0.99978, 1.00001, 1.00057, 0.99989, 0.99967, 0.99964, 0.99967, 0.99977, 0.99999, 0.99977, 1.00038, 0.99977, 1.00001, 0.99973, 1.00066, 0.99967, 0.99967, 1.00041, 0.99998, 0.99999, 0.99977, 1.00022, 0.99967, 1.00001, 0.99977, 1.00026, 0.99964, 1.00031, 1.00001, 0.99999, 0.99999, 1, 1.00023, 1, 1, 0.99999, 1.00035, 1.00001, 0.99999, 0.99973, 0.99977, 0.99999, 1.00058, 0.99973, 0.99973, 0.99955, 0.9995, 1.00026, 1.00026, 1.00032, 0.99989, 1.00034, 0.99999, 1.00026, 1.00026, 1.00026, 0.99973, 0.45998, 0.99973, 1.00026, 0.99973, 1.00001, 0.99999, 0.99982, 0.99994, 0.99996, 1, 1.00042, 1.00044, 1.00029, 1.00023, 0.99973, 0.99973, 1.00026, 0.99949, 1.00002, 0.99973, 1.0006, 1.0006, 1.0006, 0.99975, 1.00026, 1.00026, 1.00032, 0.98685, 0.99973, 1.00026, 1, 1, 0.99966, 1.00044, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1, 0.99973, 0.99971, 0.99978, 1, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00098, 1, 1, 1, 1.00049, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          o.HelveticaBoldItalicFactors = a;
          const v = {
            lineHeight: 1.35,
            lineGap: 0.2
          };
          o.HelveticaBoldItalicMetrics = v;
          const h = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.0288, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 0.99946, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.06311, 0.99973, 1.00024, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00041, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.89547, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00001, 1, 1.00054, 0.99977, 1.00084, 1.00007, 0.99973, 1.00013, 0.99924, 1.00001, 1.00001, 0.99945, 0.91221, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00001, 0.99999, 0.99977, 0.99933, 1.00022, 1.00054, 1.00001, 1.00065, 1.00026, 1.00001, 1.0001, 1.00001, 1.00052, 1, 1.0006, 1.00001, 0.99945, 0.99897, 0.99968, 0.99924, 1.00036, 0.99945, 0.99949, 1, 1.0006, 0.99897, 0.99918, 0.99968, 0.99911, 0.99924, 1, 0.99962, 1.01487, 1, 1.0005, 0.99973, 1.00012, 1.00043, 1, 0.99995, 0.99994, 1.00036, 0.99947, 1.00019, 1.00063, 1.00025, 0.99924, 1.00036, 0.99973, 1.00036, 1.00025, 1.00001, 1.00001, 1.00027, 1.0001, 1.00068, 1.00001, 1.0006, 1.0006, 1, 1.00008, 0.99957, 0.99972, 0.9994, 0.99954, 0.99975, 1.00051, 1.00001, 1.00019, 1.00001, 1.0001, 0.99986, 1.00001, 1.00001, 1.00038, 0.99954, 0.99954, 0.9994, 1.00066, 0.99999, 0.99977, 1.00022, 1.00054, 1.00001, 0.99977, 1.00026, 0.99975, 1.0001, 1.00001, 0.99993, 0.9995, 0.99955, 1.00016, 0.99978, 0.99974, 1.00019, 1.00022, 0.99955, 1.00053, 0.99973, 1.00089, 1.00005, 0.99967, 1.00048, 0.99973, 1.00002, 1.00034, 0.99973, 0.99973, 0.99964, 1.00006, 1.00066, 0.99947, 0.99973, 0.98894, 0.99973, 1, 0.44898, 1, 0.99946, 1, 1.00039, 1.00082, 0.99991, 0.99991, 0.99985, 1.00022, 1.00023, 1.00061, 1.00006, 0.99966, 0.99973, 0.99973, 0.99973, 1.00019, 1.0008, 1, 0.99924, 0.99924, 0.99924, 0.99983, 1.00044, 0.99973, 0.99964, 0.98332, 1, 0.99973, 1, 1, 0.99962, 0.99895, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 1.00423, 0.99925, 0.99999, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00049, 1, 1.00245, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 1.00003, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          o.HelveticaItalicFactors = h;
          const e = {
            lineHeight: 1.35,
            lineGap: 0.2
          };
          o.HelveticaItalicMetrics = e;
          const y = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.04596, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 1.00019, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.02572, 0.99973, 1.00005, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99999, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.84533, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99928, 1, 0.99977, 1.00013, 1.00055, 0.99947, 0.99945, 0.99941, 0.99924, 1.00001, 1.00001, 1.0004, 0.91621, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00005, 0.99999, 0.99977, 1.00015, 1.00022, 0.99977, 1.00001, 0.99973, 1.00026, 1.00001, 1.00019, 1.00001, 0.99946, 1, 1.0006, 1.00001, 0.99978, 1.00045, 0.99973, 0.99924, 1.00023, 0.99978, 0.99966, 1, 1.00065, 1.00045, 1.00019, 0.99973, 0.99973, 0.99924, 1, 1, 0.96499, 1, 1.00055, 0.99973, 1.00008, 1.00027, 1, 0.9997, 0.99995, 1.00023, 0.99933, 1.00019, 1.00015, 1.00031, 0.99924, 1.00023, 0.99973, 1.00023, 1.00031, 1.00001, 0.99928, 1.00029, 1.00092, 1.00035, 1.00001, 1.0006, 1.0006, 1, 0.99988, 0.99975, 1, 1.00082, 0.99561, 0.9996, 1.00035, 1.00001, 0.99962, 1.00001, 1.00092, 0.99964, 1.00001, 0.99963, 0.99999, 1.00035, 1.00035, 1.00082, 0.99962, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.9996, 0.99967, 1.00001, 1.00034, 1.00074, 1.00054, 1.00053, 1.00063, 0.99971, 0.99962, 1.00035, 0.99975, 0.99977, 0.99973, 1.00043, 0.99953, 1.0007, 0.99915, 0.99973, 1.00008, 0.99892, 1.00073, 1.00073, 1.00114, 0.99915, 1.00073, 0.99955, 0.99973, 1.00092, 0.99973, 1, 0.99998, 1, 1.0003, 1, 1.00043, 1.00001, 0.99969, 1.0003, 1, 1.00035, 1.00001, 0.9995, 1, 1.00092, 0.99973, 0.99973, 0.99973, 1.0007, 0.9995, 1, 0.99924, 1.0006, 0.99924, 0.99972, 1.00062, 0.99973, 1.00114, 1.00073, 1, 0.99955, 1, 1, 1.00047, 0.99968, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 0.99925, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          o.HelveticaRegularFactors = y;
          const c = {
            lineHeight: 1.2,
            lineGap: 0.2
          };
          o.HelveticaRegularMetrics = c;
        },
        /* 54 */
        /***/
        (Z, o) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.LiberationSansRegularWidths = o.LiberationSansRegularMapping = o.LiberationSansItalicWidths = o.LiberationSansItalicMapping = o.LiberationSansBoldWidths = o.LiberationSansBoldMapping = o.LiberationSansBoldItalicWidths = o.LiberationSansBoldItalicMapping = void 0;
          const C = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 719, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 785, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 385, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 465, 722, 333, 853, 906, 474, 825, 927, 838, 278, 722, 722, 601, 719, 667, 611, 722, 778, 278, 722, 667, 833, 722, 644, 778, 722, 667, 600, 611, 667, 821, 667, 809, 802, 278, 667, 615, 451, 611, 278, 582, 615, 610, 556, 606, 475, 460, 611, 541, 278, 558, 556, 612, 556, 445, 611, 766, 619, 520, 684, 446, 582, 715, 576, 753, 845, 278, 582, 611, 582, 845, 667, 669, 885, 567, 711, 667, 278, 276, 556, 1094, 1062, 875, 610, 722, 622, 719, 722, 719, 722, 567, 712, 667, 904, 626, 719, 719, 610, 702, 833, 722, 778, 719, 667, 722, 611, 622, 854, 667, 730, 703, 1005, 1019, 870, 979, 719, 711, 1031, 719, 556, 618, 615, 417, 635, 556, 709, 497, 615, 615, 500, 635, 740, 604, 611, 604, 611, 556, 490, 556, 875, 556, 615, 581, 833, 844, 729, 854, 615, 552, 854, 583, 556, 556, 611, 417, 552, 556, 278, 281, 278, 969, 906, 611, 500, 615, 556, 604, 778, 611, 487, 447, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1094, 556, 885, 489, 1115, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333];
          o.LiberationSansBoldWidths = C;
          const t = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
          o.LiberationSansBoldMapping = t;
          const a = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 740, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 782, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 396, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 722, 333, 854, 906, 473, 844, 930, 847, 278, 722, 722, 610, 671, 667, 611, 722, 778, 278, 722, 667, 833, 722, 657, 778, 718, 667, 590, 611, 667, 822, 667, 829, 781, 278, 667, 620, 479, 611, 278, 591, 620, 621, 556, 610, 479, 492, 611, 558, 278, 566, 556, 603, 556, 450, 611, 712, 605, 532, 664, 409, 591, 704, 578, 773, 834, 278, 591, 611, 591, 834, 667, 667, 886, 614, 719, 667, 278, 278, 556, 1094, 1042, 854, 622, 719, 677, 719, 722, 708, 722, 614, 722, 667, 927, 643, 719, 719, 615, 687, 833, 722, 778, 719, 667, 722, 611, 677, 781, 667, 729, 708, 979, 989, 854, 1e3, 708, 719, 1042, 729, 556, 619, 604, 534, 618, 556, 736, 510, 611, 611, 507, 622, 740, 604, 611, 611, 611, 556, 889, 556, 885, 556, 646, 583, 889, 935, 707, 854, 594, 552, 865, 589, 556, 556, 611, 469, 563, 556, 278, 278, 278, 969, 906, 611, 507, 619, 556, 611, 778, 611, 575, 467, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1104, 556, 885, 516, 1146, 1e3, 768, 600, 834, 834, 834, 834, 999, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333];
          o.LiberationSansBoldItalicWidths = a;
          const v = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
          o.LiberationSansBoldItalicMapping = v;
          const h = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 625, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 733, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 281, 556, 400, 556, 222, 722, 556, 722, 556, 722, 556, 615, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 354, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 789, 846, 389, 794, 865, 775, 222, 667, 667, 570, 671, 667, 611, 722, 778, 278, 667, 667, 833, 722, 648, 778, 725, 667, 600, 611, 667, 837, 667, 831, 761, 278, 667, 570, 439, 555, 222, 550, 570, 571, 500, 556, 439, 463, 555, 542, 222, 500, 492, 548, 500, 447, 556, 670, 573, 486, 603, 374, 550, 652, 546, 728, 779, 222, 550, 556, 550, 779, 667, 667, 843, 544, 708, 667, 278, 278, 500, 1066, 982, 844, 589, 715, 639, 724, 667, 651, 667, 544, 704, 667, 917, 614, 715, 715, 589, 686, 833, 722, 778, 725, 667, 722, 611, 639, 795, 667, 727, 673, 920, 923, 805, 886, 651, 694, 1022, 682, 556, 562, 522, 493, 553, 556, 688, 465, 556, 556, 472, 564, 686, 550, 556, 556, 556, 500, 833, 500, 835, 500, 572, 518, 830, 851, 621, 736, 526, 492, 752, 534, 556, 556, 556, 378, 496, 500, 222, 222, 222, 910, 828, 556, 472, 565, 500, 556, 778, 556, 492, 339, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1083, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 998, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 584, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285];
          o.LiberationSansItalicWidths = h;
          const e = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
          o.LiberationSansItalicMapping = e;
          const y = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 615, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 735, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 292, 556, 334, 556, 222, 722, 556, 722, 556, 722, 556, 604, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 375, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 784, 838, 384, 774, 855, 752, 222, 667, 667, 551, 668, 667, 611, 722, 778, 278, 667, 668, 833, 722, 650, 778, 722, 667, 618, 611, 667, 798, 667, 835, 748, 278, 667, 578, 446, 556, 222, 547, 578, 575, 500, 557, 446, 441, 556, 556, 222, 500, 500, 576, 500, 448, 556, 690, 569, 482, 617, 395, 547, 648, 525, 713, 781, 222, 547, 556, 547, 781, 667, 667, 865, 542, 719, 667, 278, 278, 500, 1057, 1010, 854, 583, 722, 635, 719, 667, 656, 667, 542, 677, 667, 923, 604, 719, 719, 583, 656, 833, 722, 778, 719, 667, 722, 611, 635, 760, 667, 740, 667, 917, 938, 792, 885, 656, 719, 1010, 722, 556, 573, 531, 365, 583, 556, 669, 458, 559, 559, 438, 583, 688, 552, 556, 542, 556, 500, 458, 500, 823, 500, 573, 521, 802, 823, 625, 719, 521, 510, 750, 542, 556, 556, 556, 365, 510, 500, 222, 278, 222, 906, 812, 556, 438, 559, 500, 552, 778, 556, 489, 411, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1073, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285];
          o.LiberationSansRegularWidths = y;
          const c = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
          o.LiberationSansRegularMapping = c;
        },
        /* 55 */
        /***/
        (Z, o) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.MyriadProRegularMetrics = o.MyriadProRegularFactors = o.MyriadProItalicMetrics = o.MyriadProItalicFactors = o.MyriadProBoldMetrics = o.MyriadProBoldItalicMetrics = o.MyriadProBoldItalicFactors = o.MyriadProBoldFactors = void 0;
          const C = [1.36898, 1, 1, 0.72706, 0.80479, 0.83734, 0.98894, 0.99793, 0.9897, 0.93884, 0.86209, 0.94292, 0.94292, 1.16661, 1.02058, 0.93582, 0.96694, 0.93582, 1.19137, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.72851, 0.78966, 0.90838, 0.83637, 0.82391, 0.96376, 0.80061, 0.86275, 0.8768, 0.95407, 1.0258, 0.73901, 0.85022, 0.83655, 1.0156, 0.95546, 0.92179, 0.87107, 0.92179, 0.82114, 0.8096, 0.89713, 0.94438, 0.95353, 0.94083, 0.91905, 0.90406, 0.9446, 0.94292, 1.18777, 0.94292, 1.02058, 0.89903, 0.90088, 0.94938, 0.97898, 0.81093, 0.97571, 0.94938, 1.024, 0.9577, 0.95933, 0.98621, 1.0474, 0.97455, 0.98981, 0.9672, 0.95933, 0.9446, 0.97898, 0.97407, 0.97646, 0.78036, 1.10208, 0.95442, 0.95298, 0.97579, 0.9332, 0.94039, 0.938, 0.80687, 1.01149, 0.80687, 1.02058, 0.80479, 0.99793, 0.99793, 0.99793, 0.99793, 1.01149, 1.00872, 0.90088, 0.91882, 1.0213, 0.8361, 1.02058, 0.62295, 0.54324, 0.89022, 1.08595, 1, 1, 0.90088, 1, 0.97455, 0.93582, 0.90088, 1, 1.05686, 0.8361, 0.99642, 0.99642, 0.99642, 0.72851, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.868, 0.82391, 0.80061, 0.80061, 0.80061, 0.80061, 1.0258, 1.0258, 1.0258, 1.0258, 0.97484, 0.95546, 0.92179, 0.92179, 0.92179, 0.92179, 0.92179, 1.02058, 0.92179, 0.94438, 0.94438, 0.94438, 0.94438, 0.90406, 0.86958, 0.98225, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.9031, 0.81093, 0.94938, 0.94938, 0.94938, 0.94938, 0.98621, 0.98621, 0.98621, 0.98621, 0.93969, 0.95933, 0.9446, 0.9446, 0.9446, 0.9446, 0.9446, 1.08595, 0.9446, 0.95442, 0.95442, 0.95442, 0.95442, 0.94039, 0.97898, 0.94039, 0.90838, 0.94938, 0.90838, 0.94938, 0.90838, 0.94938, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.96376, 0.84313, 0.97484, 0.97571, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.8768, 0.9577, 0.8768, 0.9577, 0.8768, 0.9577, 1, 1, 0.95407, 0.95933, 0.97069, 0.95933, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 0.887, 1.01591, 0.73901, 1.0474, 1, 1, 0.97455, 0.83655, 0.98981, 1, 1, 0.83655, 0.73977, 0.83655, 0.73903, 0.84638, 1.033, 0.95546, 0.95933, 1, 1, 0.95546, 0.95933, 0.8271, 0.95417, 0.95933, 0.92179, 0.9446, 0.92179, 0.9446, 0.92179, 0.9446, 0.936, 0.91964, 0.82114, 0.97646, 1, 1, 0.82114, 0.97646, 0.8096, 0.78036, 0.8096, 0.78036, 1, 1, 0.8096, 0.78036, 1, 1, 0.89713, 0.77452, 0.89713, 1.10208, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94083, 0.97579, 0.90406, 0.94039, 0.90406, 0.9446, 0.938, 0.9446, 0.938, 0.9446, 0.938, 1, 0.99793, 0.90838, 0.94938, 0.868, 0.9031, 0.92179, 0.9446, 1, 1, 0.89713, 1.10208, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90989, 0.9358, 0.91945, 0.83181, 0.75261, 0.87992, 0.82976, 0.96034, 0.83689, 0.97268, 1.0078, 0.90838, 0.83637, 0.8019, 0.90157, 0.80061, 0.9446, 0.95407, 0.92436, 1.0258, 0.85022, 0.97153, 1.0156, 0.95546, 0.89192, 0.92179, 0.92361, 0.87107, 0.96318, 0.89713, 0.93704, 0.95638, 0.91905, 0.91709, 0.92796, 1.0258, 0.93704, 0.94836, 1.0373, 0.95933, 1.0078, 0.95871, 0.94836, 0.96174, 0.92601, 0.9498, 0.98607, 0.95776, 0.95933, 1.05453, 1.0078, 0.98275, 0.9314, 0.95617, 0.91701, 1.05993, 0.9446, 0.78367, 0.9553, 1, 0.86832, 1.0128, 0.95871, 0.99394, 0.87548, 0.96361, 0.86774, 1.0078, 0.95871, 0.9446, 0.95871, 0.86774, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.94083, 0.97579, 0.94083, 0.97579, 0.94083, 0.97579, 0.90406, 0.94039, 0.96694, 1, 0.89903, 1, 1, 1, 0.93582, 0.93582, 0.93582, 1, 0.908, 0.908, 0.918, 0.94219, 0.94219, 0.96544, 1, 1.285, 1, 1, 0.81079, 0.81079, 1, 1, 0.74854, 1, 1, 1, 1, 0.99793, 1, 1, 1, 0.65, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.17173, 1, 0.80535, 0.76169, 1.02058, 1.0732, 1.05486, 1, 1, 1.30692, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.16161, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          o.MyriadProBoldFactors = C;
          const t = {
            lineHeight: 1.2,
            lineGap: 0.2
          };
          o.MyriadProBoldMetrics = t;
          const a = [1.36898, 1, 1, 0.66227, 0.80779, 0.81625, 0.97276, 0.97276, 0.97733, 0.92222, 0.83266, 0.94292, 0.94292, 1.16148, 1.02058, 0.93582, 0.96694, 0.93582, 1.17337, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.71541, 0.76813, 0.85576, 0.80591, 0.80729, 0.94299, 0.77512, 0.83655, 0.86523, 0.92222, 0.98621, 0.71743, 0.81698, 0.79726, 0.98558, 0.92222, 0.90637, 0.83809, 0.90637, 0.80729, 0.76463, 0.86275, 0.90699, 0.91605, 0.9154, 0.85308, 0.85458, 0.90531, 0.94292, 1.21296, 0.94292, 1.02058, 0.89903, 1.18616, 0.99613, 0.91677, 0.78216, 0.91677, 0.90083, 0.98796, 0.9135, 0.92168, 0.95381, 0.98981, 0.95298, 0.95381, 0.93459, 0.92168, 0.91513, 0.92004, 0.91677, 0.95077, 0.748, 1.04502, 0.91677, 0.92061, 0.94236, 0.89544, 0.89364, 0.9, 0.80687, 0.8578, 0.80687, 1.02058, 0.80779, 0.97276, 0.97276, 0.97276, 0.97276, 0.8578, 0.99973, 1.18616, 0.91339, 1.08074, 0.82891, 1.02058, 0.55509, 0.71526, 0.89022, 1.08595, 1, 1, 1.18616, 1, 0.96736, 0.93582, 1.18616, 1, 1.04864, 0.82711, 0.99043, 0.99043, 0.99043, 0.71541, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.845, 0.80729, 0.77512, 0.77512, 0.77512, 0.77512, 0.98621, 0.98621, 0.98621, 0.98621, 0.95961, 0.92222, 0.90637, 0.90637, 0.90637, 0.90637, 0.90637, 1.02058, 0.90251, 0.90699, 0.90699, 0.90699, 0.90699, 0.85458, 0.83659, 0.94951, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.85811, 0.78216, 0.90083, 0.90083, 0.90083, 0.90083, 0.95381, 0.95381, 0.95381, 0.95381, 0.9135, 0.92168, 0.91513, 0.91513, 0.91513, 0.91513, 0.91513, 1.08595, 0.91677, 0.91677, 0.91677, 0.91677, 0.91677, 0.89364, 0.92332, 0.89364, 0.85576, 0.99613, 0.85576, 0.99613, 0.85576, 0.99613, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.94299, 0.76783, 0.95961, 0.91677, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.86523, 0.9135, 0.86523, 0.9135, 0.86523, 0.9135, 1, 1, 0.92222, 0.92168, 0.92222, 0.92168, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.86036, 0.97096, 0.71743, 0.98981, 1, 1, 0.95298, 0.79726, 0.95381, 1, 1, 0.79726, 0.6894, 0.79726, 0.74321, 0.81691, 1.0006, 0.92222, 0.92168, 1, 1, 0.92222, 0.92168, 0.79464, 0.92098, 0.92168, 0.90637, 0.91513, 0.90637, 0.91513, 0.90637, 0.91513, 0.909, 0.87514, 0.80729, 0.95077, 1, 1, 0.80729, 0.95077, 0.76463, 0.748, 0.76463, 0.748, 1, 1, 0.76463, 0.748, 1, 1, 0.86275, 0.72651, 0.86275, 1.04502, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.9154, 0.94236, 0.85458, 0.89364, 0.85458, 0.90531, 0.9, 0.90531, 0.9, 0.90531, 0.9, 1, 0.97276, 0.85576, 0.99613, 0.845, 0.85811, 0.90251, 0.91677, 1, 1, 0.86275, 1.04502, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.00899, 1.30628, 0.85576, 0.80178, 0.66862, 0.7927, 0.69323, 0.88127, 0.72459, 0.89711, 0.95381, 0.85576, 0.80591, 0.7805, 0.94729, 0.77512, 0.90531, 0.92222, 0.90637, 0.98621, 0.81698, 0.92655, 0.98558, 0.92222, 0.85359, 0.90637, 0.90976, 0.83809, 0.94523, 0.86275, 0.83509, 0.93157, 0.85308, 0.83392, 0.92346, 0.98621, 0.83509, 0.92886, 0.91324, 0.92168, 0.95381, 0.90646, 0.92886, 0.90557, 0.86847, 0.90276, 0.91324, 0.86842, 0.92168, 0.99531, 0.95381, 0.9224, 0.85408, 0.92699, 0.86847, 1.0051, 0.91513, 0.80487, 0.93481, 1, 0.88159, 1.05214, 0.90646, 0.97355, 0.81539, 0.89398, 0.85923, 0.95381, 0.90646, 0.91513, 0.90646, 0.85923, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9154, 0.94236, 0.9154, 0.94236, 0.9154, 0.94236, 0.85458, 0.89364, 0.96694, 1, 0.89903, 1, 1, 1, 0.91782, 0.91782, 0.91782, 1, 0.896, 0.896, 0.896, 0.9332, 0.9332, 0.95973, 1, 1.26, 1, 1, 0.80479, 0.80178, 1, 1, 0.85633, 1, 1, 1, 1, 0.97276, 1, 1, 1, 0.698, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.14542, 1, 0.79199, 0.78694, 1.02058, 1.03493, 1.05486, 1, 1, 1.23026, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.20006, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          o.MyriadProBoldItalicFactors = a;
          const v = {
            lineHeight: 1.2,
            lineGap: 0.2
          };
          o.MyriadProBoldItalicMetrics = v;
          const h = [1.36898, 1, 1, 0.65507, 0.84943, 0.85639, 0.88465, 0.88465, 0.86936, 0.88307, 0.86948, 0.85283, 0.85283, 1.06383, 1.02058, 0.75945, 0.9219, 0.75945, 1.17337, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.75945, 0.75945, 1.02058, 1.02058, 1.02058, 0.69046, 0.70926, 0.85158, 0.77812, 0.76852, 0.89591, 0.70466, 0.76125, 0.80094, 0.86822, 0.83864, 0.728, 0.77212, 0.79475, 0.93637, 0.87514, 0.8588, 0.76013, 0.8588, 0.72421, 0.69866, 0.77598, 0.85991, 0.80811, 0.87832, 0.78112, 0.77512, 0.8562, 1.0222, 1.18417, 1.0222, 1.27014, 0.89903, 1.15012, 0.93859, 0.94399, 0.846, 0.94399, 0.81453, 1.0186, 0.94219, 0.96017, 1.03075, 1.02175, 0.912, 1.03075, 0.96998, 0.96017, 0.93859, 0.94399, 0.94399, 0.95493, 0.746, 1.12658, 0.94578, 0.91, 0.979, 0.882, 0.882, 0.83, 0.85034, 0.83537, 0.85034, 1.02058, 0.70869, 0.88465, 0.88465, 0.88465, 0.88465, 0.83537, 0.90083, 1.15012, 0.9161, 0.94565, 0.73541, 1.02058, 0.53609, 0.69353, 0.79519, 1.08595, 1, 1, 1.15012, 1, 0.91974, 0.75945, 1.15012, 1, 0.9446, 0.73361, 0.9005, 0.9005, 0.9005, 0.62864, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.773, 0.76852, 0.70466, 0.70466, 0.70466, 0.70466, 0.83864, 0.83864, 0.83864, 0.83864, 0.90561, 0.87514, 0.8588, 0.8588, 0.8588, 0.8588, 0.8588, 1.02058, 0.85751, 0.85991, 0.85991, 0.85991, 0.85991, 0.77512, 0.76013, 0.88075, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.8075, 0.846, 0.81453, 0.81453, 0.81453, 0.81453, 0.82424, 0.82424, 0.82424, 0.82424, 0.9278, 0.96017, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 1.08595, 0.8562, 0.94578, 0.94578, 0.94578, 0.94578, 0.882, 0.94578, 0.882, 0.85158, 0.93859, 0.85158, 0.93859, 0.85158, 0.93859, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.89591, 0.8544, 0.90561, 0.94399, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.80094, 0.94219, 0.80094, 0.94219, 0.80094, 0.94219, 1, 1, 0.86822, 0.96017, 0.86822, 0.96017, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 1.03075, 0.83864, 0.82424, 0.81402, 1.02738, 0.728, 1.02175, 1, 1, 0.912, 0.79475, 1.03075, 1, 1, 0.79475, 0.83911, 0.79475, 0.66266, 0.80553, 1.06676, 0.87514, 0.96017, 1, 1, 0.87514, 0.96017, 0.86865, 0.87396, 0.96017, 0.8588, 0.93859, 0.8588, 0.93859, 0.8588, 0.93859, 0.867, 0.84759, 0.72421, 0.95493, 1, 1, 0.72421, 0.95493, 0.69866, 0.746, 0.69866, 0.746, 1, 1, 0.69866, 0.746, 1, 1, 0.77598, 0.88417, 0.77598, 1.12658, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.87832, 0.979, 0.77512, 0.882, 0.77512, 0.8562, 0.83, 0.8562, 0.83, 0.8562, 0.83, 1, 0.88465, 0.85158, 0.93859, 0.773, 0.8075, 0.85751, 0.8562, 1, 1, 0.77598, 1.12658, 1.15012, 1.15012, 1.15012, 1.15012, 1.15012, 1.15313, 1.15012, 1.15012, 1.15012, 1.08106, 1.03901, 0.85158, 0.77025, 0.62264, 0.7646, 0.65351, 0.86026, 0.69461, 0.89947, 1.03075, 0.85158, 0.77812, 0.76449, 0.88836, 0.70466, 0.8562, 0.86822, 0.8588, 0.83864, 0.77212, 0.85308, 0.93637, 0.87514, 0.82352, 0.8588, 0.85701, 0.76013, 0.89058, 0.77598, 0.8156, 0.82565, 0.78112, 0.77899, 0.89386, 0.83864, 0.8156, 0.9486, 0.92388, 0.96186, 1.03075, 0.91123, 0.9486, 0.93298, 0.878, 0.93942, 0.92388, 0.84596, 0.96186, 0.95119, 1.03075, 0.922, 0.88787, 0.95829, 0.88, 0.93559, 0.93859, 0.78815, 0.93758, 1, 0.89217, 1.03737, 0.91123, 0.93969, 0.77487, 0.85769, 0.86799, 1.03075, 0.91123, 0.93859, 0.91123, 0.86799, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87832, 0.979, 0.87832, 0.979, 0.87832, 0.979, 0.77512, 0.882, 0.9219, 1, 0.89903, 1, 1, 1, 0.87321, 0.87321, 0.87321, 1, 1.027, 1.027, 1.027, 0.86847, 0.86847, 0.79121, 1, 1.124, 1, 1, 0.73572, 0.73572, 1, 1, 0.85034, 1, 1, 1, 1, 0.88465, 1, 1, 1, 0.669, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04828, 1, 0.74948, 0.75187, 1.02058, 0.98391, 1.02119, 1, 1, 1.06233, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05233, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          o.MyriadProItalicFactors = h;
          const e = {
            lineHeight: 1.2,
            lineGap: 0.2
          };
          o.MyriadProItalicMetrics = e;
          const y = [1.36898, 1, 1, 0.76305, 0.82784, 0.94935, 0.89364, 0.92241, 0.89073, 0.90706, 0.98472, 0.85283, 0.85283, 1.0664, 1.02058, 0.74505, 0.9219, 0.74505, 1.23456, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.74505, 0.74505, 1.02058, 1.02058, 1.02058, 0.73002, 0.72601, 0.91755, 0.8126, 0.80314, 0.92222, 0.73764, 0.79726, 0.83051, 0.90284, 0.86023, 0.74, 0.8126, 0.84869, 0.96518, 0.91115, 0.8858, 0.79761, 0.8858, 0.74498, 0.73914, 0.81363, 0.89591, 0.83659, 0.89633, 0.85608, 0.8111, 0.90531, 1.0222, 1.22736, 1.0222, 1.27014, 0.89903, 0.90088, 0.86667, 1.0231, 0.896, 1.01411, 0.90083, 1.05099, 1.00512, 0.99793, 1.05326, 1.09377, 0.938, 1.06226, 1.00119, 0.99793, 0.98714, 1.0231, 1.01231, 0.98196, 0.792, 1.19137, 0.99074, 0.962, 1.01915, 0.926, 0.942, 0.856, 0.85034, 0.92006, 0.85034, 1.02058, 0.69067, 0.92241, 0.92241, 0.92241, 0.92241, 0.92006, 0.9332, 0.90088, 0.91882, 0.93484, 0.75339, 1.02058, 0.56866, 0.54324, 0.79519, 1.08595, 1, 1, 0.90088, 1, 0.95325, 0.74505, 0.90088, 1, 0.97198, 0.75339, 0.91009, 0.91009, 0.91009, 0.66466, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.788, 0.80314, 0.73764, 0.73764, 0.73764, 0.73764, 0.86023, 0.86023, 0.86023, 0.86023, 0.92915, 0.91115, 0.8858, 0.8858, 0.8858, 0.8858, 0.8858, 1.02058, 0.8858, 0.89591, 0.89591, 0.89591, 0.89591, 0.8111, 0.79611, 0.89713, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86936, 0.896, 0.90083, 0.90083, 0.90083, 0.90083, 0.84224, 0.84224, 0.84224, 0.84224, 0.97276, 0.99793, 0.98714, 0.98714, 0.98714, 0.98714, 0.98714, 1.08595, 0.89876, 0.99074, 0.99074, 0.99074, 0.99074, 0.942, 1.0231, 0.942, 0.91755, 0.86667, 0.91755, 0.86667, 0.91755, 0.86667, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.92222, 0.93372, 0.92915, 1.01411, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.83051, 1.00512, 0.83051, 1.00512, 0.83051, 1.00512, 1, 1, 0.90284, 0.99793, 0.90976, 0.99793, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 1.05326, 0.86023, 0.84224, 0.82873, 1.07469, 0.74, 1.09377, 1, 1, 0.938, 0.84869, 1.06226, 1, 1, 0.84869, 0.83704, 0.84869, 0.81441, 0.85588, 1.08927, 0.91115, 0.99793, 1, 1, 0.91115, 0.99793, 0.91887, 0.90991, 0.99793, 0.8858, 0.98714, 0.8858, 0.98714, 0.8858, 0.98714, 0.894, 0.91434, 0.74498, 0.98196, 1, 1, 0.74498, 0.98196, 0.73914, 0.792, 0.73914, 0.792, 1, 1, 0.73914, 0.792, 1, 1, 0.81363, 0.904, 0.81363, 1.19137, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89633, 1.01915, 0.8111, 0.942, 0.8111, 0.90531, 0.856, 0.90531, 0.856, 0.90531, 0.856, 1, 0.92241, 0.91755, 0.86667, 0.788, 0.86936, 0.8858, 0.89876, 1, 1, 0.81363, 1.19137, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90388, 1.03901, 0.92138, 0.78105, 0.7154, 0.86169, 0.80513, 0.94007, 0.82528, 0.98612, 1.06226, 0.91755, 0.8126, 0.81884, 0.92819, 0.73764, 0.90531, 0.90284, 0.8858, 0.86023, 0.8126, 0.91172, 0.96518, 0.91115, 0.83089, 0.8858, 0.87791, 0.79761, 0.89297, 0.81363, 0.88157, 0.89992, 0.85608, 0.81992, 0.94307, 0.86023, 0.88157, 0.95308, 0.98699, 0.99793, 1.06226, 0.95817, 0.95308, 0.97358, 0.928, 0.98088, 0.98699, 0.92761, 0.99793, 0.96017, 1.06226, 0.986, 0.944, 0.95978, 0.938, 0.96705, 0.98714, 0.80442, 0.98972, 1, 0.89762, 1.04552, 0.95817, 0.99007, 0.87064, 0.91879, 0.88888, 1.06226, 0.95817, 0.98714, 0.95817, 0.88888, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89633, 1.01915, 0.89633, 1.01915, 0.89633, 1.01915, 0.8111, 0.942, 0.9219, 1, 0.89903, 1, 1, 1, 0.93173, 0.93173, 0.93173, 1, 1.06304, 1.06304, 1.06904, 0.89903, 0.89903, 0.80549, 1, 1.156, 1, 1, 0.76575, 0.76575, 1, 1, 0.72458, 1, 1, 1, 1, 0.92241, 1, 1, 1, 0.619, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.07257, 1, 0.74705, 0.71119, 1.02058, 1.024, 1.02119, 1, 1, 1.1536, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05638, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          o.MyriadProRegularFactors = y;
          const c = {
            lineHeight: 1.2,
            lineGap: 0.2
          };
          o.MyriadProRegularMetrics = c;
        },
        /* 56 */
        /***/
        (Z, o) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.SegoeuiRegularMetrics = o.SegoeuiRegularFactors = o.SegoeuiItalicMetrics = o.SegoeuiItalicFactors = o.SegoeuiBoldMetrics = o.SegoeuiBoldItalicMetrics = o.SegoeuiBoldItalicFactors = o.SegoeuiBoldFactors = void 0;
          const C = [1.76738, 1, 1, 0.99297, 0.9824, 1.04016, 1.06497, 1.03424, 0.97529, 1.17647, 1.23203, 1.1085, 1.1085, 1.16939, 1.2107, 0.9754, 1.21408, 0.9754, 1.59578, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 0.81378, 0.81378, 1.2107, 1.2107, 1.2107, 0.71703, 0.97847, 0.97363, 0.88776, 0.8641, 1.02096, 0.79795, 0.85132, 0.914, 1.06085, 1.1406, 0.8007, 0.89858, 0.83693, 1.14889, 1.09398, 0.97489, 0.92094, 0.97489, 0.90399, 0.84041, 0.95923, 1.00135, 1, 1.06467, 0.98243, 0.90996, 0.99361, 1.1085, 1.56942, 1.1085, 1.2107, 0.74627, 0.94282, 0.96752, 1.01519, 0.86304, 1.01359, 0.97278, 1.15103, 1.01359, 0.98561, 1.02285, 1.02285, 1.00527, 1.02285, 1.0302, 0.99041, 1.0008, 1.01519, 1.01359, 1.02258, 0.79104, 1.16862, 0.99041, 0.97454, 1.02511, 0.99298, 0.96752, 0.95801, 0.94856, 1.16579, 0.94856, 1.2107, 0.9824, 1.03424, 1.03424, 1, 1.03424, 1.16579, 0.8727, 1.3871, 1.18622, 1.10818, 1.04478, 1.2107, 1.18622, 0.75155, 0.94994, 1.28826, 1.21408, 1.21408, 0.91056, 1, 0.91572, 0.9754, 0.64663, 1.18328, 1.24866, 1.04478, 1.14169, 1.15749, 1.17389, 0.71703, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.93506, 0.8641, 0.79795, 0.79795, 0.79795, 0.79795, 1.1406, 1.1406, 1.1406, 1.1406, 1.02096, 1.09398, 0.97426, 0.97426, 0.97426, 0.97426, 0.97426, 1.2107, 0.97489, 1.00135, 1.00135, 1.00135, 1.00135, 0.90996, 0.92094, 1.02798, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.93136, 0.86304, 0.97278, 0.97278, 0.97278, 0.97278, 1.02285, 1.02285, 1.02285, 1.02285, 0.97122, 0.99041, 1, 1, 1, 1, 1, 1.28826, 1.0008, 0.99041, 0.99041, 0.99041, 0.99041, 0.96752, 1.01519, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 1.02096, 1.03057, 1.02096, 1.03517, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.914, 1.01359, 0.914, 1.01359, 0.914, 1.01359, 1, 1, 1.06085, 0.98561, 1.06085, 1.00879, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 0.97138, 1.08692, 0.8007, 1.02285, 1, 1, 1.00527, 0.83693, 1.02285, 1, 1, 0.83693, 0.9455, 0.83693, 0.90418, 0.83693, 1.13005, 1.09398, 0.99041, 1, 1, 1.09398, 0.99041, 0.96692, 1.09251, 0.99041, 0.97489, 1.0008, 0.97489, 1.0008, 0.97489, 1.0008, 0.93994, 0.97931, 0.90399, 1.02258, 1, 1, 0.90399, 1.02258, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 1, 1, 0.95923, 1.07034, 0.95923, 1.16862, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.06467, 1.02511, 0.90996, 0.96752, 0.90996, 0.99361, 0.95801, 0.99361, 0.95801, 0.99361, 0.95801, 1.07733, 1.03424, 0.97363, 0.96752, 0.93506, 0.93136, 0.97489, 1.0008, 1, 1, 0.95923, 1.16862, 1.15103, 1.15103, 1.01173, 1.03959, 0.75953, 0.81378, 0.79912, 1.15103, 1.21994, 0.95161, 0.87815, 1.01149, 0.81525, 0.7676, 0.98167, 1.01134, 1.02546, 0.84097, 1.03089, 1.18102, 0.97363, 0.88776, 0.85134, 0.97826, 0.79795, 0.99361, 1.06085, 0.97489, 1.1406, 0.89858, 1.0388, 1.14889, 1.09398, 0.86039, 0.97489, 1.0595, 0.92094, 0.94793, 0.95923, 0.90996, 0.99346, 0.98243, 1.02112, 0.95493, 1.1406, 0.90996, 1.03574, 1.02597, 1.0008, 1.18102, 1.06628, 1.03574, 1.0192, 1.01932, 1.00886, 0.97531, 1.0106, 1.0008, 1.13189, 1.18102, 1.02277, 0.98683, 1.0016, 0.99561, 1.07237, 1.0008, 0.90434, 0.99921, 0.93803, 0.8965, 1.23085, 1.06628, 1.04983, 0.96268, 1.0499, 0.98439, 1.18102, 1.06628, 1.0008, 1.06628, 0.98439, 0.79795, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09466, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.97278, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.02065, 1, 1, 1, 1, 1, 1, 1.06467, 1.02511, 1.06467, 1.02511, 1.06467, 1.02511, 0.90996, 0.96752, 1, 1.21408, 0.89903, 1, 1, 0.75155, 1.04394, 1.04394, 1.04394, 1.04394, 0.98633, 0.98633, 0.98633, 0.73047, 0.73047, 1.20642, 0.91211, 1.25635, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.12454, 0.93503, 1.03424, 1.19687, 1.03424, 1, 1, 1, 0.771, 1, 1, 1.15749, 1.15749, 1.15749, 1.10948, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.16897, 1, 0.96085, 0.90137, 1.2107, 1.18416, 1.13973, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21172, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18874, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.09193, 1.09193, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          o.SegoeuiBoldFactors = C;
          const t = {
            lineHeight: 1.33008,
            lineGap: 0
          };
          o.SegoeuiBoldMetrics = t;
          const a = [1.76738, 1, 1, 0.98946, 1.03959, 1.04016, 1.02809, 1.036, 0.97639, 1.10953, 1.23203, 1.11144, 1.11144, 1.16939, 1.21237, 0.9754, 1.21261, 0.9754, 1.59754, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 0.81378, 0.81378, 1.21237, 1.21237, 1.21237, 0.73541, 0.97847, 0.97363, 0.89723, 0.87897, 1.0426, 0.79429, 0.85292, 0.91149, 1.05815, 1.1406, 0.79631, 0.90128, 0.83853, 1.04396, 1.10615, 0.97552, 0.94436, 0.97552, 0.88641, 0.80527, 0.96083, 1.00135, 1, 1.06777, 0.9817, 0.91142, 0.99361, 1.11144, 1.57293, 1.11144, 1.21237, 0.74627, 1.31818, 1.06585, 0.97042, 0.83055, 0.97042, 0.93503, 1.1261, 0.97042, 0.97922, 1.14236, 0.94552, 1.01054, 1.14236, 1.02471, 0.97922, 0.94165, 0.97042, 0.97042, 1.0276, 0.78929, 1.1261, 0.97922, 0.95874, 1.02197, 0.98507, 0.96752, 0.97168, 0.95107, 1.16579, 0.95107, 1.21237, 1.03959, 1.036, 1.036, 1, 1.036, 1.16579, 0.87357, 1.31818, 1.18754, 1.26781, 1.05356, 1.21237, 1.18622, 0.79487, 0.94994, 1.29004, 1.24047, 1.24047, 1.31818, 1, 0.91484, 0.9754, 1.31818, 1.1349, 1.24866, 1.05356, 1.13934, 1.15574, 1.17389, 0.73541, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.94385, 0.87897, 0.79429, 0.79429, 0.79429, 0.79429, 1.1406, 1.1406, 1.1406, 1.1406, 1.0426, 1.10615, 0.97552, 0.97552, 0.97552, 0.97552, 0.97552, 1.21237, 0.97552, 1.00135, 1.00135, 1.00135, 1.00135, 0.91142, 0.94436, 0.98721, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 0.96705, 0.83055, 0.93503, 0.93503, 0.93503, 0.93503, 1.14236, 1.14236, 1.14236, 1.14236, 0.93125, 0.97922, 0.94165, 0.94165, 0.94165, 0.94165, 0.94165, 1.29004, 0.94165, 0.97922, 0.97922, 0.97922, 0.97922, 0.96752, 0.97042, 0.96752, 0.97363, 1.06585, 0.97363, 1.06585, 0.97363, 1.06585, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 1.0426, 1.0033, 1.0426, 0.97042, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.91149, 0.97042, 0.91149, 0.97042, 0.91149, 0.97042, 1, 1, 1.05815, 0.97922, 1.05815, 0.97922, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 0.97441, 1.04302, 0.79631, 1.01582, 1, 1, 1.01054, 0.83853, 1.14236, 1, 1, 0.83853, 1.09125, 0.83853, 0.90418, 0.83853, 1.19508, 1.10615, 0.97922, 1, 1, 1.10615, 0.97922, 1.01034, 1.10466, 0.97922, 0.97552, 0.94165, 0.97552, 0.94165, 0.97552, 0.94165, 0.91602, 0.91981, 0.88641, 1.0276, 1, 1, 0.88641, 1.0276, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 1, 1, 0.96083, 1.05403, 0.95923, 1.16862, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.06777, 1.02197, 0.91142, 0.96752, 0.91142, 0.99361, 0.97168, 0.99361, 0.97168, 0.99361, 0.97168, 1.23199, 1.036, 0.97363, 1.06585, 0.94385, 0.96705, 0.97552, 0.94165, 1, 1, 0.96083, 1.1261, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 0.95161, 1.27126, 1.00811, 0.83284, 0.77702, 0.99137, 0.95253, 1.0347, 0.86142, 1.07205, 1.14236, 0.97363, 0.89723, 0.86869, 1.09818, 0.79429, 0.99361, 1.05815, 0.97552, 1.1406, 0.90128, 1.06662, 1.04396, 1.10615, 0.84918, 0.97552, 1.04694, 0.94436, 0.98015, 0.96083, 0.91142, 1.00356, 0.9817, 1.01945, 0.98999, 1.1406, 0.91142, 1.04961, 0.9898, 1.00639, 1.14236, 1.07514, 1.04961, 0.99607, 1.02897, 1.008, 0.9898, 0.95134, 1.00639, 1.11121, 1.14236, 1.00518, 0.97981, 1.02186, 1, 1.08578, 0.94165, 0.99314, 0.98387, 0.93028, 0.93377, 1.35125, 1.07514, 1.10687, 0.93491, 1.04232, 1.00351, 1.14236, 1.07514, 0.94165, 1.07514, 1.00351, 0.79429, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09097, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.93503, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96609, 1, 1, 1, 1, 1, 1, 1.06777, 1.02197, 1.06777, 1.02197, 1.06777, 1.02197, 0.91142, 0.96752, 1, 1.21261, 0.89903, 1, 1, 0.75155, 1.04745, 1.04745, 1.04745, 1.04394, 0.98633, 0.98633, 0.98633, 0.72959, 0.72959, 1.20502, 0.91406, 1.26514, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.09125, 0.93327, 1.03336, 1.16541, 1.036, 1, 1, 1, 0.771, 1, 1, 1.15574, 1.15574, 1.15574, 1.15574, 0.86364, 0.94434, 0.86279, 0.94434, 0.86224, 1, 1, 1.16798, 1, 0.96085, 0.90068, 1.21237, 1.18416, 1.13904, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21339, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18775, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.13269, 1.13269, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          o.SegoeuiBoldItalicFactors = a;
          const v = {
            lineHeight: 1.33008,
            lineGap: 0
          };
          o.SegoeuiBoldItalicMetrics = v;
          const h = [1.76738, 1, 1, 0.98946, 1.14763, 1.05365, 1.06234, 0.96927, 0.92586, 1.15373, 1.18414, 0.91349, 0.91349, 1.07403, 1.17308, 0.78383, 1.20088, 0.78383, 1.42531, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78383, 0.78383, 1.17308, 1.17308, 1.17308, 0.77349, 0.94565, 0.94729, 0.85944, 0.88506, 0.9858, 0.74817, 0.80016, 0.88449, 0.98039, 0.95782, 0.69238, 0.89898, 0.83231, 0.98183, 1.03989, 0.96924, 0.86237, 0.96924, 0.80595, 0.74524, 0.86091, 0.95402, 0.94143, 0.98448, 0.8858, 0.83089, 0.93285, 1.0949, 1.39016, 1.0949, 1.45994, 0.74627, 1.04839, 0.97454, 0.97454, 0.87207, 0.97454, 0.87533, 1.06151, 0.97454, 1.00176, 1.16484, 1.08132, 0.98047, 1.16484, 1.02989, 1.01054, 0.96225, 0.97454, 0.97454, 1.06598, 0.79004, 1.16344, 1.00351, 0.94629, 0.9973, 0.91016, 0.96777, 0.9043, 0.91082, 0.92481, 0.91082, 1.17308, 0.95748, 0.96927, 0.96927, 1, 0.96927, 0.92481, 0.80597, 1.04839, 1.23393, 1.1781, 0.9245, 1.17308, 1.20808, 0.63218, 0.94261, 1.24822, 1.09971, 1.09971, 1.04839, 1, 0.85273, 0.78032, 1.04839, 1.09971, 1.22326, 0.9245, 1.09836, 1.13525, 1.15222, 0.70424, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.85498, 0.88506, 0.74817, 0.74817, 0.74817, 0.74817, 0.95782, 0.95782, 0.95782, 0.95782, 0.9858, 1.03989, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.17308, 0.96924, 0.95402, 0.95402, 0.95402, 0.95402, 0.83089, 0.86237, 0.88409, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.92916, 0.87207, 0.87533, 0.87533, 0.87533, 0.87533, 0.93146, 0.93146, 0.93146, 0.93146, 0.93854, 1.01054, 0.96225, 0.96225, 0.96225, 0.96225, 0.96225, 1.24822, 0.8761, 1.00351, 1.00351, 1.00351, 1.00351, 0.96777, 0.97454, 0.96777, 0.94729, 0.97454, 0.94729, 0.97454, 0.94729, 0.97454, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.9858, 0.95391, 0.9858, 0.97454, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.88449, 0.97454, 0.88449, 0.97454, 0.88449, 0.97454, 1, 1, 0.98039, 1.00176, 0.98039, 1.00176, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 1.16484, 0.95782, 0.93146, 0.84421, 1.12761, 0.69238, 1.08132, 1, 1, 0.98047, 0.83231, 1.16484, 1, 1, 0.84723, 1.04861, 0.84723, 0.78755, 0.83231, 1.23736, 1.03989, 1.01054, 1, 1, 1.03989, 1.01054, 0.9857, 1.03849, 1.01054, 0.96924, 0.96225, 0.96924, 0.96225, 0.96924, 0.96225, 0.92383, 0.90171, 0.80595, 1.06598, 1, 1, 0.80595, 1.06598, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 1, 1, 0.86091, 1.02759, 0.85771, 1.16344, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.98448, 0.9973, 0.83089, 0.96777, 0.83089, 0.93285, 0.9043, 0.93285, 0.9043, 0.93285, 0.9043, 1.31868, 0.96927, 0.94729, 0.97454, 0.85498, 0.92916, 0.96924, 0.8761, 1, 1, 0.86091, 1.16344, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 0.81965, 0.81965, 0.94729, 0.78032, 0.71022, 0.90883, 0.84171, 0.99877, 0.77596, 1.05734, 1.2, 0.94729, 0.85944, 0.82791, 0.9607, 0.74817, 0.93285, 0.98039, 0.96924, 0.95782, 0.89898, 0.98316, 0.98183, 1.03989, 0.78614, 0.96924, 0.97642, 0.86237, 0.86075, 0.86091, 0.83089, 0.90082, 0.8858, 0.97296, 1.01284, 0.95782, 0.83089, 1.0976, 1.04, 1.03342, 1.2, 1.0675, 1.0976, 0.98205, 1.03809, 1.05097, 1.04, 0.95364, 1.03342, 1.05401, 1.2, 1.02148, 1.0119, 1.04724, 1.0127, 1.02732, 0.96225, 0.8965, 0.97783, 0.93574, 0.94818, 1.30679, 1.0675, 1.11826, 0.99821, 1.0557, 1.0326, 1.2, 1.0675, 0.96225, 1.0675, 1.0326, 0.74817, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03754, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87533, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.98705, 1, 1, 1, 1, 1, 1, 0.98448, 0.9973, 0.98448, 0.9973, 0.98448, 0.9973, 0.83089, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 0.94945, 0.94945, 0.94945, 0.94945, 1.12317, 1.12317, 1.12317, 0.67603, 0.67603, 1.15621, 0.73584, 1.21191, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87709, 0.96927, 1.01473, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.09836, 1.09836, 1.09836, 1.01522, 0.86321, 0.94434, 0.8649, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86438, 1.17308, 1.18416, 1.14589, 0.69825, 0.97622, 1.96791, 1.24822, 1.24822, 1.17308, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.17984, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10742, 1.10742, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          o.SegoeuiItalicFactors = h;
          const e = {
            lineHeight: 1.33008,
            lineGap: 0
          };
          o.SegoeuiItalicMetrics = e;
          const y = [1.76738, 1, 1, 0.98594, 1.02285, 1.10454, 1.06234, 0.96927, 0.92037, 1.19985, 1.2046, 0.90616, 0.90616, 1.07152, 1.1714, 0.78032, 1.20088, 0.78032, 1.40246, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78032, 0.78032, 1.1714, 1.1714, 1.1714, 0.80597, 0.94084, 0.96706, 0.85944, 0.85734, 0.97093, 0.75842, 0.79936, 0.88198, 0.9831, 0.95782, 0.71387, 0.86969, 0.84636, 1.07796, 1.03584, 0.96924, 0.83968, 0.96924, 0.82826, 0.79649, 0.85771, 0.95132, 0.93119, 0.98965, 0.88433, 0.8287, 0.93365, 1.08612, 1.3638, 1.08612, 1.45786, 0.74627, 0.80499, 0.91484, 1.05707, 0.92383, 1.05882, 0.9403, 1.12654, 1.05882, 1.01756, 1.09011, 1.09011, 0.99414, 1.09011, 1.034, 1.01756, 1.05356, 1.05707, 1.05882, 1.04399, 0.84863, 1.21968, 1.01756, 0.95801, 1.00068, 0.91797, 0.96777, 0.9043, 0.90351, 0.92105, 0.90351, 1.1714, 0.85337, 0.96927, 0.96927, 0.99912, 0.96927, 0.92105, 0.80597, 1.2434, 1.20808, 1.05937, 0.90957, 1.1714, 1.20808, 0.75155, 0.94261, 1.24644, 1.09971, 1.09971, 0.84751, 1, 0.85273, 0.78032, 0.61584, 1.05425, 1.17914, 0.90957, 1.08665, 1.11593, 1.14169, 0.73381, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.86035, 0.85734, 0.75842, 0.75842, 0.75842, 0.75842, 0.95782, 0.95782, 0.95782, 0.95782, 0.97093, 1.03584, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.1714, 0.96924, 0.95132, 0.95132, 0.95132, 0.95132, 0.8287, 0.83968, 0.89049, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.93575, 0.92383, 0.9403, 0.9403, 0.9403, 0.9403, 0.8717, 0.8717, 0.8717, 0.8717, 1.00527, 1.01756, 1.05356, 1.05356, 1.05356, 1.05356, 1.05356, 1.24644, 0.95923, 1.01756, 1.01756, 1.01756, 1.01756, 0.96777, 1.05707, 0.96777, 0.96706, 0.91484, 0.96706, 0.91484, 0.96706, 0.91484, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.97093, 1.0969, 0.97093, 1.05882, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.88198, 1.05882, 0.88198, 1.05882, 0.88198, 1.05882, 1, 1, 0.9831, 1.01756, 0.9831, 1.01756, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 1.09011, 0.95782, 0.8717, 0.84784, 1.11551, 0.71387, 1.09011, 1, 1, 0.99414, 0.84636, 1.09011, 1, 1, 0.84636, 1.0536, 0.84636, 0.94298, 0.84636, 1.23297, 1.03584, 1.01756, 1, 1, 1.03584, 1.01756, 1.00323, 1.03444, 1.01756, 0.96924, 1.05356, 0.96924, 1.05356, 0.96924, 1.05356, 0.93066, 0.98293, 0.82826, 1.04399, 1, 1, 0.82826, 1.04399, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 1, 1, 0.85771, 1.17318, 0.85771, 1.21968, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.98965, 1.00068, 0.8287, 0.96777, 0.8287, 0.93365, 0.9043, 0.93365, 0.9043, 0.93365, 0.9043, 1.08571, 0.96927, 0.96706, 0.91484, 0.86035, 0.93575, 0.96924, 0.95923, 1, 1, 0.85771, 1.21968, 1.11437, 1.11437, 0.93109, 0.91202, 0.60411, 0.84164, 0.55572, 1.01173, 0.97361, 0.81818, 0.81818, 0.96635, 0.78032, 0.72727, 0.92366, 0.98601, 1.03405, 0.77968, 1.09799, 1.2, 0.96706, 0.85944, 0.85638, 0.96491, 0.75842, 0.93365, 0.9831, 0.96924, 0.95782, 0.86969, 0.94152, 1.07796, 1.03584, 0.78437, 0.96924, 0.98715, 0.83968, 0.83491, 0.85771, 0.8287, 0.94492, 0.88433, 0.9287, 1.0098, 0.95782, 0.8287, 1.0625, 0.98248, 1.03424, 1.2, 1.01071, 1.0625, 0.95246, 1.03809, 1.04912, 0.98248, 1.00221, 1.03424, 1.05443, 1.2, 1.04785, 0.99609, 1.00169, 1.05176, 0.99346, 1.05356, 0.9087, 1.03004, 0.95542, 0.93117, 1.23362, 1.01071, 1.07831, 1.02512, 1.05205, 1.03502, 1.2, 1.01071, 1.05356, 1.01071, 1.03502, 0.75842, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03719, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9403, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04021, 1, 1, 1, 1, 1, 1, 0.98965, 1.00068, 0.98965, 1.00068, 0.98965, 1.00068, 0.8287, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 1.03077, 1.03077, 1.03077, 1.03077, 1.13196, 1.13196, 1.13196, 0.67428, 0.67428, 1.16039, 0.73291, 1.20996, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87796, 0.96927, 1.01518, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.10539, 1.10539, 1.11358, 1.06967, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86507, 1.1714, 1.18416, 1.14589, 0.69825, 0.97622, 1.9697, 1.24822, 1.24822, 1.17238, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18083, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10938, 1.10938, 1, 1, 1, 1.05425, 1.09971, 1.09971, 1.09971, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          o.SegoeuiRegularFactors = y;
          const c = {
            lineHeight: 1.33008,
            lineGap: 0
          };
          o.SegoeuiRegularMetrics = c;
        },
        /* 57 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.PostScriptEvaluator = o.PostScriptCompiler = o.PDFFunctionFactory = void 0, o.isPDFFunction = p;
          var t = C(5), a = C(2), v = C(58), h = C(7), e = C(59);
          class y {
            constructor({
              xref: x,
              isEvalSupported: f = !0
            }) {
              this.xref = x, this.isEvalSupported = f !== !1;
            }
            create(x) {
              const f = this.getCached(x);
              if (f)
                return f;
              const U = d.parse({
                xref: this.xref,
                isEvalSupported: this.isEvalSupported,
                fn: x instanceof t.Ref ? this.xref.fetch(x) : x
              });
              return this._cache(x, U), U;
            }
            createFromArray(x) {
              const f = this.getCached(x);
              if (f)
                return f;
              const U = d.parseArray({
                xref: this.xref,
                isEvalSupported: this.isEvalSupported,
                fnObj: x instanceof t.Ref ? this.xref.fetch(x) : x
              });
              return this._cache(x, U), U;
            }
            getCached(x) {
              let f;
              if (x instanceof t.Ref ? f = x : x instanceof t.Dict ? f = x.objId : x instanceof h.BaseStream && (f = x.dict && x.dict.objId), f) {
                const U = this._localFunctionCache.getByRef(f);
                if (U)
                  return U;
              }
              return null;
            }
            _cache(x, f) {
              if (!f)
                throw new Error('PDFFunctionFactory._cache - expected "parsedFunction" argument.');
              let U;
              x instanceof t.Ref ? U = x : x instanceof t.Dict ? U = x.objId : x instanceof h.BaseStream && (U = x.dict && x.dict.objId), U && this._localFunctionCache.set(null, U, f);
            }
            get _localFunctionCache() {
              return (0, a.shadow)(this, "_localFunctionCache", new e.LocalFunctionCache());
            }
          }
          o.PDFFunctionFactory = y;
          function c(k) {
            if (!Array.isArray(k))
              return null;
            const x = k.length;
            for (let f = 0; f < x; f++)
              if (typeof k[f] != "number") {
                const U = new Array(x);
                for (let O = 0; O < x; O++)
                  U[O] = +k[O];
                return U;
              }
            return k;
          }
          class d {
            static getSampleArray(x, f, U, O) {
              let S, F, T = 1;
              for (S = 0, F = x.length; S < F; S++)
                T *= x[S];
              T *= f;
              const I = new Array(T);
              let M = 0, V = 0;
              const J = 1 / (2 ** U - 1), W = O.getBytes((T * U + 7) / 8);
              let z = 0;
              for (S = 0; S < T; S++) {
                for (; M < U; )
                  V <<= 8, V |= W[z++], M += 8;
                M -= U, I[S] = (V >> M) * J, V &= (1 << M) - 1;
              }
              return I;
            }
            static parse({
              xref: x,
              isEvalSupported: f,
              fn: U
            }) {
              const O = U.dict || U;
              switch (O.get("FunctionType")) {
                case 0:
                  return this.constructSampled({
                    xref: x,
                    isEvalSupported: f,
                    fn: U,
                    dict: O
                  });
                case 1:
                  break;
                case 2:
                  return this.constructInterpolated({
                    xref: x,
                    isEvalSupported: f,
                    dict: O
                  });
                case 3:
                  return this.constructStiched({
                    xref: x,
                    isEvalSupported: f,
                    dict: O
                  });
                case 4:
                  return this.constructPostScript({
                    xref: x,
                    isEvalSupported: f,
                    fn: U,
                    dict: O
                  });
              }
              throw new a.FormatError("Unknown type of function");
            }
            static parseArray({
              xref: x,
              isEvalSupported: f,
              fnObj: U
            }) {
              if (!Array.isArray(U))
                return this.parse({
                  xref: x,
                  isEvalSupported: f,
                  fn: U
                });
              const O = [];
              for (let S = 0, F = U.length; S < F; S++)
                O.push(this.parse({
                  xref: x,
                  isEvalSupported: f,
                  fn: x.fetchIfRef(U[S])
                }));
              return function(S, F, T, I) {
                for (let M = 0, V = O.length; M < V; M++)
                  O[M](S, F, T, I + M);
              };
            }
            static constructSampled({
              xref: x,
              isEvalSupported: f,
              fn: U,
              dict: O
            }) {
              function S(te) {
                const se = te.length, q = [];
                let N = 0;
                for (let Q = 0; Q < se; Q += 2)
                  q[N++] = [te[Q], te[Q + 1]];
                return q;
              }
              function F(te, se, q, N, Q) {
                return N + (te - se) * ((Q - N) / (q - se));
              }
              let T = c(O.getArray("Domain")), I = c(O.getArray("Range"));
              if (!T || !I)
                throw new a.FormatError("No domain or range");
              const M = T.length / 2, V = I.length / 2;
              T = S(T), I = S(I);
              const J = c(O.getArray("Size")), W = O.get("BitsPerSample"), z = O.get("Order") || 1;
              z !== 1 && (0, a.info)("No support for cubic spline interpolation: " + z);
              let G = c(O.getArray("Encode"));
              if (G)
                G = S(G);
              else {
                G = [];
                for (let te = 0; te < M; ++te)
                  G.push([0, J[te] - 1]);
              }
              let L = c(O.getArray("Decode"));
              L ? L = S(L) : L = I;
              const K = this.getSampleArray(J, V, W, U);
              return function(se, q, N, Q) {
                const D = 1 << M, ne = new Float64Array(D), oe = new Uint32Array(D);
                let ee, $;
                for ($ = 0; $ < D; $++)
                  ne[$] = 1;
                let E = V, H = 1;
                for (ee = 0; ee < M; ++ee) {
                  const ie = T[ee][0], ue = T[ee][1], fe = Math.min(Math.max(se[q + ee], ie), ue);
                  let de = F(fe, ie, ue, G[ee][0], G[ee][1]);
                  const pe = J[ee];
                  de = Math.min(Math.max(de, 0), pe - 1);
                  const xe = de < pe - 1 ? Math.floor(de) : de - 1, De = xe + 1 - de, Ae = de - xe, Se = xe * E, ke = Se + E;
                  for ($ = 0; $ < D; $++)
                    $ & H ? (ne[$] *= Ae, oe[$] += ke) : (ne[$] *= De, oe[$] += Se);
                  E *= pe, H <<= 1;
                }
                for ($ = 0; $ < V; ++$) {
                  let ie = 0;
                  for (ee = 0; ee < D; ee++)
                    ie += K[oe[ee] + $] * ne[ee];
                  ie = F(ie, 0, 1, L[$][0], L[$][1]), N[Q + $] = Math.min(Math.max(ie, I[$][0]), I[$][1]);
                }
              };
            }
            static constructInterpolated({
              xref: x,
              isEvalSupported: f,
              dict: U
            }) {
              const O = c(U.getArray("C0")) || [0], S = c(U.getArray("C1")) || [1], F = U.get("N"), T = [];
              for (let M = 0, V = O.length; M < V; ++M)
                T.push(S[M] - O[M]);
              const I = T.length;
              return function(V, J, W, z) {
                const G = F === 1 ? V[J] : V[J] ** F;
                for (let L = 0; L < I; ++L)
                  W[z + L] = O[L] + G * T[L];
              };
            }
            static constructStiched({
              xref: x,
              isEvalSupported: f,
              dict: U
            }) {
              const O = c(U.getArray("Domain"));
              if (!O)
                throw new a.FormatError("No domain");
              if (O.length / 2 !== 1)
                throw new a.FormatError("Bad domain for stiched function");
              const F = U.get("Functions"), T = [];
              for (let J = 0, W = F.length; J < W; ++J)
                T.push(this.parse({
                  xref: x,
                  isEvalSupported: f,
                  fn: x.fetchIfRef(F[J])
                }));
              const I = c(U.getArray("Bounds")), M = c(U.getArray("Encode")), V = new Float32Array(1);
              return function(W, z, G, L) {
                const te = function(ee, $, E) {
                  return ee > E ? ee = E : ee < $ && (ee = $), ee;
                }(W[z], O[0], O[1]), se = I.length;
                let q;
                for (q = 0; q < se && !(te < I[q]); ++q)
                  ;
                let N = O[0];
                q > 0 && (N = I[q - 1]);
                let Q = O[1];
                q < I.length && (Q = I[q]);
                const D = M[2 * q], ne = M[2 * q + 1];
                V[0] = N === Q ? D : D + (te - N) * (ne - D) / (Q - N), T[q](V, 0, G, L);
              };
            }
            static constructPostScript({
              xref: x,
              isEvalSupported: f,
              fn: U,
              dict: O
            }) {
              const S = c(O.getArray("Domain")), F = c(O.getArray("Range"));
              if (!S)
                throw new a.FormatError("No domain.");
              if (!F)
                throw new a.FormatError("No range.");
              const T = new v.PostScriptLexer(U), M = new v.PostScriptParser(T).parse();
              if (f && a.FeatureTest.isEvalSupported) {
                const te = new R().compile(M, S, F);
                if (te)
                  return new Function("src", "srcOffset", "dest", "destOffset", te);
              }
              (0, a.info)("Unable to compile PS function");
              const V = F.length >> 1, J = S.length >> 1, W = new g(M), z = /* @__PURE__ */ Object.create(null);
              let L = 2048 * 4;
              const K = new Float32Array(J);
              return function(se, q, N, Q) {
                let D, ne, oe = "";
                const ee = K;
                for (D = 0; D < J; D++)
                  ne = se[q + D], ee[D] = ne, oe += ne + "_";
                const $ = z[oe];
                if ($ !== void 0) {
                  N.set($, Q);
                  return;
                }
                const E = new Float32Array(V), H = W.execute(ee), ie = H.length - V;
                for (D = 0; D < V; D++) {
                  ne = H[ie + D];
                  let ue = F[D * 2];
                  ne < ue ? ne = ue : (ue = F[D * 2 + 1], ne > ue && (ne = ue)), E[D] = ne;
                }
                L > 0 && (L--, z[oe] = E), N.set(E, Q);
              };
            }
          }
          function p(k) {
            let x;
            if (typeof k != "object")
              return !1;
            if (k instanceof t.Dict)
              x = k;
            else if (k instanceof h.BaseStream)
              x = k.dict;
            else
              return !1;
            return x.has("FunctionType");
          }
          class m {
            static get MAX_STACK_SIZE() {
              return (0, a.shadow)(this, "MAX_STACK_SIZE", 100);
            }
            constructor(x) {
              this.stack = x ? Array.prototype.slice.call(x, 0) : [];
            }
            push(x) {
              if (this.stack.length >= m.MAX_STACK_SIZE)
                throw new Error("PostScript function stack overflow.");
              this.stack.push(x);
            }
            pop() {
              if (this.stack.length <= 0)
                throw new Error("PostScript function stack underflow.");
              return this.stack.pop();
            }
            copy(x) {
              if (this.stack.length + x >= m.MAX_STACK_SIZE)
                throw new Error("PostScript function stack overflow.");
              const f = this.stack;
              for (let U = f.length - x, O = x - 1; O >= 0; O--, U++)
                f.push(f[U]);
            }
            index(x) {
              this.push(this.stack[this.stack.length - x - 1]);
            }
            roll(x, f) {
              const U = this.stack, O = U.length - x, S = U.length - 1, F = O + (f - Math.floor(f / x) * x);
              for (let T = O, I = S; T < I; T++, I--) {
                const M = U[T];
                U[T] = U[I], U[I] = M;
              }
              for (let T = O, I = F - 1; T < I; T++, I--) {
                const M = U[T];
                U[T] = U[I], U[I] = M;
              }
              for (let T = F, I = S; T < I; T++, I--) {
                const M = U[T];
                U[T] = U[I], U[I] = M;
              }
            }
          }
          class g {
            constructor(x) {
              this.operators = x;
            }
            execute(x) {
              const f = new m(x);
              let U = 0;
              const O = this.operators, S = O.length;
              let F, T, I;
              for (; U < S; ) {
                if (F = O[U++], typeof F == "number") {
                  f.push(F);
                  continue;
                }
                switch (F) {
                  case "jz":
                    I = f.pop(), T = f.pop(), T || (U = I);
                    break;
                  case "j":
                    T = f.pop(), U = T;
                    break;
                  case "abs":
                    T = f.pop(), f.push(Math.abs(T));
                    break;
                  case "add":
                    I = f.pop(), T = f.pop(), f.push(T + I);
                    break;
                  case "and":
                    I = f.pop(), T = f.pop(), typeof T == "boolean" && typeof I == "boolean" ? f.push(T && I) : f.push(T & I);
                    break;
                  case "atan":
                    T = f.pop(), f.push(Math.atan(T));
                    break;
                  case "bitshift":
                    I = f.pop(), T = f.pop(), T > 0 ? f.push(T << I) : f.push(T >> I);
                    break;
                  case "ceiling":
                    T = f.pop(), f.push(Math.ceil(T));
                    break;
                  case "copy":
                    T = f.pop(), f.copy(T);
                    break;
                  case "cos":
                    T = f.pop(), f.push(Math.cos(T));
                    break;
                  case "cvi":
                    T = f.pop() | 0, f.push(T);
                    break;
                  case "cvr":
                    break;
                  case "div":
                    I = f.pop(), T = f.pop(), f.push(T / I);
                    break;
                  case "dup":
                    f.copy(1);
                    break;
                  case "eq":
                    I = f.pop(), T = f.pop(), f.push(T === I);
                    break;
                  case "exch":
                    f.roll(2, 1);
                    break;
                  case "exp":
                    I = f.pop(), T = f.pop(), f.push(T ** I);
                    break;
                  case "false":
                    f.push(!1);
                    break;
                  case "floor":
                    T = f.pop(), f.push(Math.floor(T));
                    break;
                  case "ge":
                    I = f.pop(), T = f.pop(), f.push(T >= I);
                    break;
                  case "gt":
                    I = f.pop(), T = f.pop(), f.push(T > I);
                    break;
                  case "idiv":
                    I = f.pop(), T = f.pop(), f.push(T / I | 0);
                    break;
                  case "index":
                    T = f.pop(), f.index(T);
                    break;
                  case "le":
                    I = f.pop(), T = f.pop(), f.push(T <= I);
                    break;
                  case "ln":
                    T = f.pop(), f.push(Math.log(T));
                    break;
                  case "log":
                    T = f.pop(), f.push(Math.log(T) / Math.LN10);
                    break;
                  case "lt":
                    I = f.pop(), T = f.pop(), f.push(T < I);
                    break;
                  case "mod":
                    I = f.pop(), T = f.pop(), f.push(T % I);
                    break;
                  case "mul":
                    I = f.pop(), T = f.pop(), f.push(T * I);
                    break;
                  case "ne":
                    I = f.pop(), T = f.pop(), f.push(T !== I);
                    break;
                  case "neg":
                    T = f.pop(), f.push(-T);
                    break;
                  case "not":
                    T = f.pop(), typeof T == "boolean" ? f.push(!T) : f.push(~T);
                    break;
                  case "or":
                    I = f.pop(), T = f.pop(), typeof T == "boolean" && typeof I == "boolean" ? f.push(T || I) : f.push(T | I);
                    break;
                  case "pop":
                    f.pop();
                    break;
                  case "roll":
                    I = f.pop(), T = f.pop(), f.roll(T, I);
                    break;
                  case "round":
                    T = f.pop(), f.push(Math.round(T));
                    break;
                  case "sin":
                    T = f.pop(), f.push(Math.sin(T));
                    break;
                  case "sqrt":
                    T = f.pop(), f.push(Math.sqrt(T));
                    break;
                  case "sub":
                    I = f.pop(), T = f.pop(), f.push(T - I);
                    break;
                  case "true":
                    f.push(!0);
                    break;
                  case "truncate":
                    T = f.pop(), T = T < 0 ? Math.ceil(T) : Math.floor(T), f.push(T);
                    break;
                  case "xor":
                    I = f.pop(), T = f.pop(), typeof T == "boolean" && typeof I == "boolean" ? f.push(T !== I) : f.push(T ^ I);
                    break;
                  default:
                    throw new a.FormatError(`Unknown operator ${F}`);
                }
              }
              return f.stack;
            }
          }
          o.PostScriptEvaluator = g;
          class n {
            constructor(x) {
              this.type = x;
            }
            visit(x) {
              (0, a.unreachable)("abstract method");
            }
          }
          class i extends n {
            constructor(x, f, U) {
              super("args"), this.index = x, this.min = f, this.max = U;
            }
            visit(x) {
              x.visitArgument(this);
            }
          }
          class l extends n {
            constructor(x) {
              super("literal"), this.number = x, this.min = x, this.max = x;
            }
            visit(x) {
              x.visitLiteral(this);
            }
          }
          class u extends n {
            constructor(x, f, U, O, S) {
              super("binary"), this.op = x, this.arg1 = f, this.arg2 = U, this.min = O, this.max = S;
            }
            visit(x) {
              x.visitBinaryOperation(this);
            }
          }
          class w extends n {
            constructor(x, f) {
              super("max"), this.arg = x, this.min = x.min, this.max = f;
            }
            visit(x) {
              x.visitMin(this);
            }
          }
          class _ extends n {
            constructor(x, f, U) {
              super("var"), this.index = x, this.min = f, this.max = U;
            }
            visit(x) {
              x.visitVariable(this);
            }
          }
          class b extends n {
            constructor(x, f) {
              super("definition"), this.variable = x, this.arg = f;
            }
            visit(x) {
              x.visitVariableDefinition(this);
            }
          }
          class A {
            constructor() {
              this.parts = [];
            }
            visitArgument(x) {
              this.parts.push("Math.max(", x.min, ", Math.min(", x.max, ", src[srcOffset + ", x.index, "]))");
            }
            visitVariable(x) {
              this.parts.push("v", x.index);
            }
            visitLiteral(x) {
              this.parts.push(x.number);
            }
            visitBinaryOperation(x) {
              this.parts.push("("), x.arg1.visit(this), this.parts.push(" ", x.op, " "), x.arg2.visit(this), this.parts.push(")");
            }
            visitVariableDefinition(x) {
              this.parts.push("var "), x.variable.visit(this), this.parts.push(" = "), x.arg.visit(this), this.parts.push(";");
            }
            visitMin(x) {
              this.parts.push("Math.min("), x.arg.visit(this), this.parts.push(", ", x.max, ")");
            }
            toString() {
              return this.parts.join("");
            }
          }
          function Y(k, x) {
            return x.type === "literal" && x.number === 0 ? k : k.type === "literal" && k.number === 0 ? x : x.type === "literal" && k.type === "literal" ? new l(k.number + x.number) : new u("+", k, x, k.min + x.min, k.max + x.max);
          }
          function j(k, x) {
            if (x.type === "literal") {
              if (x.number === 0)
                return new l(0);
              if (x.number === 1)
                return k;
              if (k.type === "literal")
                return new l(k.number * x.number);
            }
            if (k.type === "literal") {
              if (k.number === 0)
                return new l(0);
              if (k.number === 1)
                return x;
            }
            const f = Math.min(k.min * x.min, k.min * x.max, k.max * x.min, k.max * x.max), U = Math.max(k.min * x.min, k.min * x.max, k.max * x.min, k.max * x.max);
            return new u("*", k, x, f, U);
          }
          function X(k, x) {
            if (x.type === "literal") {
              if (x.number === 0)
                return k;
              if (k.type === "literal")
                return new l(k.number - x.number);
            }
            return x.type === "binary" && x.op === "-" && k.type === "literal" && k.number === 1 && x.arg1.type === "literal" && x.arg1.number === 1 ? x.arg2 : new u("-", k, x, k.min - x.max, k.max - x.min);
          }
          function B(k, x) {
            return k.min >= x ? new l(x) : k.max <= x ? k : new w(k, x);
          }
          class R {
            compile(x, f, U) {
              const O = [], S = [], F = f.length >> 1, T = U.length >> 1;
              let I = 0, M, V, J, W, z, G, L, K;
              for (let se = 0; se < F; se++)
                O.push(new i(se, f[se * 2], f[se * 2 + 1]));
              for (let se = 0, q = x.length; se < q; se++) {
                if (K = x[se], typeof K == "number") {
                  O.push(new l(K));
                  continue;
                }
                switch (K) {
                  case "add":
                    if (O.length < 2)
                      return null;
                    W = O.pop(), J = O.pop(), O.push(Y(J, W));
                    break;
                  case "cvr":
                    if (O.length < 1)
                      return null;
                    break;
                  case "mul":
                    if (O.length < 2)
                      return null;
                    W = O.pop(), J = O.pop(), O.push(j(J, W));
                    break;
                  case "sub":
                    if (O.length < 2)
                      return null;
                    W = O.pop(), J = O.pop(), O.push(X(J, W));
                    break;
                  case "exch":
                    if (O.length < 2)
                      return null;
                    z = O.pop(), G = O.pop(), O.push(z, G);
                    break;
                  case "pop":
                    if (O.length < 1)
                      return null;
                    O.pop();
                    break;
                  case "index":
                    if (O.length < 1 || (J = O.pop(), J.type !== "literal") || (M = J.number, M < 0 || !Number.isInteger(M) || O.length < M))
                      return null;
                    if (z = O[O.length - M - 1], z.type === "literal" || z.type === "var") {
                      O.push(z);
                      break;
                    }
                    L = new _(I++, z.min, z.max), O[O.length - M - 1] = L, O.push(L), S.push(new b(L, z));
                    break;
                  case "dup":
                    if (O.length < 1)
                      return null;
                    if (typeof x[se + 1] == "number" && x[se + 2] === "gt" && x[se + 3] === se + 7 && x[se + 4] === "jz" && x[se + 5] === "pop" && x[se + 6] === x[se + 1]) {
                      J = O.pop(), O.push(B(J, x[se + 1])), se += 6;
                      break;
                    }
                    if (z = O.at(-1), z.type === "literal" || z.type === "var") {
                      O.push(z);
                      break;
                    }
                    L = new _(I++, z.min, z.max), O[O.length - 1] = L, O.push(L), S.push(new b(L, z));
                    break;
                  case "roll":
                    if (O.length < 2 || (W = O.pop(), J = O.pop(), W.type !== "literal" || J.type !== "literal") || (V = W.number, M = J.number, M <= 0 || !Number.isInteger(M) || !Number.isInteger(V) || O.length < M))
                      return null;
                    if (V = (V % M + M) % M, V === 0)
                      break;
                    Array.prototype.push.apply(O, O.splice(O.length - M, M - V));
                    break;
                  default:
                    return null;
                }
              }
              if (O.length !== T)
                return null;
              const te = [];
              for (const se of S) {
                const q = new A();
                se.visit(q), te.push(q.toString());
              }
              for (let se = 0, q = O.length; se < q; se++) {
                const N = O[se], Q = new A();
                N.visit(Q);
                const D = U[se * 2], ne = U[se * 2 + 1], oe = [Q.toString()];
                D > N.min && (oe.unshift("Math.max(", D, ", "), oe.push(")")), ne < N.max && (oe.unshift("Math.min(", ne, ", "), oe.push(")")), oe.unshift("dest[destOffset + ", se, "] = "), oe.push(";"), te.push(oe.join(""));
              }
              return te.join(`
`);
            }
          }
          o.PostScriptCompiler = R;
        },
        /* 58 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.PostScriptParser = o.PostScriptLexer = void 0;
          var t = C(2), a = C(5), v = C(6);
          class h {
            constructor(p) {
              this.lexer = p, this.operators = [], this.token = null, this.prev = null;
            }
            nextToken() {
              this.prev = this.token, this.token = this.lexer.getToken();
            }
            accept(p) {
              return this.token.type === p ? (this.nextToken(), !0) : !1;
            }
            expect(p) {
              if (this.accept(p))
                return !0;
              throw new t.FormatError(`Unexpected symbol: found ${this.token.type} expected ${p}.`);
            }
            parse() {
              return this.nextToken(), this.expect(e.LBRACE), this.parseBlock(), this.expect(e.RBRACE), this.operators;
            }
            parseBlock() {
              for (; ; )
                if (this.accept(e.NUMBER))
                  this.operators.push(this.prev.value);
                else if (this.accept(e.OPERATOR))
                  this.operators.push(this.prev.value);
                else if (this.accept(e.LBRACE))
                  this.parseCondition();
                else
                  return;
            }
            parseCondition() {
              const p = this.operators.length;
              if (this.operators.push(null, null), this.parseBlock(), this.expect(e.RBRACE), this.accept(e.IF))
                this.operators[p] = this.operators.length, this.operators[p + 1] = "jz";
              else if (this.accept(e.LBRACE)) {
                const m = this.operators.length;
                this.operators.push(null, null);
                const g = this.operators.length;
                this.parseBlock(), this.expect(e.RBRACE), this.expect(e.IFELSE), this.operators[m] = this.operators.length, this.operators[m + 1] = "j", this.operators[p] = g, this.operators[p + 1] = "jz";
              } else
                throw new t.FormatError("PS Function: error parsing conditional.");
            }
          }
          o.PostScriptParser = h;
          const e = {
            LBRACE: 0,
            RBRACE: 1,
            NUMBER: 2,
            OPERATOR: 3,
            IF: 4,
            IFELSE: 5
          };
          class y {
            static get opCache() {
              return (0, t.shadow)(this, "opCache", /* @__PURE__ */ Object.create(null));
            }
            constructor(p, m) {
              this.type = p, this.value = m;
            }
            static getOperator(p) {
              const m = y.opCache[p];
              return m || (y.opCache[p] = new y(e.OPERATOR, p));
            }
            static get LBRACE() {
              return (0, t.shadow)(this, "LBRACE", new y(e.LBRACE, "{"));
            }
            static get RBRACE() {
              return (0, t.shadow)(this, "RBRACE", new y(e.RBRACE, "}"));
            }
            static get IF() {
              return (0, t.shadow)(this, "IF", new y(e.IF, "IF"));
            }
            static get IFELSE() {
              return (0, t.shadow)(this, "IFELSE", new y(e.IFELSE, "IFELSE"));
            }
          }
          class c {
            constructor(p) {
              this.stream = p, this.nextChar(), this.strBuf = [];
            }
            nextChar() {
              return this.currentChar = this.stream.getByte();
            }
            getToken() {
              let p = !1, m = this.currentChar;
              for (; ; ) {
                if (m < 0)
                  return a.EOF;
                if (p)
                  (m === 10 || m === 13) && (p = !1);
                else if (m === 37)
                  p = !0;
                else if (!(0, v.isWhiteSpace)(m))
                  break;
                m = this.nextChar();
              }
              switch (m | 0) {
                case 48:
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                case 43:
                case 45:
                case 46:
                  return new y(e.NUMBER, this.getNumber());
                case 123:
                  return this.nextChar(), y.LBRACE;
                case 125:
                  return this.nextChar(), y.RBRACE;
              }
              const g = this.strBuf;
              for (g.length = 0, g[0] = String.fromCharCode(m); (m = this.nextChar()) >= 0 && (m >= 65 && m <= 90 || m >= 97 && m <= 122); )
                g.push(String.fromCharCode(m));
              const n = g.join("");
              switch (n.toLowerCase()) {
                case "if":
                  return y.IF;
                case "ifelse":
                  return y.IFELSE;
                default:
                  return y.getOperator(n);
              }
            }
            getNumber() {
              let p = this.currentChar;
              const m = this.strBuf;
              for (m.length = 0, m[0] = String.fromCharCode(p); (p = this.nextChar()) >= 0 && (p >= 48 && p <= 57 || p === 45 || p === 46); )
                m.push(String.fromCharCode(p));
              const g = parseFloat(m.join(""));
              if (isNaN(g))
                throw new t.FormatError(`Invalid floating point number: ${g}`);
              return g;
            }
          }
          o.PostScriptLexer = c;
        },
        /* 59 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.LocalTilingPatternCache = o.LocalImageCache = o.LocalGStateCache = o.LocalFunctionCache = o.LocalColorSpaceCache = o.GlobalImageCache = void 0;
          var t = C(2), a = C(5);
          class v {
            constructor(g) {
              this.constructor === v && (0, t.unreachable)("Cannot initialize BaseLocalCache."), this._onlyRefs = (g && g.onlyRefs) === !0, this._onlyRefs || (this._nameRefMap = /* @__PURE__ */ new Map(), this._imageMap = /* @__PURE__ */ new Map()), this._imageCache = new a.RefSetCache();
            }
            getByName(g) {
              this._onlyRefs && (0, t.unreachable)("Should not call `getByName` method.");
              const n = this._nameRefMap.get(g);
              return n ? this.getByRef(n) : this._imageMap.get(g) || null;
            }
            getByRef(g) {
              return this._imageCache.get(g) || null;
            }
            set(g, n, i) {
              (0, t.unreachable)("Abstract method `set` called.");
            }
          }
          class h extends v {
            set(g, n = null, i) {
              if (typeof g != "string")
                throw new Error('LocalImageCache.set - expected "name" argument.');
              if (n) {
                if (this._imageCache.has(n))
                  return;
                this._nameRefMap.set(g, n), this._imageCache.put(n, i);
                return;
              }
              this._imageMap.has(g) || this._imageMap.set(g, i);
            }
          }
          o.LocalImageCache = h;
          class e extends v {
            set(g = null, n = null, i) {
              if (typeof g != "string" && !n)
                throw new Error('LocalColorSpaceCache.set - expected "name" and/or "ref" argument.');
              if (n) {
                if (this._imageCache.has(n))
                  return;
                g !== null && this._nameRefMap.set(g, n), this._imageCache.put(n, i);
                return;
              }
              this._imageMap.has(g) || this._imageMap.set(g, i);
            }
          }
          o.LocalColorSpaceCache = e;
          class y extends v {
            constructor(g) {
              super({
                onlyRefs: !0
              });
            }
            set(g = null, n, i) {
              if (!n)
                throw new Error('LocalFunctionCache.set - expected "ref" argument.');
              this._imageCache.has(n) || this._imageCache.put(n, i);
            }
          }
          o.LocalFunctionCache = y;
          class c extends v {
            set(g, n = null, i) {
              if (typeof g != "string")
                throw new Error('LocalGStateCache.set - expected "name" argument.');
              if (n) {
                if (this._imageCache.has(n))
                  return;
                this._nameRefMap.set(g, n), this._imageCache.put(n, i);
                return;
              }
              this._imageMap.has(g) || this._imageMap.set(g, i);
            }
          }
          o.LocalGStateCache = c;
          class d extends v {
            constructor(g) {
              super({
                onlyRefs: !0
              });
            }
            set(g = null, n, i) {
              if (!n)
                throw new Error('LocalTilingPatternCache.set - expected "ref" argument.');
              this._imageCache.has(n) || this._imageCache.put(n, i);
            }
          }
          o.LocalTilingPatternCache = d;
          class p {
            static get NUM_PAGES_THRESHOLD() {
              return (0, t.shadow)(this, "NUM_PAGES_THRESHOLD", 2);
            }
            static get MIN_IMAGES_TO_CACHE() {
              return (0, t.shadow)(this, "MIN_IMAGES_TO_CACHE", 10);
            }
            static get MAX_BYTE_SIZE() {
              return (0, t.shadow)(this, "MAX_BYTE_SIZE", 4e7);
            }
            constructor() {
              this._refCache = new a.RefSetCache(), this._imageCache = new a.RefSetCache();
            }
            get _byteSize() {
              let g = 0;
              for (const n of this._imageCache)
                g += n.byteSize;
              return g;
            }
            get _cacheLimitReached() {
              return !(this._imageCache.size < p.MIN_IMAGES_TO_CACHE || this._byteSize < p.MAX_BYTE_SIZE);
            }
            shouldCache(g, n) {
              const i = this._refCache.get(g);
              return !((i ? i.size + (i.has(n) ? 0 : 1) : 1) < p.NUM_PAGES_THRESHOLD || !this._imageCache.has(g) && this._cacheLimitReached);
            }
            addPageIndex(g, n) {
              let i = this._refCache.get(g);
              i || (i = /* @__PURE__ */ new Set(), this._refCache.put(g, i)), i.add(n);
            }
            addByteSize(g, n) {
              const i = this._imageCache.get(g);
              i && (i.byteSize || (i.byteSize = n));
            }
            getData(g, n) {
              const i = this._refCache.get(g);
              if (!i || i.size < p.NUM_PAGES_THRESHOLD)
                return null;
              const l = this._imageCache.get(g);
              return l ? (i.add(n), l) : null;
            }
            setData(g, n) {
              if (!this._refCache.has(g))
                throw new Error('GlobalImageCache.setData - expected "addPageIndex" to have been called.');
              if (!this._imageCache.has(g)) {
                if (this._cacheLimitReached) {
                  (0, t.warn)("GlobalImageCache.setData - cache limit reached.");
                  return;
                }
                this._imageCache.put(g, n);
              }
            }
            clear(g = !1) {
              g || this._refCache.clear(), this._imageCache.clear();
            }
          }
          o.GlobalImageCache = p;
        },
        /* 60 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.bidi = n;
          var t = C(2);
          const a = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "ON", "ON", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "ON", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "ON", "ET", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "L", "ON", "ON", "BN", "ON", "ON", "ET", "ET", "EN", "EN", "ON", "L", "ON", "ON", "ON", "EN", "L", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L"], v = ["AN", "AN", "AN", "AN", "AN", "AN", "ON", "ON", "AL", "ET", "ET", "AL", "CS", "AL", "ON", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "ON", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL"];
          function h(i) {
            return (i & 1) !== 0;
          }
          function e(i) {
            return (i & 1) === 0;
          }
          function y(i, l, u) {
            let w, _;
            for (w = l, _ = i.length; w < _; ++w)
              if (i[w] !== u)
                return w;
            return w;
          }
          function c(i, l, u, w) {
            for (let _ = l; _ < u; ++_)
              i[_] = w;
          }
          function d(i, l, u) {
            for (let w = l, _ = u - 1; w < _; ++w, --_) {
              const b = i[w];
              i[w] = i[_], i[_] = b;
            }
          }
          function p(i, l, u = !1) {
            let w = "ltr";
            return u ? w = "ttb" : l || (w = "rtl"), {
              str: i,
              dir: w
            };
          }
          const m = [], g = [];
          function n(i, l = -1, u = !1) {
            let w = !0;
            const _ = i.length;
            if (_ === 0 || u)
              return p(i, w, u);
            m.length = _, g.length = _;
            let b = 0, A, Y;
            for (A = 0; A < _; ++A) {
              m[A] = i.charAt(A);
              const S = i.charCodeAt(A);
              let F = "L";
              S <= 255 ? F = a[S] : 1424 <= S && S <= 1524 ? F = "R" : 1536 <= S && S <= 1791 ? (F = v[S & 255], F || (0, t.warn)("Bidi: invalid Unicode character " + S.toString(16))) : 1792 <= S && S <= 2220 && (F = "AL"), (F === "R" || F === "AL" || F === "AN") && b++, g[A] = F;
            }
            if (b === 0)
              return w = !0, p(i, w);
            l === -1 && (b / _ < 0.3 && _ > 4 ? (w = !0, l = 0) : (w = !1, l = 1));
            const j = [];
            for (A = 0; A < _; ++A)
              j[A] = l;
            const X = h(l) ? "R" : "L", B = X, R = B;
            let k = B;
            for (A = 0; A < _; ++A)
              g[A] === "NSM" ? g[A] = k : k = g[A];
            k = B;
            let x;
            for (A = 0; A < _; ++A)
              x = g[A], x === "EN" ? g[A] = k === "AL" ? "AN" : "EN" : (x === "R" || x === "L" || x === "AL") && (k = x);
            for (A = 0; A < _; ++A)
              x = g[A], x === "AL" && (g[A] = "R");
            for (A = 1; A < _ - 1; ++A)
              g[A] === "ES" && g[A - 1] === "EN" && g[A + 1] === "EN" && (g[A] = "EN"), g[A] === "CS" && (g[A - 1] === "EN" || g[A - 1] === "AN") && g[A + 1] === g[A - 1] && (g[A] = g[A - 1]);
            for (A = 0; A < _; ++A)
              if (g[A] === "EN") {
                for (let S = A - 1; S >= 0 && g[S] === "ET"; --S)
                  g[S] = "EN";
                for (let S = A + 1; S < _ && g[S] === "ET"; ++S)
                  g[S] = "EN";
              }
            for (A = 0; A < _; ++A)
              x = g[A], (x === "WS" || x === "ES" || x === "ET" || x === "CS") && (g[A] = "ON");
            for (k = B, A = 0; A < _; ++A)
              x = g[A], x === "EN" ? g[A] = k === "L" ? "L" : "EN" : (x === "R" || x === "L") && (k = x);
            for (A = 0; A < _; ++A)
              if (g[A] === "ON") {
                const S = y(g, A + 1, "ON");
                let F = B;
                A > 0 && (F = g[A - 1]);
                let T = R;
                S + 1 < _ && (T = g[S + 1]), F !== "L" && (F = "R"), T !== "L" && (T = "R"), F === T && c(g, A, S, F), A = S - 1;
              }
            for (A = 0; A < _; ++A)
              g[A] === "ON" && (g[A] = X);
            for (A = 0; A < _; ++A)
              x = g[A], e(j[A]) ? x === "R" ? j[A] += 1 : (x === "AN" || x === "EN") && (j[A] += 2) : (x === "L" || x === "AN" || x === "EN") && (j[A] += 1);
            let f = -1, U = 99, O;
            for (A = 0, Y = j.length; A < Y; ++A)
              O = j[A], f < O && (f = O), U > O && h(O) && (U = O);
            for (O = f; O >= U; --O) {
              let S = -1;
              for (A = 0, Y = j.length; A < Y; ++A)
                j[A] < O ? S >= 0 && (d(m, S, A), S = -1) : S < 0 && (S = A);
              S >= 0 && d(m, S, j.length);
            }
            for (A = 0, Y = m.length; A < Y; ++A) {
              const S = m[A];
              (S === "<" || S === ">") && (m[A] = "");
            }
            return p(m.join(""), w);
          }
        },
        /* 61 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.MurmurHash3_64 = void 0;
          var t = C(2);
          const a = 3285377520, v = 4294901760, h = 65535;
          class e {
            constructor(c) {
              this.h1 = c ? c & 4294967295 : a, this.h2 = c ? c & 4294967295 : a;
            }
            update(c) {
              let d, p;
              if (typeof c == "string") {
                d = new Uint8Array(c.length * 2), p = 0;
                for (let j = 0, X = c.length; j < X; j++) {
                  const B = c.charCodeAt(j);
                  B <= 255 ? d[p++] = B : (d[p++] = B >>> 8, d[p++] = B & 255);
                }
              } else if ((0, t.isArrayBuffer)(c))
                d = c.slice(), p = d.byteLength;
              else
                throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");
              const m = p >> 2, g = p - m * 4, n = new Uint32Array(d.buffer, 0, m);
              let i = 0, l = 0, u = this.h1, w = this.h2;
              const _ = 3432918353, b = 461845907, A = _ & h, Y = b & h;
              for (let j = 0; j < m; j++)
                j & 1 ? (i = n[j], i = i * _ & v | i * A & h, i = i << 15 | i >>> 17, i = i * b & v | i * Y & h, u ^= i, u = u << 13 | u >>> 19, u = u * 5 + 3864292196) : (l = n[j], l = l * _ & v | l * A & h, l = l << 15 | l >>> 17, l = l * b & v | l * Y & h, w ^= l, w = w << 13 | w >>> 19, w = w * 5 + 3864292196);
              switch (i = 0, g) {
                case 3:
                  i ^= d[m * 4 + 2] << 16;
                case 2:
                  i ^= d[m * 4 + 1] << 8;
                case 1:
                  i ^= d[m * 4], i = i * _ & v | i * A & h, i = i << 15 | i >>> 17, i = i * b & v | i * Y & h, m & 1 ? u ^= i : w ^= i;
              }
              this.h1 = u, this.h2 = w;
            }
            hexdigest() {
              let c = this.h1, d = this.h2;
              c ^= d >>> 1, c = c * 3981806797 & v | c * 36045 & h, d = d * 4283543511 & v | ((d << 16 | c >>> 16) * 2950163797 & v) >>> 16, c ^= d >>> 1, c = c * 444984403 & v | c * 60499 & h, d = d * 3301882366 & v | ((d << 16 | c >>> 16) * 3120437893 & v) >>> 16, c ^= d >>> 1;
              const p = (c >>> 0).toString(16), m = (d >>> 0).toString(16);
              return p.padStart(8, "0") + m.padStart(8, "0");
            }
          }
          o.MurmurHash3_64 = e;
        },
        /* 62 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.OperatorList = void 0;
          var t = C(2);
          function a(c, d, p, m, g) {
            let n = c;
            for (let i = 0, l = d.length - 1; i < l; i++) {
              const u = d[i];
              n = n[u] || (n[u] = []);
            }
            n[d.at(-1)] = {
              checkFn: p,
              iterateFn: m,
              processFn: g
            };
          }
          const v = [];
          a(v, [t.OPS.save, t.OPS.transform, t.OPS.paintInlineImageXObject, t.OPS.restore], null, function(d, p) {
            const m = d.fnArray, g = d.iCurr - 3, n = (p - g) % 4;
            switch (n) {
              case 0:
                return m[p] === t.OPS.save;
              case 1:
                return m[p] === t.OPS.transform;
              case 2:
                return m[p] === t.OPS.paintInlineImageXObject;
              case 3:
                return m[p] === t.OPS.restore;
            }
            throw new Error(`iterateInlineImageGroup - invalid pos: ${n}`);
          }, function(d, p) {
            const l = d.fnArray, u = d.argsArray, w = d.iCurr, _ = w - 3, b = w - 2, A = w - 1, Y = Math.min(Math.floor((p - _) / 4), 200);
            if (Y < 10)
              return p - (p - _) % 4;
            let j = 0;
            const X = [];
            let B = 0, R = 1, k = 1;
            for (let S = 0; S < Y; S++) {
              const F = u[b + (S << 2)], T = u[A + (S << 2)][0];
              R + T.width > 1e3 && (j = Math.max(j, R), k += B + 2, R = 0, B = 0), X.push({
                transform: F,
                x: R,
                y: k,
                w: T.width,
                h: T.height
              }), R += T.width + 2, B = Math.max(B, T.height);
            }
            const x = Math.max(j, R) + 1, f = k + B + 1, U = new Uint8Array(x * f * 4), O = x << 2;
            for (let S = 0; S < Y; S++) {
              const F = u[A + (S << 2)][0].data, T = X[S].w << 2;
              let I = 0, M = X[S].x + X[S].y * x << 2;
              U.set(F.subarray(0, T), M - O);
              for (let V = 0, J = X[S].h; V < J; V++)
                U.set(F.subarray(I, I + T), M), I += T, M += O;
              for (U.set(F.subarray(I - T, I), M); M >= 0; )
                F[M - 4] = F[M], F[M - 3] = F[M + 1], F[M - 2] = F[M + 2], F[M - 1] = F[M + 3], F[M + T] = F[M + T - 4], F[M + T + 1] = F[M + T - 3], F[M + T + 2] = F[M + T - 2], F[M + T + 3] = F[M + T - 1], M -= O;
            }
            return l.splice(_, Y * 4, t.OPS.paintInlineImageXObjectGroup), u.splice(_, Y * 4, [{
              width: x,
              height: f,
              kind: t.ImageKind.RGBA_32BPP,
              data: U
            }, X]), _ + 1;
          }), a(v, [t.OPS.save, t.OPS.transform, t.OPS.paintImageMaskXObject, t.OPS.restore], null, function(d, p) {
            const m = d.fnArray, g = d.iCurr - 3, n = (p - g) % 4;
            switch (n) {
              case 0:
                return m[p] === t.OPS.save;
              case 1:
                return m[p] === t.OPS.transform;
              case 2:
                return m[p] === t.OPS.paintImageMaskXObject;
              case 3:
                return m[p] === t.OPS.restore;
            }
            throw new Error(`iterateImageMaskGroup - invalid pos: ${n}`);
          }, function(d, p) {
            const i = d.fnArray, l = d.argsArray, u = d.iCurr, w = u - 3, _ = u - 2, b = u - 1;
            let A = Math.floor((p - w) / 4);
            if (A < 10)
              return p - (p - w) % 4;
            let Y = !1, j, X;
            const B = l[b][0], R = l[_][0], k = l[_][1], x = l[_][2], f = l[_][3];
            if (k === x) {
              Y = !0, j = _ + 4;
              let U = b + 4;
              for (let O = 1; O < A; O++, j += 4, U += 4)
                if (X = l[j], l[U][0] !== B || X[0] !== R || X[1] !== k || X[2] !== x || X[3] !== f) {
                  O < 10 ? Y = !1 : A = O;
                  break;
                }
            }
            if (Y) {
              A = Math.min(A, 1e3);
              const U = new Float32Array(A * 2);
              j = _;
              for (let O = 0; O < A; O++, j += 4)
                X = l[j], U[O << 1] = X[4], U[(O << 1) + 1] = X[5];
              i.splice(w, A * 4, t.OPS.paintImageMaskXObjectRepeat), l.splice(w, A * 4, [B, R, k, x, f, U]);
            } else {
              A = Math.min(A, 100);
              const U = [];
              for (let O = 0; O < A; O++) {
                X = l[_ + (O << 2)];
                const S = l[b + (O << 2)][0];
                U.push({
                  data: S.data,
                  width: S.width,
                  height: S.height,
                  interpolate: S.interpolate,
                  count: S.count,
                  transform: X
                });
              }
              i.splice(w, A * 4, t.OPS.paintImageMaskXObjectGroup), l.splice(w, A * 4, [U]);
            }
            return w + 1;
          }), a(v, [t.OPS.save, t.OPS.transform, t.OPS.paintImageXObject, t.OPS.restore], function(c) {
            const d = c.argsArray, p = c.iCurr - 2;
            return d[p][1] === 0 && d[p][2] === 0;
          }, function(d, p) {
            const m = d.fnArray, g = d.argsArray, n = d.iCurr - 3, i = (p - n) % 4;
            switch (i) {
              case 0:
                return m[p] === t.OPS.save;
              case 1:
                if (m[p] !== t.OPS.transform)
                  return !1;
                const l = d.iCurr - 2, u = g[l][0], w = g[l][3];
                return !(g[p][0] !== u || g[p][1] !== 0 || g[p][2] !== 0 || g[p][3] !== w);
              case 2:
                if (m[p] !== t.OPS.paintImageXObject)
                  return !1;
                const _ = d.iCurr - 1, b = g[_][0];
                return g[p][0] === b;
              case 3:
                return m[p] === t.OPS.restore;
            }
            throw new Error(`iterateImageGroup - invalid pos: ${i}`);
          }, function(c, d) {
            const g = c.fnArray, n = c.argsArray, i = c.iCurr, l = i - 3, u = i - 2, w = i - 1, _ = n[w][0], b = n[u][0], A = n[u][3], Y = Math.min(Math.floor((d - l) / 4), 1e3);
            if (Y < 3)
              return d - (d - l) % 4;
            const j = new Float32Array(Y * 2);
            let X = u;
            for (let R = 0; R < Y; R++, X += 4) {
              const k = n[X];
              j[R << 1] = k[4], j[(R << 1) + 1] = k[5];
            }
            const B = [_, b, A, j];
            return g.splice(l, Y * 4, t.OPS.paintImageXObjectRepeat), n.splice(l, Y * 4, B), l + 1;
          }), a(v, [t.OPS.beginText, t.OPS.setFont, t.OPS.setTextMatrix, t.OPS.showText, t.OPS.endText], null, function(d, p) {
            const m = d.fnArray, g = d.argsArray, n = d.iCurr - 4, i = (p - n) % 5;
            switch (i) {
              case 0:
                return m[p] === t.OPS.beginText;
              case 1:
                return m[p] === t.OPS.setFont;
              case 2:
                return m[p] === t.OPS.setTextMatrix;
              case 3:
                if (m[p] !== t.OPS.showText)
                  return !1;
                const l = d.iCurr - 3, u = g[l][0], w = g[l][1];
                return !(g[p][0] !== u || g[p][1] !== w);
              case 4:
                return m[p] === t.OPS.endText;
            }
            throw new Error(`iterateShowTextGroup - invalid pos: ${i}`);
          }, function(c, d) {
            const g = c.fnArray, n = c.argsArray, i = c.iCurr, l = i - 4, u = i - 3, w = i - 2, _ = i - 1, b = i, A = n[u][0], Y = n[u][1];
            let j = Math.min(Math.floor((d - l) / 5), 1e3);
            if (j < 3)
              return d - (d - l) % 5;
            let X = l;
            l >= 4 && g[l - 4] === g[u] && g[l - 3] === g[w] && g[l - 2] === g[_] && g[l - 1] === g[b] && n[l - 4][0] === A && n[l - 4][1] === Y && (j++, X -= 5);
            let B = X + 4;
            for (let R = 1; R < j; R++)
              g.splice(B, 3), n.splice(B, 3), B += 2;
            return B + 1;
          });
          class h {
            constructor(d) {
              this.queue = d;
            }
            _optimize() {
            }
            push(d, p) {
              this.queue.fnArray.push(d), this.queue.argsArray.push(p), this._optimize();
            }
            flush() {
            }
            reset() {
            }
          }
          class e extends h {
            constructor(d) {
              super(d), this.state = null, this.context = {
                iCurr: 0,
                fnArray: d.fnArray,
                argsArray: d.argsArray
              }, this.match = null, this.lastProcessed = 0;
            }
            _optimize() {
              const d = this.queue.fnArray;
              let p = this.lastProcessed, m = d.length, g = this.state, n = this.match;
              if (!g && !n && p + 1 === m && !v[d[p]]) {
                this.lastProcessed = m;
                return;
              }
              const i = this.context;
              for (; p < m; ) {
                if (n) {
                  if ((0, n.iterateFn)(i, p)) {
                    p++;
                    continue;
                  }
                  if (p = (0, n.processFn)(i, p + 1), m = d.length, n = null, g = null, p >= m)
                    break;
                }
                if (g = (g || v)[d[p]], !g || Array.isArray(g)) {
                  p++;
                  continue;
                }
                if (i.iCurr = p, p++, g.checkFn && !(0, g.checkFn)(i)) {
                  g = null;
                  continue;
                }
                n = g, g = null;
              }
              this.state = g, this.match = n, this.lastProcessed = p;
            }
            flush() {
              for (; this.match; ) {
                const d = this.queue.fnArray.length;
                this.lastProcessed = (0, this.match.processFn)(this.context, d), this.match = null, this.state = null, this._optimize();
              }
            }
            reset() {
              this.state = null, this.match = null, this.lastProcessed = 0;
            }
          }
          class y {
            static get CHUNK_SIZE() {
              return (0, t.shadow)(this, "CHUNK_SIZE", 1e3);
            }
            static get CHUNK_SIZE_ABOUT() {
              return (0, t.shadow)(this, "CHUNK_SIZE_ABOUT", this.CHUNK_SIZE - 5);
            }
            constructor(d = 0, p) {
              this._streamSink = p, this.fnArray = [], this.argsArray = [], p && !(d & t.RenderingIntentFlag.OPLIST) ? this.optimizer = new e(this) : this.optimizer = new h(this), this.dependencies = /* @__PURE__ */ new Set(), this._totalLength = 0, this.weight = 0, this._resolved = p ? null : Promise.resolve();
            }
            get length() {
              return this.argsArray.length;
            }
            get ready() {
              return this._resolved || this._streamSink.ready;
            }
            get totalLength() {
              return this._totalLength + this.length;
            }
            addOp(d, p) {
              this.optimizer.push(d, p), this.weight++, this._streamSink && (this.weight >= y.CHUNK_SIZE ? this.flush() : this.weight >= y.CHUNK_SIZE_ABOUT && (d === t.OPS.restore || d === t.OPS.endText) && this.flush());
            }
            addImageOps(d, p, m) {
              m !== void 0 && this.addOp(t.OPS.beginMarkedContentProps, ["OC", m]), this.addOp(d, p), m !== void 0 && this.addOp(t.OPS.endMarkedContent, []);
            }
            addDependency(d) {
              this.dependencies.has(d) || (this.dependencies.add(d), this.addOp(t.OPS.dependency, [d]));
            }
            addDependencies(d) {
              for (const p of d)
                this.addDependency(p);
            }
            addOpList(d) {
              if (!(d instanceof y)) {
                (0, t.warn)('addOpList - ignoring invalid "opList" parameter.');
                return;
              }
              for (const p of d.dependencies)
                this.dependencies.add(p);
              for (let p = 0, m = d.length; p < m; p++)
                this.addOp(d.fnArray[p], d.argsArray[p]);
            }
            getIR() {
              return {
                fnArray: this.fnArray,
                argsArray: this.argsArray,
                length: this.length
              };
            }
            get _transfers() {
              const d = [], {
                fnArray: p,
                argsArray: m,
                length: g
              } = this;
              for (let n = 0; n < g; n++)
                switch (p[n]) {
                  case t.OPS.paintInlineImageXObject:
                  case t.OPS.paintInlineImageXObjectGroup:
                  case t.OPS.paintImageMaskXObject:
                    const i = m[n][0];
                    !i.cached && i.data && i.data.buffer instanceof ArrayBuffer && d.push(i.data.buffer);
                    break;
                }
              return d;
            }
            flush(d = !1, p = null) {
              this.optimizer.flush();
              const m = this.length;
              this._totalLength += m, this._streamSink.enqueue({
                fnArray: this.fnArray,
                argsArray: this.argsArray,
                lastChunk: d,
                separateAnnots: p,
                length: m
              }, 1, this._transfers), this.dependencies.clear(), this.fnArray.length = 0, this.argsArray.length = 0, this.weight = 0, this.optimizer.reset();
            }
          }
          o.OperatorList = y;
        },
        /* 63 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.PDFImage = void 0;
          var t = C(2), a = C(64), v = C(7), h = C(14), e = C(19), y = C(27), c = C(30), d = C(5);
          function p(n, i, l, u) {
            return n = i + n * l, n < 0 ? n = 0 : n > u && (n = u), n;
          }
          function m(n, i, l, u, w, _) {
            const b = w * _;
            let A;
            i <= 8 ? A = new Uint8Array(b) : i <= 16 ? A = new Uint16Array(b) : A = new Uint32Array(b);
            const Y = l / w, j = u / _;
            let X, B, R, k = 0, x;
            const f = new Uint16Array(w), U = l;
            for (X = 0; X < w; X++)
              f[X] = Math.floor(X * Y);
            for (X = 0; X < _; X++)
              for (R = Math.floor(X * j) * U, B = 0; B < w; B++)
                x = R + f[B], A[k++] = n[x];
            return A;
          }
          class g {
            constructor({
              xref: i,
              res: l,
              image: u,
              isInline: w = !1,
              smask: _ = null,
              mask: b = null,
              isMask: A = !1,
              pdfFunctionFactory: Y,
              localColorSpaceCache: j
            }) {
              this.image = u;
              const X = u.dict, B = X.get("F", "Filter");
              let R;
              if (B instanceof d.Name)
                R = B.name;
              else if (Array.isArray(B)) {
                const U = i.fetchIfRef(B[0]);
                U instanceof d.Name && (R = U.name);
              }
              switch (R) {
                case "JPXDecode":
                  const U = new c.JpxImage();
                  U.parseImageProperties(u.stream), u.stream.reset(), u.width = U.width, u.height = U.height, u.bitsPerComponent = U.bitsPerComponent, u.numComps = U.componentsCount;
                  break;
                case "JBIG2Decode":
                  u.bitsPerComponent = 1, u.numComps = 1;
                  break;
              }
              let k = X.get("W", "Width"), x = X.get("H", "Height");
              if (Number.isInteger(u.width) && u.width > 0 && Number.isInteger(u.height) && u.height > 0 && (u.width !== k || u.height !== x) && ((0, t.warn)("PDFImage - using the Width/Height of the image data, rather than the image dictionary."), k = u.width, x = u.height), k < 1 || x < 1)
                throw new t.FormatError(`Invalid image width: ${k} or height: ${x}`);
              this.width = k, this.height = x, this.interpolate = X.get("I", "Interpolate"), this.imageMask = X.get("IM", "ImageMask") || !1, this.matte = X.get("Matte") || !1;
              let f = u.bitsPerComponent;
              if (!f && (f = X.get("BPC", "BitsPerComponent"), !f))
                if (this.imageMask)
                  f = 1;
                else
                  throw new t.FormatError(`Bits per component missing in image: ${this.imageMask}`);
              if (this.bpc = f, !this.imageMask) {
                let U = X.getRaw("CS") || X.getRaw("ColorSpace");
                if (!U)
                  switch ((0, t.info)("JPX images (which do not require color spaces)"), u.numComps) {
                    case 1:
                      U = d.Name.get("DeviceGray");
                      break;
                    case 3:
                      U = d.Name.get("DeviceRGB");
                      break;
                    case 4:
                      U = d.Name.get("DeviceCMYK");
                      break;
                    default:
                      throw new Error(`JPX images with ${u.numComps} color components not supported.`);
                  }
                this.colorSpace = h.ColorSpace.parse({
                  cs: U,
                  xref: i,
                  resources: w ? l : null,
                  pdfFunctionFactory: Y,
                  localColorSpaceCache: j
                }), this.numComps = this.colorSpace.numComps;
              }
              if (this.decode = X.getArray("D", "Decode"), this.needsDecode = !1, this.decode && (this.colorSpace && !this.colorSpace.isDefaultDecode(this.decode, f) || A && !h.ColorSpace.isDefaultDecode(this.decode, 1))) {
                this.needsDecode = !0;
                const U = (1 << f) - 1;
                this.decodeCoefficients = [], this.decodeAddends = [];
                const O = this.colorSpace && this.colorSpace.name === "Indexed";
                for (let S = 0, F = 0; S < this.decode.length; S += 2, ++F) {
                  const T = this.decode[S], I = this.decode[S + 1];
                  this.decodeCoefficients[F] = O ? (I - T) / U : I - T, this.decodeAddends[F] = O ? T : U * T;
                }
              }
              _ ? this.smask = new g({
                xref: i,
                res: l,
                image: _,
                isInline: w,
                pdfFunctionFactory: Y,
                localColorSpaceCache: j
              }) : b && (b instanceof v.BaseStream ? b.dict.get("IM", "ImageMask") ? this.mask = new g({
                xref: i,
                res: l,
                image: b,
                isInline: w,
                isMask: !0,
                pdfFunctionFactory: Y,
                localColorSpaceCache: j
              }) : (0, t.warn)("Ignoring /Mask in image without /ImageMask.") : this.mask = b);
            }
            static async buildImage({
              xref: i,
              res: l,
              image: u,
              isInline: w = !1,
              pdfFunctionFactory: _,
              localColorSpaceCache: b
            }) {
              const A = u;
              let Y = null, j = null;
              const X = u.dict.get("SMask"), B = u.dict.get("Mask");
              return X ? X instanceof v.BaseStream ? Y = X : (0, t.warn)("Unsupported /SMask format.") : B && (B instanceof v.BaseStream || Array.isArray(B) ? j = B : (0, t.warn)("Unsupported /Mask format.")), new g({
                xref: i,
                res: l,
                image: A,
                isInline: w,
                smask: Y,
                mask: j,
                pdfFunctionFactory: _,
                localColorSpaceCache: b
              });
            }
            static createRawMask({
              imgArray: i,
              width: l,
              height: u,
              imageIsFromDecodeStream: w,
              inverseDecode: _,
              interpolate: b
            }) {
              const A = (l + 7 >> 3) * u, Y = i.byteLength, j = A === Y;
              let X, B;
              if (w && (!_ || j) ? X = i : _ ? (X = new Uint8Array(A), X.set(i), X.fill(255, Y)) : X = new Uint8Array(i), _)
                for (B = 0; B < Y; B++)
                  X[B] ^= 255;
              return {
                data: X,
                width: l,
                height: u,
                interpolate: b
              };
            }
            static createMask({
              imgArray: i,
              width: l,
              height: u,
              imageIsFromDecodeStream: w,
              inverseDecode: _,
              interpolate: b
            }) {
              const A = l === 1 && u === 1 && _ === (i.length === 0 || !!(i[0] & 128));
              if (A)
                return {
                  isSingleOpaquePixel: A
                };
              if (t.FeatureTest.isOffscreenCanvasSupported) {
                const Y = new OffscreenCanvas(l, u), j = Y.getContext("2d"), X = j.createImageData(l, u);
                (0, a.applyMaskImageData)({
                  src: i,
                  dest: X.data,
                  width: l,
                  height: u,
                  inverseDecode: _
                }), j.putImageData(X, 0, 0);
                const B = Y.transferToImageBitmap();
                return {
                  data: null,
                  width: l,
                  height: u,
                  interpolate: b,
                  bitmap: B
                };
              }
              return this.createRawMask({
                imgArray: i,
                width: l,
                height: u,
                inverseDecode: _,
                imageIsFromDecodeStream: w,
                interpolate: b
              });
            }
            get drawWidth() {
              return Math.max(this.width, this.smask && this.smask.width || 0, this.mask && this.mask.width || 0);
            }
            get drawHeight() {
              return Math.max(this.height, this.smask && this.smask.height || 0, this.mask && this.mask.height || 0);
            }
            decodeBuffer(i) {
              const l = this.bpc, u = this.numComps, w = this.decodeAddends, _ = this.decodeCoefficients, b = (1 << l) - 1;
              let A, Y;
              if (l === 1) {
                for (A = 0, Y = i.length; A < Y; A++)
                  i[A] = +!i[A];
                return;
              }
              let j = 0;
              for (A = 0, Y = this.width * this.height; A < Y; A++)
                for (let X = 0; X < u; X++)
                  i[j] = p(i[j], w[X], _[X], b), j++;
            }
            getComponents(i) {
              const l = this.bpc;
              if (l === 8)
                return i;
              const u = this.width, w = this.height, _ = this.numComps, b = u * w * _;
              let A = 0, Y;
              l <= 8 ? Y = new Uint8Array(b) : l <= 16 ? Y = new Uint16Array(b) : Y = new Uint32Array(b);
              const j = u * _, X = (1 << l) - 1;
              let B = 0, R, k;
              if (l === 1) {
                let x, f, U;
                for (let O = 0; O < w; O++) {
                  for (f = B + (j & -8), U = B + j; B < f; )
                    k = i[A++], Y[B] = k >> 7 & 1, Y[B + 1] = k >> 6 & 1, Y[B + 2] = k >> 5 & 1, Y[B + 3] = k >> 4 & 1, Y[B + 4] = k >> 3 & 1, Y[B + 5] = k >> 2 & 1, Y[B + 6] = k >> 1 & 1, Y[B + 7] = k & 1, B += 8;
                  if (B < U)
                    for (k = i[A++], x = 128; B < U; )
                      Y[B++] = +!!(k & x), x >>= 1;
                }
              } else {
                let x = 0;
                for (k = 0, B = 0, R = b; B < R; ++B) {
                  for (B % j === 0 && (k = 0, x = 0); x < l; )
                    k = k << 8 | i[A++], x += 8;
                  const f = x - l;
                  let U = k >> f;
                  U < 0 ? U = 0 : U > X && (U = X), Y[B] = U, k &= (1 << f) - 1, x = f;
                }
              }
              return Y;
            }
            fillOpacity(i, l, u, w, _) {
              const b = this.smask, A = this.mask;
              let Y, j, X, B, R, k;
              if (b)
                j = b.width, X = b.height, Y = new Uint8ClampedArray(j * X), b.fillGrayBuffer(Y), (j !== l || X !== u) && (Y = m(Y, b.bpc, j, X, l, u));
              else if (A)
                if (A instanceof g) {
                  for (j = A.width, X = A.height, Y = new Uint8ClampedArray(j * X), A.numComps = 1, A.fillGrayBuffer(Y), B = 0, R = j * X; B < R; ++B)
                    Y[B] = 255 - Y[B];
                  (j !== l || X !== u) && (Y = m(Y, A.bpc, j, X, l, u));
                } else if (Array.isArray(A)) {
                  Y = new Uint8ClampedArray(l * u);
                  const x = this.numComps;
                  for (B = 0, R = l * u; B < R; ++B) {
                    let f = 0;
                    const U = B * x;
                    for (k = 0; k < x; ++k) {
                      const O = _[U + k], S = k * 2;
                      if (O < A[S] || O > A[S + 1]) {
                        f = 255;
                        break;
                      }
                    }
                    Y[B] = f;
                  }
                } else
                  throw new t.FormatError("Unknown mask format.");
              if (Y)
                for (B = 0, k = 3, R = l * w; B < R; ++B, k += 4)
                  i[k] = Y[B];
              else
                for (B = 0, k = 3, R = l * w; B < R; ++B, k += 4)
                  i[k] = 255;
            }
            undoPreblend(i, l, u) {
              const w = this.smask && this.smask.matte;
              if (!w)
                return;
              const _ = this.colorSpace.getRgb(w, 0), b = _[0], A = _[1], Y = _[2], j = l * u * 4;
              for (let X = 0; X < j; X += 4) {
                const B = i[X + 3];
                if (B === 0) {
                  i[X] = 255, i[X + 1] = 255, i[X + 2] = 255;
                  continue;
                }
                const R = 255 / B;
                i[X] = (i[X] - b) * R + b, i[X + 1] = (i[X + 1] - A) * R + A, i[X + 2] = (i[X + 2] - Y) * R + Y;
              }
            }
            createImageData(i = !1) {
              const l = this.drawWidth, u = this.drawHeight, w = {
                width: l,
                height: u,
                interpolate: this.interpolate,
                kind: 0,
                data: null
              }, _ = this.numComps, b = this.width, A = this.height, Y = this.bpc, j = b * _ * Y + 7 >> 3;
              if (!i) {
                let f;
                if (this.colorSpace.name === "DeviceGray" && Y === 1 ? f = t.ImageKind.GRAYSCALE_1BPP : this.colorSpace.name === "DeviceRGB" && Y === 8 && !this.needsDecode && (f = t.ImageKind.RGB_24BPP), f && !this.smask && !this.mask && l === b && u === A) {
                  if (w.kind = f, w.data = this.getImageBytes(A * j, {}), this.needsDecode) {
                    (0, t.assert)(f === t.ImageKind.GRAYSCALE_1BPP, "PDFImage.createImageData: The image must be grayscale.");
                    const U = w.data;
                    for (let O = 0, S = U.length; O < S; O++)
                      U[O] ^= 255;
                  }
                  return w;
                }
                if (this.image instanceof y.JpegStream && !this.smask && !this.mask) {
                  let U = A * j;
                  switch (this.colorSpace.name) {
                    case "DeviceGray":
                      U *= 3;
                    case "DeviceRGB":
                    case "DeviceCMYK":
                      return w.kind = t.ImageKind.RGB_24BPP, w.data = this.getImageBytes(U, {
                        drawWidth: l,
                        drawHeight: u,
                        forceRGB: !0
                      }), w;
                  }
                }
              }
              const X = this.getImageBytes(A * j, {
                internal: !0
              }), B = 0 | X.length / j * u / A, R = this.getComponents(X);
              let k, x;
              return !i && !this.smask && !this.mask ? (w.kind = t.ImageKind.RGB_24BPP, w.data = new Uint8ClampedArray(l * u * 3), k = 0, x = !1) : (w.kind = t.ImageKind.RGBA_32BPP, w.data = new Uint8ClampedArray(l * u * 4), k = 1, x = !0, this.fillOpacity(w.data, l, u, B, R)), this.needsDecode && this.decodeBuffer(R), this.colorSpace.fillRgb(w.data, b, A, l, u, B, Y, R, k), x && this.undoPreblend(w.data, l, B), w;
            }
            fillGrayBuffer(i) {
              const l = this.numComps;
              if (l !== 1)
                throw new t.FormatError(`Reading gray scale from a color image: ${l}`);
              const u = this.width, w = this.height, _ = this.bpc, b = u * l * _ + 7 >> 3, A = this.getImageBytes(w * b, {
                internal: !0
              }), Y = this.getComponents(A);
              let j, X;
              if (_ === 1) {
                if (X = u * w, this.needsDecode)
                  for (j = 0; j < X; ++j)
                    i[j] = Y[j] - 1 & 255;
                else
                  for (j = 0; j < X; ++j)
                    i[j] = -Y[j] & 255;
                return;
              }
              this.needsDecode && this.decodeBuffer(Y), X = u * w;
              const B = 255 / ((1 << _) - 1);
              for (j = 0; j < X; ++j)
                i[j] = B * Y[j];
            }
            getImageBytes(i, {
              drawWidth: l,
              drawHeight: u,
              forceRGB: w = !1,
              internal: _ = !1
            }) {
              this.image.reset(), this.image.drawWidth = l || this.width, this.image.drawHeight = u || this.height, this.image.forceRGB = !!w;
              const b = this.image.getBytes(i);
              return _ || this.image instanceof e.DecodeStream ? b : ((0, t.assert)(b instanceof Uint8Array, 'PDFImage.getImageBytes: Unsupported "imageBytes" type.'), new Uint8Array(b));
            }
          }
          o.PDFImage = g;
        },
        /* 64 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.applyMaskImageData = a;
          var t = C(2);
          function a({
            src: v,
            srcPos: h = 0,
            dest: e,
            destPos: y = 0,
            width: c,
            height: d,
            inverseDecode: p = !1
          }) {
            const m = t.FeatureTest.isLittleEndian ? 4278190080 : 255, [g, n] = p ? [0, m] : [m, 0], i = c >> 3, l = c & 7, u = v.length;
            e = new Uint32Array(e.buffer);
            for (let w = 0; w < d; w++) {
              for (const b = h + i; h < b; h++) {
                const A = h < u ? v[h] : 255;
                e[y++] = A & 128 ? n : g, e[y++] = A & 64 ? n : g, e[y++] = A & 32 ? n : g, e[y++] = A & 16 ? n : g, e[y++] = A & 8 ? n : g, e[y++] = A & 4 ? n : g, e[y++] = A & 2 ? n : g, e[y++] = A & 1 ? n : g;
              }
              if (l === 0)
                continue;
              const _ = h < u ? v[h++] : 255;
              for (let b = 0; b < l; b++)
                e[y++] = _ & 1 << 7 - b ? n : g;
            }
            return {
              srcPos: h,
              destPos: y
            };
          }
        },
        /* 65 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.incrementalUpdate = _, o.writeDict = d, o.writeObject = c;
          var t = C(2), a = C(5), v = C(6), h = C(66), e = C(7), y = C(67);
          function c(b, A, Y, j) {
            Y.push(`${b.num} ${b.gen} obj
`), A instanceof a.Dict ? d(A, Y, j) : A instanceof e.BaseStream && p(A, Y, j), Y.push(`
endobj
`);
          }
          function d(b, A, Y) {
            A.push("<<");
            for (const j of b.getKeys())
              A.push(` /${(0, v.escapePDFName)(j)} `), g(b.getRaw(j), A, Y);
            A.push(">>");
          }
          function p(b, A, Y) {
            d(b.dict, A, Y), A.push(` stream
`);
            let j = b.getString();
            Y !== null && (j = Y.encryptString(j)), A.push(j, `
endstream
`);
          }
          function m(b, A, Y) {
            A.push("[");
            let j = !0;
            for (const X of b)
              j ? j = !1 : A.push(" "), g(X, A, Y);
            A.push("]");
          }
          function g(b, A, Y) {
            b instanceof a.Name ? A.push(`/${(0, v.escapePDFName)(b.name)}`) : b instanceof a.Ref ? A.push(`${b.num} ${b.gen} R`) : Array.isArray(b) ? m(b, A, Y) : typeof b == "string" ? (Y !== null && (b = Y.encryptString(b)), A.push(`(${(0, t.escapeString)(b)})`)) : typeof b == "number" ? A.push((0, v.numberToString)(b)) : typeof b == "boolean" ? A.push(b.toString()) : b instanceof a.Dict ? d(b, A, Y) : b instanceof e.BaseStream ? p(b, A, Y) : b === null ? A.push("null") : (0, t.warn)(`Unhandled value in writer: ${typeof b}, please file a bug.`);
          }
          function n(b, A, Y, j) {
            for (let X = A + Y - 1; X > Y - 1; X--)
              j[X] = b & 255, b >>= 8;
            return Y + A;
          }
          function i(b, A, Y) {
            for (let j = 0, X = b.length; j < X; j++)
              Y[A + j] = b.charCodeAt(j) & 255;
          }
          function l(b, A) {
            const Y = Math.floor(Date.now() / 1e3), j = A.filename || "", X = [Y.toString(), j, b.toString()];
            let B = X.reduce((x, f) => x + f.length, 0);
            for (const x of Object.values(A.info))
              X.push(x), B += x.length;
            const R = new Uint8Array(B);
            let k = 0;
            for (const x of X)
              i(x, k, R), k += x.length;
            return (0, t.bytesToString)((0, y.calculateMD5)(R));
          }
          function u(b, A) {
            const Y = new h.SimpleXMLParser({
              hasAttributes: !0
            }).parseFromString(b);
            for (const {
              xfa: X
            } of A) {
              if (!X)
                continue;
              const {
                path: B,
                value: R
              } = X;
              if (!B)
                continue;
              const k = Y.documentElement.searchNode((0, v.parseXFAPath)(B), 0);
              k ? Array.isArray(R) ? k.childNodes = R.map((x) => new h.SimpleDOMNode("value", x)) : k.childNodes = [new h.SimpleDOMNode("#text", R)] : (0, t.warn)(`Node not found for path: ${B}`);
            }
            const j = [];
            return Y.documentElement.dump(j), j.join("");
          }
          function w({
            xfaData: b,
            xfaDatasetsRef: A,
            hasXfaDatasetsEntry: Y,
            acroFormRef: j,
            acroForm: X,
            newRefs: B,
            xref: R,
            xrefInfo: k
          }) {
            if (R === null)
              return;
            if (!Y) {
              if (!j) {
                (0, t.warn)("XFA - Cannot save it");
                return;
              }
              const U = X.get("XFA"), O = U.slice();
              O.splice(2, 0, "datasets"), O.splice(3, 0, A), X.set("XFA", O);
              const S = R.encrypt;
              let F = null;
              S && (F = S.createCipherTransform(j.num, j.gen));
              const T = [`${j.num} ${j.gen} obj
`];
              d(X, T, F), T.push(`
`), X.set("XFA", U), B.push({
                ref: j,
                data: T.join("")
              });
            }
            if (b === null) {
              const U = R.fetchIfRef(A);
              b = u(U.getString(), B);
            }
            const x = R.encrypt;
            x && (b = x.createCipherTransform(A.num, A.gen).encryptString(b));
            const f = `${A.num} ${A.gen} obj
<< /Type /EmbeddedFile /Length ${b.length}>>
stream
` + b + `
endstream
endobj
`;
            B.push({
              ref: A,
              data: f
            });
          }
          function _({
            originalData: b,
            xrefInfo: A,
            newRefs: Y,
            xref: j = null,
            hasXfa: X = !1,
            xfaDatasetsRef: B = null,
            hasXfaDatasetsEntry: R = !1,
            acroFormRef: k = null,
            acroForm: x = null,
            xfaData: f = null
          }) {
            X && w({
              xfaData: f,
              xfaDatasetsRef: B,
              hasXfaDatasetsEntry: R,
              acroFormRef: k,
              acroForm: x,
              newRefs: Y,
              xref: j,
              xrefInfo: A
            });
            const U = new a.Dict(null), O = A.newRef;
            let S, F;
            const T = b.at(-1);
            T === 10 || T === 13 ? (S = [], F = b.length) : (S = [`
`], F = b.length + 1), U.set("Size", O.num + 1), U.set("Prev", A.startXRef), U.set("Type", a.Name.get("XRef")), A.rootRef !== null && U.set("Root", A.rootRef), A.infoRef !== null && U.set("Info", A.infoRef), A.encryptRef !== null && U.set("Encrypt", A.encryptRef), Y.push({
              ref: O,
              data: ""
            }), Y = Y.sort((q, N) => q.ref.num - N.ref.num);
            const I = [[0, 1, 65535]], M = [0, 1];
            let V = 0;
            for (const {
              ref: q,
              data: N
            } of Y)
              V = Math.max(V, F), I.push([1, F, Math.min(q.gen, 65535)]), F += N.length, M.push(q.num, 1), S.push(N);
            if (U.set("Index", M), Array.isArray(A.fileIds) && A.fileIds.length > 0) {
              const q = l(F, A);
              U.set("ID", [A.fileIds[0], q]);
            }
            const W = [1, Math.ceil(Math.log2(V) / 8), 2], G = (W[0] + W[1] + W[2]) * I.length;
            U.set("W", W), U.set("Length", G), S.push(`${O.num} ${O.gen} obj
`), d(U, S, null), S.push(` stream
`);
            const L = S.reduce((q, N) => q + N.length, 0), K = `
endstream
endobj
startxref
${F}
%%EOF
`, te = new Uint8Array(b.length + L + G + K.length);
            te.set(b);
            let se = b.length;
            for (const q of S)
              i(q, se, te), se += q.length;
            for (const [q, N, Q] of I)
              se = n(q, W[0], se, te), se = n(N, W[1], se, te), se = n(Q, W[2], se, te);
            return i(K, se, te), te;
          }
        },
        /* 66 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.XMLParserErrorCode = o.XMLParserBase = o.SimpleXMLParser = o.SimpleDOMNode = void 0;
          var t = C(6);
          const a = {
            NoError: 0,
            EndOfDocument: -1,
            UnterminatedCdat: -2,
            UnterminatedXmlDeclaration: -3,
            UnterminatedDoctypeDeclaration: -4,
            UnterminatedComment: -5,
            MalformedElement: -6,
            OutOfMemory: -7,
            UnterminatedAttributeValue: -8,
            UnterminatedElement: -9,
            ElementNeverBegun: -10
          };
          o.XMLParserErrorCode = a;
          function v(d, p) {
            const m = d[p];
            return m === " " || m === `
` || m === "\r" || m === "	";
          }
          function h(d) {
            for (let p = 0, m = d.length; p < m; p++)
              if (!v(d, p))
                return !1;
            return !0;
          }
          class e {
            _resolveEntities(p) {
              return p.replace(/&([^;]+);/g, (m, g) => {
                if (g.substring(0, 2) === "#x")
                  return String.fromCodePoint(parseInt(g.substring(2), 16));
                if (g.substring(0, 1) === "#")
                  return String.fromCodePoint(parseInt(g.substring(1), 10));
                switch (g) {
                  case "lt":
                    return "<";
                  case "gt":
                    return ">";
                  case "amp":
                    return "&";
                  case "quot":
                    return '"';
                  case "apos":
                    return "'";
                }
                return this.onResolveEntity(g);
              });
            }
            _parseContent(p, m) {
              const g = [];
              let n = m;
              function i() {
                for (; n < p.length && v(p, n); )
                  ++n;
              }
              for (; n < p.length && !v(p, n) && p[n] !== ">" && p[n] !== "/"; )
                ++n;
              const l = p.substring(m, n);
              for (i(); n < p.length && p[n] !== ">" && p[n] !== "/" && p[n] !== "?"; ) {
                i();
                let u = "", w = "";
                for (; n < p.length && !v(p, n) && p[n] !== "="; )
                  u += p[n], ++n;
                if (i(), p[n] !== "=")
                  return null;
                ++n, i();
                const _ = p[n];
                if (_ !== '"' && _ !== "'")
                  return null;
                const b = p.indexOf(_, ++n);
                if (b < 0)
                  return null;
                w = p.substring(n, b), g.push({
                  name: u,
                  value: this._resolveEntities(w)
                }), n = b + 1, i();
              }
              return {
                name: l,
                attributes: g,
                parsed: n - m
              };
            }
            _parseProcessingInstruction(p, m) {
              let g = m;
              function n() {
                for (; g < p.length && v(p, g); )
                  ++g;
              }
              for (; g < p.length && !v(p, g) && p[g] !== ">" && p[g] !== "?" && p[g] !== "/"; )
                ++g;
              const i = p.substring(m, g);
              n();
              const l = g;
              for (; g < p.length && (p[g] !== "?" || p[g + 1] !== ">"); )
                ++g;
              const u = p.substring(l, g);
              return {
                name: i,
                value: u,
                parsed: g - m
              };
            }
            parseXml(p) {
              let m = 0;
              for (; m < p.length; ) {
                const g = p[m];
                let n = m;
                if (g === "<") {
                  ++n;
                  const i = p[n];
                  let l;
                  switch (i) {
                    case "/":
                      if (++n, l = p.indexOf(">", n), l < 0) {
                        this.onError(a.UnterminatedElement);
                        return;
                      }
                      this.onEndElement(p.substring(n, l)), n = l + 1;
                      break;
                    case "?":
                      ++n;
                      const u = this._parseProcessingInstruction(p, n);
                      if (p.substring(n + u.parsed, n + u.parsed + 2) !== "?>") {
                        this.onError(a.UnterminatedXmlDeclaration);
                        return;
                      }
                      this.onPi(u.name, u.value), n += u.parsed + 2;
                      break;
                    case "!":
                      if (p.substring(n + 1, n + 3) === "--") {
                        if (l = p.indexOf("-->", n + 3), l < 0) {
                          this.onError(a.UnterminatedComment);
                          return;
                        }
                        this.onComment(p.substring(n + 3, l)), n = l + 3;
                      } else if (p.substring(n + 1, n + 8) === "[CDATA[") {
                        if (l = p.indexOf("]]>", n + 8), l < 0) {
                          this.onError(a.UnterminatedCdat);
                          return;
                        }
                        this.onCdata(p.substring(n + 8, l)), n = l + 3;
                      } else if (p.substring(n + 1, n + 8) === "DOCTYPE") {
                        const b = p.indexOf("[", n + 8);
                        let A = !1;
                        if (l = p.indexOf(">", n + 8), l < 0) {
                          this.onError(a.UnterminatedDoctypeDeclaration);
                          return;
                        }
                        if (b > 0 && l > b) {
                          if (l = p.indexOf("]>", n + 8), l < 0) {
                            this.onError(a.UnterminatedDoctypeDeclaration);
                            return;
                          }
                          A = !0;
                        }
                        const Y = p.substring(n + 8, l + (A ? 1 : 0));
                        this.onDoctype(Y), n = l + (A ? 2 : 1);
                      } else {
                        this.onError(a.MalformedElement);
                        return;
                      }
                      break;
                    default:
                      const w = this._parseContent(p, n);
                      if (w === null) {
                        this.onError(a.MalformedElement);
                        return;
                      }
                      let _ = !1;
                      if (p.substring(n + w.parsed, n + w.parsed + 2) === "/>")
                        _ = !0;
                      else if (p.substring(n + w.parsed, n + w.parsed + 1) !== ">") {
                        this.onError(a.UnterminatedElement);
                        return;
                      }
                      this.onBeginElement(w.name, w.attributes, _), n += w.parsed + (_ ? 2 : 1);
                      break;
                  }
                } else {
                  for (; n < p.length && p[n] !== "<"; )
                    n++;
                  const i = p.substring(m, n);
                  this.onText(this._resolveEntities(i));
                }
                m = n;
              }
            }
            onResolveEntity(p) {
              return `&${p};`;
            }
            onPi(p, m) {
            }
            onComment(p) {
            }
            onCdata(p) {
            }
            onDoctype(p) {
            }
            onText(p) {
            }
            onBeginElement(p, m, g) {
            }
            onEndElement(p) {
            }
            onError(p) {
            }
          }
          o.XMLParserBase = e;
          class y {
            constructor(p, m) {
              this.nodeName = p, this.nodeValue = m, Object.defineProperty(this, "parentNode", {
                value: null,
                writable: !0
              });
            }
            get firstChild() {
              return this.childNodes && this.childNodes[0];
            }
            get nextSibling() {
              const p = this.parentNode.childNodes;
              if (!p)
                return;
              const m = p.indexOf(this);
              if (m !== -1)
                return p[m + 1];
            }
            get textContent() {
              return this.childNodes ? this.childNodes.map(function(p) {
                return p.textContent;
              }).join("") : this.nodeValue || "";
            }
            get children() {
              return this.childNodes || [];
            }
            hasChildNodes() {
              return this.childNodes && this.childNodes.length > 0;
            }
            searchNode(p, m) {
              if (m >= p.length)
                return this;
              const g = p[m], n = [];
              let i = this;
              for (; ; ) {
                if (g.name === i.nodeName)
                  if (g.pos === 0) {
                    const l = i.searchNode(p, m + 1);
                    if (l !== null)
                      return l;
                  } else {
                    if (n.length === 0)
                      return null;
                    {
                      const [l] = n.pop();
                      let u = 0;
                      for (const w of l.childNodes)
                        if (g.name === w.nodeName) {
                          if (u === g.pos)
                            return w.searchNode(p, m + 1);
                          u++;
                        }
                      return i.searchNode(p, m + 1);
                    }
                  }
                if (i.childNodes && i.childNodes.length !== 0)
                  n.push([i, 0]), i = i.childNodes[0];
                else {
                  if (n.length === 0)
                    return null;
                  for (; n.length !== 0; ) {
                    const [l, u] = n.pop(), w = u + 1;
                    if (w < l.childNodes.length) {
                      n.push([l, w]), i = l.childNodes[w];
                      break;
                    }
                  }
                  if (n.length === 0)
                    return null;
                }
              }
            }
            dump(p) {
              if (this.nodeName === "#text") {
                p.push((0, t.encodeToXmlString)(this.nodeValue));
                return;
              }
              if (p.push(`<${this.nodeName}`), this.attributes)
                for (const m of this.attributes)
                  p.push(` ${m.name}="${(0, t.encodeToXmlString)(m.value)}"`);
              if (this.hasChildNodes()) {
                p.push(">");
                for (const m of this.childNodes)
                  m.dump(p);
                p.push(`</${this.nodeName}>`);
              } else
                this.nodeValue ? p.push(`>${(0, t.encodeToXmlString)(this.nodeValue)}</${this.nodeName}>`) : p.push("/>");
            }
          }
          o.SimpleDOMNode = y;
          class c extends e {
            constructor({
              hasAttributes: p = !1,
              lowerCaseName: m = !1
            }) {
              super(), this._currentFragment = null, this._stack = null, this._errorCode = a.NoError, this._hasAttributes = p, this._lowerCaseName = m;
            }
            parseFromString(p) {
              if (this._currentFragment = [], this._stack = [], this._errorCode = a.NoError, this.parseXml(p), this._errorCode !== a.NoError)
                return;
              const [m] = this._currentFragment;
              if (m)
                return {
                  documentElement: m
                };
            }
            onText(p) {
              if (h(p))
                return;
              const m = new y("#text", p);
              this._currentFragment.push(m);
            }
            onCdata(p) {
              const m = new y("#text", p);
              this._currentFragment.push(m);
            }
            onBeginElement(p, m, g) {
              this._lowerCaseName && (p = p.toLowerCase());
              const n = new y(p);
              n.childNodes = [], this._hasAttributes && (n.attributes = m), this._currentFragment.push(n), !g && (this._stack.push(this._currentFragment), this._currentFragment = n.childNodes);
            }
            onEndElement(p) {
              this._currentFragment = this._stack.pop() || [];
              const m = this._currentFragment.at(-1);
              if (!m)
                return null;
              for (let g = 0, n = m.childNodes.length; g < n; g++)
                m.childNodes[g].parentNode = m;
              return m;
            }
            onError(p) {
              this._errorCode = p;
            }
          }
          o.SimpleXMLParser = c;
        },
        /* 67 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.calculateSHA256 = o.calculateMD5 = o.PDF20 = o.PDF17 = o.CipherTransformFactory = o.ARCFourCipher = o.AES256Cipher = o.AES128Cipher = void 0, o.calculateSHA384 = p, o.calculateSHA512 = void 0;
          var t = C(2), a = C(5), v = C(68);
          class h {
            constructor(A) {
              this.a = 0, this.b = 0;
              const Y = new Uint8Array(256), j = A.length;
              for (let X = 0; X < 256; ++X)
                Y[X] = X;
              for (let X = 0, B = 0; X < 256; ++X) {
                const R = Y[X];
                B = B + R + A[X % j] & 255, Y[X] = Y[B], Y[B] = R;
              }
              this.s = Y;
            }
            encryptBlock(A) {
              let Y = this.a, j = this.b;
              const X = this.s, B = A.length, R = new Uint8Array(B);
              for (let k = 0; k < B; ++k) {
                Y = Y + 1 & 255;
                const x = X[Y];
                j = j + x & 255;
                const f = X[j];
                X[Y] = f, X[j] = x, R[k] = A[k] ^ X[x + f & 255];
              }
              return this.a = Y, this.b = j, R;
            }
            decryptBlock(A) {
              return this.encryptBlock(A);
            }
            encrypt(A) {
              return this.encryptBlock(A);
            }
          }
          o.ARCFourCipher = h;
          const e = function() {
            const A = new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]), Y = new Int32Array([-680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341, -45705983, 1770035416, -1958414417, -42063, -1990404162, 1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632, 643717713, -373897302, -701558691, 38016083, -660478335, -405537848, 568446438, -1019803690, -187363961, 1163531501, -1444681467, -51403784, 1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556, -1530992060, 1272893353, -155497632, -1094730640, 681279174, -358537222, -722521979, 76029189, -640364487, -421815835, 530742520, -995338651, -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606, -1051523, -2054922799, 1873313359, -30611744, -1560198380, 1309151649, -145523070, -1120210379, 718787259, -343485551]);
            function j(X, B, R) {
              let k = 1732584193, x = -271733879, f = -1732584194, U = 271733878;
              const O = R + 72 & -64, S = new Uint8Array(O);
              let F, T;
              for (F = 0; F < R; ++F)
                S[F] = X[B++];
              S[F++] = 128;
              const I = O - 8;
              for (; F < I; )
                S[F++] = 0;
              S[F++] = R << 3 & 255, S[F++] = R >> 5 & 255, S[F++] = R >> 13 & 255, S[F++] = R >> 21 & 255, S[F++] = R >>> 29 & 255, S[F++] = 0, S[F++] = 0, S[F++] = 0;
              const M = new Int32Array(16);
              for (F = 0; F < O; ) {
                for (T = 0; T < 16; ++T, F += 4)
                  M[T] = S[F] | S[F + 1] << 8 | S[F + 2] << 16 | S[F + 3] << 24;
                let V = k, J = x, W = f, z = U, G, L;
                for (T = 0; T < 64; ++T) {
                  T < 16 ? (G = J & W | ~J & z, L = T) : T < 32 ? (G = z & J | ~z & W, L = 5 * T + 1 & 15) : T < 48 ? (G = J ^ W ^ z, L = 3 * T + 5 & 15) : (G = W ^ (J | ~z), L = 7 * T & 15);
                  const K = z, te = V + G + Y[T] + M[L] | 0, se = A[T];
                  z = W, W = J, J = J + (te << se | te >>> 32 - se) | 0, V = K;
                }
                k = k + V | 0, x = x + J | 0, f = f + W | 0, U = U + z | 0;
              }
              return new Uint8Array([k & 255, k >> 8 & 255, k >> 16 & 255, k >>> 24 & 255, x & 255, x >> 8 & 255, x >> 16 & 255, x >>> 24 & 255, f & 255, f >> 8 & 255, f >> 16 & 255, f >>> 24 & 255, U & 255, U >> 8 & 255, U >> 16 & 255, U >>> 24 & 255]);
            }
            return j;
          }();
          o.calculateMD5 = e;
          class y {
            constructor(A, Y) {
              this.high = A | 0, this.low = Y | 0;
            }
            and(A) {
              this.high &= A.high, this.low &= A.low;
            }
            xor(A) {
              this.high ^= A.high, this.low ^= A.low;
            }
            or(A) {
              this.high |= A.high, this.low |= A.low;
            }
            shiftRight(A) {
              A >= 32 ? (this.low = this.high >>> A - 32 | 0, this.high = 0) : (this.low = this.low >>> A | this.high << 32 - A, this.high = this.high >>> A | 0);
            }
            shiftLeft(A) {
              A >= 32 ? (this.high = this.low << A - 32, this.low = 0) : (this.high = this.high << A | this.low >>> 32 - A, this.low <<= A);
            }
            rotateRight(A) {
              let Y, j;
              A & 32 ? (j = this.low, Y = this.high) : (Y = this.low, j = this.high), A &= 31, this.low = Y >>> A | j << 32 - A, this.high = j >>> A | Y << 32 - A;
            }
            not() {
              this.high = ~this.high, this.low = ~this.low;
            }
            add(A) {
              const Y = (this.low >>> 0) + (A.low >>> 0);
              let j = (this.high >>> 0) + (A.high >>> 0);
              Y > 4294967295 && (j += 1), this.low = Y | 0, this.high = j | 0;
            }
            copyTo(A, Y) {
              A[Y] = this.high >>> 24 & 255, A[Y + 1] = this.high >> 16 & 255, A[Y + 2] = this.high >> 8 & 255, A[Y + 3] = this.high & 255, A[Y + 4] = this.low >>> 24 & 255, A[Y + 5] = this.low >> 16 & 255, A[Y + 6] = this.low >> 8 & 255, A[Y + 7] = this.low & 255;
            }
            assign(A) {
              this.high = A.high, this.low = A.low;
            }
          }
          const c = function() {
            function A(U, O) {
              return U >>> O | U << 32 - O;
            }
            function Y(U, O, S) {
              return U & O ^ ~U & S;
            }
            function j(U, O, S) {
              return U & O ^ U & S ^ O & S;
            }
            function X(U) {
              return A(U, 2) ^ A(U, 13) ^ A(U, 22);
            }
            function B(U) {
              return A(U, 6) ^ A(U, 11) ^ A(U, 25);
            }
            function R(U) {
              return A(U, 7) ^ A(U, 18) ^ U >>> 3;
            }
            function k(U) {
              return A(U, 17) ^ A(U, 19) ^ U >>> 10;
            }
            const x = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
            function f(U, O, S) {
              let F = 1779033703, T = 3144134277, I = 1013904242, M = 2773480762, V = 1359893119, J = 2600822924, W = 528734635, z = 1541459225;
              const G = Math.ceil((S + 9) / 64) * 64, L = new Uint8Array(G);
              let K, te;
              for (K = 0; K < S; ++K)
                L[K] = U[O++];
              L[K++] = 128;
              const se = G - 8;
              for (; K < se; )
                L[K++] = 0;
              L[K++] = 0, L[K++] = 0, L[K++] = 0, L[K++] = S >>> 29 & 255, L[K++] = S >> 21 & 255, L[K++] = S >> 13 & 255, L[K++] = S >> 5 & 255, L[K++] = S << 3 & 255;
              const q = new Uint32Array(64);
              for (K = 0; K < G; ) {
                for (te = 0; te < 16; ++te)
                  q[te] = L[K] << 24 | L[K + 1] << 16 | L[K + 2] << 8 | L[K + 3], K += 4;
                for (te = 16; te < 64; ++te)
                  q[te] = k(q[te - 2]) + q[te - 7] + R(q[te - 15]) + q[te - 16] | 0;
                let N = F, Q = T, D = I, ne = M, oe = V, ee = J, $ = W, E = z, H, ie;
                for (te = 0; te < 64; ++te)
                  H = E + B(oe) + Y(oe, ee, $) + x[te] + q[te], ie = X(N) + j(N, Q, D), E = $, $ = ee, ee = oe, oe = ne + H | 0, ne = D, D = Q, Q = N, N = H + ie | 0;
                F = F + N | 0, T = T + Q | 0, I = I + D | 0, M = M + ne | 0, V = V + oe | 0, J = J + ee | 0, W = W + $ | 0, z = z + E | 0;
              }
              return new Uint8Array([F >> 24 & 255, F >> 16 & 255, F >> 8 & 255, F & 255, T >> 24 & 255, T >> 16 & 255, T >> 8 & 255, T & 255, I >> 24 & 255, I >> 16 & 255, I >> 8 & 255, I & 255, M >> 24 & 255, M >> 16 & 255, M >> 8 & 255, M & 255, V >> 24 & 255, V >> 16 & 255, V >> 8 & 255, V & 255, J >> 24 & 255, J >> 16 & 255, J >> 8 & 255, J & 255, W >> 24 & 255, W >> 16 & 255, W >> 8 & 255, W & 255, z >> 24 & 255, z >> 16 & 255, z >> 8 & 255, z & 255]);
            }
            return f;
          }();
          o.calculateSHA256 = c;
          const d = function() {
            function A(f, U, O, S, F) {
              f.assign(U), f.and(O), F.assign(U), F.not(), F.and(S), f.xor(F);
            }
            function Y(f, U, O, S, F) {
              f.assign(U), f.and(O), F.assign(U), F.and(S), f.xor(F), F.assign(O), F.and(S), f.xor(F);
            }
            function j(f, U, O) {
              f.assign(U), f.rotateRight(28), O.assign(U), O.rotateRight(34), f.xor(O), O.assign(U), O.rotateRight(39), f.xor(O);
            }
            function X(f, U, O) {
              f.assign(U), f.rotateRight(14), O.assign(U), O.rotateRight(18), f.xor(O), O.assign(U), O.rotateRight(41), f.xor(O);
            }
            function B(f, U, O) {
              f.assign(U), f.rotateRight(1), O.assign(U), O.rotateRight(8), f.xor(O), O.assign(U), O.shiftRight(7), f.xor(O);
            }
            function R(f, U, O) {
              f.assign(U), f.rotateRight(19), O.assign(U), O.rotateRight(61), f.xor(O), O.assign(U), O.shiftRight(6), f.xor(O);
            }
            const k = [new y(1116352408, 3609767458), new y(1899447441, 602891725), new y(3049323471, 3964484399), new y(3921009573, 2173295548), new y(961987163, 4081628472), new y(1508970993, 3053834265), new y(2453635748, 2937671579), new y(2870763221, 3664609560), new y(3624381080, 2734883394), new y(310598401, 1164996542), new y(607225278, 1323610764), new y(1426881987, 3590304994), new y(1925078388, 4068182383), new y(2162078206, 991336113), new y(2614888103, 633803317), new y(3248222580, 3479774868), new y(3835390401, 2666613458), new y(4022224774, 944711139), new y(264347078, 2341262773), new y(604807628, 2007800933), new y(770255983, 1495990901), new y(1249150122, 1856431235), new y(1555081692, 3175218132), new y(1996064986, 2198950837), new y(2554220882, 3999719339), new y(2821834349, 766784016), new y(2952996808, 2566594879), new y(3210313671, 3203337956), new y(3336571891, 1034457026), new y(3584528711, 2466948901), new y(113926993, 3758326383), new y(338241895, 168717936), new y(666307205, 1188179964), new y(773529912, 1546045734), new y(1294757372, 1522805485), new y(1396182291, 2643833823), new y(1695183700, 2343527390), new y(1986661051, 1014477480), new y(2177026350, 1206759142), new y(2456956037, 344077627), new y(2730485921, 1290863460), new y(2820302411, 3158454273), new y(3259730800, 3505952657), new y(3345764771, 106217008), new y(3516065817, 3606008344), new y(3600352804, 1432725776), new y(4094571909, 1467031594), new y(275423344, 851169720), new y(430227734, 3100823752), new y(506948616, 1363258195), new y(659060556, 3750685593), new y(883997877, 3785050280), new y(958139571, 3318307427), new y(1322822218, 3812723403), new y(1537002063, 2003034995), new y(1747873779, 3602036899), new y(1955562222, 1575990012), new y(2024104815, 1125592928), new y(2227730452, 2716904306), new y(2361852424, 442776044), new y(2428436474, 593698344), new y(2756734187, 3733110249), new y(3204031479, 2999351573), new y(3329325298, 3815920427), new y(3391569614, 3928383900), new y(3515267271, 566280711), new y(3940187606, 3454069534), new y(4118630271, 4000239992), new y(116418474, 1914138554), new y(174292421, 2731055270), new y(289380356, 3203993006), new y(460393269, 320620315), new y(685471733, 587496836), new y(852142971, 1086792851), new y(1017036298, 365543100), new y(1126000580, 2618297676), new y(1288033470, 3409855158), new y(1501505948, 4234509866), new y(1607167915, 987167468), new y(1816402316, 1246189591)];
            function x(f, U, O, S = !1) {
              let F, T, I, M, V, J, W, z;
              S ? (F = new y(3418070365, 3238371032), T = new y(1654270250, 914150663), I = new y(2438529370, 812702999), M = new y(355462360, 4144912697), V = new y(1731405415, 4290775857), J = new y(2394180231, 1750603025), W = new y(3675008525, 1694076839), z = new y(1203062813, 3204075428)) : (F = new y(1779033703, 4089235720), T = new y(3144134277, 2227873595), I = new y(1013904242, 4271175723), M = new y(2773480762, 1595750129), V = new y(1359893119, 2917565137), J = new y(2600822924, 725511199), W = new y(528734635, 4215389547), z = new y(1541459225, 327033209));
              const G = Math.ceil((O + 17) / 128) * 128, L = new Uint8Array(G);
              let K, te;
              for (K = 0; K < O; ++K)
                L[K] = f[U++];
              L[K++] = 128;
              const se = G - 16;
              for (; K < se; )
                L[K++] = 0;
              L[K++] = 0, L[K++] = 0, L[K++] = 0, L[K++] = 0, L[K++] = 0, L[K++] = 0, L[K++] = 0, L[K++] = 0, L[K++] = 0, L[K++] = 0, L[K++] = 0, L[K++] = O >>> 29 & 255, L[K++] = O >> 21 & 255, L[K++] = O >> 13 & 255, L[K++] = O >> 5 & 255, L[K++] = O << 3 & 255;
              const q = new Array(80);
              for (K = 0; K < 80; K++)
                q[K] = new y(0, 0);
              let N = new y(0, 0), Q = new y(0, 0), D = new y(0, 0), ne = new y(0, 0), oe = new y(0, 0), ee = new y(0, 0), $ = new y(0, 0), E = new y(0, 0);
              const H = new y(0, 0), ie = new y(0, 0), ue = new y(0, 0), fe = new y(0, 0);
              let de;
              for (K = 0; K < G; ) {
                for (te = 0; te < 16; ++te)
                  q[te].high = L[K] << 24 | L[K + 1] << 16 | L[K + 2] << 8 | L[K + 3], q[te].low = L[K + 4] << 24 | L[K + 5] << 16 | L[K + 6] << 8 | L[K + 7], K += 8;
                for (te = 16; te < 80; ++te)
                  de = q[te], R(de, q[te - 2], fe), de.add(q[te - 7]), B(ue, q[te - 15], fe), de.add(ue), de.add(q[te - 16]);
                for (N.assign(F), Q.assign(T), D.assign(I), ne.assign(M), oe.assign(V), ee.assign(J), $.assign(W), E.assign(z), te = 0; te < 80; ++te)
                  H.assign(E), X(ue, oe, fe), H.add(ue), A(ue, oe, ee, $, fe), H.add(ue), H.add(k[te]), H.add(q[te]), j(ie, N, fe), Y(ue, N, Q, D, fe), ie.add(ue), de = E, E = $, $ = ee, ee = oe, ne.add(H), oe = ne, ne = D, D = Q, Q = N, de.assign(H), de.add(ie), N = de;
                F.add(N), T.add(Q), I.add(D), M.add(ne), V.add(oe), J.add(ee), W.add($), z.add(E);
              }
              let pe;
              return S ? (pe = new Uint8Array(48), F.copyTo(pe, 0), T.copyTo(pe, 8), I.copyTo(pe, 16), M.copyTo(pe, 24), V.copyTo(pe, 32), J.copyTo(pe, 40)) : (pe = new Uint8Array(64), F.copyTo(pe, 0), T.copyTo(pe, 8), I.copyTo(pe, 16), M.copyTo(pe, 24), V.copyTo(pe, 32), J.copyTo(pe, 40), W.copyTo(pe, 48), z.copyTo(pe, 56)), pe;
            }
            return x;
          }();
          o.calculateSHA512 = d;
          function p(b, A, Y) {
            return d(b, A, Y, !0);
          }
          class m {
            decryptBlock(A) {
              return A;
            }
            encrypt(A) {
              return A;
            }
          }
          class g {
            constructor() {
              this.constructor === g && (0, t.unreachable)("Cannot initialize AESBaseCipher."), this._s = new Uint8Array([99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22]), this._inv_s = new Uint8Array([82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125]), this._mix = new Uint32Array([0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795]), this._mixCol = new Uint8Array(256);
              for (let A = 0; A < 256; A++)
                A < 128 ? this._mixCol[A] = A << 1 : this._mixCol[A] = A << 1 ^ 27;
              this.buffer = new Uint8Array(16), this.bufferPosition = 0;
            }
            _expandKey(A) {
              (0, t.unreachable)("Cannot call `_expandKey` on the base class");
            }
            _decrypt(A, Y) {
              let j, X, B;
              const R = new Uint8Array(16);
              R.set(A);
              for (let k = 0, x = this._keySize; k < 16; ++k, ++x)
                R[k] ^= Y[x];
              for (let k = this._cyclesOfRepetition - 1; k >= 1; --k) {
                j = R[13], R[13] = R[9], R[9] = R[5], R[5] = R[1], R[1] = j, j = R[14], X = R[10], R[14] = R[6], R[10] = R[2], R[6] = j, R[2] = X, j = R[15], X = R[11], B = R[7], R[15] = R[3], R[11] = j, R[7] = X, R[3] = B;
                for (let x = 0; x < 16; ++x)
                  R[x] = this._inv_s[R[x]];
                for (let x = 0, f = k * 16; x < 16; ++x, ++f)
                  R[x] ^= Y[f];
                for (let x = 0; x < 16; x += 4) {
                  const f = this._mix[R[x]], U = this._mix[R[x + 1]], O = this._mix[R[x + 2]], S = this._mix[R[x + 3]];
                  j = f ^ U >>> 8 ^ U << 24 ^ O >>> 16 ^ O << 16 ^ S >>> 24 ^ S << 8, R[x] = j >>> 24 & 255, R[x + 1] = j >> 16 & 255, R[x + 2] = j >> 8 & 255, R[x + 3] = j & 255;
                }
              }
              j = R[13], R[13] = R[9], R[9] = R[5], R[5] = R[1], R[1] = j, j = R[14], X = R[10], R[14] = R[6], R[10] = R[2], R[6] = j, R[2] = X, j = R[15], X = R[11], B = R[7], R[15] = R[3], R[11] = j, R[7] = X, R[3] = B;
              for (let k = 0; k < 16; ++k)
                R[k] = this._inv_s[R[k]], R[k] ^= Y[k];
              return R;
            }
            _encrypt(A, Y) {
              const j = this._s;
              let X, B, R;
              const k = new Uint8Array(16);
              k.set(A);
              for (let x = 0; x < 16; ++x)
                k[x] ^= Y[x];
              for (let x = 1; x < this._cyclesOfRepetition; x++) {
                for (let f = 0; f < 16; ++f)
                  k[f] = j[k[f]];
                R = k[1], k[1] = k[5], k[5] = k[9], k[9] = k[13], k[13] = R, R = k[2], B = k[6], k[2] = k[10], k[6] = k[14], k[10] = R, k[14] = B, R = k[3], B = k[7], X = k[11], k[3] = k[15], k[7] = R, k[11] = B, k[15] = X;
                for (let f = 0; f < 16; f += 4) {
                  const U = k[f + 0], O = k[f + 1], S = k[f + 2], F = k[f + 3];
                  X = U ^ O ^ S ^ F, k[f + 0] ^= X ^ this._mixCol[U ^ O], k[f + 1] ^= X ^ this._mixCol[O ^ S], k[f + 2] ^= X ^ this._mixCol[S ^ F], k[f + 3] ^= X ^ this._mixCol[F ^ U];
                }
                for (let f = 0, U = x * 16; f < 16; ++f, ++U)
                  k[f] ^= Y[U];
              }
              for (let x = 0; x < 16; ++x)
                k[x] = j[k[x]];
              R = k[1], k[1] = k[5], k[5] = k[9], k[9] = k[13], k[13] = R, R = k[2], B = k[6], k[2] = k[10], k[6] = k[14], k[10] = R, k[14] = B, R = k[3], B = k[7], X = k[11], k[3] = k[15], k[7] = R, k[11] = B, k[15] = X;
              for (let x = 0, f = this._keySize; x < 16; ++x, ++f)
                k[x] ^= Y[f];
              return k;
            }
            _decryptBlock2(A, Y) {
              const j = A.length;
              let X = this.buffer, B = this.bufferPosition;
              const R = [];
              let k = this.iv;
              for (let U = 0; U < j; ++U) {
                if (X[B] = A[U], ++B, B < 16)
                  continue;
                const O = this._decrypt(X, this._key);
                for (let S = 0; S < 16; ++S)
                  O[S] ^= k[S];
                k = X, R.push(O), X = new Uint8Array(16), B = 0;
              }
              if (this.buffer = X, this.bufferLength = B, this.iv = k, R.length === 0)
                return new Uint8Array(0);
              let x = 16 * R.length;
              if (Y) {
                const U = R.at(-1);
                let O = U[15];
                if (O <= 16) {
                  for (let S = 15, F = 16 - O; S >= F; --S)
                    if (U[S] !== O) {
                      O = 0;
                      break;
                    }
                  x -= O, R[R.length - 1] = U.subarray(0, 16 - O);
                }
              }
              const f = new Uint8Array(x);
              for (let U = 0, O = 0, S = R.length; U < S; ++U, O += 16)
                f.set(R[U], O);
              return f;
            }
            decryptBlock(A, Y, j = null) {
              const X = A.length, B = this.buffer;
              let R = this.bufferPosition;
              if (j)
                this.iv = j;
              else {
                for (let k = 0; R < 16 && k < X; ++k, ++R)
                  B[R] = A[k];
                if (R < 16)
                  return this.bufferLength = R, new Uint8Array(0);
                this.iv = B, A = A.subarray(16);
              }
              return this.buffer = new Uint8Array(16), this.bufferLength = 0, this.decryptBlock = this._decryptBlock2, this.decryptBlock(A, Y);
            }
            encrypt(A, Y) {
              const j = A.length;
              let X = this.buffer, B = this.bufferPosition;
              const R = [];
              Y || (Y = new Uint8Array(16));
              for (let f = 0; f < j; ++f) {
                if (X[B] = A[f], ++B, B < 16)
                  continue;
                for (let O = 0; O < 16; ++O)
                  X[O] ^= Y[O];
                const U = this._encrypt(X, this._key);
                Y = U, R.push(U), X = new Uint8Array(16), B = 0;
              }
              if (this.buffer = X, this.bufferLength = B, this.iv = Y, R.length === 0)
                return new Uint8Array(0);
              const k = 16 * R.length, x = new Uint8Array(k);
              for (let f = 0, U = 0, O = R.length; f < O; ++f, U += 16)
                x.set(R[f], U);
              return x;
            }
          }
          class n extends g {
            constructor(A) {
              super(), this._cyclesOfRepetition = 10, this._keySize = 160, this._rcon = new Uint8Array([141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141]), this._key = this._expandKey(A);
            }
            _expandKey(A) {
              const j = this._s, X = this._rcon, B = new Uint8Array(176);
              B.set(A);
              for (let R = 16, k = 1; R < 176; ++k) {
                let x = B[R - 3], f = B[R - 2], U = B[R - 1], O = B[R - 4];
                x = j[x], f = j[f], U = j[U], O = j[O], x ^= X[k];
                for (let S = 0; S < 4; ++S)
                  B[R] = x ^= B[R - 16], R++, B[R] = f ^= B[R - 16], R++, B[R] = U ^= B[R - 16], R++, B[R] = O ^= B[R - 16], R++;
              }
              return B;
            }
          }
          o.AES128Cipher = n;
          class i extends g {
            constructor(A) {
              super(), this._cyclesOfRepetition = 14, this._keySize = 224, this._key = this._expandKey(A);
            }
            _expandKey(A) {
              const j = this._s, X = new Uint8Array(240);
              X.set(A);
              let B = 1, R, k, x, f;
              for (let U = 32, O = 1; U < 240; ++O) {
                U % 32 === 16 ? (R = j[R], k = j[k], x = j[x], f = j[f]) : U % 32 === 0 && (R = X[U - 3], k = X[U - 2], x = X[U - 1], f = X[U - 4], R = j[R], k = j[k], x = j[x], f = j[f], R ^= B, (B <<= 1) >= 256 && (B = (B ^ 27) & 255));
                for (let S = 0; S < 4; ++S)
                  X[U] = R ^= X[U - 32], U++, X[U] = k ^= X[U - 32], U++, X[U] = x ^= X[U - 32], U++, X[U] = f ^= X[U - 32], U++;
              }
              return X;
            }
          }
          o.AES256Cipher = i;
          class l {
            checkOwnerPassword(A, Y, j, X) {
              const B = new Uint8Array(A.length + 56);
              B.set(A, 0), B.set(Y, A.length), B.set(j, A.length + Y.length);
              const R = c(B, 0, B.length);
              return (0, t.isArrayEqual)(R, X);
            }
            checkUserPassword(A, Y, j) {
              const X = new Uint8Array(A.length + 8);
              X.set(A, 0), X.set(Y, A.length);
              const B = c(X, 0, X.length);
              return (0, t.isArrayEqual)(B, j);
            }
            getOwnerKey(A, Y, j, X) {
              const B = new Uint8Array(A.length + 56);
              B.set(A, 0), B.set(Y, A.length), B.set(j, A.length + Y.length);
              const R = c(B, 0, B.length);
              return new i(R).decryptBlock(X, !1, new Uint8Array(16));
            }
            getUserKey(A, Y, j) {
              const X = new Uint8Array(A.length + 8);
              X.set(A, 0), X.set(Y, A.length);
              const B = c(X, 0, X.length);
              return new i(B).decryptBlock(j, !1, new Uint8Array(16));
            }
          }
          o.PDF17 = l;
          const u = function() {
            function A(j, X, B) {
              let R = c(X, 0, X.length).subarray(0, 32), k = [0], x = 0;
              for (; x < 64 || k.at(-1) > x - 32; ) {
                const f = j.length + R.length + B.length, U = new Uint8Array(f);
                let O = 0;
                U.set(j, O), O += j.length, U.set(R, O), O += R.length, U.set(B, O);
                const S = new Uint8Array(f * 64);
                for (let I = 0, M = 0; I < 64; I++, M += f)
                  S.set(U, M);
                k = new n(R.subarray(0, 16)).encrypt(S, R.subarray(16, 32));
                let T = 0;
                for (let I = 0; I < 16; I++)
                  T *= 256 % 3, T %= 3, T += (k[I] >>> 0) % 3, T %= 3;
                T === 0 ? R = c(k, 0, k.length) : T === 1 ? R = p(k, 0, k.length) : T === 2 && (R = d(k, 0, k.length)), x++;
              }
              return R.subarray(0, 32);
            }
            class Y {
              hash(X, B, R) {
                return A(X, B, R);
              }
              checkOwnerPassword(X, B, R, k) {
                const x = new Uint8Array(X.length + 56);
                x.set(X, 0), x.set(B, X.length), x.set(R, X.length + B.length);
                const f = A(X, x, R);
                return (0, t.isArrayEqual)(f, k);
              }
              checkUserPassword(X, B, R) {
                const k = new Uint8Array(X.length + 8);
                k.set(X, 0), k.set(B, X.length);
                const x = A(X, k, []);
                return (0, t.isArrayEqual)(x, R);
              }
              getOwnerKey(X, B, R, k) {
                const x = new Uint8Array(X.length + 56);
                x.set(X, 0), x.set(B, X.length), x.set(R, X.length + B.length);
                const f = A(X, x, R);
                return new i(f).decryptBlock(k, !1, new Uint8Array(16));
              }
              getUserKey(X, B, R) {
                const k = new Uint8Array(X.length + 8);
                k.set(X, 0), k.set(B, X.length);
                const x = A(X, k, []);
                return new i(x).decryptBlock(R, !1, new Uint8Array(16));
              }
            }
            return Y;
          }();
          o.PDF20 = u;
          class w {
            constructor(A, Y) {
              this.StringCipherConstructor = A, this.StreamCipherConstructor = Y;
            }
            createStream(A, Y) {
              const j = new this.StreamCipherConstructor();
              return new v.DecryptStream(A, Y, function(B, R) {
                return j.decryptBlock(B, R);
              });
            }
            decryptString(A) {
              const Y = new this.StringCipherConstructor();
              let j = (0, t.stringToBytes)(A);
              return j = Y.decryptBlock(j, !0), (0, t.bytesToString)(j);
            }
            encryptString(A) {
              const Y = new this.StringCipherConstructor();
              if (Y instanceof g) {
                const B = 16 - A.length % 16;
                A += String.fromCharCode(B).repeat(B);
                const R = new Uint8Array(16);
                if (typeof crypto < "u")
                  crypto.getRandomValues(R);
                else
                  for (let f = 0; f < 16; f++)
                    R[f] = Math.floor(256 * Math.random());
                let k = (0, t.stringToBytes)(A);
                k = Y.encrypt(k, R);
                const x = new Uint8Array(16 + k.length);
                return x.set(R), x.set(k, 16), (0, t.bytesToString)(x);
              }
              let j = (0, t.stringToBytes)(A);
              return j = Y.encrypt(j), (0, t.bytesToString)(j);
            }
          }
          const _ = function() {
            const A = new Uint8Array([40, 191, 78, 94, 78, 117, 138, 65, 100, 0, 78, 86, 255, 250, 1, 8, 46, 46, 0, 182, 208, 104, 62, 128, 47, 12, 169, 254, 100, 83, 105, 122]);
            function Y(f, U, O, S, F, T, I, M, V, J, W, z) {
              if (U) {
                const L = Math.min(127, U.length);
                U = U.subarray(0, L);
              } else
                U = [];
              let G;
              return f === 6 ? G = new u() : G = new l(), G.checkUserPassword(U, M, I) ? G.getUserKey(U, V, W) : U.length && G.checkOwnerPassword(U, S, T, O) ? G.getOwnerKey(U, F, T, J) : null;
            }
            function j(f, U, O, S, F, T, I, M) {
              const V = 40 + O.length + f.length, J = new Uint8Array(V);
              let W = 0, z, G;
              if (U)
                for (G = Math.min(32, U.length); W < G; ++W)
                  J[W] = U[W];
              for (z = 0; W < 32; )
                J[W++] = A[z++];
              for (z = 0, G = O.length; z < G; ++z)
                J[W++] = O[z];
              for (J[W++] = F & 255, J[W++] = F >> 8 & 255, J[W++] = F >> 16 & 255, J[W++] = F >>> 24 & 255, z = 0, G = f.length; z < G; ++z)
                J[W++] = f[z];
              T >= 4 && !M && (J[W++] = 255, J[W++] = 255, J[W++] = 255, J[W++] = 255);
              let L = e(J, 0, W);
              const K = I >> 3;
              if (T >= 3)
                for (z = 0; z < 50; ++z)
                  L = e(L, 0, K);
              const te = L.subarray(0, K);
              let se, q;
              if (T >= 3) {
                for (W = 0; W < 32; ++W)
                  J[W] = A[W];
                for (z = 0, G = f.length; z < G; ++z)
                  J[W++] = f[z];
                se = new h(te), q = se.encryptBlock(e(J, 0, W)), G = te.length;
                const N = new Uint8Array(G);
                for (z = 1; z <= 19; ++z) {
                  for (let Q = 0; Q < G; ++Q)
                    N[Q] = te[Q] ^ z;
                  se = new h(N), q = se.encryptBlock(q);
                }
                for (z = 0, G = q.length; z < G; ++z)
                  if (S[z] !== q[z])
                    return null;
              } else
                for (se = new h(te), q = se.encryptBlock(A), z = 0, G = q.length; z < G; ++z)
                  if (S[z] !== q[z])
                    return null;
              return te;
            }
            function X(f, U, O, S) {
              const F = new Uint8Array(32);
              let T = 0;
              const I = Math.min(32, f.length);
              for (; T < I; ++T)
                F[T] = f[T];
              let M = 0;
              for (; T < 32; )
                F[T++] = A[M++];
              let V = e(F, 0, T);
              const J = S >> 3;
              if (O >= 3)
                for (M = 0; M < 50; ++M)
                  V = e(V, 0, V.length);
              let W, z;
              if (O >= 3) {
                z = U;
                const G = new Uint8Array(J);
                for (M = 19; M >= 0; M--) {
                  for (let L = 0; L < J; ++L)
                    G[L] = V[L] ^ M;
                  W = new h(G), z = W.encryptBlock(z);
                }
              } else
                W = new h(V.subarray(0, J)), z = W.encryptBlock(U);
              return z;
            }
            const B = a.Name.get("Identity");
            function R(f, U, O, S = !1) {
              const F = new Uint8Array(O.length + 9), T = O.length;
              let I;
              for (I = 0; I < T; ++I)
                F[I] = O[I];
              return F[I++] = f & 255, F[I++] = f >> 8 & 255, F[I++] = f >> 16 & 255, F[I++] = U & 255, F[I++] = U >> 8 & 255, S && (F[I++] = 115, F[I++] = 65, F[I++] = 108, F[I++] = 84), e(F, 0, I).subarray(0, Math.min(O.length + 5, 16));
            }
            function k(f, U, O, S, F) {
              if (!(U instanceof a.Name))
                throw new t.FormatError("Invalid crypt filter name.");
              const T = f.get(U.name);
              let I;
              if (T != null && (I = T.get("CFM")), !I || I.name === "None")
                return function() {
                  return new m();
                };
              if (I.name === "V2")
                return function() {
                  return new h(R(O, S, F, !1));
                };
              if (I.name === "AESV2")
                return function() {
                  return new n(R(O, S, F, !0));
                };
              if (I.name === "AESV3")
                return function() {
                  return new i(F);
                };
              throw new t.FormatError("Unknown crypto method");
            }
            class x {
              constructor(U, O, S) {
                const F = U.get("Filter");
                if (!(0, a.isName)(F, "Standard"))
                  throw new t.FormatError("unknown encryption method");
                this.filterName = F.name, this.dict = U;
                const T = U.get("V");
                if (!Number.isInteger(T) || T !== 1 && T !== 2 && T !== 4 && T !== 5)
                  throw new t.FormatError("unsupported encryption algorithm");
                this.algorithm = T;
                let I = U.get("Length");
                if (!I)
                  if (T <= 3)
                    I = 40;
                  else {
                    const te = U.get("CF"), se = U.get("StmF");
                    if (te instanceof a.Dict && se instanceof a.Name) {
                      te.suppressEncryption = !0;
                      const q = te.get(se.name);
                      I = q && q.get("Length") || 128, I < 40 && (I <<= 3);
                    }
                  }
                if (!Number.isInteger(I) || I < 40 || I % 8 !== 0)
                  throw new t.FormatError("invalid key length");
                const M = (0, t.stringToBytes)(U.get("O")).subarray(0, 32), V = (0, t.stringToBytes)(U.get("U")).subarray(0, 32), J = U.get("P"), W = U.get("R"), z = (T === 4 || T === 5) && U.get("EncryptMetadata") !== !1;
                this.encryptMetadata = z;
                const G = (0, t.stringToBytes)(O);
                let L;
                if (S) {
                  if (W === 6)
                    try {
                      S = (0, t.utf8StringToString)(S);
                    } catch {
                      (0, t.warn)("CipherTransformFactory: Unable to convert UTF8 encoded password.");
                    }
                  L = (0, t.stringToBytes)(S);
                }
                let K;
                if (T !== 5)
                  K = j(G, L, M, V, J, W, I, z);
                else {
                  const te = (0, t.stringToBytes)(U.get("O")).subarray(32, 40), se = (0, t.stringToBytes)(U.get("O")).subarray(40, 48), q = (0, t.stringToBytes)(U.get("U")).subarray(0, 48), N = (0, t.stringToBytes)(U.get("U")).subarray(32, 40), Q = (0, t.stringToBytes)(U.get("U")).subarray(40, 48), D = (0, t.stringToBytes)(U.get("OE")), ne = (0, t.stringToBytes)(U.get("UE"));
                  (0, t.stringToBytes)(U.get("Perms")), K = Y(W, L, M, te, se, q, V, N, Q, D, ne);
                }
                if (!K && !S)
                  throw new t.PasswordException("No password given", t.PasswordResponses.NEED_PASSWORD);
                if (!K && S) {
                  const te = X(L, M, W, I);
                  K = j(G, te, M, V, J, W, I, z);
                }
                if (!K)
                  throw new t.PasswordException("Incorrect Password", t.PasswordResponses.INCORRECT_PASSWORD);
                if (this.encryptionKey = K, T >= 4) {
                  const te = U.get("CF");
                  te instanceof a.Dict && (te.suppressEncryption = !0), this.cf = te, this.stmf = U.get("StmF") || B, this.strf = U.get("StrF") || B, this.eff = U.get("EFF") || this.stmf;
                }
              }
              createCipherTransform(U, O) {
                if (this.algorithm === 4 || this.algorithm === 5)
                  return new w(k(this.cf, this.strf, U, O, this.encryptionKey), k(this.cf, this.stmf, U, O, this.encryptionKey));
                const S = R(U, O, this.encryptionKey, !1), F = function() {
                  return new h(S);
                };
                return new w(F, F);
              }
            }
            return x;
          }();
          o.CipherTransformFactory = _;
        },
        /* 68 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.DecryptStream = void 0;
          var t = C(19);
          const a = 512;
          class v extends t.DecodeStream {
            constructor(e, y, c) {
              super(y), this.str = e, this.dict = e.dict, this.decrypt = c, this.nextChunk = null, this.initialized = !1;
            }
            readBlock() {
              let e;
              if (this.initialized ? e = this.nextChunk : (e = this.str.getBytes(a), this.initialized = !0), !e || e.length === 0) {
                this.eof = !0;
                return;
              }
              this.nextChunk = this.str.getBytes(a);
              const y = this.nextChunk && this.nextChunk.length > 0, c = this.decrypt;
              e = c(e, !y);
              let d = this.bufferLength;
              const p = e.length, m = this.ensureBuffer(d + p);
              for (let g = 0; g < p; g++)
                m[d++] = e[g];
              this.bufferLength = d;
            }
          }
          o.DecryptStream = v;
        },
        /* 69 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.Catalog = void 0;
          var t = C(6), a = C(2), v = C(5), h = C(70), e = C(7), y = C(71), c = C(14), d = C(72), p = C(59), m = C(73), g = C(74);
          function n(l) {
            return l instanceof v.Dict && (l = l.get("D")), Array.isArray(l) ? l : null;
          }
          class i {
            constructor(u, w) {
              if (this.pdfManager = u, this.xref = w, this._catDict = w.getCatalogObj(), !(this._catDict instanceof v.Dict))
                throw new a.FormatError("Catalog object is not a dictionary.");
              this.toplevelPagesDict, this._actualNumPages = null, this.fontCache = new v.RefSetCache(), this.builtInCMapCache = /* @__PURE__ */ new Map(), this.standardFontDataCache = /* @__PURE__ */ new Map(), this.globalImageCache = new p.GlobalImageCache(), this.pageKidsCountCache = new v.RefSetCache(), this.pageIndexCache = new v.RefSetCache(), this.nonBlendModesSet = new v.RefSet();
            }
            get version() {
              const u = this._catDict.get("Version");
              return (0, a.shadow)(this, "version", u instanceof v.Name ? u.name : null);
            }
            get lang() {
              const u = this._catDict.get("Lang");
              return (0, a.shadow)(this, "lang", typeof u == "string" ? (0, a.stringToPDFString)(u) : null);
            }
            get needsRendering() {
              const u = this._catDict.get("NeedsRendering");
              return (0, a.shadow)(this, "needsRendering", typeof u == "boolean" ? u : !1);
            }
            get collection() {
              let u = null;
              try {
                const w = this._catDict.get("Collection");
                w instanceof v.Dict && w.size > 0 && (u = w);
              } catch (w) {
                if (w instanceof t.MissingDataException)
                  throw w;
                (0, a.info)("Cannot fetch Collection entry; assuming no collection is present.");
              }
              return (0, a.shadow)(this, "collection", u);
            }
            get acroForm() {
              let u = null;
              try {
                const w = this._catDict.get("AcroForm");
                w instanceof v.Dict && w.size > 0 && (u = w);
              } catch (w) {
                if (w instanceof t.MissingDataException)
                  throw w;
                (0, a.info)("Cannot fetch AcroForm entry; assuming no forms are present.");
              }
              return (0, a.shadow)(this, "acroForm", u);
            }
            get acroFormRef() {
              const u = this._catDict.getRaw("AcroForm");
              return (0, a.shadow)(this, "acroFormRef", u instanceof v.Ref ? u : null);
            }
            get metadata() {
              const u = this._catDict.getRaw("Metadata");
              if (!(u instanceof v.Ref))
                return (0, a.shadow)(this, "metadata", null);
              let w = null;
              try {
                const _ = !(this.xref.encrypt && this.xref.encrypt.encryptMetadata), b = this.xref.fetch(u, _);
                if (b instanceof e.BaseStream && b.dict instanceof v.Dict) {
                  const A = b.dict.get("Type"), Y = b.dict.get("Subtype");
                  if ((0, v.isName)(A, "Metadata") && (0, v.isName)(Y, "XML")) {
                    const j = (0, a.stringToUTF8String)(b.getString());
                    j && (w = new m.MetadataParser(j).serializable);
                  }
                }
              } catch (_) {
                if (_ instanceof t.MissingDataException)
                  throw _;
                (0, a.info)(`Skipping invalid Metadata: "${_}".`);
              }
              return (0, a.shadow)(this, "metadata", w);
            }
            get markInfo() {
              let u = null;
              try {
                u = this._readMarkInfo();
              } catch (w) {
                if (w instanceof t.MissingDataException)
                  throw w;
                (0, a.warn)("Unable to read mark info.");
              }
              return (0, a.shadow)(this, "markInfo", u);
            }
            _readMarkInfo() {
              const u = this._catDict.get("MarkInfo");
              if (!(u instanceof v.Dict))
                return null;
              const w = {
                Marked: !1,
                UserProperties: !1,
                Suspects: !1
              };
              for (const _ in w) {
                const b = u.get(_);
                typeof b == "boolean" && (w[_] = b);
              }
              return w;
            }
            get structTreeRoot() {
              let u = null;
              try {
                u = this._readStructTreeRoot();
              } catch (w) {
                if (w instanceof t.MissingDataException)
                  throw w;
                (0, a.warn)("Unable read to structTreeRoot info.");
              }
              return (0, a.shadow)(this, "structTreeRoot", u);
            }
            _readStructTreeRoot() {
              const u = this._catDict.get("StructTreeRoot");
              if (!(u instanceof v.Dict))
                return null;
              const w = new g.StructTreeRoot(u);
              return w.init(), w;
            }
            get toplevelPagesDict() {
              const u = this._catDict.get("Pages");
              if (!(u instanceof v.Dict))
                throw new a.FormatError("Invalid top-level pages dictionary.");
              return (0, a.shadow)(this, "toplevelPagesDict", u);
            }
            get documentOutline() {
              let u = null;
              try {
                u = this._readDocumentOutline();
              } catch (w) {
                if (w instanceof t.MissingDataException)
                  throw w;
                (0, a.warn)("Unable to read document outline.");
              }
              return (0, a.shadow)(this, "documentOutline", u);
            }
            _readDocumentOutline() {
              let u = this._catDict.get("Outlines");
              if (!(u instanceof v.Dict) || (u = u.getRaw("First"), !(u instanceof v.Ref)))
                return null;
              const w = {
                items: []
              }, _ = [{
                obj: u,
                parent: w
              }], b = new v.RefSet();
              b.put(u);
              const A = this.xref, Y = new Uint8ClampedArray(3);
              for (; _.length > 0; ) {
                const j = _.shift(), X = A.fetchIfRef(j.obj);
                if (X === null)
                  continue;
                if (!X.has("Title"))
                  throw new a.FormatError("Invalid outline item encountered.");
                const B = {
                  url: null,
                  dest: null
                };
                i.parseDestDictionary({
                  destDict: X,
                  resultObj: B,
                  docBaseUrl: this.pdfManager.docBaseUrl
                });
                const R = X.get("Title"), k = X.get("F") || 0, x = X.getArray("C"), f = X.get("Count");
                let U = Y;
                Array.isArray(x) && x.length === 3 && (x[0] !== 0 || x[1] !== 0 || x[2] !== 0) && (U = c.ColorSpace.singletons.rgb.getRgb(x, 0));
                const O = {
                  dest: B.dest,
                  url: B.url,
                  unsafeUrl: B.unsafeUrl,
                  newWindow: B.newWindow,
                  title: (0, a.stringToPDFString)(R),
                  color: U,
                  count: Number.isInteger(f) ? f : void 0,
                  bold: !!(k & 2),
                  italic: !!(k & 1),
                  items: []
                };
                j.parent.items.push(O), u = X.getRaw("First"), u instanceof v.Ref && !b.has(u) && (_.push({
                  obj: u,
                  parent: O
                }), b.put(u)), u = X.getRaw("Next"), u instanceof v.Ref && !b.has(u) && (_.push({
                  obj: u,
                  parent: j.parent
                }), b.put(u));
              }
              return w.items.length > 0 ? w.items : null;
            }
            get permissions() {
              let u = null;
              try {
                u = this._readPermissions();
              } catch (w) {
                if (w instanceof t.MissingDataException)
                  throw w;
                (0, a.warn)("Unable to read permissions.");
              }
              return (0, a.shadow)(this, "permissions", u);
            }
            _readPermissions() {
              const u = this.xref.trailer.get("Encrypt");
              if (!(u instanceof v.Dict))
                return null;
              let w = u.get("P");
              if (typeof w != "number")
                return null;
              w += 4294967296;
              const _ = [];
              for (const b in a.PermissionFlag) {
                const A = a.PermissionFlag[b];
                w & A && _.push(A);
              }
              return _;
            }
            get optionalContentConfig() {
              let u = null;
              try {
                const w = this._catDict.get("OCProperties");
                if (!w)
                  return (0, a.shadow)(this, "optionalContentConfig", null);
                const _ = w.get("D");
                if (!_)
                  return (0, a.shadow)(this, "optionalContentConfig", null);
                const b = w.get("OCGs");
                if (!Array.isArray(b))
                  return (0, a.shadow)(this, "optionalContentConfig", null);
                const A = [], Y = [];
                for (const j of b) {
                  if (!(j instanceof v.Ref))
                    continue;
                  Y.push(j);
                  const X = this.xref.fetchIfRef(j);
                  A.push({
                    id: j.toString(),
                    name: typeof X.get("Name") == "string" ? (0, a.stringToPDFString)(X.get("Name")) : null,
                    intent: typeof X.get("Intent") == "string" ? (0, a.stringToPDFString)(X.get("Intent")) : null
                  });
                }
                u = this._readOptionalContentConfig(_, Y), u.groups = A;
              } catch (w) {
                if (w instanceof t.MissingDataException)
                  throw w;
                (0, a.warn)(`Unable to read optional content config: ${w}`);
              }
              return (0, a.shadow)(this, "optionalContentConfig", u);
            }
            _readOptionalContentConfig(u, w) {
              function _(B) {
                const R = [];
                if (Array.isArray(B))
                  for (const k of B)
                    k instanceof v.Ref && w.includes(k) && R.push(k.toString());
                return R;
              }
              function b(B, R = 0) {
                if (!Array.isArray(B))
                  return null;
                const k = [];
                for (const f of B) {
                  if (f instanceof v.Ref && w.includes(f)) {
                    j.put(f), k.push(f.toString());
                    continue;
                  }
                  const U = A(f, R);
                  U && k.push(U);
                }
                if (R > 0)
                  return k;
                const x = [];
                for (const f of w)
                  j.has(f) || x.push(f.toString());
                return x.length && k.push({
                  name: null,
                  order: x
                }), k;
              }
              function A(B, R) {
                if (++R > X)
                  return (0, a.warn)("parseNestedOrder - reached MAX_NESTED_LEVELS."), null;
                const k = Y.fetchIfRef(B);
                if (!Array.isArray(k))
                  return null;
                const x = Y.fetchIfRef(k[0]);
                if (typeof x != "string")
                  return null;
                const f = b(k.slice(1), R);
                return !f || !f.length ? null : {
                  name: (0, a.stringToPDFString)(x),
                  order: f
                };
              }
              const Y = this.xref, j = new v.RefSet(), X = 10;
              return {
                name: typeof u.get("Name") == "string" ? (0, a.stringToPDFString)(u.get("Name")) : null,
                creator: typeof u.get("Creator") == "string" ? (0, a.stringToPDFString)(u.get("Creator")) : null,
                baseState: u.get("BaseState") instanceof v.Name ? u.get("BaseState").name : null,
                on: _(u.get("ON")),
                off: _(u.get("OFF")),
                order: b(u.get("Order")),
                groups: null
              };
            }
            setActualNumPages(u = null) {
              this._actualNumPages = u;
            }
            get hasActualNumPages() {
              return this._actualNumPages !== null;
            }
            get _pagesCount() {
              const u = this.toplevelPagesDict.get("Count");
              if (!Number.isInteger(u))
                throw new a.FormatError("Page count in top-level pages dictionary is not an integer.");
              return (0, a.shadow)(this, "_pagesCount", u);
            }
            get numPages() {
              return this.hasActualNumPages ? this._actualNumPages : this._pagesCount;
            }
            get destinations() {
              const u = this._readDests(), w = /* @__PURE__ */ Object.create(null);
              if (u instanceof h.NameTree)
                for (const [_, b] of u.getAll()) {
                  const A = n(b);
                  A && (w[(0, a.stringToPDFString)(_)] = A);
                }
              else
                u instanceof v.Dict && u.forEach(function(_, b) {
                  const A = n(b);
                  A && (w[_] = A);
                });
              return (0, a.shadow)(this, "destinations", w);
            }
            getDestination(u) {
              const w = this._readDests();
              if (w instanceof h.NameTree) {
                const _ = n(w.get(u));
                if (_)
                  return _;
                const b = this.destinations[u];
                if (b)
                  return (0, a.warn)(`Found "${u}" at an incorrect position in the NameTree.`), b;
              } else if (w instanceof v.Dict) {
                const _ = n(w.get(u));
                if (_)
                  return _;
              }
              return null;
            }
            _readDests() {
              const u = this._catDict.get("Names");
              if (u && u.has("Dests"))
                return new h.NameTree(u.getRaw("Dests"), this.xref);
              if (this._catDict.has("Dests"))
                return this._catDict.get("Dests");
            }
            get pageLabels() {
              let u = null;
              try {
                u = this._readPageLabels();
              } catch (w) {
                if (w instanceof t.MissingDataException)
                  throw w;
                (0, a.warn)("Unable to read page labels.");
              }
              return (0, a.shadow)(this, "pageLabels", u);
            }
            _readPageLabels() {
              const u = this._catDict.getRaw("PageLabels");
              if (!u)
                return null;
              const w = new Array(this.numPages);
              let _ = null, b = "";
              const Y = new h.NumberTree(u, this.xref).getAll();
              let j = "", X = 1;
              for (let B = 0, R = this.numPages; B < R; B++) {
                const k = Y.get(B);
                if (k !== void 0) {
                  if (!(k instanceof v.Dict))
                    throw new a.FormatError("PageLabel is not a dictionary.");
                  if (k.has("Type") && !(0, v.isName)(k.get("Type"), "PageLabel"))
                    throw new a.FormatError("Invalid type in PageLabel dictionary.");
                  if (k.has("S")) {
                    const x = k.get("S");
                    if (!(x instanceof v.Name))
                      throw new a.FormatError("Invalid style in PageLabel dictionary.");
                    _ = x.name;
                  } else
                    _ = null;
                  if (k.has("P")) {
                    const x = k.get("P");
                    if (typeof x != "string")
                      throw new a.FormatError("Invalid prefix in PageLabel dictionary.");
                    b = (0, a.stringToPDFString)(x);
                  } else
                    b = "";
                  if (k.has("St")) {
                    const x = k.get("St");
                    if (!(Number.isInteger(x) && x >= 1))
                      throw new a.FormatError("Invalid start in PageLabel dictionary.");
                    X = x;
                  } else
                    X = 1;
                }
                switch (_) {
                  case "D":
                    j = X;
                    break;
                  case "R":
                  case "r":
                    j = (0, t.toRomanNumerals)(X, _ === "r");
                    break;
                  case "A":
                  case "a":
                    const x = 26, O = _ === "a" ? 97 : 65, S = X - 1;
                    j = String.fromCharCode(O + S % x).repeat(Math.floor(S / x) + 1);
                    break;
                  default:
                    if (_)
                      throw new a.FormatError(`Invalid style "${_}" in PageLabel dictionary.`);
                    j = "";
                }
                w[B] = b + j, X++;
              }
              return w;
            }
            get pageLayout() {
              const u = this._catDict.get("PageLayout");
              let w = "";
              if (u instanceof v.Name)
                switch (u.name) {
                  case "SinglePage":
                  case "OneColumn":
                  case "TwoColumnLeft":
                  case "TwoColumnRight":
                  case "TwoPageLeft":
                  case "TwoPageRight":
                    w = u.name;
                }
              return (0, a.shadow)(this, "pageLayout", w);
            }
            get pageMode() {
              const u = this._catDict.get("PageMode");
              let w = "UseNone";
              if (u instanceof v.Name)
                switch (u.name) {
                  case "UseNone":
                  case "UseOutlines":
                  case "UseThumbs":
                  case "FullScreen":
                  case "UseOC":
                  case "UseAttachments":
                    w = u.name;
                }
              return (0, a.shadow)(this, "pageMode", w);
            }
            get viewerPreferences() {
              const u = this._catDict.get("ViewerPreferences");
              if (!(u instanceof v.Dict))
                return (0, a.shadow)(this, "viewerPreferences", null);
              let w = null;
              for (const _ of u.getKeys()) {
                const b = u.get(_);
                let A;
                switch (_) {
                  case "HideToolbar":
                  case "HideMenubar":
                  case "HideWindowUI":
                  case "FitWindow":
                  case "CenterWindow":
                  case "DisplayDocTitle":
                  case "PickTrayByPDFSize":
                    typeof b == "boolean" && (A = b);
                    break;
                  case "NonFullScreenPageMode":
                    if (b instanceof v.Name)
                      switch (b.name) {
                        case "UseNone":
                        case "UseOutlines":
                        case "UseThumbs":
                        case "UseOC":
                          A = b.name;
                          break;
                        default:
                          A = "UseNone";
                      }
                    break;
                  case "Direction":
                    if (b instanceof v.Name)
                      switch (b.name) {
                        case "L2R":
                        case "R2L":
                          A = b.name;
                          break;
                        default:
                          A = "L2R";
                      }
                    break;
                  case "ViewArea":
                  case "ViewClip":
                  case "PrintArea":
                  case "PrintClip":
                    if (b instanceof v.Name)
                      switch (b.name) {
                        case "MediaBox":
                        case "CropBox":
                        case "BleedBox":
                        case "TrimBox":
                        case "ArtBox":
                          A = b.name;
                          break;
                        default:
                          A = "CropBox";
                      }
                    break;
                  case "PrintScaling":
                    if (b instanceof v.Name)
                      switch (b.name) {
                        case "None":
                        case "AppDefault":
                          A = b.name;
                          break;
                        default:
                          A = "AppDefault";
                      }
                    break;
                  case "Duplex":
                    if (b instanceof v.Name)
                      switch (b.name) {
                        case "Simplex":
                        case "DuplexFlipShortEdge":
                        case "DuplexFlipLongEdge":
                          A = b.name;
                          break;
                        default:
                          A = "None";
                      }
                    break;
                  case "PrintPageRange":
                    Array.isArray(b) && b.length % 2 === 0 && b.every((j, X, B) => Number.isInteger(j) && j > 0 && (X === 0 || j >= B[X - 1]) && j <= this.numPages) && (A = b);
                    break;
                  case "NumCopies":
                    Number.isInteger(b) && b > 0 && (A = b);
                    break;
                  default:
                    (0, a.warn)(`Ignoring non-standard key in ViewerPreferences: ${_}.`);
                    continue;
                }
                if (A === void 0) {
                  (0, a.warn)(`Bad value, for key "${_}", in ViewerPreferences: ${b}.`);
                  continue;
                }
                w || (w = /* @__PURE__ */ Object.create(null)), w[_] = A;
              }
              return (0, a.shadow)(this, "viewerPreferences", w);
            }
            get openAction() {
              const u = this._catDict.get("OpenAction"), w = /* @__PURE__ */ Object.create(null);
              if (u instanceof v.Dict) {
                const _ = new v.Dict(this.xref);
                _.set("A", u);
                const b = {
                  url: null,
                  dest: null,
                  action: null
                };
                i.parseDestDictionary({
                  destDict: _,
                  resultObj: b
                }), Array.isArray(b.dest) ? w.dest = b.dest : b.action && (w.action = b.action);
              } else
                Array.isArray(u) && (w.dest = u);
              return (0, a.shadow)(this, "openAction", (0, a.objectSize)(w) > 0 ? w : null);
            }
            get attachments() {
              const u = this._catDict.get("Names");
              let w = null;
              if (u instanceof v.Dict && u.has("EmbeddedFiles")) {
                const _ = new h.NameTree(u.getRaw("EmbeddedFiles"), this.xref);
                for (const [b, A] of _.getAll()) {
                  const Y = new d.FileSpec(A, this.xref);
                  w || (w = /* @__PURE__ */ Object.create(null)), w[(0, a.stringToPDFString)(b)] = Y.serializable;
                }
              }
              return (0, a.shadow)(this, "attachments", w);
            }
            get xfaImages() {
              const u = this._catDict.get("Names");
              let w = null;
              if (u instanceof v.Dict && u.has("XFAImages")) {
                const _ = new h.NameTree(u.getRaw("XFAImages"), this.xref);
                for (const [b, A] of _.getAll())
                  w || (w = new v.Dict(this.xref)), w.set((0, a.stringToPDFString)(b), A);
              }
              return (0, a.shadow)(this, "xfaImages", w);
            }
            _collectJavaScript() {
              const u = this._catDict.get("Names");
              let w = null;
              function _(A, Y) {
                if (!(Y instanceof v.Dict) || !(0, v.isName)(Y.get("S"), "JavaScript"))
                  return;
                let j = Y.get("JS");
                if (j instanceof e.BaseStream)
                  j = j.getString();
                else if (typeof j != "string")
                  return;
                w === null && (w = /* @__PURE__ */ new Map()), j = (0, a.stringToPDFString)(j).replace(/\u0000/g, ""), w.set(A, j);
              }
              if (u instanceof v.Dict && u.has("JavaScript")) {
                const A = new h.NameTree(u.getRaw("JavaScript"), this.xref);
                for (const [Y, j] of A.getAll())
                  _((0, a.stringToPDFString)(Y), j);
              }
              const b = this._catDict.get("OpenAction");
              return b && _("OpenAction", b), w;
            }
            get javaScript() {
              const u = this._collectJavaScript();
              return (0, a.shadow)(this, "javaScript", u ? [...u.values()] : null);
            }
            get jsActions() {
              const u = this._collectJavaScript();
              let w = (0, t.collectActions)(this.xref, this._catDict, a.DocumentActionEventType);
              if (u) {
                w || (w = /* @__PURE__ */ Object.create(null));
                for (const [_, b] of u)
                  _ in w ? w[_].push(b) : w[_] = [b];
              }
              return (0, a.shadow)(this, "jsActions", w);
            }
            async fontFallback(u, w) {
              const _ = await Promise.all(this.fontCache);
              for (const b of _)
                if (b.loadedName === u) {
                  b.fallback(w);
                  return;
                }
            }
            async cleanup(u = !1) {
              (0, y.clearGlobalCaches)(), this.globalImageCache.clear(u), this.pageKidsCountCache.clear(), this.pageIndexCache.clear(), this.nonBlendModesSet.clear();
              const w = await Promise.all(this.fontCache);
              for (const {
                dict: _
              } of w)
                delete _.cacheKey;
              this.fontCache.clear(), this.builtInCMapCache.clear(), this.standardFontDataCache.clear();
            }
            async getPageDict(u) {
              const w = [this.toplevelPagesDict], _ = new v.RefSet(), b = this._catDict.getRaw("Pages");
              b instanceof v.Ref && _.put(b);
              const A = this.xref, Y = this.pageKidsCountCache, j = this.pageIndexCache;
              let X = 0;
              for (; w.length; ) {
                const B = w.pop();
                if (B instanceof v.Ref) {
                  const f = Y.get(B);
                  if (f >= 0 && X + f <= u) {
                    X += f;
                    continue;
                  }
                  if (_.has(B))
                    throw new a.FormatError("Pages tree contains circular reference.");
                  _.put(B);
                  const U = await A.fetchAsync(B);
                  if (U instanceof v.Dict) {
                    let O = U.getRaw("Type");
                    if (O instanceof v.Ref && (O = await A.fetchAsync(O)), (0, v.isName)(O, "Page") || !U.has("Kids")) {
                      if (Y.has(B) || Y.put(B, 1), j.has(B) || j.put(B, X), X === u)
                        return [U, B];
                      X++;
                      continue;
                    }
                  }
                  w.push(U);
                  continue;
                }
                if (!(B instanceof v.Dict))
                  throw new a.FormatError("Page dictionary kid reference points to wrong type of object.");
                const {
                  objId: R
                } = B;
                let k = B.getRaw("Count");
                if (k instanceof v.Ref && (k = await A.fetchAsync(k)), Number.isInteger(k) && k >= 0 && (R && !Y.has(R) && Y.put(R, k), X + k <= u)) {
                  X += k;
                  continue;
                }
                let x = B.getRaw("Kids");
                if (x instanceof v.Ref && (x = await A.fetchAsync(x)), !Array.isArray(x)) {
                  let f = B.getRaw("Type");
                  if (f instanceof v.Ref && (f = await A.fetchAsync(f)), (0, v.isName)(f, "Page") || !B.has("Kids")) {
                    if (X === u)
                      return [B, null];
                    X++;
                    continue;
                  }
                  throw new a.FormatError("Page dictionary kids object is not an array.");
                }
                for (let f = x.length - 1; f >= 0; f--)
                  w.push(x[f]);
              }
              throw new Error(`Page index ${u} not found.`);
            }
            async getAllPageDicts(u = !1) {
              const w = [{
                currentNode: this.toplevelPagesDict,
                posInKids: 0
              }], _ = new v.RefSet(), b = this._catDict.getRaw("Pages");
              b instanceof v.Ref && _.put(b);
              const A = /* @__PURE__ */ new Map(), Y = this.xref, j = this.pageIndexCache;
              let X = 0;
              function B(k, x) {
                x && !j.has(x) && j.put(x, X), A.set(X++, [k, x]);
              }
              function R(k) {
                if (k instanceof t.XRefEntryException && !u)
                  throw k;
                A.set(X++, [k, null]);
              }
              for (; w.length > 0; ) {
                const k = w.at(-1), {
                  currentNode: x,
                  posInKids: f
                } = k;
                let U = x.getRaw("Kids");
                if (U instanceof v.Ref)
                  try {
                    U = await Y.fetchAsync(U);
                  } catch (T) {
                    R(T);
                    break;
                  }
                if (!Array.isArray(U)) {
                  R(new a.FormatError("Page dictionary kids object is not an array."));
                  break;
                }
                if (f >= U.length) {
                  w.pop();
                  continue;
                }
                const O = U[f];
                let S;
                if (O instanceof v.Ref) {
                  if (_.has(O)) {
                    R(new a.FormatError("Pages tree contains circular reference."));
                    break;
                  }
                  _.put(O);
                  try {
                    S = await Y.fetchAsync(O);
                  } catch (T) {
                    R(T);
                    break;
                  }
                } else
                  S = O;
                if (!(S instanceof v.Dict)) {
                  R(new a.FormatError("Page dictionary kid reference points to wrong type of object."));
                  break;
                }
                let F = S.getRaw("Type");
                if (F instanceof v.Ref)
                  try {
                    F = await Y.fetchAsync(F);
                  } catch (T) {
                    R(T);
                    break;
                  }
                (0, v.isName)(F, "Page") || !S.has("Kids") ? B(S, O instanceof v.Ref ? O : null) : w.push({
                  currentNode: S,
                  posInKids: 0
                }), k.posInKids++;
              }
              return A;
            }
            getPageIndex(u) {
              const w = this.pageIndexCache.get(u);
              if (w !== void 0)
                return Promise.resolve(w);
              const _ = this.xref;
              function b(j) {
                let X = 0, B;
                return _.fetchAsync(j).then(function(R) {
                  if ((0, v.isRefsEqual)(j, u) && !(0, v.isDict)(R, "Page") && !(R instanceof v.Dict && !R.has("Type") && R.has("Contents")))
                    throw new a.FormatError("The reference does not point to a /Page dictionary.");
                  if (!R)
                    return null;
                  if (!(R instanceof v.Dict))
                    throw new a.FormatError("Node must be a dictionary.");
                  return B = R.getRaw("Parent"), R.getAsync("Parent");
                }).then(function(R) {
                  if (!R)
                    return null;
                  if (!(R instanceof v.Dict))
                    throw new a.FormatError("Parent must be a dictionary.");
                  return R.getAsync("Kids");
                }).then(function(R) {
                  if (!R)
                    return null;
                  const k = [];
                  let x = !1;
                  for (let f = 0, U = R.length; f < U; f++) {
                    const O = R[f];
                    if (!(O instanceof v.Ref))
                      throw new a.FormatError("Kid must be a reference.");
                    if ((0, v.isRefsEqual)(O, j)) {
                      x = !0;
                      break;
                    }
                    k.push(_.fetchAsync(O).then(function(S) {
                      if (!(S instanceof v.Dict))
                        throw new a.FormatError("Kid node must be a dictionary.");
                      S.has("Count") ? X += S.get("Count") : X++;
                    }));
                  }
                  if (!x)
                    throw new a.FormatError("Kid reference not found in parent's kids.");
                  return Promise.all(k).then(function() {
                    return [X, B];
                  });
                });
              }
              let A = 0;
              const Y = (j) => b(j).then((X) => {
                if (!X)
                  return this.pageIndexCache.put(u, A), A;
                const [B, R] = X;
                return A += B, Y(R);
              });
              return Y(u);
            }
            get baseUrl() {
              const u = this._catDict.get("URI");
              if (u instanceof v.Dict) {
                const w = u.get("Base");
                if (typeof w == "string") {
                  const _ = (0, a.createValidAbsoluteUrl)(w, null, {
                    tryConvertEncoding: !0
                  });
                  if (_)
                    return (0, a.shadow)(this, "baseUrl", _.href);
                }
              }
              return (0, a.shadow)(this, "baseUrl", null);
            }
            static parseDestDictionary(u) {
              const w = u.destDict;
              if (!(w instanceof v.Dict)) {
                (0, a.warn)("parseDestDictionary: `destDict` must be a dictionary.");
                return;
              }
              const _ = u.resultObj;
              if (typeof _ != "object") {
                (0, a.warn)("parseDestDictionary: `resultObj` must be an object.");
                return;
              }
              const b = u.docBaseUrl || null;
              let A = w.get("A"), Y, j;
              if (A instanceof v.Dict || (w.has("Dest") ? A = w.get("Dest") : (A = w.get("AA"), A instanceof v.Dict && (A.has("D") ? A = A.get("D") : A.has("U") && (A = A.get("U"))))), A instanceof v.Dict) {
                const X = A.get("S");
                if (!(X instanceof v.Name)) {
                  (0, a.warn)("parseDestDictionary: Invalid type in Action dictionary.");
                  return;
                }
                const B = X.name;
                switch (B) {
                  case "ResetForm":
                    const R = A.get("Flags"), k = ((typeof R == "number" ? R : 0) & 1) === 0, x = [], f = [];
                    for (const V of A.get("Fields") || [])
                      V instanceof v.Ref ? f.push(V.toString()) : typeof V == "string" && x.push((0, a.stringToPDFString)(V));
                    _.resetForm = {
                      fields: x,
                      refs: f,
                      include: k
                    };
                    break;
                  case "URI":
                    Y = A.get("URI"), Y instanceof v.Name && (Y = "/" + Y.name);
                    break;
                  case "GoTo":
                    j = A.get("D");
                    break;
                  case "Launch":
                  case "GoToR":
                    const U = A.get("F");
                    U instanceof v.Dict ? Y = U.get("F") || null : typeof U == "string" && (Y = U);
                    let O = A.get("D");
                    if (O && (O instanceof v.Name && (O = O.name), typeof Y == "string")) {
                      const V = Y.split("#")[0];
                      typeof O == "string" ? Y = V + "#" + O : Array.isArray(O) && (Y = V + "#" + JSON.stringify(O));
                    }
                    const S = A.get("NewWindow");
                    typeof S == "boolean" && (_.newWindow = S);
                    break;
                  case "Named":
                    const F = A.get("N");
                    F instanceof v.Name && (_.action = F.name);
                    break;
                  case "JavaScript":
                    const T = A.get("JS");
                    let I;
                    T instanceof e.BaseStream ? I = T.getString() : typeof T == "string" && (I = T);
                    const M = I && (0, t.recoverJsURL)((0, a.stringToPDFString)(I));
                    if (M) {
                      Y = M.url, _.newWindow = M.newWindow;
                      break;
                    }
                  default:
                    if (B === "JavaScript" || B === "SubmitForm")
                      break;
                    (0, a.warn)(`parseDestDictionary - unsupported action: "${B}".`);
                    break;
                }
              } else
                w.has("Dest") && (j = w.get("Dest"));
              if (typeof Y == "string") {
                const X = (0, a.createValidAbsoluteUrl)(Y, b, {
                  addDefaultProtocol: !0,
                  tryConvertEncoding: !0
                });
                X && (_.url = X.href), _.unsafeUrl = Y;
              }
              j && (j instanceof v.Name && (j = j.name), typeof j == "string" ? _.dest = (0, a.stringToPDFString)(j) : Array.isArray(j) && (_.dest = j));
            }
          }
          o.Catalog = i;
        },
        /* 70 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.NumberTree = o.NameTree = void 0;
          var t = C(5), a = C(2);
          class v {
            constructor(c, d, p) {
              this.constructor === v && (0, a.unreachable)("Cannot initialize NameOrNumberTree."), this.root = c, this.xref = d, this._type = p;
            }
            getAll() {
              const c = /* @__PURE__ */ new Map();
              if (!this.root)
                return c;
              const d = this.xref, p = new t.RefSet();
              p.put(this.root);
              const m = [this.root];
              for (; m.length > 0; ) {
                const g = d.fetchIfRef(m.shift());
                if (!(g instanceof t.Dict))
                  continue;
                if (g.has("Kids")) {
                  const i = g.get("Kids");
                  if (!Array.isArray(i))
                    continue;
                  for (const l of i) {
                    if (p.has(l))
                      throw new a.FormatError(`Duplicate entry in "${this._type}" tree.`);
                    m.push(l), p.put(l);
                  }
                  continue;
                }
                const n = g.get(this._type);
                if (Array.isArray(n))
                  for (let i = 0, l = n.length; i < l; i += 2)
                    c.set(d.fetchIfRef(n[i]), d.fetchIfRef(n[i + 1]));
              }
              return c;
            }
            get(c) {
              if (!this.root)
                return null;
              const d = this.xref;
              let p = d.fetchIfRef(this.root), m = 0;
              const g = 10;
              for (; p.has("Kids"); ) {
                if (++m > g)
                  return (0, a.warn)(`Search depth limit reached for "${this._type}" tree.`), null;
                const i = p.get("Kids");
                if (!Array.isArray(i))
                  return null;
                let l = 0, u = i.length - 1;
                for (; l <= u; ) {
                  const w = l + u >> 1, _ = d.fetchIfRef(i[w]), b = _.get("Limits");
                  if (c < d.fetchIfRef(b[0]))
                    u = w - 1;
                  else if (c > d.fetchIfRef(b[1]))
                    l = w + 1;
                  else {
                    p = _;
                    break;
                  }
                }
                if (l > u)
                  return null;
              }
              const n = p.get(this._type);
              if (Array.isArray(n)) {
                let i = 0, l = n.length - 2;
                for (; i <= l; ) {
                  const u = i + l >> 1, w = u + (u & 1), _ = d.fetchIfRef(n[w]);
                  if (c < _)
                    l = w - 2;
                  else if (c > _)
                    i = w + 2;
                  else
                    return d.fetchIfRef(n[w + 1]);
                }
              }
              return null;
            }
          }
          class h extends v {
            constructor(c, d) {
              super(c, d, "Names");
            }
          }
          o.NameTree = h;
          class e extends v {
            constructor(c, d) {
              super(c, d, "Nums");
            }
          }
          o.NumberTree = e;
        },
        /* 71 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.clearGlobalCaches = v;
          var t = C(5), a = C(40);
          function v() {
            (0, t.clearPrimitiveCaches)(), (0, a.clearUnicodeCaches)();
          }
        },
        /* 72 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.FileSpec = void 0;
          var t = C(2), a = C(7), v = C(5);
          function h(y) {
            return y.has("UF") ? y.get("UF") : y.has("F") ? y.get("F") : y.has("Unix") ? y.get("Unix") : y.has("Mac") ? y.get("Mac") : y.has("DOS") ? y.get("DOS") : null;
          }
          class e {
            constructor(c, d) {
              c instanceof v.Dict && (this.xref = d, this.root = c, c.has("FS") && (this.fs = c.get("FS")), this.description = c.has("Desc") ? (0, t.stringToPDFString)(c.get("Desc")) : "", c.has("RF") && (0, t.warn)("Related file specifications are not supported"), this.contentAvailable = !0, c.has("EF") || (this.contentAvailable = !1, (0, t.warn)("Non-embedded file specifications are not supported")));
            }
            get filename() {
              if (!this._filename && this.root) {
                const c = h(this.root) || "unnamed";
                this._filename = (0, t.stringToPDFString)(c).replace(/\\\\/g, "\\").replace(/\\\//g, "/").replace(/\\/g, "/");
              }
              return this._filename;
            }
            get content() {
              if (!this.contentAvailable)
                return null;
              !this.contentRef && this.root && (this.contentRef = h(this.root.get("EF")));
              let c = null;
              if (this.contentRef) {
                const d = this.xref.fetchIfRef(this.contentRef);
                d instanceof a.BaseStream ? c = d.getBytes() : (0, t.warn)("Embedded file specification points to non-existing/invalid content");
              } else
                (0, t.warn)("Embedded file specification does not have a content");
              return c;
            }
            get serializable() {
              return {
                filename: this.filename,
                content: this.content
              };
            }
          }
          o.FileSpec = e;
        },
        /* 73 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.MetadataParser = void 0;
          var t = C(66);
          class a {
            constructor(h) {
              h = this._repair(h);
              const y = new t.SimpleXMLParser({
                lowerCaseName: !0
              }).parseFromString(h);
              this._metadataMap = /* @__PURE__ */ new Map(), this._data = h, y && this._parse(y);
            }
            _repair(h) {
              return h.replace(/^[^<]+/, "").replace(/>\\376\\377([^<]+)/g, function(e, y) {
                const c = y.replace(/\\([0-3])([0-7])([0-7])/g, function(p, m, g, n) {
                  return String.fromCharCode(m * 64 + g * 8 + n * 1);
                }).replace(/&(amp|apos|gt|lt|quot);/g, function(p, m) {
                  switch (m) {
                    case "amp":
                      return "&";
                    case "apos":
                      return "'";
                    case "gt":
                      return ">";
                    case "lt":
                      return "<";
                    case "quot":
                      return '"';
                  }
                  throw new Error(`_repair: ${m} isn't defined.`);
                }), d = [];
                for (let p = 0, m = c.length; p < m; p += 2) {
                  const g = c.charCodeAt(p) * 256 + c.charCodeAt(p + 1);
                  g >= 32 && g < 127 && g !== 60 && g !== 62 && g !== 38 ? d.push(String.fromCharCode(g)) : d.push("&#x" + (65536 + g).toString(16).substring(1) + ";");
                }
                return ">" + d.join("");
              });
            }
            _getSequence(h) {
              const e = h.nodeName;
              return e !== "rdf:bag" && e !== "rdf:seq" && e !== "rdf:alt" ? null : h.childNodes.filter((y) => y.nodeName === "rdf:li");
            }
            _parseArray(h) {
              if (!h.hasChildNodes())
                return;
              const [e] = h.childNodes, y = this._getSequence(e) || [];
              this._metadataMap.set(h.nodeName, y.map((c) => c.textContent.trim()));
            }
            _parse(h) {
              let e = h.documentElement;
              if (e.nodeName !== "rdf:rdf")
                for (e = e.firstChild; e && e.nodeName !== "rdf:rdf"; )
                  e = e.nextSibling;
              if (!(!e || e.nodeName !== "rdf:rdf" || !e.hasChildNodes())) {
                for (const y of e.childNodes)
                  if (y.nodeName === "rdf:description")
                    for (const c of y.childNodes) {
                      const d = c.nodeName;
                      switch (d) {
                        case "#text":
                          continue;
                        case "dc:creator":
                        case "dc:subject":
                          this._parseArray(c);
                          continue;
                      }
                      this._metadataMap.set(d, c.textContent.trim());
                    }
              }
            }
            get serializable() {
              return {
                parsedData: this._metadataMap,
                rawData: this._data
              };
            }
          }
          o.MetadataParser = a;
        },
        /* 74 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.StructTreeRoot = o.StructTreePage = void 0;
          var t = C(5), a = C(2), v = C(70);
          const h = 40, e = {
            PAGE_CONTENT: "PAGE_CONTENT",
            STREAM_CONTENT: "STREAM_CONTENT",
            OBJECT: "OBJECT",
            ELEMENT: "ELEMENT"
          };
          class y {
            constructor(g) {
              this.dict = g, this.roleMap = /* @__PURE__ */ new Map();
            }
            init() {
              this.readRoleMap();
            }
            readRoleMap() {
              const g = this.dict.get("RoleMap");
              g instanceof t.Dict && g.forEach((n, i) => {
                i instanceof t.Name && this.roleMap.set(n, i.name);
              });
            }
          }
          o.StructTreeRoot = y;
          class c {
            constructor(g, n) {
              this.tree = g, this.dict = n, this.kids = [], this.parseKids();
            }
            get role() {
              const g = this.dict.get("S"), n = g instanceof t.Name ? g.name : "", {
                root: i
              } = this.tree;
              return i.roleMap.has(n) ? i.roleMap.get(n) : n;
            }
            parseKids() {
              let g = null;
              const n = this.dict.getRaw("Pg");
              n instanceof t.Ref && (g = n.toString());
              const i = this.dict.get("K");
              if (Array.isArray(i))
                for (const l of i) {
                  const u = this.parseKid(g, l);
                  u && this.kids.push(u);
                }
              else {
                const l = this.parseKid(g, i);
                l && this.kids.push(l);
              }
            }
            parseKid(g, n) {
              if (Number.isInteger(n))
                return this.tree.pageDict.objId !== g ? null : new d({
                  type: e.PAGE_CONTENT,
                  mcid: n,
                  pageObjId: g
                });
              let i = null;
              if (n instanceof t.Ref ? i = this.dict.xref.fetch(n) : n instanceof t.Dict && (i = n), !i)
                return null;
              const l = i.getRaw("Pg");
              l instanceof t.Ref && (g = l.toString());
              const u = i.get("Type") instanceof t.Name ? i.get("Type").name : null;
              return u === "MCR" ? this.tree.pageDict.objId !== g ? null : new d({
                type: e.STREAM_CONTENT,
                refObjId: i.getRaw("Stm") instanceof t.Ref ? i.getRaw("Stm").toString() : null,
                pageObjId: g,
                mcid: i.get("MCID")
              }) : u === "OBJR" ? this.tree.pageDict.objId !== g ? null : new d({
                type: e.OBJECT,
                refObjId: i.getRaw("Obj") instanceof t.Ref ? i.getRaw("Obj").toString() : null,
                pageObjId: g
              }) : new d({
                type: e.ELEMENT,
                dict: i
              });
            }
          }
          class d {
            constructor({
              type: g,
              dict: n = null,
              mcid: i = null,
              pageObjId: l = null,
              refObjId: u = null
            }) {
              this.type = g, this.dict = n, this.mcid = i, this.pageObjId = l, this.refObjId = u, this.parentNode = null;
            }
          }
          class p {
            constructor(g, n) {
              this.root = g, this.rootDict = g ? g.dict : null, this.pageDict = n, this.nodes = [];
            }
            parse() {
              if (!this.root || !this.rootDict)
                return;
              const g = this.rootDict.get("ParentTree");
              if (!g)
                return;
              const n = this.pageDict.get("StructParents");
              if (!Number.isInteger(n))
                return;
              const l = new v.NumberTree(g, this.rootDict.xref).get(n);
              if (!Array.isArray(l))
                return;
              const u = /* @__PURE__ */ new Map();
              for (const w of l)
                w instanceof t.Ref && this.addNode(this.rootDict.xref.fetch(w), u);
            }
            addNode(g, n, i = 0) {
              if (i > h)
                return (0, a.warn)("StructTree MAX_DEPTH reached."), null;
              if (n.has(g))
                return n.get(g);
              const l = new c(this, g);
              n.set(g, l);
              const u = g.get("P");
              if (!u || (0, t.isName)(u.get("Type"), "StructTreeRoot"))
                return this.addTopLevelNode(g, l) || n.delete(g), l;
              const w = this.addNode(u, n, i + 1);
              if (!w)
                return l;
              let _ = !1;
              for (const b of w.kids)
                b.type === e.ELEMENT && b.dict === g && (b.parentNode = l, _ = !0);
              return _ || n.delete(g), l;
            }
            addTopLevelNode(g, n) {
              const i = this.rootDict.get("K");
              if (!i)
                return !1;
              if (i instanceof t.Dict)
                return i.objId !== g.objId ? !1 : (this.nodes[0] = n, !0);
              if (!Array.isArray(i))
                return !0;
              let l = !1;
              for (let u = 0; u < i.length; u++) {
                const w = i[u];
                w && w.toString() === g.objId && (this.nodes[u] = n, l = !0);
              }
              return l;
            }
            get serializable() {
              function g(i, l, u = 0) {
                if (u > h) {
                  (0, a.warn)("StructTree too deep to be fully serialized.");
                  return;
                }
                const w = /* @__PURE__ */ Object.create(null);
                w.role = i.role, w.children = [], l.children.push(w);
                const _ = i.dict.get("Alt");
                typeof _ == "string" && (w.alt = (0, a.stringToPDFString)(_));
                const b = i.dict.get("Lang");
                typeof b == "string" && (w.lang = (0, a.stringToPDFString)(b));
                for (const A of i.kids) {
                  const Y = A.type === e.ELEMENT ? A.parentNode : null;
                  if (Y) {
                    g(Y, w, u + 1);
                    continue;
                  } else
                    A.type === e.PAGE_CONTENT || A.type === e.STREAM_CONTENT ? w.children.push({
                      type: "content",
                      id: `page${A.pageObjId}_mcid${A.mcid}`
                    }) : A.type === e.OBJECT && w.children.push({
                      type: "object",
                      id: A.refObjId
                    });
                }
              }
              const n = /* @__PURE__ */ Object.create(null);
              n.children = [], n.role = "Root";
              for (const i of this.nodes)
                i && g(i, n);
              return n;
            }
          }
          o.StructTreePage = p;
        },
        /* 75 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.ObjectLoader = void 0;
          var t = C(5), a = C(7), v = C(6), h = C(2);
          function e(d) {
            return d instanceof t.Ref || d instanceof t.Dict || d instanceof a.BaseStream || Array.isArray(d);
          }
          function y(d, p) {
            if (d instanceof t.Dict)
              d = d.getRawValues();
            else if (d instanceof a.BaseStream)
              d = d.dict.getRawValues();
            else if (!Array.isArray(d))
              return;
            for (const m of d)
              e(m) && p.push(m);
          }
          class c {
            constructor(p, m, g) {
              this.dict = p, this.keys = m, this.xref = g, this.refSet = null;
            }
            async load() {
              if (this.xref.stream.isDataLoaded)
                return;
              const {
                keys: p,
                dict: m
              } = this;
              this.refSet = new t.RefSet();
              const g = [];
              for (let n = 0, i = p.length; n < i; n++) {
                const l = m.getRaw(p[n]);
                l !== void 0 && g.push(l);
              }
              return this._walk(g);
            }
            async _walk(p) {
              const m = [], g = [];
              for (; p.length; ) {
                let n = p.pop();
                if (n instanceof t.Ref) {
                  if (this.refSet.has(n))
                    continue;
                  try {
                    this.refSet.put(n), n = this.xref.fetch(n);
                  } catch (i) {
                    if (!(i instanceof v.MissingDataException)) {
                      (0, h.warn)(`ObjectLoader._walk - requesting all data: "${i}".`), this.refSet = null;
                      const {
                        manager: l
                      } = this.xref.stream;
                      return l.requestAllChunks();
                    }
                    m.push(n), g.push({
                      begin: i.begin,
                      end: i.end
                    });
                  }
                }
                if (n instanceof a.BaseStream) {
                  const i = n.getBaseStreams();
                  if (i) {
                    let l = !1;
                    for (const u of i)
                      u.isDataLoaded || (l = !0, g.push({
                        begin: u.start,
                        end: u.end
                      }));
                    l && m.push(n);
                  }
                }
                y(n, p);
              }
              if (g.length) {
                await this.xref.stream.manager.requestRanges(g);
                for (const n of m)
                  n instanceof t.Ref && this.refSet.remove(n);
                return this._walk(m);
              }
              this.refSet = null;
            }
          }
          o.ObjectLoader = c;
        },
        /* 76 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.XFAFactory = void 0;
          var t = C(77), a = C(81), v = C(87), h = C(85), e = C(78), y = C(2), c = C(88), d = C(98);
          class p {
            constructor(g) {
              try {
                this.root = new c.XFAParser().parse(p._createDocument(g));
                const n = new a.Binder(this.root);
                this.form = n.bind(), this.dataHandler = new v.DataHandler(this.root, n.getData()), this.form[t.$globalData].template = this.form;
              } catch (n) {
                (0, y.warn)(`XFA - an error occurred during parsing and binding: ${n}`);
              }
            }
            isValid() {
              return this.root && this.form;
            }
            _createPagesHelper() {
              const g = this.form[t.$toPages]();
              return new Promise((n, i) => {
                const l = () => {
                  try {
                    const u = g.next();
                    u.done ? n(u.value) : setTimeout(l, 0);
                  } catch (u) {
                    i(u);
                  }
                };
                setTimeout(l, 0);
              });
            }
            async _createPages() {
              try {
                this.pages = await this._createPagesHelper(), this.dims = this.pages.children.map((g) => {
                  const {
                    width: n,
                    height: i
                  } = g.attributes.style;
                  return [0, 0, parseInt(n), parseInt(i)];
                });
              } catch (g) {
                (0, y.warn)(`XFA - an error occurred during layout: ${g}`);
              }
            }
            getBoundingBox(g) {
              return this.dims[g];
            }
            async getNumPages() {
              return this.pages || await this._createPages(), this.dims.length;
            }
            setImages(g) {
              this.form[t.$globalData].images = g;
            }
            setFonts(g) {
              this.form[t.$globalData].fontFinder = new h.FontFinder(g);
              const n = [];
              for (let i of this.form[t.$globalData].usedTypefaces)
                i = (0, e.stripQuotes)(i), this.form[t.$globalData].fontFinder.find(i) || n.push(i);
              return n.length > 0 ? n : null;
            }
            appendFonts(g, n) {
              this.form[t.$globalData].fontFinder.add(g, n);
            }
            async getPages() {
              this.pages || await this._createPages();
              const g = this.pages;
              return this.pages = null, g;
            }
            serializeData(g) {
              return this.dataHandler.serialize(g);
            }
            static _createDocument(g) {
              return g["/xdp:xdp"] ? Object.values(g).join("") : g["xdp:xdp"];
            }
            static getRichTextAsHtml(g) {
              if (!g || typeof g != "string")
                return null;
              try {
                let n = new c.XFAParser(d.XhtmlNamespace, !0).parse(g);
                if (!["body", "xhtml"].includes(n[t.$nodeName])) {
                  const w = d.XhtmlNamespace.body({});
                  w[t.$appendChild](n), n = w;
                }
                const i = n[t.$toHTML]();
                if (!i.success)
                  return null;
                const {
                  html: l
                } = i, {
                  attributes: u
                } = l;
                return u && (u.class && (u.class = u.class.filter((w) => !w.startsWith("xfa"))), u.dir = "auto"), {
                  html: l,
                  str: n[t.$text]()
                };
              } catch (n) {
                (0, y.warn)(`XFA - an error occurred during parsing of rich text: ${n}`);
              }
              return null;
            }
          }
          o.XFAFactory = p;
        },
        /* 77 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.XmlObject = o.XFAObjectArray = o.XFAObject = o.XFAAttribute = o.StringObject = o.OptionObject = o.Option10 = o.Option01 = o.IntegerObject = o.ContentObject = o.$uid = o.$toStyle = o.$toString = o.$toPages = o.$toHTML = o.$text = o.$tabIndex = o.$setValue = o.$setSetAttributes = o.$setId = o.$searchNode = o.$root = o.$resolvePrototypes = o.$removeChild = o.$pushPara = o.$pushGlyphs = o.$popPara = o.$onText = o.$onChildCheck = o.$onChild = o.$nsAttributes = o.$nodeName = o.$namespaceId = o.$isUsable = o.$isTransparent = o.$isThereMoreWidth = o.$isSplittable = o.$isNsAgnostic = o.$isDescendent = o.$isDataValue = o.$isCDATAXml = o.$isBindable = o.$insertAt = o.$indexOf = o.$ids = o.$hasSettableValue = o.$globalData = o.$getTemplateRoot = o.$getSubformParent = o.$getRealChildrenByNameIt = o.$getParent = o.$getNextPage = o.$getExtra = o.$getDataValue = o.$getContainedChildren = o.$getChildrenByNameIt = o.$getChildrenByName = o.$getChildrenByClass = o.$getChildren = o.$getAvailableSpace = o.$getAttributes = o.$getAttributeIt = o.$flushHTML = o.$finalize = o.$extra = o.$dump = o.$data = o.$content = o.$consumed = o.$clone = o.$cleanup = o.$cleanPage = o.$clean = o.$childrenToHTML = o.$appendChild = o.$addHTML = o.$acceptWhitespace = void 0;
          var t = C(78), a = C(2), v = C(6), h = C(79), e = C(80);
          const y = Symbol();
          o.$acceptWhitespace = y;
          const c = Symbol();
          o.$addHTML = c;
          const d = Symbol();
          o.$appendChild = d;
          const p = Symbol();
          o.$childrenToHTML = p;
          const m = Symbol();
          o.$clean = m;
          const g = Symbol();
          o.$cleanPage = g;
          const n = Symbol();
          o.$cleanup = n;
          const i = Symbol();
          o.$clone = i;
          const l = Symbol();
          o.$consumed = l;
          const u = Symbol("content");
          o.$content = u;
          const w = Symbol("data");
          o.$data = w;
          const _ = Symbol();
          o.$dump = _;
          const b = Symbol("extra");
          o.$extra = b;
          const A = Symbol();
          o.$finalize = A;
          const Y = Symbol();
          o.$flushHTML = Y;
          const j = Symbol();
          o.$getAttributeIt = j;
          const X = Symbol();
          o.$getAttributes = X;
          const B = Symbol();
          o.$getAvailableSpace = B;
          const R = Symbol();
          o.$getChildrenByClass = R;
          const k = Symbol();
          o.$getChildrenByName = k;
          const x = Symbol();
          o.$getChildrenByNameIt = x;
          const f = Symbol();
          o.$getDataValue = f;
          const U = Symbol();
          o.$getExtra = U;
          const O = Symbol();
          o.$getRealChildrenByNameIt = O;
          const S = Symbol();
          o.$getChildren = S;
          const F = Symbol();
          o.$getContainedChildren = F;
          const T = Symbol();
          o.$getNextPage = T;
          const I = Symbol();
          o.$getSubformParent = I;
          const M = Symbol();
          o.$getParent = M;
          const V = Symbol();
          o.$getTemplateRoot = V;
          const J = Symbol();
          o.$globalData = J;
          const W = Symbol();
          o.$hasSettableValue = W;
          const z = Symbol();
          o.$ids = z;
          const G = Symbol();
          o.$indexOf = G;
          const L = Symbol();
          o.$insertAt = L;
          const K = Symbol();
          o.$isCDATAXml = K;
          const te = Symbol();
          o.$isBindable = te;
          const se = Symbol();
          o.$isDataValue = se;
          const q = Symbol();
          o.$isDescendent = q;
          const N = Symbol();
          o.$isNsAgnostic = N;
          const Q = Symbol();
          o.$isSplittable = Q;
          const D = Symbol();
          o.$isThereMoreWidth = D;
          const ne = Symbol();
          o.$isTransparent = ne;
          const oe = Symbol();
          o.$isUsable = oe;
          const ee = Symbol(), $ = Symbol("namespaceId");
          o.$namespaceId = $;
          const E = Symbol("nodeName");
          o.$nodeName = E;
          const H = Symbol();
          o.$nsAttributes = H;
          const ie = Symbol();
          o.$onChild = ie;
          const ue = Symbol();
          o.$onChildCheck = ue;
          const fe = Symbol();
          o.$onText = fe;
          const de = Symbol();
          o.$pushGlyphs = de;
          const pe = Symbol();
          o.$popPara = pe;
          const xe = Symbol();
          o.$pushPara = xe;
          const De = Symbol();
          o.$removeChild = De;
          const Ae = Symbol("root");
          o.$root = Ae;
          const Se = Symbol();
          o.$resolvePrototypes = Se;
          const ke = Symbol();
          o.$searchNode = ke;
          const ye = Symbol();
          o.$setId = ye;
          const _e = Symbol();
          o.$setSetAttributes = _e;
          const we = Symbol();
          o.$setValue = we;
          const Ce = Symbol();
          o.$tabIndex = Ce;
          const ve = Symbol();
          o.$text = ve;
          const Le = Symbol();
          o.$toPages = Le;
          const He = Symbol();
          o.$toHTML = He;
          const Qe = Symbol();
          o.$toString = Qe;
          const Ue = Symbol();
          o.$toStyle = Ue;
          const Ie = Symbol("uid");
          o.$uid = Ie;
          const Ee = Symbol(), et = Symbol(), qe = Symbol(), tt = Symbol("_children"), ft = Symbol(), Te = Symbol(), je = Symbol(), Ze = Symbol(), Me = Symbol(), at = Symbol(), rt = Symbol(), xt = Symbol(), ut = Symbol(), yt = Symbol("parent"), ht = Symbol(), Rt = Symbol(), Wt = Symbol();
          let Ke = 0;
          const Ge = h.NamespaceIds.datasets.id;
          class nt {
            constructor(Pe, We, Je = !1) {
              this[$] = Pe, this[E] = We, this[rt] = Je, this[yt] = null, this[tt] = [], this[Ie] = `${We}${Ke++}`, this[J] = null;
            }
            [ie](Pe) {
              if (!this[rt] || !this[ue](Pe))
                return !1;
              const We = Pe[E], Je = this[We];
              if (Je instanceof it) {
                if (Je.push(Pe))
                  return this[d](Pe), !0;
              } else
                return Je !== null && this[De](Je), this[We] = Pe, this[d](Pe), !0;
              let Ye = "";
              return this.id ? Ye = ` (id: ${this.id})` : this.name && (Ye = ` (name: ${this.name} ${this.h.value})`), (0, a.warn)(`XFA - node "${this[E]}"${Ye} has already enough "${We}"!`), !1;
            }
            [ue](Pe) {
              return this.hasOwnProperty(Pe[E]) && Pe[$] === this[$];
            }
            [N]() {
              return !1;
            }
            [y]() {
              return !1;
            }
            [K]() {
              return !1;
            }
            [te]() {
              return !1;
            }
            [pe]() {
              this.para && this[V]()[b].paraStack.pop();
            }
            [xe]() {
              this[V]()[b].paraStack.push(this.para);
            }
            [ye](Pe) {
              this.id && this[$] === h.NamespaceIds.template.id && Pe.set(this.id, this);
            }
            [V]() {
              return this[J].template;
            }
            [Q]() {
              return !1;
            }
            [D]() {
              return !1;
            }
            [d](Pe) {
              Pe[yt] = this, this[tt].push(Pe), !Pe[J] && this[J] && (Pe[J] = this[J]);
            }
            [De](Pe) {
              const We = this[tt].indexOf(Pe);
              this[tt].splice(We, 1);
            }
            [W]() {
              return this.hasOwnProperty("value");
            }
            [we](Pe) {
            }
            [fe](Pe) {
            }
            [A]() {
            }
            [m](Pe) {
              delete this[rt], this[n] && (Pe.clean(this[n]), delete this[n]);
            }
            [G](Pe) {
              return this[tt].indexOf(Pe);
            }
            [L](Pe, We) {
              We[yt] = this, this[tt].splice(Pe, 0, We), !We[J] && this[J] && (We[J] = this[J]);
            }
            [ne]() {
              return !this.name;
            }
            [ee]() {
              return "";
            }
            [ve]() {
              return this[tt].length === 0 ? this[u] : this[tt].map((Pe) => Pe[ve]()).join("");
            }
            get [qe]() {
              const Pe = Object.getPrototypeOf(this);
              if (!Pe._attributes) {
                const We = Pe._attributes = /* @__PURE__ */ new Set();
                for (const Je of Object.getOwnPropertyNames(this)) {
                  if (this[Je] === null || this[Je] instanceof nt || this[Je] instanceof it)
                    break;
                  We.add(Je);
                }
              }
              return (0, a.shadow)(this, qe, Pe._attributes);
            }
            [q](Pe) {
              let We = this;
              for (; We; ) {
                if (We === Pe)
                  return !0;
                We = We[M]();
              }
              return !1;
            }
            [M]() {
              return this[yt];
            }
            [I]() {
              return this[M]();
            }
            [S](Pe = null) {
              return Pe ? this[Pe] : this[tt];
            }
            [_]() {
              const Pe = /* @__PURE__ */ Object.create(null);
              this[u] && (Pe.$content = this[u]);
              for (const We of Object.getOwnPropertyNames(this)) {
                const Je = this[We];
                Je !== null && (Je instanceof nt ? Pe[We] = Je[_]() : Je instanceof it ? Je.isEmpty() || (Pe[We] = Je.dump()) : Pe[We] = Je);
              }
              return Pe;
            }
            [Ue]() {
              return null;
            }
            [He]() {
              return t.HTMLResult.EMPTY;
            }
            *[F]() {
              for (const Pe of this[S]())
                yield Pe;
            }
            *[Ze](Pe, We) {
              for (const Je of this[F]())
                if (!Pe || We === Pe.has(Je[E])) {
                  const Ye = this[B](), gt = Je[He](Ye);
                  gt.success || (this[b].failingNode = Je), yield gt;
                }
            }
            [Y]() {
              return null;
            }
            [c](Pe, We) {
              this[b].children.push(Pe);
            }
            [B]() {
            }
            [p]({
              filter: Pe = null,
              include: We = !0
            }) {
              if (!this[b].generator)
                this[b].generator = this[Ze](Pe, We);
              else {
                const Je = this[B](), Ye = this[b].failingNode[He](Je);
                if (!Ye.success)
                  return Ye;
                Ye.html && this[c](Ye.html, Ye.bbox), delete this[b].failingNode;
              }
              for (; ; ) {
                const Je = this[b].generator.next();
                if (Je.done)
                  break;
                const Ye = Je.value;
                if (!Ye.success)
                  return Ye;
                Ye.html && this[c](Ye.html, Ye.bbox);
              }
              return this[b].generator = null, t.HTMLResult.EMPTY;
            }
            [_e](Pe) {
              this[Rt] = new Set(Object.keys(Pe));
            }
            [at](Pe) {
              const We = this[qe], Je = this[Rt];
              return [...Pe].filter((Ye) => We.has(Ye) && !Je.has(Ye));
            }
            [Se](Pe, We = /* @__PURE__ */ new Set()) {
              for (const Je of this[tt])
                Je[ht](Pe, We);
            }
            [ht](Pe, We) {
              const Je = this[Me](Pe, We);
              Je ? this[Ee](Je, Pe, We) : this[Se](Pe, We);
            }
            [Me](Pe, We) {
              const {
                use: Je,
                usehref: Ye
              } = this;
              if (!Je && !Ye)
                return null;
              let gt = null, Dt = null, Xt = null, kt = Je;
              if (Ye ? (kt = Ye, Ye.startsWith("#som(") && Ye.endsWith(")") ? Dt = Ye.slice(5, Ye.length - 1) : Ye.startsWith(".#som(") && Ye.endsWith(")") ? Dt = Ye.slice(6, Ye.length - 1) : Ye.startsWith("#") ? Xt = Ye.slice(1) : Ye.startsWith(".#") && (Xt = Ye.slice(2))) : Je.startsWith("#") ? Xt = Je.slice(1) : Dt = Je, this.use = this.usehref = "", Xt ? gt = Pe.get(Xt) : (gt = (0, e.searchNode)(Pe.get(Ae), this, Dt, !0, !1), gt && (gt = gt[0])), !gt)
                return (0, a.warn)(`XFA - Invalid prototype reference: ${kt}.`), null;
              if (gt[E] !== this[E])
                return (0, a.warn)(`XFA - Incompatible prototype: ${gt[E]} !== ${this[E]}.`), null;
              if (We.has(gt))
                return (0, a.warn)("XFA - Cycle detected in prototypes use."), null;
              We.add(gt);
              const Pt = gt[Me](Pe, We);
              return Pt && gt[Ee](Pt, Pe, We), gt[Se](Pe, We), We.delete(gt), gt;
            }
            [Ee](Pe, We, Je) {
              if (Je.has(Pe)) {
                (0, a.warn)("XFA - Cycle detected in prototypes use.");
                return;
              }
              !this[u] && Pe[u] && (this[u] = Pe[u]), new Set(Je).add(Pe);
              for (const gt of this[at](Pe[Rt]))
                this[gt] = Pe[gt], this[Rt] && this[Rt].add(gt);
              for (const gt of Object.getOwnPropertyNames(this)) {
                if (this[qe].has(gt))
                  continue;
                const Dt = this[gt], Xt = Pe[gt];
                if (Dt instanceof it) {
                  for (const kt of Dt[tt])
                    kt[ht](We, Je);
                  for (let kt = Dt[tt].length, Pt = Xt[tt].length; kt < Pt; kt++) {
                    const zt = Pe[tt][kt][i]();
                    if (Dt.push(zt))
                      zt[yt] = this, this[tt].push(zt), zt[ht](We, Je);
                    else
                      break;
                  }
                  continue;
                }
                if (Dt !== null) {
                  Dt[Se](We, Je), Xt && Dt[Ee](Xt, We, Je);
                  continue;
                }
                if (Xt !== null) {
                  const kt = Xt[i]();
                  kt[yt] = this, this[gt] = kt, this[tt].push(kt), kt[ht](We, Je);
                }
              }
            }
            static [ft](Pe) {
              return Array.isArray(Pe) ? Pe.map((We) => nt[ft](We)) : typeof Pe == "object" && Pe !== null ? Object.assign({}, Pe) : Pe;
            }
            [i]() {
              const Pe = Object.create(Object.getPrototypeOf(this));
              for (const We of Object.getOwnPropertySymbols(this))
                try {
                  Pe[We] = this[We];
                } catch {
                  (0, a.shadow)(Pe, We, this[We]);
                }
              Pe[Ie] = `${Pe[E]}${Ke++}`, Pe[tt] = [];
              for (const We of Object.getOwnPropertyNames(this)) {
                if (this[qe].has(We)) {
                  Pe[We] = nt[ft](this[We]);
                  continue;
                }
                const Je = this[We];
                Je instanceof it ? Pe[We] = new it(Je[xt]) : Pe[We] = null;
              }
              for (const We of this[tt]) {
                const Je = We[E], Ye = We[i]();
                Pe[tt].push(Ye), Ye[yt] = Pe, Pe[Je] === null ? Pe[Je] = Ye : Pe[Je][tt].push(Ye);
              }
              return Pe;
            }
            [S](Pe = null) {
              return Pe ? this[tt].filter((We) => We[E] === Pe) : this[tt];
            }
            [R](Pe) {
              return this[Pe];
            }
            [k](Pe, We, Je = !0) {
              return Array.from(this[x](Pe, We, Je));
            }
            *[x](Pe, We, Je = !0) {
              if (Pe === "parent") {
                yield this[yt];
                return;
              }
              for (const Ye of this[tt])
                Ye[E] === Pe && (yield Ye), Ye.name === Pe && (yield Ye), (We || Ye[ne]()) && (yield* Ye[x](Pe, We, !1));
              Je && this[qe].has(Pe) && (yield new pt(this, Pe, this[Pe]));
            }
          }
          o.XFAObject = nt;
          class it {
            constructor(Pe = 1 / 0) {
              this[xt] = Pe, this[tt] = [];
            }
            push(Pe) {
              return this[tt].length <= this[xt] ? (this[tt].push(Pe), !0) : ((0, a.warn)(`XFA - node "${Pe[E]}" accepts no more than ${this[xt]} children`), !1);
            }
            isEmpty() {
              return this[tt].length === 0;
            }
            dump() {
              return this[tt].length === 1 ? this[tt][0][_]() : this[tt].map((Pe) => Pe[_]());
            }
            [i]() {
              const Pe = new it(this[xt]);
              return Pe[tt] = this[tt].map((We) => We[i]()), Pe;
            }
            get children() {
              return this[tt];
            }
            clear() {
              this[tt].length = 0;
            }
          }
          o.XFAObjectArray = it;
          class pt {
            constructor(Pe, We, Je) {
              this[yt] = Pe, this[E] = We, this[u] = Je, this[l] = !1, this[Ie] = `attribute${Ke++}`;
            }
            [M]() {
              return this[yt];
            }
            [se]() {
              return !0;
            }
            [f]() {
              return this[u].trim();
            }
            [we](Pe) {
              Pe = Pe.value || "", this[u] = Pe.toString();
            }
            [ve]() {
              return this[u];
            }
            [q](Pe) {
              return this[yt] === Pe || this[yt][q](Pe);
            }
          }
          o.XFAAttribute = pt;
          class Ft extends nt {
            constructor(Pe, We, Je = {}) {
              if (super(Pe, We), this[u] = "", this[Te] = null, We !== "#text") {
                const Ye = /* @__PURE__ */ new Map();
                this[et] = Ye;
                for (const [gt, Dt] of Object.entries(Je))
                  Ye.set(gt, new pt(this, gt, Dt));
                if (Je.hasOwnProperty(H)) {
                  const gt = Je[H].xfa.dataNode;
                  gt !== void 0 && (gt === "dataGroup" ? this[Te] = !1 : gt === "dataValue" && (this[Te] = !0));
                }
              }
              this[l] = !1;
            }
            [Qe](Pe) {
              const We = this[E];
              if (We === "#text") {
                Pe.push((0, v.encodeToXmlString)(this[u]));
                return;
              }
              const Je = (0, a.utf8StringToString)(We), Ye = this[$] === Ge ? "xfa:" : "";
              Pe.push(`<${Ye}${Je}`);
              for (const [gt, Dt] of this[et].entries()) {
                const Xt = (0, a.utf8StringToString)(gt);
                Pe.push(` ${Xt}="${(0, v.encodeToXmlString)(Dt[u])}"`);
              }
              if (this[Te] !== null && (this[Te] ? Pe.push(' xfa:dataNode="dataValue"') : Pe.push(' xfa:dataNode="dataGroup"')), !this[u] && this[tt].length === 0) {
                Pe.push("/>");
                return;
              }
              if (Pe.push(">"), this[u])
                typeof this[u] == "string" ? Pe.push((0, v.encodeToXmlString)(this[u])) : this[u][Qe](Pe);
              else
                for (const gt of this[tt])
                  gt[Qe](Pe);
              Pe.push(`</${Ye}${Je}>`);
            }
            [ie](Pe) {
              if (this[u]) {
                const We = new Ft(this[$], "#text");
                this[d](We), We[u] = this[u], this[u] = "";
              }
              return this[d](Pe), !0;
            }
            [fe](Pe) {
              this[u] += Pe;
            }
            [A]() {
              if (this[u] && this[tt].length > 0) {
                const Pe = new Ft(this[$], "#text");
                this[d](Pe), Pe[u] = this[u], delete this[u];
              }
            }
            [He]() {
              return this[E] === "#text" ? t.HTMLResult.success({
                name: "#text",
                value: this[u]
              }) : t.HTMLResult.EMPTY;
            }
            [S](Pe = null) {
              return Pe ? this[tt].filter((We) => We[E] === Pe) : this[tt];
            }
            [X]() {
              return this[et];
            }
            [R](Pe) {
              const We = this[et].get(Pe);
              return We !== void 0 ? We : this[S](Pe);
            }
            *[x](Pe, We) {
              const Je = this[et].get(Pe);
              Je && (yield Je);
              for (const Ye of this[tt])
                Ye[E] === Pe && (yield Ye), We && (yield* Ye[x](Pe, We));
            }
            *[j](Pe, We) {
              const Je = this[et].get(Pe);
              Je && (!We || !Je[l]) && (yield Je);
              for (const Ye of this[tt])
                yield* Ye[j](Pe, We);
            }
            *[O](Pe, We, Je) {
              for (const Ye of this[tt])
                Ye[E] === Pe && (!Je || !Ye[l]) && (yield Ye), We && (yield* Ye[O](Pe, We, Je));
            }
            [se]() {
              return this[Te] === null ? this[tt].length === 0 || this[tt][0][$] === h.NamespaceIds.xhtml.id : this[Te];
            }
            [f]() {
              return this[Te] === null ? this[tt].length === 0 ? this[u].trim() : this[tt][0][$] === h.NamespaceIds.xhtml.id ? this[tt][0][ve]().trim() : null : this[u].trim();
            }
            [we](Pe) {
              Pe = Pe.value || "", this[u] = Pe.toString();
            }
            [_](Pe = !1) {
              const We = /* @__PURE__ */ Object.create(null);
              Pe && (We.$ns = this[$]), this[u] && (We.$content = this[u]), We.$name = this[E], We.children = [];
              for (const Je of this[tt])
                We.children.push(Je[_](Pe));
              We.attributes = /* @__PURE__ */ Object.create(null);
              for (const [Je, Ye] of this[et])
                We.attributes[Je] = Ye[u];
              return We;
            }
          }
          o.XmlObject = Ft;
          class mt extends nt {
            constructor(Pe, We) {
              super(Pe, We), this[u] = "";
            }
            [fe](Pe) {
              this[u] += Pe;
            }
            [A]() {
            }
          }
          o.ContentObject = mt;
          class ct extends mt {
            constructor(Pe, We, Je) {
              super(Pe, We), this[ut] = Je;
            }
            [A]() {
              this[u] = (0, t.getKeyword)({
                data: this[u],
                defaultValue: this[ut][0],
                validate: (Pe) => this[ut].includes(Pe)
              });
            }
            [m](Pe) {
              super[m](Pe), delete this[ut];
            }
          }
          o.OptionObject = ct;
          class bt extends mt {
            [A]() {
              this[u] = this[u].trim();
            }
          }
          o.StringObject = bt;
          class wt extends mt {
            constructor(Pe, We, Je, Ye) {
              super(Pe, We), this[je] = Je, this[Wt] = Ye;
            }
            [A]() {
              this[u] = (0, t.getInteger)({
                data: this[u],
                defaultValue: this[je],
                validate: this[Wt]
              });
            }
            [m](Pe) {
              super[m](Pe), delete this[je], delete this[Wt];
            }
          }
          o.IntegerObject = wt;
          class Ot extends wt {
            constructor(Pe, We) {
              super(Pe, We, 0, (Je) => Je === 1);
            }
          }
          o.Option01 = Ot;
          class Et extends wt {
            constructor(Pe, We) {
              super(Pe, We, 1, (Je) => Je === 0);
            }
          }
          o.Option10 = Et;
        },
        /* 78 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.HTMLResult = void 0, o.getBBox = i, o.getColor = n, o.getFloat = y, o.getInteger = e, o.getKeyword = c, o.getMeasurement = p, o.getRatio = m, o.getRelevant = g, o.getStringOption = d, o.stripQuotes = h;
          var t = C(2);
          const a = {
            pt: (u) => u,
            cm: (u) => u / 2.54 * 72,
            mm: (u) => u / (10 * 2.54) * 72,
            in: (u) => u * 72,
            px: (u) => u
          }, v = /([+-]?\d+\.?\d*)(.*)/;
          function h(u) {
            return u.startsWith("'") || u.startsWith('"') ? u.slice(1, u.length - 1) : u;
          }
          function e({
            data: u,
            defaultValue: w,
            validate: _
          }) {
            if (!u)
              return w;
            u = u.trim();
            const b = parseInt(u, 10);
            return !isNaN(b) && _(b) ? b : w;
          }
          function y({
            data: u,
            defaultValue: w,
            validate: _
          }) {
            if (!u)
              return w;
            u = u.trim();
            const b = parseFloat(u);
            return !isNaN(b) && _(b) ? b : w;
          }
          function c({
            data: u,
            defaultValue: w,
            validate: _
          }) {
            return u ? (u = u.trim(), _(u) ? u : w) : w;
          }
          function d(u, w) {
            return c({
              data: u,
              defaultValue: w[0],
              validate: (_) => w.includes(_)
            });
          }
          function p(u, w = "0") {
            if (w = w || "0", !u)
              return p(w);
            const _ = u.trim().match(v);
            if (!_)
              return p(w);
            const [, b, A] = _, Y = parseFloat(b);
            if (isNaN(Y))
              return p(w);
            if (Y === 0)
              return 0;
            const j = a[A];
            return j ? j(Y) : Y;
          }
          function m(u) {
            if (!u)
              return {
                num: 1,
                den: 1
              };
            const w = u.trim().split(/\s*:\s*/).map((A) => parseFloat(A)).filter((A) => !isNaN(A));
            if (w.length === 1 && w.push(1), w.length === 0)
              return {
                num: 1,
                den: 1
              };
            const [_, b] = w;
            return {
              num: _,
              den: b
            };
          }
          function g(u) {
            return u ? u.trim().split(/\s+/).map((w) => ({
              excluded: w[0] === "-",
              viewname: w.substring(1)
            })) : [];
          }
          function n(u, w = [0, 0, 0]) {
            let [_, b, A] = w;
            if (!u)
              return {
                r: _,
                g: b,
                b: A
              };
            const Y = u.trim().split(/\s*,\s*/).map((j) => Math.min(Math.max(0, parseInt(j.trim(), 10)), 255)).map((j) => isNaN(j) ? 0 : j);
            return Y.length < 3 ? {
              r: _,
              g: b,
              b: A
            } : ([_, b, A] = Y, {
              r: _,
              g: b,
              b: A
            });
          }
          function i(u) {
            if (!u)
              return {
                x: -1,
                y: -1,
                width: -1,
                height: -1
              };
            const _ = u.trim().split(/\s*,\s*/).map((X) => p(X, "-1"));
            if (_.length < 4 || _[2] < 0 || _[3] < 0)
              return {
                x: -1,
                y: -1,
                width: -1,
                height: -1
              };
            const [b, A, Y, j] = _;
            return {
              x: b,
              y: A,
              width: Y,
              height: j
            };
          }
          class l {
            static get FAILURE() {
              return (0, t.shadow)(this, "FAILURE", new l(!1, null, null, null));
            }
            static get EMPTY() {
              return (0, t.shadow)(this, "EMPTY", new l(!0, null, null, null));
            }
            constructor(w, _, b, A) {
              this.success = w, this.html = _, this.bbox = b, this.breakNode = A;
            }
            isBreak() {
              return !!this.breakNode;
            }
            static breakNode(w) {
              return new l(!1, null, null, w);
            }
            static success(w, _ = null) {
              return new l(!0, w, _, null);
            }
          }
          o.HTMLResult = l;
        },
        /* 79 */
        /***/
        (Z, o) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.NamespaceIds = o.$buildXFAObject = void 0;
          const C = Symbol();
          o.$buildXFAObject = C;
          const t = {
            config: {
              id: 0,
              check: (a) => a.startsWith("http://www.xfa.org/schema/xci/")
            },
            connectionSet: {
              id: 1,
              check: (a) => a.startsWith("http://www.xfa.org/schema/xfa-connection-set/")
            },
            datasets: {
              id: 2,
              check: (a) => a.startsWith("http://www.xfa.org/schema/xfa-data/")
            },
            form: {
              id: 3,
              check: (a) => a.startsWith("http://www.xfa.org/schema/xfa-form/")
            },
            localeSet: {
              id: 4,
              check: (a) => a.startsWith("http://www.xfa.org/schema/xfa-locale-set/")
            },
            pdf: {
              id: 5,
              check: (a) => a === "http://ns.adobe.com/xdp/pdf/"
            },
            signature: {
              id: 6,
              check: (a) => a === "http://www.w3.org/2000/09/xmldsig#"
            },
            sourceSet: {
              id: 7,
              check: (a) => a.startsWith("http://www.xfa.org/schema/xfa-source-set/")
            },
            stylesheet: {
              id: 8,
              check: (a) => a === "http://www.w3.org/1999/XSL/Transform"
            },
            template: {
              id: 9,
              check: (a) => a.startsWith("http://www.xfa.org/schema/xfa-template/")
            },
            xdc: {
              id: 10,
              check: (a) => a.startsWith("http://www.xfa.org/schema/xdc/")
            },
            xdp: {
              id: 11,
              check: (a) => a === "http://ns.adobe.com/xdp/"
            },
            xfdf: {
              id: 12,
              check: (a) => a === "http://ns.adobe.com/xfdf/"
            },
            xhtml: {
              id: 13,
              check: (a) => a === "http://www.w3.org/1999/xhtml"
            },
            xmpmeta: {
              id: 14,
              check: (a) => a === "http://ns.adobe.com/xmpmeta/"
            }
          };
          o.NamespaceIds = t;
        },
        /* 80 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.createDataNode = l, o.searchNode = n;
          var t = C(77), a = C(79), v = C(2);
          const h = /^[^.[]+/, e = /^[^\]]+/, y = {
            dot: 0,
            dotDot: 1,
            dotHash: 2,
            dotBracket: 3,
            dotParen: 4
          }, c = /* @__PURE__ */ new Map([["$data", (u, w) => u.datasets ? u.datasets.data : u], ["$record", (u, w) => (u.datasets ? u.datasets.data : u)[t.$getChildren]()[0]], ["$template", (u, w) => u.template], ["$connectionSet", (u, w) => u.connectionSet], ["$form", (u, w) => u.form], ["$layout", (u, w) => u.layout], ["$host", (u, w) => u.host], ["$dataWindow", (u, w) => u.dataWindow], ["$event", (u, w) => u.event], ["!", (u, w) => u.datasets], ["$xfa", (u, w) => u], ["xfa", (u, w) => u], ["$", (u, w) => w]]), d = /* @__PURE__ */ new WeakMap(), p = a.NamespaceIds.datasets.id;
          function m(u) {
            return u = u.trim(), u === "*" ? 1 / 0 : parseInt(u, 10) || 0;
          }
          function g(u, w, _ = !0) {
            let b = u.match(h);
            if (!b)
              return null;
            let [A] = b;
            const Y = [{
              name: A,
              cacheName: "." + A,
              index: 0,
              js: null,
              formCalc: null,
              operator: y.dot
            }];
            let j = A.length;
            for (; j < u.length; ) {
              const X = j;
              if (u.charAt(j++) === "[") {
                if (b = u.slice(j).match(e), !b)
                  return (0, v.warn)("XFA - Invalid index in SOM expression"), null;
                Y.at(-1).index = m(b[0]), j += b[0].length + 1;
                continue;
              }
              let R;
              switch (u.charAt(j)) {
                case ".":
                  if (!w)
                    return null;
                  j++, R = y.dotDot;
                  break;
                case "#":
                  j++, R = y.dotHash;
                  break;
                case "[":
                  if (_)
                    return (0, v.warn)("XFA - SOM expression contains a FormCalc subexpression which is not supported for now."), null;
                  R = y.dotBracket;
                  break;
                case "(":
                  if (_)
                    return (0, v.warn)("XFA - SOM expression contains a JavaScript subexpression which is not supported for now."), null;
                  R = y.dotParen;
                  break;
                default:
                  R = y.dot;
                  break;
              }
              if (b = u.slice(j).match(h), !b)
                break;
              [A] = b, j += A.length, Y.push({
                name: A,
                cacheName: u.slice(X, j),
                operator: R,
                index: 0,
                js: null,
                formCalc: null
              });
            }
            return Y;
          }
          function n(u, w, _, b = !0, A = !0) {
            const Y = g(_, b);
            if (!Y)
              return null;
            const j = c.get(Y[0].name);
            let X = 0, B;
            j ? (B = !0, u = [j(u, w)], X = 1) : (B = w === null, u = [w || u]);
            for (let R = Y.length; X < R; X++) {
              const {
                name: k,
                cacheName: x,
                operator: f,
                index: U
              } = Y[X], O = [];
              for (const S of u) {
                if (!(S instanceof t.XFAObject))
                  continue;
                let F, T;
                if (A && (T = d.get(S), T || (T = /* @__PURE__ */ new Map(), d.set(S, T)), F = T.get(x)), !F) {
                  switch (f) {
                    case y.dot:
                      F = S[t.$getChildrenByName](k, !1);
                      break;
                    case y.dotDot:
                      F = S[t.$getChildrenByName](k, !0);
                      break;
                    case y.dotHash:
                      F = S[t.$getChildrenByClass](k), F instanceof t.XFAObjectArray ? F = F.children : F = [F];
                      break;
                  }
                  A && T.set(x, F);
                }
                F.length > 0 && O.push(F);
              }
              if (O.length === 0 && !B && X === 0) {
                if (w = w[t.$getParent](), !w)
                  return null;
                X = -1, u = [w];
                continue;
              }
              isFinite(U) ? u = O.filter((S) => U < S.length).map((S) => S[U]) : u = O.flat();
            }
            return u.length === 0 ? null : u;
          }
          function i(u, w) {
            let _ = null;
            for (const {
              name: b,
              index: A
            } of w) {
              for (let Y = 0, j = isFinite(A) ? A : 0; Y <= j; Y++) {
                const X = u[t.$namespaceId] === p ? -1 : u[t.$namespaceId];
                _ = new t.XmlObject(X, b), u[t.$appendChild](_);
              }
              u = _;
            }
            return _;
          }
          function l(u, w, _) {
            const b = g(_);
            if (!b || b.some((j) => j.operator === y.dotDot))
              return null;
            const A = c.get(b[0].name);
            let Y = 0;
            A ? (u = A(u, w), Y = 1) : u = w || u;
            for (let j = b.length; Y < j; Y++) {
              const {
                name: X,
                operator: B,
                index: R
              } = b[Y];
              if (!isFinite(R))
                return b[Y].index = 0, i(u, b.slice(Y));
              let k;
              switch (B) {
                case y.dot:
                  k = u[t.$getChildrenByName](X, !1);
                  break;
                case y.dotDot:
                  k = u[t.$getChildrenByName](X, !0);
                  break;
                case y.dotHash:
                  k = u[t.$getChildrenByClass](X), k instanceof t.XFAObjectArray ? k = k.children : k = [k];
                  break;
              }
              if (k.length === 0)
                return i(u, b.slice(Y));
              if (R < k.length) {
                const x = k[R];
                if (!(x instanceof t.XFAObject))
                  return (0, v.warn)("XFA - Cannot create a node."), null;
                u = x;
              } else
                return b[Y].index = R - k.length, i(u, b.slice(Y));
            }
            return null;
          }
        },
        /* 81 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.Binder = void 0;
          var t = C(77), a = C(82), v = C(80), h = C(79), e = C(2);
          const y = h.NamespaceIds.datasets.id;
          function c(p) {
            const m = new a.Text({});
            return m[t.$content] = p, m;
          }
          class d {
            constructor(m) {
              this.root = m, this.datasets = m.datasets, m.datasets && m.datasets.data ? this.data = m.datasets.data : this.data = new t.XmlObject(h.NamespaceIds.datasets.id, "data"), this.emptyMerge = this.data[t.$getChildren]().length === 0, this.root.form = this.form = m.template[t.$clone]();
            }
            _isConsumeData() {
              return !this.emptyMerge && this._mergeMode;
            }
            _isMatchTemplate() {
              return !this._isConsumeData();
            }
            bind() {
              return this._bindElement(this.form, this.data), this.form;
            }
            getData() {
              return this.data;
            }
            _bindValue(m, g, n) {
              if (m[t.$data] = g, m[t.$hasSettableValue]())
                if (g[t.$isDataValue]()) {
                  const i = g[t.$getDataValue]();
                  m[t.$setValue](c(i));
                } else if (m instanceof a.Field && m.ui && m.ui.choiceList && m.ui.choiceList.open === "multiSelect") {
                  const i = g[t.$getChildren]().map((l) => l[t.$content].trim()).join(`
`);
                  m[t.$setValue](c(i));
                } else
                  this._isConsumeData() && (0, e.warn)("XFA - Nodes haven't the same type.");
              else
                !g[t.$isDataValue]() || this._isMatchTemplate() ? this._bindElement(m, g) : (0, e.warn)("XFA - Nodes haven't the same type.");
            }
            _findDataByNameToConsume(m, g, n, i) {
              if (!m)
                return null;
              let l, u;
              for (let w = 0; w < 3; w++) {
                for (l = n[t.$getRealChildrenByNameIt](m, !1, !0); u = l.next().value, !!u; )
                  if (g === u[t.$isDataValue]())
                    return u;
                if (n[t.$namespaceId] === h.NamespaceIds.datasets.id && n[t.$nodeName] === "data")
                  break;
                n = n[t.$getParent]();
              }
              return i ? (l = this.data[t.$getRealChildrenByNameIt](m, !0, !1), u = l.next().value, u || (l = this.data[t.$getAttributeIt](m, !0), u = l.next().value, u && u[t.$isDataValue]()) ? u : null) : null;
            }
            _setProperties(m, g) {
              if (m.hasOwnProperty("setProperty"))
                for (const {
                  ref: n,
                  target: i,
                  connection: l
                } of m.setProperty.children) {
                  if (l || !n)
                    continue;
                  const u = (0, v.searchNode)(this.root, g, n, !1, !1);
                  if (!u) {
                    (0, e.warn)(`XFA - Invalid reference: ${n}.`);
                    continue;
                  }
                  const [w] = u;
                  if (!w[t.$isDescendent](this.data)) {
                    (0, e.warn)("XFA - Invalid node: must be a data node.");
                    continue;
                  }
                  const _ = (0, v.searchNode)(this.root, m, i, !1, !1);
                  if (!_) {
                    (0, e.warn)(`XFA - Invalid target: ${i}.`);
                    continue;
                  }
                  const [b] = _;
                  if (!b[t.$isDescendent](m)) {
                    (0, e.warn)("XFA - Invalid target: must be a property or subproperty.");
                    continue;
                  }
                  const A = b[t.$getParent]();
                  if (b instanceof a.SetProperty || A instanceof a.SetProperty) {
                    (0, e.warn)("XFA - Invalid target: cannot be a setProperty or one of its properties.");
                    continue;
                  }
                  if (b instanceof a.BindItems || A instanceof a.BindItems) {
                    (0, e.warn)("XFA - Invalid target: cannot be a bindItems or one of its properties.");
                    continue;
                  }
                  const Y = w[t.$text](), j = b[t.$nodeName];
                  if (b instanceof t.XFAAttribute) {
                    const X = /* @__PURE__ */ Object.create(null);
                    X[j] = Y;
                    const B = Reflect.construct(Object.getPrototypeOf(A).constructor, [X]);
                    A[j] = B[j];
                    continue;
                  }
                  if (!b.hasOwnProperty(t.$content)) {
                    (0, e.warn)("XFA - Invalid node to use in setProperty");
                    continue;
                  }
                  b[t.$data] = w, b[t.$content] = Y, b[t.$finalize]();
                }
            }
            _bindItems(m, g) {
              if (!m.hasOwnProperty("items") || !m.hasOwnProperty("bindItems") || m.bindItems.isEmpty())
                return;
              for (const l of m.items.children)
                m[t.$removeChild](l);
              m.items.clear();
              const n = new a.Items({}), i = new a.Items({});
              m[t.$appendChild](n), m.items.push(n), m[t.$appendChild](i), m.items.push(i);
              for (const {
                ref: l,
                labelRef: u,
                valueRef: w,
                connection: _
              } of m.bindItems.children) {
                if (_ || !l)
                  continue;
                const b = (0, v.searchNode)(this.root, g, l, !1, !1);
                if (!b) {
                  (0, e.warn)(`XFA - Invalid reference: ${l}.`);
                  continue;
                }
                for (const A of b) {
                  if (!A[t.$isDescendent](this.datasets)) {
                    (0, e.warn)(`XFA - Invalid ref (${l}): must be a datasets child.`);
                    continue;
                  }
                  const Y = (0, v.searchNode)(this.root, A, u, !0, !1);
                  if (!Y) {
                    (0, e.warn)(`XFA - Invalid label: ${u}.`);
                    continue;
                  }
                  const [j] = Y;
                  if (!j[t.$isDescendent](this.datasets)) {
                    (0, e.warn)("XFA - Invalid label: must be a datasets child.");
                    continue;
                  }
                  const X = (0, v.searchNode)(this.root, A, w, !0, !1);
                  if (!X) {
                    (0, e.warn)(`XFA - Invalid value: ${w}.`);
                    continue;
                  }
                  const [B] = X;
                  if (!B[t.$isDescendent](this.datasets)) {
                    (0, e.warn)("XFA - Invalid value: must be a datasets child.");
                    continue;
                  }
                  const R = c(j[t.$text]()), k = c(B[t.$text]());
                  n[t.$appendChild](R), n.text.push(R), i[t.$appendChild](k), i.text.push(k);
                }
              }
            }
            _bindOccurrences(m, g, n) {
              let i;
              if (g.length > 1 && (i = m[t.$clone](), i[t.$removeChild](i.occur), i.occur = null), this._bindValue(m, g[0], n), this._setProperties(m, g[0]), this._bindItems(m, g[0]), g.length === 1)
                return;
              const l = m[t.$getParent](), u = m[t.$nodeName], w = l[t.$indexOf](m);
              for (let _ = 1, b = g.length; _ < b; _++) {
                const A = g[_], Y = i[t.$clone]();
                l[u].push(Y), l[t.$insertAt](w + _, Y), this._bindValue(Y, A, n), this._setProperties(Y, A), this._bindItems(Y, A);
              }
            }
            _createOccurrences(m) {
              if (!this.emptyMerge)
                return;
              const {
                occur: g
              } = m;
              if (!g || g.initial <= 1)
                return;
              const n = m[t.$getParent](), i = m[t.$nodeName];
              if (!(n[i] instanceof t.XFAObjectArray))
                return;
              let l;
              m.name ? l = n[i].children.filter((_) => _.name === m.name).length : l = n[i].children.length;
              const u = n[t.$indexOf](m) + 1, w = g.initial - l;
              if (w) {
                const _ = m[t.$clone]();
                _[t.$removeChild](_.occur), _.occur = null, n[i].push(_), n[t.$insertAt](u, _);
                for (let b = 1; b < w; b++) {
                  const A = _[t.$clone]();
                  n[i].push(A), n[t.$insertAt](u + b, A);
                }
              }
            }
            _getOccurInfo(m) {
              const {
                name: g,
                occur: n
              } = m;
              if (!n || !g)
                return [1, 1];
              const i = n.max === -1 ? 1 / 0 : n.max;
              return [n.min, i];
            }
            _setAndBind(m, g) {
              this._setProperties(m, g), this._bindItems(m, g), this._bindElement(m, g);
            }
            _bindElement(m, g) {
              const n = [];
              this._createOccurrences(m);
              for (const i of m[t.$getChildren]()) {
                if (i[t.$data])
                  continue;
                if (this._mergeMode === void 0 && i[t.$nodeName] === "subform") {
                  this._mergeMode = i.mergeMode === "consumeData";
                  const Y = g[t.$getChildren]();
                  if (Y.length > 0)
                    this._bindOccurrences(i, [Y[0]], null);
                  else if (this.emptyMerge) {
                    const j = g[t.$namespaceId] === y ? -1 : g[t.$namespaceId], X = i[t.$data] = new t.XmlObject(j, i.name || "root");
                    g[t.$appendChild](X), this._bindElement(i, X);
                  }
                  continue;
                }
                if (!i[t.$isBindable]())
                  continue;
                let l = !1, u = null, w = null, _ = null;
                if (i.bind) {
                  switch (i.bind.match) {
                    case "none":
                      this._setAndBind(i, g);
                      continue;
                    case "global":
                      l = !0;
                      break;
                    case "dataRef":
                      if (!i.bind.ref) {
                        (0, e.warn)(`XFA - ref is empty in node ${i[t.$nodeName]}.`), this._setAndBind(i, g);
                        continue;
                      }
                      w = i.bind.ref;
                      break;
                  }
                  i.bind.picture && (u = i.bind.picture[t.$content]);
                }
                const [b, A] = this._getOccurInfo(i);
                if (w)
                  if (_ = (0, v.searchNode)(this.root, g, w, !0, !1), _ === null) {
                    if (_ = (0, v.createDataNode)(this.data, g, w), !_)
                      continue;
                    this._isConsumeData() && (_[t.$consumed] = !0), this._setAndBind(i, _);
                    continue;
                  } else
                    this._isConsumeData() && (_ = _.filter((Y) => !Y[t.$consumed])), _.length > A ? _ = _.slice(0, A) : _.length === 0 && (_ = null), _ && this._isConsumeData() && _.forEach((Y) => {
                      Y[t.$consumed] = !0;
                    });
                else {
                  if (!i.name) {
                    this._setAndBind(i, g);
                    continue;
                  }
                  if (this._isConsumeData()) {
                    const Y = [];
                    for (; Y.length < A; ) {
                      const j = this._findDataByNameToConsume(i.name, i[t.$hasSettableValue](), g, l);
                      if (!j)
                        break;
                      j[t.$consumed] = !0, Y.push(j);
                    }
                    _ = Y.length > 0 ? Y : null;
                  } else {
                    if (_ = g[t.$getRealChildrenByNameIt](i.name, !1, this.emptyMerge).next().value, !_) {
                      if (b === 0) {
                        n.push(i);
                        continue;
                      }
                      const Y = g[t.$namespaceId] === y ? -1 : g[t.$namespaceId];
                      _ = i[t.$data] = new t.XmlObject(Y, i.name), this.emptyMerge && (_[t.$consumed] = !0), g[t.$appendChild](_), this._setAndBind(i, _);
                      continue;
                    }
                    this.emptyMerge && (_[t.$consumed] = !0), _ = [_];
                  }
                }
                _ ? this._bindOccurrences(i, _, u) : b > 0 ? this._setAndBind(i, g) : n.push(i);
              }
              n.forEach((i) => i[t.$getParent]()[t.$removeChild](i));
            }
          }
          o.Binder = d;
        },
        /* 82 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.Value = o.Text = o.TemplateNamespace = o.Template = o.SetProperty = o.Items = o.Field = o.BindItems = void 0;
          var t = C(77), a = C(79), v = C(83), h = C(84), e = C(78), y = C(2), c = C(85), d = C(6), p = C(80);
          const m = a.NamespaceIds.template.id, g = "http://www.w3.org/2000/svg", n = 2, i = 3, l = 5e3, u = /^H(\d+)$/, w = /* @__PURE__ */ new Set(["image/gif", "image/jpeg", "image/jpg", "image/pjpeg", "image/png", "image/apng", "image/x-png", "image/bmp", "image/x-ms-bmp", "image/tiff", "image/tif", "application/octet-stream"]), _ = [[[66, 77], "image/bmp"], [[255, 216, 255], "image/jpeg"], [[73, 73, 42, 0], "image/tiff"], [[77, 77, 0, 42], "image/tiff"], [[71, 73, 70, 56, 57, 97], "image/gif"], [[137, 80, 78, 71, 13, 10, 26, 10], "image/png"]];
          function b(Xe) {
            if (!Xe || !Xe.border)
              return {
                w: 0,
                h: 0
              };
            const P = Xe.border[t.$getExtra]();
            return P ? {
              w: P.widths[0] + P.widths[2] + P.insets[0] + P.insets[2],
              h: P.widths[1] + P.widths[3] + P.insets[1] + P.insets[3]
            } : {
              w: 0,
              h: 0
            };
          }
          function A(Xe) {
            return Xe.margin && (Xe.margin.topInset || Xe.margin.rightInset || Xe.margin.bottomInset || Xe.margin.leftInset);
          }
          function Y(Xe, P) {
            if (!Xe.value) {
              const he = new hn({});
              Xe[t.$appendChild](he), Xe.value = he;
            }
            Xe.value[t.$setValue](P);
          }
          function* j(Xe) {
            for (const P of Xe[t.$getChildren]()) {
              if (P instanceof on) {
                yield* P[t.$getContainedChildren]();
                continue;
              }
              yield P;
            }
          }
          function X(Xe) {
            return Xe.validate && Xe.validate.nullTest === "error";
          }
          function B(Xe) {
            for (; Xe; ) {
              if (!Xe.traversal) {
                Xe[t.$tabIndex] = Xe[t.$getParent]()[t.$tabIndex];
                return;
              }
              if (Xe[t.$tabIndex])
                return;
              let P = null;
              for (const Ve of Xe.traversal[t.$getChildren]())
                if (Ve.operation === "next") {
                  P = Ve;
                  break;
                }
              if (!P || !P.ref) {
                Xe[t.$tabIndex] = Xe[t.$getParent]()[t.$tabIndex];
                return;
              }
              const he = Xe[t.$getTemplateRoot]();
              Xe[t.$tabIndex] = ++he[t.$tabIndex];
              const Ne = he[t.$searchNode](P.ref, Xe);
              if (!Ne)
                return;
              Xe = Ne[0];
            }
          }
          function R(Xe, P) {
            const he = Xe.assist;
            if (he) {
              const Ne = he[t.$toHTML]();
              Ne && (P.title = Ne);
              const st = he.role.match(u);
              if (st) {
                const Tt = "heading", Ct = st[1];
                P.role = Tt, P["aria-level"] = Ct;
              }
            }
            if (Xe.layout === "table")
              P.role = "table";
            else if (Xe.layout === "row")
              P.role = "row";
            else {
              const Ne = Xe[t.$getParent]();
              Ne.layout === "row" && (Ne.assist && Ne.assist.role === "TH" ? P.role = "columnheader" : P.role = "cell");
            }
          }
          function k(Xe) {
            if (!Xe.assist)
              return null;
            const P = Xe.assist;
            return P.speak && P.speak[t.$content] !== "" ? P.speak[t.$content] : P.toolTip ? P.toolTip[t.$content] : null;
          }
          function x(Xe) {
            return e.HTMLResult.success({
              name: "div",
              attributes: {
                class: ["xfaRich"],
                style: /* @__PURE__ */ Object.create(null)
              },
              children: [{
                name: "span",
                attributes: {
                  style: /* @__PURE__ */ Object.create(null)
                },
                value: Xe
              }]
            });
          }
          function f(Xe) {
            const P = Xe[t.$getTemplateRoot]();
            P[t.$extra].firstUnsplittable === null && (P[t.$extra].firstUnsplittable = Xe, P[t.$extra].noLayoutFailure = !0);
          }
          function U(Xe) {
            const P = Xe[t.$getTemplateRoot]();
            P[t.$extra].firstUnsplittable === Xe && (P[t.$extra].noLayoutFailure = !1);
          }
          function O(Xe) {
            if (Xe[t.$extra] || (Xe[t.$extra] = /* @__PURE__ */ Object.create(null), Xe.targetType === "auto"))
              return !1;
            const P = Xe[t.$getTemplateRoot]();
            let he = null;
            if (Xe.target) {
              if (he = P[t.$searchNode](Xe.target, Xe[t.$getParent]()), !he)
                return !1;
              he = he[0];
            }
            const {
              currentPageArea: Ne,
              currentContentArea: Ve
            } = P[t.$extra];
            if (Xe.targetType === "pageArea")
              return he instanceof Ye || (he = null), Xe.startNew ? (Xe[t.$extra].target = he || Ne, !0) : he && he !== Ne ? (Xe[t.$extra].target = he, !0) : !1;
            he instanceof ie || (he = null);
            const st = he && he[t.$getParent]();
            let Tt, Ct = st;
            if (Xe.startNew)
              if (he) {
                const _t = st.contentArea.children, It = _t.indexOf(Ve), Bt = _t.indexOf(he);
                It !== -1 && It < Bt && (Ct = null), Tt = Bt - 1;
              } else
                Tt = Ne.contentArea.children.indexOf(Ve);
            else if (he && he !== Ve)
              Tt = st.contentArea.children.indexOf(he) - 1, Ct = st === Ne ? null : st;
            else
              return !1;
            return Xe[t.$extra].target = Ct, Xe[t.$extra].index = Tt, !0;
          }
          function S(Xe, P, he) {
            const Ne = Xe[t.$getTemplateRoot](), Ve = Ne[t.$extra].noLayoutFailure, st = P[t.$getSubformParent];
            P[t.$getSubformParent] = () => Xe, Ne[t.$extra].noLayoutFailure = !0;
            const Tt = P[t.$toHTML](he);
            Xe[t.$addHTML](Tt.html, Tt.bbox), Ne[t.$extra].noLayoutFailure = Ve, P[t.$getSubformParent] = st;
          }
          class F extends t.StringObject {
            constructor(P) {
              super(m, "appearanceFilter"), this.id = P.id || "", this.type = (0, e.getStringOption)(P.type, ["optional", "required"]), this.use = P.use || "", this.usehref = P.usehref || "";
            }
          }
          class T extends t.XFAObject {
            constructor(P) {
              super(m, "arc", !0), this.circular = (0, e.getInteger)({
                data: P.circular,
                defaultValue: 0,
                validate: (he) => he === 1
              }), this.hand = (0, e.getStringOption)(P.hand, ["even", "left", "right"]), this.id = P.id || "", this.startAngle = (0, e.getFloat)({
                data: P.startAngle,
                defaultValue: 0,
                validate: (he) => !0
              }), this.sweepAngle = (0, e.getFloat)({
                data: P.sweepAngle,
                defaultValue: 360,
                validate: (he) => !0
              }), this.use = P.use || "", this.usehref = P.usehref || "", this.edge = null, this.fill = null;
            }
            [t.$toHTML]() {
              const P = this.edge || new _e({}), he = P[t.$toStyle](), Ne = /* @__PURE__ */ Object.create(null);
              this.fill && this.fill.presence === "visible" ? Object.assign(Ne, this.fill[t.$toStyle]()) : Ne.fill = "transparent", Ne.strokeWidth = (0, h.measureToString)(P.presence === "visible" ? P.thickness : 0), Ne.stroke = he.color;
              let Ve;
              const st = {
                xmlns: g,
                style: {
                  width: "100%",
                  height: "100%",
                  overflow: "visible"
                }
              };
              if (this.sweepAngle === 360)
                Ve = {
                  name: "ellipse",
                  attributes: {
                    xmlns: g,
                    cx: "50%",
                    cy: "50%",
                    rx: "50%",
                    ry: "50%",
                    style: Ne
                  }
                };
              else {
                const _t = this.startAngle * Math.PI / 180, It = this.sweepAngle * Math.PI / 180, Bt = this.sweepAngle > 180 ? 1 : 0, [Vt, Ht, qt, Gt] = [50 * (1 + Math.cos(_t)), 50 * (1 - Math.sin(_t)), 50 * (1 + Math.cos(_t + It)), 50 * (1 - Math.sin(_t + It))];
                Ve = {
                  name: "path",
                  attributes: {
                    xmlns: g,
                    d: `M ${Vt} ${Ht} A 50 50 0 ${Bt} 0 ${qt} ${Gt}`,
                    vectorEffect: "non-scaling-stroke",
                    style: Ne
                  }
                }, Object.assign(st, {
                  viewBox: "0 0 100 100",
                  preserveAspectRatio: "none"
                });
              }
              const Tt = {
                name: "svg",
                children: [Ve],
                attributes: st
              }, Ct = this[t.$getParent]()[t.$getParent]();
              return A(Ct) ? e.HTMLResult.success({
                name: "div",
                attributes: {
                  style: {
                    display: "inline",
                    width: "100%",
                    height: "100%"
                  }
                },
                children: [Tt]
              }) : (Tt.attributes.style.position = "absolute", e.HTMLResult.success(Tt));
            }
          }
          class I extends t.XFAObject {
            constructor(P) {
              super(m, "area", !0), this.colSpan = (0, e.getInteger)({
                data: P.colSpan,
                defaultValue: 1,
                validate: (he) => he >= 1 || he === -1
              }), this.id = P.id || "", this.name = P.name || "", this.relevant = (0, e.getRelevant)(P.relevant), this.use = P.use || "", this.usehref = P.usehref || "", this.x = (0, e.getMeasurement)(P.x, "0pt"), this.y = (0, e.getMeasurement)(P.y, "0pt"), this.desc = null, this.extras = null, this.area = new t.XFAObjectArray(), this.draw = new t.XFAObjectArray(), this.exObject = new t.XFAObjectArray(), this.exclGroup = new t.XFAObjectArray(), this.field = new t.XFAObjectArray(), this.subform = new t.XFAObjectArray(), this.subformSet = new t.XFAObjectArray();
            }
            *[t.$getContainedChildren]() {
              yield* j(this);
            }
            [t.$isTransparent]() {
              return !0;
            }
            [t.$isBindable]() {
              return !0;
            }
            [t.$addHTML](P, he) {
              const [Ne, Ve, st, Tt] = he;
              this[t.$extra].width = Math.max(this[t.$extra].width, Ne + st), this[t.$extra].height = Math.max(this[t.$extra].height, Ve + Tt), this[t.$extra].children.push(P);
            }
            [t.$getAvailableSpace]() {
              return this[t.$extra].availableSpace;
            }
            [t.$toHTML](P) {
              const he = (0, h.toStyle)(this, "position"), Ne = {
                style: he,
                id: this[t.$uid],
                class: ["xfaArea"]
              };
              (0, h.isPrintOnly)(this) && Ne.class.push("xfaPrintOnly"), this.name && (Ne.xfaName = this.name);
              const Ve = [];
              this[t.$extra] = {
                children: Ve,
                width: 0,
                height: 0,
                availableSpace: P
              };
              const st = this[t.$childrenToHTML]({
                filter: /* @__PURE__ */ new Set(["area", "draw", "field", "exclGroup", "subform", "subformSet"]),
                include: !0
              });
              if (!st.success)
                return st.isBreak() ? st : (delete this[t.$extra], e.HTMLResult.FAILURE);
              he.width = (0, h.measureToString)(this[t.$extra].width), he.height = (0, h.measureToString)(this[t.$extra].height);
              const Tt = {
                name: "div",
                attributes: Ne,
                children: Ve
              }, Ct = [this.x, this.y, this[t.$extra].width, this[t.$extra].height];
              return delete this[t.$extra], e.HTMLResult.success(Tt, Ct);
            }
          }
          class M extends t.XFAObject {
            constructor(P) {
              super(m, "assist", !0), this.id = P.id || "", this.role = P.role || "", this.use = P.use || "", this.usehref = P.usehref || "", this.speak = null, this.toolTip = null;
            }
            [t.$toHTML]() {
              return this.toolTip && this.toolTip[t.$content] ? this.toolTip[t.$content] : null;
            }
          }
          class V extends t.XFAObject {
            constructor(P) {
              super(m, "barcode", !0), this.charEncoding = (0, e.getKeyword)({
                data: P.charEncoding ? P.charEncoding.toLowerCase() : "",
                defaultValue: "",
                validate: (he) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(he) || he.match(/iso-8859-\d{2}/)
              }), this.checksum = (0, e.getStringOption)(P.checksum, ["none", "1mod10", "1mod10_1mod11", "2mod10", "auto"]), this.dataColumnCount = (0, e.getInteger)({
                data: P.dataColumnCount,
                defaultValue: -1,
                validate: (he) => he >= 0
              }), this.dataLength = (0, e.getInteger)({
                data: P.dataLength,
                defaultValue: -1,
                validate: (he) => he >= 0
              }), this.dataPrep = (0, e.getStringOption)(P.dataPrep, ["none", "flateCompress"]), this.dataRowCount = (0, e.getInteger)({
                data: P.dataRowCount,
                defaultValue: -1,
                validate: (he) => he >= 0
              }), this.endChar = P.endChar || "", this.errorCorrectionLevel = (0, e.getInteger)({
                data: P.errorCorrectionLevel,
                defaultValue: -1,
                validate: (he) => he >= 0 && he <= 8
              }), this.id = P.id || "", this.moduleHeight = (0, e.getMeasurement)(P.moduleHeight, "5mm"), this.moduleWidth = (0, e.getMeasurement)(P.moduleWidth, "0.25mm"), this.printCheckDigit = (0, e.getInteger)({
                data: P.printCheckDigit,
                defaultValue: 0,
                validate: (he) => he === 1
              }), this.rowColumnRatio = (0, e.getRatio)(P.rowColumnRatio), this.startChar = P.startChar || "", this.textLocation = (0, e.getStringOption)(P.textLocation, ["below", "above", "aboveEmbedded", "belowEmbedded", "none"]), this.truncate = (0, e.getInteger)({
                data: P.truncate,
                defaultValue: 0,
                validate: (he) => he === 1
              }), this.type = (0, e.getStringOption)(P.type ? P.type.toLowerCase() : "", ["aztec", "codabar", "code2of5industrial", "code2of5interleaved", "code2of5matrix", "code2of5standard", "code3of9", "code3of9extended", "code11", "code49", "code93", "code128", "code128a", "code128b", "code128c", "code128sscc", "datamatrix", "ean8", "ean8add2", "ean8add5", "ean13", "ean13add2", "ean13add5", "ean13pwcd", "fim", "logmars", "maxicode", "msi", "pdf417", "pdf417macro", "plessey", "postauscust2", "postauscust3", "postausreplypaid", "postausstandard", "postukrm4scc", "postusdpbc", "postusimb", "postusstandard", "postus5zip", "qrcode", "rfid", "rss14", "rss14expanded", "rss14limited", "rss14stacked", "rss14stackedomni", "rss14truncated", "telepen", "ucc128", "ucc128random", "ucc128sscc", "upca", "upcaadd2", "upcaadd5", "upcapwcd", "upce", "upceadd2", "upceadd5", "upcean2", "upcean5", "upsmaxicode"]), this.upsMode = (0, e.getStringOption)(P.upsMode, ["usCarrier", "internationalCarrier", "secureSymbol", "standardSymbol"]), this.use = P.use || "", this.usehref = P.usehref || "", this.wideNarrowRatio = (0, e.getRatio)(P.wideNarrowRatio), this.encrypt = null, this.extras = null;
            }
          }
          class J extends t.XFAObject {
            constructor(P) {
              super(m, "bind", !0), this.match = (0, e.getStringOption)(P.match, ["once", "dataRef", "global", "none"]), this.ref = P.ref || "", this.picture = null;
            }
          }
          class W extends t.XFAObject {
            constructor(P) {
              super(m, "bindItems"), this.connection = P.connection || "", this.labelRef = P.labelRef || "", this.ref = P.ref || "", this.valueRef = P.valueRef || "";
            }
          }
          o.BindItems = W;
          class z extends t.XFAObject {
            constructor(P) {
              super(m, "bookend"), this.id = P.id || "", this.leader = P.leader || "", this.trailer = P.trailer || "", this.use = P.use || "", this.usehref = P.usehref || "";
            }
          }
          class G extends t.Option01 {
            constructor(P) {
              super(m, "boolean"), this.id = P.id || "", this.name = P.name || "", this.use = P.use || "", this.usehref = P.usehref || "";
            }
            [t.$toHTML](P) {
              return x(this[t.$content] === 1 ? "1" : "0");
            }
          }
          class L extends t.XFAObject {
            constructor(P) {
              super(m, "border", !0), this.break = (0, e.getStringOption)(P.break, ["close", "open"]), this.hand = (0, e.getStringOption)(P.hand, ["even", "left", "right"]), this.id = P.id || "", this.presence = (0, e.getStringOption)(P.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = (0, e.getRelevant)(P.relevant), this.use = P.use || "", this.usehref = P.usehref || "", this.corner = new t.XFAObjectArray(4), this.edge = new t.XFAObjectArray(4), this.extras = null, this.fill = null, this.margin = null;
            }
            [t.$getExtra]() {
              if (!this[t.$extra]) {
                const P = this.edge.children.slice();
                if (P.length < 4) {
                  const Ve = P.at(-1) || new _e({});
                  for (let st = P.length; st < 4; st++)
                    P.push(Ve);
                }
                const he = P.map((Ve) => Ve.thickness), Ne = [0, 0, 0, 0];
                this.margin && (Ne[0] = this.margin.topInset, Ne[1] = this.margin.rightInset, Ne[2] = this.margin.bottomInset, Ne[3] = this.margin.leftInset), this[t.$extra] = {
                  widths: he,
                  insets: Ne,
                  edges: P
                };
              }
              return this[t.$extra];
            }
            [t.$toStyle]() {
              const {
                edges: P
              } = this[t.$getExtra](), he = P.map((Ve) => {
                const st = Ve[t.$toStyle]();
                return st.color = st.color || "#000000", st;
              }), Ne = /* @__PURE__ */ Object.create(null);
              if (this.margin && Object.assign(Ne, this.margin[t.$toStyle]()), this.fill && this.fill.presence === "visible" && Object.assign(Ne, this.fill[t.$toStyle]()), this.corner.children.some((Ve) => Ve.radius !== 0)) {
                const Ve = this.corner.children.map((st) => st[t.$toStyle]());
                if (Ve.length === 2 || Ve.length === 3) {
                  const st = Ve.at(-1);
                  for (let Tt = Ve.length; Tt < 4; Tt++)
                    Ve.push(st);
                }
                Ne.borderRadius = Ve.map((st) => st.radius).join(" ");
              }
              switch (this.presence) {
                case "invisible":
                case "hidden":
                  Ne.borderStyle = "";
                  break;
                case "inactive":
                  Ne.borderStyle = "none";
                  break;
                default:
                  Ne.borderStyle = he.map((Ve) => Ve.style).join(" ");
                  break;
              }
              return Ne.borderWidth = he.map((Ve) => Ve.width).join(" "), Ne.borderColor = he.map((Ve) => Ve.color).join(" "), Ne;
            }
          }
          class K extends t.XFAObject {
            constructor(P) {
              super(m, "break", !0), this.after = (0, e.getStringOption)(P.after, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]), this.afterTarget = P.afterTarget || "", this.before = (0, e.getStringOption)(P.before, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]), this.beforeTarget = P.beforeTarget || "", this.bookendLeader = P.bookendLeader || "", this.bookendTrailer = P.bookendTrailer || "", this.id = P.id || "", this.overflowLeader = P.overflowLeader || "", this.overflowTarget = P.overflowTarget || "", this.overflowTrailer = P.overflowTrailer || "", this.startNew = (0, e.getInteger)({
                data: P.startNew,
                defaultValue: 0,
                validate: (he) => he === 1
              }), this.use = P.use || "", this.usehref = P.usehref || "", this.extras = null;
            }
          }
          class te extends t.XFAObject {
            constructor(P) {
              super(m, "breakAfter", !0), this.id = P.id || "", this.leader = P.leader || "", this.startNew = (0, e.getInteger)({
                data: P.startNew,
                defaultValue: 0,
                validate: (he) => he === 1
              }), this.target = P.target || "", this.targetType = (0, e.getStringOption)(P.targetType, ["auto", "contentArea", "pageArea"]), this.trailer = P.trailer || "", this.use = P.use || "", this.usehref = P.usehref || "", this.script = null;
            }
          }
          class se extends t.XFAObject {
            constructor(P) {
              super(m, "breakBefore", !0), this.id = P.id || "", this.leader = P.leader || "", this.startNew = (0, e.getInteger)({
                data: P.startNew,
                defaultValue: 0,
                validate: (he) => he === 1
              }), this.target = P.target || "", this.targetType = (0, e.getStringOption)(P.targetType, ["auto", "contentArea", "pageArea"]), this.trailer = P.trailer || "", this.use = P.use || "", this.usehref = P.usehref || "", this.script = null;
            }
            [t.$toHTML](P) {
              return this[t.$extra] = {}, e.HTMLResult.FAILURE;
            }
          }
          class q extends t.XFAObject {
            constructor(P) {
              super(m, "button", !0), this.highlight = (0, e.getStringOption)(P.highlight, ["inverted", "none", "outline", "push"]), this.id = P.id || "", this.use = P.use || "", this.usehref = P.usehref || "", this.extras = null;
            }
            [t.$toHTML](P) {
              const Ne = this[t.$getParent]()[t.$getParent](), Ve = {
                name: "button",
                attributes: {
                  id: this[t.$uid],
                  class: ["xfaButton"],
                  style: {}
                },
                children: []
              };
              for (const st of Ne.event.children) {
                if (st.activity !== "click" || !st.script)
                  continue;
                const Tt = (0, d.recoverJsURL)(st.script[t.$content]);
                if (!Tt)
                  continue;
                const Ct = (0, h.fixURL)(Tt.url);
                Ct && Ve.children.push({
                  name: "a",
                  attributes: {
                    id: "link" + this[t.$uid],
                    href: Ct,
                    newWindow: Tt.newWindow,
                    class: ["xfaLink"],
                    style: {}
                  },
                  children: []
                });
              }
              return e.HTMLResult.success(Ve);
            }
          }
          class N extends t.XFAObject {
            constructor(P) {
              super(m, "calculate", !0), this.id = P.id || "", this.override = (0, e.getStringOption)(P.override, ["disabled", "error", "ignore", "warning"]), this.use = P.use || "", this.usehref = P.usehref || "", this.extras = null, this.message = null, this.script = null;
            }
          }
          class Q extends t.XFAObject {
            constructor(P) {
              super(m, "caption", !0), this.id = P.id || "", this.placement = (0, e.getStringOption)(P.placement, ["left", "bottom", "inline", "right", "top"]), this.presence = (0, e.getStringOption)(P.presence, ["visible", "hidden", "inactive", "invisible"]), this.reserve = Math.ceil((0, e.getMeasurement)(P.reserve)), this.use = P.use || "", this.usehref = P.usehref || "", this.extras = null, this.font = null, this.margin = null, this.para = null, this.value = null;
            }
            [t.$setValue](P) {
              Y(this, P);
            }
            [t.$getExtra](P) {
              if (!this[t.$extra]) {
                let {
                  width: he,
                  height: Ne
                } = P;
                switch (this.placement) {
                  case "left":
                  case "right":
                  case "inline":
                    he = this.reserve <= 0 ? he : this.reserve;
                    break;
                  case "top":
                  case "bottom":
                    Ne = this.reserve <= 0 ? Ne : this.reserve;
                    break;
                }
                this[t.$extra] = (0, h.layoutNode)(this, {
                  width: he,
                  height: Ne
                });
              }
              return this[t.$extra];
            }
            [t.$toHTML](P) {
              if (!this.value)
                return e.HTMLResult.EMPTY;
              this[t.$pushPara]();
              const he = this.value[t.$toHTML](P).html;
              if (!he)
                return this[t.$popPara](), e.HTMLResult.EMPTY;
              const Ne = this.reserve;
              if (this.reserve <= 0) {
                const {
                  w: Tt,
                  h: Ct
                } = this[t.$getExtra](P);
                switch (this.placement) {
                  case "left":
                  case "right":
                  case "inline":
                    this.reserve = Tt;
                    break;
                  case "top":
                  case "bottom":
                    this.reserve = Ct;
                    break;
                }
              }
              const Ve = [];
              typeof he == "string" ? Ve.push({
                name: "#text",
                value: he
              }) : Ve.push(he);
              const st = (0, h.toStyle)(this, "font", "margin", "visibility");
              switch (this.placement) {
                case "left":
                case "right":
                  this.reserve > 0 && (st.width = (0, h.measureToString)(this.reserve));
                  break;
                case "top":
                case "bottom":
                  this.reserve > 0 && (st.height = (0, h.measureToString)(this.reserve));
                  break;
              }
              return (0, h.setPara)(this, null, he), this[t.$popPara](), this.reserve = Ne, e.HTMLResult.success({
                name: "div",
                attributes: {
                  style: st,
                  class: ["xfaCaption"]
                },
                children: Ve
              });
            }
          }
          class D extends t.StringObject {
            constructor(P) {
              super(m, "certificate"), this.id = P.id || "", this.name = P.name || "", this.use = P.use || "", this.usehref = P.usehref || "";
            }
          }
          class ne extends t.XFAObject {
            constructor(P) {
              super(m, "certificates", !0), this.credentialServerPolicy = (0, e.getStringOption)(P.credentialServerPolicy, ["optional", "required"]), this.id = P.id || "", this.url = P.url || "", this.urlPolicy = P.urlPolicy || "", this.use = P.use || "", this.usehref = P.usehref || "", this.encryption = null, this.issuers = null, this.keyUsage = null, this.oids = null, this.signing = null, this.subjectDNs = null;
            }
          }
          class oe extends t.XFAObject {
            constructor(P) {
              super(m, "checkButton", !0), this.id = P.id || "", this.mark = (0, e.getStringOption)(P.mark, ["default", "check", "circle", "cross", "diamond", "square", "star"]), this.shape = (0, e.getStringOption)(P.shape, ["square", "round"]), this.size = (0, e.getMeasurement)(P.size, "10pt"), this.use = P.use || "", this.usehref = P.usehref || "", this.border = null, this.extras = null, this.margin = null;
            }
            [t.$toHTML](P) {
              const he = (0, h.toStyle)("margin"), Ne = (0, h.measureToString)(this.size);
              he.width = he.height = Ne;
              let Ve, st, Tt;
              const Ct = this[t.$getParent]()[t.$getParent](), _t = Ct.items.children.length && Ct.items.children[0][t.$toHTML]().html || [], It = {
                on: (_t[0] !== void 0 ? _t[0] : "on").toString(),
                off: (_t[1] !== void 0 ? _t[1] : "off").toString()
              }, Vt = (Ct.value && Ct.value[t.$text]() || "off") === It.on || void 0, Ht = Ct[t.$getSubformParent](), qt = Ct[t.$uid];
              let Gt;
              Ht instanceof qe ? (Tt = Ht[t.$uid], Ve = "radio", st = "xfaRadio", Gt = Ht[t.$data] && Ht[t.$data][t.$uid] || Ht[t.$uid]) : (Ve = "checkbox", st = "xfaCheckbox", Gt = Ct[t.$data] && Ct[t.$data][t.$uid] || Ct[t.$uid]);
              const Mt = {
                name: "input",
                attributes: {
                  class: [st],
                  style: he,
                  fieldId: qt,
                  dataId: Gt,
                  type: Ve,
                  checked: Vt,
                  xfaOn: It.on,
                  xfaOff: It.off,
                  "aria-label": k(Ct),
                  "aria-required": !1
                }
              };
              return Tt && (Mt.attributes.name = Tt), X(Ct) && (Mt.attributes["aria-required"] = !0, Mt.attributes.required = !0), e.HTMLResult.success({
                name: "label",
                attributes: {
                  class: ["xfaLabel"]
                },
                children: [Mt]
              });
            }
          }
          class ee extends t.XFAObject {
            constructor(P) {
              super(m, "choiceList", !0), this.commitOn = (0, e.getStringOption)(P.commitOn, ["select", "exit"]), this.id = P.id || "", this.open = (0, e.getStringOption)(P.open, ["userControl", "always", "multiSelect", "onEntry"]), this.textEntry = (0, e.getInteger)({
                data: P.textEntry,
                defaultValue: 0,
                validate: (he) => he === 1
              }), this.use = P.use || "", this.usehref = P.usehref || "", this.border = null, this.extras = null, this.margin = null;
            }
            [t.$toHTML](P) {
              const he = (0, h.toStyle)(this, "border", "margin"), Ve = this[t.$getParent]()[t.$getParent](), Tt = {
                fontSize: `calc(${Ve.font && Ve.font.size || 10}px * var(--scale-factor))`
              }, Ct = [];
              if (Ve.items.children.length > 0) {
                const It = Ve.items;
                let Bt = 0, Vt = 0;
                It.children.length === 2 && (Bt = It.children[0].save, Vt = 1 - Bt);
                const Ht = It.children[Bt][t.$toHTML]().html, qt = It.children[Vt][t.$toHTML]().html;
                let Gt = !1;
                const Mt = Ve.value && Ve.value[t.$text]() || "";
                for (let Kt = 0, Ut = Ht.length; Kt < Ut; Kt++) {
                  const Lt = {
                    name: "option",
                    attributes: {
                      value: qt[Kt] || Ht[Kt],
                      style: Tt
                    },
                    value: Ht[Kt]
                  };
                  qt[Kt] === Mt && (Lt.attributes.selected = Gt = !0), Ct.push(Lt);
                }
                Gt || Ct.splice(0, 0, {
                  name: "option",
                  attributes: {
                    hidden: !0,
                    selected: !0
                  },
                  value: " "
                });
              }
              const _t = {
                class: ["xfaSelect"],
                fieldId: Ve[t.$uid],
                dataId: Ve[t.$data] && Ve[t.$data][t.$uid] || Ve[t.$uid],
                style: he,
                "aria-label": k(Ve),
                "aria-required": !1
              };
              return X(Ve) && (_t["aria-required"] = !0, _t.required = !0), this.open === "multiSelect" && (_t.multiple = !0), e.HTMLResult.success({
                name: "label",
                attributes: {
                  class: ["xfaLabel"]
                },
                children: [{
                  name: "select",
                  children: Ct,
                  attributes: _t
                }]
              });
            }
          }
          class $ extends t.XFAObject {
            constructor(P) {
              super(m, "color", !0), this.cSpace = (0, e.getStringOption)(P.cSpace, ["SRGB"]), this.id = P.id || "", this.use = P.use || "", this.usehref = P.usehref || "", this.value = P.value ? (0, e.getColor)(P.value) : "", this.extras = null;
            }
            [t.$hasSettableValue]() {
              return !1;
            }
            [t.$toStyle]() {
              return this.value ? y.Util.makeHexColor(this.value.r, this.value.g, this.value.b) : null;
            }
          }
          class E extends t.XFAObject {
            constructor(P) {
              super(m, "comb"), this.id = P.id || "", this.numberOfCells = (0, e.getInteger)({
                data: P.numberOfCells,
                defaultValue: 0,
                validate: (he) => he >= 0
              }), this.use = P.use || "", this.usehref = P.usehref || "";
            }
          }
          class H extends t.XFAObject {
            constructor(P) {
              super(m, "connect", !0), this.connection = P.connection || "", this.id = P.id || "", this.ref = P.ref || "", this.usage = (0, e.getStringOption)(P.usage, ["exportAndImport", "exportOnly", "importOnly"]), this.use = P.use || "", this.usehref = P.usehref || "", this.picture = null;
            }
          }
          class ie extends t.XFAObject {
            constructor(P) {
              super(m, "contentArea", !0), this.h = (0, e.getMeasurement)(P.h), this.id = P.id || "", this.name = P.name || "", this.relevant = (0, e.getRelevant)(P.relevant), this.use = P.use || "", this.usehref = P.usehref || "", this.w = (0, e.getMeasurement)(P.w), this.x = (0, e.getMeasurement)(P.x, "0pt"), this.y = (0, e.getMeasurement)(P.y, "0pt"), this.desc = null, this.extras = null;
            }
            [t.$toHTML](P) {
              const he = (0, h.measureToString)(this.x), Ne = (0, h.measureToString)(this.y), Ve = {
                left: he,
                top: Ne,
                width: (0, h.measureToString)(this.w),
                height: (0, h.measureToString)(this.h)
              }, st = ["xfaContentarea"];
              return (0, h.isPrintOnly)(this) && st.push("xfaPrintOnly"), e.HTMLResult.success({
                name: "div",
                children: [],
                attributes: {
                  style: Ve,
                  class: st,
                  id: this[t.$uid]
                }
              });
            }
          }
          class ue extends t.XFAObject {
            constructor(P) {
              super(m, "corner", !0), this.id = P.id || "", this.inverted = (0, e.getInteger)({
                data: P.inverted,
                defaultValue: 0,
                validate: (he) => he === 1
              }), this.join = (0, e.getStringOption)(P.join, ["square", "round"]), this.presence = (0, e.getStringOption)(P.presence, ["visible", "hidden", "inactive", "invisible"]), this.radius = (0, e.getMeasurement)(P.radius), this.stroke = (0, e.getStringOption)(P.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]), this.thickness = (0, e.getMeasurement)(P.thickness, "0.5pt"), this.use = P.use || "", this.usehref = P.usehref || "", this.color = null, this.extras = null;
            }
            [t.$toStyle]() {
              const P = (0, h.toStyle)(this, "visibility");
              return P.radius = (0, h.measureToString)(this.join === "square" ? 0 : this.radius), P;
            }
          }
          class fe extends t.ContentObject {
            constructor(P) {
              super(m, "date"), this.id = P.id || "", this.name = P.name || "", this.use = P.use || "", this.usehref = P.usehref || "";
            }
            [t.$finalize]() {
              const P = this[t.$content].trim();
              this[t.$content] = P ? new Date(P) : null;
            }
            [t.$toHTML](P) {
              return x(this[t.$content] ? this[t.$content].toString() : "");
            }
          }
          class de extends t.ContentObject {
            constructor(P) {
              super(m, "dateTime"), this.id = P.id || "", this.name = P.name || "", this.use = P.use || "", this.usehref = P.usehref || "";
            }
            [t.$finalize]() {
              const P = this[t.$content].trim();
              this[t.$content] = P ? new Date(P) : null;
            }
            [t.$toHTML](P) {
              return x(this[t.$content] ? this[t.$content].toString() : "");
            }
          }
          class pe extends t.XFAObject {
            constructor(P) {
              super(m, "dateTimeEdit", !0), this.hScrollPolicy = (0, e.getStringOption)(P.hScrollPolicy, ["auto", "off", "on"]), this.id = P.id || "", this.picker = (0, e.getStringOption)(P.picker, ["host", "none"]), this.use = P.use || "", this.usehref = P.usehref || "", this.border = null, this.comb = null, this.extras = null, this.margin = null;
            }
            [t.$toHTML](P) {
              const he = (0, h.toStyle)(this, "border", "font", "margin"), Ne = this[t.$getParent]()[t.$getParent](), Ve = {
                name: "input",
                attributes: {
                  type: "text",
                  fieldId: Ne[t.$uid],
                  dataId: Ne[t.$data] && Ne[t.$data][t.$uid] || Ne[t.$uid],
                  class: ["xfaTextfield"],
                  style: he,
                  "aria-label": k(Ne),
                  "aria-required": !1
                }
              };
              return X(Ne) && (Ve.attributes["aria-required"] = !0, Ve.attributes.required = !0), e.HTMLResult.success({
                name: "label",
                attributes: {
                  class: ["xfaLabel"]
                },
                children: [Ve]
              });
            }
          }
          class xe extends t.ContentObject {
            constructor(P) {
              super(m, "decimal"), this.fracDigits = (0, e.getInteger)({
                data: P.fracDigits,
                defaultValue: 2,
                validate: (he) => !0
              }), this.id = P.id || "", this.leadDigits = (0, e.getInteger)({
                data: P.leadDigits,
                defaultValue: -1,
                validate: (he) => !0
              }), this.name = P.name || "", this.use = P.use || "", this.usehref = P.usehref || "";
            }
            [t.$finalize]() {
              const P = parseFloat(this[t.$content].trim());
              this[t.$content] = isNaN(P) ? null : P;
            }
            [t.$toHTML](P) {
              return x(this[t.$content] !== null ? this[t.$content].toString() : "");
            }
          }
          class De extends t.XFAObject {
            constructor(P) {
              super(m, "defaultUi", !0), this.id = P.id || "", this.use = P.use || "", this.usehref = P.usehref || "", this.extras = null;
            }
          }
          class Ae extends t.XFAObject {
            constructor(P) {
              super(m, "desc", !0), this.id = P.id || "", this.use = P.use || "", this.usehref = P.usehref || "", this.boolean = new t.XFAObjectArray(), this.date = new t.XFAObjectArray(), this.dateTime = new t.XFAObjectArray(), this.decimal = new t.XFAObjectArray(), this.exData = new t.XFAObjectArray(), this.float = new t.XFAObjectArray(), this.image = new t.XFAObjectArray(), this.integer = new t.XFAObjectArray(), this.text = new t.XFAObjectArray(), this.time = new t.XFAObjectArray();
            }
          }
          class Se extends t.OptionObject {
            constructor(P) {
              super(m, "digestMethod", ["", "SHA1", "SHA256", "SHA512", "RIPEMD160"]), this.id = P.id || "", this.use = P.use || "", this.usehref = P.usehref || "";
            }
          }
          class ke extends t.XFAObject {
            constructor(P) {
              super(m, "digestMethods", !0), this.id = P.id || "", this.type = (0, e.getStringOption)(P.type, ["optional", "required"]), this.use = P.use || "", this.usehref = P.usehref || "", this.digestMethod = new t.XFAObjectArray();
            }
          }
          class ye extends t.XFAObject {
            constructor(P) {
              super(m, "draw", !0), this.anchorType = (0, e.getStringOption)(P.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = (0, e.getInteger)({
                data: P.colSpan,
                defaultValue: 1,
                validate: (he) => he >= 1 || he === -1
              }), this.h = P.h ? (0, e.getMeasurement)(P.h) : "", this.hAlign = (0, e.getStringOption)(P.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = P.id || "", this.locale = P.locale || "", this.maxH = (0, e.getMeasurement)(P.maxH, "0pt"), this.maxW = (0, e.getMeasurement)(P.maxW, "0pt"), this.minH = (0, e.getMeasurement)(P.minH, "0pt"), this.minW = (0, e.getMeasurement)(P.minW, "0pt"), this.name = P.name || "", this.presence = (0, e.getStringOption)(P.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = (0, e.getRelevant)(P.relevant), this.rotate = (0, e.getInteger)({
                data: P.rotate,
                defaultValue: 0,
                validate: (he) => he % 90 === 0
              }), this.use = P.use || "", this.usehref = P.usehref || "", this.w = P.w ? (0, e.getMeasurement)(P.w) : "", this.x = (0, e.getMeasurement)(P.x, "0pt"), this.y = (0, e.getMeasurement)(P.y, "0pt"), this.assist = null, this.border = null, this.caption = null, this.desc = null, this.extras = null, this.font = null, this.keep = null, this.margin = null, this.para = null, this.traversal = null, this.ui = null, this.value = null, this.setProperty = new t.XFAObjectArray();
            }
            [t.$setValue](P) {
              Y(this, P);
            }
            [t.$toHTML](P) {
              if (B(this), this.presence === "hidden" || this.presence === "inactive")
                return e.HTMLResult.EMPTY;
              (0, h.fixDimensions)(this), this[t.$pushPara]();
              const he = this.w, Ne = this.h, {
                w: Ve,
                h: st,
                isBroken: Tt
              } = (0, h.layoutNode)(this, P);
              if (Ve && this.w === "") {
                if (Tt && this[t.$getSubformParent]()[t.$isThereMoreWidth]())
                  return this[t.$popPara](), e.HTMLResult.FAILURE;
                this.w = Ve;
              }
              if (st && this.h === "" && (this.h = st), f(this), !(0, v.checkDimensions)(this, P))
                return this.w = he, this.h = Ne, this[t.$popPara](), e.HTMLResult.FAILURE;
              U(this);
              const Ct = (0, h.toStyle)(this, "font", "hAlign", "dimensions", "position", "presence", "rotate", "anchorType", "border", "margin");
              (0, h.setMinMaxDimensions)(this, Ct), Ct.margin && (Ct.padding = Ct.margin, delete Ct.margin);
              const _t = ["xfaDraw"];
              this.font && _t.push("xfaFont"), (0, h.isPrintOnly)(this) && _t.push("xfaPrintOnly");
              const It = {
                style: Ct,
                id: this[t.$uid],
                class: _t
              };
              this.name && (It.xfaName = this.name);
              const Bt = {
                name: "div",
                attributes: It,
                children: []
              };
              R(this, It);
              const Vt = (0, h.computeBbox)(this, Bt, P), Ht = this.value ? this.value[t.$toHTML](P).html : null;
              return Ht === null ? (this.w = he, this.h = Ne, this[t.$popPara](), e.HTMLResult.success((0, h.createWrapper)(this, Bt), Vt)) : (Bt.children.push(Ht), (0, h.setPara)(this, Ct, Ht), this.w = he, this.h = Ne, this[t.$popPara](), e.HTMLResult.success((0, h.createWrapper)(this, Bt), Vt));
            }
          }
          class _e extends t.XFAObject {
            constructor(P) {
              super(m, "edge", !0), this.cap = (0, e.getStringOption)(P.cap, ["square", "butt", "round"]), this.id = P.id || "", this.presence = (0, e.getStringOption)(P.presence, ["visible", "hidden", "inactive", "invisible"]), this.stroke = (0, e.getStringOption)(P.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]), this.thickness = (0, e.getMeasurement)(P.thickness, "0.5pt"), this.use = P.use || "", this.usehref = P.usehref || "", this.color = null, this.extras = null;
            }
            [t.$toStyle]() {
              const P = (0, h.toStyle)(this, "visibility");
              if (Object.assign(P, {
                linecap: this.cap,
                width: (0, h.measureToString)(this.thickness),
                color: this.color ? this.color[t.$toStyle]() : "#000000",
                style: ""
              }), this.presence !== "visible")
                P.style = "none";
              else
                switch (this.stroke) {
                  case "solid":
                    P.style = "solid";
                    break;
                  case "dashDot":
                    P.style = "dashed";
                    break;
                  case "dashDotDot":
                    P.style = "dashed";
                    break;
                  case "dashed":
                    P.style = "dashed";
                    break;
                  case "dotted":
                    P.style = "dotted";
                    break;
                  case "embossed":
                    P.style = "ridge";
                    break;
                  case "etched":
                    P.style = "groove";
                    break;
                  case "lowered":
                    P.style = "inset";
                    break;
                  case "raised":
                    P.style = "outset";
                    break;
                }
              return P;
            }
          }
          class we extends t.OptionObject {
            constructor(P) {
              super(m, "encoding", ["adbe.x509.rsa_sha1", "adbe.pkcs7.detached", "adbe.pkcs7.sha1"]), this.id = P.id || "", this.use = P.use || "", this.usehref = P.usehref || "";
            }
          }
          class Ce extends t.XFAObject {
            constructor(P) {
              super(m, "encodings", !0), this.id = P.id || "", this.type = (0, e.getStringOption)(P.type, ["optional", "required"]), this.use = P.use || "", this.usehref = P.usehref || "", this.encoding = new t.XFAObjectArray();
            }
          }
          class ve extends t.XFAObject {
            constructor(P) {
              super(m, "encrypt", !0), this.id = P.id || "", this.use = P.use || "", this.usehref = P.usehref || "", this.certificate = null;
            }
          }
          class Le extends t.XFAObject {
            constructor(P) {
              super(m, "encryptData", !0), this.id = P.id || "", this.operation = (0, e.getStringOption)(P.operation, ["encrypt", "decrypt"]), this.target = P.target || "", this.use = P.use || "", this.usehref = P.usehref || "", this.filter = null, this.manifest = null;
            }
          }
          class He extends t.XFAObject {
            constructor(P) {
              super(m, "encryption", !0), this.id = P.id || "", this.type = (0, e.getStringOption)(P.type, ["optional", "required"]), this.use = P.use || "", this.usehref = P.usehref || "", this.certificate = new t.XFAObjectArray();
            }
          }
          class Qe extends t.OptionObject {
            constructor(P) {
              super(m, "encryptionMethod", ["", "AES256-CBC", "TRIPLEDES-CBC", "AES128-CBC", "AES192-CBC"]), this.id = P.id || "", this.use = P.use || "", this.usehref = P.usehref || "";
            }
          }
          class Ue extends t.XFAObject {
            constructor(P) {
              super(m, "encryptionMethods", !0), this.id = P.id || "", this.type = (0, e.getStringOption)(P.type, ["optional", "required"]), this.use = P.use || "", this.usehref = P.usehref || "", this.encryptionMethod = new t.XFAObjectArray();
            }
          }
          class Ie extends t.XFAObject {
            constructor(P) {
              super(m, "event", !0), this.activity = (0, e.getStringOption)(P.activity, ["click", "change", "docClose", "docReady", "enter", "exit", "full", "indexChange", "initialize", "mouseDown", "mouseEnter", "mouseExit", "mouseUp", "postExecute", "postOpen", "postPrint", "postSave", "postSign", "postSubmit", "preExecute", "preOpen", "prePrint", "preSave", "preSign", "preSubmit", "ready", "validationState"]), this.id = P.id || "", this.listen = (0, e.getStringOption)(P.listen, ["refOnly", "refAndDescendents"]), this.name = P.name || "", this.ref = P.ref || "", this.use = P.use || "", this.usehref = P.usehref || "", this.extras = null, this.encryptData = null, this.execute = null, this.script = null, this.signData = null, this.submit = null;
            }
          }
          class Ee extends t.ContentObject {
            constructor(P) {
              super(m, "exData"), this.contentType = P.contentType || "", this.href = P.href || "", this.id = P.id || "", this.maxLength = (0, e.getInteger)({
                data: P.maxLength,
                defaultValue: -1,
                validate: (he) => he >= -1
              }), this.name = P.name || "", this.rid = P.rid || "", this.transferEncoding = (0, e.getStringOption)(P.transferEncoding, ["none", "base64", "package"]), this.use = P.use || "", this.usehref = P.usehref || "";
            }
            [t.$isCDATAXml]() {
              return this.contentType === "text/html";
            }
            [t.$onChild](P) {
              return this.contentType === "text/html" && P[t.$namespaceId] === a.NamespaceIds.xhtml.id ? (this[t.$content] = P, !0) : this.contentType === "text/xml" ? (this[t.$content] = P, !0) : !1;
            }
            [t.$toHTML](P) {
              return this.contentType !== "text/html" || !this[t.$content] ? e.HTMLResult.EMPTY : this[t.$content][t.$toHTML](P);
            }
          }
          class et extends t.XFAObject {
            constructor(P) {
              super(m, "exObject", !0), this.archive = P.archive || "", this.classId = P.classId || "", this.codeBase = P.codeBase || "", this.codeType = P.codeType || "", this.id = P.id || "", this.name = P.name || "", this.use = P.use || "", this.usehref = P.usehref || "", this.extras = null, this.boolean = new t.XFAObjectArray(), this.date = new t.XFAObjectArray(), this.dateTime = new t.XFAObjectArray(), this.decimal = new t.XFAObjectArray(), this.exData = new t.XFAObjectArray(), this.exObject = new t.XFAObjectArray(), this.float = new t.XFAObjectArray(), this.image = new t.XFAObjectArray(), this.integer = new t.XFAObjectArray(), this.text = new t.XFAObjectArray(), this.time = new t.XFAObjectArray();
            }
          }
          class qe extends t.XFAObject {
            constructor(P) {
              super(m, "exclGroup", !0), this.access = (0, e.getStringOption)(P.access, ["open", "nonInteractive", "protected", "readOnly"]), this.accessKey = P.accessKey || "", this.anchorType = (0, e.getStringOption)(P.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = (0, e.getInteger)({
                data: P.colSpan,
                defaultValue: 1,
                validate: (he) => he >= 1 || he === -1
              }), this.h = P.h ? (0, e.getMeasurement)(P.h) : "", this.hAlign = (0, e.getStringOption)(P.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = P.id || "", this.layout = (0, e.getStringOption)(P.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]), this.maxH = (0, e.getMeasurement)(P.maxH, "0pt"), this.maxW = (0, e.getMeasurement)(P.maxW, "0pt"), this.minH = (0, e.getMeasurement)(P.minH, "0pt"), this.minW = (0, e.getMeasurement)(P.minW, "0pt"), this.name = P.name || "", this.presence = (0, e.getStringOption)(P.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = (0, e.getRelevant)(P.relevant), this.use = P.use || "", this.usehref = P.usehref || "", this.w = P.w ? (0, e.getMeasurement)(P.w) : "", this.x = (0, e.getMeasurement)(P.x, "0pt"), this.y = (0, e.getMeasurement)(P.y, "0pt"), this.assist = null, this.bind = null, this.border = null, this.calculate = null, this.caption = null, this.desc = null, this.extras = null, this.margin = null, this.para = null, this.traversal = null, this.validate = null, this.connect = new t.XFAObjectArray(), this.event = new t.XFAObjectArray(), this.field = new t.XFAObjectArray(), this.setProperty = new t.XFAObjectArray();
            }
            [t.$isBindable]() {
              return !0;
            }
            [t.$hasSettableValue]() {
              return !0;
            }
            [t.$setValue](P) {
              for (const he of this.field.children) {
                if (!he.value) {
                  const Ne = new hn({});
                  he[t.$appendChild](Ne), he.value = Ne;
                }
                he.value[t.$setValue](P);
              }
            }
            [t.$isThereMoreWidth]() {
              return this.layout.endsWith("-tb") && this[t.$extra].attempt === 0 && this[t.$extra].numberInLine > 0 || this[t.$getParent]()[t.$isThereMoreWidth]();
            }
            [t.$isSplittable]() {
              const P = this[t.$getSubformParent]();
              return P[t.$isSplittable]() ? this[t.$extra]._isSplittable !== void 0 ? this[t.$extra]._isSplittable : this.layout === "position" || this.layout.includes("row") ? (this[t.$extra]._isSplittable = !1, !1) : P.layout && P.layout.endsWith("-tb") && P[t.$extra].numberInLine !== 0 ? !1 : (this[t.$extra]._isSplittable = !0, !0) : !1;
            }
            [t.$flushHTML]() {
              return (0, v.flushHTML)(this);
            }
            [t.$addHTML](P, he) {
              (0, v.addHTML)(this, P, he);
            }
            [t.$getAvailableSpace]() {
              return (0, v.getAvailableSpace)(this);
            }
            [t.$toHTML](P) {
              if (B(this), this.presence === "hidden" || this.presence === "inactive" || this.h === 0 || this.w === 0)
                return e.HTMLResult.EMPTY;
              (0, h.fixDimensions)(this);
              const he = [], Ne = {
                id: this[t.$uid],
                class: []
              };
              (0, h.setAccess)(this, Ne.class), this[t.$extra] || (this[t.$extra] = /* @__PURE__ */ Object.create(null)), Object.assign(this[t.$extra], {
                children: he,
                attributes: Ne,
                attempt: 0,
                line: null,
                numberInLine: 0,
                availableSpace: {
                  width: Math.min(this.w || 1 / 0, P.width),
                  height: Math.min(this.h || 1 / 0, P.height)
                },
                width: 0,
                height: 0,
                prevHeight: 0,
                currentWidth: 0
              });
              const Ve = this[t.$isSplittable]();
              if (Ve || f(this), !(0, v.checkDimensions)(this, P))
                return e.HTMLResult.FAILURE;
              const st = /* @__PURE__ */ new Set(["field"]);
              if (this.layout.includes("row")) {
                const Ut = this[t.$getSubformParent]().columnWidths;
                Array.isArray(Ut) && Ut.length > 0 && (this[t.$extra].columnWidths = Ut, this[t.$extra].currentColumn = 0);
              }
              const Tt = (0, h.toStyle)(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), Ct = ["xfaExclgroup"], _t = (0, h.layoutClass)(this);
              _t && Ct.push(_t), (0, h.isPrintOnly)(this) && Ct.push("xfaPrintOnly"), Ne.style = Tt, Ne.class = Ct, this.name && (Ne.xfaName = this.name), this[t.$pushPara]();
              const It = this.layout === "lr-tb" || this.layout === "rl-tb", Bt = It ? n : 1;
              for (; this[t.$extra].attempt < Bt; this[t.$extra].attempt++) {
                It && this[t.$extra].attempt === n - 1 && (this[t.$extra].numberInLine = 0);
                const Ut = this[t.$childrenToHTML]({
                  filter: st,
                  include: !0
                });
                if (Ut.success)
                  break;
                if (Ut.isBreak())
                  return this[t.$popPara](), Ut;
                if (It && this[t.$extra].attempt === 0 && this[t.$extra].numberInLine === 0 && !this[t.$getTemplateRoot]()[t.$extra].noLayoutFailure) {
                  this[t.$extra].attempt = Bt;
                  break;
                }
              }
              if (this[t.$popPara](), Ve || U(this), this[t.$extra].attempt === Bt)
                return Ve || delete this[t.$extra], e.HTMLResult.FAILURE;
              let Vt = 0, Ht = 0;
              this.margin && (Vt = this.margin.leftInset + this.margin.rightInset, Ht = this.margin.topInset + this.margin.bottomInset);
              const qt = Math.max(this[t.$extra].width + Vt, this.w || 0), Gt = Math.max(this[t.$extra].height + Ht, this.h || 0), Mt = [this.x, this.y, qt, Gt];
              this.w === "" && (Tt.width = (0, h.measureToString)(qt)), this.h === "" && (Tt.height = (0, h.measureToString)(Gt));
              const Kt = {
                name: "div",
                attributes: Ne,
                children: he
              };
              return R(this, Ne), delete this[t.$extra], e.HTMLResult.success((0, h.createWrapper)(this, Kt), Mt);
            }
          }
          class tt extends t.XFAObject {
            constructor(P) {
              super(m, "execute"), this.connection = P.connection || "", this.executeType = (0, e.getStringOption)(P.executeType, ["import", "remerge"]), this.id = P.id || "", this.runAt = (0, e.getStringOption)(P.runAt, ["client", "both", "server"]), this.use = P.use || "", this.usehref = P.usehref || "";
            }
          }
          class ft extends t.XFAObject {
            constructor(P) {
              super(m, "extras", !0), this.id = P.id || "", this.name = P.name || "", this.use = P.use || "", this.usehref = P.usehref || "", this.boolean = new t.XFAObjectArray(), this.date = new t.XFAObjectArray(), this.dateTime = new t.XFAObjectArray(), this.decimal = new t.XFAObjectArray(), this.exData = new t.XFAObjectArray(), this.extras = new t.XFAObjectArray(), this.float = new t.XFAObjectArray(), this.image = new t.XFAObjectArray(), this.integer = new t.XFAObjectArray(), this.text = new t.XFAObjectArray(), this.time = new t.XFAObjectArray();
            }
          }
          class Te extends t.XFAObject {
            constructor(P) {
              super(m, "field", !0), this.access = (0, e.getStringOption)(P.access, ["open", "nonInteractive", "protected", "readOnly"]), this.accessKey = P.accessKey || "", this.anchorType = (0, e.getStringOption)(P.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = (0, e.getInteger)({
                data: P.colSpan,
                defaultValue: 1,
                validate: (he) => he >= 1 || he === -1
              }), this.h = P.h ? (0, e.getMeasurement)(P.h) : "", this.hAlign = (0, e.getStringOption)(P.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = P.id || "", this.locale = P.locale || "", this.maxH = (0, e.getMeasurement)(P.maxH, "0pt"), this.maxW = (0, e.getMeasurement)(P.maxW, "0pt"), this.minH = (0, e.getMeasurement)(P.minH, "0pt"), this.minW = (0, e.getMeasurement)(P.minW, "0pt"), this.name = P.name || "", this.presence = (0, e.getStringOption)(P.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = (0, e.getRelevant)(P.relevant), this.rotate = (0, e.getInteger)({
                data: P.rotate,
                defaultValue: 0,
                validate: (he) => he % 90 === 0
              }), this.use = P.use || "", this.usehref = P.usehref || "", this.w = P.w ? (0, e.getMeasurement)(P.w) : "", this.x = (0, e.getMeasurement)(P.x, "0pt"), this.y = (0, e.getMeasurement)(P.y, "0pt"), this.assist = null, this.bind = null, this.border = null, this.calculate = null, this.caption = null, this.desc = null, this.extras = null, this.font = null, this.format = null, this.items = new t.XFAObjectArray(2), this.keep = null, this.margin = null, this.para = null, this.traversal = null, this.ui = null, this.validate = null, this.value = null, this.bindItems = new t.XFAObjectArray(), this.connect = new t.XFAObjectArray(), this.event = new t.XFAObjectArray(), this.setProperty = new t.XFAObjectArray();
            }
            [t.$isBindable]() {
              return !0;
            }
            [t.$setValue](P) {
              Y(this, P);
            }
            [t.$toHTML](P) {
              if (B(this), !this.ui) {
                this.ui = new wn({}), this.ui[t.$globalData] = this[t.$globalData], this[t.$appendChild](this.ui);
                let Ut;
                switch (this.items.children.length) {
                  case 0:
                    Ut = new yn({}), this.ui.textEdit = Ut;
                    break;
                  case 1:
                    Ut = new oe({}), this.ui.checkButton = Ut;
                    break;
                  case 2:
                    Ut = new ee({}), this.ui.choiceList = Ut;
                    break;
                }
                this.ui[t.$appendChild](Ut);
              }
              if (!this.ui || this.presence === "hidden" || this.presence === "inactive" || this.h === 0 || this.w === 0)
                return e.HTMLResult.EMPTY;
              this.caption && delete this.caption[t.$extra], this[t.$pushPara]();
              const he = this.caption ? this.caption[t.$toHTML](P).html : null, Ne = this.w, Ve = this.h;
              let st = 0, Tt = 0;
              this.margin && (st = this.margin.leftInset + this.margin.rightInset, Tt = this.margin.topInset + this.margin.bottomInset);
              let Ct = null;
              if (this.w === "" || this.h === "") {
                let Ut = null, Lt = null, tn = 0, Nt = 0;
                if (this.ui.checkButton)
                  tn = Nt = this.ui.checkButton.size;
                else {
                  const {
                    w: ln,
                    h: rn
                  } = (0, h.layoutNode)(this, P);
                  ln !== null ? (tn = ln, Nt = rn) : Nt = (0, c.getMetrics)(this.font, !0).lineNoGap;
                }
                if (Ct = b(this.ui[t.$getExtra]()), tn += Ct.w, Nt += Ct.h, this.caption) {
                  const {
                    w: ln,
                    h: rn,
                    isBroken: Jt
                  } = this.caption[t.$getExtra](P);
                  if (Jt && this[t.$getSubformParent]()[t.$isThereMoreWidth]())
                    return this[t.$popPara](), e.HTMLResult.FAILURE;
                  switch (Ut = ln, Lt = rn, this.caption.placement) {
                    case "left":
                    case "right":
                    case "inline":
                      Ut += tn;
                      break;
                    case "top":
                    case "bottom":
                      Lt += Nt;
                      break;
                  }
                } else
                  Ut = tn, Lt = Nt;
                Ut && this.w === "" && (Ut += st, this.w = Math.min(this.maxW <= 0 ? 1 / 0 : this.maxW, this.minW + 1 < Ut ? Ut : this.minW)), Lt && this.h === "" && (Lt += Tt, this.h = Math.min(this.maxH <= 0 ? 1 / 0 : this.maxH, this.minH + 1 < Lt ? Lt : this.minH));
              }
              if (this[t.$popPara](), (0, h.fixDimensions)(this), f(this), !(0, v.checkDimensions)(this, P))
                return this.w = Ne, this.h = Ve, this[t.$popPara](), e.HTMLResult.FAILURE;
              U(this);
              const _t = (0, h.toStyle)(this, "font", "dimensions", "position", "rotate", "anchorType", "presence", "margin", "hAlign");
              (0, h.setMinMaxDimensions)(this, _t);
              const It = ["xfaField"];
              this.font && It.push("xfaFont"), (0, h.isPrintOnly)(this) && It.push("xfaPrintOnly");
              const Bt = {
                style: _t,
                id: this[t.$uid],
                class: It
              };
              _t.margin && (_t.padding = _t.margin, delete _t.margin), (0, h.setAccess)(this, It), this.name && (Bt.xfaName = this.name);
              const Vt = [], Ht = {
                name: "div",
                attributes: Bt,
                children: Vt
              };
              R(this, Bt);
              const qt = this.border ? this.border[t.$toStyle]() : null, Gt = (0, h.computeBbox)(this, Ht, P), Mt = this.ui[t.$toHTML]().html;
              if (!Mt)
                return Object.assign(_t, qt), e.HTMLResult.success((0, h.createWrapper)(this, Ht), Gt);
              this[t.$tabIndex] && (Mt.children && Mt.children[0] ? Mt.children[0].attributes.tabindex = this[t.$tabIndex] : Mt.attributes.tabindex = this[t.$tabIndex]), Mt.attributes.style || (Mt.attributes.style = /* @__PURE__ */ Object.create(null));
              let Kt = null;
              if (this.ui.button ? (Mt.children.length === 1 && ([Kt] = Mt.children.splice(0, 1)), Object.assign(Mt.attributes.style, qt)) : Object.assign(_t, qt), Vt.push(Mt), this.value) {
                if (this.ui.imageEdit)
                  Mt.children.push(this.value[t.$toHTML]().html);
                else if (!this.ui.button) {
                  let Ut = "";
                  if (this.value.exData)
                    Ut = this.value.exData[t.$text]();
                  else if (this.value.text)
                    Ut = this.value.text[t.$getExtra]();
                  else {
                    const Lt = this.value[t.$toHTML]().html;
                    Lt !== null && (Ut = Lt.children[0].value);
                  }
                  this.ui.textEdit && this.value.text && this.value.text.maxChars && (Mt.children[0].attributes.maxLength = this.value.text.maxChars), Ut && (this.ui.numericEdit && (Ut = parseFloat(Ut), Ut = isNaN(Ut) ? "" : Ut.toString()), Mt.children[0].name === "textarea" ? Mt.children[0].attributes.textContent = Ut : Mt.children[0].attributes.value = Ut);
                }
              }
              if (!this.ui.imageEdit && Mt.children && Mt.children[0] && this.h) {
                Ct = Ct || b(this.ui[t.$getExtra]());
                let Ut = 0;
                if (this.caption && ["top", "bottom"].includes(this.caption.placement)) {
                  Ut = this.caption.reserve, Ut <= 0 && (Ut = this.caption[t.$getExtra](P).h);
                  const Lt = this.h - Ut - Tt - Ct.h;
                  Mt.children[0].attributes.style.height = (0, h.measureToString)(Lt);
                } else
                  Mt.children[0].attributes.style.height = "100%";
              }
              if (Kt && Mt.children.push(Kt), !he)
                return Mt.attributes.class && Mt.attributes.class.push("xfaLeft"), this.w = Ne, this.h = Ve, e.HTMLResult.success((0, h.createWrapper)(this, Ht), Gt);
              if (this.ui.button)
                return _t.padding && delete _t.padding, he.name === "div" && (he.name = "span"), Mt.children.push(he), e.HTMLResult.success(Ht, Gt);
              switch (this.ui.checkButton && (he.attributes.class[0] = "xfaCaptionForCheckButton"), Mt.attributes.class || (Mt.attributes.class = []), Mt.children.splice(0, 0, he), this.caption.placement) {
                case "left":
                  Mt.attributes.class.push("xfaLeft");
                  break;
                case "right":
                  Mt.attributes.class.push("xfaRight");
                  break;
                case "top":
                  Mt.attributes.class.push("xfaTop");
                  break;
                case "bottom":
                  Mt.attributes.class.push("xfaBottom");
                  break;
                case "inline":
                  Mt.attributes.class.push("xfaLeft");
                  break;
              }
              return this.w = Ne, this.h = Ve, e.HTMLResult.success((0, h.createWrapper)(this, Ht), Gt);
            }
          }
          o.Field = Te;
          class je extends t.XFAObject {
            constructor(P) {
              super(m, "fill", !0), this.id = P.id || "", this.presence = (0, e.getStringOption)(P.presence, ["visible", "hidden", "inactive", "invisible"]), this.use = P.use || "", this.usehref = P.usehref || "", this.color = null, this.extras = null, this.linear = null, this.pattern = null, this.radial = null, this.solid = null, this.stipple = null;
            }
            [t.$toStyle]() {
              const P = this[t.$getParent](), Ne = P[t.$getParent]()[t.$getParent](), Ve = /* @__PURE__ */ Object.create(null);
              let st = "color", Tt = st;
              P instanceof L && (st = "background-color", Tt = "background", Ne instanceof wn && (Ve.backgroundColor = "white")), (P instanceof gn || P instanceof T) && (st = Tt = "fill", Ve.fill = "white");
              for (const Ct of Object.getOwnPropertyNames(this)) {
                if (Ct === "extras" || Ct === "color")
                  continue;
                const _t = this[Ct];
                if (!(_t instanceof t.XFAObject))
                  continue;
                const It = _t[t.$toStyle](this.color);
                return It && (Ve[It.startsWith("#") ? st : Tt] = It), Ve;
              }
              if (this.color && this.color.value) {
                const Ct = this.color[t.$toStyle]();
                Ve[Ct.startsWith("#") ? st : Tt] = Ct;
              }
              return Ve;
            }
          }
          class Ze extends t.XFAObject {
            constructor(P) {
              super(m, "filter", !0), this.addRevocationInfo = (0, e.getStringOption)(P.addRevocationInfo, ["", "required", "optional", "none"]), this.id = P.id || "", this.name = P.name || "", this.use = P.use || "", this.usehref = P.usehref || "", this.version = (0, e.getInteger)({
                data: this.version,
                defaultValue: 5,
                validate: (he) => he >= 1 && he <= 5
              }), this.appearanceFilter = null, this.certificates = null, this.digestMethods = null, this.encodings = null, this.encryptionMethods = null, this.handler = null, this.lockDocument = null, this.mdp = null, this.reasons = null, this.timeStamp = null;
            }
          }
          class Me extends t.ContentObject {
            constructor(P) {
              super(m, "float"), this.id = P.id || "", this.name = P.name || "", this.use = P.use || "", this.usehref = P.usehref || "";
            }
            [t.$finalize]() {
              const P = parseFloat(this[t.$content].trim());
              this[t.$content] = isNaN(P) ? null : P;
            }
            [t.$toHTML](P) {
              return x(this[t.$content] !== null ? this[t.$content].toString() : "");
            }
          }
          class at extends t.XFAObject {
            constructor(P) {
              super(m, "font", !0), this.baselineShift = (0, e.getMeasurement)(P.baselineShift), this.fontHorizontalScale = (0, e.getFloat)({
                data: P.fontHorizontalScale,
                defaultValue: 100,
                validate: (he) => he >= 0
              }), this.fontVerticalScale = (0, e.getFloat)({
                data: P.fontVerticalScale,
                defaultValue: 100,
                validate: (he) => he >= 0
              }), this.id = P.id || "", this.kerningMode = (0, e.getStringOption)(P.kerningMode, ["none", "pair"]), this.letterSpacing = (0, e.getMeasurement)(P.letterSpacing, "0"), this.lineThrough = (0, e.getInteger)({
                data: P.lineThrough,
                defaultValue: 0,
                validate: (he) => he === 1 || he === 2
              }), this.lineThroughPeriod = (0, e.getStringOption)(P.lineThroughPeriod, ["all", "word"]), this.overline = (0, e.getInteger)({
                data: P.overline,
                defaultValue: 0,
                validate: (he) => he === 1 || he === 2
              }), this.overlinePeriod = (0, e.getStringOption)(P.overlinePeriod, ["all", "word"]), this.posture = (0, e.getStringOption)(P.posture, ["normal", "italic"]), this.size = (0, e.getMeasurement)(P.size, "10pt"), this.typeface = P.typeface || "Courier", this.underline = (0, e.getInteger)({
                data: P.underline,
                defaultValue: 0,
                validate: (he) => he === 1 || he === 2
              }), this.underlinePeriod = (0, e.getStringOption)(P.underlinePeriod, ["all", "word"]), this.use = P.use || "", this.usehref = P.usehref || "", this.weight = (0, e.getStringOption)(P.weight, ["normal", "bold"]), this.extras = null, this.fill = null;
            }
            [t.$clean](P) {
              super[t.$clean](P), this[t.$globalData].usedTypefaces.add(this.typeface);
            }
            [t.$toStyle]() {
              const P = (0, h.toStyle)(this, "fill"), he = P.color;
              return he && (he === "#000000" ? delete P.color : he.startsWith("#") || (P.background = he, P.backgroundClip = "text", P.color = "transparent")), this.baselineShift && (P.verticalAlign = (0, h.measureToString)(this.baselineShift)), P.fontKerning = this.kerningMode === "none" ? "none" : "normal", P.letterSpacing = (0, h.measureToString)(this.letterSpacing), this.lineThrough !== 0 && (P.textDecoration = "line-through", this.lineThrough === 2 && (P.textDecorationStyle = "double")), this.overline !== 0 && (P.textDecoration = "overline", this.overline === 2 && (P.textDecorationStyle = "double")), P.fontStyle = this.posture, P.fontSize = (0, h.measureToString)(0.99 * this.size), (0, h.setFontFamily)(this, this, this[t.$globalData].fontFinder, P), this.underline !== 0 && (P.textDecoration = "underline", this.underline === 2 && (P.textDecorationStyle = "double")), P.fontWeight = this.weight, P;
            }
          }
          class rt extends t.XFAObject {
            constructor(P) {
              super(m, "format", !0), this.id = P.id || "", this.use = P.use || "", this.usehref = P.usehref || "", this.extras = null, this.picture = null;
            }
          }
          class xt extends t.StringObject {
            constructor(P) {
              super(m, "handler"), this.id = P.id || "", this.type = (0, e.getStringOption)(P.type, ["optional", "required"]), this.use = P.use || "", this.usehref = P.usehref || "";
            }
          }
          class ut extends t.XFAObject {
            constructor(P) {
              super(m, "hyphenation"), this.excludeAllCaps = (0, e.getInteger)({
                data: P.excludeAllCaps,
                defaultValue: 0,
                validate: (he) => he === 1
              }), this.excludeInitialCap = (0, e.getInteger)({
                data: P.excludeInitialCap,
                defaultValue: 0,
                validate: (he) => he === 1
              }), this.hyphenate = (0, e.getInteger)({
                data: P.hyphenate,
                defaultValue: 0,
                validate: (he) => he === 1
              }), this.id = P.id || "", this.pushCharacterCount = (0, e.getInteger)({
                data: P.pushCharacterCount,
                defaultValue: 3,
                validate: (he) => he >= 0
              }), this.remainCharacterCount = (0, e.getInteger)({
                data: P.remainCharacterCount,
                defaultValue: 3,
                validate: (he) => he >= 0
              }), this.use = P.use || "", this.usehref = P.usehref || "", this.wordCharacterCount = (0, e.getInteger)({
                data: P.wordCharacterCount,
                defaultValue: 7,
                validate: (he) => he >= 0
              });
            }
          }
          class yt extends t.StringObject {
            constructor(P) {
              super(m, "image"), this.aspect = (0, e.getStringOption)(P.aspect, ["fit", "actual", "height", "none", "width"]), this.contentType = P.contentType || "", this.href = P.href || "", this.id = P.id || "", this.name = P.name || "", this.transferEncoding = (0, e.getStringOption)(P.transferEncoding, ["base64", "none", "package"]), this.use = P.use || "", this.usehref = P.usehref || "";
            }
            [t.$toHTML]() {
              if (this.contentType && !w.has(this.contentType.toLowerCase()))
                return e.HTMLResult.EMPTY;
              let P = this[t.$globalData].images && this[t.$globalData].images.get(this.href);
              if (!P && (this.href || !this[t.$content]) || (!P && this.transferEncoding === "base64" && (P = (0, y.stringToBytes)(atob(this[t.$content]))), !P))
                return e.HTMLResult.EMPTY;
              if (!this.contentType) {
                for (const [st, Tt] of _)
                  if (P.length > st.length && st.every((Ct, _t) => Ct === P[_t])) {
                    this.contentType = Tt;
                    break;
                  }
                if (!this.contentType)
                  return e.HTMLResult.EMPTY;
              }
              const he = new Blob([P], {
                type: this.contentType
              });
              let Ne;
              switch (this.aspect) {
                case "fit":
                case "actual":
                  break;
                case "height":
                  Ne = {
                    height: "100%",
                    objectFit: "fill"
                  };
                  break;
                case "none":
                  Ne = {
                    width: "100%",
                    height: "100%",
                    objectFit: "fill"
                  };
                  break;
                case "width":
                  Ne = {
                    width: "100%",
                    objectFit: "fill"
                  };
                  break;
              }
              const Ve = this[t.$getParent]();
              return e.HTMLResult.success({
                name: "img",
                attributes: {
                  class: ["xfaImage"],
                  style: Ne,
                  src: URL.createObjectURL(he),
                  alt: Ve ? k(Ve[t.$getParent]()) : null
                }
              });
            }
          }
          class ht extends t.XFAObject {
            constructor(P) {
              super(m, "imageEdit", !0), this.data = (0, e.getStringOption)(P.data, ["link", "embed"]), this.id = P.id || "", this.use = P.use || "", this.usehref = P.usehref || "", this.border = null, this.extras = null, this.margin = null;
            }
            [t.$toHTML](P) {
              return this.data === "embed" ? e.HTMLResult.success({
                name: "div",
                children: [],
                attributes: {}
              }) : e.HTMLResult.EMPTY;
            }
          }
          class Rt extends t.ContentObject {
            constructor(P) {
              super(m, "integer"), this.id = P.id || "", this.name = P.name || "", this.use = P.use || "", this.usehref = P.usehref || "";
            }
            [t.$finalize]() {
              const P = parseInt(this[t.$content].trim(), 10);
              this[t.$content] = isNaN(P) ? null : P;
            }
            [t.$toHTML](P) {
              return x(this[t.$content] !== null ? this[t.$content].toString() : "");
            }
          }
          class Wt extends t.XFAObject {
            constructor(P) {
              super(m, "issuers", !0), this.id = P.id || "", this.type = (0, e.getStringOption)(P.type, ["optional", "required"]), this.use = P.use || "", this.usehref = P.usehref || "", this.certificate = new t.XFAObjectArray();
            }
          }
          class Ke extends t.XFAObject {
            constructor(P) {
              super(m, "items", !0), this.id = P.id || "", this.name = P.name || "", this.presence = (0, e.getStringOption)(P.presence, ["visible", "hidden", "inactive", "invisible"]), this.ref = P.ref || "", this.save = (0, e.getInteger)({
                data: P.save,
                defaultValue: 0,
                validate: (he) => he === 1
              }), this.use = P.use || "", this.usehref = P.usehref || "", this.boolean = new t.XFAObjectArray(), this.date = new t.XFAObjectArray(), this.dateTime = new t.XFAObjectArray(), this.decimal = new t.XFAObjectArray(), this.exData = new t.XFAObjectArray(), this.float = new t.XFAObjectArray(), this.image = new t.XFAObjectArray(), this.integer = new t.XFAObjectArray(), this.text = new t.XFAObjectArray(), this.time = new t.XFAObjectArray();
            }
            [t.$toHTML]() {
              const P = [];
              for (const he of this[t.$getChildren]())
                P.push(he[t.$text]());
              return e.HTMLResult.success(P);
            }
          }
          o.Items = Ke;
          class Ge extends t.XFAObject {
            constructor(P) {
              super(m, "keep", !0), this.id = P.id || "";
              const he = ["none", "contentArea", "pageArea"];
              this.intact = (0, e.getStringOption)(P.intact, he), this.next = (0, e.getStringOption)(P.next, he), this.previous = (0, e.getStringOption)(P.previous, he), this.use = P.use || "", this.usehref = P.usehref || "", this.extras = null;
            }
          }
          class nt extends t.XFAObject {
            constructor(P) {
              super(m, "keyUsage");
              const he = ["", "yes", "no"];
              this.crlSign = (0, e.getStringOption)(P.crlSign, he), this.dataEncipherment = (0, e.getStringOption)(P.dataEncipherment, he), this.decipherOnly = (0, e.getStringOption)(P.decipherOnly, he), this.digitalSignature = (0, e.getStringOption)(P.digitalSignature, he), this.encipherOnly = (0, e.getStringOption)(P.encipherOnly, he), this.id = P.id || "", this.keyAgreement = (0, e.getStringOption)(P.keyAgreement, he), this.keyCertSign = (0, e.getStringOption)(P.keyCertSign, he), this.keyEncipherment = (0, e.getStringOption)(P.keyEncipherment, he), this.nonRepudiation = (0, e.getStringOption)(P.nonRepudiation, he), this.type = (0, e.getStringOption)(P.type, ["optional", "required"]), this.use = P.use || "", this.usehref = P.usehref || "";
            }
          }
          class it extends t.XFAObject {
            constructor(P) {
              super(m, "line", !0), this.hand = (0, e.getStringOption)(P.hand, ["even", "left", "right"]), this.id = P.id || "", this.slope = (0, e.getStringOption)(P.slope, ["\\", "/"]), this.use = P.use || "", this.usehref = P.usehref || "", this.edge = null;
            }
            [t.$toHTML]() {
              const P = this[t.$getParent]()[t.$getParent](), he = this.edge || new _e({}), Ne = he[t.$toStyle](), Ve = /* @__PURE__ */ Object.create(null), st = he.presence === "visible" ? he.thickness : 0;
              Ve.strokeWidth = (0, h.measureToString)(st), Ve.stroke = Ne.color;
              let Tt, Ct, _t, It, Bt = "100%", Vt = "100%";
              P.w <= st ? ([Tt, Ct, _t, It] = ["50%", 0, "50%", "100%"], Bt = Ve.strokeWidth) : P.h <= st ? ([Tt, Ct, _t, It] = [0, "50%", "100%", "50%"], Vt = Ve.strokeWidth) : this.slope === "\\" ? [Tt, Ct, _t, It] = [0, 0, "100%", "100%"] : [Tt, Ct, _t, It] = [0, "100%", "100%", 0];
              const qt = {
                name: "svg",
                children: [{
                  name: "line",
                  attributes: {
                    xmlns: g,
                    x1: Tt,
                    y1: Ct,
                    x2: _t,
                    y2: It,
                    style: Ve
                  }
                }],
                attributes: {
                  xmlns: g,
                  width: Bt,
                  height: Vt,
                  style: {
                    overflow: "visible"
                  }
                }
              };
              return A(P) ? e.HTMLResult.success({
                name: "div",
                attributes: {
                  style: {
                    display: "inline",
                    width: "100%",
                    height: "100%"
                  }
                },
                children: [qt]
              }) : (qt.attributes.style.position = "absolute", e.HTMLResult.success(qt));
            }
          }
          class pt extends t.XFAObject {
            constructor(P) {
              super(m, "linear", !0), this.id = P.id || "", this.type = (0, e.getStringOption)(P.type, ["toRight", "toBottom", "toLeft", "toTop"]), this.use = P.use || "", this.usehref = P.usehref || "", this.color = null, this.extras = null;
            }
            [t.$toStyle](P) {
              P = P ? P[t.$toStyle]() : "#FFFFFF";
              const he = this.type.replace(/([RBLT])/, " $1").toLowerCase(), Ne = this.color ? this.color[t.$toStyle]() : "#000000";
              return `linear-gradient(${he}, ${P}, ${Ne})`;
            }
          }
          class Ft extends t.ContentObject {
            constructor(P) {
              super(m, "lockDocument"), this.id = P.id || "", this.type = (0, e.getStringOption)(P.type, ["optional", "required"]), this.use = P.use || "", this.usehref = P.usehref || "";
            }
            [t.$finalize]() {
              this[t.$content] = (0, e.getStringOption)(this[t.$content], ["auto", "0", "1"]);
            }
          }
          class mt extends t.XFAObject {
            constructor(P) {
              super(m, "manifest", !0), this.action = (0, e.getStringOption)(P.action, ["include", "all", "exclude"]), this.id = P.id || "", this.name = P.name || "", this.use = P.use || "", this.usehref = P.usehref || "", this.extras = null, this.ref = new t.XFAObjectArray();
            }
          }
          class ct extends t.XFAObject {
            constructor(P) {
              super(m, "margin", !0), this.bottomInset = (0, e.getMeasurement)(P.bottomInset, "0"), this.id = P.id || "", this.leftInset = (0, e.getMeasurement)(P.leftInset, "0"), this.rightInset = (0, e.getMeasurement)(P.rightInset, "0"), this.topInset = (0, e.getMeasurement)(P.topInset, "0"), this.use = P.use || "", this.usehref = P.usehref || "", this.extras = null;
            }
            [t.$toStyle]() {
              return {
                margin: (0, h.measureToString)(this.topInset) + " " + (0, h.measureToString)(this.rightInset) + " " + (0, h.measureToString)(this.bottomInset) + " " + (0, h.measureToString)(this.leftInset)
              };
            }
          }
          class bt extends t.XFAObject {
            constructor(P) {
              super(m, "mdp"), this.id = P.id || "", this.permissions = (0, e.getInteger)({
                data: P.permissions,
                defaultValue: 2,
                validate: (he) => he === 1 || he === 3
              }), this.signatureType = (0, e.getStringOption)(P.signatureType, ["filler", "author"]), this.use = P.use || "", this.usehref = P.usehref || "";
            }
          }
          class wt extends t.XFAObject {
            constructor(P) {
              super(m, "medium"), this.id = P.id || "", this.imagingBBox = (0, e.getBBox)(P.imagingBBox), this.long = (0, e.getMeasurement)(P.long), this.orientation = (0, e.getStringOption)(P.orientation, ["portrait", "landscape"]), this.short = (0, e.getMeasurement)(P.short), this.stock = P.stock || "", this.trayIn = (0, e.getStringOption)(P.trayIn, ["auto", "delegate", "pageFront"]), this.trayOut = (0, e.getStringOption)(P.trayOut, ["auto", "delegate"]), this.use = P.use || "", this.usehref = P.usehref || "";
            }
          }
          class Ot extends t.XFAObject {
            constructor(P) {
              super(m, "message", !0), this.id = P.id || "", this.use = P.use || "", this.usehref = P.usehref || "", this.text = new t.XFAObjectArray();
            }
          }
          class Et extends t.XFAObject {
            constructor(P) {
              super(m, "numericEdit", !0), this.hScrollPolicy = (0, e.getStringOption)(P.hScrollPolicy, ["auto", "off", "on"]), this.id = P.id || "", this.use = P.use || "", this.usehref = P.usehref || "", this.border = null, this.comb = null, this.extras = null, this.margin = null;
            }
            [t.$toHTML](P) {
              const he = (0, h.toStyle)(this, "border", "font", "margin"), Ne = this[t.$getParent]()[t.$getParent](), Ve = {
                name: "input",
                attributes: {
                  type: "text",
                  fieldId: Ne[t.$uid],
                  dataId: Ne[t.$data] && Ne[t.$data][t.$uid] || Ne[t.$uid],
                  class: ["xfaTextfield"],
                  style: he,
                  "aria-label": k(Ne),
                  "aria-required": !1
                }
              };
              return X(Ne) && (Ve.attributes["aria-required"] = !0, Ve.attributes.required = !0), e.HTMLResult.success({
                name: "label",
                attributes: {
                  class: ["xfaLabel"]
                },
                children: [Ve]
              });
            }
          }
          class St extends t.XFAObject {
            constructor(P) {
              super(m, "occur", !0), this.id = P.id || "", this.initial = P.initial !== "" ? (0, e.getInteger)({
                data: P.initial,
                defaultValue: "",
                validate: (he) => !0
              }) : "", this.max = P.max !== "" ? (0, e.getInteger)({
                data: P.max,
                defaultValue: 1,
                validate: (he) => !0
              }) : "", this.min = P.min !== "" ? (0, e.getInteger)({
                data: P.min,
                defaultValue: 1,
                validate: (he) => !0
              }) : "", this.use = P.use || "", this.usehref = P.usehref || "", this.extras = null;
            }
            [t.$clean]() {
              const P = this[t.$getParent](), he = this.min;
              this.min === "" && (this.min = P instanceof Ye || P instanceof gt ? 0 : 1), this.max === "" && (he === "" ? this.max = P instanceof Ye || P instanceof gt ? -1 : 1 : this.max = this.min), this.max !== -1 && this.max < this.min && (this.max = this.min), this.initial === "" && (this.initial = P instanceof bn ? 1 : this.min);
            }
          }
          class Pe extends t.StringObject {
            constructor(P) {
              super(m, "oid"), this.id = P.id || "", this.name = P.name || "", this.use = P.use || "", this.usehref = P.usehref || "";
            }
          }
          class We extends t.XFAObject {
            constructor(P) {
              super(m, "oids", !0), this.id = P.id || "", this.type = (0, e.getStringOption)(P.type, ["optional", "required"]), this.use = P.use || "", this.usehref = P.usehref || "", this.oid = new t.XFAObjectArray();
            }
          }
          class Je extends t.XFAObject {
            constructor(P) {
              super(m, "overflow"), this.id = P.id || "", this.leader = P.leader || "", this.target = P.target || "", this.trailer = P.trailer || "", this.use = P.use || "", this.usehref = P.usehref || "";
            }
            [t.$getExtra]() {
              if (!this[t.$extra]) {
                const P = this[t.$getParent](), he = this[t.$getTemplateRoot](), Ne = he[t.$searchNode](this.target, P), Ve = he[t.$searchNode](this.leader, P), st = he[t.$searchNode](this.trailer, P);
                this[t.$extra] = {
                  target: Ne && Ne[0] || null,
                  leader: Ve && Ve[0] || null,
                  trailer: st && st[0] || null,
                  addLeader: !1,
                  addTrailer: !1
                };
              }
              return this[t.$extra];
            }
          }
          class Ye extends t.XFAObject {
            constructor(P) {
              super(m, "pageArea", !0), this.blankOrNotBlank = (0, e.getStringOption)(P.blankOrNotBlank, ["any", "blank", "notBlank"]), this.id = P.id || "", this.initialNumber = (0, e.getInteger)({
                data: P.initialNumber,
                defaultValue: 1,
                validate: (he) => !0
              }), this.name = P.name || "", this.numbered = (0, e.getInteger)({
                data: P.numbered,
                defaultValue: 1,
                validate: (he) => !0
              }), this.oddOrEven = (0, e.getStringOption)(P.oddOrEven, ["any", "even", "odd"]), this.pagePosition = (0, e.getStringOption)(P.pagePosition, ["any", "first", "last", "only", "rest"]), this.relevant = (0, e.getRelevant)(P.relevant), this.use = P.use || "", this.usehref = P.usehref || "", this.desc = null, this.extras = null, this.medium = null, this.occur = null, this.area = new t.XFAObjectArray(), this.contentArea = new t.XFAObjectArray(), this.draw = new t.XFAObjectArray(), this.exclGroup = new t.XFAObjectArray(), this.field = new t.XFAObjectArray(), this.subform = new t.XFAObjectArray();
            }
            [t.$isUsable]() {
              return this[t.$extra] ? !this.occur || this.occur.max === -1 || this[t.$extra].numberOfUse < this.occur.max : (this[t.$extra] = {
                numberOfUse: 0
              }, !0);
            }
            [t.$cleanPage]() {
              delete this[t.$extra];
            }
            [t.$getNextPage]() {
              this[t.$extra] || (this[t.$extra] = {
                numberOfUse: 0
              });
              const P = this[t.$getParent]();
              return P.relation === "orderedOccurrence" && this[t.$isUsable]() ? (this[t.$extra].numberOfUse += 1, this) : P[t.$getNextPage]();
            }
            [t.$getAvailableSpace]() {
              return this[t.$extra].space || {
                width: 0,
                height: 0
              };
            }
            [t.$toHTML]() {
              this[t.$extra] || (this[t.$extra] = {
                numberOfUse: 1
              });
              const P = [];
              this[t.$extra].children = P;
              const he = /* @__PURE__ */ Object.create(null);
              if (this.medium && this.medium.short && this.medium.long) {
                if (he.width = (0, h.measureToString)(this.medium.short), he.height = (0, h.measureToString)(this.medium.long), this[t.$extra].space = {
                  width: this.medium.short,
                  height: this.medium.long
                }, this.medium.orientation === "landscape") {
                  const Ne = he.width;
                  he.width = he.height, he.height = Ne, this[t.$extra].space = {
                    width: this.medium.long,
                    height: this.medium.short
                  };
                }
              } else
                (0, y.warn)("XFA - No medium specified in pageArea: please file a bug.");
              return this[t.$childrenToHTML]({
                filter: /* @__PURE__ */ new Set(["area", "draw", "field", "subform"]),
                include: !0
              }), this[t.$childrenToHTML]({
                filter: /* @__PURE__ */ new Set(["contentArea"]),
                include: !0
              }), e.HTMLResult.success({
                name: "div",
                children: P,
                attributes: {
                  class: ["xfaPage"],
                  id: this[t.$uid],
                  style: he,
                  xfaName: this.name
                }
              });
            }
          }
          class gt extends t.XFAObject {
            constructor(P) {
              super(m, "pageSet", !0), this.duplexImposition = (0, e.getStringOption)(P.duplexImposition, ["longEdge", "shortEdge"]), this.id = P.id || "", this.name = P.name || "", this.relation = (0, e.getStringOption)(P.relation, ["orderedOccurrence", "duplexPaginated", "simplexPaginated"]), this.relevant = (0, e.getRelevant)(P.relevant), this.use = P.use || "", this.usehref = P.usehref || "", this.extras = null, this.occur = null, this.pageArea = new t.XFAObjectArray(), this.pageSet = new t.XFAObjectArray();
            }
            [t.$cleanPage]() {
              for (const P of this.pageArea.children)
                P[t.$cleanPage]();
              for (const P of this.pageSet.children)
                P[t.$cleanPage]();
            }
            [t.$isUsable]() {
              return !this.occur || this.occur.max === -1 || this[t.$extra].numberOfUse < this.occur.max;
            }
            [t.$getNextPage]() {
              if (this[t.$extra] || (this[t.$extra] = {
                numberOfUse: 1,
                pageIndex: -1,
                pageSetIndex: -1
              }), this.relation === "orderedOccurrence") {
                if (this[t.$extra].pageIndex + 1 < this.pageArea.children.length)
                  return this[t.$extra].pageIndex += 1, this.pageArea.children[this[t.$extra].pageIndex][t.$getNextPage]();
                if (this[t.$extra].pageSetIndex + 1 < this.pageSet.children.length)
                  return this[t.$extra].pageSetIndex += 1, this.pageSet.children[this[t.$extra].pageSetIndex][t.$getNextPage]();
                if (this[t.$isUsable]())
                  return this[t.$extra].numberOfUse += 1, this[t.$extra].pageIndex = -1, this[t.$extra].pageSetIndex = -1, this[t.$getNextPage]();
                const st = this[t.$getParent]();
                return st instanceof gt ? st[t.$getNextPage]() : (this[t.$cleanPage](), this[t.$getNextPage]());
              }
              const P = this[t.$getTemplateRoot]()[t.$extra].pageNumber, he = P % 2 === 0 ? "even" : "odd", Ne = P === 0 ? "first" : "rest";
              let Ve = this.pageArea.children.find((st) => st.oddOrEven === he && st.pagePosition === Ne);
              return Ve || (Ve = this.pageArea.children.find((st) => st.oddOrEven === "any" && st.pagePosition === Ne), Ve) || (Ve = this.pageArea.children.find((st) => st.oddOrEven === "any" && st.pagePosition === "any"), Ve) ? Ve : this.pageArea.children[0];
            }
          }
          class Dt extends t.XFAObject {
            constructor(P) {
              super(m, "para", !0), this.hAlign = (0, e.getStringOption)(P.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = P.id || "", this.lineHeight = P.lineHeight ? (0, e.getMeasurement)(P.lineHeight, "0pt") : "", this.marginLeft = P.marginLeft ? (0, e.getMeasurement)(P.marginLeft, "0pt") : "", this.marginRight = P.marginRight ? (0, e.getMeasurement)(P.marginRight, "0pt") : "", this.orphans = (0, e.getInteger)({
                data: P.orphans,
                defaultValue: 0,
                validate: (he) => he >= 0
              }), this.preserve = P.preserve || "", this.radixOffset = P.radixOffset ? (0, e.getMeasurement)(P.radixOffset, "0pt") : "", this.spaceAbove = P.spaceAbove ? (0, e.getMeasurement)(P.spaceAbove, "0pt") : "", this.spaceBelow = P.spaceBelow ? (0, e.getMeasurement)(P.spaceBelow, "0pt") : "", this.tabDefault = P.tabDefault ? (0, e.getMeasurement)(this.tabDefault) : "", this.tabStops = (P.tabStops || "").trim().split(/\s+/).map((he, Ne) => Ne % 2 === 1 ? (0, e.getMeasurement)(he) : he), this.textIndent = P.textIndent ? (0, e.getMeasurement)(P.textIndent, "0pt") : "", this.use = P.use || "", this.usehref = P.usehref || "", this.vAlign = (0, e.getStringOption)(P.vAlign, ["top", "bottom", "middle"]), this.widows = (0, e.getInteger)({
                data: P.widows,
                defaultValue: 0,
                validate: (he) => he >= 0
              }), this.hyphenation = null;
            }
            [t.$toStyle]() {
              const P = (0, h.toStyle)(this, "hAlign");
              return this.marginLeft !== "" && (P.paddingLeft = (0, h.measureToString)(this.marginLeft)), this.marginRight !== "" && (P.paddingight = (0, h.measureToString)(this.marginRight)), this.spaceAbove !== "" && (P.paddingTop = (0, h.measureToString)(this.spaceAbove)), this.spaceBelow !== "" && (P.paddingBottom = (0, h.measureToString)(this.spaceBelow)), this.textIndent !== "" && (P.textIndent = (0, h.measureToString)(this.textIndent), (0, h.fixTextIndent)(P)), this.lineHeight > 0 && (P.lineHeight = (0, h.measureToString)(this.lineHeight)), this.tabDefault !== "" && (P.tabSize = (0, h.measureToString)(this.tabDefault)), this.tabStops.length > 0, this.hyphenatation && Object.assign(P, this.hyphenatation[t.$toStyle]()), P;
            }
          }
          class Xt extends t.XFAObject {
            constructor(P) {
              super(m, "passwordEdit", !0), this.hScrollPolicy = (0, e.getStringOption)(P.hScrollPolicy, ["auto", "off", "on"]), this.id = P.id || "", this.passwordChar = P.passwordChar || "*", this.use = P.use || "", this.usehref = P.usehref || "", this.border = null, this.extras = null, this.margin = null;
            }
          }
          class kt extends t.XFAObject {
            constructor(P) {
              super(m, "pattern", !0), this.id = P.id || "", this.type = (0, e.getStringOption)(P.type, ["crossHatch", "crossDiagonal", "diagonalLeft", "diagonalRight", "horizontal", "vertical"]), this.use = P.use || "", this.usehref = P.usehref || "", this.color = null, this.extras = null;
            }
            [t.$toStyle](P) {
              P = P ? P[t.$toStyle]() : "#FFFFFF";
              const he = this.color ? this.color[t.$toStyle]() : "#000000", Ne = 5, Ve = "repeating-linear-gradient", st = `${P},${P} ${Ne}px,${he} ${Ne}px,${he} ${2 * Ne}px`;
              switch (this.type) {
                case "crossHatch":
                  return `${Ve}(to top,${st}) ${Ve}(to right,${st})`;
                case "crossDiagonal":
                  return `${Ve}(45deg,${st}) ${Ve}(-45deg,${st})`;
                case "diagonalLeft":
                  return `${Ve}(45deg,${st})`;
                case "diagonalRight":
                  return `${Ve}(-45deg,${st})`;
                case "horizontal":
                  return `${Ve}(to top,${st})`;
                case "vertical":
                  return `${Ve}(to right,${st})`;
              }
              return "";
            }
          }
          class Pt extends t.StringObject {
            constructor(P) {
              super(m, "picture"), this.id = P.id || "", this.use = P.use || "", this.usehref = P.usehref || "";
            }
          }
          class zt extends t.XFAObject {
            constructor(P) {
              super(m, "proto", !0), this.appearanceFilter = new t.XFAObjectArray(), this.arc = new t.XFAObjectArray(), this.area = new t.XFAObjectArray(), this.assist = new t.XFAObjectArray(), this.barcode = new t.XFAObjectArray(), this.bindItems = new t.XFAObjectArray(), this.bookend = new t.XFAObjectArray(), this.boolean = new t.XFAObjectArray(), this.border = new t.XFAObjectArray(), this.break = new t.XFAObjectArray(), this.breakAfter = new t.XFAObjectArray(), this.breakBefore = new t.XFAObjectArray(), this.button = new t.XFAObjectArray(), this.calculate = new t.XFAObjectArray(), this.caption = new t.XFAObjectArray(), this.certificate = new t.XFAObjectArray(), this.certificates = new t.XFAObjectArray(), this.checkButton = new t.XFAObjectArray(), this.choiceList = new t.XFAObjectArray(), this.color = new t.XFAObjectArray(), this.comb = new t.XFAObjectArray(), this.connect = new t.XFAObjectArray(), this.contentArea = new t.XFAObjectArray(), this.corner = new t.XFAObjectArray(), this.date = new t.XFAObjectArray(), this.dateTime = new t.XFAObjectArray(), this.dateTimeEdit = new t.XFAObjectArray(), this.decimal = new t.XFAObjectArray(), this.defaultUi = new t.XFAObjectArray(), this.desc = new t.XFAObjectArray(), this.digestMethod = new t.XFAObjectArray(), this.digestMethods = new t.XFAObjectArray(), this.draw = new t.XFAObjectArray(), this.edge = new t.XFAObjectArray(), this.encoding = new t.XFAObjectArray(), this.encodings = new t.XFAObjectArray(), this.encrypt = new t.XFAObjectArray(), this.encryptData = new t.XFAObjectArray(), this.encryption = new t.XFAObjectArray(), this.encryptionMethod = new t.XFAObjectArray(), this.encryptionMethods = new t.XFAObjectArray(), this.event = new t.XFAObjectArray(), this.exData = new t.XFAObjectArray(), this.exObject = new t.XFAObjectArray(), this.exclGroup = new t.XFAObjectArray(), this.execute = new t.XFAObjectArray(), this.extras = new t.XFAObjectArray(), this.field = new t.XFAObjectArray(), this.fill = new t.XFAObjectArray(), this.filter = new t.XFAObjectArray(), this.float = new t.XFAObjectArray(), this.font = new t.XFAObjectArray(), this.format = new t.XFAObjectArray(), this.handler = new t.XFAObjectArray(), this.hyphenation = new t.XFAObjectArray(), this.image = new t.XFAObjectArray(), this.imageEdit = new t.XFAObjectArray(), this.integer = new t.XFAObjectArray(), this.issuers = new t.XFAObjectArray(), this.items = new t.XFAObjectArray(), this.keep = new t.XFAObjectArray(), this.keyUsage = new t.XFAObjectArray(), this.line = new t.XFAObjectArray(), this.linear = new t.XFAObjectArray(), this.lockDocument = new t.XFAObjectArray(), this.manifest = new t.XFAObjectArray(), this.margin = new t.XFAObjectArray(), this.mdp = new t.XFAObjectArray(), this.medium = new t.XFAObjectArray(), this.message = new t.XFAObjectArray(), this.numericEdit = new t.XFAObjectArray(), this.occur = new t.XFAObjectArray(), this.oid = new t.XFAObjectArray(), this.oids = new t.XFAObjectArray(), this.overflow = new t.XFAObjectArray(), this.pageArea = new t.XFAObjectArray(), this.pageSet = new t.XFAObjectArray(), this.para = new t.XFAObjectArray(), this.passwordEdit = new t.XFAObjectArray(), this.pattern = new t.XFAObjectArray(), this.picture = new t.XFAObjectArray(), this.radial = new t.XFAObjectArray(), this.reason = new t.XFAObjectArray(), this.reasons = new t.XFAObjectArray(), this.rectangle = new t.XFAObjectArray(), this.ref = new t.XFAObjectArray(), this.script = new t.XFAObjectArray(), this.setProperty = new t.XFAObjectArray(), this.signData = new t.XFAObjectArray(), this.signature = new t.XFAObjectArray(), this.signing = new t.XFAObjectArray(), this.solid = new t.XFAObjectArray(), this.speak = new t.XFAObjectArray(), this.stipple = new t.XFAObjectArray(), this.subform = new t.XFAObjectArray(), this.subformSet = new t.XFAObjectArray(), this.subjectDN = new t.XFAObjectArray(), this.subjectDNs = new t.XFAObjectArray(), this.submit = new t.XFAObjectArray(), this.text = new t.XFAObjectArray(), this.textEdit = new t.XFAObjectArray(), this.time = new t.XFAObjectArray(), this.timeStamp = new t.XFAObjectArray(), this.toolTip = new t.XFAObjectArray(), this.traversal = new t.XFAObjectArray(), this.traverse = new t.XFAObjectArray(), this.ui = new t.XFAObjectArray(), this.validate = new t.XFAObjectArray(), this.value = new t.XFAObjectArray(), this.variables = new t.XFAObjectArray();
            }
          }
          class Yt extends t.XFAObject {
            constructor(P) {
              super(m, "radial", !0), this.id = P.id || "", this.type = (0, e.getStringOption)(P.type, ["toEdge", "toCenter"]), this.use = P.use || "", this.usehref = P.usehref || "", this.color = null, this.extras = null;
            }
            [t.$toStyle](P) {
              P = P ? P[t.$toStyle]() : "#FFFFFF";
              const he = this.color ? this.color[t.$toStyle]() : "#000000";
              return `radial-gradient(circle at center, ${this.type === "toEdge" ? `${P},${he}` : `${he},${P}`})`;
            }
          }
          class an extends t.StringObject {
            constructor(P) {
              super(m, "reason"), this.id = P.id || "", this.name = P.name || "", this.use = P.use || "", this.usehref = P.usehref || "";
            }
          }
          class Dn extends t.XFAObject {
            constructor(P) {
              super(m, "reasons", !0), this.id = P.id || "", this.type = (0, e.getStringOption)(P.type, ["optional", "required"]), this.use = P.use || "", this.usehref = P.usehref || "", this.reason = new t.XFAObjectArray();
            }
          }
          class gn extends t.XFAObject {
            constructor(P) {
              super(m, "rectangle", !0), this.hand = (0, e.getStringOption)(P.hand, ["even", "left", "right"]), this.id = P.id || "", this.use = P.use || "", this.usehref = P.usehref || "", this.corner = new t.XFAObjectArray(4), this.edge = new t.XFAObjectArray(4), this.fill = null;
            }
            [t.$toHTML]() {
              const P = this.edge.children.length ? this.edge.children[0] : new _e({}), he = P[t.$toStyle](), Ne = /* @__PURE__ */ Object.create(null);
              this.fill && this.fill.presence === "visible" ? Object.assign(Ne, this.fill[t.$toStyle]()) : Ne.fill = "transparent", Ne.strokeWidth = (0, h.measureToString)(P.presence === "visible" ? P.thickness : 0), Ne.stroke = he.color;
              const st = (this.corner.children.length ? this.corner.children[0] : new ue({}))[t.$toStyle](), Ct = {
                name: "svg",
                children: [{
                  name: "rect",
                  attributes: {
                    xmlns: g,
                    width: "100%",
                    height: "100%",
                    x: 0,
                    y: 0,
                    rx: st.radius,
                    ry: st.radius,
                    style: Ne
                  }
                }],
                attributes: {
                  xmlns: g,
                  style: {
                    overflow: "visible"
                  },
                  width: "100%",
                  height: "100%"
                }
              }, _t = this[t.$getParent]()[t.$getParent]();
              return A(_t) ? e.HTMLResult.success({
                name: "div",
                attributes: {
                  style: {
                    display: "inline",
                    width: "100%",
                    height: "100%"
                  }
                },
                children: [Ct]
              }) : (Ct.attributes.style.position = "absolute", e.HTMLResult.success(Ct));
            }
          }
          class _n extends t.StringObject {
            constructor(P) {
              super(m, "ref"), this.id = P.id || "", this.use = P.use || "", this.usehref = P.usehref || "";
            }
          }
          class En extends t.StringObject {
            constructor(P) {
              super(m, "script"), this.binding = P.binding || "", this.contentType = P.contentType || "", this.id = P.id || "", this.name = P.name || "", this.runAt = (0, e.getStringOption)(P.runAt, ["client", "both", "server"]), this.use = P.use || "", this.usehref = P.usehref || "";
            }
          }
          class An extends t.XFAObject {
            constructor(P) {
              super(m, "setProperty"), this.connection = P.connection || "", this.ref = P.ref || "", this.target = P.target || "";
            }
          }
          o.SetProperty = An;
          class kn extends t.XFAObject {
            constructor(P) {
              super(m, "signData", !0), this.id = P.id || "", this.operation = (0, e.getStringOption)(P.operation, ["sign", "clear", "verify"]), this.ref = P.ref || "", this.target = P.target || "", this.use = P.use || "", this.usehref = P.usehref || "", this.filter = null, this.manifest = null;
            }
          }
          class On extends t.XFAObject {
            constructor(P) {
              super(m, "signature", !0), this.id = P.id || "", this.type = (0, e.getStringOption)(P.type, ["PDF1.3", "PDF1.6"]), this.use = P.use || "", this.usehref = P.usehref || "", this.border = null, this.extras = null, this.filter = null, this.manifest = null, this.margin = null;
            }
          }
          class In extends t.XFAObject {
            constructor(P) {
              super(m, "signing", !0), this.id = P.id || "", this.type = (0, e.getStringOption)(P.type, ["optional", "required"]), this.use = P.use || "", this.usehref = P.usehref || "", this.certificate = new t.XFAObjectArray();
            }
          }
          class Pn extends t.XFAObject {
            constructor(P) {
              super(m, "solid", !0), this.id = P.id || "", this.use = P.use || "", this.usehref = P.usehref || "", this.extras = null;
            }
            [t.$toStyle](P) {
              return P ? P[t.$toStyle]() : "#FFFFFF";
            }
          }
          class Rn extends t.StringObject {
            constructor(P) {
              super(m, "speak"), this.disable = (0, e.getInteger)({
                data: P.disable,
                defaultValue: 0,
                validate: (he) => he === 1
              }), this.id = P.id || "", this.priority = (0, e.getStringOption)(P.priority, ["custom", "caption", "name", "toolTip"]), this.rid = P.rid || "", this.use = P.use || "", this.usehref = P.usehref || "";
            }
          }
          class Un extends t.XFAObject {
            constructor(P) {
              super(m, "stipple", !0), this.id = P.id || "", this.rate = (0, e.getInteger)({
                data: P.rate,
                defaultValue: 50,
                validate: (he) => he >= 0 && he <= 100
              }), this.use = P.use || "", this.usehref = P.usehref || "", this.color = null, this.extras = null;
            }
            [t.$toStyle](P) {
              const he = this.rate / 100;
              return y.Util.makeHexColor(Math.round(P.value.r * (1 - he) + this.value.r * he), Math.round(P.value.g * (1 - he) + this.value.g * he), Math.round(P.value.b * (1 - he) + this.value.b * he));
            }
          }
          class xn extends t.XFAObject {
            constructor(P) {
              super(m, "subform", !0), this.access = (0, e.getStringOption)(P.access, ["open", "nonInteractive", "protected", "readOnly"]), this.allowMacro = (0, e.getInteger)({
                data: P.allowMacro,
                defaultValue: 0,
                validate: (he) => he === 1
              }), this.anchorType = (0, e.getStringOption)(P.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = (0, e.getInteger)({
                data: P.colSpan,
                defaultValue: 1,
                validate: (he) => he >= 1 || he === -1
              }), this.columnWidths = (P.columnWidths || "").trim().split(/\s+/).map((he) => he === "-1" ? -1 : (0, e.getMeasurement)(he)), this.h = P.h ? (0, e.getMeasurement)(P.h) : "", this.hAlign = (0, e.getStringOption)(P.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = P.id || "", this.layout = (0, e.getStringOption)(P.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]), this.locale = P.locale || "", this.maxH = (0, e.getMeasurement)(P.maxH, "0pt"), this.maxW = (0, e.getMeasurement)(P.maxW, "0pt"), this.mergeMode = (0, e.getStringOption)(P.mergeMode, ["consumeData", "matchTemplate"]), this.minH = (0, e.getMeasurement)(P.minH, "0pt"), this.minW = (0, e.getMeasurement)(P.minW, "0pt"), this.name = P.name || "", this.presence = (0, e.getStringOption)(P.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = (0, e.getRelevant)(P.relevant), this.restoreState = (0, e.getStringOption)(P.restoreState, ["manual", "auto"]), this.scope = (0, e.getStringOption)(P.scope, ["name", "none"]), this.use = P.use || "", this.usehref = P.usehref || "", this.w = P.w ? (0, e.getMeasurement)(P.w) : "", this.x = (0, e.getMeasurement)(P.x, "0pt"), this.y = (0, e.getMeasurement)(P.y, "0pt"), this.assist = null, this.bind = null, this.bookend = null, this.border = null, this.break = null, this.calculate = null, this.desc = null, this.extras = null, this.keep = null, this.margin = null, this.occur = null, this.overflow = null, this.pageSet = null, this.para = null, this.traversal = null, this.validate = null, this.variables = null, this.area = new t.XFAObjectArray(), this.breakAfter = new t.XFAObjectArray(), this.breakBefore = new t.XFAObjectArray(), this.connect = new t.XFAObjectArray(), this.draw = new t.XFAObjectArray(), this.event = new t.XFAObjectArray(), this.exObject = new t.XFAObjectArray(), this.exclGroup = new t.XFAObjectArray(), this.field = new t.XFAObjectArray(), this.proto = new t.XFAObjectArray(), this.setProperty = new t.XFAObjectArray(), this.subform = new t.XFAObjectArray(), this.subformSet = new t.XFAObjectArray();
            }
            [t.$getSubformParent]() {
              const P = this[t.$getParent]();
              return P instanceof on ? P[t.$getSubformParent]() : P;
            }
            [t.$isBindable]() {
              return !0;
            }
            [t.$isThereMoreWidth]() {
              return this.layout.endsWith("-tb") && this[t.$extra].attempt === 0 && this[t.$extra].numberInLine > 0 || this[t.$getParent]()[t.$isThereMoreWidth]();
            }
            *[t.$getContainedChildren]() {
              yield* j(this);
            }
            [t.$flushHTML]() {
              return (0, v.flushHTML)(this);
            }
            [t.$addHTML](P, he) {
              (0, v.addHTML)(this, P, he);
            }
            [t.$getAvailableSpace]() {
              return (0, v.getAvailableSpace)(this);
            }
            [t.$isSplittable]() {
              const P = this[t.$getSubformParent]();
              return P[t.$isSplittable]() ? this[t.$extra]._isSplittable !== void 0 ? this[t.$extra]._isSplittable : this.layout === "position" || this.layout.includes("row") ? (this[t.$extra]._isSplittable = !1, !1) : this.keep && this.keep.intact !== "none" ? (this[t.$extra]._isSplittable = !1, !1) : P.layout && P.layout.endsWith("-tb") && P[t.$extra].numberInLine !== 0 ? !1 : (this[t.$extra]._isSplittable = !0, !0) : !1;
            }
            [t.$toHTML](P) {
              if (B(this), this.break) {
                if (this.break.after !== "auto" || this.break.afterTarget !== "") {
                  const Nt = new te({
                    targetType: this.break.after,
                    target: this.break.afterTarget,
                    startNew: this.break.startNew.toString()
                  });
                  Nt[t.$globalData] = this[t.$globalData], this[t.$appendChild](Nt), this.breakAfter.push(Nt);
                }
                if (this.break.before !== "auto" || this.break.beforeTarget !== "") {
                  const Nt = new se({
                    targetType: this.break.before,
                    target: this.break.beforeTarget,
                    startNew: this.break.startNew.toString()
                  });
                  Nt[t.$globalData] = this[t.$globalData], this[t.$appendChild](Nt), this.breakBefore.push(Nt);
                }
                if (this.break.overflowTarget !== "") {
                  const Nt = new Je({
                    target: this.break.overflowTarget,
                    leader: this.break.overflowLeader,
                    trailer: this.break.overflowTrailer
                  });
                  Nt[t.$globalData] = this[t.$globalData], this[t.$appendChild](Nt), this.overflow.push(Nt);
                }
                this[t.$removeChild](this.break), this.break = null;
              }
              if (this.presence === "hidden" || this.presence === "inactive")
                return e.HTMLResult.EMPTY;
              if ((this.breakBefore.children.length > 1 || this.breakAfter.children.length > 1) && (0, y.warn)("XFA - Several breakBefore or breakAfter in subforms: please file a bug."), this.breakBefore.children.length >= 1) {
                const Nt = this.breakBefore.children[0];
                if (O(Nt))
                  return e.HTMLResult.breakNode(Nt);
              }
              if (this[t.$extra] && this[t.$extra].afterBreakAfter)
                return e.HTMLResult.EMPTY;
              (0, h.fixDimensions)(this);
              const he = [], Ne = {
                id: this[t.$uid],
                class: []
              };
              (0, h.setAccess)(this, Ne.class), this[t.$extra] || (this[t.$extra] = /* @__PURE__ */ Object.create(null)), Object.assign(this[t.$extra], {
                children: he,
                line: null,
                attributes: Ne,
                attempt: 0,
                numberInLine: 0,
                availableSpace: {
                  width: Math.min(this.w || 1 / 0, P.width),
                  height: Math.min(this.h || 1 / 0, P.height)
                },
                width: 0,
                height: 0,
                prevHeight: 0,
                currentWidth: 0
              });
              const Ve = this[t.$getTemplateRoot](), st = Ve[t.$extra].noLayoutFailure, Tt = this[t.$isSplittable]();
              if (Tt || f(this), !(0, v.checkDimensions)(this, P))
                return e.HTMLResult.FAILURE;
              const Ct = /* @__PURE__ */ new Set(["area", "draw", "exclGroup", "field", "subform", "subformSet"]);
              if (this.layout.includes("row")) {
                const Nt = this[t.$getSubformParent]().columnWidths;
                Array.isArray(Nt) && Nt.length > 0 && (this[t.$extra].columnWidths = Nt, this[t.$extra].currentColumn = 0);
              }
              const _t = (0, h.toStyle)(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), It = ["xfaSubform"], Bt = (0, h.layoutClass)(this);
              if (Bt && It.push(Bt), Ne.style = _t, Ne.class = It, this.name && (Ne.xfaName = this.name), this.overflow) {
                const Nt = this.overflow[t.$getExtra]();
                Nt.addLeader && (Nt.addLeader = !1, S(this, Nt.leader, P));
              }
              this[t.$pushPara]();
              const Vt = this.layout === "lr-tb" || this.layout === "rl-tb", Ht = Vt ? n : 1;
              for (; this[t.$extra].attempt < Ht; this[t.$extra].attempt++) {
                Vt && this[t.$extra].attempt === n - 1 && (this[t.$extra].numberInLine = 0);
                const Nt = this[t.$childrenToHTML]({
                  filter: Ct,
                  include: !0
                });
                if (Nt.success)
                  break;
                if (Nt.isBreak())
                  return this[t.$popPara](), Nt;
                if (Vt && this[t.$extra].attempt === 0 && this[t.$extra].numberInLine === 0 && !Ve[t.$extra].noLayoutFailure) {
                  this[t.$extra].attempt = Ht;
                  break;
                }
              }
              if (this[t.$popPara](), Tt || U(this), Ve[t.$extra].noLayoutFailure = st, this[t.$extra].attempt === Ht)
                return this.overflow && (this[t.$getTemplateRoot]()[t.$extra].overflowNode = this.overflow), Tt || delete this[t.$extra], e.HTMLResult.FAILURE;
              if (this.overflow) {
                const Nt = this.overflow[t.$getExtra]();
                Nt.addTrailer && (Nt.addTrailer = !1, S(this, Nt.trailer, P));
              }
              let qt = 0, Gt = 0;
              this.margin && (qt = this.margin.leftInset + this.margin.rightInset, Gt = this.margin.topInset + this.margin.bottomInset);
              const Mt = Math.max(this[t.$extra].width + qt, this.w || 0), Kt = Math.max(this[t.$extra].height + Gt, this.h || 0), Ut = [this.x, this.y, Mt, Kt];
              if (this.w === "" && (_t.width = (0, h.measureToString)(Mt)), this.h === "" && (_t.height = (0, h.measureToString)(Kt)), (_t.width === "0px" || _t.height === "0px") && he.length === 0)
                return e.HTMLResult.EMPTY;
              const Lt = {
                name: "div",
                attributes: Ne,
                children: he
              };
              R(this, Ne);
              const tn = e.HTMLResult.success((0, h.createWrapper)(this, Lt), Ut);
              if (this.breakAfter.children.length >= 1) {
                const Nt = this.breakAfter.children[0];
                if (O(Nt))
                  return this[t.$extra].afterBreakAfter = tn, e.HTMLResult.breakNode(Nt);
              }
              return delete this[t.$extra], tn;
            }
          }
          class on extends t.XFAObject {
            constructor(P) {
              super(m, "subformSet", !0), this.id = P.id || "", this.name = P.name || "", this.relation = (0, e.getStringOption)(P.relation, ["ordered", "choice", "unordered"]), this.relevant = (0, e.getRelevant)(P.relevant), this.use = P.use || "", this.usehref = P.usehref || "", this.bookend = null, this.break = null, this.desc = null, this.extras = null, this.occur = null, this.overflow = null, this.breakAfter = new t.XFAObjectArray(), this.breakBefore = new t.XFAObjectArray(), this.subform = new t.XFAObjectArray(), this.subformSet = new t.XFAObjectArray();
            }
            *[t.$getContainedChildren]() {
              yield* j(this);
            }
            [t.$getSubformParent]() {
              let P = this[t.$getParent]();
              for (; !(P instanceof xn); )
                P = P[t.$getParent]();
              return P;
            }
            [t.$isBindable]() {
              return !0;
            }
          }
          class Sn extends t.ContentObject {
            constructor(P) {
              super(m, "subjectDN"), this.delimiter = P.delimiter || ",", this.id = P.id || "", this.name = P.name || "", this.use = P.use || "", this.usehref = P.usehref || "";
            }
            [t.$finalize]() {
              this[t.$content] = new Map(this[t.$content].split(this.delimiter).map((P) => (P = P.split("=", 2), P[0] = P[0].trim(), P)));
            }
          }
          class Qt extends t.XFAObject {
            constructor(P) {
              super(m, "subjectDNs", !0), this.id = P.id || "", this.type = (0, e.getStringOption)(P.type, ["optional", "required"]), this.use = P.use || "", this.usehref = P.usehref || "", this.subjectDN = new t.XFAObjectArray();
            }
          }
          class cn extends t.XFAObject {
            constructor(P) {
              super(m, "submit", !0), this.embedPDF = (0, e.getInteger)({
                data: P.embedPDF,
                defaultValue: 0,
                validate: (he) => he === 1
              }), this.format = (0, e.getStringOption)(P.format, ["xdp", "formdata", "pdf", "urlencoded", "xfd", "xml"]), this.id = P.id || "", this.target = P.target || "", this.textEncoding = (0, e.getKeyword)({
                data: P.textEncoding ? P.textEncoding.toLowerCase() : "",
                defaultValue: "",
                validate: (he) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(he) || he.match(/iso-8859-\d{2}/)
              }), this.use = P.use || "", this.usehref = P.usehref || "", this.xdpContent = P.xdpContent || "", this.encrypt = null, this.encryptData = new t.XFAObjectArray(), this.signData = new t.XFAObjectArray();
            }
          }
          class bn extends t.XFAObject {
            constructor(P) {
              super(m, "template", !0), this.baseProfile = (0, e.getStringOption)(P.baseProfile, ["full", "interactiveForms"]), this.extras = null, this.subform = new t.XFAObjectArray();
            }
            [t.$finalize]() {
              this.subform.children.length === 0 && (0, y.warn)("XFA - No subforms in template node."), this.subform.children.length >= 2 && (0, y.warn)("XFA - Several subforms in template node: please file a bug."), this[t.$tabIndex] = l;
            }
            [t.$isSplittable]() {
              return !0;
            }
            [t.$searchNode](P, he) {
              return P.startsWith("#") ? [this[t.$ids].get(P.slice(1))] : (0, p.searchNode)(this, he, P, !0, !0);
            }
            *[t.$toPages]() {
              if (!this.subform.children.length)
                return e.HTMLResult.success({
                  name: "div",
                  children: []
                });
              this[t.$extra] = {
                overflowNode: null,
                firstUnsplittable: null,
                currentContentArea: null,
                currentPageArea: null,
                noLayoutFailure: !1,
                pageNumber: 1,
                pagePosition: "first",
                oddOrEven: "odd",
                blankOrNotBlank: "nonBlank",
                paraStack: []
              };
              const P = this.subform.children[0];
              P.pageSet[t.$cleanPage]();
              const he = P.pageSet.pageArea.children, Ne = {
                name: "div",
                children: []
              };
              let Ve = null, st = null, Tt = null;
              if (P.breakBefore.children.length >= 1 ? (st = P.breakBefore.children[0], Tt = st.target) : P.subform.children.length >= 1 && P.subform.children[0].breakBefore.children.length >= 1 ? (st = P.subform.children[0].breakBefore.children[0], Tt = st.target) : P.break && P.break.beforeTarget ? (st = P.break, Tt = st.beforeTarget) : P.subform.children.length >= 1 && P.subform.children[0].break && P.subform.children[0].break.beforeTarget && (st = P.subform.children[0].break, Tt = st.beforeTarget), st) {
                const Gt = this[t.$searchNode](Tt, st[t.$getParent]());
                Gt instanceof Ye && (Ve = Gt, st[t.$extra] = {});
              }
              Ve || (Ve = he[0]), Ve[t.$extra] = {
                numberOfUse: 1
              };
              const Ct = Ve[t.$getParent]();
              Ct[t.$extra] = {
                numberOfUse: 1,
                pageIndex: Ct.pageArea.children.indexOf(Ve),
                pageSetIndex: 0
              };
              let _t, It = null, Bt = null, Vt = !0, Ht = 0, qt = 0;
              for (; ; ) {
                if (Vt)
                  Ht = 0;
                else if (Ne.children.pop(), ++Ht === i)
                  return (0, y.warn)("XFA - Something goes wrong: please file a bug."), Ne;
                _t = null, this[t.$extra].currentPageArea = Ve;
                const Gt = Ve[t.$toHTML]().html;
                Ne.children.push(Gt), It && (this[t.$extra].noLayoutFailure = !0, Gt.children.push(It[t.$toHTML](Ve[t.$extra].space).html), It = null), Bt && (this[t.$extra].noLayoutFailure = !0, Gt.children.push(Bt[t.$toHTML](Ve[t.$extra].space).html), Bt = null);
                const Mt = Ve.contentArea.children, Kt = Gt.children.filter((Lt) => Lt.attributes.class.includes("xfaContentarea"));
                Vt = !1, this[t.$extra].firstUnsplittable = null, this[t.$extra].noLayoutFailure = !1;
                const Ut = (Lt) => {
                  const tn = P[t.$flushHTML]();
                  tn && (Vt = Vt || tn.children && tn.children.length !== 0, Kt[Lt].children.push(tn));
                };
                for (let Lt = qt, tn = Mt.length; Lt < tn; Lt++) {
                  const Nt = this[t.$extra].currentContentArea = Mt[Lt], ln = {
                    width: Nt.w,
                    height: Nt.h
                  };
                  qt = 0, It && (Kt[Lt].children.push(It[t.$toHTML](ln).html), It = null), Bt && (Kt[Lt].children.push(Bt[t.$toHTML](ln).html), Bt = null);
                  const rn = P[t.$toHTML](ln);
                  if (rn.success)
                    return rn.html ? (Vt = Vt || rn.html.children && rn.html.children.length !== 0, Kt[Lt].children.push(rn.html)) : !Vt && Ne.children.length > 1 && Ne.children.pop(), Ne;
                  if (rn.isBreak()) {
                    const Jt = rn.breakNode;
                    if (Ut(Lt), Jt.targetType === "auto")
                      continue;
                    Jt.leader && (It = this[t.$searchNode](Jt.leader, Jt[t.$getParent]()), It = It ? It[0] : null), Jt.trailer && (Bt = this[t.$searchNode](Jt.trailer, Jt[t.$getParent]()), Bt = Bt ? Bt[0] : null), Jt.targetType === "pageArea" ? (_t = Jt[t.$extra].target, Lt = 1 / 0) : Jt[t.$extra].target ? (_t = Jt[t.$extra].target, qt = Jt[t.$extra].index + 1, Lt = 1 / 0) : Lt = Jt[t.$extra].index;
                    continue;
                  }
                  if (this[t.$extra].overflowNode) {
                    const Jt = this[t.$extra].overflowNode;
                    this[t.$extra].overflowNode = null;
                    const pn = Jt[t.$getExtra](), mn = pn.target;
                    pn.addLeader = pn.leader !== null, pn.addTrailer = pn.trailer !== null, Ut(Lt);
                    const Kn = Lt;
                    if (Lt = 1 / 0, mn instanceof Ye)
                      _t = mn;
                    else if (mn instanceof ie) {
                      const fn = Mt.indexOf(mn);
                      fn !== -1 ? fn > Kn ? Lt = fn - 1 : qt = fn : (_t = mn[t.$getParent](), qt = _t.contentArea.children.indexOf(mn));
                    }
                    continue;
                  }
                  Ut(Lt);
                }
                this[t.$extra].pageNumber += 1, _t && (_t[t.$isUsable]() ? _t[t.$extra].numberOfUse += 1 : _t = null), Ve = _t || Ve[t.$getNextPage](), yield null;
              }
            }
          }
          o.Template = bn;
          class Cn extends t.ContentObject {
            constructor(P) {
              super(m, "text"), this.id = P.id || "", this.maxChars = (0, e.getInteger)({
                data: P.maxChars,
                defaultValue: 0,
                validate: (he) => he >= 0
              }), this.name = P.name || "", this.rid = P.rid || "", this.use = P.use || "", this.usehref = P.usehref || "";
            }
            [t.$acceptWhitespace]() {
              return !0;
            }
            [t.$onChild](P) {
              return P[t.$namespaceId] === a.NamespaceIds.xhtml.id ? (this[t.$content] = P, !0) : ((0, y.warn)(`XFA - Invalid content in Text: ${P[t.$nodeName]}.`), !1);
            }
            [t.$onText](P) {
              this[t.$content] instanceof t.XFAObject || super[t.$onText](P);
            }
            [t.$finalize]() {
              typeof this[t.$content] == "string" && (this[t.$content] = this[t.$content].replace(/\r\n/g, `
`));
            }
            [t.$getExtra]() {
              return typeof this[t.$content] == "string" ? this[t.$content].split(/[\u2029\u2028\n]/).reduce((P, he) => (he && P.push(he), P), []).join(`
`) : this[t.$content][t.$text]();
            }
            [t.$toHTML](P) {
              if (typeof this[t.$content] == "string") {
                const he = x(this[t.$content]).html;
                return this[t.$content].includes("\u2029") ? (he.name = "div", he.children = [], this[t.$content].split("\u2029").map((Ne) => Ne.split(/[\u2028\n]/).reduce((Ve, st) => (Ve.push({
                  name: "span",
                  value: st
                }, {
                  name: "br"
                }), Ve), [])).forEach((Ne) => {
                  he.children.push({
                    name: "p",
                    children: Ne
                  });
                })) : /[\u2028\n]/.test(this[t.$content]) && (he.name = "div", he.children = [], this[t.$content].split(/[\u2028\n]/).forEach((Ne) => {
                  he.children.push({
                    name: "span",
                    value: Ne
                  }, {
                    name: "br"
                  });
                })), e.HTMLResult.success(he);
              }
              return this[t.$content][t.$toHTML](P);
            }
          }
          o.Text = Cn;
          class yn extends t.XFAObject {
            constructor(P) {
              super(m, "textEdit", !0), this.allowRichText = (0, e.getInteger)({
                data: P.allowRichText,
                defaultValue: 0,
                validate: (he) => he === 1
              }), this.hScrollPolicy = (0, e.getStringOption)(P.hScrollPolicy, ["auto", "off", "on"]), this.id = P.id || "", this.multiLine = (0, e.getInteger)({
                data: P.multiLine,
                defaultValue: "",
                validate: (he) => he === 0 || he === 1
              }), this.use = P.use || "", this.usehref = P.usehref || "", this.vScrollPolicy = (0, e.getStringOption)(P.vScrollPolicy, ["auto", "off", "on"]), this.border = null, this.comb = null, this.extras = null, this.margin = null;
            }
            [t.$toHTML](P) {
              const he = (0, h.toStyle)(this, "border", "font", "margin");
              let Ne;
              const Ve = this[t.$getParent]()[t.$getParent]();
              return this.multiLine === "" && (this.multiLine = Ve instanceof ye ? 1 : 0), this.multiLine === 1 ? Ne = {
                name: "textarea",
                attributes: {
                  dataId: Ve[t.$data] && Ve[t.$data][t.$uid] || Ve[t.$uid],
                  fieldId: Ve[t.$uid],
                  class: ["xfaTextfield"],
                  style: he,
                  "aria-label": k(Ve),
                  "aria-required": !1
                }
              } : Ne = {
                name: "input",
                attributes: {
                  type: "text",
                  dataId: Ve[t.$data] && Ve[t.$data][t.$uid] || Ve[t.$uid],
                  fieldId: Ve[t.$uid],
                  class: ["xfaTextfield"],
                  style: he,
                  "aria-label": k(Ve),
                  "aria-required": !1
                }
              }, X(Ve) && (Ne.attributes["aria-required"] = !0, Ne.attributes.required = !0), e.HTMLResult.success({
                name: "label",
                attributes: {
                  class: ["xfaLabel"]
                },
                children: [Ne]
              });
            }
          }
          class Mn extends t.StringObject {
            constructor(P) {
              super(m, "time"), this.id = P.id || "", this.name = P.name || "", this.use = P.use || "", this.usehref = P.usehref || "";
            }
            [t.$finalize]() {
              const P = this[t.$content].trim();
              this[t.$content] = P ? new Date(P) : null;
            }
            [t.$toHTML](P) {
              return x(this[t.$content] ? this[t.$content].toString() : "");
            }
          }
          class Bn extends t.XFAObject {
            constructor(P) {
              super(m, "timeStamp"), this.id = P.id || "", this.server = P.server || "", this.type = (0, e.getStringOption)(P.type, ["optional", "required"]), this.use = P.use || "", this.usehref = P.usehref || "";
            }
          }
          class Ln extends t.StringObject {
            constructor(P) {
              super(m, "toolTip"), this.id = P.id || "", this.rid = P.rid || "", this.use = P.use || "", this.usehref = P.usehref || "";
            }
          }
          class Nn extends t.XFAObject {
            constructor(P) {
              super(m, "traversal", !0), this.id = P.id || "", this.use = P.use || "", this.usehref = P.usehref || "", this.extras = null, this.traverse = new t.XFAObjectArray();
            }
          }
          class vn extends t.XFAObject {
            constructor(P) {
              super(m, "traverse", !0), this.id = P.id || "", this.operation = (0, e.getStringOption)(P.operation, ["next", "back", "down", "first", "left", "right", "up"]), this.ref = P.ref || "", this.use = P.use || "", this.usehref = P.usehref || "", this.extras = null, this.script = null;
            }
            get name() {
              return this.operation;
            }
            [t.$isTransparent]() {
              return !1;
            }
          }
          class wn extends t.XFAObject {
            constructor(P) {
              super(m, "ui", !0), this.id = P.id || "", this.use = P.use || "", this.usehref = P.usehref || "", this.extras = null, this.picture = null, this.barcode = null, this.button = null, this.checkButton = null, this.choiceList = null, this.dateTimeEdit = null, this.defaultUi = null, this.imageEdit = null, this.numericEdit = null, this.passwordEdit = null, this.signature = null, this.textEdit = null;
            }
            [t.$getExtra]() {
              if (this[t.$extra] === void 0) {
                for (const P of Object.getOwnPropertyNames(this)) {
                  if (P === "extras" || P === "picture")
                    continue;
                  const he = this[P];
                  if (he instanceof t.XFAObject)
                    return this[t.$extra] = he, he;
                }
                this[t.$extra] = null;
              }
              return this[t.$extra];
            }
            [t.$toHTML](P) {
              const he = this[t.$getExtra]();
              return he ? he[t.$toHTML](P) : e.HTMLResult.EMPTY;
            }
          }
          class jn extends t.XFAObject {
            constructor(P) {
              super(m, "validate", !0), this.formatTest = (0, e.getStringOption)(P.formatTest, ["warning", "disabled", "error"]), this.id = P.id || "", this.nullTest = (0, e.getStringOption)(P.nullTest, ["disabled", "error", "warning"]), this.scriptTest = (0, e.getStringOption)(P.scriptTest, ["error", "disabled", "warning"]), this.use = P.use || "", this.usehref = P.usehref || "", this.extras = null, this.message = null, this.picture = null, this.script = null;
            }
          }
          class hn extends t.XFAObject {
            constructor(P) {
              super(m, "value", !0), this.id = P.id || "", this.override = (0, e.getInteger)({
                data: P.override,
                defaultValue: 0,
                validate: (he) => he === 1
              }), this.relevant = (0, e.getRelevant)(P.relevant), this.use = P.use || "", this.usehref = P.usehref || "", this.arc = null, this.boolean = null, this.date = null, this.dateTime = null, this.decimal = null, this.exData = null, this.float = null, this.image = null, this.integer = null, this.line = null, this.rectangle = null, this.text = null, this.time = null;
            }
            [t.$setValue](P) {
              const he = this[t.$getParent]();
              if (he instanceof Te && he.ui && he.ui.imageEdit) {
                this.image || (this.image = new yt({}), this[t.$appendChild](this.image)), this.image[t.$content] = P[t.$content];
                return;
              }
              const Ne = P[t.$nodeName];
              if (this[Ne] !== null) {
                this[Ne][t.$content] = P[t.$content];
                return;
              }
              for (const Ve of Object.getOwnPropertyNames(this)) {
                const st = this[Ve];
                st instanceof t.XFAObject && (this[Ve] = null, this[t.$removeChild](st));
              }
              this[P[t.$nodeName]] = P, this[t.$appendChild](P);
            }
            [t.$text]() {
              if (this.exData)
                return typeof this.exData[t.$content] == "string" ? this.exData[t.$content].trim() : this.exData[t.$content][t.$text]().trim();
              for (const P of Object.getOwnPropertyNames(this)) {
                if (P === "image")
                  continue;
                const he = this[P];
                if (he instanceof t.XFAObject)
                  return (he[t.$content] || "").toString().trim();
              }
              return null;
            }
            [t.$toHTML](P) {
              for (const he of Object.getOwnPropertyNames(this)) {
                const Ne = this[he];
                if (Ne instanceof t.XFAObject)
                  return Ne[t.$toHTML](P);
              }
              return e.HTMLResult.EMPTY;
            }
          }
          o.Value = hn;
          class Wn extends t.XFAObject {
            constructor(P) {
              super(m, "variables", !0), this.id = P.id || "", this.use = P.use || "", this.usehref = P.usehref || "", this.boolean = new t.XFAObjectArray(), this.date = new t.XFAObjectArray(), this.dateTime = new t.XFAObjectArray(), this.decimal = new t.XFAObjectArray(), this.exData = new t.XFAObjectArray(), this.float = new t.XFAObjectArray(), this.image = new t.XFAObjectArray(), this.integer = new t.XFAObjectArray(), this.manifest = new t.XFAObjectArray(), this.script = new t.XFAObjectArray(), this.text = new t.XFAObjectArray(), this.time = new t.XFAObjectArray();
            }
            [t.$isTransparent]() {
              return !0;
            }
          }
          class dn {
            static [a.$buildXFAObject](P, he) {
              if (dn.hasOwnProperty(P)) {
                const Ne = dn[P](he);
                return Ne[t.$setSetAttributes](he), Ne;
              }
            }
            static appearanceFilter(P) {
              return new F(P);
            }
            static arc(P) {
              return new T(P);
            }
            static area(P) {
              return new I(P);
            }
            static assist(P) {
              return new M(P);
            }
            static barcode(P) {
              return new V(P);
            }
            static bind(P) {
              return new J(P);
            }
            static bindItems(P) {
              return new W(P);
            }
            static bookend(P) {
              return new z(P);
            }
            static boolean(P) {
              return new G(P);
            }
            static border(P) {
              return new L(P);
            }
            static break(P) {
              return new K(P);
            }
            static breakAfter(P) {
              return new te(P);
            }
            static breakBefore(P) {
              return new se(P);
            }
            static button(P) {
              return new q(P);
            }
            static calculate(P) {
              return new N(P);
            }
            static caption(P) {
              return new Q(P);
            }
            static certificate(P) {
              return new D(P);
            }
            static certificates(P) {
              return new ne(P);
            }
            static checkButton(P) {
              return new oe(P);
            }
            static choiceList(P) {
              return new ee(P);
            }
            static color(P) {
              return new $(P);
            }
            static comb(P) {
              return new E(P);
            }
            static connect(P) {
              return new H(P);
            }
            static contentArea(P) {
              return new ie(P);
            }
            static corner(P) {
              return new ue(P);
            }
            static date(P) {
              return new fe(P);
            }
            static dateTime(P) {
              return new de(P);
            }
            static dateTimeEdit(P) {
              return new pe(P);
            }
            static decimal(P) {
              return new xe(P);
            }
            static defaultUi(P) {
              return new De(P);
            }
            static desc(P) {
              return new Ae(P);
            }
            static digestMethod(P) {
              return new Se(P);
            }
            static digestMethods(P) {
              return new ke(P);
            }
            static draw(P) {
              return new ye(P);
            }
            static edge(P) {
              return new _e(P);
            }
            static encoding(P) {
              return new we(P);
            }
            static encodings(P) {
              return new Ce(P);
            }
            static encrypt(P) {
              return new ve(P);
            }
            static encryptData(P) {
              return new Le(P);
            }
            static encryption(P) {
              return new He(P);
            }
            static encryptionMethod(P) {
              return new Qe(P);
            }
            static encryptionMethods(P) {
              return new Ue(P);
            }
            static event(P) {
              return new Ie(P);
            }
            static exData(P) {
              return new Ee(P);
            }
            static exObject(P) {
              return new et(P);
            }
            static exclGroup(P) {
              return new qe(P);
            }
            static execute(P) {
              return new tt(P);
            }
            static extras(P) {
              return new ft(P);
            }
            static field(P) {
              return new Te(P);
            }
            static fill(P) {
              return new je(P);
            }
            static filter(P) {
              return new Ze(P);
            }
            static float(P) {
              return new Me(P);
            }
            static font(P) {
              return new at(P);
            }
            static format(P) {
              return new rt(P);
            }
            static handler(P) {
              return new xt(P);
            }
            static hyphenation(P) {
              return new ut(P);
            }
            static image(P) {
              return new yt(P);
            }
            static imageEdit(P) {
              return new ht(P);
            }
            static integer(P) {
              return new Rt(P);
            }
            static issuers(P) {
              return new Wt(P);
            }
            static items(P) {
              return new Ke(P);
            }
            static keep(P) {
              return new Ge(P);
            }
            static keyUsage(P) {
              return new nt(P);
            }
            static line(P) {
              return new it(P);
            }
            static linear(P) {
              return new pt(P);
            }
            static lockDocument(P) {
              return new Ft(P);
            }
            static manifest(P) {
              return new mt(P);
            }
            static margin(P) {
              return new ct(P);
            }
            static mdp(P) {
              return new bt(P);
            }
            static medium(P) {
              return new wt(P);
            }
            static message(P) {
              return new Ot(P);
            }
            static numericEdit(P) {
              return new Et(P);
            }
            static occur(P) {
              return new St(P);
            }
            static oid(P) {
              return new Pe(P);
            }
            static oids(P) {
              return new We(P);
            }
            static overflow(P) {
              return new Je(P);
            }
            static pageArea(P) {
              return new Ye(P);
            }
            static pageSet(P) {
              return new gt(P);
            }
            static para(P) {
              return new Dt(P);
            }
            static passwordEdit(P) {
              return new Xt(P);
            }
            static pattern(P) {
              return new kt(P);
            }
            static picture(P) {
              return new Pt(P);
            }
            static proto(P) {
              return new zt(P);
            }
            static radial(P) {
              return new Yt(P);
            }
            static reason(P) {
              return new an(P);
            }
            static reasons(P) {
              return new Dn(P);
            }
            static rectangle(P) {
              return new gn(P);
            }
            static ref(P) {
              return new _n(P);
            }
            static script(P) {
              return new En(P);
            }
            static setProperty(P) {
              return new An(P);
            }
            static signData(P) {
              return new kn(P);
            }
            static signature(P) {
              return new On(P);
            }
            static signing(P) {
              return new In(P);
            }
            static solid(P) {
              return new Pn(P);
            }
            static speak(P) {
              return new Rn(P);
            }
            static stipple(P) {
              return new Un(P);
            }
            static subform(P) {
              return new xn(P);
            }
            static subformSet(P) {
              return new on(P);
            }
            static subjectDN(P) {
              return new Sn(P);
            }
            static subjectDNs(P) {
              return new Qt(P);
            }
            static submit(P) {
              return new cn(P);
            }
            static template(P) {
              return new bn(P);
            }
            static text(P) {
              return new Cn(P);
            }
            static textEdit(P) {
              return new yn(P);
            }
            static time(P) {
              return new Mn(P);
            }
            static timeStamp(P) {
              return new Bn(P);
            }
            static toolTip(P) {
              return new Ln(P);
            }
            static traversal(P) {
              return new Nn(P);
            }
            static traverse(P) {
              return new vn(P);
            }
            static ui(P) {
              return new wn(P);
            }
            static validate(P) {
              return new jn(P);
            }
            static value(P) {
              return new hn(P);
            }
            static variables(P) {
              return new Wn(P);
            }
          }
          o.TemplateNamespace = dn;
        },
        /* 83 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.addHTML = e, o.checkDimensions = d, o.flushHTML = h, o.getAvailableSpace = y;
          var t = C(77), a = C(84);
          function v(p, m) {
            return {
              name: "div",
              attributes: {
                class: [p.layout === "lr-tb" ? "xfaLr" : "xfaRl"]
              },
              children: m
            };
          }
          function h(p) {
            if (!p[t.$extra])
              return null;
            const g = {
              name: "div",
              attributes: p[t.$extra].attributes,
              children: p[t.$extra].children
            };
            if (p[t.$extra].failingNode) {
              const n = p[t.$extra].failingNode[t.$flushHTML]();
              n && (p.layout.endsWith("-tb") ? g.children.push(v(p, [n])) : g.children.push(n));
            }
            return g.children.length === 0 ? null : g;
          }
          function e(p, m, g) {
            const n = p[t.$extra], i = n.availableSpace, [l, u, w, _] = g;
            switch (p.layout) {
              case "position": {
                n.width = Math.max(n.width, l + w), n.height = Math.max(n.height, u + _), n.children.push(m);
                break;
              }
              case "lr-tb":
              case "rl-tb":
                (!n.line || n.attempt === 1) && (n.line = v(p, []), n.children.push(n.line), n.numberInLine = 0), n.numberInLine += 1, n.line.children.push(m), n.attempt === 0 ? (n.currentWidth += w, n.height = Math.max(n.height, n.prevHeight + _)) : (n.currentWidth = w, n.prevHeight = n.height, n.height += _, n.attempt = 0), n.width = Math.max(n.width, n.currentWidth);
                break;
              case "rl-row":
              case "row": {
                n.children.push(m), n.width += w, n.height = Math.max(n.height, _);
                const b = (0, a.measureToString)(n.height);
                for (const A of n.children)
                  A.attributes.style.height = b;
                break;
              }
              case "table": {
                n.width = Math.min(i.width, Math.max(n.width, w)), n.height += _, n.children.push(m);
                break;
              }
              case "tb": {
                n.width = Math.min(i.width, Math.max(n.width, w)), n.height += _, n.children.push(m);
                break;
              }
            }
          }
          function y(p) {
            const m = p[t.$extra].availableSpace, g = p.margin ? p.margin.topInset + p.margin.bottomInset : 0, n = p.margin ? p.margin.leftInset + p.margin.rightInset : 0;
            switch (p.layout) {
              case "lr-tb":
              case "rl-tb":
                return p[t.$extra].attempt === 0 ? {
                  width: m.width - n - p[t.$extra].currentWidth,
                  height: m.height - g - p[t.$extra].prevHeight
                } : {
                  width: m.width - n,
                  height: m.height - g - p[t.$extra].height
                };
              case "rl-row":
              case "row":
                return {
                  width: p[t.$extra].columnWidths.slice(p[t.$extra].currentColumn).reduce((l, u) => l + u),
                  height: m.height - n
                };
              case "table":
              case "tb":
                return {
                  width: m.width - n,
                  height: m.height - g - p[t.$extra].height
                };
              case "position":
              default:
                return m;
            }
          }
          function c(p) {
            let m = p.w === "" ? NaN : p.w, g = p.h === "" ? NaN : p.h, [n, i] = [0, 0];
            switch (p.anchorType || "") {
              case "bottomCenter":
                [n, i] = [m / 2, g];
                break;
              case "bottomLeft":
                [n, i] = [0, g];
                break;
              case "bottomRight":
                [n, i] = [m, g];
                break;
              case "middleCenter":
                [n, i] = [m / 2, g / 2];
                break;
              case "middleLeft":
                [n, i] = [0, g / 2];
                break;
              case "middleRight":
                [n, i] = [m, g / 2];
                break;
              case "topCenter":
                [n, i] = [m / 2, 0];
                break;
              case "topRight":
                [n, i] = [m, 0];
                break;
            }
            let l, u;
            switch (p.rotate || 0) {
              case 0:
                [l, u] = [-n, -i];
                break;
              case 90:
                [l, u] = [-i, n], [m, g] = [g, -m];
                break;
              case 180:
                [l, u] = [n, i], [m, g] = [-m, -g];
                break;
              case 270:
                [l, u] = [i, -n], [m, g] = [-g, m];
                break;
            }
            return [p.x + l + Math.min(0, m), p.y + u + Math.min(0, g), Math.abs(m), Math.abs(g)];
          }
          function d(p, m) {
            if (p[t.$getTemplateRoot]()[t.$extra].firstUnsplittable === null || p.w === 0 || p.h === 0)
              return !0;
            const g = 2, n = p[t.$getSubformParent](), i = n[t.$extra] && n[t.$extra].attempt || 0, [, l, u, w] = c(p);
            switch (n.layout) {
              case "lr-tb":
              case "rl-tb":
                return i === 0 ? p[t.$getTemplateRoot]()[t.$extra].noLayoutFailure ? p.w !== "" ? Math.round(u - m.width) <= g : m.width > g : p.h !== "" && Math.round(w - m.height) > g ? !1 : p.w !== "" ? Math.round(u - m.width) <= g ? !0 : n[t.$extra].numberInLine === 0 ? m.height > g : !1 : m.width > g : p[t.$getTemplateRoot]()[t.$extra].noLayoutFailure ? !0 : p.h !== "" && Math.round(w - m.height) > g ? !1 : p.w === "" || Math.round(u - m.width) <= g ? m.height > g : n[t.$isThereMoreWidth]() ? !1 : m.height > g;
              case "table":
              case "tb":
                return p[t.$getTemplateRoot]()[t.$extra].noLayoutFailure ? !0 : p.h !== "" && !p[t.$isSplittable]() ? Math.round(w - m.height) <= g : p.w === "" || Math.round(u - m.width) <= g ? m.height > g : n[t.$isThereMoreWidth]() ? !1 : m.height > g;
              case "position":
                if (p[t.$getTemplateRoot]()[t.$extra].noLayoutFailure || p.h === "" || Math.round(w + l - m.height) <= g)
                  return !0;
                const _ = p[t.$getTemplateRoot]()[t.$extra].currentContentArea;
                return w + l > _.h;
              case "rl-row":
              case "row":
                return p[t.$getTemplateRoot]()[t.$extra].noLayoutFailure ? !0 : p.h !== "" ? Math.round(w - m.height) <= g : !0;
              default:
                return !0;
            }
          }
        },
        /* 84 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.computeBbox = g, o.createWrapper = u, o.fixDimensions = n, o.fixTextIndent = w, o.fixURL = X, o.isPrintOnly = b, o.layoutClass = i, o.layoutNode = m, o.measureToString = y, o.setAccess = _, o.setFontFamily = j, o.setMinMaxDimensions = d, o.setPara = Y, o.toStyle = l;
          var t = C(77), a = C(2), v = C(78), h = C(85), e = C(86);
          function y(B) {
            return typeof B == "string" ? "0px" : Number.isInteger(B) ? `${B}px` : `${B.toFixed(2)}px`;
          }
          const c = {
            anchorType(B, R) {
              const k = B[t.$getSubformParent]();
              if (!(!k || k.layout && k.layout !== "position"))
                switch ("transform" in R || (R.transform = ""), B.anchorType) {
                  case "bottomCenter":
                    R.transform += "translate(-50%, -100%)";
                    break;
                  case "bottomLeft":
                    R.transform += "translate(0,-100%)";
                    break;
                  case "bottomRight":
                    R.transform += "translate(-100%,-100%)";
                    break;
                  case "middleCenter":
                    R.transform += "translate(-50%,-50%)";
                    break;
                  case "middleLeft":
                    R.transform += "translate(0,-50%)";
                    break;
                  case "middleRight":
                    R.transform += "translate(-100%,-50%)";
                    break;
                  case "topCenter":
                    R.transform += "translate(-50%,0)";
                    break;
                  case "topRight":
                    R.transform += "translate(-100%,0)";
                    break;
                }
            },
            dimensions(B, R) {
              const k = B[t.$getSubformParent]();
              let x = B.w;
              const f = B.h;
              if (k.layout && k.layout.includes("row")) {
                const U = k[t.$extra], O = B.colSpan;
                let S;
                O === -1 ? (S = U.columnWidths.slice(U.currentColumn).reduce((F, T) => F + T, 0), U.currentColumn = 0) : (S = U.columnWidths.slice(U.currentColumn, U.currentColumn + O).reduce((F, T) => F + T, 0), U.currentColumn = (U.currentColumn + B.colSpan) % U.columnWidths.length), isNaN(S) || (x = B.w = S);
              }
              x !== "" ? R.width = y(x) : R.width = "auto", f !== "" ? R.height = y(f) : R.height = "auto";
            },
            position(B, R) {
              const k = B[t.$getSubformParent]();
              k && k.layout && k.layout !== "position" || (R.position = "absolute", R.left = y(B.x), R.top = y(B.y));
            },
            rotate(B, R) {
              B.rotate && ("transform" in R || (R.transform = ""), R.transform += `rotate(-${B.rotate}deg)`, R.transformOrigin = "top left");
            },
            presence(B, R) {
              switch (B.presence) {
                case "invisible":
                  R.visibility = "hidden";
                  break;
                case "hidden":
                case "inactive":
                  R.display = "none";
                  break;
              }
            },
            hAlign(B, R) {
              if (B[t.$nodeName] === "para")
                switch (B.hAlign) {
                  case "justifyAll":
                    R.textAlign = "justify-all";
                    break;
                  case "radix":
                    R.textAlign = "left";
                    break;
                  default:
                    R.textAlign = B.hAlign;
                }
              else
                switch (B.hAlign) {
                  case "left":
                    R.alignSelf = "start";
                    break;
                  case "center":
                    R.alignSelf = "center";
                    break;
                  case "right":
                    R.alignSelf = "end";
                    break;
                }
            },
            margin(B, R) {
              B.margin && (R.margin = B.margin[t.$toStyle]().margin);
            }
          };
          function d(B, R) {
            B[t.$getSubformParent]().layout === "position" && (B.minW > 0 && (R.minWidth = y(B.minW)), B.maxW > 0 && (R.maxWidth = y(B.maxW)), B.minH > 0 && (R.minHeight = y(B.minH)), B.maxH > 0 && (R.maxHeight = y(B.maxH)));
          }
          function p(B, R, k, x, f, U) {
            const O = new e.TextMeasure(R, k, x, f);
            return typeof B == "string" ? O.addString(B) : B[t.$pushGlyphs](O), O.compute(U);
          }
          function m(B, R) {
            let k = null, x = null, f = !1;
            if ((!B.w || !B.h) && B.value) {
              let U = 0, O = 0;
              B.margin && (U = B.margin.leftInset + B.margin.rightInset, O = B.margin.topInset + B.margin.bottomInset);
              let S = null, F = null;
              B.para && (F = /* @__PURE__ */ Object.create(null), S = B.para.lineHeight === "" ? null : B.para.lineHeight, F.top = B.para.spaceAbove === "" ? 0 : B.para.spaceAbove, F.bottom = B.para.spaceBelow === "" ? 0 : B.para.spaceBelow, F.left = B.para.marginLeft === "" ? 0 : B.para.marginLeft, F.right = B.para.marginRight === "" ? 0 : B.para.marginRight);
              let T = B.font;
              if (!T) {
                const V = B[t.$getTemplateRoot]();
                let J = B[t.$getParent]();
                for (; J && J !== V; ) {
                  if (J.font) {
                    T = J.font;
                    break;
                  }
                  J = J[t.$getParent]();
                }
              }
              const I = (B.w || R.width) - U, M = B[t.$globalData].fontFinder;
              if (B.value.exData && B.value.exData[t.$content] && B.value.exData.contentType === "text/html") {
                const V = p(B.value.exData[t.$content], T, F, S, M, I);
                x = V.width, k = V.height, f = V.isBroken;
              } else {
                const V = B.value[t.$text]();
                if (V) {
                  const J = p(V, T, F, S, M, I);
                  x = J.width, k = J.height, f = J.isBroken;
                }
              }
              x !== null && !B.w && (x += U), k !== null && !B.h && (k += O);
            }
            return {
              w: x,
              h: k,
              isBroken: f
            };
          }
          function g(B, R, k) {
            let x;
            if (B.w !== "" && B.h !== "")
              x = [B.x, B.y, B.w, B.h];
            else {
              if (!k)
                return null;
              let f = B.w;
              if (f === "") {
                if (B.maxW === 0) {
                  const O = B[t.$getSubformParent]();
                  O.layout === "position" && O.w !== "" ? f = 0 : f = B.minW;
                } else
                  f = Math.min(B.maxW, k.width);
                R.attributes.style.width = y(f);
              }
              let U = B.h;
              if (U === "") {
                if (B.maxH === 0) {
                  const O = B[t.$getSubformParent]();
                  O.layout === "position" && O.h !== "" ? U = 0 : U = B.minH;
                } else
                  U = Math.min(B.maxH, k.height);
                R.attributes.style.height = y(U);
              }
              x = [B.x, B.y, f, U];
            }
            return x;
          }
          function n(B) {
            const R = B[t.$getSubformParent]();
            if (R.layout && R.layout.includes("row")) {
              const k = R[t.$extra], x = B.colSpan;
              let f;
              x === -1 ? f = k.columnWidths.slice(k.currentColumn).reduce((U, O) => U + O, 0) : f = k.columnWidths.slice(k.currentColumn, k.currentColumn + x).reduce((U, O) => U + O, 0), isNaN(f) || (B.w = f);
            }
            R.layout && R.layout !== "position" && (B.x = B.y = 0), B.layout === "table" && B.w === "" && Array.isArray(B.columnWidths) && (B.w = B.columnWidths.reduce((k, x) => k + x, 0));
          }
          function i(B) {
            switch (B.layout) {
              case "position":
                return "xfaPosition";
              case "lr-tb":
                return "xfaLrTb";
              case "rl-row":
                return "xfaRlRow";
              case "rl-tb":
                return "xfaRlTb";
              case "row":
                return "xfaRow";
              case "table":
                return "xfaTable";
              case "tb":
                return "xfaTb";
              default:
                return "xfaPosition";
            }
          }
          function l(B, ...R) {
            const k = /* @__PURE__ */ Object.create(null);
            for (const x of R) {
              const f = B[x];
              if (f !== null) {
                if (c.hasOwnProperty(x)) {
                  c[x](B, k);
                  continue;
                }
                if (f instanceof t.XFAObject) {
                  const U = f[t.$toStyle]();
                  U ? Object.assign(k, U) : (0, a.warn)(`(DEBUG) - XFA - style for ${x} not implemented yet`);
                }
              }
            }
            return k;
          }
          function u(B, R) {
            const {
              attributes: k
            } = R, {
              style: x
            } = k, f = {
              name: "div",
              attributes: {
                class: ["xfaWrapper"],
                style: /* @__PURE__ */ Object.create(null)
              },
              children: []
            };
            if (k.class.push("xfaWrapped"), B.border) {
              const {
                widths: U,
                insets: O
              } = B.border[t.$extra];
              let S, F, T = O[0], I = O[3];
              const M = O[0] + O[2], V = O[1] + O[3];
              switch (B.border.hand) {
                case "even":
                  T -= U[0] / 2, I -= U[3] / 2, S = `calc(100% + ${(U[1] + U[3]) / 2 - V}px)`, F = `calc(100% + ${(U[0] + U[2]) / 2 - M}px)`;
                  break;
                case "left":
                  T -= U[0], I -= U[3], S = `calc(100% + ${U[1] + U[3] - V}px)`, F = `calc(100% + ${U[0] + U[2] - M}px)`;
                  break;
                case "right":
                  S = V ? `calc(100% - ${V}px)` : "100%", F = M ? `calc(100% - ${M}px)` : "100%";
                  break;
              }
              const J = ["xfaBorder"];
              b(B.border) && J.push("xfaPrintOnly");
              const W = {
                name: "div",
                attributes: {
                  class: J,
                  style: {
                    top: `${T}px`,
                    left: `${I}px`,
                    width: S,
                    height: F
                  }
                },
                children: []
              };
              for (const z of ["border", "borderWidth", "borderColor", "borderRadius", "borderStyle"])
                x[z] !== void 0 && (W.attributes.style[z] = x[z], delete x[z]);
              f.children.push(W, R);
            } else
              f.children.push(R);
            for (const U of ["background", "backgroundClip", "top", "left", "width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "transform", "transformOrigin", "visibility"])
              x[U] !== void 0 && (f.attributes.style[U] = x[U], delete x[U]);
            return x.position === "absolute" ? f.attributes.style.position = "absolute" : f.attributes.style.position = "relative", delete x.position, x.alignSelf && (f.attributes.style.alignSelf = x.alignSelf, delete x.alignSelf), f;
          }
          function w(B) {
            const R = (0, v.getMeasurement)(B.textIndent, "0px");
            if (R >= 0)
              return;
            const x = "padding" + ((B.textAlign === "right" ? "right" : "left") === "left" ? "Left" : "Right"), f = (0, v.getMeasurement)(B[x], "0px");
            B[x] = `${f - R}px`;
          }
          function _(B, R) {
            switch (B.access) {
              case "nonInteractive":
                R.push("xfaNonInteractive");
                break;
              case "readOnly":
                R.push("xfaReadOnly");
                break;
              case "protected":
                R.push("xfaDisabled");
                break;
            }
          }
          function b(B) {
            return B.relevant.length > 0 && !B.relevant[0].excluded && B.relevant[0].viewname === "print";
          }
          function A(B) {
            const R = B[t.$getTemplateRoot]()[t.$extra].paraStack;
            return R.length ? R.at(-1) : null;
          }
          function Y(B, R, k) {
            if (k.attributes.class && k.attributes.class.includes("xfaRich")) {
              R && (B.h === "" && (R.height = "auto"), B.w === "" && (R.width = "auto"));
              const x = A(B);
              if (x) {
                const f = k.attributes.style;
                switch (f.display = "flex", f.flexDirection = "column", x.vAlign) {
                  case "top":
                    f.justifyContent = "start";
                    break;
                  case "bottom":
                    f.justifyContent = "end";
                    break;
                  case "middle":
                    f.justifyContent = "center";
                    break;
                }
                const U = x[t.$toStyle]();
                for (const [O, S] of Object.entries(U))
                  O in f || (f[O] = S);
              }
            }
          }
          function j(B, R, k, x) {
            if (!k) {
              delete x.fontFamily;
              return;
            }
            const f = (0, v.stripQuotes)(B.typeface);
            x.fontFamily = `"${f}"`;
            const U = k.find(f);
            if (U) {
              const {
                fontFamily: O
              } = U.regular.cssFontInfo;
              O !== f && (x.fontFamily = `"${O}"`);
              const S = A(R);
              if (S && S.lineHeight !== "" || x.lineHeight)
                return;
              const F = (0, h.selectFont)(B, U);
              F && (x.lineHeight = Math.max(1.2, F.lineHeight));
            }
          }
          function X(B) {
            const R = (0, a.createValidAbsoluteUrl)(B, null, {
              addDefaultProtocol: !0,
              tryConvertEncoding: !0
            });
            return R ? R.href : null;
          }
        },
        /* 85 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.FontFinder = void 0, o.getMetrics = y, o.selectFont = e;
          var t = C(77), a = C(78), v = C(2);
          class h {
            constructor(d) {
              this.fonts = /* @__PURE__ */ new Map(), this.cache = /* @__PURE__ */ new Map(), this.warned = /* @__PURE__ */ new Set(), this.defaultFont = null, this.add(d);
            }
            add(d, p = null) {
              for (const g of d)
                this.addPdfFont(g);
              for (const g of this.fonts.values())
                g.regular || (g.regular = g.italic || g.bold || g.bolditalic);
              if (!p || p.size === 0)
                return;
              const m = this.fonts.get("PdfJS-Fallback-PdfJS-XFA");
              for (const g of p)
                this.fonts.set(g, m);
            }
            addPdfFont(d) {
              const p = d.cssFontInfo, m = p.fontFamily;
              let g = this.fonts.get(m);
              g || (g = /* @__PURE__ */ Object.create(null), this.fonts.set(m, g), this.defaultFont || (this.defaultFont = g));
              let n = "";
              const i = parseFloat(p.fontWeight);
              parseFloat(p.italicAngle) !== 0 ? n = i >= 700 ? "bolditalic" : "italic" : i >= 700 && (n = "bold"), n || ((d.name.includes("Bold") || d.psName && d.psName.includes("Bold")) && (n = "bold"), (d.name.includes("Italic") || d.name.endsWith("It") || d.psName && (d.psName.includes("Italic") || d.psName.endsWith("It"))) && (n += "italic")), n || (n = "regular"), g[n] = d;
            }
            getDefault() {
              return this.defaultFont;
            }
            find(d, p = !0) {
              let m = this.fonts.get(d) || this.cache.get(d);
              if (m)
                return m;
              const g = /,|-|_| |bolditalic|bold|italic|regular|it/gi;
              let n = d.replace(g, "");
              if (m = this.fonts.get(n), m)
                return this.cache.set(d, m), m;
              n = n.toLowerCase();
              const i = [];
              for (const [l, u] of this.fonts.entries())
                l.replace(g, "").toLowerCase().startsWith(n) && i.push(u);
              if (i.length === 0)
                for (const [, l] of this.fonts.entries())
                  l.regular.name && l.regular.name.replace(g, "").toLowerCase().startsWith(n) && i.push(l);
              if (i.length === 0) {
                n = n.replace(/psmt|mt/gi, "");
                for (const [l, u] of this.fonts.entries())
                  l.replace(g, "").toLowerCase().startsWith(n) && i.push(u);
              }
              if (i.length === 0)
                for (const l of this.fonts.values())
                  l.regular.name && l.regular.name.replace(g, "").toLowerCase().startsWith(n) && i.push(l);
              return i.length >= 1 ? (i.length !== 1 && p && (0, v.warn)(`XFA - Too many choices to guess the correct font: ${d}`), this.cache.set(d, i[0]), i[0]) : (p && !this.warned.has(d) && (this.warned.add(d), (0, v.warn)(`XFA - Cannot find the font: ${d}`)), null);
            }
          }
          o.FontFinder = h;
          function e(c, d) {
            return c.posture === "italic" ? c.weight === "bold" ? d.bolditalic : d.italic : c.weight === "bold" ? d.bold : d.regular;
          }
          function y(c, d = !1) {
            let p = null;
            if (c) {
              const i = (0, a.stripQuotes)(c.typeface), l = c[t.$globalData].fontFinder.find(i);
              p = e(c, l);
            }
            if (!p)
              return {
                lineHeight: 12,
                lineGap: 2,
                lineNoGap: 10
              };
            const m = c.size || 10, g = p.lineHeight ? Math.max(d ? 0 : 1.2, p.lineHeight) : 1.2, n = p.lineGap === void 0 ? 0.2 : p.lineGap;
            return {
              lineHeight: g * m,
              lineGap: n * m,
              lineNoGap: Math.max(1, g - n) * m
            };
          }
        },
        /* 86 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.TextMeasure = void 0;
          var t = C(85);
          const a = 1.02;
          class v {
            constructor(c, d, p, m) {
              if (this.lineHeight = p, this.paraMargin = d || {
                top: 0,
                bottom: 0,
                left: 0,
                right: 0
              }, !c) {
                [this.pdfFont, this.xfaFont] = this.defaultFont(m);
                return;
              }
              this.xfaFont = {
                typeface: c.typeface,
                posture: c.posture,
                weight: c.weight,
                size: c.size,
                letterSpacing: c.letterSpacing
              };
              const g = m.find(c.typeface);
              if (!g) {
                [this.pdfFont, this.xfaFont] = this.defaultFont(m);
                return;
              }
              this.pdfFont = (0, t.selectFont)(c, g), this.pdfFont || ([this.pdfFont, this.xfaFont] = this.defaultFont(m));
            }
            defaultFont(c) {
              const d = c.find("Helvetica", !1) || c.find("Myriad Pro", !1) || c.find("Arial", !1) || c.getDefault();
              if (d && d.regular) {
                const m = d.regular, n = {
                  typeface: m.cssFontInfo.fontFamily,
                  posture: "normal",
                  weight: "normal",
                  size: 10,
                  letterSpacing: 0
                };
                return [m, n];
              }
              return [null, {
                typeface: "Courier",
                posture: "normal",
                weight: "normal",
                size: 10,
                letterSpacing: 0
              }];
            }
          }
          class h {
            constructor(c, d, p, m) {
              this.fontFinder = m, this.stack = [new v(c, d, p, m)];
            }
            pushData(c, d, p) {
              const m = this.stack.at(-1);
              for (const n of ["typeface", "posture", "weight", "size", "letterSpacing"])
                c[n] || (c[n] = m.xfaFont[n]);
              for (const n of ["top", "bottom", "left", "right"])
                isNaN(d[n]) && (d[n] = m.paraMargin[n]);
              const g = new v(c, d, p || m.lineHeight, this.fontFinder);
              g.pdfFont || (g.pdfFont = m.pdfFont), this.stack.push(g);
            }
            popFont() {
              this.stack.pop();
            }
            topFont() {
              return this.stack.at(-1);
            }
          }
          class e {
            constructor(c, d, p, m) {
              this.glyphs = [], this.fontSelector = new h(c, d, p, m), this.extraHeight = 0;
            }
            pushData(c, d, p) {
              this.fontSelector.pushData(c, d, p);
            }
            popFont(c) {
              return this.fontSelector.popFont();
            }
            addPara() {
              const c = this.fontSelector.topFont();
              this.extraHeight += c.paraMargin.top + c.paraMargin.bottom;
            }
            addString(c) {
              if (!c)
                return;
              const d = this.fontSelector.topFont(), p = d.xfaFont.size;
              if (d.pdfFont) {
                const m = d.xfaFont.letterSpacing, g = d.pdfFont, n = g.lineHeight || 1.2, i = d.lineHeight || Math.max(1.2, n) * p, l = g.lineGap === void 0 ? 0.2 : g.lineGap, u = n - l, w = Math.max(1, u) * p, _ = p / 1e3, b = g.defaultWidth || g.charsToGlyphs(" ")[0].width;
                for (const A of c.split(/[\u2029\n]/)) {
                  const Y = g.encodeString(A).join(""), j = g.charsToGlyphs(Y);
                  for (const X of j) {
                    const B = X.width || b;
                    this.glyphs.push([B * _ + m, i, w, X.unicode, !1]);
                  }
                  this.glyphs.push([0, 0, 0, `
`, !0]);
                }
                this.glyphs.pop();
                return;
              }
              for (const m of c.split(/[\u2029\n]/)) {
                for (const g of m.split(""))
                  this.glyphs.push([p, 1.2 * p, p, g, !1]);
                this.glyphs.push([0, 0, 0, `
`, !0]);
              }
              this.glyphs.pop();
            }
            compute(c) {
              let d = -1, p = 0, m = 0, g = 0, n = 0, i = 0, l = !1, u = !0;
              for (let w = 0, _ = this.glyphs.length; w < _; w++) {
                const [b, A, Y, j, X] = this.glyphs[w], B = j === " ", R = u ? Y : A;
                if (X) {
                  m = Math.max(m, n), n = 0, g += i, i = R, d = -1, p = 0, u = !1;
                  continue;
                }
                if (B) {
                  n + b > c ? (m = Math.max(m, n), n = 0, g += i, i = R, d = -1, p = 0, l = !0, u = !1) : (i = Math.max(R, i), p = n, n += b, d = w);
                  continue;
                }
                if (n + b > c) {
                  g += i, i = R, d !== -1 ? (w = d, m = Math.max(m, p), n = 0, d = -1, p = 0) : (m = Math.max(m, n), n = b), l = !0, u = !1;
                  continue;
                }
                n += b, i = Math.max(R, i);
              }
              return m = Math.max(m, n), g += i + this.extraHeight, {
                width: a * m,
                height: g,
                isBroken: l
              };
            }
          }
          o.TextMeasure = e;
        },
        /* 87 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.DataHandler = void 0;
          var t = C(77);
          class a {
            constructor(h, e) {
              this.data = e, this.dataset = h.datasets || null;
            }
            serialize(h) {
              const e = [[-1, this.data[t.$getChildren]()]];
              for (; e.length > 0; ) {
                const c = e.at(-1), [d, p] = c;
                if (d + 1 === p.length) {
                  e.pop();
                  continue;
                }
                const m = p[++c[0]], g = h.get(m[t.$uid]);
                if (g)
                  m[t.$setValue](g);
                else {
                  const i = m[t.$getAttributes]();
                  for (const l of i.values()) {
                    const u = h.get(l[t.$uid]);
                    if (u) {
                      l[t.$setValue](u);
                      break;
                    }
                  }
                }
                const n = m[t.$getChildren]();
                n.length > 0 && e.push([-1, n]);
              }
              const y = ['<xfa:datasets xmlns:xfa="http://www.xfa.org/schema/xfa-data/1.0/">'];
              if (this.dataset)
                for (const c of this.dataset[t.$getChildren]())
                  c[t.$nodeName] !== "data" && c[t.$toString](y);
              return this.data[t.$toString](y), y.push("</xfa:datasets>"), y.join("");
            }
          }
          o.DataHandler = a;
        },
        /* 88 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.XFAParser = void 0;
          var t = C(77), a = C(66), v = C(89), h = C(2);
          class e extends a.XMLParserBase {
            constructor(c = null, d = !1) {
              super(), this._builder = new v.Builder(c), this._stack = [], this._globalData = {
                usedTypefaces: /* @__PURE__ */ new Set()
              }, this._ids = /* @__PURE__ */ new Map(), this._current = this._builder.buildRoot(this._ids), this._errorCode = a.XMLParserErrorCode.NoError, this._whiteRegex = /^\s+$/, this._nbsps = /\xa0+/g, this._richText = d;
            }
            parse(c) {
              if (this.parseXml(c), this._errorCode === a.XMLParserErrorCode.NoError)
                return this._current[t.$finalize](), this._current.element;
            }
            onText(c) {
              if (c = c.replace(this._nbsps, (d) => d.slice(1) + " "), this._richText || this._current[t.$acceptWhitespace]()) {
                this._current[t.$onText](c, this._richText);
                return;
              }
              this._whiteRegex.test(c) || this._current[t.$onText](c.trim());
            }
            onCdata(c) {
              this._current[t.$onText](c);
            }
            _mkAttributes(c, d) {
              let p = null, m = null;
              const g = /* @__PURE__ */ Object.create({});
              for (const {
                name: n,
                value: i
              } of c)
                if (n === "xmlns")
                  p ? (0, h.warn)(`XFA - multiple namespace definition in <${d}>`) : p = i;
                else if (n.startsWith("xmlns:")) {
                  const l = n.substring(6);
                  m || (m = []), m.push({
                    prefix: l,
                    value: i
                  });
                } else {
                  const l = n.indexOf(":");
                  if (l === -1)
                    g[n] = i;
                  else {
                    let u = g[t.$nsAttributes];
                    u || (u = g[t.$nsAttributes] = /* @__PURE__ */ Object.create(null));
                    const [w, _] = [n.slice(0, l), n.slice(l + 1)];
                    let b = u[w];
                    b || (b = u[w] = /* @__PURE__ */ Object.create(null)), b[_] = i;
                  }
                }
              return [p, m, g];
            }
            _getNameAndPrefix(c, d) {
              const p = c.indexOf(":");
              return p === -1 ? [c, null] : [c.substring(p + 1), d ? "" : c.substring(0, p)];
            }
            onBeginElement(c, d, p) {
              const [m, g, n] = this._mkAttributes(d, c), [i, l] = this._getNameAndPrefix(c, this._builder.isNsAgnostic()), u = this._builder.build({
                nsPrefix: l,
                name: i,
                attributes: n,
                namespace: m,
                prefixes: g
              });
              if (u[t.$globalData] = this._globalData, p) {
                u[t.$finalize](), this._current[t.$onChild](u) && u[t.$setId](this._ids), u[t.$clean](this._builder);
                return;
              }
              this._stack.push(this._current), this._current = u;
            }
            onEndElement(c) {
              const d = this._current;
              if (d[t.$isCDATAXml]() && typeof d[t.$content] == "string") {
                const p = new e();
                p._globalData = this._globalData;
                const m = p.parse(d[t.$content]);
                d[t.$content] = null, d[t.$onChild](m);
              }
              d[t.$finalize](), this._current = this._stack.pop(), this._current[t.$onChild](d) && d[t.$setId](this._ids), d[t.$clean](this._builder);
            }
            onError(c) {
              this._errorCode = c;
            }
          }
          o.XFAParser = e;
        },
        /* 89 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.Builder = void 0;
          var t = C(79), a = C(77), v = C(90), h = C(82), e = C(99), y = C(2);
          class c extends a.XFAObject {
            constructor(g) {
              super(-1, "root", /* @__PURE__ */ Object.create(null)), this.element = null, this[a.$ids] = g;
            }
            [a.$onChild](g) {
              return this.element = g, !0;
            }
            [a.$finalize]() {
              super[a.$finalize](), this.element.template instanceof h.Template && (this[a.$ids].set(a.$root, this.element), this.element.template[a.$resolvePrototypes](this[a.$ids]), this.element.template[a.$ids] = this[a.$ids]);
            }
          }
          class d extends a.XFAObject {
            constructor() {
              super(-1, "", /* @__PURE__ */ Object.create(null));
            }
            [a.$onChild](g) {
              return !1;
            }
          }
          class p {
            constructor(g = null) {
              this._namespaceStack = [], this._nsAgnosticLevel = 0, this._namespacePrefixes = /* @__PURE__ */ new Map(), this._namespaces = /* @__PURE__ */ new Map(), this._nextNsId = Math.max(...Object.values(t.NamespaceIds).map(({
                id: n
              }) => n)), this._currentNamespace = g || new e.UnknownNamespace(++this._nextNsId);
            }
            buildRoot(g) {
              return new c(g);
            }
            build({
              nsPrefix: g,
              name: n,
              attributes: i,
              namespace: l,
              prefixes: u
            }) {
              const w = l !== null;
              if (w && (this._namespaceStack.push(this._currentNamespace), this._currentNamespace = this._searchNamespace(l)), u && this._addNamespacePrefix(u), i.hasOwnProperty(a.$nsAttributes)) {
                const A = v.NamespaceSetUp.datasets, Y = i[a.$nsAttributes];
                let j = null;
                for (const [X, B] of Object.entries(Y))
                  if (this._getNamespaceToUse(X) === A) {
                    j = {
                      xfa: B
                    };
                    break;
                  }
                j ? i[a.$nsAttributes] = j : delete i[a.$nsAttributes];
              }
              const _ = this._getNamespaceToUse(g), b = _ && _[t.$buildXFAObject](n, i) || new d();
              return b[a.$isNsAgnostic]() && this._nsAgnosticLevel++, (w || u || b[a.$isNsAgnostic]()) && (b[a.$cleanup] = {
                hasNamespace: w,
                prefixes: u,
                nsAgnostic: b[a.$isNsAgnostic]()
              }), b;
            }
            isNsAgnostic() {
              return this._nsAgnosticLevel > 0;
            }
            _searchNamespace(g) {
              let n = this._namespaces.get(g);
              if (n)
                return n;
              for (const [i, {
                check: l
              }] of Object.entries(t.NamespaceIds))
                if (l(g)) {
                  if (n = v.NamespaceSetUp[i], n)
                    return this._namespaces.set(g, n), n;
                  break;
                }
              return n = new e.UnknownNamespace(++this._nextNsId), this._namespaces.set(g, n), n;
            }
            _addNamespacePrefix(g) {
              for (const {
                prefix: n,
                value: i
              } of g) {
                const l = this._searchNamespace(i);
                let u = this._namespacePrefixes.get(n);
                u || (u = [], this._namespacePrefixes.set(n, u)), u.push(l);
              }
            }
            _getNamespaceToUse(g) {
              if (!g)
                return this._currentNamespace;
              const n = this._namespacePrefixes.get(g);
              return n && n.length > 0 ? n.at(-1) : ((0, y.warn)(`Unknown namespace prefix: ${g}.`), null);
            }
            clean(g) {
              const {
                hasNamespace: n,
                prefixes: i,
                nsAgnostic: l
              } = g;
              n && (this._currentNamespace = this._namespaceStack.pop()), i && i.forEach(({
                prefix: u
              }) => {
                this._namespacePrefixes.get(u).pop();
              }), l && this._nsAgnosticLevel--;
            }
          }
          o.Builder = p;
        },
        /* 90 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.NamespaceSetUp = void 0;
          var t = C(91), a = C(92), v = C(93), h = C(94), e = C(95), y = C(96), c = C(82), d = C(97), p = C(98);
          const m = {
            config: t.ConfigNamespace,
            connection: a.ConnectionSetNamespace,
            datasets: v.DatasetsNamespace,
            localeSet: h.LocaleSetNamespace,
            signature: e.SignatureNamespace,
            stylesheet: y.StylesheetNamespace,
            template: c.TemplateNamespace,
            xdp: d.XdpNamespace,
            xhtml: p.XhtmlNamespace
          };
          o.NamespaceSetUp = m;
        },
        /* 91 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.ConfigNamespace = void 0;
          var t = C(79), a = C(77), v = C(78), h = C(2);
          const e = t.NamespaceIds.config.id;
          class y extends a.XFAObject {
            constructor(he) {
              super(e, "acrobat", !0), this.acrobat7 = null, this.autoSave = null, this.common = null, this.validate = null, this.validateApprovalSignatures = null, this.submitUrl = new a.XFAObjectArray();
            }
          }
          class c extends a.XFAObject {
            constructor(he) {
              super(e, "acrobat7", !0), this.dynamicRender = null;
            }
          }
          class d extends a.OptionObject {
            constructor(he) {
              super(e, "ADBE_JSConsole", ["delegate", "Enable", "Disable"]);
            }
          }
          class p extends a.OptionObject {
            constructor(he) {
              super(e, "ADBE_JSDebugger", ["delegate", "Enable", "Disable"]);
            }
          }
          class m extends a.Option01 {
            constructor(he) {
              super(e, "addSilentPrint");
            }
          }
          class g extends a.Option01 {
            constructor(he) {
              super(e, "addViewerPreferences");
            }
          }
          class n extends a.Option10 {
            constructor(he) {
              super(e, "adjustData");
            }
          }
          class i extends a.IntegerObject {
            constructor(he) {
              super(e, "adobeExtensionLevel", 0, (Ne) => Ne >= 1 && Ne <= 8);
            }
          }
          class l extends a.XFAObject {
            constructor(he) {
              super(e, "agent", !0), this.name = he.name ? he.name.trim() : "", this.common = new a.XFAObjectArray();
            }
          }
          class u extends a.ContentObject {
            constructor(he) {
              super(e, "alwaysEmbed");
            }
          }
          class w extends a.StringObject {
            constructor(he) {
              super(e, "amd");
            }
          }
          class _ extends a.XFAObject {
            constructor(he) {
              super(e, "area"), this.level = (0, v.getInteger)({
                data: he.level,
                defaultValue: 0,
                validate: (Ne) => Ne >= 1 && Ne <= 3
              }), this.name = (0, v.getStringOption)(he.name, ["", "barcode", "coreinit", "deviceDriver", "font", "general", "layout", "merge", "script", "signature", "sourceSet", "templateCache"]);
            }
          }
          class b extends a.OptionObject {
            constructor(he) {
              super(e, "attributes", ["preserve", "delegate", "ignore"]);
            }
          }
          class A extends a.OptionObject {
            constructor(he) {
              super(e, "autoSave", ["disabled", "enabled"]);
            }
          }
          class Y extends a.StringObject {
            constructor(he) {
              super(e, "base");
            }
          }
          class j extends a.XFAObject {
            constructor(he) {
              super(e, "batchOutput"), this.format = (0, v.getStringOption)(he.format, ["none", "concat", "zip", "zipCompress"]);
            }
          }
          class X extends a.ContentObject {
            constructor(he) {
              super(e, "behaviorOverride");
            }
            [a.$finalize]() {
              this[a.$content] = new Map(this[a.$content].trim().split(/\s+/).filter((he) => he.includes(":")).map((he) => he.split(":", 2)));
            }
          }
          class B extends a.XFAObject {
            constructor(he) {
              super(e, "cache", !0), this.templateCache = null;
            }
          }
          class R extends a.Option01 {
            constructor(he) {
              super(e, "change");
            }
          }
          class k extends a.XFAObject {
            constructor(he) {
              super(e, "common", !0), this.data = null, this.locale = null, this.localeSet = null, this.messaging = null, this.suppressBanner = null, this.template = null, this.validationMessaging = null, this.versionControl = null, this.log = new a.XFAObjectArray();
            }
          }
          class x extends a.XFAObject {
            constructor(he) {
              super(e, "compress"), this.scope = (0, v.getStringOption)(he.scope, ["imageOnly", "document"]);
            }
          }
          class f extends a.Option01 {
            constructor(he) {
              super(e, "compressLogicalStructure");
            }
          }
          class U extends a.Option10 {
            constructor(he) {
              super(e, "compressObjectStream");
            }
          }
          class O extends a.XFAObject {
            constructor(he) {
              super(e, "compression", !0), this.compressLogicalStructure = null, this.compressObjectStream = null, this.level = null, this.type = null;
            }
          }
          class S extends a.XFAObject {
            constructor(he) {
              super(e, "config", !0), this.acrobat = null, this.present = null, this.trace = null, this.agent = new a.XFAObjectArray();
            }
          }
          class F extends a.OptionObject {
            constructor(he) {
              super(e, "conformance", ["A", "B"]);
            }
          }
          class T extends a.Option01 {
            constructor(he) {
              super(e, "contentCopy");
            }
          }
          class I extends a.IntegerObject {
            constructor(he) {
              super(e, "copies", 1, (Ne) => Ne >= 1);
            }
          }
          class M extends a.StringObject {
            constructor(he) {
              super(e, "creator");
            }
          }
          class V extends a.IntegerObject {
            constructor(he) {
              super(e, "currentPage", 0, (Ne) => Ne >= 0);
            }
          }
          class J extends a.XFAObject {
            constructor(he) {
              super(e, "data", !0), this.adjustData = null, this.attributes = null, this.incrementalLoad = null, this.outputXSL = null, this.range = null, this.record = null, this.startNode = null, this.uri = null, this.window = null, this.xsl = null, this.excludeNS = new a.XFAObjectArray(), this.transform = new a.XFAObjectArray();
            }
          }
          class W extends a.XFAObject {
            constructor(he) {
              super(e, "debug", !0), this.uri = null;
            }
          }
          class z extends a.ContentObject {
            constructor(he) {
              super(e, "defaultTypeface"), this.writingScript = (0, v.getStringOption)(he.writingScript, ["*", "Arabic", "Cyrillic", "EastEuropeanRoman", "Greek", "Hebrew", "Japanese", "Korean", "Roman", "SimplifiedChinese", "Thai", "TraditionalChinese", "Vietnamese"]);
            }
          }
          class G extends a.OptionObject {
            constructor(he) {
              super(e, "destination", ["pdf", "pcl", "ps", "webClient", "zpl"]);
            }
          }
          class L extends a.Option01 {
            constructor(he) {
              super(e, "documentAssembly");
            }
          }
          class K extends a.XFAObject {
            constructor(he) {
              super(e, "driver", !0), this.name = he.name ? he.name.trim() : "", this.fontInfo = null, this.xdc = null;
            }
          }
          class te extends a.OptionObject {
            constructor(he) {
              super(e, "duplexOption", ["simplex", "duplexFlipLongEdge", "duplexFlipShortEdge"]);
            }
          }
          class se extends a.OptionObject {
            constructor(he) {
              super(e, "dynamicRender", ["forbidden", "required"]);
            }
          }
          class q extends a.Option01 {
            constructor(he) {
              super(e, "embed");
            }
          }
          class N extends a.Option01 {
            constructor(he) {
              super(e, "encrypt");
            }
          }
          class Q extends a.XFAObject {
            constructor(he) {
              super(e, "encryption", !0), this.encrypt = null, this.encryptionLevel = null, this.permissions = null;
            }
          }
          class D extends a.OptionObject {
            constructor(he) {
              super(e, "encryptionLevel", ["40bit", "128bit"]);
            }
          }
          class ne extends a.StringObject {
            constructor(he) {
              super(e, "enforce");
            }
          }
          class oe extends a.XFAObject {
            constructor(he) {
              super(e, "equate"), this.force = (0, v.getInteger)({
                data: he.force,
                defaultValue: 1,
                validate: (Ne) => Ne === 0
              }), this.from = he.from || "", this.to = he.to || "";
            }
          }
          class ee extends a.XFAObject {
            constructor(he) {
              super(e, "equateRange"), this.from = he.from || "", this.to = he.to || "", this._unicodeRange = he.unicodeRange || "";
            }
            get unicodeRange() {
              const he = [], Ne = /U\+([0-9a-fA-F]+)/, Ve = this._unicodeRange;
              for (let st of Ve.split(",").map((Tt) => Tt.trim()).filter((Tt) => !!Tt))
                st = st.split("-", 2).map((Tt) => {
                  const Ct = Tt.match(Ne);
                  return Ct ? parseInt(Ct[1], 16) : 0;
                }), st.length === 1 && st.push(st[0]), he.push(st);
              return (0, h.shadow)(this, "unicodeRange", he);
            }
          }
          class $ extends a.ContentObject {
            constructor(he) {
              super(e, "exclude");
            }
            [a.$finalize]() {
              this[a.$content] = this[a.$content].trim().split(/\s+/).filter((he) => he && ["calculate", "close", "enter", "exit", "initialize", "ready", "validate"].includes(he));
            }
          }
          class E extends a.StringObject {
            constructor(he) {
              super(e, "excludeNS");
            }
          }
          class H extends a.OptionObject {
            constructor(he) {
              super(e, "flipLabel", ["usePrinterSetting", "on", "off"]);
            }
          }
          class ie extends a.XFAObject {
            constructor(he) {
              super(e, "fontInfo", !0), this.embed = null, this.map = null, this.subsetBelow = null, this.alwaysEmbed = new a.XFAObjectArray(), this.defaultTypeface = new a.XFAObjectArray(), this.neverEmbed = new a.XFAObjectArray();
            }
          }
          class ue extends a.Option01 {
            constructor(he) {
              super(e, "formFieldFilling");
            }
          }
          class fe extends a.StringObject {
            constructor(he) {
              super(e, "groupParent");
            }
          }
          class de extends a.OptionObject {
            constructor(he) {
              super(e, "ifEmpty", ["dataValue", "dataGroup", "ignore", "remove"]);
            }
          }
          class pe extends a.StringObject {
            constructor(he) {
              super(e, "includeXDPContent");
            }
          }
          class xe extends a.OptionObject {
            constructor(he) {
              super(e, "incrementalLoad", ["none", "forwardOnly"]);
            }
          }
          class De extends a.Option01 {
            constructor(he) {
              super(e, "incrementalMerge");
            }
          }
          class Ae extends a.Option01 {
            constructor(he) {
              super(e, "interactive");
            }
          }
          class Se extends a.OptionObject {
            constructor(he) {
              super(e, "jog", ["usePrinterSetting", "none", "pageSet"]);
            }
          }
          class ke extends a.XFAObject {
            constructor(he) {
              super(e, "labelPrinter", !0), this.name = (0, v.getStringOption)(he.name, ["zpl", "dpl", "ipl", "tcpl"]), this.batchOutput = null, this.flipLabel = null, this.fontInfo = null, this.xdc = null;
            }
          }
          class ye extends a.OptionObject {
            constructor(he) {
              super(e, "layout", ["paginate", "panel"]);
            }
          }
          class _e extends a.IntegerObject {
            constructor(he) {
              super(e, "level", 0, (Ne) => Ne > 0);
            }
          }
          class we extends a.Option01 {
            constructor(he) {
              super(e, "linearized");
            }
          }
          class Ce extends a.StringObject {
            constructor(he) {
              super(e, "locale");
            }
          }
          class ve extends a.StringObject {
            constructor(he) {
              super(e, "localeSet");
            }
          }
          class Le extends a.XFAObject {
            constructor(he) {
              super(e, "log", !0), this.mode = null, this.threshold = null, this.to = null, this.uri = null;
            }
          }
          class He extends a.XFAObject {
            constructor(he) {
              super(e, "map", !0), this.equate = new a.XFAObjectArray(), this.equateRange = new a.XFAObjectArray();
            }
          }
          class Qe extends a.XFAObject {
            constructor(he) {
              super(e, "mediumInfo", !0), this.map = null;
            }
          }
          class Ue extends a.XFAObject {
            constructor(he) {
              super(e, "message", !0), this.msgId = null, this.severity = null;
            }
          }
          class Ie extends a.XFAObject {
            constructor(he) {
              super(e, "messaging", !0), this.message = new a.XFAObjectArray();
            }
          }
          class Ee extends a.OptionObject {
            constructor(he) {
              super(e, "mode", ["append", "overwrite"]);
            }
          }
          class et extends a.Option01 {
            constructor(he) {
              super(e, "modifyAnnots");
            }
          }
          class qe extends a.IntegerObject {
            constructor(he) {
              super(e, "msgId", 1, (Ne) => Ne >= 1);
            }
          }
          class tt extends a.StringObject {
            constructor(he) {
              super(e, "nameAttr");
            }
          }
          class ft extends a.ContentObject {
            constructor(he) {
              super(e, "neverEmbed");
            }
          }
          class Te extends a.IntegerObject {
            constructor(he) {
              super(e, "numberOfCopies", null, (Ne) => Ne >= 2 && Ne <= 5);
            }
          }
          class je extends a.XFAObject {
            constructor(he) {
              super(e, "openAction", !0), this.destination = null;
            }
          }
          class Ze extends a.XFAObject {
            constructor(he) {
              super(e, "output", !0), this.to = null, this.type = null, this.uri = null;
            }
          }
          class Me extends a.StringObject {
            constructor(he) {
              super(e, "outputBin");
            }
          }
          class at extends a.XFAObject {
            constructor(he) {
              super(e, "outputXSL", !0), this.uri = null;
            }
          }
          class rt extends a.OptionObject {
            constructor(he) {
              super(e, "overprint", ["none", "both", "draw", "field"]);
            }
          }
          class xt extends a.StringObject {
            constructor(he) {
              super(e, "packets");
            }
            [a.$finalize]() {
              this[a.$content] !== "*" && (this[a.$content] = this[a.$content].trim().split(/\s+/).filter((he) => ["config", "datasets", "template", "xfdf", "xslt"].includes(he)));
            }
          }
          class ut extends a.XFAObject {
            constructor(he) {
              super(e, "pageOffset"), this.x = (0, v.getInteger)({
                data: he.x,
                defaultValue: "useXDCSetting",
                validate: (Ne) => !0
              }), this.y = (0, v.getInteger)({
                data: he.y,
                defaultValue: "useXDCSetting",
                validate: (Ne) => !0
              });
            }
          }
          class yt extends a.StringObject {
            constructor(he) {
              super(e, "pageRange");
            }
            [a.$finalize]() {
              const he = this[a.$content].trim().split(/\s+/).map((Ve) => parseInt(Ve, 10)), Ne = [];
              for (let Ve = 0, st = he.length; Ve < st; Ve += 2)
                Ne.push(he.slice(Ve, Ve + 2));
              this[a.$content] = Ne;
            }
          }
          class ht extends a.OptionObject {
            constructor(he) {
              super(e, "pagination", ["simplex", "duplexShortEdge", "duplexLongEdge"]);
            }
          }
          class Rt extends a.OptionObject {
            constructor(he) {
              super(e, "paginationOverride", ["none", "forceDuplex", "forceDuplexLongEdge", "forceDuplexShortEdge", "forceSimplex"]);
            }
          }
          class Wt extends a.IntegerObject {
            constructor(he) {
              super(e, "part", 1, (Ne) => !1);
            }
          }
          class Ke extends a.XFAObject {
            constructor(he) {
              super(e, "pcl", !0), this.name = he.name || "", this.batchOutput = null, this.fontInfo = null, this.jog = null, this.mediumInfo = null, this.outputBin = null, this.pageOffset = null, this.staple = null, this.xdc = null;
            }
          }
          class Ge extends a.XFAObject {
            constructor(he) {
              super(e, "pdf", !0), this.name = he.name || "", this.adobeExtensionLevel = null, this.batchOutput = null, this.compression = null, this.creator = null, this.encryption = null, this.fontInfo = null, this.interactive = null, this.linearized = null, this.openAction = null, this.pdfa = null, this.producer = null, this.renderPolicy = null, this.scriptModel = null, this.silentPrint = null, this.submitFormat = null, this.tagged = null, this.version = null, this.viewerPreferences = null, this.xdc = null;
            }
          }
          class nt extends a.XFAObject {
            constructor(he) {
              super(e, "pdfa", !0), this.amd = null, this.conformance = null, this.includeXDPContent = null, this.part = null;
            }
          }
          class it extends a.XFAObject {
            constructor(he) {
              super(e, "permissions", !0), this.accessibleContent = null, this.change = null, this.contentCopy = null, this.documentAssembly = null, this.formFieldFilling = null, this.modifyAnnots = null, this.plaintextMetadata = null, this.print = null, this.printHighQuality = null;
            }
          }
          class pt extends a.Option01 {
            constructor(he) {
              super(e, "pickTrayByPDFSize");
            }
          }
          class Ft extends a.StringObject {
            constructor(he) {
              super(e, "picture");
            }
          }
          class mt extends a.Option01 {
            constructor(he) {
              super(e, "plaintextMetadata");
            }
          }
          class ct extends a.OptionObject {
            constructor(he) {
              super(e, "presence", ["preserve", "dissolve", "dissolveStructure", "ignore", "remove"]);
            }
          }
          class bt extends a.XFAObject {
            constructor(he) {
              super(e, "present", !0), this.behaviorOverride = null, this.cache = null, this.common = null, this.copies = null, this.destination = null, this.incrementalMerge = null, this.layout = null, this.output = null, this.overprint = null, this.pagination = null, this.paginationOverride = null, this.script = null, this.validate = null, this.xdp = null, this.driver = new a.XFAObjectArray(), this.labelPrinter = new a.XFAObjectArray(), this.pcl = new a.XFAObjectArray(), this.pdf = new a.XFAObjectArray(), this.ps = new a.XFAObjectArray(), this.submitUrl = new a.XFAObjectArray(), this.webClient = new a.XFAObjectArray(), this.zpl = new a.XFAObjectArray();
            }
          }
          class wt extends a.Option01 {
            constructor(he) {
              super(e, "print");
            }
          }
          class Ot extends a.Option01 {
            constructor(he) {
              super(e, "printHighQuality");
            }
          }
          class Et extends a.OptionObject {
            constructor(he) {
              super(e, "printScaling", ["appdefault", "noScaling"]);
            }
          }
          class St extends a.StringObject {
            constructor(he) {
              super(e, "printerName");
            }
          }
          class Pe extends a.StringObject {
            constructor(he) {
              super(e, "producer");
            }
          }
          class We extends a.XFAObject {
            constructor(he) {
              super(e, "ps", !0), this.name = he.name || "", this.batchOutput = null, this.fontInfo = null, this.jog = null, this.mediumInfo = null, this.outputBin = null, this.staple = null, this.xdc = null;
            }
          }
          class Je extends a.ContentObject {
            constructor(he) {
              super(e, "range");
            }
            [a.$finalize]() {
              this[a.$content] = this[a.$content].trim().split(/\s*,\s*/, 2).map((he) => he.split("-").map((Ne) => parseInt(Ne.trim(), 10))).filter((he) => he.every((Ne) => !isNaN(Ne))).map((he) => (he.length === 1 && he.push(he[0]), he));
            }
          }
          class Ye extends a.ContentObject {
            constructor(he) {
              super(e, "record");
            }
            [a.$finalize]() {
              this[a.$content] = this[a.$content].trim();
              const he = parseInt(this[a.$content], 10);
              !isNaN(he) && he >= 0 && (this[a.$content] = he);
            }
          }
          class gt extends a.ContentObject {
            constructor(he) {
              super(e, "relevant");
            }
            [a.$finalize]() {
              this[a.$content] = this[a.$content].trim().split(/\s+/);
            }
          }
          class Dt extends a.ContentObject {
            constructor(he) {
              super(e, "rename");
            }
            [a.$finalize]() {
              this[a.$content] = this[a.$content].trim(), (this[a.$content].toLowerCase().startsWith("xml") || this[a.$content].match(new RegExp("[\\p{L}_][\\p{L}\\d._\\p{M}-]*", "u"))) && (0, h.warn)("XFA - Rename: invalid XFA name");
            }
          }
          class Xt extends a.OptionObject {
            constructor(he) {
              super(e, "renderPolicy", ["server", "client"]);
            }
          }
          class kt extends a.OptionObject {
            constructor(he) {
              super(e, "runScripts", ["both", "client", "none", "server"]);
            }
          }
          class Pt extends a.XFAObject {
            constructor(he) {
              super(e, "script", !0), this.currentPage = null, this.exclude = null, this.runScripts = null;
            }
          }
          class zt extends a.OptionObject {
            constructor(he) {
              super(e, "scriptModel", ["XFA", "none"]);
            }
          }
          class Yt extends a.OptionObject {
            constructor(he) {
              super(e, "severity", ["ignore", "error", "information", "trace", "warning"]);
            }
          }
          class an extends a.XFAObject {
            constructor(he) {
              super(e, "silentPrint", !0), this.addSilentPrint = null, this.printerName = null;
            }
          }
          class Dn extends a.XFAObject {
            constructor(he) {
              super(e, "staple"), this.mode = (0, v.getStringOption)(he.mode, ["usePrinterSetting", "on", "off"]);
            }
          }
          class gn extends a.StringObject {
            constructor(he) {
              super(e, "startNode");
            }
          }
          class _n extends a.IntegerObject {
            constructor(he) {
              super(e, "startPage", 0, (Ne) => !0);
            }
          }
          class En extends a.OptionObject {
            constructor(he) {
              super(e, "submitFormat", ["html", "delegate", "fdf", "xml", "pdf"]);
            }
          }
          class An extends a.StringObject {
            constructor(he) {
              super(e, "submitUrl");
            }
          }
          class kn extends a.IntegerObject {
            constructor(he) {
              super(e, "subsetBelow", 100, (Ne) => Ne >= 0 && Ne <= 100);
            }
          }
          class On extends a.Option01 {
            constructor(he) {
              super(e, "suppressBanner");
            }
          }
          class In extends a.Option01 {
            constructor(he) {
              super(e, "tagged");
            }
          }
          class Pn extends a.XFAObject {
            constructor(he) {
              super(e, "template", !0), this.base = null, this.relevant = null, this.startPage = null, this.uri = null, this.xsl = null;
            }
          }
          class Rn extends a.OptionObject {
            constructor(he) {
              super(e, "threshold", ["trace", "error", "information", "warning"]);
            }
          }
          class Un extends a.OptionObject {
            constructor(he) {
              super(e, "to", ["null", "memory", "stderr", "stdout", "system", "uri"]);
            }
          }
          class xn extends a.XFAObject {
            constructor(he) {
              super(e, "templateCache"), this.maxEntries = (0, v.getInteger)({
                data: he.maxEntries,
                defaultValue: 5,
                validate: (Ne) => Ne >= 0
              });
            }
          }
          class on extends a.XFAObject {
            constructor(he) {
              super(e, "trace", !0), this.area = new a.XFAObjectArray();
            }
          }
          class Sn extends a.XFAObject {
            constructor(he) {
              super(e, "transform", !0), this.groupParent = null, this.ifEmpty = null, this.nameAttr = null, this.picture = null, this.presence = null, this.rename = null, this.whitespace = null;
            }
          }
          class Qt extends a.OptionObject {
            constructor(he) {
              super(e, "type", ["none", "ascii85", "asciiHex", "ccittfax", "flate", "lzw", "runLength", "native", "xdp", "mergedXDP"]);
            }
          }
          class cn extends a.StringObject {
            constructor(he) {
              super(e, "uri");
            }
          }
          class bn extends a.OptionObject {
            constructor(he) {
              super(e, "validate", ["preSubmit", "prePrint", "preExecute", "preSave"]);
            }
          }
          class Cn extends a.ContentObject {
            constructor(he) {
              super(e, "validateApprovalSignatures");
            }
            [a.$finalize]() {
              this[a.$content] = this[a.$content].trim().split(/\s+/).filter((he) => ["docReady", "postSign"].includes(he));
            }
          }
          class yn extends a.OptionObject {
            constructor(he) {
              super(e, "validationMessaging", ["allMessagesIndividually", "allMessagesTogether", "firstMessageOnly", "noMessages"]);
            }
          }
          class Mn extends a.OptionObject {
            constructor(he) {
              super(e, "version", ["1.7", "1.6", "1.5", "1.4", "1.3", "1.2"]);
            }
          }
          class Bn extends a.XFAObject {
            constructor(he) {
              super(e, "VersionControl"), this.outputBelow = (0, v.getStringOption)(he.outputBelow, ["warn", "error", "update"]), this.sourceAbove = (0, v.getStringOption)(he.sourceAbove, ["warn", "error"]), this.sourceBelow = (0, v.getStringOption)(he.sourceBelow, ["update", "maintain"]);
            }
          }
          class Ln extends a.XFAObject {
            constructor(he) {
              super(e, "viewerPreferences", !0), this.ADBE_JSConsole = null, this.ADBE_JSDebugger = null, this.addViewerPreferences = null, this.duplexOption = null, this.enforce = null, this.numberOfCopies = null, this.pageRange = null, this.pickTrayByPDFSize = null, this.printScaling = null;
            }
          }
          class Nn extends a.XFAObject {
            constructor(he) {
              super(e, "webClient", !0), this.name = he.name ? he.name.trim() : "", this.fontInfo = null, this.xdc = null;
            }
          }
          class vn extends a.OptionObject {
            constructor(he) {
              super(e, "whitespace", ["preserve", "ltrim", "normalize", "rtrim", "trim"]);
            }
          }
          class wn extends a.ContentObject {
            constructor(he) {
              super(e, "window");
            }
            [a.$finalize]() {
              const he = this[a.$content].trim().split(/\s*,\s*/, 2).map((Ne) => parseInt(Ne, 10));
              if (he.some((Ne) => isNaN(Ne))) {
                this[a.$content] = [0, 0];
                return;
              }
              he.length === 1 && he.push(he[0]), this[a.$content] = he;
            }
          }
          class jn extends a.XFAObject {
            constructor(he) {
              super(e, "xdc", !0), this.uri = new a.XFAObjectArray(), this.xsl = new a.XFAObjectArray();
            }
          }
          class hn extends a.XFAObject {
            constructor(he) {
              super(e, "xdp", !0), this.packets = null;
            }
          }
          class Wn extends a.XFAObject {
            constructor(he) {
              super(e, "xsl", !0), this.debug = null, this.uri = null;
            }
          }
          class dn extends a.XFAObject {
            constructor(he) {
              super(e, "zpl", !0), this.name = he.name ? he.name.trim() : "", this.batchOutput = null, this.flipLabel = null, this.fontInfo = null, this.xdc = null;
            }
          }
          class Xe {
            static [t.$buildXFAObject](he, Ne) {
              if (Xe.hasOwnProperty(he))
                return Xe[he](Ne);
            }
            static acrobat(he) {
              return new y(he);
            }
            static acrobat7(he) {
              return new c(he);
            }
            static ADBE_JSConsole(he) {
              return new d(he);
            }
            static ADBE_JSDebugger(he) {
              return new p(he);
            }
            static addSilentPrint(he) {
              return new m(he);
            }
            static addViewerPreferences(he) {
              return new g(he);
            }
            static adjustData(he) {
              return new n(he);
            }
            static adobeExtensionLevel(he) {
              return new i(he);
            }
            static agent(he) {
              return new l(he);
            }
            static alwaysEmbed(he) {
              return new u(he);
            }
            static amd(he) {
              return new w(he);
            }
            static area(he) {
              return new _(he);
            }
            static attributes(he) {
              return new b(he);
            }
            static autoSave(he) {
              return new A(he);
            }
            static base(he) {
              return new Y(he);
            }
            static batchOutput(he) {
              return new j(he);
            }
            static behaviorOverride(he) {
              return new X(he);
            }
            static cache(he) {
              return new B(he);
            }
            static change(he) {
              return new R(he);
            }
            static common(he) {
              return new k(he);
            }
            static compress(he) {
              return new x(he);
            }
            static compressLogicalStructure(he) {
              return new f(he);
            }
            static compressObjectStream(he) {
              return new U(he);
            }
            static compression(he) {
              return new O(he);
            }
            static config(he) {
              return new S(he);
            }
            static conformance(he) {
              return new F(he);
            }
            static contentCopy(he) {
              return new T(he);
            }
            static copies(he) {
              return new I(he);
            }
            static creator(he) {
              return new M(he);
            }
            static currentPage(he) {
              return new V(he);
            }
            static data(he) {
              return new J(he);
            }
            static debug(he) {
              return new W(he);
            }
            static defaultTypeface(he) {
              return new z(he);
            }
            static destination(he) {
              return new G(he);
            }
            static documentAssembly(he) {
              return new L(he);
            }
            static driver(he) {
              return new K(he);
            }
            static duplexOption(he) {
              return new te(he);
            }
            static dynamicRender(he) {
              return new se(he);
            }
            static embed(he) {
              return new q(he);
            }
            static encrypt(he) {
              return new N(he);
            }
            static encryption(he) {
              return new Q(he);
            }
            static encryptionLevel(he) {
              return new D(he);
            }
            static enforce(he) {
              return new ne(he);
            }
            static equate(he) {
              return new oe(he);
            }
            static equateRange(he) {
              return new ee(he);
            }
            static exclude(he) {
              return new $(he);
            }
            static excludeNS(he) {
              return new E(he);
            }
            static flipLabel(he) {
              return new H(he);
            }
            static fontInfo(he) {
              return new ie(he);
            }
            static formFieldFilling(he) {
              return new ue(he);
            }
            static groupParent(he) {
              return new fe(he);
            }
            static ifEmpty(he) {
              return new de(he);
            }
            static includeXDPContent(he) {
              return new pe(he);
            }
            static incrementalLoad(he) {
              return new xe(he);
            }
            static incrementalMerge(he) {
              return new De(he);
            }
            static interactive(he) {
              return new Ae(he);
            }
            static jog(he) {
              return new Se(he);
            }
            static labelPrinter(he) {
              return new ke(he);
            }
            static layout(he) {
              return new ye(he);
            }
            static level(he) {
              return new _e(he);
            }
            static linearized(he) {
              return new we(he);
            }
            static locale(he) {
              return new Ce(he);
            }
            static localeSet(he) {
              return new ve(he);
            }
            static log(he) {
              return new Le(he);
            }
            static map(he) {
              return new He(he);
            }
            static mediumInfo(he) {
              return new Qe(he);
            }
            static message(he) {
              return new Ue(he);
            }
            static messaging(he) {
              return new Ie(he);
            }
            static mode(he) {
              return new Ee(he);
            }
            static modifyAnnots(he) {
              return new et(he);
            }
            static msgId(he) {
              return new qe(he);
            }
            static nameAttr(he) {
              return new tt(he);
            }
            static neverEmbed(he) {
              return new ft(he);
            }
            static numberOfCopies(he) {
              return new Te(he);
            }
            static openAction(he) {
              return new je(he);
            }
            static output(he) {
              return new Ze(he);
            }
            static outputBin(he) {
              return new Me(he);
            }
            static outputXSL(he) {
              return new at(he);
            }
            static overprint(he) {
              return new rt(he);
            }
            static packets(he) {
              return new xt(he);
            }
            static pageOffset(he) {
              return new ut(he);
            }
            static pageRange(he) {
              return new yt(he);
            }
            static pagination(he) {
              return new ht(he);
            }
            static paginationOverride(he) {
              return new Rt(he);
            }
            static part(he) {
              return new Wt(he);
            }
            static pcl(he) {
              return new Ke(he);
            }
            static pdf(he) {
              return new Ge(he);
            }
            static pdfa(he) {
              return new nt(he);
            }
            static permissions(he) {
              return new it(he);
            }
            static pickTrayByPDFSize(he) {
              return new pt(he);
            }
            static picture(he) {
              return new Ft(he);
            }
            static plaintextMetadata(he) {
              return new mt(he);
            }
            static presence(he) {
              return new ct(he);
            }
            static present(he) {
              return new bt(he);
            }
            static print(he) {
              return new wt(he);
            }
            static printHighQuality(he) {
              return new Ot(he);
            }
            static printScaling(he) {
              return new Et(he);
            }
            static printerName(he) {
              return new St(he);
            }
            static producer(he) {
              return new Pe(he);
            }
            static ps(he) {
              return new We(he);
            }
            static range(he) {
              return new Je(he);
            }
            static record(he) {
              return new Ye(he);
            }
            static relevant(he) {
              return new gt(he);
            }
            static rename(he) {
              return new Dt(he);
            }
            static renderPolicy(he) {
              return new Xt(he);
            }
            static runScripts(he) {
              return new kt(he);
            }
            static script(he) {
              return new Pt(he);
            }
            static scriptModel(he) {
              return new zt(he);
            }
            static severity(he) {
              return new Yt(he);
            }
            static silentPrint(he) {
              return new an(he);
            }
            static staple(he) {
              return new Dn(he);
            }
            static startNode(he) {
              return new gn(he);
            }
            static startPage(he) {
              return new _n(he);
            }
            static submitFormat(he) {
              return new En(he);
            }
            static submitUrl(he) {
              return new An(he);
            }
            static subsetBelow(he) {
              return new kn(he);
            }
            static suppressBanner(he) {
              return new On(he);
            }
            static tagged(he) {
              return new In(he);
            }
            static template(he) {
              return new Pn(he);
            }
            static templateCache(he) {
              return new xn(he);
            }
            static threshold(he) {
              return new Rn(he);
            }
            static to(he) {
              return new Un(he);
            }
            static trace(he) {
              return new on(he);
            }
            static transform(he) {
              return new Sn(he);
            }
            static type(he) {
              return new Qt(he);
            }
            static uri(he) {
              return new cn(he);
            }
            static validate(he) {
              return new bn(he);
            }
            static validateApprovalSignatures(he) {
              return new Cn(he);
            }
            static validationMessaging(he) {
              return new yn(he);
            }
            static version(he) {
              return new Mn(he);
            }
            static versionControl(he) {
              return new Bn(he);
            }
            static viewerPreferences(he) {
              return new Ln(he);
            }
            static webClient(he) {
              return new Nn(he);
            }
            static whitespace(he) {
              return new vn(he);
            }
            static window(he) {
              return new wn(he);
            }
            static xdc(he) {
              return new jn(he);
            }
            static xdp(he) {
              return new hn(he);
            }
            static xsl(he) {
              return new Wn(he);
            }
            static zpl(he) {
              return new dn(he);
            }
          }
          o.ConfigNamespace = Xe;
        },
        /* 92 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.ConnectionSetNamespace = void 0;
          var t = C(79), a = C(77);
          const v = t.NamespaceIds.connectionSet.id;
          class h extends a.XFAObject {
            constructor(b) {
              super(v, "connectionSet", !0), this.wsdlConnection = new a.XFAObjectArray(), this.xmlConnection = new a.XFAObjectArray(), this.xsdConnection = new a.XFAObjectArray();
            }
          }
          class e extends a.XFAObject {
            constructor(b) {
              super(v, "effectiveInputPolicy"), this.id = b.id || "", this.name = b.name || "", this.use = b.use || "", this.usehref = b.usehref || "";
            }
          }
          class y extends a.XFAObject {
            constructor(b) {
              super(v, "effectiveOutputPolicy"), this.id = b.id || "", this.name = b.name || "", this.use = b.use || "", this.usehref = b.usehref || "";
            }
          }
          class c extends a.StringObject {
            constructor(b) {
              super(v, "operation"), this.id = b.id || "", this.input = b.input || "", this.name = b.name || "", this.output = b.output || "", this.use = b.use || "", this.usehref = b.usehref || "";
            }
          }
          class d extends a.StringObject {
            constructor(b) {
              super(v, "rootElement"), this.id = b.id || "", this.name = b.name || "", this.use = b.use || "", this.usehref = b.usehref || "";
            }
          }
          class p extends a.StringObject {
            constructor(b) {
              super(v, "soapAction"), this.id = b.id || "", this.name = b.name || "", this.use = b.use || "", this.usehref = b.usehref || "";
            }
          }
          class m extends a.StringObject {
            constructor(b) {
              super(v, "soapAddress"), this.id = b.id || "", this.name = b.name || "", this.use = b.use || "", this.usehref = b.usehref || "";
            }
          }
          class g extends a.StringObject {
            constructor(b) {
              super(v, "uri"), this.id = b.id || "", this.name = b.name || "", this.use = b.use || "", this.usehref = b.usehref || "";
            }
          }
          class n extends a.StringObject {
            constructor(b) {
              super(v, "wsdlAddress"), this.id = b.id || "", this.name = b.name || "", this.use = b.use || "", this.usehref = b.usehref || "";
            }
          }
          class i extends a.XFAObject {
            constructor(b) {
              super(v, "wsdlConnection", !0), this.dataDescription = b.dataDescription || "", this.name = b.name || "", this.effectiveInputPolicy = null, this.effectiveOutputPolicy = null, this.operation = null, this.soapAction = null, this.soapAddress = null, this.wsdlAddress = null;
            }
          }
          class l extends a.XFAObject {
            constructor(b) {
              super(v, "xmlConnection", !0), this.dataDescription = b.dataDescription || "", this.name = b.name || "", this.uri = null;
            }
          }
          class u extends a.XFAObject {
            constructor(b) {
              super(v, "xsdConnection", !0), this.dataDescription = b.dataDescription || "", this.name = b.name || "", this.rootElement = null, this.uri = null;
            }
          }
          class w {
            static [t.$buildXFAObject](b, A) {
              if (w.hasOwnProperty(b))
                return w[b](A);
            }
            static connectionSet(b) {
              return new h(b);
            }
            static effectiveInputPolicy(b) {
              return new e(b);
            }
            static effectiveOutputPolicy(b) {
              return new y(b);
            }
            static operation(b) {
              return new c(b);
            }
            static rootElement(b) {
              return new d(b);
            }
            static soapAction(b) {
              return new p(b);
            }
            static soapAddress(b) {
              return new m(b);
            }
            static uri(b) {
              return new g(b);
            }
            static wsdlAddress(b) {
              return new n(b);
            }
            static wsdlConnection(b) {
              return new i(b);
            }
            static xmlConnection(b) {
              return new l(b);
            }
            static xsdConnection(b) {
              return new u(b);
            }
          }
          o.ConnectionSetNamespace = w;
        },
        /* 93 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.DatasetsNamespace = void 0;
          var t = C(77), a = C(79);
          const v = a.NamespaceIds.datasets.id;
          class h extends t.XmlObject {
            constructor(d) {
              super(v, "data", d);
            }
            [t.$isNsAgnostic]() {
              return !0;
            }
          }
          class e extends t.XFAObject {
            constructor(d) {
              super(v, "datasets", !0), this.data = null, this.Signature = null;
            }
            [t.$onChild](d) {
              const p = d[t.$nodeName];
              (p === "data" && d[t.$namespaceId] === v || p === "Signature" && d[t.$namespaceId] === a.NamespaceIds.signature.id) && (this[p] = d), this[t.$appendChild](d);
            }
          }
          class y {
            static [a.$buildXFAObject](d, p) {
              if (y.hasOwnProperty(d))
                return y[d](p);
            }
            static datasets(d) {
              return new e(d);
            }
            static data(d) {
              return new h(d);
            }
          }
          o.DatasetsNamespace = y;
        },
        /* 94 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.LocaleSetNamespace = void 0;
          var t = C(79), a = C(77), v = C(78);
          const h = t.NamespaceIds.localeSet.id;
          class e extends a.XFAObject {
            constructor(F) {
              super(h, "calendarSymbols", !0), this.name = "gregorian", this.dayNames = new a.XFAObjectArray(2), this.eraNames = null, this.meridiemNames = null, this.monthNames = new a.XFAObjectArray(2);
            }
          }
          class y extends a.StringObject {
            constructor(F) {
              super(h, "currencySymbol"), this.name = (0, v.getStringOption)(F.name, ["symbol", "isoname", "decimal"]);
            }
          }
          class c extends a.XFAObject {
            constructor(F) {
              super(h, "currencySymbols", !0), this.currencySymbol = new a.XFAObjectArray(3);
            }
          }
          class d extends a.StringObject {
            constructor(F) {
              super(h, "datePattern"), this.name = (0, v.getStringOption)(F.name, ["full", "long", "med", "short"]);
            }
          }
          class p extends a.XFAObject {
            constructor(F) {
              super(h, "datePatterns", !0), this.datePattern = new a.XFAObjectArray(4);
            }
          }
          class m extends a.ContentObject {
            constructor(F) {
              super(h, "dateTimeSymbols");
            }
          }
          class g extends a.StringObject {
            constructor(F) {
              super(h, "day");
            }
          }
          class n extends a.XFAObject {
            constructor(F) {
              super(h, "dayNames", !0), this.abbr = (0, v.getInteger)({
                data: F.abbr,
                defaultValue: 0,
                validate: (T) => T === 1
              }), this.day = new a.XFAObjectArray(7);
            }
          }
          class i extends a.StringObject {
            constructor(F) {
              super(h, "era");
            }
          }
          class l extends a.XFAObject {
            constructor(F) {
              super(h, "eraNames", !0), this.era = new a.XFAObjectArray(2);
            }
          }
          class u extends a.XFAObject {
            constructor(F) {
              super(h, "locale", !0), this.desc = F.desc || "", this.name = "isoname", this.calendarSymbols = null, this.currencySymbols = null, this.datePatterns = null, this.dateTimeSymbols = null, this.numberPatterns = null, this.numberSymbols = null, this.timePatterns = null, this.typeFaces = null;
            }
          }
          class w extends a.XFAObject {
            constructor(F) {
              super(h, "localeSet", !0), this.locale = new a.XFAObjectArray();
            }
          }
          class _ extends a.StringObject {
            constructor(F) {
              super(h, "meridiem");
            }
          }
          class b extends a.XFAObject {
            constructor(F) {
              super(h, "meridiemNames", !0), this.meridiem = new a.XFAObjectArray(2);
            }
          }
          class A extends a.StringObject {
            constructor(F) {
              super(h, "month");
            }
          }
          class Y extends a.XFAObject {
            constructor(F) {
              super(h, "monthNames", !0), this.abbr = (0, v.getInteger)({
                data: F.abbr,
                defaultValue: 0,
                validate: (T) => T === 1
              }), this.month = new a.XFAObjectArray(12);
            }
          }
          class j extends a.StringObject {
            constructor(F) {
              super(h, "numberPattern"), this.name = (0, v.getStringOption)(F.name, ["full", "long", "med", "short"]);
            }
          }
          class X extends a.XFAObject {
            constructor(F) {
              super(h, "numberPatterns", !0), this.numberPattern = new a.XFAObjectArray(4);
            }
          }
          class B extends a.StringObject {
            constructor(F) {
              super(h, "numberSymbol"), this.name = (0, v.getStringOption)(F.name, ["decimal", "grouping", "percent", "minus", "zero"]);
            }
          }
          class R extends a.XFAObject {
            constructor(F) {
              super(h, "numberSymbols", !0), this.numberSymbol = new a.XFAObjectArray(5);
            }
          }
          class k extends a.StringObject {
            constructor(F) {
              super(h, "timePattern"), this.name = (0, v.getStringOption)(F.name, ["full", "long", "med", "short"]);
            }
          }
          class x extends a.XFAObject {
            constructor(F) {
              super(h, "timePatterns", !0), this.timePattern = new a.XFAObjectArray(4);
            }
          }
          class f extends a.XFAObject {
            constructor(F) {
              super(h, "typeFace", !0), this.name = F.name | "";
            }
          }
          class U extends a.XFAObject {
            constructor(F) {
              super(h, "typeFaces", !0), this.typeFace = new a.XFAObjectArray();
            }
          }
          class O {
            static [t.$buildXFAObject](F, T) {
              if (O.hasOwnProperty(F))
                return O[F](T);
            }
            static calendarSymbols(F) {
              return new e(F);
            }
            static currencySymbol(F) {
              return new y(F);
            }
            static currencySymbols(F) {
              return new c(F);
            }
            static datePattern(F) {
              return new d(F);
            }
            static datePatterns(F) {
              return new p(F);
            }
            static dateTimeSymbols(F) {
              return new m(F);
            }
            static day(F) {
              return new g(F);
            }
            static dayNames(F) {
              return new n(F);
            }
            static era(F) {
              return new i(F);
            }
            static eraNames(F) {
              return new l(F);
            }
            static locale(F) {
              return new u(F);
            }
            static localeSet(F) {
              return new w(F);
            }
            static meridiem(F) {
              return new _(F);
            }
            static meridiemNames(F) {
              return new b(F);
            }
            static month(F) {
              return new A(F);
            }
            static monthNames(F) {
              return new Y(F);
            }
            static numberPattern(F) {
              return new j(F);
            }
            static numberPatterns(F) {
              return new X(F);
            }
            static numberSymbol(F) {
              return new B(F);
            }
            static numberSymbols(F) {
              return new R(F);
            }
            static timePattern(F) {
              return new k(F);
            }
            static timePatterns(F) {
              return new x(F);
            }
            static typeFace(F) {
              return new f(F);
            }
            static typeFaces(F) {
              return new U(F);
            }
          }
          o.LocaleSetNamespace = O;
        },
        /* 95 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.SignatureNamespace = void 0;
          var t = C(79), a = C(77);
          const v = t.NamespaceIds.signature.id;
          class h extends a.XFAObject {
            constructor(c) {
              super(v, "signature", !0);
            }
          }
          class e {
            static [t.$buildXFAObject](c, d) {
              if (e.hasOwnProperty(c))
                return e[c](d);
            }
            static signature(c) {
              return new h(c);
            }
          }
          o.SignatureNamespace = e;
        },
        /* 96 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.StylesheetNamespace = void 0;
          var t = C(79), a = C(77);
          const v = t.NamespaceIds.stylesheet.id;
          class h extends a.XFAObject {
            constructor(c) {
              super(v, "stylesheet", !0);
            }
          }
          class e {
            static [t.$buildXFAObject](c, d) {
              if (e.hasOwnProperty(c))
                return e[c](d);
            }
            static stylesheet(c) {
              return new h(c);
            }
          }
          o.StylesheetNamespace = e;
        },
        /* 97 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.XdpNamespace = void 0;
          var t = C(79), a = C(77);
          const v = t.NamespaceIds.xdp.id;
          class h extends a.XFAObject {
            constructor(c) {
              super(v, "xdp", !0), this.uuid = c.uuid || "", this.timeStamp = c.timeStamp || "", this.config = null, this.connectionSet = null, this.datasets = null, this.localeSet = null, this.stylesheet = new a.XFAObjectArray(), this.template = null;
            }
            [a.$onChildCheck](c) {
              const d = t.NamespaceIds[c[a.$nodeName]];
              return d && c[a.$namespaceId] === d.id;
            }
          }
          class e {
            static [t.$buildXFAObject](c, d) {
              if (e.hasOwnProperty(c))
                return e[c](d);
            }
            static xdp(c) {
              return new h(c);
            }
          }
          o.XdpNamespace = e;
        },
        /* 98 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.XhtmlNamespace = void 0;
          var t = C(77), a = C(79), v = C(84), h = C(78);
          const e = a.NamespaceIds.xhtml.id, y = Symbol(), c = /* @__PURE__ */ new Set(["color", "font", "font-family", "font-size", "font-stretch", "font-style", "font-weight", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "letter-spacing", "line-height", "orphans", "page-break-after", "page-break-before", "page-break-inside", "tab-interval", "tab-stop", "text-align", "text-decoration", "text-indent", "vertical-align", "widows", "kerning-mode", "xfa-font-horizontal-scale", "xfa-font-vertical-scale", "xfa-spacerun", "xfa-tab-stops"]), d = /* @__PURE__ */ new Map([["page-break-after", "breakAfter"], ["page-break-before", "breakBefore"], ["page-break-inside", "breakInside"], ["kerning-mode", (S) => S === "none" ? "none" : "normal"], ["xfa-font-horizontal-scale", (S) => `scaleX(${Math.max(0, Math.min(parseInt(S) / 100)).toFixed(2)})`], ["xfa-font-vertical-scale", (S) => `scaleY(${Math.max(0, Math.min(parseInt(S) / 100)).toFixed(2)})`], ["xfa-spacerun", ""], ["xfa-tab-stops", ""], ["font-size", (S, F) => (S = F.fontSize = (0, h.getMeasurement)(S), (0, v.measureToString)(0.99 * S))], ["letter-spacing", (S) => (0, v.measureToString)((0, h.getMeasurement)(S))], ["line-height", (S) => (0, v.measureToString)((0, h.getMeasurement)(S))], ["margin", (S) => (0, v.measureToString)((0, h.getMeasurement)(S))], ["margin-bottom", (S) => (0, v.measureToString)((0, h.getMeasurement)(S))], ["margin-left", (S) => (0, v.measureToString)((0, h.getMeasurement)(S))], ["margin-right", (S) => (0, v.measureToString)((0, h.getMeasurement)(S))], ["margin-top", (S) => (0, v.measureToString)((0, h.getMeasurement)(S))], ["text-indent", (S) => (0, v.measureToString)((0, h.getMeasurement)(S))], ["font-family", (S) => S], ["vertical-align", (S) => (0, v.measureToString)((0, h.getMeasurement)(S))]]), p = /\s+/g, m = /[\r\n]+/g, g = /\r\n?/g;
          function n(S, F, T) {
            const I = /* @__PURE__ */ Object.create(null);
            if (!S)
              return I;
            const M = /* @__PURE__ */ Object.create(null);
            for (const [V, J] of S.split(";").map((W) => W.split(":", 2))) {
              const W = d.get(V);
              if (W === "")
                continue;
              let z = J;
              W && (typeof W == "string" ? z = W : z = W(J, M)), V.endsWith("scale") ? I.transform ? I.transform = `${I[V]} ${z}` : I.transform = z : I[V.replaceAll(/-([a-zA-Z])/g, (G, L) => L.toUpperCase())] = z;
            }
            if (I.fontFamily && (0, v.setFontFamily)({
              typeface: I.fontFamily,
              weight: I.fontWeight || "normal",
              posture: I.fontStyle || "normal",
              size: M.fontSize || 0
            }, F, F[t.$globalData].fontFinder, I), T && I.verticalAlign && I.verticalAlign !== "0px" && I.fontSize) {
              const W = (0, h.getMeasurement)(I.fontSize);
              I.fontSize = (0, v.measureToString)(W * 0.583), I.verticalAlign = (0, v.measureToString)(Math.sign((0, h.getMeasurement)(I.verticalAlign)) * W * 0.333);
            }
            return T && I.fontSize && (I.fontSize = `calc(${I.fontSize} * var(--scale-factor))`), (0, v.fixTextIndent)(I), I;
          }
          function i(S) {
            return S.style ? S.style.trim().split(/\s*;\s*/).filter((F) => !!F).map((F) => F.split(/\s*:\s*/, 2)).filter(([F, T]) => (F === "font-family" && S[t.$globalData].usedTypefaces.add(T), c.has(F))).map((F) => F.join(":")).join(";") : "";
          }
          const l = /* @__PURE__ */ new Set(["body", "html"]);
          class u extends t.XmlObject {
            constructor(F, T) {
              super(e, T), this[y] = !1, this.style = F.style || "";
            }
            [t.$clean](F) {
              super[t.$clean](F), this.style = i(this);
            }
            [t.$acceptWhitespace]() {
              return !l.has(this[t.$nodeName]);
            }
            [t.$onText](F, T = !1) {
              T ? this[y] = !0 : (F = F.replace(m, ""), this.style.includes("xfa-spacerun:yes") || (F = F.replace(p, " "))), F && (this[t.$content] += F);
            }
            [t.$pushGlyphs](F, T = !0) {
              const I = /* @__PURE__ */ Object.create(null), M = {
                top: NaN,
                bottom: NaN,
                left: NaN,
                right: NaN
              };
              let V = null;
              for (const [J, W] of this.style.split(";").map((z) => z.split(":", 2)))
                switch (J) {
                  case "font-family":
                    I.typeface = (0, h.stripQuotes)(W);
                    break;
                  case "font-size":
                    I.size = (0, h.getMeasurement)(W);
                    break;
                  case "font-weight":
                    I.weight = W;
                    break;
                  case "font-style":
                    I.posture = W;
                    break;
                  case "letter-spacing":
                    I.letterSpacing = (0, h.getMeasurement)(W);
                    break;
                  case "margin":
                    const z = W.split(/ \t/).map((G) => (0, h.getMeasurement)(G));
                    switch (z.length) {
                      case 1:
                        M.top = M.bottom = M.left = M.right = z[0];
                        break;
                      case 2:
                        M.top = M.bottom = z[0], M.left = M.right = z[1];
                        break;
                      case 3:
                        M.top = z[0], M.bottom = z[2], M.left = M.right = z[1];
                        break;
                      case 4:
                        M.top = z[0], M.left = z[1], M.bottom = z[2], M.right = z[3];
                        break;
                    }
                    break;
                  case "margin-top":
                    M.top = (0, h.getMeasurement)(W);
                    break;
                  case "margin-bottom":
                    M.bottom = (0, h.getMeasurement)(W);
                    break;
                  case "margin-left":
                    M.left = (0, h.getMeasurement)(W);
                    break;
                  case "margin-right":
                    M.right = (0, h.getMeasurement)(W);
                    break;
                  case "line-height":
                    V = (0, h.getMeasurement)(W);
                    break;
                }
              if (F.pushData(I, M, V), this[t.$content])
                F.addString(this[t.$content]);
              else
                for (const J of this[t.$getChildren]()) {
                  if (J[t.$nodeName] === "#text") {
                    F.addString(J[t.$content]);
                    continue;
                  }
                  J[t.$pushGlyphs](F);
                }
              T && F.popFont();
            }
            [t.$toHTML](F) {
              const T = [];
              if (this[t.$extra] = {
                children: T
              }, this[t.$childrenToHTML]({}), T.length === 0 && !this[t.$content])
                return h.HTMLResult.EMPTY;
              let I;
              return this[y] ? I = this[t.$content] ? this[t.$content].replace(g, `
`) : void 0 : I = this[t.$content] || void 0, h.HTMLResult.success({
                name: this[t.$nodeName],
                attributes: {
                  href: this.href,
                  style: n(this.style, this, this[y])
                },
                children: T,
                value: I
              });
            }
          }
          class w extends u {
            constructor(F) {
              super(F, "a"), this.href = (0, v.fixURL)(F.href) || "";
            }
          }
          class _ extends u {
            constructor(F) {
              super(F, "b");
            }
            [t.$pushGlyphs](F) {
              F.pushFont({
                weight: "bold"
              }), super[t.$pushGlyphs](F), F.popFont();
            }
          }
          class b extends u {
            constructor(F) {
              super(F, "body");
            }
            [t.$toHTML](F) {
              const T = super[t.$toHTML](F), {
                html: I
              } = T;
              return I ? (I.name = "div", I.attributes.class = ["xfaRich"], T) : h.HTMLResult.EMPTY;
            }
          }
          class A extends u {
            constructor(F) {
              super(F, "br");
            }
            [t.$text]() {
              return `
`;
            }
            [t.$pushGlyphs](F) {
              F.addString(`
`);
            }
            [t.$toHTML](F) {
              return h.HTMLResult.success({
                name: "br"
              });
            }
          }
          class Y extends u {
            constructor(F) {
              super(F, "html");
            }
            [t.$toHTML](F) {
              const T = [];
              if (this[t.$extra] = {
                children: T
              }, this[t.$childrenToHTML]({}), T.length === 0)
                return h.HTMLResult.success({
                  name: "div",
                  attributes: {
                    class: ["xfaRich"],
                    style: {}
                  },
                  value: this[t.$content] || ""
                });
              if (T.length === 1) {
                const I = T[0];
                if (I.attributes && I.attributes.class.includes("xfaRich"))
                  return h.HTMLResult.success(I);
              }
              return h.HTMLResult.success({
                name: "div",
                attributes: {
                  class: ["xfaRich"],
                  style: {}
                },
                children: T
              });
            }
          }
          class j extends u {
            constructor(F) {
              super(F, "i");
            }
            [t.$pushGlyphs](F) {
              F.pushFont({
                posture: "italic"
              }), super[t.$pushGlyphs](F), F.popFont();
            }
          }
          class X extends u {
            constructor(F) {
              super(F, "li");
            }
          }
          class B extends u {
            constructor(F) {
              super(F, "ol");
            }
          }
          class R extends u {
            constructor(F) {
              super(F, "p");
            }
            [t.$pushGlyphs](F) {
              super[t.$pushGlyphs](F, !1), F.addString(`
`), F.addPara(), F.popFont();
            }
            [t.$text]() {
              return this[t.$getParent]()[t.$getChildren]().at(-1) === this ? super[t.$text]() : super[t.$text]() + `
`;
            }
          }
          class k extends u {
            constructor(F) {
              super(F, "span");
            }
          }
          class x extends u {
            constructor(F) {
              super(F, "sub");
            }
          }
          class f extends u {
            constructor(F) {
              super(F, "sup");
            }
          }
          class U extends u {
            constructor(F) {
              super(F, "ul");
            }
          }
          class O {
            static [a.$buildXFAObject](F, T) {
              if (O.hasOwnProperty(F))
                return O[F](T);
            }
            static a(F) {
              return new w(F);
            }
            static b(F) {
              return new _(F);
            }
            static body(F) {
              return new b(F);
            }
            static br(F) {
              return new A(F);
            }
            static html(F) {
              return new Y(F);
            }
            static i(F) {
              return new j(F);
            }
            static li(F) {
              return new X(F);
            }
            static ol(F) {
              return new B(F);
            }
            static p(F) {
              return new R(F);
            }
            static span(F) {
              return new k(F);
            }
            static sub(F) {
              return new x(F);
            }
            static sup(F) {
              return new f(F);
            }
            static ul(F) {
              return new U(F);
            }
          }
          o.XhtmlNamespace = O;
        },
        /* 99 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.UnknownNamespace = void 0;
          var t = C(79), a = C(77);
          class v {
            constructor(e) {
              this.namespaceId = e;
            }
            [t.$buildXFAObject](e, y) {
              return new a.XmlObject(this.namespaceId, e, y);
            }
          }
          o.UnknownNamespace = v;
        },
        /* 100 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.DatasetReader = void 0;
          var t = C(2), a = C(6), v = C(66);
          function h(c) {
            try {
              return (0, t.stringToUTF8String)(c);
            } catch (d) {
              return (0, t.warn)(`UTF-8 decoding failed: "${d}".`), c;
            }
          }
          class e extends v.SimpleXMLParser {
            constructor(d) {
              super(d), this.node = null;
            }
            onEndElement(d) {
              const p = super.onEndElement(d);
              if (p && d === "xfa:datasets")
                throw this.node = p, new Error("Aborting DatasetXMLParser.");
            }
          }
          class y {
            constructor(d) {
              if (d.datasets)
                this.node = new v.SimpleXMLParser({
                  hasAttributes: !0
                }).parseFromString(d.datasets).documentElement;
              else {
                const p = new e({
                  hasAttributes: !0
                });
                try {
                  p.parseFromString(d["xdp:xdp"]);
                } catch {
                }
                this.node = p.node;
              }
            }
            getValue(d) {
              if (!this.node || !d)
                return "";
              const p = this.node.searchNode((0, a.parseXFAPath)(d), 0);
              if (!p)
                return "";
              const m = p.firstChild;
              return m && m.nodeName === "value" ? p.children.map((g) => h(g.textContent)) : h(p.textContent);
            }
          }
          o.DatasetReader = y;
        },
        /* 101 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.XRef = void 0;
          var t = C(2), a = C(5), v = C(6), h = C(17), e = C(7), y = C(67);
          class c {
            constructor(p, m) {
              this.stream = p, this.pdfManager = m, this.entries = [], this.xrefstms = /* @__PURE__ */ Object.create(null), this._cacheMap = /* @__PURE__ */ new Map(), this._pendingRefs = new a.RefSet(), this.stats = new v.DocStats(m.msgHandler), this._newRefNum = null;
            }
            getNewRef() {
              return this._newRefNum === null && (this._newRefNum = this.entries.length || 1), a.Ref.get(this._newRefNum++, 0);
            }
            resetNewRef() {
              this._newRefNum = null;
            }
            setStartXRef(p) {
              this.startXRefQueue = [p];
            }
            parse(p = !1) {
              let m;
              p ? ((0, t.warn)("Indexing all PDF objects"), m = this.indexObjects()) : m = this.readXRef(), m.assignXref(this), this.trailer = m;
              let g;
              try {
                g = m.get("Encrypt");
              } catch (i) {
                if (i instanceof v.MissingDataException)
                  throw i;
                (0, t.warn)(`XRef.parse - Invalid "Encrypt" reference: "${i}".`);
              }
              if (g instanceof a.Dict) {
                const i = m.get("ID"), l = i && i.length ? i[0] : "";
                g.suppressEncryption = !0, this.encrypt = new y.CipherTransformFactory(g, l, this.pdfManager.password);
              }
              let n;
              try {
                n = m.get("Root");
              } catch (i) {
                if (i instanceof v.MissingDataException)
                  throw i;
                (0, t.warn)(`XRef.parse - Invalid "Root" reference: "${i}".`);
              }
              if (n instanceof a.Dict)
                try {
                  if (n.get("Pages") instanceof a.Dict) {
                    this.root = n;
                    return;
                  }
                } catch (i) {
                  if (i instanceof v.MissingDataException)
                    throw i;
                  (0, t.warn)(`XRef.parse - Invalid "Pages" reference: "${i}".`);
                }
              throw p ? new t.InvalidPDFException("Invalid Root reference.") : new v.XRefParseException();
            }
            processXRefTable(p) {
              "tableState" in this || (this.tableState = {
                entryNum: 0,
                streamPos: p.lexer.stream.pos,
                parserBuf1: p.buf1,
                parserBuf2: p.buf2
              });
              const m = this.readXRefTable(p);
              if (!(0, a.isCmd)(m, "trailer"))
                throw new t.FormatError("Invalid XRef table: could not find trailer dictionary");
              let g = p.getObj();
              if (!(g instanceof a.Dict) && g.dict && (g = g.dict), !(g instanceof a.Dict))
                throw new t.FormatError("Invalid XRef table: could not parse trailer dictionary");
              return delete this.tableState, g;
            }
            readXRefTable(p) {
              const m = p.lexer.stream, g = this.tableState;
              m.pos = g.streamPos, p.buf1 = g.parserBuf1, p.buf2 = g.parserBuf2;
              let n;
              for (; ; ) {
                if (!("firstEntryNum" in g) || !("entryCount" in g)) {
                  if ((0, a.isCmd)(n = p.getObj(), "trailer"))
                    break;
                  g.firstEntryNum = n, g.entryCount = p.getObj();
                }
                let i = g.firstEntryNum;
                const l = g.entryCount;
                if (!Number.isInteger(i) || !Number.isInteger(l))
                  throw new t.FormatError("Invalid XRef table: wrong types in subsection header");
                for (let u = g.entryNum; u < l; u++) {
                  g.streamPos = m.pos, g.entryNum = u, g.parserBuf1 = p.buf1, g.parserBuf2 = p.buf2;
                  const w = {};
                  w.offset = p.getObj(), w.gen = p.getObj();
                  const _ = p.getObj();
                  if (_ instanceof a.Cmd)
                    switch (_.cmd) {
                      case "f":
                        w.free = !0;
                        break;
                      case "n":
                        w.uncompressed = !0;
                        break;
                    }
                  if (!Number.isInteger(w.offset) || !Number.isInteger(w.gen) || !(w.free || w.uncompressed))
                    throw new t.FormatError(`Invalid entry in XRef subsection: ${i}, ${l}`);
                  u === 0 && w.free && i === 1 && (i = 0), this.entries[u + i] || (this.entries[u + i] = w);
                }
                g.entryNum = 0, g.streamPos = m.pos, g.parserBuf1 = p.buf1, g.parserBuf2 = p.buf2, delete g.firstEntryNum, delete g.entryCount;
              }
              if (this.entries[0] && !this.entries[0].free)
                throw new t.FormatError("Invalid XRef table: unexpected first object");
              return n;
            }
            processXRefStream(p) {
              if (!("streamState" in this)) {
                const m = p.dict, g = m.get("W");
                let n = m.get("Index");
                n || (n = [0, m.get("Size")]), this.streamState = {
                  entryRanges: n,
                  byteWidths: g,
                  entryNum: 0,
                  streamPos: p.pos
                };
              }
              return this.readXRefStream(p), delete this.streamState, p.dict;
            }
            readXRefStream(p) {
              const m = this.streamState;
              p.pos = m.streamPos;
              const [g, n, i] = m.byteWidths, l = m.entryRanges;
              for (; l.length > 0; ) {
                const [u, w] = l;
                if (!Number.isInteger(u) || !Number.isInteger(w))
                  throw new t.FormatError(`Invalid XRef range fields: ${u}, ${w}`);
                if (!Number.isInteger(g) || !Number.isInteger(n) || !Number.isInteger(i))
                  throw new t.FormatError(`Invalid XRef entry fields length: ${u}, ${w}`);
                for (let _ = m.entryNum; _ < w; ++_) {
                  m.entryNum = _, m.streamPos = p.pos;
                  let b = 0, A = 0, Y = 0;
                  for (let X = 0; X < g; ++X) {
                    const B = p.getByte();
                    if (B === -1)
                      throw new t.FormatError("Invalid XRef byteWidths 'type'.");
                    b = b << 8 | B;
                  }
                  g === 0 && (b = 1);
                  for (let X = 0; X < n; ++X) {
                    const B = p.getByte();
                    if (B === -1)
                      throw new t.FormatError("Invalid XRef byteWidths 'offset'.");
                    A = A << 8 | B;
                  }
                  for (let X = 0; X < i; ++X) {
                    const B = p.getByte();
                    if (B === -1)
                      throw new t.FormatError("Invalid XRef byteWidths 'generation'.");
                    Y = Y << 8 | B;
                  }
                  const j = {};
                  switch (j.offset = A, j.gen = Y, b) {
                    case 0:
                      j.free = !0;
                      break;
                    case 1:
                      j.uncompressed = !0;
                      break;
                    case 2:
                      break;
                    default:
                      throw new t.FormatError(`Invalid XRef entry type: ${b}`);
                  }
                  this.entries[u + _] || (this.entries[u + _] = j);
                }
                m.entryNum = 0, m.streamPos = p.pos, l.splice(0, 2);
              }
            }
            indexObjects() {
              function u(T, I) {
                let M = "", V = T[I];
                for (; V !== 10 && V !== 13 && V !== 60 && !(++I >= T.length); )
                  M += String.fromCharCode(V), V = T[I];
                return M;
              }
              function w(T, I, M) {
                const V = M.length, J = T.length;
                let W = 0;
                for (; I < J; ) {
                  let z = 0;
                  for (; z < V && T[I + z] === M[z]; )
                    ++z;
                  if (z >= V)
                    break;
                  I++, W++;
                }
                return W;
              }
              const _ = /^(\d+)\s+(\d+)\s+obj\b/, b = /\bendobj[\b\s]$/, A = /\s+(\d+\s+\d+\s+obj[\b\s<])$/, Y = 25, j = new Uint8Array([116, 114, 97, 105, 108, 101, 114]), X = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]), B = new Uint8Array([111, 98, 106]), R = new Uint8Array([47, 88, 82, 101, 102]);
              this.entries.length = 0, this._cacheMap.clear();
              const k = this.stream;
              k.pos = 0;
              const x = k.getBytes(), f = x.length;
              let U = k.start;
              const O = [], S = [];
              for (; U < f; ) {
                let T = x[U];
                if (T === 9 || T === 10 || T === 13 || T === 32) {
                  ++U;
                  continue;
                }
                if (T === 37) {
                  do {
                    if (++U, U >= f)
                      break;
                    T = x[U];
                  } while (T !== 10 && T !== 13);
                  continue;
                }
                const I = u(x, U);
                let M;
                if (I.startsWith("xref") && (I.length === 4 || /\s/.test(I[4])))
                  U += w(x, U, j), O.push(U), U += w(x, U, X);
                else if (M = _.exec(I)) {
                  const V = M[1] | 0, J = M[2] | 0;
                  let W, z = U + I.length, G = !1;
                  if (!this.entries[V])
                    G = !0;
                  else if (this.entries[V].gen === J)
                    try {
                      new h.Parser({
                        lexer: new h.Lexer(k.makeSubStream(z))
                      }).getObj(), G = !0;
                    } catch (te) {
                      te instanceof v.ParserEOFException ? (0, t.warn)(`indexObjects -- checking object (${I}): "${te}".`) : G = !0;
                    }
                  for (G && (this.entries[V] = {
                    offset: U - k.start,
                    gen: J,
                    uncompressed: !0
                  }); z < x.length; ) {
                    const te = z + w(x, z, B) + 4;
                    W = te - U;
                    const se = Math.max(te - Y, z), q = (0, t.bytesToString)(x.subarray(se, te));
                    if (b.test(q))
                      break;
                    {
                      const N = A.exec(q);
                      if (N && N[1]) {
                        (0, t.warn)('indexObjects: Found new "obj" inside of another "obj", caused by missing "endobj" -- trying to recover.'), W -= N[1].length;
                        break;
                      }
                    }
                    z = te;
                  }
                  const L = x.subarray(U, U + W), K = w(L, 0, R);
                  K < W && L[K + 5] < 64 && (S.push(U - k.start), this.xrefstms[U - k.start] = 1), U += W;
                } else
                  I.startsWith("trailer") && (I.length === 7 || /\s/.test(I[7])) ? (O.push(U), U += w(x, U, X)) : U += I.length + 1;
              }
              for (let T = 0, I = S.length; T < I; ++T)
                this.startXRefQueue.push(S[T]), this.readXRef(!0);
              let F;
              for (let T = 0, I = O.length; T < I; ++T) {
                k.pos = O[T];
                const M = new h.Parser({
                  lexer: new h.Lexer(k),
                  xref: this,
                  allowStreams: !0,
                  recoveryMode: !0
                }), V = M.getObj();
                if (!(0, a.isCmd)(V, "trailer"))
                  continue;
                const J = M.getObj();
                if (J instanceof a.Dict) {
                  try {
                    const W = J.get("Root");
                    if (!(W instanceof a.Dict))
                      continue;
                    const z = W.get("Pages");
                    if (!(z instanceof a.Dict))
                      continue;
                    const G = z.get("Count");
                    if (!Number.isInteger(G))
                      continue;
                  } catch {
                    continue;
                  }
                  if (J.has("ID"))
                    return J;
                  F = J;
                }
              }
              if (F)
                return F;
              if (this.topDict)
                return this.topDict;
              throw new t.InvalidPDFException("Invalid PDF structure.");
            }
            readXRef(p = !1) {
              const m = this.stream, g = /* @__PURE__ */ new Set();
              try {
                for (; this.startXRefQueue.length; ) {
                  const n = this.startXRefQueue[0];
                  if (g.has(n)) {
                    (0, t.warn)("readXRef - skipping XRef table since it was already parsed."), this.startXRefQueue.shift();
                    continue;
                  }
                  g.add(n), m.pos = n + m.start;
                  const i = new h.Parser({
                    lexer: new h.Lexer(m),
                    xref: this,
                    allowStreams: !0
                  });
                  let l = i.getObj(), u;
                  if ((0, a.isCmd)(l, "xref")) {
                    if (u = this.processXRefTable(i), this.topDict || (this.topDict = u), l = u.get("XRefStm"), Number.isInteger(l)) {
                      const w = l;
                      w in this.xrefstms || (this.xrefstms[w] = 1, this.startXRefQueue.push(w));
                    }
                  } else if (Number.isInteger(l)) {
                    if (!Number.isInteger(i.getObj()) || !(0, a.isCmd)(i.getObj(), "obj") || !((l = i.getObj()) instanceof e.BaseStream))
                      throw new t.FormatError("Invalid XRef stream");
                    if (u = this.processXRefStream(l), this.topDict || (this.topDict = u), !u)
                      throw new t.FormatError("Failed to read XRef stream");
                  } else
                    throw new t.FormatError("Invalid XRef stream header");
                  l = u.get("Prev"), Number.isInteger(l) ? this.startXRefQueue.push(l) : l instanceof a.Ref && this.startXRefQueue.push(l.num), this.startXRefQueue.shift();
                }
                return this.topDict;
              } catch (n) {
                if (n instanceof v.MissingDataException)
                  throw n;
                (0, t.info)("(while reading XRef): " + n), this.startXRefQueue.shift();
              }
              if (!p)
                throw new v.XRefParseException();
            }
            getEntry(p) {
              const m = this.entries[p];
              return m && !m.free && m.offset ? m : null;
            }
            fetchIfRef(p, m = !1) {
              return p instanceof a.Ref ? this.fetch(p, m) : p;
            }
            fetch(p, m = !1) {
              if (!(p instanceof a.Ref))
                throw new Error("ref object is not a reference");
              const g = p.num, n = this._cacheMap.get(g);
              if (n !== void 0)
                return n instanceof a.Dict && !n.objId && (n.objId = p.toString()), n;
              let i = this.getEntry(g);
              if (i === null)
                return this._cacheMap.set(g, i), i;
              if (this._pendingRefs.has(p))
                return this._pendingRefs.remove(p), (0, t.warn)(`Ignoring circular reference: ${p}.`), a.CIRCULAR_REF;
              this._pendingRefs.put(p);
              try {
                i.uncompressed ? i = this.fetchUncompressed(p, i, m) : i = this.fetchCompressed(p, i, m), this._pendingRefs.remove(p);
              } catch (l) {
                throw this._pendingRefs.remove(p), l;
              }
              return i instanceof a.Dict ? i.objId = p.toString() : i instanceof e.BaseStream && (i.dict.objId = p.toString()), i;
            }
            fetchUncompressed(p, m, g = !1) {
              const n = p.gen;
              let i = p.num;
              if (m.gen !== n)
                throw new v.XRefEntryException(`Inconsistent generation in XRef: ${p}`);
              const l = this.stream.makeSubStream(m.offset + this.stream.start), u = new h.Parser({
                lexer: new h.Lexer(l),
                xref: this,
                allowStreams: !0
              }), w = u.getObj(), _ = u.getObj(), b = u.getObj();
              if (w !== i || _ !== n || !(b instanceof a.Cmd))
                throw new v.XRefEntryException(`Bad (uncompressed) XRef entry: ${p}`);
              if (b.cmd !== "obj") {
                if (b.cmd.startsWith("obj") && (i = parseInt(b.cmd.substring(3), 10), !Number.isNaN(i)))
                  return i;
                throw new v.XRefEntryException(`Bad (uncompressed) XRef entry: ${p}`);
              }
              return this.encrypt && !g ? m = u.getObj(this.encrypt.createCipherTransform(i, n)) : m = u.getObj(), m instanceof e.BaseStream || this._cacheMap.set(i, m), m;
            }
            fetchCompressed(p, m, g = !1) {
              const n = m.offset, i = this.fetch(a.Ref.get(n, 0));
              if (!(i instanceof e.BaseStream))
                throw new t.FormatError("bad ObjStm stream");
              const l = i.dict.get("First"), u = i.dict.get("N");
              if (!Number.isInteger(l) || !Number.isInteger(u))
                throw new t.FormatError("invalid first and n parameters for ObjStm stream");
              let w = new h.Parser({
                lexer: new h.Lexer(i),
                xref: this,
                allowStreams: !0
              });
              const _ = new Array(u), b = new Array(u);
              for (let j = 0; j < u; ++j) {
                const X = w.getObj();
                if (!Number.isInteger(X))
                  throw new t.FormatError(`invalid object number in the ObjStm stream: ${X}`);
                const B = w.getObj();
                if (!Number.isInteger(B))
                  throw new t.FormatError(`invalid object offset in the ObjStm stream: ${B}`);
                _[j] = X, b[j] = B;
              }
              const A = (i.start || 0) + l, Y = new Array(u);
              for (let j = 0; j < u; ++j) {
                const X = j < u - 1 ? b[j + 1] - b[j] : void 0;
                if (X < 0)
                  throw new t.FormatError("Invalid offset in the ObjStm stream.");
                w = new h.Parser({
                  lexer: new h.Lexer(i.makeSubStream(A + b[j], X, i.dict)),
                  xref: this,
                  allowStreams: !0
                });
                const B = w.getObj();
                if (Y[j] = B, B instanceof e.BaseStream)
                  continue;
                const R = _[j], k = this.entries[R];
                k && k.offset === n && k.gen === j && this._cacheMap.set(R, B);
              }
              if (m = Y[m.gen], m === void 0)
                throw new v.XRefEntryException(`Bad (compressed) XRef entry: ${p}`);
              return m;
            }
            async fetchIfRefAsync(p, m) {
              return p instanceof a.Ref ? this.fetchAsync(p, m) : p;
            }
            async fetchAsync(p, m) {
              try {
                return this.fetch(p, m);
              } catch (g) {
                if (!(g instanceof v.MissingDataException))
                  throw g;
                return await this.pdfManager.requestRange(g.begin, g.end), this.fetchAsync(p, m);
              }
            }
            getCatalogObj() {
              return this.root;
            }
          }
          o.XRef = c;
        },
        /* 102 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.MessageHandler = void 0;
          var t = C(2);
          const a = {
            UNKNOWN: 0,
            DATA: 1,
            ERROR: 2
          }, v = {
            UNKNOWN: 0,
            CANCEL: 1,
            CANCEL_COMPLETE: 2,
            CLOSE: 3,
            ENQUEUE: 4,
            ERROR: 5,
            PULL: 6,
            PULL_COMPLETE: 7,
            START_COMPLETE: 8
          };
          function h(y) {
            switch (y instanceof Error || typeof y == "object" && y !== null || (0, t.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), y.name) {
              case "AbortException":
                return new t.AbortException(y.message);
              case "MissingPDFException":
                return new t.MissingPDFException(y.message);
              case "PasswordException":
                return new t.PasswordException(y.message, y.code);
              case "UnexpectedResponseException":
                return new t.UnexpectedResponseException(y.message, y.status);
              case "UnknownErrorException":
                return new t.UnknownErrorException(y.message, y.details);
              default:
                return new t.UnknownErrorException(y.message, y.toString());
            }
          }
          class e {
            constructor(c, d, p) {
              this.sourceName = c, this.targetName = d, this.comObj = p, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), this._onComObjOnMessage = (m) => {
                const g = m.data;
                if (g.targetName !== this.sourceName)
                  return;
                if (g.stream) {
                  this._processStreamMessage(g);
                  return;
                }
                if (g.callback) {
                  const i = g.callbackId, l = this.callbackCapabilities[i];
                  if (!l)
                    throw new Error(`Cannot resolve callback ${i}`);
                  if (delete this.callbackCapabilities[i], g.callback === a.DATA)
                    l.resolve(g.data);
                  else if (g.callback === a.ERROR)
                    l.reject(h(g.reason));
                  else
                    throw new Error("Unexpected callback case");
                  return;
                }
                const n = this.actionHandler[g.action];
                if (!n)
                  throw new Error(`Unknown action from worker: ${g.action}`);
                if (g.callbackId) {
                  const i = this.sourceName, l = g.sourceName;
                  new Promise(function(u) {
                    u(n(g.data));
                  }).then(function(u) {
                    p.postMessage({
                      sourceName: i,
                      targetName: l,
                      callback: a.DATA,
                      callbackId: g.callbackId,
                      data: u
                    });
                  }, function(u) {
                    p.postMessage({
                      sourceName: i,
                      targetName: l,
                      callback: a.ERROR,
                      callbackId: g.callbackId,
                      reason: h(u)
                    });
                  });
                  return;
                }
                if (g.streamId) {
                  this._createStreamSink(g);
                  return;
                }
                n(g.data);
              }, p.addEventListener("message", this._onComObjOnMessage);
            }
            on(c, d) {
              const p = this.actionHandler;
              if (p[c])
                throw new Error(`There is already an actionName called "${c}"`);
              p[c] = d;
            }
            send(c, d, p) {
              this.comObj.postMessage({
                sourceName: this.sourceName,
                targetName: this.targetName,
                action: c,
                data: d
              }, p);
            }
            sendWithPromise(c, d, p) {
              const m = this.callbackId++, g = (0, t.createPromiseCapability)();
              this.callbackCapabilities[m] = g;
              try {
                this.comObj.postMessage({
                  sourceName: this.sourceName,
                  targetName: this.targetName,
                  action: c,
                  callbackId: m,
                  data: d
                }, p);
              } catch (n) {
                g.reject(n);
              }
              return g.promise;
            }
            sendWithStream(c, d, p, m) {
              const g = this.streamId++, n = this.sourceName, i = this.targetName, l = this.comObj;
              return new ReadableStream({
                start: (u) => {
                  const w = (0, t.createPromiseCapability)();
                  return this.streamControllers[g] = {
                    controller: u,
                    startCall: w,
                    pullCall: null,
                    cancelCall: null,
                    isClosed: !1
                  }, l.postMessage({
                    sourceName: n,
                    targetName: i,
                    action: c,
                    streamId: g,
                    data: d,
                    desiredSize: u.desiredSize
                  }, m), w.promise;
                },
                pull: (u) => {
                  const w = (0, t.createPromiseCapability)();
                  return this.streamControllers[g].pullCall = w, l.postMessage({
                    sourceName: n,
                    targetName: i,
                    stream: v.PULL,
                    streamId: g,
                    desiredSize: u.desiredSize
                  }), w.promise;
                },
                cancel: (u) => {
                  (0, t.assert)(u instanceof Error, "cancel must have a valid reason");
                  const w = (0, t.createPromiseCapability)();
                  return this.streamControllers[g].cancelCall = w, this.streamControllers[g].isClosed = !0, l.postMessage({
                    sourceName: n,
                    targetName: i,
                    stream: v.CANCEL,
                    streamId: g,
                    reason: h(u)
                  }), w.promise;
                }
              }, p);
            }
            _createStreamSink(c) {
              const d = c.streamId, p = this.sourceName, m = c.sourceName, g = this.comObj, n = this, i = this.actionHandler[c.action], l = {
                enqueue(u, w = 1, _) {
                  if (this.isCancelled)
                    return;
                  const b = this.desiredSize;
                  this.desiredSize -= w, b > 0 && this.desiredSize <= 0 && (this.sinkCapability = (0, t.createPromiseCapability)(), this.ready = this.sinkCapability.promise), g.postMessage({
                    sourceName: p,
                    targetName: m,
                    stream: v.ENQUEUE,
                    streamId: d,
                    chunk: u
                  }, _);
                },
                close() {
                  this.isCancelled || (this.isCancelled = !0, g.postMessage({
                    sourceName: p,
                    targetName: m,
                    stream: v.CLOSE,
                    streamId: d
                  }), delete n.streamSinks[d]);
                },
                error(u) {
                  (0, t.assert)(u instanceof Error, "error must have a valid reason"), !this.isCancelled && (this.isCancelled = !0, g.postMessage({
                    sourceName: p,
                    targetName: m,
                    stream: v.ERROR,
                    streamId: d,
                    reason: h(u)
                  }));
                },
                sinkCapability: (0, t.createPromiseCapability)(),
                onPull: null,
                onCancel: null,
                isCancelled: !1,
                desiredSize: c.desiredSize,
                ready: null
              };
              l.sinkCapability.resolve(), l.ready = l.sinkCapability.promise, this.streamSinks[d] = l, new Promise(function(u) {
                u(i(c.data, l));
              }).then(function() {
                g.postMessage({
                  sourceName: p,
                  targetName: m,
                  stream: v.START_COMPLETE,
                  streamId: d,
                  success: !0
                });
              }, function(u) {
                g.postMessage({
                  sourceName: p,
                  targetName: m,
                  stream: v.START_COMPLETE,
                  streamId: d,
                  reason: h(u)
                });
              });
            }
            _processStreamMessage(c) {
              const d = c.streamId, p = this.sourceName, m = c.sourceName, g = this.comObj, n = this.streamControllers[d], i = this.streamSinks[d];
              switch (c.stream) {
                case v.START_COMPLETE:
                  c.success ? n.startCall.resolve() : n.startCall.reject(h(c.reason));
                  break;
                case v.PULL_COMPLETE:
                  c.success ? n.pullCall.resolve() : n.pullCall.reject(h(c.reason));
                  break;
                case v.PULL:
                  if (!i) {
                    g.postMessage({
                      sourceName: p,
                      targetName: m,
                      stream: v.PULL_COMPLETE,
                      streamId: d,
                      success: !0
                    });
                    break;
                  }
                  i.desiredSize <= 0 && c.desiredSize > 0 && i.sinkCapability.resolve(), i.desiredSize = c.desiredSize, new Promise(function(l) {
                    l(i.onPull && i.onPull());
                  }).then(function() {
                    g.postMessage({
                      sourceName: p,
                      targetName: m,
                      stream: v.PULL_COMPLETE,
                      streamId: d,
                      success: !0
                    });
                  }, function(l) {
                    g.postMessage({
                      sourceName: p,
                      targetName: m,
                      stream: v.PULL_COMPLETE,
                      streamId: d,
                      reason: h(l)
                    });
                  });
                  break;
                case v.ENQUEUE:
                  if ((0, t.assert)(n, "enqueue should have stream controller"), n.isClosed)
                    break;
                  n.controller.enqueue(c.chunk);
                  break;
                case v.CLOSE:
                  if ((0, t.assert)(n, "close should have stream controller"), n.isClosed)
                    break;
                  n.isClosed = !0, n.controller.close(), this._deleteStreamController(n, d);
                  break;
                case v.ERROR:
                  (0, t.assert)(n, "error should have stream controller"), n.controller.error(h(c.reason)), this._deleteStreamController(n, d);
                  break;
                case v.CANCEL_COMPLETE:
                  c.success ? n.cancelCall.resolve() : n.cancelCall.reject(h(c.reason)), this._deleteStreamController(n, d);
                  break;
                case v.CANCEL:
                  if (!i)
                    break;
                  new Promise(function(l) {
                    l(i.onCancel && i.onCancel(h(c.reason)));
                  }).then(function() {
                    g.postMessage({
                      sourceName: p,
                      targetName: m,
                      stream: v.CANCEL_COMPLETE,
                      streamId: d,
                      success: !0
                    });
                  }, function(l) {
                    g.postMessage({
                      sourceName: p,
                      targetName: m,
                      stream: v.CANCEL_COMPLETE,
                      streamId: d,
                      reason: h(l)
                    });
                  }), i.sinkCapability.reject(h(c.reason)), i.isCancelled = !0, delete this.streamSinks[d];
                  break;
                default:
                  throw new Error("Unexpected stream case");
              }
            }
            async _deleteStreamController(c, d) {
              await Promise.allSettled([c.startCall && c.startCall.promise, c.pullCall && c.pullCall.promise, c.cancelCall && c.cancelCall.promise]), delete this.streamControllers[d];
            }
            destroy() {
              this.comObj.removeEventListener("message", this._onComObjOnMessage);
            }
          }
          o.MessageHandler = e;
        },
        /* 103 */
        /***/
        (Z, o, C) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.PDFWorkerStream = void 0;
          var t = C(2);
          class a {
            constructor(y) {
              this._msgHandler = y, this._contentLength = null, this._fullRequestReader = null, this._rangeRequestReaders = [];
            }
            getFullReader() {
              return (0, t.assert)(!this._fullRequestReader, "PDFWorkerStream.getFullReader can only be called once."), this._fullRequestReader = new v(this._msgHandler), this._fullRequestReader;
            }
            getRangeReader(y, c) {
              const d = new h(y, c, this._msgHandler);
              return this._rangeRequestReaders.push(d), d;
            }
            cancelAllRequests(y) {
              this._fullRequestReader && this._fullRequestReader.cancel(y);
              for (const c of this._rangeRequestReaders.slice(0))
                c.cancel(y);
            }
          }
          o.PDFWorkerStream = a;
          class v {
            constructor(y) {
              this._msgHandler = y, this.onProgress = null, this._contentLength = null, this._isRangeSupported = !1, this._isStreamingSupported = !1;
              const c = this._msgHandler.sendWithStream("GetReader");
              this._reader = c.getReader(), this._headersReady = this._msgHandler.sendWithPromise("ReaderHeadersReady").then((d) => {
                this._isStreamingSupported = d.isStreamingSupported, this._isRangeSupported = d.isRangeSupported, this._contentLength = d.contentLength;
              });
            }
            get headersReady() {
              return this._headersReady;
            }
            get contentLength() {
              return this._contentLength;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            get isRangeSupported() {
              return this._isRangeSupported;
            }
            async read() {
              const {
                value: y,
                done: c
              } = await this._reader.read();
              return c ? {
                value: void 0,
                done: !0
              } : {
                value: y.buffer,
                done: !1
              };
            }
            cancel(y) {
              this._reader.cancel(y);
            }
          }
          class h {
            constructor(y, c, d) {
              this._msgHandler = d, this.onProgress = null;
              const p = this._msgHandler.sendWithStream("GetRangeReader", {
                begin: y,
                end: c
              });
              this._reader = p.getReader();
            }
            get isStreamingSupported() {
              return !1;
            }
            async read() {
              const {
                value: y,
                done: c
              } = await this._reader.read();
              return c ? {
                value: void 0,
                done: !0
              } : {
                value: y.buffer,
                done: !1
              };
            }
            cancel(y) {
              this._reader.cancel(y);
            }
          }
        }
        /******/
      ], ce = {};
      function re(Z) {
        var o = ce[Z];
        if (o !== void 0)
          return o.exports;
        var C = ce[Z] = {
          /******/
          // no module.id needed
          /******/
          // no module.loaded needed
          /******/
          exports: {}
          /******/
        };
        return le[Z](C, C.exports, re), C.exports;
      }
      re.d = (Z, o) => {
        for (var C in o)
          re.o(o, C) && !re.o(Z, C) && Object.defineProperty(Z, C, { enumerable: !0, get: o[C] });
      }, re.o = (Z, o) => Object.prototype.hasOwnProperty.call(Z, o), re.r = (Z) => {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(Z, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(Z, "__esModule", { value: !0 });
      };
      var ae = {};
      return (() => {
        var Z = ae;
        Object.defineProperty(Z, "__esModule", {
          value: !0
        }), Object.defineProperty(Z, "WorkerMessageHandler", {
          enumerable: !0,
          get: function() {
            return o.WorkerMessageHandler;
          }
        });
        var o = re(1);
      })(), ae;
    })()
  ));
})(pdf_worker);
(typeof window < "u" ? window : {}).pdfjsWorker = pdf_workerExports;
const wrapper$3 = "_wrapper_118zq_1", header = "_header_118zq_6", document$1 = "_document_118zq_10", button = "_button_118zq_16", thumbnail$1 = "_thumbnail_118zq_33", s$3 = {
  wrapper: wrapper$3,
  header,
  document: document$1,
  button,
  thumbnail: thumbnail$1
};
pdfExports.GlobalWorkerOptions.workerSrc = pdf_worker_entry.workerSrc;
const PDFViewer = ({ filePath: be, isThumbnail: ge }) => {
  const [le, ce] = useState(1), [re, ae] = useState(1), Z = le > 1 && !ge;
  return /* @__PURE__ */ jsxs("div", { className: s$3.wrapper, children: [
    Z && /* @__PURE__ */ jsxs("div", { children: [
      "Page ",
      re,
      " of ",
      le
    ] }),
    /* @__PURE__ */ jsxs(
      Document,
      {
        className: s$3.document,
        file: be,
        onLoadSuccess: ({ numPages: o }) => ce(o),
        children: [
          Z && /* @__PURE__ */ jsx(
            "button",
            {
              className: s$3.button,
              onClick: () => ae(re - 1),
              disabled: re === 1,
              children: "Previous"
            }
          ),
          /* @__PURE__ */ jsx(
            Page$1,
            {
              className: `${ge ? s$3.thumbnail : ""}`,
              pageNumber: re,
              renderAnnotationLayer: !1,
              renderTextLayer: !1
            }
          ),
          Z && /* @__PURE__ */ jsx(
            "button",
            {
              className: s$3.button,
              onClick: () => ae(re + 1),
              disabled: re === le,
              children: "Next"
            }
          )
        ]
      }
    )
  ] });
};
var mammoth_browserExports = {}, mammoth_browser = {
  get exports() {
    return mammoth_browserExports;
  },
  set exports(be) {
    mammoth_browserExports = be;
  }
};
(function(be, ge) {
  (function(le) {
    be.exports = le();
  })(function() {
    return function le(ce, re, ae) {
      function Z(t, a) {
        if (!re[t]) {
          if (!ce[t]) {
            var v = typeof commonjsRequire == "function" && commonjsRequire;
            if (!a && v)
              return v(t, !0);
            if (o)
              return o(t, !0);
            var h = new Error("Cannot find module '" + t + "'");
            throw h.code = "MODULE_NOT_FOUND", h;
          }
          var e = re[t] = { exports: {} };
          ce[t][0].call(e.exports, function(y) {
            var c = ce[t][1][y];
            return Z(c || y);
          }, e, e.exports, le, ce, re, ae);
        }
        return re[t].exports;
      }
      for (var o = typeof commonjsRequire == "function" && commonjsRequire, C = 0; C < ae.length; C++)
        Z(ae[C]);
      return Z;
    }({ 1: [function(le, ce, re) {
      var ae = le("../../lib/promises");
      re.Files = Z;
      function Z() {
        function o(C) {
          return ae.reject(new Error("could not open external image: '" + C + `'
cannot open linked files from a web browser`));
        }
        return {
          read: o
        };
      }
    }, { "../../lib/promises": 23 }], 2: [function(le, ce, re) {
      var ae = le("../lib/promises"), Z = le("../lib/zipfile");
      re.openZip = o;
      function o(C) {
        return C.arrayBuffer ? ae.resolve(Z.openArrayBuffer(C.arrayBuffer)) : ae.reject(new Error("Could not find file in options"));
      }
    }, { "../lib/promises": 23, "../lib/zipfile": 39 }], 3: [function(le, ce, re) {
      var ae = le("underscore"), Z = le("./promises"), o = le("./documents"), C = le("./styles/html-paths"), t = le("./results"), a = le("./images"), v = le("./html"), h = le("./writers");
      re.DocumentConverter = e;
      function e(i) {
        return {
          convertToHtml: function(l) {
            var u = ae.indexBy(
              l.type === o.types.document ? l.comments : [],
              "commentId"
            ), w = new y(i, u);
            return w.convertToHtml(l);
          }
        };
      }
      function y(i, l) {
        var u = 1, w = [], _ = [];
        i = ae.extend({ ignoreEmptyParagraphs: !0 }, i);
        var b = i.idPrefix === void 0 ? "" : i.idPrefix, A = i.ignoreEmptyParagraphs, Y = C.topLevelElement("p"), j = i.styleMap || [];
        function X(D) {
          var ne = [], oe = R(D, ne, {}), ee = [];
          g(oe, function(E) {
            E.type === "deferred" && ee.push(E);
          });
          var $ = {};
          return Z.mapSeries(ee, function(E) {
            return E.value().then(function(H) {
              $[E.id] = H;
            });
          }).then(function() {
            function E(ie) {
              return m(ie, function(ue) {
                return ue.type === "deferred" ? $[ue.id] : ue.children ? [
                  ae.extend({}, ue, {
                    children: E(ue.children)
                  })
                ] : [ue];
              });
            }
            var H = h.writer({
              prettyPrint: i.prettyPrint,
              outputFormat: i.outputFormat
            });
            return v.write(H, v.simplify(E(oe))), new t.Result(H.asString(), ne);
          });
        }
        function B(D, ne, oe) {
          return m(D, function(ee) {
            return R(ee, ne, oe);
          });
        }
        function R(D, ne, oe) {
          if (!oe)
            throw new Error("options not set");
          var ee = Q[D.type];
          return ee ? ee(D, ne, oe) : [];
        }
        function k(D, ne, oe) {
          return x(D, ne).wrap(function() {
            var ee = B(D.children, ne, oe);
            return A ? ee : [v.forceWrite].concat(ee);
          });
        }
        function x(D, ne) {
          var oe = S(D);
          return oe ? oe.to : (D.styleId && ne.push(p("paragraph", D)), Y);
        }
        function f(D, ne, oe) {
          var ee = function() {
            return B(D.children, ne, oe);
          }, $ = [];
          D.isSmallCaps && $.push(U("smallCaps")), D.isAllCaps && $.push(U("allCaps")), D.isStrikethrough && $.push(U("strikethrough", "s")), D.isUnderline && $.push(U("underline")), D.verticalAlignment === o.verticalAlignment.subscript && $.push(C.element("sub", {}, { fresh: !1 })), D.verticalAlignment === o.verticalAlignment.superscript && $.push(C.element("sup", {}, { fresh: !1 })), D.isItalic && $.push(U("italic", "em")), D.isBold && $.push(U("bold", "strong"));
          var E = C.empty, H = S(D);
          return H ? E = H.to : D.styleId && ne.push(p("run", D)), $.push(E), $.forEach(function(ie) {
            ee = ie.wrap.bind(ie, ee);
          }), ee();
        }
        function U(D, ne) {
          var oe = O({ type: D });
          return oe || (ne ? C.element(ne, {}, { fresh: !1 }) : C.empty);
        }
        function O(D, ne) {
          var oe = S(D);
          return oe ? oe.to : ne;
        }
        function S(D) {
          for (var ne = 0; ne < j.length; ne++)
            if (j[ne].from.matches(D))
              return j[ne];
        }
        function F(D) {
          return function(ne, oe) {
            return Z.attempt(function() {
              return D(ne, oe);
            }).caught(function(ee) {
              return oe.push(t.error(ee)), [];
            });
          };
        }
        function T(D) {
          return M(D.noteType, D.noteId);
        }
        function I(D) {
          return V(D.noteType, D.noteId);
        }
        function M(D, ne) {
          return J(D + "-" + ne);
        }
        function V(D, ne) {
          return J(D + "-ref-" + ne);
        }
        function J(D) {
          return b + D;
        }
        var W = C.elements([
          C.element("table", {}, { fresh: !0 })
        ]);
        function z(D, ne, oe) {
          return O(D, W).wrap(function() {
            return G(D, ne, oe);
          });
        }
        function G(D, ne, oe) {
          var ee = ae.findIndex(D.children, function(ie) {
            return !ie.type === o.types.tableRow || !ie.isHeader;
          });
          ee === -1 && (ee = D.children.length);
          var $;
          if (ee === 0)
            $ = B(
              D.children,
              ne,
              ae.extend({}, oe, { isTableHeader: !1 })
            );
          else {
            var E = B(
              D.children.slice(0, ee),
              ne,
              ae.extend({}, oe, { isTableHeader: !0 })
            ), H = B(
              D.children.slice(ee),
              ne,
              ae.extend({}, oe, { isTableHeader: !1 })
            );
            $ = [
              v.freshElement("thead", {}, E),
              v.freshElement("tbody", {}, H)
            ];
          }
          return [v.forceWrite].concat($);
        }
        function L(D, ne, oe) {
          var ee = B(D.children, ne, oe);
          return [
            v.freshElement("tr", {}, [v.forceWrite].concat(ee))
          ];
        }
        function K(D, ne, oe) {
          var ee = oe.isTableHeader ? "th" : "td", $ = B(D.children, ne, oe), E = {};
          return D.colSpan !== 1 && (E.colspan = D.colSpan.toString()), D.rowSpan !== 1 && (E.rowspan = D.rowSpan.toString()), [
            v.freshElement(ee, E, [v.forceWrite].concat($))
          ];
        }
        function te(D, ne, oe) {
          return O(D, C.ignore).wrap(function() {
            var ee = l[D.commentId], $ = _.length + 1, E = "[" + n(ee) + $ + "]";
            return _.push({ label: E, comment: ee }), [
              v.freshElement("a", {
                href: "#" + M("comment", D.commentId),
                id: V("comment", D.commentId)
              }, [v.text(E)])
            ];
          });
        }
        function se(D, ne, oe) {
          var ee = D.label, $ = D.comment, E = B($.body, ne, oe).concat([
            v.nonFreshElement("p", {}, [
              v.text(" "),
              v.freshElement("a", { href: "#" + V("comment", $.commentId) }, [
                v.text("↑")
              ])
            ])
          ]);
          return [
            v.freshElement(
              "dt",
              { id: M("comment", $.commentId) },
              [v.text("Comment " + ee)]
            ),
            v.freshElement("dd", {}, E)
          ];
        }
        function q(D, ne, oe) {
          return N(D).wrap(function() {
            return [];
          });
        }
        function N(D) {
          var ne = S(D);
          return ne ? ne.to : D.breakType === "line" ? C.topLevelElement("br") : C.empty;
        }
        var Q = {
          document: function(D, ne, oe) {
            var ee = B(D.children, ne, oe), $ = w.map(function(H) {
              return D.notes.resolve(H);
            }), E = B($, ne, oe);
            return ee.concat([
              v.freshElement("ol", {}, E),
              v.freshElement("dl", {}, m(_, function(H) {
                return se(H, ne, oe);
              }))
            ]);
          },
          paragraph: k,
          run: f,
          text: function(D, ne, oe) {
            return [v.text(D.value)];
          },
          tab: function(D, ne, oe) {
            return [v.text("	")];
          },
          hyperlink: function(D, ne, oe) {
            var ee = D.anchor ? "#" + J(D.anchor) : D.href, $ = { href: ee };
            D.targetFrame != null && ($.target = D.targetFrame);
            var E = B(D.children, ne, oe);
            return [v.nonFreshElement("a", $, E)];
          },
          bookmarkStart: function(D, ne, oe) {
            var ee = v.freshElement("a", {
              id: J(D.name)
            }, [v.forceWrite]);
            return [ee];
          },
          noteReference: function(D, ne, oe) {
            w.push(D);
            var ee = v.freshElement("a", {
              href: "#" + T(D),
              id: I(D)
            }, [v.text("[" + u++ + "]")]);
            return [v.freshElement("sup", {}, [ee])];
          },
          note: function(D, ne, oe) {
            var ee = B(D.body, ne, oe), $ = v.elementWithTag(C.element("p", {}, { fresh: !1 }), [
              v.text(" "),
              v.freshElement("a", { href: "#" + I(D) }, [v.text("↑")])
            ]), E = ee.concat([$]);
            return v.freshElement("li", { id: T(D) }, E);
          },
          commentReference: te,
          comment: se,
          image: d(F(i.convertImage || a.dataUri)),
          table: z,
          tableRow: L,
          tableCell: K,
          break: q
        };
        return {
          convertToHtml: X
        };
      }
      var c = 1;
      function d(i) {
        return function(l, u, w) {
          return [
            {
              type: "deferred",
              id: c++,
              value: function() {
                return i(l, u, w);
              }
            }
          ];
        };
      }
      function p(i, l) {
        return t.warning(
          "Unrecognised " + i + " style: '" + l.styleName + "' (Style ID: " + l.styleId + ")"
        );
      }
      function m(i, l) {
        return ae.flatten(i.map(l), !0);
      }
      function g(i, l) {
        i.forEach(function(u) {
          l(u), u.children && g(u.children, l);
        });
      }
      var n = re.commentAuthorLabel = function(l) {
        return l.authorInitials || "";
      };
    }, { "./documents": 4, "./html": 18, "./images": 20, "./promises": 23, "./results": 25, "./styles/html-paths": 28, "./writers": 33, underscore: 117 }], 4: [function(le, ce, re) {
      var ae = le("underscore"), Z = re.types = {
        document: "document",
        paragraph: "paragraph",
        run: "run",
        text: "text",
        tab: "tab",
        hyperlink: "hyperlink",
        noteReference: "noteReference",
        image: "image",
        note: "note",
        commentReference: "commentReference",
        comment: "comment",
        table: "table",
        tableRow: "tableRow",
        tableCell: "tableCell",
        break: "break",
        bookmarkStart: "bookmarkStart"
      };
      function o(b, A) {
        return A = A || {}, {
          type: Z.document,
          children: b,
          notes: A.notes || new c({}),
          comments: A.comments || []
        };
      }
      function C(b, A) {
        A = A || {};
        var Y = A.indent || {};
        return {
          type: Z.paragraph,
          children: b,
          styleId: A.styleId || null,
          styleName: A.styleName || null,
          numbering: A.numbering || null,
          alignment: A.alignment || null,
          indent: {
            start: Y.start || null,
            end: Y.end || null,
            firstLine: Y.firstLine || null,
            hanging: Y.hanging || null
          }
        };
      }
      function t(b, A) {
        return A = A || {}, {
          type: Z.run,
          children: b,
          styleId: A.styleId || null,
          styleName: A.styleName || null,
          isBold: A.isBold,
          isUnderline: A.isUnderline,
          isItalic: A.isItalic,
          isStrikethrough: A.isStrikethrough,
          isAllCaps: A.isAllCaps,
          isSmallCaps: A.isSmallCaps,
          verticalAlignment: A.verticalAlignment || a.baseline,
          font: A.font || null,
          fontSize: A.fontSize || null
        };
      }
      var a = {
        baseline: "baseline",
        superscript: "superscript",
        subscript: "subscript"
      };
      function v(b) {
        return {
          type: Z.text,
          value: b
        };
      }
      function h() {
        return {
          type: Z.tab
        };
      }
      function e(b, A) {
        return {
          type: Z.hyperlink,
          children: b,
          href: A.href,
          anchor: A.anchor,
          targetFrame: A.targetFrame
        };
      }
      function y(b) {
        return {
          type: Z.noteReference,
          noteType: b.noteType,
          noteId: b.noteId
        };
      }
      function c(b) {
        this._notes = ae.indexBy(b, function(A) {
          return g(A.noteType, A.noteId);
        });
      }
      c.prototype.resolve = function(b) {
        return this.findNoteByKey(g(b.noteType, b.noteId));
      }, c.prototype.findNoteByKey = function(b) {
        return this._notes[b] || null;
      };
      function d(b) {
        return {
          type: Z.note,
          noteType: b.noteType,
          noteId: b.noteId,
          body: b.body
        };
      }
      function p(b) {
        return {
          type: Z.commentReference,
          commentId: b.commentId
        };
      }
      function m(b) {
        return {
          type: Z.comment,
          commentId: b.commentId,
          body: b.body,
          authorName: b.authorName,
          authorInitials: b.authorInitials
        };
      }
      function g(b, A) {
        return b + "-" + A;
      }
      function n(b) {
        return {
          type: Z.image,
          read: b.readImage,
          altText: b.altText,
          contentType: b.contentType
        };
      }
      function i(b, A) {
        return A = A || {}, {
          type: Z.table,
          children: b,
          styleId: A.styleId || null,
          styleName: A.styleName || null
        };
      }
      function l(b, A) {
        return A = A || {}, {
          type: Z.tableRow,
          children: b,
          isHeader: A.isHeader || !1
        };
      }
      function u(b, A) {
        return A = A || {}, {
          type: Z.tableCell,
          children: b,
          colSpan: A.colSpan == null ? 1 : A.colSpan,
          rowSpan: A.rowSpan == null ? 1 : A.rowSpan
        };
      }
      function w(b) {
        return {
          type: Z.break,
          breakType: b
        };
      }
      function _(b) {
        return {
          type: Z.bookmarkStart,
          name: b.name
        };
      }
      re.document = re.Document = o, re.paragraph = re.Paragraph = C, re.run = re.Run = t, re.Text = v, re.tab = re.Tab = h, re.Hyperlink = e, re.noteReference = re.NoteReference = y, re.Notes = c, re.Note = d, re.commentReference = p, re.comment = m, re.Image = n, re.Table = i, re.TableRow = l, re.TableCell = u, re.lineBreak = w("line"), re.pageBreak = w("page"), re.columnBreak = w("column"), re.BookmarkStart = _, re.verticalAlignment = a;
    }, { underscore: 117 }], 5: [function(le, ce, re) {
      re.createBodyReader = v, re._readNumberingProperties = e;
      var ae = le("dingbat-to-unicode"), Z = le("underscore"), o = le("../documents"), C = le("../results").Result, t = le("../results").warning, a = le("./uris");
      function v(A) {
        return {
          readXmlElement: function(Y) {
            return new h(A).readXmlElement(Y);
          },
          readXmlElements: function(Y) {
            return new h(A).readXmlElements(Y);
          }
        };
      }
      function h(A) {
        var Y = [], j = [], X = A.relationships, B = A.contentTypes, R = A.docxFile, k = A.files, x = A.numbering, f = A.styles;
        function U(Se) {
          var ke = Se.map(O);
          return w(ke);
        }
        function O(Se) {
          if (Se.type === "element") {
            var ke = D[Se.name];
            if (ke)
              return ke(Se);
            if (!Object.prototype.hasOwnProperty.call(c, Se.name)) {
              var ye = t("An unrecognised element was ignored: " + Se.name);
              return g([ye]);
            }
          }
          return n();
        }
        function S(Se) {
          return {
            start: Se.attributes["w:start"] || Se.attributes["w:left"],
            end: Se.attributes["w:end"] || Se.attributes["w:right"],
            firstLine: Se.attributes["w:firstLine"],
            hanging: Se.attributes["w:hanging"]
          };
        }
        function F(Se) {
          return V(Se).map(function(ke) {
            var ye = Se.firstOrEmpty("w:sz").attributes["w:val"], _e = /^[0-9]+$/.test(ye) ? parseInt(ye, 10) / 2 : null;
            return {
              type: "runProperties",
              styleId: ke.styleId,
              styleName: ke.name,
              verticalAlignment: Se.firstOrEmpty("w:vertAlign").attributes["w:val"],
              font: Se.firstOrEmpty("w:rFonts").attributes["w:ascii"],
              fontSize: _e,
              isBold: I(Se.first("w:b")),
              isUnderline: T(Se.first("w:u")),
              isItalic: I(Se.first("w:i")),
              isStrikethrough: I(Se.first("w:strike")),
              isAllCaps: I(Se.first("w:caps")),
              isSmallCaps: I(Se.first("w:smallCaps"))
            };
          });
        }
        function T(Se) {
          if (Se) {
            var ke = Se.attributes["w:val"];
            return ke !== void 0 && ke !== "false" && ke !== "0" && ke !== "none";
          } else
            return !1;
        }
        function I(Se) {
          if (Se) {
            var ke = Se.attributes["w:val"];
            return ke !== "false" && ke !== "0";
          } else
            return !1;
        }
        function M(Se) {
          return W(Se, "w:pStyle", "Paragraph", f.findParagraphStyleById);
        }
        function V(Se) {
          return W(Se, "w:rStyle", "Run", f.findCharacterStyleById);
        }
        function J(Se) {
          return W(Se, "w:tblStyle", "Table", f.findTableStyleById);
        }
        function W(Se, ke, ye, _e) {
          var we = [], Ce = Se.first(ke), ve = null, Le = null;
          if (Ce && (ve = Ce.attributes["w:val"], ve)) {
            var He = _e(ve);
            He ? Le = He.name : we.push(Ae(ye, ve));
          }
          return l({ styleId: ve, name: Le }, we);
        }
        var z = { type: "unknown" };
        function G(Se) {
          var ke = Se.attributes["w:fldCharType"];
          if (ke === "begin")
            Y.push(z), j = [];
          else if (ke === "end")
            Y.pop();
          else if (ke === "separate") {
            var ye = K(j.join("")), _e = ye === null ? z : { type: "hyperlink", options: ye };
            Y.pop(), Y.push(_e);
          }
          return n();
        }
        function L() {
          var Se = Z.last(Y.filter(function(ke) {
            return ke.type === "hyperlink";
          }));
          return Se ? Se.options : null;
        }
        function K(Se) {
          var ke = /\s*HYPERLINK "(.*)"/.exec(Se);
          if (ke)
            return { href: ke[1] };
          var ye = /\s*HYPERLINK\s+\\l\s+"(.*)"/.exec(Se);
          return ye ? { anchor: ye[1] } : null;
        }
        function te(Se) {
          return j.push(Se.text()), n();
        }
        function se(Se) {
          var ke = Se.attributes["w:font"], ye = Se.attributes["w:char"], _e = ae.hex(ke, ye);
          return _e == null && /^F0..$/.test(ye) && (_e = ae.hex(ke, ye.substring(2))), _e == null ? g([t(
            "A w:sym element with an unsupported character was ignored: char " + ye + " in font " + ke
          )]) : i(new o.Text(_e.string));
        }
        function q(Se) {
          return function(ke) {
            var ye = ke.attributes["w:id"];
            return i(new o.NoteReference({
              noteType: Se,
              noteId: ye
            }));
          };
        }
        function N(Se) {
          return i(o.commentReference({
            commentId: Se.attributes["w:id"]
          }));
        }
        function Q(Se) {
          return U(Se.children);
        }
        var D = {
          "w:p": function(Se) {
            return U(Se.children).map(function(ke) {
              var ye = Z.find(ke, d);
              return new o.Paragraph(
                ke.filter(m(d)),
                ye
              );
            }).insertExtra();
          },
          "w:pPr": function(Se) {
            return M(Se).map(function(ke) {
              return {
                type: "paragraphProperties",
                styleId: ke.styleId,
                styleName: ke.name,
                alignment: Se.firstOrEmpty("w:jc").attributes["w:val"],
                numbering: e(ke.styleId, Se.firstOrEmpty("w:numPr"), x),
                indent: S(Se.firstOrEmpty("w:ind"))
              };
            });
          },
          "w:r": function(Se) {
            return U(Se.children).map(function(ke) {
              var ye = Z.find(ke, p);
              ke = ke.filter(m(p));
              var _e = L();
              return _e !== null && (ke = [new o.Hyperlink(ke, _e)]), new o.Run(ke, ye);
            });
          },
          "w:rPr": F,
          "w:fldChar": G,
          "w:instrText": te,
          "w:t": function(Se) {
            return i(new o.Text(Se.text()));
          },
          "w:tab": function(Se) {
            return i(new o.Tab());
          },
          "w:noBreakHyphen": function() {
            return i(new o.Text("‑"));
          },
          "w:softHyphen": function(Se) {
            return i(new o.Text("­"));
          },
          "w:sym": se,
          "w:hyperlink": function(Se) {
            var ke = Se.attributes["r:id"], ye = Se.attributes["w:anchor"];
            return U(Se.children).map(function(_e) {
              function we(ve) {
                var Le = Se.attributes["w:tgtFrame"] || null;
                return new o.Hyperlink(
                  _e,
                  Z.extend({ targetFrame: Le }, ve)
                );
              }
              if (ke) {
                var Ce = X.findTargetByRelationshipId(ke);
                return ye && (Ce = a.replaceFragment(Ce, ye)), we({ href: Ce });
              } else
                return ye ? we({ anchor: ye }) : _e;
            });
          },
          "w:tbl": ne,
          "w:tr": ee,
          "w:tc": $,
          "w:footnoteReference": q("footnote"),
          "w:endnoteReference": q("endnote"),
          "w:commentReference": N,
          "w:br": function(Se) {
            var ke = Se.attributes["w:type"];
            return ke == null || ke === "textWrapping" ? i(o.lineBreak) : ke === "page" ? i(o.pageBreak) : ke === "column" ? i(o.columnBreak) : g([t("Unsupported break type: " + ke)]);
          },
          "w:bookmarkStart": function(Se) {
            var ke = Se.attributes["w:name"];
            return ke === "_GoBack" ? n() : i(new o.BookmarkStart({ name: ke }));
          },
          "mc:AlternateContent": function(Se) {
            return Q(Se.first("mc:Fallback"));
          },
          "w:sdt": function(Se) {
            return U(Se.firstOrEmpty("w:sdtContent").children);
          },
          "w:ins": Q,
          "w:object": Q,
          "w:smartTag": Q,
          "w:drawing": Q,
          "w:pict": function(Se) {
            return Q(Se).toExtra();
          },
          "v:roundrect": Q,
          "v:shape": Q,
          "v:textbox": Q,
          "w:txbxContent": Q,
          "wp:inline": ie,
          "wp:anchor": ie,
          "v:imagedata": pe,
          "v:group": Q,
          "v:rect": Q
        };
        return {
          readXmlElement: O,
          readXmlElements: U
        };
        function ne(Se) {
          var ke = oe(Se.firstOrEmpty("w:tblPr"));
          return U(Se.children).flatMap(H).flatMap(function(ye) {
            return ke.map(function(_e) {
              return o.Table(ye, _e);
            });
          });
        }
        function oe(Se) {
          return J(Se).map(function(ke) {
            return {
              styleId: ke.styleId,
              styleName: ke.name
            };
          });
        }
        function ee(Se) {
          var ke = Se.firstOrEmpty("w:trPr"), ye = !!ke.first("w:tblHeader");
          return U(Se.children).map(function(_e) {
            return o.TableRow(_e, { isHeader: ye });
          });
        }
        function $(Se) {
          return U(Se.children).map(function(ke) {
            var ye = Se.firstOrEmpty("w:tcPr"), _e = ye.firstOrEmpty("w:gridSpan").attributes["w:val"], we = _e ? parseInt(_e, 10) : 1, Ce = o.TableCell(ke, { colSpan: we });
            return Ce._vMerge = E(ye), Ce;
          });
        }
        function E(Se) {
          var ke = Se.first("w:vMerge");
          if (ke) {
            var ye = ke.attributes["w:val"];
            return ye === "continue" || !ye;
          } else
            return null;
        }
        function H(Se) {
          var ke = Z.any(Se, function(we) {
            return we.type !== o.types.tableRow;
          });
          if (ke)
            return l(Se, [t(
              "unexpected non-row element in table, cell merging may be incorrect"
            )]);
          var ye = Z.any(Se, function(we) {
            return Z.any(we.children, function(Ce) {
              return Ce.type !== o.types.tableCell;
            });
          });
          if (ye)
            return l(Se, [t(
              "unexpected non-cell element in table row, cell merging may be incorrect"
            )]);
          var _e = {};
          return Se.forEach(function(we) {
            var Ce = 0;
            we.children.forEach(function(ve) {
              ve._vMerge && _e[Ce] ? _e[Ce].rowSpan++ : (_e[Ce] = ve, ve._vMerge = !1), Ce += ve.colSpan;
            });
          }), Se.forEach(function(we) {
            we.children = we.children.filter(function(Ce) {
              return !Ce._vMerge;
            }), we.children.forEach(function(Ce) {
              delete Ce._vMerge;
            });
          }), i(Se);
        }
        function ie(Se) {
          var ke = Se.getElementsByTagName("a:graphic").getElementsByTagName("a:graphicData").getElementsByTagName("pic:pic").getElementsByTagName("pic:blipFill").getElementsByTagName("a:blip");
          return w(ke.map(ue.bind(null, Se)));
        }
        function ue(Se, ke) {
          var ye = Se.first("wp:docPr").attributes, _e = fe(ye.descr) ? ye.title : ye.descr, we = de(ke);
          return we === null ? g([t("Could not find image file for a:blip element")]) : De(we, _e);
        }
        function fe(Se) {
          return Se == null || /^\s*$/.test(Se);
        }
        function de(Se) {
          var ke = Se.attributes["r:embed"], ye = Se.attributes["r:link"];
          if (ke)
            return xe(ke);
          if (ye) {
            var _e = X.findTargetByRelationshipId(ye);
            return {
              path: _e,
              read: k.read.bind(k, _e)
            };
          } else
            return null;
        }
        function pe(Se) {
          var ke = Se.attributes["r:id"];
          return ke ? De(
            xe(ke),
            Se.attributes["o:title"]
          ) : g([t("A v:imagedata element without a relationship ID was ignored")]);
        }
        function xe(Se) {
          var ke = a.uriToZipEntryName("word", X.findTargetByRelationshipId(Se));
          return {
            path: ke,
            read: R.read.bind(R, ke)
          };
        }
        function De(Se, ke) {
          var ye = B.findContentType(Se.path), _e = o.Image({
            readImage: Se.read,
            altText: ke,
            contentType: ye
          }), we = y[ye] ? [] : t("Image of type " + ye + " is unlikely to display in web browsers");
          return l(_e, we);
        }
        function Ae(Se, ke) {
          return t(
            Se + " style with ID " + ke + " was referenced but not defined in the document"
          );
        }
      }
      function e(A, Y, j) {
        if (A != null) {
          var X = j.findLevelByParagraphStyleId(A);
          if (X != null)
            return X;
        }
        var B = Y.firstOrEmpty("w:ilvl").attributes["w:val"], R = Y.firstOrEmpty("w:numId").attributes["w:val"];
        return B === void 0 || R === void 0 ? null : j.findLevel(R, B);
      }
      var y = {
        "image/png": !0,
        "image/gif": !0,
        "image/jpeg": !0,
        "image/svg+xml": !0,
        "image/tiff": !0
      }, c = {
        "office-word:wrap": !0,
        "v:shadow": !0,
        "v:shapetype": !0,
        "w:annotationRef": !0,
        "w:bookmarkEnd": !0,
        "w:sectPr": !0,
        "w:proofErr": !0,
        "w:lastRenderedPageBreak": !0,
        "w:commentRangeStart": !0,
        "w:commentRangeEnd": !0,
        "w:del": !0,
        "w:footnoteRef": !0,
        "w:endnoteRef": !0,
        "w:tblPr": !0,
        "w:tblGrid": !0,
        "w:trPr": !0,
        "w:tcPr": !0
      };
      function d(A) {
        return A.type === "paragraphProperties";
      }
      function p(A) {
        return A.type === "runProperties";
      }
      function m(A) {
        return function(Y) {
          return !A(Y);
        };
      }
      function g(A) {
        return new u(null, null, A);
      }
      function n() {
        return new u(null);
      }
      function i(A) {
        return new u(A);
      }
      function l(A, Y) {
        return new u(A, null, Y);
      }
      function u(A, Y, j) {
        this.value = A || [], this.extra = Y, this._result = new C({
          element: this.value,
          extra: Y
        }, j), this.messages = this._result.messages;
      }
      u.prototype.toExtra = function() {
        return new u(null, _(this.extra, this.value), this.messages);
      }, u.prototype.insertExtra = function() {
        var A = this.extra;
        return A && A.length ? new u(_(this.value, A), null, this.messages) : this;
      }, u.prototype.map = function(A) {
        var Y = this._result.map(function(j) {
          return A(j.element);
        });
        return new u(Y.value, this.extra, Y.messages);
      }, u.prototype.flatMap = function(A) {
        var Y = this._result.flatMap(function(j) {
          return A(j.element)._result;
        });
        return new u(Y.value.element, _(this.extra, Y.value.extra), Y.messages);
      };
      function w(A) {
        var Y = C.combine(Z.pluck(A, "_result"));
        return new u(
          Z.flatten(Z.pluck(Y.value, "element")),
          Z.filter(Z.flatten(Z.pluck(Y.value, "extra")), b),
          Y.messages
        );
      }
      function _(A, Y) {
        return Z.flatten([A, Y]);
      }
      function b(A) {
        return A;
      }
    }, { "../documents": 4, "../results": 25, "./uris": 16, "dingbat-to-unicode": 81, underscore: 117 }], 6: [function(le, ce, re) {
      var ae = le("../documents"), Z = le("../results").Result;
      function o(C) {
        function t(v) {
          return Z.combine(v.getElementsByTagName("w:comment").map(a));
        }
        function a(v) {
          var h = v.attributes["w:id"];
          function e(y) {
            return (v.attributes[y] || "").trim() || null;
          }
          return C.readXmlElements(v.children).map(function(y) {
            return ae.comment({
              commentId: h,
              body: y,
              authorName: e("w:author"),
              authorInitials: e("w:initials")
            });
          });
        }
        return t;
      }
      re.createCommentsReader = o;
    }, { "../documents": 4, "../results": 25 }], 7: [function(le, ce, re) {
      re.readContentTypesFromXml = Z;
      var ae = {
        png: "png",
        gif: "gif",
        jpeg: "jpeg",
        jpg: "jpeg",
        tif: "tiff",
        tiff: "tiff",
        bmp: "bmp"
      };
      re.defaultContentTypes = o({}, {});
      function Z(C) {
        var t = {}, a = {};
        return C.children.forEach(function(v) {
          if (v.name === "content-types:Default" && (t[v.attributes.Extension] = v.attributes.ContentType), v.name === "content-types:Override") {
            var h = v.attributes.PartName;
            h.charAt(0) === "/" && (h = h.substring(1)), a[h] = v.attributes.ContentType;
          }
        }), o(a, t);
      }
      function o(C, t) {
        return {
          findContentType: function(a) {
            var v = C[a];
            if (v)
              return v;
            var h = a.split("."), e = h[h.length - 1];
            if (t.hasOwnProperty(e))
              return t[e];
            var y = ae[e.toLowerCase()];
            return y ? "image/" + y : null;
          }
        };
      }
    }, {}], 8: [function(le, ce, re) {
      re.DocumentXmlReader = o;
      var ae = le("../documents"), Z = le("../results").Result;
      function o(C) {
        var t = C.bodyReader;
        function a(v) {
          var h = v.first("w:body"), e = t.readXmlElements(h.children).map(function(y) {
            return new ae.Document(y, {
              notes: C.notes,
              comments: C.comments
            });
          });
          return new Z(e.value, e.messages);
        }
        return {
          convertXmlToDocument: a
        };
      }
    }, { "../documents": 4, "../results": 25 }], 9: [function(le, ce, re) {
      re.read = n, re._findPartPaths = i;
      var ae = le("path"), Z = le("../promises"), o = le("../documents"), C = le("../results").Result, t = le("../zipfile"), a = le("./office-xml-reader").readXmlFromZipFile, v = le("./body-reader").createBodyReader, h = le("./document-xml-reader").DocumentXmlReader, e = le("./relationships-reader"), y = le("./content-types-reader"), c = le("./numbering-xml"), d = le("./styles-reader"), p = le("./notes-reader"), m = le("./comments-reader"), g = le("./files").Files;
      function n(B, R) {
        return R = R || {}, Z.props({
          contentTypes: A(B),
          partPaths: i(B),
          docxFile: B,
          files: new g(R.path ? ae.dirname(R.path) : null)
        }).also(function(k) {
          return {
            styles: j(B, k.partPaths.styles)
          };
        }).also(function(k) {
          return {
            numbering: Y(B, k.partPaths.numbering, k.styles)
          };
        }).also(function(k) {
          return {
            footnotes: _(k.partPaths.footnotes, k, function(x, f) {
              return f ? p.createFootnotesReader(x)(f) : new C([]);
            }),
            endnotes: _(k.partPaths.endnotes, k, function(x, f) {
              return f ? p.createEndnotesReader(x)(f) : new C([]);
            }),
            comments: _(k.partPaths.comments, k, function(x, f) {
              return f ? m.createCommentsReader(x)(f) : new C([]);
            })
          };
        }).also(function(k) {
          return {
            notes: k.footnotes.flatMap(function(x) {
              return k.endnotes.map(function(f) {
                return new o.Notes(x.concat(f));
              });
            })
          };
        }).then(function(k) {
          return _(k.partPaths.mainDocument, k, function(x, f) {
            return k.notes.flatMap(function(U) {
              return k.comments.flatMap(function(O) {
                var S = new h({
                  bodyReader: x,
                  notes: U,
                  comments: O
                });
                return S.convertXmlToDocument(f);
              });
            });
          });
        });
      }
      function i(B) {
        return X(B).then(function(R) {
          var k = l({
            docxFile: B,
            relationships: R,
            relationshipType: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
            basePath: "",
            fallbackPath: "word/document.xml"
          });
          if (!B.exists(k))
            throw new Error("Could not find main document part. Are you sure this is a valid .docx file?");
          return w({
            filename: b(k),
            readElement: e.readRelationships,
            defaultValue: e.defaultValue
          })(B).then(function(x) {
            function f(U) {
              return l({
                docxFile: B,
                relationships: x,
                relationshipType: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/" + U,
                basePath: t.splitPath(k).dirname,
                fallbackPath: "word/" + U + ".xml"
              });
            }
            return {
              mainDocument: k,
              comments: f("comments"),
              endnotes: f("endnotes"),
              footnotes: f("footnotes"),
              numbering: f("numbering"),
              styles: f("styles")
            };
          });
        });
      }
      function l(B) {
        var R = B.docxFile, k = B.relationships, x = B.relationshipType, f = B.basePath, U = B.fallbackPath, O = k.findTargetsByType(x), S = O.map(function(T) {
          return u(t.joinPath(f, T), "/");
        }), F = S.filter(function(T) {
          return R.exists(T);
        });
        return F.length === 0 ? U : F[0];
      }
      function u(B, R) {
        return B.substring(0, R.length) === R ? B.substring(R.length) : B;
      }
      function w(B) {
        return function(R) {
          return a(R, B.filename).then(function(k) {
            return k ? B.readElement(k) : B.defaultValue;
          });
        };
      }
      function _(B, R, k) {
        var x = w({
          filename: b(B),
          readElement: e.readRelationships,
          defaultValue: e.defaultValue
        });
        return x(R.docxFile).then(function(f) {
          var U = new v({
            relationships: f,
            contentTypes: R.contentTypes,
            docxFile: R.docxFile,
            numbering: R.numbering,
            styles: R.styles,
            files: R.files
          });
          return a(R.docxFile, B).then(function(O) {
            return k(U, O);
          });
        });
      }
      function b(B) {
        var R = t.splitPath(B);
        return t.joinPath(R.dirname, "_rels", R.basename + ".rels");
      }
      var A = w({
        filename: "[Content_Types].xml",
        readElement: y.readContentTypesFromXml,
        defaultValue: y.defaultContentTypes
      });
      function Y(B, R, k) {
        return w({
          filename: R,
          readElement: function(x) {
            return c.readNumberingXml(x, { styles: k });
          },
          defaultValue: c.defaultNumbering
        })(B);
      }
      function j(B, R) {
        return w({
          filename: R,
          readElement: d.readStylesXml,
          defaultValue: d.defaultStyles
        })(B);
      }
      var X = w({
        filename: "_rels/.rels",
        readElement: e.readRelationships,
        defaultValue: e.defaultValue
      });
    }, { "../documents": 4, "../promises": 23, "../results": 25, "../zipfile": 39, "./body-reader": 5, "./comments-reader": 6, "./content-types-reader": 7, "./document-xml-reader": 8, "./files": 1, "./notes-reader": 10, "./numbering-xml": 11, "./office-xml-reader": 12, "./relationships-reader": 13, "./styles-reader": 15, path: 100 }], 10: [function(le, ce, re) {
      var ae = le("../documents"), Z = le("../results").Result;
      re.createFootnotesReader = o.bind(this, "footnote"), re.createEndnotesReader = o.bind(this, "endnote");
      function o(C, t) {
        function a(e) {
          return Z.combine(e.getElementsByTagName("w:" + C).filter(v).map(h));
        }
        function v(e) {
          var y = e.attributes["w:type"];
          return y !== "continuationSeparator" && y !== "separator";
        }
        function h(e) {
          var y = e.attributes["w:id"];
          return t.readXmlElements(e.children).map(function(c) {
            return ae.Note({ noteType: C, noteId: y, body: c });
          });
        }
        return a;
      }
    }, { "../documents": 4, "../results": 25 }], 11: [function(le, ce, re) {
      var ae = le("underscore");
      re.readNumberingXml = o, re.Numbering = Z, re.defaultNumbering = new Z({}, {});
      function Z(v, h, e) {
        var y = ae.flatten(ae.values(h).map(function(m) {
          return ae.values(m.levels);
        })), c = ae.indexBy(
          y.filter(function(m) {
            return m.paragraphStyleId != null;
          }),
          "paragraphStyleId"
        );
        function d(m, g) {
          var n = v[m];
          if (n) {
            var i = h[n.abstractNumId];
            if (i) {
              if (i.numStyleLink == null)
                return h[n.abstractNumId].levels[g];
              var l = e.findNumberingStyleById(i.numStyleLink);
              return d(l.numId, g);
            } else
              return null;
          } else
            return null;
        }
        function p(m) {
          return c[m] || null;
        }
        return {
          findLevel: d,
          findLevelByParagraphStyleId: p
        };
      }
      function o(v, h) {
        if (!h || !h.styles)
          throw new Error("styles is missing");
        var e = C(v), y = a(v);
        return new Z(y, e, h.styles);
      }
      function C(v) {
        var h = {};
        return v.getElementsByTagName("w:abstractNum").forEach(function(e) {
          var y = e.attributes["w:abstractNumId"];
          h[y] = t(e);
        }), h;
      }
      function t(v) {
        var h = {};
        v.getElementsByTagName("w:lvl").forEach(function(y) {
          var c = y.attributes["w:ilvl"], d = y.first("w:numFmt").attributes["w:val"], p = y.firstOrEmpty("w:pStyle").attributes["w:val"];
          h[c] = {
            isOrdered: d !== "bullet",
            level: c,
            paragraphStyleId: p
          };
        });
        var e = v.firstOrEmpty("w:numStyleLink").attributes["w:val"];
        return { levels: h, numStyleLink: e };
      }
      function a(v) {
        var h = {};
        return v.getElementsByTagName("w:num").forEach(function(e) {
          var y = e.attributes["w:numId"], c = e.first("w:abstractNumId").attributes["w:val"];
          h[y] = { abstractNumId: c };
        }), h;
      }
    }, { underscore: 117 }], 12: [function(le, ce, re) {
      var ae = le("underscore"), Z = le("../promises"), o = le("../xml");
      re.read = t, re.readXmlFromZipFile = a;
      var C = {
        "http://schemas.openxmlformats.org/wordprocessingml/2006/main": "w",
        "http://schemas.openxmlformats.org/officeDocument/2006/relationships": "r",
        "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing": "wp",
        "http://schemas.openxmlformats.org/drawingml/2006/main": "a",
        "http://schemas.openxmlformats.org/drawingml/2006/picture": "pic",
        "http://schemas.openxmlformats.org/package/2006/content-types": "content-types",
        "urn:schemas-microsoft-com:vml": "v",
        "http://schemas.openxmlformats.org/markup-compatibility/2006": "mc",
        "urn:schemas-microsoft-com:office:word": "office-word"
      };
      function t(e) {
        return o.readString(e, C).then(function(y) {
          return h(y)[0];
        });
      }
      function a(e, y) {
        return e.exists(y) ? e.read(y, "utf-8").then(v).then(t) : Z.resolve(null);
      }
      function v(e) {
        return e.replace(/^\uFEFF/g, "");
      }
      function h(e) {
        return e.type === "element" ? e.name === "mc:AlternateContent" ? e.first("mc:Fallback").children : (e.children = ae.flatten(e.children.map(h, !0)), [e]) : [e];
      }
    }, { "../promises": 23, "../xml": 35, underscore: 117 }], 13: [function(le, ce, re) {
      re.readRelationships = ae, re.defaultValue = new Z([]), re.Relationships = Z;
      function ae(o) {
        var C = [];
        return o.children.forEach(function(t) {
          if (t.name === "{http://schemas.openxmlformats.org/package/2006/relationships}Relationship") {
            var a = {
              relationshipId: t.attributes.Id,
              target: t.attributes.Target,
              type: t.attributes.Type
            };
            C.push(a);
          }
        }), new Z(C);
      }
      function Z(o) {
        var C = {};
        o.forEach(function(a) {
          C[a.relationshipId] = a.target;
        });
        var t = {};
        return o.forEach(function(a) {
          t[a.type] || (t[a.type] = []), t[a.type].push(a.target);
        }), {
          findTargetByRelationshipId: function(a) {
            return C[a];
          },
          findTargetsByType: function(a) {
            return t[a] || [];
          }
        };
      }
    }, {}], 14: [function(le, ce, re) {
      var ae = le("underscore"), Z = le("../promises"), o = le("../xml");
      re.writeStyleMap = v, re.readStyleMap = c;
      var C = "http://schemas.zwobble.org/mammoth/style-map", t = "mammoth/style-map", a = "/" + t;
      function v(d, p) {
        return d.write(t, p), h(d).then(function() {
          return e(d);
        });
      }
      function h(d) {
        var p = "word/_rels/document.xml.rels", m = "http://schemas.openxmlformats.org/package/2006/relationships", g = "{" + m + "}Relationship";
        return d.read(p, "utf8").then(o.readString).then(function(n) {
          var i = n.children;
          y(i, g, "Id", {
            Id: "rMammothStyleMap",
            Type: C,
            Target: a
          });
          var l = { "": m };
          return d.write(p, o.writeString(n, l));
        });
      }
      function e(d) {
        var p = "[Content_Types].xml", m = "http://schemas.openxmlformats.org/package/2006/content-types", g = "{" + m + "}Override";
        return d.read(p, "utf8").then(o.readString).then(function(n) {
          var i = n.children;
          y(i, g, "PartName", {
            PartName: a,
            ContentType: "text/prs.mammoth.style-map"
          });
          var l = { "": m };
          return d.write(p, o.writeString(n, l));
        });
      }
      function y(d, p, m, g) {
        var n = ae.find(d, function(i) {
          return i.name === p && i.attributes[m] === g[m];
        });
        n ? n.attributes = g : d.push(o.element(p, g));
      }
      function c(d) {
        return d.exists(t) ? d.read(t, "utf8") : Z.resolve(null);
      }
    }, { "../promises": 23, "../xml": 35, underscore: 117 }], 15: [function(le, ce, re) {
      re.readStylesXml = Z, re.Styles = ae, re.defaultStyles = new ae({}, {});
      function ae(a, v, h, e) {
        return {
          findParagraphStyleById: function(y) {
            return a[y];
          },
          findCharacterStyleById: function(y) {
            return v[y];
          },
          findTableStyleById: function(y) {
            return h[y];
          },
          findNumberingStyleById: function(y) {
            return e[y];
          }
        };
      }
      ae.EMPTY = new ae({}, {}, {}, {});
      function Z(a) {
        var v = {}, h = {}, e = {}, y = {}, c = {
          paragraph: v,
          character: h,
          table: e
        };
        return a.getElementsByTagName("w:style").forEach(function(d) {
          var p = o(d);
          if (p.type === "numbering")
            y[p.styleId] = t(d);
          else {
            var m = c[p.type];
            m && (m[p.styleId] = p);
          }
        }), new ae(v, h, e, y);
      }
      function o(a) {
        var v = a.attributes["w:type"], h = a.attributes["w:styleId"], e = C(a);
        return { type: v, styleId: h, name: e };
      }
      function C(a) {
        var v = a.first("w:name");
        return v ? v.attributes["w:val"] : null;
      }
      function t(a) {
        var v = a.firstOrEmpty("w:pPr").firstOrEmpty("w:numPr").firstOrEmpty("w:numId").attributes["w:val"];
        return { numId: v };
      }
    }, {}], 16: [function(le, ce, re) {
      re.uriToZipEntryName = ae, re.replaceFragment = Z;
      function ae(o, C) {
        return C.charAt(0) === "/" ? C.substr(1) : o + "/" + C;
      }
      function Z(o, C) {
        var t = o.indexOf("#");
        return t !== -1 && (o = o.substring(0, t)), o + "#" + C;
      }
    }, {}], 17: [function(le, ce, re) {
      var ae = le("../styles/html-paths");
      function Z(e, y, c) {
        return C(
          ae.element(e, y, { fresh: !1 }),
          c
        );
      }
      function o(e, y, c) {
        var d = ae.element(e, y, { fresh: !0 });
        return C(d, c);
      }
      function C(e, y) {
        return {
          type: "element",
          tag: e,
          children: y || []
        };
      }
      function t(e) {
        return {
          type: "text",
          value: e
        };
      }
      var a = {
        type: "forceWrite"
      };
      re.freshElement = o, re.nonFreshElement = Z, re.elementWithTag = C, re.text = t, re.forceWrite = a;
      var v = {
        br: !0,
        hr: !0,
        img: !0
      };
      function h(e) {
        return e.children.length === 0 && v[e.tag.tagName];
      }
      re.isVoidElement = h;
    }, { "../styles/html-paths": 28 }], 18: [function(le, ce, re) {
      var ae = le("./ast");
      re.freshElement = ae.freshElement, re.nonFreshElement = ae.nonFreshElement, re.elementWithTag = ae.elementWithTag, re.text = ae.text, re.forceWrite = ae.forceWrite, re.simplify = le("./simplify");
      function Z(v, h) {
        h.forEach(function(e) {
          o(v, e);
        });
      }
      function o(v, h) {
        C[h.type](v, h);
      }
      var C = {
        element: t,
        text: a,
        forceWrite: function() {
        }
      };
      function t(v, h) {
        ae.isVoidElement(h) ? v.selfClosing(h.tag.tagName, h.tag.attributes) : (v.open(h.tag.tagName, h.tag.attributes), Z(v, h.children), v.close(h.tag.tagName));
      }
      function a(v, h) {
        v.text(h.value);
      }
      re.write = Z;
    }, { "./ast": 17, "./simplify": 19 }], 19: [function(le, ce, re) {
      var ae = le("underscore"), Z = le("./ast");
      function o(n) {
        return C(y(n));
      }
      function C(n) {
        var i = [];
        return n.map(t).forEach(function(l) {
          e(i, l);
        }), i;
      }
      function t(n) {
        return a[n.type](n);
      }
      var a = {
        element: v,
        text: h,
        forceWrite: h
      };
      function v(n) {
        return Z.elementWithTag(n.tag, C(n.children));
      }
      function h(n) {
        return n;
      }
      function e(n, i) {
        var l = n[n.length - 1];
        i.type === "element" && !i.tag.fresh && l && l.type === "element" && i.tag.matchesElement(l.tag) ? (i.tag.separator && e(l.children, Z.text(i.tag.separator)), i.children.forEach(function(u) {
          e(l.children, u);
        })) : n.push(i);
      }
      function y(n) {
        return c(n, function(i) {
          return d[i.type](i);
        });
      }
      function c(n, i) {
        return ae.flatten(ae.map(n, i), !0);
      }
      var d = {
        element: m,
        text: g,
        forceWrite: p
      };
      function p(n) {
        return [n];
      }
      function m(n) {
        var i = y(n.children);
        return i.length === 0 && !Z.isVoidElement(n) ? [] : [Z.elementWithTag(n.tag, i)];
      }
      function g(n) {
        return n.value.length === 0 ? [] : [n];
      }
      ce.exports = o;
    }, { "./ast": 17, underscore: 117 }], 20: [function(le, ce, re) {
      var ae = le("underscore"), Z = le("./promises"), o = le("./html");
      re.imgElement = C;
      function C(t) {
        return function(a, v) {
          return Z.when(t(a)).then(function(h) {
            var e = {};
            return a.altText && (e.alt = a.altText), ae.extend(e, h), [o.freshElement("img", e)];
          });
        };
      }
      re.inline = re.imgElement, re.dataUri = C(function(t) {
        return t.read("base64").then(function(a) {
          return {
            src: "data:" + t.contentType + ";base64," + a
          };
        });
      });
    }, { "./html": 18, "./promises": 23, underscore: 117 }], 21: [function(le, ce, re) {
      var ae = le("underscore"), Z = le("./docx/docx-reader"), o = le("./docx/style-map"), C = le("./document-to-html").DocumentConverter, t = le("./raw-text").convertElementToRawText, a = le("./style-reader").readStyle, v = le("./options-reader").readOptions, h = le("./unzip"), e = le("./results").Result;
      re.convertToHtml = y, re.convertToMarkdown = c, re.convert = d, re.extractRawText = n, re.images = le("./images"), re.transforms = le("./transforms"), re.underline = le("./underline"), re.embedStyleMap = i, re.readEmbeddedStyleMap = p;
      function y(l, u) {
        return d(l, u);
      }
      function c(l, u) {
        var w = Object.create(u || {});
        return w.outputFormat = "markdown", d(l, w);
      }
      function d(l, u) {
        return u = v(u), h.openZip(l).tap(function(w) {
          return o.readStyleMap(w).then(function(_) {
            u.embeddedStyleMap = _;
          });
        }).then(function(w) {
          return Z.read(w, l).then(function(_) {
            return _.map(u.transformDocument);
          }).then(function(_) {
            return m(_, u);
          });
        });
      }
      function p(l) {
        return h.openZip(l).then(o.readStyleMap);
      }
      function m(l, u) {
        var w = g(u.readStyleMap()), _ = ae.extend({}, u, {
          styleMap: w.value
        }), b = new C(_);
        return l.flatMapThen(function(A) {
          return w.flatMapThen(function(Y) {
            return b.convertToHtml(A);
          });
        });
      }
      function g(l) {
        return e.combine((l || []).map(a)).map(function(u) {
          return u.filter(function(w) {
            return !!w;
          });
        });
      }
      function n(l) {
        return h.openZip(l).then(Z.read).then(function(u) {
          return u.map(t);
        });
      }
      function i(l, u) {
        return h.openZip(l).tap(function(w) {
          return o.writeStyleMap(w, u);
        }).then(function(w) {
          return w.toBuffer();
        }).then(function(w) {
          return {
            toBuffer: function() {
              return w;
            }
          };
        });
      }
      re.styleMapping = function() {
        throw new Error(`Use a raw string instead of mammoth.styleMapping e.g. "p[style-name='Title'] => h1" instead of mammoth.styleMapping("p[style-name='Title'] => h1")`);
      };
    }, { "./document-to-html": 3, "./docx/docx-reader": 9, "./docx/style-map": 14, "./images": 20, "./options-reader": 22, "./raw-text": 24, "./results": 25, "./style-reader": 26, "./transforms": 30, "./underline": 31, "./unzip": 2, underscore: 117 }], 22: [function(le, ce, re) {
      re.readOptions = C;
      var ae = le("underscore"), Z = re._defaultStyleMap = [
        "p.Heading1 => h1:fresh",
        "p.Heading2 => h2:fresh",
        "p.Heading3 => h3:fresh",
        "p.Heading4 => h4:fresh",
        "p.Heading5 => h5:fresh",
        "p.Heading6 => h6:fresh",
        "p[style-name='Heading 1'] => h1:fresh",
        "p[style-name='Heading 2'] => h2:fresh",
        "p[style-name='Heading 3'] => h3:fresh",
        "p[style-name='Heading 4'] => h4:fresh",
        "p[style-name='Heading 5'] => h5:fresh",
        "p[style-name='Heading 6'] => h6:fresh",
        "p[style-name='heading 1'] => h1:fresh",
        "p[style-name='heading 2'] => h2:fresh",
        "p[style-name='heading 3'] => h3:fresh",
        "p[style-name='heading 4'] => h4:fresh",
        "p[style-name='heading 5'] => h5:fresh",
        "p[style-name='heading 6'] => h6:fresh",
        "r[style-name='Strong'] => strong",
        "p[style-name='footnote text'] => p:fresh",
        "r[style-name='footnote reference'] =>",
        "p[style-name='endnote text'] => p:fresh",
        "r[style-name='endnote reference'] =>",
        "p[style-name='annotation text'] => p:fresh",
        "r[style-name='annotation reference'] =>",
        // LibreOffice
        "p[style-name='Footnote'] => p:fresh",
        "r[style-name='Footnote anchor'] =>",
        "p[style-name='Endnote'] => p:fresh",
        "r[style-name='Endnote anchor'] =>",
        "p:unordered-list(1) => ul > li:fresh",
        "p:unordered-list(2) => ul|ol > li > ul > li:fresh",
        "p:unordered-list(3) => ul|ol > li > ul|ol > li > ul > li:fresh",
        "p:unordered-list(4) => ul|ol > li > ul|ol > li > ul|ol > li > ul > li:fresh",
        "p:unordered-list(5) => ul|ol > li > ul|ol > li > ul|ol > li > ul|ol > li > ul > li:fresh",
        "p:ordered-list(1) => ol > li:fresh",
        "p:ordered-list(2) => ul|ol > li > ol > li:fresh",
        "p:ordered-list(3) => ul|ol > li > ul|ol > li > ol > li:fresh",
        "p:ordered-list(4) => ul|ol > li > ul|ol > li > ul|ol > li > ol > li:fresh",
        "p:ordered-list(5) => ul|ol > li > ul|ol > li > ul|ol > li > ul|ol > li > ol > li:fresh",
        "r[style-name='Hyperlink'] =>",
        "p[style-name='Normal'] => p:fresh"
      ], o = re._standardOptions = {
        transformDocument: a,
        includeDefaultStyleMap: !0,
        includeEmbeddedStyleMap: !0
      };
      function C(v) {
        return v = v || {}, ae.extend({}, o, v, {
          customStyleMap: t(v.styleMap),
          readStyleMap: function() {
            var h = this.customStyleMap;
            return this.includeEmbeddedStyleMap && (h = h.concat(t(this.embeddedStyleMap))), this.includeDefaultStyleMap && (h = h.concat(Z)), h;
          }
        });
      }
      function t(v) {
        return v ? ae.isString(v) ? v.split(`
`).map(function(h) {
          return h.trim();
        }).filter(function(h) {
          return h !== "" && h.charAt(0) !== "#";
        }) : v : [];
      }
      function a(v) {
        return v;
      }
    }, { underscore: 117 }], 23: [function(le, ce, re) {
      var ae = le("underscore"), Z = le("bluebird/js/release/promise")();
      re.defer = o, re.when = Z.resolve, re.resolve = Z.resolve, re.all = Z.all, re.props = Z.props, re.reject = Z.reject, re.promisify = Z.promisify, re.mapSeries = Z.mapSeries, re.attempt = Z.attempt, re.nfcall = function(C) {
        var t = Array.prototype.slice.call(arguments, 1), a = Z.promisify(C);
        return a.apply(null, t);
      }, Z.prototype.fail = Z.prototype.caught, Z.prototype.also = function(C) {
        return this.then(function(t) {
          var a = ae.extend({}, t, C(t));
          return Z.props(a);
        });
      };
      function o() {
        var C, t, a = new Z.Promise(function(v, h) {
          C = v, t = h;
        });
        return {
          resolve: C,
          reject: t,
          promise: a
        };
      }
    }, { "bluebird/js/release/promise": 61, underscore: 117 }], 24: [function(le, ce, re) {
      var ae = le("./documents");
      function Z(o) {
        if (o.type === "text")
          return o.value;
        if (o.type === ae.types.tab)
          return "	";
        var C = o.type === "paragraph" ? `

` : "";
        return (o.children || []).map(Z).join("") + C;
      }
      re.convertElementToRawText = Z;
    }, { "./documents": 4 }], 25: [function(le, ce, re) {
      var ae = le("underscore");
      re.Result = Z, re.success = o, re.warning = C, re.error = t;
      function Z(e, y) {
        this.value = e, this.messages = y || [];
      }
      Z.prototype.map = function(e) {
        return new Z(e(this.value), this.messages);
      }, Z.prototype.flatMap = function(e) {
        var y = e(this.value);
        return new Z(y.value, a([this, y]));
      }, Z.prototype.flatMapThen = function(e) {
        var y = this;
        return e(this.value).then(function(c) {
          return new Z(c.value, a([y, c]));
        });
      }, Z.combine = function(e) {
        var y = ae.flatten(ae.pluck(e, "value")), c = a(e);
        return new Z(y, c);
      };
      function o(e) {
        return new Z(e, []);
      }
      function C(e) {
        return {
          type: "warning",
          message: e
        };
      }
      function t(e) {
        return {
          type: "error",
          message: e.message,
          error: e
        };
      }
      function a(e) {
        var y = [];
        return ae.flatten(ae.pluck(e, "messages"), !0).forEach(function(c) {
          v(y, c) || y.push(c);
        }), y;
      }
      function v(e, y) {
        return ae.find(e, h.bind(null, y)) !== void 0;
      }
      function h(e, y) {
        return e.type === y.type && e.message === y.message;
      }
    }, { underscore: 117 }], 26: [function(le, ce, re) {
      var ae = le("underscore"), Z = le("lop"), o = le("./styles/document-matchers"), C = le("./styles/html-paths"), t = le("./styles/parser/tokeniser").tokenise, a = le("./results");
      re.readHtmlPath = c, re.readDocumentMatcher = e, re.readStyle = v;
      function v(A) {
        return u(b, A);
      }
      function h() {
        return Z.rules.sequence(
          Z.rules.sequence.capture(y()),
          Z.rules.tokenOfType("whitespace"),
          Z.rules.tokenOfType("arrow"),
          Z.rules.sequence.capture(Z.rules.optional(Z.rules.sequence(
            Z.rules.tokenOfType("whitespace"),
            Z.rules.sequence.capture(d())
          ).head())),
          Z.rules.tokenOfType("end")
        ).map(function(A, Y) {
          return {
            from: A,
            to: Y.valueOrElse(C.empty)
          };
        });
      }
      function e(A) {
        return u(y(), A);
      }
      function y() {
        var A = Z.rules.sequence, Y = function(L, K) {
          return Z.rules.then(
            Z.rules.token("identifier", L),
            function() {
              return K;
            }
          );
        }, j = Y("p", o.paragraph), X = Y("r", o.run), B = Z.rules.firstOf(
          "p or r or table",
          j,
          X
        ), R = Z.rules.then(
          l,
          function(L) {
            return { styleId: L };
          }
        ), k = Z.rules.firstOf(
          "style name matcher",
          Z.rules.then(
            Z.rules.sequence(
              Z.rules.tokenOfType("equals"),
              Z.rules.sequence.cut(),
              Z.rules.sequence.capture(g)
            ).head(),
            function(L) {
              return { styleName: o.equalTo(L) };
            }
          ),
          Z.rules.then(
            Z.rules.sequence(
              Z.rules.tokenOfType("startsWith"),
              Z.rules.sequence.cut(),
              Z.rules.sequence.capture(g)
            ).head(),
            function(L) {
              return { styleName: o.startsWith(L) };
            }
          )
        ), x = Z.rules.sequence(
          Z.rules.tokenOfType("open-square-bracket"),
          Z.rules.sequence.cut(),
          Z.rules.token("identifier", "style-name"),
          Z.rules.sequence.capture(k),
          Z.rules.tokenOfType("close-square-bracket")
        ).head(), f = Z.rules.firstOf(
          "list type",
          Y("ordered-list", { isOrdered: !0 }),
          Y("unordered-list", { isOrdered: !1 })
        ), U = A(
          Z.rules.tokenOfType("colon"),
          A.capture(f),
          A.cut(),
          Z.rules.tokenOfType("open-paren"),
          A.capture(m),
          Z.rules.tokenOfType("close-paren")
        ).map(function(L, K) {
          return {
            list: {
              isOrdered: L.isOrdered,
              levelIndex: K - 1
            }
          };
        });
        function O(L) {
          var K = Z.rules.firstOf.apply(
            Z.rules.firstOf,
            ["matcher suffix"].concat(L)
          ), te = Z.rules.zeroOrMore(K);
          return Z.rules.then(te, function(se) {
            var q = {};
            return se.forEach(function(N) {
              ae.extend(q, N);
            }), q;
          });
        }
        var S = A(
          A.capture(B),
          A.capture(O([
            R,
            x,
            U
          ]))
        ).map(function(L, K) {
          return L(K);
        }), F = A(
          Z.rules.token("identifier", "table"),
          A.capture(O([
            R,
            x
          ]))
        ).map(function(L) {
          return o.table(L);
        }), T = Y("b", o.bold), I = Y("i", o.italic), M = Y("u", o.underline), V = Y("strike", o.strikethrough), J = Y("all-caps", o.allCaps), W = Y("small-caps", o.smallCaps), z = Y("comment-reference", o.commentReference), G = A(
          Z.rules.token("identifier", "br"),
          A.cut(),
          Z.rules.tokenOfType("open-square-bracket"),
          Z.rules.token("identifier", "type"),
          Z.rules.tokenOfType("equals"),
          A.capture(g),
          Z.rules.tokenOfType("close-square-bracket")
        ).map(function(L) {
          switch (L) {
            case "line":
              return o.lineBreak;
            case "page":
              return o.pageBreak;
            case "column":
              return o.columnBreak;
          }
        });
        return Z.rules.firstOf(
          "element type",
          S,
          F,
          T,
          I,
          M,
          V,
          J,
          W,
          z,
          G
        );
      }
      function c(A) {
        return u(d(), A);
      }
      function d() {
        var A = Z.rules.sequence.capture, Y = Z.rules.tokenOfType("whitespace"), j = Z.rules.then(
          Z.rules.optional(Z.rules.sequence(
            Z.rules.tokenOfType("colon"),
            Z.rules.token("identifier", "fresh")
          )),
          function(k) {
            return k.map(function() {
              return !0;
            }).valueOrElse(!1);
          }
        ), X = Z.rules.then(
          Z.rules.optional(Z.rules.sequence(
            Z.rules.tokenOfType("colon"),
            Z.rules.token("identifier", "separator"),
            Z.rules.tokenOfType("open-paren"),
            A(g),
            Z.rules.tokenOfType("close-paren")
          ).head()),
          function(k) {
            return k.valueOrElse("");
          }
        ), B = Z.rules.oneOrMoreWithSeparator(
          p,
          Z.rules.tokenOfType("choice")
        ), R = Z.rules.sequence(
          A(B),
          A(Z.rules.zeroOrMore(l)),
          A(j),
          A(X)
        ).map(function(k, x, f, U) {
          var O = {}, S = {};
          return x.length > 0 && (O.class = x.join(" ")), f && (S.fresh = !0), U && (S.separator = U), C.element(k, O, S);
        });
        return Z.rules.firstOf(
          "html path",
          Z.rules.then(Z.rules.tokenOfType("bang"), function() {
            return C.ignore;
          }),
          Z.rules.then(
            Z.rules.zeroOrMoreWithSeparator(
              R,
              Z.rules.sequence(
                Y,
                Z.rules.tokenOfType("gt"),
                Y
              )
            ),
            C.elements
          )
        );
      }
      var p = Z.rules.then(
        Z.rules.tokenOfType("identifier"),
        i
      ), m = Z.rules.tokenOfType("integer"), g = Z.rules.then(
        Z.rules.tokenOfType("string"),
        i
      ), n = {
        n: `
`,
        r: "\r",
        t: "	"
      };
      function i(A) {
        return A.replace(/\\(.)/g, function(Y, j) {
          return n[j] || j;
        });
      }
      var l = Z.rules.sequence(
        Z.rules.tokenOfType("dot"),
        Z.rules.sequence.cut(),
        Z.rules.sequence.capture(p)
      ).head();
      function u(A, Y) {
        var j = t(Y), X = Z.Parser(), B = X.parseTokens(A, j);
        return B.isSuccess() ? a.success(B.value()) : new a.Result(null, [a.warning(w(Y, B))]);
      }
      function w(A, Y) {
        return "Did not understand this style mapping, so ignored it: " + A + `
` + Y.errors().map(_).join(`
`);
      }
      function _(A) {
        return "Error was at character number " + A.characterNumber() + ": Expected " + A.expected + " but got " + A.actual;
      }
      var b = h();
    }, { "./results": 25, "./styles/document-matchers": 27, "./styles/html-paths": 28, "./styles/parser/tokeniser": 29, lop: 88, underscore: 117 }], 27: [function(le, ce, re) {
      re.paragraph = ae, re.run = Z, re.table = o, re.bold = new C("bold"), re.italic = new C("italic"), re.underline = new C("underline"), re.strikethrough = new C("strikethrough"), re.allCaps = new C("allCaps"), re.smallCaps = new C("smallCaps"), re.commentReference = new C("commentReference"), re.lineBreak = new C("break", { breakType: "line" }), re.pageBreak = new C("break", { breakType: "page" }), re.columnBreak = new C("break", { breakType: "column" }), re.equalTo = a, re.startsWith = v;
      function ae(y) {
        return new C("paragraph", y);
      }
      function Z(y) {
        return new C("run", y);
      }
      function o(y) {
        return new C("table", y);
      }
      function C(y, c) {
        c = c || {}, this._elementType = y, this._styleId = c.styleId, this._styleName = c.styleName, c.list && (this._listIndex = c.list.levelIndex, this._listIsOrdered = c.list.isOrdered);
      }
      C.prototype.matches = function(y) {
        return y.type === this._elementType && (this._styleId === void 0 || y.styleId === this._styleId) && (this._styleName === void 0 || y.styleName && this._styleName.operator(this._styleName.operand, y.styleName)) && (this._listIndex === void 0 || t(y, this._listIndex, this._listIsOrdered)) && (this._breakType === void 0 || this._breakType === y.breakType);
      };
      function t(y, c, d) {
        return y.numbering && y.numbering.level == c && y.numbering.isOrdered == d;
      }
      function a(y) {
        return {
          operator: h,
          operand: y
        };
      }
      function v(y) {
        return {
          operator: e,
          operand: y
        };
      }
      function h(y, c) {
        return y.toUpperCase() === c.toUpperCase();
      }
      function e(y, c) {
        return c.toUpperCase().indexOf(y.toUpperCase()) === 0;
      }
    }, {}], 28: [function(le, ce, re) {
      var ae = le("underscore"), Z = le("../html");
      re.topLevelElement = o, re.elements = C, re.element = a;
      function o(h, e) {
        return C([a(h, e, { fresh: !0 })]);
      }
      function C(h) {
        return new t(h.map(function(e) {
          return ae.isString(e) ? a(e) : e;
        }));
      }
      function t(h) {
        this._elements = h;
      }
      t.prototype.wrap = function(e) {
        for (var y = e(), c = this._elements.length - 1; c >= 0; c--)
          y = this._elements[c].wrapNodes(y);
        return y;
      };
      function a(h, e, y) {
        return y = y || {}, new v(h, e, y);
      }
      function v(h, e, y) {
        var c = {};
        ae.isArray(h) ? (h.forEach(function(d) {
          c[d] = !0;
        }), h = h[0]) : c[h] = !0, this.tagName = h, this.tagNames = c, this.attributes = e || {}, this.fresh = y.fresh, this.separator = y.separator;
      }
      v.prototype.matchesElement = function(h) {
        return this.tagNames[h.tagName] && ae.isEqual(this.attributes || {}, h.attributes || {});
      }, v.prototype.wrap = function(e) {
        return this.wrapNodes(e());
      }, v.prototype.wrapNodes = function(e) {
        return [Z.elementWithTag(this, e)];
      }, re.empty = C([]), re.ignore = {
        wrap: function() {
          return [];
        }
      };
    }, { "../html": 18, underscore: 117 }], 29: [function(le, ce, re) {
      var ae = le("lop"), Z = ae.RegexTokeniser;
      re.tokenise = C;
      var o = "'((?:\\\\.|[^'])*)";
      function C(t) {
        var a = "(?:[a-zA-Z\\-_]|\\\\.)", v = new Z([
          { name: "identifier", regex: new RegExp("(" + a + "(?:" + a + "|[0-9])*)") },
          { name: "dot", regex: /\./ },
          { name: "colon", regex: /:/ },
          { name: "gt", regex: />/ },
          { name: "whitespace", regex: /\s+/ },
          { name: "arrow", regex: /=>/ },
          { name: "equals", regex: /=/ },
          { name: "startsWith", regex: /\^=/ },
          { name: "open-paren", regex: /\(/ },
          { name: "close-paren", regex: /\)/ },
          { name: "open-square-bracket", regex: /\[/ },
          { name: "close-square-bracket", regex: /\]/ },
          { name: "string", regex: new RegExp(o + "'") },
          { name: "unterminated-string", regex: new RegExp(o) },
          { name: "integer", regex: /([0-9]+)/ },
          { name: "choice", regex: /\|/ },
          { name: "bang", regex: /(!)/ }
        ]);
        return v.tokenise(t);
      }
    }, { lop: 88 }], 30: [function(le, ce, re) {
      var ae = le("underscore");
      re.paragraph = Z, re.run = o, re._elements = t, re.getDescendantsOfType = a, re.getDescendants = v;
      function Z(e) {
        return C("paragraph", e);
      }
      function o(e) {
        return C("run", e);
      }
      function C(e, y) {
        return t(function(c) {
          return c.type === e ? y(c) : c;
        });
      }
      function t(e) {
        return function y(c) {
          if (c.children) {
            var d = ae.map(c.children, y);
            c = ae.extend(c, { children: d });
          }
          return e(c);
        };
      }
      function a(e, y) {
        return v(e).filter(function(c) {
          return c.type === y;
        });
      }
      function v(e) {
        var y = [];
        return h(e, function(c) {
          y.push(c);
        }), y;
      }
      function h(e, y) {
        e.children && e.children.forEach(function(c) {
          h(c, y), y(c);
        });
      }
    }, { underscore: 117 }], 31: [function(le, ce, re) {
      var ae = le("./styles/html-paths"), Z = le("./html");
      re.element = o;
      function o(C) {
        return function(t) {
          return Z.elementWithTag(ae.element(C), [t]);
        };
      }
    }, { "./html": 18, "./styles/html-paths": 28 }], 32: [function(le, ce, re) {
      var ae = le("util"), Z = le("underscore");
      re.writer = o;
      function o(e) {
        return e = e || {}, e.prettyPrint ? t() : a();
      }
      var C = {
        div: !0,
        p: !0,
        ul: !0,
        li: !0
      };
      function t() {
        var e = 0, y = "  ", c = [], d = !0, p = !1, m = a();
        function g(A, Y) {
          C[A] && _(), c.push(A), m.open(A, Y), C[A] && e++, d = !1;
        }
        function n(A) {
          C[A] && (e--, _()), c.pop(), m.close(A);
        }
        function i(A) {
          w();
          var Y = b() ? A : A.replace(`
`, `
` + y);
          m.text(Y);
        }
        function l(A, Y) {
          _(), m.selfClosing(A, Y);
        }
        function u() {
          return c.length === 0 || C[c[c.length - 1]];
        }
        function w() {
          p || (_(), p = !0);
        }
        function _() {
          if (p = !1, !d && u() && !b()) {
            m._append(`
`);
            for (var A = 0; A < e; A++)
              m._append(y);
          }
        }
        function b() {
          return Z.some(c, function(A) {
            return A === "pre";
          });
        }
        return {
          asString: m.asString,
          open: g,
          close: n,
          text: i,
          selfClosing: l
        };
      }
      function a() {
        var e = [];
        function y(i, l) {
          var u = p(l);
          e.push(ae.format("<%s%s>", i, u));
        }
        function c(i) {
          e.push(ae.format("</%s>", i));
        }
        function d(i, l) {
          var u = p(l);
          e.push(ae.format("<%s%s />", i, u));
        }
        function p(i) {
          return Z.map(i, function(l, u) {
            return ae.format(' %s="%s"', u, h(l));
          }).join("");
        }
        function m(i) {
          e.push(v(i));
        }
        function g(i) {
          e.push(i);
        }
        function n() {
          return e.join("");
        }
        return {
          asString: n,
          open: y,
          close: c,
          text: m,
          selfClosing: d,
          _append: g
        };
      }
      function v(e) {
        return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
      }
      function h(e) {
        return e.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
      }
    }, { underscore: 117, util: 121 }], 33: [function(le, ce, re) {
      var ae = le("./html-writer"), Z = le("./markdown-writer");
      re.writer = o;
      function o(C) {
        return C = C || {}, C.outputFormat === "markdown" ? Z.writer() : ae.writer(C);
      }
    }, { "./html-writer": 32, "./markdown-writer": 34 }], 34: [function(le, ce, re) {
      var ae = le("underscore");
      function Z(d) {
        return o(d, d);
      }
      function o(d, p) {
        return function() {
          return { start: d, end: p };
        };
      }
      function C(d) {
        var p = d.href || "";
        return p ? {
          start: "[",
          end: "](" + p + ")",
          anchorPosition: "before"
        } : {};
      }
      function t(d) {
        var p = d.src || "", m = d.alt || "";
        return p || m ? { start: "![" + m + "](" + p + ")" } : {};
      }
      function a(d) {
        return function(p, m) {
          return {
            start: m ? `
` : "",
            end: m ? "" : `
`,
            list: {
              isOrdered: d.isOrdered,
              indent: m ? m.indent + 1 : 0,
              count: 0
            }
          };
        };
      }
      function v(d, p, m) {
        p = p || { indent: 0, isOrdered: !1, count: 0 }, p.count++, m.hasClosed = !1;
        var g = p.isOrdered ? p.count + "." : "-", n = e("	", p.indent) + g + " ";
        return {
          start: n,
          end: function() {
            if (!m.hasClosed)
              return m.hasClosed = !0, `
`;
          }
        };
      }
      var h = {
        p: o("", `

`),
        br: o("", `  
`),
        ul: a({ isOrdered: !1 }),
        ol: a({ isOrdered: !0 }),
        li: v,
        strong: Z("__"),
        em: Z("*"),
        a: C,
        img: t
      };
      (function() {
        for (var d = 1; d <= 6; d++)
          h["h" + d] = o(e("#", d) + " ", `

`);
      })();
      function e(d, p) {
        return new Array(p + 1).join(d);
      }
      function y() {
        var d = [], p = [], m = null, g = {};
        function n(b, A) {
          A = A || {};
          var Y = h[b] || function() {
            return {};
          }, j = Y(A, m, g);
          p.push({ end: j.end, list: m }), j.list && (m = j.list);
          var X = j.anchorPosition === "before";
          X && i(A), d.push(j.start || ""), X || i(A);
        }
        function i(b) {
          b.id && d.push('<a id="' + b.id + '"></a>');
        }
        function l(b) {
          var A = p.pop();
          m = A.list;
          var Y = ae.isFunction(A.end) ? A.end() : A.end;
          d.push(Y || "");
        }
        function u(b, A) {
          n(b, A), l();
        }
        function w(b) {
          d.push(c(b));
        }
        function _() {
          return d.join("");
        }
        return {
          asString: _,
          open: n,
          close: l,
          text: w,
          selfClosing: u
        };
      }
      re.writer = y;
      function c(d) {
        return d.replace(/\\/g, "\\\\").replace(/([\`\*_\{\}\[\]\(\)\#\+\-\.\!])/g, "\\$1");
      }
    }, { underscore: 117 }], 35: [function(le, ce, re) {
      var ae = le("./nodes");
      re.Element = ae.Element, re.element = ae.element, re.text = ae.text, re.readString = le("./reader").readString, re.writeString = le("./writer").writeString;
    }, { "./nodes": 36, "./reader": 37, "./writer": 38 }], 36: [function(le, ce, re) {
      var ae = le("underscore");
      re.Element = o, re.element = function(a, v, h) {
        return new o(a, v, h);
      }, re.text = function(a) {
        return {
          type: "text",
          value: a
        };
      };
      var Z = {
        first: function() {
          return null;
        },
        firstOrEmpty: function() {
          return Z;
        },
        attributes: {}
      };
      function o(a, v, h) {
        this.type = "element", this.name = a, this.attributes = v || {}, this.children = h || [];
      }
      o.prototype.first = function(a) {
        return ae.find(this.children, function(v) {
          return v.name === a;
        });
      }, o.prototype.firstOrEmpty = function(a) {
        return this.first(a) || Z;
      }, o.prototype.getElementsByTagName = function(a) {
        var v = ae.filter(this.children, function(h) {
          return h.name === a;
        });
        return t(v);
      }, o.prototype.text = function() {
        if (this.children.length === 0)
          return "";
        if (this.children.length !== 1 || this.children[0].type !== "text")
          throw new Error("Not implemented");
        return this.children[0].value;
      };
      var C = {
        getElementsByTagName: function(a) {
          return t(ae.flatten(this.map(function(v) {
            return v.getElementsByTagName(a);
          }, !0)));
        }
      };
      function t(a) {
        return ae.extend(a, C);
      }
    }, { underscore: 117 }], 37: [function(le, ce, re) {
      var ae = le("../promises"), Z = le("sax"), o = le("underscore"), C = le("./nodes"), t = C.Element;
      re.readString = a;
      function a(h, e) {
        e = e || {};
        var y = !1, c = Z.parser(!0, { xmlns: !0, position: !1 }), d = { children: [] }, p = d, m = [], g = ae.defer();
        c.onopentag = function(i) {
          var l = v(i.attributes, function(w) {
            return w.value;
          }, n), u = new t(n(i), l);
          p.children.push(u), m.push(p), p = u;
        };
        function n(i) {
          if (i.uri) {
            var l = e[i.uri], u;
            return l ? u = l + ":" : u = "{" + i.uri + "}", u + i.local;
          } else
            return i.local;
        }
        return c.onclosetag = function(i) {
          p = m.pop();
        }, c.ontext = function(i) {
          p !== d && p.children.push(C.text(i));
        }, c.onend = function() {
          y || (y = !0, g.resolve(d.children[0]));
        }, c.onerror = function(i) {
          y || (y = !0, g.reject(i));
        }, c.write(h).close(), g.promise;
      }
      function v(h, e, y) {
        return o.reduce(h, function(c, d, p) {
          var m = y(d, p, h);
          return c[m] = e(d, p, h), c;
        }, {});
      }
    }, { "../promises": 23, "./nodes": 36, sax: 114, underscore: 117 }], 38: [function(le, ce, re) {
      var ae = le("underscore"), Z = le("xmlbuilder");
      re.writeString = o;
      function o(t, a) {
        var v = ae.invert(a), h = {
          element: y,
          text: C
        };
        function e(p, m) {
          return h[m.type](p, m);
        }
        function y(p, m) {
          var g = p.element(c(m.name), m.attributes);
          m.children.forEach(function(n) {
            e(g, n);
          });
        }
        function c(p) {
          var m = /^\{(.*)\}(.*)$/.exec(p);
          if (m) {
            var g = v[m[1]];
            return g + (g === "" ? "" : ":") + m[2];
          } else
            return p;
        }
        function d(p) {
          var m = Z.create(c(p.name), {
            version: "1.0",
            encoding: "UTF-8",
            standalone: !0
          });
          return ae.forEach(a, function(g, n) {
            var i = "xmlns" + (n === "" ? "" : ":" + n);
            m.attribute(i, g);
          }), p.children.forEach(function(g) {
            e(m, g);
          }), m.end();
        }
        return d(t);
      }
      function C(t, a) {
        t.text(a.value);
      }
    }, { underscore: 117, xmlbuilder: 143 }], 39: [function(le, ce, re) {
      (function(ae) {
        var Z = le("jszip");
        re.openArrayBuffer = o, re.splitPath = t, re.joinPath = a;
        function o(v) {
          return Z.loadAsync(v).then(function(h) {
            function e(p) {
              return h.file(p) !== null;
            }
            function y(p, m) {
              return h.file(p).async("uint8array").then(function(g) {
                var n = C(g);
                return m ? n.toString(m) : n;
              });
            }
            function c(p, m) {
              h.file(p, m);
            }
            function d() {
              return h.generateAsync({ type: "nodebuffer" });
            }
            return {
              exists: e,
              read: y,
              write: c,
              toBuffer: d
            };
          });
        }
        function C(v) {
          return ae.from && ae.from !== Uint8Array.from ? ae.from(v) : new ae(v);
        }
        function t(v) {
          var h = v.lastIndexOf("/");
          return h === -1 ? { dirname: "", basename: v } : {
            dirname: v.substring(0, h),
            basename: v.substring(h + 1)
          };
        }
        function a() {
          var v = Array.prototype.filter.call(arguments, function(e) {
            return e;
          }), h = [];
          return v.forEach(function(e) {
            /^\//.test(e) ? h = [e] : h.push(e);
          }), h.join("/");
        }
      }).call(this, le("buffer").Buffer);
    }, { buffer: 78, jszip: 87 }], 40: [function(le, ce, re) {
      re.byteLength = h, re.toByteArray = e, re.fromByteArray = d;
      for (var ae = [], Z = [], o = typeof Uint8Array < "u" ? Uint8Array : Array, C = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t = 0, a = C.length; t < a; ++t)
        ae[t] = C[t], Z[C.charCodeAt(t)] = t;
      Z["-".charCodeAt(0)] = 62, Z["_".charCodeAt(0)] = 63;
      function v(p) {
        var m = p.length;
        if (m % 4 > 0)
          throw new Error("Invalid string. Length must be a multiple of 4");
        return p[m - 2] === "=" ? 2 : p[m - 1] === "=" ? 1 : 0;
      }
      function h(p) {
        return p.length * 3 / 4 - v(p);
      }
      function e(p) {
        var m, g, n, i, l, u, w = p.length;
        l = v(p), u = new o(w * 3 / 4 - l), n = l > 0 ? w - 4 : w;
        var _ = 0;
        for (m = 0, g = 0; m < n; m += 4, g += 3)
          i = Z[p.charCodeAt(m)] << 18 | Z[p.charCodeAt(m + 1)] << 12 | Z[p.charCodeAt(m + 2)] << 6 | Z[p.charCodeAt(m + 3)], u[_++] = i >> 16 & 255, u[_++] = i >> 8 & 255, u[_++] = i & 255;
        return l === 2 ? (i = Z[p.charCodeAt(m)] << 2 | Z[p.charCodeAt(m + 1)] >> 4, u[_++] = i & 255) : l === 1 && (i = Z[p.charCodeAt(m)] << 10 | Z[p.charCodeAt(m + 1)] << 4 | Z[p.charCodeAt(m + 2)] >> 2, u[_++] = i >> 8 & 255, u[_++] = i & 255), u;
      }
      function y(p) {
        return ae[p >> 18 & 63] + ae[p >> 12 & 63] + ae[p >> 6 & 63] + ae[p & 63];
      }
      function c(p, m, g) {
        for (var n, i = [], l = m; l < g; l += 3)
          n = (p[l] << 16) + (p[l + 1] << 8) + p[l + 2], i.push(y(n));
        return i.join("");
      }
      function d(p) {
        for (var m, g = p.length, n = g % 3, i = "", l = [], u = 16383, w = 0, _ = g - n; w < _; w += u)
          l.push(c(p, w, w + u > _ ? _ : w + u));
        return n === 1 ? (m = p[g - 1], i += ae[m >> 2], i += ae[m << 4 & 63], i += "==") : n === 2 && (m = (p[g - 2] << 8) + p[g - 1], i += ae[m >> 10], i += ae[m >> 4 & 63], i += ae[m << 2 & 63], i += "="), l.push(i), l.join("");
      }
    }, {}], 41: [function(le, ce, re) {
      ce.exports = function(ae) {
        var Z = ae._SomePromiseArray;
        function o(C) {
          var t = new Z(C), a = t.promise();
          return t.setHowMany(1), t.setUnwrap(), t.init(), a;
        }
        ae.any = function(C) {
          return o(C);
        }, ae.prototype.any = function() {
          return o(this);
        };
      };
    }, {}], 42: [function(le, ce, re) {
      (function(ae) {
        var Z;
        try {
          throw new Error();
        } catch (y) {
          Z = y;
        }
        var o = le("./schedule"), C = le("./queue"), t = le("./util");
        function a() {
          this._customScheduler = !1, this._isTickUsed = !1, this._lateQueue = new C(16), this._normalQueue = new C(16), this._haveDrainedQueues = !1, this._trampolineEnabled = !0;
          var y = this;
          this.drainQueues = function() {
            y._drainQueues();
          }, this._schedule = o;
        }
        a.prototype.setScheduler = function(y) {
          var c = this._schedule;
          return this._schedule = y, this._customScheduler = !0, c;
        }, a.prototype.hasCustomScheduler = function() {
          return this._customScheduler;
        }, a.prototype.enableTrampoline = function() {
          this._trampolineEnabled = !0;
        }, a.prototype.disableTrampolineIfNecessary = function() {
          t.hasDevTools && (this._trampolineEnabled = !1);
        }, a.prototype.haveItemsQueued = function() {
          return this._isTickUsed || this._haveDrainedQueues;
        }, a.prototype.fatalError = function(y, c) {
          c ? (ae.stderr.write("Fatal " + (y instanceof Error ? y.stack : y) + `
`), ae.exit(2)) : this.throwLater(y);
        }, a.prototype.throwLater = function(y, c) {
          if (arguments.length === 1 && (c = y, y = function() {
            throw c;
          }), typeof setTimeout < "u")
            setTimeout(function() {
              y(c);
            }, 0);
          else
            try {
              this._schedule(function() {
                y(c);
              });
            } catch {
              throw new Error(`No async scheduler available

    See http://goo.gl/MqrFmX
`);
            }
        };
        function v(y, c, d) {
          this._lateQueue.push(y, c, d), this._queueTick();
        }
        function h(y, c, d) {
          this._normalQueue.push(y, c, d), this._queueTick();
        }
        function e(y) {
          this._normalQueue._pushOne(y), this._queueTick();
        }
        t.hasDevTools ? (a.prototype.invokeLater = function(y, c, d) {
          this._trampolineEnabled ? v.call(this, y, c, d) : this._schedule(function() {
            setTimeout(function() {
              y.call(c, d);
            }, 100);
          });
        }, a.prototype.invoke = function(y, c, d) {
          this._trampolineEnabled ? h.call(this, y, c, d) : this._schedule(function() {
            y.call(c, d);
          });
        }, a.prototype.settlePromises = function(y) {
          this._trampolineEnabled ? e.call(this, y) : this._schedule(function() {
            y._settlePromises();
          });
        }) : (a.prototype.invokeLater = v, a.prototype.invoke = h, a.prototype.settlePromises = e), a.prototype._drainQueue = function(y) {
          for (; y.length() > 0; ) {
            var c = y.shift();
            if (typeof c != "function") {
              c._settlePromises();
              continue;
            }
            var d = y.shift(), p = y.shift();
            c.call(d, p);
          }
        }, a.prototype._drainQueues = function() {
          this._drainQueue(this._normalQueue), this._reset(), this._haveDrainedQueues = !0, this._drainQueue(this._lateQueue);
        }, a.prototype._queueTick = function() {
          this._isTickUsed || (this._isTickUsed = !0, this._schedule(this.drainQueues));
        }, a.prototype._reset = function() {
          this._isTickUsed = !1;
        }, ce.exports = a, ce.exports.firstLineError = Z;
      }).call(this, le("_process"));
    }, { "./queue": 65, "./schedule": 68, "./util": 75, _process: 102 }], 43: [function(le, ce, re) {
      ce.exports = function(ae, Z, o, C) {
        var t = !1, a = function(y, c) {
          this._reject(c);
        }, v = function(y, c) {
          c.promiseRejectionQueued = !0, c.bindingPromise._then(a, a, null, this, y);
        }, h = function(y, c) {
          this._bitField & 50397184 || this._resolveCallback(c.target);
        }, e = function(y, c) {
          c.promiseRejectionQueued || this._reject(y);
        };
        ae.prototype.bind = function(y) {
          t || (t = !0, ae.prototype._propagateFrom = C.propagateFromFunction(), ae.prototype._boundValue = C.boundValueFunction());
          var c = o(y), d = new ae(Z);
          d._propagateFrom(this, 1);
          var p = this._target();
          if (d._setBoundTo(c), c instanceof ae) {
            var m = {
              promiseRejectionQueued: !1,
              promise: d,
              target: p,
              bindingPromise: c
            };
            p._then(Z, v, void 0, d, m), c._then(
              h,
              e,
              void 0,
              d,
              m
            ), d._setOnCancel(c);
          } else
            d._resolveCallback(p);
          return d;
        }, ae.prototype._setBoundTo = function(y) {
          y !== void 0 ? (this._bitField = this._bitField | 2097152, this._boundTo = y) : this._bitField = this._bitField & -2097153;
        }, ae.prototype._isBound = function() {
          return (this._bitField & 2097152) === 2097152;
        }, ae.bind = function(y, c) {
          return ae.resolve(c).bind(y);
        };
      };
    }, {}], 44: [function(le, ce, re) {
      var ae = Object.create;
      if (ae) {
        var Z = ae(null), o = ae(null);
        Z[" size"] = o[" size"] = 0;
      }
      ce.exports = function(C) {
        var t = le("./util"), a = t.canEvaluate, v = t.isIdentifier, h, e;
        {
          var y = function(i) {
            return new Function("ensureMethod", `                                    
	        return function(obj) {                                               
	            'use strict'                                                     
	            var len = this.length;                                           
	            ensureMethod(obj, 'methodName');                                 
	            switch(len) {                                                    
	                case 1: return obj.methodName(this[0]);                      
	                case 2: return obj.methodName(this[0], this[1]);             
	                case 3: return obj.methodName(this[0], this[1], this[2]);    
	                case 0: return obj.methodName();                             
	                default:                                                     
	                    return obj.methodName.apply(obj, this);                  
	            }                                                                
	        };                                                                   
	        `.replace(/methodName/g, i))(p);
          }, c = function(i) {
            return new Function("obj", `                                             
	        'use strict';                                                        
	        return obj.propertyName;                                             
	        `.replace("propertyName", i));
          }, d = function(i, l, u) {
            var w = u[i];
            if (typeof w != "function") {
              if (!v(i))
                return null;
              if (w = l(i), u[i] = w, u[" size"]++, u[" size"] > 512) {
                for (var _ = Object.keys(u), b = 0; b < 256; ++b)
                  delete u[_[b]];
                u[" size"] = _.length - 256;
              }
            }
            return w;
          };
          h = function(i) {
            return d(i, y, Z);
          }, e = function(i) {
            return d(i, c, o);
          };
        }
        function p(i, l) {
          var u;
          if (i != null && (u = i[l]), typeof u != "function") {
            var w = "Object " + t.classString(i) + " has no method '" + t.toString(l) + "'";
            throw new C.TypeError(w);
          }
          return u;
        }
        function m(i) {
          var l = this.pop(), u = p(i, l);
          return u.apply(i, this);
        }
        C.prototype.call = function(i) {
          for (var l = arguments.length, u = new Array(Math.max(l - 1, 0)), w = 1; w < l; ++w)
            u[w - 1] = arguments[w];
          if (a) {
            var _ = h(i);
            if (_ !== null)
              return this._then(
                _,
                void 0,
                void 0,
                u,
                void 0
              );
          }
          return u.push(i), this._then(m, void 0, void 0, u, void 0);
        };
        function g(i) {
          return i[this];
        }
        function n(i) {
          var l = +this;
          return l < 0 && (l = Math.max(0, l + i.length)), i[l];
        }
        C.prototype.get = function(i) {
          var l = typeof i == "number", u;
          if (l)
            u = n;
          else if (a) {
            var w = e(i);
            u = w !== null ? w : g;
          } else
            u = g;
          return this._then(u, void 0, void 0, i, void 0);
        };
      };
    }, { "./util": 75 }], 45: [function(le, ce, re) {
      ce.exports = function(ae, Z, o, C) {
        var t = le("./util"), a = t.tryCatch, v = t.errorObj, h = ae._async;
        ae.prototype.break = ae.prototype.cancel = function() {
          if (!C.cancellation())
            return this._warn("cancellation is disabled");
          for (var e = this, y = e; e._isCancellable(); ) {
            if (!e._cancelBy(y)) {
              y._isFollowing() ? y._followee().cancel() : y._cancelBranched();
              break;
            }
            var c = e._cancellationParent;
            if (c == null || !c._isCancellable()) {
              e._isFollowing() ? e._followee().cancel() : e._cancelBranched();
              break;
            } else
              e._isFollowing() && e._followee().cancel(), e._setWillBeCancelled(), y = e, e = c;
          }
        }, ae.prototype._branchHasCancelled = function() {
          this._branchesRemainingToCancel--;
        }, ae.prototype._enoughBranchesHaveCancelled = function() {
          return this._branchesRemainingToCancel === void 0 || this._branchesRemainingToCancel <= 0;
        }, ae.prototype._cancelBy = function(e) {
          return e === this ? (this._branchesRemainingToCancel = 0, this._invokeOnCancel(), !0) : (this._branchHasCancelled(), this._enoughBranchesHaveCancelled() ? (this._invokeOnCancel(), !0) : !1);
        }, ae.prototype._cancelBranched = function() {
          this._enoughBranchesHaveCancelled() && this._cancel();
        }, ae.prototype._cancel = function() {
          this._isCancellable() && (this._setCancelled(), h.invoke(this._cancelPromises, this, void 0));
        }, ae.prototype._cancelPromises = function() {
          this._length() > 0 && this._settlePromises();
        }, ae.prototype._unsetOnCancel = function() {
          this._onCancelField = void 0;
        }, ae.prototype._isCancellable = function() {
          return this.isPending() && !this._isCancelled();
        }, ae.prototype.isCancellable = function() {
          return this.isPending() && !this.isCancelled();
        }, ae.prototype._doInvokeOnCancel = function(e, y) {
          if (t.isArray(e))
            for (var c = 0; c < e.length; ++c)
              this._doInvokeOnCancel(e[c], y);
          else if (e !== void 0)
            if (typeof e == "function") {
              if (!y) {
                var d = a(e).call(this._boundValue());
                d === v && (this._attachExtraTrace(d.e), h.throwLater(d.e));
              }
            } else
              e._resultCancelled(this);
        }, ae.prototype._invokeOnCancel = function() {
          var e = this._onCancel();
          this._unsetOnCancel(), h.invoke(this._doInvokeOnCancel, this, e);
        }, ae.prototype._invokeInternalOnCancel = function() {
          this._isCancellable() && (this._doInvokeOnCancel(this._onCancel(), !0), this._unsetOnCancel());
        }, ae.prototype._resultCancelled = function() {
          this.cancel();
        };
      };
    }, { "./util": 75 }], 46: [function(le, ce, re) {
      ce.exports = function(ae) {
        var Z = le("./util"), o = le("./es5").keys, C = Z.tryCatch, t = Z.errorObj;
        function a(v, h, e) {
          return function(y) {
            var c = e._boundValue();
            e:
              for (var d = 0; d < v.length; ++d) {
                var p = v[d];
                if (p === Error || p != null && p.prototype instanceof Error) {
                  if (y instanceof p)
                    return C(h).call(c, y);
                } else if (typeof p == "function") {
                  var m = C(p).call(c, y);
                  if (m === t)
                    return m;
                  if (m)
                    return C(h).call(c, y);
                } else if (Z.isObject(y)) {
                  for (var g = o(p), n = 0; n < g.length; ++n) {
                    var i = g[n];
                    if (p[i] != y[i])
                      continue e;
                  }
                  return C(h).call(c, y);
                }
              }
            return ae;
          };
        }
        return a;
      };
    }, { "./es5": 52, "./util": 75 }], 47: [function(le, ce, re) {
      ce.exports = function(ae) {
        var Z = !1, o = [];
        ae.prototype._promiseCreated = function() {
        }, ae.prototype._pushContext = function() {
        }, ae.prototype._popContext = function() {
          return null;
        }, ae._peekContext = ae.prototype._peekContext = function() {
        };
        function C() {
          this._trace = new C.CapturedTrace(a());
        }
        C.prototype._pushContext = function() {
          this._trace !== void 0 && (this._trace._promiseCreated = null, o.push(this._trace));
        }, C.prototype._popContext = function() {
          if (this._trace !== void 0) {
            var v = o.pop(), h = v._promiseCreated;
            return v._promiseCreated = null, h;
          }
          return null;
        };
        function t() {
          if (Z)
            return new C();
        }
        function a() {
          var v = o.length - 1;
          if (v >= 0)
            return o[v];
        }
        return C.CapturedTrace = null, C.create = t, C.deactivateLongStackTraces = function() {
        }, C.activateLongStackTraces = function() {
          var v = ae.prototype._pushContext, h = ae.prototype._popContext, e = ae._peekContext, y = ae.prototype._peekContext, c = ae.prototype._promiseCreated;
          C.deactivateLongStackTraces = function() {
            ae.prototype._pushContext = v, ae.prototype._popContext = h, ae._peekContext = e, ae.prototype._peekContext = y, ae.prototype._promiseCreated = c, Z = !1;
          }, Z = !0, ae.prototype._pushContext = C.prototype._pushContext, ae.prototype._popContext = C.prototype._popContext, ae._peekContext = ae.prototype._peekContext = a, ae.prototype._promiseCreated = function() {
            var d = this._peekContext();
            d && d._promiseCreated == null && (d._promiseCreated = this);
          };
        }, C;
      };
    }, {}], 48: [function(le, ce, re) {
      (function(ae) {
        ce.exports = function(Z, o) {
          var C = Z._getDomain, t = Z._async, a = le("./errors").Warning, v = le("./util"), h = v.canAttachTrace, e, y, c = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/, d = /\((?:timers\.js):\d+:\d+\)/, p = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/, m = null, g = null, n = !1, i, l = !!(v.env("BLUEBIRD_DEBUG") != 0 && (v.env("BLUEBIRD_DEBUG") || v.env("NODE_ENV") === "development")), u = !!(v.env("BLUEBIRD_WARNINGS") != 0 && (l || v.env("BLUEBIRD_WARNINGS"))), w = !!(v.env("BLUEBIRD_LONG_STACK_TRACES") != 0 && (l || v.env("BLUEBIRD_LONG_STACK_TRACES"))), _ = v.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (u || !!v.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
          Z.prototype.suppressUnhandledRejections = function() {
            var de = this._target();
            de._bitField = de._bitField & -1048577 | 524288;
          }, Z.prototype._ensurePossibleRejectionHandled = function() {
            this._bitField & 524288 || (this._setRejectionIsUnhandled(), t.invokeLater(this._notifyUnhandledRejection, this, void 0));
          }, Z.prototype._notifyUnhandledRejectionIsHandled = function() {
            Q(
              "rejectionHandled",
              e,
              void 0,
              this
            );
          }, Z.prototype._setReturnedNonUndefined = function() {
            this._bitField = this._bitField | 268435456;
          }, Z.prototype._returnedNonUndefined = function() {
            return (this._bitField & 268435456) !== 0;
          }, Z.prototype._notifyUnhandledRejection = function() {
            if (this._isRejectionUnhandled()) {
              var de = this._settledValue();
              this._setUnhandledRejectionIsNotified(), Q(
                "unhandledRejection",
                y,
                de,
                this
              );
            }
          }, Z.prototype._setUnhandledRejectionIsNotified = function() {
            this._bitField = this._bitField | 262144;
          }, Z.prototype._unsetUnhandledRejectionIsNotified = function() {
            this._bitField = this._bitField & -262145;
          }, Z.prototype._isUnhandledRejectionNotified = function() {
            return (this._bitField & 262144) > 0;
          }, Z.prototype._setRejectionIsUnhandled = function() {
            this._bitField = this._bitField | 1048576;
          }, Z.prototype._unsetRejectionIsUnhandled = function() {
            this._bitField = this._bitField & -1048577, this._isUnhandledRejectionNotified() && (this._unsetUnhandledRejectionIsNotified(), this._notifyUnhandledRejectionIsHandled());
          }, Z.prototype._isRejectionUnhandled = function() {
            return (this._bitField & 1048576) > 0;
          }, Z.prototype._warn = function(de, pe, xe) {
            return z(de, pe, xe || this);
          }, Z.onPossiblyUnhandledRejection = function(de) {
            var pe = C();
            y = typeof de == "function" ? pe === null ? de : v.domainBind(pe, de) : void 0;
          }, Z.onUnhandledRejectionHandled = function(de) {
            var pe = C();
            e = typeof de == "function" ? pe === null ? de : v.domainBind(pe, de) : void 0;
          };
          var b = function() {
          };
          Z.longStackTraces = function() {
            if (t.haveItemsQueued() && !fe.longStackTraces)
              throw new Error(`cannot enable long stack traces after promises have been created

    See http://goo.gl/MqrFmX
`);
            if (!fe.longStackTraces && oe()) {
              var de = Z.prototype._captureStackTrace, pe = Z.prototype._attachExtraTrace;
              fe.longStackTraces = !0, b = function() {
                if (t.haveItemsQueued() && !fe.longStackTraces)
                  throw new Error(`cannot enable long stack traces after promises have been created

    See http://goo.gl/MqrFmX
`);
                Z.prototype._captureStackTrace = de, Z.prototype._attachExtraTrace = pe, o.deactivateLongStackTraces(), t.enableTrampoline(), fe.longStackTraces = !1;
              }, Z.prototype._captureStackTrace = M, Z.prototype._attachExtraTrace = V, o.activateLongStackTraces(), t.disableTrampolineIfNecessary();
            }
          }, Z.hasLongStackTraces = function() {
            return fe.longStackTraces && oe();
          };
          var A = function() {
            try {
              if (typeof CustomEvent == "function") {
                var de = new CustomEvent("CustomEvent");
                return v.global.dispatchEvent(de), function(pe, xe) {
                  var De = new CustomEvent(pe.toLowerCase(), {
                    detail: xe,
                    cancelable: !0
                  });
                  return !v.global.dispatchEvent(De);
                };
              } else if (typeof Event == "function") {
                var de = new Event("CustomEvent");
                return v.global.dispatchEvent(de), function(xe, De) {
                  var Ae = new Event(xe.toLowerCase(), {
                    cancelable: !0
                  });
                  return Ae.detail = De, !v.global.dispatchEvent(Ae);
                };
              } else {
                var de = document.createEvent("CustomEvent");
                return de.initCustomEvent("testingtheevent", !1, !0, {}), v.global.dispatchEvent(de), function(xe, De) {
                  var Ae = document.createEvent("CustomEvent");
                  return Ae.initCustomEvent(
                    xe.toLowerCase(),
                    !1,
                    !0,
                    De
                  ), !v.global.dispatchEvent(Ae);
                };
              }
            } catch {
            }
            return function() {
              return !1;
            };
          }(), Y = function() {
            return v.isNode ? function() {
              return ae.emit.apply(ae, arguments);
            } : v.global ? function(de) {
              var pe = "on" + de.toLowerCase(), xe = v.global[pe];
              return xe ? (xe.apply(v.global, [].slice.call(arguments, 1)), !0) : !1;
            } : function() {
              return !1;
            };
          }();
          function j(de, pe) {
            return { promise: pe };
          }
          var X = {
            promiseCreated: j,
            promiseFulfilled: j,
            promiseRejected: j,
            promiseResolved: j,
            promiseCancelled: j,
            promiseChained: function(de, pe, xe) {
              return { promise: pe, child: xe };
            },
            warning: function(de, pe) {
              return { warning: pe };
            },
            unhandledRejection: function(de, pe, xe) {
              return { reason: pe, promise: xe };
            },
            rejectionHandled: j
          }, B = function(de) {
            var pe = !1;
            try {
              pe = Y.apply(null, arguments);
            } catch (De) {
              t.throwLater(De), pe = !0;
            }
            var xe = !1;
            try {
              xe = A(
                de,
                X[de].apply(null, arguments)
              );
            } catch (De) {
              t.throwLater(De), xe = !0;
            }
            return xe || pe;
          };
          Z.config = function(de) {
            if (de = Object(de), "longStackTraces" in de && (de.longStackTraces ? Z.longStackTraces() : !de.longStackTraces && Z.hasLongStackTraces() && b()), "warnings" in de) {
              var pe = de.warnings;
              fe.warnings = !!pe, _ = fe.warnings, v.isObject(pe) && "wForgottenReturn" in pe && (_ = !!pe.wForgottenReturn);
            }
            if ("cancellation" in de && de.cancellation && !fe.cancellation) {
              if (t.haveItemsQueued())
                throw new Error(
                  "cannot enable cancellation after promises are in use"
                );
              Z.prototype._clearCancellationData = O, Z.prototype._propagateFrom = S, Z.prototype._onCancel = f, Z.prototype._setOnCancel = U, Z.prototype._attachCancellationCallback = x, Z.prototype._execute = k, T = S, fe.cancellation = !0;
            }
            return "monitoring" in de && (de.monitoring && !fe.monitoring ? (fe.monitoring = !0, Z.prototype._fireEvent = B) : !de.monitoring && fe.monitoring && (fe.monitoring = !1, Z.prototype._fireEvent = R)), Z;
          };
          function R() {
            return !1;
          }
          Z.prototype._fireEvent = R, Z.prototype._execute = function(de, pe, xe) {
            try {
              de(pe, xe);
            } catch (De) {
              return De;
            }
          }, Z.prototype._onCancel = function() {
          }, Z.prototype._setOnCancel = function(de) {
          }, Z.prototype._attachCancellationCallback = function(de) {
          }, Z.prototype._captureStackTrace = function() {
          }, Z.prototype._attachExtraTrace = function() {
          }, Z.prototype._clearCancellationData = function() {
          }, Z.prototype._propagateFrom = function(de, pe) {
          };
          function k(de, pe, xe) {
            var De = this;
            try {
              de(pe, xe, function(Ae) {
                if (typeof Ae != "function")
                  throw new TypeError("onCancel must be a function, got: " + v.toString(Ae));
                De._attachCancellationCallback(Ae);
              });
            } catch (Ae) {
              return Ae;
            }
          }
          function x(de) {
            if (!this._isCancellable())
              return this;
            var pe = this._onCancel();
            pe !== void 0 ? v.isArray(pe) ? pe.push(de) : this._setOnCancel([pe, de]) : this._setOnCancel(de);
          }
          function f() {
            return this._onCancelField;
          }
          function U(de) {
            this._onCancelField = de;
          }
          function O() {
            this._cancellationParent = void 0, this._onCancelField = void 0;
          }
          function S(de, pe) {
            if (pe & 1) {
              this._cancellationParent = de;
              var xe = de._branchesRemainingToCancel;
              xe === void 0 && (xe = 0), de._branchesRemainingToCancel = xe + 1;
            }
            pe & 2 && de._isBound() && this._setBoundTo(de._boundTo);
          }
          function F(de, pe) {
            pe & 2 && de._isBound() && this._setBoundTo(de._boundTo);
          }
          var T = F;
          function I() {
            var de = this._boundTo;
            return de !== void 0 && de instanceof Z ? de.isFulfilled() ? de.value() : void 0 : de;
          }
          function M() {
            this._trace = new ie(this._peekContext());
          }
          function V(de, pe) {
            if (h(de)) {
              var xe = this._trace;
              if (xe !== void 0 && pe && (xe = xe._parent), xe !== void 0)
                xe.attachExtraTrace(de);
              else if (!de.__stackCleaned__) {
                var De = q(de);
                v.notEnumerableProp(
                  de,
                  "stack",
                  De.message + `
` + De.stack.join(`
`)
                ), v.notEnumerableProp(de, "__stackCleaned__", !0);
              }
            }
          }
          function J(de, pe, xe, De, Ae) {
            if (de === void 0 && pe !== null && _) {
              if (Ae !== void 0 && Ae._returnedNonUndefined() || !(De._bitField & 65535))
                return;
              xe && (xe = xe + " ");
              var Se = "", ke = "";
              if (pe._trace) {
                for (var ye = pe._trace.stack.split(`
`), _e = te(ye), we = _e.length - 1; we >= 0; --we) {
                  var Ce = _e[we];
                  if (!d.test(Ce)) {
                    var ve = Ce.match(p);
                    ve && (Se = "at " + ve[1] + ":" + ve[2] + ":" + ve[3] + " ");
                    break;
                  }
                }
                if (_e.length > 0) {
                  for (var Le = _e[0], we = 0; we < ye.length; ++we)
                    if (ye[we] === Le) {
                      we > 0 && (ke = `
` + ye[we - 1]);
                      break;
                    }
                }
              }
              var He = "a promise was created in a " + xe + "handler " + Se + "but was not returned from it, see http://goo.gl/rRqMUw" + ke;
              De._warn(He, !0, pe);
            }
          }
          function W(de, pe) {
            var xe = de + " is deprecated and will be removed in a future version.";
            return pe && (xe += " Use " + pe + " instead."), z(xe);
          }
          function z(de, pe, xe) {
            if (fe.warnings) {
              var De = new a(de), Ae;
              if (pe)
                xe._attachExtraTrace(De);
              else if (fe.longStackTraces && (Ae = Z._peekContext()))
                Ae.attachExtraTrace(De);
              else {
                var Se = q(De);
                De.stack = Se.message + `
` + Se.stack.join(`
`);
              }
              B("warning", De) || N(De, "", !0);
            }
          }
          function G(de, pe) {
            for (var xe = 0; xe < pe.length - 1; ++xe)
              pe[xe].push("From previous event:"), pe[xe] = pe[xe].join(`
`);
            return xe < pe.length && (pe[xe] = pe[xe].join(`
`)), de + `
` + pe.join(`
`);
          }
          function L(de) {
            for (var pe = 0; pe < de.length; ++pe)
              (de[pe].length === 0 || pe + 1 < de.length && de[pe][0] === de[pe + 1][0]) && (de.splice(pe, 1), pe--);
          }
          function K(de) {
            for (var pe = de[0], xe = 1; xe < de.length; ++xe) {
              for (var De = de[xe], Ae = pe.length - 1, Se = pe[Ae], ke = -1, ye = De.length - 1; ye >= 0; --ye)
                if (De[ye] === Se) {
                  ke = ye;
                  break;
                }
              for (var ye = ke; ye >= 0; --ye) {
                var _e = De[ye];
                if (pe[Ae] === _e)
                  pe.pop(), Ae--;
                else
                  break;
              }
              pe = De;
            }
          }
          function te(de) {
            for (var pe = [], xe = 0; xe < de.length; ++xe) {
              var De = de[xe], Ae = De === "    (No stack trace)" || m.test(De), Se = Ae && ee(De);
              Ae && !Se && (n && De.charAt(0) !== " " && (De = "    " + De), pe.push(De));
            }
            return pe;
          }
          function se(de) {
            for (var pe = de.stack.replace(/\s+$/g, "").split(`
`), xe = 0; xe < pe.length; ++xe) {
              var De = pe[xe];
              if (De === "    (No stack trace)" || m.test(De))
                break;
            }
            return xe > 0 && de.name != "SyntaxError" && (pe = pe.slice(xe)), pe;
          }
          function q(de) {
            var pe = de.stack, xe = de.toString();
            return pe = typeof pe == "string" && pe.length > 0 ? se(de) : ["    (No stack trace)"], {
              message: xe,
              stack: de.name == "SyntaxError" ? pe : te(pe)
            };
          }
          function N(de, pe, xe) {
            if (typeof console < "u") {
              var De;
              if (v.isObject(de)) {
                var Ae = de.stack;
                De = pe + g(Ae, de);
              } else
                De = pe + String(de);
              typeof i == "function" ? i(De, xe) : (typeof console.log == "function" || typeof console.log == "object") && console.log(De);
            }
          }
          function Q(de, pe, xe, De) {
            var Ae = !1;
            try {
              typeof pe == "function" && (Ae = !0, de === "rejectionHandled" ? pe(De) : pe(xe, De));
            } catch (Se) {
              t.throwLater(Se);
            }
            de === "unhandledRejection" ? !B(de, xe, De) && !Ae && N(xe, "Unhandled rejection ") : B(de, De);
          }
          function D(de) {
            var pe;
            if (typeof de == "function")
              pe = "[function " + (de.name || "anonymous") + "]";
            else {
              pe = de && typeof de.toString == "function" ? de.toString() : v.toString(de);
              var xe = /\[object [a-zA-Z0-9$_]+\]/;
              if (xe.test(pe))
                try {
                  var De = JSON.stringify(de);
                  pe = De;
                } catch {
                }
              pe.length === 0 && (pe = "(empty array)");
            }
            return "(<" + ne(pe) + ">, no stack trace)";
          }
          function ne(de) {
            var pe = 41;
            return de.length < pe ? de : de.substr(0, pe - 3) + "...";
          }
          function oe() {
            return typeof ue == "function";
          }
          var ee = function() {
            return !1;
          }, $ = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
          function E(de) {
            var pe = de.match($);
            if (pe)
              return {
                fileName: pe[1],
                line: parseInt(pe[2], 10)
              };
          }
          function H(de, pe) {
            if (oe()) {
              for (var xe = de.stack.split(`
`), De = pe.stack.split(`
`), Ae = -1, Se = -1, ke, ye, _e = 0; _e < xe.length; ++_e) {
                var we = E(xe[_e]);
                if (we) {
                  ke = we.fileName, Ae = we.line;
                  break;
                }
              }
              for (var _e = 0; _e < De.length; ++_e) {
                var we = E(De[_e]);
                if (we) {
                  ye = we.fileName, Se = we.line;
                  break;
                }
              }
              Ae < 0 || Se < 0 || !ke || !ye || ke !== ye || Ae >= Se || (ee = function(Ce) {
                if (c.test(Ce))
                  return !0;
                var ve = E(Ce);
                return !!(ve && ve.fileName === ke && Ae <= ve.line && ve.line <= Se);
              });
            }
          }
          function ie(de) {
            this._parent = de, this._promisesCreated = 0;
            var pe = this._length = 1 + (de === void 0 ? 0 : de._length);
            ue(this, ie), pe > 32 && this.uncycle();
          }
          v.inherits(ie, Error), o.CapturedTrace = ie, ie.prototype.uncycle = function() {
            var de = this._length;
            if (!(de < 2)) {
              for (var pe = [], xe = {}, De = 0, Ae = this; Ae !== void 0; ++De)
                pe.push(Ae), Ae = Ae._parent;
              de = this._length = De;
              for (var De = de - 1; De >= 0; --De) {
                var Se = pe[De].stack;
                xe[Se] === void 0 && (xe[Se] = De);
              }
              for (var De = 0; De < de; ++De) {
                var ke = pe[De].stack, ye = xe[ke];
                if (ye !== void 0 && ye !== De) {
                  ye > 0 && (pe[ye - 1]._parent = void 0, pe[ye - 1]._length = 1), pe[De]._parent = void 0, pe[De]._length = 1;
                  var _e = De > 0 ? pe[De - 1] : this;
                  ye < de - 1 ? (_e._parent = pe[ye + 1], _e._parent.uncycle(), _e._length = _e._parent._length + 1) : (_e._parent = void 0, _e._length = 1);
                  for (var we = _e._length + 1, Ce = De - 2; Ce >= 0; --Ce)
                    pe[Ce]._length = we, we++;
                  return;
                }
              }
            }
          }, ie.prototype.attachExtraTrace = function(de) {
            if (!de.__stackCleaned__) {
              this.uncycle();
              for (var pe = q(de), xe = pe.message, De = [pe.stack], Ae = this; Ae !== void 0; )
                De.push(te(Ae.stack.split(`
`))), Ae = Ae._parent;
              K(De), L(De), v.notEnumerableProp(de, "stack", G(xe, De)), v.notEnumerableProp(de, "__stackCleaned__", !0);
            }
          };
          var ue = function() {
            var pe = /^\s*at\s*/, xe = function(ke, ye) {
              return typeof ke == "string" ? ke : ye.name !== void 0 && ye.message !== void 0 ? ye.toString() : D(ye);
            };
            if (typeof Error.stackTraceLimit == "number" && typeof Error.captureStackTrace == "function") {
              Error.stackTraceLimit += 6, m = pe, g = xe;
              var De = Error.captureStackTrace;
              return ee = function(ke) {
                return c.test(ke);
              }, function(ke, ye) {
                Error.stackTraceLimit += 6, De(ke, ye), Error.stackTraceLimit -= 6;
              };
            }
            var Ae = new Error();
            if (typeof Ae.stack == "string" && Ae.stack.split(`
`)[0].indexOf("stackDetection@") >= 0)
              return m = /@/, g = xe, n = !0, function(ye) {
                ye.stack = new Error().stack;
              };
            var Se;
            try {
              throw new Error();
            } catch (ke) {
              Se = "stack" in ke;
            }
            return !("stack" in Ae) && Se && typeof Error.stackTraceLimit == "number" ? (m = pe, g = xe, function(ye) {
              Error.stackTraceLimit += 6;
              try {
                throw new Error();
              } catch (_e) {
                ye.stack = _e.stack;
              }
              Error.stackTraceLimit -= 6;
            }) : (g = function(ke, ye) {
              return typeof ke == "string" ? ke : (typeof ye == "object" || typeof ye == "function") && ye.name !== void 0 && ye.message !== void 0 ? ye.toString() : D(ye);
            }, null);
          }();
          typeof console < "u" && typeof console.warn < "u" && (i = function(de) {
            console.warn(de);
          }, v.isNode && ae.stderr.isTTY ? i = function(de, pe) {
            var xe = pe ? "\x1B[33m" : "\x1B[31m";
            console.warn(xe + de + `\x1B[0m
`);
          } : !v.isNode && typeof new Error().stack == "string" && (i = function(de, pe) {
            console.warn(
              "%c" + de,
              pe ? "color: darkorange" : "color: red"
            );
          }));
          var fe = {
            warnings: u,
            longStackTraces: !1,
            cancellation: !1,
            monitoring: !1
          };
          return w && Z.longStackTraces(), {
            longStackTraces: function() {
              return fe.longStackTraces;
            },
            warnings: function() {
              return fe.warnings;
            },
            cancellation: function() {
              return fe.cancellation;
            },
            monitoring: function() {
              return fe.monitoring;
            },
            propagateFromFunction: function() {
              return T;
            },
            boundValueFunction: function() {
              return I;
            },
            checkForgottenReturns: J,
            setBounds: H,
            warn: z,
            deprecated: W,
            CapturedTrace: ie,
            fireDomEvent: A,
            fireGlobalEvent: Y
          };
        };
      }).call(this, le("_process"));
    }, { "./errors": 51, "./util": 75, _process: 102 }], 49: [function(le, ce, re) {
      ce.exports = function(ae) {
        function Z() {
          return this.value;
        }
        function o() {
          throw this.reason;
        }
        ae.prototype.return = ae.prototype.thenReturn = function(C) {
          return C instanceof ae && C.suppressUnhandledRejections(), this._then(
            Z,
            void 0,
            void 0,
            { value: C },
            void 0
          );
        }, ae.prototype.throw = ae.prototype.thenThrow = function(C) {
          return this._then(
            o,
            void 0,
            void 0,
            { reason: C },
            void 0
          );
        }, ae.prototype.catchThrow = function(C) {
          if (arguments.length <= 1)
            return this._then(
              void 0,
              o,
              void 0,
              { reason: C },
              void 0
            );
          var t = arguments[1], a = function() {
            throw t;
          };
          return this.caught(C, a);
        }, ae.prototype.catchReturn = function(C) {
          if (arguments.length <= 1)
            return C instanceof ae && C.suppressUnhandledRejections(), this._then(
              void 0,
              Z,
              void 0,
              { value: C },
              void 0
            );
          var t = arguments[1];
          t instanceof ae && t.suppressUnhandledRejections();
          var a = function() {
            return t;
          };
          return this.caught(C, a);
        };
      };
    }, {}], 50: [function(le, ce, re) {
      ce.exports = function(ae, Z) {
        var o = ae.reduce, C = ae.all;
        function t() {
          return C(this);
        }
        function a(v, h) {
          return o(v, h, Z, Z);
        }
        ae.prototype.each = function(v) {
          return o(this, v, Z, 0)._then(t, void 0, void 0, this, void 0);
        }, ae.prototype.mapSeries = function(v) {
          return o(this, v, Z, Z);
        }, ae.each = function(v, h) {
          return o(v, h, Z, 0)._then(t, void 0, void 0, v, void 0);
        }, ae.mapSeries = a;
      };
    }, {}], 51: [function(le, ce, re) {
      var ae = le("./es5"), Z = ae.freeze, o = le("./util"), C = o.inherits, t = o.notEnumerableProp;
      function a(l, u) {
        function w(_) {
          if (!(this instanceof w))
            return new w(_);
          t(
            this,
            "message",
            typeof _ == "string" ? _ : u
          ), t(this, "name", l), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : Error.call(this);
        }
        return C(w, Error), w;
      }
      var v, h, e = a("Warning", "warning"), y = a("CancellationError", "cancellation error"), c = a("TimeoutError", "timeout error"), d = a("AggregateError", "aggregate error");
      try {
        v = TypeError, h = RangeError;
      } catch {
        v = a("TypeError", "type error"), h = a("RangeError", "range error");
      }
      for (var p = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" "), m = 0; m < p.length; ++m)
        typeof Array.prototype[p[m]] == "function" && (d.prototype[p[m]] = Array.prototype[p[m]]);
      ae.defineProperty(d.prototype, "length", {
        value: 0,
        configurable: !1,
        writable: !0,
        enumerable: !0
      }), d.prototype.isOperational = !0;
      var g = 0;
      d.prototype.toString = function() {
        var l = Array(g * 4 + 1).join(" "), u = `
` + l + `AggregateError of:
`;
        g++, l = Array(g * 4 + 1).join(" ");
        for (var w = 0; w < this.length; ++w) {
          for (var _ = this[w] === this ? "[Circular AggregateError]" : this[w] + "", b = _.split(`
`), A = 0; A < b.length; ++A)
            b[A] = l + b[A];
          _ = b.join(`
`), u += _ + `
`;
        }
        return g--, u;
      };
      function n(l) {
        if (!(this instanceof n))
          return new n(l);
        t(this, "name", "OperationalError"), t(this, "message", l), this.cause = l, this.isOperational = !0, l instanceof Error ? (t(this, "message", l.message), t(this, "stack", l.stack)) : Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
      }
      C(n, Error);
      var i = Error.__BluebirdErrorTypes__;
      i || (i = Z({
        CancellationError: y,
        TimeoutError: c,
        OperationalError: n,
        RejectionError: n,
        AggregateError: d
      }), ae.defineProperty(Error, "__BluebirdErrorTypes__", {
        value: i,
        writable: !1,
        enumerable: !1,
        configurable: !1
      })), ce.exports = {
        Error,
        TypeError: v,
        RangeError: h,
        CancellationError: i.CancellationError,
        OperationalError: i.OperationalError,
        TimeoutError: i.TimeoutError,
        AggregateError: i.AggregateError,
        Warning: e
      };
    }, { "./es5": 52, "./util": 75 }], 52: [function(le, ce, re) {
      var ae = function() {
        return this === void 0;
      }();
      if (ae)
        ce.exports = {
          freeze: Object.freeze,
          defineProperty: Object.defineProperty,
          getDescriptor: Object.getOwnPropertyDescriptor,
          keys: Object.keys,
          names: Object.getOwnPropertyNames,
          getPrototypeOf: Object.getPrototypeOf,
          isArray: Array.isArray,
          isES5: ae,
          propertyIsWritable: function(c, d) {
            var p = Object.getOwnPropertyDescriptor(c, d);
            return !!(!p || p.writable || p.set);
          }
        };
      else {
        var Z = {}.hasOwnProperty, o = {}.toString, C = {}.constructor.prototype, t = function(c) {
          var d = [];
          for (var p in c)
            Z.call(c, p) && d.push(p);
          return d;
        }, a = function(c, d) {
          return { value: c[d] };
        }, v = function(c, d, p) {
          return c[d] = p.value, c;
        }, h = function(c) {
          return c;
        }, e = function(c) {
          try {
            return Object(c).constructor.prototype;
          } catch {
            return C;
          }
        }, y = function(c) {
          try {
            return o.call(c) === "[object Array]";
          } catch {
            return !1;
          }
        };
        ce.exports = {
          isArray: y,
          keys: t,
          names: t,
          defineProperty: v,
          getDescriptor: a,
          freeze: h,
          getPrototypeOf: e,
          isES5: ae,
          propertyIsWritable: function() {
            return !0;
          }
        };
      }
    }, {}], 53: [function(le, ce, re) {
      ce.exports = function(ae, Z) {
        var o = ae.map;
        ae.prototype.filter = function(C, t) {
          return o(this, C, t, Z);
        }, ae.filter = function(C, t, a) {
          return o(C, t, a, Z);
        };
      };
    }, {}], 54: [function(le, ce, re) {
      ce.exports = function(ae, Z) {
        var o = le("./util"), C = ae.CancellationError, t = o.errorObj;
        function a(d, p, m) {
          this.promise = d, this.type = p, this.handler = m, this.called = !1, this.cancelPromise = null;
        }
        a.prototype.isFinallyHandler = function() {
          return this.type === 0;
        };
        function v(d) {
          this.finallyHandler = d;
        }
        v.prototype._resultCancelled = function() {
          h(this.finallyHandler);
        };
        function h(d, p) {
          return d.cancelPromise != null ? (arguments.length > 1 ? d.cancelPromise._reject(p) : d.cancelPromise._cancel(), d.cancelPromise = null, !0) : !1;
        }
        function e() {
          return c.call(this, this.promise._target()._settledValue());
        }
        function y(d) {
          if (!h(this, d))
            return t.e = d, t;
        }
        function c(d) {
          var p = this.promise, m = this.handler;
          if (!this.called) {
            this.called = !0;
            var g = this.isFinallyHandler() ? m.call(p._boundValue()) : m.call(p._boundValue(), d);
            if (g !== void 0) {
              p._setReturnedNonUndefined();
              var n = Z(g, p);
              if (n instanceof ae) {
                if (this.cancelPromise != null)
                  if (n._isCancelled()) {
                    var i = new C("late cancellation observer");
                    return p._attachExtraTrace(i), t.e = i, t;
                  } else
                    n.isPending() && n._attachCancellationCallback(
                      new v(this)
                    );
                return n._then(
                  e,
                  y,
                  void 0,
                  this,
                  void 0
                );
              }
            }
          }
          return p.isRejected() ? (h(this), t.e = d, t) : (h(this), d);
        }
        return ae.prototype._passThrough = function(d, p, m, g) {
          return typeof d != "function" ? this.then() : this._then(
            m,
            g,
            void 0,
            new a(this, p, d),
            void 0
          );
        }, ae.prototype.lastly = ae.prototype.finally = function(d) {
          return this._passThrough(
            d,
            0,
            c,
            c
          );
        }, ae.prototype.tap = function(d) {
          return this._passThrough(d, 1, c);
        }, a;
      };
    }, { "./util": 75 }], 55: [function(le, ce, re) {
      ce.exports = function(ae, Z, o, C, t, a) {
        var v = le("./errors"), h = v.TypeError, e = le("./util"), y = e.errorObj, c = e.tryCatch, d = [];
        function p(g, n, i) {
          for (var l = 0; l < n.length; ++l) {
            i._pushContext();
            var u = c(n[l])(g);
            if (i._popContext(), u === y) {
              i._pushContext();
              var w = ae.reject(y.e);
              return i._popContext(), w;
            }
            var _ = C(u, i);
            if (_ instanceof ae)
              return _;
          }
          return null;
        }
        function m(g, n, i, l) {
          if (a.cancellation()) {
            var u = new ae(o), w = this._finallyPromise = new ae(o);
            this._promise = u.lastly(function() {
              return w;
            }), u._captureStackTrace(), u._setOnCancel(this);
          } else {
            var _ = this._promise = new ae(o);
            _._captureStackTrace();
          }
          this._stack = l, this._generatorFunction = g, this._receiver = n, this._generator = void 0, this._yieldHandlers = typeof i == "function" ? [i].concat(d) : d, this._yieldedPromise = null, this._cancellationPhase = !1;
        }
        e.inherits(m, t), m.prototype._isResolved = function() {
          return this._promise === null;
        }, m.prototype._cleanup = function() {
          this._promise = this._generator = null, a.cancellation() && this._finallyPromise !== null && (this._finallyPromise._fulfill(), this._finallyPromise = null);
        }, m.prototype._promiseCancelled = function() {
          if (!this._isResolved()) {
            var g = typeof this._generator.return < "u", n;
            if (g)
              this._promise._pushContext(), n = c(this._generator.return).call(
                this._generator,
                void 0
              ), this._promise._popContext();
            else {
              var i = new ae.CancellationError(
                "generator .return() sentinel"
              );
              ae.coroutine.returnSentinel = i, this._promise._attachExtraTrace(i), this._promise._pushContext(), n = c(this._generator.throw).call(
                this._generator,
                i
              ), this._promise._popContext();
            }
            this._cancellationPhase = !0, this._yieldedPromise = null, this._continue(n);
          }
        }, m.prototype._promiseFulfilled = function(g) {
          this._yieldedPromise = null, this._promise._pushContext();
          var n = c(this._generator.next).call(this._generator, g);
          this._promise._popContext(), this._continue(n);
        }, m.prototype._promiseRejected = function(g) {
          this._yieldedPromise = null, this._promise._attachExtraTrace(g), this._promise._pushContext();
          var n = c(this._generator.throw).call(this._generator, g);
          this._promise._popContext(), this._continue(n);
        }, m.prototype._resultCancelled = function() {
          if (this._yieldedPromise instanceof ae) {
            var g = this._yieldedPromise;
            this._yieldedPromise = null, g.cancel();
          }
        }, m.prototype.promise = function() {
          return this._promise;
        }, m.prototype._run = function() {
          this._generator = this._generatorFunction.call(this._receiver), this._receiver = this._generatorFunction = void 0, this._promiseFulfilled(void 0);
        }, m.prototype._continue = function(g) {
          var n = this._promise;
          if (g === y)
            return this._cleanup(), this._cancellationPhase ? n.cancel() : n._rejectCallback(g.e, !1);
          var i = g.value;
          if (g.done === !0)
            return this._cleanup(), this._cancellationPhase ? n.cancel() : n._resolveCallback(i);
          var l = C(i, this._promise);
          if (!(l instanceof ae) && (l = p(
            l,
            this._yieldHandlers,
            this._promise
          ), l === null)) {
            this._promiseRejected(
              new h(
                `A value %s was yielded that could not be treated as a promise

    See http://goo.gl/MqrFmX

`.replace("%s", i) + `From coroutine:
` + this._stack.split(`
`).slice(1, -7).join(`
`)
              )
            );
            return;
          }
          l = l._target();
          var u = l._bitField;
          u & 50397184 ? u & 33554432 ? ae._async.invoke(
            this._promiseFulfilled,
            this,
            l._value()
          ) : u & 16777216 ? ae._async.invoke(
            this._promiseRejected,
            this,
            l._reason()
          ) : this._promiseCancelled() : (this._yieldedPromise = l, l._proxy(this, null));
        }, ae.coroutine = function(g, n) {
          if (typeof g != "function")
            throw new h(`generatorFunction must be a function

    See http://goo.gl/MqrFmX
`);
          var i = Object(n).yieldHandler, l = m, u = new Error().stack;
          return function() {
            var w = g.apply(this, arguments), _ = new l(
              void 0,
              void 0,
              i,
              u
            ), b = _.promise();
            return _._generator = w, _._promiseFulfilled(void 0), b;
          };
        }, ae.coroutine.addYieldHandler = function(g) {
          if (typeof g != "function")
            throw new h("expecting a function but got " + e.classString(g));
          d.push(g);
        }, ae.spawn = function(g) {
          if (a.deprecated("Promise.spawn()", "Promise.coroutine()"), typeof g != "function")
            return Z(`generatorFunction must be a function

    See http://goo.gl/MqrFmX
`);
          var n = new m(g, this), i = n.promise();
          return n._run(ae.spawn), i;
        };
      };
    }, { "./errors": 51, "./util": 75 }], 56: [function(le, ce, re) {
      ce.exports = function(ae, Z, o, C, t, a) {
        var v = le("./util"), h = v.canEvaluate, e = v.tryCatch, y = v.errorObj, c;
        if (h) {
          for (var d = function(u) {
            return new Function("value", "holder", `                             
	            'use strict';                                                    
	            holder.pIndex = value;                                           
	            holder.checkFulfillment(this);                                   
	            `.replace(/Index/g, u));
          }, p = function(u) {
            return new Function("promise", "holder", `                           
	            'use strict';                                                    
	            holder.pIndex = promise;                                         
	            `.replace(/Index/g, u));
          }, m = function(u) {
            for (var w = new Array(u), _ = 0; _ < w.length; ++_)
              w[_] = "this.p" + (_ + 1);
            var b = w.join(" = ") + " = null;", A = `var promise;
` + w.map(function(B) {
              return `                                                         
	                promise = ` + B + `;                                      
	                if (promise instanceof Promise) {                            
	                    promise.cancel();                                        
	                }                                                            
	            `;
            }).join(`
`), Y = w.join(", "), j = "Holder$" + u, X = `return function(tryCatch, errorObj, Promise, async) {    
	            'use strict';                                                    
	            function [TheName](fn) {                                         
	                [TheProperties]                                              
	                this.fn = fn;                                                
	                this.asyncNeeded = true;                                     
	                this.now = 0;                                                
	            }                                                                
	                                                                             
	            [TheName].prototype._callFunction = function(promise) {          
	                promise._pushContext();                                      
	                var ret = tryCatch(this.fn)([ThePassedArguments]);           
	                promise._popContext();                                       
	                if (ret === errorObj) {                                      
	                    promise._rejectCallback(ret.e, false);                   
	                } else {                                                     
	                    promise._resolveCallback(ret);                           
	                }                                                            
	            };                                                               
	                                                                             
	            [TheName].prototype.checkFulfillment = function(promise) {       
	                var now = ++this.now;                                        
	                if (now === [TheTotal]) {                                    
	                    if (this.asyncNeeded) {                                  
	                        async.invoke(this._callFunction, this, promise);     
	                    } else {                                                 
	                        this._callFunction(promise);                         
	                    }                                                        
	                                                                             
	                }                                                            
	            };                                                               
	                                                                             
	            [TheName].prototype._resultCancelled = function() {              
	                [CancellationCode]                                           
	            };                                                               
	                                                                             
	            return [TheName];                                                
	        }(tryCatch, errorObj, Promise, async);                               
	        `;
            return X = X.replace(/\[TheName\]/g, j).replace(/\[TheTotal\]/g, u).replace(/\[ThePassedArguments\]/g, Y).replace(/\[TheProperties\]/g, b).replace(/\[CancellationCode\]/g, A), new Function("tryCatch", "errorObj", "Promise", "async", X)(e, y, ae, t);
          }, g = [], n = [], i = [], l = 0; l < 8; ++l)
            g.push(m(l + 1)), n.push(d(l + 1)), i.push(p(l + 1));
          c = function(u) {
            this._reject(u);
          };
        }
        ae.join = function() {
          var u = arguments.length - 1, w;
          if (u > 0 && typeof arguments[u] == "function" && (w = arguments[u], u <= 8 && h)) {
            var f = new ae(C);
            f._captureStackTrace();
            for (var _ = g[u - 1], b = new _(w), A = n, Y = 0; Y < u; ++Y) {
              var j = o(arguments[Y], f);
              if (j instanceof ae) {
                j = j._target();
                var X = j._bitField;
                X & 50397184 ? X & 33554432 ? A[Y].call(
                  f,
                  j._value(),
                  b
                ) : X & 16777216 ? f._reject(j._reason()) : f._cancel() : (j._then(
                  A[Y],
                  c,
                  void 0,
                  f,
                  b
                ), i[Y](j, b), b.asyncNeeded = !1);
              } else
                A[Y].call(f, j, b);
            }
            if (!f._isFateSealed()) {
              if (b.asyncNeeded) {
                var B = a();
                B !== null && (b.fn = v.domainBind(B, b.fn));
              }
              f._setAsyncGuaranteed(), f._setOnCancel(b);
            }
            return f;
          }
          for (var R = arguments.length, k = new Array(R), x = 0; x < R; ++x)
            k[x] = arguments[x];
          w && k.pop();
          var f = new Z(k).promise();
          return w !== void 0 ? f.spread(w) : f;
        };
      };
    }, { "./util": 75 }], 57: [function(le, ce, re) {
      ce.exports = function(ae, Z, o, C, t, a) {
        var v = ae._getDomain, h = le("./util"), e = h.tryCatch, y = h.errorObj, c = ae._async;
        function d(m, g, n, i) {
          this.constructor$(m), this._promise._captureStackTrace();
          var l = v();
          this._callback = l === null ? g : h.domainBind(l, g), this._preservedValues = i === t ? new Array(this.length()) : null, this._limit = n, this._inFlight = 0, this._queue = [], c.invoke(this._asyncInit, this, void 0);
        }
        h.inherits(d, Z), d.prototype._asyncInit = function() {
          this._init$(void 0, -2);
        }, d.prototype._init = function() {
        }, d.prototype._promiseFulfilled = function(m, g) {
          var n = this._values, i = this.length(), l = this._preservedValues, u = this._limit;
          if (g < 0) {
            if (g = g * -1 - 1, n[g] = m, u >= 1 && (this._inFlight--, this._drainQueue(), this._isResolved()))
              return !0;
          } else {
            if (u >= 1 && this._inFlight >= u)
              return n[g] = m, this._queue.push(g), !1;
            l !== null && (l[g] = m);
            var w = this._promise, _ = this._callback, b = w._boundValue();
            w._pushContext();
            var A = e(_).call(b, m, g, i), Y = w._popContext();
            if (a.checkForgottenReturns(
              A,
              Y,
              l !== null ? "Promise.filter" : "Promise.map",
              w
            ), A === y)
              return this._reject(A.e), !0;
            var j = C(A, this._promise);
            if (j instanceof ae) {
              j = j._target();
              var X = j._bitField;
              if (X & 50397184)
                if (X & 33554432)
                  A = j._value();
                else
                  return X & 16777216 ? (this._reject(j._reason()), !0) : (this._cancel(), !0);
              else
                return u >= 1 && this._inFlight++, n[g] = j, j._proxy(this, (g + 1) * -1), !1;
            }
            n[g] = A;
          }
          var B = ++this._totalResolved;
          return B >= i ? (l !== null ? this._filter(n, l) : this._resolve(n), !0) : !1;
        }, d.prototype._drainQueue = function() {
          for (var m = this._queue, g = this._limit, n = this._values; m.length > 0 && this._inFlight < g; ) {
            if (this._isResolved())
              return;
            var i = m.pop();
            this._promiseFulfilled(n[i], i);
          }
        }, d.prototype._filter = function(m, g) {
          for (var n = g.length, i = new Array(n), l = 0, u = 0; u < n; ++u)
            m[u] && (i[l++] = g[u]);
          i.length = l, this._resolve(i);
        }, d.prototype.preservedValues = function() {
          return this._preservedValues;
        };
        function p(m, g, n, i) {
          if (typeof g != "function")
            return o("expecting a function but got " + h.classString(g));
          var l = 0;
          if (n !== void 0)
            if (typeof n == "object" && n !== null) {
              if (typeof n.concurrency != "number")
                return ae.reject(
                  new TypeError("'concurrency' must be a number but it is " + h.classString(n.concurrency))
                );
              l = n.concurrency;
            } else
              return ae.reject(new TypeError(
                "options argument must be an object but it is " + h.classString(n)
              ));
          return l = typeof l == "number" && isFinite(l) && l >= 1 ? l : 0, new d(m, g, l, i).promise();
        }
        ae.prototype.map = function(m, g) {
          return p(this, m, g, null);
        }, ae.map = function(m, g, n, i) {
          return p(m, g, n, i);
        };
      };
    }, { "./util": 75 }], 58: [function(le, ce, re) {
      ce.exports = function(ae, Z, o, C, t) {
        var a = le("./util"), v = a.tryCatch;
        ae.method = function(h) {
          if (typeof h != "function")
            throw new ae.TypeError("expecting a function but got " + a.classString(h));
          return function() {
            var e = new ae(Z);
            e._captureStackTrace(), e._pushContext();
            var y = v(h).apply(this, arguments), c = e._popContext();
            return t.checkForgottenReturns(
              y,
              c,
              "Promise.method",
              e
            ), e._resolveFromSyncValue(y), e;
          };
        }, ae.attempt = ae.try = function(h) {
          if (typeof h != "function")
            return C("expecting a function but got " + a.classString(h));
          var e = new ae(Z);
          e._captureStackTrace(), e._pushContext();
          var y;
          if (arguments.length > 1) {
            t.deprecated("calling Promise.try with more than 1 argument");
            var c = arguments[1], d = arguments[2];
            y = a.isArray(c) ? v(h).apply(d, c) : v(h).call(d, c);
          } else
            y = v(h)();
          var p = e._popContext();
          return t.checkForgottenReturns(
            y,
            p,
            "Promise.try",
            e
          ), e._resolveFromSyncValue(y), e;
        }, ae.prototype._resolveFromSyncValue = function(h) {
          h === a.errorObj ? this._rejectCallback(h.e, !1) : this._resolveCallback(h, !0);
        };
      };
    }, { "./util": 75 }], 59: [function(le, ce, re) {
      var ae = le("./util"), Z = ae.maybeWrapAsError, o = le("./errors"), C = o.OperationalError, t = le("./es5");
      function a(y) {
        return y instanceof Error && t.getPrototypeOf(y) === Error.prototype;
      }
      var v = /^(?:name|message|stack|cause)$/;
      function h(y) {
        var c;
        if (a(y)) {
          c = new C(y), c.name = y.name, c.message = y.message, c.stack = y.stack;
          for (var d = t.keys(y), p = 0; p < d.length; ++p) {
            var m = d[p];
            v.test(m) || (c[m] = y[m]);
          }
          return c;
        }
        return ae.markAsOriginatingFromRejection(y), y;
      }
      function e(y, c) {
        return function(d, p) {
          if (y !== null) {
            if (d) {
              var m = h(Z(d));
              y._attachExtraTrace(m), y._reject(m);
            } else if (!c)
              y._fulfill(p);
            else {
              for (var g = arguments.length, n = new Array(Math.max(g - 1, 0)), i = 1; i < g; ++i)
                n[i - 1] = arguments[i];
              y._fulfill(n);
            }
            y = null;
          }
        };
      }
      ce.exports = e;
    }, { "./errors": 51, "./es5": 52, "./util": 75 }], 60: [function(le, ce, re) {
      ce.exports = function(ae) {
        var Z = le("./util"), o = ae._async, C = Z.tryCatch, t = Z.errorObj;
        function a(e, y) {
          var c = this;
          if (!Z.isArray(e))
            return v.call(c, e, y);
          var d = C(y).apply(c._boundValue(), [null].concat(e));
          d === t && o.throwLater(d.e);
        }
        function v(e, y) {
          var c = this, d = c._boundValue(), p = e === void 0 ? C(y).call(d, null) : C(y).call(d, null, e);
          p === t && o.throwLater(p.e);
        }
        function h(e, y) {
          var c = this;
          if (!e) {
            var d = new Error(e + "");
            d.cause = e, e = d;
          }
          var p = C(y).call(c._boundValue(), e);
          p === t && o.throwLater(p.e);
        }
        ae.prototype.asCallback = ae.prototype.nodeify = function(e, y) {
          if (typeof e == "function") {
            var c = v;
            y !== void 0 && Object(y).spread && (c = a), this._then(
              c,
              h,
              void 0,
              this,
              e
            );
          }
          return this;
        };
      };
    }, { "./util": 75 }], 61: [function(le, ce, re) {
      (function(ae) {
        ce.exports = function() {
          var Z = function() {
            return new p(`circular promise resolution chain

    See http://goo.gl/MqrFmX
`);
          }, o = function() {
            return new k.PromiseInspection(this._target());
          }, C = function(O) {
            return k.reject(new p(O));
          };
          function t() {
          }
          var a = {}, v = le("./util"), h;
          v.isNode ? h = function() {
            var O = ae.domain;
            return O === void 0 && (O = null), O;
          } : h = function() {
            return null;
          }, v.notEnumerableProp(k, "_getDomain", h);
          var e = le("./es5"), y = le("./async"), c = new y();
          e.defineProperty(k, "_async", { value: c });
          var d = le("./errors"), p = k.TypeError = d.TypeError;
          k.RangeError = d.RangeError;
          var m = k.CancellationError = d.CancellationError;
          k.TimeoutError = d.TimeoutError, k.OperationalError = d.OperationalError, k.RejectionError = d.OperationalError, k.AggregateError = d.AggregateError;
          var g = function() {
          }, n = {}, i = {}, l = le("./thenables")(k, g), u = le("./promise_array")(
            k,
            g,
            l,
            C,
            t
          ), w = le("./context")(k), _ = w.create, b = le("./debuggability")(k, w);
          b.CapturedTrace;
          var A = le("./finally")(k, l), Y = le("./catch_filter")(i), j = le("./nodeback"), X = v.errorObj, B = v.tryCatch;
          function R(O, S) {
            if (typeof S != "function")
              throw new p("expecting a function but got " + v.classString(S));
            if (O.constructor !== k)
              throw new p(`the promise constructor cannot be invoked directly

    See http://goo.gl/MqrFmX
`);
          }
          function k(O) {
            this._bitField = 0, this._fulfillmentHandler0 = void 0, this._rejectionHandler0 = void 0, this._promise0 = void 0, this._receiver0 = void 0, O !== g && (R(this, O), this._resolveFromExecutor(O)), this._promiseCreated(), this._fireEvent("promiseCreated", this);
          }
          k.prototype.toString = function() {
            return "[object Promise]";
          }, k.prototype.caught = k.prototype.catch = function(O) {
            var S = arguments.length;
            if (S > 1) {
              var F = new Array(S - 1), T = 0, I;
              for (I = 0; I < S - 1; ++I) {
                var M = arguments[I];
                if (v.isObject(M))
                  F[T++] = M;
                else
                  return C("expecting an object but got A catch statement predicate " + v.classString(M));
              }
              return F.length = T, O = arguments[I], this.then(void 0, Y(F, O, this));
            }
            return this.then(void 0, O);
          }, k.prototype.reflect = function() {
            return this._then(
              o,
              o,
              void 0,
              this,
              void 0
            );
          }, k.prototype.then = function(O, S) {
            if (b.warnings() && arguments.length > 0 && typeof O != "function" && typeof S != "function") {
              var F = ".then() only accepts functions but was passed: " + v.classString(O);
              arguments.length > 1 && (F += ", " + v.classString(S)), this._warn(F);
            }
            return this._then(O, S, void 0, void 0, void 0);
          }, k.prototype.done = function(O, S) {
            var F = this._then(O, S, void 0, void 0, void 0);
            F._setIsFinal();
          }, k.prototype.spread = function(O) {
            return typeof O != "function" ? C("expecting a function but got " + v.classString(O)) : this.all()._then(O, void 0, void 0, n, void 0);
          }, k.prototype.toJSON = function() {
            var O = {
              isFulfilled: !1,
              isRejected: !1,
              fulfillmentValue: void 0,
              rejectionReason: void 0
            };
            return this.isFulfilled() ? (O.fulfillmentValue = this.value(), O.isFulfilled = !0) : this.isRejected() && (O.rejectionReason = this.reason(), O.isRejected = !0), O;
          }, k.prototype.all = function() {
            return arguments.length > 0 && this._warn(".all() was passed arguments but it does not take any"), new u(this).promise();
          }, k.prototype.error = function(O) {
            return this.caught(v.originatesFromRejection, O);
          }, k.getNewLibraryCopy = ce.exports, k.is = function(O) {
            return O instanceof k;
          }, k.fromNode = k.fromCallback = function(O) {
            var S = new k(g);
            S._captureStackTrace();
            var F = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : !1, T = B(O)(j(S, F));
            return T === X && S._rejectCallback(T.e, !0), S._isFateSealed() || S._setAsyncGuaranteed(), S;
          }, k.all = function(O) {
            return new u(O).promise();
          }, k.cast = function(O) {
            var S = l(O);
            return S instanceof k || (S = new k(g), S._captureStackTrace(), S._setFulfilled(), S._rejectionHandler0 = O), S;
          }, k.resolve = k.fulfilled = k.cast, k.reject = k.rejected = function(O) {
            var S = new k(g);
            return S._captureStackTrace(), S._rejectCallback(O, !0), S;
          }, k.setScheduler = function(O) {
            if (typeof O != "function")
              throw new p("expecting a function but got " + v.classString(O));
            return c.setScheduler(O);
          }, k.prototype._then = function(O, S, F, T, I) {
            var M = I !== void 0, V = M ? I : new k(g), J = this._target(), W = J._bitField;
            M || (V._propagateFrom(this, 3), V._captureStackTrace(), T === void 0 && this._bitField & 2097152 && (W & 50397184 ? T = this._boundValue() : T = J === this ? void 0 : this._boundTo), this._fireEvent("promiseChained", this, V));
            var z = h();
            if (W & 50397184) {
              var G, L, K = J._settlePromiseCtx;
              W & 33554432 ? (L = J._rejectionHandler0, G = O) : W & 16777216 ? (L = J._fulfillmentHandler0, G = S, J._unsetRejectionIsUnhandled()) : (K = J._settlePromiseLateCancellationObserver, L = new m("late cancellation observer"), J._attachExtraTrace(L), G = S), c.invoke(K, J, {
                handler: z === null ? G : typeof G == "function" && v.domainBind(z, G),
                promise: V,
                receiver: T,
                value: L
              });
            } else
              J._addCallbacks(O, S, V, T, z);
            return V;
          }, k.prototype._length = function() {
            return this._bitField & 65535;
          }, k.prototype._isFateSealed = function() {
            return (this._bitField & 117506048) !== 0;
          }, k.prototype._isFollowing = function() {
            return (this._bitField & 67108864) === 67108864;
          }, k.prototype._setLength = function(O) {
            this._bitField = this._bitField & -65536 | O & 65535;
          }, k.prototype._setFulfilled = function() {
            this._bitField = this._bitField | 33554432, this._fireEvent("promiseFulfilled", this);
          }, k.prototype._setRejected = function() {
            this._bitField = this._bitField | 16777216, this._fireEvent("promiseRejected", this);
          }, k.prototype._setFollowing = function() {
            this._bitField = this._bitField | 67108864, this._fireEvent("promiseResolved", this);
          }, k.prototype._setIsFinal = function() {
            this._bitField = this._bitField | 4194304;
          }, k.prototype._isFinal = function() {
            return (this._bitField & 4194304) > 0;
          }, k.prototype._unsetCancelled = function() {
            this._bitField = this._bitField & -65537;
          }, k.prototype._setCancelled = function() {
            this._bitField = this._bitField | 65536, this._fireEvent("promiseCancelled", this);
          }, k.prototype._setWillBeCancelled = function() {
            this._bitField = this._bitField | 8388608;
          }, k.prototype._setAsyncGuaranteed = function() {
            c.hasCustomScheduler() || (this._bitField = this._bitField | 134217728);
          }, k.prototype._receiverAt = function(O) {
            var S = O === 0 ? this._receiver0 : this[O * 4 - 4 + 3];
            if (S !== a)
              return S === void 0 && this._isBound() ? this._boundValue() : S;
          }, k.prototype._promiseAt = function(O) {
            return this[O * 4 - 4 + 2];
          }, k.prototype._fulfillmentHandlerAt = function(O) {
            return this[O * 4 - 4 + 0];
          }, k.prototype._rejectionHandlerAt = function(O) {
            return this[O * 4 - 4 + 1];
          }, k.prototype._boundValue = function() {
          }, k.prototype._migrateCallback0 = function(O) {
            O._bitField;
            var S = O._fulfillmentHandler0, F = O._rejectionHandler0, T = O._promise0, I = O._receiverAt(0);
            I === void 0 && (I = a), this._addCallbacks(S, F, T, I, null);
          }, k.prototype._migrateCallbackAt = function(O, S) {
            var F = O._fulfillmentHandlerAt(S), T = O._rejectionHandlerAt(S), I = O._promiseAt(S), M = O._receiverAt(S);
            M === void 0 && (M = a), this._addCallbacks(F, T, I, M, null);
          }, k.prototype._addCallbacks = function(O, S, F, T, I) {
            var M = this._length();
            if (M >= 65535 - 4 && (M = 0, this._setLength(0)), M === 0)
              this._promise0 = F, this._receiver0 = T, typeof O == "function" && (this._fulfillmentHandler0 = I === null ? O : v.domainBind(I, O)), typeof S == "function" && (this._rejectionHandler0 = I === null ? S : v.domainBind(I, S));
            else {
              var V = M * 4 - 4;
              this[V + 2] = F, this[V + 3] = T, typeof O == "function" && (this[V + 0] = I === null ? O : v.domainBind(I, O)), typeof S == "function" && (this[V + 1] = I === null ? S : v.domainBind(I, S));
            }
            return this._setLength(M + 1), M;
          }, k.prototype._proxy = function(O, S) {
            this._addCallbacks(void 0, void 0, S, O, null);
          }, k.prototype._resolveCallback = function(O, S) {
            if (!(this._bitField & 117506048)) {
              if (O === this)
                return this._rejectCallback(Z(), !1);
              var F = l(O, this);
              if (!(F instanceof k))
                return this._fulfill(O);
              S && this._propagateFrom(F, 2);
              var T = F._target();
              if (T === this) {
                this._reject(Z());
                return;
              }
              var I = T._bitField;
              if (I & 50397184)
                if (I & 33554432)
                  this._fulfill(T._value());
                else if (I & 16777216)
                  this._reject(T._reason());
                else {
                  var J = new m("late cancellation observer");
                  T._attachExtraTrace(J), this._reject(J);
                }
              else {
                var M = this._length();
                M > 0 && T._migrateCallback0(this);
                for (var V = 1; V < M; ++V)
                  T._migrateCallbackAt(this, V);
                this._setFollowing(), this._setLength(0), this._setFollowee(T);
              }
            }
          }, k.prototype._rejectCallback = function(O, S, F) {
            var T = v.ensureErrorObject(O), I = T === O;
            if (!I && !F && b.warnings()) {
              var M = "a promise was rejected with a non-error: " + v.classString(O);
              this._warn(M, !0);
            }
            this._attachExtraTrace(T, S ? I : !1), this._reject(O);
          }, k.prototype._resolveFromExecutor = function(O) {
            var S = this;
            this._captureStackTrace(), this._pushContext();
            var F = !0, T = this._execute(O, function(I) {
              S._resolveCallback(I);
            }, function(I) {
              S._rejectCallback(I, F);
            });
            F = !1, this._popContext(), T !== void 0 && S._rejectCallback(T, !0);
          }, k.prototype._settlePromiseFromHandler = function(O, S, F, T) {
            var I = T._bitField;
            if (!(I & 65536)) {
              T._pushContext();
              var M;
              S === n ? !F || typeof F.length != "number" ? (M = X, M.e = new p("cannot .spread() a non-array: " + v.classString(F))) : M = B(O).apply(this._boundValue(), F) : M = B(O).call(S, F);
              var V = T._popContext();
              I = T._bitField, !(I & 65536) && (M === i ? T._reject(F) : M === X ? T._rejectCallback(M.e, !1) : (b.checkForgottenReturns(M, V, "", T, this), T._resolveCallback(M)));
            }
          }, k.prototype._target = function() {
            for (var O = this; O._isFollowing(); )
              O = O._followee();
            return O;
          }, k.prototype._followee = function() {
            return this._rejectionHandler0;
          }, k.prototype._setFollowee = function(O) {
            this._rejectionHandler0 = O;
          }, k.prototype._settlePromise = function(O, S, F, T) {
            var I = O instanceof k, M = this._bitField, V = (M & 134217728) !== 0;
            M & 65536 ? (I && O._invokeInternalOnCancel(), F instanceof A && F.isFinallyHandler() ? (F.cancelPromise = O, B(S).call(F, T) === X && O._reject(X.e)) : S === o ? O._fulfill(o.call(F)) : F instanceof t ? F._promiseCancelled(O) : I || O instanceof u ? O._cancel() : F.cancel()) : typeof S == "function" ? I ? (V && O._setAsyncGuaranteed(), this._settlePromiseFromHandler(S, F, T, O)) : S.call(F, T, O) : F instanceof t ? F._isResolved() || (M & 33554432 ? F._promiseFulfilled(T, O) : F._promiseRejected(T, O)) : I && (V && O._setAsyncGuaranteed(), M & 33554432 ? O._fulfill(T) : O._reject(T));
          }, k.prototype._settlePromiseLateCancellationObserver = function(O) {
            var S = O.handler, F = O.promise, T = O.receiver, I = O.value;
            typeof S == "function" ? F instanceof k ? this._settlePromiseFromHandler(S, T, I, F) : S.call(T, I, F) : F instanceof k && F._reject(I);
          }, k.prototype._settlePromiseCtx = function(O) {
            this._settlePromise(O.promise, O.handler, O.receiver, O.value);
          }, k.prototype._settlePromise0 = function(O, S, F) {
            var T = this._promise0, I = this._receiverAt(0);
            this._promise0 = void 0, this._receiver0 = void 0, this._settlePromise(T, O, I, S);
          }, k.prototype._clearCallbackDataAtIndex = function(O) {
            var S = O * 4 - 4;
            this[S + 2] = this[S + 3] = this[S + 0] = this[S + 1] = void 0;
          }, k.prototype._fulfill = function(O) {
            var S = this._bitField;
            if (!((S & 117506048) >>> 16)) {
              if (O === this) {
                var F = Z();
                return this._attachExtraTrace(F), this._reject(F);
              }
              this._setFulfilled(), this._rejectionHandler0 = O, (S & 65535) > 0 && (S & 134217728 ? this._settlePromises() : c.settlePromises(this));
            }
          }, k.prototype._reject = function(O) {
            var S = this._bitField;
            if (!((S & 117506048) >>> 16)) {
              if (this._setRejected(), this._fulfillmentHandler0 = O, this._isFinal())
                return c.fatalError(O, v.isNode);
              (S & 65535) > 0 ? c.settlePromises(this) : this._ensurePossibleRejectionHandled();
            }
          }, k.prototype._fulfillPromises = function(O, S) {
            for (var F = 1; F < O; F++) {
              var T = this._fulfillmentHandlerAt(F), I = this._promiseAt(F), M = this._receiverAt(F);
              this._clearCallbackDataAtIndex(F), this._settlePromise(I, T, M, S);
            }
          }, k.prototype._rejectPromises = function(O, S) {
            for (var F = 1; F < O; F++) {
              var T = this._rejectionHandlerAt(F), I = this._promiseAt(F), M = this._receiverAt(F);
              this._clearCallbackDataAtIndex(F), this._settlePromise(I, T, M, S);
            }
          }, k.prototype._settlePromises = function() {
            var O = this._bitField, S = O & 65535;
            if (S > 0) {
              if (O & 16842752) {
                var F = this._fulfillmentHandler0;
                this._settlePromise0(this._rejectionHandler0, F, O), this._rejectPromises(S, F);
              } else {
                var T = this._rejectionHandler0;
                this._settlePromise0(this._fulfillmentHandler0, T, O), this._fulfillPromises(S, T);
              }
              this._setLength(0);
            }
            this._clearCancellationData();
          }, k.prototype._settledValue = function() {
            var O = this._bitField;
            if (O & 33554432)
              return this._rejectionHandler0;
            if (O & 16777216)
              return this._fulfillmentHandler0;
          };
          function x(O) {
            this.promise._resolveCallback(O);
          }
          function f(O) {
            this.promise._rejectCallback(O, !1);
          }
          k.defer = k.pending = function() {
            b.deprecated("Promise.defer", "new Promise");
            var O = new k(g);
            return {
              promise: O,
              resolve: x,
              reject: f
            };
          }, v.notEnumerableProp(
            k,
            "_makeSelfResolutionError",
            Z
          ), le("./method")(
            k,
            g,
            l,
            C,
            b
          ), le("./bind")(k, g, l, b), le("./cancel")(k, u, C, b), le("./direct_resolve")(k), le("./synchronous_inspection")(k), le("./join")(
            k,
            u,
            l,
            g,
            c,
            h
          ), k.Promise = k, k.version = "3.4.7", le("./map.js")(k, u, C, l, g, b), le("./call_get.js")(k), le("./using.js")(k, C, l, _, g, b), le("./timers.js")(k, g, b), le("./generators.js")(k, C, g, l, t, b), le("./nodeify.js")(k), le("./promisify.js")(k, g), le("./props.js")(k, u, l, C), le("./race.js")(k, g, l, C), le("./reduce.js")(k, u, C, l, g, b), le("./settle.js")(k, u, b), le("./some.js")(k, u, C), le("./filter.js")(k, g), le("./each.js")(k, g), le("./any.js")(k), v.toFastProperties(k), v.toFastProperties(k.prototype);
          function U(O) {
            var S = new k(g);
            S._fulfillmentHandler0 = O, S._rejectionHandler0 = O, S._promise0 = O, S._receiver0 = O;
          }
          return U({ a: 1 }), U({ b: 2 }), U({ c: 3 }), U(1), U(function() {
          }), U(void 0), U(!1), U(new k(g)), b.setBounds(y.firstLineError, v.lastLineError), k;
        };
      }).call(this, le("_process"));
    }, { "./any.js": 41, "./async": 42, "./bind": 43, "./call_get.js": 44, "./cancel": 45, "./catch_filter": 46, "./context": 47, "./debuggability": 48, "./direct_resolve": 49, "./each.js": 50, "./errors": 51, "./es5": 52, "./filter.js": 53, "./finally": 54, "./generators.js": 55, "./join": 56, "./map.js": 57, "./method": 58, "./nodeback": 59, "./nodeify.js": 60, "./promise_array": 62, "./promisify.js": 63, "./props.js": 64, "./race.js": 66, "./reduce.js": 67, "./settle.js": 69, "./some.js": 70, "./synchronous_inspection": 71, "./thenables": 72, "./timers.js": 73, "./using.js": 74, "./util": 75, _process: 102 }], 62: [function(le, ce, re) {
      ce.exports = function(ae, Z, o, C, t) {
        var a = le("./util");
        a.isArray;
        function v(e) {
          switch (e) {
            case -2:
              return [];
            case -3:
              return {};
          }
        }
        function h(e) {
          var y = this._promise = new ae(Z);
          e instanceof ae && y._propagateFrom(e, 3), y._setOnCancel(this), this._values = e, this._length = 0, this._totalResolved = 0, this._init(void 0, -2);
        }
        return a.inherits(h, t), h.prototype.length = function() {
          return this._length;
        }, h.prototype.promise = function() {
          return this._promise;
        }, h.prototype._init = function e(y, c) {
          var d = o(this._values, this._promise);
          if (d instanceof ae) {
            d = d._target();
            var p = d._bitField;
            if (this._values = d, p & 50397184)
              if (p & 33554432)
                d = d._value();
              else
                return p & 16777216 ? this._reject(d._reason()) : this._cancel();
            else
              return this._promise._setAsyncGuaranteed(), d._then(
                e,
                this._reject,
                void 0,
                this,
                c
              );
          }
          if (d = a.asArray(d), d === null) {
            var m = C(
              "expecting an array or an iterable object but got " + a.classString(d)
            ).reason();
            this._promise._rejectCallback(m, !1);
            return;
          }
          if (d.length === 0) {
            c === -5 ? this._resolveEmptyArray() : this._resolve(v(c));
            return;
          }
          this._iterate(d);
        }, h.prototype._iterate = function(e) {
          var y = this.getActualLength(e.length);
          this._length = y, this._values = this.shouldCopyValues() ? new Array(y) : this._values;
          for (var c = this._promise, d = !1, p = null, m = 0; m < y; ++m) {
            var g = o(e[m], c);
            g instanceof ae ? (g = g._target(), p = g._bitField) : p = null, d ? p !== null && g.suppressUnhandledRejections() : p !== null ? p & 50397184 ? p & 33554432 ? d = this._promiseFulfilled(g._value(), m) : p & 16777216 ? d = this._promiseRejected(g._reason(), m) : d = this._promiseCancelled(m) : (g._proxy(this, m), this._values[m] = g) : d = this._promiseFulfilled(g, m);
          }
          d || c._setAsyncGuaranteed();
        }, h.prototype._isResolved = function() {
          return this._values === null;
        }, h.prototype._resolve = function(e) {
          this._values = null, this._promise._fulfill(e);
        }, h.prototype._cancel = function() {
          this._isResolved() || !this._promise._isCancellable() || (this._values = null, this._promise._cancel());
        }, h.prototype._reject = function(e) {
          this._values = null, this._promise._rejectCallback(e, !1);
        }, h.prototype._promiseFulfilled = function(e, y) {
          this._values[y] = e;
          var c = ++this._totalResolved;
          return c >= this._length ? (this._resolve(this._values), !0) : !1;
        }, h.prototype._promiseCancelled = function() {
          return this._cancel(), !0;
        }, h.prototype._promiseRejected = function(e) {
          return this._totalResolved++, this._reject(e), !0;
        }, h.prototype._resultCancelled = function() {
          if (!this._isResolved()) {
            var e = this._values;
            if (this._cancel(), e instanceof ae)
              e.cancel();
            else
              for (var y = 0; y < e.length; ++y)
                e[y] instanceof ae && e[y].cancel();
          }
        }, h.prototype.shouldCopyValues = function() {
          return !0;
        }, h.prototype.getActualLength = function(e) {
          return e;
        }, h;
      };
    }, { "./util": 75 }], 63: [function(le, ce, re) {
      ce.exports = function(ae, Z) {
        var o = {}, C = le("./util"), t = le("./nodeback"), a = C.withAppended, v = C.maybeWrapAsError, h = C.canEvaluate, e = le("./errors").TypeError, y = "Async", c = { __isPromisified__: !0 }, d = [
          "arity",
          "length",
          "name",
          "arguments",
          "caller",
          "callee",
          "prototype",
          "__isPromisified__"
        ], p = new RegExp("^(?:" + d.join("|") + ")$"), m = function(x) {
          return C.isIdentifier(x) && x.charAt(0) !== "_" && x !== "constructor";
        };
        function g(x) {
          return !p.test(x);
        }
        function n(x) {
          try {
            return x.__isPromisified__ === !0;
          } catch {
            return !1;
          }
        }
        function i(x, f, U) {
          var O = C.getDataPropertyOrDefault(
            x,
            f + U,
            c
          );
          return O ? n(O) : !1;
        }
        function l(x, f, U) {
          for (var O = 0; O < x.length; O += 2) {
            var S = x[O];
            if (U.test(S)) {
              for (var F = S.replace(U, ""), T = 0; T < x.length; T += 2)
                if (x[T] === F)
                  throw new e(`Cannot promisify an API that has normal methods with '%s'-suffix

    See http://goo.gl/MqrFmX
`.replace("%s", f));
            }
          }
        }
        function u(x, f, U, O) {
          for (var S = C.inheritedDataKeys(x), F = [], T = 0; T < S.length; ++T) {
            var I = S[T], M = x[I], V = O === m ? !0 : m(I);
            typeof M == "function" && !n(M) && !i(x, I, f) && O(I, M, x, V) && F.push(I, M);
          }
          return l(F, f, U), F;
        }
        var w = function(x) {
          return x.replace(/([$])/, "\\$");
        }, _;
        {
          var b = function(x) {
            for (var f = [x], U = Math.max(0, x - 1 - 3), O = x - 1; O >= U; --O)
              f.push(O);
            for (var O = x + 1; O <= 3; ++O)
              f.push(O);
            return f;
          }, A = function(x) {
            return C.filledRange(x, "_arg", "");
          }, Y = function(x) {
            return C.filledRange(
              Math.max(x, 3),
              "_arg",
              ""
            );
          }, j = function(x) {
            return typeof x.length == "number" ? Math.max(Math.min(x.length, 1024), 0) : 0;
          };
          _ = function(x, f, U, O, S, F) {
            var T = Math.max(0, j(O) - 1), I = b(T), M = typeof x == "string" || f === o;
            function V(G) {
              var L = A(G).join(", "), K = G > 0 ? ", " : "", te;
              return M ? te = `ret = callback.call(this, {{args}}, nodeback); break;
` : te = f === void 0 ? `ret = callback({{args}}, nodeback); break;
` : `ret = callback.call(receiver, {{args}}, nodeback); break;
`, te.replace("{{args}}", L).replace(", ", K);
            }
            function J() {
              for (var G = "", L = 0; L < I.length; ++L)
                G += "case " + I[L] + ":" + V(I[L]);
              return G += `                                                             
	        default:                                                             
	            var args = new Array(len + 1);                                   
	            var i = 0;                                                       
	            for (var i = 0; i < len; ++i) {                                  
	               args[i] = arguments[i];                                       
	            }                                                                
	            args[i] = nodeback;                                              
	            [CodeForCall]                                                    
	            break;                                                           
	        `.replace("[CodeForCall]", M ? `ret = callback.apply(this, args);
` : `ret = callback.apply(receiver, args);
`), G;
            }
            var W = typeof x == "string" ? "this != null ? this['" + x + "'] : fn" : "fn", z = `'use strict';                                                
	        var ret = function (Parameters) {                                    
	            'use strict';                                                    
	            var len = arguments.length;                                      
	            var promise = new Promise(INTERNAL);                             
	            promise._captureStackTrace();                                    
	            var nodeback = nodebackForPromise(promise, ` + F + `);   
	            var ret;                                                         
	            var callback = tryCatch([GetFunctionCode]);                      
	            switch(len) {                                                    
	                [CodeForSwitchCase]                                          
	            }                                                                
	            if (ret === errorObj) {                                          
	                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
	            }                                                                
	            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     
	            return promise;                                                  
	        };                                                                   
	        notEnumerableProp(ret, '__isPromisified__', true);                   
	        return ret;                                                          
	    `.replace("[CodeForSwitchCase]", J()).replace("[GetFunctionCode]", W);
            return z = z.replace("Parameters", Y(T)), new Function(
              "Promise",
              "fn",
              "receiver",
              "withAppended",
              "maybeWrapAsError",
              "nodebackForPromise",
              "tryCatch",
              "errorObj",
              "notEnumerableProp",
              "INTERNAL",
              z
            )(
              ae,
              O,
              f,
              a,
              v,
              t,
              C.tryCatch,
              C.errorObj,
              C.notEnumerableProp,
              Z
            );
          };
        }
        function X(x, f, U, O, S, F) {
          var T = function() {
            return this;
          }(), I = x;
          typeof I == "string" && (x = O);
          function M() {
            var V = f;
            f === o && (V = this);
            var J = new ae(Z);
            J._captureStackTrace();
            var W = typeof I == "string" && this !== T ? this[I] : x, z = t(J, F);
            try {
              W.apply(V, a(arguments, z));
            } catch (G) {
              J._rejectCallback(v(G), !0, !0);
            }
            return J._isFateSealed() || J._setAsyncGuaranteed(), J;
          }
          return C.notEnumerableProp(M, "__isPromisified__", !0), M;
        }
        var B = h ? _ : X;
        function R(x, f, U, O, S) {
          for (var F = new RegExp(w(f) + "$"), T = u(x, f, F, U), I = 0, M = T.length; I < M; I += 2) {
            var V = T[I], J = T[I + 1], W = V + f;
            if (O === B)
              x[W] = B(V, o, V, J, f, S);
            else {
              var z = O(J, function() {
                return B(
                  V,
                  o,
                  V,
                  J,
                  f,
                  S
                );
              });
              C.notEnumerableProp(z, "__isPromisified__", !0), x[W] = z;
            }
          }
          return C.toFastProperties(x), x;
        }
        function k(x, f, U) {
          return B(
            x,
            f,
            void 0,
            x,
            null,
            U
          );
        }
        ae.promisify = function(x, f) {
          if (typeof x != "function")
            throw new e("expecting a function but got " + C.classString(x));
          if (n(x))
            return x;
          f = Object(f);
          var U = f.context === void 0 ? o : f.context, O = !!f.multiArgs, S = k(x, U, O);
          return C.copyDescriptors(x, S, g), S;
        }, ae.promisifyAll = function(x, f) {
          if (typeof x != "function" && typeof x != "object")
            throw new e(`the target of promisifyAll must be an object or a function

    See http://goo.gl/MqrFmX
`);
          f = Object(f);
          var U = !!f.multiArgs, O = f.suffix;
          typeof O != "string" && (O = y);
          var S = f.filter;
          typeof S != "function" && (S = m);
          var F = f.promisifier;
          if (typeof F != "function" && (F = B), !C.isIdentifier(O))
            throw new RangeError(`suffix must be a valid identifier

    See http://goo.gl/MqrFmX
`);
          for (var T = C.inheritedDataKeys(x), I = 0; I < T.length; ++I) {
            var M = x[T[I]];
            T[I] !== "constructor" && C.isClass(M) && (R(
              M.prototype,
              O,
              S,
              F,
              U
            ), R(M, O, S, F, U));
          }
          return R(x, O, S, F, U);
        };
      };
    }, { "./errors": 51, "./nodeback": 59, "./util": 75 }], 64: [function(le, ce, re) {
      ce.exports = function(ae, Z, o, C) {
        var t = le("./util"), a = t.isObject, v = le("./es5"), h;
        typeof Map == "function" && (h = Map);
        var e = function() {
          var p = 0, m = 0;
          function g(n, i) {
            this[p] = n, this[p + m] = i, p++;
          }
          return function(i) {
            m = i.size, p = 0;
            var l = new Array(i.size * 2);
            return i.forEach(g, l), l;
          };
        }(), y = function(p) {
          for (var m = new h(), g = p.length / 2 | 0, n = 0; n < g; ++n) {
            var i = p[g + n], l = p[n];
            m.set(i, l);
          }
          return m;
        };
        function c(p) {
          var m = !1, g;
          if (h !== void 0 && p instanceof h)
            g = e(p), m = !0;
          else {
            var n = v.keys(p), i = n.length;
            g = new Array(i * 2);
            for (var l = 0; l < i; ++l) {
              var u = n[l];
              g[l] = p[u], g[l + i] = u;
            }
          }
          this.constructor$(g), this._isMap = m, this._init$(void 0, -3);
        }
        t.inherits(c, Z), c.prototype._init = function() {
        }, c.prototype._promiseFulfilled = function(p, m) {
          this._values[m] = p;
          var g = ++this._totalResolved;
          if (g >= this._length) {
            var n;
            if (this._isMap)
              n = y(this._values);
            else {
              n = {};
              for (var i = this.length(), l = 0, u = this.length(); l < u; ++l)
                n[this._values[l + i]] = this._values[l];
            }
            return this._resolve(n), !0;
          }
          return !1;
        }, c.prototype.shouldCopyValues = function() {
          return !1;
        }, c.prototype.getActualLength = function(p) {
          return p >> 1;
        };
        function d(p) {
          var m, g = o(p);
          if (a(g))
            g instanceof ae ? m = g._then(
              ae.props,
              void 0,
              void 0,
              void 0,
              void 0
            ) : m = new c(g).promise();
          else
            return C(`cannot await properties of a non-object

    See http://goo.gl/MqrFmX
`);
          return g instanceof ae && m._propagateFrom(g, 2), m;
        }
        ae.prototype.props = function() {
          return d(this);
        }, ae.props = function(p) {
          return d(p);
        };
      };
    }, { "./es5": 52, "./util": 75 }], 65: [function(le, ce, re) {
      function ae(o, C, t, a, v) {
        for (var h = 0; h < v; ++h)
          t[h + a] = o[h + C], o[h + C] = void 0;
      }
      function Z(o) {
        this._capacity = o, this._length = 0, this._front = 0;
      }
      Z.prototype._willBeOverCapacity = function(o) {
        return this._capacity < o;
      }, Z.prototype._pushOne = function(o) {
        var C = this.length();
        this._checkCapacity(C + 1);
        var t = this._front + C & this._capacity - 1;
        this[t] = o, this._length = C + 1;
      }, Z.prototype.push = function(o, C, t) {
        var a = this.length() + 3;
        if (this._willBeOverCapacity(a)) {
          this._pushOne(o), this._pushOne(C), this._pushOne(t);
          return;
        }
        var v = this._front + a - 3;
        this._checkCapacity(a);
        var h = this._capacity - 1;
        this[v + 0 & h] = o, this[v + 1 & h] = C, this[v + 2 & h] = t, this._length = a;
      }, Z.prototype.shift = function() {
        var o = this._front, C = this[o];
        return this[o] = void 0, this._front = o + 1 & this._capacity - 1, this._length--, C;
      }, Z.prototype.length = function() {
        return this._length;
      }, Z.prototype._checkCapacity = function(o) {
        this._capacity < o && this._resizeTo(this._capacity << 1);
      }, Z.prototype._resizeTo = function(o) {
        var C = this._capacity;
        this._capacity = o;
        var t = this._front, a = this._length, v = t + a & C - 1;
        ae(this, 0, this, C, v);
      }, ce.exports = Z;
    }, {}], 66: [function(le, ce, re) {
      ce.exports = function(ae, Z, o, C) {
        var t = le("./util"), a = function(h) {
          return h.then(function(e) {
            return v(e, h);
          });
        };
        function v(h, e) {
          var y = o(h);
          if (y instanceof ae)
            return a(y);
          if (h = t.asArray(h), h === null)
            return C("expecting an array or an iterable object but got " + t.classString(h));
          var c = new ae(Z);
          e !== void 0 && c._propagateFrom(e, 3);
          for (var d = c._fulfill, p = c._reject, m = 0, g = h.length; m < g; ++m) {
            var n = h[m];
            n === void 0 && !(m in h) || ae.cast(n)._then(d, p, void 0, c, null);
          }
          return c;
        }
        ae.race = function(h) {
          return v(h, void 0);
        }, ae.prototype.race = function() {
          return v(this, void 0);
        };
      };
    }, { "./util": 75 }], 67: [function(le, ce, re) {
      ce.exports = function(ae, Z, o, C, t, a) {
        var v = ae._getDomain, h = le("./util"), e = h.tryCatch;
        function y(g, n, i, l) {
          this.constructor$(g);
          var u = v();
          this._fn = u === null ? n : h.domainBind(u, n), i !== void 0 && (i = ae.resolve(i), i._attachCancellationCallback(this)), this._initialValue = i, this._currentCancellable = null, l === t ? this._eachValues = Array(this._length) : l === 0 ? this._eachValues = null : this._eachValues = void 0, this._promise._captureStackTrace(), this._init$(void 0, -5);
        }
        h.inherits(y, Z), y.prototype._gotAccum = function(g) {
          this._eachValues !== void 0 && this._eachValues !== null && g !== t && this._eachValues.push(g);
        }, y.prototype._eachComplete = function(g) {
          return this._eachValues !== null && this._eachValues.push(g), this._eachValues;
        }, y.prototype._init = function() {
        }, y.prototype._resolveEmptyArray = function() {
          this._resolve(this._eachValues !== void 0 ? this._eachValues : this._initialValue);
        }, y.prototype.shouldCopyValues = function() {
          return !1;
        }, y.prototype._resolve = function(g) {
          this._promise._resolveCallback(g), this._values = null;
        }, y.prototype._resultCancelled = function(g) {
          if (g === this._initialValue)
            return this._cancel();
          this._isResolved() || (this._resultCancelled$(), this._currentCancellable instanceof ae && this._currentCancellable.cancel(), this._initialValue instanceof ae && this._initialValue.cancel());
        }, y.prototype._iterate = function(g) {
          this._values = g;
          var n, i, l = g.length;
          if (this._initialValue !== void 0 ? (n = this._initialValue, i = 0) : (n = ae.resolve(g[0]), i = 1), this._currentCancellable = n, !n.isRejected())
            for (; i < l; ++i) {
              var u = {
                accum: null,
                value: g[i],
                index: i,
                length: l,
                array: this
              };
              n = n._then(p, void 0, void 0, u, void 0);
            }
          this._eachValues !== void 0 && (n = n._then(this._eachComplete, void 0, void 0, this, void 0)), n._then(c, c, void 0, n, this);
        }, ae.prototype.reduce = function(g, n) {
          return d(this, g, n, null);
        }, ae.reduce = function(g, n, i, l) {
          return d(g, n, i, l);
        };
        function c(g, n) {
          this.isFulfilled() ? n._resolve(g) : n._reject(g);
        }
        function d(g, n, i, l) {
          if (typeof n != "function")
            return o("expecting a function but got " + h.classString(n));
          var u = new y(g, n, i, l);
          return u.promise();
        }
        function p(g) {
          this.accum = g, this.array._gotAccum(g);
          var n = C(this.value, this.array._promise);
          return n instanceof ae ? (this.array._currentCancellable = n, n._then(m, void 0, void 0, this, void 0)) : m.call(this, n);
        }
        function m(g) {
          var n = this.array, i = n._promise, l = e(n._fn);
          i._pushContext();
          var u;
          n._eachValues !== void 0 ? u = l.call(i._boundValue(), g, this.index, this.length) : u = l.call(
            i._boundValue(),
            this.accum,
            g,
            this.index,
            this.length
          ), u instanceof ae && (n._currentCancellable = u);
          var w = i._popContext();
          return a.checkForgottenReturns(
            u,
            w,
            n._eachValues !== void 0 ? "Promise.each" : "Promise.reduce",
            i
          ), u;
        }
      };
    }, { "./util": 75 }], 68: [function(le, ce, re) {
      (function(ae, Z) {
        var o = le("./util"), C, t = function() {
          throw new Error(`No async scheduler available

    See http://goo.gl/MqrFmX
`);
        }, a = o.getNativePromise();
        if (o.isNode && typeof MutationObserver > "u") {
          var v = Z.setImmediate, h = ae.nextTick;
          C = o.isRecentNode ? function(y) {
            v.call(Z, y);
          } : function(y) {
            h.call(ae, y);
          };
        } else if (typeof a == "function" && typeof a.resolve == "function") {
          var e = a.resolve();
          C = function(y) {
            e.then(y);
          };
        } else
          typeof MutationObserver < "u" && !(typeof window < "u" && window.navigator && (window.navigator.standalone || window.cordova)) ? C = function() {
            var y = document.createElement("div"), c = { attributes: !0 }, d = !1, p = document.createElement("div"), m = new MutationObserver(function() {
              y.classList.toggle("foo"), d = !1;
            });
            m.observe(p, c);
            var g = function() {
              d || (d = !0, p.classList.toggle("foo"));
            };
            return function(i) {
              var l = new MutationObserver(function() {
                l.disconnect(), i();
              });
              l.observe(y, c), g();
            };
          }() : typeof setImmediate < "u" ? C = function(y) {
            setImmediate(y);
          } : typeof setTimeout < "u" ? C = function(y) {
            setTimeout(y, 0);
          } : C = t;
        ce.exports = C;
      }).call(this, le("_process"), typeof commonjsGlobal < "u" ? commonjsGlobal : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "./util": 75, _process: 102 }], 69: [function(le, ce, re) {
      ce.exports = function(ae, Z, o) {
        var C = ae.PromiseInspection, t = le("./util");
        function a(v) {
          this.constructor$(v);
        }
        t.inherits(a, Z), a.prototype._promiseResolved = function(v, h) {
          this._values[v] = h;
          var e = ++this._totalResolved;
          return e >= this._length ? (this._resolve(this._values), !0) : !1;
        }, a.prototype._promiseFulfilled = function(v, h) {
          var e = new C();
          return e._bitField = 33554432, e._settledValueField = v, this._promiseResolved(h, e);
        }, a.prototype._promiseRejected = function(v, h) {
          var e = new C();
          return e._bitField = 16777216, e._settledValueField = v, this._promiseResolved(h, e);
        }, ae.settle = function(v) {
          return o.deprecated(".settle()", ".reflect()"), new a(v).promise();
        }, ae.prototype.settle = function() {
          return ae.settle(this);
        };
      };
    }, { "./util": 75 }], 70: [function(le, ce, re) {
      ce.exports = function(ae, Z, o) {
        var C = le("./util"), t = le("./errors").RangeError, a = le("./errors").AggregateError, v = C.isArray, h = {};
        function e(c) {
          this.constructor$(c), this._howMany = 0, this._unwrap = !1, this._initialized = !1;
        }
        C.inherits(e, Z), e.prototype._init = function() {
          if (this._initialized) {
            if (this._howMany === 0) {
              this._resolve([]);
              return;
            }
            this._init$(void 0, -5);
            var c = v(this._values);
            !this._isResolved() && c && this._howMany > this._canPossiblyFulfill() && this._reject(this._getRangeError(this.length()));
          }
        }, e.prototype.init = function() {
          this._initialized = !0, this._init();
        }, e.prototype.setUnwrap = function() {
          this._unwrap = !0;
        }, e.prototype.howMany = function() {
          return this._howMany;
        }, e.prototype.setHowMany = function(c) {
          this._howMany = c;
        }, e.prototype._promiseFulfilled = function(c) {
          return this._addFulfilled(c), this._fulfilled() === this.howMany() ? (this._values.length = this.howMany(), this.howMany() === 1 && this._unwrap ? this._resolve(this._values[0]) : this._resolve(this._values), !0) : !1;
        }, e.prototype._promiseRejected = function(c) {
          return this._addRejected(c), this._checkOutcome();
        }, e.prototype._promiseCancelled = function() {
          return this._values instanceof ae || this._values == null ? this._cancel() : (this._addRejected(h), this._checkOutcome());
        }, e.prototype._checkOutcome = function() {
          if (this.howMany() > this._canPossiblyFulfill()) {
            for (var c = new a(), d = this.length(); d < this._values.length; ++d)
              this._values[d] !== h && c.push(this._values[d]);
            return c.length > 0 ? this._reject(c) : this._cancel(), !0;
          }
          return !1;
        }, e.prototype._fulfilled = function() {
          return this._totalResolved;
        }, e.prototype._rejected = function() {
          return this._values.length - this.length();
        }, e.prototype._addRejected = function(c) {
          this._values.push(c);
        }, e.prototype._addFulfilled = function(c) {
          this._values[this._totalResolved++] = c;
        }, e.prototype._canPossiblyFulfill = function() {
          return this.length() - this._rejected();
        }, e.prototype._getRangeError = function(c) {
          var d = "Input array must contain at least " + this._howMany + " items but contains only " + c + " items";
          return new t(d);
        }, e.prototype._resolveEmptyArray = function() {
          this._reject(this._getRangeError(0));
        };
        function y(c, d) {
          if ((d | 0) !== d || d < 0)
            return o(`expecting a positive integer

    See http://goo.gl/MqrFmX
`);
          var p = new e(c), m = p.promise();
          return p.setHowMany(d), p.init(), m;
        }
        ae.some = function(c, d) {
          return y(c, d);
        }, ae.prototype.some = function(c) {
          return y(this, c);
        }, ae._SomePromiseArray = e;
      };
    }, { "./errors": 51, "./util": 75 }], 71: [function(le, ce, re) {
      ce.exports = function(ae) {
        function Z(e) {
          e !== void 0 ? (e = e._target(), this._bitField = e._bitField, this._settledValueField = e._isFateSealed() ? e._settledValue() : void 0) : (this._bitField = 0, this._settledValueField = void 0);
        }
        Z.prototype._settledValue = function() {
          return this._settledValueField;
        };
        var o = Z.prototype.value = function() {
          if (!this.isFulfilled())
            throw new TypeError(`cannot get fulfillment value of a non-fulfilled promise

    See http://goo.gl/MqrFmX
`);
          return this._settledValue();
        }, C = Z.prototype.error = Z.prototype.reason = function() {
          if (!this.isRejected())
            throw new TypeError(`cannot get rejection reason of a non-rejected promise

    See http://goo.gl/MqrFmX
`);
          return this._settledValue();
        }, t = Z.prototype.isFulfilled = function() {
          return (this._bitField & 33554432) !== 0;
        }, a = Z.prototype.isRejected = function() {
          return (this._bitField & 16777216) !== 0;
        }, v = Z.prototype.isPending = function() {
          return (this._bitField & 50397184) === 0;
        }, h = Z.prototype.isResolved = function() {
          return (this._bitField & 50331648) !== 0;
        };
        Z.prototype.isCancelled = function() {
          return (this._bitField & 8454144) !== 0;
        }, ae.prototype.__isCancelled = function() {
          return (this._bitField & 65536) === 65536;
        }, ae.prototype._isCancelled = function() {
          return this._target().__isCancelled();
        }, ae.prototype.isCancelled = function() {
          return (this._target()._bitField & 8454144) !== 0;
        }, ae.prototype.isPending = function() {
          return v.call(this._target());
        }, ae.prototype.isRejected = function() {
          return a.call(this._target());
        }, ae.prototype.isFulfilled = function() {
          return t.call(this._target());
        }, ae.prototype.isResolved = function() {
          return h.call(this._target());
        }, ae.prototype.value = function() {
          return o.call(this._target());
        }, ae.prototype.reason = function() {
          var e = this._target();
          return e._unsetRejectionIsUnhandled(), C.call(e);
        }, ae.prototype._value = function() {
          return this._settledValue();
        }, ae.prototype._reason = function() {
          return this._unsetRejectionIsUnhandled(), this._settledValue();
        }, ae.PromiseInspection = Z;
      };
    }, {}], 72: [function(le, ce, re) {
      ce.exports = function(ae, Z) {
        var o = le("./util"), C = o.errorObj, t = o.isObject;
        function a(d, p) {
          if (t(d)) {
            if (d instanceof ae)
              return d;
            var m = h(d);
            if (m === C) {
              p && p._pushContext();
              var g = ae.reject(m.e);
              return p && p._popContext(), g;
            } else if (typeof m == "function") {
              if (y(d)) {
                var g = new ae(Z);
                return d._then(
                  g._fulfill,
                  g._reject,
                  void 0,
                  g,
                  null
                ), g;
              }
              return c(d, m, p);
            }
          }
          return d;
        }
        function v(d) {
          return d.then;
        }
        function h(d) {
          try {
            return v(d);
          } catch (p) {
            return C.e = p, C;
          }
        }
        var e = {}.hasOwnProperty;
        function y(d) {
          try {
            return e.call(d, "_promise0");
          } catch {
            return !1;
          }
        }
        function c(d, p, m) {
          var g = new ae(Z), n = g;
          m && m._pushContext(), g._captureStackTrace(), m && m._popContext();
          var i = !0, l = o.tryCatch(p).call(d, u, w);
          i = !1, g && l === C && (g._rejectCallback(l.e, !0, !0), g = null);
          function u(_) {
            g && (g._resolveCallback(_), g = null);
          }
          function w(_) {
            g && (g._rejectCallback(_, i, !0), g = null);
          }
          return n;
        }
        return a;
      };
    }, { "./util": 75 }], 73: [function(le, ce, re) {
      ce.exports = function(ae, Z, o) {
        var C = le("./util"), t = ae.TimeoutError;
        function a(d) {
          this.handle = d;
        }
        a.prototype._resultCancelled = function() {
          clearTimeout(this.handle);
        };
        var v = function(d) {
          return h(+this).thenReturn(d);
        }, h = ae.delay = function(d, p) {
          var m, g;
          return p !== void 0 ? (m = ae.resolve(p)._then(v, null, null, d, void 0), o.cancellation() && p instanceof ae && m._setOnCancel(p)) : (m = new ae(Z), g = setTimeout(function() {
            m._fulfill();
          }, +d), o.cancellation() && m._setOnCancel(new a(g)), m._captureStackTrace()), m._setAsyncGuaranteed(), m;
        };
        ae.prototype.delay = function(d) {
          return h(d, this);
        };
        var e = function(d, p, m) {
          var g;
          typeof p != "string" ? p instanceof Error ? g = p : g = new t("operation timed out") : g = new t(p), C.markAsOriginatingFromRejection(g), d._attachExtraTrace(g), d._reject(g), m != null && m.cancel();
        };
        function y(d) {
          return clearTimeout(this.handle), d;
        }
        function c(d) {
          throw clearTimeout(this.handle), d;
        }
        ae.prototype.timeout = function(d, p) {
          d = +d;
          var m, g, n = new a(setTimeout(function() {
            m.isPending() && e(m, p, g);
          }, d));
          return o.cancellation() ? (g = this.then(), m = g._then(
            y,
            c,
            void 0,
            n,
            void 0
          ), m._setOnCancel(n)) : m = this._then(
            y,
            c,
            void 0,
            n,
            void 0
          ), m;
        };
      };
    }, { "./util": 75 }], 74: [function(le, ce, re) {
      ce.exports = function(ae, Z, o, C, t, a) {
        var v = le("./util"), h = le("./errors").TypeError, e = le("./util").inherits, y = v.errorObj, c = v.tryCatch, d = {};
        function p(w) {
          setTimeout(function() {
            throw w;
          }, 0);
        }
        function m(w) {
          var _ = o(w);
          return _ !== w && typeof w._isDisposable == "function" && typeof w._getDisposer == "function" && w._isDisposable() && _._setDisposable(w._getDisposer()), _;
        }
        function g(w, _) {
          var b = 0, A = w.length, Y = new ae(t);
          function j() {
            if (b >= A)
              return Y._fulfill();
            var X = m(w[b++]);
            if (X instanceof ae && X._isDisposable()) {
              try {
                X = o(
                  X._getDisposer().tryDispose(_),
                  w.promise
                );
              } catch (B) {
                return p(B);
              }
              if (X instanceof ae)
                return X._then(
                  j,
                  p,
                  null,
                  null,
                  null
                );
            }
            j();
          }
          return j(), Y;
        }
        function n(w, _, b) {
          this._data = w, this._promise = _, this._context = b;
        }
        n.prototype.data = function() {
          return this._data;
        }, n.prototype.promise = function() {
          return this._promise;
        }, n.prototype.resource = function() {
          return this.promise().isFulfilled() ? this.promise().value() : d;
        }, n.prototype.tryDispose = function(w) {
          var _ = this.resource(), b = this._context;
          b !== void 0 && b._pushContext();
          var A = _ !== d ? this.doDispose(_, w) : null;
          return b !== void 0 && b._popContext(), this._promise._unsetDisposable(), this._data = null, A;
        }, n.isDisposer = function(w) {
          return w != null && typeof w.resource == "function" && typeof w.tryDispose == "function";
        };
        function i(w, _, b) {
          this.constructor$(w, _, b);
        }
        e(i, n), i.prototype.doDispose = function(w, _) {
          var b = this.data();
          return b.call(w, w, _);
        };
        function l(w) {
          return n.isDisposer(w) ? (this.resources[this.index]._setDisposable(w), w.promise()) : w;
        }
        function u(w) {
          this.length = w, this.promise = null, this[w - 1] = null;
        }
        u.prototype._resultCancelled = function() {
          for (var w = this.length, _ = 0; _ < w; ++_) {
            var b = this[_];
            b instanceof ae && b.cancel();
          }
        }, ae.using = function() {
          var w = arguments.length;
          if (w < 2)
            return Z(
              "you must pass at least 2 arguments to Promise.using"
            );
          var _ = arguments[w - 1];
          if (typeof _ != "function")
            return Z("expecting a function but got " + v.classString(_));
          var b, A = !0;
          w === 2 && Array.isArray(arguments[0]) ? (b = arguments[0], w = b.length, A = !1) : (b = arguments, w--);
          for (var Y = new u(w), j = 0; j < w; ++j) {
            var X = b[j];
            if (n.isDisposer(X)) {
              var B = X;
              X = X.promise(), X._setDisposable(B);
            } else {
              var R = o(X);
              R instanceof ae && (X = R._then(l, null, null, {
                resources: Y,
                index: j
              }, void 0));
            }
            Y[j] = X;
          }
          for (var k = new Array(Y.length), j = 0; j < k.length; ++j)
            k[j] = ae.resolve(Y[j]).reflect();
          var x = ae.all(k).then(function(U) {
            for (var O = 0; O < U.length; ++O) {
              var S = U[O];
              if (S.isRejected())
                return y.e = S.error(), y;
              if (!S.isFulfilled()) {
                x.cancel();
                return;
              }
              U[O] = S.value();
            }
            f._pushContext(), _ = c(_);
            var F = A ? _.apply(void 0, U) : _(U), T = f._popContext();
            return a.checkForgottenReturns(
              F,
              T,
              "Promise.using",
              f
            ), F;
          }), f = x.lastly(function() {
            var U = new ae.PromiseInspection(x);
            return g(Y, U);
          });
          return Y.promise = f, f._setOnCancel(Y), f;
        }, ae.prototype._setDisposable = function(w) {
          this._bitField = this._bitField | 131072, this._disposer = w;
        }, ae.prototype._isDisposable = function() {
          return (this._bitField & 131072) > 0;
        }, ae.prototype._getDisposer = function() {
          return this._disposer;
        }, ae.prototype._unsetDisposable = function() {
          this._bitField = this._bitField & -131073, this._disposer = void 0;
        }, ae.prototype.disposer = function(w) {
          if (typeof w == "function")
            return new i(w, this, C());
          throw new h();
        };
      };
    }, { "./errors": 51, "./util": 75 }], 75: [function(le, ce, re) {
      (function(ae, Z) {
        var o = le("./es5"), C = typeof navigator > "u", t = { e: {} }, a, v = typeof self < "u" ? self : typeof window < "u" ? window : typeof Z < "u" ? Z : this !== void 0 ? this : null;
        function h() {
          try {
            var W = a;
            return a = null, W.apply(this, arguments);
          } catch (z) {
            return t.e = z, t;
          }
        }
        function e(W) {
          return a = W, h;
        }
        var y = function(W, z) {
          var G = {}.hasOwnProperty;
          function L() {
            this.constructor = W, this.constructor$ = z;
            for (var K in z.prototype)
              G.call(z.prototype, K) && K.charAt(K.length - 1) !== "$" && (this[K + "$"] = z.prototype[K]);
          }
          return L.prototype = z.prototype, W.prototype = new L(), W.prototype;
        };
        function c(W) {
          return W == null || W === !0 || W === !1 || typeof W == "string" || typeof W == "number";
        }
        function d(W) {
          return typeof W == "function" || typeof W == "object" && W !== null;
        }
        function p(W) {
          return c(W) ? new Error(j(W)) : W;
        }
        function m(W, z) {
          var G = W.length, L = new Array(G + 1), K;
          for (K = 0; K < G; ++K)
            L[K] = W[K];
          return L[K] = z, L;
        }
        function g(W, z, G) {
          if (o.isES5) {
            var L = Object.getOwnPropertyDescriptor(W, z);
            if (L != null)
              return L.get == null && L.set == null ? L.value : G;
          } else
            return {}.hasOwnProperty.call(W, z) ? W[z] : void 0;
        }
        function n(W, z, G) {
          if (c(W))
            return W;
          var L = {
            value: G,
            configurable: !0,
            enumerable: !1,
            writable: !0
          };
          return o.defineProperty(W, z, L), W;
        }
        function i(W) {
          throw W;
        }
        var l = function() {
          var W = [
            Array.prototype,
            Object.prototype,
            Function.prototype
          ], z = function(K) {
            for (var te = 0; te < W.length; ++te)
              if (W[te] === K)
                return !0;
            return !1;
          };
          if (o.isES5) {
            var G = Object.getOwnPropertyNames;
            return function(K) {
              for (var te = [], se = /* @__PURE__ */ Object.create(null); K != null && !z(K); ) {
                var q;
                try {
                  q = G(K);
                } catch {
                  return te;
                }
                for (var N = 0; N < q.length; ++N) {
                  var Q = q[N];
                  if (!se[Q]) {
                    se[Q] = !0;
                    var D = Object.getOwnPropertyDescriptor(K, Q);
                    D != null && D.get == null && D.set == null && te.push(Q);
                  }
                }
                K = o.getPrototypeOf(K);
              }
              return te;
            };
          } else {
            var L = {}.hasOwnProperty;
            return function(K) {
              if (z(K))
                return [];
              var te = [];
              e:
                for (var se in K)
                  if (L.call(K, se))
                    te.push(se);
                  else {
                    for (var q = 0; q < W.length; ++q)
                      if (L.call(W[q], se))
                        continue e;
                    te.push(se);
                  }
              return te;
            };
          }
        }(), u = /this\s*\.\s*\S+\s*=/;
        function w(W) {
          try {
            if (typeof W == "function") {
              var z = o.names(W.prototype), G = o.isES5 && z.length > 1, L = z.length > 0 && !(z.length === 1 && z[0] === "constructor"), K = u.test(W + "") && o.names(W).length > 0;
              if (G || L || K)
                return !0;
            }
            return !1;
          } catch {
            return !1;
          }
        }
        function _(W) {
          return W;
        }
        var b = /^[a-z$_][a-z$_0-9]*$/i;
        function A(W) {
          return b.test(W);
        }
        function Y(W, z, G) {
          for (var L = new Array(W), K = 0; K < W; ++K)
            L[K] = z + K + G;
          return L;
        }
        function j(W) {
          try {
            return W + "";
          } catch {
            return "[no string representation]";
          }
        }
        function X(W) {
          return W !== null && typeof W == "object" && typeof W.message == "string" && typeof W.name == "string";
        }
        function B(W) {
          try {
            n(W, "isOperational", !0);
          } catch {
          }
        }
        function R(W) {
          return W == null ? !1 : W instanceof Error.__BluebirdErrorTypes__.OperationalError || W.isOperational === !0;
        }
        function k(W) {
          return X(W) && o.propertyIsWritable(W, "stack");
        }
        var x = function() {
          return "stack" in new Error() ? function(W) {
            return k(W) ? W : new Error(j(W));
          } : function(W) {
            if (k(W))
              return W;
            try {
              throw new Error(j(W));
            } catch (z) {
              return z;
            }
          };
        }();
        function f(W) {
          return {}.toString.call(W);
        }
        function U(W, z, G) {
          for (var L = o.names(W), K = 0; K < L.length; ++K) {
            var te = L[K];
            if (G(te))
              try {
                o.defineProperty(z, te, o.getDescriptor(W, te));
              } catch {
              }
          }
        }
        var O = function(W) {
          return o.isArray(W) ? W : null;
        };
        if (typeof Symbol < "u" && Symbol.iterator) {
          var S = typeof Array.from == "function" ? function(W) {
            return Array.from(W);
          } : function(W) {
            for (var z = [], G = W[Symbol.iterator](), L; !(L = G.next()).done; )
              z.push(L.value);
            return z;
          };
          O = function(W) {
            return o.isArray(W) ? W : W != null && typeof W[Symbol.iterator] == "function" ? S(W) : null;
          };
        }
        var F = typeof ae < "u" && f(ae).toLowerCase() === "[object process]", T = typeof ae < "u" && typeof ae.env < "u";
        function I(W) {
          return T ? ae.env[W] : void 0;
        }
        function M() {
          if (typeof Promise == "function")
            try {
              var W = new Promise(function() {
              });
              if ({}.toString.call(W) === "[object Promise]")
                return Promise;
            } catch {
            }
        }
        function V(W, z) {
          return W.bind(z);
        }
        var J = {
          isClass: w,
          isIdentifier: A,
          inheritedDataKeys: l,
          getDataPropertyOrDefault: g,
          thrower: i,
          isArray: o.isArray,
          asArray: O,
          notEnumerableProp: n,
          isPrimitive: c,
          isObject: d,
          isError: X,
          canEvaluate: C,
          errorObj: t,
          tryCatch: e,
          inherits: y,
          withAppended: m,
          maybeWrapAsError: p,
          toFastProperties: _,
          filledRange: Y,
          toString: j,
          canAttachTrace: k,
          ensureErrorObject: x,
          originatesFromRejection: R,
          markAsOriginatingFromRejection: B,
          classString: f,
          copyDescriptors: U,
          hasDevTools: typeof chrome < "u" && chrome && typeof chrome.loadTimes == "function",
          isNode: F,
          hasEnvVariables: T,
          env: I,
          global: v,
          getNativePromise: M,
          domainBind: V
        };
        J.isRecentNode = J.isNode && function() {
          var W = ae.versions.node.split(".").map(Number);
          return W[0] === 0 && W[1] > 10 || W[0] > 0;
        }(), J.isNode && J.toFastProperties(ae);
        try {
          throw new Error();
        } catch (W) {
          J.lastLineError = W;
        }
        ce.exports = J;
      }).call(this, le("_process"), typeof commonjsGlobal < "u" ? commonjsGlobal : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "./es5": 52, _process: 102 }], 76: [function(le, ce, re) {
    }, {}], 77: [function(le, ce, re) {
      (function(ae) {
        var Z = le("buffer"), o = Z.Buffer, C = Z.SlowBuffer, t = Z.kMaxLength || 2147483647;
        re.alloc = function(v, h, e) {
          if (typeof o.alloc == "function")
            return o.alloc(v, h, e);
          if (typeof e == "number")
            throw new TypeError("encoding must not be number");
          if (typeof v != "number")
            throw new TypeError("size must be a number");
          if (v > t)
            throw new RangeError("size is too large");
          var y = e, c = h;
          c === void 0 && (y = void 0, c = 0);
          var d = new o(v);
          if (typeof c == "string")
            for (var p = new o(c, y), m = p.length, g = -1; ++g < v; )
              d[g] = p[g % m];
          else
            d.fill(c);
          return d;
        }, re.allocUnsafe = function(v) {
          if (typeof o.allocUnsafe == "function")
            return o.allocUnsafe(v);
          if (typeof v != "number")
            throw new TypeError("size must be a number");
          if (v > t)
            throw new RangeError("size is too large");
          return new o(v);
        }, re.from = function(v, h, e) {
          if (typeof o.from == "function" && (!ae.Uint8Array || Uint8Array.from !== o.from))
            return o.from(v, h, e);
          if (typeof v == "number")
            throw new TypeError('"value" argument must not be a number');
          if (typeof v == "string")
            return new o(v, h);
          if (typeof ArrayBuffer < "u" && v instanceof ArrayBuffer) {
            var y = h;
            if (arguments.length === 1)
              return new o(v);
            typeof y > "u" && (y = 0);
            var c = e;
            if (typeof c > "u" && (c = v.byteLength - y), y >= v.byteLength)
              throw new RangeError("'offset' is out of bounds");
            if (c > v.byteLength - y)
              throw new RangeError("'length' is out of bounds");
            return new o(v.slice(y, y + c));
          }
          if (o.isBuffer(v)) {
            var d = new o(v.length);
            return v.copy(d, 0, 0, v.length), d;
          }
          if (v) {
            if (Array.isArray(v) || typeof ArrayBuffer < "u" && v.buffer instanceof ArrayBuffer || "length" in v)
              return new o(v);
            if (v.type === "Buffer" && Array.isArray(v.data))
              return new o(v.data);
          }
          throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
        }, re.allocUnsafeSlow = function(v) {
          if (typeof o.allocUnsafeSlow == "function")
            return o.allocUnsafeSlow(v);
          if (typeof v != "number")
            throw new TypeError("size must be a number");
          if (v >= t)
            throw new RangeError("size is too large");
          return new C(v);
        };
      }).call(this, typeof commonjsGlobal < "u" ? commonjsGlobal : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { buffer: 78 }], 78: [function(le, ce, re) {
      (function(ae) {
        var Z = le("base64-js"), o = le("ieee754"), C = le("isarray");
        re.Buffer = h, re.SlowBuffer = l, re.INSPECT_MAX_BYTES = 50, h.TYPED_ARRAY_SUPPORT = ae.TYPED_ARRAY_SUPPORT !== void 0 ? ae.TYPED_ARRAY_SUPPORT : t(), re.kMaxLength = a();
        function t() {
          try {
            var $ = new Uint8Array(1);
            return $.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
              return 42;
            } }, $.foo() === 42 && // typed array instances can be augmented
            typeof $.subarray == "function" && // chrome 9-10 lack `subarray`
            $.subarray(1, 1).byteLength === 0;
          } catch {
            return !1;
          }
        }
        function a() {
          return h.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
        }
        function v($, E) {
          if (a() < E)
            throw new RangeError("Invalid typed array length");
          return h.TYPED_ARRAY_SUPPORT ? ($ = new Uint8Array(E), $.__proto__ = h.prototype) : ($ === null && ($ = new h(E)), $.length = E), $;
        }
        function h($, E, H) {
          if (!h.TYPED_ARRAY_SUPPORT && !(this instanceof h))
            return new h($, E, H);
          if (typeof $ == "number") {
            if (typeof E == "string")
              throw new Error(
                "If encoding is specified then the first argument must be a string"
              );
            return d(this, $);
          }
          return e(this, $, E, H);
        }
        h.poolSize = 8192, h._augment = function($) {
          return $.__proto__ = h.prototype, $;
        };
        function e($, E, H, ie) {
          if (typeof E == "number")
            throw new TypeError('"value" argument must not be a number');
          return typeof ArrayBuffer < "u" && E instanceof ArrayBuffer ? g($, E, H, ie) : typeof E == "string" ? p($, E, H) : n($, E);
        }
        h.from = function($, E, H) {
          return e(null, $, E, H);
        }, h.TYPED_ARRAY_SUPPORT && (h.prototype.__proto__ = Uint8Array.prototype, h.__proto__ = Uint8Array, typeof Symbol < "u" && Symbol.species && h[Symbol.species] === h && Object.defineProperty(h, Symbol.species, {
          value: null,
          configurable: !0
        }));
        function y($) {
          if (typeof $ != "number")
            throw new TypeError('"size" argument must be a number');
          if ($ < 0)
            throw new RangeError('"size" argument must not be negative');
        }
        function c($, E, H, ie) {
          return y(E), E <= 0 ? v($, E) : H !== void 0 ? typeof ie == "string" ? v($, E).fill(H, ie) : v($, E).fill(H) : v($, E);
        }
        h.alloc = function($, E, H) {
          return c(null, $, E, H);
        };
        function d($, E) {
          if (y(E), $ = v($, E < 0 ? 0 : i(E) | 0), !h.TYPED_ARRAY_SUPPORT)
            for (var H = 0; H < E; ++H)
              $[H] = 0;
          return $;
        }
        h.allocUnsafe = function($) {
          return d(null, $);
        }, h.allocUnsafeSlow = function($) {
          return d(null, $);
        };
        function p($, E, H) {
          if ((typeof H != "string" || H === "") && (H = "utf8"), !h.isEncoding(H))
            throw new TypeError('"encoding" must be a valid string encoding');
          var ie = u(E, H) | 0;
          $ = v($, ie);
          var ue = $.write(E, H);
          return ue !== ie && ($ = $.slice(0, ue)), $;
        }
        function m($, E) {
          var H = E.length < 0 ? 0 : i(E.length) | 0;
          $ = v($, H);
          for (var ie = 0; ie < H; ie += 1)
            $[ie] = E[ie] & 255;
          return $;
        }
        function g($, E, H, ie) {
          if (E.byteLength, H < 0 || E.byteLength < H)
            throw new RangeError("'offset' is out of bounds");
          if (E.byteLength < H + (ie || 0))
            throw new RangeError("'length' is out of bounds");
          return H === void 0 && ie === void 0 ? E = new Uint8Array(E) : ie === void 0 ? E = new Uint8Array(E, H) : E = new Uint8Array(E, H, ie), h.TYPED_ARRAY_SUPPORT ? ($ = E, $.__proto__ = h.prototype) : $ = m($, E), $;
        }
        function n($, E) {
          if (h.isBuffer(E)) {
            var H = i(E.length) | 0;
            return $ = v($, H), $.length === 0 || E.copy($, 0, 0, H), $;
          }
          if (E) {
            if (typeof ArrayBuffer < "u" && E.buffer instanceof ArrayBuffer || "length" in E)
              return typeof E.length != "number" || ee(E.length) ? v($, 0) : m($, E);
            if (E.type === "Buffer" && C(E.data))
              return m($, E.data);
          }
          throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
        }
        function i($) {
          if ($ >= a())
            throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + a().toString(16) + " bytes");
          return $ | 0;
        }
        function l($) {
          return +$ != $ && ($ = 0), h.alloc(+$);
        }
        h.isBuffer = function(E) {
          return !!(E != null && E._isBuffer);
        }, h.compare = function(E, H) {
          if (!h.isBuffer(E) || !h.isBuffer(H))
            throw new TypeError("Arguments must be Buffers");
          if (E === H)
            return 0;
          for (var ie = E.length, ue = H.length, fe = 0, de = Math.min(ie, ue); fe < de; ++fe)
            if (E[fe] !== H[fe]) {
              ie = E[fe], ue = H[fe];
              break;
            }
          return ie < ue ? -1 : ue < ie ? 1 : 0;
        }, h.isEncoding = function(E) {
          switch (String(E).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return !0;
            default:
              return !1;
          }
        }, h.concat = function(E, H) {
          if (!C(E))
            throw new TypeError('"list" argument must be an Array of Buffers');
          if (E.length === 0)
            return h.alloc(0);
          var ie;
          if (H === void 0)
            for (H = 0, ie = 0; ie < E.length; ++ie)
              H += E[ie].length;
          var ue = h.allocUnsafe(H), fe = 0;
          for (ie = 0; ie < E.length; ++ie) {
            var de = E[ie];
            if (!h.isBuffer(de))
              throw new TypeError('"list" argument must be an Array of Buffers');
            de.copy(ue, fe), fe += de.length;
          }
          return ue;
        };
        function u($, E) {
          if (h.isBuffer($))
            return $.length;
          if (typeof ArrayBuffer < "u" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView($) || $ instanceof ArrayBuffer))
            return $.byteLength;
          typeof $ != "string" && ($ = "" + $);
          var H = $.length;
          if (H === 0)
            return 0;
          for (var ie = !1; ; )
            switch (E) {
              case "ascii":
              case "latin1":
              case "binary":
                return H;
              case "utf8":
              case "utf-8":
              case void 0:
                return N($).length;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return H * 2;
              case "hex":
                return H >>> 1;
              case "base64":
                return ne($).length;
              default:
                if (ie)
                  return N($).length;
                E = ("" + E).toLowerCase(), ie = !0;
            }
        }
        h.byteLength = u;
        function w($, E, H) {
          var ie = !1;
          if ((E === void 0 || E < 0) && (E = 0), E > this.length || ((H === void 0 || H > this.length) && (H = this.length), H <= 0) || (H >>>= 0, E >>>= 0, H <= E))
            return "";
          for ($ || ($ = "utf8"); ; )
            switch ($) {
              case "hex":
                return T(this, E, H);
              case "utf8":
              case "utf-8":
                return f(this, E, H);
              case "ascii":
                return S(this, E, H);
              case "latin1":
              case "binary":
                return F(this, E, H);
              case "base64":
                return x(this, E, H);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return I(this, E, H);
              default:
                if (ie)
                  throw new TypeError("Unknown encoding: " + $);
                $ = ($ + "").toLowerCase(), ie = !0;
            }
        }
        h.prototype._isBuffer = !0;
        function _($, E, H) {
          var ie = $[E];
          $[E] = $[H], $[H] = ie;
        }
        h.prototype.swap16 = function() {
          var E = this.length;
          if (E % 2 !== 0)
            throw new RangeError("Buffer size must be a multiple of 16-bits");
          for (var H = 0; H < E; H += 2)
            _(this, H, H + 1);
          return this;
        }, h.prototype.swap32 = function() {
          var E = this.length;
          if (E % 4 !== 0)
            throw new RangeError("Buffer size must be a multiple of 32-bits");
          for (var H = 0; H < E; H += 4)
            _(this, H, H + 3), _(this, H + 1, H + 2);
          return this;
        }, h.prototype.swap64 = function() {
          var E = this.length;
          if (E % 8 !== 0)
            throw new RangeError("Buffer size must be a multiple of 64-bits");
          for (var H = 0; H < E; H += 8)
            _(this, H, H + 7), _(this, H + 1, H + 6), _(this, H + 2, H + 5), _(this, H + 3, H + 4);
          return this;
        }, h.prototype.toString = function() {
          var E = this.length | 0;
          return E === 0 ? "" : arguments.length === 0 ? f(this, 0, E) : w.apply(this, arguments);
        }, h.prototype.equals = function(E) {
          if (!h.isBuffer(E))
            throw new TypeError("Argument must be a Buffer");
          return this === E ? !0 : h.compare(this, E) === 0;
        }, h.prototype.inspect = function() {
          var E = "", H = re.INSPECT_MAX_BYTES;
          return this.length > 0 && (E = this.toString("hex", 0, H).match(/.{2}/g).join(" "), this.length > H && (E += " ... ")), "<Buffer " + E + ">";
        }, h.prototype.compare = function(E, H, ie, ue, fe) {
          if (!h.isBuffer(E))
            throw new TypeError("Argument must be a Buffer");
          if (H === void 0 && (H = 0), ie === void 0 && (ie = E ? E.length : 0), ue === void 0 && (ue = 0), fe === void 0 && (fe = this.length), H < 0 || ie > E.length || ue < 0 || fe > this.length)
            throw new RangeError("out of range index");
          if (ue >= fe && H >= ie)
            return 0;
          if (ue >= fe)
            return -1;
          if (H >= ie)
            return 1;
          if (H >>>= 0, ie >>>= 0, ue >>>= 0, fe >>>= 0, this === E)
            return 0;
          for (var de = fe - ue, pe = ie - H, xe = Math.min(de, pe), De = this.slice(ue, fe), Ae = E.slice(H, ie), Se = 0; Se < xe; ++Se)
            if (De[Se] !== Ae[Se]) {
              de = De[Se], pe = Ae[Se];
              break;
            }
          return de < pe ? -1 : pe < de ? 1 : 0;
        };
        function b($, E, H, ie, ue) {
          if ($.length === 0)
            return -1;
          if (typeof H == "string" ? (ie = H, H = 0) : H > 2147483647 ? H = 2147483647 : H < -2147483648 && (H = -2147483648), H = +H, isNaN(H) && (H = ue ? 0 : $.length - 1), H < 0 && (H = $.length + H), H >= $.length) {
            if (ue)
              return -1;
            H = $.length - 1;
          } else if (H < 0)
            if (ue)
              H = 0;
            else
              return -1;
          if (typeof E == "string" && (E = h.from(E, ie)), h.isBuffer(E))
            return E.length === 0 ? -1 : A($, E, H, ie, ue);
          if (typeof E == "number")
            return E = E & 255, h.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? ue ? Uint8Array.prototype.indexOf.call($, E, H) : Uint8Array.prototype.lastIndexOf.call($, E, H) : A($, [E], H, ie, ue);
          throw new TypeError("val must be string, number or Buffer");
        }
        function A($, E, H, ie, ue) {
          var fe = 1, de = $.length, pe = E.length;
          if (ie !== void 0 && (ie = String(ie).toLowerCase(), ie === "ucs2" || ie === "ucs-2" || ie === "utf16le" || ie === "utf-16le")) {
            if ($.length < 2 || E.length < 2)
              return -1;
            fe = 2, de /= 2, pe /= 2, H /= 2;
          }
          function xe(ye, _e) {
            return fe === 1 ? ye[_e] : ye.readUInt16BE(_e * fe);
          }
          var De;
          if (ue) {
            var Ae = -1;
            for (De = H; De < de; De++)
              if (xe($, De) === xe(E, Ae === -1 ? 0 : De - Ae)) {
                if (Ae === -1 && (Ae = De), De - Ae + 1 === pe)
                  return Ae * fe;
              } else
                Ae !== -1 && (De -= De - Ae), Ae = -1;
          } else
            for (H + pe > de && (H = de - pe), De = H; De >= 0; De--) {
              for (var Se = !0, ke = 0; ke < pe; ke++)
                if (xe($, De + ke) !== xe(E, ke)) {
                  Se = !1;
                  break;
                }
              if (Se)
                return De;
            }
          return -1;
        }
        h.prototype.includes = function(E, H, ie) {
          return this.indexOf(E, H, ie) !== -1;
        }, h.prototype.indexOf = function(E, H, ie) {
          return b(this, E, H, ie, !0);
        }, h.prototype.lastIndexOf = function(E, H, ie) {
          return b(this, E, H, ie, !1);
        };
        function Y($, E, H, ie) {
          H = Number(H) || 0;
          var ue = $.length - H;
          ie ? (ie = Number(ie), ie > ue && (ie = ue)) : ie = ue;
          var fe = E.length;
          if (fe % 2 !== 0)
            throw new TypeError("Invalid hex string");
          ie > fe / 2 && (ie = fe / 2);
          for (var de = 0; de < ie; ++de) {
            var pe = parseInt(E.substr(de * 2, 2), 16);
            if (isNaN(pe))
              return de;
            $[H + de] = pe;
          }
          return de;
        }
        function j($, E, H, ie) {
          return oe(N(E, $.length - H), $, H, ie);
        }
        function X($, E, H, ie) {
          return oe(Q(E), $, H, ie);
        }
        function B($, E, H, ie) {
          return X($, E, H, ie);
        }
        function R($, E, H, ie) {
          return oe(ne(E), $, H, ie);
        }
        function k($, E, H, ie) {
          return oe(D(E, $.length - H), $, H, ie);
        }
        h.prototype.write = function(E, H, ie, ue) {
          if (H === void 0)
            ue = "utf8", ie = this.length, H = 0;
          else if (ie === void 0 && typeof H == "string")
            ue = H, ie = this.length, H = 0;
          else if (isFinite(H))
            H = H | 0, isFinite(ie) ? (ie = ie | 0, ue === void 0 && (ue = "utf8")) : (ue = ie, ie = void 0);
          else
            throw new Error(
              "Buffer.write(string, encoding, offset[, length]) is no longer supported"
            );
          var fe = this.length - H;
          if ((ie === void 0 || ie > fe) && (ie = fe), E.length > 0 && (ie < 0 || H < 0) || H > this.length)
            throw new RangeError("Attempt to write outside buffer bounds");
          ue || (ue = "utf8");
          for (var de = !1; ; )
            switch (ue) {
              case "hex":
                return Y(this, E, H, ie);
              case "utf8":
              case "utf-8":
                return j(this, E, H, ie);
              case "ascii":
                return X(this, E, H, ie);
              case "latin1":
              case "binary":
                return B(this, E, H, ie);
              case "base64":
                return R(this, E, H, ie);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return k(this, E, H, ie);
              default:
                if (de)
                  throw new TypeError("Unknown encoding: " + ue);
                ue = ("" + ue).toLowerCase(), de = !0;
            }
        }, h.prototype.toJSON = function() {
          return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
          };
        };
        function x($, E, H) {
          return E === 0 && H === $.length ? Z.fromByteArray($) : Z.fromByteArray($.slice(E, H));
        }
        function f($, E, H) {
          H = Math.min($.length, H);
          for (var ie = [], ue = E; ue < H; ) {
            var fe = $[ue], de = null, pe = fe > 239 ? 4 : fe > 223 ? 3 : fe > 191 ? 2 : 1;
            if (ue + pe <= H) {
              var xe, De, Ae, Se;
              switch (pe) {
                case 1:
                  fe < 128 && (de = fe);
                  break;
                case 2:
                  xe = $[ue + 1], (xe & 192) === 128 && (Se = (fe & 31) << 6 | xe & 63, Se > 127 && (de = Se));
                  break;
                case 3:
                  xe = $[ue + 1], De = $[ue + 2], (xe & 192) === 128 && (De & 192) === 128 && (Se = (fe & 15) << 12 | (xe & 63) << 6 | De & 63, Se > 2047 && (Se < 55296 || Se > 57343) && (de = Se));
                  break;
                case 4:
                  xe = $[ue + 1], De = $[ue + 2], Ae = $[ue + 3], (xe & 192) === 128 && (De & 192) === 128 && (Ae & 192) === 128 && (Se = (fe & 15) << 18 | (xe & 63) << 12 | (De & 63) << 6 | Ae & 63, Se > 65535 && Se < 1114112 && (de = Se));
              }
            }
            de === null ? (de = 65533, pe = 1) : de > 65535 && (de -= 65536, ie.push(de >>> 10 & 1023 | 55296), de = 56320 | de & 1023), ie.push(de), ue += pe;
          }
          return O(ie);
        }
        var U = 4096;
        function O($) {
          var E = $.length;
          if (E <= U)
            return String.fromCharCode.apply(String, $);
          for (var H = "", ie = 0; ie < E; )
            H += String.fromCharCode.apply(
              String,
              $.slice(ie, ie += U)
            );
          return H;
        }
        function S($, E, H) {
          var ie = "";
          H = Math.min($.length, H);
          for (var ue = E; ue < H; ++ue)
            ie += String.fromCharCode($[ue] & 127);
          return ie;
        }
        function F($, E, H) {
          var ie = "";
          H = Math.min($.length, H);
          for (var ue = E; ue < H; ++ue)
            ie += String.fromCharCode($[ue]);
          return ie;
        }
        function T($, E, H) {
          var ie = $.length;
          (!E || E < 0) && (E = 0), (!H || H < 0 || H > ie) && (H = ie);
          for (var ue = "", fe = E; fe < H; ++fe)
            ue += q($[fe]);
          return ue;
        }
        function I($, E, H) {
          for (var ie = $.slice(E, H), ue = "", fe = 0; fe < ie.length; fe += 2)
            ue += String.fromCharCode(ie[fe] + ie[fe + 1] * 256);
          return ue;
        }
        h.prototype.slice = function(E, H) {
          var ie = this.length;
          E = ~~E, H = H === void 0 ? ie : ~~H, E < 0 ? (E += ie, E < 0 && (E = 0)) : E > ie && (E = ie), H < 0 ? (H += ie, H < 0 && (H = 0)) : H > ie && (H = ie), H < E && (H = E);
          var ue;
          if (h.TYPED_ARRAY_SUPPORT)
            ue = this.subarray(E, H), ue.__proto__ = h.prototype;
          else {
            var fe = H - E;
            ue = new h(fe, void 0);
            for (var de = 0; de < fe; ++de)
              ue[de] = this[de + E];
          }
          return ue;
        };
        function M($, E, H) {
          if ($ % 1 !== 0 || $ < 0)
            throw new RangeError("offset is not uint");
          if ($ + E > H)
            throw new RangeError("Trying to access beyond buffer length");
        }
        h.prototype.readUIntLE = function(E, H, ie) {
          E = E | 0, H = H | 0, ie || M(E, H, this.length);
          for (var ue = this[E], fe = 1, de = 0; ++de < H && (fe *= 256); )
            ue += this[E + de] * fe;
          return ue;
        }, h.prototype.readUIntBE = function(E, H, ie) {
          E = E | 0, H = H | 0, ie || M(E, H, this.length);
          for (var ue = this[E + --H], fe = 1; H > 0 && (fe *= 256); )
            ue += this[E + --H] * fe;
          return ue;
        }, h.prototype.readUInt8 = function(E, H) {
          return H || M(E, 1, this.length), this[E];
        }, h.prototype.readUInt16LE = function(E, H) {
          return H || M(E, 2, this.length), this[E] | this[E + 1] << 8;
        }, h.prototype.readUInt16BE = function(E, H) {
          return H || M(E, 2, this.length), this[E] << 8 | this[E + 1];
        }, h.prototype.readUInt32LE = function(E, H) {
          return H || M(E, 4, this.length), (this[E] | this[E + 1] << 8 | this[E + 2] << 16) + this[E + 3] * 16777216;
        }, h.prototype.readUInt32BE = function(E, H) {
          return H || M(E, 4, this.length), this[E] * 16777216 + (this[E + 1] << 16 | this[E + 2] << 8 | this[E + 3]);
        }, h.prototype.readIntLE = function(E, H, ie) {
          E = E | 0, H = H | 0, ie || M(E, H, this.length);
          for (var ue = this[E], fe = 1, de = 0; ++de < H && (fe *= 256); )
            ue += this[E + de] * fe;
          return fe *= 128, ue >= fe && (ue -= Math.pow(2, 8 * H)), ue;
        }, h.prototype.readIntBE = function(E, H, ie) {
          E = E | 0, H = H | 0, ie || M(E, H, this.length);
          for (var ue = H, fe = 1, de = this[E + --ue]; ue > 0 && (fe *= 256); )
            de += this[E + --ue] * fe;
          return fe *= 128, de >= fe && (de -= Math.pow(2, 8 * H)), de;
        }, h.prototype.readInt8 = function(E, H) {
          return H || M(E, 1, this.length), this[E] & 128 ? (255 - this[E] + 1) * -1 : this[E];
        }, h.prototype.readInt16LE = function(E, H) {
          H || M(E, 2, this.length);
          var ie = this[E] | this[E + 1] << 8;
          return ie & 32768 ? ie | 4294901760 : ie;
        }, h.prototype.readInt16BE = function(E, H) {
          H || M(E, 2, this.length);
          var ie = this[E + 1] | this[E] << 8;
          return ie & 32768 ? ie | 4294901760 : ie;
        }, h.prototype.readInt32LE = function(E, H) {
          return H || M(E, 4, this.length), this[E] | this[E + 1] << 8 | this[E + 2] << 16 | this[E + 3] << 24;
        }, h.prototype.readInt32BE = function(E, H) {
          return H || M(E, 4, this.length), this[E] << 24 | this[E + 1] << 16 | this[E + 2] << 8 | this[E + 3];
        }, h.prototype.readFloatLE = function(E, H) {
          return H || M(E, 4, this.length), o.read(this, E, !0, 23, 4);
        }, h.prototype.readFloatBE = function(E, H) {
          return H || M(E, 4, this.length), o.read(this, E, !1, 23, 4);
        }, h.prototype.readDoubleLE = function(E, H) {
          return H || M(E, 8, this.length), o.read(this, E, !0, 52, 8);
        }, h.prototype.readDoubleBE = function(E, H) {
          return H || M(E, 8, this.length), o.read(this, E, !1, 52, 8);
        };
        function V($, E, H, ie, ue, fe) {
          if (!h.isBuffer($))
            throw new TypeError('"buffer" argument must be a Buffer instance');
          if (E > ue || E < fe)
            throw new RangeError('"value" argument is out of bounds');
          if (H + ie > $.length)
            throw new RangeError("Index out of range");
        }
        h.prototype.writeUIntLE = function(E, H, ie, ue) {
          if (E = +E, H = H | 0, ie = ie | 0, !ue) {
            var fe = Math.pow(2, 8 * ie) - 1;
            V(this, E, H, ie, fe, 0);
          }
          var de = 1, pe = 0;
          for (this[H] = E & 255; ++pe < ie && (de *= 256); )
            this[H + pe] = E / de & 255;
          return H + ie;
        }, h.prototype.writeUIntBE = function(E, H, ie, ue) {
          if (E = +E, H = H | 0, ie = ie | 0, !ue) {
            var fe = Math.pow(2, 8 * ie) - 1;
            V(this, E, H, ie, fe, 0);
          }
          var de = ie - 1, pe = 1;
          for (this[H + de] = E & 255; --de >= 0 && (pe *= 256); )
            this[H + de] = E / pe & 255;
          return H + ie;
        }, h.prototype.writeUInt8 = function(E, H, ie) {
          return E = +E, H = H | 0, ie || V(this, E, H, 1, 255, 0), h.TYPED_ARRAY_SUPPORT || (E = Math.floor(E)), this[H] = E & 255, H + 1;
        };
        function J($, E, H, ie) {
          E < 0 && (E = 65535 + E + 1);
          for (var ue = 0, fe = Math.min($.length - H, 2); ue < fe; ++ue)
            $[H + ue] = (E & 255 << 8 * (ie ? ue : 1 - ue)) >>> (ie ? ue : 1 - ue) * 8;
        }
        h.prototype.writeUInt16LE = function(E, H, ie) {
          return E = +E, H = H | 0, ie || V(this, E, H, 2, 65535, 0), h.TYPED_ARRAY_SUPPORT ? (this[H] = E & 255, this[H + 1] = E >>> 8) : J(this, E, H, !0), H + 2;
        }, h.prototype.writeUInt16BE = function(E, H, ie) {
          return E = +E, H = H | 0, ie || V(this, E, H, 2, 65535, 0), h.TYPED_ARRAY_SUPPORT ? (this[H] = E >>> 8, this[H + 1] = E & 255) : J(this, E, H, !1), H + 2;
        };
        function W($, E, H, ie) {
          E < 0 && (E = 4294967295 + E + 1);
          for (var ue = 0, fe = Math.min($.length - H, 4); ue < fe; ++ue)
            $[H + ue] = E >>> (ie ? ue : 3 - ue) * 8 & 255;
        }
        h.prototype.writeUInt32LE = function(E, H, ie) {
          return E = +E, H = H | 0, ie || V(this, E, H, 4, 4294967295, 0), h.TYPED_ARRAY_SUPPORT ? (this[H + 3] = E >>> 24, this[H + 2] = E >>> 16, this[H + 1] = E >>> 8, this[H] = E & 255) : W(this, E, H, !0), H + 4;
        }, h.prototype.writeUInt32BE = function(E, H, ie) {
          return E = +E, H = H | 0, ie || V(this, E, H, 4, 4294967295, 0), h.TYPED_ARRAY_SUPPORT ? (this[H] = E >>> 24, this[H + 1] = E >>> 16, this[H + 2] = E >>> 8, this[H + 3] = E & 255) : W(this, E, H, !1), H + 4;
        }, h.prototype.writeIntLE = function(E, H, ie, ue) {
          if (E = +E, H = H | 0, !ue) {
            var fe = Math.pow(2, 8 * ie - 1);
            V(this, E, H, ie, fe - 1, -fe);
          }
          var de = 0, pe = 1, xe = 0;
          for (this[H] = E & 255; ++de < ie && (pe *= 256); )
            E < 0 && xe === 0 && this[H + de - 1] !== 0 && (xe = 1), this[H + de] = (E / pe >> 0) - xe & 255;
          return H + ie;
        }, h.prototype.writeIntBE = function(E, H, ie, ue) {
          if (E = +E, H = H | 0, !ue) {
            var fe = Math.pow(2, 8 * ie - 1);
            V(this, E, H, ie, fe - 1, -fe);
          }
          var de = ie - 1, pe = 1, xe = 0;
          for (this[H + de] = E & 255; --de >= 0 && (pe *= 256); )
            E < 0 && xe === 0 && this[H + de + 1] !== 0 && (xe = 1), this[H + de] = (E / pe >> 0) - xe & 255;
          return H + ie;
        }, h.prototype.writeInt8 = function(E, H, ie) {
          return E = +E, H = H | 0, ie || V(this, E, H, 1, 127, -128), h.TYPED_ARRAY_SUPPORT || (E = Math.floor(E)), E < 0 && (E = 255 + E + 1), this[H] = E & 255, H + 1;
        }, h.prototype.writeInt16LE = function(E, H, ie) {
          return E = +E, H = H | 0, ie || V(this, E, H, 2, 32767, -32768), h.TYPED_ARRAY_SUPPORT ? (this[H] = E & 255, this[H + 1] = E >>> 8) : J(this, E, H, !0), H + 2;
        }, h.prototype.writeInt16BE = function(E, H, ie) {
          return E = +E, H = H | 0, ie || V(this, E, H, 2, 32767, -32768), h.TYPED_ARRAY_SUPPORT ? (this[H] = E >>> 8, this[H + 1] = E & 255) : J(this, E, H, !1), H + 2;
        }, h.prototype.writeInt32LE = function(E, H, ie) {
          return E = +E, H = H | 0, ie || V(this, E, H, 4, 2147483647, -2147483648), h.TYPED_ARRAY_SUPPORT ? (this[H] = E & 255, this[H + 1] = E >>> 8, this[H + 2] = E >>> 16, this[H + 3] = E >>> 24) : W(this, E, H, !0), H + 4;
        }, h.prototype.writeInt32BE = function(E, H, ie) {
          return E = +E, H = H | 0, ie || V(this, E, H, 4, 2147483647, -2147483648), E < 0 && (E = 4294967295 + E + 1), h.TYPED_ARRAY_SUPPORT ? (this[H] = E >>> 24, this[H + 1] = E >>> 16, this[H + 2] = E >>> 8, this[H + 3] = E & 255) : W(this, E, H, !1), H + 4;
        };
        function z($, E, H, ie, ue, fe) {
          if (H + ie > $.length)
            throw new RangeError("Index out of range");
          if (H < 0)
            throw new RangeError("Index out of range");
        }
        function G($, E, H, ie, ue) {
          return ue || z($, E, H, 4), o.write($, E, H, ie, 23, 4), H + 4;
        }
        h.prototype.writeFloatLE = function(E, H, ie) {
          return G(this, E, H, !0, ie);
        }, h.prototype.writeFloatBE = function(E, H, ie) {
          return G(this, E, H, !1, ie);
        };
        function L($, E, H, ie, ue) {
          return ue || z($, E, H, 8), o.write($, E, H, ie, 52, 8), H + 8;
        }
        h.prototype.writeDoubleLE = function(E, H, ie) {
          return L(this, E, H, !0, ie);
        }, h.prototype.writeDoubleBE = function(E, H, ie) {
          return L(this, E, H, !1, ie);
        }, h.prototype.copy = function(E, H, ie, ue) {
          if (ie || (ie = 0), !ue && ue !== 0 && (ue = this.length), H >= E.length && (H = E.length), H || (H = 0), ue > 0 && ue < ie && (ue = ie), ue === ie || E.length === 0 || this.length === 0)
            return 0;
          if (H < 0)
            throw new RangeError("targetStart out of bounds");
          if (ie < 0 || ie >= this.length)
            throw new RangeError("sourceStart out of bounds");
          if (ue < 0)
            throw new RangeError("sourceEnd out of bounds");
          ue > this.length && (ue = this.length), E.length - H < ue - ie && (ue = E.length - H + ie);
          var fe = ue - ie, de;
          if (this === E && ie < H && H < ue)
            for (de = fe - 1; de >= 0; --de)
              E[de + H] = this[de + ie];
          else if (fe < 1e3 || !h.TYPED_ARRAY_SUPPORT)
            for (de = 0; de < fe; ++de)
              E[de + H] = this[de + ie];
          else
            Uint8Array.prototype.set.call(
              E,
              this.subarray(ie, ie + fe),
              H
            );
          return fe;
        }, h.prototype.fill = function(E, H, ie, ue) {
          if (typeof E == "string") {
            if (typeof H == "string" ? (ue = H, H = 0, ie = this.length) : typeof ie == "string" && (ue = ie, ie = this.length), E.length === 1) {
              var fe = E.charCodeAt(0);
              fe < 256 && (E = fe);
            }
            if (ue !== void 0 && typeof ue != "string")
              throw new TypeError("encoding must be a string");
            if (typeof ue == "string" && !h.isEncoding(ue))
              throw new TypeError("Unknown encoding: " + ue);
          } else
            typeof E == "number" && (E = E & 255);
          if (H < 0 || this.length < H || this.length < ie)
            throw new RangeError("Out of range index");
          if (ie <= H)
            return this;
          H = H >>> 0, ie = ie === void 0 ? this.length : ie >>> 0, E || (E = 0);
          var de;
          if (typeof E == "number")
            for (de = H; de < ie; ++de)
              this[de] = E;
          else {
            var pe = h.isBuffer(E) ? E : N(new h(E, ue).toString()), xe = pe.length;
            for (de = 0; de < ie - H; ++de)
              this[de + H] = pe[de % xe];
          }
          return this;
        };
        var K = /[^+\/0-9A-Za-z-_]/g;
        function te($) {
          if ($ = se($).replace(K, ""), $.length < 2)
            return "";
          for (; $.length % 4 !== 0; )
            $ = $ + "=";
          return $;
        }
        function se($) {
          return $.trim ? $.trim() : $.replace(/^\s+|\s+$/g, "");
        }
        function q($) {
          return $ < 16 ? "0" + $.toString(16) : $.toString(16);
        }
        function N($, E) {
          E = E || 1 / 0;
          for (var H, ie = $.length, ue = null, fe = [], de = 0; de < ie; ++de) {
            if (H = $.charCodeAt(de), H > 55295 && H < 57344) {
              if (!ue) {
                if (H > 56319) {
                  (E -= 3) > -1 && fe.push(239, 191, 189);
                  continue;
                } else if (de + 1 === ie) {
                  (E -= 3) > -1 && fe.push(239, 191, 189);
                  continue;
                }
                ue = H;
                continue;
              }
              if (H < 56320) {
                (E -= 3) > -1 && fe.push(239, 191, 189), ue = H;
                continue;
              }
              H = (ue - 55296 << 10 | H - 56320) + 65536;
            } else
              ue && (E -= 3) > -1 && fe.push(239, 191, 189);
            if (ue = null, H < 128) {
              if ((E -= 1) < 0)
                break;
              fe.push(H);
            } else if (H < 2048) {
              if ((E -= 2) < 0)
                break;
              fe.push(
                H >> 6 | 192,
                H & 63 | 128
              );
            } else if (H < 65536) {
              if ((E -= 3) < 0)
                break;
              fe.push(
                H >> 12 | 224,
                H >> 6 & 63 | 128,
                H & 63 | 128
              );
            } else if (H < 1114112) {
              if ((E -= 4) < 0)
                break;
              fe.push(
                H >> 18 | 240,
                H >> 12 & 63 | 128,
                H >> 6 & 63 | 128,
                H & 63 | 128
              );
            } else
              throw new Error("Invalid code point");
          }
          return fe;
        }
        function Q($) {
          for (var E = [], H = 0; H < $.length; ++H)
            E.push($.charCodeAt(H) & 255);
          return E;
        }
        function D($, E) {
          for (var H, ie, ue, fe = [], de = 0; de < $.length && !((E -= 2) < 0); ++de)
            H = $.charCodeAt(de), ie = H >> 8, ue = H % 256, fe.push(ue), fe.push(ie);
          return fe;
        }
        function ne($) {
          return Z.toByteArray(te($));
        }
        function oe($, E, H, ie) {
          for (var ue = 0; ue < ie && !(ue + H >= E.length || ue >= $.length); ++ue)
            E[ue + H] = $[ue];
          return ue;
        }
        function ee($) {
          return $ !== $;
        }
      }).call(this, typeof commonjsGlobal < "u" ? commonjsGlobal : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "base64-js": 40, ieee754: 83, isarray: 86 }], 79: [function(le, ce, re) {
      (function(ae) {
        function Z(i) {
          return Array.isArray ? Array.isArray(i) : n(i) === "[object Array]";
        }
        re.isArray = Z;
        function o(i) {
          return typeof i == "boolean";
        }
        re.isBoolean = o;
        function C(i) {
          return i === null;
        }
        re.isNull = C;
        function t(i) {
          return i == null;
        }
        re.isNullOrUndefined = t;
        function a(i) {
          return typeof i == "number";
        }
        re.isNumber = a;
        function v(i) {
          return typeof i == "string";
        }
        re.isString = v;
        function h(i) {
          return typeof i == "symbol";
        }
        re.isSymbol = h;
        function e(i) {
          return i === void 0;
        }
        re.isUndefined = e;
        function y(i) {
          return n(i) === "[object RegExp]";
        }
        re.isRegExp = y;
        function c(i) {
          return typeof i == "object" && i !== null;
        }
        re.isObject = c;
        function d(i) {
          return n(i) === "[object Date]";
        }
        re.isDate = d;
        function p(i) {
          return n(i) === "[object Error]" || i instanceof Error;
        }
        re.isError = p;
        function m(i) {
          return typeof i == "function";
        }
        re.isFunction = m;
        function g(i) {
          return i === null || typeof i == "boolean" || typeof i == "number" || typeof i == "string" || typeof i == "symbol" || // ES6 symbol
          typeof i > "u";
        }
        re.isPrimitive = g, re.isBuffer = ae.isBuffer;
        function n(i) {
          return Object.prototype.toString.call(i);
        }
      }).call(this, { isBuffer: le("../../is-buffer/index.js") });
    }, { "../../is-buffer/index.js": 85 }], 80: [function(le, ce, re) {
      Object.defineProperty(re, "__esModule", { value: !0 });
      var ae = [
        { "Typeface name": "Symbol", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
        { "Typeface name": "Symbol", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "33", "Unicode hex": "21" },
        { "Typeface name": "Symbol", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "8704", "Unicode hex": "2200" },
        { "Typeface name": "Symbol", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "35", "Unicode hex": "23" },
        { "Typeface name": "Symbol", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "8707", "Unicode hex": "2203" },
        { "Typeface name": "Symbol", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "37", "Unicode hex": "25" },
        { "Typeface name": "Symbol", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "38", "Unicode hex": "26" },
        { "Typeface name": "Symbol", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "8717", "Unicode hex": "220D" },
        { "Typeface name": "Symbol", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "40", "Unicode hex": "28" },
        { "Typeface name": "Symbol", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "41", "Unicode hex": "29" },
        { "Typeface name": "Symbol", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "42", "Unicode hex": "2A" },
        { "Typeface name": "Symbol", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "43", "Unicode hex": "2B" },
        { "Typeface name": "Symbol", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "44", "Unicode hex": "2C" },
        { "Typeface name": "Symbol", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "8722", "Unicode hex": "2212" },
        { "Typeface name": "Symbol", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "46", "Unicode hex": "2E" },
        { "Typeface name": "Symbol", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "47", "Unicode hex": "2F" },
        { "Typeface name": "Symbol", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "48", "Unicode hex": "30" },
        { "Typeface name": "Symbol", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "49", "Unicode hex": "31" },
        { "Typeface name": "Symbol", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "50", "Unicode hex": "32" },
        { "Typeface name": "Symbol", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "51", "Unicode hex": "33" },
        { "Typeface name": "Symbol", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "52", "Unicode hex": "34" },
        { "Typeface name": "Symbol", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "53", "Unicode hex": "35" },
        { "Typeface name": "Symbol", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "54", "Unicode hex": "36" },
        { "Typeface name": "Symbol", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "55", "Unicode hex": "37" },
        { "Typeface name": "Symbol", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "56", "Unicode hex": "38" },
        { "Typeface name": "Symbol", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "57", "Unicode hex": "39" },
        { "Typeface name": "Symbol", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "58", "Unicode hex": "3A" },
        { "Typeface name": "Symbol", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "59", "Unicode hex": "3B" },
        { "Typeface name": "Symbol", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "60", "Unicode hex": "3C" },
        { "Typeface name": "Symbol", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "61", "Unicode hex": "3D" },
        { "Typeface name": "Symbol", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "62", "Unicode hex": "3E" },
        { "Typeface name": "Symbol", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "63", "Unicode hex": "3F" },
        { "Typeface name": "Symbol", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "8773", "Unicode hex": "2245" },
        { "Typeface name": "Symbol", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "913", "Unicode hex": "391" },
        { "Typeface name": "Symbol", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "914", "Unicode hex": "392" },
        { "Typeface name": "Symbol", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "935", "Unicode hex": "3A7" },
        { "Typeface name": "Symbol", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "916", "Unicode hex": "394" },
        { "Typeface name": "Symbol", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "917", "Unicode hex": "395" },
        { "Typeface name": "Symbol", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "934", "Unicode hex": "3A6" },
        { "Typeface name": "Symbol", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "915", "Unicode hex": "393" },
        { "Typeface name": "Symbol", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "919", "Unicode hex": "397" },
        { "Typeface name": "Symbol", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "921", "Unicode hex": "399" },
        { "Typeface name": "Symbol", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "977", "Unicode hex": "3D1" },
        { "Typeface name": "Symbol", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "922", "Unicode hex": "39A" },
        { "Typeface name": "Symbol", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "923", "Unicode hex": "39B" },
        { "Typeface name": "Symbol", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "924", "Unicode hex": "39C" },
        { "Typeface name": "Symbol", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "925", "Unicode hex": "39D" },
        { "Typeface name": "Symbol", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "927", "Unicode hex": "39F" },
        { "Typeface name": "Symbol", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "928", "Unicode hex": "3A0" },
        { "Typeface name": "Symbol", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "920", "Unicode hex": "398" },
        { "Typeface name": "Symbol", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "929", "Unicode hex": "3A1" },
        { "Typeface name": "Symbol", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "931", "Unicode hex": "3A3" },
        { "Typeface name": "Symbol", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "932", "Unicode hex": "3A4" },
        { "Typeface name": "Symbol", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "933", "Unicode hex": "3A5" },
        { "Typeface name": "Symbol", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "962", "Unicode hex": "3C2" },
        { "Typeface name": "Symbol", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "937", "Unicode hex": "3A9" },
        { "Typeface name": "Symbol", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "926", "Unicode hex": "39E" },
        { "Typeface name": "Symbol", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "936", "Unicode hex": "3A8" },
        { "Typeface name": "Symbol", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "918", "Unicode hex": "396" },
        { "Typeface name": "Symbol", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "91", "Unicode hex": "5B" },
        { "Typeface name": "Symbol", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "8756", "Unicode hex": "2234" },
        { "Typeface name": "Symbol", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "93", "Unicode hex": "5D" },
        { "Typeface name": "Symbol", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "8869", "Unicode hex": "22A5" },
        { "Typeface name": "Symbol", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "95", "Unicode hex": "5F" },
        { "Typeface name": "Symbol", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "8254", "Unicode hex": "203E" },
        { "Typeface name": "Symbol", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "945", "Unicode hex": "3B1" },
        { "Typeface name": "Symbol", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "946", "Unicode hex": "3B2" },
        { "Typeface name": "Symbol", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "967", "Unicode hex": "3C7" },
        { "Typeface name": "Symbol", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "948", "Unicode hex": "3B4" },
        { "Typeface name": "Symbol", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "949", "Unicode hex": "3B5" },
        { "Typeface name": "Symbol", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "966", "Unicode hex": "3C6" },
        { "Typeface name": "Symbol", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "947", "Unicode hex": "3B3" },
        { "Typeface name": "Symbol", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "951", "Unicode hex": "3B7" },
        { "Typeface name": "Symbol", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "953", "Unicode hex": "3B9" },
        { "Typeface name": "Symbol", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "981", "Unicode hex": "3D5" },
        { "Typeface name": "Symbol", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "954", "Unicode hex": "3BA" },
        { "Typeface name": "Symbol", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "955", "Unicode hex": "3BB" },
        { "Typeface name": "Symbol", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "956", "Unicode hex": "3BC" },
        { "Typeface name": "Symbol", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "957", "Unicode hex": "3BD" },
        { "Typeface name": "Symbol", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "959", "Unicode hex": "3BF" },
        { "Typeface name": "Symbol", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "960", "Unicode hex": "3C0" },
        { "Typeface name": "Symbol", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "952", "Unicode hex": "3B8" },
        { "Typeface name": "Symbol", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "961", "Unicode hex": "3C1" },
        { "Typeface name": "Symbol", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "963", "Unicode hex": "3C3" },
        { "Typeface name": "Symbol", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "964", "Unicode hex": "3C4" },
        { "Typeface name": "Symbol", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "965", "Unicode hex": "3C5" },
        { "Typeface name": "Symbol", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "982", "Unicode hex": "3D6" },
        { "Typeface name": "Symbol", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "969", "Unicode hex": "3C9" },
        { "Typeface name": "Symbol", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "958", "Unicode hex": "3BE" },
        { "Typeface name": "Symbol", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "968", "Unicode hex": "3C8" },
        { "Typeface name": "Symbol", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "950", "Unicode hex": "3B6" },
        { "Typeface name": "Symbol", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "123", "Unicode hex": "7B" },
        { "Typeface name": "Symbol", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "124", "Unicode hex": "7C" },
        { "Typeface name": "Symbol", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "125", "Unicode hex": "7D" },
        { "Typeface name": "Symbol", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "126", "Unicode hex": "7E" },
        { "Typeface name": "Symbol", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "8364", "Unicode hex": "20AC" },
        { "Typeface name": "Symbol", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "978", "Unicode hex": "3D2" },
        { "Typeface name": "Symbol", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "8242", "Unicode hex": "2032" },
        { "Typeface name": "Symbol", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "8804", "Unicode hex": "2264" },
        { "Typeface name": "Symbol", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "8260", "Unicode hex": "2044" },
        { "Typeface name": "Symbol", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "8734", "Unicode hex": "221E" },
        { "Typeface name": "Symbol", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "402", "Unicode hex": "192" },
        { "Typeface name": "Symbol", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "9827", "Unicode hex": "2663" },
        { "Typeface name": "Symbol", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "9830", "Unicode hex": "2666" },
        { "Typeface name": "Symbol", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "9829", "Unicode hex": "2665" },
        { "Typeface name": "Symbol", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "9824", "Unicode hex": "2660" },
        { "Typeface name": "Symbol", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "8596", "Unicode hex": "2194" },
        { "Typeface name": "Symbol", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "8592", "Unicode hex": "2190" },
        { "Typeface name": "Symbol", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "8593", "Unicode hex": "2191" },
        { "Typeface name": "Symbol", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "8594", "Unicode hex": "2192" },
        { "Typeface name": "Symbol", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "8595", "Unicode hex": "2193" },
        { "Typeface name": "Symbol", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "176", "Unicode hex": "B0" },
        { "Typeface name": "Symbol", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "177", "Unicode hex": "B1" },
        { "Typeface name": "Symbol", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "8243", "Unicode hex": "2033" },
        { "Typeface name": "Symbol", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "8805", "Unicode hex": "2265" },
        { "Typeface name": "Symbol", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "215", "Unicode hex": "D7" },
        { "Typeface name": "Symbol", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "8733", "Unicode hex": "221D" },
        { "Typeface name": "Symbol", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "8706", "Unicode hex": "2202" },
        { "Typeface name": "Symbol", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "8226", "Unicode hex": "2022" },
        { "Typeface name": "Symbol", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "247", "Unicode hex": "F7" },
        { "Typeface name": "Symbol", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "8800", "Unicode hex": "2260" },
        { "Typeface name": "Symbol", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "8801", "Unicode hex": "2261" },
        { "Typeface name": "Symbol", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "8776", "Unicode hex": "2248" },
        { "Typeface name": "Symbol", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "8230", "Unicode hex": "2026" },
        { "Typeface name": "Symbol", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "9168", "Unicode hex": "23D0" },
        { "Typeface name": "Symbol", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "9135", "Unicode hex": "23AF" },
        { "Typeface name": "Symbol", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "8629", "Unicode hex": "21B5" },
        { "Typeface name": "Symbol", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "8501", "Unicode hex": "2135" },
        { "Typeface name": "Symbol", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "8465", "Unicode hex": "2111" },
        { "Typeface name": "Symbol", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "8476", "Unicode hex": "211C" },
        { "Typeface name": "Symbol", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "8472", "Unicode hex": "2118" },
        { "Typeface name": "Symbol", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "8855", "Unicode hex": "2297" },
        { "Typeface name": "Symbol", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "8853", "Unicode hex": "2295" },
        { "Typeface name": "Symbol", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "8709", "Unicode hex": "2205" },
        { "Typeface name": "Symbol", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "8745", "Unicode hex": "2229" },
        { "Typeface name": "Symbol", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "8746", "Unicode hex": "222A" },
        { "Typeface name": "Symbol", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "8835", "Unicode hex": "2283" },
        { "Typeface name": "Symbol", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "8839", "Unicode hex": "2287" },
        { "Typeface name": "Symbol", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "8836", "Unicode hex": "2284" },
        { "Typeface name": "Symbol", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "8834", "Unicode hex": "2282" },
        { "Typeface name": "Symbol", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "8838", "Unicode hex": "2286" },
        { "Typeface name": "Symbol", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "8712", "Unicode hex": "2208" },
        { "Typeface name": "Symbol", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "8713", "Unicode hex": "2209" },
        { "Typeface name": "Symbol", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "8736", "Unicode hex": "2220" },
        { "Typeface name": "Symbol", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "8711", "Unicode hex": "2207" },
        { "Typeface name": "Symbol", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "174", "Unicode hex": "AE" },
        { "Typeface name": "Symbol", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "169", "Unicode hex": "A9" },
        { "Typeface name": "Symbol", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "8482", "Unicode hex": "2122" },
        { "Typeface name": "Symbol", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "8719", "Unicode hex": "220F" },
        { "Typeface name": "Symbol", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "8730", "Unicode hex": "221A" },
        { "Typeface name": "Symbol", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "8901", "Unicode hex": "22C5" },
        { "Typeface name": "Symbol", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "172", "Unicode hex": "AC" },
        { "Typeface name": "Symbol", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "8743", "Unicode hex": "2227" },
        { "Typeface name": "Symbol", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "8744", "Unicode hex": "2228" },
        { "Typeface name": "Symbol", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "8660", "Unicode hex": "21D4" },
        { "Typeface name": "Symbol", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "8656", "Unicode hex": "21D0" },
        { "Typeface name": "Symbol", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "8657", "Unicode hex": "21D1" },
        { "Typeface name": "Symbol", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "8658", "Unicode hex": "21D2" },
        { "Typeface name": "Symbol", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "8659", "Unicode hex": "21D3" },
        { "Typeface name": "Symbol", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "9674", "Unicode hex": "25CA" },
        { "Typeface name": "Symbol", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "12296", "Unicode hex": "3008" },
        { "Typeface name": "Symbol", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "174", "Unicode hex": "AE" },
        { "Typeface name": "Symbol", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "169", "Unicode hex": "A9" },
        { "Typeface name": "Symbol", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "8482", "Unicode hex": "2122" },
        { "Typeface name": "Symbol", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "8721", "Unicode hex": "2211" },
        { "Typeface name": "Symbol", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "9115", "Unicode hex": "239B" },
        { "Typeface name": "Symbol", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "9116", "Unicode hex": "239C" },
        { "Typeface name": "Symbol", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "9117", "Unicode hex": "239D" },
        { "Typeface name": "Symbol", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "9121", "Unicode hex": "23A1" },
        { "Typeface name": "Symbol", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "9122", "Unicode hex": "23A2" },
        { "Typeface name": "Symbol", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "9123", "Unicode hex": "23A3" },
        { "Typeface name": "Symbol", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "9127", "Unicode hex": "23A7" },
        { "Typeface name": "Symbol", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "9128", "Unicode hex": "23A8" },
        { "Typeface name": "Symbol", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "9129", "Unicode hex": "23A9" },
        { "Typeface name": "Symbol", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "9130", "Unicode hex": "23AA" },
        { "Typeface name": "Symbol", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "63743", "Unicode hex": "F8FF" },
        { "Typeface name": "Symbol", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "12297", "Unicode hex": "3009" },
        { "Typeface name": "Symbol", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "8747", "Unicode hex": "222B" },
        { "Typeface name": "Symbol", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "8992", "Unicode hex": "2320" },
        { "Typeface name": "Symbol", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "9134", "Unicode hex": "23AE" },
        { "Typeface name": "Symbol", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "8993", "Unicode hex": "2321" },
        { "Typeface name": "Symbol", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "9118", "Unicode hex": "239E" },
        { "Typeface name": "Symbol", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "9119", "Unicode hex": "239F" },
        { "Typeface name": "Symbol", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "9120", "Unicode hex": "23A0" },
        { "Typeface name": "Symbol", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "9124", "Unicode hex": "23A4" },
        { "Typeface name": "Symbol", "Dingbat dec": "250", "Dingbat hex": "FA", "Unicode dec": "9125", "Unicode hex": "23A5" },
        { "Typeface name": "Symbol", "Dingbat dec": "251", "Dingbat hex": "FB", "Unicode dec": "9126", "Unicode hex": "23A6" },
        { "Typeface name": "Symbol", "Dingbat dec": "252", "Dingbat hex": "FC", "Unicode dec": "9131", "Unicode hex": "23AB" },
        { "Typeface name": "Symbol", "Dingbat dec": "253", "Dingbat hex": "FD", "Unicode dec": "9132", "Unicode hex": "23AC" },
        { "Typeface name": "Symbol", "Dingbat dec": "254", "Dingbat hex": "FE", "Unicode dec": "9133", "Unicode hex": "23AD" },
        { "Typeface name": "Webdings", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
        { "Typeface name": "Webdings", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "128375", "Unicode hex": "1F577" },
        { "Typeface name": "Webdings", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "128376", "Unicode hex": "1F578" },
        { "Typeface name": "Webdings", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "128370", "Unicode hex": "1F572" },
        { "Typeface name": "Webdings", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "128374", "Unicode hex": "1F576" },
        { "Typeface name": "Webdings", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "127942", "Unicode hex": "1F3C6" },
        { "Typeface name": "Webdings", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "127894", "Unicode hex": "1F396" },
        { "Typeface name": "Webdings", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "128391", "Unicode hex": "1F587" },
        { "Typeface name": "Webdings", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "128488", "Unicode hex": "1F5E8" },
        { "Typeface name": "Webdings", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "128489", "Unicode hex": "1F5E9" },
        { "Typeface name": "Webdings", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "128496", "Unicode hex": "1F5F0" },
        { "Typeface name": "Webdings", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "128497", "Unicode hex": "1F5F1" },
        { "Typeface name": "Webdings", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "127798", "Unicode hex": "1F336" },
        { "Typeface name": "Webdings", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "127895", "Unicode hex": "1F397" },
        { "Typeface name": "Webdings", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "128638", "Unicode hex": "1F67E" },
        { "Typeface name": "Webdings", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "128636", "Unicode hex": "1F67C" },
        { "Typeface name": "Webdings", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "128469", "Unicode hex": "1F5D5" },
        { "Typeface name": "Webdings", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "128470", "Unicode hex": "1F5D6" },
        { "Typeface name": "Webdings", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "128471", "Unicode hex": "1F5D7" },
        { "Typeface name": "Webdings", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "9204", "Unicode hex": "23F4" },
        { "Typeface name": "Webdings", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "9205", "Unicode hex": "23F5" },
        { "Typeface name": "Webdings", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "9206", "Unicode hex": "23F6" },
        { "Typeface name": "Webdings", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "9207", "Unicode hex": "23F7" },
        { "Typeface name": "Webdings", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "9194", "Unicode hex": "23EA" },
        { "Typeface name": "Webdings", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "9193", "Unicode hex": "23E9" },
        { "Typeface name": "Webdings", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "9198", "Unicode hex": "23EE" },
        { "Typeface name": "Webdings", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "9197", "Unicode hex": "23ED" },
        { "Typeface name": "Webdings", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "9208", "Unicode hex": "23F8" },
        { "Typeface name": "Webdings", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "9209", "Unicode hex": "23F9" },
        { "Typeface name": "Webdings", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "9210", "Unicode hex": "23FA" },
        { "Typeface name": "Webdings", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "128474", "Unicode hex": "1F5DA" },
        { "Typeface name": "Webdings", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "128499", "Unicode hex": "1F5F3" },
        { "Typeface name": "Webdings", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "128736", "Unicode hex": "1F6E0" },
        { "Typeface name": "Webdings", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "127959", "Unicode hex": "1F3D7" },
        { "Typeface name": "Webdings", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "127960", "Unicode hex": "1F3D8" },
        { "Typeface name": "Webdings", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "127961", "Unicode hex": "1F3D9" },
        { "Typeface name": "Webdings", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "127962", "Unicode hex": "1F3DA" },
        { "Typeface name": "Webdings", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "127964", "Unicode hex": "1F3DC" },
        { "Typeface name": "Webdings", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "127981", "Unicode hex": "1F3ED" },
        { "Typeface name": "Webdings", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "127963", "Unicode hex": "1F3DB" },
        { "Typeface name": "Webdings", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "127968", "Unicode hex": "1F3E0" },
        { "Typeface name": "Webdings", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "127958", "Unicode hex": "1F3D6" },
        { "Typeface name": "Webdings", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "127965", "Unicode hex": "1F3DD" },
        { "Typeface name": "Webdings", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "128739", "Unicode hex": "1F6E3" },
        { "Typeface name": "Webdings", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "128269", "Unicode hex": "1F50D" },
        { "Typeface name": "Webdings", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "127956", "Unicode hex": "1F3D4" },
        { "Typeface name": "Webdings", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "128065", "Unicode hex": "1F441" },
        { "Typeface name": "Webdings", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "128066", "Unicode hex": "1F442" },
        { "Typeface name": "Webdings", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "127966", "Unicode hex": "1F3DE" },
        { "Typeface name": "Webdings", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "127957", "Unicode hex": "1F3D5" },
        { "Typeface name": "Webdings", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "128740", "Unicode hex": "1F6E4" },
        { "Typeface name": "Webdings", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "127967", "Unicode hex": "1F3DF" },
        { "Typeface name": "Webdings", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "128755", "Unicode hex": "1F6F3" },
        { "Typeface name": "Webdings", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "128364", "Unicode hex": "1F56C" },
        { "Typeface name": "Webdings", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "128363", "Unicode hex": "1F56B" },
        { "Typeface name": "Webdings", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "128360", "Unicode hex": "1F568" },
        { "Typeface name": "Webdings", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "128264", "Unicode hex": "1F508" },
        { "Typeface name": "Webdings", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "127892", "Unicode hex": "1F394" },
        { "Typeface name": "Webdings", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "127893", "Unicode hex": "1F395" },
        { "Typeface name": "Webdings", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "128492", "Unicode hex": "1F5EC" },
        { "Typeface name": "Webdings", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "128637", "Unicode hex": "1F67D" },
        { "Typeface name": "Webdings", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "128493", "Unicode hex": "1F5ED" },
        { "Typeface name": "Webdings", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "128490", "Unicode hex": "1F5EA" },
        { "Typeface name": "Webdings", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "128491", "Unicode hex": "1F5EB" },
        { "Typeface name": "Webdings", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "11156", "Unicode hex": "2B94" },
        { "Typeface name": "Webdings", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "10004", "Unicode hex": "2714" },
        { "Typeface name": "Webdings", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "128690", "Unicode hex": "1F6B2" },
        { "Typeface name": "Webdings", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "11036", "Unicode hex": "2B1C" },
        { "Typeface name": "Webdings", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "128737", "Unicode hex": "1F6E1" },
        { "Typeface name": "Webdings", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "128230", "Unicode hex": "1F4E6" },
        { "Typeface name": "Webdings", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "128753", "Unicode hex": "1F6F1" },
        { "Typeface name": "Webdings", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "11035", "Unicode hex": "2B1B" },
        { "Typeface name": "Webdings", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "128657", "Unicode hex": "1F691" },
        { "Typeface name": "Webdings", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "128712", "Unicode hex": "1F6C8" },
        { "Typeface name": "Webdings", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "128745", "Unicode hex": "1F6E9" },
        { "Typeface name": "Webdings", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "128752", "Unicode hex": "1F6F0" },
        { "Typeface name": "Webdings", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "128968", "Unicode hex": "1F7C8" },
        { "Typeface name": "Webdings", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "128372", "Unicode hex": "1F574" },
        { "Typeface name": "Webdings", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "11044", "Unicode hex": "2B24" },
        { "Typeface name": "Webdings", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "128741", "Unicode hex": "1F6E5" },
        { "Typeface name": "Webdings", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "128660", "Unicode hex": "1F694" },
        { "Typeface name": "Webdings", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "128472", "Unicode hex": "1F5D8" },
        { "Typeface name": "Webdings", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "128473", "Unicode hex": "1F5D9" },
        { "Typeface name": "Webdings", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "10067", "Unicode hex": "2753" },
        { "Typeface name": "Webdings", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "128754", "Unicode hex": "1F6F2" },
        { "Typeface name": "Webdings", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "128647", "Unicode hex": "1F687" },
        { "Typeface name": "Webdings", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "128653", "Unicode hex": "1F68D" },
        { "Typeface name": "Webdings", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "9971", "Unicode hex": "26F3" },
        { "Typeface name": "Webdings", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "10680", "Unicode hex": "29B8" },
        { "Typeface name": "Webdings", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "8854", "Unicode hex": "2296" },
        { "Typeface name": "Webdings", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "128685", "Unicode hex": "1F6AD" },
        { "Typeface name": "Webdings", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "128494", "Unicode hex": "1F5EE" },
        { "Typeface name": "Webdings", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "9168", "Unicode hex": "23D0" },
        { "Typeface name": "Webdings", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "128495", "Unicode hex": "1F5EF" },
        { "Typeface name": "Webdings", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "128498", "Unicode hex": "1F5F2" },
        { "Typeface name": "Webdings", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "128697", "Unicode hex": "1F6B9" },
        { "Typeface name": "Webdings", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "128698", "Unicode hex": "1F6BA" },
        { "Typeface name": "Webdings", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "128713", "Unicode hex": "1F6C9" },
        { "Typeface name": "Webdings", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "128714", "Unicode hex": "1F6CA" },
        { "Typeface name": "Webdings", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "128700", "Unicode hex": "1F6BC" },
        { "Typeface name": "Webdings", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "128125", "Unicode hex": "1F47D" },
        { "Typeface name": "Webdings", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "127947", "Unicode hex": "1F3CB" },
        { "Typeface name": "Webdings", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "9975", "Unicode hex": "26F7" },
        { "Typeface name": "Webdings", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "127938", "Unicode hex": "1F3C2" },
        { "Typeface name": "Webdings", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "127948", "Unicode hex": "1F3CC" },
        { "Typeface name": "Webdings", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "127946", "Unicode hex": "1F3CA" },
        { "Typeface name": "Webdings", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "127940", "Unicode hex": "1F3C4" },
        { "Typeface name": "Webdings", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "127949", "Unicode hex": "1F3CD" },
        { "Typeface name": "Webdings", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "127950", "Unicode hex": "1F3CE" },
        { "Typeface name": "Webdings", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "128664", "Unicode hex": "1F698" },
        { "Typeface name": "Webdings", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "128480", "Unicode hex": "1F5E0" },
        { "Typeface name": "Webdings", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "128738", "Unicode hex": "1F6E2" },
        { "Typeface name": "Webdings", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "128176", "Unicode hex": "1F4B0" },
        { "Typeface name": "Webdings", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "127991", "Unicode hex": "1F3F7" },
        { "Typeface name": "Webdings", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "128179", "Unicode hex": "1F4B3" },
        { "Typeface name": "Webdings", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "128106", "Unicode hex": "1F46A" },
        { "Typeface name": "Webdings", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "128481", "Unicode hex": "1F5E1" },
        { "Typeface name": "Webdings", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "128482", "Unicode hex": "1F5E2" },
        { "Typeface name": "Webdings", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "128483", "Unicode hex": "1F5E3" },
        { "Typeface name": "Webdings", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "10031", "Unicode hex": "272F" },
        { "Typeface name": "Webdings", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "128388", "Unicode hex": "1F584" },
        { "Typeface name": "Webdings", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "128389", "Unicode hex": "1F585" },
        { "Typeface name": "Webdings", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "128387", "Unicode hex": "1F583" },
        { "Typeface name": "Webdings", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "128390", "Unicode hex": "1F586" },
        { "Typeface name": "Webdings", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "128441", "Unicode hex": "1F5B9" },
        { "Typeface name": "Webdings", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "128442", "Unicode hex": "1F5BA" },
        { "Typeface name": "Webdings", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "128443", "Unicode hex": "1F5BB" },
        { "Typeface name": "Webdings", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "128373", "Unicode hex": "1F575" },
        { "Typeface name": "Webdings", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "128368", "Unicode hex": "1F570" },
        { "Typeface name": "Webdings", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "128445", "Unicode hex": "1F5BD" },
        { "Typeface name": "Webdings", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "128446", "Unicode hex": "1F5BE" },
        { "Typeface name": "Webdings", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "128203", "Unicode hex": "1F4CB" },
        { "Typeface name": "Webdings", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "128466", "Unicode hex": "1F5D2" },
        { "Typeface name": "Webdings", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "128467", "Unicode hex": "1F5D3" },
        { "Typeface name": "Webdings", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "128366", "Unicode hex": "1F56E" },
        { "Typeface name": "Webdings", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "128218", "Unicode hex": "1F4DA" },
        { "Typeface name": "Webdings", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "128478", "Unicode hex": "1F5DE" },
        { "Typeface name": "Webdings", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "128479", "Unicode hex": "1F5DF" },
        { "Typeface name": "Webdings", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "128451", "Unicode hex": "1F5C3" },
        { "Typeface name": "Webdings", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "128450", "Unicode hex": "1F5C2" },
        { "Typeface name": "Webdings", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "128444", "Unicode hex": "1F5BC" },
        { "Typeface name": "Webdings", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "127917", "Unicode hex": "1F3AD" },
        { "Typeface name": "Webdings", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "127900", "Unicode hex": "1F39C" },
        { "Typeface name": "Webdings", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "127896", "Unicode hex": "1F398" },
        { "Typeface name": "Webdings", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "127897", "Unicode hex": "1F399" },
        { "Typeface name": "Webdings", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "127911", "Unicode hex": "1F3A7" },
        { "Typeface name": "Webdings", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "128191", "Unicode hex": "1F4BF" },
        { "Typeface name": "Webdings", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "127902", "Unicode hex": "1F39E" },
        { "Typeface name": "Webdings", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "128247", "Unicode hex": "1F4F7" },
        { "Typeface name": "Webdings", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "127903", "Unicode hex": "1F39F" },
        { "Typeface name": "Webdings", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "127916", "Unicode hex": "1F3AC" },
        { "Typeface name": "Webdings", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "128253", "Unicode hex": "1F4FD" },
        { "Typeface name": "Webdings", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "128249", "Unicode hex": "1F4F9" },
        { "Typeface name": "Webdings", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "128254", "Unicode hex": "1F4FE" },
        { "Typeface name": "Webdings", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "128251", "Unicode hex": "1F4FB" },
        { "Typeface name": "Webdings", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "127898", "Unicode hex": "1F39A" },
        { "Typeface name": "Webdings", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "127899", "Unicode hex": "1F39B" },
        { "Typeface name": "Webdings", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "128250", "Unicode hex": "1F4FA" },
        { "Typeface name": "Webdings", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "128187", "Unicode hex": "1F4BB" },
        { "Typeface name": "Webdings", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "128421", "Unicode hex": "1F5A5" },
        { "Typeface name": "Webdings", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "128422", "Unicode hex": "1F5A6" },
        { "Typeface name": "Webdings", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "128423", "Unicode hex": "1F5A7" },
        { "Typeface name": "Webdings", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "128377", "Unicode hex": "1F579" },
        { "Typeface name": "Webdings", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "127918", "Unicode hex": "1F3AE" },
        { "Typeface name": "Webdings", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "128379", "Unicode hex": "1F57B" },
        { "Typeface name": "Webdings", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "128380", "Unicode hex": "1F57C" },
        { "Typeface name": "Webdings", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "128223", "Unicode hex": "1F4DF" },
        { "Typeface name": "Webdings", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "128385", "Unicode hex": "1F581" },
        { "Typeface name": "Webdings", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "128384", "Unicode hex": "1F580" },
        { "Typeface name": "Webdings", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "128424", "Unicode hex": "1F5A8" },
        { "Typeface name": "Webdings", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "128425", "Unicode hex": "1F5A9" },
        { "Typeface name": "Webdings", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "128447", "Unicode hex": "1F5BF" },
        { "Typeface name": "Webdings", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "128426", "Unicode hex": "1F5AA" },
        { "Typeface name": "Webdings", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "128476", "Unicode hex": "1F5DC" },
        { "Typeface name": "Webdings", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "128274", "Unicode hex": "1F512" },
        { "Typeface name": "Webdings", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "128275", "Unicode hex": "1F513" },
        { "Typeface name": "Webdings", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "128477", "Unicode hex": "1F5DD" },
        { "Typeface name": "Webdings", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "128229", "Unicode hex": "1F4E5" },
        { "Typeface name": "Webdings", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "128228", "Unicode hex": "1F4E4" },
        { "Typeface name": "Webdings", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "128371", "Unicode hex": "1F573" },
        { "Typeface name": "Webdings", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "127779", "Unicode hex": "1F323" },
        { "Typeface name": "Webdings", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "127780", "Unicode hex": "1F324" },
        { "Typeface name": "Webdings", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "127781", "Unicode hex": "1F325" },
        { "Typeface name": "Webdings", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "127782", "Unicode hex": "1F326" },
        { "Typeface name": "Webdings", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "9729", "Unicode hex": "2601" },
        { "Typeface name": "Webdings", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "127784", "Unicode hex": "1F328" },
        { "Typeface name": "Webdings", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "127783", "Unicode hex": "1F327" },
        { "Typeface name": "Webdings", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "127785", "Unicode hex": "1F329" },
        { "Typeface name": "Webdings", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "127786", "Unicode hex": "1F32A" },
        { "Typeface name": "Webdings", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "127788", "Unicode hex": "1F32C" },
        { "Typeface name": "Webdings", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "127787", "Unicode hex": "1F32B" },
        { "Typeface name": "Webdings", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "127772", "Unicode hex": "1F31C" },
        { "Typeface name": "Webdings", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "127777", "Unicode hex": "1F321" },
        { "Typeface name": "Webdings", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "128715", "Unicode hex": "1F6CB" },
        { "Typeface name": "Webdings", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "128719", "Unicode hex": "1F6CF" },
        { "Typeface name": "Webdings", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "127869", "Unicode hex": "1F37D" },
        { "Typeface name": "Webdings", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "127864", "Unicode hex": "1F378" },
        { "Typeface name": "Webdings", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "128718", "Unicode hex": "1F6CE" },
        { "Typeface name": "Webdings", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "128717", "Unicode hex": "1F6CD" },
        { "Typeface name": "Webdings", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "9413", "Unicode hex": "24C5" },
        { "Typeface name": "Webdings", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "9855", "Unicode hex": "267F" },
        { "Typeface name": "Webdings", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "128710", "Unicode hex": "1F6C6" },
        { "Typeface name": "Webdings", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "128392", "Unicode hex": "1F588" },
        { "Typeface name": "Webdings", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "127891", "Unicode hex": "1F393" },
        { "Typeface name": "Webdings", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "128484", "Unicode hex": "1F5E4" },
        { "Typeface name": "Webdings", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "128485", "Unicode hex": "1F5E5" },
        { "Typeface name": "Webdings", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "128486", "Unicode hex": "1F5E6" },
        { "Typeface name": "Webdings", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "128487", "Unicode hex": "1F5E7" },
        { "Typeface name": "Webdings", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "128746", "Unicode hex": "1F6EA" },
        { "Typeface name": "Webdings", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "128063", "Unicode hex": "1F43F" },
        { "Typeface name": "Webdings", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "128038", "Unicode hex": "1F426" },
        { "Typeface name": "Webdings", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "128031", "Unicode hex": "1F41F" },
        { "Typeface name": "Webdings", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "128021", "Unicode hex": "1F415" },
        { "Typeface name": "Webdings", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "128008", "Unicode hex": "1F408" },
        { "Typeface name": "Webdings", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "128620", "Unicode hex": "1F66C" },
        { "Typeface name": "Webdings", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "128622", "Unicode hex": "1F66E" },
        { "Typeface name": "Webdings", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "128621", "Unicode hex": "1F66D" },
        { "Typeface name": "Webdings", "Dingbat dec": "250", "Dingbat hex": "FA", "Unicode dec": "128623", "Unicode hex": "1F66F" },
        { "Typeface name": "Webdings", "Dingbat dec": "251", "Dingbat hex": "FB", "Unicode dec": "128506", "Unicode hex": "1F5FA" },
        { "Typeface name": "Webdings", "Dingbat dec": "252", "Dingbat hex": "FC", "Unicode dec": "127757", "Unicode hex": "1F30D" },
        { "Typeface name": "Webdings", "Dingbat dec": "253", "Dingbat hex": "FD", "Unicode dec": "127759", "Unicode hex": "1F30F" },
        { "Typeface name": "Webdings", "Dingbat dec": "254", "Dingbat hex": "FE", "Unicode dec": "127758", "Unicode hex": "1F30E" },
        { "Typeface name": "Webdings", "Dingbat dec": "255", "Dingbat hex": "FF", "Unicode dec": "128330", "Unicode hex": "1F54A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
        { "Typeface name": "Wingdings", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "128393", "Unicode hex": "1F589" },
        { "Typeface name": "Wingdings", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "9986", "Unicode hex": "2702" },
        { "Typeface name": "Wingdings", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "9985", "Unicode hex": "2701" },
        { "Typeface name": "Wingdings", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "128083", "Unicode hex": "1F453" },
        { "Typeface name": "Wingdings", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "128365", "Unicode hex": "1F56D" },
        { "Typeface name": "Wingdings", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "128366", "Unicode hex": "1F56E" },
        { "Typeface name": "Wingdings", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "128367", "Unicode hex": "1F56F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "128383", "Unicode hex": "1F57F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "9990", "Unicode hex": "2706" },
        { "Typeface name": "Wingdings", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "128386", "Unicode hex": "1F582" },
        { "Typeface name": "Wingdings", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "128387", "Unicode hex": "1F583" },
        { "Typeface name": "Wingdings", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "128234", "Unicode hex": "1F4EA" },
        { "Typeface name": "Wingdings", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "128235", "Unicode hex": "1F4EB" },
        { "Typeface name": "Wingdings", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "128236", "Unicode hex": "1F4EC" },
        { "Typeface name": "Wingdings", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "128237", "Unicode hex": "1F4ED" },
        { "Typeface name": "Wingdings", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "128448", "Unicode hex": "1F5C0" },
        { "Typeface name": "Wingdings", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "128449", "Unicode hex": "1F5C1" },
        { "Typeface name": "Wingdings", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "128462", "Unicode hex": "1F5CE" },
        { "Typeface name": "Wingdings", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "128463", "Unicode hex": "1F5CF" },
        { "Typeface name": "Wingdings", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "128464", "Unicode hex": "1F5D0" },
        { "Typeface name": "Wingdings", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "128452", "Unicode hex": "1F5C4" },
        { "Typeface name": "Wingdings", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "8987", "Unicode hex": "231B" },
        { "Typeface name": "Wingdings", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "128430", "Unicode hex": "1F5AE" },
        { "Typeface name": "Wingdings", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "128432", "Unicode hex": "1F5B0" },
        { "Typeface name": "Wingdings", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "128434", "Unicode hex": "1F5B2" },
        { "Typeface name": "Wingdings", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "128435", "Unicode hex": "1F5B3" },
        { "Typeface name": "Wingdings", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "128436", "Unicode hex": "1F5B4" },
        { "Typeface name": "Wingdings", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "128427", "Unicode hex": "1F5AB" },
        { "Typeface name": "Wingdings", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "128428", "Unicode hex": "1F5AC" },
        { "Typeface name": "Wingdings", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "9991", "Unicode hex": "2707" },
        { "Typeface name": "Wingdings", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "9997", "Unicode hex": "270D" },
        { "Typeface name": "Wingdings", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "128398", "Unicode hex": "1F58E" },
        { "Typeface name": "Wingdings", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "9996", "Unicode hex": "270C" },
        { "Typeface name": "Wingdings", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "128399", "Unicode hex": "1F58F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "128077", "Unicode hex": "1F44D" },
        { "Typeface name": "Wingdings", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "128078", "Unicode hex": "1F44E" },
        { "Typeface name": "Wingdings", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "9756", "Unicode hex": "261C" },
        { "Typeface name": "Wingdings", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "9758", "Unicode hex": "261E" },
        { "Typeface name": "Wingdings", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "9757", "Unicode hex": "261D" },
        { "Typeface name": "Wingdings", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "9759", "Unicode hex": "261F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "128400", "Unicode hex": "1F590" },
        { "Typeface name": "Wingdings", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "9786", "Unicode hex": "263A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "128528", "Unicode hex": "1F610" },
        { "Typeface name": "Wingdings", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "9785", "Unicode hex": "2639" },
        { "Typeface name": "Wingdings", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "128163", "Unicode hex": "1F4A3" },
        { "Typeface name": "Wingdings", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "128369", "Unicode hex": "1F571" },
        { "Typeface name": "Wingdings", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "127987", "Unicode hex": "1F3F3" },
        { "Typeface name": "Wingdings", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "127985", "Unicode hex": "1F3F1" },
        { "Typeface name": "Wingdings", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "9992", "Unicode hex": "2708" },
        { "Typeface name": "Wingdings", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "9788", "Unicode hex": "263C" },
        { "Typeface name": "Wingdings", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "127778", "Unicode hex": "1F322" },
        { "Typeface name": "Wingdings", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "10052", "Unicode hex": "2744" },
        { "Typeface name": "Wingdings", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "128326", "Unicode hex": "1F546" },
        { "Typeface name": "Wingdings", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "10014", "Unicode hex": "271E" },
        { "Typeface name": "Wingdings", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "128328", "Unicode hex": "1F548" },
        { "Typeface name": "Wingdings", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "10016", "Unicode hex": "2720" },
        { "Typeface name": "Wingdings", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "10017", "Unicode hex": "2721" },
        { "Typeface name": "Wingdings", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "9770", "Unicode hex": "262A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "9775", "Unicode hex": "262F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "128329", "Unicode hex": "1F549" },
        { "Typeface name": "Wingdings", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "9784", "Unicode hex": "2638" },
        { "Typeface name": "Wingdings", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "9800", "Unicode hex": "2648" },
        { "Typeface name": "Wingdings", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "9801", "Unicode hex": "2649" },
        { "Typeface name": "Wingdings", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "9802", "Unicode hex": "264A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "9803", "Unicode hex": "264B" },
        { "Typeface name": "Wingdings", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "9804", "Unicode hex": "264C" },
        { "Typeface name": "Wingdings", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "9805", "Unicode hex": "264D" },
        { "Typeface name": "Wingdings", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "9806", "Unicode hex": "264E" },
        { "Typeface name": "Wingdings", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "9807", "Unicode hex": "264F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "9808", "Unicode hex": "2650" },
        { "Typeface name": "Wingdings", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "9809", "Unicode hex": "2651" },
        { "Typeface name": "Wingdings", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "9810", "Unicode hex": "2652" },
        { "Typeface name": "Wingdings", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "9811", "Unicode hex": "2653" },
        { "Typeface name": "Wingdings", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "128624", "Unicode hex": "1F670" },
        { "Typeface name": "Wingdings", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "128629", "Unicode hex": "1F675" },
        { "Typeface name": "Wingdings", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "9899", "Unicode hex": "26AB" },
        { "Typeface name": "Wingdings", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "128318", "Unicode hex": "1F53E" },
        { "Typeface name": "Wingdings", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "9724", "Unicode hex": "25FC" },
        { "Typeface name": "Wingdings", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "128911", "Unicode hex": "1F78F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "128912", "Unicode hex": "1F790" },
        { "Typeface name": "Wingdings", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "10065", "Unicode hex": "2751" },
        { "Typeface name": "Wingdings", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "10066", "Unicode hex": "2752" },
        { "Typeface name": "Wingdings", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "128927", "Unicode hex": "1F79F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "10731", "Unicode hex": "29EB" },
        { "Typeface name": "Wingdings", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "9670", "Unicode hex": "25C6" },
        { "Typeface name": "Wingdings", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "10070", "Unicode hex": "2756" },
        { "Typeface name": "Wingdings", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "11049", "Unicode hex": "2B29" },
        { "Typeface name": "Wingdings", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "8999", "Unicode hex": "2327" },
        { "Typeface name": "Wingdings", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "11193", "Unicode hex": "2BB9" },
        { "Typeface name": "Wingdings", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "8984", "Unicode hex": "2318" },
        { "Typeface name": "Wingdings", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "127989", "Unicode hex": "1F3F5" },
        { "Typeface name": "Wingdings", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "127990", "Unicode hex": "1F3F6" },
        { "Typeface name": "Wingdings", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "128630", "Unicode hex": "1F676" },
        { "Typeface name": "Wingdings", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "128631", "Unicode hex": "1F677" },
        { "Typeface name": "Wingdings", "Dingbat dec": "127", "Dingbat hex": "7F", "Unicode dec": "9647", "Unicode hex": "25AF" },
        { "Typeface name": "Wingdings", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "127243", "Unicode hex": "1F10B" },
        { "Typeface name": "Wingdings", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "10112", "Unicode hex": "2780" },
        { "Typeface name": "Wingdings", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "10113", "Unicode hex": "2781" },
        { "Typeface name": "Wingdings", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "10114", "Unicode hex": "2782" },
        { "Typeface name": "Wingdings", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "10115", "Unicode hex": "2783" },
        { "Typeface name": "Wingdings", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "10116", "Unicode hex": "2784" },
        { "Typeface name": "Wingdings", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "10117", "Unicode hex": "2785" },
        { "Typeface name": "Wingdings", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "10118", "Unicode hex": "2786" },
        { "Typeface name": "Wingdings", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "10119", "Unicode hex": "2787" },
        { "Typeface name": "Wingdings", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "10120", "Unicode hex": "2788" },
        { "Typeface name": "Wingdings", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "10121", "Unicode hex": "2789" },
        { "Typeface name": "Wingdings", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "127244", "Unicode hex": "1F10C" },
        { "Typeface name": "Wingdings", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "10122", "Unicode hex": "278A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "10123", "Unicode hex": "278B" },
        { "Typeface name": "Wingdings", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "10124", "Unicode hex": "278C" },
        { "Typeface name": "Wingdings", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "10125", "Unicode hex": "278D" },
        { "Typeface name": "Wingdings", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "10126", "Unicode hex": "278E" },
        { "Typeface name": "Wingdings", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "10127", "Unicode hex": "278F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "10128", "Unicode hex": "2790" },
        { "Typeface name": "Wingdings", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "10129", "Unicode hex": "2791" },
        { "Typeface name": "Wingdings", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "10130", "Unicode hex": "2792" },
        { "Typeface name": "Wingdings", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "10131", "Unicode hex": "2793" },
        { "Typeface name": "Wingdings", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "128610", "Unicode hex": "1F662" },
        { "Typeface name": "Wingdings", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "128608", "Unicode hex": "1F660" },
        { "Typeface name": "Wingdings", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "128609", "Unicode hex": "1F661" },
        { "Typeface name": "Wingdings", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "128611", "Unicode hex": "1F663" },
        { "Typeface name": "Wingdings", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "128606", "Unicode hex": "1F65E" },
        { "Typeface name": "Wingdings", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "128604", "Unicode hex": "1F65C" },
        { "Typeface name": "Wingdings", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "128605", "Unicode hex": "1F65D" },
        { "Typeface name": "Wingdings", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "128607", "Unicode hex": "1F65F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "8729", "Unicode hex": "2219" },
        { "Typeface name": "Wingdings", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "8226", "Unicode hex": "2022" },
        { "Typeface name": "Wingdings", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "11037", "Unicode hex": "2B1D" },
        { "Typeface name": "Wingdings", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "11096", "Unicode hex": "2B58" },
        { "Typeface name": "Wingdings", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "128902", "Unicode hex": "1F786" },
        { "Typeface name": "Wingdings", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "128904", "Unicode hex": "1F788" },
        { "Typeface name": "Wingdings", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "128906", "Unicode hex": "1F78A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "128907", "Unicode hex": "1F78B" },
        { "Typeface name": "Wingdings", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "128319", "Unicode hex": "1F53F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "9642", "Unicode hex": "25AA" },
        { "Typeface name": "Wingdings", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "128910", "Unicode hex": "1F78E" },
        { "Typeface name": "Wingdings", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "128961", "Unicode hex": "1F7C1" },
        { "Typeface name": "Wingdings", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "128965", "Unicode hex": "1F7C5" },
        { "Typeface name": "Wingdings", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "9733", "Unicode hex": "2605" },
        { "Typeface name": "Wingdings", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "128971", "Unicode hex": "1F7CB" },
        { "Typeface name": "Wingdings", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "128975", "Unicode hex": "1F7CF" },
        { "Typeface name": "Wingdings", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "128979", "Unicode hex": "1F7D3" },
        { "Typeface name": "Wingdings", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "128977", "Unicode hex": "1F7D1" },
        { "Typeface name": "Wingdings", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "11216", "Unicode hex": "2BD0" },
        { "Typeface name": "Wingdings", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "8982", "Unicode hex": "2316" },
        { "Typeface name": "Wingdings", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "11214", "Unicode hex": "2BCE" },
        { "Typeface name": "Wingdings", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "11215", "Unicode hex": "2BCF" },
        { "Typeface name": "Wingdings", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "11217", "Unicode hex": "2BD1" },
        { "Typeface name": "Wingdings", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "10026", "Unicode hex": "272A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "10032", "Unicode hex": "2730" },
        { "Typeface name": "Wingdings", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "128336", "Unicode hex": "1F550" },
        { "Typeface name": "Wingdings", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "128337", "Unicode hex": "1F551" },
        { "Typeface name": "Wingdings", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "128338", "Unicode hex": "1F552" },
        { "Typeface name": "Wingdings", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "128339", "Unicode hex": "1F553" },
        { "Typeface name": "Wingdings", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "128340", "Unicode hex": "1F554" },
        { "Typeface name": "Wingdings", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "128341", "Unicode hex": "1F555" },
        { "Typeface name": "Wingdings", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "128342", "Unicode hex": "1F556" },
        { "Typeface name": "Wingdings", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "128343", "Unicode hex": "1F557" },
        { "Typeface name": "Wingdings", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "128344", "Unicode hex": "1F558" },
        { "Typeface name": "Wingdings", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "128345", "Unicode hex": "1F559" },
        { "Typeface name": "Wingdings", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "128346", "Unicode hex": "1F55A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "128347", "Unicode hex": "1F55B" },
        { "Typeface name": "Wingdings", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "11184", "Unicode hex": "2BB0" },
        { "Typeface name": "Wingdings", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "11185", "Unicode hex": "2BB1" },
        { "Typeface name": "Wingdings", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "11186", "Unicode hex": "2BB2" },
        { "Typeface name": "Wingdings", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "11187", "Unicode hex": "2BB3" },
        { "Typeface name": "Wingdings", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "11188", "Unicode hex": "2BB4" },
        { "Typeface name": "Wingdings", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "11189", "Unicode hex": "2BB5" },
        { "Typeface name": "Wingdings", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "11190", "Unicode hex": "2BB6" },
        { "Typeface name": "Wingdings", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "11191", "Unicode hex": "2BB7" },
        { "Typeface name": "Wingdings", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "128618", "Unicode hex": "1F66A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "128619", "Unicode hex": "1F66B" },
        { "Typeface name": "Wingdings", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "128597", "Unicode hex": "1F655" },
        { "Typeface name": "Wingdings", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "128596", "Unicode hex": "1F654" },
        { "Typeface name": "Wingdings", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "128599", "Unicode hex": "1F657" },
        { "Typeface name": "Wingdings", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "128598", "Unicode hex": "1F656" },
        { "Typeface name": "Wingdings", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "128592", "Unicode hex": "1F650" },
        { "Typeface name": "Wingdings", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "128593", "Unicode hex": "1F651" },
        { "Typeface name": "Wingdings", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "128594", "Unicode hex": "1F652" },
        { "Typeface name": "Wingdings", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "128595", "Unicode hex": "1F653" },
        { "Typeface name": "Wingdings", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "9003", "Unicode hex": "232B" },
        { "Typeface name": "Wingdings", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "8998", "Unicode hex": "2326" },
        { "Typeface name": "Wingdings", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "11160", "Unicode hex": "2B98" },
        { "Typeface name": "Wingdings", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "11162", "Unicode hex": "2B9A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "11161", "Unicode hex": "2B99" },
        { "Typeface name": "Wingdings", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "11163", "Unicode hex": "2B9B" },
        { "Typeface name": "Wingdings", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "11144", "Unicode hex": "2B88" },
        { "Typeface name": "Wingdings", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "11146", "Unicode hex": "2B8A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "11145", "Unicode hex": "2B89" },
        { "Typeface name": "Wingdings", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "11147", "Unicode hex": "2B8B" },
        { "Typeface name": "Wingdings", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "129128", "Unicode hex": "1F868" },
        { "Typeface name": "Wingdings", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "129130", "Unicode hex": "1F86A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "129129", "Unicode hex": "1F869" },
        { "Typeface name": "Wingdings", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "129131", "Unicode hex": "1F86B" },
        { "Typeface name": "Wingdings", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "129132", "Unicode hex": "1F86C" },
        { "Typeface name": "Wingdings", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "129133", "Unicode hex": "1F86D" },
        { "Typeface name": "Wingdings", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "129135", "Unicode hex": "1F86F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "129134", "Unicode hex": "1F86E" },
        { "Typeface name": "Wingdings", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "129144", "Unicode hex": "1F878" },
        { "Typeface name": "Wingdings", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "129146", "Unicode hex": "1F87A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "129145", "Unicode hex": "1F879" },
        { "Typeface name": "Wingdings", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "129147", "Unicode hex": "1F87B" },
        { "Typeface name": "Wingdings", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "129148", "Unicode hex": "1F87C" },
        { "Typeface name": "Wingdings", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "129149", "Unicode hex": "1F87D" },
        { "Typeface name": "Wingdings", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "129151", "Unicode hex": "1F87F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "129150", "Unicode hex": "1F87E" },
        { "Typeface name": "Wingdings", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "8678", "Unicode hex": "21E6" },
        { "Typeface name": "Wingdings", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "8680", "Unicode hex": "21E8" },
        { "Typeface name": "Wingdings", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "8679", "Unicode hex": "21E7" },
        { "Typeface name": "Wingdings", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "8681", "Unicode hex": "21E9" },
        { "Typeface name": "Wingdings", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "11012", "Unicode hex": "2B04" },
        { "Typeface name": "Wingdings", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "8691", "Unicode hex": "21F3" },
        { "Typeface name": "Wingdings", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "11009", "Unicode hex": "2B01" },
        { "Typeface name": "Wingdings", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "11008", "Unicode hex": "2B00" },
        { "Typeface name": "Wingdings", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "11011", "Unicode hex": "2B03" },
        { "Typeface name": "Wingdings", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "11010", "Unicode hex": "2B02" },
        { "Typeface name": "Wingdings", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "129196", "Unicode hex": "1F8AC" },
        { "Typeface name": "Wingdings", "Dingbat dec": "250", "Dingbat hex": "FA", "Unicode dec": "129197", "Unicode hex": "1F8AD" },
        { "Typeface name": "Wingdings", "Dingbat dec": "251", "Dingbat hex": "FB", "Unicode dec": "128502", "Unicode hex": "1F5F6" },
        { "Typeface name": "Wingdings", "Dingbat dec": "252", "Dingbat hex": "FC", "Unicode dec": "10003", "Unicode hex": "2713" },
        { "Typeface name": "Wingdings", "Dingbat dec": "253", "Dingbat hex": "FD", "Unicode dec": "128503", "Unicode hex": "1F5F7" },
        { "Typeface name": "Wingdings", "Dingbat dec": "254", "Dingbat hex": "FE", "Unicode dec": "128505", "Unicode hex": "1F5F9" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "128394", "Unicode hex": "1F58A" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "128395", "Unicode hex": "1F58B" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "128396", "Unicode hex": "1F58C" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "128397", "Unicode hex": "1F58D" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "9988", "Unicode hex": "2704" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "9984", "Unicode hex": "2700" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "128382", "Unicode hex": "1F57E" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "128381", "Unicode hex": "1F57D" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "128453", "Unicode hex": "1F5C5" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "128454", "Unicode hex": "1F5C6" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "128455", "Unicode hex": "1F5C7" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "128456", "Unicode hex": "1F5C8" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "128457", "Unicode hex": "1F5C9" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "128458", "Unicode hex": "1F5CA" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "128459", "Unicode hex": "1F5CB" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "128460", "Unicode hex": "1F5CC" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "128461", "Unicode hex": "1F5CD" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "128203", "Unicode hex": "1F4CB" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "128465", "Unicode hex": "1F5D1" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "128468", "Unicode hex": "1F5D4" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "128437", "Unicode hex": "1F5B5" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "128438", "Unicode hex": "1F5B6" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "128439", "Unicode hex": "1F5B7" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "128440", "Unicode hex": "1F5B8" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "128429", "Unicode hex": "1F5AD" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "128431", "Unicode hex": "1F5AF" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "128433", "Unicode hex": "1F5B1" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "128402", "Unicode hex": "1F592" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "128403", "Unicode hex": "1F593" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "128408", "Unicode hex": "1F598" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "128409", "Unicode hex": "1F599" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "128410", "Unicode hex": "1F59A" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "128411", "Unicode hex": "1F59B" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "128072", "Unicode hex": "1F448" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "128073", "Unicode hex": "1F449" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "128412", "Unicode hex": "1F59C" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "128413", "Unicode hex": "1F59D" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "128414", "Unicode hex": "1F59E" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "128415", "Unicode hex": "1F59F" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "128416", "Unicode hex": "1F5A0" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "128417", "Unicode hex": "1F5A1" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "128070", "Unicode hex": "1F446" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "128071", "Unicode hex": "1F447" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "128418", "Unicode hex": "1F5A2" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "128419", "Unicode hex": "1F5A3" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "128401", "Unicode hex": "1F591" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "128500", "Unicode hex": "1F5F4" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "128504", "Unicode hex": "1F5F8" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "128501", "Unicode hex": "1F5F5" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "9745", "Unicode hex": "2611" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "11197", "Unicode hex": "2BBD" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "9746", "Unicode hex": "2612" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "11198", "Unicode hex": "2BBE" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "11199", "Unicode hex": "2BBF" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "128711", "Unicode hex": "1F6C7" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "10680", "Unicode hex": "29B8" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "128625", "Unicode hex": "1F671" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "128628", "Unicode hex": "1F674" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "128626", "Unicode hex": "1F672" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "128627", "Unicode hex": "1F673" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "8253", "Unicode hex": "203D" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "128633", "Unicode hex": "1F679" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "128634", "Unicode hex": "1F67A" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "128635", "Unicode hex": "1F67B" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "128614", "Unicode hex": "1F666" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "128612", "Unicode hex": "1F664" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "128613", "Unicode hex": "1F665" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "128615", "Unicode hex": "1F667" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "128602", "Unicode hex": "1F65A" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "128600", "Unicode hex": "1F658" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "128601", "Unicode hex": "1F659" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "128603", "Unicode hex": "1F65B" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "9450", "Unicode hex": "24EA" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "9312", "Unicode hex": "2460" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "9313", "Unicode hex": "2461" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "9314", "Unicode hex": "2462" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "9315", "Unicode hex": "2463" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "9316", "Unicode hex": "2464" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "9317", "Unicode hex": "2465" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "9318", "Unicode hex": "2466" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "9319", "Unicode hex": "2467" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "9320", "Unicode hex": "2468" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "9321", "Unicode hex": "2469" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "9471", "Unicode hex": "24FF" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "10102", "Unicode hex": "2776" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "10103", "Unicode hex": "2777" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "10104", "Unicode hex": "2778" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "10105", "Unicode hex": "2779" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "10106", "Unicode hex": "277A" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "10107", "Unicode hex": "277B" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "10108", "Unicode hex": "277C" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "10109", "Unicode hex": "277D" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "10110", "Unicode hex": "277E" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "10111", "Unicode hex": "277F" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "9737", "Unicode hex": "2609" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "127765", "Unicode hex": "1F315" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "9789", "Unicode hex": "263D" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "9790", "Unicode hex": "263E" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "11839", "Unicode hex": "2E3F" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "10013", "Unicode hex": "271D" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "128327", "Unicode hex": "1F547" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "128348", "Unicode hex": "1F55C" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "128349", "Unicode hex": "1F55D" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "128350", "Unicode hex": "1F55E" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "128351", "Unicode hex": "1F55F" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "128352", "Unicode hex": "1F560" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "128353", "Unicode hex": "1F561" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "128354", "Unicode hex": "1F562" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "128355", "Unicode hex": "1F563" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "128356", "Unicode hex": "1F564" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "128357", "Unicode hex": "1F565" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "128358", "Unicode hex": "1F566" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "128359", "Unicode hex": "1F567" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "128616", "Unicode hex": "1F668" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "128617", "Unicode hex": "1F669" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "8901", "Unicode hex": "22C5" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "128900", "Unicode hex": "1F784" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "10625", "Unicode hex": "2981" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "9679", "Unicode hex": "25CF" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "9675", "Unicode hex": "25CB" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "128901", "Unicode hex": "1F785" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "128903", "Unicode hex": "1F787" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "128905", "Unicode hex": "1F789" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "8857", "Unicode hex": "2299" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "10687", "Unicode hex": "29BF" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "128908", "Unicode hex": "1F78C" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "128909", "Unicode hex": "1F78D" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "9726", "Unicode hex": "25FE" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "9632", "Unicode hex": "25A0" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "9633", "Unicode hex": "25A1" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "128913", "Unicode hex": "1F791" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "128914", "Unicode hex": "1F792" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "128915", "Unicode hex": "1F793" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "128916", "Unicode hex": "1F794" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "9635", "Unicode hex": "25A3" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "128917", "Unicode hex": "1F795" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "128918", "Unicode hex": "1F796" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "128919", "Unicode hex": "1F797" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "128920", "Unicode hex": "1F798" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "11049", "Unicode hex": "2B29" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "11045", "Unicode hex": "2B25" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "9671", "Unicode hex": "25C7" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "128922", "Unicode hex": "1F79A" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "9672", "Unicode hex": "25C8" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "128923", "Unicode hex": "1F79B" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "128924", "Unicode hex": "1F79C" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "128925", "Unicode hex": "1F79D" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "128926", "Unicode hex": "1F79E" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "11050", "Unicode hex": "2B2A" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "11047", "Unicode hex": "2B27" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "9674", "Unicode hex": "25CA" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "128928", "Unicode hex": "1F7A0" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "9686", "Unicode hex": "25D6" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "9687", "Unicode hex": "25D7" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "11210", "Unicode hex": "2BCA" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "11211", "Unicode hex": "2BCB" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "11200", "Unicode hex": "2BC0" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "11201", "Unicode hex": "2BC1" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "11039", "Unicode hex": "2B1F" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "11202", "Unicode hex": "2BC2" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "11043", "Unicode hex": "2B23" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "11042", "Unicode hex": "2B22" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "11203", "Unicode hex": "2BC3" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "11204", "Unicode hex": "2BC4" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "128929", "Unicode hex": "1F7A1" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "128930", "Unicode hex": "1F7A2" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "128931", "Unicode hex": "1F7A3" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "128932", "Unicode hex": "1F7A4" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "128933", "Unicode hex": "1F7A5" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "128934", "Unicode hex": "1F7A6" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "128935", "Unicode hex": "1F7A7" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "128936", "Unicode hex": "1F7A8" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "128937", "Unicode hex": "1F7A9" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "128938", "Unicode hex": "1F7AA" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "128939", "Unicode hex": "1F7AB" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "128940", "Unicode hex": "1F7AC" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "128941", "Unicode hex": "1F7AD" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "128942", "Unicode hex": "1F7AE" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "128943", "Unicode hex": "1F7AF" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "128944", "Unicode hex": "1F7B0" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "128945", "Unicode hex": "1F7B1" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "128946", "Unicode hex": "1F7B2" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "128947", "Unicode hex": "1F7B3" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "128948", "Unicode hex": "1F7B4" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "128949", "Unicode hex": "1F7B5" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "128950", "Unicode hex": "1F7B6" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "128951", "Unicode hex": "1F7B7" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "128952", "Unicode hex": "1F7B8" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "128953", "Unicode hex": "1F7B9" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "128954", "Unicode hex": "1F7BA" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "128955", "Unicode hex": "1F7BB" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "128956", "Unicode hex": "1F7BC" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "128957", "Unicode hex": "1F7BD" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "128958", "Unicode hex": "1F7BE" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "128959", "Unicode hex": "1F7BF" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "128960", "Unicode hex": "1F7C0" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "128962", "Unicode hex": "1F7C2" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "128964", "Unicode hex": "1F7C4" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "128966", "Unicode hex": "1F7C6" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "128969", "Unicode hex": "1F7C9" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "128970", "Unicode hex": "1F7CA" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "10038", "Unicode hex": "2736" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "128972", "Unicode hex": "1F7CC" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "128974", "Unicode hex": "1F7CE" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "128976", "Unicode hex": "1F7D0" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "128978", "Unicode hex": "1F7D2" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "10041", "Unicode hex": "2739" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "128963", "Unicode hex": "1F7C3" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "128967", "Unicode hex": "1F7C7" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "10031", "Unicode hex": "272F" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "128973", "Unicode hex": "1F7CD" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "128980", "Unicode hex": "1F7D4" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "11212", "Unicode hex": "2BCC" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "11213", "Unicode hex": "2BCD" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "8251", "Unicode hex": "203B" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "8258", "Unicode hex": "2042" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "11104", "Unicode hex": "2B60" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "11106", "Unicode hex": "2B62" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "11105", "Unicode hex": "2B61" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "11107", "Unicode hex": "2B63" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "11110", "Unicode hex": "2B66" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "11111", "Unicode hex": "2B67" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "11113", "Unicode hex": "2B69" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "11112", "Unicode hex": "2B68" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "11120", "Unicode hex": "2B70" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "11122", "Unicode hex": "2B72" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "11121", "Unicode hex": "2B71" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "11123", "Unicode hex": "2B73" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "11126", "Unicode hex": "2B76" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "11128", "Unicode hex": "2B78" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "11131", "Unicode hex": "2B7B" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "11133", "Unicode hex": "2B7D" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "11108", "Unicode hex": "2B64" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "11109", "Unicode hex": "2B65" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "11114", "Unicode hex": "2B6A" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "11116", "Unicode hex": "2B6C" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "11115", "Unicode hex": "2B6B" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "11117", "Unicode hex": "2B6D" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "11085", "Unicode hex": "2B4D" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "11168", "Unicode hex": "2BA0" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "11169", "Unicode hex": "2BA1" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "11170", "Unicode hex": "2BA2" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "11171", "Unicode hex": "2BA3" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "11172", "Unicode hex": "2BA4" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "11173", "Unicode hex": "2BA5" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "11174", "Unicode hex": "2BA6" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "11175", "Unicode hex": "2BA7" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "11152", "Unicode hex": "2B90" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "11153", "Unicode hex": "2B91" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "11154", "Unicode hex": "2B92" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "11155", "Unicode hex": "2B93" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "11136", "Unicode hex": "2B80" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "11139", "Unicode hex": "2B83" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "11134", "Unicode hex": "2B7E" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "11135", "Unicode hex": "2B7F" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "11140", "Unicode hex": "2B84" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "11142", "Unicode hex": "2B86" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "11141", "Unicode hex": "2B85" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "11143", "Unicode hex": "2B87" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "11151", "Unicode hex": "2B8F" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "11149", "Unicode hex": "2B8D" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "11150", "Unicode hex": "2B8E" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "11148", "Unicode hex": "2B8C" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "11118", "Unicode hex": "2B6E" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "11119", "Unicode hex": "2B6F" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "9099", "Unicode hex": "238B" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "8996", "Unicode hex": "2324" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "8963", "Unicode hex": "2303" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "8997", "Unicode hex": "2325" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "9251", "Unicode hex": "2423" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "9085", "Unicode hex": "237D" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "8682", "Unicode hex": "21EA" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "11192", "Unicode hex": "2BB8" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "129184", "Unicode hex": "1F8A0" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "129185", "Unicode hex": "1F8A1" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "129186", "Unicode hex": "1F8A2" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "129187", "Unicode hex": "1F8A3" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "129188", "Unicode hex": "1F8A4" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "129189", "Unicode hex": "1F8A5" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "129190", "Unicode hex": "1F8A6" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "129191", "Unicode hex": "1F8A7" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "129192", "Unicode hex": "1F8A8" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "129193", "Unicode hex": "1F8A9" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "129194", "Unicode hex": "1F8AA" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "129195", "Unicode hex": "1F8AB" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "129104", "Unicode hex": "1F850" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "129106", "Unicode hex": "1F852" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "129105", "Unicode hex": "1F851" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "129107", "Unicode hex": "1F853" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "129108", "Unicode hex": "1F854" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "129109", "Unicode hex": "1F855" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "129111", "Unicode hex": "1F857" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "129110", "Unicode hex": "1F856" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "129112", "Unicode hex": "1F858" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "129113", "Unicode hex": "1F859" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "9650", "Unicode hex": "25B2" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "9660", "Unicode hex": "25BC" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "9651", "Unicode hex": "25B3" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "9661", "Unicode hex": "25BD" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "9664", "Unicode hex": "25C0" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "9654", "Unicode hex": "25B6" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "9665", "Unicode hex": "25C1" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "9655", "Unicode hex": "25B7" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "9699", "Unicode hex": "25E3" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "9698", "Unicode hex": "25E2" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "9700", "Unicode hex": "25E4" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "9701", "Unicode hex": "25E5" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "128896", "Unicode hex": "1F780" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "128898", "Unicode hex": "1F782" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "128897", "Unicode hex": "1F781" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "128899", "Unicode hex": "1F783" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "11205", "Unicode hex": "2BC5" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "11206", "Unicode hex": "2BC6" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "11207", "Unicode hex": "2BC7" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "11208", "Unicode hex": "2BC8" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "11164", "Unicode hex": "2B9C" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "11166", "Unicode hex": "2B9E" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "11165", "Unicode hex": "2B9D" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "11167", "Unicode hex": "2B9F" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "129040", "Unicode hex": "1F810" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "129042", "Unicode hex": "1F812" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "129041", "Unicode hex": "1F811" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "129043", "Unicode hex": "1F813" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "129044", "Unicode hex": "1F814" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "129046", "Unicode hex": "1F816" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "129045", "Unicode hex": "1F815" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "129047", "Unicode hex": "1F817" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "129048", "Unicode hex": "1F818" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "129050", "Unicode hex": "1F81A" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "129049", "Unicode hex": "1F819" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "129051", "Unicode hex": "1F81B" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "129052", "Unicode hex": "1F81C" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "129054", "Unicode hex": "1F81E" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "129053", "Unicode hex": "1F81D" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "129055", "Unicode hex": "1F81F" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "129024", "Unicode hex": "1F800" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "129026", "Unicode hex": "1F802" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "129025", "Unicode hex": "1F801" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "129027", "Unicode hex": "1F803" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "129028", "Unicode hex": "1F804" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "129030", "Unicode hex": "1F806" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "129029", "Unicode hex": "1F805" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "129031", "Unicode hex": "1F807" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "129032", "Unicode hex": "1F808" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "129034", "Unicode hex": "1F80A" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "129033", "Unicode hex": "1F809" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "129035", "Unicode hex": "1F80B" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "129056", "Unicode hex": "1F820" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "129058", "Unicode hex": "1F822" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "129060", "Unicode hex": "1F824" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "129062", "Unicode hex": "1F826" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "129064", "Unicode hex": "1F828" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "129066", "Unicode hex": "1F82A" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "129068", "Unicode hex": "1F82C" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "129180", "Unicode hex": "1F89C" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "129181", "Unicode hex": "1F89D" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "129182", "Unicode hex": "1F89E" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "129183", "Unicode hex": "1F89F" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "129070", "Unicode hex": "1F82E" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "129072", "Unicode hex": "1F830" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "129074", "Unicode hex": "1F832" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "129076", "Unicode hex": "1F834" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "129078", "Unicode hex": "1F836" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "129080", "Unicode hex": "1F838" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "129082", "Unicode hex": "1F83A" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "129081", "Unicode hex": "1F839" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "129083", "Unicode hex": "1F83B" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "129176", "Unicode hex": "1F898" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "129178", "Unicode hex": "1F89A" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "129177", "Unicode hex": "1F899" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "129179", "Unicode hex": "1F89B" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "129084", "Unicode hex": "1F83C" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "129086", "Unicode hex": "1F83E" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "129085", "Unicode hex": "1F83D" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "129087", "Unicode hex": "1F83F" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "129088", "Unicode hex": "1F840" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "129090", "Unicode hex": "1F842" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "129089", "Unicode hex": "1F841" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "129091", "Unicode hex": "1F843" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "129092", "Unicode hex": "1F844" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "129094", "Unicode hex": "1F846" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "129093", "Unicode hex": "1F845" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "129095", "Unicode hex": "1F847" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "11176", "Unicode hex": "2BA8" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "11177", "Unicode hex": "2BA9" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "11178", "Unicode hex": "2BAA" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "11179", "Unicode hex": "2BAB" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "11180", "Unicode hex": "2BAC" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "11181", "Unicode hex": "2BAD" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "11182", "Unicode hex": "2BAE" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "11183", "Unicode hex": "2BAF" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "129120", "Unicode hex": "1F860" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "129122", "Unicode hex": "1F862" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "129121", "Unicode hex": "1F861" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "129123", "Unicode hex": "1F863" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "129124", "Unicode hex": "1F864" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "129125", "Unicode hex": "1F865" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "129127", "Unicode hex": "1F867" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "129126", "Unicode hex": "1F866" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "129136", "Unicode hex": "1F870" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "129138", "Unicode hex": "1F872" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "129137", "Unicode hex": "1F871" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "129139", "Unicode hex": "1F873" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "129140", "Unicode hex": "1F874" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "129141", "Unicode hex": "1F875" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "129143", "Unicode hex": "1F877" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "129142", "Unicode hex": "1F876" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "129152", "Unicode hex": "1F880" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "129154", "Unicode hex": "1F882" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "129153", "Unicode hex": "1F881" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "129155", "Unicode hex": "1F883" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "129156", "Unicode hex": "1F884" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "129157", "Unicode hex": "1F885" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "129159", "Unicode hex": "1F887" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "129158", "Unicode hex": "1F886" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "129168", "Unicode hex": "1F890" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "129170", "Unicode hex": "1F892" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "129169", "Unicode hex": "1F891" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "129171", "Unicode hex": "1F893" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "129172", "Unicode hex": "1F894" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "129174", "Unicode hex": "1F896" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "129173", "Unicode hex": "1F895" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "129175", "Unicode hex": "1F897" }
      ];
      re.default = ae;
    }, {}], 81: [function(le, ce, re) {
      var ae = this && this.__importDefault || function(m) {
        return m && m.__esModule ? m : { default: m };
      };
      Object.defineProperty(re, "__esModule", { value: !0 }), re.hex = re.dec = re.codePoint = void 0;
      for (var Z = ae(le("./dingbats")), o = {}, C = String.fromCodePoint ? String.fromCodePoint : p, t = 0, a = Z.default; t < a.length; t++) {
        var v = a[t], h = parseInt(v["Unicode dec"], 10), e = {
          codePoint: h,
          string: C(h)
        };
        o[v["Typeface name"].toUpperCase() + "_" + v["Dingbat dec"]] = e;
      }
      function y(m, g) {
        return o[m.toUpperCase() + "_" + g];
      }
      re.codePoint = y;
      function c(m, g) {
        return y(m, parseInt(g, 10));
      }
      re.dec = c;
      function d(m, g) {
        return y(m, parseInt(g, 16));
      }
      re.hex = d;
      function p(m) {
        if (m <= 65535)
          return String.fromCharCode(m);
        var g = Math.floor((m - 65536) / 1024) + 55296, n = (m - 65536) % 1024 + 56320;
        return String.fromCharCode(g, n);
      }
    }, { "./dingbats": 80 }], 82: [function(le, ce, re) {
      function ae() {
        this._events = this._events || {}, this._maxListeners = this._maxListeners || void 0;
      }
      ce.exports = ae, ae.EventEmitter = ae, ae.prototype._events = void 0, ae.prototype._maxListeners = void 0, ae.defaultMaxListeners = 10, ae.prototype.setMaxListeners = function(a) {
        if (!o(a) || a < 0 || isNaN(a))
          throw TypeError("n must be a positive number");
        return this._maxListeners = a, this;
      }, ae.prototype.emit = function(a) {
        var v, h, e, y, c, d;
        if (this._events || (this._events = {}), a === "error" && (!this._events.error || C(this._events.error) && !this._events.error.length)) {
          if (v = arguments[1], v instanceof Error)
            throw v;
          var p = new Error('Uncaught, unspecified "error" event. (' + v + ")");
          throw p.context = v, p;
        }
        if (h = this._events[a], t(h))
          return !1;
        if (Z(h))
          switch (arguments.length) {
            case 1:
              h.call(this);
              break;
            case 2:
              h.call(this, arguments[1]);
              break;
            case 3:
              h.call(this, arguments[1], arguments[2]);
              break;
            default:
              y = Array.prototype.slice.call(arguments, 1), h.apply(this, y);
          }
        else if (C(h))
          for (y = Array.prototype.slice.call(arguments, 1), d = h.slice(), e = d.length, c = 0; c < e; c++)
            d[c].apply(this, y);
        return !0;
      }, ae.prototype.addListener = function(a, v) {
        var h;
        if (!Z(v))
          throw TypeError("listener must be a function");
        return this._events || (this._events = {}), this._events.newListener && this.emit(
          "newListener",
          a,
          Z(v.listener) ? v.listener : v
        ), this._events[a] ? C(this._events[a]) ? this._events[a].push(v) : this._events[a] = [this._events[a], v] : this._events[a] = v, C(this._events[a]) && !this._events[a].warned && (t(this._maxListeners) ? h = ae.defaultMaxListeners : h = this._maxListeners, h && h > 0 && this._events[a].length > h && (this._events[a].warned = !0, console.error(
          "(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",
          this._events[a].length
        ), typeof console.trace == "function" && console.trace())), this;
      }, ae.prototype.on = ae.prototype.addListener, ae.prototype.once = function(a, v) {
        if (!Z(v))
          throw TypeError("listener must be a function");
        var h = !1;
        function e() {
          this.removeListener(a, e), h || (h = !0, v.apply(this, arguments));
        }
        return e.listener = v, this.on(a, e), this;
      }, ae.prototype.removeListener = function(a, v) {
        var h, e, y, c;
        if (!Z(v))
          throw TypeError("listener must be a function");
        if (!this._events || !this._events[a])
          return this;
        if (h = this._events[a], y = h.length, e = -1, h === v || Z(h.listener) && h.listener === v)
          delete this._events[a], this._events.removeListener && this.emit("removeListener", a, v);
        else if (C(h)) {
          for (c = y; c-- > 0; )
            if (h[c] === v || h[c].listener && h[c].listener === v) {
              e = c;
              break;
            }
          if (e < 0)
            return this;
          h.length === 1 ? (h.length = 0, delete this._events[a]) : h.splice(e, 1), this._events.removeListener && this.emit("removeListener", a, v);
        }
        return this;
      }, ae.prototype.removeAllListeners = function(a) {
        var v, h;
        if (!this._events)
          return this;
        if (!this._events.removeListener)
          return arguments.length === 0 ? this._events = {} : this._events[a] && delete this._events[a], this;
        if (arguments.length === 0) {
          for (v in this._events)
            v !== "removeListener" && this.removeAllListeners(v);
          return this.removeAllListeners("removeListener"), this._events = {}, this;
        }
        if (h = this._events[a], Z(h))
          this.removeListener(a, h);
        else if (h)
          for (; h.length; )
            this.removeListener(a, h[h.length - 1]);
        return delete this._events[a], this;
      }, ae.prototype.listeners = function(a) {
        var v;
        return !this._events || !this._events[a] ? v = [] : Z(this._events[a]) ? v = [this._events[a]] : v = this._events[a].slice(), v;
      }, ae.prototype.listenerCount = function(a) {
        if (this._events) {
          var v = this._events[a];
          if (Z(v))
            return 1;
          if (v)
            return v.length;
        }
        return 0;
      }, ae.listenerCount = function(a, v) {
        return a.listenerCount(v);
      };
      function Z(a) {
        return typeof a == "function";
      }
      function o(a) {
        return typeof a == "number";
      }
      function C(a) {
        return typeof a == "object" && a !== null;
      }
      function t(a) {
        return a === void 0;
      }
    }, {}], 83: [function(le, ce, re) {
      re.read = function(ae, Z, o, C, t) {
        var a, v, h = t * 8 - C - 1, e = (1 << h) - 1, y = e >> 1, c = -7, d = o ? t - 1 : 0, p = o ? -1 : 1, m = ae[Z + d];
        for (d += p, a = m & (1 << -c) - 1, m >>= -c, c += h; c > 0; a = a * 256 + ae[Z + d], d += p, c -= 8)
          ;
        for (v = a & (1 << -c) - 1, a >>= -c, c += C; c > 0; v = v * 256 + ae[Z + d], d += p, c -= 8)
          ;
        if (a === 0)
          a = 1 - y;
        else {
          if (a === e)
            return v ? NaN : (m ? -1 : 1) * (1 / 0);
          v = v + Math.pow(2, C), a = a - y;
        }
        return (m ? -1 : 1) * v * Math.pow(2, a - C);
      }, re.write = function(ae, Z, o, C, t, a) {
        var v, h, e, y = a * 8 - t - 1, c = (1 << y) - 1, d = c >> 1, p = t === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, m = C ? 0 : a - 1, g = C ? 1 : -1, n = Z < 0 || Z === 0 && 1 / Z < 0 ? 1 : 0;
        for (Z = Math.abs(Z), isNaN(Z) || Z === 1 / 0 ? (h = isNaN(Z) ? 1 : 0, v = c) : (v = Math.floor(Math.log(Z) / Math.LN2), Z * (e = Math.pow(2, -v)) < 1 && (v--, e *= 2), v + d >= 1 ? Z += p / e : Z += p * Math.pow(2, 1 - d), Z * e >= 2 && (v++, e /= 2), v + d >= c ? (h = 0, v = c) : v + d >= 1 ? (h = (Z * e - 1) * Math.pow(2, t), v = v + d) : (h = Z * Math.pow(2, d - 1) * Math.pow(2, t), v = 0)); t >= 8; ae[o + m] = h & 255, m += g, h /= 256, t -= 8)
          ;
        for (v = v << t | h, y += t; y > 0; ae[o + m] = v & 255, m += g, v /= 256, y -= 8)
          ;
        ae[o + m - g] |= n * 128;
      };
    }, {}], 84: [function(le, ce, re) {
      typeof Object.create == "function" ? ce.exports = function(Z, o) {
        Z.super_ = o, Z.prototype = Object.create(o.prototype, {
          constructor: {
            value: Z,
            enumerable: !1,
            writable: !0,
            configurable: !0
          }
        });
      } : ce.exports = function(Z, o) {
        Z.super_ = o;
        var C = function() {
        };
        C.prototype = o.prototype, Z.prototype = new C(), Z.prototype.constructor = Z;
      };
    }, {}], 85: [function(le, ce, re) {
      /*!
       * Determine if an object is a Buffer
       *
       * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
       * @license  MIT
       */
      ce.exports = function(o) {
        return o != null && (ae(o) || Z(o) || !!o._isBuffer);
      };
      function ae(o) {
        return !!o.constructor && typeof o.constructor.isBuffer == "function" && o.constructor.isBuffer(o);
      }
      function Z(o) {
        return typeof o.readFloatLE == "function" && typeof o.slice == "function" && ae(o.slice(0, 0));
      }
    }, {}], 86: [function(le, ce, re) {
      var ae = {}.toString;
      ce.exports = Array.isArray || function(Z) {
        return ae.call(Z) == "[object Array]";
      };
    }, {}], 87: [function(le, ce, re) {
      (function(ae, Z) {
        /*!
        
        	JSZip v3.7.1 - A JavaScript class for generating and reading zip files
        	<http://stuartk.com/jszip>
        
        	(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
        	Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.
        
        	JSZip uses the library pako released under the MIT license :
        	https://github.com/nodeca/pako/blob/master/LICENSE
        	*/
        (function(o) {
          typeof re == "object" && typeof ce < "u" ? ce.exports = o() : (typeof window < "u" ? window : typeof ae < "u" ? ae : typeof self < "u" ? self : this).JSZip = o();
        })(function() {
          return function o(C, t, a) {
            function v(y, c) {
              if (!t[y]) {
                if (!C[y]) {
                  var d = typeof le == "function" && le;
                  if (!c && d)
                    return d(y, !0);
                  if (h)
                    return h(y, !0);
                  var p = new Error("Cannot find module '" + y + "'");
                  throw p.code = "MODULE_NOT_FOUND", p;
                }
                var m = t[y] = { exports: {} };
                C[y][0].call(m.exports, function(g) {
                  var n = C[y][1][g];
                  return v(n || g);
                }, m, m.exports, o, C, t, a);
              }
              return t[y].exports;
            }
            for (var h = typeof le == "function" && le, e = 0; e < a.length; e++)
              v(a[e]);
            return v;
          }({ 1: [function(o, C, t) {
            var a = o("./utils"), v = o("./support"), h = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            t.encode = function(e) {
              for (var y, c, d, p, m, g, n, i = [], l = 0, u = e.length, w = u, _ = a.getTypeOf(e) !== "string"; l < e.length; )
                w = u - l, d = _ ? (y = e[l++], c = l < u ? e[l++] : 0, l < u ? e[l++] : 0) : (y = e.charCodeAt(l++), c = l < u ? e.charCodeAt(l++) : 0, l < u ? e.charCodeAt(l++) : 0), p = y >> 2, m = (3 & y) << 4 | c >> 4, g = 1 < w ? (15 & c) << 2 | d >> 6 : 64, n = 2 < w ? 63 & d : 64, i.push(h.charAt(p) + h.charAt(m) + h.charAt(g) + h.charAt(n));
              return i.join("");
            }, t.decode = function(e) {
              var y, c, d, p, m, g, n = 0, i = 0, l = "data:";
              if (e.substr(0, l.length) === l)
                throw new Error("Invalid base64 input, it looks like a data url.");
              var u, w = 3 * (e = e.replace(/[^A-Za-z0-9\+\/\=]/g, "")).length / 4;
              if (e.charAt(e.length - 1) === h.charAt(64) && w--, e.charAt(e.length - 2) === h.charAt(64) && w--, w % 1 != 0)
                throw new Error("Invalid base64 input, bad content length.");
              for (u = v.uint8array ? new Uint8Array(0 | w) : new Array(0 | w); n < e.length; )
                y = h.indexOf(e.charAt(n++)) << 2 | (p = h.indexOf(e.charAt(n++))) >> 4, c = (15 & p) << 4 | (m = h.indexOf(e.charAt(n++))) >> 2, d = (3 & m) << 6 | (g = h.indexOf(e.charAt(n++))), u[i++] = y, m !== 64 && (u[i++] = c), g !== 64 && (u[i++] = d);
              return u;
            };
          }, { "./support": 30, "./utils": 32 }], 2: [function(o, C, t) {
            var a = o("./external"), v = o("./stream/DataWorker"), h = o("./stream/Crc32Probe"), e = o("./stream/DataLengthProbe");
            function y(c, d, p, m, g) {
              this.compressedSize = c, this.uncompressedSize = d, this.crc32 = p, this.compression = m, this.compressedContent = g;
            }
            y.prototype = { getContentWorker: function() {
              var c = new v(a.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new e("data_length")), d = this;
              return c.on("end", function() {
                if (this.streamInfo.data_length !== d.uncompressedSize)
                  throw new Error("Bug : uncompressed data size mismatch");
              }), c;
            }, getCompressedWorker: function() {
              return new v(a.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
            } }, y.createWorkerFrom = function(c, d, p) {
              return c.pipe(new h()).pipe(new e("uncompressedSize")).pipe(d.compressWorker(p)).pipe(new e("compressedSize")).withStreamInfo("compression", d);
            }, C.exports = y;
          }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(o, C, t) {
            var a = o("./stream/GenericWorker");
            t.STORE = { magic: "\0\0", compressWorker: function(v) {
              return new a("STORE compression");
            }, uncompressWorker: function() {
              return new a("STORE decompression");
            } }, t.DEFLATE = o("./flate");
          }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(o, C, t) {
            var a = o("./utils"), v = function() {
              for (var h, e = [], y = 0; y < 256; y++) {
                h = y;
                for (var c = 0; c < 8; c++)
                  h = 1 & h ? 3988292384 ^ h >>> 1 : h >>> 1;
                e[y] = h;
              }
              return e;
            }();
            C.exports = function(h, e) {
              return h !== void 0 && h.length ? a.getTypeOf(h) !== "string" ? function(y, c, d, p) {
                var m = v, g = p + d;
                y ^= -1;
                for (var n = p; n < g; n++)
                  y = y >>> 8 ^ m[255 & (y ^ c[n])];
                return -1 ^ y;
              }(0 | e, h, h.length, 0) : function(y, c, d, p) {
                var m = v, g = p + d;
                y ^= -1;
                for (var n = p; n < g; n++)
                  y = y >>> 8 ^ m[255 & (y ^ c.charCodeAt(n))];
                return -1 ^ y;
              }(0 | e, h, h.length, 0) : 0;
            };
          }, { "./utils": 32 }], 5: [function(o, C, t) {
            t.base64 = !1, t.binary = !1, t.dir = !1, t.createFolders = !0, t.date = null, t.compression = null, t.compressionOptions = null, t.comment = null, t.unixPermissions = null, t.dosPermissions = null;
          }, {}], 6: [function(o, C, t) {
            var a = null;
            a = typeof Promise < "u" ? Promise : o("lie"), C.exports = { Promise: a };
          }, { lie: 37 }], 7: [function(o, C, t) {
            var a = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", v = o("pako"), h = o("./utils"), e = o("./stream/GenericWorker"), y = a ? "uint8array" : "array";
            function c(d, p) {
              e.call(this, "FlateWorker/" + d), this._pako = null, this._pakoAction = d, this._pakoOptions = p, this.meta = {};
            }
            t.magic = "\b\0", h.inherits(c, e), c.prototype.processChunk = function(d) {
              this.meta = d.meta, this._pako === null && this._createPako(), this._pako.push(h.transformTo(y, d.data), !1);
            }, c.prototype.flush = function() {
              e.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
            }, c.prototype.cleanUp = function() {
              e.prototype.cleanUp.call(this), this._pako = null;
            }, c.prototype._createPako = function() {
              this._pako = new v[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
              var d = this;
              this._pako.onData = function(p) {
                d.push({ data: p, meta: d.meta });
              };
            }, t.compressWorker = function(d) {
              return new c("Deflate", d);
            }, t.uncompressWorker = function() {
              return new c("Inflate", {});
            };
          }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(o, C, t) {
            function a(m, g) {
              var n, i = "";
              for (n = 0; n < g; n++)
                i += String.fromCharCode(255 & m), m >>>= 8;
              return i;
            }
            function v(m, g, n, i, l, u) {
              var w, _, b = m.file, A = m.compression, Y = u !== y.utf8encode, j = h.transformTo("string", u(b.name)), X = h.transformTo("string", y.utf8encode(b.name)), B = b.comment, R = h.transformTo("string", u(B)), k = h.transformTo("string", y.utf8encode(B)), x = X.length !== b.name.length, f = k.length !== B.length, U = "", O = "", S = "", F = b.dir, T = b.date, I = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
              g && !n || (I.crc32 = m.crc32, I.compressedSize = m.compressedSize, I.uncompressedSize = m.uncompressedSize);
              var M = 0;
              g && (M |= 8), Y || !x && !f || (M |= 2048);
              var V = 0, J = 0;
              F && (V |= 16), l === "UNIX" ? (J = 798, V |= function(z, G) {
                var L = z;
                return z || (L = G ? 16893 : 33204), (65535 & L) << 16;
              }(b.unixPermissions, F)) : (J = 20, V |= function(z) {
                return 63 & (z || 0);
              }(b.dosPermissions)), w = T.getUTCHours(), w <<= 6, w |= T.getUTCMinutes(), w <<= 5, w |= T.getUTCSeconds() / 2, _ = T.getUTCFullYear() - 1980, _ <<= 4, _ |= T.getUTCMonth() + 1, _ <<= 5, _ |= T.getUTCDate(), x && (O = a(1, 1) + a(c(j), 4) + X, U += "up" + a(O.length, 2) + O), f && (S = a(1, 1) + a(c(R), 4) + k, U += "uc" + a(S.length, 2) + S);
              var W = "";
              return W += `
\0`, W += a(M, 2), W += A.magic, W += a(w, 2), W += a(_, 2), W += a(I.crc32, 4), W += a(I.compressedSize, 4), W += a(I.uncompressedSize, 4), W += a(j.length, 2), W += a(U.length, 2), { fileRecord: d.LOCAL_FILE_HEADER + W + j + U, dirRecord: d.CENTRAL_FILE_HEADER + a(J, 2) + W + a(R.length, 2) + "\0\0\0\0" + a(V, 4) + a(i, 4) + j + U + R };
            }
            var h = o("../utils"), e = o("../stream/GenericWorker"), y = o("../utf8"), c = o("../crc32"), d = o("../signature");
            function p(m, g, n, i) {
              e.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = g, this.zipPlatform = n, this.encodeFileName = i, this.streamFiles = m, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
            }
            h.inherits(p, e), p.prototype.push = function(m) {
              var g = m.meta.percent || 0, n = this.entriesCount, i = this._sources.length;
              this.accumulate ? this.contentBuffer.push(m) : (this.bytesWritten += m.data.length, e.prototype.push.call(this, { data: m.data, meta: { currentFile: this.currentFile, percent: n ? (g + 100 * (n - i - 1)) / n : 100 } }));
            }, p.prototype.openedSource = function(m) {
              this.currentSourceOffset = this.bytesWritten, this.currentFile = m.file.name;
              var g = this.streamFiles && !m.file.dir;
              if (g) {
                var n = v(m, g, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
                this.push({ data: n.fileRecord, meta: { percent: 0 } });
              } else
                this.accumulate = !0;
            }, p.prototype.closedSource = function(m) {
              this.accumulate = !1;
              var g = this.streamFiles && !m.file.dir, n = v(m, g, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
              if (this.dirRecords.push(n.dirRecord), g)
                this.push({ data: function(i) {
                  return d.DATA_DESCRIPTOR + a(i.crc32, 4) + a(i.compressedSize, 4) + a(i.uncompressedSize, 4);
                }(m), meta: { percent: 100 } });
              else
                for (this.push({ data: n.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
                  this.push(this.contentBuffer.shift());
              this.currentFile = null;
            }, p.prototype.flush = function() {
              for (var m = this.bytesWritten, g = 0; g < this.dirRecords.length; g++)
                this.push({ data: this.dirRecords[g], meta: { percent: 100 } });
              var n = this.bytesWritten - m, i = function(l, u, w, _, b) {
                var A = h.transformTo("string", b(_));
                return d.CENTRAL_DIRECTORY_END + "\0\0\0\0" + a(l, 2) + a(l, 2) + a(u, 4) + a(w, 4) + a(A.length, 2) + A;
              }(this.dirRecords.length, n, m, this.zipComment, this.encodeFileName);
              this.push({ data: i, meta: { percent: 100 } });
            }, p.prototype.prepareNextSource = function() {
              this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
            }, p.prototype.registerPrevious = function(m) {
              this._sources.push(m);
              var g = this;
              return m.on("data", function(n) {
                g.processChunk(n);
              }), m.on("end", function() {
                g.closedSource(g.previous.streamInfo), g._sources.length ? g.prepareNextSource() : g.end();
              }), m.on("error", function(n) {
                g.error(n);
              }), this;
            }, p.prototype.resume = function() {
              return !!e.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
            }, p.prototype.error = function(m) {
              var g = this._sources;
              if (!e.prototype.error.call(this, m))
                return !1;
              for (var n = 0; n < g.length; n++)
                try {
                  g[n].error(m);
                } catch {
                }
              return !0;
            }, p.prototype.lock = function() {
              e.prototype.lock.call(this);
              for (var m = this._sources, g = 0; g < m.length; g++)
                m[g].lock();
            }, C.exports = p;
          }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(o, C, t) {
            var a = o("../compressions"), v = o("./ZipFileWorker");
            t.generateWorker = function(h, e, y) {
              var c = new v(e.streamFiles, y, e.platform, e.encodeFileName), d = 0;
              try {
                h.forEach(function(p, m) {
                  d++;
                  var g = function(u, w) {
                    var _ = u || w, b = a[_];
                    if (!b)
                      throw new Error(_ + " is not a valid compression method !");
                    return b;
                  }(m.options.compression, e.compression), n = m.options.compressionOptions || e.compressionOptions || {}, i = m.dir, l = m.date;
                  m._compressWorker(g, n).withStreamInfo("file", { name: p, dir: i, date: l, comment: m.comment || "", unixPermissions: m.unixPermissions, dosPermissions: m.dosPermissions }).pipe(c);
                }), c.entriesCount = d;
              } catch (p) {
                c.error(p);
              }
              return c;
            };
          }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(o, C, t) {
            function a() {
              if (!(this instanceof a))
                return new a();
              if (arguments.length)
                throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
              this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
                var v = new a();
                for (var h in this)
                  typeof this[h] != "function" && (v[h] = this[h]);
                return v;
              };
            }
            (a.prototype = o("./object")).loadAsync = o("./load"), a.support = o("./support"), a.defaults = o("./defaults"), a.version = "3.7.1", a.loadAsync = function(v, h) {
              return new a().loadAsync(v, h);
            }, a.external = o("./external"), C.exports = a;
          }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(o, C, t) {
            var a = o("./utils"), v = o("./external"), h = o("./utf8"), e = o("./zipEntries"), y = o("./stream/Crc32Probe"), c = o("./nodejsUtils");
            function d(p) {
              return new v.Promise(function(m, g) {
                var n = p.decompressed.getContentWorker().pipe(new y());
                n.on("error", function(i) {
                  g(i);
                }).on("end", function() {
                  n.streamInfo.crc32 !== p.decompressed.crc32 ? g(new Error("Corrupted zip : CRC32 mismatch")) : m();
                }).resume();
              });
            }
            C.exports = function(p, m) {
              var g = this;
              return m = a.extend(m || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: h.utf8decode }), c.isNode && c.isStream(p) ? v.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : a.prepareContent("the loaded zip file", p, !0, m.optimizedBinaryString, m.base64).then(function(n) {
                var i = new e(m);
                return i.load(n), i;
              }).then(function(n) {
                var i = [v.Promise.resolve(n)], l = n.files;
                if (m.checkCRC32)
                  for (var u = 0; u < l.length; u++)
                    i.push(d(l[u]));
                return v.Promise.all(i);
              }).then(function(n) {
                for (var i = n.shift(), l = i.files, u = 0; u < l.length; u++) {
                  var w = l[u];
                  g.file(w.fileNameStr, w.decompressed, { binary: !0, optimizedBinaryString: !0, date: w.date, dir: w.dir, comment: w.fileCommentStr.length ? w.fileCommentStr : null, unixPermissions: w.unixPermissions, dosPermissions: w.dosPermissions, createFolders: m.createFolders });
                }
                return i.zipComment.length && (g.comment = i.zipComment), g;
              });
            };
          }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(o, C, t) {
            var a = o("../utils"), v = o("../stream/GenericWorker");
            function h(e, y) {
              v.call(this, "Nodejs stream input adapter for " + e), this._upstreamEnded = !1, this._bindStream(y);
            }
            a.inherits(h, v), h.prototype._bindStream = function(e) {
              var y = this;
              (this._stream = e).pause(), e.on("data", function(c) {
                y.push({ data: c, meta: { percent: 0 } });
              }).on("error", function(c) {
                y.isPaused ? this.generatedError = c : y.error(c);
              }).on("end", function() {
                y.isPaused ? y._upstreamEnded = !0 : y.end();
              });
            }, h.prototype.pause = function() {
              return !!v.prototype.pause.call(this) && (this._stream.pause(), !0);
            }, h.prototype.resume = function() {
              return !!v.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
            }, C.exports = h;
          }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(o, C, t) {
            var a = o("readable-stream").Readable;
            function v(h, e, y) {
              a.call(this, e), this._helper = h;
              var c = this;
              h.on("data", function(d, p) {
                c.push(d) || c._helper.pause(), y && y(p);
              }).on("error", function(d) {
                c.emit("error", d);
              }).on("end", function() {
                c.push(null);
              });
            }
            o("../utils").inherits(v, a), v.prototype._read = function() {
              this._helper.resume();
            }, C.exports = v;
          }, { "../utils": 32, "readable-stream": 16 }], 14: [function(o, C, t) {
            C.exports = { isNode: typeof Z < "u", newBufferFrom: function(a, v) {
              if (Z.from && Z.from !== Uint8Array.from)
                return Z.from(a, v);
              if (typeof a == "number")
                throw new Error('The "data" argument must not be a number');
              return new Z(a, v);
            }, allocBuffer: function(a) {
              if (Z.alloc)
                return Z.alloc(a);
              var v = new Z(a);
              return v.fill(0), v;
            }, isBuffer: function(a) {
              return Z.isBuffer(a);
            }, isStream: function(a) {
              return a && typeof a.on == "function" && typeof a.pause == "function" && typeof a.resume == "function";
            } };
          }, {}], 15: [function(o, C, t) {
            function a(b, A, Y) {
              var j, X = h.getTypeOf(A), B = h.extend(Y || {}, c);
              B.date = B.date || new Date(), B.compression !== null && (B.compression = B.compression.toUpperCase()), typeof B.unixPermissions == "string" && (B.unixPermissions = parseInt(B.unixPermissions, 8)), B.unixPermissions && 16384 & B.unixPermissions && (B.dir = !0), B.dosPermissions && 16 & B.dosPermissions && (B.dir = !0), B.dir && (b = l(b)), B.createFolders && (j = i(b)) && u.call(this, j, !0);
              var R = X === "string" && B.binary === !1 && B.base64 === !1;
              Y && Y.binary !== void 0 || (B.binary = !R), (A instanceof d && A.uncompressedSize === 0 || B.dir || !A || A.length === 0) && (B.base64 = !1, B.binary = !0, A = "", B.compression = "STORE", X = "string");
              var k = null;
              k = A instanceof d || A instanceof e ? A : g.isNode && g.isStream(A) ? new n(b, A) : h.prepareContent(b, A, B.binary, B.optimizedBinaryString, B.base64);
              var x = new p(b, k, B);
              this.files[b] = x;
            }
            var v = o("./utf8"), h = o("./utils"), e = o("./stream/GenericWorker"), y = o("./stream/StreamHelper"), c = o("./defaults"), d = o("./compressedObject"), p = o("./zipObject"), m = o("./generate"), g = o("./nodejsUtils"), n = o("./nodejs/NodejsStreamInputAdapter"), i = function(b) {
              b.slice(-1) === "/" && (b = b.substring(0, b.length - 1));
              var A = b.lastIndexOf("/");
              return 0 < A ? b.substring(0, A) : "";
            }, l = function(b) {
              return b.slice(-1) !== "/" && (b += "/"), b;
            }, u = function(b, A) {
              return A = A !== void 0 ? A : c.createFolders, b = l(b), this.files[b] || a.call(this, b, null, { dir: !0, createFolders: A }), this.files[b];
            };
            function w(b) {
              return Object.prototype.toString.call(b) === "[object RegExp]";
            }
            var _ = { load: function() {
              throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
            }, forEach: function(b) {
              var A, Y, j;
              for (A in this.files)
                j = this.files[A], (Y = A.slice(this.root.length, A.length)) && A.slice(0, this.root.length) === this.root && b(Y, j);
            }, filter: function(b) {
              var A = [];
              return this.forEach(function(Y, j) {
                b(Y, j) && A.push(j);
              }), A;
            }, file: function(b, A, Y) {
              if (arguments.length !== 1)
                return b = this.root + b, a.call(this, b, A, Y), this;
              if (w(b)) {
                var j = b;
                return this.filter(function(B, R) {
                  return !R.dir && j.test(B);
                });
              }
              var X = this.files[this.root + b];
              return X && !X.dir ? X : null;
            }, folder: function(b) {
              if (!b)
                return this;
              if (w(b))
                return this.filter(function(X, B) {
                  return B.dir && b.test(X);
                });
              var A = this.root + b, Y = u.call(this, A), j = this.clone();
              return j.root = Y.name, j;
            }, remove: function(b) {
              b = this.root + b;
              var A = this.files[b];
              if (A || (b.slice(-1) !== "/" && (b += "/"), A = this.files[b]), A && !A.dir)
                delete this.files[b];
              else
                for (var Y = this.filter(function(X, B) {
                  return B.name.slice(0, b.length) === b;
                }), j = 0; j < Y.length; j++)
                  delete this.files[Y[j].name];
              return this;
            }, generate: function(b) {
              throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
            }, generateInternalStream: function(b) {
              var A, Y = {};
              try {
                if ((Y = h.extend(b || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: v.utf8encode })).type = Y.type.toLowerCase(), Y.compression = Y.compression.toUpperCase(), Y.type === "binarystring" && (Y.type = "string"), !Y.type)
                  throw new Error("No output type specified.");
                h.checkSupport(Y.type), Y.platform !== "darwin" && Y.platform !== "freebsd" && Y.platform !== "linux" && Y.platform !== "sunos" || (Y.platform = "UNIX"), Y.platform === "win32" && (Y.platform = "DOS");
                var j = Y.comment || this.comment || "";
                A = m.generateWorker(this, Y, j);
              } catch (X) {
                (A = new e("error")).error(X);
              }
              return new y(A, Y.type || "string", Y.mimeType);
            }, generateAsync: function(b, A) {
              return this.generateInternalStream(b).accumulate(A);
            }, generateNodeStream: function(b, A) {
              return (b = b || {}).type || (b.type = "nodebuffer"), this.generateInternalStream(b).toNodejsStream(A);
            } };
            C.exports = _;
          }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(o, C, t) {
            C.exports = o("stream");
          }, { stream: void 0 }], 17: [function(o, C, t) {
            var a = o("./DataReader");
            function v(h) {
              a.call(this, h);
              for (var e = 0; e < this.data.length; e++)
                h[e] = 255 & h[e];
            }
            o("../utils").inherits(v, a), v.prototype.byteAt = function(h) {
              return this.data[this.zero + h];
            }, v.prototype.lastIndexOfSignature = function(h) {
              for (var e = h.charCodeAt(0), y = h.charCodeAt(1), c = h.charCodeAt(2), d = h.charCodeAt(3), p = this.length - 4; 0 <= p; --p)
                if (this.data[p] === e && this.data[p + 1] === y && this.data[p + 2] === c && this.data[p + 3] === d)
                  return p - this.zero;
              return -1;
            }, v.prototype.readAndCheckSignature = function(h) {
              var e = h.charCodeAt(0), y = h.charCodeAt(1), c = h.charCodeAt(2), d = h.charCodeAt(3), p = this.readData(4);
              return e === p[0] && y === p[1] && c === p[2] && d === p[3];
            }, v.prototype.readData = function(h) {
              if (this.checkOffset(h), h === 0)
                return [];
              var e = this.data.slice(this.zero + this.index, this.zero + this.index + h);
              return this.index += h, e;
            }, C.exports = v;
          }, { "../utils": 32, "./DataReader": 18 }], 18: [function(o, C, t) {
            var a = o("../utils");
            function v(h) {
              this.data = h, this.length = h.length, this.index = 0, this.zero = 0;
            }
            v.prototype = { checkOffset: function(h) {
              this.checkIndex(this.index + h);
            }, checkIndex: function(h) {
              if (this.length < this.zero + h || h < 0)
                throw new Error("End of data reached (data length = " + this.length + ", asked index = " + h + "). Corrupted zip ?");
            }, setIndex: function(h) {
              this.checkIndex(h), this.index = h;
            }, skip: function(h) {
              this.setIndex(this.index + h);
            }, byteAt: function(h) {
            }, readInt: function(h) {
              var e, y = 0;
              for (this.checkOffset(h), e = this.index + h - 1; e >= this.index; e--)
                y = (y << 8) + this.byteAt(e);
              return this.index += h, y;
            }, readString: function(h) {
              return a.transformTo("string", this.readData(h));
            }, readData: function(h) {
            }, lastIndexOfSignature: function(h) {
            }, readAndCheckSignature: function(h) {
            }, readDate: function() {
              var h = this.readInt(4);
              return new Date(Date.UTC(1980 + (h >> 25 & 127), (h >> 21 & 15) - 1, h >> 16 & 31, h >> 11 & 31, h >> 5 & 63, (31 & h) << 1));
            } }, C.exports = v;
          }, { "../utils": 32 }], 19: [function(o, C, t) {
            var a = o("./Uint8ArrayReader");
            function v(h) {
              a.call(this, h);
            }
            o("../utils").inherits(v, a), v.prototype.readData = function(h) {
              this.checkOffset(h);
              var e = this.data.slice(this.zero + this.index, this.zero + this.index + h);
              return this.index += h, e;
            }, C.exports = v;
          }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(o, C, t) {
            var a = o("./DataReader");
            function v(h) {
              a.call(this, h);
            }
            o("../utils").inherits(v, a), v.prototype.byteAt = function(h) {
              return this.data.charCodeAt(this.zero + h);
            }, v.prototype.lastIndexOfSignature = function(h) {
              return this.data.lastIndexOf(h) - this.zero;
            }, v.prototype.readAndCheckSignature = function(h) {
              return h === this.readData(4);
            }, v.prototype.readData = function(h) {
              this.checkOffset(h);
              var e = this.data.slice(this.zero + this.index, this.zero + this.index + h);
              return this.index += h, e;
            }, C.exports = v;
          }, { "../utils": 32, "./DataReader": 18 }], 21: [function(o, C, t) {
            var a = o("./ArrayReader");
            function v(h) {
              a.call(this, h);
            }
            o("../utils").inherits(v, a), v.prototype.readData = function(h) {
              if (this.checkOffset(h), h === 0)
                return new Uint8Array(0);
              var e = this.data.subarray(this.zero + this.index, this.zero + this.index + h);
              return this.index += h, e;
            }, C.exports = v;
          }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(o, C, t) {
            var a = o("../utils"), v = o("../support"), h = o("./ArrayReader"), e = o("./StringReader"), y = o("./NodeBufferReader"), c = o("./Uint8ArrayReader");
            C.exports = function(d) {
              var p = a.getTypeOf(d);
              return a.checkSupport(p), p !== "string" || v.uint8array ? p === "nodebuffer" ? new y(d) : v.uint8array ? new c(a.transformTo("uint8array", d)) : new h(a.transformTo("array", d)) : new e(d);
            };
          }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(o, C, t) {
            t.LOCAL_FILE_HEADER = "PK", t.CENTRAL_FILE_HEADER = "PK", t.CENTRAL_DIRECTORY_END = "PK", t.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", t.ZIP64_CENTRAL_DIRECTORY_END = "PK", t.DATA_DESCRIPTOR = "PK\x07\b";
          }, {}], 24: [function(o, C, t) {
            var a = o("./GenericWorker"), v = o("../utils");
            function h(e) {
              a.call(this, "ConvertWorker to " + e), this.destType = e;
            }
            v.inherits(h, a), h.prototype.processChunk = function(e) {
              this.push({ data: v.transformTo(this.destType, e.data), meta: e.meta });
            }, C.exports = h;
          }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(o, C, t) {
            var a = o("./GenericWorker"), v = o("../crc32");
            function h() {
              a.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
            }
            o("../utils").inherits(h, a), h.prototype.processChunk = function(e) {
              this.streamInfo.crc32 = v(e.data, this.streamInfo.crc32 || 0), this.push(e);
            }, C.exports = h;
          }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(o, C, t) {
            var a = o("../utils"), v = o("./GenericWorker");
            function h(e) {
              v.call(this, "DataLengthProbe for " + e), this.propName = e, this.withStreamInfo(e, 0);
            }
            a.inherits(h, v), h.prototype.processChunk = function(e) {
              if (e) {
                var y = this.streamInfo[this.propName] || 0;
                this.streamInfo[this.propName] = y + e.data.length;
              }
              v.prototype.processChunk.call(this, e);
            }, C.exports = h;
          }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(o, C, t) {
            var a = o("../utils"), v = o("./GenericWorker");
            function h(e) {
              v.call(this, "DataWorker");
              var y = this;
              this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, e.then(function(c) {
                y.dataIsReady = !0, y.data = c, y.max = c && c.length || 0, y.type = a.getTypeOf(c), y.isPaused || y._tickAndRepeat();
              }, function(c) {
                y.error(c);
              });
            }
            a.inherits(h, v), h.prototype.cleanUp = function() {
              v.prototype.cleanUp.call(this), this.data = null;
            }, h.prototype.resume = function() {
              return !!v.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, a.delay(this._tickAndRepeat, [], this)), !0);
            }, h.prototype._tickAndRepeat = function() {
              this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (a.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
            }, h.prototype._tick = function() {
              if (this.isPaused || this.isFinished)
                return !1;
              var e = null, y = Math.min(this.max, this.index + 16384);
              if (this.index >= this.max)
                return this.end();
              switch (this.type) {
                case "string":
                  e = this.data.substring(this.index, y);
                  break;
                case "uint8array":
                  e = this.data.subarray(this.index, y);
                  break;
                case "array":
                case "nodebuffer":
                  e = this.data.slice(this.index, y);
              }
              return this.index = y, this.push({ data: e, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
            }, C.exports = h;
          }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(o, C, t) {
            function a(v) {
              this.name = v || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
            }
            a.prototype = { push: function(v) {
              this.emit("data", v);
            }, end: function() {
              if (this.isFinished)
                return !1;
              this.flush();
              try {
                this.emit("end"), this.cleanUp(), this.isFinished = !0;
              } catch (v) {
                this.emit("error", v);
              }
              return !0;
            }, error: function(v) {
              return !this.isFinished && (this.isPaused ? this.generatedError = v : (this.isFinished = !0, this.emit("error", v), this.previous && this.previous.error(v), this.cleanUp()), !0);
            }, on: function(v, h) {
              return this._listeners[v].push(h), this;
            }, cleanUp: function() {
              this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
            }, emit: function(v, h) {
              if (this._listeners[v])
                for (var e = 0; e < this._listeners[v].length; e++)
                  this._listeners[v][e].call(this, h);
            }, pipe: function(v) {
              return v.registerPrevious(this);
            }, registerPrevious: function(v) {
              if (this.isLocked)
                throw new Error("The stream '" + this + "' has already been used.");
              this.streamInfo = v.streamInfo, this.mergeStreamInfo(), this.previous = v;
              var h = this;
              return v.on("data", function(e) {
                h.processChunk(e);
              }), v.on("end", function() {
                h.end();
              }), v.on("error", function(e) {
                h.error(e);
              }), this;
            }, pause: function() {
              return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
            }, resume: function() {
              if (!this.isPaused || this.isFinished)
                return !1;
              var v = this.isPaused = !1;
              return this.generatedError && (this.error(this.generatedError), v = !0), this.previous && this.previous.resume(), !v;
            }, flush: function() {
            }, processChunk: function(v) {
              this.push(v);
            }, withStreamInfo: function(v, h) {
              return this.extraStreamInfo[v] = h, this.mergeStreamInfo(), this;
            }, mergeStreamInfo: function() {
              for (var v in this.extraStreamInfo)
                this.extraStreamInfo.hasOwnProperty(v) && (this.streamInfo[v] = this.extraStreamInfo[v]);
            }, lock: function() {
              if (this.isLocked)
                throw new Error("The stream '" + this + "' has already been used.");
              this.isLocked = !0, this.previous && this.previous.lock();
            }, toString: function() {
              var v = "Worker " + this.name;
              return this.previous ? this.previous + " -> " + v : v;
            } }, C.exports = a;
          }, {}], 29: [function(o, C, t) {
            var a = o("../utils"), v = o("./ConvertWorker"), h = o("./GenericWorker"), e = o("../base64"), y = o("../support"), c = o("../external"), d = null;
            if (y.nodestream)
              try {
                d = o("../nodejs/NodejsStreamOutputAdapter");
              } catch {
              }
            function p(g, n) {
              return new c.Promise(function(i, l) {
                var u = [], w = g._internalType, _ = g._outputType, b = g._mimeType;
                g.on("data", function(A, Y) {
                  u.push(A), n && n(Y);
                }).on("error", function(A) {
                  u = [], l(A);
                }).on("end", function() {
                  try {
                    var A = function(Y, j, X) {
                      switch (Y) {
                        case "blob":
                          return a.newBlob(a.transformTo("arraybuffer", j), X);
                        case "base64":
                          return e.encode(j);
                        default:
                          return a.transformTo(Y, j);
                      }
                    }(_, function(Y, j) {
                      var X, B = 0, R = null, k = 0;
                      for (X = 0; X < j.length; X++)
                        k += j[X].length;
                      switch (Y) {
                        case "string":
                          return j.join("");
                        case "array":
                          return Array.prototype.concat.apply([], j);
                        case "uint8array":
                          for (R = new Uint8Array(k), X = 0; X < j.length; X++)
                            R.set(j[X], B), B += j[X].length;
                          return R;
                        case "nodebuffer":
                          return Z.concat(j);
                        default:
                          throw new Error("concat : unsupported type '" + Y + "'");
                      }
                    }(w, u), b);
                    i(A);
                  } catch (Y) {
                    l(Y);
                  }
                  u = [];
                }).resume();
              });
            }
            function m(g, n, i) {
              var l = n;
              switch (n) {
                case "blob":
                case "arraybuffer":
                  l = "uint8array";
                  break;
                case "base64":
                  l = "string";
              }
              try {
                this._internalType = l, this._outputType = n, this._mimeType = i, a.checkSupport(l), this._worker = g.pipe(new v(l)), g.lock();
              } catch (u) {
                this._worker = new h("error"), this._worker.error(u);
              }
            }
            m.prototype = { accumulate: function(g) {
              return p(this, g);
            }, on: function(g, n) {
              var i = this;
              return g === "data" ? this._worker.on(g, function(l) {
                n.call(i, l.data, l.meta);
              }) : this._worker.on(g, function() {
                a.delay(n, arguments, i);
              }), this;
            }, resume: function() {
              return a.delay(this._worker.resume, [], this._worker), this;
            }, pause: function() {
              return this._worker.pause(), this;
            }, toNodejsStream: function(g) {
              if (a.checkSupport("nodestream"), this._outputType !== "nodebuffer")
                throw new Error(this._outputType + " is not supported by this method");
              return new d(this, { objectMode: this._outputType !== "nodebuffer" }, g);
            } }, C.exports = m;
          }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(o, C, t) {
            if (t.base64 = !0, t.array = !0, t.string = !0, t.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", t.nodebuffer = typeof Z < "u", t.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u")
              t.blob = !1;
            else {
              var a = new ArrayBuffer(0);
              try {
                t.blob = new Blob([a], { type: "application/zip" }).size === 0;
              } catch {
                try {
                  var v = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
                  v.append(a), t.blob = v.getBlob("application/zip").size === 0;
                } catch {
                  t.blob = !1;
                }
              }
            }
            try {
              t.nodestream = !!o("readable-stream").Readable;
            } catch {
              t.nodestream = !1;
            }
          }, { "readable-stream": 16 }], 31: [function(o, C, t) {
            for (var a = o("./utils"), v = o("./support"), h = o("./nodejsUtils"), e = o("./stream/GenericWorker"), y = new Array(256), c = 0; c < 256; c++)
              y[c] = 252 <= c ? 6 : 248 <= c ? 5 : 240 <= c ? 4 : 224 <= c ? 3 : 192 <= c ? 2 : 1;
            y[254] = y[254] = 1;
            function d() {
              e.call(this, "utf-8 decode"), this.leftOver = null;
            }
            function p() {
              e.call(this, "utf-8 encode");
            }
            t.utf8encode = function(m) {
              return v.nodebuffer ? h.newBufferFrom(m, "utf-8") : function(g) {
                var n, i, l, u, w, _ = g.length, b = 0;
                for (u = 0; u < _; u++)
                  (64512 & (i = g.charCodeAt(u))) == 55296 && u + 1 < _ && (64512 & (l = g.charCodeAt(u + 1))) == 56320 && (i = 65536 + (i - 55296 << 10) + (l - 56320), u++), b += i < 128 ? 1 : i < 2048 ? 2 : i < 65536 ? 3 : 4;
                for (n = v.uint8array ? new Uint8Array(b) : new Array(b), u = w = 0; w < b; u++)
                  (64512 & (i = g.charCodeAt(u))) == 55296 && u + 1 < _ && (64512 & (l = g.charCodeAt(u + 1))) == 56320 && (i = 65536 + (i - 55296 << 10) + (l - 56320), u++), i < 128 ? n[w++] = i : (i < 2048 ? n[w++] = 192 | i >>> 6 : (i < 65536 ? n[w++] = 224 | i >>> 12 : (n[w++] = 240 | i >>> 18, n[w++] = 128 | i >>> 12 & 63), n[w++] = 128 | i >>> 6 & 63), n[w++] = 128 | 63 & i);
                return n;
              }(m);
            }, t.utf8decode = function(m) {
              return v.nodebuffer ? a.transformTo("nodebuffer", m).toString("utf-8") : function(g) {
                var n, i, l, u, w = g.length, _ = new Array(2 * w);
                for (n = i = 0; n < w; )
                  if ((l = g[n++]) < 128)
                    _[i++] = l;
                  else if (4 < (u = y[l]))
                    _[i++] = 65533, n += u - 1;
                  else {
                    for (l &= u === 2 ? 31 : u === 3 ? 15 : 7; 1 < u && n < w; )
                      l = l << 6 | 63 & g[n++], u--;
                    1 < u ? _[i++] = 65533 : l < 65536 ? _[i++] = l : (l -= 65536, _[i++] = 55296 | l >> 10 & 1023, _[i++] = 56320 | 1023 & l);
                  }
                return _.length !== i && (_.subarray ? _ = _.subarray(0, i) : _.length = i), a.applyFromCharCode(_);
              }(m = a.transformTo(v.uint8array ? "uint8array" : "array", m));
            }, a.inherits(d, e), d.prototype.processChunk = function(m) {
              var g = a.transformTo(v.uint8array ? "uint8array" : "array", m.data);
              if (this.leftOver && this.leftOver.length) {
                if (v.uint8array) {
                  var n = g;
                  (g = new Uint8Array(n.length + this.leftOver.length)).set(this.leftOver, 0), g.set(n, this.leftOver.length);
                } else
                  g = this.leftOver.concat(g);
                this.leftOver = null;
              }
              var i = function(u, w) {
                var _;
                for ((w = w || u.length) > u.length && (w = u.length), _ = w - 1; 0 <= _ && (192 & u[_]) == 128; )
                  _--;
                return _ < 0 || _ === 0 ? w : _ + y[u[_]] > w ? _ : w;
              }(g), l = g;
              i !== g.length && (v.uint8array ? (l = g.subarray(0, i), this.leftOver = g.subarray(i, g.length)) : (l = g.slice(0, i), this.leftOver = g.slice(i, g.length))), this.push({ data: t.utf8decode(l), meta: m.meta });
            }, d.prototype.flush = function() {
              this.leftOver && this.leftOver.length && (this.push({ data: t.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
            }, t.Utf8DecodeWorker = d, a.inherits(p, e), p.prototype.processChunk = function(m) {
              this.push({ data: t.utf8encode(m.data), meta: m.meta });
            }, t.Utf8EncodeWorker = p;
          }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(o, C, t) {
            var a = o("./support"), v = o("./base64"), h = o("./nodejsUtils"), e = o("set-immediate-shim"), y = o("./external");
            function c(i) {
              return i;
            }
            function d(i, l) {
              for (var u = 0; u < i.length; ++u)
                l[u] = 255 & i.charCodeAt(u);
              return l;
            }
            t.newBlob = function(i, l) {
              t.checkSupport("blob");
              try {
                return new Blob([i], { type: l });
              } catch {
                try {
                  var u = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
                  return u.append(i), u.getBlob(l);
                } catch {
                  throw new Error("Bug : can't construct the Blob.");
                }
              }
            };
            var p = { stringifyByChunk: function(i, l, u) {
              var w = [], _ = 0, b = i.length;
              if (b <= u)
                return String.fromCharCode.apply(null, i);
              for (; _ < b; )
                l === "array" || l === "nodebuffer" ? w.push(String.fromCharCode.apply(null, i.slice(_, Math.min(_ + u, b)))) : w.push(String.fromCharCode.apply(null, i.subarray(_, Math.min(_ + u, b)))), _ += u;
              return w.join("");
            }, stringifyByChar: function(i) {
              for (var l = "", u = 0; u < i.length; u++)
                l += String.fromCharCode(i[u]);
              return l;
            }, applyCanBeUsed: { uint8array: function() {
              try {
                return a.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
              } catch {
                return !1;
              }
            }(), nodebuffer: function() {
              try {
                return a.nodebuffer && String.fromCharCode.apply(null, h.allocBuffer(1)).length === 1;
              } catch {
                return !1;
              }
            }() } };
            function m(i) {
              var l = 65536, u = t.getTypeOf(i), w = !0;
              if (u === "uint8array" ? w = p.applyCanBeUsed.uint8array : u === "nodebuffer" && (w = p.applyCanBeUsed.nodebuffer), w)
                for (; 1 < l; )
                  try {
                    return p.stringifyByChunk(i, u, l);
                  } catch {
                    l = Math.floor(l / 2);
                  }
              return p.stringifyByChar(i);
            }
            function g(i, l) {
              for (var u = 0; u < i.length; u++)
                l[u] = i[u];
              return l;
            }
            t.applyFromCharCode = m;
            var n = {};
            n.string = { string: c, array: function(i) {
              return d(i, new Array(i.length));
            }, arraybuffer: function(i) {
              return n.string.uint8array(i).buffer;
            }, uint8array: function(i) {
              return d(i, new Uint8Array(i.length));
            }, nodebuffer: function(i) {
              return d(i, h.allocBuffer(i.length));
            } }, n.array = { string: m, array: c, arraybuffer: function(i) {
              return new Uint8Array(i).buffer;
            }, uint8array: function(i) {
              return new Uint8Array(i);
            }, nodebuffer: function(i) {
              return h.newBufferFrom(i);
            } }, n.arraybuffer = { string: function(i) {
              return m(new Uint8Array(i));
            }, array: function(i) {
              return g(new Uint8Array(i), new Array(i.byteLength));
            }, arraybuffer: c, uint8array: function(i) {
              return new Uint8Array(i);
            }, nodebuffer: function(i) {
              return h.newBufferFrom(new Uint8Array(i));
            } }, n.uint8array = { string: m, array: function(i) {
              return g(i, new Array(i.length));
            }, arraybuffer: function(i) {
              return i.buffer;
            }, uint8array: c, nodebuffer: function(i) {
              return h.newBufferFrom(i);
            } }, n.nodebuffer = { string: m, array: function(i) {
              return g(i, new Array(i.length));
            }, arraybuffer: function(i) {
              return n.nodebuffer.uint8array(i).buffer;
            }, uint8array: function(i) {
              return g(i, new Uint8Array(i.length));
            }, nodebuffer: c }, t.transformTo = function(i, l) {
              if (l = l || "", !i)
                return l;
              t.checkSupport(i);
              var u = t.getTypeOf(l);
              return n[u][i](l);
            }, t.getTypeOf = function(i) {
              return typeof i == "string" ? "string" : Object.prototype.toString.call(i) === "[object Array]" ? "array" : a.nodebuffer && h.isBuffer(i) ? "nodebuffer" : a.uint8array && i instanceof Uint8Array ? "uint8array" : a.arraybuffer && i instanceof ArrayBuffer ? "arraybuffer" : void 0;
            }, t.checkSupport = function(i) {
              if (!a[i.toLowerCase()])
                throw new Error(i + " is not supported by this platform");
            }, t.MAX_VALUE_16BITS = 65535, t.MAX_VALUE_32BITS = -1, t.pretty = function(i) {
              var l, u, w = "";
              for (u = 0; u < (i || "").length; u++)
                w += "\\x" + ((l = i.charCodeAt(u)) < 16 ? "0" : "") + l.toString(16).toUpperCase();
              return w;
            }, t.delay = function(i, l, u) {
              e(function() {
                i.apply(u || null, l || []);
              });
            }, t.inherits = function(i, l) {
              function u() {
              }
              u.prototype = l.prototype, i.prototype = new u();
            }, t.extend = function() {
              var i, l, u = {};
              for (i = 0; i < arguments.length; i++)
                for (l in arguments[i])
                  arguments[i].hasOwnProperty(l) && u[l] === void 0 && (u[l] = arguments[i][l]);
              return u;
            }, t.prepareContent = function(i, l, u, w, _) {
              return y.Promise.resolve(l).then(function(b) {
                return a.blob && (b instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(b)) !== -1) && typeof FileReader < "u" ? new y.Promise(function(A, Y) {
                  var j = new FileReader();
                  j.onload = function(X) {
                    A(X.target.result);
                  }, j.onerror = function(X) {
                    Y(X.target.error);
                  }, j.readAsArrayBuffer(b);
                }) : b;
              }).then(function(b) {
                var A = t.getTypeOf(b);
                return A ? (A === "arraybuffer" ? b = t.transformTo("uint8array", b) : A === "string" && (_ ? b = v.decode(b) : u && w !== !0 && (b = function(Y) {
                  return d(Y, a.uint8array ? new Uint8Array(Y.length) : new Array(Y.length));
                }(b))), b) : y.Promise.reject(new Error("Can't read the data of '" + i + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
              });
            };
          }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, "set-immediate-shim": 54 }], 33: [function(o, C, t) {
            var a = o("./reader/readerFor"), v = o("./utils"), h = o("./signature"), e = o("./zipEntry"), y = (o("./utf8"), o("./support"));
            function c(d) {
              this.files = [], this.loadOptions = d;
            }
            c.prototype = { checkSignature: function(d) {
              if (!this.reader.readAndCheckSignature(d)) {
                this.reader.index -= 4;
                var p = this.reader.readString(4);
                throw new Error("Corrupted zip or bug: unexpected signature (" + v.pretty(p) + ", expected " + v.pretty(d) + ")");
              }
            }, isSignature: function(d, p) {
              var m = this.reader.index;
              this.reader.setIndex(d);
              var g = this.reader.readString(4) === p;
              return this.reader.setIndex(m), g;
            }, readBlockEndOfCentral: function() {
              this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
              var d = this.reader.readData(this.zipCommentLength), p = y.uint8array ? "uint8array" : "array", m = v.transformTo(p, d);
              this.zipComment = this.loadOptions.decodeFileName(m);
            }, readBlockZip64EndOfCentral: function() {
              this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
              for (var d, p, m, g = this.zip64EndOfCentralSize - 44; 0 < g; )
                d = this.reader.readInt(2), p = this.reader.readInt(4), m = this.reader.readData(p), this.zip64ExtensibleData[d] = { id: d, length: p, value: m };
            }, readBlockZip64EndOfCentralLocator: function() {
              if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
                throw new Error("Multi-volumes zip are not supported");
            }, readLocalFiles: function() {
              var d, p;
              for (d = 0; d < this.files.length; d++)
                p = this.files[d], this.reader.setIndex(p.localHeaderOffset), this.checkSignature(h.LOCAL_FILE_HEADER), p.readLocalPart(this.reader), p.handleUTF8(), p.processAttributes();
            }, readCentralDir: function() {
              var d;
              for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(h.CENTRAL_FILE_HEADER); )
                (d = new e({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(d);
              if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0)
                throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
            }, readEndOfCentral: function() {
              var d = this.reader.lastIndexOfSignature(h.CENTRAL_DIRECTORY_END);
              if (d < 0)
                throw this.isSignature(0, h.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
              this.reader.setIndex(d);
              var p = d;
              if (this.checkSignature(h.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === v.MAX_VALUE_16BITS || this.diskWithCentralDirStart === v.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === v.MAX_VALUE_16BITS || this.centralDirRecords === v.MAX_VALUE_16BITS || this.centralDirSize === v.MAX_VALUE_32BITS || this.centralDirOffset === v.MAX_VALUE_32BITS) {
                if (this.zip64 = !0, (d = this.reader.lastIndexOfSignature(h.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
                  throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
                if (this.reader.setIndex(d), this.checkSignature(h.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, h.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(h.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
                  throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
                this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(h.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
              }
              var m = this.centralDirOffset + this.centralDirSize;
              this.zip64 && (m += 20, m += 12 + this.zip64EndOfCentralSize);
              var g = p - m;
              if (0 < g)
                this.isSignature(p, h.CENTRAL_FILE_HEADER) || (this.reader.zero = g);
              else if (g < 0)
                throw new Error("Corrupted zip: missing " + Math.abs(g) + " bytes.");
            }, prepareReader: function(d) {
              this.reader = a(d);
            }, load: function(d) {
              this.prepareReader(d), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
            } }, C.exports = c;
          }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utf8": 31, "./utils": 32, "./zipEntry": 34 }], 34: [function(o, C, t) {
            var a = o("./reader/readerFor"), v = o("./utils"), h = o("./compressedObject"), e = o("./crc32"), y = o("./utf8"), c = o("./compressions"), d = o("./support");
            function p(m, g) {
              this.options = m, this.loadOptions = g;
            }
            p.prototype = { isEncrypted: function() {
              return (1 & this.bitFlag) == 1;
            }, useUTF8: function() {
              return (2048 & this.bitFlag) == 2048;
            }, readLocalPart: function(m) {
              var g, n;
              if (m.skip(22), this.fileNameLength = m.readInt(2), n = m.readInt(2), this.fileName = m.readData(this.fileNameLength), m.skip(n), this.compressedSize === -1 || this.uncompressedSize === -1)
                throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
              if ((g = function(i) {
                for (var l in c)
                  if (c.hasOwnProperty(l) && c[l].magic === i)
                    return c[l];
                return null;
              }(this.compressionMethod)) === null)
                throw new Error("Corrupted zip : compression " + v.pretty(this.compressionMethod) + " unknown (inner file : " + v.transformTo("string", this.fileName) + ")");
              this.decompressed = new h(this.compressedSize, this.uncompressedSize, this.crc32, g, m.readData(this.compressedSize));
            }, readCentralPart: function(m) {
              this.versionMadeBy = m.readInt(2), m.skip(2), this.bitFlag = m.readInt(2), this.compressionMethod = m.readString(2), this.date = m.readDate(), this.crc32 = m.readInt(4), this.compressedSize = m.readInt(4), this.uncompressedSize = m.readInt(4);
              var g = m.readInt(2);
              if (this.extraFieldsLength = m.readInt(2), this.fileCommentLength = m.readInt(2), this.diskNumberStart = m.readInt(2), this.internalFileAttributes = m.readInt(2), this.externalFileAttributes = m.readInt(4), this.localHeaderOffset = m.readInt(4), this.isEncrypted())
                throw new Error("Encrypted zip are not supported");
              m.skip(g), this.readExtraFields(m), this.parseZIP64ExtraField(m), this.fileComment = m.readData(this.fileCommentLength);
            }, processAttributes: function() {
              this.unixPermissions = null, this.dosPermissions = null;
              var m = this.versionMadeBy >> 8;
              this.dir = !!(16 & this.externalFileAttributes), m == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), m == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
            }, parseZIP64ExtraField: function(m) {
              if (this.extraFields[1]) {
                var g = a(this.extraFields[1].value);
                this.uncompressedSize === v.MAX_VALUE_32BITS && (this.uncompressedSize = g.readInt(8)), this.compressedSize === v.MAX_VALUE_32BITS && (this.compressedSize = g.readInt(8)), this.localHeaderOffset === v.MAX_VALUE_32BITS && (this.localHeaderOffset = g.readInt(8)), this.diskNumberStart === v.MAX_VALUE_32BITS && (this.diskNumberStart = g.readInt(4));
              }
            }, readExtraFields: function(m) {
              var g, n, i, l = m.index + this.extraFieldsLength;
              for (this.extraFields || (this.extraFields = {}); m.index + 4 < l; )
                g = m.readInt(2), n = m.readInt(2), i = m.readData(n), this.extraFields[g] = { id: g, length: n, value: i };
              m.setIndex(l);
            }, handleUTF8: function() {
              var m = d.uint8array ? "uint8array" : "array";
              if (this.useUTF8())
                this.fileNameStr = y.utf8decode(this.fileName), this.fileCommentStr = y.utf8decode(this.fileComment);
              else {
                var g = this.findExtraFieldUnicodePath();
                if (g !== null)
                  this.fileNameStr = g;
                else {
                  var n = v.transformTo(m, this.fileName);
                  this.fileNameStr = this.loadOptions.decodeFileName(n);
                }
                var i = this.findExtraFieldUnicodeComment();
                if (i !== null)
                  this.fileCommentStr = i;
                else {
                  var l = v.transformTo(m, this.fileComment);
                  this.fileCommentStr = this.loadOptions.decodeFileName(l);
                }
              }
            }, findExtraFieldUnicodePath: function() {
              var m = this.extraFields[28789];
              if (m) {
                var g = a(m.value);
                return g.readInt(1) !== 1 || e(this.fileName) !== g.readInt(4) ? null : y.utf8decode(g.readData(m.length - 5));
              }
              return null;
            }, findExtraFieldUnicodeComment: function() {
              var m = this.extraFields[25461];
              if (m) {
                var g = a(m.value);
                return g.readInt(1) !== 1 || e(this.fileComment) !== g.readInt(4) ? null : y.utf8decode(g.readData(m.length - 5));
              }
              return null;
            } }, C.exports = p;
          }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(o, C, t) {
            function a(g, n, i) {
              this.name = g, this.dir = i.dir, this.date = i.date, this.comment = i.comment, this.unixPermissions = i.unixPermissions, this.dosPermissions = i.dosPermissions, this._data = n, this._dataBinary = i.binary, this.options = { compression: i.compression, compressionOptions: i.compressionOptions };
            }
            var v = o("./stream/StreamHelper"), h = o("./stream/DataWorker"), e = o("./utf8"), y = o("./compressedObject"), c = o("./stream/GenericWorker");
            a.prototype = { internalStream: function(g) {
              var n = null, i = "string";
              try {
                if (!g)
                  throw new Error("No output type specified.");
                var l = (i = g.toLowerCase()) === "string" || i === "text";
                i !== "binarystring" && i !== "text" || (i = "string"), n = this._decompressWorker();
                var u = !this._dataBinary;
                u && !l && (n = n.pipe(new e.Utf8EncodeWorker())), !u && l && (n = n.pipe(new e.Utf8DecodeWorker()));
              } catch (w) {
                (n = new c("error")).error(w);
              }
              return new v(n, i, "");
            }, async: function(g, n) {
              return this.internalStream(g).accumulate(n);
            }, nodeStream: function(g, n) {
              return this.internalStream(g || "nodebuffer").toNodejsStream(n);
            }, _compressWorker: function(g, n) {
              if (this._data instanceof y && this._data.compression.magic === g.magic)
                return this._data.getCompressedWorker();
              var i = this._decompressWorker();
              return this._dataBinary || (i = i.pipe(new e.Utf8EncodeWorker())), y.createWorkerFrom(i, g, n);
            }, _decompressWorker: function() {
              return this._data instanceof y ? this._data.getContentWorker() : this._data instanceof c ? this._data : new h(this._data);
            } };
            for (var d = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], p = function() {
              throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
            }, m = 0; m < d.length; m++)
              a.prototype[d[m]] = p;
            C.exports = a;
          }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(o, C, t) {
            (function(a) {
              var v, h, e = a.MutationObserver || a.WebKitMutationObserver;
              if (e) {
                var y = 0, c = new e(g), d = a.document.createTextNode("");
                c.observe(d, { characterData: !0 }), v = function() {
                  d.data = y = ++y % 2;
                };
              } else if (a.setImmediate || a.MessageChannel === void 0)
                v = "document" in a && "onreadystatechange" in a.document.createElement("script") ? function() {
                  var n = a.document.createElement("script");
                  n.onreadystatechange = function() {
                    g(), n.onreadystatechange = null, n.parentNode.removeChild(n), n = null;
                  }, a.document.documentElement.appendChild(n);
                } : function() {
                  setTimeout(g, 0);
                };
              else {
                var p = new a.MessageChannel();
                p.port1.onmessage = g, v = function() {
                  p.port2.postMessage(0);
                };
              }
              var m = [];
              function g() {
                var n, i;
                h = !0;
                for (var l = m.length; l; ) {
                  for (i = m, m = [], n = -1; ++n < l; )
                    i[n]();
                  l = m.length;
                }
                h = !1;
              }
              C.exports = function(n) {
                m.push(n) !== 1 || h || v();
              };
            }).call(this, typeof ae < "u" ? ae : typeof self < "u" ? self : typeof window < "u" ? window : {});
          }, {}], 37: [function(o, C, t) {
            var a = o("immediate");
            function v() {
            }
            var h = {}, e = ["REJECTED"], y = ["FULFILLED"], c = ["PENDING"];
            function d(l) {
              if (typeof l != "function")
                throw new TypeError("resolver must be a function");
              this.state = c, this.queue = [], this.outcome = void 0, l !== v && n(this, l);
            }
            function p(l, u, w) {
              this.promise = l, typeof u == "function" && (this.onFulfilled = u, this.callFulfilled = this.otherCallFulfilled), typeof w == "function" && (this.onRejected = w, this.callRejected = this.otherCallRejected);
            }
            function m(l, u, w) {
              a(function() {
                var _;
                try {
                  _ = u(w);
                } catch (b) {
                  return h.reject(l, b);
                }
                _ === l ? h.reject(l, new TypeError("Cannot resolve promise with itself")) : h.resolve(l, _);
              });
            }
            function g(l) {
              var u = l && l.then;
              if (l && (typeof l == "object" || typeof l == "function") && typeof u == "function")
                return function() {
                  u.apply(l, arguments);
                };
            }
            function n(l, u) {
              var w = !1;
              function _(Y) {
                w || (w = !0, h.reject(l, Y));
              }
              function b(Y) {
                w || (w = !0, h.resolve(l, Y));
              }
              var A = i(function() {
                u(b, _);
              });
              A.status === "error" && _(A.value);
            }
            function i(l, u) {
              var w = {};
              try {
                w.value = l(u), w.status = "success";
              } catch (_) {
                w.status = "error", w.value = _;
              }
              return w;
            }
            (C.exports = d).prototype.finally = function(l) {
              if (typeof l != "function")
                return this;
              var u = this.constructor;
              return this.then(function(w) {
                return u.resolve(l()).then(function() {
                  return w;
                });
              }, function(w) {
                return u.resolve(l()).then(function() {
                  throw w;
                });
              });
            }, d.prototype.catch = function(l) {
              return this.then(null, l);
            }, d.prototype.then = function(l, u) {
              if (typeof l != "function" && this.state === y || typeof u != "function" && this.state === e)
                return this;
              var w = new this.constructor(v);
              return this.state !== c ? m(w, this.state === y ? l : u, this.outcome) : this.queue.push(new p(w, l, u)), w;
            }, p.prototype.callFulfilled = function(l) {
              h.resolve(this.promise, l);
            }, p.prototype.otherCallFulfilled = function(l) {
              m(this.promise, this.onFulfilled, l);
            }, p.prototype.callRejected = function(l) {
              h.reject(this.promise, l);
            }, p.prototype.otherCallRejected = function(l) {
              m(this.promise, this.onRejected, l);
            }, h.resolve = function(l, u) {
              var w = i(g, u);
              if (w.status === "error")
                return h.reject(l, w.value);
              var _ = w.value;
              if (_)
                n(l, _);
              else {
                l.state = y, l.outcome = u;
                for (var b = -1, A = l.queue.length; ++b < A; )
                  l.queue[b].callFulfilled(u);
              }
              return l;
            }, h.reject = function(l, u) {
              l.state = e, l.outcome = u;
              for (var w = -1, _ = l.queue.length; ++w < _; )
                l.queue[w].callRejected(u);
              return l;
            }, d.resolve = function(l) {
              return l instanceof this ? l : h.resolve(new this(v), l);
            }, d.reject = function(l) {
              var u = new this(v);
              return h.reject(u, l);
            }, d.all = function(l) {
              var u = this;
              if (Object.prototype.toString.call(l) !== "[object Array]")
                return this.reject(new TypeError("must be an array"));
              var w = l.length, _ = !1;
              if (!w)
                return this.resolve([]);
              for (var b = new Array(w), A = 0, Y = -1, j = new this(v); ++Y < w; )
                X(l[Y], Y);
              return j;
              function X(B, R) {
                u.resolve(B).then(function(k) {
                  b[R] = k, ++A !== w || _ || (_ = !0, h.resolve(j, b));
                }, function(k) {
                  _ || (_ = !0, h.reject(j, k));
                });
              }
            }, d.race = function(l) {
              var u = this;
              if (Object.prototype.toString.call(l) !== "[object Array]")
                return this.reject(new TypeError("must be an array"));
              var w = l.length, _ = !1;
              if (!w)
                return this.resolve([]);
              for (var b = -1, A = new this(v); ++b < w; )
                Y = l[b], u.resolve(Y).then(function(j) {
                  _ || (_ = !0, h.resolve(A, j));
                }, function(j) {
                  _ || (_ = !0, h.reject(A, j));
                });
              var Y;
              return A;
            };
          }, { immediate: 36 }], 38: [function(o, C, t) {
            var a = {};
            (0, o("./lib/utils/common").assign)(a, o("./lib/deflate"), o("./lib/inflate"), o("./lib/zlib/constants")), C.exports = a;
          }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(o, C, t) {
            var a = o("./zlib/deflate"), v = o("./utils/common"), h = o("./utils/strings"), e = o("./zlib/messages"), y = o("./zlib/zstream"), c = Object.prototype.toString, d = 0, p = -1, m = 0, g = 8;
            function n(l) {
              if (!(this instanceof n))
                return new n(l);
              this.options = v.assign({ level: p, method: g, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: m, to: "" }, l || {});
              var u = this.options;
              u.raw && 0 < u.windowBits ? u.windowBits = -u.windowBits : u.gzip && 0 < u.windowBits && u.windowBits < 16 && (u.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new y(), this.strm.avail_out = 0;
              var w = a.deflateInit2(this.strm, u.level, u.method, u.windowBits, u.memLevel, u.strategy);
              if (w !== d)
                throw new Error(e[w]);
              if (u.header && a.deflateSetHeader(this.strm, u.header), u.dictionary) {
                var _;
                if (_ = typeof u.dictionary == "string" ? h.string2buf(u.dictionary) : c.call(u.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(u.dictionary) : u.dictionary, (w = a.deflateSetDictionary(this.strm, _)) !== d)
                  throw new Error(e[w]);
                this._dict_set = !0;
              }
            }
            function i(l, u) {
              var w = new n(u);
              if (w.push(l, !0), w.err)
                throw w.msg || e[w.err];
              return w.result;
            }
            n.prototype.push = function(l, u) {
              var w, _, b = this.strm, A = this.options.chunkSize;
              if (this.ended)
                return !1;
              _ = u === ~~u ? u : u === !0 ? 4 : 0, typeof l == "string" ? b.input = h.string2buf(l) : c.call(l) === "[object ArrayBuffer]" ? b.input = new Uint8Array(l) : b.input = l, b.next_in = 0, b.avail_in = b.input.length;
              do {
                if (b.avail_out === 0 && (b.output = new v.Buf8(A), b.next_out = 0, b.avail_out = A), (w = a.deflate(b, _)) !== 1 && w !== d)
                  return this.onEnd(w), !(this.ended = !0);
                b.avail_out !== 0 && (b.avail_in !== 0 || _ !== 4 && _ !== 2) || (this.options.to === "string" ? this.onData(h.buf2binstring(v.shrinkBuf(b.output, b.next_out))) : this.onData(v.shrinkBuf(b.output, b.next_out)));
              } while ((0 < b.avail_in || b.avail_out === 0) && w !== 1);
              return _ === 4 ? (w = a.deflateEnd(this.strm), this.onEnd(w), this.ended = !0, w === d) : _ !== 2 || (this.onEnd(d), !(b.avail_out = 0));
            }, n.prototype.onData = function(l) {
              this.chunks.push(l);
            }, n.prototype.onEnd = function(l) {
              l === d && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = v.flattenChunks(this.chunks)), this.chunks = [], this.err = l, this.msg = this.strm.msg;
            }, t.Deflate = n, t.deflate = i, t.deflateRaw = function(l, u) {
              return (u = u || {}).raw = !0, i(l, u);
            }, t.gzip = function(l, u) {
              return (u = u || {}).gzip = !0, i(l, u);
            };
          }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(o, C, t) {
            var a = o("./zlib/inflate"), v = o("./utils/common"), h = o("./utils/strings"), e = o("./zlib/constants"), y = o("./zlib/messages"), c = o("./zlib/zstream"), d = o("./zlib/gzheader"), p = Object.prototype.toString;
            function m(n) {
              if (!(this instanceof m))
                return new m(n);
              this.options = v.assign({ chunkSize: 16384, windowBits: 0, to: "" }, n || {});
              var i = this.options;
              i.raw && 0 <= i.windowBits && i.windowBits < 16 && (i.windowBits = -i.windowBits, i.windowBits === 0 && (i.windowBits = -15)), !(0 <= i.windowBits && i.windowBits < 16) || n && n.windowBits || (i.windowBits += 32), 15 < i.windowBits && i.windowBits < 48 && !(15 & i.windowBits) && (i.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new c(), this.strm.avail_out = 0;
              var l = a.inflateInit2(this.strm, i.windowBits);
              if (l !== e.Z_OK)
                throw new Error(y[l]);
              this.header = new d(), a.inflateGetHeader(this.strm, this.header);
            }
            function g(n, i) {
              var l = new m(i);
              if (l.push(n, !0), l.err)
                throw l.msg || y[l.err];
              return l.result;
            }
            m.prototype.push = function(n, i) {
              var l, u, w, _, b, A, Y = this.strm, j = this.options.chunkSize, X = this.options.dictionary, B = !1;
              if (this.ended)
                return !1;
              u = i === ~~i ? i : i === !0 ? e.Z_FINISH : e.Z_NO_FLUSH, typeof n == "string" ? Y.input = h.binstring2buf(n) : p.call(n) === "[object ArrayBuffer]" ? Y.input = new Uint8Array(n) : Y.input = n, Y.next_in = 0, Y.avail_in = Y.input.length;
              do {
                if (Y.avail_out === 0 && (Y.output = new v.Buf8(j), Y.next_out = 0, Y.avail_out = j), (l = a.inflate(Y, e.Z_NO_FLUSH)) === e.Z_NEED_DICT && X && (A = typeof X == "string" ? h.string2buf(X) : p.call(X) === "[object ArrayBuffer]" ? new Uint8Array(X) : X, l = a.inflateSetDictionary(this.strm, A)), l === e.Z_BUF_ERROR && B === !0 && (l = e.Z_OK, B = !1), l !== e.Z_STREAM_END && l !== e.Z_OK)
                  return this.onEnd(l), !(this.ended = !0);
                Y.next_out && (Y.avail_out !== 0 && l !== e.Z_STREAM_END && (Y.avail_in !== 0 || u !== e.Z_FINISH && u !== e.Z_SYNC_FLUSH) || (this.options.to === "string" ? (w = h.utf8border(Y.output, Y.next_out), _ = Y.next_out - w, b = h.buf2string(Y.output, w), Y.next_out = _, Y.avail_out = j - _, _ && v.arraySet(Y.output, Y.output, w, _, 0), this.onData(b)) : this.onData(v.shrinkBuf(Y.output, Y.next_out)))), Y.avail_in === 0 && Y.avail_out === 0 && (B = !0);
              } while ((0 < Y.avail_in || Y.avail_out === 0) && l !== e.Z_STREAM_END);
              return l === e.Z_STREAM_END && (u = e.Z_FINISH), u === e.Z_FINISH ? (l = a.inflateEnd(this.strm), this.onEnd(l), this.ended = !0, l === e.Z_OK) : u !== e.Z_SYNC_FLUSH || (this.onEnd(e.Z_OK), !(Y.avail_out = 0));
            }, m.prototype.onData = function(n) {
              this.chunks.push(n);
            }, m.prototype.onEnd = function(n) {
              n === e.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = v.flattenChunks(this.chunks)), this.chunks = [], this.err = n, this.msg = this.strm.msg;
            }, t.Inflate = m, t.inflate = g, t.inflateRaw = function(n, i) {
              return (i = i || {}).raw = !0, g(n, i);
            }, t.ungzip = g;
          }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(o, C, t) {
            var a = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
            t.assign = function(e) {
              for (var y = Array.prototype.slice.call(arguments, 1); y.length; ) {
                var c = y.shift();
                if (c) {
                  if (typeof c != "object")
                    throw new TypeError(c + "must be non-object");
                  for (var d in c)
                    c.hasOwnProperty(d) && (e[d] = c[d]);
                }
              }
              return e;
            }, t.shrinkBuf = function(e, y) {
              return e.length === y ? e : e.subarray ? e.subarray(0, y) : (e.length = y, e);
            };
            var v = { arraySet: function(e, y, c, d, p) {
              if (y.subarray && e.subarray)
                e.set(y.subarray(c, c + d), p);
              else
                for (var m = 0; m < d; m++)
                  e[p + m] = y[c + m];
            }, flattenChunks: function(e) {
              var y, c, d, p, m, g;
              for (y = d = 0, c = e.length; y < c; y++)
                d += e[y].length;
              for (g = new Uint8Array(d), y = p = 0, c = e.length; y < c; y++)
                m = e[y], g.set(m, p), p += m.length;
              return g;
            } }, h = { arraySet: function(e, y, c, d, p) {
              for (var m = 0; m < d; m++)
                e[p + m] = y[c + m];
            }, flattenChunks: function(e) {
              return [].concat.apply([], e);
            } };
            t.setTyped = function(e) {
              e ? (t.Buf8 = Uint8Array, t.Buf16 = Uint16Array, t.Buf32 = Int32Array, t.assign(t, v)) : (t.Buf8 = Array, t.Buf16 = Array, t.Buf32 = Array, t.assign(t, h));
            }, t.setTyped(a);
          }, {}], 42: [function(o, C, t) {
            var a = o("./common"), v = !0, h = !0;
            try {
              String.fromCharCode.apply(null, [0]);
            } catch {
              v = !1;
            }
            try {
              String.fromCharCode.apply(null, new Uint8Array(1));
            } catch {
              h = !1;
            }
            for (var e = new a.Buf8(256), y = 0; y < 256; y++)
              e[y] = 252 <= y ? 6 : 248 <= y ? 5 : 240 <= y ? 4 : 224 <= y ? 3 : 192 <= y ? 2 : 1;
            function c(d, p) {
              if (p < 65537 && (d.subarray && h || !d.subarray && v))
                return String.fromCharCode.apply(null, a.shrinkBuf(d, p));
              for (var m = "", g = 0; g < p; g++)
                m += String.fromCharCode(d[g]);
              return m;
            }
            e[254] = e[254] = 1, t.string2buf = function(d) {
              var p, m, g, n, i, l = d.length, u = 0;
              for (n = 0; n < l; n++)
                (64512 & (m = d.charCodeAt(n))) == 55296 && n + 1 < l && (64512 & (g = d.charCodeAt(n + 1))) == 56320 && (m = 65536 + (m - 55296 << 10) + (g - 56320), n++), u += m < 128 ? 1 : m < 2048 ? 2 : m < 65536 ? 3 : 4;
              for (p = new a.Buf8(u), n = i = 0; i < u; n++)
                (64512 & (m = d.charCodeAt(n))) == 55296 && n + 1 < l && (64512 & (g = d.charCodeAt(n + 1))) == 56320 && (m = 65536 + (m - 55296 << 10) + (g - 56320), n++), m < 128 ? p[i++] = m : (m < 2048 ? p[i++] = 192 | m >>> 6 : (m < 65536 ? p[i++] = 224 | m >>> 12 : (p[i++] = 240 | m >>> 18, p[i++] = 128 | m >>> 12 & 63), p[i++] = 128 | m >>> 6 & 63), p[i++] = 128 | 63 & m);
              return p;
            }, t.buf2binstring = function(d) {
              return c(d, d.length);
            }, t.binstring2buf = function(d) {
              for (var p = new a.Buf8(d.length), m = 0, g = p.length; m < g; m++)
                p[m] = d.charCodeAt(m);
              return p;
            }, t.buf2string = function(d, p) {
              var m, g, n, i, l = p || d.length, u = new Array(2 * l);
              for (m = g = 0; m < l; )
                if ((n = d[m++]) < 128)
                  u[g++] = n;
                else if (4 < (i = e[n]))
                  u[g++] = 65533, m += i - 1;
                else {
                  for (n &= i === 2 ? 31 : i === 3 ? 15 : 7; 1 < i && m < l; )
                    n = n << 6 | 63 & d[m++], i--;
                  1 < i ? u[g++] = 65533 : n < 65536 ? u[g++] = n : (n -= 65536, u[g++] = 55296 | n >> 10 & 1023, u[g++] = 56320 | 1023 & n);
                }
              return c(u, g);
            }, t.utf8border = function(d, p) {
              var m;
              for ((p = p || d.length) > d.length && (p = d.length), m = p - 1; 0 <= m && (192 & d[m]) == 128; )
                m--;
              return m < 0 || m === 0 ? p : m + e[d[m]] > p ? m : p;
            };
          }, { "./common": 41 }], 43: [function(o, C, t) {
            C.exports = function(a, v, h, e) {
              for (var y = 65535 & a | 0, c = a >>> 16 & 65535 | 0, d = 0; h !== 0; ) {
                for (h -= d = 2e3 < h ? 2e3 : h; c = c + (y = y + v[e++] | 0) | 0, --d; )
                  ;
                y %= 65521, c %= 65521;
              }
              return y | c << 16 | 0;
            };
          }, {}], 44: [function(o, C, t) {
            C.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
          }, {}], 45: [function(o, C, t) {
            var a = function() {
              for (var v, h = [], e = 0; e < 256; e++) {
                v = e;
                for (var y = 0; y < 8; y++)
                  v = 1 & v ? 3988292384 ^ v >>> 1 : v >>> 1;
                h[e] = v;
              }
              return h;
            }();
            C.exports = function(v, h, e, y) {
              var c = a, d = y + e;
              v ^= -1;
              for (var p = y; p < d; p++)
                v = v >>> 8 ^ c[255 & (v ^ h[p])];
              return -1 ^ v;
            };
          }, {}], 46: [function(o, C, t) {
            var a, v = o("../utils/common"), h = o("./trees"), e = o("./adler32"), y = o("./crc32"), c = o("./messages"), d = 0, p = 4, m = 0, g = -2, n = -1, i = 4, l = 2, u = 8, w = 9, _ = 286, b = 30, A = 19, Y = 2 * _ + 1, j = 15, X = 3, B = 258, R = B + X + 1, k = 42, x = 113, f = 1, U = 2, O = 3, S = 4;
            function F(D, ne) {
              return D.msg = c[ne], ne;
            }
            function T(D) {
              return (D << 1) - (4 < D ? 9 : 0);
            }
            function I(D) {
              for (var ne = D.length; 0 <= --ne; )
                D[ne] = 0;
            }
            function M(D) {
              var ne = D.state, oe = ne.pending;
              oe > D.avail_out && (oe = D.avail_out), oe !== 0 && (v.arraySet(D.output, ne.pending_buf, ne.pending_out, oe, D.next_out), D.next_out += oe, ne.pending_out += oe, D.total_out += oe, D.avail_out -= oe, ne.pending -= oe, ne.pending === 0 && (ne.pending_out = 0));
            }
            function V(D, ne) {
              h._tr_flush_block(D, 0 <= D.block_start ? D.block_start : -1, D.strstart - D.block_start, ne), D.block_start = D.strstart, M(D.strm);
            }
            function J(D, ne) {
              D.pending_buf[D.pending++] = ne;
            }
            function W(D, ne) {
              D.pending_buf[D.pending++] = ne >>> 8 & 255, D.pending_buf[D.pending++] = 255 & ne;
            }
            function z(D, ne) {
              var oe, ee, $ = D.max_chain_length, E = D.strstart, H = D.prev_length, ie = D.nice_match, ue = D.strstart > D.w_size - R ? D.strstart - (D.w_size - R) : 0, fe = D.window, de = D.w_mask, pe = D.prev, xe = D.strstart + B, De = fe[E + H - 1], Ae = fe[E + H];
              D.prev_length >= D.good_match && ($ >>= 2), ie > D.lookahead && (ie = D.lookahead);
              do
                if (fe[(oe = ne) + H] === Ae && fe[oe + H - 1] === De && fe[oe] === fe[E] && fe[++oe] === fe[E + 1]) {
                  E += 2, oe++;
                  do
                    ;
                  while (fe[++E] === fe[++oe] && fe[++E] === fe[++oe] && fe[++E] === fe[++oe] && fe[++E] === fe[++oe] && fe[++E] === fe[++oe] && fe[++E] === fe[++oe] && fe[++E] === fe[++oe] && fe[++E] === fe[++oe] && E < xe);
                  if (ee = B - (xe - E), E = xe - B, H < ee) {
                    if (D.match_start = ne, ie <= (H = ee))
                      break;
                    De = fe[E + H - 1], Ae = fe[E + H];
                  }
                }
              while ((ne = pe[ne & de]) > ue && --$ != 0);
              return H <= D.lookahead ? H : D.lookahead;
            }
            function G(D) {
              var ne, oe, ee, $, E, H, ie, ue, fe, de, pe = D.w_size;
              do {
                if ($ = D.window_size - D.lookahead - D.strstart, D.strstart >= pe + (pe - R)) {
                  for (v.arraySet(D.window, D.window, pe, pe, 0), D.match_start -= pe, D.strstart -= pe, D.block_start -= pe, ne = oe = D.hash_size; ee = D.head[--ne], D.head[ne] = pe <= ee ? ee - pe : 0, --oe; )
                    ;
                  for (ne = oe = pe; ee = D.prev[--ne], D.prev[ne] = pe <= ee ? ee - pe : 0, --oe; )
                    ;
                  $ += pe;
                }
                if (D.strm.avail_in === 0)
                  break;
                if (H = D.strm, ie = D.window, ue = D.strstart + D.lookahead, fe = $, de = void 0, de = H.avail_in, fe < de && (de = fe), oe = de === 0 ? 0 : (H.avail_in -= de, v.arraySet(ie, H.input, H.next_in, de, ue), H.state.wrap === 1 ? H.adler = e(H.adler, ie, de, ue) : H.state.wrap === 2 && (H.adler = y(H.adler, ie, de, ue)), H.next_in += de, H.total_in += de, de), D.lookahead += oe, D.lookahead + D.insert >= X)
                  for (E = D.strstart - D.insert, D.ins_h = D.window[E], D.ins_h = (D.ins_h << D.hash_shift ^ D.window[E + 1]) & D.hash_mask; D.insert && (D.ins_h = (D.ins_h << D.hash_shift ^ D.window[E + X - 1]) & D.hash_mask, D.prev[E & D.w_mask] = D.head[D.ins_h], D.head[D.ins_h] = E, E++, D.insert--, !(D.lookahead + D.insert < X)); )
                    ;
              } while (D.lookahead < R && D.strm.avail_in !== 0);
            }
            function L(D, ne) {
              for (var oe, ee; ; ) {
                if (D.lookahead < R) {
                  if (G(D), D.lookahead < R && ne === d)
                    return f;
                  if (D.lookahead === 0)
                    break;
                }
                if (oe = 0, D.lookahead >= X && (D.ins_h = (D.ins_h << D.hash_shift ^ D.window[D.strstart + X - 1]) & D.hash_mask, oe = D.prev[D.strstart & D.w_mask] = D.head[D.ins_h], D.head[D.ins_h] = D.strstart), oe !== 0 && D.strstart - oe <= D.w_size - R && (D.match_length = z(D, oe)), D.match_length >= X)
                  if (ee = h._tr_tally(D, D.strstart - D.match_start, D.match_length - X), D.lookahead -= D.match_length, D.match_length <= D.max_lazy_match && D.lookahead >= X) {
                    for (D.match_length--; D.strstart++, D.ins_h = (D.ins_h << D.hash_shift ^ D.window[D.strstart + X - 1]) & D.hash_mask, oe = D.prev[D.strstart & D.w_mask] = D.head[D.ins_h], D.head[D.ins_h] = D.strstart, --D.match_length != 0; )
                      ;
                    D.strstart++;
                  } else
                    D.strstart += D.match_length, D.match_length = 0, D.ins_h = D.window[D.strstart], D.ins_h = (D.ins_h << D.hash_shift ^ D.window[D.strstart + 1]) & D.hash_mask;
                else
                  ee = h._tr_tally(D, 0, D.window[D.strstart]), D.lookahead--, D.strstart++;
                if (ee && (V(D, !1), D.strm.avail_out === 0))
                  return f;
              }
              return D.insert = D.strstart < X - 1 ? D.strstart : X - 1, ne === p ? (V(D, !0), D.strm.avail_out === 0 ? O : S) : D.last_lit && (V(D, !1), D.strm.avail_out === 0) ? f : U;
            }
            function K(D, ne) {
              for (var oe, ee, $; ; ) {
                if (D.lookahead < R) {
                  if (G(D), D.lookahead < R && ne === d)
                    return f;
                  if (D.lookahead === 0)
                    break;
                }
                if (oe = 0, D.lookahead >= X && (D.ins_h = (D.ins_h << D.hash_shift ^ D.window[D.strstart + X - 1]) & D.hash_mask, oe = D.prev[D.strstart & D.w_mask] = D.head[D.ins_h], D.head[D.ins_h] = D.strstart), D.prev_length = D.match_length, D.prev_match = D.match_start, D.match_length = X - 1, oe !== 0 && D.prev_length < D.max_lazy_match && D.strstart - oe <= D.w_size - R && (D.match_length = z(D, oe), D.match_length <= 5 && (D.strategy === 1 || D.match_length === X && 4096 < D.strstart - D.match_start) && (D.match_length = X - 1)), D.prev_length >= X && D.match_length <= D.prev_length) {
                  for ($ = D.strstart + D.lookahead - X, ee = h._tr_tally(D, D.strstart - 1 - D.prev_match, D.prev_length - X), D.lookahead -= D.prev_length - 1, D.prev_length -= 2; ++D.strstart <= $ && (D.ins_h = (D.ins_h << D.hash_shift ^ D.window[D.strstart + X - 1]) & D.hash_mask, oe = D.prev[D.strstart & D.w_mask] = D.head[D.ins_h], D.head[D.ins_h] = D.strstart), --D.prev_length != 0; )
                    ;
                  if (D.match_available = 0, D.match_length = X - 1, D.strstart++, ee && (V(D, !1), D.strm.avail_out === 0))
                    return f;
                } else if (D.match_available) {
                  if ((ee = h._tr_tally(D, 0, D.window[D.strstart - 1])) && V(D, !1), D.strstart++, D.lookahead--, D.strm.avail_out === 0)
                    return f;
                } else
                  D.match_available = 1, D.strstart++, D.lookahead--;
              }
              return D.match_available && (ee = h._tr_tally(D, 0, D.window[D.strstart - 1]), D.match_available = 0), D.insert = D.strstart < X - 1 ? D.strstart : X - 1, ne === p ? (V(D, !0), D.strm.avail_out === 0 ? O : S) : D.last_lit && (V(D, !1), D.strm.avail_out === 0) ? f : U;
            }
            function te(D, ne, oe, ee, $) {
              this.good_length = D, this.max_lazy = ne, this.nice_length = oe, this.max_chain = ee, this.func = $;
            }
            function se() {
              this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = u, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new v.Buf16(2 * Y), this.dyn_dtree = new v.Buf16(2 * (2 * b + 1)), this.bl_tree = new v.Buf16(2 * (2 * A + 1)), I(this.dyn_ltree), I(this.dyn_dtree), I(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new v.Buf16(j + 1), this.heap = new v.Buf16(2 * _ + 1), I(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new v.Buf16(2 * _ + 1), I(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
            }
            function q(D) {
              var ne;
              return D && D.state ? (D.total_in = D.total_out = 0, D.data_type = l, (ne = D.state).pending = 0, ne.pending_out = 0, ne.wrap < 0 && (ne.wrap = -ne.wrap), ne.status = ne.wrap ? k : x, D.adler = ne.wrap === 2 ? 0 : 1, ne.last_flush = d, h._tr_init(ne), m) : F(D, g);
            }
            function N(D) {
              var ne = q(D);
              return ne === m && function(oe) {
                oe.window_size = 2 * oe.w_size, I(oe.head), oe.max_lazy_match = a[oe.level].max_lazy, oe.good_match = a[oe.level].good_length, oe.nice_match = a[oe.level].nice_length, oe.max_chain_length = a[oe.level].max_chain, oe.strstart = 0, oe.block_start = 0, oe.lookahead = 0, oe.insert = 0, oe.match_length = oe.prev_length = X - 1, oe.match_available = 0, oe.ins_h = 0;
              }(D.state), ne;
            }
            function Q(D, ne, oe, ee, $, E) {
              if (!D)
                return g;
              var H = 1;
              if (ne === n && (ne = 6), ee < 0 ? (H = 0, ee = -ee) : 15 < ee && (H = 2, ee -= 16), $ < 1 || w < $ || oe !== u || ee < 8 || 15 < ee || ne < 0 || 9 < ne || E < 0 || i < E)
                return F(D, g);
              ee === 8 && (ee = 9);
              var ie = new se();
              return (D.state = ie).strm = D, ie.wrap = H, ie.gzhead = null, ie.w_bits = ee, ie.w_size = 1 << ie.w_bits, ie.w_mask = ie.w_size - 1, ie.hash_bits = $ + 7, ie.hash_size = 1 << ie.hash_bits, ie.hash_mask = ie.hash_size - 1, ie.hash_shift = ~~((ie.hash_bits + X - 1) / X), ie.window = new v.Buf8(2 * ie.w_size), ie.head = new v.Buf16(ie.hash_size), ie.prev = new v.Buf16(ie.w_size), ie.lit_bufsize = 1 << $ + 6, ie.pending_buf_size = 4 * ie.lit_bufsize, ie.pending_buf = new v.Buf8(ie.pending_buf_size), ie.d_buf = 1 * ie.lit_bufsize, ie.l_buf = 3 * ie.lit_bufsize, ie.level = ne, ie.strategy = E, ie.method = oe, N(D);
            }
            a = [new te(0, 0, 0, 0, function(D, ne) {
              var oe = 65535;
              for (oe > D.pending_buf_size - 5 && (oe = D.pending_buf_size - 5); ; ) {
                if (D.lookahead <= 1) {
                  if (G(D), D.lookahead === 0 && ne === d)
                    return f;
                  if (D.lookahead === 0)
                    break;
                }
                D.strstart += D.lookahead, D.lookahead = 0;
                var ee = D.block_start + oe;
                if ((D.strstart === 0 || D.strstart >= ee) && (D.lookahead = D.strstart - ee, D.strstart = ee, V(D, !1), D.strm.avail_out === 0) || D.strstart - D.block_start >= D.w_size - R && (V(D, !1), D.strm.avail_out === 0))
                  return f;
              }
              return D.insert = 0, ne === p ? (V(D, !0), D.strm.avail_out === 0 ? O : S) : (D.strstart > D.block_start && (V(D, !1), D.strm.avail_out), f);
            }), new te(4, 4, 8, 4, L), new te(4, 5, 16, 8, L), new te(4, 6, 32, 32, L), new te(4, 4, 16, 16, K), new te(8, 16, 32, 32, K), new te(8, 16, 128, 128, K), new te(8, 32, 128, 256, K), new te(32, 128, 258, 1024, K), new te(32, 258, 258, 4096, K)], t.deflateInit = function(D, ne) {
              return Q(D, ne, u, 15, 8, 0);
            }, t.deflateInit2 = Q, t.deflateReset = N, t.deflateResetKeep = q, t.deflateSetHeader = function(D, ne) {
              return D && D.state ? D.state.wrap !== 2 ? g : (D.state.gzhead = ne, m) : g;
            }, t.deflate = function(D, ne) {
              var oe, ee, $, E;
              if (!D || !D.state || 5 < ne || ne < 0)
                return D ? F(D, g) : g;
              if (ee = D.state, !D.output || !D.input && D.avail_in !== 0 || ee.status === 666 && ne !== p)
                return F(D, D.avail_out === 0 ? -5 : g);
              if (ee.strm = D, oe = ee.last_flush, ee.last_flush = ne, ee.status === k)
                if (ee.wrap === 2)
                  D.adler = 0, J(ee, 31), J(ee, 139), J(ee, 8), ee.gzhead ? (J(ee, (ee.gzhead.text ? 1 : 0) + (ee.gzhead.hcrc ? 2 : 0) + (ee.gzhead.extra ? 4 : 0) + (ee.gzhead.name ? 8 : 0) + (ee.gzhead.comment ? 16 : 0)), J(ee, 255 & ee.gzhead.time), J(ee, ee.gzhead.time >> 8 & 255), J(ee, ee.gzhead.time >> 16 & 255), J(ee, ee.gzhead.time >> 24 & 255), J(ee, ee.level === 9 ? 2 : 2 <= ee.strategy || ee.level < 2 ? 4 : 0), J(ee, 255 & ee.gzhead.os), ee.gzhead.extra && ee.gzhead.extra.length && (J(ee, 255 & ee.gzhead.extra.length), J(ee, ee.gzhead.extra.length >> 8 & 255)), ee.gzhead.hcrc && (D.adler = y(D.adler, ee.pending_buf, ee.pending, 0)), ee.gzindex = 0, ee.status = 69) : (J(ee, 0), J(ee, 0), J(ee, 0), J(ee, 0), J(ee, 0), J(ee, ee.level === 9 ? 2 : 2 <= ee.strategy || ee.level < 2 ? 4 : 0), J(ee, 3), ee.status = x);
                else {
                  var H = u + (ee.w_bits - 8 << 4) << 8;
                  H |= (2 <= ee.strategy || ee.level < 2 ? 0 : ee.level < 6 ? 1 : ee.level === 6 ? 2 : 3) << 6, ee.strstart !== 0 && (H |= 32), H += 31 - H % 31, ee.status = x, W(ee, H), ee.strstart !== 0 && (W(ee, D.adler >>> 16), W(ee, 65535 & D.adler)), D.adler = 1;
                }
              if (ee.status === 69)
                if (ee.gzhead.extra) {
                  for ($ = ee.pending; ee.gzindex < (65535 & ee.gzhead.extra.length) && (ee.pending !== ee.pending_buf_size || (ee.gzhead.hcrc && ee.pending > $ && (D.adler = y(D.adler, ee.pending_buf, ee.pending - $, $)), M(D), $ = ee.pending, ee.pending !== ee.pending_buf_size)); )
                    J(ee, 255 & ee.gzhead.extra[ee.gzindex]), ee.gzindex++;
                  ee.gzhead.hcrc && ee.pending > $ && (D.adler = y(D.adler, ee.pending_buf, ee.pending - $, $)), ee.gzindex === ee.gzhead.extra.length && (ee.gzindex = 0, ee.status = 73);
                } else
                  ee.status = 73;
              if (ee.status === 73)
                if (ee.gzhead.name) {
                  $ = ee.pending;
                  do {
                    if (ee.pending === ee.pending_buf_size && (ee.gzhead.hcrc && ee.pending > $ && (D.adler = y(D.adler, ee.pending_buf, ee.pending - $, $)), M(D), $ = ee.pending, ee.pending === ee.pending_buf_size)) {
                      E = 1;
                      break;
                    }
                    E = ee.gzindex < ee.gzhead.name.length ? 255 & ee.gzhead.name.charCodeAt(ee.gzindex++) : 0, J(ee, E);
                  } while (E !== 0);
                  ee.gzhead.hcrc && ee.pending > $ && (D.adler = y(D.adler, ee.pending_buf, ee.pending - $, $)), E === 0 && (ee.gzindex = 0, ee.status = 91);
                } else
                  ee.status = 91;
              if (ee.status === 91)
                if (ee.gzhead.comment) {
                  $ = ee.pending;
                  do {
                    if (ee.pending === ee.pending_buf_size && (ee.gzhead.hcrc && ee.pending > $ && (D.adler = y(D.adler, ee.pending_buf, ee.pending - $, $)), M(D), $ = ee.pending, ee.pending === ee.pending_buf_size)) {
                      E = 1;
                      break;
                    }
                    E = ee.gzindex < ee.gzhead.comment.length ? 255 & ee.gzhead.comment.charCodeAt(ee.gzindex++) : 0, J(ee, E);
                  } while (E !== 0);
                  ee.gzhead.hcrc && ee.pending > $ && (D.adler = y(D.adler, ee.pending_buf, ee.pending - $, $)), E === 0 && (ee.status = 103);
                } else
                  ee.status = 103;
              if (ee.status === 103 && (ee.gzhead.hcrc ? (ee.pending + 2 > ee.pending_buf_size && M(D), ee.pending + 2 <= ee.pending_buf_size && (J(ee, 255 & D.adler), J(ee, D.adler >> 8 & 255), D.adler = 0, ee.status = x)) : ee.status = x), ee.pending !== 0) {
                if (M(D), D.avail_out === 0)
                  return ee.last_flush = -1, m;
              } else if (D.avail_in === 0 && T(ne) <= T(oe) && ne !== p)
                return F(D, -5);
              if (ee.status === 666 && D.avail_in !== 0)
                return F(D, -5);
              if (D.avail_in !== 0 || ee.lookahead !== 0 || ne !== d && ee.status !== 666) {
                var ie = ee.strategy === 2 ? function(ue, fe) {
                  for (var de; ; ) {
                    if (ue.lookahead === 0 && (G(ue), ue.lookahead === 0)) {
                      if (fe === d)
                        return f;
                      break;
                    }
                    if (ue.match_length = 0, de = h._tr_tally(ue, 0, ue.window[ue.strstart]), ue.lookahead--, ue.strstart++, de && (V(ue, !1), ue.strm.avail_out === 0))
                      return f;
                  }
                  return ue.insert = 0, fe === p ? (V(ue, !0), ue.strm.avail_out === 0 ? O : S) : ue.last_lit && (V(ue, !1), ue.strm.avail_out === 0) ? f : U;
                }(ee, ne) : ee.strategy === 3 ? function(ue, fe) {
                  for (var de, pe, xe, De, Ae = ue.window; ; ) {
                    if (ue.lookahead <= B) {
                      if (G(ue), ue.lookahead <= B && fe === d)
                        return f;
                      if (ue.lookahead === 0)
                        break;
                    }
                    if (ue.match_length = 0, ue.lookahead >= X && 0 < ue.strstart && (pe = Ae[xe = ue.strstart - 1]) === Ae[++xe] && pe === Ae[++xe] && pe === Ae[++xe]) {
                      De = ue.strstart + B;
                      do
                        ;
                      while (pe === Ae[++xe] && pe === Ae[++xe] && pe === Ae[++xe] && pe === Ae[++xe] && pe === Ae[++xe] && pe === Ae[++xe] && pe === Ae[++xe] && pe === Ae[++xe] && xe < De);
                      ue.match_length = B - (De - xe), ue.match_length > ue.lookahead && (ue.match_length = ue.lookahead);
                    }
                    if (ue.match_length >= X ? (de = h._tr_tally(ue, 1, ue.match_length - X), ue.lookahead -= ue.match_length, ue.strstart += ue.match_length, ue.match_length = 0) : (de = h._tr_tally(ue, 0, ue.window[ue.strstart]), ue.lookahead--, ue.strstart++), de && (V(ue, !1), ue.strm.avail_out === 0))
                      return f;
                  }
                  return ue.insert = 0, fe === p ? (V(ue, !0), ue.strm.avail_out === 0 ? O : S) : ue.last_lit && (V(ue, !1), ue.strm.avail_out === 0) ? f : U;
                }(ee, ne) : a[ee.level].func(ee, ne);
                if (ie !== O && ie !== S || (ee.status = 666), ie === f || ie === O)
                  return D.avail_out === 0 && (ee.last_flush = -1), m;
                if (ie === U && (ne === 1 ? h._tr_align(ee) : ne !== 5 && (h._tr_stored_block(ee, 0, 0, !1), ne === 3 && (I(ee.head), ee.lookahead === 0 && (ee.strstart = 0, ee.block_start = 0, ee.insert = 0))), M(D), D.avail_out === 0))
                  return ee.last_flush = -1, m;
              }
              return ne !== p ? m : ee.wrap <= 0 ? 1 : (ee.wrap === 2 ? (J(ee, 255 & D.adler), J(ee, D.adler >> 8 & 255), J(ee, D.adler >> 16 & 255), J(ee, D.adler >> 24 & 255), J(ee, 255 & D.total_in), J(ee, D.total_in >> 8 & 255), J(ee, D.total_in >> 16 & 255), J(ee, D.total_in >> 24 & 255)) : (W(ee, D.adler >>> 16), W(ee, 65535 & D.adler)), M(D), 0 < ee.wrap && (ee.wrap = -ee.wrap), ee.pending !== 0 ? m : 1);
            }, t.deflateEnd = function(D) {
              var ne;
              return D && D.state ? (ne = D.state.status) !== k && ne !== 69 && ne !== 73 && ne !== 91 && ne !== 103 && ne !== x && ne !== 666 ? F(D, g) : (D.state = null, ne === x ? F(D, -3) : m) : g;
            }, t.deflateSetDictionary = function(D, ne) {
              var oe, ee, $, E, H, ie, ue, fe, de = ne.length;
              if (!D || !D.state || (E = (oe = D.state).wrap) === 2 || E === 1 && oe.status !== k || oe.lookahead)
                return g;
              for (E === 1 && (D.adler = e(D.adler, ne, de, 0)), oe.wrap = 0, de >= oe.w_size && (E === 0 && (I(oe.head), oe.strstart = 0, oe.block_start = 0, oe.insert = 0), fe = new v.Buf8(oe.w_size), v.arraySet(fe, ne, de - oe.w_size, oe.w_size, 0), ne = fe, de = oe.w_size), H = D.avail_in, ie = D.next_in, ue = D.input, D.avail_in = de, D.next_in = 0, D.input = ne, G(oe); oe.lookahead >= X; ) {
                for (ee = oe.strstart, $ = oe.lookahead - (X - 1); oe.ins_h = (oe.ins_h << oe.hash_shift ^ oe.window[ee + X - 1]) & oe.hash_mask, oe.prev[ee & oe.w_mask] = oe.head[oe.ins_h], oe.head[oe.ins_h] = ee, ee++, --$; )
                  ;
                oe.strstart = ee, oe.lookahead = X - 1, G(oe);
              }
              return oe.strstart += oe.lookahead, oe.block_start = oe.strstart, oe.insert = oe.lookahead, oe.lookahead = 0, oe.match_length = oe.prev_length = X - 1, oe.match_available = 0, D.next_in = ie, D.input = ue, D.avail_in = H, oe.wrap = E, m;
            }, t.deflateInfo = "pako deflate (from Nodeca project)";
          }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(o, C, t) {
            C.exports = function() {
              this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
            };
          }, {}], 48: [function(o, C, t) {
            C.exports = function(a, v) {
              var h, e, y, c, d, p, m, g, n, i, l, u, w, _, b, A, Y, j, X, B, R, k, x, f, U;
              h = a.state, e = a.next_in, f = a.input, y = e + (a.avail_in - 5), c = a.next_out, U = a.output, d = c - (v - a.avail_out), p = c + (a.avail_out - 257), m = h.dmax, g = h.wsize, n = h.whave, i = h.wnext, l = h.window, u = h.hold, w = h.bits, _ = h.lencode, b = h.distcode, A = (1 << h.lenbits) - 1, Y = (1 << h.distbits) - 1;
              e:
                do {
                  w < 15 && (u += f[e++] << w, w += 8, u += f[e++] << w, w += 8), j = _[u & A];
                  t:
                    for (; ; ) {
                      if (u >>>= X = j >>> 24, w -= X, (X = j >>> 16 & 255) === 0)
                        U[c++] = 65535 & j;
                      else {
                        if (!(16 & X)) {
                          if (!(64 & X)) {
                            j = _[(65535 & j) + (u & (1 << X) - 1)];
                            continue t;
                          }
                          if (32 & X) {
                            h.mode = 12;
                            break e;
                          }
                          a.msg = "invalid literal/length code", h.mode = 30;
                          break e;
                        }
                        B = 65535 & j, (X &= 15) && (w < X && (u += f[e++] << w, w += 8), B += u & (1 << X) - 1, u >>>= X, w -= X), w < 15 && (u += f[e++] << w, w += 8, u += f[e++] << w, w += 8), j = b[u & Y];
                        n:
                          for (; ; ) {
                            if (u >>>= X = j >>> 24, w -= X, !(16 & (X = j >>> 16 & 255))) {
                              if (!(64 & X)) {
                                j = b[(65535 & j) + (u & (1 << X) - 1)];
                                continue n;
                              }
                              a.msg = "invalid distance code", h.mode = 30;
                              break e;
                            }
                            if (R = 65535 & j, w < (X &= 15) && (u += f[e++] << w, (w += 8) < X && (u += f[e++] << w, w += 8)), m < (R += u & (1 << X) - 1)) {
                              a.msg = "invalid distance too far back", h.mode = 30;
                              break e;
                            }
                            if (u >>>= X, w -= X, (X = c - d) < R) {
                              if (n < (X = R - X) && h.sane) {
                                a.msg = "invalid distance too far back", h.mode = 30;
                                break e;
                              }
                              if (x = l, (k = 0) === i) {
                                if (k += g - X, X < B) {
                                  for (B -= X; U[c++] = l[k++], --X; )
                                    ;
                                  k = c - R, x = U;
                                }
                              } else if (i < X) {
                                if (k += g + i - X, (X -= i) < B) {
                                  for (B -= X; U[c++] = l[k++], --X; )
                                    ;
                                  if (k = 0, i < B) {
                                    for (B -= X = i; U[c++] = l[k++], --X; )
                                      ;
                                    k = c - R, x = U;
                                  }
                                }
                              } else if (k += i - X, X < B) {
                                for (B -= X; U[c++] = l[k++], --X; )
                                  ;
                                k = c - R, x = U;
                              }
                              for (; 2 < B; )
                                U[c++] = x[k++], U[c++] = x[k++], U[c++] = x[k++], B -= 3;
                              B && (U[c++] = x[k++], 1 < B && (U[c++] = x[k++]));
                            } else {
                              for (k = c - R; U[c++] = U[k++], U[c++] = U[k++], U[c++] = U[k++], 2 < (B -= 3); )
                                ;
                              B && (U[c++] = U[k++], 1 < B && (U[c++] = U[k++]));
                            }
                            break;
                          }
                      }
                      break;
                    }
                } while (e < y && c < p);
              e -= B = w >> 3, u &= (1 << (w -= B << 3)) - 1, a.next_in = e, a.next_out = c, a.avail_in = e < y ? y - e + 5 : 5 - (e - y), a.avail_out = c < p ? p - c + 257 : 257 - (c - p), h.hold = u, h.bits = w;
            };
          }, {}], 49: [function(o, C, t) {
            var a = o("../utils/common"), v = o("./adler32"), h = o("./crc32"), e = o("./inffast"), y = o("./inftrees"), c = 1, d = 2, p = 0, m = -2, g = 1, n = 852, i = 592;
            function l(k) {
              return (k >>> 24 & 255) + (k >>> 8 & 65280) + ((65280 & k) << 8) + ((255 & k) << 24);
            }
            function u() {
              this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new a.Buf16(320), this.work = new a.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
            }
            function w(k) {
              var x;
              return k && k.state ? (x = k.state, k.total_in = k.total_out = x.total = 0, k.msg = "", x.wrap && (k.adler = 1 & x.wrap), x.mode = g, x.last = 0, x.havedict = 0, x.dmax = 32768, x.head = null, x.hold = 0, x.bits = 0, x.lencode = x.lendyn = new a.Buf32(n), x.distcode = x.distdyn = new a.Buf32(i), x.sane = 1, x.back = -1, p) : m;
            }
            function _(k) {
              var x;
              return k && k.state ? ((x = k.state).wsize = 0, x.whave = 0, x.wnext = 0, w(k)) : m;
            }
            function b(k, x) {
              var f, U;
              return k && k.state ? (U = k.state, x < 0 ? (f = 0, x = -x) : (f = 1 + (x >> 4), x < 48 && (x &= 15)), x && (x < 8 || 15 < x) ? m : (U.window !== null && U.wbits !== x && (U.window = null), U.wrap = f, U.wbits = x, _(k))) : m;
            }
            function A(k, x) {
              var f, U;
              return k ? (U = new u(), (k.state = U).window = null, (f = b(k, x)) !== p && (k.state = null), f) : m;
            }
            var Y, j, X = !0;
            function B(k) {
              if (X) {
                var x;
                for (Y = new a.Buf32(512), j = new a.Buf32(32), x = 0; x < 144; )
                  k.lens[x++] = 8;
                for (; x < 256; )
                  k.lens[x++] = 9;
                for (; x < 280; )
                  k.lens[x++] = 7;
                for (; x < 288; )
                  k.lens[x++] = 8;
                for (y(c, k.lens, 0, 288, Y, 0, k.work, { bits: 9 }), x = 0; x < 32; )
                  k.lens[x++] = 5;
                y(d, k.lens, 0, 32, j, 0, k.work, { bits: 5 }), X = !1;
              }
              k.lencode = Y, k.lenbits = 9, k.distcode = j, k.distbits = 5;
            }
            function R(k, x, f, U) {
              var O, S = k.state;
              return S.window === null && (S.wsize = 1 << S.wbits, S.wnext = 0, S.whave = 0, S.window = new a.Buf8(S.wsize)), U >= S.wsize ? (a.arraySet(S.window, x, f - S.wsize, S.wsize, 0), S.wnext = 0, S.whave = S.wsize) : (U < (O = S.wsize - S.wnext) && (O = U), a.arraySet(S.window, x, f - U, O, S.wnext), (U -= O) ? (a.arraySet(S.window, x, f - U, U, 0), S.wnext = U, S.whave = S.wsize) : (S.wnext += O, S.wnext === S.wsize && (S.wnext = 0), S.whave < S.wsize && (S.whave += O))), 0;
            }
            t.inflateReset = _, t.inflateReset2 = b, t.inflateResetKeep = w, t.inflateInit = function(k) {
              return A(k, 15);
            }, t.inflateInit2 = A, t.inflate = function(k, x) {
              var f, U, O, S, F, T, I, M, V, J, W, z, G, L, K, te, se, q, N, Q, D, ne, oe, ee, $ = 0, E = new a.Buf8(4), H = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
              if (!k || !k.state || !k.output || !k.input && k.avail_in !== 0)
                return m;
              (f = k.state).mode === 12 && (f.mode = 13), F = k.next_out, O = k.output, I = k.avail_out, S = k.next_in, U = k.input, T = k.avail_in, M = f.hold, V = f.bits, J = T, W = I, ne = p;
              e:
                for (; ; )
                  switch (f.mode) {
                    case g:
                      if (f.wrap === 0) {
                        f.mode = 13;
                        break;
                      }
                      for (; V < 16; ) {
                        if (T === 0)
                          break e;
                        T--, M += U[S++] << V, V += 8;
                      }
                      if (2 & f.wrap && M === 35615) {
                        E[f.check = 0] = 255 & M, E[1] = M >>> 8 & 255, f.check = h(f.check, E, 2, 0), V = M = 0, f.mode = 2;
                        break;
                      }
                      if (f.flags = 0, f.head && (f.head.done = !1), !(1 & f.wrap) || (((255 & M) << 8) + (M >> 8)) % 31) {
                        k.msg = "incorrect header check", f.mode = 30;
                        break;
                      }
                      if ((15 & M) != 8) {
                        k.msg = "unknown compression method", f.mode = 30;
                        break;
                      }
                      if (V -= 4, D = 8 + (15 & (M >>>= 4)), f.wbits === 0)
                        f.wbits = D;
                      else if (D > f.wbits) {
                        k.msg = "invalid window size", f.mode = 30;
                        break;
                      }
                      f.dmax = 1 << D, k.adler = f.check = 1, f.mode = 512 & M ? 10 : 12, V = M = 0;
                      break;
                    case 2:
                      for (; V < 16; ) {
                        if (T === 0)
                          break e;
                        T--, M += U[S++] << V, V += 8;
                      }
                      if (f.flags = M, (255 & f.flags) != 8) {
                        k.msg = "unknown compression method", f.mode = 30;
                        break;
                      }
                      if (57344 & f.flags) {
                        k.msg = "unknown header flags set", f.mode = 30;
                        break;
                      }
                      f.head && (f.head.text = M >> 8 & 1), 512 & f.flags && (E[0] = 255 & M, E[1] = M >>> 8 & 255, f.check = h(f.check, E, 2, 0)), V = M = 0, f.mode = 3;
                    case 3:
                      for (; V < 32; ) {
                        if (T === 0)
                          break e;
                        T--, M += U[S++] << V, V += 8;
                      }
                      f.head && (f.head.time = M), 512 & f.flags && (E[0] = 255 & M, E[1] = M >>> 8 & 255, E[2] = M >>> 16 & 255, E[3] = M >>> 24 & 255, f.check = h(f.check, E, 4, 0)), V = M = 0, f.mode = 4;
                    case 4:
                      for (; V < 16; ) {
                        if (T === 0)
                          break e;
                        T--, M += U[S++] << V, V += 8;
                      }
                      f.head && (f.head.xflags = 255 & M, f.head.os = M >> 8), 512 & f.flags && (E[0] = 255 & M, E[1] = M >>> 8 & 255, f.check = h(f.check, E, 2, 0)), V = M = 0, f.mode = 5;
                    case 5:
                      if (1024 & f.flags) {
                        for (; V < 16; ) {
                          if (T === 0)
                            break e;
                          T--, M += U[S++] << V, V += 8;
                        }
                        f.length = M, f.head && (f.head.extra_len = M), 512 & f.flags && (E[0] = 255 & M, E[1] = M >>> 8 & 255, f.check = h(f.check, E, 2, 0)), V = M = 0;
                      } else
                        f.head && (f.head.extra = null);
                      f.mode = 6;
                    case 6:
                      if (1024 & f.flags && (T < (z = f.length) && (z = T), z && (f.head && (D = f.head.extra_len - f.length, f.head.extra || (f.head.extra = new Array(f.head.extra_len)), a.arraySet(f.head.extra, U, S, z, D)), 512 & f.flags && (f.check = h(f.check, U, z, S)), T -= z, S += z, f.length -= z), f.length))
                        break e;
                      f.length = 0, f.mode = 7;
                    case 7:
                      if (2048 & f.flags) {
                        if (T === 0)
                          break e;
                        for (z = 0; D = U[S + z++], f.head && D && f.length < 65536 && (f.head.name += String.fromCharCode(D)), D && z < T; )
                          ;
                        if (512 & f.flags && (f.check = h(f.check, U, z, S)), T -= z, S += z, D)
                          break e;
                      } else
                        f.head && (f.head.name = null);
                      f.length = 0, f.mode = 8;
                    case 8:
                      if (4096 & f.flags) {
                        if (T === 0)
                          break e;
                        for (z = 0; D = U[S + z++], f.head && D && f.length < 65536 && (f.head.comment += String.fromCharCode(D)), D && z < T; )
                          ;
                        if (512 & f.flags && (f.check = h(f.check, U, z, S)), T -= z, S += z, D)
                          break e;
                      } else
                        f.head && (f.head.comment = null);
                      f.mode = 9;
                    case 9:
                      if (512 & f.flags) {
                        for (; V < 16; ) {
                          if (T === 0)
                            break e;
                          T--, M += U[S++] << V, V += 8;
                        }
                        if (M !== (65535 & f.check)) {
                          k.msg = "header crc mismatch", f.mode = 30;
                          break;
                        }
                        V = M = 0;
                      }
                      f.head && (f.head.hcrc = f.flags >> 9 & 1, f.head.done = !0), k.adler = f.check = 0, f.mode = 12;
                      break;
                    case 10:
                      for (; V < 32; ) {
                        if (T === 0)
                          break e;
                        T--, M += U[S++] << V, V += 8;
                      }
                      k.adler = f.check = l(M), V = M = 0, f.mode = 11;
                    case 11:
                      if (f.havedict === 0)
                        return k.next_out = F, k.avail_out = I, k.next_in = S, k.avail_in = T, f.hold = M, f.bits = V, 2;
                      k.adler = f.check = 1, f.mode = 12;
                    case 12:
                      if (x === 5 || x === 6)
                        break e;
                    case 13:
                      if (f.last) {
                        M >>>= 7 & V, V -= 7 & V, f.mode = 27;
                        break;
                      }
                      for (; V < 3; ) {
                        if (T === 0)
                          break e;
                        T--, M += U[S++] << V, V += 8;
                      }
                      switch (f.last = 1 & M, V -= 1, 3 & (M >>>= 1)) {
                        case 0:
                          f.mode = 14;
                          break;
                        case 1:
                          if (B(f), f.mode = 20, x !== 6)
                            break;
                          M >>>= 2, V -= 2;
                          break e;
                        case 2:
                          f.mode = 17;
                          break;
                        case 3:
                          k.msg = "invalid block type", f.mode = 30;
                      }
                      M >>>= 2, V -= 2;
                      break;
                    case 14:
                      for (M >>>= 7 & V, V -= 7 & V; V < 32; ) {
                        if (T === 0)
                          break e;
                        T--, M += U[S++] << V, V += 8;
                      }
                      if ((65535 & M) != (M >>> 16 ^ 65535)) {
                        k.msg = "invalid stored block lengths", f.mode = 30;
                        break;
                      }
                      if (f.length = 65535 & M, V = M = 0, f.mode = 15, x === 6)
                        break e;
                    case 15:
                      f.mode = 16;
                    case 16:
                      if (z = f.length) {
                        if (T < z && (z = T), I < z && (z = I), z === 0)
                          break e;
                        a.arraySet(O, U, S, z, F), T -= z, S += z, I -= z, F += z, f.length -= z;
                        break;
                      }
                      f.mode = 12;
                      break;
                    case 17:
                      for (; V < 14; ) {
                        if (T === 0)
                          break e;
                        T--, M += U[S++] << V, V += 8;
                      }
                      if (f.nlen = 257 + (31 & M), M >>>= 5, V -= 5, f.ndist = 1 + (31 & M), M >>>= 5, V -= 5, f.ncode = 4 + (15 & M), M >>>= 4, V -= 4, 286 < f.nlen || 30 < f.ndist) {
                        k.msg = "too many length or distance symbols", f.mode = 30;
                        break;
                      }
                      f.have = 0, f.mode = 18;
                    case 18:
                      for (; f.have < f.ncode; ) {
                        for (; V < 3; ) {
                          if (T === 0)
                            break e;
                          T--, M += U[S++] << V, V += 8;
                        }
                        f.lens[H[f.have++]] = 7 & M, M >>>= 3, V -= 3;
                      }
                      for (; f.have < 19; )
                        f.lens[H[f.have++]] = 0;
                      if (f.lencode = f.lendyn, f.lenbits = 7, oe = { bits: f.lenbits }, ne = y(0, f.lens, 0, 19, f.lencode, 0, f.work, oe), f.lenbits = oe.bits, ne) {
                        k.msg = "invalid code lengths set", f.mode = 30;
                        break;
                      }
                      f.have = 0, f.mode = 19;
                    case 19:
                      for (; f.have < f.nlen + f.ndist; ) {
                        for (; te = ($ = f.lencode[M & (1 << f.lenbits) - 1]) >>> 16 & 255, se = 65535 & $, !((K = $ >>> 24) <= V); ) {
                          if (T === 0)
                            break e;
                          T--, M += U[S++] << V, V += 8;
                        }
                        if (se < 16)
                          M >>>= K, V -= K, f.lens[f.have++] = se;
                        else {
                          if (se === 16) {
                            for (ee = K + 2; V < ee; ) {
                              if (T === 0)
                                break e;
                              T--, M += U[S++] << V, V += 8;
                            }
                            if (M >>>= K, V -= K, f.have === 0) {
                              k.msg = "invalid bit length repeat", f.mode = 30;
                              break;
                            }
                            D = f.lens[f.have - 1], z = 3 + (3 & M), M >>>= 2, V -= 2;
                          } else if (se === 17) {
                            for (ee = K + 3; V < ee; ) {
                              if (T === 0)
                                break e;
                              T--, M += U[S++] << V, V += 8;
                            }
                            V -= K, D = 0, z = 3 + (7 & (M >>>= K)), M >>>= 3, V -= 3;
                          } else {
                            for (ee = K + 7; V < ee; ) {
                              if (T === 0)
                                break e;
                              T--, M += U[S++] << V, V += 8;
                            }
                            V -= K, D = 0, z = 11 + (127 & (M >>>= K)), M >>>= 7, V -= 7;
                          }
                          if (f.have + z > f.nlen + f.ndist) {
                            k.msg = "invalid bit length repeat", f.mode = 30;
                            break;
                          }
                          for (; z--; )
                            f.lens[f.have++] = D;
                        }
                      }
                      if (f.mode === 30)
                        break;
                      if (f.lens[256] === 0) {
                        k.msg = "invalid code -- missing end-of-block", f.mode = 30;
                        break;
                      }
                      if (f.lenbits = 9, oe = { bits: f.lenbits }, ne = y(c, f.lens, 0, f.nlen, f.lencode, 0, f.work, oe), f.lenbits = oe.bits, ne) {
                        k.msg = "invalid literal/lengths set", f.mode = 30;
                        break;
                      }
                      if (f.distbits = 6, f.distcode = f.distdyn, oe = { bits: f.distbits }, ne = y(d, f.lens, f.nlen, f.ndist, f.distcode, 0, f.work, oe), f.distbits = oe.bits, ne) {
                        k.msg = "invalid distances set", f.mode = 30;
                        break;
                      }
                      if (f.mode = 20, x === 6)
                        break e;
                    case 20:
                      f.mode = 21;
                    case 21:
                      if (6 <= T && 258 <= I) {
                        k.next_out = F, k.avail_out = I, k.next_in = S, k.avail_in = T, f.hold = M, f.bits = V, e(k, W), F = k.next_out, O = k.output, I = k.avail_out, S = k.next_in, U = k.input, T = k.avail_in, M = f.hold, V = f.bits, f.mode === 12 && (f.back = -1);
                        break;
                      }
                      for (f.back = 0; te = ($ = f.lencode[M & (1 << f.lenbits) - 1]) >>> 16 & 255, se = 65535 & $, !((K = $ >>> 24) <= V); ) {
                        if (T === 0)
                          break e;
                        T--, M += U[S++] << V, V += 8;
                      }
                      if (te && !(240 & te)) {
                        for (q = K, N = te, Q = se; te = ($ = f.lencode[Q + ((M & (1 << q + N) - 1) >> q)]) >>> 16 & 255, se = 65535 & $, !(q + (K = $ >>> 24) <= V); ) {
                          if (T === 0)
                            break e;
                          T--, M += U[S++] << V, V += 8;
                        }
                        M >>>= q, V -= q, f.back += q;
                      }
                      if (M >>>= K, V -= K, f.back += K, f.length = se, te === 0) {
                        f.mode = 26;
                        break;
                      }
                      if (32 & te) {
                        f.back = -1, f.mode = 12;
                        break;
                      }
                      if (64 & te) {
                        k.msg = "invalid literal/length code", f.mode = 30;
                        break;
                      }
                      f.extra = 15 & te, f.mode = 22;
                    case 22:
                      if (f.extra) {
                        for (ee = f.extra; V < ee; ) {
                          if (T === 0)
                            break e;
                          T--, M += U[S++] << V, V += 8;
                        }
                        f.length += M & (1 << f.extra) - 1, M >>>= f.extra, V -= f.extra, f.back += f.extra;
                      }
                      f.was = f.length, f.mode = 23;
                    case 23:
                      for (; te = ($ = f.distcode[M & (1 << f.distbits) - 1]) >>> 16 & 255, se = 65535 & $, !((K = $ >>> 24) <= V); ) {
                        if (T === 0)
                          break e;
                        T--, M += U[S++] << V, V += 8;
                      }
                      if (!(240 & te)) {
                        for (q = K, N = te, Q = se; te = ($ = f.distcode[Q + ((M & (1 << q + N) - 1) >> q)]) >>> 16 & 255, se = 65535 & $, !(q + (K = $ >>> 24) <= V); ) {
                          if (T === 0)
                            break e;
                          T--, M += U[S++] << V, V += 8;
                        }
                        M >>>= q, V -= q, f.back += q;
                      }
                      if (M >>>= K, V -= K, f.back += K, 64 & te) {
                        k.msg = "invalid distance code", f.mode = 30;
                        break;
                      }
                      f.offset = se, f.extra = 15 & te, f.mode = 24;
                    case 24:
                      if (f.extra) {
                        for (ee = f.extra; V < ee; ) {
                          if (T === 0)
                            break e;
                          T--, M += U[S++] << V, V += 8;
                        }
                        f.offset += M & (1 << f.extra) - 1, M >>>= f.extra, V -= f.extra, f.back += f.extra;
                      }
                      if (f.offset > f.dmax) {
                        k.msg = "invalid distance too far back", f.mode = 30;
                        break;
                      }
                      f.mode = 25;
                    case 25:
                      if (I === 0)
                        break e;
                      if (z = W - I, f.offset > z) {
                        if ((z = f.offset - z) > f.whave && f.sane) {
                          k.msg = "invalid distance too far back", f.mode = 30;
                          break;
                        }
                        G = z > f.wnext ? (z -= f.wnext, f.wsize - z) : f.wnext - z, z > f.length && (z = f.length), L = f.window;
                      } else
                        L = O, G = F - f.offset, z = f.length;
                      for (I < z && (z = I), I -= z, f.length -= z; O[F++] = L[G++], --z; )
                        ;
                      f.length === 0 && (f.mode = 21);
                      break;
                    case 26:
                      if (I === 0)
                        break e;
                      O[F++] = f.length, I--, f.mode = 21;
                      break;
                    case 27:
                      if (f.wrap) {
                        for (; V < 32; ) {
                          if (T === 0)
                            break e;
                          T--, M |= U[S++] << V, V += 8;
                        }
                        if (W -= I, k.total_out += W, f.total += W, W && (k.adler = f.check = f.flags ? h(f.check, O, W, F - W) : v(f.check, O, W, F - W)), W = I, (f.flags ? M : l(M)) !== f.check) {
                          k.msg = "incorrect data check", f.mode = 30;
                          break;
                        }
                        V = M = 0;
                      }
                      f.mode = 28;
                    case 28:
                      if (f.wrap && f.flags) {
                        for (; V < 32; ) {
                          if (T === 0)
                            break e;
                          T--, M += U[S++] << V, V += 8;
                        }
                        if (M !== (4294967295 & f.total)) {
                          k.msg = "incorrect length check", f.mode = 30;
                          break;
                        }
                        V = M = 0;
                      }
                      f.mode = 29;
                    case 29:
                      ne = 1;
                      break e;
                    case 30:
                      ne = -3;
                      break e;
                    case 31:
                      return -4;
                    case 32:
                    default:
                      return m;
                  }
              return k.next_out = F, k.avail_out = I, k.next_in = S, k.avail_in = T, f.hold = M, f.bits = V, (f.wsize || W !== k.avail_out && f.mode < 30 && (f.mode < 27 || x !== 4)) && R(k, k.output, k.next_out, W - k.avail_out) ? (f.mode = 31, -4) : (J -= k.avail_in, W -= k.avail_out, k.total_in += J, k.total_out += W, f.total += W, f.wrap && W && (k.adler = f.check = f.flags ? h(f.check, O, W, k.next_out - W) : v(f.check, O, W, k.next_out - W)), k.data_type = f.bits + (f.last ? 64 : 0) + (f.mode === 12 ? 128 : 0) + (f.mode === 20 || f.mode === 15 ? 256 : 0), (J == 0 && W === 0 || x === 4) && ne === p && (ne = -5), ne);
            }, t.inflateEnd = function(k) {
              if (!k || !k.state)
                return m;
              var x = k.state;
              return x.window && (x.window = null), k.state = null, p;
            }, t.inflateGetHeader = function(k, x) {
              var f;
              return k && k.state && 2 & (f = k.state).wrap ? ((f.head = x).done = !1, p) : m;
            }, t.inflateSetDictionary = function(k, x) {
              var f, U = x.length;
              return k && k.state ? (f = k.state).wrap !== 0 && f.mode !== 11 ? m : f.mode === 11 && v(1, x, U, 0) !== f.check ? -3 : R(k, x, U, U) ? (f.mode = 31, -4) : (f.havedict = 1, p) : m;
            }, t.inflateInfo = "pako inflate (from Nodeca project)";
          }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(o, C, t) {
            var a = o("../utils/common"), v = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], h = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], e = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], y = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
            C.exports = function(c, d, p, m, g, n, i, l) {
              var u, w, _, b, A, Y, j, X, B, R = l.bits, k = 0, x = 0, f = 0, U = 0, O = 0, S = 0, F = 0, T = 0, I = 0, M = 0, V = null, J = 0, W = new a.Buf16(16), z = new a.Buf16(16), G = null, L = 0;
              for (k = 0; k <= 15; k++)
                W[k] = 0;
              for (x = 0; x < m; x++)
                W[d[p + x]]++;
              for (O = R, U = 15; 1 <= U && W[U] === 0; U--)
                ;
              if (U < O && (O = U), U === 0)
                return g[n++] = 20971520, g[n++] = 20971520, l.bits = 1, 0;
              for (f = 1; f < U && W[f] === 0; f++)
                ;
              for (O < f && (O = f), k = T = 1; k <= 15; k++)
                if (T <<= 1, (T -= W[k]) < 0)
                  return -1;
              if (0 < T && (c === 0 || U !== 1))
                return -1;
              for (z[1] = 0, k = 1; k < 15; k++)
                z[k + 1] = z[k] + W[k];
              for (x = 0; x < m; x++)
                d[p + x] !== 0 && (i[z[d[p + x]]++] = x);
              if (Y = c === 0 ? (V = G = i, 19) : c === 1 ? (V = v, J -= 257, G = h, L -= 257, 256) : (V = e, G = y, -1), k = f, A = n, F = x = M = 0, _ = -1, b = (I = 1 << (S = O)) - 1, c === 1 && 852 < I || c === 2 && 592 < I)
                return 1;
              for (; ; ) {
                for (j = k - F, B = i[x] < Y ? (X = 0, i[x]) : i[x] > Y ? (X = G[L + i[x]], V[J + i[x]]) : (X = 96, 0), u = 1 << k - F, f = w = 1 << S; g[A + (M >> F) + (w -= u)] = j << 24 | X << 16 | B | 0, w !== 0; )
                  ;
                for (u = 1 << k - 1; M & u; )
                  u >>= 1;
                if (u !== 0 ? (M &= u - 1, M += u) : M = 0, x++, --W[k] == 0) {
                  if (k === U)
                    break;
                  k = d[p + i[x]];
                }
                if (O < k && (M & b) !== _) {
                  for (F === 0 && (F = O), A += f, T = 1 << (S = k - F); S + F < U && !((T -= W[S + F]) <= 0); )
                    S++, T <<= 1;
                  if (I += 1 << S, c === 1 && 852 < I || c === 2 && 592 < I)
                    return 1;
                  g[_ = M & b] = O << 24 | S << 16 | A - n | 0;
                }
              }
              return M !== 0 && (g[A + M] = k - F << 24 | 64 << 16 | 0), l.bits = O, 0;
            };
          }, { "../utils/common": 41 }], 51: [function(o, C, t) {
            C.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
          }, {}], 52: [function(o, C, t) {
            var a = o("../utils/common"), v = 0, h = 1;
            function e($) {
              for (var E = $.length; 0 <= --E; )
                $[E] = 0;
            }
            var y = 0, c = 29, d = 256, p = d + 1 + c, m = 30, g = 19, n = 2 * p + 1, i = 15, l = 16, u = 7, w = 256, _ = 16, b = 17, A = 18, Y = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], j = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], X = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], B = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], R = new Array(2 * (p + 2));
            e(R);
            var k = new Array(2 * m);
            e(k);
            var x = new Array(512);
            e(x);
            var f = new Array(256);
            e(f);
            var U = new Array(c);
            e(U);
            var O, S, F, T = new Array(m);
            function I($, E, H, ie, ue) {
              this.static_tree = $, this.extra_bits = E, this.extra_base = H, this.elems = ie, this.max_length = ue, this.has_stree = $ && $.length;
            }
            function M($, E) {
              this.dyn_tree = $, this.max_code = 0, this.stat_desc = E;
            }
            function V($) {
              return $ < 256 ? x[$] : x[256 + ($ >>> 7)];
            }
            function J($, E) {
              $.pending_buf[$.pending++] = 255 & E, $.pending_buf[$.pending++] = E >>> 8 & 255;
            }
            function W($, E, H) {
              $.bi_valid > l - H ? ($.bi_buf |= E << $.bi_valid & 65535, J($, $.bi_buf), $.bi_buf = E >> l - $.bi_valid, $.bi_valid += H - l) : ($.bi_buf |= E << $.bi_valid & 65535, $.bi_valid += H);
            }
            function z($, E, H) {
              W($, H[2 * E], H[2 * E + 1]);
            }
            function G($, E) {
              for (var H = 0; H |= 1 & $, $ >>>= 1, H <<= 1, 0 < --E; )
                ;
              return H >>> 1;
            }
            function L($, E, H) {
              var ie, ue, fe = new Array(i + 1), de = 0;
              for (ie = 1; ie <= i; ie++)
                fe[ie] = de = de + H[ie - 1] << 1;
              for (ue = 0; ue <= E; ue++) {
                var pe = $[2 * ue + 1];
                pe !== 0 && ($[2 * ue] = G(fe[pe]++, pe));
              }
            }
            function K($) {
              var E;
              for (E = 0; E < p; E++)
                $.dyn_ltree[2 * E] = 0;
              for (E = 0; E < m; E++)
                $.dyn_dtree[2 * E] = 0;
              for (E = 0; E < g; E++)
                $.bl_tree[2 * E] = 0;
              $.dyn_ltree[2 * w] = 1, $.opt_len = $.static_len = 0, $.last_lit = $.matches = 0;
            }
            function te($) {
              8 < $.bi_valid ? J($, $.bi_buf) : 0 < $.bi_valid && ($.pending_buf[$.pending++] = $.bi_buf), $.bi_buf = 0, $.bi_valid = 0;
            }
            function se($, E, H, ie) {
              var ue = 2 * E, fe = 2 * H;
              return $[ue] < $[fe] || $[ue] === $[fe] && ie[E] <= ie[H];
            }
            function q($, E, H) {
              for (var ie = $.heap[H], ue = H << 1; ue <= $.heap_len && (ue < $.heap_len && se(E, $.heap[ue + 1], $.heap[ue], $.depth) && ue++, !se(E, ie, $.heap[ue], $.depth)); )
                $.heap[H] = $.heap[ue], H = ue, ue <<= 1;
              $.heap[H] = ie;
            }
            function N($, E, H) {
              var ie, ue, fe, de, pe = 0;
              if ($.last_lit !== 0)
                for (; ie = $.pending_buf[$.d_buf + 2 * pe] << 8 | $.pending_buf[$.d_buf + 2 * pe + 1], ue = $.pending_buf[$.l_buf + pe], pe++, ie === 0 ? z($, ue, E) : (z($, (fe = f[ue]) + d + 1, E), (de = Y[fe]) !== 0 && W($, ue -= U[fe], de), z($, fe = V(--ie), H), (de = j[fe]) !== 0 && W($, ie -= T[fe], de)), pe < $.last_lit; )
                  ;
              z($, w, E);
            }
            function Q($, E) {
              var H, ie, ue, fe = E.dyn_tree, de = E.stat_desc.static_tree, pe = E.stat_desc.has_stree, xe = E.stat_desc.elems, De = -1;
              for ($.heap_len = 0, $.heap_max = n, H = 0; H < xe; H++)
                fe[2 * H] !== 0 ? ($.heap[++$.heap_len] = De = H, $.depth[H] = 0) : fe[2 * H + 1] = 0;
              for (; $.heap_len < 2; )
                fe[2 * (ue = $.heap[++$.heap_len] = De < 2 ? ++De : 0)] = 1, $.depth[ue] = 0, $.opt_len--, pe && ($.static_len -= de[2 * ue + 1]);
              for (E.max_code = De, H = $.heap_len >> 1; 1 <= H; H--)
                q($, fe, H);
              for (ue = xe; H = $.heap[1], $.heap[1] = $.heap[$.heap_len--], q($, fe, 1), ie = $.heap[1], $.heap[--$.heap_max] = H, $.heap[--$.heap_max] = ie, fe[2 * ue] = fe[2 * H] + fe[2 * ie], $.depth[ue] = ($.depth[H] >= $.depth[ie] ? $.depth[H] : $.depth[ie]) + 1, fe[2 * H + 1] = fe[2 * ie + 1] = ue, $.heap[1] = ue++, q($, fe, 1), 2 <= $.heap_len; )
                ;
              $.heap[--$.heap_max] = $.heap[1], function(Ae, Se) {
                var ke, ye, _e, we, Ce, ve, Le = Se.dyn_tree, He = Se.max_code, Qe = Se.stat_desc.static_tree, Ue = Se.stat_desc.has_stree, Ie = Se.stat_desc.extra_bits, Ee = Se.stat_desc.extra_base, et = Se.stat_desc.max_length, qe = 0;
                for (we = 0; we <= i; we++)
                  Ae.bl_count[we] = 0;
                for (Le[2 * Ae.heap[Ae.heap_max] + 1] = 0, ke = Ae.heap_max + 1; ke < n; ke++)
                  et < (we = Le[2 * Le[2 * (ye = Ae.heap[ke]) + 1] + 1] + 1) && (we = et, qe++), Le[2 * ye + 1] = we, He < ye || (Ae.bl_count[we]++, Ce = 0, Ee <= ye && (Ce = Ie[ye - Ee]), ve = Le[2 * ye], Ae.opt_len += ve * (we + Ce), Ue && (Ae.static_len += ve * (Qe[2 * ye + 1] + Ce)));
                if (qe !== 0) {
                  do {
                    for (we = et - 1; Ae.bl_count[we] === 0; )
                      we--;
                    Ae.bl_count[we]--, Ae.bl_count[we + 1] += 2, Ae.bl_count[et]--, qe -= 2;
                  } while (0 < qe);
                  for (we = et; we !== 0; we--)
                    for (ye = Ae.bl_count[we]; ye !== 0; )
                      He < (_e = Ae.heap[--ke]) || (Le[2 * _e + 1] !== we && (Ae.opt_len += (we - Le[2 * _e + 1]) * Le[2 * _e], Le[2 * _e + 1] = we), ye--);
                }
              }($, E), L(fe, De, $.bl_count);
            }
            function D($, E, H) {
              var ie, ue, fe = -1, de = E[1], pe = 0, xe = 7, De = 4;
              for (de === 0 && (xe = 138, De = 3), E[2 * (H + 1) + 1] = 65535, ie = 0; ie <= H; ie++)
                ue = de, de = E[2 * (ie + 1) + 1], ++pe < xe && ue === de || (pe < De ? $.bl_tree[2 * ue] += pe : ue !== 0 ? (ue !== fe && $.bl_tree[2 * ue]++, $.bl_tree[2 * _]++) : pe <= 10 ? $.bl_tree[2 * b]++ : $.bl_tree[2 * A]++, fe = ue, De = (pe = 0) === de ? (xe = 138, 3) : ue === de ? (xe = 6, 3) : (xe = 7, 4));
            }
            function ne($, E, H) {
              var ie, ue, fe = -1, de = E[1], pe = 0, xe = 7, De = 4;
              for (de === 0 && (xe = 138, De = 3), ie = 0; ie <= H; ie++)
                if (ue = de, de = E[2 * (ie + 1) + 1], !(++pe < xe && ue === de)) {
                  if (pe < De)
                    for (; z($, ue, $.bl_tree), --pe != 0; )
                      ;
                  else
                    ue !== 0 ? (ue !== fe && (z($, ue, $.bl_tree), pe--), z($, _, $.bl_tree), W($, pe - 3, 2)) : pe <= 10 ? (z($, b, $.bl_tree), W($, pe - 3, 3)) : (z($, A, $.bl_tree), W($, pe - 11, 7));
                  fe = ue, De = (pe = 0) === de ? (xe = 138, 3) : ue === de ? (xe = 6, 3) : (xe = 7, 4);
                }
            }
            e(T);
            var oe = !1;
            function ee($, E, H, ie) {
              W($, (y << 1) + (ie ? 1 : 0), 3), function(ue, fe, de, pe) {
                te(ue), pe && (J(ue, de), J(ue, ~de)), a.arraySet(ue.pending_buf, ue.window, fe, de, ue.pending), ue.pending += de;
              }($, E, H, !0);
            }
            t._tr_init = function($) {
              oe || (function() {
                var E, H, ie, ue, fe, de = new Array(i + 1);
                for (ue = ie = 0; ue < c - 1; ue++)
                  for (U[ue] = ie, E = 0; E < 1 << Y[ue]; E++)
                    f[ie++] = ue;
                for (f[ie - 1] = ue, ue = fe = 0; ue < 16; ue++)
                  for (T[ue] = fe, E = 0; E < 1 << j[ue]; E++)
                    x[fe++] = ue;
                for (fe >>= 7; ue < m; ue++)
                  for (T[ue] = fe << 7, E = 0; E < 1 << j[ue] - 7; E++)
                    x[256 + fe++] = ue;
                for (H = 0; H <= i; H++)
                  de[H] = 0;
                for (E = 0; E <= 143; )
                  R[2 * E + 1] = 8, E++, de[8]++;
                for (; E <= 255; )
                  R[2 * E + 1] = 9, E++, de[9]++;
                for (; E <= 279; )
                  R[2 * E + 1] = 7, E++, de[7]++;
                for (; E <= 287; )
                  R[2 * E + 1] = 8, E++, de[8]++;
                for (L(R, p + 1, de), E = 0; E < m; E++)
                  k[2 * E + 1] = 5, k[2 * E] = G(E, 5);
                O = new I(R, Y, d + 1, p, i), S = new I(k, j, 0, m, i), F = new I(new Array(0), X, 0, g, u);
              }(), oe = !0), $.l_desc = new M($.dyn_ltree, O), $.d_desc = new M($.dyn_dtree, S), $.bl_desc = new M($.bl_tree, F), $.bi_buf = 0, $.bi_valid = 0, K($);
            }, t._tr_stored_block = ee, t._tr_flush_block = function($, E, H, ie) {
              var ue, fe, de = 0;
              0 < $.level ? ($.strm.data_type === 2 && ($.strm.data_type = function(pe) {
                var xe, De = 4093624447;
                for (xe = 0; xe <= 31; xe++, De >>>= 1)
                  if (1 & De && pe.dyn_ltree[2 * xe] !== 0)
                    return v;
                if (pe.dyn_ltree[18] !== 0 || pe.dyn_ltree[20] !== 0 || pe.dyn_ltree[26] !== 0)
                  return h;
                for (xe = 32; xe < d; xe++)
                  if (pe.dyn_ltree[2 * xe] !== 0)
                    return h;
                return v;
              }($)), Q($, $.l_desc), Q($, $.d_desc), de = function(pe) {
                var xe;
                for (D(pe, pe.dyn_ltree, pe.l_desc.max_code), D(pe, pe.dyn_dtree, pe.d_desc.max_code), Q(pe, pe.bl_desc), xe = g - 1; 3 <= xe && pe.bl_tree[2 * B[xe] + 1] === 0; xe--)
                  ;
                return pe.opt_len += 3 * (xe + 1) + 5 + 5 + 4, xe;
              }($), ue = $.opt_len + 3 + 7 >>> 3, (fe = $.static_len + 3 + 7 >>> 3) <= ue && (ue = fe)) : ue = fe = H + 5, H + 4 <= ue && E !== -1 ? ee($, E, H, ie) : $.strategy === 4 || fe === ue ? (W($, 2 + (ie ? 1 : 0), 3), N($, R, k)) : (W($, 4 + (ie ? 1 : 0), 3), function(pe, xe, De, Ae) {
                var Se;
                for (W(pe, xe - 257, 5), W(pe, De - 1, 5), W(pe, Ae - 4, 4), Se = 0; Se < Ae; Se++)
                  W(pe, pe.bl_tree[2 * B[Se] + 1], 3);
                ne(pe, pe.dyn_ltree, xe - 1), ne(pe, pe.dyn_dtree, De - 1);
              }($, $.l_desc.max_code + 1, $.d_desc.max_code + 1, de + 1), N($, $.dyn_ltree, $.dyn_dtree)), K($), ie && te($);
            }, t._tr_tally = function($, E, H) {
              return $.pending_buf[$.d_buf + 2 * $.last_lit] = E >>> 8 & 255, $.pending_buf[$.d_buf + 2 * $.last_lit + 1] = 255 & E, $.pending_buf[$.l_buf + $.last_lit] = 255 & H, $.last_lit++, E === 0 ? $.dyn_ltree[2 * H]++ : ($.matches++, E--, $.dyn_ltree[2 * (f[H] + d + 1)]++, $.dyn_dtree[2 * V(E)]++), $.last_lit === $.lit_bufsize - 1;
            }, t._tr_align = function($) {
              W($, 2, 3), z($, w, R), function(E) {
                E.bi_valid === 16 ? (J(E, E.bi_buf), E.bi_buf = 0, E.bi_valid = 0) : 8 <= E.bi_valid && (E.pending_buf[E.pending++] = 255 & E.bi_buf, E.bi_buf >>= 8, E.bi_valid -= 8);
              }($);
            };
          }, { "../utils/common": 41 }], 53: [function(o, C, t) {
            C.exports = function() {
              this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
            };
          }, {}], 54: [function(o, C, t) {
            C.exports = typeof setImmediate == "function" ? setImmediate : function() {
              var a = [].slice.apply(arguments);
              a.splice(1, 0, 0), setTimeout.apply(null, a);
            };
          }, {}] }, {}, [10])(10);
        });
      }).call(this, typeof commonjsGlobal < "u" ? commonjsGlobal : typeof self < "u" ? self : typeof window < "u" ? window : {}, le("buffer").Buffer);
    }, { buffer: 78 }], 88: [function(le, ce, re) {
      re.Parser = le("./lib/parser").Parser, re.rules = le("./lib/rules"), re.errors = le("./lib/errors"), re.results = le("./lib/parsing-results"), re.StringSource = le("./lib/StringSource"), re.Token = le("./lib/Token"), re.bottomUp = le("./lib/bottom-up"), re.RegexTokeniser = le("./lib/regex-tokeniser").RegexTokeniser, re.rule = function(ae) {
        var Z;
        return function(o) {
          return Z || (Z = ae()), Z(o);
        };
      };
    }, { "./lib/StringSource": 89, "./lib/Token": 90, "./lib/bottom-up": 92, "./lib/errors": 93, "./lib/parser": 95, "./lib/parsing-results": 96, "./lib/regex-tokeniser": 97, "./lib/rules": 98 }], 89: [function(le, ce, re) {
      var ae = le("util");
      ce.exports = function(o, C) {
        var t = {
          asString: function() {
            return o;
          },
          range: function(a, v) {
            return new Z(o, C, a, v);
          }
        };
        return t;
      };
      var Z = function(o, C, t, a) {
        this._string = o, this._description = C, this._startIndex = t, this._endIndex = a;
      };
      Z.prototype.to = function(o) {
        return new Z(this._string, this._description, this._startIndex, o._endIndex);
      }, Z.prototype.describe = function() {
        var o = this._position(), C = this._description ? this._description + `
` : "";
        return ae.format(
          `%sLine number: %s
Character number: %s`,
          C,
          o.lineNumber,
          o.characterNumber
        );
      }, Z.prototype.lineNumber = function() {
        return this._position().lineNumber;
      }, Z.prototype.characterNumber = function() {
        return this._position().characterNumber;
      }, Z.prototype._position = function() {
        for (var o = this, C = 0, t = function() {
          return o._string.indexOf(`
`, C);
        }, a = 1; t() !== -1 && t() < this._startIndex; )
          C = t() + 1, a += 1;
        var v = this._startIndex - C + 1;
        return { lineNumber: a, characterNumber: v };
      };
    }, { util: 121 }], 90: [function(le, ce, re) {
      ce.exports = function(ae, Z, o) {
        this.name = ae, this.value = Z, o && (this.source = o);
      };
    }, {}], 91: [function(le, ce, re) {
      var ae = ce.exports = function(Z, o) {
        this._tokens = Z, this._startIndex = o || 0;
      };
      ae.prototype.head = function() {
        return this._tokens[this._startIndex];
      }, ae.prototype.tail = function(Z) {
        return new ae(this._tokens, this._startIndex + 1);
      }, ae.prototype.toArray = function() {
        return this._tokens.slice(this._startIndex);
      }, ae.prototype.end = function() {
        return this._tokens[this._tokens.length - 1];
      }, ae.prototype.to = function(Z) {
        var o = this.head().source, C = Z.head() || Z.end();
        return o.to(C.source);
      };
    }, {}], 92: [function(le, ce, re) {
      var ae = le("./rules"), Z = le("./parsing-results");
      re.parser = function(t, a, v) {
        var h = {
          rule: d,
          leftAssociative: p,
          rightAssociative: m
        }, e = new o(v.map(c)), y = ae.firstOf(t, a);
        function c(i) {
          return {
            name: i.name,
            rule: C(i.ruleBuilder.bind(null, h))
          };
        }
        function d() {
          return g(e);
        }
        function p(i) {
          return g(e.untilExclusive(i));
        }
        function m(i) {
          return g(e.untilInclusive(i));
        }
        function g(i) {
          return n.bind(null, i);
        }
        function n(i, l) {
          var u = y(l);
          return u.isSuccess() ? i.apply(u) : u;
        }
        return h;
      };
      function o(t) {
        function a(c) {
          return new o(t.slice(0, h().indexOf(c)));
        }
        function v(c) {
          return new o(t.slice(0, h().indexOf(c) + 1));
        }
        function h() {
          return t.map(function(c) {
            return c.name;
          });
        }
        function e(c) {
          for (var d, p; ; )
            if (d = y(c.remaining()), d.isSuccess())
              p = c.source().to(d.source()), c = Z.success(
                d.value()(c.value(), p),
                d.remaining(),
                p
              );
            else
              return d.isFailure() ? c : d;
        }
        function y(c) {
          return ae.firstOf("infix", t.map(function(d) {
            return d.rule;
          }))(c);
        }
        return {
          apply: e,
          untilExclusive: a,
          untilInclusive: v
        };
      }
      re.infix = function(t, a) {
        function v(h) {
          return re.infix(t, function(e) {
            var y = a(e);
            return function(c) {
              var d = y(c);
              return d.map(function(p) {
                return function(m, g) {
                  return h(m, p, g);
                };
              });
            };
          });
        }
        return {
          name: t,
          ruleBuilder: a,
          map: v
        };
      };
      var C = function(t) {
        var a;
        return function(v) {
          return a || (a = t()), a(v);
        };
      };
    }, { "./parsing-results": 96, "./rules": 98 }], 93: [function(le, ce, re) {
      re.error = function(Z) {
        return new ae(Z);
      };
      var ae = function(Z) {
        this.expected = Z.expected, this.actual = Z.actual, this._location = Z.location;
      };
      ae.prototype.describe = function() {
        var Z = this._location ? this._location.describe() + `:
` : "";
        return Z + "Expected " + this.expected + `
but got ` + this.actual;
      }, ae.prototype.lineNumber = function() {
        return this._location.lineNumber();
      }, ae.prototype.characterNumber = function() {
        return this._location.characterNumber();
      };
    }, {}], 94: [function(le, ce, re) {
      re.fromArray = function(Z) {
        var o = 0, C = function() {
          return o < Z.length;
        };
        return new ae({
          hasNext: C,
          next: function() {
            if (C())
              return Z[o++];
            throw new Error("No more elements");
          }
        });
      };
      var ae = function(Z) {
        this._iterator = Z;
      };
      ae.prototype.map = function(Z) {
        var o = this._iterator;
        return new ae({
          hasNext: function() {
            return o.hasNext();
          },
          next: function() {
            return Z(o.next());
          }
        });
      }, ae.prototype.filter = function(Z) {
        var o = this._iterator, C = !1, t = !1, a, v = function() {
          if (!C)
            for (C = !0, t = !1; o.hasNext() && !t; )
              a = o.next(), t = Z(a);
        };
        return new ae({
          hasNext: function() {
            return v(), t;
          },
          next: function() {
            v();
            var h = a;
            return C = !1, h;
          }
        });
      }, ae.prototype.first = function() {
        var Z = this._iterator;
        return this._iterator.hasNext() ? Z.next() : null;
      }, ae.prototype.toArray = function() {
        for (var Z = []; this._iterator.hasNext(); )
          Z.push(this._iterator.next());
        return Z;
      };
    }, {}], 95: [function(le, ce, re) {
      var ae = le("./TokenIterator");
      re.Parser = function(Z) {
        var o = function(C, t) {
          return C(new ae(t));
        };
        return {
          parseTokens: o
        };
      };
    }, { "./TokenIterator": 91 }], 96: [function(le, ce, re) {
      ce.exports = {
        failure: function(Z, o) {
          if (Z.length < 1)
            throw new Error("Failure must have errors");
          return new ae({
            status: "failure",
            remaining: o,
            errors: Z
          });
        },
        error: function(Z, o) {
          if (Z.length < 1)
            throw new Error("Failure must have errors");
          return new ae({
            status: "error",
            remaining: o,
            errors: Z
          });
        },
        success: function(Z, o, C) {
          return new ae({
            status: "success",
            value: Z,
            source: C,
            remaining: o,
            errors: []
          });
        },
        cut: function(Z) {
          return new ae({
            status: "cut",
            remaining: Z,
            errors: []
          });
        }
      };
      var ae = function(Z) {
        this._value = Z.value, this._status = Z.status, this._hasValue = Z.value !== void 0, this._remaining = Z.remaining, this._source = Z.source, this._errors = Z.errors;
      };
      ae.prototype.map = function(Z) {
        return this._hasValue ? new ae({
          value: Z(this._value, this._source),
          status: this._status,
          remaining: this._remaining,
          source: this._source,
          errors: this._errors
        }) : this;
      }, ae.prototype.changeRemaining = function(Z) {
        return new ae({
          value: this._value,
          status: this._status,
          remaining: Z,
          source: this._source,
          errors: this._errors
        });
      }, ae.prototype.isSuccess = function() {
        return this._status === "success" || this._status === "cut";
      }, ae.prototype.isFailure = function() {
        return this._status === "failure";
      }, ae.prototype.isError = function() {
        return this._status === "error";
      }, ae.prototype.isCut = function() {
        return this._status === "cut";
      }, ae.prototype.value = function() {
        return this._value;
      }, ae.prototype.remaining = function() {
        return this._remaining;
      }, ae.prototype.source = function() {
        return this._source;
      }, ae.prototype.errors = function() {
        return this._errors;
      };
    }, {}], 97: [function(le, ce, re) {
      var ae = le("./Token"), Z = le("./StringSource");
      re.RegexTokeniser = o;
      function o(C) {
        C = C.map(function(h) {
          return {
            name: h.name,
            regex: new RegExp(h.regex.source, "g")
          };
        });
        function t(h, e) {
          for (var y = new Z(h, e), c = 0, d = []; c < h.length; ) {
            var p = a(h, c, y);
            c = p.endIndex, d.push(p.token);
          }
          return d.push(v(h, y)), d;
        }
        function a(h, e, y) {
          for (var c = 0; c < C.length; c++) {
            var d = C[c].regex;
            d.lastIndex = e;
            var p = d.exec(h);
            if (p) {
              var g = e + p[0].length;
              if (p.index === e && g > e) {
                var m = p[1], n = new ae(
                  C[c].name,
                  m,
                  y.range(e, g)
                );
                return { token: n, endIndex: g };
              }
            }
          }
          var g = e + 1, n = new ae(
            "unrecognisedCharacter",
            h.substring(e, g),
            y.range(e, g)
          );
          return { token: n, endIndex: g };
        }
        function v(h, e) {
          return new ae(
            "end",
            null,
            e.range(h.length, h.length)
          );
        }
        return {
          tokenise: t
        };
      }
    }, { "./StringSource": 89, "./Token": 90 }], 98: [function(le, ce, re) {
      var ae = le("underscore"), Z = le("option"), o = le("./parsing-results"), C = le("./errors"), t = le("./lazy-iterators");
      re.token = function(d, p) {
        var m = p !== void 0;
        return function(g) {
          var n = g.head();
          if (n && n.name === d && (!m || n.value === p))
            return o.success(n.value, g.tail(), n.source);
          var i = y({ name: d, value: p });
          return c(g, i);
        };
      }, re.tokenOfType = function(d) {
        return re.token(d);
      }, re.firstOf = function(d, p) {
        return ae.isArray(p) || (p = Array.prototype.slice.call(arguments, 1)), function(m) {
          return t.fromArray(p).map(function(g) {
            return g(m);
          }).filter(function(g) {
            return g.isSuccess() || g.isError();
          }).first() || c(m, d);
        };
      }, re.then = function(d, p) {
        return function(m) {
          var g = d(m);
          return g.map || console.log(g), g.map(p);
        };
      }, re.sequence = function() {
        var d = Array.prototype.slice.call(arguments, 0), p = function(g) {
          var n = ae.foldl(d, function(l, u) {
            var w = l.result, _ = l.hasCut;
            if (!w.isSuccess())
              return { result: w, hasCut: _ };
            var b = u(w.remaining());
            if (b.isCut())
              return { result: w, hasCut: !0 };
            if (b.isSuccess()) {
              var A;
              u.isCaptured ? A = w.value().withValue(u, b.value()) : A = w.value();
              var Y = b.remaining(), j = g.to(Y);
              return {
                result: o.success(A, Y, j),
                hasCut: _
              };
            } else
              return _ ? { result: o.error(b.errors(), b.remaining()), hasCut: _ } : { result: b, hasCut: _ };
          }, { result: o.success(new a(), g), hasCut: !1 }).result, i = g.to(n.remaining());
          return n.map(function(l) {
            return l.withValue(re.sequence.source, i);
          });
        };
        p.head = function() {
          var g = ae.find(d, m);
          return re.then(
            p,
            re.sequence.extract(g)
          );
        }, p.map = function(g) {
          return re.then(
            p,
            function(n) {
              return g.apply(this, n.toArray());
            }
          );
        };
        function m(g) {
          return g.isCaptured;
        }
        return p;
      };
      var a = function(d, p) {
        this._values = d || {}, this._valuesArray = p || [];
      };
      a.prototype.withValue = function(d, p) {
        if (d.captureName && d.captureName in this._values)
          throw new Error('Cannot add second value for capture "' + d.captureName + '"');
        var m = ae.clone(this._values);
        m[d.captureName] = p;
        var g = this._valuesArray.concat([p]);
        return new a(m, g);
      }, a.prototype.get = function(d) {
        if (d.captureName in this._values)
          return this._values[d.captureName];
        throw new Error('No value for capture "' + d.captureName + '"');
      }, a.prototype.toArray = function() {
        return this._valuesArray;
      }, re.sequence.capture = function(d, p) {
        var m = function() {
          return d.apply(this, arguments);
        };
        return m.captureName = p, m.isCaptured = !0, m;
      }, re.sequence.extract = function(d) {
        return function(p) {
          return p.get(d);
        };
      }, re.sequence.applyValues = function(d) {
        var p = Array.prototype.slice.call(arguments, 1);
        return function(m) {
          var g = p.map(function(n) {
            return m.get(n);
          });
          return d.apply(this, g);
        };
      }, re.sequence.source = {
        captureName: "☃source☃"
      }, re.sequence.cut = function() {
        return function(d) {
          return o.cut(d);
        };
      }, re.optional = function(d) {
        return function(p) {
          var m = d(p);
          return m.isSuccess() ? m.map(Z.some) : m.isFailure() ? o.success(Z.none, p) : m;
        };
      }, re.zeroOrMoreWithSeparator = function(d, p) {
        return e(d, p, !1);
      }, re.oneOrMoreWithSeparator = function(d, p) {
        return e(d, p, !0);
      };
      var v = re.zeroOrMore = function(d) {
        return function(p) {
          for (var m = [], g; (g = d(p)) && g.isSuccess(); )
            p = g.remaining(), m.push(g.value());
          return g.isError() ? g : o.success(m, p);
        };
      };
      re.oneOrMore = function(d) {
        return re.oneOrMoreWithSeparator(d, h);
      };
      function h(d) {
        return o.success(null, d);
      }
      var e = function(d, p, m) {
        return function(g) {
          var n = d(g);
          if (n.isSuccess()) {
            var i = re.sequence.capture(d, "main"), l = v(re.then(
              re.sequence(p, i),
              re.sequence.extract(i)
            )), u = l(n.remaining());
            return o.success([n.value()].concat(u.value()), u.remaining());
          } else
            return m || n.isError() ? n : o.success([], g);
        };
      };
      re.leftAssociative = function(d, p, m) {
        var g;
        m ? g = [{ func: m, rule: p }] : g = p, g = g.map(function(i) {
          return re.then(i.rule, function(l) {
            return function(u, w) {
              return i.func(u, l, w);
            };
          });
        });
        var n = re.firstOf.apply(null, ["rules"].concat(g));
        return function(i) {
          var l = i, u = d(i);
          if (!u.isSuccess())
            return u;
          for (var w = n(u.remaining()); w.isSuccess(); ) {
            var _ = w.remaining(), b = l.to(w.remaining()), A = w.value();
            u = o.success(
              A(u.value(), b),
              _,
              b
            ), w = n(u.remaining());
          }
          return w.isError() ? w : u;
        };
      }, re.leftAssociative.firstOf = function() {
        return Array.prototype.slice.call(arguments, 0);
      }, re.nonConsuming = function(d) {
        return function(p) {
          return d(p).changeRemaining(p);
        };
      };
      var y = function(d) {
        return d.value ? d.name + ' "' + d.value + '"' : d.name;
      };
      function c(d, p) {
        var m, g = d.head();
        return g ? m = C.error({
          expected: p,
          actual: y(g),
          location: g.source
        }) : m = C.error({
          expected: p,
          actual: "end of tokens"
        }), o.failure([m], d);
      }
    }, { "./errors": 93, "./lazy-iterators": 94, "./parsing-results": 96, option: 99, underscore: 117 }], 99: [function(le, ce, re) {
      re.none = /* @__PURE__ */ Object.create({
        value: function() {
          throw new Error("Called value on none");
        },
        isNone: function() {
          return !0;
        },
        isSome: function() {
          return !1;
        },
        map: function() {
          return re.none;
        },
        flatMap: function() {
          return re.none;
        },
        filter: function() {
          return re.none;
        },
        toArray: function() {
          return [];
        },
        orElse: ae,
        valueOrElse: ae
      });
      function ae(o) {
        return typeof o == "function" ? o() : o;
      }
      re.some = function(o) {
        return new Z(o);
      };
      var Z = function(o) {
        this._value = o;
      };
      Z.prototype.value = function() {
        return this._value;
      }, Z.prototype.isNone = function() {
        return !1;
      }, Z.prototype.isSome = function() {
        return !0;
      }, Z.prototype.map = function(o) {
        return new Z(o(this._value));
      }, Z.prototype.flatMap = function(o) {
        return o(this._value);
      }, Z.prototype.filter = function(o) {
        return o(this._value) ? this : re.none;
      }, Z.prototype.toArray = function() {
        return [this._value];
      }, Z.prototype.orElse = function(o) {
        return this;
      }, Z.prototype.valueOrElse = function(o) {
        return this._value;
      }, re.isOption = function(o) {
        return o === re.none || o instanceof Z;
      }, re.fromNullable = function(o) {
        return o == null ? re.none : new Z(o);
      };
    }, {}], 100: [function(le, ce, re) {
      (function(ae) {
        function Z(v, h) {
          for (var e = 0, y = v.length - 1; y >= 0; y--) {
            var c = v[y];
            c === "." ? v.splice(y, 1) : c === ".." ? (v.splice(y, 1), e++) : e && (v.splice(y, 1), e--);
          }
          if (h)
            for (; e--; e)
              v.unshift("..");
          return v;
        }
        var o = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, C = function(v) {
          return o.exec(v).slice(1);
        };
        re.resolve = function() {
          for (var v = "", h = !1, e = arguments.length - 1; e >= -1 && !h; e--) {
            var y = e >= 0 ? arguments[e] : ae.cwd();
            if (typeof y != "string")
              throw new TypeError("Arguments to path.resolve must be strings");
            if (!y)
              continue;
            v = y + "/" + v, h = y.charAt(0) === "/";
          }
          return v = Z(t(v.split("/"), function(c) {
            return !!c;
          }), !h).join("/"), (h ? "/" : "") + v || ".";
        }, re.normalize = function(v) {
          var h = re.isAbsolute(v), e = a(v, -1) === "/";
          return v = Z(t(v.split("/"), function(y) {
            return !!y;
          }), !h).join("/"), !v && !h && (v = "."), v && e && (v += "/"), (h ? "/" : "") + v;
        }, re.isAbsolute = function(v) {
          return v.charAt(0) === "/";
        }, re.join = function() {
          var v = Array.prototype.slice.call(arguments, 0);
          return re.normalize(t(v, function(h, e) {
            if (typeof h != "string")
              throw new TypeError("Arguments to path.join must be strings");
            return h;
          }).join("/"));
        }, re.relative = function(v, h) {
          v = re.resolve(v).substr(1), h = re.resolve(h).substr(1);
          function e(n) {
            for (var i = 0; i < n.length && n[i] === ""; i++)
              ;
            for (var l = n.length - 1; l >= 0 && n[l] === ""; l--)
              ;
            return i > l ? [] : n.slice(i, l - i + 1);
          }
          for (var y = e(v.split("/")), c = e(h.split("/")), d = Math.min(y.length, c.length), p = d, m = 0; m < d; m++)
            if (y[m] !== c[m]) {
              p = m;
              break;
            }
          for (var g = [], m = p; m < y.length; m++)
            g.push("..");
          return g = g.concat(c.slice(p)), g.join("/");
        }, re.sep = "/", re.delimiter = ":", re.dirname = function(v) {
          var h = C(v), e = h[0], y = h[1];
          return !e && !y ? "." : (y && (y = y.substr(0, y.length - 1)), e + y);
        }, re.basename = function(v, h) {
          var e = C(v)[2];
          return h && e.substr(-1 * h.length) === h && (e = e.substr(0, e.length - h.length)), e;
        }, re.extname = function(v) {
          return C(v)[3];
        };
        function t(v, h) {
          if (v.filter)
            return v.filter(h);
          for (var e = [], y = 0; y < v.length; y++)
            h(v[y], y, v) && e.push(v[y]);
          return e;
        }
        var a = "ab".substr(-1) === "b" ? function(v, h, e) {
          return v.substr(h, e);
        } : function(v, h, e) {
          return h < 0 && (h = v.length + h), v.substr(h, e);
        };
      }).call(this, le("_process"));
    }, { _process: 102 }], 101: [function(le, ce, re) {
      (function(ae) {
        !ae.version || ae.version.indexOf("v0.") === 0 || ae.version.indexOf("v1.") === 0 && ae.version.indexOf("v1.8.") !== 0 ? ce.exports = Z : ce.exports = ae.nextTick;
        function Z(o, C, t, a) {
          if (typeof o != "function")
            throw new TypeError('"callback" argument must be a function');
          var v = arguments.length, h, e;
          switch (v) {
            case 0:
            case 1:
              return ae.nextTick(o);
            case 2:
              return ae.nextTick(function() {
                o.call(null, C);
              });
            case 3:
              return ae.nextTick(function() {
                o.call(null, C, t);
              });
            case 4:
              return ae.nextTick(function() {
                o.call(null, C, t, a);
              });
            default:
              for (h = new Array(v - 1), e = 0; e < h.length; )
                h[e++] = arguments[e];
              return ae.nextTick(function() {
                o.apply(null, h);
              });
          }
        }
      }).call(this, le("_process"));
    }, { _process: 102 }], 102: [function(le, ce, re) {
      var ae = ce.exports = {}, Z, o;
      function C() {
        throw new Error("setTimeout has not been defined");
      }
      function t() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          typeof setTimeout == "function" ? Z = setTimeout : Z = C;
        } catch {
          Z = C;
        }
        try {
          typeof clearTimeout == "function" ? o = clearTimeout : o = t;
        } catch {
          o = t;
        }
      })();
      function a(n) {
        if (Z === setTimeout)
          return setTimeout(n, 0);
        if ((Z === C || !Z) && setTimeout)
          return Z = setTimeout, setTimeout(n, 0);
        try {
          return Z(n, 0);
        } catch {
          try {
            return Z.call(null, n, 0);
          } catch {
            return Z.call(this, n, 0);
          }
        }
      }
      function v(n) {
        if (o === clearTimeout)
          return clearTimeout(n);
        if ((o === t || !o) && clearTimeout)
          return o = clearTimeout, clearTimeout(n);
        try {
          return o(n);
        } catch {
          try {
            return o.call(null, n);
          } catch {
            return o.call(this, n);
          }
        }
      }
      var h = [], e = !1, y, c = -1;
      function d() {
        !e || !y || (e = !1, y.length ? h = y.concat(h) : c = -1, h.length && p());
      }
      function p() {
        if (!e) {
          var n = a(d);
          e = !0;
          for (var i = h.length; i; ) {
            for (y = h, h = []; ++c < i; )
              y && y[c].run();
            c = -1, i = h.length;
          }
          y = null, e = !1, v(n);
        }
      }
      ae.nextTick = function(n) {
        var i = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var l = 1; l < arguments.length; l++)
            i[l - 1] = arguments[l];
        h.push(new m(n, i)), h.length === 1 && !e && a(p);
      };
      function m(n, i) {
        this.fun = n, this.array = i;
      }
      m.prototype.run = function() {
        this.fun.apply(null, this.array);
      }, ae.title = "browser", ae.browser = !0, ae.env = {}, ae.argv = [], ae.version = "", ae.versions = {};
      function g() {
      }
      ae.on = g, ae.addListener = g, ae.once = g, ae.off = g, ae.removeListener = g, ae.removeAllListeners = g, ae.emit = g, ae.binding = function(n) {
        throw new Error("process.binding is not supported");
      }, ae.cwd = function() {
        return "/";
      }, ae.chdir = function(n) {
        throw new Error("process.chdir is not supported");
      }, ae.umask = function() {
        return 0;
      };
    }, {}], 103: [function(le, ce, re) {
      ce.exports = le("./lib/_stream_duplex.js");
    }, { "./lib/_stream_duplex.js": 104 }], 104: [function(le, ce, re) {
      var ae = Object.keys || function(d) {
        var p = [];
        for (var m in d)
          p.push(m);
        return p;
      };
      ce.exports = e;
      var Z = le("process-nextick-args"), o = le("core-util-is");
      o.inherits = le("inherits");
      var C = le("./_stream_readable"), t = le("./_stream_writable");
      o.inherits(e, C);
      for (var a = ae(t.prototype), v = 0; v < a.length; v++) {
        var h = a[v];
        e.prototype[h] || (e.prototype[h] = t.prototype[h]);
      }
      function e(d) {
        if (!(this instanceof e))
          return new e(d);
        C.call(this, d), t.call(this, d), d && d.readable === !1 && (this.readable = !1), d && d.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, d && d.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", y);
      }
      function y() {
        this.allowHalfOpen || this._writableState.ended || Z(c, this);
      }
      function c(d) {
        d.end();
      }
    }, { "./_stream_readable": 106, "./_stream_writable": 108, "core-util-is": 79, inherits: 84, "process-nextick-args": 101 }], 105: [function(le, ce, re) {
      ce.exports = o;
      var ae = le("./_stream_transform"), Z = le("core-util-is");
      Z.inherits = le("inherits"), Z.inherits(o, ae);
      function o(C) {
        if (!(this instanceof o))
          return new o(C);
        ae.call(this, C);
      }
      o.prototype._transform = function(C, t, a) {
        a(null, C);
      };
    }, { "./_stream_transform": 107, "core-util-is": 79, inherits: 84 }], 106: [function(le, ce, re) {
      (function(ae) {
        ce.exports = n;
        var Z = le("process-nextick-args"), o = le("isarray"), C;
        n.ReadableState = g, le("events").EventEmitter;
        var t = function(W, z) {
          return W.listeners(z).length;
        }, a;
        (function() {
          try {
            a = le("stream");
          } catch {
          } finally {
            a || (a = le("events").EventEmitter);
          }
        })();
        var v = le("buffer").Buffer, h = le("buffer-shims"), e = le("core-util-is");
        e.inherits = le("inherits");
        var y = le("util"), c = void 0;
        y && y.debuglog ? c = y.debuglog("stream") : c = function() {
        };
        var d = le("./internal/streams/BufferList"), p;
        e.inherits(n, a);
        function m(W, z, G) {
          if (typeof W.prependListener == "function")
            return W.prependListener(z, G);
          !W._events || !W._events[z] ? W.on(z, G) : o(W._events[z]) ? W._events[z].unshift(G) : W._events[z] = [G, W._events[z]];
        }
        function g(W, z) {
          C = C || le("./_stream_duplex"), W = W || {}, this.objectMode = !!W.objectMode, z instanceof C && (this.objectMode = this.objectMode || !!W.readableObjectMode);
          var G = W.highWaterMark, L = this.objectMode ? 16 : 16 * 1024;
          this.highWaterMark = G || G === 0 ? G : L, this.highWaterMark = ~~this.highWaterMark, this.buffer = new d(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.defaultEncoding = W.defaultEncoding || "utf8", this.ranOut = !1, this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, W.encoding && (p || (p = le("string_decoder/").StringDecoder), this.decoder = new p(W.encoding), this.encoding = W.encoding);
        }
        function n(W) {
          if (C = C || le("./_stream_duplex"), !(this instanceof n))
            return new n(W);
          this._readableState = new g(W, this), this.readable = !0, W && typeof W.read == "function" && (this._read = W.read), a.call(this);
        }
        n.prototype.push = function(W, z) {
          var G = this._readableState;
          return !G.objectMode && typeof W == "string" && (z = z || G.defaultEncoding, z !== G.encoding && (W = h.from(W, z), z = "")), i(this, G, W, z, !1);
        }, n.prototype.unshift = function(W) {
          var z = this._readableState;
          return i(this, z, W, "", !0);
        }, n.prototype.isPaused = function() {
          return this._readableState.flowing === !1;
        };
        function i(W, z, G, L, K) {
          var te = b(z, G);
          if (te)
            W.emit("error", te);
          else if (G === null)
            z.reading = !1, A(W, z);
          else if (z.objectMode || G && G.length > 0)
            if (z.ended && !K) {
              var se = new Error("stream.push() after EOF");
              W.emit("error", se);
            } else if (z.endEmitted && K) {
              var q = new Error("stream.unshift() after end event");
              W.emit("error", q);
            } else {
              var N;
              z.decoder && !K && !L && (G = z.decoder.write(G), N = !z.objectMode && G.length === 0), K || (z.reading = !1), N || (z.flowing && z.length === 0 && !z.sync ? (W.emit("data", G), W.read(0)) : (z.length += z.objectMode ? 1 : G.length, K ? z.buffer.unshift(G) : z.buffer.push(G), z.needReadable && Y(W))), X(W, z);
            }
          else
            K || (z.reading = !1);
          return l(z);
        }
        function l(W) {
          return !W.ended && (W.needReadable || W.length < W.highWaterMark || W.length === 0);
        }
        n.prototype.setEncoding = function(W) {
          return p || (p = le("string_decoder/").StringDecoder), this._readableState.decoder = new p(W), this._readableState.encoding = W, this;
        };
        var u = 8388608;
        function w(W) {
          return W >= u ? W = u : (W--, W |= W >>> 1, W |= W >>> 2, W |= W >>> 4, W |= W >>> 8, W |= W >>> 16, W++), W;
        }
        function _(W, z) {
          return W <= 0 || z.length === 0 && z.ended ? 0 : z.objectMode ? 1 : W !== W ? z.flowing && z.length ? z.buffer.head.data.length : z.length : (W > z.highWaterMark && (z.highWaterMark = w(W)), W <= z.length ? W : z.ended ? z.length : (z.needReadable = !0, 0));
        }
        n.prototype.read = function(W) {
          c("read", W), W = parseInt(W, 10);
          var z = this._readableState, G = W;
          if (W !== 0 && (z.emittedReadable = !1), W === 0 && z.needReadable && (z.length >= z.highWaterMark || z.ended))
            return c("read: emitReadable", z.length, z.ended), z.length === 0 && z.ended ? I(this) : Y(this), null;
          if (W = _(W, z), W === 0 && z.ended)
            return z.length === 0 && I(this), null;
          var L = z.needReadable;
          c("need readable", L), (z.length === 0 || z.length - W < z.highWaterMark) && (L = !0, c("length less than watermark", L)), z.ended || z.reading ? (L = !1, c("reading or ended", L)) : L && (c("do read"), z.reading = !0, z.sync = !0, z.length === 0 && (z.needReadable = !0), this._read(z.highWaterMark), z.sync = !1, z.reading || (W = _(G, z)));
          var K;
          return W > 0 ? K = O(W, z) : K = null, K === null ? (z.needReadable = !0, W = 0) : z.length -= W, z.length === 0 && (z.ended || (z.needReadable = !0), G !== W && z.ended && I(this)), K !== null && this.emit("data", K), K;
        };
        function b(W, z) {
          var G = null;
          return !v.isBuffer(z) && typeof z != "string" && z !== null && z !== void 0 && !W.objectMode && (G = new TypeError("Invalid non-string/buffer chunk")), G;
        }
        function A(W, z) {
          if (!z.ended) {
            if (z.decoder) {
              var G = z.decoder.end();
              G && G.length && (z.buffer.push(G), z.length += z.objectMode ? 1 : G.length);
            }
            z.ended = !0, Y(W);
          }
        }
        function Y(W) {
          var z = W._readableState;
          z.needReadable = !1, z.emittedReadable || (c("emitReadable", z.flowing), z.emittedReadable = !0, z.sync ? Z(j, W) : j(W));
        }
        function j(W) {
          c("emit readable"), W.emit("readable"), U(W);
        }
        function X(W, z) {
          z.readingMore || (z.readingMore = !0, Z(B, W, z));
        }
        function B(W, z) {
          for (var G = z.length; !z.reading && !z.flowing && !z.ended && z.length < z.highWaterMark && (c("maybeReadMore read 0"), W.read(0), G !== z.length); )
            G = z.length;
          z.readingMore = !1;
        }
        n.prototype._read = function(W) {
          this.emit("error", new Error("_read() is not implemented"));
        }, n.prototype.pipe = function(W, z) {
          var G = this, L = this._readableState;
          switch (L.pipesCount) {
            case 0:
              L.pipes = W;
              break;
            case 1:
              L.pipes = [L.pipes, W];
              break;
            default:
              L.pipes.push(W);
              break;
          }
          L.pipesCount += 1, c("pipe count=%d opts=%j", L.pipesCount, z);
          var K = (!z || z.end !== !1) && W !== ae.stdout && W !== ae.stderr, te = K ? q : D;
          L.endEmitted ? Z(te) : G.once("end", te), W.on("unpipe", se);
          function se(ie) {
            c("onunpipe"), ie === G && D();
          }
          function q() {
            c("onend"), W.end();
          }
          var N = R(G);
          W.on("drain", N);
          var Q = !1;
          function D() {
            c("cleanup"), W.removeListener("close", $), W.removeListener("finish", E), W.removeListener("drain", N), W.removeListener("error", ee), W.removeListener("unpipe", se), G.removeListener("end", q), G.removeListener("end", D), G.removeListener("data", oe), Q = !0, L.awaitDrain && (!W._writableState || W._writableState.needDrain) && N();
          }
          var ne = !1;
          G.on("data", oe);
          function oe(ie) {
            c("ondata"), ne = !1;
            var ue = W.write(ie);
            ue === !1 && !ne && ((L.pipesCount === 1 && L.pipes === W || L.pipesCount > 1 && J(L.pipes, W) !== -1) && !Q && (c("false write response, pause", G._readableState.awaitDrain), G._readableState.awaitDrain++, ne = !0), G.pause());
          }
          function ee(ie) {
            c("onerror", ie), H(), W.removeListener("error", ee), t(W, "error") === 0 && W.emit("error", ie);
          }
          m(W, "error", ee);
          function $() {
            W.removeListener("finish", E), H();
          }
          W.once("close", $);
          function E() {
            c("onfinish"), W.removeListener("close", $), H();
          }
          W.once("finish", E);
          function H() {
            c("unpipe"), G.unpipe(W);
          }
          return W.emit("pipe", G), L.flowing || (c("pipe resume"), G.resume()), W;
        };
        function R(W) {
          return function() {
            var z = W._readableState;
            c("pipeOnDrain", z.awaitDrain), z.awaitDrain && z.awaitDrain--, z.awaitDrain === 0 && t(W, "data") && (z.flowing = !0, U(W));
          };
        }
        n.prototype.unpipe = function(W) {
          var z = this._readableState;
          if (z.pipesCount === 0)
            return this;
          if (z.pipesCount === 1)
            return W && W !== z.pipes ? this : (W || (W = z.pipes), z.pipes = null, z.pipesCount = 0, z.flowing = !1, W && W.emit("unpipe", this), this);
          if (!W) {
            var G = z.pipes, L = z.pipesCount;
            z.pipes = null, z.pipesCount = 0, z.flowing = !1;
            for (var K = 0; K < L; K++)
              G[K].emit("unpipe", this);
            return this;
          }
          var te = J(z.pipes, W);
          return te === -1 ? this : (z.pipes.splice(te, 1), z.pipesCount -= 1, z.pipesCount === 1 && (z.pipes = z.pipes[0]), W.emit("unpipe", this), this);
        }, n.prototype.on = function(W, z) {
          var G = a.prototype.on.call(this, W, z);
          if (W === "data")
            this._readableState.flowing !== !1 && this.resume();
          else if (W === "readable") {
            var L = this._readableState;
            !L.endEmitted && !L.readableListening && (L.readableListening = L.needReadable = !0, L.emittedReadable = !1, L.reading ? L.length && Y(this) : Z(k, this));
          }
          return G;
        }, n.prototype.addListener = n.prototype.on;
        function k(W) {
          c("readable nexttick read 0"), W.read(0);
        }
        n.prototype.resume = function() {
          var W = this._readableState;
          return W.flowing || (c("resume"), W.flowing = !0, x(this, W)), this;
        };
        function x(W, z) {
          z.resumeScheduled || (z.resumeScheduled = !0, Z(f, W, z));
        }
        function f(W, z) {
          z.reading || (c("resume read 0"), W.read(0)), z.resumeScheduled = !1, z.awaitDrain = 0, W.emit("resume"), U(W), z.flowing && !z.reading && W.read(0);
        }
        n.prototype.pause = function() {
          return c("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (c("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
        };
        function U(W) {
          var z = W._readableState;
          for (c("flow", z.flowing); z.flowing && W.read() !== null; )
            ;
        }
        n.prototype.wrap = function(W) {
          var z = this._readableState, G = !1, L = this;
          W.on("end", function() {
            if (c("wrapped end"), z.decoder && !z.ended) {
              var se = z.decoder.end();
              se && se.length && L.push(se);
            }
            L.push(null);
          }), W.on("data", function(se) {
            if (c("wrapped data"), z.decoder && (se = z.decoder.write(se)), !(z.objectMode && se == null) && !(!z.objectMode && (!se || !se.length))) {
              var q = L.push(se);
              q || (G = !0, W.pause());
            }
          });
          for (var K in W)
            this[K] === void 0 && typeof W[K] == "function" && (this[K] = function(se) {
              return function() {
                return W[se].apply(W, arguments);
              };
            }(K));
          var te = ["error", "close", "destroy", "pause", "resume"];
          return V(te, function(se) {
            W.on(se, L.emit.bind(L, se));
          }), L._read = function(se) {
            c("wrapped _read", se), G && (G = !1, W.resume());
          }, L;
        }, n._fromList = O;
        function O(W, z) {
          if (z.length === 0)
            return null;
          var G;
          return z.objectMode ? G = z.buffer.shift() : !W || W >= z.length ? (z.decoder ? G = z.buffer.join("") : z.buffer.length === 1 ? G = z.buffer.head.data : G = z.buffer.concat(z.length), z.buffer.clear()) : G = S(W, z.buffer, z.decoder), G;
        }
        function S(W, z, G) {
          var L;
          return W < z.head.data.length ? (L = z.head.data.slice(0, W), z.head.data = z.head.data.slice(W)) : W === z.head.data.length ? L = z.shift() : L = G ? F(W, z) : T(W, z), L;
        }
        function F(W, z) {
          var G = z.head, L = 1, K = G.data;
          for (W -= K.length; G = G.next; ) {
            var te = G.data, se = W > te.length ? te.length : W;
            if (se === te.length ? K += te : K += te.slice(0, W), W -= se, W === 0) {
              se === te.length ? (++L, G.next ? z.head = G.next : z.head = z.tail = null) : (z.head = G, G.data = te.slice(se));
              break;
            }
            ++L;
          }
          return z.length -= L, K;
        }
        function T(W, z) {
          var G = h.allocUnsafe(W), L = z.head, K = 1;
          for (L.data.copy(G), W -= L.data.length; L = L.next; ) {
            var te = L.data, se = W > te.length ? te.length : W;
            if (te.copy(G, G.length - W, 0, se), W -= se, W === 0) {
              se === te.length ? (++K, L.next ? z.head = L.next : z.head = z.tail = null) : (z.head = L, L.data = te.slice(se));
              break;
            }
            ++K;
          }
          return z.length -= K, G;
        }
        function I(W) {
          var z = W._readableState;
          if (z.length > 0)
            throw new Error('"endReadable()" called on non-empty stream');
          z.endEmitted || (z.ended = !0, Z(M, z, W));
        }
        function M(W, z) {
          !W.endEmitted && W.length === 0 && (W.endEmitted = !0, z.readable = !1, z.emit("end"));
        }
        function V(W, z) {
          for (var G = 0, L = W.length; G < L; G++)
            z(W[G], G);
        }
        function J(W, z) {
          for (var G = 0, L = W.length; G < L; G++)
            if (W[G] === z)
              return G;
          return -1;
        }
      }).call(this, le("_process"));
    }, { "./_stream_duplex": 104, "./internal/streams/BufferList": 109, _process: 102, buffer: 78, "buffer-shims": 77, "core-util-is": 79, events: 82, inherits: 84, isarray: 86, "process-nextick-args": 101, "string_decoder/": 116, util: 76 }], 107: [function(le, ce, re) {
      ce.exports = t;
      var ae = le("./_stream_duplex"), Z = le("core-util-is");
      Z.inherits = le("inherits"), Z.inherits(t, ae);
      function o(v) {
        this.afterTransform = function(h, e) {
          return C(v, h, e);
        }, this.needTransform = !1, this.transforming = !1, this.writecb = null, this.writechunk = null, this.writeencoding = null;
      }
      function C(v, h, e) {
        var y = v._transformState;
        y.transforming = !1;
        var c = y.writecb;
        if (!c)
          return v.emit("error", new Error("no writecb in Transform class"));
        y.writechunk = null, y.writecb = null, e != null && v.push(e), c(h);
        var d = v._readableState;
        d.reading = !1, (d.needReadable || d.length < d.highWaterMark) && v._read(d.highWaterMark);
      }
      function t(v) {
        if (!(this instanceof t))
          return new t(v);
        ae.call(this, v), this._transformState = new o(this);
        var h = this;
        this._readableState.needReadable = !0, this._readableState.sync = !1, v && (typeof v.transform == "function" && (this._transform = v.transform), typeof v.flush == "function" && (this._flush = v.flush)), this.once("prefinish", function() {
          typeof this._flush == "function" ? this._flush(function(e, y) {
            a(h, e, y);
          }) : a(h);
        });
      }
      t.prototype.push = function(v, h) {
        return this._transformState.needTransform = !1, ae.prototype.push.call(this, v, h);
      }, t.prototype._transform = function(v, h, e) {
        throw new Error("_transform() is not implemented");
      }, t.prototype._write = function(v, h, e) {
        var y = this._transformState;
        if (y.writecb = e, y.writechunk = v, y.writeencoding = h, !y.transforming) {
          var c = this._readableState;
          (y.needTransform || c.needReadable || c.length < c.highWaterMark) && this._read(c.highWaterMark);
        }
      }, t.prototype._read = function(v) {
        var h = this._transformState;
        h.writechunk !== null && h.writecb && !h.transforming ? (h.transforming = !0, this._transform(h.writechunk, h.writeencoding, h.afterTransform)) : h.needTransform = !0;
      };
      function a(v, h, e) {
        if (h)
          return v.emit("error", h);
        e != null && v.push(e);
        var y = v._writableState, c = v._transformState;
        if (y.length)
          throw new Error("Calling transform done when ws.length != 0");
        if (c.transforming)
          throw new Error("Calling transform done when still transforming");
        return v.push(null);
      }
    }, { "./_stream_duplex": 104, "core-util-is": 79, inherits: 84 }], 108: [function(le, ce, re) {
      (function(ae) {
        ce.exports = m;
        var Z = le("process-nextick-args"), o = !ae.browser && ["v0.10", "v0.9."].indexOf(ae.version.slice(0, 5)) > -1 ? setImmediate : Z, C;
        m.WritableState = d;
        var t = le("core-util-is");
        t.inherits = le("inherits");
        var a = {
          deprecate: le("util-deprecate")
        }, v;
        (function() {
          try {
            v = le("stream");
          } catch {
          } finally {
            v || (v = le("events").EventEmitter);
          }
        })();
        var h = le("buffer").Buffer, e = le("buffer-shims");
        t.inherits(m, v);
        function y() {
        }
        function c(f, U, O) {
          this.chunk = f, this.encoding = U, this.callback = O, this.next = null;
        }
        function d(f, U) {
          C = C || le("./_stream_duplex"), f = f || {}, this.objectMode = !!f.objectMode, U instanceof C && (this.objectMode = this.objectMode || !!f.writableObjectMode);
          var O = f.highWaterMark, S = this.objectMode ? 16 : 16 * 1024;
          this.highWaterMark = O || O === 0 ? O : S, this.highWaterMark = ~~this.highWaterMark, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1;
          var F = f.decodeStrings === !1;
          this.decodeStrings = !F, this.defaultEncoding = f.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(T) {
            b(U, T);
          }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new x(this);
        }
        d.prototype.getBuffer = function() {
          for (var U = this.bufferedRequest, O = []; U; )
            O.push(U), U = U.next;
          return O;
        }, function() {
          try {
            Object.defineProperty(d.prototype, "buffer", {
              get: a.deprecate(function() {
                return this.getBuffer();
              }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
            });
          } catch {
          }
        }();
        var p;
        typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (p = Function.prototype[Symbol.hasInstance], Object.defineProperty(m, Symbol.hasInstance, {
          value: function(f) {
            return p.call(this, f) ? !0 : f && f._writableState instanceof d;
          }
        })) : p = function(f) {
          return f instanceof this;
        };
        function m(f) {
          if (C = C || le("./_stream_duplex"), !p.call(m, this) && !(this instanceof C))
            return new m(f);
          this._writableState = new d(f, this), this.writable = !0, f && (typeof f.write == "function" && (this._write = f.write), typeof f.writev == "function" && (this._writev = f.writev)), v.call(this);
        }
        m.prototype.pipe = function() {
          this.emit("error", new Error("Cannot pipe, not readable"));
        };
        function g(f, U) {
          var O = new Error("write after end");
          f.emit("error", O), Z(U, O);
        }
        function n(f, U, O, S) {
          var F = !0, T = !1;
          return O === null ? T = new TypeError("May not write null values to stream") : typeof O != "string" && O !== void 0 && !U.objectMode && (T = new TypeError("Invalid non-string/buffer chunk")), T && (f.emit("error", T), Z(S, T), F = !1), F;
        }
        m.prototype.write = function(f, U, O) {
          var S = this._writableState, F = !1, T = h.isBuffer(f);
          return typeof U == "function" && (O = U, U = null), T ? U = "buffer" : U || (U = S.defaultEncoding), typeof O != "function" && (O = y), S.ended ? g(this, O) : (T || n(this, S, f, O)) && (S.pendingcb++, F = l(this, S, T, f, U, O)), F;
        }, m.prototype.cork = function() {
          var f = this._writableState;
          f.corked++;
        }, m.prototype.uncork = function() {
          var f = this._writableState;
          f.corked && (f.corked--, !f.writing && !f.corked && !f.finished && !f.bufferProcessing && f.bufferedRequest && j(this, f));
        }, m.prototype.setDefaultEncoding = function(U) {
          if (typeof U == "string" && (U = U.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((U + "").toLowerCase()) > -1))
            throw new TypeError("Unknown encoding: " + U);
          return this._writableState.defaultEncoding = U, this;
        };
        function i(f, U, O) {
          return !f.objectMode && f.decodeStrings !== !1 && typeof U == "string" && (U = e.from(U, O)), U;
        }
        function l(f, U, O, S, F, T) {
          O || (S = i(U, S, F), h.isBuffer(S) && (F = "buffer"));
          var I = U.objectMode ? 1 : S.length;
          U.length += I;
          var M = U.length < U.highWaterMark;
          if (M || (U.needDrain = !0), U.writing || U.corked) {
            var V = U.lastBufferedRequest;
            U.lastBufferedRequest = new c(S, F, T), V ? V.next = U.lastBufferedRequest : U.bufferedRequest = U.lastBufferedRequest, U.bufferedRequestCount += 1;
          } else
            u(f, U, !1, I, S, F, T);
          return M;
        }
        function u(f, U, O, S, F, T, I) {
          U.writelen = S, U.writecb = I, U.writing = !0, U.sync = !0, O ? f._writev(F, U.onwrite) : f._write(F, T, U.onwrite), U.sync = !1;
        }
        function w(f, U, O, S, F) {
          --U.pendingcb, O ? Z(F, S) : F(S), f._writableState.errorEmitted = !0, f.emit("error", S);
        }
        function _(f) {
          f.writing = !1, f.writecb = null, f.length -= f.writelen, f.writelen = 0;
        }
        function b(f, U) {
          var O = f._writableState, S = O.sync, F = O.writecb;
          if (_(O), U)
            w(f, O, S, U, F);
          else {
            var T = X(O);
            !T && !O.corked && !O.bufferProcessing && O.bufferedRequest && j(f, O), S ? o(A, f, O, T, F) : A(f, O, T, F);
          }
        }
        function A(f, U, O, S) {
          O || Y(f, U), U.pendingcb--, S(), R(f, U);
        }
        function Y(f, U) {
          U.length === 0 && U.needDrain && (U.needDrain = !1, f.emit("drain"));
        }
        function j(f, U) {
          U.bufferProcessing = !0;
          var O = U.bufferedRequest;
          if (f._writev && O && O.next) {
            var S = U.bufferedRequestCount, F = new Array(S), T = U.corkedRequestsFree;
            T.entry = O;
            for (var I = 0; O; )
              F[I] = O, O = O.next, I += 1;
            u(f, U, !0, U.length, F, "", T.finish), U.pendingcb++, U.lastBufferedRequest = null, T.next ? (U.corkedRequestsFree = T.next, T.next = null) : U.corkedRequestsFree = new x(U);
          } else {
            for (; O; ) {
              var M = O.chunk, V = O.encoding, J = O.callback, W = U.objectMode ? 1 : M.length;
              if (u(f, U, !1, W, M, V, J), O = O.next, U.writing)
                break;
            }
            O === null && (U.lastBufferedRequest = null);
          }
          U.bufferedRequestCount = 0, U.bufferedRequest = O, U.bufferProcessing = !1;
        }
        m.prototype._write = function(f, U, O) {
          O(new Error("_write() is not implemented"));
        }, m.prototype._writev = null, m.prototype.end = function(f, U, O) {
          var S = this._writableState;
          typeof f == "function" ? (O = f, f = null, U = null) : typeof U == "function" && (O = U, U = null), f != null && this.write(f, U), S.corked && (S.corked = 1, this.uncork()), !S.ending && !S.finished && k(this, S, O);
        };
        function X(f) {
          return f.ending && f.length === 0 && f.bufferedRequest === null && !f.finished && !f.writing;
        }
        function B(f, U) {
          U.prefinished || (U.prefinished = !0, f.emit("prefinish"));
        }
        function R(f, U) {
          var O = X(U);
          return O && (U.pendingcb === 0 ? (B(f, U), U.finished = !0, f.emit("finish")) : B(f, U)), O;
        }
        function k(f, U, O) {
          U.ending = !0, R(f, U), O && (U.finished ? Z(O) : f.once("finish", O)), U.ended = !0, f.writable = !1;
        }
        function x(f) {
          var U = this;
          this.next = null, this.entry = null, this.finish = function(O) {
            var S = U.entry;
            for (U.entry = null; S; ) {
              var F = S.callback;
              f.pendingcb--, F(O), S = S.next;
            }
            f.corkedRequestsFree ? f.corkedRequestsFree.next = U : f.corkedRequestsFree = U;
          };
        }
      }).call(this, le("_process"));
    }, { "./_stream_duplex": 104, _process: 102, buffer: 78, "buffer-shims": 77, "core-util-is": 79, events: 82, inherits: 84, "process-nextick-args": 101, "util-deprecate": 118 }], 109: [function(le, ce, re) {
      le("buffer").Buffer;
      var ae = le("buffer-shims");
      ce.exports = Z;
      function Z() {
        this.head = null, this.tail = null, this.length = 0;
      }
      Z.prototype.push = function(o) {
        var C = { data: o, next: null };
        this.length > 0 ? this.tail.next = C : this.head = C, this.tail = C, ++this.length;
      }, Z.prototype.unshift = function(o) {
        var C = { data: o, next: this.head };
        this.length === 0 && (this.tail = C), this.head = C, ++this.length;
      }, Z.prototype.shift = function() {
        if (this.length !== 0) {
          var o = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, o;
        }
      }, Z.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, Z.prototype.join = function(o) {
        if (this.length === 0)
          return "";
        for (var C = this.head, t = "" + C.data; C = C.next; )
          t += o + C.data;
        return t;
      }, Z.prototype.concat = function(o) {
        if (this.length === 0)
          return ae.alloc(0);
        if (this.length === 1)
          return this.head.data;
        for (var C = ae.allocUnsafe(o >>> 0), t = this.head, a = 0; t; )
          t.data.copy(C, a), a += t.data.length, t = t.next;
        return C;
      };
    }, { buffer: 78, "buffer-shims": 77 }], 110: [function(le, ce, re) {
      ce.exports = le("./lib/_stream_passthrough.js");
    }, { "./lib/_stream_passthrough.js": 105 }], 111: [function(le, ce, re) {
      (function(ae) {
        var Z = function() {
          try {
            return le("stream");
          } catch {
          }
        }();
        re = ce.exports = le("./lib/_stream_readable.js"), re.Stream = Z || re, re.Readable = re, re.Writable = le("./lib/_stream_writable.js"), re.Duplex = le("./lib/_stream_duplex.js"), re.Transform = le("./lib/_stream_transform.js"), re.PassThrough = le("./lib/_stream_passthrough.js"), !ae.browser && ae.env.READABLE_STREAM === "disable" && Z && (ce.exports = Z);
      }).call(this, le("_process"));
    }, { "./lib/_stream_duplex.js": 104, "./lib/_stream_passthrough.js": 105, "./lib/_stream_readable.js": 106, "./lib/_stream_transform.js": 107, "./lib/_stream_writable.js": 108, _process: 102 }], 112: [function(le, ce, re) {
      ce.exports = le("./lib/_stream_transform.js");
    }, { "./lib/_stream_transform.js": 107 }], 113: [function(le, ce, re) {
      ce.exports = le("./lib/_stream_writable.js");
    }, { "./lib/_stream_writable.js": 108 }], 114: [function(le, ce, re) {
      (function(ae) {
        (function(Z) {
          Z.parser = function(q, N) {
            return new C(q, N);
          }, Z.SAXParser = C, Z.SAXStream = c, Z.createStream = y, Z.MAX_BUFFER_LENGTH = 64 * 1024;
          var o = [
            "comment",
            "sgmlDecl",
            "textNode",
            "tagName",
            "doctype",
            "procInstName",
            "procInstBody",
            "entity",
            "attribName",
            "attribValue",
            "cdata",
            "script"
          ];
          Z.EVENTS = [
            "text",
            "processinginstruction",
            "sgmldeclaration",
            "doctype",
            "comment",
            "attribute",
            "opentag",
            "closetag",
            "opencdata",
            "cdata",
            "closecdata",
            "error",
            "end",
            "ready",
            "script",
            "opennamespace",
            "closenamespace"
          ];
          function C(q, N) {
            if (!(this instanceof C))
              return new C(q, N);
            var Q = this;
            a(Q), Q.q = Q.c = "", Q.bufferCheckPosition = Z.MAX_BUFFER_LENGTH, Q.opt = N || {}, Q.opt.lowercase = Q.opt.lowercase || Q.opt.lowercasetags, Q.looseCase = Q.opt.lowercase ? "toLowerCase" : "toUpperCase", Q.tags = [], Q.closed = Q.closedRoot = Q.sawRoot = !1, Q.tag = Q.error = null, Q.strict = !!q, Q.noscript = !!(q || Q.opt.noscript), Q.state = x.BEGIN, Q.strictEntities = Q.opt.strictEntities, Q.ENTITIES = Q.strictEntities ? Object.create(Z.XML_ENTITIES) : Object.create(Z.ENTITIES), Q.attribList = [], Q.opt.xmlns && (Q.ns = Object.create(_)), Q.trackPosition = Q.opt.position !== !1, Q.trackPosition && (Q.position = Q.line = Q.column = 0), U(Q, "onready");
          }
          Object.create || (Object.create = function(q) {
            function N() {
            }
            N.prototype = q;
            var Q = new N();
            return Q;
          }), Object.keys || (Object.keys = function(q) {
            var N = [];
            for (var Q in q)
              q.hasOwnProperty(Q) && N.push(Q);
            return N;
          });
          function t(q) {
            for (var N = Math.max(Z.MAX_BUFFER_LENGTH, 10), Q = 0, D = 0, ne = o.length; D < ne; D++) {
              var oe = q[o[D]].length;
              if (oe > N)
                switch (o[D]) {
                  case "textNode":
                    S(q);
                    break;
                  case "cdata":
                    O(q, "oncdata", q.cdata), q.cdata = "";
                    break;
                  case "script":
                    O(q, "onscript", q.script), q.script = "";
                    break;
                  default:
                    T(q, "Max buffer length exceeded: " + o[D]);
                }
              Q = Math.max(Q, oe);
            }
            var ee = Z.MAX_BUFFER_LENGTH - Q;
            q.bufferCheckPosition = ee + q.position;
          }
          function a(q) {
            for (var N = 0, Q = o.length; N < Q; N++)
              q[o[N]] = "";
          }
          function v(q) {
            S(q), q.cdata !== "" && (O(q, "oncdata", q.cdata), q.cdata = ""), q.script !== "" && (O(q, "onscript", q.script), q.script = "");
          }
          C.prototype = {
            end: function() {
              I(this);
            },
            write: se,
            resume: function() {
              return this.error = null, this;
            },
            close: function() {
              return this.write(null);
            },
            flush: function() {
              v(this);
            }
          };
          var h;
          try {
            h = le("stream").Stream;
          } catch {
            h = function() {
            };
          }
          var e = Z.EVENTS.filter(function(q) {
            return q !== "error" && q !== "end";
          });
          function y(q, N) {
            return new c(q, N);
          }
          function c(q, N) {
            if (!(this instanceof c))
              return new c(q, N);
            h.apply(this), this._parser = new C(q, N), this.writable = !0, this.readable = !0;
            var Q = this;
            this._parser.onend = function() {
              Q.emit("end");
            }, this._parser.onerror = function(D) {
              Q.emit("error", D), Q._parser.error = null;
            }, this._decoder = null, e.forEach(function(D) {
              Object.defineProperty(Q, "on" + D, {
                get: function() {
                  return Q._parser["on" + D];
                },
                set: function(ne) {
                  if (!ne)
                    return Q.removeAllListeners(D), Q._parser["on" + D] = ne, ne;
                  Q.on(D, ne);
                },
                enumerable: !0,
                configurable: !1
              });
            });
          }
          c.prototype = Object.create(h.prototype, {
            constructor: {
              value: c
            }
          }), c.prototype.write = function(q) {
            if (typeof ae == "function" && typeof ae.isBuffer == "function" && ae.isBuffer(q)) {
              if (!this._decoder) {
                var N = le("string_decoder").StringDecoder;
                this._decoder = new N("utf8");
              }
              q = this._decoder.write(q);
            }
            return this._parser.write(q.toString()), this.emit("data", q), !0;
          }, c.prototype.end = function(q) {
            return q && q.length && this.write(q), this._parser.end(), !0;
          }, c.prototype.on = function(q, N) {
            var Q = this;
            return !Q._parser["on" + q] && e.indexOf(q) !== -1 && (Q._parser["on" + q] = function() {
              var D = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
              D.splice(0, 0, q), Q.emit.apply(Q, D);
            }), h.prototype.on.call(Q, q, N);
          };
          var d = `\r
	 `, p = "0124356789", m = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", g = `'"`, n = d + ">", i = "[CDATA[", l = "DOCTYPE", u = "http://www.w3.org/XML/1998/namespace", w = "http://www.w3.org/2000/xmlns/", _ = { xml: u, xmlns: w };
          d = X(d), p = X(p), m = X(m);
          var b = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, A = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/, Y = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, j = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/;
          g = X(g), n = X(n);
          function X(q) {
            return q.split("").reduce(function(N, Q) {
              return N[Q] = !0, N;
            }, {});
          }
          function B(q) {
            return Object.prototype.toString.call(q) === "[object RegExp]";
          }
          function R(q, N) {
            return B(q) ? !!N.match(q) : q[N];
          }
          function k(q, N) {
            return !R(q, N);
          }
          var x = 0;
          Z.STATE = {
            BEGIN: x++,
            // leading byte order mark or whitespace
            BEGIN_WHITESPACE: x++,
            // leading whitespace
            TEXT: x++,
            // general stuff
            TEXT_ENTITY: x++,
            // &amp and such.
            OPEN_WAKA: x++,
            // <
            SGML_DECL: x++,
            // <!BLARG
            SGML_DECL_QUOTED: x++,
            // <!BLARG foo "bar
            DOCTYPE: x++,
            // <!DOCTYPE
            DOCTYPE_QUOTED: x++,
            // <!DOCTYPE "//blah
            DOCTYPE_DTD: x++,
            // <!DOCTYPE "//blah" [ ...
            DOCTYPE_DTD_QUOTED: x++,
            // <!DOCTYPE "//blah" [ "foo
            COMMENT_STARTING: x++,
            // <!-
            COMMENT: x++,
            // <!--
            COMMENT_ENDING: x++,
            // <!-- blah -
            COMMENT_ENDED: x++,
            // <!-- blah --
            CDATA: x++,
            // <![CDATA[ something
            CDATA_ENDING: x++,
            // ]
            CDATA_ENDING_2: x++,
            // ]]
            PROC_INST: x++,
            // <?hi
            PROC_INST_BODY: x++,
            // <?hi there
            PROC_INST_ENDING: x++,
            // <?hi "there" ?
            OPEN_TAG: x++,
            // <strong
            OPEN_TAG_SLASH: x++,
            // <strong /
            ATTRIB: x++,
            // <a
            ATTRIB_NAME: x++,
            // <a foo
            ATTRIB_NAME_SAW_WHITE: x++,
            // <a foo _
            ATTRIB_VALUE: x++,
            // <a foo=
            ATTRIB_VALUE_QUOTED: x++,
            // <a foo="bar
            ATTRIB_VALUE_CLOSED: x++,
            // <a foo="bar"
            ATTRIB_VALUE_UNQUOTED: x++,
            // <a foo=bar
            ATTRIB_VALUE_ENTITY_Q: x++,
            // <foo bar="&quot;"
            ATTRIB_VALUE_ENTITY_U: x++,
            // <foo bar=&quot
            CLOSE_TAG: x++,
            // </a
            CLOSE_TAG_SAW_WHITE: x++,
            // </a   >
            SCRIPT: x++,
            // <script> ...
            SCRIPT_ENDING: x++
            // <script> ... <
          }, Z.XML_ENTITIES = {
            amp: "&",
            gt: ">",
            lt: "<",
            quot: '"',
            apos: "'"
          }, Z.ENTITIES = {
            amp: "&",
            gt: ">",
            lt: "<",
            quot: '"',
            apos: "'",
            AElig: 198,
            Aacute: 193,
            Acirc: 194,
            Agrave: 192,
            Aring: 197,
            Atilde: 195,
            Auml: 196,
            Ccedil: 199,
            ETH: 208,
            Eacute: 201,
            Ecirc: 202,
            Egrave: 200,
            Euml: 203,
            Iacute: 205,
            Icirc: 206,
            Igrave: 204,
            Iuml: 207,
            Ntilde: 209,
            Oacute: 211,
            Ocirc: 212,
            Ograve: 210,
            Oslash: 216,
            Otilde: 213,
            Ouml: 214,
            THORN: 222,
            Uacute: 218,
            Ucirc: 219,
            Ugrave: 217,
            Uuml: 220,
            Yacute: 221,
            aacute: 225,
            acirc: 226,
            aelig: 230,
            agrave: 224,
            aring: 229,
            atilde: 227,
            auml: 228,
            ccedil: 231,
            eacute: 233,
            ecirc: 234,
            egrave: 232,
            eth: 240,
            euml: 235,
            iacute: 237,
            icirc: 238,
            igrave: 236,
            iuml: 239,
            ntilde: 241,
            oacute: 243,
            ocirc: 244,
            ograve: 242,
            oslash: 248,
            otilde: 245,
            ouml: 246,
            szlig: 223,
            thorn: 254,
            uacute: 250,
            ucirc: 251,
            ugrave: 249,
            uuml: 252,
            yacute: 253,
            yuml: 255,
            copy: 169,
            reg: 174,
            nbsp: 160,
            iexcl: 161,
            cent: 162,
            pound: 163,
            curren: 164,
            yen: 165,
            brvbar: 166,
            sect: 167,
            uml: 168,
            ordf: 170,
            laquo: 171,
            not: 172,
            shy: 173,
            macr: 175,
            deg: 176,
            plusmn: 177,
            sup1: 185,
            sup2: 178,
            sup3: 179,
            acute: 180,
            micro: 181,
            para: 182,
            middot: 183,
            cedil: 184,
            ordm: 186,
            raquo: 187,
            frac14: 188,
            frac12: 189,
            frac34: 190,
            iquest: 191,
            times: 215,
            divide: 247,
            OElig: 338,
            oelig: 339,
            Scaron: 352,
            scaron: 353,
            Yuml: 376,
            fnof: 402,
            circ: 710,
            tilde: 732,
            Alpha: 913,
            Beta: 914,
            Gamma: 915,
            Delta: 916,
            Epsilon: 917,
            Zeta: 918,
            Eta: 919,
            Theta: 920,
            Iota: 921,
            Kappa: 922,
            Lambda: 923,
            Mu: 924,
            Nu: 925,
            Xi: 926,
            Omicron: 927,
            Pi: 928,
            Rho: 929,
            Sigma: 931,
            Tau: 932,
            Upsilon: 933,
            Phi: 934,
            Chi: 935,
            Psi: 936,
            Omega: 937,
            alpha: 945,
            beta: 946,
            gamma: 947,
            delta: 948,
            epsilon: 949,
            zeta: 950,
            eta: 951,
            theta: 952,
            iota: 953,
            kappa: 954,
            lambda: 955,
            mu: 956,
            nu: 957,
            xi: 958,
            omicron: 959,
            pi: 960,
            rho: 961,
            sigmaf: 962,
            sigma: 963,
            tau: 964,
            upsilon: 965,
            phi: 966,
            chi: 967,
            psi: 968,
            omega: 969,
            thetasym: 977,
            upsih: 978,
            piv: 982,
            ensp: 8194,
            emsp: 8195,
            thinsp: 8201,
            zwnj: 8204,
            zwj: 8205,
            lrm: 8206,
            rlm: 8207,
            ndash: 8211,
            mdash: 8212,
            lsquo: 8216,
            rsquo: 8217,
            sbquo: 8218,
            ldquo: 8220,
            rdquo: 8221,
            bdquo: 8222,
            dagger: 8224,
            Dagger: 8225,
            bull: 8226,
            hellip: 8230,
            permil: 8240,
            prime: 8242,
            Prime: 8243,
            lsaquo: 8249,
            rsaquo: 8250,
            oline: 8254,
            frasl: 8260,
            euro: 8364,
            image: 8465,
            weierp: 8472,
            real: 8476,
            trade: 8482,
            alefsym: 8501,
            larr: 8592,
            uarr: 8593,
            rarr: 8594,
            darr: 8595,
            harr: 8596,
            crarr: 8629,
            lArr: 8656,
            uArr: 8657,
            rArr: 8658,
            dArr: 8659,
            hArr: 8660,
            forall: 8704,
            part: 8706,
            exist: 8707,
            empty: 8709,
            nabla: 8711,
            isin: 8712,
            notin: 8713,
            ni: 8715,
            prod: 8719,
            sum: 8721,
            minus: 8722,
            lowast: 8727,
            radic: 8730,
            prop: 8733,
            infin: 8734,
            ang: 8736,
            and: 8743,
            or: 8744,
            cap: 8745,
            cup: 8746,
            int: 8747,
            there4: 8756,
            sim: 8764,
            cong: 8773,
            asymp: 8776,
            ne: 8800,
            equiv: 8801,
            le: 8804,
            ge: 8805,
            sub: 8834,
            sup: 8835,
            nsub: 8836,
            sube: 8838,
            supe: 8839,
            oplus: 8853,
            otimes: 8855,
            perp: 8869,
            sdot: 8901,
            lceil: 8968,
            rceil: 8969,
            lfloor: 8970,
            rfloor: 8971,
            lang: 9001,
            rang: 9002,
            loz: 9674,
            spades: 9824,
            clubs: 9827,
            hearts: 9829,
            diams: 9830
          }, Object.keys(Z.ENTITIES).forEach(function(q) {
            var N = Z.ENTITIES[q], Q = typeof N == "number" ? String.fromCharCode(N) : N;
            Z.ENTITIES[q] = Q;
          });
          for (var f in Z.STATE)
            Z.STATE[Z.STATE[f]] = f;
          x = Z.STATE;
          function U(q, N, Q) {
            q[N] && q[N](Q);
          }
          function O(q, N, Q) {
            q.textNode && S(q), U(q, N, Q);
          }
          function S(q) {
            q.textNode = F(q.opt, q.textNode), q.textNode && U(q, "ontext", q.textNode), q.textNode = "";
          }
          function F(q, N) {
            return q.trim && (N = N.trim()), q.normalize && (N = N.replace(/\s+/g, " ")), N;
          }
          function T(q, N) {
            return S(q), q.trackPosition && (N += `
Line: ` + q.line + `
Column: ` + q.column + `
Char: ` + q.c), N = new Error(N), q.error = N, U(q, "onerror", N), q;
          }
          function I(q) {
            return q.sawRoot && !q.closedRoot && M(q, "Unclosed root tag"), q.state !== x.BEGIN && q.state !== x.BEGIN_WHITESPACE && q.state !== x.TEXT && T(q, "Unexpected end"), S(q), q.c = "", q.closed = !0, U(q, "onend"), C.call(q, q.strict, q.opt), q;
          }
          function M(q, N) {
            if (typeof q != "object" || !(q instanceof C))
              throw new Error("bad call to strictFail");
            q.strict && T(q, N);
          }
          function V(q) {
            q.strict || (q.tagName = q.tagName[q.looseCase]());
            var N = q.tags[q.tags.length - 1] || q, Q = q.tag = { name: q.tagName, attributes: {} };
            q.opt.xmlns && (Q.ns = N.ns), q.attribList.length = 0;
          }
          function J(q, N) {
            var Q = q.indexOf(":"), D = Q < 0 ? ["", q] : q.split(":"), ne = D[0], oe = D[1];
            return N && q === "xmlns" && (ne = "xmlns", oe = ""), { prefix: ne, local: oe };
          }
          function W(q) {
            if (q.strict || (q.attribName = q.attribName[q.looseCase]()), q.attribList.indexOf(q.attribName) !== -1 || q.tag.attributes.hasOwnProperty(q.attribName)) {
              q.attribName = q.attribValue = "";
              return;
            }
            if (q.opt.xmlns) {
              var N = J(q.attribName, !0), Q = N.prefix, D = N.local;
              if (Q === "xmlns")
                if (D === "xml" && q.attribValue !== u)
                  M(
                    q,
                    "xml: prefix must be bound to " + u + `
Actual: ` + q.attribValue
                  );
                else if (D === "xmlns" && q.attribValue !== w)
                  M(
                    q,
                    "xmlns: prefix must be bound to " + w + `
Actual: ` + q.attribValue
                  );
                else {
                  var ne = q.tag, oe = q.tags[q.tags.length - 1] || q;
                  ne.ns === oe.ns && (ne.ns = Object.create(oe.ns)), ne.ns[D] = q.attribValue;
                }
              q.attribList.push([q.attribName, q.attribValue]);
            } else
              q.tag.attributes[q.attribName] = q.attribValue, O(q, "onattribute", {
                name: q.attribName,
                value: q.attribValue
              });
            q.attribName = q.attribValue = "";
          }
          function z(q, N) {
            if (q.opt.xmlns) {
              var Q = q.tag, D = J(q.tagName);
              Q.prefix = D.prefix, Q.local = D.local, Q.uri = Q.ns[D.prefix] || "", Q.prefix && !Q.uri && (M(q, "Unbound namespace prefix: " + JSON.stringify(q.tagName)), Q.uri = D.prefix);
              var ne = q.tags[q.tags.length - 1] || q;
              Q.ns && ne.ns !== Q.ns && Object.keys(Q.ns).forEach(function(xe) {
                O(q, "onopennamespace", {
                  prefix: xe,
                  uri: Q.ns[xe]
                });
              });
              for (var oe = 0, ee = q.attribList.length; oe < ee; oe++) {
                var $ = q.attribList[oe], E = $[0], H = $[1], ie = J(E, !0), ue = ie.prefix, fe = ie.local, de = ue === "" ? "" : Q.ns[ue] || "", pe = {
                  name: E,
                  value: H,
                  prefix: ue,
                  local: fe,
                  uri: de
                };
                ue && ue !== "xmlns" && !de && (M(q, "Unbound namespace prefix: " + JSON.stringify(ue)), pe.uri = ue), q.tag.attributes[E] = pe, O(q, "onattribute", pe);
              }
              q.attribList.length = 0;
            }
            q.tag.isSelfClosing = !!N, q.sawRoot = !0, q.tags.push(q.tag), O(q, "onopentag", q.tag), N || (!q.noscript && q.tagName.toLowerCase() === "script" ? q.state = x.SCRIPT : q.state = x.TEXT, q.tag = null, q.tagName = ""), q.attribName = q.attribValue = "", q.attribList.length = 0;
          }
          function G(q) {
            if (!q.tagName) {
              M(q, "Weird empty close tag."), q.textNode += "</>", q.state = x.TEXT;
              return;
            }
            if (q.script) {
              if (q.tagName !== "script") {
                q.script += "</" + q.tagName + ">", q.tagName = "", q.state = x.SCRIPT;
                return;
              }
              O(q, "onscript", q.script), q.script = "";
            }
            var N = q.tags.length, Q = q.tagName;
            q.strict || (Q = Q[q.looseCase]());
            for (var D = Q; N--; ) {
              var ne = q.tags[N];
              if (ne.name !== D)
                M(q, "Unexpected close tag");
              else
                break;
            }
            if (N < 0) {
              M(q, "Unmatched closing tag: " + q.tagName), q.textNode += "</" + q.tagName + ">", q.state = x.TEXT;
              return;
            }
            q.tagName = Q;
            for (var oe = q.tags.length; oe-- > N; ) {
              var ee = q.tag = q.tags.pop();
              q.tagName = q.tag.name, O(q, "onclosetag", q.tagName);
              var $ = {};
              for (var E in ee.ns)
                $[E] = ee.ns[E];
              var H = q.tags[q.tags.length - 1] || q;
              q.opt.xmlns && ee.ns !== H.ns && Object.keys(ee.ns).forEach(function(ie) {
                var ue = ee.ns[ie];
                O(q, "onclosenamespace", { prefix: ie, uri: ue });
              });
            }
            N === 0 && (q.closedRoot = !0), q.tagName = q.attribValue = q.attribName = "", q.attribList.length = 0, q.state = x.TEXT;
          }
          function L(q) {
            var N = q.entity, Q = N.toLowerCase(), D, ne = "";
            return q.ENTITIES[N] ? q.ENTITIES[N] : q.ENTITIES[Q] ? q.ENTITIES[Q] : (N = Q, N.charAt(0) === "#" && (N.charAt(1) === "x" ? (N = N.slice(2), D = parseInt(N, 16), ne = D.toString(16)) : (N = N.slice(1), D = parseInt(N, 10), ne = D.toString(10))), N = N.replace(/^0+/, ""), ne.toLowerCase() !== N ? (M(q, "Invalid character entity"), "&" + q.entity + ";") : String.fromCodePoint(D));
          }
          function K(q, N) {
            N === "<" ? (q.state = x.OPEN_WAKA, q.startTagPosition = q.position) : k(d, N) && (M(q, "Non-whitespace before first tag."), q.textNode = N, q.state = x.TEXT);
          }
          function te(q, N) {
            var Q = "";
            return N < q.length && (Q = q.charAt(N)), Q;
          }
          function se(q) {
            var N = this;
            if (this.error)
              throw this.error;
            if (N.closed)
              return T(
                N,
                "Cannot write after close. Assign an onready handler."
              );
            if (q === null)
              return I(N);
            typeof q == "object" && (q = q.toString());
            for (var Q = 0, D = ""; D = te(q, Q++), N.c = D, !!D; )
              switch (N.trackPosition && (N.position++, D === `
` ? (N.line++, N.column = 0) : N.column++), N.state) {
                case x.BEGIN:
                  if (N.state = x.BEGIN_WHITESPACE, D === "\uFEFF")
                    continue;
                  K(N, D);
                  continue;
                case x.BEGIN_WHITESPACE:
                  K(N, D);
                  continue;
                case x.TEXT:
                  if (N.sawRoot && !N.closedRoot) {
                    for (var ne = Q - 1; D && D !== "<" && D !== "&"; )
                      D = te(q, Q++), D && N.trackPosition && (N.position++, D === `
` ? (N.line++, N.column = 0) : N.column++);
                    N.textNode += q.substring(ne, Q - 1);
                  }
                  D === "<" && !(N.sawRoot && N.closedRoot && !N.strict) ? (N.state = x.OPEN_WAKA, N.startTagPosition = N.position) : (k(d, D) && (!N.sawRoot || N.closedRoot) && M(N, "Text data outside of root node."), D === "&" ? N.state = x.TEXT_ENTITY : N.textNode += D);
                  continue;
                case x.SCRIPT:
                  D === "<" ? N.state = x.SCRIPT_ENDING : N.script += D;
                  continue;
                case x.SCRIPT_ENDING:
                  D === "/" ? N.state = x.CLOSE_TAG : (N.script += "<" + D, N.state = x.SCRIPT);
                  continue;
                case x.OPEN_WAKA:
                  if (D === "!")
                    N.state = x.SGML_DECL, N.sgmlDecl = "";
                  else if (!R(d, D))
                    if (R(b, D))
                      N.state = x.OPEN_TAG, N.tagName = D;
                    else if (D === "/")
                      N.state = x.CLOSE_TAG, N.tagName = "";
                    else if (D === "?")
                      N.state = x.PROC_INST, N.procInstName = N.procInstBody = "";
                    else {
                      if (M(N, "Unencoded <"), N.startTagPosition + 1 < N.position) {
                        var oe = N.position - N.startTagPosition;
                        D = new Array(oe).join(" ") + D;
                      }
                      N.textNode += "<" + D, N.state = x.TEXT;
                    }
                  continue;
                case x.SGML_DECL:
                  (N.sgmlDecl + D).toUpperCase() === i ? (O(N, "onopencdata"), N.state = x.CDATA, N.sgmlDecl = "", N.cdata = "") : N.sgmlDecl + D === "--" ? (N.state = x.COMMENT, N.comment = "", N.sgmlDecl = "") : (N.sgmlDecl + D).toUpperCase() === l ? (N.state = x.DOCTYPE, (N.doctype || N.sawRoot) && M(
                    N,
                    "Inappropriately located doctype declaration"
                  ), N.doctype = "", N.sgmlDecl = "") : D === ">" ? (O(N, "onsgmldeclaration", N.sgmlDecl), N.sgmlDecl = "", N.state = x.TEXT) : (R(g, D) && (N.state = x.SGML_DECL_QUOTED), N.sgmlDecl += D);
                  continue;
                case x.SGML_DECL_QUOTED:
                  D === N.q && (N.state = x.SGML_DECL, N.q = ""), N.sgmlDecl += D;
                  continue;
                case x.DOCTYPE:
                  D === ">" ? (N.state = x.TEXT, O(N, "ondoctype", N.doctype), N.doctype = !0) : (N.doctype += D, D === "[" ? N.state = x.DOCTYPE_DTD : R(g, D) && (N.state = x.DOCTYPE_QUOTED, N.q = D));
                  continue;
                case x.DOCTYPE_QUOTED:
                  N.doctype += D, D === N.q && (N.q = "", N.state = x.DOCTYPE);
                  continue;
                case x.DOCTYPE_DTD:
                  N.doctype += D, D === "]" ? N.state = x.DOCTYPE : R(g, D) && (N.state = x.DOCTYPE_DTD_QUOTED, N.q = D);
                  continue;
                case x.DOCTYPE_DTD_QUOTED:
                  N.doctype += D, D === N.q && (N.state = x.DOCTYPE_DTD, N.q = "");
                  continue;
                case x.COMMENT:
                  D === "-" ? N.state = x.COMMENT_ENDING : N.comment += D;
                  continue;
                case x.COMMENT_ENDING:
                  D === "-" ? (N.state = x.COMMENT_ENDED, N.comment = F(N.opt, N.comment), N.comment && O(N, "oncomment", N.comment), N.comment = "") : (N.comment += "-" + D, N.state = x.COMMENT);
                  continue;
                case x.COMMENT_ENDED:
                  D !== ">" ? (M(N, "Malformed comment"), N.comment += "--" + D, N.state = x.COMMENT) : N.state = x.TEXT;
                  continue;
                case x.CDATA:
                  D === "]" ? N.state = x.CDATA_ENDING : N.cdata += D;
                  continue;
                case x.CDATA_ENDING:
                  D === "]" ? N.state = x.CDATA_ENDING_2 : (N.cdata += "]" + D, N.state = x.CDATA);
                  continue;
                case x.CDATA_ENDING_2:
                  D === ">" ? (N.cdata && O(N, "oncdata", N.cdata), O(N, "onclosecdata"), N.cdata = "", N.state = x.TEXT) : D === "]" ? N.cdata += "]" : (N.cdata += "]]" + D, N.state = x.CDATA);
                  continue;
                case x.PROC_INST:
                  D === "?" ? N.state = x.PROC_INST_ENDING : R(d, D) ? N.state = x.PROC_INST_BODY : N.procInstName += D;
                  continue;
                case x.PROC_INST_BODY:
                  if (!N.procInstBody && R(d, D))
                    continue;
                  D === "?" ? N.state = x.PROC_INST_ENDING : N.procInstBody += D;
                  continue;
                case x.PROC_INST_ENDING:
                  D === ">" ? (O(N, "onprocessinginstruction", {
                    name: N.procInstName,
                    body: N.procInstBody
                  }), N.procInstName = N.procInstBody = "", N.state = x.TEXT) : (N.procInstBody += "?" + D, N.state = x.PROC_INST_BODY);
                  continue;
                case x.OPEN_TAG:
                  R(A, D) ? N.tagName += D : (V(N), D === ">" ? z(N) : D === "/" ? N.state = x.OPEN_TAG_SLASH : (k(d, D) && M(N, "Invalid character in tag name"), N.state = x.ATTRIB));
                  continue;
                case x.OPEN_TAG_SLASH:
                  D === ">" ? (z(N, !0), G(N)) : (M(N, "Forward-slash in opening tag not followed by >"), N.state = x.ATTRIB);
                  continue;
                case x.ATTRIB:
                  if (R(d, D))
                    continue;
                  D === ">" ? z(N) : D === "/" ? N.state = x.OPEN_TAG_SLASH : R(b, D) ? (N.attribName = D, N.attribValue = "", N.state = x.ATTRIB_NAME) : M(N, "Invalid attribute name");
                  continue;
                case x.ATTRIB_NAME:
                  D === "=" ? N.state = x.ATTRIB_VALUE : D === ">" ? (M(N, "Attribute without value"), N.attribValue = N.attribName, W(N), z(N)) : R(d, D) ? N.state = x.ATTRIB_NAME_SAW_WHITE : R(A, D) ? N.attribName += D : M(N, "Invalid attribute name");
                  continue;
                case x.ATTRIB_NAME_SAW_WHITE:
                  if (D === "=")
                    N.state = x.ATTRIB_VALUE;
                  else {
                    if (R(d, D))
                      continue;
                    M(N, "Attribute without value"), N.tag.attributes[N.attribName] = "", N.attribValue = "", O(N, "onattribute", {
                      name: N.attribName,
                      value: ""
                    }), N.attribName = "", D === ">" ? z(N) : R(b, D) ? (N.attribName = D, N.state = x.ATTRIB_NAME) : (M(N, "Invalid attribute name"), N.state = x.ATTRIB);
                  }
                  continue;
                case x.ATTRIB_VALUE:
                  if (R(d, D))
                    continue;
                  R(g, D) ? (N.q = D, N.state = x.ATTRIB_VALUE_QUOTED) : (M(N, "Unquoted attribute value"), N.state = x.ATTRIB_VALUE_UNQUOTED, N.attribValue = D);
                  continue;
                case x.ATTRIB_VALUE_QUOTED:
                  if (D !== N.q) {
                    D === "&" ? N.state = x.ATTRIB_VALUE_ENTITY_Q : N.attribValue += D;
                    continue;
                  }
                  W(N), N.q = "", N.state = x.ATTRIB_VALUE_CLOSED;
                  continue;
                case x.ATTRIB_VALUE_CLOSED:
                  R(d, D) ? N.state = x.ATTRIB : D === ">" ? z(N) : D === "/" ? N.state = x.OPEN_TAG_SLASH : R(b, D) ? (M(N, "No whitespace between attributes"), N.attribName = D, N.attribValue = "", N.state = x.ATTRIB_NAME) : M(N, "Invalid attribute name");
                  continue;
                case x.ATTRIB_VALUE_UNQUOTED:
                  if (k(n, D)) {
                    D === "&" ? N.state = x.ATTRIB_VALUE_ENTITY_U : N.attribValue += D;
                    continue;
                  }
                  W(N), D === ">" ? z(N) : N.state = x.ATTRIB;
                  continue;
                case x.CLOSE_TAG:
                  if (N.tagName)
                    D === ">" ? G(N) : R(A, D) ? N.tagName += D : N.script ? (N.script += "</" + N.tagName, N.tagName = "", N.state = x.SCRIPT) : (k(d, D) && M(N, "Invalid tagname in closing tag"), N.state = x.CLOSE_TAG_SAW_WHITE);
                  else {
                    if (R(d, D))
                      continue;
                    k(b, D) ? N.script ? (N.script += "</" + D, N.state = x.SCRIPT) : M(N, "Invalid tagname in closing tag.") : N.tagName = D;
                  }
                  continue;
                case x.CLOSE_TAG_SAW_WHITE:
                  if (R(d, D))
                    continue;
                  D === ">" ? G(N) : M(N, "Invalid characters in closing tag");
                  continue;
                case x.TEXT_ENTITY:
                case x.ATTRIB_VALUE_ENTITY_Q:
                case x.ATTRIB_VALUE_ENTITY_U:
                  var ee, $;
                  switch (N.state) {
                    case x.TEXT_ENTITY:
                      ee = x.TEXT, $ = "textNode";
                      break;
                    case x.ATTRIB_VALUE_ENTITY_Q:
                      ee = x.ATTRIB_VALUE_QUOTED, $ = "attribValue";
                      break;
                    case x.ATTRIB_VALUE_ENTITY_U:
                      ee = x.ATTRIB_VALUE_UNQUOTED, $ = "attribValue";
                      break;
                  }
                  D === ";" ? (N[$] += L(N), N.entity = "", N.state = ee) : R(N.entity.length ? j : Y, D) ? N.entity += D : (M(N, "Invalid character in entity name"), N[$] += "&" + N.entity + D, N.entity = "", N.state = ee);
                  continue;
                default:
                  throw new Error(N, "Unknown state: " + N.state);
              }
            return N.position >= N.bufferCheckPosition && t(N), N;
          }
          /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
          String.fromCodePoint || function() {
            var q = String.fromCharCode, N = Math.floor, Q = function() {
              var D = 16384, ne = [], oe, ee, $ = -1, E = arguments.length;
              if (!E)
                return "";
              for (var H = ""; ++$ < E; ) {
                var ie = Number(arguments[$]);
                if (!isFinite(ie) || // `NaN`, `+Infinity`, or `-Infinity`
                ie < 0 || // not a valid Unicode code point
                ie > 1114111 || // not a valid Unicode code point
                N(ie) !== ie)
                  throw RangeError("Invalid code point: " + ie);
                ie <= 65535 ? ne.push(ie) : (ie -= 65536, oe = (ie >> 10) + 55296, ee = ie % 1024 + 56320, ne.push(oe, ee)), ($ + 1 === E || ne.length > D) && (H += q.apply(null, ne), ne.length = 0);
              }
              return H;
            };
            Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
              value: Q,
              configurable: !0,
              writable: !0
            }) : String.fromCodePoint = Q;
          }();
        })(typeof re > "u" ? this.sax = {} : re);
      }).call(this, le("buffer").Buffer);
    }, { buffer: 78, stream: 115, string_decoder: 116 }], 115: [function(le, ce, re) {
      ce.exports = o;
      var ae = le("events").EventEmitter, Z = le("inherits");
      Z(o, ae), o.Readable = le("readable-stream/readable.js"), o.Writable = le("readable-stream/writable.js"), o.Duplex = le("readable-stream/duplex.js"), o.Transform = le("readable-stream/transform.js"), o.PassThrough = le("readable-stream/passthrough.js"), o.Stream = o;
      function o() {
        ae.call(this);
      }
      o.prototype.pipe = function(C, t) {
        var a = this;
        function v(m) {
          C.writable && C.write(m) === !1 && a.pause && a.pause();
        }
        a.on("data", v);
        function h() {
          a.readable && a.resume && a.resume();
        }
        C.on("drain", h), !C._isStdio && (!t || t.end !== !1) && (a.on("end", y), a.on("close", c));
        var e = !1;
        function y() {
          e || (e = !0, C.end());
        }
        function c() {
          e || (e = !0, typeof C.destroy == "function" && C.destroy());
        }
        function d(m) {
          if (p(), ae.listenerCount(this, "error") === 0)
            throw m;
        }
        a.on("error", d), C.on("error", d);
        function p() {
          a.removeListener("data", v), C.removeListener("drain", h), a.removeListener("end", y), a.removeListener("close", c), a.removeListener("error", d), C.removeListener("error", d), a.removeListener("end", p), a.removeListener("close", p), C.removeListener("close", p);
        }
        return a.on("end", p), a.on("close", p), C.on("close", p), C.emit("pipe", a), C;
      };
    }, { events: 82, inherits: 84, "readable-stream/duplex.js": 103, "readable-stream/passthrough.js": 110, "readable-stream/readable.js": 111, "readable-stream/transform.js": 112, "readable-stream/writable.js": 113 }], 116: [function(le, ce, re) {
      var ae = le("buffer").Buffer, Z = ae.isEncoding || function(h) {
        switch (h && h.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return !0;
          default:
            return !1;
        }
      };
      function o(h) {
        if (h && !Z(h))
          throw new Error("Unknown encoding: " + h);
      }
      var C = re.StringDecoder = function(h) {
        switch (this.encoding = (h || "utf8").toLowerCase().replace(/[-_]/, ""), o(h), this.encoding) {
          case "utf8":
            this.surrogateSize = 3;
            break;
          case "ucs2":
          case "utf16le":
            this.surrogateSize = 2, this.detectIncompleteChar = a;
            break;
          case "base64":
            this.surrogateSize = 3, this.detectIncompleteChar = v;
            break;
          default:
            this.write = t;
            return;
        }
        this.charBuffer = new ae(6), this.charReceived = 0, this.charLength = 0;
      };
      C.prototype.write = function(h) {
        for (var e = ""; this.charLength; ) {
          var y = h.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : h.length;
          if (h.copy(this.charBuffer, this.charReceived, 0, y), this.charReceived += y, this.charReceived < this.charLength)
            return "";
          h = h.slice(y, h.length), e = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
          var d = e.charCodeAt(e.length - 1);
          if (d >= 55296 && d <= 56319) {
            this.charLength += this.surrogateSize, e = "";
            continue;
          }
          if (this.charReceived = this.charLength = 0, h.length === 0)
            return e;
          break;
        }
        this.detectIncompleteChar(h);
        var c = h.length;
        this.charLength && (h.copy(this.charBuffer, 0, h.length - this.charReceived, c), c -= this.charReceived), e += h.toString(this.encoding, 0, c);
        var c = e.length - 1, d = e.charCodeAt(c);
        if (d >= 55296 && d <= 56319) {
          var p = this.surrogateSize;
          return this.charLength += p, this.charReceived += p, this.charBuffer.copy(this.charBuffer, p, 0, p), h.copy(this.charBuffer, 0, 0, p), e.substring(0, c);
        }
        return e;
      }, C.prototype.detectIncompleteChar = function(h) {
        for (var e = h.length >= 3 ? 3 : h.length; e > 0; e--) {
          var y = h[h.length - e];
          if (e == 1 && y >> 5 == 6) {
            this.charLength = 2;
            break;
          }
          if (e <= 2 && y >> 4 == 14) {
            this.charLength = 3;
            break;
          }
          if (e <= 3 && y >> 3 == 30) {
            this.charLength = 4;
            break;
          }
        }
        this.charReceived = e;
      }, C.prototype.end = function(h) {
        var e = "";
        if (h && h.length && (e = this.write(h)), this.charReceived) {
          var y = this.charReceived, c = this.charBuffer, d = this.encoding;
          e += c.slice(0, y).toString(d);
        }
        return e;
      };
      function t(h) {
        return h.toString(this.encoding);
      }
      function a(h) {
        this.charReceived = h.length % 2, this.charLength = this.charReceived ? 2 : 0;
      }
      function v(h) {
        this.charReceived = h.length % 3, this.charLength = this.charReceived ? 3 : 0;
      }
    }, { buffer: 78 }], 117: [function(le, ce, re) {
      (function(ae) {
        (function(Z, o) {
          typeof re == "object" && typeof ce < "u" ? ce.exports = o() : (Z = typeof globalThis < "u" ? globalThis : Z || self, function() {
            var C = Z._, t = Z._ = o();
            t.noConflict = function() {
              return Z._ = C, t;
            };
          }());
        })(this, function() {
          var Z = "1.13.1", o = typeof self == "object" && self.self === self && self || typeof ae == "object" && ae.global === ae && ae || Function("return this")() || {}, C = Array.prototype, t = Object.prototype, a = typeof Symbol < "u" ? Symbol.prototype : null, v = C.push, h = C.slice, e = t.toString, y = t.hasOwnProperty, c = typeof ArrayBuffer < "u", d = typeof DataView < "u", p = Array.isArray, m = Object.keys, g = Object.create, n = c && ArrayBuffer.isView, i = isNaN, l = isFinite, u = !{ toString: null }.propertyIsEnumerable("toString"), w = [
            "valueOf",
            "isPrototypeOf",
            "toString",
            "propertyIsEnumerable",
            "hasOwnProperty",
            "toLocaleString"
          ], _ = Math.pow(2, 53) - 1;
          function b(me, Fe) {
            return Fe = Fe == null ? me.length - 1 : +Fe, function() {
              for (var Re = Math.max(arguments.length - Fe, 0), Be = Array(Re), ze = 0; ze < Re; ze++)
                Be[ze] = arguments[ze + Fe];
              switch (Fe) {
                case 0:
                  return me.call(this, Be);
                case 1:
                  return me.call(this, arguments[0], Be);
                case 2:
                  return me.call(this, arguments[0], arguments[1], Be);
              }
              var $e = Array(Fe + 1);
              for (ze = 0; ze < Fe; ze++)
                $e[ze] = arguments[ze];
              return $e[Fe] = Be, me.apply(this, $e);
            };
          }
          function A(me) {
            var Fe = typeof me;
            return Fe === "function" || Fe === "object" && !!me;
          }
          function Y(me) {
            return me === null;
          }
          function j(me) {
            return me === void 0;
          }
          function X(me) {
            return me === !0 || me === !1 || e.call(me) === "[object Boolean]";
          }
          function B(me) {
            return !!(me && me.nodeType === 1);
          }
          function R(me) {
            var Fe = "[object " + me + "]";
            return function(Re) {
              return e.call(Re) === Fe;
            };
          }
          var k = R("String"), x = R("Number"), f = R("Date"), U = R("RegExp"), O = R("Error"), S = R("Symbol"), F = R("ArrayBuffer"), T = R("Function"), I = o.document && o.document.childNodes;
          typeof /./ != "function" && typeof Int8Array != "object" && typeof I != "function" && (T = function(me) {
            return typeof me == "function" || !1;
          });
          var M = T, V = R("Object"), J = d && V(new DataView(new ArrayBuffer(8))), W = typeof Map < "u" && V(/* @__PURE__ */ new Map()), z = R("DataView");
          function G(me) {
            return me != null && M(me.getInt8) && F(me.buffer);
          }
          var L = J ? G : z, K = p || R("Array");
          function te(me, Fe) {
            return me != null && y.call(me, Fe);
          }
          var se = R("Arguments");
          (function() {
            se(arguments) || (se = function(me) {
              return te(me, "callee");
            });
          })();
          var q = se;
          function N(me) {
            return !S(me) && l(me) && !isNaN(parseFloat(me));
          }
          function Q(me) {
            return x(me) && i(me);
          }
          function D(me) {
            return function() {
              return me;
            };
          }
          function ne(me) {
            return function(Fe) {
              var Re = me(Fe);
              return typeof Re == "number" && Re >= 0 && Re <= _;
            };
          }
          function oe(me) {
            return function(Fe) {
              return Fe == null ? void 0 : Fe[me];
            };
          }
          var ee = oe("byteLength"), $ = ne(ee), E = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
          function H(me) {
            return n ? n(me) && !L(me) : $(me) && E.test(e.call(me));
          }
          var ie = c ? H : D(!1), ue = oe("length");
          function fe(me) {
            for (var Fe = {}, Re = me.length, Be = 0; Be < Re; ++Be)
              Fe[me[Be]] = !0;
            return {
              contains: function(ze) {
                return Fe[ze];
              },
              push: function(ze) {
                return Fe[ze] = !0, me.push(ze);
              }
            };
          }
          function de(me, Fe) {
            Fe = fe(Fe);
            var Re = w.length, Be = me.constructor, ze = M(Be) && Be.prototype || t, $e = "constructor";
            for (te(me, $e) && !Fe.contains($e) && Fe.push($e); Re--; )
              $e = w[Re], $e in me && me[$e] !== ze[$e] && !Fe.contains($e) && Fe.push($e);
          }
          function pe(me) {
            if (!A(me))
              return [];
            if (m)
              return m(me);
            var Fe = [];
            for (var Re in me)
              te(me, Re) && Fe.push(Re);
            return u && de(me, Fe), Fe;
          }
          function xe(me) {
            if (me == null)
              return !0;
            var Fe = ue(me);
            return typeof Fe == "number" && (K(me) || k(me) || q(me)) ? Fe === 0 : ue(pe(me)) === 0;
          }
          function De(me, Fe) {
            var Re = pe(Fe), Be = Re.length;
            if (me == null)
              return !Be;
            for (var ze = Object(me), $e = 0; $e < Be; $e++) {
              var lt = Re[$e];
              if (Fe[lt] !== ze[lt] || !(lt in ze))
                return !1;
            }
            return !0;
          }
          function Ae(me) {
            if (me instanceof Ae)
              return me;
            if (!(this instanceof Ae))
              return new Ae(me);
            this._wrapped = me;
          }
          Ae.VERSION = Z, Ae.prototype.value = function() {
            return this._wrapped;
          }, Ae.prototype.valueOf = Ae.prototype.toJSON = Ae.prototype.value, Ae.prototype.toString = function() {
            return String(this._wrapped);
          };
          function Se(me) {
            return new Uint8Array(
              me.buffer || me,
              me.byteOffset || 0,
              ee(me)
            );
          }
          var ke = "[object DataView]";
          function ye(me, Fe, Re, Be) {
            if (me === Fe)
              return me !== 0 || 1 / me === 1 / Fe;
            if (me == null || Fe == null)
              return !1;
            if (me !== me)
              return Fe !== Fe;
            var ze = typeof me;
            return ze !== "function" && ze !== "object" && typeof Fe != "object" ? !1 : _e(me, Fe, Re, Be);
          }
          function _e(me, Fe, Re, Be) {
            me instanceof Ae && (me = me._wrapped), Fe instanceof Ae && (Fe = Fe._wrapped);
            var ze = e.call(me);
            if (ze !== e.call(Fe))
              return !1;
            if (J && ze == "[object Object]" && L(me)) {
              if (!L(Fe))
                return !1;
              ze = ke;
            }
            switch (ze) {
              case "[object RegExp]":
              case "[object String]":
                return "" + me == "" + Fe;
              case "[object Number]":
                return +me != +me ? +Fe != +Fe : +me == 0 ? 1 / +me === 1 / Fe : +me == +Fe;
              case "[object Date]":
              case "[object Boolean]":
                return +me == +Fe;
              case "[object Symbol]":
                return a.valueOf.call(me) === a.valueOf.call(Fe);
              case "[object ArrayBuffer]":
              case ke:
                return _e(Se(me), Se(Fe), Re, Be);
            }
            var $e = ze === "[object Array]";
            if (!$e && ie(me)) {
              var lt = ee(me);
              if (lt !== ee(Fe))
                return !1;
              if (me.buffer === Fe.buffer && me.byteOffset === Fe.byteOffset)
                return !0;
              $e = !0;
            }
            if (!$e) {
              if (typeof me != "object" || typeof Fe != "object")
                return !1;
              var At = me.constructor, $t = Fe.constructor;
              if (At !== $t && !(M(At) && At instanceof At && M($t) && $t instanceof $t) && "constructor" in me && "constructor" in Fe)
                return !1;
            }
            Re = Re || [], Be = Be || [];
            for (var jt = Re.length; jt--; )
              if (Re[jt] === me)
                return Be[jt] === Fe;
            if (Re.push(me), Be.push(Fe), $e) {
              if (jt = me.length, jt !== Fe.length)
                return !1;
              for (; jt--; )
                if (!ye(me[jt], Fe[jt], Re, Be))
                  return !1;
            } else {
              var en = pe(me), nn;
              if (jt = en.length, pe(Fe).length !== jt)
                return !1;
              for (; jt--; )
                if (nn = en[jt], !(te(Fe, nn) && ye(me[nn], Fe[nn], Re, Be)))
                  return !1;
            }
            return Re.pop(), Be.pop(), !0;
          }
          function we(me, Fe) {
            return ye(me, Fe);
          }
          function Ce(me) {
            if (!A(me))
              return [];
            var Fe = [];
            for (var Re in me)
              Fe.push(Re);
            return u && de(me, Fe), Fe;
          }
          function ve(me) {
            var Fe = ue(me);
            return function(Re) {
              if (Re == null)
                return !1;
              var Be = Ce(Re);
              if (ue(Be))
                return !1;
              for (var ze = 0; ze < Fe; ze++)
                if (!M(Re[me[ze]]))
                  return !1;
              return me !== Ee || !M(Re[Le]);
            };
          }
          var Le = "forEach", He = "has", Qe = ["clear", "delete"], Ue = ["get", He, "set"], Ie = Qe.concat(Le, Ue), Ee = Qe.concat(Ue), et = ["add"].concat(Qe, Le, He), qe = W ? ve(Ie) : R("Map"), tt = W ? ve(Ee) : R("WeakMap"), ft = W ? ve(et) : R("Set"), Te = R("WeakSet");
          function je(me) {
            for (var Fe = pe(me), Re = Fe.length, Be = Array(Re), ze = 0; ze < Re; ze++)
              Be[ze] = me[Fe[ze]];
            return Be;
          }
          function Ze(me) {
            for (var Fe = pe(me), Re = Fe.length, Be = Array(Re), ze = 0; ze < Re; ze++)
              Be[ze] = [Fe[ze], me[Fe[ze]]];
            return Be;
          }
          function Me(me) {
            for (var Fe = {}, Re = pe(me), Be = 0, ze = Re.length; Be < ze; Be++)
              Fe[me[Re[Be]]] = Re[Be];
            return Fe;
          }
          function at(me) {
            var Fe = [];
            for (var Re in me)
              M(me[Re]) && Fe.push(Re);
            return Fe.sort();
          }
          function rt(me, Fe) {
            return function(Re) {
              var Be = arguments.length;
              if (Fe && (Re = Object(Re)), Be < 2 || Re == null)
                return Re;
              for (var ze = 1; ze < Be; ze++)
                for (var $e = arguments[ze], lt = me($e), At = lt.length, $t = 0; $t < At; $t++) {
                  var jt = lt[$t];
                  (!Fe || Re[jt] === void 0) && (Re[jt] = $e[jt]);
                }
              return Re;
            };
          }
          var xt = rt(Ce), ut = rt(pe), yt = rt(Ce, !0);
          function ht() {
            return function() {
            };
          }
          function Rt(me) {
            if (!A(me))
              return {};
            if (g)
              return g(me);
            var Fe = ht();
            Fe.prototype = me;
            var Re = new Fe();
            return Fe.prototype = null, Re;
          }
          function Wt(me, Fe) {
            var Re = Rt(me);
            return Fe && ut(Re, Fe), Re;
          }
          function Ke(me) {
            return A(me) ? K(me) ? me.slice() : xt({}, me) : me;
          }
          function Ge(me, Fe) {
            return Fe(me), me;
          }
          function nt(me) {
            return K(me) ? me : [me];
          }
          Ae.toPath = nt;
          function it(me) {
            return Ae.toPath(me);
          }
          function pt(me, Fe) {
            for (var Re = Fe.length, Be = 0; Be < Re; Be++) {
              if (me == null)
                return;
              me = me[Fe[Be]];
            }
            return Re ? me : void 0;
          }
          function Ft(me, Fe, Re) {
            var Be = pt(me, it(Fe));
            return j(Be) ? Re : Be;
          }
          function mt(me, Fe) {
            Fe = it(Fe);
            for (var Re = Fe.length, Be = 0; Be < Re; Be++) {
              var ze = Fe[Be];
              if (!te(me, ze))
                return !1;
              me = me[ze];
            }
            return !!Re;
          }
          function ct(me) {
            return me;
          }
          function bt(me) {
            return me = ut({}, me), function(Fe) {
              return De(Fe, me);
            };
          }
          function wt(me) {
            return me = it(me), function(Fe) {
              return pt(Fe, me);
            };
          }
          function Ot(me, Fe, Re) {
            if (Fe === void 0)
              return me;
            switch (Re ?? 3) {
              case 1:
                return function(Be) {
                  return me.call(Fe, Be);
                };
              case 3:
                return function(Be, ze, $e) {
                  return me.call(Fe, Be, ze, $e);
                };
              case 4:
                return function(Be, ze, $e, lt) {
                  return me.call(Fe, Be, ze, $e, lt);
                };
            }
            return function() {
              return me.apply(Fe, arguments);
            };
          }
          function Et(me, Fe, Re) {
            return me == null ? ct : M(me) ? Ot(me, Fe, Re) : A(me) && !K(me) ? bt(me) : wt(me);
          }
          function St(me, Fe) {
            return Et(me, Fe, 1 / 0);
          }
          Ae.iteratee = St;
          function Pe(me, Fe, Re) {
            return Ae.iteratee !== St ? Ae.iteratee(me, Fe) : Et(me, Fe, Re);
          }
          function We(me, Fe, Re) {
            Fe = Pe(Fe, Re);
            for (var Be = pe(me), ze = Be.length, $e = {}, lt = 0; lt < ze; lt++) {
              var At = Be[lt];
              $e[At] = Fe(me[At], At, me);
            }
            return $e;
          }
          function Je() {
          }
          function Ye(me) {
            return me == null ? Je : function(Fe) {
              return Ft(me, Fe);
            };
          }
          function gt(me, Fe, Re) {
            var Be = Array(Math.max(0, me));
            Fe = Ot(Fe, Re, 1);
            for (var ze = 0; ze < me; ze++)
              Be[ze] = Fe(ze);
            return Be;
          }
          function Dt(me, Fe) {
            return Fe == null && (Fe = me, me = 0), me + Math.floor(Math.random() * (Fe - me + 1));
          }
          var Xt = Date.now || function() {
            return new Date().getTime();
          };
          function kt(me) {
            var Fe = function($e) {
              return me[$e];
            }, Re = "(?:" + pe(me).join("|") + ")", Be = RegExp(Re), ze = RegExp(Re, "g");
            return function($e) {
              return $e = $e == null ? "" : "" + $e, Be.test($e) ? $e.replace(ze, Fe) : $e;
            };
          }
          var Pt = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#x27;",
            "`": "&#x60;"
          }, zt = kt(Pt), Yt = Me(Pt), an = kt(Yt), Dn = Ae.templateSettings = {
            evaluate: /<%([\s\S]+?)%>/g,
            interpolate: /<%=([\s\S]+?)%>/g,
            escape: /<%-([\s\S]+?)%>/g
          }, gn = /(.)^/, _n = {
            "'": "'",
            "\\": "\\",
            "\r": "r",
            "\n": "n",
            "\u2028": "u2028",
            "\u2029": "u2029"
          }, En = /\\|'|\r|\n|\u2028|\u2029/g;
          function An(me) {
            return "\\" + _n[me];
          }
          var kn = /^\s*(\w|\$)+\s*$/;
          function On(me, Fe, Re) {
            !Fe && Re && (Fe = Re), Fe = yt({}, Fe, Ae.templateSettings);
            var Be = RegExp([
              (Fe.escape || gn).source,
              (Fe.interpolate || gn).source,
              (Fe.evaluate || gn).source
            ].join("|") + "|$", "g"), ze = 0, $e = "__p+='";
            me.replace(Be, function(jt, en, nn, Fi, Ti) {
              return $e += me.slice(ze, Ti).replace(En, An), ze = Ti + jt.length, en ? $e += `'+
((__t=(` + en + `))==null?'':_.escape(__t))+
'` : nn ? $e += `'+
((__t=(` + nn + `))==null?'':__t)+
'` : Fi && ($e += `';
` + Fi + `
__p+='`), jt;
            }), $e += `';
`;
            var lt = Fe.variable;
            if (lt) {
              if (!kn.test(lt))
                throw new Error(
                  "variable is not a bare identifier: " + lt
                );
            } else
              $e = `with(obj||{}){
` + $e + `}
`, lt = "obj";
            $e = `var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
` + $e + `return __p;
`;
            var At;
            try {
              At = new Function(lt, "_", $e);
            } catch (jt) {
              throw jt.source = $e, jt;
            }
            var $t = function(jt) {
              return At.call(this, jt, Ae);
            };
            return $t.source = "function(" + lt + `){
` + $e + "}", $t;
          }
          function In(me, Fe, Re) {
            Fe = it(Fe);
            var Be = Fe.length;
            if (!Be)
              return M(Re) ? Re.call(me) : Re;
            for (var ze = 0; ze < Be; ze++) {
              var $e = me == null ? void 0 : me[Fe[ze]];
              $e === void 0 && ($e = Re, ze = Be), me = M($e) ? $e.call(me) : $e;
            }
            return me;
          }
          var Pn = 0;
          function Rn(me) {
            var Fe = ++Pn + "";
            return me ? me + Fe : Fe;
          }
          function Un(me) {
            var Fe = Ae(me);
            return Fe._chain = !0, Fe;
          }
          function xn(me, Fe, Re, Be, ze) {
            if (!(Be instanceof Fe))
              return me.apply(Re, ze);
            var $e = Rt(me.prototype), lt = me.apply($e, ze);
            return A(lt) ? lt : $e;
          }
          var on = b(function(me, Fe) {
            var Re = on.placeholder, Be = function() {
              for (var ze = 0, $e = Fe.length, lt = Array($e), At = 0; At < $e; At++)
                lt[At] = Fe[At] === Re ? arguments[ze++] : Fe[At];
              for (; ze < arguments.length; )
                lt.push(arguments[ze++]);
              return xn(me, Be, this, this, lt);
            };
            return Be;
          });
          on.placeholder = Ae;
          var Sn = b(function(me, Fe, Re) {
            if (!M(me))
              throw new TypeError("Bind must be called on a function");
            var Be = b(function(ze) {
              return xn(me, Be, Fe, this, Re.concat(ze));
            });
            return Be;
          }), Qt = ne(ue);
          function cn(me, Fe, Re, Be) {
            if (Be = Be || [], !Fe && Fe !== 0)
              Fe = 1 / 0;
            else if (Fe <= 0)
              return Be.concat(me);
            for (var ze = Be.length, $e = 0, lt = ue(me); $e < lt; $e++) {
              var At = me[$e];
              if (Qt(At) && (K(At) || q(At)))
                if (Fe > 1)
                  cn(At, Fe - 1, Re, Be), ze = Be.length;
                else
                  for (var $t = 0, jt = At.length; $t < jt; )
                    Be[ze++] = At[$t++];
              else
                Re || (Be[ze++] = At);
            }
            return Be;
          }
          var bn = b(function(me, Fe) {
            Fe = cn(Fe, !1, !1);
            var Re = Fe.length;
            if (Re < 1)
              throw new Error("bindAll must be passed function names");
            for (; Re--; ) {
              var Be = Fe[Re];
              me[Be] = Sn(me[Be], me);
            }
            return me;
          });
          function Cn(me, Fe) {
            var Re = function(Be) {
              var ze = Re.cache, $e = "" + (Fe ? Fe.apply(this, arguments) : Be);
              return te(ze, $e) || (ze[$e] = me.apply(this, arguments)), ze[$e];
            };
            return Re.cache = {}, Re;
          }
          var yn = b(function(me, Fe, Re) {
            return setTimeout(function() {
              return me.apply(null, Re);
            }, Fe);
          }), Mn = on(yn, Ae, 1);
          function Bn(me, Fe, Re) {
            var Be, ze, $e, lt, At = 0;
            Re || (Re = {});
            var $t = function() {
              At = Re.leading === !1 ? 0 : Xt(), Be = null, lt = me.apply(ze, $e), Be || (ze = $e = null);
            }, jt = function() {
              var en = Xt();
              !At && Re.leading === !1 && (At = en);
              var nn = Fe - (en - At);
              return ze = this, $e = arguments, nn <= 0 || nn > Fe ? (Be && (clearTimeout(Be), Be = null), At = en, lt = me.apply(ze, $e), Be || (ze = $e = null)) : !Be && Re.trailing !== !1 && (Be = setTimeout($t, nn)), lt;
            };
            return jt.cancel = function() {
              clearTimeout(Be), At = 0, Be = ze = $e = null;
            }, jt;
          }
          function Ln(me, Fe, Re) {
            var Be, ze, $e, lt, At, $t = function() {
              var en = Xt() - ze;
              Fe > en ? Be = setTimeout($t, Fe - en) : (Be = null, Re || (lt = me.apply(At, $e)), Be || ($e = At = null));
            }, jt = b(function(en) {
              return At = this, $e = en, ze = Xt(), Be || (Be = setTimeout($t, Fe), Re && (lt = me.apply(At, $e))), lt;
            });
            return jt.cancel = function() {
              clearTimeout(Be), Be = $e = At = null;
            }, jt;
          }
          function Nn(me, Fe) {
            return on(Fe, me);
          }
          function vn(me) {
            return function() {
              return !me.apply(this, arguments);
            };
          }
          function wn() {
            var me = arguments, Fe = me.length - 1;
            return function() {
              for (var Re = Fe, Be = me[Fe].apply(this, arguments); Re--; )
                Be = me[Re].call(this, Be);
              return Be;
            };
          }
          function jn(me, Fe) {
            return function() {
              if (--me < 1)
                return Fe.apply(this, arguments);
            };
          }
          function hn(me, Fe) {
            var Re;
            return function() {
              return --me > 0 && (Re = Fe.apply(this, arguments)), me <= 1 && (Fe = null), Re;
            };
          }
          var Wn = on(hn, 2);
          function dn(me, Fe, Re) {
            Fe = Pe(Fe, Re);
            for (var Be = pe(me), ze, $e = 0, lt = Be.length; $e < lt; $e++)
              if (ze = Be[$e], Fe(me[ze], ze, me))
                return ze;
          }
          function Xe(me) {
            return function(Fe, Re, Be) {
              Re = Pe(Re, Be);
              for (var ze = ue(Fe), $e = me > 0 ? 0 : ze - 1; $e >= 0 && $e < ze; $e += me)
                if (Re(Fe[$e], $e, Fe))
                  return $e;
              return -1;
            };
          }
          var P = Xe(1), he = Xe(-1);
          function Ne(me, Fe, Re, Be) {
            Re = Pe(Re, Be, 1);
            for (var ze = Re(Fe), $e = 0, lt = ue(me); $e < lt; ) {
              var At = Math.floor(($e + lt) / 2);
              Re(me[At]) < ze ? $e = At + 1 : lt = At;
            }
            return $e;
          }
          function Ve(me, Fe, Re) {
            return function(Be, ze, $e) {
              var lt = 0, At = ue(Be);
              if (typeof $e == "number")
                me > 0 ? lt = $e >= 0 ? $e : Math.max($e + At, lt) : At = $e >= 0 ? Math.min($e + 1, At) : $e + At + 1;
              else if (Re && $e && At)
                return $e = Re(Be, ze), Be[$e] === ze ? $e : -1;
              if (ze !== ze)
                return $e = Fe(h.call(Be, lt, At), Q), $e >= 0 ? $e + lt : -1;
              for ($e = me > 0 ? lt : At - 1; $e >= 0 && $e < At; $e += me)
                if (Be[$e] === ze)
                  return $e;
              return -1;
            };
          }
          var st = Ve(1, P, Ne), Tt = Ve(-1, he);
          function Ct(me, Fe, Re) {
            var Be = Qt(me) ? P : dn, ze = Be(me, Fe, Re);
            if (ze !== void 0 && ze !== -1)
              return me[ze];
          }
          function _t(me, Fe) {
            return Ct(me, bt(Fe));
          }
          function It(me, Fe, Re) {
            Fe = Ot(Fe, Re);
            var Be, ze;
            if (Qt(me))
              for (Be = 0, ze = me.length; Be < ze; Be++)
                Fe(me[Be], Be, me);
            else {
              var $e = pe(me);
              for (Be = 0, ze = $e.length; Be < ze; Be++)
                Fe(me[$e[Be]], $e[Be], me);
            }
            return me;
          }
          function Bt(me, Fe, Re) {
            Fe = Pe(Fe, Re);
            for (var Be = !Qt(me) && pe(me), ze = (Be || me).length, $e = Array(ze), lt = 0; lt < ze; lt++) {
              var At = Be ? Be[lt] : lt;
              $e[lt] = Fe(me[At], At, me);
            }
            return $e;
          }
          function Vt(me) {
            var Fe = function(Re, Be, ze, $e) {
              var lt = !Qt(Re) && pe(Re), At = (lt || Re).length, $t = me > 0 ? 0 : At - 1;
              for ($e || (ze = Re[lt ? lt[$t] : $t], $t += me); $t >= 0 && $t < At; $t += me) {
                var jt = lt ? lt[$t] : $t;
                ze = Be(ze, Re[jt], jt, Re);
              }
              return ze;
            };
            return function(Re, Be, ze, $e) {
              var lt = arguments.length >= 3;
              return Fe(Re, Ot(Be, $e, 4), ze, lt);
            };
          }
          var Ht = Vt(1), qt = Vt(-1);
          function Gt(me, Fe, Re) {
            var Be = [];
            return Fe = Pe(Fe, Re), It(me, function(ze, $e, lt) {
              Fe(ze, $e, lt) && Be.push(ze);
            }), Be;
          }
          function Mt(me, Fe, Re) {
            return Gt(me, vn(Pe(Fe)), Re);
          }
          function Kt(me, Fe, Re) {
            Fe = Pe(Fe, Re);
            for (var Be = !Qt(me) && pe(me), ze = (Be || me).length, $e = 0; $e < ze; $e++) {
              var lt = Be ? Be[$e] : $e;
              if (!Fe(me[lt], lt, me))
                return !1;
            }
            return !0;
          }
          function Ut(me, Fe, Re) {
            Fe = Pe(Fe, Re);
            for (var Be = !Qt(me) && pe(me), ze = (Be || me).length, $e = 0; $e < ze; $e++) {
              var lt = Be ? Be[$e] : $e;
              if (Fe(me[lt], lt, me))
                return !0;
            }
            return !1;
          }
          function Lt(me, Fe, Re, Be) {
            return Qt(me) || (me = je(me)), (typeof Re != "number" || Be) && (Re = 0), st(me, Fe, Re) >= 0;
          }
          var tn = b(function(me, Fe, Re) {
            var Be, ze;
            return M(Fe) ? ze = Fe : (Fe = it(Fe), Be = Fe.slice(0, -1), Fe = Fe[Fe.length - 1]), Bt(me, function($e) {
              var lt = ze;
              if (!lt) {
                if (Be && Be.length && ($e = pt($e, Be)), $e == null)
                  return;
                lt = $e[Fe];
              }
              return lt == null ? lt : lt.apply($e, Re);
            });
          });
          function Nt(me, Fe) {
            return Bt(me, wt(Fe));
          }
          function ln(me, Fe) {
            return Gt(me, bt(Fe));
          }
          function rn(me, Fe, Re) {
            var Be = -1 / 0, ze = -1 / 0, $e, lt;
            if (Fe == null || typeof Fe == "number" && typeof me[0] != "object" && me != null) {
              me = Qt(me) ? me : je(me);
              for (var At = 0, $t = me.length; At < $t; At++)
                $e = me[At], $e != null && $e > Be && (Be = $e);
            } else
              Fe = Pe(Fe, Re), It(me, function(jt, en, nn) {
                lt = Fe(jt, en, nn), (lt > ze || lt === -1 / 0 && Be === -1 / 0) && (Be = jt, ze = lt);
              });
            return Be;
          }
          function Jt(me, Fe, Re) {
            var Be = 1 / 0, ze = 1 / 0, $e, lt;
            if (Fe == null || typeof Fe == "number" && typeof me[0] != "object" && me != null) {
              me = Qt(me) ? me : je(me);
              for (var At = 0, $t = me.length; At < $t; At++)
                $e = me[At], $e != null && $e < Be && (Be = $e);
            } else
              Fe = Pe(Fe, Re), It(me, function(jt, en, nn) {
                lt = Fe(jt, en, nn), (lt < ze || lt === 1 / 0 && Be === 1 / 0) && (Be = jt, ze = lt);
              });
            return Be;
          }
          function pn(me, Fe, Re) {
            if (Fe == null || Re)
              return Qt(me) || (me = je(me)), me[Dt(me.length - 1)];
            var Be = Qt(me) ? Ke(me) : je(me), ze = ue(Be);
            Fe = Math.max(Math.min(Fe, ze), 0);
            for (var $e = ze - 1, lt = 0; lt < Fe; lt++) {
              var At = Dt(lt, $e), $t = Be[lt];
              Be[lt] = Be[At], Be[At] = $t;
            }
            return Be.slice(0, Fe);
          }
          function mn(me) {
            return pn(me, 1 / 0);
          }
          function Kn(me, Fe, Re) {
            var Be = 0;
            return Fe = Pe(Fe, Re), Nt(Bt(me, function(ze, $e, lt) {
              return {
                value: ze,
                index: Be++,
                criteria: Fe(ze, $e, lt)
              };
            }).sort(function(ze, $e) {
              var lt = ze.criteria, At = $e.criteria;
              if (lt !== At) {
                if (lt > At || lt === void 0)
                  return 1;
                if (lt < At || At === void 0)
                  return -1;
              }
              return ze.index - $e.index;
            }), "value");
          }
          function fn(me, Fe) {
            return function(Re, Be, ze) {
              var $e = Fe ? [[], []] : {};
              return Be = Pe(Be, ze), It(Re, function(lt, At) {
                var $t = Be(lt, At, Re);
                me($e, lt, $t);
              }), $e;
            };
          }
          var Vi = fn(function(me, Fe, Re) {
            te(me, Re) ? me[Re].push(Fe) : me[Re] = [Fe];
          }), qi = fn(function(me, Fe, Re) {
            me[Re] = Fe;
          }), Yi = fn(function(me, Fe, Re) {
            te(me, Re) ? me[Re]++ : me[Re] = 1;
          }), Ki = fn(function(me, Fe, Re) {
            me[Re ? 0 : 1].push(Fe);
          }, !0), Zi = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
          function Ji(me) {
            return me ? K(me) ? h.call(me) : k(me) ? me.match(Zi) : Qt(me) ? Bt(me, ct) : je(me) : [];
          }
          function Qi(me) {
            return me == null ? 0 : Qt(me) ? me.length : pe(me).length;
          }
          function er(me, Fe, Re) {
            return Fe in Re;
          }
          var wi = b(function(me, Fe) {
            var Re = {}, Be = Fe[0];
            if (me == null)
              return Re;
            M(Be) ? (Fe.length > 1 && (Be = Ot(Be, Fe[1])), Fe = Ce(me)) : (Be = er, Fe = cn(Fe, !1, !1), me = Object(me));
            for (var ze = 0, $e = Fe.length; ze < $e; ze++) {
              var lt = Fe[ze], At = me[lt];
              Be(At, lt, me) && (Re[lt] = At);
            }
            return Re;
          }), tr = b(function(me, Fe) {
            var Re = Fe[0], Be;
            return M(Re) ? (Re = vn(Re), Fe.length > 1 && (Be = Fe[1])) : (Fe = Bt(cn(Fe, !1, !1), String), Re = function(ze, $e) {
              return !Lt(Fe, $e);
            }), wi(me, Re, Be);
          });
          function Ai(me, Fe, Re) {
            return h.call(me, 0, Math.max(0, me.length - (Fe == null || Re ? 1 : Fe)));
          }
          function Zn(me, Fe, Re) {
            return me == null || me.length < 1 ? Fe == null || Re ? void 0 : [] : Fe == null || Re ? me[0] : Ai(me, me.length - Fe);
          }
          function Hn(me, Fe, Re) {
            return h.call(me, Fe == null || Re ? 1 : Fe);
          }
          function nr(me, Fe, Re) {
            return me == null || me.length < 1 ? Fe == null || Re ? void 0 : [] : Fe == null || Re ? me[me.length - 1] : Hn(me, Math.max(0, me.length - Fe));
          }
          function ir(me) {
            return Gt(me, Boolean);
          }
          function rr(me, Fe) {
            return cn(me, Fe, !1);
          }
          var Si = b(function(me, Fe) {
            return Fe = cn(Fe, !0, !0), Gt(me, function(Re) {
              return !Lt(Fe, Re);
            });
          }), ar = b(function(me, Fe) {
            return Si(me, Fe);
          });
          function Jn(me, Fe, Re, Be) {
            X(Fe) || (Be = Re, Re = Fe, Fe = !1), Re != null && (Re = Pe(Re, Be));
            for (var ze = [], $e = [], lt = 0, At = ue(me); lt < At; lt++) {
              var $t = me[lt], jt = Re ? Re($t, lt, me) : $t;
              Fe && !Re ? ((!lt || $e !== jt) && ze.push($t), $e = jt) : Re ? Lt($e, jt) || ($e.push(jt), ze.push($t)) : Lt(ze, $t) || ze.push($t);
            }
            return ze;
          }
          var sr = b(function(me) {
            return Jn(cn(me, !0, !0));
          });
          function or(me) {
            for (var Fe = [], Re = arguments.length, Be = 0, ze = ue(me); Be < ze; Be++) {
              var $e = me[Be];
              if (!Lt(Fe, $e)) {
                var lt;
                for (lt = 1; lt < Re && Lt(arguments[lt], $e); lt++)
                  ;
                lt === Re && Fe.push($e);
              }
            }
            return Fe;
          }
          function Qn(me) {
            for (var Fe = me && rn(me, ue).length || 0, Re = Array(Fe), Be = 0; Be < Fe; Be++)
              Re[Be] = Nt(me, Be);
            return Re;
          }
          var cr = b(Qn);
          function lr(me, Fe) {
            for (var Re = {}, Be = 0, ze = ue(me); Be < ze; Be++)
              Fe ? Re[me[Be]] = Fe[Be] : Re[me[Be][0]] = me[Be][1];
            return Re;
          }
          function ur(me, Fe, Re) {
            Fe == null && (Fe = me || 0, me = 0), Re || (Re = Fe < me ? -1 : 1);
            for (var Be = Math.max(Math.ceil((Fe - me) / Re), 0), ze = Array(Be), $e = 0; $e < Be; $e++, me += Re)
              ze[$e] = me;
            return ze;
          }
          function hr(me, Fe) {
            if (Fe == null || Fe < 1)
              return [];
            for (var Re = [], Be = 0, ze = me.length; Be < ze; )
              Re.push(h.call(me, Be, Be += Fe));
            return Re;
          }
          function ei(me, Fe) {
            return me._chain ? Ae(Fe).chain() : Fe;
          }
          function Ci(me) {
            return It(at(me), function(Fe) {
              var Re = Ae[Fe] = me[Fe];
              Ae.prototype[Fe] = function() {
                var Be = [this._wrapped];
                return v.apply(Be, arguments), ei(this, Re.apply(Ae, Be));
              };
            }), Ae;
          }
          It(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(me) {
            var Fe = C[me];
            Ae.prototype[me] = function() {
              var Re = this._wrapped;
              return Re != null && (Fe.apply(Re, arguments), (me === "shift" || me === "splice") && Re.length === 0 && delete Re[0]), ei(this, Re);
            };
          }), It(["concat", "join", "slice"], function(me) {
            var Fe = C[me];
            Ae.prototype[me] = function() {
              var Re = this._wrapped;
              return Re != null && (Re = Fe.apply(Re, arguments)), ei(this, Re);
            };
          });
          var dr = {
            __proto__: null,
            VERSION: Z,
            restArguments: b,
            isObject: A,
            isNull: Y,
            isUndefined: j,
            isBoolean: X,
            isElement: B,
            isString: k,
            isNumber: x,
            isDate: f,
            isRegExp: U,
            isError: O,
            isSymbol: S,
            isArrayBuffer: F,
            isDataView: L,
            isArray: K,
            isFunction: M,
            isArguments: q,
            isFinite: N,
            isNaN: Q,
            isTypedArray: ie,
            isEmpty: xe,
            isMatch: De,
            isEqual: we,
            isMap: qe,
            isWeakMap: tt,
            isSet: ft,
            isWeakSet: Te,
            keys: pe,
            allKeys: Ce,
            values: je,
            pairs: Ze,
            invert: Me,
            functions: at,
            methods: at,
            extend: xt,
            extendOwn: ut,
            assign: ut,
            defaults: yt,
            create: Wt,
            clone: Ke,
            tap: Ge,
            get: Ft,
            has: mt,
            mapObject: We,
            identity: ct,
            constant: D,
            noop: Je,
            toPath: nt,
            property: wt,
            propertyOf: Ye,
            matcher: bt,
            matches: bt,
            times: gt,
            random: Dt,
            now: Xt,
            escape: zt,
            unescape: an,
            templateSettings: Dn,
            template: On,
            result: In,
            uniqueId: Rn,
            chain: Un,
            iteratee: St,
            partial: on,
            bind: Sn,
            bindAll: bn,
            memoize: Cn,
            delay: yn,
            defer: Mn,
            throttle: Bn,
            debounce: Ln,
            wrap: Nn,
            negate: vn,
            compose: wn,
            after: jn,
            before: hn,
            once: Wn,
            findKey: dn,
            findIndex: P,
            findLastIndex: he,
            sortedIndex: Ne,
            indexOf: st,
            lastIndexOf: Tt,
            find: Ct,
            detect: Ct,
            findWhere: _t,
            each: It,
            forEach: It,
            map: Bt,
            collect: Bt,
            reduce: Ht,
            foldl: Ht,
            inject: Ht,
            reduceRight: qt,
            foldr: qt,
            filter: Gt,
            select: Gt,
            reject: Mt,
            every: Kt,
            all: Kt,
            some: Ut,
            any: Ut,
            contains: Lt,
            includes: Lt,
            include: Lt,
            invoke: tn,
            pluck: Nt,
            where: ln,
            max: rn,
            min: Jt,
            shuffle: mn,
            sample: pn,
            sortBy: Kn,
            groupBy: Vi,
            indexBy: qi,
            countBy: Yi,
            partition: Ki,
            toArray: Ji,
            size: Qi,
            pick: wi,
            omit: tr,
            first: Zn,
            head: Zn,
            take: Zn,
            initial: Ai,
            last: nr,
            rest: Hn,
            tail: Hn,
            drop: Hn,
            compact: ir,
            flatten: rr,
            without: ar,
            uniq: Jn,
            unique: Jn,
            union: sr,
            intersection: or,
            difference: Si,
            unzip: Qn,
            transpose: Qn,
            zip: cr,
            object: lr,
            range: ur,
            chunk: hr,
            mixin: Ci,
            default: Ae
          }, ti = Ci(dr);
          return ti._ = ti, ti;
        });
      }).call(this, typeof commonjsGlobal < "u" ? commonjsGlobal : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 118: [function(le, ce, re) {
      (function(ae) {
        ce.exports = Z;
        function Z(C, t) {
          if (o("noDeprecation"))
            return C;
          var a = !1;
          function v() {
            if (!a) {
              if (o("throwDeprecation"))
                throw new Error(t);
              o("traceDeprecation") ? console.trace(t) : console.warn(t), a = !0;
            }
            return C.apply(this, arguments);
          }
          return v;
        }
        function o(C) {
          try {
            if (!ae.localStorage)
              return !1;
          } catch {
            return !1;
          }
          var t = ae.localStorage[C];
          return t == null ? !1 : String(t).toLowerCase() === "true";
        }
      }).call(this, typeof commonjsGlobal < "u" ? commonjsGlobal : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 119: [function(le, ce, re) {
      arguments[4][84][0].apply(re, arguments);
    }, { dup: 84 }], 120: [function(le, ce, re) {
      ce.exports = function(Z) {
        return Z && typeof Z == "object" && typeof Z.copy == "function" && typeof Z.fill == "function" && typeof Z.readUInt8 == "function";
      };
    }, {}], 121: [function(le, ce, re) {
      (function(ae, Z) {
        var o = /%[sdj%]/g;
        re.format = function(F) {
          if (!_(F)) {
            for (var T = [], I = 0; I < arguments.length; I++)
              T.push(a(arguments[I]));
            return T.join(" ");
          }
          for (var I = 1, M = arguments, V = M.length, J = String(F).replace(o, function(z) {
            if (z === "%%")
              return "%";
            if (I >= V)
              return z;
            switch (z) {
              case "%s":
                return String(M[I++]);
              case "%d":
                return Number(M[I++]);
              case "%j":
                try {
                  return JSON.stringify(M[I++]);
                } catch {
                  return "[Circular]";
                }
              default:
                return z;
            }
          }), W = M[I]; I < V; W = M[++I])
            l(W) || !j(W) ? J += " " + W : J += " " + a(W);
          return J;
        }, re.deprecate = function(F, T) {
          if (A(Z.process))
            return function() {
              return re.deprecate(F, T).apply(this, arguments);
            };
          if (ae.noDeprecation === !0)
            return F;
          var I = !1;
          function M() {
            if (!I) {
              if (ae.throwDeprecation)
                throw new Error(T);
              ae.traceDeprecation ? console.trace(T) : console.error(T), I = !0;
            }
            return F.apply(this, arguments);
          }
          return M;
        };
        var C = {}, t;
        re.debuglog = function(F) {
          if (A(t) && (t = ae.env.NODE_DEBUG || ""), F = F.toUpperCase(), !C[F])
            if (new RegExp("\\b" + F + "\\b", "i").test(t)) {
              var T = ae.pid;
              C[F] = function() {
                var I = re.format.apply(re, arguments);
                console.error("%s %d: %s", F, T, I);
              };
            } else
              C[F] = function() {
              };
          return C[F];
        };
        function a(F, T) {
          var I = {
            seen: [],
            stylize: h
          };
          return arguments.length >= 3 && (I.depth = arguments[2]), arguments.length >= 4 && (I.colors = arguments[3]), i(T) ? I.showHidden = T : T && re._extend(I, T), A(I.showHidden) && (I.showHidden = !1), A(I.depth) && (I.depth = 2), A(I.colors) && (I.colors = !1), A(I.customInspect) && (I.customInspect = !0), I.colors && (I.stylize = v), y(I, F, I.depth);
        }
        re.inspect = a, a.colors = {
          bold: [1, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          white: [37, 39],
          grey: [90, 39],
          black: [30, 39],
          blue: [34, 39],
          cyan: [36, 39],
          green: [32, 39],
          magenta: [35, 39],
          red: [31, 39],
          yellow: [33, 39]
        }, a.styles = {
          special: "cyan",
          number: "yellow",
          boolean: "yellow",
          undefined: "grey",
          null: "bold",
          string: "green",
          date: "magenta",
          // "name": intentionally not styling
          regexp: "red"
        };
        function v(F, T) {
          var I = a.styles[T];
          return I ? "\x1B[" + a.colors[I][0] + "m" + F + "\x1B[" + a.colors[I][1] + "m" : F;
        }
        function h(F, T) {
          return F;
        }
        function e(F) {
          var T = {};
          return F.forEach(function(I, M) {
            T[I] = !0;
          }), T;
        }
        function y(F, T, I) {
          if (F.customInspect && T && R(T.inspect) && // Filter out the util module, it's inspect function is special
          T.inspect !== re.inspect && // Also filter out any prototype objects using the circular check.
          !(T.constructor && T.constructor.prototype === T)) {
            var M = T.inspect(I, F);
            return _(M) || (M = y(F, M, I)), M;
          }
          var V = c(F, T);
          if (V)
            return V;
          var J = Object.keys(T), W = e(J);
          if (F.showHidden && (J = Object.getOwnPropertyNames(T)), B(T) && (J.indexOf("message") >= 0 || J.indexOf("description") >= 0))
            return d(T);
          if (J.length === 0) {
            if (R(T)) {
              var z = T.name ? ": " + T.name : "";
              return F.stylize("[Function" + z + "]", "special");
            }
            if (Y(T))
              return F.stylize(RegExp.prototype.toString.call(T), "regexp");
            if (X(T))
              return F.stylize(Date.prototype.toString.call(T), "date");
            if (B(T))
              return d(T);
          }
          var G = "", L = !1, K = ["{", "}"];
          if (n(T) && (L = !0, K = ["[", "]"]), R(T)) {
            var te = T.name ? ": " + T.name : "";
            G = " [Function" + te + "]";
          }
          if (Y(T) && (G = " " + RegExp.prototype.toString.call(T)), X(T) && (G = " " + Date.prototype.toUTCString.call(T)), B(T) && (G = " " + d(T)), J.length === 0 && (!L || T.length == 0))
            return K[0] + G + K[1];
          if (I < 0)
            return Y(T) ? F.stylize(RegExp.prototype.toString.call(T), "regexp") : F.stylize("[Object]", "special");
          F.seen.push(T);
          var se;
          return L ? se = p(F, T, I, W, J) : se = J.map(function(q) {
            return m(F, T, I, W, q, L);
          }), F.seen.pop(), g(se, G, K);
        }
        function c(F, T) {
          if (A(T))
            return F.stylize("undefined", "undefined");
          if (_(T)) {
            var I = "'" + JSON.stringify(T).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
            return F.stylize(I, "string");
          }
          if (w(T))
            return F.stylize("" + T, "number");
          if (i(T))
            return F.stylize("" + T, "boolean");
          if (l(T))
            return F.stylize("null", "null");
        }
        function d(F) {
          return "[" + Error.prototype.toString.call(F) + "]";
        }
        function p(F, T, I, M, V) {
          for (var J = [], W = 0, z = T.length; W < z; ++W)
            S(T, String(W)) ? J.push(m(
              F,
              T,
              I,
              M,
              String(W),
              !0
            )) : J.push("");
          return V.forEach(function(G) {
            G.match(/^\d+$/) || J.push(m(
              F,
              T,
              I,
              M,
              G,
              !0
            ));
          }), J;
        }
        function m(F, T, I, M, V, J) {
          var W, z, G;
          if (G = Object.getOwnPropertyDescriptor(T, V) || { value: T[V] }, G.get ? G.set ? z = F.stylize("[Getter/Setter]", "special") : z = F.stylize("[Getter]", "special") : G.set && (z = F.stylize("[Setter]", "special")), S(M, V) || (W = "[" + V + "]"), z || (F.seen.indexOf(G.value) < 0 ? (l(I) ? z = y(F, G.value, null) : z = y(F, G.value, I - 1), z.indexOf(`
`) > -1 && (J ? z = z.split(`
`).map(function(L) {
            return "  " + L;
          }).join(`
`).substr(2) : z = `
` + z.split(`
`).map(function(L) {
            return "   " + L;
          }).join(`
`))) : z = F.stylize("[Circular]", "special")), A(W)) {
            if (J && V.match(/^\d+$/))
              return z;
            W = JSON.stringify("" + V), W.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (W = W.substr(1, W.length - 2), W = F.stylize(W, "name")) : (W = W.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), W = F.stylize(W, "string"));
          }
          return W + ": " + z;
        }
        function g(F, T, I) {
          var M = F.reduce(function(V, J) {
            return J.indexOf(`
`) >= 0, V + J.replace(/\u001b\[\d\d?m/g, "").length + 1;
          }, 0);
          return M > 60 ? I[0] + (T === "" ? "" : T + `
 `) + " " + F.join(`,
  `) + " " + I[1] : I[0] + T + " " + F.join(", ") + " " + I[1];
        }
        function n(F) {
          return Array.isArray(F);
        }
        re.isArray = n;
        function i(F) {
          return typeof F == "boolean";
        }
        re.isBoolean = i;
        function l(F) {
          return F === null;
        }
        re.isNull = l;
        function u(F) {
          return F == null;
        }
        re.isNullOrUndefined = u;
        function w(F) {
          return typeof F == "number";
        }
        re.isNumber = w;
        function _(F) {
          return typeof F == "string";
        }
        re.isString = _;
        function b(F) {
          return typeof F == "symbol";
        }
        re.isSymbol = b;
        function A(F) {
          return F === void 0;
        }
        re.isUndefined = A;
        function Y(F) {
          return j(F) && x(F) === "[object RegExp]";
        }
        re.isRegExp = Y;
        function j(F) {
          return typeof F == "object" && F !== null;
        }
        re.isObject = j;
        function X(F) {
          return j(F) && x(F) === "[object Date]";
        }
        re.isDate = X;
        function B(F) {
          return j(F) && (x(F) === "[object Error]" || F instanceof Error);
        }
        re.isError = B;
        function R(F) {
          return typeof F == "function";
        }
        re.isFunction = R;
        function k(F) {
          return F === null || typeof F == "boolean" || typeof F == "number" || typeof F == "string" || typeof F == "symbol" || // ES6 symbol
          typeof F > "u";
        }
        re.isPrimitive = k, re.isBuffer = le("./support/isBuffer");
        function x(F) {
          return Object.prototype.toString.call(F);
        }
        function f(F) {
          return F < 10 ? "0" + F.toString(10) : F.toString(10);
        }
        var U = [
          "Jan",
          "Feb",
          "Mar",
          "Apr",
          "May",
          "Jun",
          "Jul",
          "Aug",
          "Sep",
          "Oct",
          "Nov",
          "Dec"
        ];
        function O() {
          var F = new Date(), T = [
            f(F.getHours()),
            f(F.getMinutes()),
            f(F.getSeconds())
          ].join(":");
          return [F.getDate(), U[F.getMonth()], T].join(" ");
        }
        re.log = function() {
          console.log("%s - %s", O(), re.format.apply(re, arguments));
        }, re.inherits = le("inherits"), re._extend = function(F, T) {
          if (!T || !j(T))
            return F;
          for (var I = Object.keys(T), M = I.length; M--; )
            F[I[M]] = T[I[M]];
          return F;
        };
        function S(F, T) {
          return Object.prototype.hasOwnProperty.call(F, T);
        }
      }).call(this, le("_process"), typeof commonjsGlobal < "u" ? commonjsGlobal : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "./support/isBuffer": 120, _process: 102, inherits: 119 }], 122: [function(le, ce, re) {
      (function() {
        var ae, Z, o, C, t, a, v, h = [].slice, e = {}.hasOwnProperty;
        ae = function() {
          var y, c, d, p, m, g;
          if (g = arguments[0], m = 2 <= arguments.length ? h.call(arguments, 1) : [], t(Object.assign))
            Object.assign.apply(null, arguments);
          else
            for (y = 0, d = m.length; y < d; y++)
              if (p = m[y], p != null)
                for (c in p)
                  e.call(p, c) && (g[c] = p[c]);
          return g;
        }, t = function(y) {
          return !!y && Object.prototype.toString.call(y) === "[object Function]";
        }, a = function(y) {
          var c;
          return !!y && ((c = typeof y) == "function" || c === "object");
        }, o = function(y) {
          return t(Array.isArray) ? Array.isArray(y) : Object.prototype.toString.call(y) === "[object Array]";
        }, C = function(y) {
          var c;
          if (o(y))
            return !y.length;
          for (c in y)
            if (e.call(y, c))
              return !1;
          return !0;
        }, v = function(y) {
          var c, d;
          return a(y) && (d = Object.getPrototypeOf(y)) && (c = d.constructor) && typeof c == "function" && c instanceof c && Function.prototype.toString.call(c) === Function.prototype.toString.call(Object);
        }, Z = function(y) {
          return t(y.valueOf) ? y.valueOf() : y;
        }, ce.exports.assign = ae, ce.exports.isFunction = t, ce.exports.isObject = a, ce.exports.isArray = o, ce.exports.isEmpty = C, ce.exports.isPlainObject = v, ce.exports.getValue = Z;
      }).call(this);
    }, {}], 123: [function(le, ce, re) {
      (function() {
        ce.exports = function() {
          function ae(Z, o, C) {
            if (this.options = Z.options, this.stringify = Z.stringify, this.parent = Z, o == null)
              throw new Error("Missing attribute name. " + this.debugInfo(o));
            if (C == null)
              throw new Error("Missing attribute value. " + this.debugInfo(o));
            this.name = this.stringify.attName(o), this.value = this.stringify.attValue(C);
          }
          return ae.prototype.clone = function() {
            return Object.create(this);
          }, ae.prototype.toString = function(Z) {
            return this.options.writer.set(Z).attribute(this);
          }, ae.prototype.debugInfo = function(Z) {
            var o, C;
            return Z = Z || this.name, Z == null && !((o = this.parent) != null && o.name) ? "" : Z == null ? "parent: <" + this.parent.name + ">" : (C = this.parent) != null && C.name ? "attribute: {" + Z + "}, parent: <" + this.parent.name + ">" : "attribute: {" + Z + "}";
          }, ae;
        }();
      }).call(this);
    }, {}], 124: [function(le, ce, re) {
      (function() {
        var ae, Z = function(C, t) {
          for (var a in t)
            o.call(t, a) && (C[a] = t[a]);
          function v() {
            this.constructor = C;
          }
          return v.prototype = t.prototype, C.prototype = new v(), C.__super__ = t.prototype, C;
        }, o = {}.hasOwnProperty;
        ae = le("./XMLNode"), ce.exports = function(C) {
          Z(t, C);
          function t(a, v) {
            if (t.__super__.constructor.call(this, a), v == null)
              throw new Error("Missing CDATA text. " + this.debugInfo());
            this.text = this.stringify.cdata(v);
          }
          return t.prototype.clone = function() {
            return Object.create(this);
          }, t.prototype.toString = function(a) {
            return this.options.writer.set(a).cdata(this);
          }, t;
        }(ae);
      }).call(this);
    }, { "./XMLNode": 135 }], 125: [function(le, ce, re) {
      (function() {
        var ae, Z = function(C, t) {
          for (var a in t)
            o.call(t, a) && (C[a] = t[a]);
          function v() {
            this.constructor = C;
          }
          return v.prototype = t.prototype, C.prototype = new v(), C.__super__ = t.prototype, C;
        }, o = {}.hasOwnProperty;
        ae = le("./XMLNode"), ce.exports = function(C) {
          Z(t, C);
          function t(a, v) {
            if (t.__super__.constructor.call(this, a), v == null)
              throw new Error("Missing comment text. " + this.debugInfo());
            this.text = this.stringify.comment(v);
          }
          return t.prototype.clone = function() {
            return Object.create(this);
          }, t.prototype.toString = function(a) {
            return this.options.writer.set(a).comment(this);
          }, t;
        }(ae);
      }).call(this);
    }, { "./XMLNode": 135 }], 126: [function(le, ce, re) {
      (function() {
        var ae, Z = function(C, t) {
          for (var a in t)
            o.call(t, a) && (C[a] = t[a]);
          function v() {
            this.constructor = C;
          }
          return v.prototype = t.prototype, C.prototype = new v(), C.__super__ = t.prototype, C;
        }, o = {}.hasOwnProperty;
        ae = le("./XMLNode"), ce.exports = function(C) {
          Z(t, C);
          function t(a, v, h, e, y, c) {
            if (t.__super__.constructor.call(this, a), v == null)
              throw new Error("Missing DTD element name. " + this.debugInfo());
            if (h == null)
              throw new Error("Missing DTD attribute name. " + this.debugInfo(v));
            if (!e)
              throw new Error("Missing DTD attribute type. " + this.debugInfo(v));
            if (!y)
              throw new Error("Missing DTD attribute default. " + this.debugInfo(v));
            if (y.indexOf("#") !== 0 && (y = "#" + y), !y.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/))
              throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(v));
            if (c && !y.match(/^(#FIXED|#DEFAULT)$/))
              throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(v));
            this.elementName = this.stringify.eleName(v), this.attributeName = this.stringify.attName(h), this.attributeType = this.stringify.dtdAttType(e), this.defaultValue = this.stringify.dtdAttDefault(c), this.defaultValueType = y;
          }
          return t.prototype.toString = function(a) {
            return this.options.writer.set(a).dtdAttList(this);
          }, t;
        }(ae);
      }).call(this);
    }, { "./XMLNode": 135 }], 127: [function(le, ce, re) {
      (function() {
        var ae, Z = function(C, t) {
          for (var a in t)
            o.call(t, a) && (C[a] = t[a]);
          function v() {
            this.constructor = C;
          }
          return v.prototype = t.prototype, C.prototype = new v(), C.__super__ = t.prototype, C;
        }, o = {}.hasOwnProperty;
        ae = le("./XMLNode"), ce.exports = function(C) {
          Z(t, C);
          function t(a, v, h) {
            if (t.__super__.constructor.call(this, a), v == null)
              throw new Error("Missing DTD element name. " + this.debugInfo());
            h || (h = "(#PCDATA)"), Array.isArray(h) && (h = "(" + h.join(",") + ")"), this.name = this.stringify.eleName(v), this.value = this.stringify.dtdElementValue(h);
          }
          return t.prototype.toString = function(a) {
            return this.options.writer.set(a).dtdElement(this);
          }, t;
        }(ae);
      }).call(this);
    }, { "./XMLNode": 135 }], 128: [function(le, ce, re) {
      (function() {
        var ae, Z, o = function(t, a) {
          for (var v in a)
            C.call(a, v) && (t[v] = a[v]);
          function h() {
            this.constructor = t;
          }
          return h.prototype = a.prototype, t.prototype = new h(), t.__super__ = a.prototype, t;
        }, C = {}.hasOwnProperty;
        Z = le("./Utility").isObject, ae = le("./XMLNode"), ce.exports = function(t) {
          o(a, t);
          function a(v, h, e, y) {
            if (a.__super__.constructor.call(this, v), e == null)
              throw new Error("Missing DTD entity name. " + this.debugInfo(e));
            if (y == null)
              throw new Error("Missing DTD entity value. " + this.debugInfo(e));
            if (this.pe = !!h, this.name = this.stringify.eleName(e), !Z(y))
              this.value = this.stringify.dtdEntityValue(y);
            else {
              if (!y.pubID && !y.sysID)
                throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(e));
              if (y.pubID && !y.sysID)
                throw new Error("System identifier is required for a public external entity. " + this.debugInfo(e));
              if (y.pubID != null && (this.pubID = this.stringify.dtdPubID(y.pubID)), y.sysID != null && (this.sysID = this.stringify.dtdSysID(y.sysID)), y.nData != null && (this.nData = this.stringify.dtdNData(y.nData)), this.pe && this.nData)
                throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(e));
            }
          }
          return a.prototype.toString = function(v) {
            return this.options.writer.set(v).dtdEntity(this);
          }, a;
        }(ae);
      }).call(this);
    }, { "./Utility": 122, "./XMLNode": 135 }], 129: [function(le, ce, re) {
      (function() {
        var ae, Z = function(C, t) {
          for (var a in t)
            o.call(t, a) && (C[a] = t[a]);
          function v() {
            this.constructor = C;
          }
          return v.prototype = t.prototype, C.prototype = new v(), C.__super__ = t.prototype, C;
        }, o = {}.hasOwnProperty;
        ae = le("./XMLNode"), ce.exports = function(C) {
          Z(t, C);
          function t(a, v, h) {
            if (t.__super__.constructor.call(this, a), v == null)
              throw new Error("Missing DTD notation name. " + this.debugInfo(v));
            if (!h.pubID && !h.sysID)
              throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(v));
            this.name = this.stringify.eleName(v), h.pubID != null && (this.pubID = this.stringify.dtdPubID(h.pubID)), h.sysID != null && (this.sysID = this.stringify.dtdSysID(h.sysID));
          }
          return t.prototype.toString = function(a) {
            return this.options.writer.set(a).dtdNotation(this);
          }, t;
        }(ae);
      }).call(this);
    }, { "./XMLNode": 135 }], 130: [function(le, ce, re) {
      (function() {
        var ae, Z, o = function(t, a) {
          for (var v in a)
            C.call(a, v) && (t[v] = a[v]);
          function h() {
            this.constructor = t;
          }
          return h.prototype = a.prototype, t.prototype = new h(), t.__super__ = a.prototype, t;
        }, C = {}.hasOwnProperty;
        Z = le("./Utility").isObject, ae = le("./XMLNode"), ce.exports = function(t) {
          o(a, t);
          function a(v, h, e, y) {
            var c;
            a.__super__.constructor.call(this, v), Z(h) && (c = h, h = c.version, e = c.encoding, y = c.standalone), h || (h = "1.0"), this.version = this.stringify.xmlVersion(h), e != null && (this.encoding = this.stringify.xmlEncoding(e)), y != null && (this.standalone = this.stringify.xmlStandalone(y));
          }
          return a.prototype.toString = function(v) {
            return this.options.writer.set(v).declaration(this);
          }, a;
        }(ae);
      }).call(this);
    }, { "./Utility": 122, "./XMLNode": 135 }], 131: [function(le, ce, re) {
      (function() {
        var ae, Z, o, C, t, a, v = function(e, y) {
          for (var c in y)
            h.call(y, c) && (e[c] = y[c]);
          function d() {
            this.constructor = e;
          }
          return d.prototype = y.prototype, e.prototype = new d(), e.__super__ = y.prototype, e;
        }, h = {}.hasOwnProperty;
        a = le("./Utility").isObject, t = le("./XMLNode"), ae = le("./XMLDTDAttList"), o = le("./XMLDTDEntity"), Z = le("./XMLDTDElement"), C = le("./XMLDTDNotation"), ce.exports = function(e) {
          v(y, e);
          function y(c, d, p) {
            var m, g;
            y.__super__.constructor.call(this, c), this.name = "!DOCTYPE", this.documentObject = c, a(d) && (m = d, d = m.pubID, p = m.sysID), p == null && (g = [d, p], p = g[0], d = g[1]), d != null && (this.pubID = this.stringify.dtdPubID(d)), p != null && (this.sysID = this.stringify.dtdSysID(p));
          }
          return y.prototype.element = function(c, d) {
            var p;
            return p = new Z(this, c, d), this.children.push(p), this;
          }, y.prototype.attList = function(c, d, p, m, g) {
            var n;
            return n = new ae(this, c, d, p, m, g), this.children.push(n), this;
          }, y.prototype.entity = function(c, d) {
            var p;
            return p = new o(this, !1, c, d), this.children.push(p), this;
          }, y.prototype.pEntity = function(c, d) {
            var p;
            return p = new o(this, !0, c, d), this.children.push(p), this;
          }, y.prototype.notation = function(c, d) {
            var p;
            return p = new C(this, c, d), this.children.push(p), this;
          }, y.prototype.toString = function(c) {
            return this.options.writer.set(c).docType(this);
          }, y.prototype.ele = function(c, d) {
            return this.element(c, d);
          }, y.prototype.att = function(c, d, p, m, g) {
            return this.attList(c, d, p, m, g);
          }, y.prototype.ent = function(c, d) {
            return this.entity(c, d);
          }, y.prototype.pent = function(c, d) {
            return this.pEntity(c, d);
          }, y.prototype.not = function(c, d) {
            return this.notation(c, d);
          }, y.prototype.up = function() {
            return this.root() || this.documentObject;
          }, y;
        }(t);
      }).call(this);
    }, { "./Utility": 122, "./XMLDTDAttList": 126, "./XMLDTDElement": 127, "./XMLDTDEntity": 128, "./XMLDTDNotation": 129, "./XMLNode": 135 }], 132: [function(le, ce, re) {
      (function() {
        var ae, Z, o, C, t = function(v, h) {
          for (var e in h)
            a.call(h, e) && (v[e] = h[e]);
          function y() {
            this.constructor = v;
          }
          return y.prototype = h.prototype, v.prototype = new y(), v.__super__ = h.prototype, v;
        }, a = {}.hasOwnProperty;
        C = le("./Utility").isPlainObject, ae = le("./XMLNode"), o = le("./XMLStringifier"), Z = le("./XMLStringWriter"), ce.exports = function(v) {
          t(h, v);
          function h(e) {
            h.__super__.constructor.call(this, null), this.name = "?xml", e || (e = {}), e.writer || (e.writer = new Z()), this.options = e, this.stringify = new o(e), this.isDocument = !0;
          }
          return h.prototype.end = function(e) {
            var y;
            return e ? C(e) && (y = e, e = this.options.writer.set(y)) : e = this.options.writer, e.document(this);
          }, h.prototype.toString = function(e) {
            return this.options.writer.set(e).document(this);
          }, h;
        }(ae);
      }).call(this);
    }, { "./Utility": 122, "./XMLNode": 135, "./XMLStringWriter": 139, "./XMLStringifier": 140 }], 133: [function(le, ce, re) {
      (function() {
        var ae, Z, o, C, t, a, v, h, e, y, c, d, p, m, g, n, i, l, u, w, _ = {}.hasOwnProperty;
        w = le("./Utility"), l = w.isObject, i = w.isFunction, u = w.isPlainObject, n = w.getValue, y = le("./XMLElement"), Z = le("./XMLCData"), o = le("./XMLComment"), d = le("./XMLRaw"), g = le("./XMLText"), c = le("./XMLProcessingInstruction"), h = le("./XMLDeclaration"), e = le("./XMLDocType"), C = le("./XMLDTDAttList"), a = le("./XMLDTDEntity"), t = le("./XMLDTDElement"), v = le("./XMLDTDNotation"), ae = le("./XMLAttribute"), m = le("./XMLStringifier"), p = le("./XMLStringWriter"), ce.exports = function() {
          function b(A, Y, j) {
            var X;
            this.name = "?xml", A || (A = {}), A.writer ? u(A.writer) && (X = A.writer, A.writer = new p(X)) : A.writer = new p(A), this.options = A, this.writer = A.writer, this.stringify = new m(A), this.onDataCallback = Y || function() {
            }, this.onEndCallback = j || function() {
            }, this.currentNode = null, this.currentLevel = -1, this.openTags = {}, this.documentStarted = !1, this.documentCompleted = !1, this.root = null;
          }
          return b.prototype.node = function(A, Y, j) {
            var X;
            if (A == null)
              throw new Error("Missing node name.");
            if (this.root && this.currentLevel === -1)
              throw new Error("Document can only have one root node. " + this.debugInfo(A));
            return this.openCurrent(), A = n(A), Y == null && (Y = {}), Y = n(Y), l(Y) || (X = [Y, j], j = X[0], Y = X[1]), this.currentNode = new y(this, A, Y), this.currentNode.children = !1, this.currentLevel++, this.openTags[this.currentLevel] = this.currentNode, j != null && this.text(j), this;
          }, b.prototype.element = function(A, Y, j) {
            return this.currentNode && this.currentNode instanceof e ? this.dtdElement.apply(this, arguments) : this.node(A, Y, j);
          }, b.prototype.attribute = function(A, Y) {
            var j, X;
            if (!this.currentNode || this.currentNode.children)
              throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(A));
            if (A != null && (A = n(A)), l(A))
              for (j in A)
                _.call(A, j) && (X = A[j], this.attribute(j, X));
            else
              i(Y) && (Y = Y.apply()), (!this.options.skipNullAttributes || Y != null) && (this.currentNode.attributes[A] = new ae(this, A, Y));
            return this;
          }, b.prototype.text = function(A) {
            var Y;
            return this.openCurrent(), Y = new g(this, A), this.onData(this.writer.text(Y, this.currentLevel + 1), this.currentLevel + 1), this;
          }, b.prototype.cdata = function(A) {
            var Y;
            return this.openCurrent(), Y = new Z(this, A), this.onData(this.writer.cdata(Y, this.currentLevel + 1), this.currentLevel + 1), this;
          }, b.prototype.comment = function(A) {
            var Y;
            return this.openCurrent(), Y = new o(this, A), this.onData(this.writer.comment(Y, this.currentLevel + 1), this.currentLevel + 1), this;
          }, b.prototype.raw = function(A) {
            var Y;
            return this.openCurrent(), Y = new d(this, A), this.onData(this.writer.raw(Y, this.currentLevel + 1), this.currentLevel + 1), this;
          }, b.prototype.instruction = function(A, Y) {
            var j, X, B, R, k;
            if (this.openCurrent(), A != null && (A = n(A)), Y != null && (Y = n(Y)), Array.isArray(A))
              for (j = 0, R = A.length; j < R; j++)
                X = A[j], this.instruction(X);
            else if (l(A))
              for (X in A)
                _.call(A, X) && (B = A[X], this.instruction(X, B));
            else
              i(Y) && (Y = Y.apply()), k = new c(this, A, Y), this.onData(this.writer.processingInstruction(k, this.currentLevel + 1), this.currentLevel + 1);
            return this;
          }, b.prototype.declaration = function(A, Y, j) {
            var X;
            if (this.openCurrent(), this.documentStarted)
              throw new Error("declaration() must be the first node.");
            return X = new h(this, A, Y, j), this.onData(this.writer.declaration(X, this.currentLevel + 1), this.currentLevel + 1), this;
          }, b.prototype.doctype = function(A, Y, j) {
            if (this.openCurrent(), A == null)
              throw new Error("Missing root node name.");
            if (this.root)
              throw new Error("dtd() must come before the root node.");
            return this.currentNode = new e(this, Y, j), this.currentNode.rootNodeName = A, this.currentNode.children = !1, this.currentLevel++, this.openTags[this.currentLevel] = this.currentNode, this;
          }, b.prototype.dtdElement = function(A, Y) {
            var j;
            return this.openCurrent(), j = new t(this, A, Y), this.onData(this.writer.dtdElement(j, this.currentLevel + 1), this.currentLevel + 1), this;
          }, b.prototype.attList = function(A, Y, j, X, B) {
            var R;
            return this.openCurrent(), R = new C(this, A, Y, j, X, B), this.onData(this.writer.dtdAttList(R, this.currentLevel + 1), this.currentLevel + 1), this;
          }, b.prototype.entity = function(A, Y) {
            var j;
            return this.openCurrent(), j = new a(this, !1, A, Y), this.onData(this.writer.dtdEntity(j, this.currentLevel + 1), this.currentLevel + 1), this;
          }, b.prototype.pEntity = function(A, Y) {
            var j;
            return this.openCurrent(), j = new a(this, !0, A, Y), this.onData(this.writer.dtdEntity(j, this.currentLevel + 1), this.currentLevel + 1), this;
          }, b.prototype.notation = function(A, Y) {
            var j;
            return this.openCurrent(), j = new v(this, A, Y), this.onData(this.writer.dtdNotation(j, this.currentLevel + 1), this.currentLevel + 1), this;
          }, b.prototype.up = function() {
            if (this.currentLevel < 0)
              throw new Error("The document node has no parent.");
            return this.currentNode ? (this.currentNode.children ? this.closeNode(this.currentNode) : this.openNode(this.currentNode), this.currentNode = null) : this.closeNode(this.openTags[this.currentLevel]), delete this.openTags[this.currentLevel], this.currentLevel--, this;
          }, b.prototype.end = function() {
            for (; this.currentLevel >= 0; )
              this.up();
            return this.onEnd();
          }, b.prototype.openCurrent = function() {
            if (this.currentNode)
              return this.currentNode.children = !0, this.openNode(this.currentNode);
          }, b.prototype.openNode = function(A) {
            if (!A.isOpen)
              return !this.root && this.currentLevel === 0 && A instanceof y && (this.root = A), this.onData(this.writer.openNode(A, this.currentLevel), this.currentLevel), A.isOpen = !0;
          }, b.prototype.closeNode = function(A) {
            if (!A.isClosed)
              return this.onData(this.writer.closeNode(A, this.currentLevel), this.currentLevel), A.isClosed = !0;
          }, b.prototype.onData = function(A, Y) {
            return this.documentStarted = !0, this.onDataCallback(A, Y + 1);
          }, b.prototype.onEnd = function() {
            return this.documentCompleted = !0, this.onEndCallback();
          }, b.prototype.debugInfo = function(A) {
            return A == null ? "" : "node: <" + A + ">";
          }, b.prototype.ele = function() {
            return this.element.apply(this, arguments);
          }, b.prototype.nod = function(A, Y, j) {
            return this.node(A, Y, j);
          }, b.prototype.txt = function(A) {
            return this.text(A);
          }, b.prototype.dat = function(A) {
            return this.cdata(A);
          }, b.prototype.com = function(A) {
            return this.comment(A);
          }, b.prototype.ins = function(A, Y) {
            return this.instruction(A, Y);
          }, b.prototype.dec = function(A, Y, j) {
            return this.declaration(A, Y, j);
          }, b.prototype.dtd = function(A, Y, j) {
            return this.doctype(A, Y, j);
          }, b.prototype.e = function(A, Y, j) {
            return this.element(A, Y, j);
          }, b.prototype.n = function(A, Y, j) {
            return this.node(A, Y, j);
          }, b.prototype.t = function(A) {
            return this.text(A);
          }, b.prototype.d = function(A) {
            return this.cdata(A);
          }, b.prototype.c = function(A) {
            return this.comment(A);
          }, b.prototype.r = function(A) {
            return this.raw(A);
          }, b.prototype.i = function(A, Y) {
            return this.instruction(A, Y);
          }, b.prototype.att = function() {
            return this.currentNode && this.currentNode instanceof e ? this.attList.apply(this, arguments) : this.attribute.apply(this, arguments);
          }, b.prototype.a = function() {
            return this.currentNode && this.currentNode instanceof e ? this.attList.apply(this, arguments) : this.attribute.apply(this, arguments);
          }, b.prototype.ent = function(A, Y) {
            return this.entity(A, Y);
          }, b.prototype.pent = function(A, Y) {
            return this.pEntity(A, Y);
          }, b.prototype.not = function(A, Y) {
            return this.notation(A, Y);
          }, b;
        }();
      }).call(this);
    }, { "./Utility": 122, "./XMLAttribute": 123, "./XMLCData": 124, "./XMLComment": 125, "./XMLDTDAttList": 126, "./XMLDTDElement": 127, "./XMLDTDEntity": 128, "./XMLDTDNotation": 129, "./XMLDeclaration": 130, "./XMLDocType": 131, "./XMLElement": 134, "./XMLProcessingInstruction": 136, "./XMLRaw": 137, "./XMLStringWriter": 139, "./XMLStringifier": 140, "./XMLText": 141 }], 134: [function(le, ce, re) {
      (function() {
        var ae, Z, o, C, t, a, v = function(e, y) {
          for (var c in y)
            h.call(y, c) && (e[c] = y[c]);
          function d() {
            this.constructor = e;
          }
          return d.prototype = y.prototype, e.prototype = new d(), e.__super__ = y.prototype, e;
        }, h = {}.hasOwnProperty;
        a = le("./Utility"), t = a.isObject, C = a.isFunction, o = a.getValue, Z = le("./XMLNode"), ae = le("./XMLAttribute"), ce.exports = function(e) {
          v(y, e);
          function y(c, d, p) {
            if (y.__super__.constructor.call(this, c), d == null)
              throw new Error("Missing element name. " + this.debugInfo());
            this.name = this.stringify.eleName(d), this.attributes = {}, p != null && this.attribute(p), c.isDocument && (this.isRoot = !0, this.documentObject = c, c.rootObject = this);
          }
          return y.prototype.clone = function() {
            var c, d, p, m;
            p = Object.create(this), p.isRoot && (p.documentObject = null), p.attributes = {}, m = this.attributes;
            for (d in m)
              h.call(m, d) && (c = m[d], p.attributes[d] = c.clone());
            return p.children = [], this.children.forEach(function(g) {
              var n;
              return n = g.clone(), n.parent = p, p.children.push(n);
            }), p;
          }, y.prototype.attribute = function(c, d) {
            var p, m;
            if (c != null && (c = o(c)), t(c))
              for (p in c)
                h.call(c, p) && (m = c[p], this.attribute(p, m));
            else
              C(d) && (d = d.apply()), (!this.options.skipNullAttributes || d != null) && (this.attributes[c] = new ae(this, c, d));
            return this;
          }, y.prototype.removeAttribute = function(c) {
            var d, p, m;
            if (c == null)
              throw new Error("Missing attribute name. " + this.debugInfo());
            if (c = o(c), Array.isArray(c))
              for (p = 0, m = c.length; p < m; p++)
                d = c[p], delete this.attributes[d];
            else
              delete this.attributes[c];
            return this;
          }, y.prototype.toString = function(c) {
            return this.options.writer.set(c).element(this);
          }, y.prototype.att = function(c, d) {
            return this.attribute(c, d);
          }, y.prototype.a = function(c, d) {
            return this.attribute(c, d);
          }, y;
        }(Z);
      }).call(this);
    }, { "./Utility": 122, "./XMLAttribute": 123, "./XMLNode": 135 }], 135: [function(le, ce, re) {
      (function() {
        var ae, Z, o, C, t, a, v, h, e, y, c, d, p, m = {}.hasOwnProperty;
        p = le("./Utility"), d = p.isObject, c = p.isFunction, y = p.isEmpty, e = p.getValue, t = null, ae = null, Z = null, o = null, C = null, v = null, h = null, a = null, ce.exports = function() {
          function g(n) {
            this.parent = n, this.parent && (this.options = this.parent.options, this.stringify = this.parent.stringify), this.children = [], t || (t = le("./XMLElement"), ae = le("./XMLCData"), Z = le("./XMLComment"), o = le("./XMLDeclaration"), C = le("./XMLDocType"), v = le("./XMLRaw"), h = le("./XMLText"), a = le("./XMLProcessingInstruction"));
          }
          return g.prototype.element = function(n, i, l) {
            var u, w, _, b, A, Y, j, X, B, R;
            if (Y = null, i == null && (i = {}), i = e(i), d(i) || (B = [i, l], l = B[0], i = B[1]), n != null && (n = e(n)), Array.isArray(n))
              for (_ = 0, j = n.length; _ < j; _++)
                w = n[_], Y = this.element(w);
            else if (c(n))
              Y = this.element(n.apply());
            else if (d(n)) {
              for (A in n)
                if (m.call(n, A))
                  if (R = n[A], c(R) && (R = R.apply()), d(R) && y(R) && (R = null), !this.options.ignoreDecorators && this.stringify.convertAttKey && A.indexOf(this.stringify.convertAttKey) === 0)
                    Y = this.attribute(A.substr(this.stringify.convertAttKey.length), R);
                  else if (!this.options.separateArrayItems && Array.isArray(R))
                    for (b = 0, X = R.length; b < X; b++)
                      w = R[b], u = {}, u[A] = w, Y = this.element(u);
                  else
                    d(R) ? (Y = this.element(A), Y.element(R)) : Y = this.element(A, R);
            } else
              !this.options.ignoreDecorators && this.stringify.convertTextKey && n.indexOf(this.stringify.convertTextKey) === 0 ? Y = this.text(l) : !this.options.ignoreDecorators && this.stringify.convertCDataKey && n.indexOf(this.stringify.convertCDataKey) === 0 ? Y = this.cdata(l) : !this.options.ignoreDecorators && this.stringify.convertCommentKey && n.indexOf(this.stringify.convertCommentKey) === 0 ? Y = this.comment(l) : !this.options.ignoreDecorators && this.stringify.convertRawKey && n.indexOf(this.stringify.convertRawKey) === 0 ? Y = this.raw(l) : !this.options.ignoreDecorators && this.stringify.convertPIKey && n.indexOf(this.stringify.convertPIKey) === 0 ? Y = this.instruction(n.substr(this.stringify.convertPIKey.length), l) : Y = this.node(n, i, l);
            if (Y == null)
              throw new Error("Could not create any elements with: " + n + ". " + this.debugInfo());
            return Y;
          }, g.prototype.insertBefore = function(n, i, l) {
            var u, w, _;
            if (this.isRoot)
              throw new Error("Cannot insert elements at root level. " + this.debugInfo(n));
            return w = this.parent.children.indexOf(this), _ = this.parent.children.splice(w), u = this.parent.element(n, i, l), Array.prototype.push.apply(this.parent.children, _), u;
          }, g.prototype.insertAfter = function(n, i, l) {
            var u, w, _;
            if (this.isRoot)
              throw new Error("Cannot insert elements at root level. " + this.debugInfo(n));
            return w = this.parent.children.indexOf(this), _ = this.parent.children.splice(w + 1), u = this.parent.element(n, i, l), Array.prototype.push.apply(this.parent.children, _), u;
          }, g.prototype.remove = function() {
            var n;
            if (this.isRoot)
              throw new Error("Cannot remove the root element. " + this.debugInfo());
            return n = this.parent.children.indexOf(this), [].splice.apply(this.parent.children, [n, n - n + 1].concat([])), this.parent;
          }, g.prototype.node = function(n, i, l) {
            var u, w;
            return n != null && (n = e(n)), i || (i = {}), i = e(i), d(i) || (w = [i, l], l = w[0], i = w[1]), u = new t(this, n, i), l != null && u.text(l), this.children.push(u), u;
          }, g.prototype.text = function(n) {
            var i;
            return i = new h(this, n), this.children.push(i), this;
          }, g.prototype.cdata = function(n) {
            var i;
            return i = new ae(this, n), this.children.push(i), this;
          }, g.prototype.comment = function(n) {
            var i;
            return i = new Z(this, n), this.children.push(i), this;
          }, g.prototype.commentBefore = function(n) {
            var i, l;
            return i = this.parent.children.indexOf(this), l = this.parent.children.splice(i), this.parent.comment(n), Array.prototype.push.apply(this.parent.children, l), this;
          }, g.prototype.commentAfter = function(n) {
            var i, l;
            return i = this.parent.children.indexOf(this), l = this.parent.children.splice(i + 1), this.parent.comment(n), Array.prototype.push.apply(this.parent.children, l), this;
          }, g.prototype.raw = function(n) {
            var i;
            return i = new v(this, n), this.children.push(i), this;
          }, g.prototype.instruction = function(n, i) {
            var l, u, w, _, b;
            if (n != null && (n = e(n)), i != null && (i = e(i)), Array.isArray(n))
              for (_ = 0, b = n.length; _ < b; _++)
                l = n[_], this.instruction(l);
            else if (d(n))
              for (l in n)
                m.call(n, l) && (u = n[l], this.instruction(l, u));
            else
              c(i) && (i = i.apply()), w = new a(this, n, i), this.children.push(w);
            return this;
          }, g.prototype.instructionBefore = function(n, i) {
            var l, u;
            return l = this.parent.children.indexOf(this), u = this.parent.children.splice(l), this.parent.instruction(n, i), Array.prototype.push.apply(this.parent.children, u), this;
          }, g.prototype.instructionAfter = function(n, i) {
            var l, u;
            return l = this.parent.children.indexOf(this), u = this.parent.children.splice(l + 1), this.parent.instruction(n, i), Array.prototype.push.apply(this.parent.children, u), this;
          }, g.prototype.declaration = function(n, i, l) {
            var u, w;
            return u = this.document(), w = new o(u, n, i, l), u.children[0] instanceof o ? u.children[0] = w : u.children.unshift(w), u.root() || u;
          }, g.prototype.doctype = function(n, i) {
            var l, u, w, _, b, A, Y, j, X, B;
            for (u = this.document(), w = new C(u, n, i), X = u.children, _ = b = 0, Y = X.length; b < Y; _ = ++b)
              if (l = X[_], l instanceof C)
                return u.children[_] = w, w;
            for (B = u.children, _ = A = 0, j = B.length; A < j; _ = ++A)
              if (l = B[_], l.isRoot)
                return u.children.splice(_, 0, w), w;
            return u.children.push(w), w;
          }, g.prototype.up = function() {
            if (this.isRoot)
              throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
            return this.parent;
          }, g.prototype.root = function() {
            var n;
            for (n = this; n; ) {
              if (n.isDocument)
                return n.rootObject;
              if (n.isRoot)
                return n;
              n = n.parent;
            }
          }, g.prototype.document = function() {
            var n;
            for (n = this; n; ) {
              if (n.isDocument)
                return n;
              n = n.parent;
            }
          }, g.prototype.end = function(n) {
            return this.document().end(n);
          }, g.prototype.prev = function() {
            var n;
            if (n = this.parent.children.indexOf(this), n < 1)
              throw new Error("Already at the first node. " + this.debugInfo());
            return this.parent.children[n - 1];
          }, g.prototype.next = function() {
            var n;
            if (n = this.parent.children.indexOf(this), n === -1 || n === this.parent.children.length - 1)
              throw new Error("Already at the last node. " + this.debugInfo());
            return this.parent.children[n + 1];
          }, g.prototype.importDocument = function(n) {
            var i;
            return i = n.root().clone(), i.parent = this, i.isRoot = !1, this.children.push(i), this;
          }, g.prototype.debugInfo = function(n) {
            var i, l;
            return n = n || this.name, n == null && !((i = this.parent) != null && i.name) ? "" : n == null ? "parent: <" + this.parent.name + ">" : (l = this.parent) != null && l.name ? "node: <" + n + ">, parent: <" + this.parent.name + ">" : "node: <" + n + ">";
          }, g.prototype.ele = function(n, i, l) {
            return this.element(n, i, l);
          }, g.prototype.nod = function(n, i, l) {
            return this.node(n, i, l);
          }, g.prototype.txt = function(n) {
            return this.text(n);
          }, g.prototype.dat = function(n) {
            return this.cdata(n);
          }, g.prototype.com = function(n) {
            return this.comment(n);
          }, g.prototype.ins = function(n, i) {
            return this.instruction(n, i);
          }, g.prototype.doc = function() {
            return this.document();
          }, g.prototype.dec = function(n, i, l) {
            return this.declaration(n, i, l);
          }, g.prototype.dtd = function(n, i) {
            return this.doctype(n, i);
          }, g.prototype.e = function(n, i, l) {
            return this.element(n, i, l);
          }, g.prototype.n = function(n, i, l) {
            return this.node(n, i, l);
          }, g.prototype.t = function(n) {
            return this.text(n);
          }, g.prototype.d = function(n) {
            return this.cdata(n);
          }, g.prototype.c = function(n) {
            return this.comment(n);
          }, g.prototype.r = function(n) {
            return this.raw(n);
          }, g.prototype.i = function(n, i) {
            return this.instruction(n, i);
          }, g.prototype.u = function() {
            return this.up();
          }, g.prototype.importXMLBuilder = function(n) {
            return this.importDocument(n);
          }, g;
        }();
      }).call(this);
    }, { "./Utility": 122, "./XMLCData": 124, "./XMLComment": 125, "./XMLDeclaration": 130, "./XMLDocType": 131, "./XMLElement": 134, "./XMLProcessingInstruction": 136, "./XMLRaw": 137, "./XMLText": 141 }], 136: [function(le, ce, re) {
      (function() {
        var ae, Z = function(C, t) {
          for (var a in t)
            o.call(t, a) && (C[a] = t[a]);
          function v() {
            this.constructor = C;
          }
          return v.prototype = t.prototype, C.prototype = new v(), C.__super__ = t.prototype, C;
        }, o = {}.hasOwnProperty;
        ae = le("./XMLNode"), ce.exports = function(C) {
          Z(t, C);
          function t(a, v, h) {
            if (t.__super__.constructor.call(this, a), v == null)
              throw new Error("Missing instruction target. " + this.debugInfo());
            this.target = this.stringify.insTarget(v), h && (this.value = this.stringify.insValue(h));
          }
          return t.prototype.clone = function() {
            return Object.create(this);
          }, t.prototype.toString = function(a) {
            return this.options.writer.set(a).processingInstruction(this);
          }, t;
        }(ae);
      }).call(this);
    }, { "./XMLNode": 135 }], 137: [function(le, ce, re) {
      (function() {
        var ae, Z = function(C, t) {
          for (var a in t)
            o.call(t, a) && (C[a] = t[a]);
          function v() {
            this.constructor = C;
          }
          return v.prototype = t.prototype, C.prototype = new v(), C.__super__ = t.prototype, C;
        }, o = {}.hasOwnProperty;
        ae = le("./XMLNode"), ce.exports = function(C) {
          Z(t, C);
          function t(a, v) {
            if (t.__super__.constructor.call(this, a), v == null)
              throw new Error("Missing raw text. " + this.debugInfo());
            this.value = this.stringify.raw(v);
          }
          return t.prototype.clone = function() {
            return Object.create(this);
          }, t.prototype.toString = function(a) {
            return this.options.writer.set(a).raw(this);
          }, t;
        }(ae);
      }).call(this);
    }, { "./XMLNode": 135 }], 138: [function(le, ce, re) {
      (function() {
        var ae, Z, o, C, t, a, v, h, e, y, c, d, p, m = function(n, i) {
          for (var l in i)
            g.call(i, l) && (n[l] = i[l]);
          function u() {
            this.constructor = n;
          }
          return u.prototype = i.prototype, n.prototype = new u(), n.__super__ = i.prototype, n;
        }, g = {}.hasOwnProperty;
        v = le("./XMLDeclaration"), h = le("./XMLDocType"), ae = le("./XMLCData"), Z = le("./XMLComment"), e = le("./XMLElement"), c = le("./XMLRaw"), d = le("./XMLText"), y = le("./XMLProcessingInstruction"), o = le("./XMLDTDAttList"), C = le("./XMLDTDElement"), t = le("./XMLDTDEntity"), a = le("./XMLDTDNotation"), p = le("./XMLWriterBase"), ce.exports = function(n) {
          m(i, n);
          function i(l, u) {
            i.__super__.constructor.call(this, u), this.stream = l;
          }
          return i.prototype.document = function(l) {
            var u, w, _, b, A, Y, j, X;
            for (Y = l.children, w = 0, b = Y.length; w < b; w++)
              u = Y[w], u.isLastRootNode = !1;
            for (l.children[l.children.length - 1].isLastRootNode = !0, j = l.children, X = [], _ = 0, A = j.length; _ < A; _++)
              switch (u = j[_], !1) {
                case !(u instanceof v):
                  X.push(this.declaration(u));
                  break;
                case !(u instanceof h):
                  X.push(this.docType(u));
                  break;
                case !(u instanceof Z):
                  X.push(this.comment(u));
                  break;
                case !(u instanceof y):
                  X.push(this.processingInstruction(u));
                  break;
                default:
                  X.push(this.element(u));
              }
            return X;
          }, i.prototype.attribute = function(l) {
            return this.stream.write(" " + l.name + '="' + l.value + '"');
          }, i.prototype.cdata = function(l, u) {
            return this.stream.write(this.space(u) + "<![CDATA[" + l.text + "]]>" + this.endline(l));
          }, i.prototype.comment = function(l, u) {
            return this.stream.write(this.space(u) + "<!-- " + l.text + " -->" + this.endline(l));
          }, i.prototype.declaration = function(l, u) {
            return this.stream.write(this.space(u)), this.stream.write('<?xml version="' + l.version + '"'), l.encoding != null && this.stream.write(' encoding="' + l.encoding + '"'), l.standalone != null && this.stream.write(' standalone="' + l.standalone + '"'), this.stream.write(this.spacebeforeslash + "?>"), this.stream.write(this.endline(l));
          }, i.prototype.docType = function(l, u) {
            var w, _, b, A;
            if (u || (u = 0), this.stream.write(this.space(u)), this.stream.write("<!DOCTYPE " + l.root().name), l.pubID && l.sysID ? this.stream.write(' PUBLIC "' + l.pubID + '" "' + l.sysID + '"') : l.sysID && this.stream.write(' SYSTEM "' + l.sysID + '"'), l.children.length > 0) {
              for (this.stream.write(" ["), this.stream.write(this.endline(l)), A = l.children, _ = 0, b = A.length; _ < b; _++)
                switch (w = A[_], !1) {
                  case !(w instanceof o):
                    this.dtdAttList(w, u + 1);
                    break;
                  case !(w instanceof C):
                    this.dtdElement(w, u + 1);
                    break;
                  case !(w instanceof t):
                    this.dtdEntity(w, u + 1);
                    break;
                  case !(w instanceof a):
                    this.dtdNotation(w, u + 1);
                    break;
                  case !(w instanceof ae):
                    this.cdata(w, u + 1);
                    break;
                  case !(w instanceof Z):
                    this.comment(w, u + 1);
                    break;
                  case !(w instanceof y):
                    this.processingInstruction(w, u + 1);
                    break;
                  default:
                    throw new Error("Unknown DTD node type: " + w.constructor.name);
                }
              this.stream.write("]");
            }
            return this.stream.write(this.spacebeforeslash + ">"), this.stream.write(this.endline(l));
          }, i.prototype.element = function(l, u) {
            var w, _, b, A, Y, j, X, B;
            u || (u = 0), B = this.space(u), this.stream.write(B + "<" + l.name), j = l.attributes;
            for (Y in j)
              g.call(j, Y) && (w = j[Y], this.attribute(w));
            if (l.children.length === 0 || l.children.every(function(R) {
              return R.value === "";
            }))
              this.allowEmpty ? this.stream.write("></" + l.name + ">") : this.stream.write(this.spacebeforeslash + "/>");
            else if (this.pretty && l.children.length === 1 && l.children[0].value != null)
              this.stream.write(">"), this.stream.write(l.children[0].value), this.stream.write("</" + l.name + ">");
            else {
              for (this.stream.write(">" + this.newline), X = l.children, b = 0, A = X.length; b < A; b++)
                switch (_ = X[b], !1) {
                  case !(_ instanceof ae):
                    this.cdata(_, u + 1);
                    break;
                  case !(_ instanceof Z):
                    this.comment(_, u + 1);
                    break;
                  case !(_ instanceof e):
                    this.element(_, u + 1);
                    break;
                  case !(_ instanceof c):
                    this.raw(_, u + 1);
                    break;
                  case !(_ instanceof d):
                    this.text(_, u + 1);
                    break;
                  case !(_ instanceof y):
                    this.processingInstruction(_, u + 1);
                    break;
                  default:
                    throw new Error("Unknown XML node type: " + _.constructor.name);
                }
              this.stream.write(B + "</" + l.name + ">");
            }
            return this.stream.write(this.endline(l));
          }, i.prototype.processingInstruction = function(l, u) {
            return this.stream.write(this.space(u) + "<?" + l.target), l.value && this.stream.write(" " + l.value), this.stream.write(this.spacebeforeslash + "?>" + this.endline(l));
          }, i.prototype.raw = function(l, u) {
            return this.stream.write(this.space(u) + l.value + this.endline(l));
          }, i.prototype.text = function(l, u) {
            return this.stream.write(this.space(u) + l.value + this.endline(l));
          }, i.prototype.dtdAttList = function(l, u) {
            return this.stream.write(this.space(u) + "<!ATTLIST " + l.elementName + " " + l.attributeName + " " + l.attributeType), l.defaultValueType !== "#DEFAULT" && this.stream.write(" " + l.defaultValueType), l.defaultValue && this.stream.write(' "' + l.defaultValue + '"'), this.stream.write(this.spacebeforeslash + ">" + this.endline(l));
          }, i.prototype.dtdElement = function(l, u) {
            return this.stream.write(this.space(u) + "<!ELEMENT " + l.name + " " + l.value), this.stream.write(this.spacebeforeslash + ">" + this.endline(l));
          }, i.prototype.dtdEntity = function(l, u) {
            return this.stream.write(this.space(u) + "<!ENTITY"), l.pe && this.stream.write(" %"), this.stream.write(" " + l.name), l.value ? this.stream.write(' "' + l.value + '"') : (l.pubID && l.sysID ? this.stream.write(' PUBLIC "' + l.pubID + '" "' + l.sysID + '"') : l.sysID && this.stream.write(' SYSTEM "' + l.sysID + '"'), l.nData && this.stream.write(" NDATA " + l.nData)), this.stream.write(this.spacebeforeslash + ">" + this.endline(l));
          }, i.prototype.dtdNotation = function(l, u) {
            return this.stream.write(this.space(u) + "<!NOTATION " + l.name), l.pubID && l.sysID ? this.stream.write(' PUBLIC "' + l.pubID + '" "' + l.sysID + '"') : l.pubID ? this.stream.write(' PUBLIC "' + l.pubID + '"') : l.sysID && this.stream.write(' SYSTEM "' + l.sysID + '"'), this.stream.write(this.spacebeforeslash + ">" + this.endline(l));
          }, i.prototype.endline = function(l) {
            return l.isLastRootNode ? "" : this.newline;
          }, i;
        }(p);
      }).call(this);
    }, { "./XMLCData": 124, "./XMLComment": 125, "./XMLDTDAttList": 126, "./XMLDTDElement": 127, "./XMLDTDEntity": 128, "./XMLDTDNotation": 129, "./XMLDeclaration": 130, "./XMLDocType": 131, "./XMLElement": 134, "./XMLProcessingInstruction": 136, "./XMLRaw": 137, "./XMLText": 141, "./XMLWriterBase": 142 }], 139: [function(le, ce, re) {
      (function() {
        var ae, Z, o, C, t, a, v, h, e, y, c, d, p, m = function(n, i) {
          for (var l in i)
            g.call(i, l) && (n[l] = i[l]);
          function u() {
            this.constructor = n;
          }
          return u.prototype = i.prototype, n.prototype = new u(), n.__super__ = i.prototype, n;
        }, g = {}.hasOwnProperty;
        v = le("./XMLDeclaration"), h = le("./XMLDocType"), ae = le("./XMLCData"), Z = le("./XMLComment"), e = le("./XMLElement"), c = le("./XMLRaw"), d = le("./XMLText"), y = le("./XMLProcessingInstruction"), o = le("./XMLDTDAttList"), C = le("./XMLDTDElement"), t = le("./XMLDTDEntity"), a = le("./XMLDTDNotation"), p = le("./XMLWriterBase"), ce.exports = function(n) {
          m(i, n);
          function i(l) {
            i.__super__.constructor.call(this, l);
          }
          return i.prototype.document = function(l) {
            var u, w, _, b, A;
            for (this.textispresent = !1, b = "", A = l.children, w = 0, _ = A.length; w < _; w++)
              u = A[w], b += function() {
                switch (!1) {
                  case !(u instanceof v):
                    return this.declaration(u);
                  case !(u instanceof h):
                    return this.docType(u);
                  case !(u instanceof Z):
                    return this.comment(u);
                  case !(u instanceof y):
                    return this.processingInstruction(u);
                  default:
                    return this.element(u, 0);
                }
              }.call(this);
            return this.pretty && b.slice(-this.newline.length) === this.newline && (b = b.slice(0, -this.newline.length)), b;
          }, i.prototype.attribute = function(l) {
            return " " + l.name + '="' + l.value + '"';
          }, i.prototype.cdata = function(l, u) {
            return this.space(u) + "<![CDATA[" + l.text + "]]>" + this.newline;
          }, i.prototype.comment = function(l, u) {
            return this.space(u) + "<!-- " + l.text + " -->" + this.newline;
          }, i.prototype.declaration = function(l, u) {
            var w;
            return w = this.space(u), w += '<?xml version="' + l.version + '"', l.encoding != null && (w += ' encoding="' + l.encoding + '"'), l.standalone != null && (w += ' standalone="' + l.standalone + '"'), w += this.spacebeforeslash + "?>", w += this.newline, w;
          }, i.prototype.docType = function(l, u) {
            var w, _, b, A, Y;
            if (u || (u = 0), A = this.space(u), A += "<!DOCTYPE " + l.root().name, l.pubID && l.sysID ? A += ' PUBLIC "' + l.pubID + '" "' + l.sysID + '"' : l.sysID && (A += ' SYSTEM "' + l.sysID + '"'), l.children.length > 0) {
              for (A += " [", A += this.newline, Y = l.children, _ = 0, b = Y.length; _ < b; _++)
                w = Y[_], A += function() {
                  switch (!1) {
                    case !(w instanceof o):
                      return this.dtdAttList(w, u + 1);
                    case !(w instanceof C):
                      return this.dtdElement(w, u + 1);
                    case !(w instanceof t):
                      return this.dtdEntity(w, u + 1);
                    case !(w instanceof a):
                      return this.dtdNotation(w, u + 1);
                    case !(w instanceof ae):
                      return this.cdata(w, u + 1);
                    case !(w instanceof Z):
                      return this.comment(w, u + 1);
                    case !(w instanceof y):
                      return this.processingInstruction(w, u + 1);
                    default:
                      throw new Error("Unknown DTD node type: " + w.constructor.name);
                  }
                }.call(this);
              A += "]";
            }
            return A += this.spacebeforeslash + ">", A += this.newline, A;
          }, i.prototype.element = function(l, u) {
            var w, _, b, A, Y, j, X, B, R, k, x, f, U;
            u || (u = 0), U = !1, this.textispresent ? (this.newline = "", this.pretty = !1) : (this.newline = this.newlinedefault, this.pretty = this.prettydefault), f = this.space(u), B = "", B += f + "<" + l.name, R = l.attributes;
            for (X in R)
              g.call(R, X) && (w = R[X], B += this.attribute(w));
            if (l.children.length === 0 || l.children.every(function(O) {
              return O.value === "";
            }))
              this.allowEmpty ? B += "></" + l.name + ">" + this.newline : B += this.spacebeforeslash + "/>" + this.newline;
            else if (this.pretty && l.children.length === 1 && l.children[0].value != null)
              B += ">", B += l.children[0].value, B += "</" + l.name + ">" + this.newline;
            else {
              if (this.dontprettytextnodes) {
                for (k = l.children, b = 0, Y = k.length; b < Y; b++)
                  if (_ = k[b], _.value != null) {
                    this.textispresent++, U = !0;
                    break;
                  }
              }
              for (this.textispresent && (this.newline = "", this.pretty = !1, f = this.space(u)), B += ">" + this.newline, x = l.children, A = 0, j = x.length; A < j; A++)
                _ = x[A], B += function() {
                  switch (!1) {
                    case !(_ instanceof ae):
                      return this.cdata(_, u + 1);
                    case !(_ instanceof Z):
                      return this.comment(_, u + 1);
                    case !(_ instanceof e):
                      return this.element(_, u + 1);
                    case !(_ instanceof c):
                      return this.raw(_, u + 1);
                    case !(_ instanceof d):
                      return this.text(_, u + 1);
                    case !(_ instanceof y):
                      return this.processingInstruction(_, u + 1);
                    default:
                      throw new Error("Unknown XML node type: " + _.constructor.name);
                  }
                }.call(this);
              U && this.textispresent--, this.textispresent || (this.newline = this.newlinedefault, this.pretty = this.prettydefault), B += f + "</" + l.name + ">" + this.newline;
            }
            return B;
          }, i.prototype.processingInstruction = function(l, u) {
            var w;
            return w = this.space(u) + "<?" + l.target, l.value && (w += " " + l.value), w += this.spacebeforeslash + "?>" + this.newline, w;
          }, i.prototype.raw = function(l, u) {
            return this.space(u) + l.value + this.newline;
          }, i.prototype.text = function(l, u) {
            return this.space(u) + l.value + this.newline;
          }, i.prototype.dtdAttList = function(l, u) {
            var w;
            return w = this.space(u) + "<!ATTLIST " + l.elementName + " " + l.attributeName + " " + l.attributeType, l.defaultValueType !== "#DEFAULT" && (w += " " + l.defaultValueType), l.defaultValue && (w += ' "' + l.defaultValue + '"'), w += this.spacebeforeslash + ">" + this.newline, w;
          }, i.prototype.dtdElement = function(l, u) {
            return this.space(u) + "<!ELEMENT " + l.name + " " + l.value + this.spacebeforeslash + ">" + this.newline;
          }, i.prototype.dtdEntity = function(l, u) {
            var w;
            return w = this.space(u) + "<!ENTITY", l.pe && (w += " %"), w += " " + l.name, l.value ? w += ' "' + l.value + '"' : (l.pubID && l.sysID ? w += ' PUBLIC "' + l.pubID + '" "' + l.sysID + '"' : l.sysID && (w += ' SYSTEM "' + l.sysID + '"'), l.nData && (w += " NDATA " + l.nData)), w += this.spacebeforeslash + ">" + this.newline, w;
          }, i.prototype.dtdNotation = function(l, u) {
            var w;
            return w = this.space(u) + "<!NOTATION " + l.name, l.pubID && l.sysID ? w += ' PUBLIC "' + l.pubID + '" "' + l.sysID + '"' : l.pubID ? w += ' PUBLIC "' + l.pubID + '"' : l.sysID && (w += ' SYSTEM "' + l.sysID + '"'), w += this.spacebeforeslash + ">" + this.newline, w;
          }, i.prototype.openNode = function(l, u) {
            var w, _, b, A;
            if (u || (u = 0), l instanceof e) {
              b = this.space(u) + "<" + l.name, A = l.attributes;
              for (_ in A)
                g.call(A, _) && (w = A[_], b += this.attribute(w));
              return b += (l.children ? ">" : "/>") + this.newline, b;
            } else
              return b = this.space(u) + "<!DOCTYPE " + l.rootNodeName, l.pubID && l.sysID ? b += ' PUBLIC "' + l.pubID + '" "' + l.sysID + '"' : l.sysID && (b += ' SYSTEM "' + l.sysID + '"'), b += (l.children ? " [" : ">") + this.newline, b;
          }, i.prototype.closeNode = function(l, u) {
            switch (u || (u = 0), !1) {
              case !(l instanceof e):
                return this.space(u) + "</" + l.name + ">" + this.newline;
              case !(l instanceof h):
                return this.space(u) + "]>" + this.newline;
            }
          }, i;
        }(p);
      }).call(this);
    }, { "./XMLCData": 124, "./XMLComment": 125, "./XMLDTDAttList": 126, "./XMLDTDElement": 127, "./XMLDTDEntity": 128, "./XMLDTDNotation": 129, "./XMLDeclaration": 130, "./XMLDocType": 131, "./XMLElement": 134, "./XMLProcessingInstruction": 136, "./XMLRaw": 137, "./XMLText": 141, "./XMLWriterBase": 142 }], 140: [function(le, ce, re) {
      (function() {
        var ae = function(o, C) {
          return function() {
            return o.apply(C, arguments);
          };
        }, Z = {}.hasOwnProperty;
        ce.exports = function() {
          function o(C) {
            this.assertLegalChar = ae(this.assertLegalChar, this);
            var t, a, v;
            C || (C = {}), this.noDoubleEncoding = C.noDoubleEncoding, a = C.stringify || {};
            for (t in a)
              Z.call(a, t) && (v = a[t], this[t] = v);
          }
          return o.prototype.eleName = function(C) {
            return C = "" + C || "", this.assertLegalChar(C);
          }, o.prototype.eleText = function(C) {
            return C = "" + C || "", this.assertLegalChar(this.elEscape(C));
          }, o.prototype.cdata = function(C) {
            return C = "" + C || "", C = C.replace("]]>", "]]]]><![CDATA[>"), this.assertLegalChar(C);
          }, o.prototype.comment = function(C) {
            if (C = "" + C || "", C.match(/--/))
              throw new Error("Comment text cannot contain double-hypen: " + C);
            return this.assertLegalChar(C);
          }, o.prototype.raw = function(C) {
            return "" + C || "";
          }, o.prototype.attName = function(C) {
            return C = "" + C || "";
          }, o.prototype.attValue = function(C) {
            return C = "" + C || "", this.attEscape(C);
          }, o.prototype.insTarget = function(C) {
            return "" + C || "";
          }, o.prototype.insValue = function(C) {
            if (C = "" + C || "", C.match(/\?>/))
              throw new Error("Invalid processing instruction value: " + C);
            return C;
          }, o.prototype.xmlVersion = function(C) {
            if (C = "" + C || "", !C.match(/1\.[0-9]+/))
              throw new Error("Invalid version number: " + C);
            return C;
          }, o.prototype.xmlEncoding = function(C) {
            if (C = "" + C || "", !C.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/))
              throw new Error("Invalid encoding: " + C);
            return C;
          }, o.prototype.xmlStandalone = function(C) {
            return C ? "yes" : "no";
          }, o.prototype.dtdPubID = function(C) {
            return "" + C || "";
          }, o.prototype.dtdSysID = function(C) {
            return "" + C || "";
          }, o.prototype.dtdElementValue = function(C) {
            return "" + C || "";
          }, o.prototype.dtdAttType = function(C) {
            return "" + C || "";
          }, o.prototype.dtdAttDefault = function(C) {
            return C != null ? "" + C || "" : C;
          }, o.prototype.dtdEntityValue = function(C) {
            return "" + C || "";
          }, o.prototype.dtdNData = function(C) {
            return "" + C || "";
          }, o.prototype.convertAttKey = "@", o.prototype.convertPIKey = "?", o.prototype.convertTextKey = "#text", o.prototype.convertCDataKey = "#cdata", o.prototype.convertCommentKey = "#comment", o.prototype.convertRawKey = "#raw", o.prototype.assertLegalChar = function(C) {
            var t;
            if (t = C.match(/[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/), t)
              throw new Error("Invalid character in string: " + C + " at index " + t.index);
            return C;
          }, o.prototype.elEscape = function(C) {
            var t;
            return t = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g, C.replace(t, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;");
          }, o.prototype.attEscape = function(C) {
            var t;
            return t = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g, C.replace(t, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
          }, o;
        }();
      }).call(this);
    }, {}], 141: [function(le, ce, re) {
      (function() {
        var ae, Z = function(C, t) {
          for (var a in t)
            o.call(t, a) && (C[a] = t[a]);
          function v() {
            this.constructor = C;
          }
          return v.prototype = t.prototype, C.prototype = new v(), C.__super__ = t.prototype, C;
        }, o = {}.hasOwnProperty;
        ae = le("./XMLNode"), ce.exports = function(C) {
          Z(t, C);
          function t(a, v) {
            if (t.__super__.constructor.call(this, a), v == null)
              throw new Error("Missing element text. " + this.debugInfo());
            this.value = this.stringify.eleText(v);
          }
          return t.prototype.clone = function() {
            return Object.create(this);
          }, t.prototype.toString = function(a) {
            return this.options.writer.set(a).text(this);
          }, t;
        }(ae);
      }).call(this);
    }, { "./XMLNode": 135 }], 142: [function(le, ce, re) {
      (function() {
        var ae = {}.hasOwnProperty;
        ce.exports = function() {
          function Z(o) {
            var C, t, a, v, h, e, y, c, d;
            o || (o = {}), this.pretty = o.pretty || !1, this.allowEmpty = (t = o.allowEmpty) != null ? t : !1, this.pretty ? (this.indent = (a = o.indent) != null ? a : "  ", this.newline = (v = o.newline) != null ? v : `
`, this.offset = (h = o.offset) != null ? h : 0, this.dontprettytextnodes = (e = o.dontprettytextnodes) != null ? e : 0) : (this.indent = "", this.newline = "", this.offset = 0, this.dontprettytextnodes = 0), this.spacebeforeslash = (y = o.spacebeforeslash) != null ? y : "", this.spacebeforeslash === !0 && (this.spacebeforeslash = " "), this.newlinedefault = this.newline, this.prettydefault = this.pretty, c = o.writer || {};
            for (C in c)
              ae.call(c, C) && (d = c[C], this[C] = d);
          }
          return Z.prototype.set = function(o) {
            var C, t, a;
            o || (o = {}), "pretty" in o && (this.pretty = o.pretty), "allowEmpty" in o && (this.allowEmpty = o.allowEmpty), this.pretty ? (this.indent = "indent" in o ? o.indent : "  ", this.newline = "newline" in o ? o.newline : `
`, this.offset = "offset" in o ? o.offset : 0, this.dontprettytextnodes = "dontprettytextnodes" in o ? o.dontprettytextnodes : 0) : (this.indent = "", this.newline = "", this.offset = 0, this.dontprettytextnodes = 0), this.spacebeforeslash = "spacebeforeslash" in o ? o.spacebeforeslash : "", this.spacebeforeslash === !0 && (this.spacebeforeslash = " "), this.newlinedefault = this.newline, this.prettydefault = this.pretty, t = o.writer || {};
            for (C in t)
              ae.call(t, C) && (a = t[C], this[C] = a);
            return this;
          }, Z.prototype.space = function(o) {
            var C;
            return this.pretty ? (C = (o || 0) + this.offset + 1, C > 0 ? new Array(C).join(this.indent) : "") : "";
          }, Z;
        }();
      }).call(this);
    }, {}], 143: [function(le, ce, re) {
      (function() {
        var ae, Z, o, C, t, a, v;
        v = le("./Utility"), t = v.assign, a = v.isFunction, ae = le("./XMLDocument"), Z = le("./XMLDocumentCB"), C = le("./XMLStringWriter"), o = le("./XMLStreamWriter"), ce.exports.create = function(h, e, y, c) {
          var d, p;
          if (h == null)
            throw new Error("Root element needs a name.");
          return c = t({}, e, y, c), d = new ae(c), p = d.element(h), c.headless || (d.declaration(c), (c.pubID != null || c.sysID != null) && d.doctype(c)), p;
        }, ce.exports.begin = function(h, e, y) {
          var c;
          return a(h) && (c = [h, e], e = c[0], y = c[1], h = {}), e ? new Z(h, e, y) : new ae(h);
        }, ce.exports.stringWriter = function(h) {
          return new C(h);
        }, ce.exports.streamWriter = function(h, e) {
          return new o(h, e);
        };
      }).call(this);
    }, { "./Utility": 122, "./XMLDocument": 132, "./XMLDocumentCB": 133, "./XMLStreamWriter": 138, "./XMLStringWriter": 139 }] }, {}, [21])(21);
  });
})(mammoth_browser);
const mammoth = /* @__PURE__ */ getDefaultExportFromCjs(mammoth_browserExports), wrapper$2 = "_wrapper_1n25d_1", thumbnail = "_thumbnail_1n25d_9", loading = "_loading_1n25d_14", s$2 = {
  wrapper: wrapper$2,
  thumbnail,
  loading
}, DOCXViewer = ({ filePath: be, isThumbnail: ge }) => {
  const le = `${be}${ge ? "-thumb" : ""}`, ce = async (re) => {
    const ae = document.getElementById(le);
    try {
      const Z = await mammoth.convertToHtml({
        arrayBuffer: re
      }), o = document.createElement("div");
      o.innerHTML = Z.value, ae && (ae.innerHTML = o.outerHTML);
    } catch (Z) {
      ae && (ae.innerHTML = Z.message);
    }
  };
  return useEffect(() => {
    const re = new XMLHttpRequest();
    re.open("GET", be, !0), re.send(), re.responseType = "arraybuffer", re.onreadystatechange = () => {
      re.readyState === 4 && re.status === 200 && ce(re.response);
    };
  }, []), /* @__PURE__ */ jsx("div", { id: le, className: `${s$2.wrapper} ${ge ? s$2.thumbnail : ""}`, children: /* @__PURE__ */ jsx("div", { className: s$2.loading, children: "Loading document..." }) });
}, wrapper$1 = "_wrapper_1awyo_1", s$1 = {
  wrapper: wrapper$1
}, UnsupportedViewer = () => /* @__PURE__ */ jsx("div", { className: s$1.wrapper, children: "Unsupported file format" }), wrapper = "_wrapper_lm3j5_1", viewer = "_viewer_lm3j5_7", s = {
  wrapper,
  viewer
}, FileViewer = ({
  fileType: be,
  filePath: ge,
  isThumbnail: le
}) => {
  const ce = (re) => {
    switch (be) {
      case "jpg":
      case "jpeg":
      case "gif":
      case "bmp":
      case "png":
        return /* @__PURE__ */ jsx(ImageViewer, { ...re });
      case "pdf":
        return /* @__PURE__ */ jsx(PDFViewer, { ...re });
      case "docx":
        return /* @__PURE__ */ jsx(DOCXViewer, { ...re });
      default:
        return /* @__PURE__ */ jsx(UnsupportedViewer, {});
    }
  };
  return /* @__PURE__ */ jsx("div", { className: s.wrapper, children: /* @__PURE__ */ jsx("div", { className: s.viewer, children: ce({ filePath: ge, isThumbnail: le }) }) });
};
export {
  FileViewer
};
