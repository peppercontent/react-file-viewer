var dr = Object.defineProperty;
var fr = (Ee, ge, le) => ge in Ee ? dr(Ee, ge, { enumerable: !0, configurable: !0, writable: !0, value: le }) : Ee[ge] = le;
var sn = (Ee, ge, le) => (fr(Ee, typeof ge != "symbol" ? ge + "" : ge, le), le), ui = (Ee, ge, le) => {
  if (!ge.has(Ee))
    throw TypeError("Cannot " + le);
};
var ke = (Ee, ge, le) => (ui(Ee, ge, "read from private field"), le ? le.call(Ee) : ge.get(Ee)), ft = (Ee, ge, le) => {
  if (ge.has(Ee))
    throw TypeError("Cannot add the same private member more than once");
  ge instanceof WeakSet ? ge.add(Ee) : ge.set(Ee, le);
}, Tt = (Ee, ge, le, de) => (ui(Ee, ge, "write to private field"), de ? de.call(Ee, le) : ge.set(Ee, le), le), hi = (Ee, ge, le, de) => ({
  set _(oe) {
    Tt(Ee, ge, oe, le);
  },
  get _() {
    return ke(Ee, ge, de);
  }
}), wt = (Ee, ge, le) => (ui(Ee, ge, "access private method"), le);
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getAugmentedNamespace(Ee) {
  if (Ee.__esModule)
    return Ee;
  var ge = Ee.default;
  if (typeof ge == "function") {
    var le = function de() {
      if (this instanceof de) {
        var oe = [null];
        oe.push.apply(oe, arguments);
        var se = Function.bind.apply(ge, oe);
        return new se();
      }
      return ge.apply(this, arguments);
    };
    le.prototype = ge.prototype;
  } else
    le = {};
  return Object.defineProperty(le, "__esModule", { value: !0 }), Object.keys(Ee).forEach(function(de) {
    var oe = Object.getOwnPropertyDescriptor(Ee, de);
    Object.defineProperty(le, de, oe.get ? oe : {
      enumerable: !0,
      get: function() {
        return Ee[de];
      }
    });
  }), le;
}
var jsxRuntimeExports = {}, jsxRuntime = {
  get exports() {
    return jsxRuntimeExports;
  },
  set exports(Ee) {
    jsxRuntimeExports = Ee;
  }
}, reactJsxRuntime_production_min = {}, reactExports = {}, react = {
  get exports() {
    return reactExports;
  },
  set exports(Ee) {
    reactExports = Ee;
  }
}, react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReact_production_min;
function requireReact_production_min() {
  if (hasRequiredReact_production_min)
    return react_production_min;
  hasRequiredReact_production_min = 1;
  var Ee = Symbol.for("react.element"), ge = Symbol.for("react.portal"), le = Symbol.for("react.fragment"), de = Symbol.for("react.strict_mode"), oe = Symbol.for("react.profiler"), se = Symbol.for("react.provider"), Q = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), P = Symbol.for("react.suspense"), t = Symbol.for("react.memo"), i = Symbol.for("react.lazy"), v = Symbol.iterator;
  function a(_) {
    return _ === null || typeof _ != "object" ? null : (_ = v && _[v] || _["@@iterator"], typeof _ == "function" ? _ : null);
  }
  var e = { isMounted: function() {
    return !1;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, y = Object.assign, r = {};
  function h(_, S, A) {
    this.props = _, this.context = S, this.refs = r, this.updater = A || e;
  }
  h.prototype.isReactComponent = {}, h.prototype.setState = function(_, S) {
    if (typeof _ != "object" && typeof _ != "function" && _ != null)
      throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, _, S, "setState");
  }, h.prototype.forceUpdate = function(_) {
    this.updater.enqueueForceUpdate(this, _, "forceUpdate");
  };
  function g() {
  }
  g.prototype = h.prototype;
  function d(_, S, A) {
    this.props = _, this.context = S, this.refs = r, this.updater = A || e;
  }
  var c = d.prototype = new g();
  c.constructor = d, y(c, h.prototype), c.isPureReactComponent = !0;
  var n = Array.isArray, o = Object.prototype.hasOwnProperty, x = { current: null }, f = { key: !0, ref: !0, __self: !0, __source: !0 };
  function m(_, S, A) {
    var F, T = {}, O = null, U = null;
    if (S != null)
      for (F in S.ref !== void 0 && (U = S.ref), S.key !== void 0 && (O = "" + S.key), S)
        o.call(S, F) && !f.hasOwnProperty(F) && (T[F] = S[F]);
    var G = arguments.length - 2;
    if (G === 1)
      T.children = A;
    else if (1 < G) {
      for (var K = Array(G), W = 0; W < G; W++)
        K[W] = arguments[W + 2];
      T.children = K;
    }
    if (_ && _.defaultProps)
      for (F in G = _.defaultProps, G)
        T[F] === void 0 && (T[F] = G[F]);
    return { $$typeof: Ee, type: _, key: O, ref: U, props: T, _owner: x.current };
  }
  function C(_, S) {
    return { $$typeof: Ee, type: _.type, key: S, ref: _.ref, props: _.props, _owner: _._owner };
  }
  function p(_) {
    return typeof _ == "object" && _ !== null && _.$$typeof === Ee;
  }
  function w(_) {
    var S = { "=": "=0", ":": "=2" };
    return "$" + _.replace(/[=:]/g, function(A) {
      return S[A];
    });
  }
  var X = /\/+/g;
  function M(_, S) {
    return typeof _ == "object" && _ !== null && _.key != null ? w("" + _.key) : S.toString(36);
  }
  function j(_, S, A, F, T) {
    var O = typeof _;
    (O === "undefined" || O === "boolean") && (_ = null);
    var U = !1;
    if (_ === null)
      U = !0;
    else
      switch (O) {
        case "string":
        case "number":
          U = !0;
          break;
        case "object":
          switch (_.$$typeof) {
            case Ee:
            case ge:
              U = !0;
          }
      }
    if (U)
      return U = _, T = T(U), _ = F === "" ? "." + M(U, 0) : F, n(T) ? (A = "", _ != null && (A = _.replace(X, "$&/") + "/"), j(T, S, A, "", function(W) {
        return W;
      })) : T != null && (p(T) && (T = C(T, A + (!T.key || U && U.key === T.key ? "" : ("" + T.key).replace(X, "$&/") + "/") + _)), S.push(T)), 1;
    if (U = 0, F = F === "" ? "." : F + ":", n(_))
      for (var G = 0; G < _.length; G++) {
        O = _[G];
        var K = F + M(O, G);
        U += j(O, S, A, K, T);
      }
    else if (K = a(_), typeof K == "function")
      for (_ = K.call(_), G = 0; !(O = _.next()).done; )
        O = O.value, K = F + M(O, G++), U += j(O, S, A, K, T);
    else if (O === "object")
      throw S = String(_), Error("Objects are not valid as a React child (found: " + (S === "[object Object]" ? "object with keys {" + Object.keys(_).join(", ") + "}" : S) + "). If you meant to render a collection of children, use an array instead.");
    return U;
  }
  function B(_, S, A) {
    if (_ == null)
      return _;
    var F = [], T = 0;
    return j(_, F, "", "", function(O) {
      return S.call(A, O, T++);
    }), F;
  }
  function R(_) {
    if (_._status === -1) {
      var S = _._result;
      S = S(), S.then(function(A) {
        (_._status === 0 || _._status === -1) && (_._status = 1, _._result = A);
      }, function(A) {
        (_._status === 0 || _._status === -1) && (_._status = 2, _._result = A);
      }), _._status === -1 && (_._status = 0, _._result = S);
    }
    if (_._status === 1)
      return _._result.default;
    throw _._result;
  }
  var D = { current: null }, b = { transition: null }, l = { ReactCurrentDispatcher: D, ReactCurrentBatchConfig: b, ReactCurrentOwner: x };
  return react_production_min.Children = { map: B, forEach: function(_, S, A) {
    B(_, function() {
      S.apply(this, arguments);
    }, A);
  }, count: function(_) {
    var S = 0;
    return B(_, function() {
      S++;
    }), S;
  }, toArray: function(_) {
    return B(_, function(S) {
      return S;
    }) || [];
  }, only: function(_) {
    if (!p(_))
      throw Error("React.Children.only expected to receive a single React element child.");
    return _;
  } }, react_production_min.Component = h, react_production_min.Fragment = le, react_production_min.Profiler = oe, react_production_min.PureComponent = d, react_production_min.StrictMode = de, react_production_min.Suspense = P, react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = l, react_production_min.cloneElement = function(_, S, A) {
    if (_ == null)
      throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + _ + ".");
    var F = y({}, _.props), T = _.key, O = _.ref, U = _._owner;
    if (S != null) {
      if (S.ref !== void 0 && (O = S.ref, U = x.current), S.key !== void 0 && (T = "" + S.key), _.type && _.type.defaultProps)
        var G = _.type.defaultProps;
      for (K in S)
        o.call(S, K) && !f.hasOwnProperty(K) && (F[K] = S[K] === void 0 && G !== void 0 ? G[K] : S[K]);
    }
    var K = arguments.length - 2;
    if (K === 1)
      F.children = A;
    else if (1 < K) {
      G = Array(K);
      for (var W = 0; W < K; W++)
        G[W] = arguments[W + 2];
      F.children = G;
    }
    return { $$typeof: Ee, type: _.type, key: T, ref: O, props: F, _owner: U };
  }, react_production_min.createContext = function(_) {
    return _ = { $$typeof: Q, _currentValue: _, _currentValue2: _, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, _.Provider = { $$typeof: se, _context: _ }, _.Consumer = _;
  }, react_production_min.createElement = m, react_production_min.createFactory = function(_) {
    var S = m.bind(null, _);
    return S.type = _, S;
  }, react_production_min.createRef = function() {
    return { current: null };
  }, react_production_min.forwardRef = function(_) {
    return { $$typeof: u, render: _ };
  }, react_production_min.isValidElement = p, react_production_min.lazy = function(_) {
    return { $$typeof: i, _payload: { _status: -1, _result: _ }, _init: R };
  }, react_production_min.memo = function(_, S) {
    return { $$typeof: t, type: _, compare: S === void 0 ? null : S };
  }, react_production_min.startTransition = function(_) {
    var S = b.transition;
    b.transition = {};
    try {
      _();
    } finally {
      b.transition = S;
    }
  }, react_production_min.unstable_act = function() {
    throw Error("act(...) is not supported in production builds of React.");
  }, react_production_min.useCallback = function(_, S) {
    return D.current.useCallback(_, S);
  }, react_production_min.useContext = function(_) {
    return D.current.useContext(_);
  }, react_production_min.useDebugValue = function() {
  }, react_production_min.useDeferredValue = function(_) {
    return D.current.useDeferredValue(_);
  }, react_production_min.useEffect = function(_, S) {
    return D.current.useEffect(_, S);
  }, react_production_min.useId = function() {
    return D.current.useId();
  }, react_production_min.useImperativeHandle = function(_, S, A) {
    return D.current.useImperativeHandle(_, S, A);
  }, react_production_min.useInsertionEffect = function(_, S) {
    return D.current.useInsertionEffect(_, S);
  }, react_production_min.useLayoutEffect = function(_, S) {
    return D.current.useLayoutEffect(_, S);
  }, react_production_min.useMemo = function(_, S) {
    return D.current.useMemo(_, S);
  }, react_production_min.useReducer = function(_, S, A) {
    return D.current.useReducer(_, S, A);
  }, react_production_min.useRef = function(_) {
    return D.current.useRef(_);
  }, react_production_min.useState = function(_) {
    return D.current.useState(_);
  }, react_production_min.useSyncExternalStore = function(_, S, A) {
    return D.current.useSyncExternalStore(_, S, A);
  }, react_production_min.useTransition = function() {
    return D.current.useTransition();
  }, react_production_min.version = "18.2.0", react_production_min;
}
var react_developmentExports = {}, react_development = {
  get exports() {
    return react_developmentExports;
  },
  set exports(Ee) {
    react_developmentExports = Ee;
  }
};
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReact_development;
function requireReact_development() {
  return hasRequiredReact_development || (hasRequiredReact_development = 1, function(Ee, ge) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var le = "18.2.0", de = Symbol.for("react.element"), oe = Symbol.for("react.portal"), se = Symbol.for("react.fragment"), Q = Symbol.for("react.strict_mode"), u = Symbol.for("react.profiler"), P = Symbol.for("react.provider"), t = Symbol.for("react.context"), i = Symbol.for("react.forward_ref"), v = Symbol.for("react.suspense"), a = Symbol.for("react.suspense_list"), e = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), r = Symbol.for("react.offscreen"), h = Symbol.iterator, g = "@@iterator";
      function d(ye) {
        if (ye === null || typeof ye != "object")
          return null;
        var Pe = h && ye[h] || ye[g];
        return typeof Pe == "function" ? Pe : null;
      }
      var c = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, n = {
        transition: null
      }, o = {
        current: null,
        // Used to reproduce behavior of `batchedUpdates` in legacy mode.
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1
      }, x = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, f = {}, m = null;
      function C(ye) {
        m = ye;
      }
      f.setExtraStackFrame = function(ye) {
        m = ye;
      }, f.getCurrentStack = null, f.getStackAddendum = function() {
        var ye = "";
        m && (ye += m);
        var Pe = f.getCurrentStack;
        return Pe && (ye += Pe() || ""), ye;
      };
      var p = !1, w = !1, X = !1, M = !1, j = !1, B = {
        ReactCurrentDispatcher: c,
        ReactCurrentBatchConfig: n,
        ReactCurrentOwner: x
      };
      B.ReactDebugCurrentFrame = f, B.ReactCurrentActQueue = o;
      function R(ye) {
        {
          for (var Pe = arguments.length, Qe = new Array(Pe > 1 ? Pe - 1 : 0), Ye = 1; Ye < Pe; Ye++)
            Qe[Ye - 1] = arguments[Ye];
          b("warn", ye, Qe);
        }
      }
      function D(ye) {
        {
          for (var Pe = arguments.length, Qe = new Array(Pe > 1 ? Pe - 1 : 0), Ye = 1; Ye < Pe; Ye++)
            Qe[Ye - 1] = arguments[Ye];
          b("error", ye, Qe);
        }
      }
      function b(ye, Pe, Qe) {
        {
          var Ye = B.ReactDebugCurrentFrame, lt = Ye.getStackAddendum();
          lt !== "" && (Pe += "%s", Qe = Qe.concat([lt]));
          var Bt = Qe.map(function(yt) {
            return String(yt);
          });
          Bt.unshift("Warning: " + Pe), Function.prototype.apply.call(console[ye], console, Bt);
        }
      }
      var l = {};
      function _(ye, Pe) {
        {
          var Qe = ye.constructor, Ye = Qe && (Qe.displayName || Qe.name) || "ReactClass", lt = Ye + "." + Pe;
          if (l[lt])
            return;
          D("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", Pe, Ye), l[lt] = !0;
        }
      }
      var S = {
        /**
         * Checks whether or not this composite component is mounted.
         * @param {ReactClass} publicInstance The instance we want to test.
         * @return {boolean} True if mounted, false otherwise.
         * @protected
         * @final
         */
        isMounted: function(ye) {
          return !1;
        },
        /**
         * Forces an update. This should only be invoked when it is known with
         * certainty that we are **not** in a DOM transaction.
         *
         * You may want to call this when you know that some deeper aspect of the
         * component's state has changed but `setState` was not called.
         *
         * This will not invoke `shouldComponentUpdate`, but it will invoke
         * `componentWillUpdate` and `componentDidUpdate`.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueForceUpdate: function(ye, Pe, Qe) {
          _(ye, "forceUpdate");
        },
        /**
         * Replaces all of the state. Always use this or `setState` to mutate state.
         * You should treat `this.state` as immutable.
         *
         * There is no guarantee that `this.state` will be immediately updated, so
         * accessing `this.state` after calling this method may return the old value.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} completeState Next state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueReplaceState: function(ye, Pe, Qe, Ye) {
          _(ye, "replaceState");
        },
        /**
         * Sets a subset of the state. This only exists because _pendingState is
         * internal. This provides a merging strategy that is not available to deep
         * properties which is confusing. TODO: Expose pendingState or don't use it
         * during the merge.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} partialState Next partial state to be merged with state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} Name of the calling function in the public API.
         * @internal
         */
        enqueueSetState: function(ye, Pe, Qe, Ye) {
          _(ye, "setState");
        }
      }, A = Object.assign, F = {};
      Object.freeze(F);
      function T(ye, Pe, Qe) {
        this.props = ye, this.context = Pe, this.refs = F, this.updater = Qe || S;
      }
      T.prototype.isReactComponent = {}, T.prototype.setState = function(ye, Pe) {
        if (typeof ye != "object" && typeof ye != "function" && ye != null)
          throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, ye, Pe, "setState");
      }, T.prototype.forceUpdate = function(ye) {
        this.updater.enqueueForceUpdate(this, ye, "forceUpdate");
      };
      {
        var O = {
          isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
          replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
        }, U = function(ye, Pe) {
          Object.defineProperty(T.prototype, ye, {
            get: function() {
              R("%s(...) is deprecated in plain JavaScript React classes. %s", Pe[0], Pe[1]);
            }
          });
        };
        for (var G in O)
          O.hasOwnProperty(G) && U(G, O[G]);
      }
      function K() {
      }
      K.prototype = T.prototype;
      function W(ye, Pe, Qe) {
        this.props = ye, this.context = Pe, this.refs = F, this.updater = Qe || S;
      }
      var z = W.prototype = new K();
      z.constructor = W, A(z, T.prototype), z.isPureReactComponent = !0;
      function V() {
        var ye = {
          current: null
        };
        return Object.seal(ye), ye;
      }
      var L = Array.isArray;
      function Y(ye) {
        return L(ye);
      }
      function J(ye) {
        {
          var Pe = typeof Symbol == "function" && Symbol.toStringTag, Qe = Pe && ye[Symbol.toStringTag] || ye.constructor.name || "Object";
          return Qe;
        }
      }
      function ie(ye) {
        try {
          return q(ye), !1;
        } catch {
          return !0;
        }
      }
      function q(ye) {
        return "" + ye;
      }
      function N(ye) {
        if (ie(ye))
          return D("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", J(ye)), q(ye);
      }
      function Z(ye, Pe, Qe) {
        var Ye = ye.displayName;
        if (Ye)
          return Ye;
        var lt = Pe.displayName || Pe.name || "";
        return lt !== "" ? Qe + "(" + lt + ")" : Qe;
      }
      function E(ye) {
        return ye.displayName || "Context";
      }
      function te(ye) {
        if (ye == null)
          return null;
        if (typeof ye.tag == "number" && D("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof ye == "function")
          return ye.displayName || ye.name || null;
        if (typeof ye == "string")
          return ye;
        switch (ye) {
          case se:
            return "Fragment";
          case oe:
            return "Portal";
          case u:
            return "Profiler";
          case Q:
            return "StrictMode";
          case v:
            return "Suspense";
          case a:
            return "SuspenseList";
        }
        if (typeof ye == "object")
          switch (ye.$$typeof) {
            case t:
              var Pe = ye;
              return E(Pe) + ".Consumer";
            case P:
              var Qe = ye;
              return E(Qe._context) + ".Provider";
            case i:
              return Z(ye, ye.render, "ForwardRef");
            case e:
              var Ye = ye.displayName || null;
              return Ye !== null ? Ye : te(ye.type) || "Memo";
            case y: {
              var lt = ye, Bt = lt._payload, yt = lt._init;
              try {
                return te(yt(Bt));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var re = Object.prototype.hasOwnProperty, ee = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, $, k, H;
      H = {};
      function ne(ye) {
        if (re.call(ye, "ref")) {
          var Pe = Object.getOwnPropertyDescriptor(ye, "ref").get;
          if (Pe && Pe.isReactWarning)
            return !1;
        }
        return ye.ref !== void 0;
      }
      function ae(ye) {
        if (re.call(ye, "key")) {
          var Pe = Object.getOwnPropertyDescriptor(ye, "key").get;
          if (Pe && Pe.isReactWarning)
            return !1;
        }
        return ye.key !== void 0;
      }
      function he(ye, Pe) {
        var Qe = function() {
          $ || ($ = !0, D("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Pe));
        };
        Qe.isReactWarning = !0, Object.defineProperty(ye, "key", {
          get: Qe,
          configurable: !0
        });
      }
      function ue(ye, Pe) {
        var Qe = function() {
          k || (k = !0, D("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Pe));
        };
        Qe.isReactWarning = !0, Object.defineProperty(ye, "ref", {
          get: Qe,
          configurable: !0
        });
      }
      function fe(ye) {
        if (typeof ye.ref == "string" && x.current && ye.__self && x.current.stateNode !== ye.__self) {
          var Pe = te(x.current.type);
          H[Pe] || (D('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', Pe, ye.ref), H[Pe] = !0);
        }
      }
      var me = function(ye, Pe, Qe, Ye, lt, Bt, yt) {
        var $t = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: de,
          // Built-in properties that belong on the element
          type: ye,
          key: Pe,
          ref: Qe,
          props: yt,
          // Record the component responsible for creating this element.
          _owner: Bt
        };
        return $t._store = {}, Object.defineProperty($t._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty($t, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: Ye
        }), Object.defineProperty($t, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: lt
        }), Object.freeze && (Object.freeze($t.props), Object.freeze($t)), $t;
      };
      function Fe(ye, Pe, Qe) {
        var Ye, lt = {}, Bt = null, yt = null, $t = null, Ht = null;
        if (Pe != null) {
          ne(Pe) && (yt = Pe.ref, fe(Pe)), ae(Pe) && (N(Pe.key), Bt = "" + Pe.key), $t = Pe.__self === void 0 ? null : Pe.__self, Ht = Pe.__source === void 0 ? null : Pe.__source;
          for (Ye in Pe)
            re.call(Pe, Ye) && !ee.hasOwnProperty(Ye) && (lt[Ye] = Pe[Ye]);
        }
        var zt = arguments.length - 2;
        if (zt === 1)
          lt.children = Qe;
        else if (zt > 1) {
          for (var Jt = Array(zt), Qt = 0; Qt < zt; Qt++)
            Jt[Qt] = arguments[Qt + 2];
          Object.freeze && Object.freeze(Jt), lt.children = Jt;
        }
        if (ye && ye.defaultProps) {
          var nn = ye.defaultProps;
          for (Ye in nn)
            lt[Ye] === void 0 && (lt[Ye] = nn[Ye]);
        }
        if (Bt || yt) {
          var tn = typeof ye == "function" ? ye.displayName || ye.name || "Unknown" : ye;
          Bt && he(lt, tn), yt && ue(lt, tn);
        }
        return me(ye, Bt, yt, $t, Ht, x.current, lt);
      }
      function we(ye, Pe) {
        var Qe = me(ye.type, Pe, ye.ref, ye._self, ye._source, ye._owner, ye.props);
        return Qe;
      }
      function Ae(ye, Pe, Qe) {
        if (ye == null)
          throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + ye + ".");
        var Ye, lt = A({}, ye.props), Bt = ye.key, yt = ye.ref, $t = ye._self, Ht = ye._source, zt = ye._owner;
        if (Pe != null) {
          ne(Pe) && (yt = Pe.ref, zt = x.current), ae(Pe) && (N(Pe.key), Bt = "" + Pe.key);
          var Jt;
          ye.type && ye.type.defaultProps && (Jt = ye.type.defaultProps);
          for (Ye in Pe)
            re.call(Pe, Ye) && !ee.hasOwnProperty(Ye) && (Pe[Ye] === void 0 && Jt !== void 0 ? lt[Ye] = Jt[Ye] : lt[Ye] = Pe[Ye]);
        }
        var Qt = arguments.length - 2;
        if (Qt === 1)
          lt.children = Qe;
        else if (Qt > 1) {
          for (var nn = Array(Qt), tn = 0; tn < Qt; tn++)
            nn[tn] = arguments[tn + 2];
          lt.children = nn;
        }
        return me(ye.type, Bt, yt, $t, Ht, zt, lt);
      }
      function De(ye) {
        return typeof ye == "object" && ye !== null && ye.$$typeof === de;
      }
      var xe = ".", Te = ":";
      function ve(ye) {
        var Pe = /[=:]/g, Qe = {
          "=": "=0",
          ":": "=2"
        }, Ye = ye.replace(Pe, function(lt) {
          return Qe[lt];
        });
        return "$" + Ye;
      }
      var Se = !1, be = /\/+/g;
      function Le(ye) {
        return ye.replace(be, "$&/");
      }
      function ze(ye, Pe) {
        return typeof ye == "object" && ye !== null && ye.key != null ? (N(ye.key), ve("" + ye.key)) : Pe.toString(36);
      }
      function nt(ye, Pe, Qe, Ye, lt) {
        var Bt = typeof ye;
        (Bt === "undefined" || Bt === "boolean") && (ye = null);
        var yt = !1;
        if (ye === null)
          yt = !0;
        else
          switch (Bt) {
            case "string":
            case "number":
              yt = !0;
              break;
            case "object":
              switch (ye.$$typeof) {
                case de:
                case oe:
                  yt = !0;
              }
          }
        if (yt) {
          var $t = ye, Ht = lt($t), zt = Ye === "" ? xe + ze($t, 0) : Ye;
          if (Y(Ht)) {
            var Jt = "";
            zt != null && (Jt = Le(zt) + "/"), nt(Ht, Pe, Jt, "", function(Kn) {
              return Kn;
            });
          } else
            Ht != null && (De(Ht) && (Ht.key && (!$t || $t.key !== Ht.key) && N(Ht.key), Ht = we(
              Ht,
              // Keep both the (mapped) and old keys if they differ, just as
              // traverseAllChildren used to do for objects as children
              Qe + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
              (Ht.key && (!$t || $t.key !== Ht.key) ? (
                // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
                // eslint-disable-next-line react-internal/safe-string-coercion
                Le("" + Ht.key) + "/"
              ) : "") + zt
            )), Pe.push(Ht));
          return 1;
        }
        var Qt, nn, tn = 0, on = Ye === "" ? xe : Ye + Te;
        if (Y(ye))
          for (var Wn = 0; Wn < ye.length; Wn++)
            Qt = ye[Wn], nn = on + ze(Qt, Wn), tn += nt(Qt, Pe, Qe, nn, lt);
        else {
          var Hn = d(ye);
          if (typeof Hn == "function") {
            var Vn = ye;
            Hn === Vn.entries && (Se || R("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), Se = !0);
            for (var ii = Hn.call(Vn), qn, ri = 0; !(qn = ii.next()).done; )
              Qt = qn.value, nn = on + ze(Qt, ri++), tn += nt(Qt, Pe, Qe, nn, lt);
          } else if (Bt === "object") {
            var Yn = String(ye);
            throw new Error("Objects are not valid as a React child (found: " + (Yn === "[object Object]" ? "object with keys {" + Object.keys(ye).join(", ") + "}" : Yn) + "). If you meant to render a collection of children, use an array instead.");
          }
        }
        return tn;
      }
      function Ue(ye, Pe, Qe) {
        if (ye == null)
          return ye;
        var Ye = [], lt = 0;
        return nt(ye, Ye, "", "", function(Bt) {
          return Pe.call(Qe, Bt, lt++);
        }), Ye;
      }
      function Oe(ye) {
        var Pe = 0;
        return Ue(ye, function() {
          Pe++;
        }), Pe;
      }
      function _e(ye, Pe, Qe) {
        Ue(ye, function() {
          Pe.apply(this, arguments);
        }, Qe);
      }
      function at(ye) {
        return Ue(ye, function(Pe) {
          return Pe;
        }) || [];
      }
      function Je(ye) {
        if (!De(ye))
          throw new Error("React.Children.only expected to receive a single React element child.");
        return ye;
      }
      function ot(ye) {
        var Pe = {
          $$typeof: t,
          // As a workaround to support multiple concurrent renderers, we categorize
          // some renderers as primary and others as secondary. We only expect
          // there to be two concurrent renderers at most: React Native (primary) and
          // Fabric (secondary); React DOM (primary) and React ART (secondary).
          // Secondary renderers store their context values on separate fields.
          _currentValue: ye,
          _currentValue2: ye,
          // Used to track how many concurrent renderers this context currently
          // supports within in a single renderer. Such as parallel server rendering.
          _threadCount: 0,
          // These are circular
          Provider: null,
          Consumer: null,
          // Add these to use same hidden class in VM as ServerContext
          _defaultValue: null,
          _globalName: null
        };
        Pe.Provider = {
          $$typeof: P,
          _context: Pe
        };
        var Qe = !1, Ye = !1, lt = !1;
        {
          var Bt = {
            $$typeof: t,
            _context: Pe
          };
          Object.defineProperties(Bt, {
            Provider: {
              get: function() {
                return Ye || (Ye = !0, D("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?")), Pe.Provider;
              },
              set: function(yt) {
                Pe.Provider = yt;
              }
            },
            _currentValue: {
              get: function() {
                return Pe._currentValue;
              },
              set: function(yt) {
                Pe._currentValue = yt;
              }
            },
            _currentValue2: {
              get: function() {
                return Pe._currentValue2;
              },
              set: function(yt) {
                Pe._currentValue2 = yt;
              }
            },
            _threadCount: {
              get: function() {
                return Pe._threadCount;
              },
              set: function(yt) {
                Pe._threadCount = yt;
              }
            },
            Consumer: {
              get: function() {
                return Qe || (Qe = !0, D("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")), Pe.Consumer;
              }
            },
            displayName: {
              get: function() {
                return Pe.displayName;
              },
              set: function(yt) {
                lt || (R("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", yt), lt = !0);
              }
            }
          }), Pe.Consumer = Bt;
        }
        return Pe._currentRenderer = null, Pe._currentRenderer2 = null, Pe;
      }
      var mt = -1, Ze = 0, pt = 1, Ft = 2;
      function $e(ye) {
        if (ye._status === mt) {
          var Pe = ye._result, Qe = Pe();
          if (Qe.then(function(Bt) {
            if (ye._status === Ze || ye._status === mt) {
              var yt = ye;
              yt._status = pt, yt._result = Bt;
            }
          }, function(Bt) {
            if (ye._status === Ze || ye._status === mt) {
              var yt = ye;
              yt._status = Ft, yt._result = Bt;
            }
          }), ye._status === mt) {
            var Ye = ye;
            Ye._status = Ze, Ye._result = Qe;
          }
        }
        if (ye._status === pt) {
          var lt = ye._result;
          return lt === void 0 && D(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, lt), "default" in lt || D(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, lt), lt.default;
        } else
          throw ye._result;
      }
      function St(ye) {
        var Pe = {
          // We use these fields to store the result.
          _status: mt,
          _result: ye
        }, Qe = {
          $$typeof: y,
          _payload: Pe,
          _init: $e
        };
        {
          var Ye, lt;
          Object.defineProperties(Qe, {
            defaultProps: {
              configurable: !0,
              get: function() {
                return Ye;
              },
              set: function(Bt) {
                D("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), Ye = Bt, Object.defineProperty(Qe, "defaultProps", {
                  enumerable: !0
                });
              }
            },
            propTypes: {
              configurable: !0,
              get: function() {
                return lt;
              },
              set: function(Bt) {
                D("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), lt = Bt, Object.defineProperty(Qe, "propTypes", {
                  enumerable: !0
                });
              }
            }
          });
        }
        return Qe;
      }
      function xt(ye) {
        ye != null && ye.$$typeof === e ? D("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof ye != "function" ? D("forwardRef requires a render function but was given %s.", ye === null ? "null" : typeof ye) : ye.length !== 0 && ye.length !== 2 && D("forwardRef render functions accept exactly two parameters: props and ref. %s", ye.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."), ye != null && (ye.defaultProps != null || ye.propTypes != null) && D("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
        var Pe = {
          $$typeof: i,
          render: ye
        };
        {
          var Qe;
          Object.defineProperty(Pe, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return Qe;
            },
            set: function(Ye) {
              Qe = Ye, !ye.name && !ye.displayName && (ye.displayName = Ye);
            }
          });
        }
        return Pe;
      }
      var Ie;
      Ie = Symbol.for("react.module.reference");
      function Ve(ye) {
        return !!(typeof ye == "string" || typeof ye == "function" || ye === se || ye === u || j || ye === Q || ye === v || ye === a || M || ye === r || p || w || X || typeof ye == "object" && ye !== null && (ye.$$typeof === y || ye.$$typeof === e || ye.$$typeof === P || ye.$$typeof === t || ye.$$typeof === i || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        ye.$$typeof === Ie || ye.getModuleId !== void 0));
      }
      function st(ye, Pe) {
        Ve(ye) || D("memo: The first argument must be a component. Instead received: %s", ye === null ? "null" : typeof ye);
        var Qe = {
          $$typeof: e,
          type: ye,
          compare: Pe === void 0 ? null : Pe
        };
        {
          var Ye;
          Object.defineProperty(Qe, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return Ye;
            },
            set: function(lt) {
              Ye = lt, !ye.name && !ye.displayName && (ye.displayName = lt);
            }
          });
        }
        return Qe;
      }
      function ct() {
        var ye = c.current;
        return ye === null && D(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`), ye;
      }
      function Rt(ye) {
        var Pe = ct();
        if (ye._context !== void 0) {
          var Qe = ye._context;
          Qe.Consumer === ye ? D("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?") : Qe.Provider === ye && D("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
        }
        return Pe.useContext(ye);
      }
      function Lt(ye) {
        var Pe = ct();
        return Pe.useState(ye);
      }
      function Ge(ye, Pe, Qe) {
        var Ye = ct();
        return Ye.useReducer(ye, Pe, Qe);
      }
      function Ne(ye) {
        var Pe = ct();
        return Pe.useRef(ye);
      }
      function rt(ye, Pe) {
        var Qe = ct();
        return Qe.useEffect(ye, Pe);
      }
      function tt(ye, Pe) {
        var Qe = ct();
        return Qe.useInsertionEffect(ye, Pe);
      }
      function dt(ye, Pe) {
        var Qe = ct();
        return Qe.useLayoutEffect(ye, Pe);
      }
      function Ct(ye, Pe) {
        var Qe = ct();
        return Qe.useCallback(ye, Pe);
      }
      function bt(ye, Pe) {
        var Qe = ct();
        return Qe.useMemo(ye, Pe);
      }
      function ht(ye, Pe, Qe) {
        var Ye = ct();
        return Ye.useImperativeHandle(ye, Pe, Qe);
      }
      function vt(ye, Pe) {
        {
          var Qe = ct();
          return Qe.useDebugValue(ye, Pe);
        }
      }
      function _t() {
        var ye = ct();
        return ye.useTransition();
      }
      function Nt(ye) {
        var Pe = ct();
        return Pe.useDeferredValue(ye);
      }
      function Mt() {
        var ye = ct();
        return ye.useId();
      }
      function Et(ye, Pe, Qe) {
        var Ye = ct();
        return Ye.useSyncExternalStore(ye, Pe, Qe);
      }
      var Re = 0, We, it, et, At, It, Vt, Ut;
      function Wt() {
      }
      Wt.__reactDisabledLog = !0;
      function Kt() {
        {
          if (Re === 0) {
            We = console.log, it = console.info, et = console.warn, At = console.error, It = console.group, Vt = console.groupCollapsed, Ut = console.groupEnd;
            var ye = {
              configurable: !0,
              enumerable: !0,
              value: Wt,
              writable: !0
            };
            Object.defineProperties(console, {
              info: ye,
              log: ye,
              warn: ye,
              error: ye,
              group: ye,
              groupCollapsed: ye,
              groupEnd: ye
            });
          }
          Re++;
        }
      }
      function rn() {
        {
          if (Re--, Re === 0) {
            var ye = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: A({}, ye, {
                value: We
              }),
              info: A({}, ye, {
                value: it
              }),
              warn: A({}, ye, {
                value: et
              }),
              error: A({}, ye, {
                value: At
              }),
              group: A({}, ye, {
                value: It
              }),
              groupCollapsed: A({}, ye, {
                value: Vt
              }),
              groupEnd: A({}, ye, {
                value: Ut
              })
            });
          }
          Re < 0 && D("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var ln = B.ReactCurrentDispatcher, Cn;
      function fn(ye, Pe, Qe) {
        {
          if (Cn === void 0)
            try {
              throw Error();
            } catch (lt) {
              var Ye = lt.stack.trim().match(/\n( *(at )?)/);
              Cn = Ye && Ye[1] || "";
            }
          return `
` + Cn + ye;
        }
      }
      var Fn = !1, yn;
      {
        var Dn = typeof WeakMap == "function" ? WeakMap : Map;
        yn = new Dn();
      }
      function En(ye, Pe) {
        if (!ye || Fn)
          return "";
        {
          var Qe = yn.get(ye);
          if (Qe !== void 0)
            return Qe;
        }
        var Ye;
        Fn = !0;
        var lt = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var Bt;
        Bt = ln.current, ln.current = null, Kt();
        try {
          if (Pe) {
            var yt = function() {
              throw Error();
            };
            if (Object.defineProperty(yt.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(yt, []);
              } catch (on) {
                Ye = on;
              }
              Reflect.construct(ye, [], yt);
            } else {
              try {
                yt.call();
              } catch (on) {
                Ye = on;
              }
              ye.call(yt.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (on) {
              Ye = on;
            }
            ye();
          }
        } catch (on) {
          if (on && Ye && typeof on.stack == "string") {
            for (var $t = on.stack.split(`
`), Ht = Ye.stack.split(`
`), zt = $t.length - 1, Jt = Ht.length - 1; zt >= 1 && Jt >= 0 && $t[zt] !== Ht[Jt]; )
              Jt--;
            for (; zt >= 1 && Jt >= 0; zt--, Jt--)
              if ($t[zt] !== Ht[Jt]) {
                if (zt !== 1 || Jt !== 1)
                  do
                    if (zt--, Jt--, Jt < 0 || $t[zt] !== Ht[Jt]) {
                      var Qt = `
` + $t[zt].replace(" at new ", " at ");
                      return ye.displayName && Qt.includes("<anonymous>") && (Qt = Qt.replace("<anonymous>", ye.displayName)), typeof ye == "function" && yn.set(ye, Qt), Qt;
                    }
                  while (zt >= 1 && Jt >= 0);
                break;
              }
          }
        } finally {
          Fn = !1, ln.current = Bt, rn(), Error.prepareStackTrace = lt;
        }
        var nn = ye ? ye.displayName || ye.name : "", tn = nn ? fn(nn) : "";
        return typeof ye == "function" && yn.set(ye, tn), tn;
      }
      function Bn(ye, Pe, Qe) {
        return En(ye, !1);
      }
      function Ln(ye) {
        var Pe = ye.prototype;
        return !!(Pe && Pe.isReactComponent);
      }
      function vn(ye, Pe, Qe) {
        if (ye == null)
          return "";
        if (typeof ye == "function")
          return En(ye, Ln(ye));
        if (typeof ye == "string")
          return fn(ye);
        switch (ye) {
          case v:
            return fn("Suspense");
          case a:
            return fn("SuspenseList");
        }
        if (typeof ye == "object")
          switch (ye.$$typeof) {
            case i:
              return Bn(ye.render);
            case e:
              return vn(ye.type, Pe, Qe);
            case y: {
              var Ye = ye, lt = Ye._payload, Bt = Ye._init;
              try {
                return vn(Bt(lt), Pe, Qe);
              } catch {
              }
            }
          }
        return "";
      }
      var kn = {}, On = B.ReactDebugCurrentFrame;
      function mn(ye) {
        if (ye) {
          var Pe = ye._owner, Qe = vn(ye.type, ye._source, Pe ? Pe.type : null);
          On.setExtraStackFrame(Qe);
        } else
          On.setExtraStackFrame(null);
      }
      function hn(ye, Pe, Qe, Ye, lt) {
        {
          var Bt = Function.call.bind(re);
          for (var yt in ye)
            if (Bt(ye, yt)) {
              var $t = void 0;
              try {
                if (typeof ye[yt] != "function") {
                  var Ht = Error((Ye || "React class") + ": " + Qe + " type `" + yt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof ye[yt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw Ht.name = "Invariant Violation", Ht;
                }
                $t = ye[yt](Pe, yt, Ye, Qe, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (zt) {
                $t = zt;
              }
              $t && !($t instanceof Error) && (mn(lt), D("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Ye || "React class", Qe, yt, typeof $t), mn(null)), $t instanceof Error && !($t.message in kn) && (kn[$t.message] = !0, mn(lt), D("Failed %s type: %s", Qe, $t.message), mn(null));
            }
        }
      }
      function gn(ye) {
        if (ye) {
          var Pe = ye._owner, Qe = vn(ye.type, ye._source, Pe ? Pe.type : null);
          C(Qe);
        } else
          C(null);
      }
      var an;
      an = !1;
      function dn() {
        if (x.current) {
          var ye = te(x.current.type);
          if (ye)
            return `

Check the render method of \`` + ye + "`.";
        }
        return "";
      }
      function Tn(ye) {
        if (ye !== void 0) {
          var Pe = ye.fileName.replace(/^.*[\\\/]/, ""), Qe = ye.lineNumber;
          return `

Check your code at ` + Pe + ":" + Qe + ".";
        }
        return "";
      }
      function In(ye) {
        return ye != null ? Tn(ye.__source) : "";
      }
      var wn = {};
      function Nn(ye) {
        var Pe = dn();
        if (!Pe) {
          var Qe = typeof ye == "string" ? ye : ye.displayName || ye.name;
          Qe && (Pe = `

Check the top-level render call using <` + Qe + ">.");
        }
        return Pe;
      }
      function Pn(ye, Pe) {
        if (!(!ye._store || ye._store.validated || ye.key != null)) {
          ye._store.validated = !0;
          var Qe = Nn(Pe);
          if (!wn[Qe]) {
            wn[Qe] = !0;
            var Ye = "";
            ye && ye._owner && ye._owner !== x.current && (Ye = " It was passed a child from " + te(ye._owner.type) + "."), gn(ye), D('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Qe, Ye), gn(null);
          }
        }
      }
      function Rn(ye, Pe) {
        if (typeof ye == "object") {
          if (Y(ye))
            for (var Qe = 0; Qe < ye.length; Qe++) {
              var Ye = ye[Qe];
              De(Ye) && Pn(Ye, Pe);
            }
          else if (De(ye))
            ye._store && (ye._store.validated = !0);
          else if (ye) {
            var lt = d(ye);
            if (typeof lt == "function" && lt !== ye.entries)
              for (var Bt = lt.call(ye), yt; !(yt = Bt.next()).done; )
                De(yt.value) && Pn(yt.value, Pe);
          }
        }
      }
      function Un(ye) {
        {
          var Pe = ye.type;
          if (Pe == null || typeof Pe == "string")
            return;
          var Qe;
          if (typeof Pe == "function")
            Qe = Pe.propTypes;
          else if (typeof Pe == "object" && (Pe.$$typeof === i || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          Pe.$$typeof === e))
            Qe = Pe.propTypes;
          else
            return;
          if (Qe) {
            var Ye = te(Pe);
            hn(Qe, ye.props, "prop", Ye, ye);
          } else if (Pe.PropTypes !== void 0 && !an) {
            an = !0;
            var lt = te(Pe);
            D("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", lt || "Unknown");
          }
          typeof Pe.getDefaultProps == "function" && !Pe.getDefaultProps.isReactClassApproved && D("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function _n(ye) {
        {
          for (var Pe = Object.keys(ye.props), Qe = 0; Qe < Pe.length; Qe++) {
            var Ye = Pe[Qe];
            if (Ye !== "children" && Ye !== "key") {
              gn(ye), D("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Ye), gn(null);
              break;
            }
          }
          ye.ref !== null && (gn(ye), D("Invalid attribute `ref` supplied to `React.Fragment`."), gn(null));
        }
      }
      function An(ye, Pe, Qe) {
        var Ye = Ve(ye);
        if (!Ye) {
          var lt = "";
          (ye === void 0 || typeof ye == "object" && ye !== null && Object.keys(ye).length === 0) && (lt += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Bt = In(Pe);
          Bt ? lt += Bt : lt += dn();
          var yt;
          ye === null ? yt = "null" : Y(ye) ? yt = "array" : ye !== void 0 && ye.$$typeof === de ? (yt = "<" + (te(ye.type) || "Unknown") + " />", lt = " Did you accidentally export a JSX literal instead of a component?") : yt = typeof ye, D("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", yt, lt);
        }
        var $t = Fe.apply(this, arguments);
        if ($t == null)
          return $t;
        if (Ye)
          for (var Ht = 2; Ht < arguments.length; Ht++)
            Rn(arguments[Ht], ye);
        return ye === se ? _n($t) : Un($t), $t;
      }
      var Mn = !1;
      function xn(ye) {
        var Pe = An.bind(null, ye);
        return Pe.type = ye, Mn || (Mn = !0, R("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")), Object.defineProperty(Pe, "type", {
          enumerable: !1,
          get: function() {
            return R("Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", {
              value: ye
            }), ye;
          }
        }), Pe;
      }
      function jn(ye, Pe, Qe) {
        for (var Ye = Ae.apply(this, arguments), lt = 2; lt < arguments.length; lt++)
          Rn(arguments[lt], Ye.type);
        return Un(Ye), Ye;
      }
      function bn(ye, Pe) {
        var Qe = n.transition;
        n.transition = {};
        var Ye = n.transition;
        n.transition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          ye();
        } finally {
          if (n.transition = Qe, Qe === null && Ye._updatedFibers) {
            var lt = Ye._updatedFibers.size;
            lt > 10 && R("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), Ye._updatedFibers.clear();
          }
        }
      }
      var Xe = !1, I = null;
      function ce(ye) {
        if (I === null)
          try {
            var Pe = ("require" + Math.random()).slice(0, 7), Qe = Ee && Ee[Pe];
            I = Qe.call(Ee, "timers").setImmediate;
          } catch {
            I = function(lt) {
              Xe === !1 && (Xe = !0, typeof MessageChannel > "u" && D("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
              var Bt = new MessageChannel();
              Bt.port1.onmessage = lt, Bt.port2.postMessage(void 0);
            };
          }
        return I(ye);
      }
      var je = 0, Ke = !1;
      function ut(ye) {
        {
          var Pe = je;
          je++, o.current === null && (o.current = []);
          var Qe = o.isBatchingLegacy, Ye;
          try {
            if (o.isBatchingLegacy = !0, Ye = ye(), !Qe && o.didScheduleLegacyUpdate) {
              var lt = o.current;
              lt !== null && (o.didScheduleLegacyUpdate = !1, jt(lt));
            }
          } catch (nn) {
            throw Ot(Pe), nn;
          } finally {
            o.isBatchingLegacy = Qe;
          }
          if (Ye !== null && typeof Ye == "object" && typeof Ye.then == "function") {
            var Bt = Ye, yt = !1, $t = {
              then: function(nn, tn) {
                yt = !0, Bt.then(function(on) {
                  Ot(Pe), je === 0 ? Dt(on, nn, tn) : nn(on);
                }, function(on) {
                  Ot(Pe), tn(on);
                });
              }
            };
            return !Ke && typeof Promise < "u" && Promise.resolve().then(function() {
            }).then(function() {
              yt || (Ke = !0, D("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
            }), $t;
          } else {
            var Ht = Ye;
            if (Ot(Pe), je === 0) {
              var zt = o.current;
              zt !== null && (jt(zt), o.current = null);
              var Jt = {
                then: function(nn, tn) {
                  o.current === null ? (o.current = [], Dt(Ht, nn, tn)) : nn(Ht);
                }
              };
              return Jt;
            } else {
              var Qt = {
                then: function(nn, tn) {
                  nn(Ht);
                }
              };
              return Qt;
            }
          }
        }
      }
      function Ot(ye) {
        ye !== je - 1 && D("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "), je = ye;
      }
      function Dt(ye, Pe, Qe) {
        {
          var Ye = o.current;
          if (Ye !== null)
            try {
              jt(Ye), ce(function() {
                Ye.length === 0 ? (o.current = null, Pe(ye)) : Dt(ye, Pe, Qe);
              });
            } catch (lt) {
              Qe(lt);
            }
          else
            Pe(ye);
        }
      }
      var Pt = !1;
      function jt(ye) {
        if (!Pt) {
          Pt = !0;
          var Pe = 0;
          try {
            for (; Pe < ye.length; Pe++) {
              var Qe = ye[Pe];
              do
                Qe = Qe(!0);
              while (Qe !== null);
            }
            ye.length = 0;
          } catch (Ye) {
            throw ye = ye.slice(Pe + 1), Ye;
          } finally {
            Pt = !1;
          }
        }
      }
      var Xt = An, Zt = jn, Yt = xn, en = {
        map: Ue,
        forEach: _e,
        count: Oe,
        toArray: at,
        only: Je
      };
      ge.Children = en, ge.Component = T, ge.Fragment = se, ge.Profiler = u, ge.PureComponent = W, ge.StrictMode = Q, ge.Suspense = v, ge.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = B, ge.cloneElement = Zt, ge.createContext = ot, ge.createElement = Xt, ge.createFactory = Yt, ge.createRef = V, ge.forwardRef = xt, ge.isValidElement = De, ge.lazy = St, ge.memo = st, ge.startTransition = bn, ge.unstable_act = ut, ge.useCallback = Ct, ge.useContext = Rt, ge.useDebugValue = vt, ge.useDeferredValue = Nt, ge.useEffect = rt, ge.useId = Mt, ge.useImperativeHandle = ht, ge.useInsertionEffect = tt, ge.useLayoutEffect = dt, ge.useMemo = bt, ge.useReducer = Ge, ge.useRef = Ne, ge.useState = Lt, ge.useSyncExternalStore = Et, ge.useTransition = _t, ge.version = le, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(react_development, react_developmentExports)), react_developmentExports;
}
var hasRequiredReact;
function requireReact() {
  return hasRequiredReact || (hasRequiredReact = 1, function(Ee) {
    process.env.NODE_ENV === "production" ? Ee.exports = requireReact_production_min() : Ee.exports = requireReact_development();
  }(react)), reactExports;
}
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min)
    return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var Ee = requireReact(), ge = Symbol.for("react.element"), le = Symbol.for("react.fragment"), de = Object.prototype.hasOwnProperty, oe = Ee.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, se = { key: !0, ref: !0, __self: !0, __source: !0 };
  function Q(u, P, t) {
    var i, v = {}, a = null, e = null;
    t !== void 0 && (a = "" + t), P.key !== void 0 && (a = "" + P.key), P.ref !== void 0 && (e = P.ref);
    for (i in P)
      de.call(P, i) && !se.hasOwnProperty(i) && (v[i] = P[i]);
    if (u && u.defaultProps)
      for (i in P = u.defaultProps, P)
        v[i] === void 0 && (v[i] = P[i]);
    return { $$typeof: ge, type: u, key: a, ref: e, props: v, _owner: oe.current };
  }
  return reactJsxRuntime_production_min.Fragment = le, reactJsxRuntime_production_min.jsx = Q, reactJsxRuntime_production_min.jsxs = Q, reactJsxRuntime_production_min;
}
var reactJsxRuntime_development = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
  return hasRequiredReactJsxRuntime_development || (hasRequiredReactJsxRuntime_development = 1, process.env.NODE_ENV !== "production" && function() {
    var Ee = requireReact(), ge = Symbol.for("react.element"), le = Symbol.for("react.portal"), de = Symbol.for("react.fragment"), oe = Symbol.for("react.strict_mode"), se = Symbol.for("react.profiler"), Q = Symbol.for("react.provider"), u = Symbol.for("react.context"), P = Symbol.for("react.forward_ref"), t = Symbol.for("react.suspense"), i = Symbol.for("react.suspense_list"), v = Symbol.for("react.memo"), a = Symbol.for("react.lazy"), e = Symbol.for("react.offscreen"), y = Symbol.iterator, r = "@@iterator";
    function h(Ie) {
      if (Ie === null || typeof Ie != "object")
        return null;
      var Ve = y && Ie[y] || Ie[r];
      return typeof Ve == "function" ? Ve : null;
    }
    var g = Ee.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function d(Ie) {
      {
        for (var Ve = arguments.length, st = new Array(Ve > 1 ? Ve - 1 : 0), ct = 1; ct < Ve; ct++)
          st[ct - 1] = arguments[ct];
        c("error", Ie, st);
      }
    }
    function c(Ie, Ve, st) {
      {
        var ct = g.ReactDebugCurrentFrame, Rt = ct.getStackAddendum();
        Rt !== "" && (Ve += "%s", st = st.concat([Rt]));
        var Lt = st.map(function(Ge) {
          return String(Ge);
        });
        Lt.unshift("Warning: " + Ve), Function.prototype.apply.call(console[Ie], console, Lt);
      }
    }
    var n = !1, o = !1, x = !1, f = !1, m = !1, C;
    C = Symbol.for("react.module.reference");
    function p(Ie) {
      return !!(typeof Ie == "string" || typeof Ie == "function" || Ie === de || Ie === se || m || Ie === oe || Ie === t || Ie === i || f || Ie === e || n || o || x || typeof Ie == "object" && Ie !== null && (Ie.$$typeof === a || Ie.$$typeof === v || Ie.$$typeof === Q || Ie.$$typeof === u || Ie.$$typeof === P || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      Ie.$$typeof === C || Ie.getModuleId !== void 0));
    }
    function w(Ie, Ve, st) {
      var ct = Ie.displayName;
      if (ct)
        return ct;
      var Rt = Ve.displayName || Ve.name || "";
      return Rt !== "" ? st + "(" + Rt + ")" : st;
    }
    function X(Ie) {
      return Ie.displayName || "Context";
    }
    function M(Ie) {
      if (Ie == null)
        return null;
      if (typeof Ie.tag == "number" && d("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof Ie == "function")
        return Ie.displayName || Ie.name || null;
      if (typeof Ie == "string")
        return Ie;
      switch (Ie) {
        case de:
          return "Fragment";
        case le:
          return "Portal";
        case se:
          return "Profiler";
        case oe:
          return "StrictMode";
        case t:
          return "Suspense";
        case i:
          return "SuspenseList";
      }
      if (typeof Ie == "object")
        switch (Ie.$$typeof) {
          case u:
            var Ve = Ie;
            return X(Ve) + ".Consumer";
          case Q:
            var st = Ie;
            return X(st._context) + ".Provider";
          case P:
            return w(Ie, Ie.render, "ForwardRef");
          case v:
            var ct = Ie.displayName || null;
            return ct !== null ? ct : M(Ie.type) || "Memo";
          case a: {
            var Rt = Ie, Lt = Rt._payload, Ge = Rt._init;
            try {
              return M(Ge(Lt));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var j = Object.assign, B = 0, R, D, b, l, _, S, A;
    function F() {
    }
    F.__reactDisabledLog = !0;
    function T() {
      {
        if (B === 0) {
          R = console.log, D = console.info, b = console.warn, l = console.error, _ = console.group, S = console.groupCollapsed, A = console.groupEnd;
          var Ie = {
            configurable: !0,
            enumerable: !0,
            value: F,
            writable: !0
          };
          Object.defineProperties(console, {
            info: Ie,
            log: Ie,
            warn: Ie,
            error: Ie,
            group: Ie,
            groupCollapsed: Ie,
            groupEnd: Ie
          });
        }
        B++;
      }
    }
    function O() {
      {
        if (B--, B === 0) {
          var Ie = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: j({}, Ie, {
              value: R
            }),
            info: j({}, Ie, {
              value: D
            }),
            warn: j({}, Ie, {
              value: b
            }),
            error: j({}, Ie, {
              value: l
            }),
            group: j({}, Ie, {
              value: _
            }),
            groupCollapsed: j({}, Ie, {
              value: S
            }),
            groupEnd: j({}, Ie, {
              value: A
            })
          });
        }
        B < 0 && d("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var U = g.ReactCurrentDispatcher, G;
    function K(Ie, Ve, st) {
      {
        if (G === void 0)
          try {
            throw Error();
          } catch (Rt) {
            var ct = Rt.stack.trim().match(/\n( *(at )?)/);
            G = ct && ct[1] || "";
          }
        return `
` + G + Ie;
      }
    }
    var W = !1, z;
    {
      var V = typeof WeakMap == "function" ? WeakMap : Map;
      z = new V();
    }
    function L(Ie, Ve) {
      if (!Ie || W)
        return "";
      {
        var st = z.get(Ie);
        if (st !== void 0)
          return st;
      }
      var ct;
      W = !0;
      var Rt = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Lt;
      Lt = U.current, U.current = null, T();
      try {
        if (Ve) {
          var Ge = function() {
            throw Error();
          };
          if (Object.defineProperty(Ge.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Ge, []);
            } catch (vt) {
              ct = vt;
            }
            Reflect.construct(Ie, [], Ge);
          } else {
            try {
              Ge.call();
            } catch (vt) {
              ct = vt;
            }
            Ie.call(Ge.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (vt) {
            ct = vt;
          }
          Ie();
        }
      } catch (vt) {
        if (vt && ct && typeof vt.stack == "string") {
          for (var Ne = vt.stack.split(`
`), rt = ct.stack.split(`
`), tt = Ne.length - 1, dt = rt.length - 1; tt >= 1 && dt >= 0 && Ne[tt] !== rt[dt]; )
            dt--;
          for (; tt >= 1 && dt >= 0; tt--, dt--)
            if (Ne[tt] !== rt[dt]) {
              if (tt !== 1 || dt !== 1)
                do
                  if (tt--, dt--, dt < 0 || Ne[tt] !== rt[dt]) {
                    var Ct = `
` + Ne[tt].replace(" at new ", " at ");
                    return Ie.displayName && Ct.includes("<anonymous>") && (Ct = Ct.replace("<anonymous>", Ie.displayName)), typeof Ie == "function" && z.set(Ie, Ct), Ct;
                  }
                while (tt >= 1 && dt >= 0);
              break;
            }
        }
      } finally {
        W = !1, U.current = Lt, O(), Error.prepareStackTrace = Rt;
      }
      var bt = Ie ? Ie.displayName || Ie.name : "", ht = bt ? K(bt) : "";
      return typeof Ie == "function" && z.set(Ie, ht), ht;
    }
    function Y(Ie, Ve, st) {
      return L(Ie, !1);
    }
    function J(Ie) {
      var Ve = Ie.prototype;
      return !!(Ve && Ve.isReactComponent);
    }
    function ie(Ie, Ve, st) {
      if (Ie == null)
        return "";
      if (typeof Ie == "function")
        return L(Ie, J(Ie));
      if (typeof Ie == "string")
        return K(Ie);
      switch (Ie) {
        case t:
          return K("Suspense");
        case i:
          return K("SuspenseList");
      }
      if (typeof Ie == "object")
        switch (Ie.$$typeof) {
          case P:
            return Y(Ie.render);
          case v:
            return ie(Ie.type, Ve, st);
          case a: {
            var ct = Ie, Rt = ct._payload, Lt = ct._init;
            try {
              return ie(Lt(Rt), Ve, st);
            } catch {
            }
          }
        }
      return "";
    }
    var q = Object.prototype.hasOwnProperty, N = {}, Z = g.ReactDebugCurrentFrame;
    function E(Ie) {
      if (Ie) {
        var Ve = Ie._owner, st = ie(Ie.type, Ie._source, Ve ? Ve.type : null);
        Z.setExtraStackFrame(st);
      } else
        Z.setExtraStackFrame(null);
    }
    function te(Ie, Ve, st, ct, Rt) {
      {
        var Lt = Function.call.bind(q);
        for (var Ge in Ie)
          if (Lt(Ie, Ge)) {
            var Ne = void 0;
            try {
              if (typeof Ie[Ge] != "function") {
                var rt = Error((ct || "React class") + ": " + st + " type `" + Ge + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Ie[Ge] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw rt.name = "Invariant Violation", rt;
              }
              Ne = Ie[Ge](Ve, Ge, ct, st, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (tt) {
              Ne = tt;
            }
            Ne && !(Ne instanceof Error) && (E(Rt), d("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ct || "React class", st, Ge, typeof Ne), E(null)), Ne instanceof Error && !(Ne.message in N) && (N[Ne.message] = !0, E(Rt), d("Failed %s type: %s", st, Ne.message), E(null));
          }
      }
    }
    var re = Array.isArray;
    function ee(Ie) {
      return re(Ie);
    }
    function $(Ie) {
      {
        var Ve = typeof Symbol == "function" && Symbol.toStringTag, st = Ve && Ie[Symbol.toStringTag] || Ie.constructor.name || "Object";
        return st;
      }
    }
    function k(Ie) {
      try {
        return H(Ie), !1;
      } catch {
        return !0;
      }
    }
    function H(Ie) {
      return "" + Ie;
    }
    function ne(Ie) {
      if (k(Ie))
        return d("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", $(Ie)), H(Ie);
    }
    var ae = g.ReactCurrentOwner, he = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, ue, fe, me;
    me = {};
    function Fe(Ie) {
      if (q.call(Ie, "ref")) {
        var Ve = Object.getOwnPropertyDescriptor(Ie, "ref").get;
        if (Ve && Ve.isReactWarning)
          return !1;
      }
      return Ie.ref !== void 0;
    }
    function we(Ie) {
      if (q.call(Ie, "key")) {
        var Ve = Object.getOwnPropertyDescriptor(Ie, "key").get;
        if (Ve && Ve.isReactWarning)
          return !1;
      }
      return Ie.key !== void 0;
    }
    function Ae(Ie, Ve) {
      if (typeof Ie.ref == "string" && ae.current && Ve && ae.current.stateNode !== Ve) {
        var st = M(ae.current.type);
        me[st] || (d('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', M(ae.current.type), Ie.ref), me[st] = !0);
      }
    }
    function De(Ie, Ve) {
      {
        var st = function() {
          ue || (ue = !0, d("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ve));
        };
        st.isReactWarning = !0, Object.defineProperty(Ie, "key", {
          get: st,
          configurable: !0
        });
      }
    }
    function xe(Ie, Ve) {
      {
        var st = function() {
          fe || (fe = !0, d("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ve));
        };
        st.isReactWarning = !0, Object.defineProperty(Ie, "ref", {
          get: st,
          configurable: !0
        });
      }
    }
    var Te = function(Ie, Ve, st, ct, Rt, Lt, Ge) {
      var Ne = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: ge,
        // Built-in properties that belong on the element
        type: Ie,
        key: Ve,
        ref: st,
        props: Ge,
        // Record the component responsible for creating this element.
        _owner: Lt
      };
      return Ne._store = {}, Object.defineProperty(Ne._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Ne, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ct
      }), Object.defineProperty(Ne, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Rt
      }), Object.freeze && (Object.freeze(Ne.props), Object.freeze(Ne)), Ne;
    };
    function ve(Ie, Ve, st, ct, Rt) {
      {
        var Lt, Ge = {}, Ne = null, rt = null;
        st !== void 0 && (ne(st), Ne = "" + st), we(Ve) && (ne(Ve.key), Ne = "" + Ve.key), Fe(Ve) && (rt = Ve.ref, Ae(Ve, Rt));
        for (Lt in Ve)
          q.call(Ve, Lt) && !he.hasOwnProperty(Lt) && (Ge[Lt] = Ve[Lt]);
        if (Ie && Ie.defaultProps) {
          var tt = Ie.defaultProps;
          for (Lt in tt)
            Ge[Lt] === void 0 && (Ge[Lt] = tt[Lt]);
        }
        if (Ne || rt) {
          var dt = typeof Ie == "function" ? Ie.displayName || Ie.name || "Unknown" : Ie;
          Ne && De(Ge, dt), rt && xe(Ge, dt);
        }
        return Te(Ie, Ne, rt, Rt, ct, ae.current, Ge);
      }
    }
    var Se = g.ReactCurrentOwner, be = g.ReactDebugCurrentFrame;
    function Le(Ie) {
      if (Ie) {
        var Ve = Ie._owner, st = ie(Ie.type, Ie._source, Ve ? Ve.type : null);
        be.setExtraStackFrame(st);
      } else
        be.setExtraStackFrame(null);
    }
    var ze;
    ze = !1;
    function nt(Ie) {
      return typeof Ie == "object" && Ie !== null && Ie.$$typeof === ge;
    }
    function Ue() {
      {
        if (Se.current) {
          var Ie = M(Se.current.type);
          if (Ie)
            return `

Check the render method of \`` + Ie + "`.";
        }
        return "";
      }
    }
    function Oe(Ie) {
      {
        if (Ie !== void 0) {
          var Ve = Ie.fileName.replace(/^.*[\\\/]/, ""), st = Ie.lineNumber;
          return `

Check your code at ` + Ve + ":" + st + ".";
        }
        return "";
      }
    }
    var _e = {};
    function at(Ie) {
      {
        var Ve = Ue();
        if (!Ve) {
          var st = typeof Ie == "string" ? Ie : Ie.displayName || Ie.name;
          st && (Ve = `

Check the top-level render call using <` + st + ">.");
        }
        return Ve;
      }
    }
    function Je(Ie, Ve) {
      {
        if (!Ie._store || Ie._store.validated || Ie.key != null)
          return;
        Ie._store.validated = !0;
        var st = at(Ve);
        if (_e[st])
          return;
        _e[st] = !0;
        var ct = "";
        Ie && Ie._owner && Ie._owner !== Se.current && (ct = " It was passed a child from " + M(Ie._owner.type) + "."), Le(Ie), d('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', st, ct), Le(null);
      }
    }
    function ot(Ie, Ve) {
      {
        if (typeof Ie != "object")
          return;
        if (ee(Ie))
          for (var st = 0; st < Ie.length; st++) {
            var ct = Ie[st];
            nt(ct) && Je(ct, Ve);
          }
        else if (nt(Ie))
          Ie._store && (Ie._store.validated = !0);
        else if (Ie) {
          var Rt = h(Ie);
          if (typeof Rt == "function" && Rt !== Ie.entries)
            for (var Lt = Rt.call(Ie), Ge; !(Ge = Lt.next()).done; )
              nt(Ge.value) && Je(Ge.value, Ve);
        }
      }
    }
    function mt(Ie) {
      {
        var Ve = Ie.type;
        if (Ve == null || typeof Ve == "string")
          return;
        var st;
        if (typeof Ve == "function")
          st = Ve.propTypes;
        else if (typeof Ve == "object" && (Ve.$$typeof === P || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        Ve.$$typeof === v))
          st = Ve.propTypes;
        else
          return;
        if (st) {
          var ct = M(Ve);
          te(st, Ie.props, "prop", ct, Ie);
        } else if (Ve.PropTypes !== void 0 && !ze) {
          ze = !0;
          var Rt = M(Ve);
          d("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Rt || "Unknown");
        }
        typeof Ve.getDefaultProps == "function" && !Ve.getDefaultProps.isReactClassApproved && d("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Ze(Ie) {
      {
        for (var Ve = Object.keys(Ie.props), st = 0; st < Ve.length; st++) {
          var ct = Ve[st];
          if (ct !== "children" && ct !== "key") {
            Le(Ie), d("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ct), Le(null);
            break;
          }
        }
        Ie.ref !== null && (Le(Ie), d("Invalid attribute `ref` supplied to `React.Fragment`."), Le(null));
      }
    }
    function pt(Ie, Ve, st, ct, Rt, Lt) {
      {
        var Ge = p(Ie);
        if (!Ge) {
          var Ne = "";
          (Ie === void 0 || typeof Ie == "object" && Ie !== null && Object.keys(Ie).length === 0) && (Ne += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var rt = Oe(Rt);
          rt ? Ne += rt : Ne += Ue();
          var tt;
          Ie === null ? tt = "null" : ee(Ie) ? tt = "array" : Ie !== void 0 && Ie.$$typeof === ge ? (tt = "<" + (M(Ie.type) || "Unknown") + " />", Ne = " Did you accidentally export a JSX literal instead of a component?") : tt = typeof Ie, d("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", tt, Ne);
        }
        var dt = ve(Ie, Ve, st, Rt, Lt);
        if (dt == null)
          return dt;
        if (Ge) {
          var Ct = Ve.children;
          if (Ct !== void 0)
            if (ct)
              if (ee(Ct)) {
                for (var bt = 0; bt < Ct.length; bt++)
                  ot(Ct[bt], Ie);
                Object.freeze && Object.freeze(Ct);
              } else
                d("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              ot(Ct, Ie);
        }
        return Ie === de ? Ze(dt) : mt(dt), dt;
      }
    }
    function Ft(Ie, Ve, st) {
      return pt(Ie, Ve, st, !0);
    }
    function $e(Ie, Ve, st) {
      return pt(Ie, Ve, st, !1);
    }
    var St = $e, xt = Ft;
    reactJsxRuntime_development.Fragment = de, reactJsxRuntime_development.jsx = St, reactJsxRuntime_development.jsxs = xt;
  }()), reactJsxRuntime_development;
}
(function(Ee) {
  process.env.NODE_ENV === "production" ? Ee.exports = requireReactJsxRuntime_production_min() : Ee.exports = requireReactJsxRuntime_development();
})(jsxRuntime);
const wrapper$4 = "_wrapper_1658j_1", image = "_image_1658j_6", thumbnail$2 = "_thumbnail_1658j_10", s$4 = {
  wrapper: wrapper$4,
  image,
  thumbnail: thumbnail$2
};
requireReact();
function commonjsRequire(Ee) {
  throw new Error('Could not dynamically require "' + Ee + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var pdfExports = {}, pdf = {
  get exports() {
    return pdfExports;
  },
  set exports(Ee) {
    pdfExports = Ee;
  }
};
const __viteBrowserExternal = {}, __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" })), require$$5 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
(function(module, exports) {
  (function(ge, le) {
    module.exports = le();
  })(globalThis, () => (
    /******/
    (() => {
      var __webpack_modules__ = [
        ,
        /* 1 */
        /***/
        (Ee, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.VerbosityLevel = ge.Util = ge.UnknownErrorException = ge.UnexpectedResponseException = ge.UNSUPPORTED_FEATURES = ge.TextRenderingMode = ge.StreamType = ge.RenderingIntentFlag = ge.PermissionFlag = ge.PasswordResponses = ge.PasswordException = ge.PageActionEventType = ge.OPS = ge.MissingPDFException = ge.LINE_FACTOR = ge.LINE_DESCENT_FACTOR = ge.InvalidPDFException = ge.ImageKind = ge.IDENTITY_MATRIX = ge.FormatError = ge.FontType = ge.FeatureTest = ge.FONT_IDENTITY_MATRIX = ge.DocumentActionEventType = ge.CMapCompressionType = ge.BaseException = ge.AnnotationType = ge.AnnotationStateModelType = ge.AnnotationReviewState = ge.AnnotationReplyType = ge.AnnotationMode = ge.AnnotationMarkedState = ge.AnnotationFlag = ge.AnnotationFieldFlag = ge.AnnotationEditorType = ge.AnnotationEditorPrefix = ge.AnnotationEditorParamsType = ge.AnnotationBorderStyleType = ge.AnnotationActionEventType = ge.AbortException = void 0, ge.arrayByteLength = N, ge.arraysToBytes = Z, ge.assert = F, ge.bytesToString = ie, ge.createPromiseCapability = Te, ge.createValidAbsoluteUrl = O, ge.escapeString = ue, ge.getModificationDate = xe, ge.getVerbosityLevel = l, ge.info = _, ge.isArrayBuffer = Ae, ge.isArrayEqual = De, ge.isAscii = fe, ge.objectFromMap = re, ge.objectSize = te, ge.setVerbosityLevel = b, ge.shadow = U, ge.string32 = E, ge.stringToBytes = q, ge.stringToPDFString = he, ge.stringToUTF16BEString = me, ge.stringToUTF8String = Fe, ge.unreachable = A, ge.utf8StringToString = we, ge.warn = S, le(2);
          const de = [1, 0, 0, 1, 0, 0];
          ge.IDENTITY_MATRIX = de;
          const oe = [1e-3, 0, 0, 1e-3, 0, 0];
          ge.FONT_IDENTITY_MATRIX = oe;
          const se = 1.35;
          ge.LINE_FACTOR = se;
          const Q = 0.35;
          ge.LINE_DESCENT_FACTOR = Q;
          const u = {
            ANY: 1,
            DISPLAY: 2,
            PRINT: 4,
            ANNOTATIONS_FORMS: 16,
            ANNOTATIONS_STORAGE: 32,
            ANNOTATIONS_DISABLE: 64,
            OPLIST: 256
          };
          ge.RenderingIntentFlag = u;
          const P = {
            DISABLE: 0,
            ENABLE: 1,
            ENABLE_FORMS: 2,
            ENABLE_STORAGE: 3
          };
          ge.AnnotationMode = P;
          const t = "pdfjs_internal_editor_";
          ge.AnnotationEditorPrefix = t;
          const i = {
            DISABLE: -1,
            NONE: 0,
            FREETEXT: 3,
            INK: 15
          };
          ge.AnnotationEditorType = i;
          const v = {
            FREETEXT_SIZE: 1,
            FREETEXT_COLOR: 2,
            FREETEXT_OPACITY: 3,
            INK_COLOR: 11,
            INK_THICKNESS: 12,
            INK_OPACITY: 13
          };
          ge.AnnotationEditorParamsType = v;
          const a = {
            PRINT: 4,
            MODIFY_CONTENTS: 8,
            COPY: 16,
            MODIFY_ANNOTATIONS: 32,
            FILL_INTERACTIVE_FORMS: 256,
            COPY_FOR_ACCESSIBILITY: 512,
            ASSEMBLE: 1024,
            PRINT_HIGH_QUALITY: 2048
          };
          ge.PermissionFlag = a;
          const e = {
            FILL: 0,
            STROKE: 1,
            FILL_STROKE: 2,
            INVISIBLE: 3,
            FILL_ADD_TO_PATH: 4,
            STROKE_ADD_TO_PATH: 5,
            FILL_STROKE_ADD_TO_PATH: 6,
            ADD_TO_PATH: 7,
            FILL_STROKE_MASK: 3,
            ADD_TO_PATH_FLAG: 4
          };
          ge.TextRenderingMode = e;
          const y = {
            GRAYSCALE_1BPP: 1,
            RGB_24BPP: 2,
            RGBA_32BPP: 3
          };
          ge.ImageKind = y;
          const r = {
            TEXT: 1,
            LINK: 2,
            FREETEXT: 3,
            LINE: 4,
            SQUARE: 5,
            CIRCLE: 6,
            POLYGON: 7,
            POLYLINE: 8,
            HIGHLIGHT: 9,
            UNDERLINE: 10,
            SQUIGGLY: 11,
            STRIKEOUT: 12,
            STAMP: 13,
            CARET: 14,
            INK: 15,
            POPUP: 16,
            FILEATTACHMENT: 17,
            SOUND: 18,
            MOVIE: 19,
            WIDGET: 20,
            SCREEN: 21,
            PRINTERMARK: 22,
            TRAPNET: 23,
            WATERMARK: 24,
            THREED: 25,
            REDACT: 26
          };
          ge.AnnotationType = r;
          const h = {
            MARKED: "Marked",
            REVIEW: "Review"
          };
          ge.AnnotationStateModelType = h;
          const g = {
            MARKED: "Marked",
            UNMARKED: "Unmarked"
          };
          ge.AnnotationMarkedState = g;
          const d = {
            ACCEPTED: "Accepted",
            REJECTED: "Rejected",
            CANCELLED: "Cancelled",
            COMPLETED: "Completed",
            NONE: "None"
          };
          ge.AnnotationReviewState = d;
          const c = {
            GROUP: "Group",
            REPLY: "R"
          };
          ge.AnnotationReplyType = c;
          const n = {
            INVISIBLE: 1,
            HIDDEN: 2,
            PRINT: 4,
            NOZOOM: 8,
            NOROTATE: 16,
            NOVIEW: 32,
            READONLY: 64,
            LOCKED: 128,
            TOGGLENOVIEW: 256,
            LOCKEDCONTENTS: 512
          };
          ge.AnnotationFlag = n;
          const o = {
            READONLY: 1,
            REQUIRED: 2,
            NOEXPORT: 4,
            MULTILINE: 4096,
            PASSWORD: 8192,
            NOTOGGLETOOFF: 16384,
            RADIO: 32768,
            PUSHBUTTON: 65536,
            COMBO: 131072,
            EDIT: 262144,
            SORT: 524288,
            FILESELECT: 1048576,
            MULTISELECT: 2097152,
            DONOTSPELLCHECK: 4194304,
            DONOTSCROLL: 8388608,
            COMB: 16777216,
            RICHTEXT: 33554432,
            RADIOSINUNISON: 33554432,
            COMMITONSELCHANGE: 67108864
          };
          ge.AnnotationFieldFlag = o;
          const x = {
            SOLID: 1,
            DASHED: 2,
            BEVELED: 3,
            INSET: 4,
            UNDERLINE: 5
          };
          ge.AnnotationBorderStyleType = x;
          const f = {
            E: "Mouse Enter",
            X: "Mouse Exit",
            D: "Mouse Down",
            U: "Mouse Up",
            Fo: "Focus",
            Bl: "Blur",
            PO: "PageOpen",
            PC: "PageClose",
            PV: "PageVisible",
            PI: "PageInvisible",
            K: "Keystroke",
            F: "Format",
            V: "Validate",
            C: "Calculate"
          };
          ge.AnnotationActionEventType = f;
          const m = {
            WC: "WillClose",
            WS: "WillSave",
            DS: "DidSave",
            WP: "WillPrint",
            DP: "DidPrint"
          };
          ge.DocumentActionEventType = m;
          const C = {
            O: "PageOpen",
            C: "PageClose"
          };
          ge.PageActionEventType = C;
          const p = {
            UNKNOWN: "UNKNOWN",
            FLATE: "FLATE",
            LZW: "LZW",
            DCT: "DCT",
            JPX: "JPX",
            JBIG: "JBIG",
            A85: "A85",
            AHX: "AHX",
            CCF: "CCF",
            RLX: "RLX"
          };
          ge.StreamType = p;
          const w = {
            UNKNOWN: "UNKNOWN",
            TYPE1: "TYPE1",
            TYPE1STANDARD: "TYPE1STANDARD",
            TYPE1C: "TYPE1C",
            CIDFONTTYPE0: "CIDFONTTYPE0",
            CIDFONTTYPE0C: "CIDFONTTYPE0C",
            TRUETYPE: "TRUETYPE",
            CIDFONTTYPE2: "CIDFONTTYPE2",
            TYPE3: "TYPE3",
            OPENTYPE: "OPENTYPE",
            TYPE0: "TYPE0",
            MMTYPE1: "MMTYPE1"
          };
          ge.FontType = w;
          const X = {
            ERRORS: 0,
            WARNINGS: 1,
            INFOS: 5
          };
          ge.VerbosityLevel = X;
          const M = {
            NONE: 0,
            BINARY: 1,
            STREAM: 2
          };
          ge.CMapCompressionType = M;
          const j = {
            dependency: 1,
            setLineWidth: 2,
            setLineCap: 3,
            setLineJoin: 4,
            setMiterLimit: 5,
            setDash: 6,
            setRenderingIntent: 7,
            setFlatness: 8,
            setGState: 9,
            save: 10,
            restore: 11,
            transform: 12,
            moveTo: 13,
            lineTo: 14,
            curveTo: 15,
            curveTo2: 16,
            curveTo3: 17,
            closePath: 18,
            rectangle: 19,
            stroke: 20,
            closeStroke: 21,
            fill: 22,
            eoFill: 23,
            fillStroke: 24,
            eoFillStroke: 25,
            closeFillStroke: 26,
            closeEOFillStroke: 27,
            endPath: 28,
            clip: 29,
            eoClip: 30,
            beginText: 31,
            endText: 32,
            setCharSpacing: 33,
            setWordSpacing: 34,
            setHScale: 35,
            setLeading: 36,
            setFont: 37,
            setTextRenderingMode: 38,
            setTextRise: 39,
            moveText: 40,
            setLeadingMoveText: 41,
            setTextMatrix: 42,
            nextLine: 43,
            showText: 44,
            showSpacedText: 45,
            nextLineShowText: 46,
            nextLineSetSpacingShowText: 47,
            setCharWidth: 48,
            setCharWidthAndBounds: 49,
            setStrokeColorSpace: 50,
            setFillColorSpace: 51,
            setStrokeColor: 52,
            setStrokeColorN: 53,
            setFillColor: 54,
            setFillColorN: 55,
            setStrokeGray: 56,
            setFillGray: 57,
            setStrokeRGBColor: 58,
            setFillRGBColor: 59,
            setStrokeCMYKColor: 60,
            setFillCMYKColor: 61,
            shadingFill: 62,
            beginInlineImage: 63,
            beginImageData: 64,
            endInlineImage: 65,
            paintXObject: 66,
            markPoint: 67,
            markPointProps: 68,
            beginMarkedContent: 69,
            beginMarkedContentProps: 70,
            endMarkedContent: 71,
            beginCompat: 72,
            endCompat: 73,
            paintFormXObjectBegin: 74,
            paintFormXObjectEnd: 75,
            beginGroup: 76,
            endGroup: 77,
            beginAnnotations: 78,
            endAnnotations: 79,
            beginAnnotation: 80,
            endAnnotation: 81,
            paintJpegXObject: 82,
            paintImageMaskXObject: 83,
            paintImageMaskXObjectGroup: 84,
            paintImageXObject: 85,
            paintInlineImageXObject: 86,
            paintInlineImageXObjectGroup: 87,
            paintImageXObjectRepeat: 88,
            paintImageMaskXObjectRepeat: 89,
            paintSolidColorImageMask: 90,
            constructPath: 91
          };
          ge.OPS = j;
          const B = {
            unknown: "unknown",
            forms: "forms",
            javaScript: "javaScript",
            signatures: "signatures",
            smask: "smask",
            shadingPattern: "shadingPattern",
            font: "font",
            errorTilingPattern: "errorTilingPattern",
            errorExtGState: "errorExtGState",
            errorXObject: "errorXObject",
            errorFontLoadType3: "errorFontLoadType3",
            errorFontState: "errorFontState",
            errorFontMissing: "errorFontMissing",
            errorFontTranslate: "errorFontTranslate",
            errorColorSpace: "errorColorSpace",
            errorOperatorList: "errorOperatorList",
            errorFontToUnicode: "errorFontToUnicode",
            errorFontLoadNative: "errorFontLoadNative",
            errorFontBuildPath: "errorFontBuildPath",
            errorFontGetPath: "errorFontGetPath",
            errorMarkedContent: "errorMarkedContent",
            errorContentSubStream: "errorContentSubStream"
          };
          ge.UNSUPPORTED_FEATURES = B;
          const R = {
            NEED_PASSWORD: 1,
            INCORRECT_PASSWORD: 2
          };
          ge.PasswordResponses = R;
          let D = X.WARNINGS;
          function b(ve) {
            Number.isInteger(ve) && (D = ve);
          }
          function l() {
            return D;
          }
          function _(ve) {
            D >= X.INFOS && console.log(`Info: ${ve}`);
          }
          function S(ve) {
            D >= X.WARNINGS && console.log(`Warning: ${ve}`);
          }
          function A(ve) {
            throw new Error(ve);
          }
          function F(ve, Se) {
            ve || A(Se);
          }
          function T(ve) {
            if (!ve)
              return !1;
            switch (ve.protocol) {
              case "http:":
              case "https:":
              case "ftp:":
              case "mailto:":
              case "tel:":
                return !0;
              default:
                return !1;
            }
          }
          function O(ve, Se = null, be = null) {
            if (!ve)
              return null;
            try {
              if (be && typeof ve == "string") {
                if (be.addDefaultProtocol && ve.startsWith("www.")) {
                  const ze = ve.match(/\./g);
                  ze && ze.length >= 2 && (ve = `http://${ve}`);
                }
                if (be.tryConvertEncoding)
                  try {
                    ve = Fe(ve);
                  } catch {
                  }
              }
              const Le = Se ? new URL(ve, Se) : new URL(ve);
              if (T(Le))
                return Le;
            } catch {
            }
            return null;
          }
          function U(ve, Se, be) {
            return Object.defineProperty(ve, Se, {
              value: be,
              enumerable: !0,
              configurable: !0,
              writable: !1
            }), be;
          }
          const G = function() {
            function Se(be, Le) {
              this.constructor === Se && A("Cannot initialize BaseException."), this.message = be, this.name = Le;
            }
            return Se.prototype = new Error(), Se.constructor = Se, Se;
          }();
          ge.BaseException = G;
          class K extends G {
            constructor(Se, be) {
              super(Se, "PasswordException"), this.code = be;
            }
          }
          ge.PasswordException = K;
          class W extends G {
            constructor(Se, be) {
              super(Se, "UnknownErrorException"), this.details = be;
            }
          }
          ge.UnknownErrorException = W;
          class z extends G {
            constructor(Se) {
              super(Se, "InvalidPDFException");
            }
          }
          ge.InvalidPDFException = z;
          class V extends G {
            constructor(Se) {
              super(Se, "MissingPDFException");
            }
          }
          ge.MissingPDFException = V;
          class L extends G {
            constructor(Se, be) {
              super(Se, "UnexpectedResponseException"), this.status = be;
            }
          }
          ge.UnexpectedResponseException = L;
          class Y extends G {
            constructor(Se) {
              super(Se, "FormatError");
            }
          }
          ge.FormatError = Y;
          class J extends G {
            constructor(Se) {
              super(Se, "AbortException");
            }
          }
          ge.AbortException = J;
          function ie(ve) {
            (typeof ve != "object" || ve === null || ve.length === void 0) && A("Invalid argument for bytesToString");
            const Se = ve.length, be = 8192;
            if (Se < be)
              return String.fromCharCode.apply(null, ve);
            const Le = [];
            for (let ze = 0; ze < Se; ze += be) {
              const nt = Math.min(ze + be, Se), Ue = ve.subarray(ze, nt);
              Le.push(String.fromCharCode.apply(null, Ue));
            }
            return Le.join("");
          }
          function q(ve) {
            typeof ve != "string" && A("Invalid argument for stringToBytes");
            const Se = ve.length, be = new Uint8Array(Se);
            for (let Le = 0; Le < Se; ++Le)
              be[Le] = ve.charCodeAt(Le) & 255;
            return be;
          }
          function N(ve) {
            if (ve.length !== void 0)
              return ve.length;
            if (ve.byteLength !== void 0)
              return ve.byteLength;
            A("Invalid argument for arrayByteLength");
          }
          function Z(ve) {
            const Se = ve.length;
            if (Se === 1 && ve[0] instanceof Uint8Array)
              return ve[0];
            let be = 0;
            for (let nt = 0; nt < Se; nt++)
              be += N(ve[nt]);
            let Le = 0;
            const ze = new Uint8Array(be);
            for (let nt = 0; nt < Se; nt++) {
              let Ue = ve[nt];
              Ue instanceof Uint8Array || (typeof Ue == "string" ? Ue = q(Ue) : Ue = new Uint8Array(Ue));
              const Oe = Ue.byteLength;
              ze.set(Ue, Le), Le += Oe;
            }
            return ze;
          }
          function E(ve) {
            return String.fromCharCode(ve >> 24 & 255, ve >> 16 & 255, ve >> 8 & 255, ve & 255);
          }
          function te(ve) {
            return Object.keys(ve).length;
          }
          function re(ve) {
            const Se = /* @__PURE__ */ Object.create(null);
            for (const [be, Le] of ve)
              Se[be] = Le;
            return Se;
          }
          function ee() {
            const ve = new Uint8Array(4);
            return ve[0] = 1, new Uint32Array(ve.buffer, 0, 1)[0] === 1;
          }
          function $() {
            try {
              return new Function(""), !0;
            } catch {
              return !1;
            }
          }
          class k {
            static get isLittleEndian() {
              return U(this, "isLittleEndian", ee());
            }
            static get isEvalSupported() {
              return U(this, "isEvalSupported", $());
            }
            static get isOffscreenCanvasSupported() {
              return U(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas < "u");
            }
          }
          ge.FeatureTest = k;
          const H = [...Array(256).keys()].map((ve) => ve.toString(16).padStart(2, "0"));
          class ne {
            static makeHexColor(Se, be, Le) {
              return `#${H[Se]}${H[be]}${H[Le]}`;
            }
            static scaleMinMax(Se, be) {
              let Le;
              Se[0] ? (Se[0] < 0 && (Le = be[0], be[0] = be[1], be[1] = Le), be[0] *= Se[0], be[1] *= Se[0], Se[3] < 0 && (Le = be[2], be[2] = be[3], be[3] = Le), be[2] *= Se[3], be[3] *= Se[3]) : (Le = be[0], be[0] = be[2], be[2] = Le, Le = be[1], be[1] = be[3], be[3] = Le, Se[1] < 0 && (Le = be[2], be[2] = be[3], be[3] = Le), be[2] *= Se[1], be[3] *= Se[1], Se[2] < 0 && (Le = be[0], be[0] = be[1], be[1] = Le), be[0] *= Se[2], be[1] *= Se[2]), be[0] += Se[4], be[1] += Se[4], be[2] += Se[5], be[3] += Se[5];
            }
            static transform(Se, be) {
              return [Se[0] * be[0] + Se[2] * be[1], Se[1] * be[0] + Se[3] * be[1], Se[0] * be[2] + Se[2] * be[3], Se[1] * be[2] + Se[3] * be[3], Se[0] * be[4] + Se[2] * be[5] + Se[4], Se[1] * be[4] + Se[3] * be[5] + Se[5]];
            }
            static applyTransform(Se, be) {
              const Le = Se[0] * be[0] + Se[1] * be[2] + be[4], ze = Se[0] * be[1] + Se[1] * be[3] + be[5];
              return [Le, ze];
            }
            static applyInverseTransform(Se, be) {
              const Le = be[0] * be[3] - be[1] * be[2], ze = (Se[0] * be[3] - Se[1] * be[2] + be[2] * be[5] - be[4] * be[3]) / Le, nt = (-Se[0] * be[1] + Se[1] * be[0] + be[4] * be[1] - be[5] * be[0]) / Le;
              return [ze, nt];
            }
            static getAxialAlignedBoundingBox(Se, be) {
              const Le = ne.applyTransform(Se, be), ze = ne.applyTransform(Se.slice(2, 4), be), nt = ne.applyTransform([Se[0], Se[3]], be), Ue = ne.applyTransform([Se[2], Se[1]], be);
              return [Math.min(Le[0], ze[0], nt[0], Ue[0]), Math.min(Le[1], ze[1], nt[1], Ue[1]), Math.max(Le[0], ze[0], nt[0], Ue[0]), Math.max(Le[1], ze[1], nt[1], Ue[1])];
            }
            static inverseTransform(Se) {
              const be = Se[0] * Se[3] - Se[1] * Se[2];
              return [Se[3] / be, -Se[1] / be, -Se[2] / be, Se[0] / be, (Se[2] * Se[5] - Se[4] * Se[3]) / be, (Se[4] * Se[1] - Se[5] * Se[0]) / be];
            }
            static apply3dTransform(Se, be) {
              return [Se[0] * be[0] + Se[1] * be[1] + Se[2] * be[2], Se[3] * be[0] + Se[4] * be[1] + Se[5] * be[2], Se[6] * be[0] + Se[7] * be[1] + Se[8] * be[2]];
            }
            static singularValueDecompose2dScale(Se) {
              const be = [Se[0], Se[2], Se[1], Se[3]], Le = Se[0] * be[0] + Se[1] * be[2], ze = Se[0] * be[1] + Se[1] * be[3], nt = Se[2] * be[0] + Se[3] * be[2], Ue = Se[2] * be[1] + Se[3] * be[3], Oe = (Le + Ue) / 2, _e = Math.sqrt((Le + Ue) ** 2 - 4 * (Le * Ue - nt * ze)) / 2, at = Oe + _e || 1, Je = Oe - _e || 1;
              return [Math.sqrt(at), Math.sqrt(Je)];
            }
            static normalizeRect(Se) {
              const be = Se.slice(0);
              return Se[0] > Se[2] && (be[0] = Se[2], be[2] = Se[0]), Se[1] > Se[3] && (be[1] = Se[3], be[3] = Se[1]), be;
            }
            static intersect(Se, be) {
              const Le = Math.max(Math.min(Se[0], Se[2]), Math.min(be[0], be[2])), ze = Math.min(Math.max(Se[0], Se[2]), Math.max(be[0], be[2]));
              if (Le > ze)
                return null;
              const nt = Math.max(Math.min(Se[1], Se[3]), Math.min(be[1], be[3])), Ue = Math.min(Math.max(Se[1], Se[3]), Math.max(be[1], be[3]));
              return nt > Ue ? null : [Le, nt, ze, Ue];
            }
            static bezierBoundingBox(Se, be, Le, ze, nt, Ue, Oe, _e) {
              const at = [], Je = [[], []];
              let ot, mt, Ze, pt, Ft, $e, St, xt;
              for (let ct = 0; ct < 2; ++ct) {
                if (ct === 0 ? (mt = 6 * Se - 12 * Le + 6 * nt, ot = -3 * Se + 9 * Le - 9 * nt + 3 * Oe, Ze = 3 * Le - 3 * Se) : (mt = 6 * be - 12 * ze + 6 * Ue, ot = -3 * be + 9 * ze - 9 * Ue + 3 * _e, Ze = 3 * ze - 3 * be), Math.abs(ot) < 1e-12) {
                  if (Math.abs(mt) < 1e-12)
                    continue;
                  pt = -Ze / mt, 0 < pt && pt < 1 && at.push(pt);
                  continue;
                }
                St = mt * mt - 4 * Ze * ot, xt = Math.sqrt(St), !(St < 0) && (Ft = (-mt + xt) / (2 * ot), 0 < Ft && Ft < 1 && at.push(Ft), $e = (-mt - xt) / (2 * ot), 0 < $e && $e < 1 && at.push($e));
              }
              let Ie = at.length, Ve;
              const st = Ie;
              for (; Ie--; )
                pt = at[Ie], Ve = 1 - pt, Je[0][Ie] = Ve * Ve * Ve * Se + 3 * Ve * Ve * pt * Le + 3 * Ve * pt * pt * nt + pt * pt * pt * Oe, Je[1][Ie] = Ve * Ve * Ve * be + 3 * Ve * Ve * pt * ze + 3 * Ve * pt * pt * Ue + pt * pt * pt * _e;
              return Je[0][st] = Se, Je[1][st] = be, Je[0][st + 1] = Oe, Je[1][st + 1] = _e, Je[0].length = Je[1].length = st + 2, [Math.min(...Je[0]), Math.min(...Je[1]), Math.max(...Je[0]), Math.max(...Je[1])];
            }
          }
          ge.Util = ne;
          const ae = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
          function he(ve) {
            if (ve[0] >= "ï") {
              let be;
              if (ve[0] === "þ" && ve[1] === "ÿ" ? be = "utf-16be" : ve[0] === "ÿ" && ve[1] === "þ" ? be = "utf-16le" : ve[0] === "ï" && ve[1] === "»" && ve[2] === "¿" && (be = "utf-8"), be)
                try {
                  const Le = new TextDecoder(be, {
                    fatal: !0
                  }), ze = q(ve);
                  return Le.decode(ze);
                } catch (Le) {
                  S(`stringToPDFString: "${Le}".`);
                }
            }
            const Se = [];
            for (let be = 0, Le = ve.length; be < Le; be++) {
              const ze = ae[ve.charCodeAt(be)];
              Se.push(ze ? String.fromCharCode(ze) : ve.charAt(be));
            }
            return Se.join("");
          }
          function ue(ve) {
            return ve.replace(/([()\\\n\r])/g, (Se) => Se === `
` ? "\\n" : Se === "\r" ? "\\r" : `\\${Se}`);
          }
          function fe(ve) {
            return /^[\x00-\x7F]*$/.test(ve);
          }
          function me(ve) {
            const Se = ["þÿ"];
            for (let be = 0, Le = ve.length; be < Le; be++) {
              const ze = ve.charCodeAt(be);
              Se.push(String.fromCharCode(ze >> 8 & 255), String.fromCharCode(ze & 255));
            }
            return Se.join("");
          }
          function Fe(ve) {
            return decodeURIComponent(escape(ve));
          }
          function we(ve) {
            return unescape(encodeURIComponent(ve));
          }
          function Ae(ve) {
            return typeof ve == "object" && ve !== null && ve.byteLength !== void 0;
          }
          function De(ve, Se) {
            if (ve.length !== Se.length)
              return !1;
            for (let be = 0, Le = ve.length; be < Le; be++)
              if (ve[be] !== Se[be])
                return !1;
            return !0;
          }
          function xe(ve = new Date()) {
            return [ve.getUTCFullYear().toString(), (ve.getUTCMonth() + 1).toString().padStart(2, "0"), ve.getUTCDate().toString().padStart(2, "0"), ve.getUTCHours().toString().padStart(2, "0"), ve.getUTCMinutes().toString().padStart(2, "0"), ve.getUTCSeconds().toString().padStart(2, "0")].join("");
          }
          function Te() {
            const ve = /* @__PURE__ */ Object.create(null);
            let Se = !1;
            return Object.defineProperty(ve, "settled", {
              get() {
                return Se;
              }
            }), ve.promise = new Promise(function(be, Le) {
              ve.resolve = function(ze) {
                Se = !0, be(ze);
              }, ve.reject = function(ze) {
                Se = !0, Le(ze);
              };
            }), ve;
          }
        },
        /* 2 */
        /***/
        (Ee, ge, le) => {
          le(3);
        },
        /* 3 */
        /***/
        (Ee, ge) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.isNodeJS = void 0;
          const le = typeof process == "object" && process + "" == "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
          ge.isNodeJS = le;
        },
        /* 4 */
        /***/
        (__unused_webpack_module, exports, __w_pdfjs_require__) => {
          var Ee, le, de, oe, se, Q, u, P, t, di, v, a;
          Object.defineProperty(exports, "__esModule", {
            value: !0
          }), exports.build = exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0, exports.getDocument = getDocument, exports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory, exports.version = void 0;
          var _util = __w_pdfjs_require__(1), _annotation_storage = __w_pdfjs_require__(5), _display_utils = __w_pdfjs_require__(8), _font_loader = __w_pdfjs_require__(11), _canvas = __w_pdfjs_require__(12), _worker_options = __w_pdfjs_require__(15), _is_node = __w_pdfjs_require__(3), _message_handler = __w_pdfjs_require__(16), _metadata = __w_pdfjs_require__(17), _optional_content_config = __w_pdfjs_require__(18), _transport_stream = __w_pdfjs_require__(19), _xfa_text = __w_pdfjs_require__(20);
          const DEFAULT_RANGE_CHUNK_SIZE = 65536, RENDERING_CANCELLED_TIMEOUT = 100;
          let DefaultCanvasFactory = _display_utils.DOMCanvasFactory;
          exports.DefaultCanvasFactory = DefaultCanvasFactory;
          let DefaultCMapReaderFactory = _display_utils.DOMCMapReaderFactory;
          exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;
          let DefaultStandardFontDataFactory = _display_utils.DOMStandardFontDataFactory;
          if (exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory, _is_node.isNodeJS) {
            const {
              NodeCanvasFactory: y,
              NodeCMapReaderFactory: r,
              NodeStandardFontDataFactory: h
            } = __w_pdfjs_require__(21);
            exports.DefaultCanvasFactory = DefaultCanvasFactory = y, exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory = r, exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory = h;
          }
          let createPDFNetworkStream;
          function setPDFNetworkStreamFactory(y) {
            createPDFNetworkStream = y;
          }
          function getDocument(y) {
            const r = new PDFDocumentLoadingTask();
            let h;
            if (typeof y == "string" || y instanceof URL)
              h = {
                url: y
              };
            else if ((0, _util.isArrayBuffer)(y))
              h = {
                data: y
              };
            else if (y instanceof PDFDataRangeTransport)
              h = {
                range: y
              };
            else {
              if (typeof y != "object")
                throw new Error("Invalid parameter in getDocument, need either string, URL, TypedArray, or parameter object.");
              if (!y.url && !y.data && !y.range)
                throw new Error("Invalid parameter object: need either .data, .range or .url");
              h = y;
            }
            const g = /* @__PURE__ */ Object.create(null);
            let d = null, c = null;
            for (const o in h) {
              const x = h[o];
              switch (o) {
                case "url":
                  if (typeof window < "u")
                    try {
                      g[o] = new URL(x, window.location).href;
                      continue;
                    } catch (f) {
                      (0, _util.warn)(`Cannot create valid URL: "${f}".`);
                    }
                  else if (typeof x == "string" || x instanceof URL) {
                    g[o] = x.toString();
                    continue;
                  }
                  throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
                case "range":
                  d = x;
                  continue;
                case "worker":
                  c = x;
                  continue;
                case "data":
                  if (_is_node.isNodeJS && typeof Buffer < "u" && x instanceof Buffer)
                    g[o] = new Uint8Array(x);
                  else {
                    if (x instanceof Uint8Array)
                      break;
                    if (typeof x == "string")
                      g[o] = (0, _util.stringToBytes)(x);
                    else if (typeof x == "object" && x !== null && !isNaN(x.length))
                      g[o] = new Uint8Array(x);
                    else if ((0, _util.isArrayBuffer)(x))
                      g[o] = new Uint8Array(x);
                    else
                      throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
                  }
                  continue;
              }
              g[o] = x;
            }
            if (g.CMapReaderFactory = g.CMapReaderFactory || DefaultCMapReaderFactory, g.StandardFontDataFactory = g.StandardFontDataFactory || DefaultStandardFontDataFactory, g.ignoreErrors = g.stopAtErrors !== !0, g.fontExtraProperties = g.fontExtraProperties === !0, g.pdfBug = g.pdfBug === !0, g.enableXfa = g.enableXfa === !0, (!Number.isInteger(g.rangeChunkSize) || g.rangeChunkSize < 1) && (g.rangeChunkSize = DEFAULT_RANGE_CHUNK_SIZE), (typeof g.docBaseUrl != "string" || (0, _display_utils.isDataScheme)(g.docBaseUrl)) && (g.docBaseUrl = null), (!Number.isInteger(g.maxImageSize) || g.maxImageSize < -1) && (g.maxImageSize = -1), typeof g.cMapUrl != "string" && (g.cMapUrl = null), typeof g.standardFontDataUrl != "string" && (g.standardFontDataUrl = null), typeof g.useWorkerFetch != "boolean" && (g.useWorkerFetch = g.CMapReaderFactory === _display_utils.DOMCMapReaderFactory && g.StandardFontDataFactory === _display_utils.DOMStandardFontDataFactory), typeof g.isEvalSupported != "boolean" && (g.isEvalSupported = !0), typeof g.disableFontFace != "boolean" && (g.disableFontFace = _is_node.isNodeJS), typeof g.useSystemFonts != "boolean" && (g.useSystemFonts = !_is_node.isNodeJS && !g.disableFontFace), (typeof g.ownerDocument != "object" || g.ownerDocument === null) && (g.ownerDocument = globalThis.document), typeof g.disableRange != "boolean" && (g.disableRange = !1), typeof g.disableStream != "boolean" && (g.disableStream = !1), typeof g.disableAutoFetch != "boolean" && (g.disableAutoFetch = !1), (0, _util.setVerbosityLevel)(g.verbosity), !c) {
              const o = {
                verbosity: g.verbosity,
                port: _worker_options.GlobalWorkerOptions.workerPort
              };
              c = o.port ? PDFWorker.fromPort(o) : new PDFWorker(o), r._worker = c;
            }
            const n = r.docId;
            return c.promise.then(function() {
              if (r.destroyed)
                throw new Error("Loading aborted");
              const o = _fetchDocument(c, g, d, n), x = new Promise(function(f) {
                let m;
                d ? m = new _transport_stream.PDFDataTransportStream({
                  length: g.length,
                  initialData: g.initialData,
                  progressiveDone: g.progressiveDone,
                  contentDispositionFilename: g.contentDispositionFilename,
                  disableRange: g.disableRange,
                  disableStream: g.disableStream
                }, d) : g.data || (m = createPDFNetworkStream({
                  url: g.url,
                  length: g.length,
                  httpHeaders: g.httpHeaders,
                  withCredentials: g.withCredentials,
                  rangeChunkSize: g.rangeChunkSize,
                  disableRange: g.disableRange,
                  disableStream: g.disableStream
                })), f(m);
              });
              return Promise.all([o, x]).then(function([f, m]) {
                if (r.destroyed)
                  throw new Error("Loading aborted");
                const C = new _message_handler.MessageHandler(n, f, c.port), p = new WorkerTransport(C, r, m, g);
                r._transport = p, C.send("Ready", null);
              });
            }).catch(r._capability.reject), r;
          }
          async function _fetchDocument(y, r, h, g) {
            if (y.destroyed)
              throw new Error("Worker was destroyed");
            h && (r.length = h.length, r.initialData = h.initialData, r.progressiveDone = h.progressiveDone, r.contentDispositionFilename = h.contentDispositionFilename);
            const d = await y.messageHandler.sendWithPromise("GetDocRequest", {
              docId: g,
              apiVersion: "2.16.105",
              source: {
                data: r.data,
                url: r.url,
                password: r.password,
                disableAutoFetch: r.disableAutoFetch,
                rangeChunkSize: r.rangeChunkSize,
                length: r.length
              },
              maxImageSize: r.maxImageSize,
              disableFontFace: r.disableFontFace,
              docBaseUrl: r.docBaseUrl,
              ignoreErrors: r.ignoreErrors,
              isEvalSupported: r.isEvalSupported,
              fontExtraProperties: r.fontExtraProperties,
              enableXfa: r.enableXfa,
              useSystemFonts: r.useSystemFonts,
              cMapUrl: r.useWorkerFetch ? r.cMapUrl : null,
              standardFontDataUrl: r.useWorkerFetch ? r.standardFontDataUrl : null
            });
            if (r.data && (r.data = null), y.destroyed)
              throw new Error("Worker was destroyed");
            return d;
          }
          const ge = class {
            constructor() {
              this._capability = (0, _util.createPromiseCapability)(), this._transport = null, this._worker = null, this.docId = `d${hi(ge, Ee)._++}`, this.destroyed = !1, this.onPassword = null, this.onProgress = null, this.onUnsupportedFeature = null;
            }
            get promise() {
              return this._capability.promise;
            }
            async destroy() {
              var r;
              this.destroyed = !0, await ((r = this._transport) == null ? void 0 : r.destroy()), this._transport = null, this._worker && (this._worker.destroy(), this._worker = null);
            }
          };
          let PDFDocumentLoadingTask = ge;
          Ee = new WeakMap(), ft(PDFDocumentLoadingTask, Ee, 0), exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;
          class PDFDataRangeTransport {
            constructor(r, h, g = !1, d = null) {
              this.length = r, this.initialData = h, this.progressiveDone = g, this.contentDispositionFilename = d, this._rangeListeners = [], this._progressListeners = [], this._progressiveReadListeners = [], this._progressiveDoneListeners = [], this._readyCapability = (0, _util.createPromiseCapability)();
            }
            addRangeListener(r) {
              this._rangeListeners.push(r);
            }
            addProgressListener(r) {
              this._progressListeners.push(r);
            }
            addProgressiveReadListener(r) {
              this._progressiveReadListeners.push(r);
            }
            addProgressiveDoneListener(r) {
              this._progressiveDoneListeners.push(r);
            }
            onDataRange(r, h) {
              for (const g of this._rangeListeners)
                g(r, h);
            }
            onDataProgress(r, h) {
              this._readyCapability.promise.then(() => {
                for (const g of this._progressListeners)
                  g(r, h);
              });
            }
            onDataProgressiveRead(r) {
              this._readyCapability.promise.then(() => {
                for (const h of this._progressiveReadListeners)
                  h(r);
              });
            }
            onDataProgressiveDone() {
              this._readyCapability.promise.then(() => {
                for (const r of this._progressiveDoneListeners)
                  r();
              });
            }
            transportReady() {
              this._readyCapability.resolve();
            }
            requestDataRange(r, h) {
              (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
            }
            abort() {
            }
          }
          exports.PDFDataRangeTransport = PDFDataRangeTransport;
          class PDFDocumentProxy {
            constructor(r, h) {
              this._pdfInfo = r, this._transport = h, Object.defineProperty(this, "fingerprint", {
                get() {
                  return (0, _display_utils.deprecated)("`PDFDocumentProxy.fingerprint`, please use `PDFDocumentProxy.fingerprints` instead."), this.fingerprints[0];
                }
              }), Object.defineProperty(this, "getStats", {
                value: async () => ((0, _display_utils.deprecated)("`PDFDocumentProxy.getStats`, please use the `PDFDocumentProxy.stats`-getter instead."), this.stats || {
                  streamTypes: {},
                  fontTypes: {}
                })
              });
            }
            get annotationStorage() {
              return this._transport.annotationStorage;
            }
            get numPages() {
              return this._pdfInfo.numPages;
            }
            get fingerprints() {
              return this._pdfInfo.fingerprints;
            }
            get stats() {
              return this._transport.stats;
            }
            get isPureXfa() {
              return !!this._transport._htmlForXfa;
            }
            get allXfaHtml() {
              return this._transport._htmlForXfa;
            }
            getPage(r) {
              return this._transport.getPage(r);
            }
            getPageIndex(r) {
              return this._transport.getPageIndex(r);
            }
            getDestinations() {
              return this._transport.getDestinations();
            }
            getDestination(r) {
              return this._transport.getDestination(r);
            }
            getPageLabels() {
              return this._transport.getPageLabels();
            }
            getPageLayout() {
              return this._transport.getPageLayout();
            }
            getPageMode() {
              return this._transport.getPageMode();
            }
            getViewerPreferences() {
              return this._transport.getViewerPreferences();
            }
            getOpenAction() {
              return this._transport.getOpenAction();
            }
            getAttachments() {
              return this._transport.getAttachments();
            }
            getJavaScript() {
              return this._transport.getJavaScript();
            }
            getJSActions() {
              return this._transport.getDocJSActions();
            }
            getOutline() {
              return this._transport.getOutline();
            }
            getOptionalContentConfig() {
              return this._transport.getOptionalContentConfig();
            }
            getPermissions() {
              return this._transport.getPermissions();
            }
            getMetadata() {
              return this._transport.getMetadata();
            }
            getMarkInfo() {
              return this._transport.getMarkInfo();
            }
            getData() {
              return this._transport.getData();
            }
            getDownloadInfo() {
              return this._transport.downloadInfoCapability.promise;
            }
            cleanup(r = !1) {
              return this._transport.startCleanup(r || this.isPureXfa);
            }
            destroy() {
              return this.loadingTask.destroy();
            }
            get loadingParams() {
              return this._transport.loadingParams;
            }
            get loadingTask() {
              return this._transport.loadingTask;
            }
            saveDocument() {
              return this._transport.annotationStorage.size <= 0 && (0, _display_utils.deprecated)("saveDocument called while `annotationStorage` is empty, please use the getData-method instead."), this._transport.saveDocument();
            }
            getFieldObjects() {
              return this._transport.getFieldObjects();
            }
            hasJSActions() {
              return this._transport.hasJSActions();
            }
            getCalculationOrderIds() {
              return this._transport.getCalculationOrderIds();
            }
          }
          exports.PDFDocumentProxy = PDFDocumentProxy;
          class PDFPageProxy {
            constructor(r, h, g, d, c = !1) {
              this._pageIndex = r, this._pageInfo = h, this._ownerDocument = d, this._transport = g, this._stats = c ? new _display_utils.StatTimer() : null, this._pdfBug = c, this.commonObjs = g.commonObjs, this.objs = new PDFObjects(), this._bitmaps = /* @__PURE__ */ new Set(), this.cleanupAfterRender = !1, this.pendingCleanup = !1, this._intentStates = /* @__PURE__ */ new Map(), this._annotationPromises = /* @__PURE__ */ new Map(), this.destroyed = !1;
            }
            get pageNumber() {
              return this._pageIndex + 1;
            }
            get rotate() {
              return this._pageInfo.rotate;
            }
            get ref() {
              return this._pageInfo.ref;
            }
            get userUnit() {
              return this._pageInfo.userUnit;
            }
            get view() {
              return this._pageInfo.view;
            }
            getViewport({
              scale: r,
              rotation: h = this.rotate,
              offsetX: g = 0,
              offsetY: d = 0,
              dontFlip: c = !1
            } = {}) {
              return new _display_utils.PageViewport({
                viewBox: this.view,
                scale: r,
                rotation: h,
                offsetX: g,
                offsetY: d,
                dontFlip: c
              });
            }
            getAnnotations({
              intent: r = "display"
            } = {}) {
              const h = this._transport.getRenderingIntent(r);
              let g = this._annotationPromises.get(h.cacheKey);
              return g || (g = this._transport.getAnnotations(this._pageIndex, h.renderingIntent), this._annotationPromises.set(h.cacheKey, g), g = g.then((d) => {
                for (const c of d)
                  c.titleObj !== void 0 && Object.defineProperty(c, "title", {
                    get() {
                      return (0, _display_utils.deprecated)("`title`-property on annotation, please use `titleObj` instead."), c.titleObj.str;
                    }
                  }), c.contentsObj !== void 0 && Object.defineProperty(c, "contents", {
                    get() {
                      return (0, _display_utils.deprecated)("`contents`-property on annotation, please use `contentsObj` instead."), c.contentsObj.str;
                    }
                  });
                return d;
              })), g;
            }
            getJSActions() {
              return this._jsActionsPromise || (this._jsActionsPromise = this._transport.getPageJSActions(this._pageIndex));
            }
            async getXfa() {
              var r;
              return ((r = this._transport._htmlForXfa) == null ? void 0 : r.children[this._pageIndex]) || null;
            }
            render({
              canvasContext: r,
              viewport: h,
              intent: g = "display",
              annotationMode: d = _util.AnnotationMode.ENABLE,
              transform: c = null,
              imageLayer: n = null,
              canvasFactory: o = null,
              background: x = null,
              optionalContentConfigPromise: f = null,
              annotationCanvasMap: m = null,
              pageColors: C = null,
              printAnnotationStorage: p = null
            }) {
              var b, l;
              ((b = arguments[0]) == null ? void 0 : b.renderInteractiveForms) !== void 0 && ((0, _display_utils.deprecated)("render no longer accepts the `renderInteractiveForms`-option, please use the `annotationMode`-option instead."), arguments[0].renderInteractiveForms === !0 && d === _util.AnnotationMode.ENABLE && (d = _util.AnnotationMode.ENABLE_FORMS)), ((l = arguments[0]) == null ? void 0 : l.includeAnnotationStorage) !== void 0 && ((0, _display_utils.deprecated)("render no longer accepts the `includeAnnotationStorage`-option, please use the `annotationMode`-option instead."), arguments[0].includeAnnotationStorage === !0 && d === _util.AnnotationMode.ENABLE && (d = _util.AnnotationMode.ENABLE_STORAGE)), this._stats && this._stats.time("Overall");
              const w = this._transport.getRenderingIntent(g, d, p);
              this.pendingCleanup = !1, f || (f = this._transport.getOptionalContentConfig());
              let X = this._intentStates.get(w.cacheKey);
              X || (X = /* @__PURE__ */ Object.create(null), this._intentStates.set(w.cacheKey, X)), X.streamReaderCancelTimeout && (clearTimeout(X.streamReaderCancelTimeout), X.streamReaderCancelTimeout = null);
              const M = o || new DefaultCanvasFactory({
                ownerDocument: this._ownerDocument
              }), j = !!(w.renderingIntent & _util.RenderingIntentFlag.PRINT);
              X.displayReadyCapability || (X.displayReadyCapability = (0, _util.createPromiseCapability)(), X.operatorList = {
                fnArray: [],
                argsArray: [],
                lastChunk: !1,
                separateAnnots: null
              }, this._stats && this._stats.time("Page Request"), this._pumpOperatorList(w));
              const B = (_) => {
                X.renderTasks.delete(R), (this.cleanupAfterRender || j) && (this.pendingCleanup = !0), this._tryCleanup(), _ ? (R.capability.reject(_), this._abortOperatorList({
                  intentState: X,
                  reason: _ instanceof Error ? _ : new Error(_)
                })) : R.capability.resolve(), this._stats && (this._stats.timeEnd("Rendering"), this._stats.timeEnd("Overall"));
              }, R = new InternalRenderTask({
                callback: B,
                params: {
                  canvasContext: r,
                  viewport: h,
                  transform: c,
                  imageLayer: n,
                  background: x
                },
                objs: this.objs,
                commonObjs: this.commonObjs,
                annotationCanvasMap: m,
                operatorList: X.operatorList,
                pageIndex: this._pageIndex,
                canvasFactory: M,
                useRequestAnimationFrame: !j,
                pdfBug: this._pdfBug,
                pageColors: C
              });
              (X.renderTasks || (X.renderTasks = /* @__PURE__ */ new Set())).add(R);
              const D = R.task;
              return Promise.all([X.displayReadyCapability.promise, f]).then(([_, S]) => {
                if (this.pendingCleanup) {
                  B();
                  return;
                }
                this._stats && this._stats.time("Rendering"), R.initializeGraphics({
                  transparency: _,
                  optionalContentConfig: S
                }), R.operatorListChanged();
              }).catch(B), D;
            }
            getOperatorList({
              intent: r = "display",
              annotationMode: h = _util.AnnotationMode.ENABLE,
              printAnnotationStorage: g = null
            } = {}) {
              function d() {
                n.operatorList.lastChunk && (n.opListReadCapability.resolve(n.operatorList), n.renderTasks.delete(o));
              }
              const c = this._transport.getRenderingIntent(r, h, g, !0);
              let n = this._intentStates.get(c.cacheKey);
              n || (n = /* @__PURE__ */ Object.create(null), this._intentStates.set(c.cacheKey, n));
              let o;
              return n.opListReadCapability || (o = /* @__PURE__ */ Object.create(null), o.operatorListChanged = d, n.opListReadCapability = (0, _util.createPromiseCapability)(), (n.renderTasks || (n.renderTasks = /* @__PURE__ */ new Set())).add(o), n.operatorList = {
                fnArray: [],
                argsArray: [],
                lastChunk: !1,
                separateAnnots: null
              }, this._stats && this._stats.time("Page Request"), this._pumpOperatorList(c)), n.opListReadCapability.promise;
            }
            streamTextContent({
              disableCombineTextItems: r = !1,
              includeMarkedContent: h = !1
            } = {}) {
              return this._transport.messageHandler.sendWithStream("GetTextContent", {
                pageIndex: this._pageIndex,
                combineTextItems: r !== !0,
                includeMarkedContent: h === !0
              }, {
                highWaterMark: 100,
                size(d) {
                  return d.items.length;
                }
              });
            }
            getTextContent(r = {}) {
              if (this._transport._htmlForXfa)
                return this.getXfa().then((g) => _xfa_text.XfaText.textContent(g));
              const h = this.streamTextContent(r);
              return new Promise(function(g, d) {
                function c() {
                  n.read().then(function({
                    value: x,
                    done: f
                  }) {
                    if (f) {
                      g(o);
                      return;
                    }
                    Object.assign(o.styles, x.styles), o.items.push(...x.items), c();
                  }, d);
                }
                const n = h.getReader(), o = {
                  items: [],
                  styles: /* @__PURE__ */ Object.create(null)
                };
                c();
              });
            }
            getStructTree() {
              return this._structTreePromise || (this._structTreePromise = this._transport.getStructTree(this._pageIndex));
            }
            _destroy() {
              this.destroyed = !0;
              const r = [];
              for (const h of this._intentStates.values())
                if (this._abortOperatorList({
                  intentState: h,
                  reason: new Error("Page was destroyed."),
                  force: !0
                }), !h.opListReadCapability)
                  for (const g of h.renderTasks)
                    r.push(g.completed), g.cancel();
              this.objs.clear();
              for (const h of this._bitmaps)
                h.close();
              return this._bitmaps.clear(), this._annotationPromises.clear(), this._jsActionsPromise = null, this._structTreePromise = null, this.pendingCleanup = !1, Promise.all(r);
            }
            cleanup(r = !1) {
              return this.pendingCleanup = !0, this._tryCleanup(r);
            }
            _tryCleanup(r = !1) {
              if (!this.pendingCleanup)
                return !1;
              for (const {
                renderTasks: h,
                operatorList: g
              } of this._intentStates.values())
                if (h.size > 0 || !g.lastChunk)
                  return !1;
              this._intentStates.clear(), this.objs.clear(), this._annotationPromises.clear(), this._jsActionsPromise = null, this._structTreePromise = null, r && this._stats && (this._stats = new _display_utils.StatTimer());
              for (const h of this._bitmaps)
                h.close();
              return this._bitmaps.clear(), this.pendingCleanup = !1, !0;
            }
            _startRenderPage(r, h) {
              const g = this._intentStates.get(h);
              g && (this._stats && this._stats.timeEnd("Page Request"), g.displayReadyCapability && g.displayReadyCapability.resolve(r));
            }
            _renderPageChunk(r, h) {
              for (let g = 0, d = r.length; g < d; g++)
                h.operatorList.fnArray.push(r.fnArray[g]), h.operatorList.argsArray.push(r.argsArray[g]);
              h.operatorList.lastChunk = r.lastChunk, h.operatorList.separateAnnots = r.separateAnnots;
              for (const g of h.renderTasks)
                g.operatorListChanged();
              r.lastChunk && this._tryCleanup();
            }
            _pumpOperatorList({
              renderingIntent: r,
              cacheKey: h,
              annotationStorageMap: g
            }) {
              const c = this._transport.messageHandler.sendWithStream("GetOperatorList", {
                pageIndex: this._pageIndex,
                intent: r,
                cacheKey: h,
                annotationStorage: g
              }).getReader(), n = this._intentStates.get(h);
              n.streamReader = c;
              const o = () => {
                c.read().then(({
                  value: x,
                  done: f
                }) => {
                  if (f) {
                    n.streamReader = null;
                    return;
                  }
                  this._transport.destroyed || (this._renderPageChunk(x, n), o());
                }, (x) => {
                  if (n.streamReader = null, !this._transport.destroyed) {
                    if (n.operatorList) {
                      n.operatorList.lastChunk = !0;
                      for (const f of n.renderTasks)
                        f.operatorListChanged();
                      this._tryCleanup();
                    }
                    if (n.displayReadyCapability)
                      n.displayReadyCapability.reject(x);
                    else if (n.opListReadCapability)
                      n.opListReadCapability.reject(x);
                    else
                      throw x;
                  }
                });
              };
              o();
            }
            _abortOperatorList({
              intentState: r,
              reason: h,
              force: g = !1
            }) {
              if (r.streamReader) {
                if (!g) {
                  if (r.renderTasks.size > 0)
                    return;
                  if (h instanceof _display_utils.RenderingCancelledException) {
                    r.streamReaderCancelTimeout = setTimeout(() => {
                      this._abortOperatorList({
                        intentState: r,
                        reason: h,
                        force: !0
                      }), r.streamReaderCancelTimeout = null;
                    }, RENDERING_CANCELLED_TIMEOUT);
                    return;
                  }
                }
                if (r.streamReader.cancel(new _util.AbortException(h.message)).catch(() => {
                }), r.streamReader = null, !this._transport.destroyed) {
                  for (const [d, c] of this._intentStates)
                    if (c === r) {
                      this._intentStates.delete(d);
                      break;
                    }
                  this.cleanup();
                }
              }
            }
            get stats() {
              return this._stats;
            }
          }
          exports.PDFPageProxy = PDFPageProxy;
          class LoopbackPort {
            constructor() {
              this._listeners = [], this._deferred = Promise.resolve();
            }
            postMessage(r, h) {
              const g = {
                data: structuredClone(r, h)
              };
              this._deferred.then(() => {
                for (const d of this._listeners)
                  d.call(this, g);
              });
            }
            addEventListener(r, h) {
              this._listeners.push(h);
            }
            removeEventListener(r, h) {
              const g = this._listeners.indexOf(h);
              this._listeners.splice(g, 1);
            }
            terminate() {
              this._listeners.length = 0;
            }
          }
          exports.LoopbackPort = LoopbackPort;
          const PDFWorkerUtil = {
            isWorkerDisabled: !1,
            fallbackWorkerSrc: null,
            fakeWorkerId: 0
          };
          exports.PDFWorkerUtil = PDFWorkerUtil;
          {
            if (_is_node.isNodeJS && typeof commonjsRequire == "function")
              PDFWorkerUtil.isWorkerDisabled = !0, PDFWorkerUtil.fallbackWorkerSrc = "./pdf.worker.js";
            else if (typeof document == "object") {
              const y = (le = document == null ? void 0 : document.currentScript) == null ? void 0 : le.src;
              y && (PDFWorkerUtil.fallbackWorkerSrc = y.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2"));
            }
            PDFWorkerUtil.isSameOrigin = function(y, r) {
              let h;
              try {
                if (h = new URL(y), !h.origin || h.origin === "null")
                  return !1;
              } catch {
                return !1;
              }
              const g = new URL(r, h);
              return h.origin === g.origin;
            }, PDFWorkerUtil.createCDNWrapper = function(y) {
              const r = `importScripts("${y}");`;
              return URL.createObjectURL(new Blob([r]));
            };
          }
          const _PDFWorker = class {
            constructor({
              name: y = null,
              port: r = null,
              verbosity: h = (0, _util.getVerbosityLevel)()
            } = {}) {
              if (r && ke(_PDFWorker, de).has(r))
                throw new Error("Cannot use more than one PDFWorker per port.");
              if (this.name = y, this.destroyed = !1, this.verbosity = h, this._readyCapability = (0, _util.createPromiseCapability)(), this._port = null, this._webWorker = null, this._messageHandler = null, r) {
                ke(_PDFWorker, de).set(r, this), this._initializeFromPort(r);
                return;
              }
              this._initialize();
            }
            get promise() {
              return this._readyCapability.promise;
            }
            get port() {
              return this._port;
            }
            get messageHandler() {
              return this._messageHandler;
            }
            _initializeFromPort(y) {
              this._port = y, this._messageHandler = new _message_handler.MessageHandler("main", "worker", y), this._messageHandler.on("ready", function() {
              }), this._readyCapability.resolve();
            }
            _initialize() {
              if (!PDFWorkerUtil.isWorkerDisabled && !_PDFWorker._mainThreadWorkerMessageHandler) {
                let {
                  workerSrc: y
                } = _PDFWorker;
                try {
                  PDFWorkerUtil.isSameOrigin(window.location.href, y) || (y = PDFWorkerUtil.createCDNWrapper(new URL(y, window.location).href));
                  const r = new Worker(y), h = new _message_handler.MessageHandler("main", "worker", r), g = () => {
                    r.removeEventListener("error", d), h.destroy(), r.terminate(), this.destroyed ? this._readyCapability.reject(new Error("Worker was destroyed")) : this._setupFakeWorker();
                  }, d = () => {
                    this._webWorker || g();
                  };
                  r.addEventListener("error", d), h.on("test", (n) => {
                    if (r.removeEventListener("error", d), this.destroyed) {
                      g();
                      return;
                    }
                    n ? (this._messageHandler = h, this._port = r, this._webWorker = r, this._readyCapability.resolve(), h.send("configure", {
                      verbosity: this.verbosity
                    })) : (this._setupFakeWorker(), h.destroy(), r.terminate());
                  }), h.on("ready", (n) => {
                    if (r.removeEventListener("error", d), this.destroyed) {
                      g();
                      return;
                    }
                    try {
                      c();
                    } catch {
                      this._setupFakeWorker();
                    }
                  });
                  const c = () => {
                    const n = new Uint8Array();
                    h.send("test", n, [n.buffer]);
                  };
                  c();
                  return;
                } catch {
                  (0, _util.info)("The worker has been disabled.");
                }
              }
              this._setupFakeWorker();
            }
            _setupFakeWorker() {
              PDFWorkerUtil.isWorkerDisabled || ((0, _util.warn)("Setting up fake worker."), PDFWorkerUtil.isWorkerDisabled = !0), _PDFWorker._setupFakeWorkerGlobal.then((y) => {
                if (this.destroyed) {
                  this._readyCapability.reject(new Error("Worker was destroyed"));
                  return;
                }
                const r = new LoopbackPort();
                this._port = r;
                const h = `fake${PDFWorkerUtil.fakeWorkerId++}`, g = new _message_handler.MessageHandler(h + "_worker", h, r);
                y.setup(g, r);
                const d = new _message_handler.MessageHandler(h, h + "_worker", r);
                this._messageHandler = d, this._readyCapability.resolve(), d.send("configure", {
                  verbosity: this.verbosity
                });
              }).catch((y) => {
                this._readyCapability.reject(new Error(`Setting up fake worker failed: "${y.message}".`));
              });
            }
            destroy() {
              this.destroyed = !0, this._webWorker && (this._webWorker.terminate(), this._webWorker = null), ke(_PDFWorker, de).delete(this._port), this._port = null, this._messageHandler && (this._messageHandler.destroy(), this._messageHandler = null);
            }
            static fromPort(y) {
              if (!(y != null && y.port))
                throw new Error("PDFWorker.fromPort - invalid method signature.");
              return ke(this, de).has(y.port) ? ke(this, de).get(y.port) : new _PDFWorker(y);
            }
            static get workerSrc() {
              if (_worker_options.GlobalWorkerOptions.workerSrc)
                return _worker_options.GlobalWorkerOptions.workerSrc;
              if (PDFWorkerUtil.fallbackWorkerSrc !== null)
                return _is_node.isNodeJS || (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.'), PDFWorkerUtil.fallbackWorkerSrc;
              throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
            }
            static get _mainThreadWorkerMessageHandler() {
              var y;
              try {
                return ((y = globalThis.pdfjsWorker) == null ? void 0 : y.WorkerMessageHandler) || null;
              } catch {
                return null;
              }
            }
            static get _setupFakeWorkerGlobal() {
              const loader = async () => {
                const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler;
                if (mainWorkerMessageHandler)
                  return mainWorkerMessageHandler;
                if (_is_node.isNodeJS && typeof commonjsRequire == "function") {
                  const worker = eval("require")(this.workerSrc);
                  return worker.WorkerMessageHandler;
                }
                return await (0, _display_utils.loadScript)(this.workerSrc), window.pdfjsWorker.WorkerMessageHandler;
              };
              return (0, _util.shadow)(this, "_setupFakeWorkerGlobal", loader());
            }
          };
          let PDFWorker = _PDFWorker;
          de = new WeakMap(), ft(PDFWorker, de, /* @__PURE__ */ new WeakMap()), exports.PDFWorker = PDFWorker, PDFWorker.getWorkerSrc = function() {
            return (0, _display_utils.deprecated)("`PDFWorker.getWorkerSrc()`, please use `PDFWorker.workerSrc` instead."), this.workerSrc;
          };
          class WorkerTransport {
            constructor(r, h, g, d) {
              ft(this, oe, null);
              ft(this, se, /* @__PURE__ */ new Map());
              ft(this, Q, /* @__PURE__ */ new Map());
              ft(this, u, null);
              this.messageHandler = r, this.loadingTask = h, this.commonObjs = new PDFObjects(), this.fontLoader = new _font_loader.FontLoader({
                docId: h.docId,
                onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
                ownerDocument: d.ownerDocument,
                styleElement: d.styleElement
              }), this._params = d, d.useWorkerFetch || (this.CMapReaderFactory = new d.CMapReaderFactory({
                baseUrl: d.cMapUrl,
                isCompressed: d.cMapPacked
              }), this.StandardFontDataFactory = new d.StandardFontDataFactory({
                baseUrl: d.standardFontDataUrl
              })), this.destroyed = !1, this.destroyCapability = null, this._passwordCapability = null, this._networkStream = g, this._fullReader = null, this._lastProgress = null, this.downloadInfoCapability = (0, _util.createPromiseCapability)(), this.setupMessageHandler();
            }
            get annotationStorage() {
              return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());
            }
            get stats() {
              return ke(this, oe);
            }
            getRenderingIntent(r, h = _util.AnnotationMode.ENABLE, g = null, d = !1) {
              let c = _util.RenderingIntentFlag.DISPLAY, n = null;
              switch (r) {
                case "any":
                  c = _util.RenderingIntentFlag.ANY;
                  break;
                case "display":
                  break;
                case "print":
                  c = _util.RenderingIntentFlag.PRINT;
                  break;
                default:
                  (0, _util.warn)(`getRenderingIntent - invalid intent: ${r}`);
              }
              switch (h) {
                case _util.AnnotationMode.DISABLE:
                  c += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;
                  break;
                case _util.AnnotationMode.ENABLE:
                  break;
                case _util.AnnotationMode.ENABLE_FORMS:
                  c += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;
                  break;
                case _util.AnnotationMode.ENABLE_STORAGE:
                  c += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE, n = (c & _util.RenderingIntentFlag.PRINT && g instanceof _annotation_storage.PrintAnnotationStorage ? g : this.annotationStorage).serializable;
                  break;
                default:
                  (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${h}`);
              }
              return d && (c += _util.RenderingIntentFlag.OPLIST), {
                renderingIntent: c,
                cacheKey: `${c}_${_annotation_storage.AnnotationStorage.getHash(n)}`,
                annotationStorageMap: n
              };
            }
            destroy() {
              if (this.destroyCapability)
                return this.destroyCapability.promise;
              this.destroyed = !0, this.destroyCapability = (0, _util.createPromiseCapability)(), this._passwordCapability && this._passwordCapability.reject(new Error("Worker was destroyed during onPassword callback"));
              const r = [];
              for (const g of ke(this, se).values())
                r.push(g._destroy());
              ke(this, se).clear(), ke(this, Q).clear(), this.hasOwnProperty("annotationStorage") && this.annotationStorage.resetModified();
              const h = this.messageHandler.sendWithPromise("Terminate", null);
              return r.push(h), Promise.all(r).then(() => {
                this.commonObjs.clear(), this.fontLoader.clear(), Tt(this, u, null), this._getFieldObjectsPromise = null, this._hasJSActionsPromise = null, this._networkStream && this._networkStream.cancelAllRequests(new _util.AbortException("Worker was terminated.")), this.messageHandler && (this.messageHandler.destroy(), this.messageHandler = null), this.destroyCapability.resolve();
              }, this.destroyCapability.reject), this.destroyCapability.promise;
            }
            setupMessageHandler() {
              const {
                messageHandler: r,
                loadingTask: h
              } = this;
              r.on("GetReader", (g, d) => {
                (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available."), this._fullReader = this._networkStream.getFullReader(), this._fullReader.onProgress = (c) => {
                  this._lastProgress = {
                    loaded: c.loaded,
                    total: c.total
                  };
                }, d.onPull = () => {
                  this._fullReader.read().then(function({
                    value: c,
                    done: n
                  }) {
                    if (n) {
                      d.close();
                      return;
                    }
                    (0, _util.assert)((0, _util.isArrayBuffer)(c), "GetReader - expected an ArrayBuffer."), d.enqueue(new Uint8Array(c), 1, [c]);
                  }).catch((c) => {
                    d.error(c);
                  });
                }, d.onCancel = (c) => {
                  this._fullReader.cancel(c), d.ready.catch((n) => {
                    if (!this.destroyed)
                      throw n;
                  });
                };
              }), r.on("ReaderHeadersReady", (g) => {
                const d = (0, _util.createPromiseCapability)(), c = this._fullReader;
                return c.headersReady.then(() => {
                  var n;
                  (!c.isStreamingSupported || !c.isRangeSupported) && (this._lastProgress && ((n = h.onProgress) == null || n.call(h, this._lastProgress)), c.onProgress = (o) => {
                    var x;
                    (x = h.onProgress) == null || x.call(h, {
                      loaded: o.loaded,
                      total: o.total
                    });
                  }), d.resolve({
                    isStreamingSupported: c.isStreamingSupported,
                    isRangeSupported: c.isRangeSupported,
                    contentLength: c.contentLength
                  });
                }, d.reject), d.promise;
              }), r.on("GetRangeReader", (g, d) => {
                (0, _util.assert)(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
                const c = this._networkStream.getRangeReader(g.begin, g.end);
                if (!c) {
                  d.close();
                  return;
                }
                d.onPull = () => {
                  c.read().then(function({
                    value: n,
                    done: o
                  }) {
                    if (o) {
                      d.close();
                      return;
                    }
                    (0, _util.assert)((0, _util.isArrayBuffer)(n), "GetRangeReader - expected an ArrayBuffer."), d.enqueue(new Uint8Array(n), 1, [n]);
                  }).catch((n) => {
                    d.error(n);
                  });
                }, d.onCancel = (n) => {
                  c.cancel(n), d.ready.catch((o) => {
                    if (!this.destroyed)
                      throw o;
                  });
                };
              }), r.on("GetDoc", ({
                pdfInfo: g
              }) => {
                this._numPages = g.numPages, this._htmlForXfa = g.htmlForXfa, delete g.htmlForXfa, h._capability.resolve(new PDFDocumentProxy(g, this));
              }), r.on("DocException", function(g) {
                let d;
                switch (g.name) {
                  case "PasswordException":
                    d = new _util.PasswordException(g.message, g.code);
                    break;
                  case "InvalidPDFException":
                    d = new _util.InvalidPDFException(g.message);
                    break;
                  case "MissingPDFException":
                    d = new _util.MissingPDFException(g.message);
                    break;
                  case "UnexpectedResponseException":
                    d = new _util.UnexpectedResponseException(g.message, g.status);
                    break;
                  case "UnknownErrorException":
                    d = new _util.UnknownErrorException(g.message, g.details);
                    break;
                  default:
                    (0, _util.unreachable)("DocException - expected a valid Error.");
                }
                h._capability.reject(d);
              }), r.on("PasswordRequest", (g) => {
                if (this._passwordCapability = (0, _util.createPromiseCapability)(), h.onPassword) {
                  const d = (c) => {
                    c instanceof Error ? this._passwordCapability.reject(c) : this._passwordCapability.resolve({
                      password: c
                    });
                  };
                  try {
                    h.onPassword(d, g.code);
                  } catch (c) {
                    this._passwordCapability.reject(c);
                  }
                } else
                  this._passwordCapability.reject(new _util.PasswordException(g.message, g.code));
                return this._passwordCapability.promise;
              }), r.on("DataLoaded", (g) => {
                var d;
                (d = h.onProgress) == null || d.call(h, {
                  loaded: g.length,
                  total: g.length
                }), this.downloadInfoCapability.resolve(g);
              }), r.on("StartRenderPage", (g) => {
                if (this.destroyed)
                  return;
                ke(this, se).get(g.pageIndex)._startRenderPage(g.transparency, g.cacheKey);
              }), r.on("commonobj", ([g, d, c]) => {
                var n;
                if (!this.destroyed && !this.commonObjs.has(g))
                  switch (d) {
                    case "Font":
                      const o = this._params;
                      if ("error" in c) {
                        const m = c.error;
                        (0, _util.warn)(`Error during font loading: ${m}`), this.commonObjs.resolve(g, m);
                        break;
                      }
                      let x = null;
                      o.pdfBug && ((n = globalThis.FontInspector) != null && n.enabled) && (x = {
                        registerFont(m, C) {
                          globalThis.FontInspector.fontAdded(m, C);
                        }
                      });
                      const f = new _font_loader.FontFaceObject(c, {
                        isEvalSupported: o.isEvalSupported,
                        disableFontFace: o.disableFontFace,
                        ignoreErrors: o.ignoreErrors,
                        onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
                        fontRegistry: x
                      });
                      this.fontLoader.bind(f).catch((m) => r.sendWithPromise("FontFallback", {
                        id: g
                      })).finally(() => {
                        !o.fontExtraProperties && f.data && (f.data = null), this.commonObjs.resolve(g, f);
                      });
                      break;
                    case "FontPath":
                    case "Image":
                      this.commonObjs.resolve(g, c);
                      break;
                    default:
                      throw new Error(`Got unknown common object type ${d}`);
                  }
              }), r.on("obj", ([g, d, c, n]) => {
                var x;
                if (this.destroyed)
                  return;
                const o = ke(this, se).get(d);
                if (!o.objs.has(g))
                  switch (c) {
                    case "Image":
                      o.objs.resolve(g, n);
                      const f = 8e6;
                      if (n) {
                        let m;
                        if (n.bitmap) {
                          const {
                            bitmap: C,
                            width: p,
                            height: w
                          } = n;
                          m = p * w * 4, o._bitmaps.add(C);
                        } else
                          m = ((x = n.data) == null ? void 0 : x.length) || 0;
                        m > f && (o.cleanupAfterRender = !0);
                      }
                      break;
                    case "Pattern":
                      o.objs.resolve(g, n);
                      break;
                    default:
                      throw new Error(`Got unknown object type ${c}`);
                  }
              }), r.on("DocProgress", (g) => {
                var d;
                this.destroyed || (d = h.onProgress) == null || d.call(h, {
                  loaded: g.loaded,
                  total: g.total
                });
              }), r.on("DocStats", (g) => {
                this.destroyed || Tt(this, oe, Object.freeze({
                  streamTypes: Object.freeze(g.streamTypes),
                  fontTypes: Object.freeze(g.fontTypes)
                }));
              }), r.on("UnsupportedFeature", this._onUnsupportedFeature.bind(this)), r.on("FetchBuiltInCMap", (g) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.CMapReaderFactory ? this.CMapReaderFactory.fetch(g) : Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."))), r.on("FetchStandardFontData", (g) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.StandardFontDataFactory ? this.StandardFontDataFactory.fetch(g) : Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.")));
            }
            _onUnsupportedFeature({
              featureId: r
            }) {
              var h, g;
              this.destroyed || (g = (h = this.loadingTask).onUnsupportedFeature) == null || g.call(h, r);
            }
            getData() {
              return this.messageHandler.sendWithPromise("GetData", null);
            }
            getPage(r) {
              if (!Number.isInteger(r) || r <= 0 || r > this._numPages)
                return Promise.reject(new Error("Invalid page request."));
              const h = r - 1, g = ke(this, Q).get(h);
              if (g)
                return g;
              const d = this.messageHandler.sendWithPromise("GetPage", {
                pageIndex: h
              }).then((c) => {
                if (this.destroyed)
                  throw new Error("Transport destroyed");
                const n = new PDFPageProxy(h, c, this, this._params.ownerDocument, this._params.pdfBug);
                return ke(this, se).set(h, n), n;
              });
              return ke(this, Q).set(h, d), d;
            }
            getPageIndex(r) {
              return typeof r != "object" || r === null || !Number.isInteger(r.num) || r.num < 0 || !Number.isInteger(r.gen) || r.gen < 0 ? Promise.reject(new Error("Invalid pageIndex request.")) : this.messageHandler.sendWithPromise("GetPageIndex", {
                num: r.num,
                gen: r.gen
              });
            }
            getAnnotations(r, h) {
              return this.messageHandler.sendWithPromise("GetAnnotations", {
                pageIndex: r,
                intent: h
              });
            }
            saveDocument() {
              var r;
              return this.messageHandler.sendWithPromise("SaveDocument", {
                isPureXfa: !!this._htmlForXfa,
                numPages: this._numPages,
                annotationStorage: this.annotationStorage.serializable,
                filename: ((r = this._fullReader) == null ? void 0 : r.filename) ?? null
              }).finally(() => {
                this.annotationStorage.resetModified();
              });
            }
            getFieldObjects() {
              return this._getFieldObjectsPromise || (this._getFieldObjectsPromise = this.messageHandler.sendWithPromise("GetFieldObjects", null));
            }
            hasJSActions() {
              return this._hasJSActionsPromise || (this._hasJSActionsPromise = this.messageHandler.sendWithPromise("HasJSActions", null));
            }
            getCalculationOrderIds() {
              return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
            }
            getDestinations() {
              return this.messageHandler.sendWithPromise("GetDestinations", null);
            }
            getDestination(r) {
              return typeof r != "string" ? Promise.reject(new Error("Invalid destination request.")) : this.messageHandler.sendWithPromise("GetDestination", {
                id: r
              });
            }
            getPageLabels() {
              return this.messageHandler.sendWithPromise("GetPageLabels", null);
            }
            getPageLayout() {
              return this.messageHandler.sendWithPromise("GetPageLayout", null);
            }
            getPageMode() {
              return this.messageHandler.sendWithPromise("GetPageMode", null);
            }
            getViewerPreferences() {
              return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
            }
            getOpenAction() {
              return this.messageHandler.sendWithPromise("GetOpenAction", null);
            }
            getAttachments() {
              return this.messageHandler.sendWithPromise("GetAttachments", null);
            }
            getJavaScript() {
              return this.messageHandler.sendWithPromise("GetJavaScript", null);
            }
            getDocJSActions() {
              return this.messageHandler.sendWithPromise("GetDocJSActions", null);
            }
            getPageJSActions(r) {
              return this.messageHandler.sendWithPromise("GetPageJSActions", {
                pageIndex: r
              });
            }
            getStructTree(r) {
              return this.messageHandler.sendWithPromise("GetStructTree", {
                pageIndex: r
              });
            }
            getOutline() {
              return this.messageHandler.sendWithPromise("GetOutline", null);
            }
            getOptionalContentConfig() {
              return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then((r) => new _optional_content_config.OptionalContentConfig(r));
            }
            getPermissions() {
              return this.messageHandler.sendWithPromise("GetPermissions", null);
            }
            getMetadata() {
              return ke(this, u) || Tt(this, u, this.messageHandler.sendWithPromise("GetMetadata", null).then((r) => {
                var h, g;
                return {
                  info: r[0],
                  metadata: r[1] ? new _metadata.Metadata(r[1]) : null,
                  contentDispositionFilename: ((h = this._fullReader) == null ? void 0 : h.filename) ?? null,
                  contentLength: ((g = this._fullReader) == null ? void 0 : g.contentLength) ?? null
                };
              }));
            }
            getMarkInfo() {
              return this.messageHandler.sendWithPromise("GetMarkInfo", null);
            }
            async startCleanup(r = !1) {
              if (await this.messageHandler.sendWithPromise("Cleanup", null), !this.destroyed) {
                for (const h of ke(this, se).values())
                  if (!h.cleanup())
                    throw new Error(`startCleanup: Page ${h.pageNumber} is currently rendering.`);
                this.commonObjs.clear(), r || this.fontLoader.clear(), Tt(this, u, null), this._getFieldObjectsPromise = null, this._hasJSActionsPromise = null;
              }
            }
            get loadingParams() {
              const r = this._params;
              return (0, _util.shadow)(this, "loadingParams", {
                disableAutoFetch: r.disableAutoFetch,
                enableXfa: r.enableXfa
              });
            }
          }
          oe = new WeakMap(), se = new WeakMap(), Q = new WeakMap(), u = new WeakMap();
          class PDFObjects {
            constructor() {
              ft(this, t);
              ft(this, P, /* @__PURE__ */ Object.create(null));
            }
            get(r, h = null) {
              if (h) {
                const d = wt(this, t, di).call(this, r);
                return d.capability.promise.then(() => h(d.data)), null;
              }
              const g = ke(this, P)[r];
              if (!(g != null && g.capability.settled))
                throw new Error(`Requesting object that isn't resolved yet ${r}.`);
              return g.data;
            }
            has(r) {
              const h = ke(this, P)[r];
              return (h == null ? void 0 : h.capability.settled) || !1;
            }
            resolve(r, h = null) {
              const g = wt(this, t, di).call(this, r);
              g.data = h, g.capability.resolve();
            }
            clear() {
              Tt(this, P, /* @__PURE__ */ Object.create(null));
            }
          }
          P = new WeakMap(), t = new WeakSet(), di = function(r) {
            const h = ke(this, P)[r];
            return h || (ke(this, P)[r] = {
              capability: (0, _util.createPromiseCapability)(),
              data: null
            });
          };
          class RenderTask {
            constructor(r) {
              ft(this, v, null);
              Tt(this, v, r), this.onContinue = null;
            }
            get promise() {
              return ke(this, v).capability.promise;
            }
            cancel() {
              ke(this, v).cancel();
            }
            get separateAnnots() {
              const {
                separateAnnots: r
              } = ke(this, v).operatorList;
              if (!r)
                return !1;
              const {
                annotationCanvasMap: h
              } = ke(this, v);
              return r.form || r.canvas && (h == null ? void 0 : h.size) > 0;
            }
          }
          v = new WeakMap(), exports.RenderTask = RenderTask;
          const e = class {
            constructor({
              callback: r,
              params: h,
              objs: g,
              commonObjs: d,
              annotationCanvasMap: c,
              operatorList: n,
              pageIndex: o,
              canvasFactory: x,
              useRequestAnimationFrame: f = !1,
              pdfBug: m = !1,
              pageColors: C = null
            }) {
              this.callback = r, this.params = h, this.objs = g, this.commonObjs = d, this.annotationCanvasMap = c, this.operatorListIdx = null, this.operatorList = n, this._pageIndex = o, this.canvasFactory = x, this._pdfBug = m, this.pageColors = C, this.running = !1, this.graphicsReadyCallback = null, this.graphicsReady = !1, this._useRequestAnimationFrame = f === !0 && typeof window < "u", this.cancelled = !1, this.capability = (0, _util.createPromiseCapability)(), this.task = new RenderTask(this), this._cancelBound = this.cancel.bind(this), this._continueBound = this._continue.bind(this), this._scheduleNextBound = this._scheduleNext.bind(this), this._nextBound = this._next.bind(this), this._canvas = h.canvasContext.canvas;
            }
            get completed() {
              return this.capability.promise.catch(function() {
              });
            }
            initializeGraphics({
              transparency: r = !1,
              optionalContentConfig: h
            }) {
              var x;
              if (this.cancelled)
                return;
              if (this._canvas) {
                if (ke(e, a).has(this._canvas))
                  throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
                ke(e, a).add(this._canvas);
              }
              this._pdfBug && ((x = globalThis.StepperManager) != null && x.enabled) && (this.stepper = globalThis.StepperManager.create(this._pageIndex), this.stepper.init(this.operatorList), this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint());
              const {
                canvasContext: g,
                viewport: d,
                transform: c,
                imageLayer: n,
                background: o
              } = this.params;
              this.gfx = new _canvas.CanvasGraphics(g, this.commonObjs, this.objs, this.canvasFactory, n, h, this.annotationCanvasMap, this.pageColors), this.gfx.beginDrawing({
                transform: c,
                viewport: d,
                transparency: r,
                background: o
              }), this.operatorListIdx = 0, this.graphicsReady = !0, this.graphicsReadyCallback && this.graphicsReadyCallback();
            }
            cancel(r = null) {
              this.running = !1, this.cancelled = !0, this.gfx && this.gfx.endDrawing(), this._canvas && ke(e, a).delete(this._canvas), this.callback(r || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, "canvas"));
            }
            operatorListChanged() {
              if (!this.graphicsReady) {
                this.graphicsReadyCallback || (this.graphicsReadyCallback = this._continueBound);
                return;
              }
              this.stepper && this.stepper.updateOperatorList(this.operatorList), !this.running && this._continue();
            }
            _continue() {
              this.running = !0, !this.cancelled && (this.task.onContinue ? this.task.onContinue(this._scheduleNextBound) : this._scheduleNext());
            }
            _scheduleNext() {
              this._useRequestAnimationFrame ? window.requestAnimationFrame(() => {
                this._nextBound().catch(this._cancelBound);
              }) : Promise.resolve().then(this._nextBound).catch(this._cancelBound);
            }
            async _next() {
              this.cancelled || (this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper), this.operatorListIdx === this.operatorList.argsArray.length && (this.running = !1, this.operatorList.lastChunk && (this.gfx.endDrawing(), this._canvas && ke(e, a).delete(this._canvas), this.callback())));
            }
          };
          let InternalRenderTask = e;
          a = new WeakMap(), ft(InternalRenderTask, a, /* @__PURE__ */ new WeakSet());
          const version = "2.16.105";
          exports.version = version;
          const build = "172ccdbe5";
          exports.build = build;
        },
        /* 5 */
        /***/
        (Ee, ge, le) => {
          var P, Ri, i;
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.PrintAnnotationStorage = ge.AnnotationStorage = void 0;
          var de = le(1), oe = le(6), se = le(10);
          class Q {
            constructor() {
              ft(this, P);
              this._storage = /* @__PURE__ */ new Map(), this._modified = !1, this.onSetModified = null, this.onResetModified = null, this.onAnnotationEditor = null;
            }
            getValue(a, e) {
              const y = this._storage.get(a);
              return y === void 0 ? e : Object.assign(e, y);
            }
            getRawValue(a) {
              return this._storage.get(a);
            }
            remove(a) {
              if (this._storage.delete(a), this._storage.size === 0 && this.resetModified(), typeof this.onAnnotationEditor == "function") {
                for (const e of this._storage.values())
                  if (e instanceof oe.AnnotationEditor)
                    return;
                this.onAnnotationEditor(null);
              }
            }
            setValue(a, e) {
              const y = this._storage.get(a);
              let r = !1;
              if (y !== void 0)
                for (const [h, g] of Object.entries(e))
                  y[h] !== g && (r = !0, y[h] = g);
              else
                r = !0, this._storage.set(a, e);
              r && wt(this, P, Ri).call(this), e instanceof oe.AnnotationEditor && typeof this.onAnnotationEditor == "function" && this.onAnnotationEditor(e.constructor._type);
            }
            has(a) {
              return this._storage.has(a);
            }
            getAll() {
              return this._storage.size > 0 ? (0, de.objectFromMap)(this._storage) : null;
            }
            get size() {
              return this._storage.size;
            }
            resetModified() {
              this._modified && (this._modified = !1, typeof this.onResetModified == "function" && this.onResetModified());
            }
            get print() {
              return new u(this);
            }
            get serializable() {
              if (this._storage.size === 0)
                return null;
              const a = /* @__PURE__ */ new Map();
              for (const [e, y] of this._storage) {
                const r = y instanceof oe.AnnotationEditor ? y.serialize() : y;
                r && a.set(e, r);
              }
              return a;
            }
            static getHash(a) {
              if (!a)
                return "";
              const e = new se.MurmurHash3_64();
              for (const [y, r] of a)
                e.update(`${y}:${JSON.stringify(r)}`);
              return e.hexdigest();
            }
          }
          P = new WeakSet(), Ri = function() {
            this._modified || (this._modified = !0, typeof this.onSetModified == "function" && this.onSetModified());
          }, ge.AnnotationStorage = Q;
          class u extends Q {
            constructor(e) {
              super();
              ft(this, i, null);
              Tt(this, i, structuredClone(e.serializable));
            }
            get print() {
              (0, de.unreachable)("Should not call PrintAnnotationStorage.print");
            }
            get serializable() {
              return ke(this, i);
            }
          }
          i = new WeakMap(), ge.PrintAnnotationStorage = u;
        },
        /* 6 */
        /***/
        (Ee, ge, le) => {
          var Q, u, P, t, i, v;
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.AnnotationEditor = void 0;
          var de = le(7), oe = le(1);
          const a = class {
            constructor(y) {
              ft(this, Q, this.focusin.bind(this));
              ft(this, u, this.focusout.bind(this));
              ft(this, P, !1);
              ft(this, t, !1);
              ft(this, i, !1);
              ft(this, v, a._zIndex++);
              this.constructor === a && (0, oe.unreachable)("Cannot initialize AnnotationEditor."), this.parent = y.parent, this.id = y.id, this.width = this.height = null, this.pageIndex = y.parent.pageIndex, this.name = y.name, this.div = null;
              const [r, h] = this.parent.viewportBaseDimensions;
              this.x = y.x / r, this.y = y.y / h, this.rotation = this.parent.viewport.rotation, this.isAttachedToDOM = !1;
            }
            static get _defaultLineColor() {
              return (0, oe.shadow)(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
            }
            setInBackground() {
              this.div.style.zIndex = 0;
            }
            setInForeground() {
              this.div.style.zIndex = ke(this, v);
            }
            focusin(y) {
              ke(this, P) ? Tt(this, P, !1) : this.parent.setSelected(this);
            }
            focusout(y) {
              if (!this.isAttachedToDOM)
                return;
              const r = y.relatedTarget;
              r != null && r.closest(`#${this.id}`) || (y.preventDefault(), this.parent.isMultipleSelection || this.commitOrRemove());
            }
            commitOrRemove() {
              this.isEmpty() ? this.remove() : this.commit();
            }
            commit() {
              this.parent.addToAnnotationStorage(this);
            }
            dragstart(y) {
              const r = this.parent.div.getBoundingClientRect();
              this.startX = y.clientX - r.x, this.startY = y.clientY - r.y, y.dataTransfer.setData("text/plain", this.id), y.dataTransfer.effectAllowed = "move";
            }
            setAt(y, r, h, g) {
              const [d, c] = this.parent.viewportBaseDimensions;
              [h, g] = this.screenToPageTranslation(h, g), this.x = (y + h) / d, this.y = (r + g) / c, this.div.style.left = `${100 * this.x}%`, this.div.style.top = `${100 * this.y}%`;
            }
            translate(y, r) {
              const [h, g] = this.parent.viewportBaseDimensions;
              [y, r] = this.screenToPageTranslation(y, r), this.x += y / h, this.y += r / g, this.div.style.left = `${100 * this.x}%`, this.div.style.top = `${100 * this.y}%`;
            }
            screenToPageTranslation(y, r) {
              const {
                rotation: h
              } = this.parent.viewport;
              switch (h) {
                case 90:
                  return [r, -y];
                case 180:
                  return [-y, -r];
                case 270:
                  return [-r, y];
                default:
                  return [y, r];
              }
            }
            setDims(y, r) {
              const [h, g] = this.parent.viewportBaseDimensions;
              this.div.style.width = `${100 * y / h}%`, this.div.style.height = `${100 * r / g}%`;
            }
            getInitialTranslation() {
              return [0, 0];
            }
            render() {
              this.div = document.createElement("div"), this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360), this.div.className = this.name, this.div.setAttribute("id", this.id), this.div.setAttribute("tabIndex", 0), this.setInForeground(), this.div.addEventListener("focusin", ke(this, Q)), this.div.addEventListener("focusout", ke(this, u));
              const [y, r] = this.getInitialTranslation();
              return this.translate(y, r), (0, de.bindEvents)(this, this.div, ["dragstart", "pointerdown"]), this.div;
            }
            pointerdown(y) {
              const r = de.KeyboardManager.platform.isMac;
              if (y.button !== 0 || y.ctrlKey && r) {
                y.preventDefault();
                return;
              }
              y.ctrlKey && !r || y.shiftKey || y.metaKey && r ? this.parent.toggleSelected(this) : this.parent.setSelected(this), Tt(this, P, !0);
            }
            getRect(y, r) {
              const [h, g] = this.parent.viewportBaseDimensions, [d, c] = this.parent.pageDimensions, n = d * y / h, o = c * r / g, x = this.x * d, f = this.y * c, m = this.width * d, C = this.height * c;
              switch (this.rotation) {
                case 0:
                  return [x + n, c - f - o - C, x + n + m, c - f - o];
                case 90:
                  return [x + o, c - f + n, x + o + C, c - f + n + m];
                case 180:
                  return [x - n - m, c - f + o, x - n, c - f + o + C];
                case 270:
                  return [x - o - C, c - f - n - m, x - o, c - f - n];
                default:
                  throw new Error("Invalid rotation");
              }
            }
            getRectInCurrentCoords(y, r) {
              const [h, g, d, c] = y, n = d - h, o = c - g;
              switch (this.rotation) {
                case 0:
                  return [h, r - c, n, o];
                case 90:
                  return [h, r - g, o, n];
                case 180:
                  return [d, r - g, n, o];
                case 270:
                  return [d, r - c, o, n];
                default:
                  throw new Error("Invalid rotation");
              }
            }
            onceAdded() {
            }
            isEmpty() {
              return !1;
            }
            enableEditMode() {
              Tt(this, i, !0);
            }
            disableEditMode() {
              Tt(this, i, !1);
            }
            isInEditMode() {
              return ke(this, i);
            }
            shouldGetKeyboardEvents() {
              return !1;
            }
            needsToBeRebuilt() {
              return this.div && !this.isAttachedToDOM;
            }
            rebuild() {
              var y;
              (y = this.div) == null || y.addEventListener("focusin", ke(this, Q));
            }
            serialize() {
              (0, oe.unreachable)("An editor must be serializable");
            }
            static deserialize(y, r) {
              const h = new this.prototype.constructor({
                parent: r,
                id: r.getNextId()
              });
              h.rotation = y.rotation;
              const [g, d] = r.pageDimensions, [c, n, o, x] = h.getRectInCurrentCoords(y.rect, d);
              return h.x = c / g, h.y = n / d, h.width = o / g, h.height = x / d, h;
            }
            remove() {
              this.div.removeEventListener("focusin", ke(this, Q)), this.div.removeEventListener("focusout", ke(this, u)), this.isEmpty() || this.commit(), this.parent.remove(this);
            }
            select() {
              var y;
              (y = this.div) == null || y.classList.add("selectedEditor");
            }
            unselect() {
              var y;
              (y = this.div) == null || y.classList.remove("selectedEditor");
            }
            updateParams(y, r) {
            }
            disableEditing() {
            }
            enableEditing() {
            }
            get propertiesToUpdate() {
              return {};
            }
            get contentDiv() {
              return this.div;
            }
            get isEditing() {
              return ke(this, t);
            }
            set isEditing(y) {
              Tt(this, t, y), y ? (this.parent.setSelected(this), this.parent.setActiveEditor(this)) : this.parent.setActiveEditor(null);
            }
          };
          let se = a;
          Q = new WeakMap(), u = new WeakMap(), P = new WeakMap(), t = new WeakMap(), i = new WeakMap(), v = new WeakMap(), sn(se, "_colorManager", new de.ColorManager()), sn(se, "_zIndex", 1), ge.AnnotationEditor = se;
        },
        /* 7 */
        /***/
        (Ee, ge, le) => {
          var e, y, r, h, g, d, Ui, o, f, m, C, p, w, X, M, j, B, R, D, b, l, _, S, A, F, T, Mi, U, fi, K, pn, z, zn, L, Bi, J, Li, q, gi, Z, Gn, te, Jn;
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.KeyboardManager = ge.CommandManager = ge.ColorManager = ge.AnnotationEditorUIManager = void 0, ge.bindEvents = se, ge.opacityToHex = Q;
          var de = le(1), oe = le(8);
          function se($, k, H) {
            for (const ne of H)
              k.addEventListener(ne, $[ne].bind($));
          }
          function Q($) {
            return Math.round(Math.min(255, Math.max(1, 255 * $))).toString(16).padStart(2, "0");
          }
          class u {
            constructor() {
              ft(this, e, 0);
            }
            getId() {
              return `${de.AnnotationEditorPrefix}${hi(this, e)._++}`;
            }
          }
          e = new WeakMap();
          class P {
            constructor(k = 128) {
              ft(this, y, []);
              ft(this, r, !1);
              ft(this, h, void 0);
              ft(this, g, -1);
              Tt(this, h, k);
            }
            add({
              cmd: k,
              undo: H,
              mustExec: ne,
              type: ae = NaN,
              overwriteIfSameType: he = !1,
              keepUndo: ue = !1
            }) {
              if (ne && k(), ke(this, r))
                return;
              const fe = {
                cmd: k,
                undo: H,
                type: ae
              };
              if (ke(this, g) === -1) {
                ke(this, y).length > 0 && (ke(this, y).length = 0), Tt(this, g, 0), ke(this, y).push(fe);
                return;
              }
              if (he && ke(this, y)[ke(this, g)].type === ae) {
                ue && (fe.undo = ke(this, y)[ke(this, g)].undo), ke(this, y)[ke(this, g)] = fe;
                return;
              }
              const me = ke(this, g) + 1;
              me === ke(this, h) ? ke(this, y).splice(0, 1) : (Tt(this, g, me), me < ke(this, y).length && ke(this, y).splice(me)), ke(this, y).push(fe);
            }
            undo() {
              ke(this, g) !== -1 && (Tt(this, r, !0), ke(this, y)[ke(this, g)].undo(), Tt(this, r, !1), Tt(this, g, ke(this, g) - 1));
            }
            redo() {
              ke(this, g) < ke(this, y).length - 1 && (Tt(this, g, ke(this, g) + 1), Tt(this, r, !0), ke(this, y)[ke(this, g)].cmd(), Tt(this, r, !1));
            }
            hasSomethingToUndo() {
              return ke(this, g) !== -1;
            }
            hasSomethingToRedo() {
              return ke(this, g) < ke(this, y).length - 1;
            }
            destroy() {
              Tt(this, y, null);
            }
          }
          y = new WeakMap(), r = new WeakMap(), h = new WeakMap(), g = new WeakMap(), ge.CommandManager = P;
          const n = class {
            constructor(k) {
              ft(this, d);
              this.buffer = [], this.callbacks = /* @__PURE__ */ new Map(), this.allKeys = /* @__PURE__ */ new Set();
              const H = n.platform.isMac;
              for (const [ne, ae] of k)
                for (const he of ne) {
                  const ue = he.startsWith("mac+");
                  H && ue ? (this.callbacks.set(he.slice(4), ae), this.allKeys.add(he.split("+").at(-1))) : !H && !ue && (this.callbacks.set(he, ae), this.allKeys.add(he.split("+").at(-1)));
                }
            }
            static get platform() {
              const k = typeof navigator < "u" ? navigator.platform : "";
              return (0, de.shadow)(this, "platform", {
                isWin: k.includes("Win"),
                isMac: k.includes("Mac")
              });
            }
            exec(k, H) {
              if (!this.allKeys.has(H.key))
                return;
              const ne = this.callbacks.get(wt(this, d, Ui).call(this, H));
              ne && (ne.bind(k)(), H.stopPropagation(), H.preventDefault());
            }
          };
          let t = n;
          d = new WeakSet(), Ui = function(k) {
            k.altKey && this.buffer.push("alt"), k.ctrlKey && this.buffer.push("ctrl"), k.metaKey && this.buffer.push("meta"), k.shiftKey && this.buffer.push("shift"), this.buffer.push(k.key);
            const H = this.buffer.join("+");
            return this.buffer.length = 0, H;
          }, ge.KeyboardManager = t;
          class i {
            constructor() {
              ft(this, o, null);
            }
            copy(k) {
              k && (Array.isArray(k) ? Tt(this, o, k.map((H) => H.serialize())) : Tt(this, o, [k.serialize()]), Tt(this, o, ke(this, o).filter((H) => !!H)), ke(this, o).length === 0 && Tt(this, o, null));
            }
            paste() {
              return ke(this, o);
            }
            isEmpty() {
              return ke(this, o) === null;
            }
            destroy() {
              Tt(this, o, null);
            }
          }
          o = new WeakMap();
          const x = class {
            get _colors() {
              const k = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
              return (0, oe.getColorValues)(k), (0, de.shadow)(this, "_colors", k);
            }
            convert(k) {
              const H = (0, oe.getRGB)(k);
              if (!window.matchMedia("(forced-colors: active)").matches)
                return H;
              for (const [ne, ae] of this._colors)
                if (ae.every((he, ue) => he === H[ue]))
                  return x._colorsMapping.get(ne);
              return H;
            }
            getHexCode(k) {
              const H = this._colors.get(k);
              return H ? de.Util.makeHexColor(...H) : k;
            }
          };
          let v = x;
          sn(v, "_colorsMapping", /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]])), ge.ColorManager = v;
          const ee = class {
            constructor(k, H) {
              ft(this, T);
              ft(this, U);
              ft(this, K);
              ft(this, z);
              ft(this, L);
              ft(this, J);
              ft(this, q);
              ft(this, Z);
              ft(this, te);
              ft(this, f, null);
              ft(this, m, /* @__PURE__ */ new Map());
              ft(this, C, /* @__PURE__ */ new Map());
              ft(this, p, new i());
              ft(this, w, new P());
              ft(this, X, 0);
              ft(this, M, null);
              ft(this, j, null);
              ft(this, B, new u());
              ft(this, R, !1);
              ft(this, D, de.AnnotationEditorType.NONE);
              ft(this, b, /* @__PURE__ */ new Set());
              ft(this, l, this.keydown.bind(this));
              ft(this, _, this.onEditingAction.bind(this));
              ft(this, S, this.onPageChanging.bind(this));
              ft(this, A, {
                isEditing: !1,
                isEmpty: !0,
                hasEmptyClipboard: !0,
                hasSomethingToUndo: !1,
                hasSomethingToRedo: !1,
                hasSelectedEditor: !1
              });
              ft(this, F, null);
              Tt(this, F, k), Tt(this, j, H), ke(this, j)._on("editingaction", ke(this, _)), ke(this, j)._on("pagechanging", ke(this, S));
            }
            destroy() {
              wt(this, U, fi).call(this), ke(this, j)._off("editingaction", ke(this, _)), ke(this, j)._off("pagechanging", ke(this, S));
              for (const k of ke(this, C).values())
                k.destroy();
              ke(this, C).clear(), ke(this, m).clear(), Tt(this, f, null), ke(this, b).clear(), ke(this, p).destroy(), ke(this, w).destroy();
            }
            onPageChanging({
              pageNumber: k
            }) {
              Tt(this, X, k - 1);
            }
            focusMainContainer() {
              ke(this, F).focus();
            }
            keydown(k) {
              var H;
              (H = this.getActive()) != null && H.shouldGetKeyboardEvents() || ee._keyboardManager.exec(this, k);
            }
            onEditingAction(k) {
              ["undo", "redo", "cut", "copy", "paste", "delete", "selectAll"].includes(k.name) && this[k.name]();
            }
            setEditingState(k) {
              k ? (wt(this, T, Mi).call(this), wt(this, K, pn).call(this, {
                isEditing: ke(this, D) !== de.AnnotationEditorType.NONE,
                isEmpty: wt(this, Z, Gn).call(this),
                hasSomethingToUndo: ke(this, w).hasSomethingToUndo(),
                hasSomethingToRedo: ke(this, w).hasSomethingToRedo(),
                hasSelectedEditor: !1,
                hasEmptyClipboard: ke(this, p).isEmpty()
              })) : (wt(this, U, fi).call(this), wt(this, K, pn).call(this, {
                isEditing: !1
              }));
            }
            registerEditorTypes(k) {
              Tt(this, M, k);
              for (const H of ke(this, M))
                wt(this, z, zn).call(this, H.defaultPropertiesToUpdate);
            }
            getId() {
              return ke(this, B).getId();
            }
            addLayer(k) {
              ke(this, C).set(k.pageIndex, k), ke(this, R) ? k.enable() : k.disable();
            }
            removeLayer(k) {
              ke(this, C).delete(k.pageIndex);
            }
            updateMode(k) {
              if (Tt(this, D, k), k === de.AnnotationEditorType.NONE)
                this.setEditingState(!1), wt(this, J, Li).call(this);
              else {
                this.setEditingState(!0), wt(this, L, Bi).call(this);
                for (const H of ke(this, C).values())
                  H.updateMode(k);
              }
            }
            updateToolbar(k) {
              k !== ke(this, D) && ke(this, j).dispatch("switchannotationeditormode", {
                source: this,
                mode: k
              });
            }
            updateParams(k, H) {
              for (const ne of ke(this, b))
                ne.updateParams(k, H);
              for (const ne of ke(this, M))
                ne.updateDefaultParams(k, H);
            }
            getEditors(k) {
              const H = [];
              for (const ne of ke(this, m).values())
                ne.pageIndex === k && H.push(ne);
              return H;
            }
            getEditor(k) {
              return ke(this, m).get(k);
            }
            addEditor(k) {
              ke(this, m).set(k.id, k);
            }
            removeEditor(k) {
              ke(this, m).delete(k.id), this.unselect(k);
            }
            setActiveEditor(k) {
              ke(this, f) !== k && (Tt(this, f, k), k && wt(this, z, zn).call(this, k.propertiesToUpdate));
            }
            toggleSelected(k) {
              if (ke(this, b).has(k)) {
                ke(this, b).delete(k), k.unselect(), wt(this, K, pn).call(this, {
                  hasSelectedEditor: this.hasSelection
                });
                return;
              }
              ke(this, b).add(k), k.select(), wt(this, z, zn).call(this, k.propertiesToUpdate), wt(this, K, pn).call(this, {
                hasSelectedEditor: !0
              });
            }
            setSelected(k) {
              for (const H of ke(this, b))
                H !== k && H.unselect();
              ke(this, b).clear(), ke(this, b).add(k), k.select(), wt(this, z, zn).call(this, k.propertiesToUpdate), wt(this, K, pn).call(this, {
                hasSelectedEditor: !0
              });
            }
            isSelected(k) {
              return ke(this, b).has(k);
            }
            unselect(k) {
              k.unselect(), ke(this, b).delete(k), wt(this, K, pn).call(this, {
                hasSelectedEditor: this.hasSelection
              });
            }
            get hasSelection() {
              return ke(this, b).size !== 0;
            }
            undo() {
              ke(this, w).undo(), wt(this, K, pn).call(this, {
                hasSomethingToUndo: ke(this, w).hasSomethingToUndo(),
                hasSomethingToRedo: !0,
                isEmpty: wt(this, Z, Gn).call(this)
              });
            }
            redo() {
              ke(this, w).redo(), wt(this, K, pn).call(this, {
                hasSomethingToUndo: !0,
                hasSomethingToRedo: ke(this, w).hasSomethingToRedo(),
                isEmpty: wt(this, Z, Gn).call(this)
              });
            }
            addCommands(k) {
              ke(this, w).add(k), wt(this, K, pn).call(this, {
                hasSomethingToUndo: !0,
                hasSomethingToRedo: !1,
                isEmpty: wt(this, Z, Gn).call(this)
              });
            }
            delete() {
              if (ke(this, f) && ke(this, f).commitOrRemove(), !this.hasSelection)
                return;
              const k = [...ke(this, b)], H = () => {
                for (const ae of k)
                  ae.remove();
              }, ne = () => {
                for (const ae of k)
                  wt(this, q, gi).call(this, ae);
              };
              this.addCommands({
                cmd: H,
                undo: ne,
                mustExec: !0
              });
            }
            copy() {
              if (ke(this, f) && ke(this, f).commitOrRemove(), this.hasSelection) {
                const k = [];
                for (const H of ke(this, b))
                  H.isEmpty() || k.push(H);
                if (k.length === 0)
                  return;
                ke(this, p).copy(k), wt(this, K, pn).call(this, {
                  hasEmptyClipboard: !1
                });
              }
            }
            cut() {
              this.copy(), this.delete();
            }
            paste() {
              if (ke(this, p).isEmpty())
                return;
              this.unselectAll();
              const k = ke(this, C).get(ke(this, X)), H = ke(this, p).paste().map((he) => k.deserialize(he)), ne = () => {
                for (const he of H)
                  wt(this, q, gi).call(this, he);
                wt(this, te, Jn).call(this, H);
              }, ae = () => {
                for (const he of H)
                  he.remove();
              };
              this.addCommands({
                cmd: ne,
                undo: ae,
                mustExec: !0
              });
            }
            selectAll() {
              for (const k of ke(this, b))
                k.commit();
              wt(this, te, Jn).call(this, ke(this, m).values());
            }
            unselectAll() {
              if (ke(this, f)) {
                ke(this, f).commitOrRemove();
                return;
              }
              if (wt(this, te, Jn).size !== 0) {
                for (const k of ke(this, b))
                  k.unselect();
                ke(this, b).clear(), wt(this, K, pn).call(this, {
                  hasSelectedEditor: !1
                });
              }
            }
            isActive(k) {
              return ke(this, f) === k;
            }
            getActive() {
              return ke(this, f);
            }
            getMode() {
              return ke(this, D);
            }
          };
          let a = ee;
          f = new WeakMap(), m = new WeakMap(), C = new WeakMap(), p = new WeakMap(), w = new WeakMap(), X = new WeakMap(), M = new WeakMap(), j = new WeakMap(), B = new WeakMap(), R = new WeakMap(), D = new WeakMap(), b = new WeakMap(), l = new WeakMap(), _ = new WeakMap(), S = new WeakMap(), A = new WeakMap(), F = new WeakMap(), T = new WeakSet(), Mi = function() {
            ke(this, F).addEventListener("keydown", ke(this, l));
          }, U = new WeakSet(), fi = function() {
            ke(this, F).removeEventListener("keydown", ke(this, l));
          }, K = new WeakSet(), pn = function(k) {
            Object.entries(k).some(([ne, ae]) => ke(this, A)[ne] !== ae) && ke(this, j).dispatch("annotationeditorstateschanged", {
              source: this,
              details: Object.assign(ke(this, A), k)
            });
          }, z = new WeakSet(), zn = function(k) {
            ke(this, j).dispatch("annotationeditorparamschanged", {
              source: this,
              details: k
            });
          }, L = new WeakSet(), Bi = function() {
            if (!ke(this, R)) {
              Tt(this, R, !0);
              for (const k of ke(this, C).values())
                k.enable();
            }
          }, J = new WeakSet(), Li = function() {
            if (this.unselectAll(), ke(this, R)) {
              Tt(this, R, !1);
              for (const k of ke(this, C).values())
                k.disable();
            }
          }, q = new WeakSet(), gi = function(k) {
            const H = ke(this, C).get(k.pageIndex);
            H ? H.addOrRebuild(k) : this.addEditor(k);
          }, Z = new WeakSet(), Gn = function() {
            if (ke(this, m).size === 0)
              return !0;
            if (ke(this, m).size === 1)
              for (const k of ke(this, m).values())
                return k.isEmpty();
            return !1;
          }, te = new WeakSet(), Jn = function(k) {
            ke(this, b).clear();
            for (const H of k)
              H.isEmpty() || (ke(this, b).add(H), H.select());
            wt(this, K, pn).call(this, {
              hasSelectedEditor: !0
            });
          }, sn(a, "_keyboardManager", new t([[["ctrl+a", "mac+meta+a"], ee.prototype.selectAll], [["ctrl+c", "mac+meta+c"], ee.prototype.copy], [["ctrl+v", "mac+meta+v"], ee.prototype.paste], [["ctrl+x", "mac+meta+x"], ee.prototype.cut], [["ctrl+z", "mac+meta+z"], ee.prototype.undo], [["ctrl+y", "ctrl+shift+Z", "mac+meta+shift+Z"], ee.prototype.redo], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete"], ee.prototype.delete], [["Escape", "mac+Escape"], ee.prototype.unselectAll]])), ge.AnnotationEditorUIManager = a;
        },
        /* 8 */
        /***/
        (Ee, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.StatTimer = ge.RenderingCancelledException = ge.PixelsPerInch = ge.PageViewport = ge.PDFDateString = ge.DOMStandardFontDataFactory = ge.DOMSVGFactory = ge.DOMCanvasFactory = ge.DOMCMapReaderFactory = ge.AnnotationPrefix = void 0, ge.deprecated = x, ge.getColorValues = w, ge.getCurrentTransform = X, ge.getCurrentTransformInverse = M, ge.getFilenameFromUrl = g, ge.getPdfFilenameFromUrl = d, ge.getRGB = p, ge.getXfaPageViewport = C, ge.isDataScheme = r, ge.isPdfFile = h, ge.isValidFetchUrl = n, ge.loadScript = o;
          var de = le(9), oe = le(1);
          const se = "http://www.w3.org/2000/svg", Q = "pdfjs_internal_id_";
          ge.AnnotationPrefix = Q;
          const j = class {
          };
          let u = j;
          sn(u, "CSS", 96), sn(u, "PDF", 72), sn(u, "PDF_TO_CSS_UNITS", j.CSS / j.PDF), ge.PixelsPerInch = u;
          class P extends de.BaseCanvasFactory {
            constructor({
              ownerDocument: R = globalThis.document
            } = {}) {
              super(), this._document = R;
            }
            _createCanvas(R, D) {
              const b = this._document.createElement("canvas");
              return b.width = R, b.height = D, b;
            }
          }
          ge.DOMCanvasFactory = P;
          async function t(B, R = !1) {
            if (n(B, document.baseURI)) {
              const D = await fetch(B);
              if (!D.ok)
                throw new Error(D.statusText);
              return R ? new Uint8Array(await D.arrayBuffer()) : (0, oe.stringToBytes)(await D.text());
            }
            return new Promise((D, b) => {
              const l = new XMLHttpRequest();
              l.open("GET", B, !0), R && (l.responseType = "arraybuffer"), l.onreadystatechange = () => {
                if (l.readyState === XMLHttpRequest.DONE) {
                  if (l.status === 200 || l.status === 0) {
                    let _;
                    if (R && l.response ? _ = new Uint8Array(l.response) : !R && l.responseText && (_ = (0, oe.stringToBytes)(l.responseText)), _) {
                      D(_);
                      return;
                    }
                  }
                  b(new Error(l.statusText));
                }
              }, l.send(null);
            });
          }
          class i extends de.BaseCMapReaderFactory {
            _fetchData(R, D) {
              return t(R, this.isCompressed).then((b) => ({
                cMapData: b,
                compressionType: D
              }));
            }
          }
          ge.DOMCMapReaderFactory = i;
          class v extends de.BaseStandardFontDataFactory {
            _fetchData(R) {
              return t(R, !0);
            }
          }
          ge.DOMStandardFontDataFactory = v;
          class a extends de.BaseSVGFactory {
            _createSVG(R) {
              return document.createElementNS(se, R);
            }
          }
          ge.DOMSVGFactory = a;
          class e {
            constructor({
              viewBox: R,
              scale: D,
              rotation: b,
              offsetX: l = 0,
              offsetY: _ = 0,
              dontFlip: S = !1
            }) {
              this.viewBox = R, this.scale = D, this.rotation = b, this.offsetX = l, this.offsetY = _;
              const A = (R[2] + R[0]) / 2, F = (R[3] + R[1]) / 2;
              let T, O, U, G;
              switch (b %= 360, b < 0 && (b += 360), b) {
                case 180:
                  T = -1, O = 0, U = 0, G = 1;
                  break;
                case 90:
                  T = 0, O = 1, U = 1, G = 0;
                  break;
                case 270:
                  T = 0, O = -1, U = -1, G = 0;
                  break;
                case 0:
                  T = 1, O = 0, U = 0, G = -1;
                  break;
                default:
                  throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
              }
              S && (U = -U, G = -G);
              let K, W, z, V;
              T === 0 ? (K = Math.abs(F - R[1]) * D + l, W = Math.abs(A - R[0]) * D + _, z = Math.abs(R[3] - R[1]) * D, V = Math.abs(R[2] - R[0]) * D) : (K = Math.abs(A - R[0]) * D + l, W = Math.abs(F - R[1]) * D + _, z = Math.abs(R[2] - R[0]) * D, V = Math.abs(R[3] - R[1]) * D), this.transform = [T * D, O * D, U * D, G * D, K - T * D * A - U * D * F, W - O * D * A - G * D * F], this.width = z, this.height = V;
            }
            clone({
              scale: R = this.scale,
              rotation: D = this.rotation,
              offsetX: b = this.offsetX,
              offsetY: l = this.offsetY,
              dontFlip: _ = !1
            } = {}) {
              return new e({
                viewBox: this.viewBox.slice(),
                scale: R,
                rotation: D,
                offsetX: b,
                offsetY: l,
                dontFlip: _
              });
            }
            convertToViewportPoint(R, D) {
              return oe.Util.applyTransform([R, D], this.transform);
            }
            convertToViewportRectangle(R) {
              const D = oe.Util.applyTransform([R[0], R[1]], this.transform), b = oe.Util.applyTransform([R[2], R[3]], this.transform);
              return [D[0], D[1], b[0], b[1]];
            }
            convertToPdfPoint(R, D) {
              return oe.Util.applyInverseTransform([R, D], this.transform);
            }
          }
          ge.PageViewport = e;
          class y extends oe.BaseException {
            constructor(R, D) {
              super(R, "RenderingCancelledException"), this.type = D;
            }
          }
          ge.RenderingCancelledException = y;
          function r(B) {
            const R = B.length;
            let D = 0;
            for (; D < R && B[D].trim() === ""; )
              D++;
            return B.substring(D, D + 5).toLowerCase() === "data:";
          }
          function h(B) {
            return typeof B == "string" && /\.pdf$/i.test(B);
          }
          function g(B) {
            const R = B.indexOf("#"), D = B.indexOf("?"), b = Math.min(R > 0 ? R : B.length, D > 0 ? D : B.length);
            return B.substring(B.lastIndexOf("/", b) + 1, b);
          }
          function d(B, R = "document.pdf") {
            if (typeof B != "string")
              return R;
            if (r(B))
              return (0, oe.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.'), R;
            const D = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/, b = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i, l = D.exec(B);
            let _ = b.exec(l[1]) || b.exec(l[2]) || b.exec(l[3]);
            if (_ && (_ = _[0], _.includes("%")))
              try {
                _ = b.exec(decodeURIComponent(_))[0];
              } catch {
              }
            return _ || R;
          }
          class c {
            constructor() {
              this.started = /* @__PURE__ */ Object.create(null), this.times = [];
            }
            time(R) {
              R in this.started && (0, oe.warn)(`Timer is already running for ${R}`), this.started[R] = Date.now();
            }
            timeEnd(R) {
              R in this.started || (0, oe.warn)(`Timer has not been started for ${R}`), this.times.push({
                name: R,
                start: this.started[R],
                end: Date.now()
              }), delete this.started[R];
            }
            toString() {
              const R = [];
              let D = 0;
              for (const b of this.times) {
                const l = b.name;
                l.length > D && (D = l.length);
              }
              for (const b of this.times) {
                const l = b.end - b.start;
                R.push(`${b.name.padEnd(D)} ${l}ms
`);
              }
              return R.join("");
            }
          }
          ge.StatTimer = c;
          function n(B, R) {
            try {
              const {
                protocol: D
              } = R ? new URL(B, R) : new URL(B);
              return D === "http:" || D === "https:";
            } catch {
              return !1;
            }
          }
          function o(B, R = !1) {
            return new Promise((D, b) => {
              const l = document.createElement("script");
              l.src = B, l.onload = function(_) {
                R && l.remove(), D(_);
              }, l.onerror = function() {
                b(new Error(`Cannot load script at: ${l.src}`));
              }, (document.head || document.documentElement).append(l);
            });
          }
          function x(B) {
            console.log("Deprecated API usage: " + B);
          }
          let f;
          class m {
            static toDateObject(R) {
              if (!R || typeof R != "string")
                return null;
              f || (f = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"));
              const D = f.exec(R);
              if (!D)
                return null;
              const b = parseInt(D[1], 10);
              let l = parseInt(D[2], 10);
              l = l >= 1 && l <= 12 ? l - 1 : 0;
              let _ = parseInt(D[3], 10);
              _ = _ >= 1 && _ <= 31 ? _ : 1;
              let S = parseInt(D[4], 10);
              S = S >= 0 && S <= 23 ? S : 0;
              let A = parseInt(D[5], 10);
              A = A >= 0 && A <= 59 ? A : 0;
              let F = parseInt(D[6], 10);
              F = F >= 0 && F <= 59 ? F : 0;
              const T = D[7] || "Z";
              let O = parseInt(D[8], 10);
              O = O >= 0 && O <= 23 ? O : 0;
              let U = parseInt(D[9], 10) || 0;
              return U = U >= 0 && U <= 59 ? U : 0, T === "-" ? (S += O, A += U) : T === "+" && (S -= O, A -= U), new Date(Date.UTC(b, l, _, S, A, F));
            }
          }
          ge.PDFDateString = m;
          function C(B, {
            scale: R = 1,
            rotation: D = 0
          }) {
            const {
              width: b,
              height: l
            } = B.attributes.style, _ = [0, 0, parseInt(b), parseInt(l)];
            return new e({
              viewBox: _,
              scale: R,
              rotation: D
            });
          }
          function p(B) {
            if (B.startsWith("#")) {
              const R = parseInt(B.slice(1), 16);
              return [(R & 16711680) >> 16, (R & 65280) >> 8, R & 255];
            }
            return B.startsWith("rgb(") ? B.slice(4, -1).split(",").map((R) => parseInt(R)) : B.startsWith("rgba(") ? B.slice(5, -1).split(",").map((R) => parseInt(R)).slice(0, 3) : ((0, oe.warn)(`Not a valid color format: "${B}"`), [0, 0, 0]);
          }
          function w(B) {
            const R = document.createElement("span");
            R.style.visibility = "hidden", document.body.append(R);
            for (const D of B.keys()) {
              R.style.color = D;
              const b = window.getComputedStyle(R).color;
              B.set(D, p(b));
            }
            R.remove();
          }
          function X(B) {
            const {
              a: R,
              b: D,
              c: b,
              d: l,
              e: _,
              f: S
            } = B.getTransform();
            return [R, D, b, l, _, S];
          }
          function M(B) {
            const {
              a: R,
              b: D,
              c: b,
              d: l,
              e: _,
              f: S
            } = B.getTransform().invertSelf();
            return [R, D, b, l, _, S];
          }
        },
        /* 9 */
        /***/
        (Ee, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.BaseStandardFontDataFactory = ge.BaseSVGFactory = ge.BaseCanvasFactory = ge.BaseCMapReaderFactory = void 0;
          var de = le(1);
          class oe {
            constructor() {
              this.constructor === oe && (0, de.unreachable)("Cannot initialize BaseCanvasFactory.");
            }
            create(t, i) {
              if (t <= 0 || i <= 0)
                throw new Error("Invalid canvas size");
              const v = this._createCanvas(t, i);
              return {
                canvas: v,
                context: v.getContext("2d")
              };
            }
            reset(t, i, v) {
              if (!t.canvas)
                throw new Error("Canvas is not specified");
              if (i <= 0 || v <= 0)
                throw new Error("Invalid canvas size");
              t.canvas.width = i, t.canvas.height = v;
            }
            destroy(t) {
              if (!t.canvas)
                throw new Error("Canvas is not specified");
              t.canvas.width = 0, t.canvas.height = 0, t.canvas = null, t.context = null;
            }
            _createCanvas(t, i) {
              (0, de.unreachable)("Abstract method `_createCanvas` called.");
            }
          }
          ge.BaseCanvasFactory = oe;
          class se {
            constructor({
              baseUrl: t = null,
              isCompressed: i = !1
            }) {
              this.constructor === se && (0, de.unreachable)("Cannot initialize BaseCMapReaderFactory."), this.baseUrl = t, this.isCompressed = i;
            }
            async fetch({
              name: t
            }) {
              if (!this.baseUrl)
                throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');
              if (!t)
                throw new Error("CMap name must be specified.");
              const i = this.baseUrl + t + (this.isCompressed ? ".bcmap" : ""), v = this.isCompressed ? de.CMapCompressionType.BINARY : de.CMapCompressionType.NONE;
              return this._fetchData(i, v).catch((a) => {
                throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${i}`);
              });
            }
            _fetchData(t, i) {
              (0, de.unreachable)("Abstract method `_fetchData` called.");
            }
          }
          ge.BaseCMapReaderFactory = se;
          class Q {
            constructor({
              baseUrl: t = null
            }) {
              this.constructor === Q && (0, de.unreachable)("Cannot initialize BaseStandardFontDataFactory."), this.baseUrl = t;
            }
            async fetch({
              filename: t
            }) {
              if (!this.baseUrl)
                throw new Error('The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.');
              if (!t)
                throw new Error("Font filename must be specified.");
              const i = `${this.baseUrl}${t}`;
              return this._fetchData(i).catch((v) => {
                throw new Error(`Unable to load font data at: ${i}`);
              });
            }
            _fetchData(t) {
              (0, de.unreachable)("Abstract method `_fetchData` called.");
            }
          }
          ge.BaseStandardFontDataFactory = Q;
          class u {
            constructor() {
              this.constructor === u && (0, de.unreachable)("Cannot initialize BaseSVGFactory.");
            }
            create(t, i, v = !1) {
              if (t <= 0 || i <= 0)
                throw new Error("Invalid SVG dimensions");
              const a = this._createSVG("svg:svg");
              return a.setAttribute("version", "1.1"), v || (a.setAttribute("width", `${t}px`), a.setAttribute("height", `${i}px`)), a.setAttribute("preserveAspectRatio", "none"), a.setAttribute("viewBox", `0 0 ${t} ${i}`), a;
            }
            createElement(t) {
              if (typeof t != "string")
                throw new Error("Invalid SVG element type");
              return this._createSVG(t);
            }
            _createSVG(t) {
              (0, de.unreachable)("Abstract method `_createSVG` called.");
            }
          }
          ge.BaseSVGFactory = u;
        },
        /* 10 */
        /***/
        (Ee, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.MurmurHash3_64 = void 0;
          var de = le(1);
          const oe = 3285377520, se = 4294901760, Q = 65535;
          class u {
            constructor(t) {
              this.h1 = t ? t & 4294967295 : oe, this.h2 = t ? t & 4294967295 : oe;
            }
            update(t) {
              let i, v;
              if (typeof t == "string") {
                i = new Uint8Array(t.length * 2), v = 0;
                for (let f = 0, m = t.length; f < m; f++) {
                  const C = t.charCodeAt(f);
                  C <= 255 ? i[v++] = C : (i[v++] = C >>> 8, i[v++] = C & 255);
                }
              } else if ((0, de.isArrayBuffer)(t))
                i = t.slice(), v = i.byteLength;
              else
                throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");
              const a = v >> 2, e = v - a * 4, y = new Uint32Array(i.buffer, 0, a);
              let r = 0, h = 0, g = this.h1, d = this.h2;
              const c = 3432918353, n = 461845907, o = c & Q, x = n & Q;
              for (let f = 0; f < a; f++)
                f & 1 ? (r = y[f], r = r * c & se | r * o & Q, r = r << 15 | r >>> 17, r = r * n & se | r * x & Q, g ^= r, g = g << 13 | g >>> 19, g = g * 5 + 3864292196) : (h = y[f], h = h * c & se | h * o & Q, h = h << 15 | h >>> 17, h = h * n & se | h * x & Q, d ^= h, d = d << 13 | d >>> 19, d = d * 5 + 3864292196);
              switch (r = 0, e) {
                case 3:
                  r ^= i[a * 4 + 2] << 16;
                case 2:
                  r ^= i[a * 4 + 1] << 8;
                case 1:
                  r ^= i[a * 4], r = r * c & se | r * o & Q, r = r << 15 | r >>> 17, r = r * n & se | r * x & Q, a & 1 ? g ^= r : d ^= r;
              }
              this.h1 = g, this.h2 = d;
            }
            hexdigest() {
              let t = this.h1, i = this.h2;
              t ^= i >>> 1, t = t * 3981806797 & se | t * 36045 & Q, i = i * 4283543511 & se | ((i << 16 | t >>> 16) * 2950163797 & se) >>> 16, t ^= i >>> 1, t = t * 444984403 & se | t * 60499 & Q, i = i * 3301882366 & se | ((i << 16 | t >>> 16) * 3120437893 & se) >>> 16, t ^= i >>> 1;
              const v = (t >>> 0).toString(16), a = (i >>> 0).toString(16);
              return v.padStart(8, "0") + a.padStart(8, "0");
            }
          }
          ge.MurmurHash3_64 = u;
        },
        /* 11 */
        /***/
        (Ee, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.FontLoader = ge.FontFaceObject = void 0;
          var de = le(1);
          class oe {
            constructor({
              docId: P,
              onUnsupportedFeature: t,
              ownerDocument: i = globalThis.document,
              styleElement: v = null
            }) {
              this.constructor === oe && (0, de.unreachable)("Cannot initialize BaseFontLoader."), this.docId = P, this._onUnsupportedFeature = t, this._document = i, this.nativeFontFaces = [], this.styleElement = null;
            }
            addNativeFontFace(P) {
              this.nativeFontFaces.push(P), this._document.fonts.add(P);
            }
            insertRule(P) {
              let t = this.styleElement;
              t || (t = this.styleElement = this._document.createElement("style"), t.id = `PDFJS_FONT_STYLE_TAG_${this.docId}`, this._document.documentElement.getElementsByTagName("head")[0].append(t));
              const i = t.sheet;
              i.insertRule(P, i.cssRules.length);
            }
            clear() {
              for (const P of this.nativeFontFaces)
                this._document.fonts.delete(P);
              this.nativeFontFaces.length = 0, this.styleElement && (this.styleElement.remove(), this.styleElement = null);
            }
            async bind(P) {
              if (P.attached || P.missingFile)
                return;
              if (P.attached = !0, this.isFontLoadingAPISupported) {
                const i = P.createNativeFontFace();
                if (i) {
                  this.addNativeFontFace(i);
                  try {
                    await i.loaded;
                  } catch (v) {
                    throw this._onUnsupportedFeature({
                      featureId: de.UNSUPPORTED_FEATURES.errorFontLoadNative
                    }), (0, de.warn)(`Failed to load font '${i.family}': '${v}'.`), P.disableFontFace = !0, v;
                  }
                }
                return;
              }
              const t = P.createFontFaceRule();
              if (t) {
                if (this.insertRule(t), this.isSyncFontLoadingSupported)
                  return;
                await new Promise((i) => {
                  const v = this._queueLoadingCallback(i);
                  this._prepareFontLoadEvent([t], [P], v);
                });
              }
            }
            _queueLoadingCallback(P) {
              (0, de.unreachable)("Abstract method `_queueLoadingCallback`.");
            }
            get isFontLoadingAPISupported() {
              var t;
              const P = !!((t = this._document) != null && t.fonts);
              return (0, de.shadow)(this, "isFontLoadingAPISupported", P);
            }
            get isSyncFontLoadingSupported() {
              (0, de.unreachable)("Abstract method `isSyncFontLoadingSupported`.");
            }
            get _loadTestFont() {
              (0, de.unreachable)("Abstract method `_loadTestFont`.");
            }
            _prepareFontLoadEvent(P, t, i) {
              (0, de.unreachable)("Abstract method `_prepareFontLoadEvent`.");
            }
          }
          let se;
          ge.FontLoader = se, ge.FontLoader = se = class extends oe {
            constructor(P) {
              super(P), this.loadingContext = {
                requests: [],
                nextRequestId: 0
              }, this.loadTestFontId = 0;
            }
            get isSyncFontLoadingSupported() {
              let P = !1;
              if (typeof navigator > "u")
                P = !0;
              else {
                const t = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(navigator.userAgent);
                (t == null ? void 0 : t[1]) >= 14 && (P = !0);
              }
              return (0, de.shadow)(this, "isSyncFontLoadingSupported", P);
            }
            _queueLoadingCallback(P) {
              function t() {
                for ((0, de.assert)(!v.done, "completeRequest() cannot be called twice."), v.done = !0; i.requests.length > 0 && i.requests[0].done; ) {
                  const a = i.requests.shift();
                  setTimeout(a.callback, 0);
                }
              }
              const i = this.loadingContext, v = {
                id: `pdfjs-font-loading-${i.nextRequestId++}`,
                done: !1,
                complete: t,
                callback: P
              };
              return i.requests.push(v), v;
            }
            get _loadTestFont() {
              const P = function() {
                return atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
              };
              return (0, de.shadow)(this, "_loadTestFont", P());
            }
            _prepareFontLoadEvent(P, t, i) {
              function v(M, j) {
                return M.charCodeAt(j) << 24 | M.charCodeAt(j + 1) << 16 | M.charCodeAt(j + 2) << 8 | M.charCodeAt(j + 3) & 255;
              }
              function a(M, j, B, R) {
                const D = M.substring(0, j), b = M.substring(j + B);
                return D + R + b;
              }
              let e, y;
              const r = this._document.createElement("canvas");
              r.width = 1, r.height = 1;
              const h = r.getContext("2d");
              let g = 0;
              function d(M, j) {
                if (g++, g > 30) {
                  (0, de.warn)("Load test font never loaded."), j();
                  return;
                }
                if (h.font = "30px " + M, h.fillText(".", 0, 20), h.getImageData(0, 0, 1, 1).data[3] > 0) {
                  j();
                  return;
                }
                setTimeout(d.bind(null, M, j));
              }
              const c = `lt${Date.now()}${this.loadTestFontId++}`;
              let n = this._loadTestFont;
              n = a(n, 976, c.length, c);
              const x = 16, f = 1482184792;
              let m = v(n, x);
              for (e = 0, y = c.length - 3; e < y; e += 4)
                m = m - f + v(c, e) | 0;
              e < c.length && (m = m - f + v(c + "XXX", e) | 0), n = a(n, x, 4, (0, de.string32)(m));
              const C = `url(data:font/opentype;base64,${btoa(n)});`, p = `@font-face {font-family:"${c}";src:${C}}`;
              this.insertRule(p);
              const w = [];
              for (const M of t)
                w.push(M.loadedName);
              w.push(c);
              const X = this._document.createElement("div");
              X.style.visibility = "hidden", X.style.width = X.style.height = "10px", X.style.position = "absolute", X.style.top = X.style.left = "0px";
              for (const M of w) {
                const j = this._document.createElement("span");
                j.textContent = "Hi", j.style.fontFamily = M, X.append(j);
              }
              this._document.body.append(X), d(c, () => {
                X.remove(), i.complete();
              });
            }
          };
          class Q {
            constructor(P, {
              isEvalSupported: t = !0,
              disableFontFace: i = !1,
              ignoreErrors: v = !1,
              onUnsupportedFeature: a,
              fontRegistry: e = null
            }) {
              this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
              for (const y in P)
                this[y] = P[y];
              this.isEvalSupported = t !== !1, this.disableFontFace = i === !0, this.ignoreErrors = v === !0, this._onUnsupportedFeature = a, this.fontRegistry = e;
            }
            createNativeFontFace() {
              if (!this.data || this.disableFontFace)
                return null;
              let P;
              if (!this.cssFontInfo)
                P = new FontFace(this.loadedName, this.data, {});
              else {
                const t = {
                  weight: this.cssFontInfo.fontWeight
                };
                this.cssFontInfo.italicAngle && (t.style = `oblique ${this.cssFontInfo.italicAngle}deg`), P = new FontFace(this.cssFontInfo.fontFamily, this.data, t);
              }
              return this.fontRegistry && this.fontRegistry.registerFont(this), P;
            }
            createFontFaceRule() {
              if (!this.data || this.disableFontFace)
                return null;
              const P = (0, de.bytesToString)(this.data), t = `url(data:${this.mimetype};base64,${btoa(P)});`;
              let i;
              if (!this.cssFontInfo)
                i = `@font-face {font-family:"${this.loadedName}";src:${t}}`;
              else {
                let v = `font-weight: ${this.cssFontInfo.fontWeight};`;
                this.cssFontInfo.italicAngle && (v += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`), i = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${v}src:${t}}`;
              }
              return this.fontRegistry && this.fontRegistry.registerFont(this, t), i;
            }
            getPathGenerator(P, t) {
              if (this.compiledGlyphs[t] !== void 0)
                return this.compiledGlyphs[t];
              let i;
              try {
                i = P.get(this.loadedName + "_path_" + t);
              } catch (v) {
                if (!this.ignoreErrors)
                  throw v;
                return this._onUnsupportedFeature({
                  featureId: de.UNSUPPORTED_FEATURES.errorFontGetPath
                }), (0, de.warn)(`getPathGenerator - ignoring character: "${v}".`), this.compiledGlyphs[t] = function(a, e) {
                };
              }
              if (this.isEvalSupported && de.FeatureTest.isEvalSupported) {
                const v = [];
                for (const a of i) {
                  const e = a.args !== void 0 ? a.args.join(",") : "";
                  v.push("c.", a.cmd, "(", e, `);
`);
                }
                return this.compiledGlyphs[t] = new Function("c", "size", v.join(""));
              }
              return this.compiledGlyphs[t] = function(v, a) {
                for (const e of i)
                  e.cmd === "scale" && (e.args = [a, -a]), v[e.cmd].apply(v, e.args);
              };
            }
          }
          ge.FontFaceObject = Q;
        },
        /* 12 */
        /***/
        (Ee, ge, le) => {
          var l, pi;
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.CanvasGraphics = void 0;
          var de = le(8), oe = le(1), se = le(13), Q = le(14), u = le(3);
          const P = 16, t = 100, i = 4096, v = 15, a = 10, e = u.isNodeJS && typeof Path2D > "u" ? -1 : 1e3, y = 16;
          function r(A, F) {
            if (A._removeMirroring)
              throw new Error("Context is already forwarding operations.");
            A.__originalSave = A.save, A.__originalRestore = A.restore, A.__originalRotate = A.rotate, A.__originalScale = A.scale, A.__originalTranslate = A.translate, A.__originalTransform = A.transform, A.__originalSetTransform = A.setTransform, A.__originalResetTransform = A.resetTransform, A.__originalClip = A.clip, A.__originalMoveTo = A.moveTo, A.__originalLineTo = A.lineTo, A.__originalBezierCurveTo = A.bezierCurveTo, A.__originalRect = A.rect, A.__originalClosePath = A.closePath, A.__originalBeginPath = A.beginPath, A._removeMirroring = () => {
              A.save = A.__originalSave, A.restore = A.__originalRestore, A.rotate = A.__originalRotate, A.scale = A.__originalScale, A.translate = A.__originalTranslate, A.transform = A.__originalTransform, A.setTransform = A.__originalSetTransform, A.resetTransform = A.__originalResetTransform, A.clip = A.__originalClip, A.moveTo = A.__originalMoveTo, A.lineTo = A.__originalLineTo, A.bezierCurveTo = A.__originalBezierCurveTo, A.rect = A.__originalRect, A.closePath = A.__originalClosePath, A.beginPath = A.__originalBeginPath, delete A._removeMirroring;
            }, A.save = function() {
              F.save(), this.__originalSave();
            }, A.restore = function() {
              F.restore(), this.__originalRestore();
            }, A.translate = function(O, U) {
              F.translate(O, U), this.__originalTranslate(O, U);
            }, A.scale = function(O, U) {
              F.scale(O, U), this.__originalScale(O, U);
            }, A.transform = function(O, U, G, K, W, z) {
              F.transform(O, U, G, K, W, z), this.__originalTransform(O, U, G, K, W, z);
            }, A.setTransform = function(O, U, G, K, W, z) {
              F.setTransform(O, U, G, K, W, z), this.__originalSetTransform(O, U, G, K, W, z);
            }, A.resetTransform = function() {
              F.resetTransform(), this.__originalResetTransform();
            }, A.rotate = function(O) {
              F.rotate(O), this.__originalRotate(O);
            }, A.clip = function(O) {
              F.clip(O), this.__originalClip(O);
            }, A.moveTo = function(T, O) {
              F.moveTo(T, O), this.__originalMoveTo(T, O);
            }, A.lineTo = function(T, O) {
              F.lineTo(T, O), this.__originalLineTo(T, O);
            }, A.bezierCurveTo = function(T, O, U, G, K, W) {
              F.bezierCurveTo(T, O, U, G, K, W), this.__originalBezierCurveTo(T, O, U, G, K, W);
            }, A.rect = function(T, O, U, G) {
              F.rect(T, O, U, G), this.__originalRect(T, O, U, G);
            }, A.closePath = function() {
              F.closePath(), this.__originalClosePath();
            }, A.beginPath = function() {
              F.beginPath(), this.__originalBeginPath();
            };
          }
          class h {
            constructor(F) {
              this.canvasFactory = F, this.cache = /* @__PURE__ */ Object.create(null);
            }
            getCanvas(F, T, O) {
              let U;
              return this.cache[F] !== void 0 ? (U = this.cache[F], this.canvasFactory.reset(U, T, O)) : (U = this.canvasFactory.create(T, O), this.cache[F] = U), U;
            }
            delete(F) {
              delete this.cache[F];
            }
            clear() {
              for (const F in this.cache) {
                const T = this.cache[F];
                this.canvasFactory.destroy(T), delete this.cache[F];
              }
            }
          }
          function g(A, F, T, O, U, G, K, W, z, V) {
            const [L, Y, J, ie, q, N] = (0, de.getCurrentTransform)(A);
            if (Y === 0 && J === 0) {
              const te = K * L + q, re = Math.round(te), ee = W * ie + N, $ = Math.round(ee), k = (K + z) * L + q, H = Math.abs(Math.round(k) - re) || 1, ne = (W + V) * ie + N, ae = Math.abs(Math.round(ne) - $) || 1;
              return A.setTransform(Math.sign(L), 0, 0, Math.sign(ie), re, $), A.drawImage(F, T, O, U, G, 0, 0, H, ae), A.setTransform(L, Y, J, ie, q, N), [H, ae];
            }
            if (L === 0 && ie === 0) {
              const te = W * J + q, re = Math.round(te), ee = K * Y + N, $ = Math.round(ee), k = (W + V) * J + q, H = Math.abs(Math.round(k) - re) || 1, ne = (K + z) * Y + N, ae = Math.abs(Math.round(ne) - $) || 1;
              return A.setTransform(0, Math.sign(Y), Math.sign(J), 0, re, $), A.drawImage(F, T, O, U, G, 0, 0, ae, H), A.setTransform(L, Y, J, ie, q, N), [ae, H];
            }
            A.drawImage(F, T, O, U, G, K, W, z, V);
            const Z = Math.hypot(L, Y), E = Math.hypot(J, ie);
            return [Z * z, E * V];
          }
          function d(A) {
            const {
              width: F,
              height: T
            } = A;
            if (F > e || T > e)
              return null;
            const O = 1e3, U = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]), G = F + 1;
            let K = new Uint8Array(G * (T + 1)), W, z, V;
            const L = F + 7 & -8;
            let Y = new Uint8Array(L * T), J = 0;
            for (const E of A.data) {
              let te = 128;
              for (; te > 0; )
                Y[J++] = E & te ? 0 : 255, te >>= 1;
            }
            let ie = 0;
            for (J = 0, Y[J] !== 0 && (K[0] = 1, ++ie), z = 1; z < F; z++)
              Y[J] !== Y[J + 1] && (K[z] = Y[J] ? 2 : 1, ++ie), J++;
            for (Y[J] !== 0 && (K[z] = 2, ++ie), W = 1; W < T; W++) {
              J = W * L, V = W * G, Y[J - L] !== Y[J] && (K[V] = Y[J] ? 1 : 8, ++ie);
              let E = (Y[J] ? 4 : 0) + (Y[J - L] ? 8 : 0);
              for (z = 1; z < F; z++)
                E = (E >> 2) + (Y[J + 1] ? 4 : 0) + (Y[J - L + 1] ? 8 : 0), U[E] && (K[V + z] = U[E], ++ie), J++;
              if (Y[J - L] !== Y[J] && (K[V + z] = Y[J] ? 2 : 4, ++ie), ie > O)
                return null;
            }
            for (J = L * (T - 1), V = W * G, Y[J] !== 0 && (K[V] = 8, ++ie), z = 1; z < F; z++)
              Y[J] !== Y[J + 1] && (K[V + z] = Y[J] ? 4 : 8, ++ie), J++;
            if (Y[J] !== 0 && (K[V + z] = 4, ++ie), ie > O)
              return null;
            const q = new Int32Array([0, G, -1, 0, -G, 0, 0, 0, 1]), N = new Path2D();
            for (W = 0; ie && W <= T; W++) {
              let E = W * G;
              const te = E + F;
              for (; E < te && !K[E]; )
                E++;
              if (E === te)
                continue;
              N.moveTo(E % G, W);
              const re = E;
              let ee = K[E];
              do {
                const $ = q[ee];
                do
                  E += $;
                while (!K[E]);
                const k = K[E];
                k !== 5 && k !== 10 ? (ee = k, K[E] = 0) : (ee = k & 51 * ee >> 4, K[E] &= ee >> 2 | ee << 2), N.lineTo(E % G, E / G | 0), K[E] || --ie;
              } while (re !== E);
              --W;
            }
            return Y = null, K = null, function(E) {
              E.save(), E.scale(1 / F, -1 / T), E.translate(0, -T), E.fill(N), E.beginPath(), E.restore();
            };
          }
          class c {
            constructor(F, T) {
              this.alphaIsShape = !1, this.fontSize = 0, this.fontSizeScale = 1, this.textMatrix = oe.IDENTITY_MATRIX, this.textMatrixScale = 1, this.fontMatrix = oe.FONT_IDENTITY_MATRIX, this.leading = 0, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRenderingMode = oe.TextRenderingMode.FILL, this.textRise = 0, this.fillColor = "#000000", this.strokeColor = "#000000", this.patternFill = !1, this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.activeSMask = null, this.transferMaps = null, this.startNewPathAndClipBox([0, 0, F, T]);
            }
            clone() {
              const F = Object.create(this);
              return F.clipBox = this.clipBox.slice(), F;
            }
            setCurrentPoint(F, T) {
              this.x = F, this.y = T;
            }
            updatePathMinMax(F, T, O) {
              [T, O] = oe.Util.applyTransform([T, O], F), this.minX = Math.min(this.minX, T), this.minY = Math.min(this.minY, O), this.maxX = Math.max(this.maxX, T), this.maxY = Math.max(this.maxY, O);
            }
            updateRectMinMax(F, T) {
              const O = oe.Util.applyTransform(T, F), U = oe.Util.applyTransform(T.slice(2), F);
              this.minX = Math.min(this.minX, O[0], U[0]), this.minY = Math.min(this.minY, O[1], U[1]), this.maxX = Math.max(this.maxX, O[0], U[0]), this.maxY = Math.max(this.maxY, O[1], U[1]);
            }
            updateScalingPathMinMax(F, T) {
              oe.Util.scaleMinMax(F, T), this.minX = Math.min(this.minX, T[0]), this.maxX = Math.max(this.maxX, T[1]), this.minY = Math.min(this.minY, T[2]), this.maxY = Math.max(this.maxY, T[3]);
            }
            updateCurvePathMinMax(F, T, O, U, G, K, W, z, V, L) {
              const Y = oe.Util.bezierBoundingBox(T, O, U, G, K, W, z, V);
              if (L) {
                L[0] = Math.min(L[0], Y[0], Y[2]), L[1] = Math.max(L[1], Y[0], Y[2]), L[2] = Math.min(L[2], Y[1], Y[3]), L[3] = Math.max(L[3], Y[1], Y[3]);
                return;
              }
              this.updateRectMinMax(F, Y);
            }
            getPathBoundingBox(F = se.PathType.FILL, T = null) {
              const O = [this.minX, this.minY, this.maxX, this.maxY];
              if (F === se.PathType.STROKE) {
                T || (0, oe.unreachable)("Stroke bounding box must include transform.");
                const U = oe.Util.singularValueDecompose2dScale(T), G = U[0] * this.lineWidth / 2, K = U[1] * this.lineWidth / 2;
                O[0] -= G, O[1] -= K, O[2] += G, O[3] += K;
              }
              return O;
            }
            updateClipFromPath() {
              const F = oe.Util.intersect(this.clipBox, this.getPathBoundingBox());
              this.startNewPathAndClipBox(F || [0, 0, 0, 0]);
            }
            isEmptyClip() {
              return this.minX === 1 / 0;
            }
            startNewPathAndClipBox(F) {
              this.clipBox = F, this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = 0, this.maxY = 0;
            }
            getClippedPathBoundingBox(F = se.PathType.FILL, T = null) {
              return oe.Util.intersect(this.clipBox, this.getPathBoundingBox(F, T));
            }
          }
          function n(A, F, T = null) {
            if (typeof ImageData < "u" && F instanceof ImageData) {
              A.putImageData(F, 0, 0);
              return;
            }
            const O = F.height, U = F.width, G = O % y, K = (O - G) / y, W = G === 0 ? K : K + 1, z = A.createImageData(U, y);
            let V = 0, L;
            const Y = F.data, J = z.data;
            let ie, q, N, Z, E, te, re, ee;
            if (T)
              switch (T.length) {
                case 1:
                  E = T[0], te = T[0], re = T[0], ee = T[0];
                  break;
                case 4:
                  E = T[0], te = T[1], re = T[2], ee = T[3];
                  break;
              }
            if (F.kind === oe.ImageKind.GRAYSCALE_1BPP) {
              const $ = Y.byteLength, k = new Uint32Array(J.buffer, 0, J.byteLength >> 2), H = k.length, ne = U + 7 >> 3;
              let ae = 4294967295, he = oe.FeatureTest.isLittleEndian ? 4278190080 : 255;
              for (ee && ee[0] === 255 && ee[255] === 0 && ([ae, he] = [he, ae]), ie = 0; ie < W; ie++) {
                for (N = ie < K ? y : G, L = 0, q = 0; q < N; q++) {
                  const ue = $ - V;
                  let fe = 0;
                  const me = ue > ne ? U : ue * 8 - 7, Fe = me & -8;
                  let we = 0, Ae = 0;
                  for (; fe < Fe; fe += 8)
                    Ae = Y[V++], k[L++] = Ae & 128 ? ae : he, k[L++] = Ae & 64 ? ae : he, k[L++] = Ae & 32 ? ae : he, k[L++] = Ae & 16 ? ae : he, k[L++] = Ae & 8 ? ae : he, k[L++] = Ae & 4 ? ae : he, k[L++] = Ae & 2 ? ae : he, k[L++] = Ae & 1 ? ae : he;
                  for (; fe < me; fe++)
                    we === 0 && (Ae = Y[V++], we = 128), k[L++] = Ae & we ? ae : he, we >>= 1;
                }
                for (; L < H; )
                  k[L++] = 0;
                A.putImageData(z, 0, ie * y);
              }
            } else if (F.kind === oe.ImageKind.RGBA_32BPP) {
              const $ = !!(E || te || re);
              for (q = 0, Z = U * y * 4, ie = 0; ie < K; ie++) {
                if (J.set(Y.subarray(V, V + Z)), V += Z, $)
                  for (let k = 0; k < Z; k += 4)
                    E && (J[k + 0] = E[J[k + 0]]), te && (J[k + 1] = te[J[k + 1]]), re && (J[k + 2] = re[J[k + 2]]);
                A.putImageData(z, 0, q), q += y;
              }
              if (ie < W) {
                if (Z = U * G * 4, J.set(Y.subarray(V, V + Z)), $)
                  for (let k = 0; k < Z; k += 4)
                    E && (J[k + 0] = E[J[k + 0]]), te && (J[k + 1] = te[J[k + 1]]), re && (J[k + 2] = re[J[k + 2]]);
                A.putImageData(z, 0, q);
              }
            } else if (F.kind === oe.ImageKind.RGB_24BPP) {
              const $ = !!(E || te || re);
              for (N = y, Z = U * N, ie = 0; ie < W; ie++) {
                for (ie >= K && (N = G, Z = U * N), L = 0, q = Z; q--; )
                  J[L++] = Y[V++], J[L++] = Y[V++], J[L++] = Y[V++], J[L++] = 255;
                if ($)
                  for (let k = 0; k < L; k += 4)
                    E && (J[k + 0] = E[J[k + 0]]), te && (J[k + 1] = te[J[k + 1]]), re && (J[k + 2] = re[J[k + 2]]);
                A.putImageData(z, 0, ie * y);
              }
            } else
              throw new Error(`bad image kind: ${F.kind}`);
          }
          function o(A, F) {
            if (F.bitmap) {
              A.drawImage(F.bitmap, 0, 0);
              return;
            }
            const T = F.height, O = F.width, U = T % y, G = (T - U) / y, K = U === 0 ? G : G + 1, W = A.createImageData(O, y);
            let z = 0;
            const V = F.data, L = W.data;
            for (let Y = 0; Y < K; Y++) {
              const J = Y < G ? y : U;
              ({
                srcPos: z
              } = (0, Q.applyMaskImageData)({
                src: V,
                srcPos: z,
                dest: L,
                width: O,
                height: J
              })), A.putImageData(W, 0, Y * y);
            }
          }
          function x(A, F) {
            const T = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font"];
            for (let O = 0, U = T.length; O < U; O++) {
              const G = T[O];
              A[G] !== void 0 && (F[G] = A[G]);
            }
            A.setLineDash !== void 0 && (F.setLineDash(A.getLineDash()), F.lineDashOffset = A.lineDashOffset);
          }
          function f(A, F) {
            A.strokeStyle = A.fillStyle = F || "#000000", A.fillRule = "nonzero", A.globalAlpha = 1, A.lineWidth = 1, A.lineCap = "butt", A.lineJoin = "miter", A.miterLimit = 10, A.globalCompositeOperation = "source-over", A.font = "10px sans-serif", A.setLineDash !== void 0 && (A.setLineDash([]), A.lineDashOffset = 0);
          }
          function m(A, F, T, O) {
            const U = A.length;
            for (let G = 3; G < U; G += 4) {
              const K = A[G];
              if (K === 0)
                A[G - 3] = F, A[G - 2] = T, A[G - 1] = O;
              else if (K < 255) {
                const W = 255 - K;
                A[G - 3] = A[G - 3] * K + F * W >> 8, A[G - 2] = A[G - 2] * K + T * W >> 8, A[G - 1] = A[G - 1] * K + O * W >> 8;
              }
            }
          }
          function C(A, F, T) {
            const O = A.length, U = 1 / 255;
            for (let G = 3; G < O; G += 4) {
              const K = T ? T[A[G]] : A[G];
              F[G] = F[G] * K * U | 0;
            }
          }
          function p(A, F, T) {
            const O = A.length;
            for (let U = 3; U < O; U += 4) {
              const G = A[U - 3] * 77 + A[U - 2] * 152 + A[U - 1] * 28;
              F[U] = T ? F[U] * T[G >> 8] >> 8 : F[U] * G >> 16;
            }
          }
          function w(A, F, T, O, U, G, K, W, z, V, L) {
            const Y = !!G, J = Y ? G[0] : 0, ie = Y ? G[1] : 0, q = Y ? G[2] : 0;
            let N;
            U === "Luminosity" ? N = p : N = C;
            const E = Math.min(O, Math.ceil(1048576 / T));
            for (let te = 0; te < O; te += E) {
              const re = Math.min(E, O - te), ee = A.getImageData(W - V, te + (z - L), T, re), $ = F.getImageData(W, te + z, T, re);
              Y && m(ee.data, J, ie, q), N(ee.data, $.data, K), F.putImageData($, W, te + z);
            }
          }
          function X(A, F, T, O) {
            const U = O[0], G = O[1], K = O[2] - U, W = O[3] - G;
            K === 0 || W === 0 || (w(F.context, T, K, W, F.subtype, F.backdrop, F.transferMap, U, G, F.offsetX, F.offsetY), A.save(), A.globalAlpha = 1, A.globalCompositeOperation = "source-over", A.setTransform(1, 0, 0, 1, 0, 0), A.drawImage(T.canvas, 0, 0), A.restore());
          }
          function M(A, F) {
            const T = oe.Util.singularValueDecompose2dScale(A);
            T[0] = Math.fround(T[0]), T[1] = Math.fround(T[1]);
            const O = Math.fround((globalThis.devicePixelRatio || 1) * de.PixelsPerInch.PDF_TO_CSS_UNITS);
            return F !== void 0 ? F : T[0] <= O || T[1] <= O;
          }
          const j = ["butt", "round", "square"], B = ["miter", "round", "bevel"], R = {}, D = {}, S = class {
            constructor(F, T, O, U, G, K, W, z) {
              ft(this, l);
              this.ctx = F, this.current = new c(this.ctx.canvas.width, this.ctx.canvas.height), this.stateStack = [], this.pendingClip = null, this.pendingEOFill = !1, this.res = null, this.xobjs = null, this.commonObjs = T, this.objs = O, this.canvasFactory = U, this.imageLayer = G, this.groupStack = [], this.processingType3 = null, this.baseTransform = null, this.baseTransformStack = [], this.groupLevel = 0, this.smaskStack = [], this.smaskCounter = 0, this.tempSMask = null, this.suspendedCtx = null, this.contentVisible = !0, this.markedContentStack = [], this.optionalContentConfig = K, this.cachedCanvases = new h(this.canvasFactory), this.cachedPatterns = /* @__PURE__ */ new Map(), this.annotationCanvasMap = W, this.viewportScale = 1, this.outputScaleX = 1, this.outputScaleY = 1, this.backgroundColor = (z == null ? void 0 : z.background) || null, this.foregroundColor = (z == null ? void 0 : z.foreground) || null, this._cachedScaleForStroking = null, this._cachedGetSinglePixelWidth = null, this._cachedBitmapsMap = /* @__PURE__ */ new Map();
            }
            getObject(F, T = null) {
              return typeof F == "string" ? F.startsWith("g_") ? this.commonObjs.get(F) : this.objs.get(F) : T;
            }
            beginDrawing({
              transform: F,
              viewport: T,
              transparency: O = !1,
              background: U = null
            }) {
              const G = this.ctx.canvas.width, K = this.ctx.canvas.height, W = U || "#ffffff";
              if (this.ctx.save(), this.foregroundColor && this.backgroundColor) {
                this.ctx.fillStyle = this.foregroundColor;
                const z = this.foregroundColor = this.ctx.fillStyle;
                this.ctx.fillStyle = this.backgroundColor;
                const V = this.backgroundColor = this.ctx.fillStyle;
                let L = !0, Y = W;
                if (this.ctx.fillStyle = W, Y = this.ctx.fillStyle, L = typeof Y == "string" && /^#[0-9A-Fa-f]{6}$/.test(Y), z === "#000000" && V === "#ffffff" || z === V || !L)
                  this.foregroundColor = this.backgroundColor = null;
                else {
                  const [J, ie, q] = (0, de.getRGB)(Y), N = (E) => (E /= 255, E <= 0.03928 ? E / 12.92 : ((E + 0.055) / 1.055) ** 2.4), Z = Math.round(0.2126 * N(J) + 0.7152 * N(ie) + 0.0722 * N(q));
                  this.selectColor = (E, te, re) => {
                    const ee = 0.2126 * N(E) + 0.7152 * N(te) + 0.0722 * N(re);
                    return Math.round(ee) === Z ? V : z;
                  };
                }
              }
              if (this.ctx.fillStyle = this.backgroundColor || W, this.ctx.fillRect(0, 0, G, K), this.ctx.restore(), O) {
                const z = this.cachedCanvases.getCanvas("transparent", G, K);
                this.compositeCtx = this.ctx, this.transparentCanvas = z.canvas, this.ctx = z.context, this.ctx.save(), this.ctx.transform(...(0, de.getCurrentTransform)(this.compositeCtx));
              }
              this.ctx.save(), f(this.ctx, this.foregroundColor), F && (this.ctx.transform(...F), this.outputScaleX = F[0], this.outputScaleY = F[0]), this.ctx.transform(...T.transform), this.viewportScale = T.scale, this.baseTransform = (0, de.getCurrentTransform)(this.ctx), this.imageLayer && ((0, de.deprecated)("The `imageLayer` functionality will be removed in the future."), this.imageLayer.beginLayout());
            }
            executeOperatorList(F, T, O, U) {
              const G = F.argsArray, K = F.fnArray;
              let W = T || 0;
              const z = G.length;
              if (z === W)
                return W;
              const V = z - W > a && typeof O == "function", L = V ? Date.now() + v : 0;
              let Y = 0;
              const J = this.commonObjs, ie = this.objs;
              let q;
              for (; ; ) {
                if (U !== void 0 && W === U.nextBreakPoint)
                  return U.breakIt(W, O), W;
                if (q = K[W], q !== oe.OPS.dependency)
                  this[q].apply(this, G[W]);
                else
                  for (const N of G[W]) {
                    const Z = N.startsWith("g_") ? J : ie;
                    if (!Z.has(N))
                      return Z.get(N, O), W;
                  }
                if (W++, W === z)
                  return W;
                if (V && ++Y > a) {
                  if (Date.now() > L)
                    return O(), W;
                  Y = 0;
                }
              }
            }
            endDrawing() {
              wt(this, l, pi).call(this), this.cachedCanvases.clear(), this.cachedPatterns.clear();
              for (const F of this._cachedBitmapsMap.values()) {
                for (const T of F.values())
                  typeof HTMLCanvasElement < "u" && T instanceof HTMLCanvasElement && (T.width = T.height = 0);
                F.clear();
              }
              this._cachedBitmapsMap.clear(), this.imageLayer && this.imageLayer.endLayout();
            }
            _scaleImage(F, T) {
              const O = F.width, U = F.height;
              let G = Math.max(Math.hypot(T[0], T[1]), 1), K = Math.max(Math.hypot(T[2], T[3]), 1), W = O, z = U, V = "prescale1", L, Y;
              for (; G > 2 && W > 1 || K > 2 && z > 1; ) {
                let J = W, ie = z;
                G > 2 && W > 1 && (J = Math.ceil(W / 2), G /= W / J), K > 2 && z > 1 && (ie = Math.ceil(z / 2), K /= z / ie), L = this.cachedCanvases.getCanvas(V, J, ie), Y = L.context, Y.clearRect(0, 0, J, ie), Y.drawImage(F, 0, 0, W, z, 0, 0, J, ie), F = L.canvas, W = J, z = ie, V = V === "prescale1" ? "prescale2" : "prescale1";
              }
              return {
                img: F,
                paintWidth: W,
                paintHeight: z
              };
            }
            _createMaskCanvas(F) {
              const T = this.ctx, {
                width: O,
                height: U
              } = F, G = this.current.fillColor, K = this.current.patternFill, W = (0, de.getCurrentTransform)(T);
              let z, V, L, Y;
              if ((F.bitmap || F.data) && F.count > 1) {
                const H = F.bitmap || F.data.buffer, ne = W.slice(0, 4);
                V = JSON.stringify(K ? ne : [ne, G]), z = this._cachedBitmapsMap.get(H), z || (z = /* @__PURE__ */ new Map(), this._cachedBitmapsMap.set(H, z));
                const ae = z.get(V);
                if (ae && !K) {
                  const he = Math.round(Math.min(W[0], W[2]) + W[4]), ue = Math.round(Math.min(W[1], W[3]) + W[5]);
                  return {
                    canvas: ae,
                    offsetX: he,
                    offsetY: ue
                  };
                }
                L = ae;
              }
              L || (Y = this.cachedCanvases.getCanvas("maskCanvas", O, U), o(Y.context, F));
              let J = oe.Util.transform(W, [1 / O, 0, 0, -1 / U, 0, 0]);
              J = oe.Util.transform(J, [1, 0, 0, 1, 0, -U]);
              const ie = oe.Util.applyTransform([0, 0], J), q = oe.Util.applyTransform([O, U], J), N = oe.Util.normalizeRect([ie[0], ie[1], q[0], q[1]]), Z = Math.round(N[2] - N[0]) || 1, E = Math.round(N[3] - N[1]) || 1, te = this.cachedCanvases.getCanvas("fillCanvas", Z, E), re = te.context, ee = Math.min(ie[0], q[0]), $ = Math.min(ie[1], q[1]);
              re.translate(-ee, -$), re.transform(...J), L || (L = this._scaleImage(Y.canvas, (0, de.getCurrentTransformInverse)(re)), L = L.img, z && K && z.set(V, L)), re.imageSmoothingEnabled = M((0, de.getCurrentTransform)(re), F.interpolate), g(re, L, 0, 0, L.width, L.height, 0, 0, O, U), re.globalCompositeOperation = "source-in";
              const k = oe.Util.transform((0, de.getCurrentTransformInverse)(re), [1, 0, 0, 1, -ee, -$]);
              return re.fillStyle = K ? G.getPattern(T, this, k, se.PathType.FILL) : G, re.fillRect(0, 0, O, U), z && !K && (this.cachedCanvases.delete("fillCanvas"), z.set(V, te.canvas)), {
                canvas: te.canvas,
                offsetX: Math.round(ee),
                offsetY: Math.round($)
              };
            }
            setLineWidth(F) {
              F !== this.current.lineWidth && (this._cachedScaleForStroking = null), this.current.lineWidth = F, this.ctx.lineWidth = F;
            }
            setLineCap(F) {
              this.ctx.lineCap = j[F];
            }
            setLineJoin(F) {
              this.ctx.lineJoin = B[F];
            }
            setMiterLimit(F) {
              this.ctx.miterLimit = F;
            }
            setDash(F, T) {
              const O = this.ctx;
              O.setLineDash !== void 0 && (O.setLineDash(F), O.lineDashOffset = T);
            }
            setRenderingIntent(F) {
            }
            setFlatness(F) {
            }
            setGState(F) {
              for (let T = 0, O = F.length; T < O; T++) {
                const U = F[T], G = U[0], K = U[1];
                switch (G) {
                  case "LW":
                    this.setLineWidth(K);
                    break;
                  case "LC":
                    this.setLineCap(K);
                    break;
                  case "LJ":
                    this.setLineJoin(K);
                    break;
                  case "ML":
                    this.setMiterLimit(K);
                    break;
                  case "D":
                    this.setDash(K[0], K[1]);
                    break;
                  case "RI":
                    this.setRenderingIntent(K);
                    break;
                  case "FL":
                    this.setFlatness(K);
                    break;
                  case "Font":
                    this.setFont(K[0], K[1]);
                    break;
                  case "CA":
                    this.current.strokeAlpha = U[1];
                    break;
                  case "ca":
                    this.current.fillAlpha = U[1], this.ctx.globalAlpha = U[1];
                    break;
                  case "BM":
                    this.ctx.globalCompositeOperation = K;
                    break;
                  case "SMask":
                    this.current.activeSMask = K ? this.tempSMask : null, this.tempSMask = null, this.checkSMaskState();
                    break;
                  case "TR":
                    this.current.transferMaps = K;
                }
              }
            }
            get inSMaskMode() {
              return !!this.suspendedCtx;
            }
            checkSMaskState() {
              const F = this.inSMaskMode;
              this.current.activeSMask && !F ? this.beginSMaskMode() : !this.current.activeSMask && F && this.endSMaskMode();
            }
            beginSMaskMode() {
              if (this.inSMaskMode)
                throw new Error("beginSMaskMode called while already in smask mode");
              const F = this.ctx.canvas.width, T = this.ctx.canvas.height, O = "smaskGroupAt" + this.groupLevel, U = this.cachedCanvases.getCanvas(O, F, T);
              this.suspendedCtx = this.ctx, this.ctx = U.context;
              const G = this.ctx;
              G.setTransform(...(0, de.getCurrentTransform)(this.suspendedCtx)), x(this.suspendedCtx, G), r(G, this.suspendedCtx), this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
            }
            endSMaskMode() {
              if (!this.inSMaskMode)
                throw new Error("endSMaskMode called while not in smask mode");
              this.ctx._removeMirroring(), x(this.ctx, this.suspendedCtx), this.ctx = this.suspendedCtx, this.suspendedCtx = null;
            }
            compose(F) {
              if (!this.current.activeSMask)
                return;
              F ? (F[0] = Math.floor(F[0]), F[1] = Math.floor(F[1]), F[2] = Math.ceil(F[2]), F[3] = Math.ceil(F[3])) : F = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
              const T = this.current.activeSMask, O = this.suspendedCtx;
              X(O, T, this.ctx, F), this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height), this.ctx.restore();
            }
            save() {
              this.inSMaskMode ? (x(this.ctx, this.suspendedCtx), this.suspendedCtx.save()) : this.ctx.save();
              const F = this.current;
              this.stateStack.push(F), this.current = F.clone();
            }
            restore() {
              this.stateStack.length === 0 && this.inSMaskMode && this.endSMaskMode(), this.stateStack.length !== 0 && (this.current = this.stateStack.pop(), this.inSMaskMode ? (this.suspendedCtx.restore(), x(this.suspendedCtx, this.ctx)) : this.ctx.restore(), this.checkSMaskState(), this.pendingClip = null, this._cachedScaleForStroking = null, this._cachedGetSinglePixelWidth = null);
            }
            transform(F, T, O, U, G, K) {
              this.ctx.transform(F, T, O, U, G, K), this._cachedScaleForStroking = null, this._cachedGetSinglePixelWidth = null;
            }
            constructPath(F, T, O) {
              const U = this.ctx, G = this.current;
              let K = G.x, W = G.y, z, V;
              const L = (0, de.getCurrentTransform)(U), Y = L[0] === 0 && L[3] === 0 || L[1] === 0 && L[2] === 0, J = Y ? O.slice(0) : null;
              for (let ie = 0, q = 0, N = F.length; ie < N; ie++)
                switch (F[ie] | 0) {
                  case oe.OPS.rectangle:
                    K = T[q++], W = T[q++];
                    const Z = T[q++], E = T[q++], te = K + Z, re = W + E;
                    U.moveTo(K, W), Z === 0 || E === 0 ? U.lineTo(te, re) : (U.lineTo(te, W), U.lineTo(te, re), U.lineTo(K, re)), Y || G.updateRectMinMax(L, [K, W, te, re]), U.closePath();
                    break;
                  case oe.OPS.moveTo:
                    K = T[q++], W = T[q++], U.moveTo(K, W), Y || G.updatePathMinMax(L, K, W);
                    break;
                  case oe.OPS.lineTo:
                    K = T[q++], W = T[q++], U.lineTo(K, W), Y || G.updatePathMinMax(L, K, W);
                    break;
                  case oe.OPS.curveTo:
                    z = K, V = W, K = T[q + 4], W = T[q + 5], U.bezierCurveTo(T[q], T[q + 1], T[q + 2], T[q + 3], K, W), G.updateCurvePathMinMax(L, z, V, T[q], T[q + 1], T[q + 2], T[q + 3], K, W, J), q += 6;
                    break;
                  case oe.OPS.curveTo2:
                    z = K, V = W, U.bezierCurveTo(K, W, T[q], T[q + 1], T[q + 2], T[q + 3]), G.updateCurvePathMinMax(L, z, V, K, W, T[q], T[q + 1], T[q + 2], T[q + 3], J), K = T[q + 2], W = T[q + 3], q += 4;
                    break;
                  case oe.OPS.curveTo3:
                    z = K, V = W, K = T[q + 2], W = T[q + 3], U.bezierCurveTo(T[q], T[q + 1], K, W, K, W), G.updateCurvePathMinMax(L, z, V, T[q], T[q + 1], K, W, K, W, J), q += 4;
                    break;
                  case oe.OPS.closePath:
                    U.closePath();
                    break;
                }
              Y && G.updateScalingPathMinMax(L, J), G.setCurrentPoint(K, W);
            }
            closePath() {
              this.ctx.closePath();
            }
            stroke(F) {
              F = typeof F < "u" ? F : !0;
              const T = this.ctx, O = this.current.strokeColor;
              T.globalAlpha = this.current.strokeAlpha, this.contentVisible && (typeof O == "object" && (O != null && O.getPattern) ? (T.save(), T.strokeStyle = O.getPattern(T, this, (0, de.getCurrentTransformInverse)(T), se.PathType.STROKE), this.rescaleAndStroke(!1), T.restore()) : this.rescaleAndStroke(!0)), F && this.consumePath(this.current.getClippedPathBoundingBox()), T.globalAlpha = this.current.fillAlpha;
            }
            closeStroke() {
              this.closePath(), this.stroke();
            }
            fill(F) {
              F = typeof F < "u" ? F : !0;
              const T = this.ctx, O = this.current.fillColor, U = this.current.patternFill;
              let G = !1;
              U && (T.save(), T.fillStyle = O.getPattern(T, this, (0, de.getCurrentTransformInverse)(T), se.PathType.FILL), G = !0);
              const K = this.current.getClippedPathBoundingBox();
              this.contentVisible && K !== null && (this.pendingEOFill ? (T.fill("evenodd"), this.pendingEOFill = !1) : T.fill()), G && T.restore(), F && this.consumePath(K);
            }
            eoFill() {
              this.pendingEOFill = !0, this.fill();
            }
            fillStroke() {
              this.fill(!1), this.stroke(!1), this.consumePath();
            }
            eoFillStroke() {
              this.pendingEOFill = !0, this.fillStroke();
            }
            closeFillStroke() {
              this.closePath(), this.fillStroke();
            }
            closeEOFillStroke() {
              this.pendingEOFill = !0, this.closePath(), this.fillStroke();
            }
            endPath() {
              this.consumePath();
            }
            clip() {
              this.pendingClip = R;
            }
            eoClip() {
              this.pendingClip = D;
            }
            beginText() {
              this.current.textMatrix = oe.IDENTITY_MATRIX, this.current.textMatrixScale = 1, this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
            }
            endText() {
              const F = this.pendingTextPaths, T = this.ctx;
              if (F === void 0) {
                T.beginPath();
                return;
              }
              T.save(), T.beginPath();
              for (const O of F)
                T.setTransform(...O.transform), T.translate(O.x, O.y), O.addToPath(T, O.fontSize);
              T.restore(), T.clip(), T.beginPath(), delete this.pendingTextPaths;
            }
            setCharSpacing(F) {
              this.current.charSpacing = F;
            }
            setWordSpacing(F) {
              this.current.wordSpacing = F;
            }
            setHScale(F) {
              this.current.textHScale = F / 100;
            }
            setLeading(F) {
              this.current.leading = -F;
            }
            setFont(F, T) {
              const O = this.commonObjs.get(F), U = this.current;
              if (!O)
                throw new Error(`Can't find font for ${F}`);
              if (U.fontMatrix = O.fontMatrix || oe.FONT_IDENTITY_MATRIX, (U.fontMatrix[0] === 0 || U.fontMatrix[3] === 0) && (0, oe.warn)("Invalid font matrix for font " + F), T < 0 ? (T = -T, U.fontDirection = -1) : U.fontDirection = 1, this.current.font = O, this.current.fontSize = T, O.isType3Font)
                return;
              const G = O.loadedName || "sans-serif";
              let K = "normal";
              O.black ? K = "900" : O.bold && (K = "bold");
              const W = O.italic ? "italic" : "normal", z = `"${G}", ${O.fallbackName}`;
              let V = T;
              T < P ? V = P : T > t && (V = t), this.current.fontSizeScale = T / V, this.ctx.font = `${W} ${K} ${V}px ${z}`;
            }
            setTextRenderingMode(F) {
              this.current.textRenderingMode = F;
            }
            setTextRise(F) {
              this.current.textRise = F;
            }
            moveText(F, T) {
              this.current.x = this.current.lineX += F, this.current.y = this.current.lineY += T;
            }
            setLeadingMoveText(F, T) {
              this.setLeading(-T), this.moveText(F, T);
            }
            setTextMatrix(F, T, O, U, G, K) {
              this.current.textMatrix = [F, T, O, U, G, K], this.current.textMatrixScale = Math.hypot(F, T), this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
            }
            nextLine() {
              this.moveText(0, this.current.leading);
            }
            paintChar(F, T, O, U) {
              const G = this.ctx, K = this.current, W = K.font, z = K.textRenderingMode, V = K.fontSize / K.fontSizeScale, L = z & oe.TextRenderingMode.FILL_STROKE_MASK, Y = !!(z & oe.TextRenderingMode.ADD_TO_PATH_FLAG), J = K.patternFill && !W.missingFile;
              let ie;
              (W.disableFontFace || Y || J) && (ie = W.getPathGenerator(this.commonObjs, F)), W.disableFontFace || J ? (G.save(), G.translate(T, O), G.beginPath(), ie(G, V), U && G.setTransform(...U), (L === oe.TextRenderingMode.FILL || L === oe.TextRenderingMode.FILL_STROKE) && G.fill(), (L === oe.TextRenderingMode.STROKE || L === oe.TextRenderingMode.FILL_STROKE) && G.stroke(), G.restore()) : ((L === oe.TextRenderingMode.FILL || L === oe.TextRenderingMode.FILL_STROKE) && G.fillText(F, T, O), (L === oe.TextRenderingMode.STROKE || L === oe.TextRenderingMode.FILL_STROKE) && G.strokeText(F, T, O)), Y && (this.pendingTextPaths || (this.pendingTextPaths = [])).push({
                transform: (0, de.getCurrentTransform)(G),
                x: T,
                y: O,
                fontSize: V,
                addToPath: ie
              });
            }
            get isFontSubpixelAAEnabled() {
              const {
                context: F
              } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
              F.scale(1.5, 1), F.fillText("I", 0, 10);
              const T = F.getImageData(0, 0, 10, 10).data;
              let O = !1;
              for (let U = 3; U < T.length; U += 4)
                if (T[U] > 0 && T[U] < 255) {
                  O = !0;
                  break;
                }
              return (0, oe.shadow)(this, "isFontSubpixelAAEnabled", O);
            }
            showText(F) {
              const T = this.current, O = T.font;
              if (O.isType3Font)
                return this.showType3Text(F);
              const U = T.fontSize;
              if (U === 0)
                return;
              const G = this.ctx, K = T.fontSizeScale, W = T.charSpacing, z = T.wordSpacing, V = T.fontDirection, L = T.textHScale * V, Y = F.length, J = O.vertical, ie = J ? 1 : -1, q = O.defaultVMetrics, N = U * T.fontMatrix[0], Z = T.textRenderingMode === oe.TextRenderingMode.FILL && !O.disableFontFace && !T.patternFill;
              G.save(), G.transform(...T.textMatrix), G.translate(T.x, T.y + T.textRise), V > 0 ? G.scale(L, -1) : G.scale(L, 1);
              let E;
              if (T.patternFill) {
                G.save();
                const k = T.fillColor.getPattern(G, this, (0, de.getCurrentTransformInverse)(G), se.PathType.FILL);
                E = (0, de.getCurrentTransform)(G), G.restore(), G.fillStyle = k;
              }
              let te = T.lineWidth;
              const re = T.textMatrixScale;
              if (re === 0 || te === 0) {
                const k = T.textRenderingMode & oe.TextRenderingMode.FILL_STROKE_MASK;
                (k === oe.TextRenderingMode.STROKE || k === oe.TextRenderingMode.FILL_STROKE) && (te = this.getSinglePixelWidth());
              } else
                te /= re;
              K !== 1 && (G.scale(K, K), te /= K), G.lineWidth = te;
              let ee = 0, $;
              for ($ = 0; $ < Y; ++$) {
                const k = F[$];
                if (typeof k == "number") {
                  ee += ie * k * U / 1e3;
                  continue;
                }
                let H = !1;
                const ne = (k.isSpace ? z : 0) + W, ae = k.fontChar, he = k.accent;
                let ue, fe, me = k.width;
                if (J) {
                  const we = k.vmetric || q, Ae = -(k.vmetric ? we[1] : me * 0.5) * N, De = we[2] * N;
                  me = we ? -we[0] : me, ue = Ae / K, fe = (ee + De) / K;
                } else
                  ue = ee / K, fe = 0;
                if (O.remeasure && me > 0) {
                  const we = G.measureText(ae).width * 1e3 / U * K;
                  if (me < we && this.isFontSubpixelAAEnabled) {
                    const Ae = me / we;
                    H = !0, G.save(), G.scale(Ae, 1), ue /= Ae;
                  } else
                    me !== we && (ue += (me - we) / 2e3 * U / K);
                }
                if (this.contentVisible && (k.isInFont || O.missingFile)) {
                  if (Z && !he)
                    G.fillText(ae, ue, fe);
                  else if (this.paintChar(ae, ue, fe, E), he) {
                    const we = ue + U * he.offset.x / K, Ae = fe - U * he.offset.y / K;
                    this.paintChar(he.fontChar, we, Ae, E);
                  }
                }
                let Fe;
                J ? Fe = me * N - ne * V : Fe = me * N + ne * V, ee += Fe, H && G.restore();
              }
              J ? T.y -= ee : T.x += ee * L, G.restore(), this.compose();
            }
            showType3Text(F) {
              const T = this.ctx, O = this.current, U = O.font, G = O.fontSize, K = O.fontDirection, W = U.vertical ? 1 : -1, z = O.charSpacing, V = O.wordSpacing, L = O.textHScale * K, Y = O.fontMatrix || oe.FONT_IDENTITY_MATRIX, J = F.length, ie = O.textRenderingMode === oe.TextRenderingMode.INVISIBLE;
              let q, N, Z, E;
              if (!(ie || G === 0)) {
                for (this._cachedScaleForStroking = null, this._cachedGetSinglePixelWidth = null, T.save(), T.transform(...O.textMatrix), T.translate(O.x, O.y), T.scale(L, K), q = 0; q < J; ++q) {
                  if (N = F[q], typeof N == "number") {
                    E = W * N * G / 1e3, this.ctx.translate(E, 0), O.x += E * L;
                    continue;
                  }
                  const te = (N.isSpace ? V : 0) + z, re = U.charProcOperatorList[N.operatorListId];
                  if (!re) {
                    (0, oe.warn)(`Type3 character "${N.operatorListId}" is not available.`);
                    continue;
                  }
                  this.contentVisible && (this.processingType3 = N, this.save(), T.scale(G, G), T.transform(...Y), this.executeOperatorList(re), this.restore()), Z = oe.Util.applyTransform([N.width, 0], Y)[0] * G + te, T.translate(Z, 0), O.x += Z * L;
                }
                T.restore(), this.processingType3 = null;
              }
            }
            setCharWidth(F, T) {
            }
            setCharWidthAndBounds(F, T, O, U, G, K) {
              this.ctx.rect(O, U, G - O, K - U), this.ctx.clip(), this.endPath();
            }
            getColorN_Pattern(F) {
              let T;
              if (F[0] === "TilingPattern") {
                const O = F[1], U = this.baseTransform || (0, de.getCurrentTransform)(this.ctx), G = {
                  createCanvasGraphics: (K) => new S(K, this.commonObjs, this.objs, this.canvasFactory)
                };
                T = new se.TilingPattern(F, O, this.ctx, G, U);
              } else
                T = this._getPattern(F[1], F[2]);
              return T;
            }
            setStrokeColorN() {
              this.current.strokeColor = this.getColorN_Pattern(arguments);
            }
            setFillColorN() {
              this.current.fillColor = this.getColorN_Pattern(arguments), this.current.patternFill = !0;
            }
            setStrokeRGBColor(F, T, O) {
              var G;
              const U = ((G = this.selectColor) == null ? void 0 : G.call(this, F, T, O)) || oe.Util.makeHexColor(F, T, O);
              this.ctx.strokeStyle = U, this.current.strokeColor = U;
            }
            setFillRGBColor(F, T, O) {
              var G;
              const U = ((G = this.selectColor) == null ? void 0 : G.call(this, F, T, O)) || oe.Util.makeHexColor(F, T, O);
              this.ctx.fillStyle = U, this.current.fillColor = U, this.current.patternFill = !1;
            }
            _getPattern(F, T = null) {
              let O;
              return this.cachedPatterns.has(F) ? O = this.cachedPatterns.get(F) : (O = (0, se.getShadingPattern)(this.objs.get(F)), this.cachedPatterns.set(F, O)), T && (O.matrix = T), O;
            }
            shadingFill(F) {
              if (!this.contentVisible)
                return;
              const T = this.ctx;
              this.save();
              const O = this._getPattern(F);
              T.fillStyle = O.getPattern(T, this, (0, de.getCurrentTransformInverse)(T), se.PathType.SHADING);
              const U = (0, de.getCurrentTransformInverse)(T);
              if (U) {
                const G = T.canvas, K = G.width, W = G.height, z = oe.Util.applyTransform([0, 0], U), V = oe.Util.applyTransform([0, W], U), L = oe.Util.applyTransform([K, 0], U), Y = oe.Util.applyTransform([K, W], U), J = Math.min(z[0], V[0], L[0], Y[0]), ie = Math.min(z[1], V[1], L[1], Y[1]), q = Math.max(z[0], V[0], L[0], Y[0]), N = Math.max(z[1], V[1], L[1], Y[1]);
                this.ctx.fillRect(J, ie, q - J, N - ie);
              } else
                this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
              this.compose(this.current.getClippedPathBoundingBox()), this.restore();
            }
            beginInlineImage() {
              (0, oe.unreachable)("Should not call beginInlineImage");
            }
            beginImageData() {
              (0, oe.unreachable)("Should not call beginImageData");
            }
            paintFormXObjectBegin(F, T) {
              if (this.contentVisible && (this.save(), this.baseTransformStack.push(this.baseTransform), Array.isArray(F) && F.length === 6 && this.transform(...F), this.baseTransform = (0, de.getCurrentTransform)(this.ctx), T)) {
                const O = T[2] - T[0], U = T[3] - T[1];
                this.ctx.rect(T[0], T[1], O, U), this.current.updateRectMinMax((0, de.getCurrentTransform)(this.ctx), T), this.clip(), this.endPath();
              }
            }
            paintFormXObjectEnd() {
              this.contentVisible && (this.restore(), this.baseTransform = this.baseTransformStack.pop());
            }
            beginGroup(F) {
              if (!this.contentVisible)
                return;
              this.save(), this.inSMaskMode && (this.endSMaskMode(), this.current.activeSMask = null);
              const T = this.ctx;
              F.isolated || (0, oe.info)("TODO: Support non-isolated groups."), F.knockout && (0, oe.warn)("Knockout groups not supported.");
              const O = (0, de.getCurrentTransform)(T);
              if (F.matrix && T.transform(...F.matrix), !F.bbox)
                throw new Error("Bounding box is required.");
              let U = oe.Util.getAxialAlignedBoundingBox(F.bbox, (0, de.getCurrentTransform)(T));
              const G = [0, 0, T.canvas.width, T.canvas.height];
              U = oe.Util.intersect(U, G) || [0, 0, 0, 0];
              const K = Math.floor(U[0]), W = Math.floor(U[1]);
              let z = Math.max(Math.ceil(U[2]) - K, 1), V = Math.max(Math.ceil(U[3]) - W, 1), L = 1, Y = 1;
              z > i && (L = z / i, z = i), V > i && (Y = V / i, V = i), this.current.startNewPathAndClipBox([0, 0, z, V]);
              let J = "groupAt" + this.groupLevel;
              F.smask && (J += "_smask_" + this.smaskCounter++ % 2);
              const ie = this.cachedCanvases.getCanvas(J, z, V), q = ie.context;
              q.scale(1 / L, 1 / Y), q.translate(-K, -W), q.transform(...O), F.smask ? this.smaskStack.push({
                canvas: ie.canvas,
                context: q,
                offsetX: K,
                offsetY: W,
                scaleX: L,
                scaleY: Y,
                subtype: F.smask.subtype,
                backdrop: F.smask.backdrop,
                transferMap: F.smask.transferMap || null,
                startTransformInverse: null
              }) : (T.setTransform(1, 0, 0, 1, 0, 0), T.translate(K, W), T.scale(L, Y), T.save()), x(T, q), this.ctx = q, this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]), this.groupStack.push(T), this.groupLevel++;
            }
            endGroup(F) {
              if (!this.contentVisible)
                return;
              this.groupLevel--;
              const T = this.ctx, O = this.groupStack.pop();
              if (this.ctx = O, this.ctx.imageSmoothingEnabled = !1, F.smask)
                this.tempSMask = this.smaskStack.pop(), this.restore();
              else {
                this.ctx.restore();
                const U = (0, de.getCurrentTransform)(this.ctx);
                this.restore(), this.ctx.save(), this.ctx.setTransform(...U);
                const G = oe.Util.getAxialAlignedBoundingBox([0, 0, T.canvas.width, T.canvas.height], U);
                this.ctx.drawImage(T.canvas, 0, 0), this.ctx.restore(), this.compose(G);
              }
            }
            beginAnnotation(F, T, O, U, G) {
              if (wt(this, l, pi).call(this), f(this.ctx, this.foregroundColor), this.ctx.save(), this.save(), this.baseTransform && this.ctx.setTransform(...this.baseTransform), Array.isArray(T) && T.length === 4) {
                const K = T[2] - T[0], W = T[3] - T[1];
                if (G && this.annotationCanvasMap) {
                  O = O.slice(), O[4] -= T[0], O[5] -= T[1], T = T.slice(), T[0] = T[1] = 0, T[2] = K, T[3] = W;
                  const [z, V] = oe.Util.singularValueDecompose2dScale((0, de.getCurrentTransform)(this.ctx)), {
                    viewportScale: L
                  } = this, Y = Math.ceil(K * this.outputScaleX * L), J = Math.ceil(W * this.outputScaleY * L);
                  this.annotationCanvas = this.canvasFactory.create(Y, J);
                  const {
                    canvas: ie,
                    context: q
                  } = this.annotationCanvas;
                  this.annotationCanvasMap.set(F, ie), this.annotationCanvas.savedCtx = this.ctx, this.ctx = q, this.ctx.setTransform(z, 0, 0, -V, 0, W * V), f(this.ctx, this.foregroundColor);
                } else
                  f(this.ctx, this.foregroundColor), this.ctx.rect(T[0], T[1], K, W), this.ctx.clip(), this.endPath();
              }
              this.current = new c(this.ctx.canvas.width, this.ctx.canvas.height), this.transform(...O), this.transform(...U);
            }
            endAnnotation() {
              this.annotationCanvas && (this.ctx = this.annotationCanvas.savedCtx, delete this.annotationCanvas.savedCtx, delete this.annotationCanvas);
            }
            paintImageMaskXObject(F) {
              if (!this.contentVisible)
                return;
              const T = F.count;
              F = this.getObject(F.data, F), F.count = T;
              const O = this.ctx, U = this.processingType3;
              if (U && (U.compiled === void 0 && (U.compiled = d(F)), U.compiled)) {
                U.compiled(O);
                return;
              }
              const G = this._createMaskCanvas(F), K = G.canvas;
              O.save(), O.setTransform(1, 0, 0, 1, 0, 0), O.drawImage(K, G.offsetX, G.offsetY), O.restore(), this.compose();
            }
            paintImageMaskXObjectRepeat(F, T, O = 0, U = 0, G, K) {
              if (!this.contentVisible)
                return;
              F = this.getObject(F.data, F);
              const W = this.ctx;
              W.save();
              const z = (0, de.getCurrentTransform)(W);
              W.transform(T, O, U, G, 0, 0);
              const V = this._createMaskCanvas(F);
              W.setTransform(1, 0, 0, 1, 0, 0);
              for (let L = 0, Y = K.length; L < Y; L += 2) {
                const J = oe.Util.transform(z, [T, O, U, G, K[L], K[L + 1]]), [ie, q] = oe.Util.applyTransform([0, 0], J);
                W.drawImage(V.canvas, ie, q);
              }
              W.restore(), this.compose();
            }
            paintImageMaskXObjectGroup(F) {
              if (!this.contentVisible)
                return;
              const T = this.ctx, O = this.current.fillColor, U = this.current.patternFill;
              for (const G of F) {
                const {
                  data: K,
                  width: W,
                  height: z,
                  transform: V
                } = G, L = this.cachedCanvases.getCanvas("maskCanvas", W, z), Y = L.context;
                Y.save();
                const J = this.getObject(K, G);
                o(Y, J), Y.globalCompositeOperation = "source-in", Y.fillStyle = U ? O.getPattern(Y, this, (0, de.getCurrentTransformInverse)(T), se.PathType.FILL) : O, Y.fillRect(0, 0, W, z), Y.restore(), T.save(), T.transform(...V), T.scale(1, -1), g(T, L.canvas, 0, 0, W, z, 0, -1, 1, 1), T.restore();
              }
              this.compose();
            }
            paintImageXObject(F) {
              if (!this.contentVisible)
                return;
              const T = this.getObject(F);
              if (!T) {
                (0, oe.warn)("Dependent image isn't ready yet");
                return;
              }
              this.paintInlineImageXObject(T);
            }
            paintImageXObjectRepeat(F, T, O, U) {
              if (!this.contentVisible)
                return;
              const G = this.getObject(F);
              if (!G) {
                (0, oe.warn)("Dependent image isn't ready yet");
                return;
              }
              const K = G.width, W = G.height, z = [];
              for (let V = 0, L = U.length; V < L; V += 2)
                z.push({
                  transform: [T, 0, 0, O, U[V], U[V + 1]],
                  x: 0,
                  y: 0,
                  w: K,
                  h: W
                });
              this.paintInlineImageXObjectGroup(G, z);
            }
            paintInlineImageXObject(F) {
              if (!this.contentVisible)
                return;
              const T = F.width, O = F.height, U = this.ctx;
              this.save(), U.scale(1 / T, -1 / O);
              let G;
              if (typeof HTMLElement == "function" && F instanceof HTMLElement || !F.data)
                G = F;
              else {
                const V = this.cachedCanvases.getCanvas("inlineImage", T, O), L = V.context;
                n(L, F, this.current.transferMaps), G = V.canvas;
              }
              const K = this._scaleImage(G, (0, de.getCurrentTransformInverse)(U));
              U.imageSmoothingEnabled = M((0, de.getCurrentTransform)(U), F.interpolate);
              const [W, z] = g(U, K.img, 0, 0, K.paintWidth, K.paintHeight, 0, -O, T, O);
              if (this.imageLayer) {
                const [V, L] = oe.Util.applyTransform([0, -O], (0, de.getCurrentTransform)(this.ctx));
                this.imageLayer.appendImage({
                  imgData: F,
                  left: V,
                  top: L,
                  width: W,
                  height: z
                });
              }
              this.compose(), this.restore();
            }
            paintInlineImageXObjectGroup(F, T) {
              if (!this.contentVisible)
                return;
              const O = this.ctx, U = F.width, G = F.height, K = this.cachedCanvases.getCanvas("inlineImage", U, G), W = K.context;
              n(W, F, this.current.transferMaps);
              for (const z of T) {
                if (O.save(), O.transform(...z.transform), O.scale(1, -1), g(O, K.canvas, z.x, z.y, z.w, z.h, 0, -1, 1, 1), this.imageLayer) {
                  const [V, L] = oe.Util.applyTransform([z.x, z.y], (0, de.getCurrentTransform)(this.ctx));
                  this.imageLayer.appendImage({
                    imgData: F,
                    left: V,
                    top: L,
                    width: U,
                    height: G
                  });
                }
                O.restore();
              }
              this.compose();
            }
            paintSolidColorImageMask() {
              this.contentVisible && (this.ctx.fillRect(0, 0, 1, 1), this.compose());
            }
            markPoint(F) {
            }
            markPointProps(F, T) {
            }
            beginMarkedContent(F) {
              this.markedContentStack.push({
                visible: !0
              });
            }
            beginMarkedContentProps(F, T) {
              F === "OC" ? this.markedContentStack.push({
                visible: this.optionalContentConfig.isVisible(T)
              }) : this.markedContentStack.push({
                visible: !0
              }), this.contentVisible = this.isContentVisible();
            }
            endMarkedContent() {
              this.markedContentStack.pop(), this.contentVisible = this.isContentVisible();
            }
            beginCompat() {
            }
            endCompat() {
            }
            consumePath(F) {
              const T = this.current.isEmptyClip();
              this.pendingClip && this.current.updateClipFromPath(), this.pendingClip || this.compose(F);
              const O = this.ctx;
              this.pendingClip && (T || (this.pendingClip === D ? O.clip("evenodd") : O.clip()), this.pendingClip = null), this.current.startNewPathAndClipBox(this.current.clipBox), O.beginPath();
            }
            getSinglePixelWidth() {
              if (!this._cachedGetSinglePixelWidth) {
                const F = (0, de.getCurrentTransform)(this.ctx);
                if (F[1] === 0 && F[2] === 0)
                  this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(F[0]), Math.abs(F[3]));
                else {
                  const T = Math.abs(F[0] * F[3] - F[2] * F[1]), O = Math.hypot(F[0], F[2]), U = Math.hypot(F[1], F[3]);
                  this._cachedGetSinglePixelWidth = Math.max(O, U) / T;
                }
              }
              return this._cachedGetSinglePixelWidth;
            }
            getScaleForStroking() {
              if (!this._cachedScaleForStroking) {
                const {
                  lineWidth: F
                } = this.current, T = (0, de.getCurrentTransform)(this.ctx);
                let O, U;
                if (T[1] === 0 && T[2] === 0) {
                  const G = Math.abs(T[0]), K = Math.abs(T[3]);
                  if (F === 0)
                    O = 1 / G, U = 1 / K;
                  else {
                    const W = G * F, z = K * F;
                    O = W < 1 ? 1 / W : 1, U = z < 1 ? 1 / z : 1;
                  }
                } else {
                  const G = Math.abs(T[0] * T[3] - T[2] * T[1]), K = Math.hypot(T[0], T[1]), W = Math.hypot(T[2], T[3]);
                  if (F === 0)
                    O = W / G, U = K / G;
                  else {
                    const z = F * G;
                    O = W > z ? W / z : 1, U = K > z ? K / z : 1;
                  }
                }
                this._cachedScaleForStroking = [O, U];
              }
              return this._cachedScaleForStroking;
            }
            rescaleAndStroke(F) {
              const {
                ctx: T
              } = this, {
                lineWidth: O
              } = this.current, [U, G] = this.getScaleForStroking();
              if (T.lineWidth = O || 1, U === 1 && G === 1) {
                T.stroke();
                return;
              }
              let K, W, z;
              F && (K = (0, de.getCurrentTransform)(T), W = T.getLineDash().slice(), z = T.lineDashOffset), T.scale(U, G);
              const V = Math.max(U, G);
              T.setLineDash(T.getLineDash().map((L) => L / V)), T.lineDashOffset /= V, T.stroke(), F && (T.setTransform(...K), T.setLineDash(W), T.lineDashOffset = z);
            }
            isContentVisible() {
              for (let F = this.markedContentStack.length - 1; F >= 0; F--)
                if (!this.markedContentStack[F].visible)
                  return !1;
              return !0;
            }
          };
          let b = S;
          l = new WeakSet(), pi = function() {
            for (; this.stateStack.length || this.inSMaskMode; )
              this.restore();
            this.ctx.restore(), this.transparentCanvas && (this.ctx = this.compositeCtx, this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.drawImage(this.transparentCanvas, 0, 0), this.ctx.restore(), this.transparentCanvas = null);
          }, ge.CanvasGraphics = b;
          for (const A in oe.OPS)
            b.prototype[A] !== void 0 && (b.prototype[oe.OPS[A]] = b.prototype[A]);
        },
        /* 13 */
        /***/
        (Ee, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.TilingPattern = ge.PathType = void 0, ge.getShadingPattern = y;
          var de = le(1), oe = le(8), se = le(3);
          const Q = {
            FILL: "Fill",
            STROKE: "Stroke",
            SHADING: "Shading"
          };
          ge.PathType = Q;
          function u(g, d) {
            if (!d || se.isNodeJS)
              return;
            const c = d[2] - d[0], n = d[3] - d[1], o = new Path2D();
            o.rect(d[0], d[1], c, n), g.clip(o);
          }
          class P {
            constructor() {
              this.constructor === P && (0, de.unreachable)("Cannot initialize BaseShadingPattern.");
            }
            getPattern() {
              (0, de.unreachable)("Abstract method `getPattern` called.");
            }
          }
          class t extends P {
            constructor(d) {
              super(), this._type = d[1], this._bbox = d[2], this._colorStops = d[3], this._p0 = d[4], this._p1 = d[5], this._r0 = d[6], this._r1 = d[7], this.matrix = null;
            }
            _createGradient(d) {
              let c;
              this._type === "axial" ? c = d.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]) : this._type === "radial" && (c = d.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1));
              for (const n of this._colorStops)
                c.addColorStop(n[0], n[1]);
              return c;
            }
            getPattern(d, c, n, o) {
              let x;
              if (o === Q.STROKE || o === Q.FILL) {
                const f = c.current.getClippedPathBoundingBox(o, (0, oe.getCurrentTransform)(d)) || [0, 0, 0, 0], m = Math.ceil(f[2] - f[0]) || 1, C = Math.ceil(f[3] - f[1]) || 1, p = c.cachedCanvases.getCanvas("pattern", m, C, !0), w = p.context;
                w.clearRect(0, 0, w.canvas.width, w.canvas.height), w.beginPath(), w.rect(0, 0, w.canvas.width, w.canvas.height), w.translate(-f[0], -f[1]), n = de.Util.transform(n, [1, 0, 0, 1, f[0], f[1]]), w.transform(...c.baseTransform), this.matrix && w.transform(...this.matrix), u(w, this._bbox), w.fillStyle = this._createGradient(w), w.fill(), x = d.createPattern(p.canvas, "no-repeat");
                const X = new DOMMatrix(n);
                try {
                  x.setTransform(X);
                } catch (M) {
                  (0, de.warn)(`RadialAxialShadingPattern.getPattern: "${M == null ? void 0 : M.message}".`);
                }
              } else
                u(d, this._bbox), x = this._createGradient(d);
              return x;
            }
          }
          function i(g, d, c, n, o, x, f, m) {
            const C = d.coords, p = d.colors, w = g.data, X = g.width * 4;
            let M;
            C[c + 1] > C[n + 1] && (M = c, c = n, n = M, M = x, x = f, f = M), C[n + 1] > C[o + 1] && (M = n, n = o, o = M, M = f, f = m, m = M), C[c + 1] > C[n + 1] && (M = c, c = n, n = M, M = x, x = f, f = M);
            const j = (C[c] + d.offsetX) * d.scaleX, B = (C[c + 1] + d.offsetY) * d.scaleY, R = (C[n] + d.offsetX) * d.scaleX, D = (C[n + 1] + d.offsetY) * d.scaleY, b = (C[o] + d.offsetX) * d.scaleX, l = (C[o + 1] + d.offsetY) * d.scaleY;
            if (B >= l)
              return;
            const _ = p[x], S = p[x + 1], A = p[x + 2], F = p[f], T = p[f + 1], O = p[f + 2], U = p[m], G = p[m + 1], K = p[m + 2], W = Math.round(B), z = Math.round(l);
            let V, L, Y, J, ie, q, N, Z;
            for (let E = W; E <= z; E++) {
              if (E < D) {
                let k;
                E < B ? k = 0 : k = (B - E) / (B - D), V = j - (j - R) * k, L = _ - (_ - F) * k, Y = S - (S - T) * k, J = A - (A - O) * k;
              } else {
                let k;
                E > l ? k = 1 : D === l ? k = 0 : k = (D - E) / (D - l), V = R - (R - b) * k, L = F - (F - U) * k, Y = T - (T - G) * k, J = O - (O - K) * k;
              }
              let te;
              E < B ? te = 0 : E > l ? te = 1 : te = (B - E) / (B - l), ie = j - (j - b) * te, q = _ - (_ - U) * te, N = S - (S - G) * te, Z = A - (A - K) * te;
              const re = Math.round(Math.min(V, ie)), ee = Math.round(Math.max(V, ie));
              let $ = X * E + re * 4;
              for (let k = re; k <= ee; k++)
                te = (V - k) / (V - ie), te < 0 ? te = 0 : te > 1 && (te = 1), w[$++] = L - (L - q) * te | 0, w[$++] = Y - (Y - N) * te | 0, w[$++] = J - (J - Z) * te | 0, w[$++] = 255;
            }
          }
          function v(g, d, c) {
            const n = d.coords, o = d.colors;
            let x, f;
            switch (d.type) {
              case "lattice":
                const m = d.verticesPerRow, C = Math.floor(n.length / m) - 1, p = m - 1;
                for (x = 0; x < C; x++) {
                  let w = x * m;
                  for (let X = 0; X < p; X++, w++)
                    i(g, c, n[w], n[w + 1], n[w + m], o[w], o[w + 1], o[w + m]), i(g, c, n[w + m + 1], n[w + 1], n[w + m], o[w + m + 1], o[w + 1], o[w + m]);
                }
                break;
              case "triangles":
                for (x = 0, f = n.length; x < f; x += 3)
                  i(g, c, n[x], n[x + 1], n[x + 2], o[x], o[x + 1], o[x + 2]);
                break;
              default:
                throw new Error("illegal figure");
            }
          }
          class a extends P {
            constructor(d) {
              super(), this._coords = d[2], this._colors = d[3], this._figures = d[4], this._bounds = d[5], this._bbox = d[7], this._background = d[8], this.matrix = null;
            }
            _createMeshCanvas(d, c, n) {
              const m = Math.floor(this._bounds[0]), C = Math.floor(this._bounds[1]), p = Math.ceil(this._bounds[2]) - m, w = Math.ceil(this._bounds[3]) - C, X = Math.min(Math.ceil(Math.abs(p * d[0] * 1.1)), 3e3), M = Math.min(Math.ceil(Math.abs(w * d[1] * 1.1)), 3e3), j = p / X, B = w / M, R = {
                coords: this._coords,
                colors: this._colors,
                offsetX: -m,
                offsetY: -C,
                scaleX: 1 / j,
                scaleY: 1 / B
              }, D = X + 2 * 2, b = M + 2 * 2, l = n.getCanvas("mesh", D, b, !1), _ = l.context, S = _.createImageData(X, M);
              if (c) {
                const F = S.data;
                for (let T = 0, O = F.length; T < O; T += 4)
                  F[T] = c[0], F[T + 1] = c[1], F[T + 2] = c[2], F[T + 3] = 255;
              }
              for (const F of this._figures)
                v(S, F, R);
              return _.putImageData(S, 2, 2), {
                canvas: l.canvas,
                offsetX: m - 2 * j,
                offsetY: C - 2 * B,
                scaleX: j,
                scaleY: B
              };
            }
            getPattern(d, c, n, o) {
              u(d, this._bbox);
              let x;
              if (o === Q.SHADING)
                x = de.Util.singularValueDecompose2dScale((0, oe.getCurrentTransform)(d));
              else if (x = de.Util.singularValueDecompose2dScale(c.baseTransform), this.matrix) {
                const m = de.Util.singularValueDecompose2dScale(this.matrix);
                x = [x[0] * m[0], x[1] * m[1]];
              }
              const f = this._createMeshCanvas(x, o === Q.SHADING ? null : this._background, c.cachedCanvases);
              return o !== Q.SHADING && (d.setTransform(...c.baseTransform), this.matrix && d.transform(...this.matrix)), d.translate(f.offsetX, f.offsetY), d.scale(f.scaleX, f.scaleY), d.createPattern(f.canvas, "no-repeat");
            }
          }
          class e extends P {
            getPattern() {
              return "hotpink";
            }
          }
          function y(g) {
            switch (g[0]) {
              case "RadialAxial":
                return new t(g);
              case "Mesh":
                return new a(g);
              case "Dummy":
                return new e();
            }
            throw new Error(`Unknown IR type: ${g[0]}`);
          }
          const r = {
            COLORED: 1,
            UNCOLORED: 2
          };
          class h {
            static get MAX_PATTERN_SIZE() {
              return (0, de.shadow)(this, "MAX_PATTERN_SIZE", 3e3);
            }
            constructor(d, c, n, o, x) {
              this.operatorList = d[2], this.matrix = d[3] || [1, 0, 0, 1, 0, 0], this.bbox = d[4], this.xstep = d[5], this.ystep = d[6], this.paintType = d[7], this.tilingType = d[8], this.color = c, this.ctx = n, this.canvasGraphicsFactory = o, this.baseTransform = x;
            }
            createPatternCanvas(d) {
              const c = this.operatorList, n = this.bbox, o = this.xstep, x = this.ystep, f = this.paintType, m = this.tilingType, C = this.color, p = this.canvasGraphicsFactory;
              (0, de.info)("TilingType: " + m);
              const w = n[0], X = n[1], M = n[2], j = n[3], B = de.Util.singularValueDecompose2dScale(this.matrix), R = de.Util.singularValueDecompose2dScale(this.baseTransform), D = [B[0] * R[0], B[1] * R[1]], b = this.getSizeAndScale(o, this.ctx.canvas.width, D[0]), l = this.getSizeAndScale(x, this.ctx.canvas.height, D[1]), _ = d.cachedCanvases.getCanvas("pattern", b.size, l.size, !0), S = _.context, A = p.createCanvasGraphics(S);
              A.groupLevel = d.groupLevel, this.setFillAndStrokeStyleToContext(A, f, C);
              let F = w, T = X, O = M, U = j;
              return w < 0 && (F = 0, O += Math.abs(w)), X < 0 && (T = 0, U += Math.abs(X)), S.translate(-(b.scale * F), -(l.scale * T)), A.transform(b.scale, 0, 0, l.scale, 0, 0), S.save(), this.clipBbox(A, F, T, O, U), A.baseTransform = (0, oe.getCurrentTransform)(A.ctx), A.executeOperatorList(c), A.endDrawing(), {
                canvas: _.canvas,
                scaleX: b.scale,
                scaleY: l.scale,
                offsetX: F,
                offsetY: T
              };
            }
            getSizeAndScale(d, c, n) {
              d = Math.abs(d);
              const o = Math.max(h.MAX_PATTERN_SIZE, c);
              let x = Math.ceil(d * n);
              return x >= o ? x = o : n = x / d, {
                scale: n,
                size: x
              };
            }
            clipBbox(d, c, n, o, x) {
              const f = o - c, m = x - n;
              d.ctx.rect(c, n, f, m), d.current.updateRectMinMax((0, oe.getCurrentTransform)(d.ctx), [c, n, o, x]), d.clip(), d.endPath();
            }
            setFillAndStrokeStyleToContext(d, c, n) {
              const o = d.ctx, x = d.current;
              switch (c) {
                case r.COLORED:
                  const f = this.ctx;
                  o.fillStyle = f.fillStyle, o.strokeStyle = f.strokeStyle, x.fillColor = f.fillStyle, x.strokeColor = f.strokeStyle;
                  break;
                case r.UNCOLORED:
                  const m = de.Util.makeHexColor(n[0], n[1], n[2]);
                  o.fillStyle = m, o.strokeStyle = m, x.fillColor = m, x.strokeColor = m;
                  break;
                default:
                  throw new de.FormatError(`Unsupported paint type: ${c}`);
              }
            }
            getPattern(d, c, n, o) {
              let x = n;
              o !== Q.SHADING && (x = de.Util.transform(x, c.baseTransform), this.matrix && (x = de.Util.transform(x, this.matrix)));
              const f = this.createPatternCanvas(c);
              let m = new DOMMatrix(x);
              m = m.translate(f.offsetX, f.offsetY), m = m.scale(1 / f.scaleX, 1 / f.scaleY);
              const C = d.createPattern(f.canvas, "repeat");
              try {
                C.setTransform(m);
              } catch (p) {
                (0, de.warn)(`TilingPattern.getPattern: "${p == null ? void 0 : p.message}".`);
              }
              return C;
            }
          }
          ge.TilingPattern = h;
        },
        /* 14 */
        /***/
        (Ee, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.applyMaskImageData = oe;
          var de = le(1);
          function oe({
            src: se,
            srcPos: Q = 0,
            dest: u,
            destPos: P = 0,
            width: t,
            height: i,
            inverseDecode: v = !1
          }) {
            const a = de.FeatureTest.isLittleEndian ? 4278190080 : 255, [e, y] = v ? [0, a] : [a, 0], r = t >> 3, h = t & 7, g = se.length;
            u = new Uint32Array(u.buffer);
            for (let d = 0; d < i; d++) {
              for (const n = Q + r; Q < n; Q++) {
                const o = Q < g ? se[Q] : 255;
                u[P++] = o & 128 ? y : e, u[P++] = o & 64 ? y : e, u[P++] = o & 32 ? y : e, u[P++] = o & 16 ? y : e, u[P++] = o & 8 ? y : e, u[P++] = o & 4 ? y : e, u[P++] = o & 2 ? y : e, u[P++] = o & 1 ? y : e;
              }
              if (h === 0)
                continue;
              const c = Q < g ? se[Q++] : 255;
              for (let n = 0; n < h; n++)
                u[P++] = c & 1 << 7 - n ? y : e;
            }
            return {
              srcPos: Q,
              destPos: P
            };
          }
        },
        /* 15 */
        /***/
        (Ee, ge) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.GlobalWorkerOptions = void 0;
          const le = /* @__PURE__ */ Object.create(null);
          ge.GlobalWorkerOptions = le, le.workerPort = le.workerPort === void 0 ? null : le.workerPort, le.workerSrc = le.workerSrc === void 0 ? "" : le.workerSrc;
        },
        /* 16 */
        /***/
        (Ee, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.MessageHandler = void 0;
          var de = le(1);
          const oe = {
            UNKNOWN: 0,
            DATA: 1,
            ERROR: 2
          }, se = {
            UNKNOWN: 0,
            CANCEL: 1,
            CANCEL_COMPLETE: 2,
            CLOSE: 3,
            ENQUEUE: 4,
            ERROR: 5,
            PULL: 6,
            PULL_COMPLETE: 7,
            START_COMPLETE: 8
          };
          function Q(P) {
            switch (P instanceof Error || typeof P == "object" && P !== null || (0, de.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), P.name) {
              case "AbortException":
                return new de.AbortException(P.message);
              case "MissingPDFException":
                return new de.MissingPDFException(P.message);
              case "PasswordException":
                return new de.PasswordException(P.message, P.code);
              case "UnexpectedResponseException":
                return new de.UnexpectedResponseException(P.message, P.status);
              case "UnknownErrorException":
                return new de.UnknownErrorException(P.message, P.details);
              default:
                return new de.UnknownErrorException(P.message, P.toString());
            }
          }
          class u {
            constructor(t, i, v) {
              this.sourceName = t, this.targetName = i, this.comObj = v, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), this._onComObjOnMessage = (a) => {
                const e = a.data;
                if (e.targetName !== this.sourceName)
                  return;
                if (e.stream) {
                  this._processStreamMessage(e);
                  return;
                }
                if (e.callback) {
                  const r = e.callbackId, h = this.callbackCapabilities[r];
                  if (!h)
                    throw new Error(`Cannot resolve callback ${r}`);
                  if (delete this.callbackCapabilities[r], e.callback === oe.DATA)
                    h.resolve(e.data);
                  else if (e.callback === oe.ERROR)
                    h.reject(Q(e.reason));
                  else
                    throw new Error("Unexpected callback case");
                  return;
                }
                const y = this.actionHandler[e.action];
                if (!y)
                  throw new Error(`Unknown action from worker: ${e.action}`);
                if (e.callbackId) {
                  const r = this.sourceName, h = e.sourceName;
                  new Promise(function(g) {
                    g(y(e.data));
                  }).then(function(g) {
                    v.postMessage({
                      sourceName: r,
                      targetName: h,
                      callback: oe.DATA,
                      callbackId: e.callbackId,
                      data: g
                    });
                  }, function(g) {
                    v.postMessage({
                      sourceName: r,
                      targetName: h,
                      callback: oe.ERROR,
                      callbackId: e.callbackId,
                      reason: Q(g)
                    });
                  });
                  return;
                }
                if (e.streamId) {
                  this._createStreamSink(e);
                  return;
                }
                y(e.data);
              }, v.addEventListener("message", this._onComObjOnMessage);
            }
            on(t, i) {
              const v = this.actionHandler;
              if (v[t])
                throw new Error(`There is already an actionName called "${t}"`);
              v[t] = i;
            }
            send(t, i, v) {
              this.comObj.postMessage({
                sourceName: this.sourceName,
                targetName: this.targetName,
                action: t,
                data: i
              }, v);
            }
            sendWithPromise(t, i, v) {
              const a = this.callbackId++, e = (0, de.createPromiseCapability)();
              this.callbackCapabilities[a] = e;
              try {
                this.comObj.postMessage({
                  sourceName: this.sourceName,
                  targetName: this.targetName,
                  action: t,
                  callbackId: a,
                  data: i
                }, v);
              } catch (y) {
                e.reject(y);
              }
              return e.promise;
            }
            sendWithStream(t, i, v, a) {
              const e = this.streamId++, y = this.sourceName, r = this.targetName, h = this.comObj;
              return new ReadableStream({
                start: (g) => {
                  const d = (0, de.createPromiseCapability)();
                  return this.streamControllers[e] = {
                    controller: g,
                    startCall: d,
                    pullCall: null,
                    cancelCall: null,
                    isClosed: !1
                  }, h.postMessage({
                    sourceName: y,
                    targetName: r,
                    action: t,
                    streamId: e,
                    data: i,
                    desiredSize: g.desiredSize
                  }, a), d.promise;
                },
                pull: (g) => {
                  const d = (0, de.createPromiseCapability)();
                  return this.streamControllers[e].pullCall = d, h.postMessage({
                    sourceName: y,
                    targetName: r,
                    stream: se.PULL,
                    streamId: e,
                    desiredSize: g.desiredSize
                  }), d.promise;
                },
                cancel: (g) => {
                  (0, de.assert)(g instanceof Error, "cancel must have a valid reason");
                  const d = (0, de.createPromiseCapability)();
                  return this.streamControllers[e].cancelCall = d, this.streamControllers[e].isClosed = !0, h.postMessage({
                    sourceName: y,
                    targetName: r,
                    stream: se.CANCEL,
                    streamId: e,
                    reason: Q(g)
                  }), d.promise;
                }
              }, v);
            }
            _createStreamSink(t) {
              const i = t.streamId, v = this.sourceName, a = t.sourceName, e = this.comObj, y = this, r = this.actionHandler[t.action], h = {
                enqueue(g, d = 1, c) {
                  if (this.isCancelled)
                    return;
                  const n = this.desiredSize;
                  this.desiredSize -= d, n > 0 && this.desiredSize <= 0 && (this.sinkCapability = (0, de.createPromiseCapability)(), this.ready = this.sinkCapability.promise), e.postMessage({
                    sourceName: v,
                    targetName: a,
                    stream: se.ENQUEUE,
                    streamId: i,
                    chunk: g
                  }, c);
                },
                close() {
                  this.isCancelled || (this.isCancelled = !0, e.postMessage({
                    sourceName: v,
                    targetName: a,
                    stream: se.CLOSE,
                    streamId: i
                  }), delete y.streamSinks[i]);
                },
                error(g) {
                  (0, de.assert)(g instanceof Error, "error must have a valid reason"), !this.isCancelled && (this.isCancelled = !0, e.postMessage({
                    sourceName: v,
                    targetName: a,
                    stream: se.ERROR,
                    streamId: i,
                    reason: Q(g)
                  }));
                },
                sinkCapability: (0, de.createPromiseCapability)(),
                onPull: null,
                onCancel: null,
                isCancelled: !1,
                desiredSize: t.desiredSize,
                ready: null
              };
              h.sinkCapability.resolve(), h.ready = h.sinkCapability.promise, this.streamSinks[i] = h, new Promise(function(g) {
                g(r(t.data, h));
              }).then(function() {
                e.postMessage({
                  sourceName: v,
                  targetName: a,
                  stream: se.START_COMPLETE,
                  streamId: i,
                  success: !0
                });
              }, function(g) {
                e.postMessage({
                  sourceName: v,
                  targetName: a,
                  stream: se.START_COMPLETE,
                  streamId: i,
                  reason: Q(g)
                });
              });
            }
            _processStreamMessage(t) {
              const i = t.streamId, v = this.sourceName, a = t.sourceName, e = this.comObj, y = this.streamControllers[i], r = this.streamSinks[i];
              switch (t.stream) {
                case se.START_COMPLETE:
                  t.success ? y.startCall.resolve() : y.startCall.reject(Q(t.reason));
                  break;
                case se.PULL_COMPLETE:
                  t.success ? y.pullCall.resolve() : y.pullCall.reject(Q(t.reason));
                  break;
                case se.PULL:
                  if (!r) {
                    e.postMessage({
                      sourceName: v,
                      targetName: a,
                      stream: se.PULL_COMPLETE,
                      streamId: i,
                      success: !0
                    });
                    break;
                  }
                  r.desiredSize <= 0 && t.desiredSize > 0 && r.sinkCapability.resolve(), r.desiredSize = t.desiredSize, new Promise(function(h) {
                    h(r.onPull && r.onPull());
                  }).then(function() {
                    e.postMessage({
                      sourceName: v,
                      targetName: a,
                      stream: se.PULL_COMPLETE,
                      streamId: i,
                      success: !0
                    });
                  }, function(h) {
                    e.postMessage({
                      sourceName: v,
                      targetName: a,
                      stream: se.PULL_COMPLETE,
                      streamId: i,
                      reason: Q(h)
                    });
                  });
                  break;
                case se.ENQUEUE:
                  if ((0, de.assert)(y, "enqueue should have stream controller"), y.isClosed)
                    break;
                  y.controller.enqueue(t.chunk);
                  break;
                case se.CLOSE:
                  if ((0, de.assert)(y, "close should have stream controller"), y.isClosed)
                    break;
                  y.isClosed = !0, y.controller.close(), this._deleteStreamController(y, i);
                  break;
                case se.ERROR:
                  (0, de.assert)(y, "error should have stream controller"), y.controller.error(Q(t.reason)), this._deleteStreamController(y, i);
                  break;
                case se.CANCEL_COMPLETE:
                  t.success ? y.cancelCall.resolve() : y.cancelCall.reject(Q(t.reason)), this._deleteStreamController(y, i);
                  break;
                case se.CANCEL:
                  if (!r)
                    break;
                  new Promise(function(h) {
                    h(r.onCancel && r.onCancel(Q(t.reason)));
                  }).then(function() {
                    e.postMessage({
                      sourceName: v,
                      targetName: a,
                      stream: se.CANCEL_COMPLETE,
                      streamId: i,
                      success: !0
                    });
                  }, function(h) {
                    e.postMessage({
                      sourceName: v,
                      targetName: a,
                      stream: se.CANCEL_COMPLETE,
                      streamId: i,
                      reason: Q(h)
                    });
                  }), r.sinkCapability.reject(Q(t.reason)), r.isCancelled = !0, delete this.streamSinks[i];
                  break;
                default:
                  throw new Error("Unexpected stream case");
              }
            }
            async _deleteStreamController(t, i) {
              await Promise.allSettled([t.startCall && t.startCall.promise, t.pullCall && t.pullCall.promise, t.cancelCall && t.cancelCall.promise]), delete this.streamControllers[i];
            }
            destroy() {
              this.comObj.removeEventListener("message", this._onComObjOnMessage);
            }
          }
          ge.MessageHandler = u;
        },
        /* 17 */
        /***/
        (Ee, ge, le) => {
          var se, Q;
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.Metadata = void 0;
          var de = le(1);
          class oe {
            constructor({
              parsedData: P,
              rawData: t
            }) {
              ft(this, se, void 0);
              ft(this, Q, void 0);
              Tt(this, se, P), Tt(this, Q, t);
            }
            getRaw() {
              return ke(this, Q);
            }
            get(P) {
              return ke(this, se).get(P) ?? null;
            }
            getAll() {
              return (0, de.objectFromMap)(ke(this, se));
            }
            has(P) {
              return ke(this, se).has(P);
            }
          }
          se = new WeakMap(), Q = new WeakMap(), ge.Metadata = oe;
        },
        /* 18 */
        /***/
        (Ee, ge, le) => {
          var u, P, t, i, v, a, mi;
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.OptionalContentConfig = void 0;
          var de = le(1);
          const oe = Symbol("INTERNAL");
          class se {
            constructor(r, h) {
              ft(this, u, !0);
              this.name = r, this.intent = h;
            }
            get visible() {
              return ke(this, u);
            }
            _setVisible(r, h) {
              r !== oe && (0, de.unreachable)("Internal method `_setVisible` called."), Tt(this, u, h);
            }
          }
          u = new WeakMap();
          class Q {
            constructor(r) {
              ft(this, a);
              ft(this, P, !0);
              ft(this, t, /* @__PURE__ */ new Map());
              ft(this, i, null);
              ft(this, v, null);
              if (this.name = null, this.creator = null, r !== null) {
                this.name = r.name, this.creator = r.creator, Tt(this, v, r.order);
                for (const h of r.groups)
                  ke(this, t).set(h.id, new se(h.name, h.intent));
                if (r.baseState === "OFF")
                  for (const h of ke(this, t).values())
                    h._setVisible(oe, !1);
                for (const h of r.on)
                  ke(this, t).get(h)._setVisible(oe, !0);
                for (const h of r.off)
                  ke(this, t).get(h)._setVisible(oe, !1);
                Tt(this, i, /* @__PURE__ */ new Map());
                for (const [h, g] of ke(this, t))
                  ke(this, i).set(h, g.visible);
              }
            }
            isVisible(r) {
              if (ke(this, t).size === 0)
                return !0;
              if (!r)
                return (0, de.warn)("Optional content group not defined."), !0;
              if (r.type === "OCG")
                return ke(this, t).has(r.id) ? ke(this, t).get(r.id).visible : ((0, de.warn)(`Optional content group not found: ${r.id}`), !0);
              if (r.type === "OCMD") {
                if (r.expression)
                  return wt(this, a, mi).call(this, r.expression);
                if (!r.policy || r.policy === "AnyOn") {
                  for (const h of r.ids) {
                    if (!ke(this, t).has(h))
                      return (0, de.warn)(`Optional content group not found: ${h}`), !0;
                    if (ke(this, t).get(h).visible)
                      return !0;
                  }
                  return !1;
                } else if (r.policy === "AllOn") {
                  for (const h of r.ids) {
                    if (!ke(this, t).has(h))
                      return (0, de.warn)(`Optional content group not found: ${h}`), !0;
                    if (!ke(this, t).get(h).visible)
                      return !1;
                  }
                  return !0;
                } else if (r.policy === "AnyOff") {
                  for (const h of r.ids) {
                    if (!ke(this, t).has(h))
                      return (0, de.warn)(`Optional content group not found: ${h}`), !0;
                    if (!ke(this, t).get(h).visible)
                      return !0;
                  }
                  return !1;
                } else if (r.policy === "AllOff") {
                  for (const h of r.ids) {
                    if (!ke(this, t).has(h))
                      return (0, de.warn)(`Optional content group not found: ${h}`), !0;
                    if (ke(this, t).get(h).visible)
                      return !1;
                  }
                  return !0;
                }
                return (0, de.warn)(`Unknown optional content policy ${r.policy}.`), !0;
              }
              return (0, de.warn)(`Unknown group type ${r.type}.`), !0;
            }
            setVisibility(r, h = !0) {
              if (!ke(this, t).has(r)) {
                (0, de.warn)(`Optional content group not found: ${r}`);
                return;
              }
              ke(this, t).get(r)._setVisible(oe, !!h), Tt(this, P, null);
            }
            get hasInitialVisibility() {
              if (ke(this, P) !== null)
                return ke(this, P);
              for (const [r, h] of ke(this, t)) {
                const g = ke(this, i).get(r);
                if (h.visible !== g)
                  return Tt(this, P, !1);
              }
              return Tt(this, P, !0);
            }
            getOrder() {
              return ke(this, t).size ? ke(this, v) ? ke(this, v).slice() : [...ke(this, t).keys()] : null;
            }
            getGroups() {
              return ke(this, t).size > 0 ? (0, de.objectFromMap)(ke(this, t)) : null;
            }
            getGroup(r) {
              return ke(this, t).get(r) || null;
            }
          }
          P = new WeakMap(), t = new WeakMap(), i = new WeakMap(), v = new WeakMap(), a = new WeakSet(), mi = function(r) {
            const h = r.length;
            if (h < 2)
              return !0;
            const g = r[0];
            for (let d = 1; d < h; d++) {
              const c = r[d];
              let n;
              if (Array.isArray(c))
                n = wt(this, a, mi).call(this, c);
              else if (ke(this, t).has(c))
                n = ke(this, t).get(c).visible;
              else
                return (0, de.warn)(`Optional content group not found: ${c}`), !0;
              switch (g) {
                case "And":
                  if (!n)
                    return !1;
                  break;
                case "Or":
                  if (n)
                    return !0;
                  break;
                case "Not":
                  return !n;
                default:
                  return !0;
              }
            }
            return g === "And";
          }, ge.OptionalContentConfig = Q;
        },
        /* 19 */
        /***/
        (Ee, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.PDFDataTransportStream = void 0;
          var de = le(1), oe = le(8);
          class se {
            constructor(t, i) {
              (0, de.assert)(i, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.'), this._queuedChunks = [], this._progressiveDone = t.progressiveDone || !1, this._contentDispositionFilename = t.contentDispositionFilename || null;
              const v = t.initialData;
              if ((v == null ? void 0 : v.length) > 0) {
                const a = new Uint8Array(v).buffer;
                this._queuedChunks.push(a);
              }
              this._pdfDataRangeTransport = i, this._isStreamingSupported = !t.disableStream, this._isRangeSupported = !t.disableRange, this._contentLength = t.length, this._fullRequestReader = null, this._rangeReaders = [], this._pdfDataRangeTransport.addRangeListener((a, e) => {
                this._onReceiveData({
                  begin: a,
                  chunk: e
                });
              }), this._pdfDataRangeTransport.addProgressListener((a, e) => {
                this._onProgress({
                  loaded: a,
                  total: e
                });
              }), this._pdfDataRangeTransport.addProgressiveReadListener((a) => {
                this._onReceiveData({
                  chunk: a
                });
              }), this._pdfDataRangeTransport.addProgressiveDoneListener(() => {
                this._onProgressiveDone();
              }), this._pdfDataRangeTransport.transportReady();
            }
            _onReceiveData(t) {
              const i = new Uint8Array(t.chunk).buffer;
              if (t.begin === void 0)
                this._fullRequestReader ? this._fullRequestReader._enqueue(i) : this._queuedChunks.push(i);
              else {
                const v = this._rangeReaders.some(function(a) {
                  return a._begin !== t.begin ? !1 : (a._enqueue(i), !0);
                });
                (0, de.assert)(v, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
              }
            }
            get _progressiveDataLength() {
              var t;
              return ((t = this._fullRequestReader) == null ? void 0 : t._loaded) ?? 0;
            }
            _onProgress(t) {
              if (t.total === void 0) {
                const i = this._rangeReaders[0];
                i != null && i.onProgress && i.onProgress({
                  loaded: t.loaded
                });
              } else {
                const i = this._fullRequestReader;
                i != null && i.onProgress && i.onProgress({
                  loaded: t.loaded,
                  total: t.total
                });
              }
            }
            _onProgressiveDone() {
              this._fullRequestReader && this._fullRequestReader.progressiveDone(), this._progressiveDone = !0;
            }
            _removeRangeReader(t) {
              const i = this._rangeReaders.indexOf(t);
              i >= 0 && this._rangeReaders.splice(i, 1);
            }
            getFullReader() {
              (0, de.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
              const t = this._queuedChunks;
              return this._queuedChunks = null, new Q(this, t, this._progressiveDone, this._contentDispositionFilename);
            }
            getRangeReader(t, i) {
              if (i <= this._progressiveDataLength)
                return null;
              const v = new u(this, t, i);
              return this._pdfDataRangeTransport.requestDataRange(t, i), this._rangeReaders.push(v), v;
            }
            cancelAllRequests(t) {
              this._fullRequestReader && this._fullRequestReader.cancel(t);
              for (const i of this._rangeReaders.slice(0))
                i.cancel(t);
              this._pdfDataRangeTransport.abort();
            }
          }
          ge.PDFDataTransportStream = se;
          class Q {
            constructor(t, i, v = !1, a = null) {
              this._stream = t, this._done = v || !1, this._filename = (0, oe.isPdfFile)(a) ? a : null, this._queuedChunks = i || [], this._loaded = 0;
              for (const e of this._queuedChunks)
                this._loaded += e.byteLength;
              this._requests = [], this._headersReady = Promise.resolve(), t._fullRequestReader = this, this.onProgress = null;
            }
            _enqueue(t) {
              this._done || (this._requests.length > 0 ? this._requests.shift().resolve({
                value: t,
                done: !1
              }) : this._queuedChunks.push(t), this._loaded += t.byteLength);
            }
            get headersReady() {
              return this._headersReady;
            }
            get filename() {
              return this._filename;
            }
            get isRangeSupported() {
              return this._stream._isRangeSupported;
            }
            get isStreamingSupported() {
              return this._stream._isStreamingSupported;
            }
            get contentLength() {
              return this._stream._contentLength;
            }
            async read() {
              if (this._queuedChunks.length > 0)
                return {
                  value: this._queuedChunks.shift(),
                  done: !1
                };
              if (this._done)
                return {
                  value: void 0,
                  done: !0
                };
              const t = (0, de.createPromiseCapability)();
              return this._requests.push(t), t.promise;
            }
            cancel(t) {
              this._done = !0;
              for (const i of this._requests)
                i.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0;
            }
            progressiveDone() {
              this._done || (this._done = !0);
            }
          }
          class u {
            constructor(t, i, v) {
              this._stream = t, this._begin = i, this._end = v, this._queuedChunk = null, this._requests = [], this._done = !1, this.onProgress = null;
            }
            _enqueue(t) {
              if (!this._done) {
                if (this._requests.length === 0)
                  this._queuedChunk = t;
                else {
                  this._requests.shift().resolve({
                    value: t,
                    done: !1
                  });
                  for (const v of this._requests)
                    v.resolve({
                      value: void 0,
                      done: !0
                    });
                  this._requests.length = 0;
                }
                this._done = !0, this._stream._removeRangeReader(this);
              }
            }
            get isStreamingSupported() {
              return !1;
            }
            async read() {
              if (this._queuedChunk) {
                const i = this._queuedChunk;
                return this._queuedChunk = null, {
                  value: i,
                  done: !1
                };
              }
              if (this._done)
                return {
                  value: void 0,
                  done: !0
                };
              const t = (0, de.createPromiseCapability)();
              return this._requests.push(t), t.promise;
            }
            cancel(t) {
              this._done = !0;
              for (const i of this._requests)
                i.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0, this._stream._removeRangeReader(this);
            }
          }
        },
        /* 20 */
        /***/
        (Ee, ge) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.XfaText = void 0;
          class le {
            static textContent(oe) {
              const se = [], Q = {
                items: se,
                styles: /* @__PURE__ */ Object.create(null)
              };
              function u(P) {
                var v;
                if (!P)
                  return;
                let t = null;
                const i = P.name;
                if (i === "#text")
                  t = P.value;
                else if (le.shouldBuildText(i))
                  (v = P == null ? void 0 : P.attributes) != null && v.textContent ? t = P.attributes.textContent : P.value && (t = P.value);
                else
                  return;
                if (t !== null && se.push({
                  str: t
                }), !!P.children)
                  for (const a of P.children)
                    u(a);
              }
              return u(oe), Q;
            }
            static shouldBuildText(oe) {
              return !(oe === "textarea" || oe === "input" || oe === "option" || oe === "select");
            }
          }
          ge.XfaText = le;
        },
        /* 21 */
        /***/
        (Ee, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.NodeStandardFontDataFactory = ge.NodeCanvasFactory = ge.NodeCMapReaderFactory = void 0;
          var de = le(9);
          const oe = function(P) {
            return new Promise((t, i) => {
              require$$5.readFile(P, (a, e) => {
                if (a || !e) {
                  i(new Error(a));
                  return;
                }
                t(new Uint8Array(e));
              });
            });
          };
          class se extends de.BaseCanvasFactory {
            _createCanvas(t, i) {
              return require$$5.createCanvas(t, i);
            }
          }
          ge.NodeCanvasFactory = se;
          class Q extends de.BaseCMapReaderFactory {
            _fetchData(t, i) {
              return oe(t).then((v) => ({
                cMapData: v,
                compressionType: i
              }));
            }
          }
          ge.NodeCMapReaderFactory = Q;
          class u extends de.BaseStandardFontDataFactory {
            _fetchData(t) {
              return oe(t);
            }
          }
          ge.NodeStandardFontDataFactory = u;
        },
        /* 22 */
        /***/
        (Ee, ge, le) => {
          var P, t, i, v, a, e, y, r, h, xi, d, Ni, n, bi, x, ji;
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.AnnotationEditorLayer = void 0;
          var de = le(7), oe = le(1), se = le(23), Q = le(24);
          const m = class {
            constructor(p) {
              ft(this, h);
              ft(this, d);
              ft(this, n);
              ft(this, x);
              ft(this, P, void 0);
              ft(this, t, !1);
              ft(this, i, this.pointerup.bind(this));
              ft(this, v, this.pointerdown.bind(this));
              ft(this, a, /* @__PURE__ */ new Map());
              ft(this, e, !1);
              ft(this, y, !1);
              ft(this, r, void 0);
              m._initialized || (m._initialized = !0, se.FreeTextEditor.initialize(p.l10n), Q.InkEditor.initialize(p.l10n), p.uiManager.registerEditorTypes([se.FreeTextEditor, Q.InkEditor])), Tt(this, r, p.uiManager), this.annotationStorage = p.annotationStorage, this.pageIndex = p.pageIndex, this.div = p.div, Tt(this, P, p.accessibilityManager), ke(this, r).addLayer(this);
            }
            updateToolbar(p) {
              ke(this, r).updateToolbar(p);
            }
            updateMode(p = ke(this, r).getMode()) {
              wt(this, x, ji).call(this), p === oe.AnnotationEditorType.INK ? (this.addInkEditorIfNeeded(!1), this.disableClick()) : this.enableClick(), ke(this, r).unselectAll();
            }
            addInkEditorIfNeeded(p) {
              if (!p && ke(this, r).getMode() !== oe.AnnotationEditorType.INK)
                return;
              if (!p) {
                for (const X of ke(this, a).values())
                  if (X.isEmpty()) {
                    X.setInBackground();
                    return;
                  }
              }
              wt(this, n, bi).call(this, {
                offsetX: 0,
                offsetY: 0
              }).setInBackground();
            }
            setEditingState(p) {
              ke(this, r).setEditingState(p);
            }
            addCommands(p) {
              ke(this, r).addCommands(p);
            }
            enable() {
              this.div.style.pointerEvents = "auto";
              for (const p of ke(this, a).values())
                p.enableEditing();
            }
            disable() {
              this.div.style.pointerEvents = "none";
              for (const p of ke(this, a).values())
                p.disableEditing();
            }
            setActiveEditor(p) {
              ke(this, r).getActive() !== p && ke(this, r).setActiveEditor(p);
            }
            enableClick() {
              this.div.addEventListener("pointerdown", ke(this, v)), this.div.addEventListener("pointerup", ke(this, i));
            }
            disableClick() {
              this.div.removeEventListener("pointerdown", ke(this, v)), this.div.removeEventListener("pointerup", ke(this, i));
            }
            attach(p) {
              ke(this, a).set(p.id, p);
            }
            detach(p) {
              var w;
              ke(this, a).delete(p.id), (w = ke(this, P)) == null || w.removePointerInTextLayer(p.contentDiv);
            }
            remove(p) {
              ke(this, r).removeEditor(p), this.detach(p), this.annotationStorage.remove(p.id), p.div.style.display = "none", setTimeout(() => {
                p.div.style.display = "", p.div.remove(), p.isAttachedToDOM = !1, document.activeElement === document.body && ke(this, r).focusMainContainer();
              }, 0), ke(this, y) || this.addInkEditorIfNeeded(!1);
            }
            add(p) {
              if (wt(this, h, xi).call(this, p), ke(this, r).addEditor(p), this.attach(p), !p.isAttachedToDOM) {
                const w = p.render();
                this.div.append(w), p.isAttachedToDOM = !0;
              }
              this.moveEditorInDOM(p), p.onceAdded(), this.addToAnnotationStorage(p);
            }
            moveEditorInDOM(p) {
              var w;
              (w = ke(this, P)) == null || w.moveElementInDOM(this.div, p.div, p.contentDiv, !0);
            }
            addToAnnotationStorage(p) {
              !p.isEmpty() && !this.annotationStorage.has(p.id) && this.annotationStorage.setValue(p.id, p);
            }
            addOrRebuild(p) {
              p.needsToBeRebuilt() ? p.rebuild() : this.add(p);
            }
            addANewEditor(p) {
              const w = () => {
                this.addOrRebuild(p);
              }, X = () => {
                p.remove();
              };
              this.addCommands({
                cmd: w,
                undo: X,
                mustExec: !0
              });
            }
            addUndoableEditor(p) {
              const w = () => {
                this.addOrRebuild(p);
              }, X = () => {
                p.remove();
              };
              this.addCommands({
                cmd: w,
                undo: X,
                mustExec: !1
              });
            }
            getNextId() {
              return ke(this, r).getId();
            }
            deserialize(p) {
              switch (p.annotationType) {
                case oe.AnnotationEditorType.FREETEXT:
                  return se.FreeTextEditor.deserialize(p, this);
                case oe.AnnotationEditorType.INK:
                  return Q.InkEditor.deserialize(p, this);
              }
              return null;
            }
            setSelected(p) {
              ke(this, r).setSelected(p);
            }
            toggleSelected(p) {
              ke(this, r).toggleSelected(p);
            }
            isSelected(p) {
              return ke(this, r).isSelected(p);
            }
            unselect(p) {
              ke(this, r).unselect(p);
            }
            pointerup(p) {
              const w = de.KeyboardManager.platform.isMac;
              if (!(p.button !== 0 || p.ctrlKey && w) && p.target === this.div && ke(this, e)) {
                if (Tt(this, e, !1), !ke(this, t)) {
                  Tt(this, t, !0);
                  return;
                }
                wt(this, n, bi).call(this, p);
              }
            }
            pointerdown(p) {
              const w = de.KeyboardManager.platform.isMac;
              if (p.button !== 0 || p.ctrlKey && w || p.target !== this.div)
                return;
              Tt(this, e, !0);
              const X = ke(this, r).getActive();
              Tt(this, t, !X || X.isEmpty());
            }
            drop(p) {
              const w = p.dataTransfer.getData("text/plain"), X = ke(this, r).getEditor(w);
              if (!X)
                return;
              p.preventDefault(), p.dataTransfer.dropEffect = "move", wt(this, h, xi).call(this, X);
              const M = this.div.getBoundingClientRect(), j = p.clientX - M.x, B = p.clientY - M.y;
              X.translate(j - X.startX, B - X.startY), this.moveEditorInDOM(X), X.div.focus();
            }
            dragover(p) {
              p.preventDefault();
            }
            destroy() {
              var p, w;
              ((p = ke(this, r).getActive()) == null ? void 0 : p.parent) === this && ke(this, r).setActiveEditor(null);
              for (const X of ke(this, a).values())
                (w = ke(this, P)) == null || w.removePointerInTextLayer(X.contentDiv), X.isAttachedToDOM = !1, X.div.remove(), X.parent = null;
              this.div = null, ke(this, a).clear(), ke(this, r).removeLayer(this);
            }
            render(p) {
              this.viewport = p.viewport, (0, de.bindEvents)(this, this.div, ["dragover", "drop"]), this.setDimensions();
              for (const w of ke(this, r).getEditors(this.pageIndex))
                this.add(w);
              this.updateMode();
            }
            update(p) {
              this.viewport = p.viewport, this.setDimensions(), this.updateMode();
            }
            get scaleFactor() {
              return this.viewport.scale;
            }
            get pageDimensions() {
              const [p, w, X, M] = this.viewport.viewBox, j = X - p, B = M - w;
              return [j, B];
            }
            get viewportBaseDimensions() {
              const {
                width: p,
                height: w,
                rotation: X
              } = this.viewport;
              return X % 180 === 0 ? [p, w] : [w, p];
            }
            setDimensions() {
              const {
                width: p,
                height: w,
                rotation: X
              } = this.viewport, M = X % 180 !== 0, j = Math.floor(p) + "px", B = Math.floor(w) + "px";
              this.div.style.width = M ? B : j, this.div.style.height = M ? j : B, this.div.setAttribute("data-main-rotation", X);
            }
          };
          let u = m;
          P = new WeakMap(), t = new WeakMap(), i = new WeakMap(), v = new WeakMap(), a = new WeakMap(), e = new WeakMap(), y = new WeakMap(), r = new WeakMap(), h = new WeakSet(), xi = function(p) {
            var w;
            p.parent !== this && (this.attach(p), p.pageIndex = this.pageIndex, (w = p.parent) == null || w.detach(p), p.parent = this, p.div && p.isAttachedToDOM && (p.div.remove(), this.div.append(p.div)));
          }, d = new WeakSet(), Ni = function(p) {
            switch (ke(this, r).getMode()) {
              case oe.AnnotationEditorType.FREETEXT:
                return new se.FreeTextEditor(p);
              case oe.AnnotationEditorType.INK:
                return new Q.InkEditor(p);
            }
            return null;
          }, n = new WeakSet(), bi = function(p) {
            const w = this.getNextId(), X = wt(this, d, Ni).call(this, {
              parent: this,
              id: w,
              x: p.offsetX,
              y: p.offsetY
            });
            return X && this.add(X), X;
          }, x = new WeakSet(), ji = function() {
            Tt(this, y, !0);
            for (const p of ke(this, a).values())
              p.isEmpty() && p.remove();
            Tt(this, y, !1);
          }, sn(u, "_initialized", !1), ge.AnnotationEditorLayer = u;
        },
        /* 23 */
        /***/
        (Ee, ge, le) => {
          var u, P, t, i, v, a, e, y, Wi, h, $i, d, Xi, n, yi;
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.FreeTextEditor = void 0;
          var de = le(1), oe = le(7), se = le(6);
          const x = class extends se.AnnotationEditor {
            constructor(C) {
              super({
                ...C,
                name: "freeTextEditor"
              });
              ft(this, y);
              ft(this, h);
              ft(this, d);
              ft(this, n);
              ft(this, u, this.editorDivBlur.bind(this));
              ft(this, P, this.editorDivFocus.bind(this));
              ft(this, t, this.editorDivKeydown.bind(this));
              ft(this, i, void 0);
              ft(this, v, "");
              ft(this, a, !1);
              ft(this, e, void 0);
              Tt(this, i, C.color || x._defaultColor || se.AnnotationEditor._defaultLineColor), Tt(this, e, C.fontSize || x._defaultFontSize);
            }
            static initialize(C) {
              this._l10nPromise = new Map(["free_text_default_content", "editor_free_text_aria_label"].map((w) => [w, C.get(w)]));
              const p = getComputedStyle(document.documentElement);
              this._internalPadding = parseFloat(p.getPropertyValue("--freetext-padding"));
            }
            static updateDefaultParams(C, p) {
              switch (C) {
                case de.AnnotationEditorParamsType.FREETEXT_SIZE:
                  x._defaultFontSize = p;
                  break;
                case de.AnnotationEditorParamsType.FREETEXT_COLOR:
                  x._defaultColor = p;
                  break;
              }
            }
            updateParams(C, p) {
              switch (C) {
                case de.AnnotationEditorParamsType.FREETEXT_SIZE:
                  wt(this, y, Wi).call(this, p);
                  break;
                case de.AnnotationEditorParamsType.FREETEXT_COLOR:
                  wt(this, h, $i).call(this, p);
                  break;
              }
            }
            static get defaultPropertiesToUpdate() {
              return [[de.AnnotationEditorParamsType.FREETEXT_SIZE, x._defaultFontSize], [de.AnnotationEditorParamsType.FREETEXT_COLOR, x._defaultColor || se.AnnotationEditor._defaultLineColor]];
            }
            get propertiesToUpdate() {
              return [[de.AnnotationEditorParamsType.FREETEXT_SIZE, ke(this, e)], [de.AnnotationEditorParamsType.FREETEXT_COLOR, ke(this, i)]];
            }
            getInitialTranslation() {
              return [-x._internalPadding * this.parent.scaleFactor, -(x._internalPadding + ke(this, e)) * this.parent.scaleFactor];
            }
            rebuild() {
              super.rebuild(), this.div !== null && (this.isAttachedToDOM || this.parent.add(this));
            }
            enableEditMode() {
              this.isInEditMode() || (this.parent.setEditingState(!1), this.parent.updateToolbar(de.AnnotationEditorType.FREETEXT), super.enableEditMode(), this.enableEditing(), this.overlayDiv.classList.remove("enabled"), this.editorDiv.contentEditable = !0, this.div.draggable = !1, this.editorDiv.addEventListener("keydown", ke(this, t)), this.editorDiv.addEventListener("focus", ke(this, P)), this.editorDiv.addEventListener("blur", ke(this, u)));
            }
            disableEditMode() {
              this.isInEditMode() && (this.parent.setEditingState(!0), super.disableEditMode(), this.disableEditing(), this.overlayDiv.classList.add("enabled"), this.editorDiv.contentEditable = !1, this.div.draggable = !0, this.editorDiv.removeEventListener("keydown", ke(this, t)), this.editorDiv.removeEventListener("focus", ke(this, P)), this.editorDiv.removeEventListener("blur", ke(this, u)), this.div.focus(), this.isEditing = !1);
            }
            focusin(C) {
              super.focusin(C), C.target !== this.editorDiv && this.editorDiv.focus();
            }
            onceAdded() {
              this.width || (this.enableEditMode(), this.editorDiv.focus());
            }
            isEmpty() {
              return !this.editorDiv || this.editorDiv.innerText.trim() === "";
            }
            remove() {
              this.isEditing = !1, this.parent.setEditingState(!0), super.remove();
            }
            commit() {
              super.commit(), ke(this, a) || (Tt(this, a, !0), this.parent.addUndoableEditor(this)), this.disableEditMode(), Tt(this, v, wt(this, d, Xi).call(this).trimEnd()), wt(this, n, yi).call(this);
            }
            shouldGetKeyboardEvents() {
              return this.isInEditMode();
            }
            dblclick(C) {
              this.enableEditMode(), this.editorDiv.focus();
            }
            keydown(C) {
              C.target === this.div && C.key === "Enter" && (this.enableEditMode(), this.editorDiv.focus());
            }
            editorDivKeydown(C) {
              x._keyboardManager.exec(this, C);
            }
            editorDivFocus(C) {
              this.isEditing = !0;
            }
            editorDivBlur(C) {
              this.isEditing = !1;
            }
            disableEditing() {
              this.editorDiv.setAttribute("role", "comment"), this.editorDiv.removeAttribute("aria-multiline");
            }
            enableEditing() {
              this.editorDiv.setAttribute("role", "textbox"), this.editorDiv.setAttribute("aria-multiline", !0);
            }
            render() {
              if (this.div)
                return this.div;
              let C, p;
              this.width && (C = this.x, p = this.y), super.render(), this.editorDiv = document.createElement("div"), this.editorDiv.className = "internal", this.editorDiv.setAttribute("id", `${this.id}-editor`), this.enableEditing(), x._l10nPromise.get("editor_free_text_aria_label").then((X) => {
                var M;
                return (M = this.editorDiv) == null ? void 0 : M.setAttribute("aria-label", X);
              }), x._l10nPromise.get("free_text_default_content").then((X) => {
                var M;
                return (M = this.editorDiv) == null ? void 0 : M.setAttribute("default-content", X);
              }), this.editorDiv.contentEditable = !0;
              const {
                style: w
              } = this.editorDiv;
              if (w.fontSize = `calc(${ke(this, e)}px * var(--scale-factor))`, w.color = ke(this, i), this.div.append(this.editorDiv), this.overlayDiv = document.createElement("div"), this.overlayDiv.classList.add("overlay", "enabled"), this.div.append(this.overlayDiv), (0, oe.bindEvents)(this, this.div, ["dblclick", "keydown"]), this.width) {
                const [X, M] = this.parent.viewportBaseDimensions;
                this.setAt(C * X, p * M, this.width * X, this.height * M);
                for (const j of ke(this, v).split(`
`)) {
                  const B = document.createElement("div");
                  B.append(j ? document.createTextNode(j) : document.createElement("br")), this.editorDiv.append(B);
                }
                this.div.draggable = !0, this.editorDiv.contentEditable = !1;
              } else
                this.div.draggable = !1, this.editorDiv.contentEditable = !0;
              return this.div;
            }
            get contentDiv() {
              return this.editorDiv;
            }
            static deserialize(C, p) {
              const w = super.deserialize(C, p);
              return Tt(w, e, C.fontSize), Tt(w, i, de.Util.makeHexColor(...C.color)), Tt(w, v, C.value), w;
            }
            serialize() {
              if (this.isEmpty())
                return null;
              const C = x._internalPadding * this.parent.scaleFactor, p = this.getRect(C, C), w = se.AnnotationEditor._colorManager.convert(getComputedStyle(this.editorDiv).color);
              return {
                annotationType: de.AnnotationEditorType.FREETEXT,
                color: w,
                fontSize: ke(this, e),
                value: ke(this, v),
                pageIndex: this.parent.pageIndex,
                rect: p,
                rotation: this.rotation
              };
            }
          };
          let Q = x;
          u = new WeakMap(), P = new WeakMap(), t = new WeakMap(), i = new WeakMap(), v = new WeakMap(), a = new WeakMap(), e = new WeakMap(), y = new WeakSet(), Wi = function(C) {
            const p = (X) => {
              this.editorDiv.style.fontSize = `calc(${X}px * var(--scale-factor))`, this.translate(0, -(X - ke(this, e)) * this.parent.scaleFactor), Tt(this, e, X), wt(this, n, yi).call(this);
            }, w = ke(this, e);
            this.parent.addCommands({
              cmd: () => {
                p(C);
              },
              undo: () => {
                p(w);
              },
              mustExec: !0,
              type: de.AnnotationEditorParamsType.FREETEXT_SIZE,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }, h = new WeakSet(), $i = function(C) {
            const p = ke(this, i);
            this.parent.addCommands({
              cmd: () => {
                Tt(this, i, C), this.editorDiv.style.color = C;
              },
              undo: () => {
                Tt(this, i, p), this.editorDiv.style.color = p;
              },
              mustExec: !0,
              type: de.AnnotationEditorParamsType.FREETEXT_COLOR,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }, d = new WeakSet(), Xi = function() {
            const C = this.editorDiv.getElementsByTagName("div");
            if (C.length === 0)
              return this.editorDiv.innerText;
            const p = [];
            for (let w = 0, X = C.length; w < X; w++) {
              const j = C[w].firstChild;
              (j == null ? void 0 : j.nodeName) === "#text" ? p.push(j.data) : p.push("");
            }
            return p.join(`
`);
          }, n = new WeakSet(), yi = function() {
            const [C, p] = this.parent.viewportBaseDimensions, w = this.div.getBoundingClientRect();
            this.width = w.width / C, this.height = w.height / p;
          }, sn(Q, "_freeTextDefaultContent", ""), sn(Q, "_l10nPromise"), sn(Q, "_internalPadding", 0), sn(Q, "_defaultColor", null), sn(Q, "_defaultFontSize", 10), sn(Q, "_keyboardManager", new oe.KeyboardManager([[["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], x.prototype.commitOrRemove]])), sn(Q, "_type", "freetext"), ge.FreeTextEditor = Q;
        },
        /* 24 */
        /***/
        (Ee, ge, le) => {
          var t, i, v, a, e, y, r, h, g, d, c, n, o, x, f, Hi, C, zi, w, Gi, M, Vi, B, vi, D, qi, l, Yi, S, Ki, F, Sn, O, wi, G, Qn, W, ei, V, $n, Y, Ai, ie, ti, N, Si, E, Zi, re, Ji, $, Qi, H, Ci, ae, ni, ue, Xn, me, Fi;
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.InkEditor = void 0, Object.defineProperty(ge, "fitCurve", {
            enumerable: !0,
            get: function() {
              return se.fitCurve;
            }
          });
          var de = le(1), oe = le(6), se = le(25), Q = le(7);
          const u = 16, we = class extends oe.AnnotationEditor {
            constructor(xe) {
              super({
                ...xe,
                name: "inkEditor"
              });
              ft(this, f);
              ft(this, C);
              ft(this, w);
              ft(this, M);
              ft(this, B);
              ft(this, D);
              ft(this, l);
              ft(this, S);
              ft(this, F);
              ft(this, O);
              ft(this, G);
              ft(this, W);
              ft(this, V);
              ft(this, Y);
              ft(this, ie);
              ft(this, E);
              ft(this, re);
              ft(this, $);
              ft(this, H);
              ft(this, ae);
              ft(this, ue);
              ft(this, me);
              ft(this, t, 0);
              ft(this, i, 0);
              ft(this, v, 0);
              ft(this, a, this.canvasPointermove.bind(this));
              ft(this, e, this.canvasPointerleave.bind(this));
              ft(this, y, this.canvasPointerup.bind(this));
              ft(this, r, this.canvasPointerdown.bind(this));
              ft(this, h, !1);
              ft(this, g, !1);
              ft(this, d, null);
              ft(this, c, null);
              ft(this, n, 0);
              ft(this, o, 0);
              ft(this, x, null);
              this.color = xe.color || null, this.thickness = xe.thickness || null, this.opacity = xe.opacity || null, this.paths = [], this.bezierPath2D = [], this.currentPath = [], this.scaleFactor = 1, this.translationX = this.translationY = 0, this.x = 0, this.y = 0;
            }
            static initialize(xe) {
              this._l10nPromise = new Map(["editor_ink_canvas_aria_label", "editor_ink_aria_label"].map((Te) => [Te, xe.get(Te)]));
            }
            static updateDefaultParams(xe, Te) {
              switch (xe) {
                case de.AnnotationEditorParamsType.INK_THICKNESS:
                  we._defaultThickness = Te;
                  break;
                case de.AnnotationEditorParamsType.INK_COLOR:
                  we._defaultColor = Te;
                  break;
                case de.AnnotationEditorParamsType.INK_OPACITY:
                  we._defaultOpacity = Te / 100;
                  break;
              }
            }
            updateParams(xe, Te) {
              switch (xe) {
                case de.AnnotationEditorParamsType.INK_THICKNESS:
                  wt(this, f, Hi).call(this, Te);
                  break;
                case de.AnnotationEditorParamsType.INK_COLOR:
                  wt(this, C, zi).call(this, Te);
                  break;
                case de.AnnotationEditorParamsType.INK_OPACITY:
                  wt(this, w, Gi).call(this, Te);
                  break;
              }
            }
            static get defaultPropertiesToUpdate() {
              return [[de.AnnotationEditorParamsType.INK_THICKNESS, we._defaultThickness], [de.AnnotationEditorParamsType.INK_COLOR, we._defaultColor || oe.AnnotationEditor._defaultLineColor], [de.AnnotationEditorParamsType.INK_OPACITY, Math.round(we._defaultOpacity * 100)]];
            }
            get propertiesToUpdate() {
              return [[de.AnnotationEditorParamsType.INK_THICKNESS, this.thickness || we._defaultThickness], [de.AnnotationEditorParamsType.INK_COLOR, this.color || we._defaultColor || oe.AnnotationEditor._defaultLineColor], [de.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * (this.opacity ?? we._defaultOpacity))]];
            }
            rebuild() {
              super.rebuild(), this.div !== null && (this.canvas || (wt(this, G, Qn).call(this), wt(this, W, ei).call(this)), this.isAttachedToDOM || (this.parent.add(this), wt(this, V, $n).call(this)), wt(this, ue, Xn).call(this));
            }
            remove() {
              this.canvas !== null && (this.isEmpty() || this.commit(), this.canvas.width = this.canvas.height = 0, this.canvas.remove(), this.canvas = null, ke(this, c).disconnect(), Tt(this, c, null), super.remove());
            }
            enableEditMode() {
              ke(this, h) || this.canvas === null || (super.enableEditMode(), this.div.draggable = !1, this.canvas.addEventListener("pointerdown", ke(this, r)), this.canvas.addEventListener("pointerup", ke(this, y)));
            }
            disableEditMode() {
              !this.isInEditMode() || this.canvas === null || (super.disableEditMode(), this.div.draggable = !this.isEmpty(), this.div.classList.remove("editing"), this.canvas.removeEventListener("pointerdown", ke(this, r)), this.canvas.removeEventListener("pointerup", ke(this, y)));
            }
            onceAdded() {
              this.div.draggable = !this.isEmpty();
            }
            isEmpty() {
              return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;
            }
            commit() {
              ke(this, h) || (super.commit(), this.isEditing = !1, this.disableEditMode(), this.setInForeground(), Tt(this, h, !0), this.div.classList.add("disabled"), wt(this, ue, Xn).call(this, !0), this.parent.addInkEditorIfNeeded(!0), this.parent.moveEditorInDOM(this), this.div.focus());
            }
            focusin(xe) {
              super.focusin(xe), this.enableEditMode();
            }
            canvasPointerdown(xe) {
              xe.button !== 0 || !this.isInEditMode() || ke(this, h) || (this.setInForeground(), xe.type !== "mouse" && this.div.focus(), xe.stopPropagation(), this.canvas.addEventListener("pointerleave", ke(this, e)), this.canvas.addEventListener("pointermove", ke(this, a)), wt(this, D, qi).call(this, xe.offsetX, xe.offsetY));
            }
            canvasPointermove(xe) {
              xe.stopPropagation(), wt(this, l, Yi).call(this, xe.offsetX, xe.offsetY);
            }
            canvasPointerup(xe) {
              xe.button === 0 && this.isInEditMode() && this.currentPath.length !== 0 && (xe.stopPropagation(), wt(this, O, wi).call(this, xe), this.setInBackground());
            }
            canvasPointerleave(xe) {
              wt(this, O, wi).call(this, xe), this.setInBackground();
            }
            render() {
              if (this.div)
                return this.div;
              let xe, Te;
              this.width && (xe = this.x, Te = this.y), super.render(), we._l10nPromise.get("editor_ink_aria_label").then((ze) => {
                var nt;
                return (nt = this.div) == null ? void 0 : nt.setAttribute("aria-label", ze);
              });
              const [ve, Se, be, Le] = wt(this, M, Vi).call(this);
              if (this.setAt(ve, Se, 0, 0), this.setDims(be, Le), wt(this, G, Qn).call(this), this.width) {
                const [ze, nt] = this.parent.viewportBaseDimensions;
                this.setAt(xe * ze, Te * nt, this.width * ze, this.height * nt), Tt(this, g, !0), wt(this, V, $n).call(this), this.setDims(this.width * ze, this.height * nt), wt(this, F, Sn).call(this), wt(this, me, Fi).call(this), this.div.classList.add("disabled");
              } else
                this.div.classList.add("editing"), this.enableEditMode();
              return wt(this, W, ei).call(this), this.div;
            }
            setDimensions(xe, Te) {
              const ve = Math.round(xe), Se = Math.round(Te);
              if (ke(this, n) === ve && ke(this, o) === Se)
                return;
              Tt(this, n, ve), Tt(this, o, Se), this.canvas.style.visibility = "hidden", ke(this, t) && Math.abs(ke(this, t) - xe / Te) > 0.01 && (Te = Math.ceil(xe / ke(this, t)), this.setDims(xe, Te));
              const [be, Le] = this.parent.viewportBaseDimensions;
              this.width = xe / be, this.height = Te / Le, ke(this, h) && wt(this, Y, Ai).call(this, xe, Te), wt(this, V, $n).call(this), wt(this, F, Sn).call(this), this.canvas.style.visibility = "visible";
            }
            static deserialize(xe, Te) {
              var _e, at;
              const ve = super.deserialize(xe, Te);
              ve.thickness = xe.thickness, ve.color = de.Util.makeHexColor(...xe.color), ve.opacity = xe.opacity;
              const [Se, be] = Te.pageDimensions, Le = ve.width * Se, ze = ve.height * be, nt = Te.scaleFactor, Ue = xe.thickness / 2;
              Tt(ve, t, Le / ze), Tt(ve, h, !0), Tt(ve, n, Math.round(Le)), Tt(ve, o, Math.round(ze));
              for (const {
                bezier: Je
              } of xe.paths) {
                const ot = [];
                ve.paths.push(ot);
                let mt = nt * (Je[0] - Ue), Ze = nt * (ze - Je[1] - Ue);
                for (let Ft = 2, $e = Je.length; Ft < $e; Ft += 6) {
                  const St = nt * (Je[Ft] - Ue), xt = nt * (ze - Je[Ft + 1] - Ue), Ie = nt * (Je[Ft + 2] - Ue), Ve = nt * (ze - Je[Ft + 3] - Ue), st = nt * (Je[Ft + 4] - Ue), ct = nt * (ze - Je[Ft + 5] - Ue);
                  ot.push([[mt, Ze], [St, xt], [Ie, Ve], [st, ct]]), mt = st, Ze = ct;
                }
                const pt = wt(this, N, Si).call(this, ot);
                ve.bezierPath2D.push(pt);
              }
              const Oe = wt(_e = ve, H, Ci).call(_e);
              return Tt(ve, v, Math.max(u, Oe[2] - Oe[0])), Tt(ve, i, Math.max(u, Oe[3] - Oe[1])), wt(at = ve, Y, Ai).call(at, Le, ze), ve;
            }
            serialize() {
              if (this.isEmpty())
                return null;
              const xe = this.getRect(0, 0), Te = this.rotation % 180 === 0 ? xe[3] - xe[1] : xe[2] - xe[0], ve = oe.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);
              return {
                annotationType: de.AnnotationEditorType.INK,
                color: ve,
                thickness: this.thickness,
                opacity: this.opacity,
                paths: wt(this, E, Zi).call(this, this.scaleFactor / this.parent.scaleFactor, this.translationX, this.translationY, Te),
                pageIndex: this.parent.pageIndex,
                rect: xe,
                rotation: this.rotation
              };
            }
          };
          let P = we;
          t = new WeakMap(), i = new WeakMap(), v = new WeakMap(), a = new WeakMap(), e = new WeakMap(), y = new WeakMap(), r = new WeakMap(), h = new WeakMap(), g = new WeakMap(), d = new WeakMap(), c = new WeakMap(), n = new WeakMap(), o = new WeakMap(), x = new WeakMap(), f = new WeakSet(), Hi = function(xe) {
            const Te = this.thickness;
            this.parent.addCommands({
              cmd: () => {
                this.thickness = xe, wt(this, ue, Xn).call(this);
              },
              undo: () => {
                this.thickness = Te, wt(this, ue, Xn).call(this);
              },
              mustExec: !0,
              type: de.AnnotationEditorParamsType.INK_THICKNESS,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }, C = new WeakSet(), zi = function(xe) {
            const Te = this.color;
            this.parent.addCommands({
              cmd: () => {
                this.color = xe, wt(this, F, Sn).call(this);
              },
              undo: () => {
                this.color = Te, wt(this, F, Sn).call(this);
              },
              mustExec: !0,
              type: de.AnnotationEditorParamsType.INK_COLOR,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }, w = new WeakSet(), Gi = function(xe) {
            xe /= 100;
            const Te = this.opacity;
            this.parent.addCommands({
              cmd: () => {
                this.opacity = xe, wt(this, F, Sn).call(this);
              },
              undo: () => {
                this.opacity = Te, wt(this, F, Sn).call(this);
              },
              mustExec: !0,
              type: de.AnnotationEditorParamsType.INK_OPACITY,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }, M = new WeakSet(), Vi = function() {
            const {
              width: xe,
              height: Te,
              rotation: ve
            } = this.parent.viewport;
            switch (ve) {
              case 90:
                return [0, xe, xe, Te];
              case 180:
                return [xe, Te, xe, Te];
              case 270:
                return [Te, 0, xe, Te];
              default:
                return [0, 0, xe, Te];
            }
          }, B = new WeakSet(), vi = function() {
            this.ctx.lineWidth = this.thickness * this.parent.scaleFactor / this.scaleFactor, this.ctx.lineCap = "round", this.ctx.lineJoin = "round", this.ctx.miterLimit = 10, this.ctx.strokeStyle = `${this.color}${(0, Q.opacityToHex)(this.opacity)}`;
          }, D = new WeakSet(), qi = function(xe, Te) {
            this.isEditing = !0, ke(this, g) || (Tt(this, g, !0), wt(this, V, $n).call(this), this.thickness || (this.thickness = we._defaultThickness), this.color || (this.color = we._defaultColor || oe.AnnotationEditor._defaultLineColor), this.opacity ?? (this.opacity = we._defaultOpacity)), this.currentPath.push([xe, Te]), Tt(this, d, null), wt(this, B, vi).call(this), this.ctx.beginPath(), this.ctx.moveTo(xe, Te), Tt(this, x, () => {
              ke(this, x) && (ke(this, d) && (this.isEmpty() ? (this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)) : wt(this, F, Sn).call(this), this.ctx.lineTo(...ke(this, d)), Tt(this, d, null), this.ctx.stroke()), window.requestAnimationFrame(ke(this, x)));
            }), window.requestAnimationFrame(ke(this, x));
          }, l = new WeakSet(), Yi = function(xe, Te) {
            const [ve, Se] = this.currentPath.at(-1);
            xe === ve && Te === Se || (this.currentPath.push([xe, Te]), Tt(this, d, [xe, Te]));
          }, S = new WeakSet(), Ki = function(xe, Te) {
            var Ue;
            this.ctx.closePath(), Tt(this, x, null), xe = Math.min(Math.max(xe, 0), this.canvas.width), Te = Math.min(Math.max(Te, 0), this.canvas.height);
            const [ve, Se] = this.currentPath.at(-1);
            (xe !== ve || Te !== Se) && this.currentPath.push([xe, Te]);
            let be;
            if (this.currentPath.length !== 1)
              be = (0, se.fitCurve)(this.currentPath, 30, null);
            else {
              const Oe = [xe, Te];
              be = [[Oe, Oe.slice(), Oe.slice(), Oe]];
            }
            const Le = wt(Ue = we, N, Si).call(Ue, be);
            this.currentPath.length = 0;
            const ze = () => {
              this.paths.push(be), this.bezierPath2D.push(Le), this.rebuild();
            }, nt = () => {
              this.paths.pop(), this.bezierPath2D.pop(), this.paths.length === 0 ? this.remove() : (this.canvas || (wt(this, G, Qn).call(this), wt(this, W, ei).call(this)), wt(this, ue, Xn).call(this));
            };
            this.parent.addCommands({
              cmd: ze,
              undo: nt,
              mustExec: !0
            });
          }, F = new WeakSet(), Sn = function() {
            if (this.isEmpty()) {
              wt(this, ie, ti).call(this);
              return;
            }
            wt(this, B, vi).call(this);
            const {
              canvas: xe,
              ctx: Te
            } = this;
            Te.setTransform(1, 0, 0, 1, 0, 0), Te.clearRect(0, 0, xe.width, xe.height), wt(this, ie, ti).call(this);
            for (const ve of this.bezierPath2D)
              Te.stroke(ve);
          }, O = new WeakSet(), wi = function(xe) {
            wt(this, S, Ki).call(this, xe.offsetX, xe.offsetY), this.canvas.removeEventListener("pointerleave", ke(this, e)), this.canvas.removeEventListener("pointermove", ke(this, a)), this.parent.addToAnnotationStorage(this);
          }, G = new WeakSet(), Qn = function() {
            this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = 0, this.canvas.className = "inkEditorCanvas", we._l10nPromise.get("editor_ink_canvas_aria_label").then((xe) => {
              var Te;
              return (Te = this.canvas) == null ? void 0 : Te.setAttribute("aria-label", xe);
            }), this.div.append(this.canvas), this.ctx = this.canvas.getContext("2d");
          }, W = new WeakSet(), ei = function() {
            Tt(this, c, new ResizeObserver((xe) => {
              const Te = xe[0].contentRect;
              Te.width && Te.height && this.setDimensions(Te.width, Te.height);
            })), ke(this, c).observe(this.div);
          }, V = new WeakSet(), $n = function() {
            if (!ke(this, g))
              return;
            const [xe, Te] = this.parent.viewportBaseDimensions;
            this.canvas.width = Math.ceil(this.width * xe), this.canvas.height = Math.ceil(this.height * Te), wt(this, ie, ti).call(this);
          }, Y = new WeakSet(), Ai = function(xe, Te) {
            const ve = wt(this, ae, ni).call(this), Se = (xe - ve) / ke(this, v), be = (Te - ve) / ke(this, i);
            this.scaleFactor = Math.min(Se, be);
          }, ie = new WeakSet(), ti = function() {
            const xe = wt(this, ae, ni).call(this) / 2;
            this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + xe, this.translationY * this.scaleFactor + xe);
          }, N = new WeakSet(), Si = function(xe) {
            const Te = new Path2D();
            for (let ve = 0, Se = xe.length; ve < Se; ve++) {
              const [be, Le, ze, nt] = xe[ve];
              ve === 0 && Te.moveTo(...be), Te.bezierCurveTo(Le[0], Le[1], ze[0], ze[1], nt[0], nt[1]);
            }
            return Te;
          }, E = new WeakSet(), Zi = function(xe, Te, ve, Se) {
            const Le = [], ze = this.thickness / 2;
            let nt, Ue;
            for (const Oe of this.paths) {
              nt = [], Ue = [];
              for (let _e = 0, at = Oe.length; _e < at; _e++) {
                const [Je, ot, mt, Ze] = Oe[_e], pt = xe * (Je[0] + Te) + ze, Ft = Se - xe * (Je[1] + ve) - ze, $e = xe * (ot[0] + Te) + ze, St = Se - xe * (ot[1] + ve) - ze, xt = xe * (mt[0] + Te) + ze, Ie = Se - xe * (mt[1] + ve) - ze, Ve = xe * (Ze[0] + Te) + ze, st = Se - xe * (Ze[1] + ve) - ze;
                _e === 0 && (nt.push(pt, Ft), Ue.push(pt, Ft)), nt.push($e, St, xt, Ie, Ve, st), wt(this, re, Ji).call(this, pt, Ft, $e, St, xt, Ie, Ve, st, 4, Ue);
              }
              Le.push({
                bezier: nt,
                points: Ue
              });
            }
            return Le;
          }, re = new WeakSet(), Ji = function(xe, Te, ve, Se, be, Le, ze, nt, Ue, Oe) {
            if (wt(this, $, Qi).call(this, xe, Te, ve, Se, be, Le, ze, nt)) {
              Oe.push(ze, nt);
              return;
            }
            for (let _e = 1; _e < Ue - 1; _e++) {
              const at = _e / Ue, Je = 1 - at;
              let ot = at * xe + Je * ve, mt = at * Te + Je * Se, Ze = at * ve + Je * be, pt = at * Se + Je * Le;
              const Ft = at * be + Je * ze, $e = at * Le + Je * nt;
              ot = at * ot + Je * Ze, mt = at * mt + Je * pt, Ze = at * Ze + Je * Ft, pt = at * pt + Je * $e, ot = at * ot + Je * Ze, mt = at * mt + Je * pt, Oe.push(ot, mt);
            }
            Oe.push(ze, nt);
          }, $ = new WeakSet(), Qi = function(xe, Te, ve, Se, be, Le, ze, nt) {
            const Oe = (3 * ve - 2 * xe - ze) ** 2, _e = (3 * Se - 2 * Te - nt) ** 2, at = (3 * be - xe - 2 * ze) ** 2, Je = (3 * Le - Te - 2 * nt) ** 2;
            return Math.max(Oe, at) + Math.max(_e, Je) <= 10;
          }, H = new WeakSet(), Ci = function() {
            let xe = 1 / 0, Te = -1 / 0, ve = 1 / 0, Se = -1 / 0;
            for (const be of this.paths)
              for (const [Le, ze, nt, Ue] of be) {
                const Oe = de.Util.bezierBoundingBox(...Le, ...ze, ...nt, ...Ue);
                xe = Math.min(xe, Oe[0]), ve = Math.min(ve, Oe[1]), Te = Math.max(Te, Oe[2]), Se = Math.max(Se, Oe[3]);
              }
            return [xe, ve, Te, Se];
          }, ae = new WeakSet(), ni = function() {
            return ke(this, h) ? Math.ceil(this.thickness * this.parent.scaleFactor) : 0;
          }, ue = new WeakSet(), Xn = function(xe = !1) {
            if (this.isEmpty())
              return;
            if (!ke(this, h)) {
              wt(this, F, Sn).call(this);
              return;
            }
            const Te = wt(this, H, Ci).call(this), ve = wt(this, ae, ni).call(this);
            Tt(this, v, Math.max(u, Te[2] - Te[0])), Tt(this, i, Math.max(u, Te[3] - Te[1]));
            const Se = Math.ceil(ve + ke(this, v) * this.scaleFactor), be = Math.ceil(ve + ke(this, i) * this.scaleFactor), [Le, ze] = this.parent.viewportBaseDimensions;
            this.width = Se / Le, this.height = be / ze, Tt(this, t, Se / be), wt(this, me, Fi).call(this);
            const nt = this.translationX, Ue = this.translationY;
            this.translationX = -Te[0], this.translationY = -Te[1], wt(this, V, $n).call(this), wt(this, F, Sn).call(this), Tt(this, n, Se), Tt(this, o, be), this.setDims(Se, be);
            const Oe = xe ? ve / this.scaleFactor / 2 : 0;
            this.translate(nt - this.translationX - Oe, Ue - this.translationY - Oe);
          }, me = new WeakSet(), Fi = function() {
            const {
              style: xe
            } = this.div;
            ke(this, t) >= 1 ? (xe.minHeight = `${u}px`, xe.minWidth = `${Math.round(ke(this, t) * u)}px`) : (xe.minWidth = `${u}px`, xe.minHeight = `${Math.round(u / ke(this, t))}px`);
          }, ft(P, N), sn(P, "_defaultColor", null), sn(P, "_defaultOpacity", 1), sn(P, "_defaultThickness", 1), sn(P, "_l10nPromise"), sn(P, "_type", "ink"), ge.InkEditor = P;
        },
        /* 25 */
        /***/
        (Ee, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.fitCurve = void 0;
          const de = le(26);
          ge.fitCurve = de;
        },
        /* 26 */
        /***/
        (Ee) => {
          function ge(y, r, h) {
            if (!Array.isArray(y))
              throw new TypeError("First argument should be an array");
            if (y.forEach((n) => {
              if (!Array.isArray(n) || n.some((o) => typeof o != "number") || n.length !== y[0].length)
                throw Error("Each point should be an array of numbers. Each point should have the same amount of numbers.");
            }), y = y.filter((n, o) => o === 0 || !n.every((x, f) => x === y[o - 1][f])), y.length < 2)
              return [];
            const g = y.length, d = v(y[1], y[0]), c = v(y[g - 2], y[g - 1]);
            return le(y, d, c, r, h);
          }
          function le(y, r, h, g, d) {
            var n, o, x, f, m, C, p, w, X, M, j, B, R;
            if (y.length === 2)
              return B = a.vectorLen(a.subtract(y[0], y[1])) / 3, n = [y[0], a.addArrays(y[0], a.mulItems(r, B)), a.addArrays(y[1], a.mulItems(h, B)), y[1]], [n];
            if (o = u(y), [n, f, C] = de(y, o, o, r, h, d), f === 0 || f < g)
              return [n];
            if (f < g * g)
              for (x = o, m = f, p = C, R = 0; R < 20; R++) {
                if (x = se(n, y, x), [n, f, C] = de(y, o, x, r, h, d), f < g)
                  return [n];
                if (C === p) {
                  let D = f / m;
                  if (D > 0.9999 && D < 1.0001)
                    break;
                }
                m = f, p = C;
              }
            return j = [], w = a.subtract(y[C - 1], y[C + 1]), w.every((D) => D === 0) && (w = a.subtract(y[C - 1], y[C]), [w[0], w[1]] = [-w[1], w[0]]), X = a.normalize(w), M = a.mulItems(X, -1), j = j.concat(le(y.slice(0, C + 1), r, X, g, d)), j = j.concat(le(y.slice(C), M, h, g, d)), j;
          }
          function de(y, r, h, g, d, c) {
            var n, o, x;
            return n = oe(y, h, g, d), [o, x] = P(y, n, r), c && c({
              bez: n,
              points: y,
              params: r,
              maxErr: o,
              maxPoint: x
            }), [n, o, x];
          }
          function oe(y, r, h, g) {
            var d, c, n, o, x, f, m, C, p, w, X, M, j, B, R, D, b, l = y[0], _ = y[y.length - 1];
            for (d = [l, null, null, _], c = a.zeros_Xx2x2(r.length), j = 0, B = r.length; j < B; j++)
              D = r[j], b = 1 - D, n = c[j], n[0] = a.mulItems(h, 3 * D * (b * b)), n[1] = a.mulItems(g, 3 * b * (D * D));
            for (o = [[0, 0], [0, 0]], x = [0, 0], j = 0, B = y.length; j < B; j++)
              D = r[j], n = c[j], o[0][0] += a.dot(n[0], n[0]), o[0][1] += a.dot(n[0], n[1]), o[1][0] += a.dot(n[0], n[1]), o[1][1] += a.dot(n[1], n[1]), R = a.subtract(y[j], e.q([l, l, _, _], D)), x[0] += a.dot(n[0], R), x[1] += a.dot(n[1], R);
            return f = o[0][0] * o[1][1] - o[1][0] * o[0][1], m = o[0][0] * x[1] - o[1][0] * x[0], C = x[0] * o[1][1] - x[1] * o[0][1], p = f === 0 ? 0 : C / f, w = f === 0 ? 0 : m / f, M = a.vectorLen(a.subtract(l, _)), X = 1e-6 * M, p < X || w < X ? (d[1] = a.addArrays(l, a.mulItems(h, M / 3)), d[2] = a.addArrays(_, a.mulItems(g, M / 3))) : (d[1] = a.addArrays(l, a.mulItems(h, p)), d[2] = a.addArrays(_, a.mulItems(g, w))), d;
          }
          function se(y, r, h) {
            return h.map((g, d) => Q(y, r[d], g));
          }
          function Q(y, r, h) {
            var g = a.subtract(e.q(y, h), r), d = e.qprime(y, h), c = a.mulMatrix(g, d), n = a.sum(a.squareItems(d)) + 2 * a.mulMatrix(g, e.qprimeprime(y, h));
            return n === 0 ? h : h - c / n;
          }
          function u(y) {
            var r = [], h, g, d;
            return y.forEach((c, n) => {
              h = n ? g + a.vectorLen(a.subtract(c, d)) : 0, r.push(h), g = h, d = c;
            }), r = r.map((c) => c / g), r;
          }
          function P(y, r, h) {
            var g, d, c, n, o, x, f, m;
            d = 0, c = Math.floor(y.length / 2);
            const C = t(r, 10);
            for (o = 0, x = y.length; o < x; o++)
              f = y[o], m = i(r, h[o], C, 10), n = a.subtract(e.q(r, m), f), g = n[0] * n[0] + n[1] * n[1], g > d && (d = g, c = o);
            return [d, c];
          }
          var t = function(y, r) {
            for (var h, g = [0], d = y[0], c = 0, n = 1; n <= r; n++)
              h = e.q(y, n / r), c += a.vectorLen(a.subtract(h, d)), g.push(c), d = h;
            return g = g.map((o) => o / c), g;
          };
          function i(y, r, h, g) {
            if (r < 0)
              return 0;
            if (r > 1)
              return 1;
            for (var d, c, n, o, x, f = 1; f <= g; f++)
              if (r <= h[f]) {
                o = (f - 1) / g, n = f / g, c = h[f - 1], d = h[f], x = (r - c) / (d - c) * (n - o) + o;
                break;
              }
            return x;
          }
          function v(y, r) {
            return a.normalize(a.subtract(y, r));
          }
          class a {
            static zeros_Xx2x2(r) {
              for (var h = []; r--; )
                h.push([0, 0]);
              return h;
            }
            static mulItems(r, h) {
              return r.map((g) => g * h);
            }
            static mulMatrix(r, h) {
              return r.reduce((g, d, c) => g + d * h[c], 0);
            }
            static subtract(r, h) {
              return r.map((g, d) => g - h[d]);
            }
            static addArrays(r, h) {
              return r.map((g, d) => g + h[d]);
            }
            static addItems(r, h) {
              return r.map((g) => g + h);
            }
            static sum(r) {
              return r.reduce((h, g) => h + g);
            }
            static dot(r, h) {
              return a.mulMatrix(r, h);
            }
            static vectorLen(r) {
              return Math.hypot(...r);
            }
            static divItems(r, h) {
              return r.map((g) => g / h);
            }
            static squareItems(r) {
              return r.map((h) => h * h);
            }
            static normalize(r) {
              return this.divItems(r, this.vectorLen(r));
            }
          }
          class e {
            static q(r, h) {
              var g = 1 - h, d = a.mulItems(r[0], g * g * g), c = a.mulItems(r[1], 3 * g * g * h), n = a.mulItems(r[2], 3 * g * h * h), o = a.mulItems(r[3], h * h * h);
              return a.addArrays(a.addArrays(d, c), a.addArrays(n, o));
            }
            static qprime(r, h) {
              var g = 1 - h, d = a.mulItems(a.subtract(r[1], r[0]), 3 * g * g), c = a.mulItems(a.subtract(r[2], r[1]), 6 * g * h), n = a.mulItems(a.subtract(r[3], r[2]), 3 * h * h);
              return a.addArrays(a.addArrays(d, c), n);
            }
            static qprimeprime(r, h) {
              return a.addArrays(a.mulItems(a.addArrays(a.subtract(r[2], a.mulItems(r[1], 2)), r[0]), 6 * (1 - h)), a.mulItems(a.addArrays(a.subtract(r[3], a.mulItems(r[2], 2)), r[1]), 6 * h));
            }
          }
          Ee.exports = ge, Ee.exports.fitCubic = le, Ee.exports.createTangent = v;
        },
        /* 27 */
        /***/
        (Ee, ge, le) => {
          var F, Ti, O, _i, G, Di;
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.AnnotationLayer = void 0;
          var de = le(1), oe = le(8), se = le(5), Q = le(28), u = le(29);
          const P = 1e3, t = 9, i = /* @__PURE__ */ new WeakSet();
          function v(z) {
            return {
              width: z[2] - z[0],
              height: z[3] - z[1]
            };
          }
          class a {
            static create(V) {
              switch (V.data.annotationType) {
                case de.AnnotationType.LINK:
                  return new y(V);
                case de.AnnotationType.TEXT:
                  return new r(V);
                case de.AnnotationType.WIDGET:
                  switch (V.data.fieldType) {
                    case "Tx":
                      return new g(V);
                    case "Btn":
                      return V.data.radioButton ? new c(V) : V.data.checkBox ? new d(V) : new n(V);
                    case "Ch":
                      return new o(V);
                  }
                  return new h(V);
                case de.AnnotationType.POPUP:
                  return new x(V);
                case de.AnnotationType.FREETEXT:
                  return new m(V);
                case de.AnnotationType.LINE:
                  return new C(V);
                case de.AnnotationType.SQUARE:
                  return new p(V);
                case de.AnnotationType.CIRCLE:
                  return new w(V);
                case de.AnnotationType.POLYLINE:
                  return new X(V);
                case de.AnnotationType.CARET:
                  return new j(V);
                case de.AnnotationType.INK:
                  return new B(V);
                case de.AnnotationType.POLYGON:
                  return new M(V);
                case de.AnnotationType.HIGHLIGHT:
                  return new R(V);
                case de.AnnotationType.UNDERLINE:
                  return new D(V);
                case de.AnnotationType.SQUIGGLY:
                  return new b(V);
                case de.AnnotationType.STRIKEOUT:
                  return new l(V);
                case de.AnnotationType.STAMP:
                  return new _(V);
                case de.AnnotationType.FILEATTACHMENT:
                  return new S(V);
                default:
                  return new e(V);
              }
            }
          }
          class e {
            constructor(V, {
              isRenderable: L = !1,
              ignoreBorder: Y = !1,
              createQuadrilaterals: J = !1
            } = {}) {
              this.isRenderable = L, this.data = V.data, this.layer = V.layer, this.page = V.page, this.viewport = V.viewport, this.linkService = V.linkService, this.downloadManager = V.downloadManager, this.imageResourcesPath = V.imageResourcesPath, this.renderForms = V.renderForms, this.svgFactory = V.svgFactory, this.annotationStorage = V.annotationStorage, this.enableScripting = V.enableScripting, this.hasJSActions = V.hasJSActions, this._fieldObjects = V.fieldObjects, this._mouseState = V.mouseState, L && (this.container = this._createContainer(Y)), J && (this.quadrilaterals = this._createQuadrilaterals(Y));
            }
            _createContainer(V = !1) {
              const L = this.data, Y = this.page, J = this.viewport, ie = document.createElement("section"), {
                width: q,
                height: N
              } = v(L.rect), [Z, E, te, re] = J.viewBox, ee = te - Z, $ = re - E;
              ie.setAttribute("data-annotation-id", L.id);
              const k = de.Util.normalizeRect([L.rect[0], Y.view[3] - L.rect[1] + Y.view[1], L.rect[2], Y.view[3] - L.rect[3] + Y.view[1]]);
              if (!V && L.borderStyle.width > 0) {
                ie.style.borderWidth = `${L.borderStyle.width}px`;
                const ne = L.borderStyle.horizontalCornerRadius, ae = L.borderStyle.verticalCornerRadius;
                if (ne > 0 || ae > 0) {
                  const ue = `calc(${ne}px * var(--scale-factor)) / calc(${ae}px * var(--scale-factor))`;
                  ie.style.borderRadius = ue;
                } else if (this instanceof c) {
                  const ue = `calc(${q}px * var(--scale-factor)) / calc(${N}px * var(--scale-factor))`;
                  ie.style.borderRadius = ue;
                }
                switch (L.borderStyle.style) {
                  case de.AnnotationBorderStyleType.SOLID:
                    ie.style.borderStyle = "solid";
                    break;
                  case de.AnnotationBorderStyleType.DASHED:
                    ie.style.borderStyle = "dashed";
                    break;
                  case de.AnnotationBorderStyleType.BEVELED:
                    (0, de.warn)("Unimplemented border style: beveled");
                    break;
                  case de.AnnotationBorderStyleType.INSET:
                    (0, de.warn)("Unimplemented border style: inset");
                    break;
                  case de.AnnotationBorderStyleType.UNDERLINE:
                    ie.style.borderBottomStyle = "solid";
                    break;
                }
                const he = L.borderColor || null;
                he ? ie.style.borderColor = de.Util.makeHexColor(he[0] | 0, he[1] | 0, he[2] | 0) : ie.style.borderWidth = 0;
              }
              ie.style.left = `${100 * (k[0] - Z) / ee}%`, ie.style.top = `${100 * (k[1] - E) / $}%`;
              const {
                rotation: H
              } = L;
              return L.hasOwnCanvas || H === 0 ? (ie.style.width = `${100 * q / ee}%`, ie.style.height = `${100 * N / $}%`) : this.setRotation(H, ie), ie;
            }
            setRotation(V, L = this.container) {
              const [Y, J, ie, q] = this.viewport.viewBox, N = ie - Y, Z = q - J, {
                width: E,
                height: te
              } = v(this.data.rect);
              let re, ee;
              V % 180 === 0 ? (re = 100 * E / N, ee = 100 * te / Z) : (re = 100 * te / N, ee = 100 * E / Z), L.style.width = `${re}%`, L.style.height = `${ee}%`, L.setAttribute("data-main-rotation", (360 - V) % 360);
            }
            get _commonActions() {
              const V = (L, Y, J) => {
                const ie = J.detail[L];
                J.target.style[Y] = Q.ColorConverters[`${ie[0]}_HTML`](ie.slice(1));
              };
              return (0, de.shadow)(this, "_commonActions", {
                display: (L) => {
                  const Y = L.detail.display % 2 === 1;
                  this.container.style.visibility = Y ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
                    hidden: Y,
                    print: L.detail.display === 0 || L.detail.display === 3
                  });
                },
                print: (L) => {
                  this.annotationStorage.setValue(this.data.id, {
                    print: L.detail.print
                  });
                },
                hidden: (L) => {
                  this.container.style.visibility = L.detail.hidden ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
                    hidden: L.detail.hidden
                  });
                },
                focus: (L) => {
                  setTimeout(() => L.target.focus({
                    preventScroll: !1
                  }), 0);
                },
                userName: (L) => {
                  L.target.title = L.detail.userName;
                },
                readonly: (L) => {
                  L.detail.readonly ? L.target.setAttribute("readonly", "") : L.target.removeAttribute("readonly");
                },
                required: (L) => {
                  this._setRequired(L.target, L.detail.required);
                },
                bgColor: (L) => {
                  V("bgColor", "backgroundColor", L);
                },
                fillColor: (L) => {
                  V("fillColor", "backgroundColor", L);
                },
                fgColor: (L) => {
                  V("fgColor", "color", L);
                },
                textColor: (L) => {
                  V("textColor", "color", L);
                },
                borderColor: (L) => {
                  V("borderColor", "borderColor", L);
                },
                strokeColor: (L) => {
                  V("strokeColor", "borderColor", L);
                },
                rotation: (L) => {
                  const Y = L.detail.rotation;
                  this.setRotation(Y), this.annotationStorage.setValue(this.data.id, {
                    rotation: Y
                  });
                }
              });
            }
            _dispatchEventFromSandbox(V, L) {
              const Y = this._commonActions;
              for (const J of Object.keys(L.detail)) {
                const ie = V[J] || Y[J];
                ie && ie(L);
              }
            }
            _setDefaultPropertiesFromJS(V) {
              if (!this.enableScripting)
                return;
              const L = this.annotationStorage.getRawValue(this.data.id);
              if (!L)
                return;
              const Y = this._commonActions;
              for (const [J, ie] of Object.entries(L)) {
                const q = Y[J];
                if (q) {
                  const N = {
                    detail: {
                      [J]: ie
                    },
                    target: V
                  };
                  q(N), delete L[J];
                }
              }
            }
            _createQuadrilaterals(V = !1) {
              if (!this.data.quadPoints)
                return null;
              const L = [], Y = this.data.rect;
              for (const J of this.data.quadPoints)
                this.data.rect = [J[2].x, J[2].y, J[1].x, J[1].y], L.push(this._createContainer(V));
              return this.data.rect = Y, L;
            }
            _createPopup(V, L) {
              let Y = this.container;
              this.quadrilaterals && (V = V || this.quadrilaterals, Y = this.quadrilaterals[0]), V || (V = document.createElement("div"), V.className = "popupTriggerArea", Y.append(V));
              const ie = new f({
                container: Y,
                trigger: V,
                color: L.color,
                titleObj: L.titleObj,
                modificationDate: L.modificationDate,
                contentsObj: L.contentsObj,
                richText: L.richText,
                hideWrapper: !0
              }).render();
              ie.style.left = "100%", Y.append(ie);
            }
            _renderQuadrilaterals(V) {
              for (const L of this.quadrilaterals)
                L.className = V;
              return this.quadrilaterals;
            }
            render() {
              (0, de.unreachable)("Abstract method `AnnotationElement.render` called");
            }
            _getElementsByName(V, L = null) {
              const Y = [];
              if (this._fieldObjects) {
                const J = this._fieldObjects[V];
                if (J)
                  for (const {
                    page: ie,
                    id: q,
                    exportValues: N
                  } of J) {
                    if (ie === -1 || q === L)
                      continue;
                    const Z = typeof N == "string" ? N : null, E = document.querySelector(`[data-element-id="${q}"]`);
                    if (E && !i.has(E)) {
                      (0, de.warn)(`_getElementsByName - element not allowed: ${q}`);
                      continue;
                    }
                    Y.push({
                      id: q,
                      exportValue: Z,
                      domElement: E
                    });
                  }
                return Y;
              }
              for (const J of document.getElementsByName(V)) {
                const {
                  id: ie,
                  exportValue: q
                } = J;
                ie !== L && i.has(J) && Y.push({
                  id: ie,
                  exportValue: q,
                  domElement: J
                });
              }
              return Y;
            }
            static get platform() {
              const V = typeof navigator < "u" ? navigator.platform : "";
              return (0, de.shadow)(this, "platform", {
                isWin: V.includes("Win"),
                isMac: V.includes("Mac")
              });
            }
          }
          class y extends e {
            constructor(V, L = null) {
              super(V, {
                isRenderable: !0,
                ignoreBorder: !!(L != null && L.ignoreBorder),
                createQuadrilaterals: !0
              }), this.isTooltipOnly = V.data.isTooltipOnly;
            }
            render() {
              const {
                data: V,
                linkService: L
              } = this, Y = document.createElement("a");
              Y.setAttribute("data-element-id", V.id);
              let J = !1;
              return V.url ? (L.addLinkAttributes(Y, V.url, V.newWindow), J = !0) : V.action ? (this._bindNamedAction(Y, V.action), J = !0) : V.dest ? (this._bindLink(Y, V.dest), J = !0) : (V.actions && (V.actions.Action || V.actions["Mouse Up"] || V.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions && (this._bindJSAction(Y, V), J = !0), V.resetForm ? (this._bindResetFormAction(Y, V.resetForm), J = !0) : this.isTooltipOnly && !J && (this._bindLink(Y, ""), J = !0)), this.quadrilaterals ? this._renderQuadrilaterals("linkAnnotation").map((ie, q) => {
                const N = q === 0 ? Y : Y.cloneNode();
                return ie.append(N), ie;
              }) : (this.container.className = "linkAnnotation", J && this.container.append(Y), this.container);
            }
            _bindLink(V, L) {
              V.href = this.linkService.getDestinationHash(L), V.onclick = () => (L && this.linkService.goToDestination(L), !1), (L || L === "") && (V.className = "internalLink");
            }
            _bindNamedAction(V, L) {
              V.href = this.linkService.getAnchorUrl(""), V.onclick = () => (this.linkService.executeNamedAction(L), !1), V.className = "internalLink";
            }
            _bindJSAction(V, L) {
              V.href = this.linkService.getAnchorUrl("");
              const Y = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
              for (const J of Object.keys(L.actions)) {
                const ie = Y.get(J);
                ie && (V[ie] = () => {
                  var q;
                  return (q = this.linkService.eventBus) == null || q.dispatch("dispatcheventinsandbox", {
                    source: this,
                    detail: {
                      id: L.id,
                      name: J
                    }
                  }), !1;
                });
              }
              V.onclick || (V.onclick = () => !1), V.className = "internalLink";
            }
            _bindResetFormAction(V, L) {
              const Y = V.onclick;
              if (Y || (V.href = this.linkService.getAnchorUrl("")), V.className = "internalLink", !this._fieldObjects) {
                (0, de.warn)('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.'), Y || (V.onclick = () => !1);
                return;
              }
              V.onclick = () => {
                var te;
                Y && Y();
                const {
                  fields: J,
                  refs: ie,
                  include: q
                } = L, N = [];
                if (J.length !== 0 || ie.length !== 0) {
                  const re = new Set(ie);
                  for (const ee of J) {
                    const $ = this._fieldObjects[ee] || [];
                    for (const {
                      id: k
                    } of $)
                      re.add(k);
                  }
                  for (const ee of Object.values(this._fieldObjects))
                    for (const $ of ee)
                      re.has($.id) === q && N.push($);
                } else
                  for (const re of Object.values(this._fieldObjects))
                    N.push(...re);
                const Z = this.annotationStorage, E = [];
                for (const re of N) {
                  const {
                    id: ee
                  } = re;
                  switch (E.push(ee), re.type) {
                    case "text": {
                      const k = re.defaultValue || "";
                      Z.setValue(ee, {
                        value: k
                      });
                      break;
                    }
                    case "checkbox":
                    case "radiobutton": {
                      const k = re.defaultValue === re.exportValues;
                      Z.setValue(ee, {
                        value: k
                      });
                      break;
                    }
                    case "combobox":
                    case "listbox": {
                      const k = re.defaultValue || "";
                      Z.setValue(ee, {
                        value: k
                      });
                      break;
                    }
                    default:
                      continue;
                  }
                  const $ = document.querySelector(`[data-element-id="${ee}"]`);
                  if ($) {
                    if (!i.has($)) {
                      (0, de.warn)(`_bindResetFormAction - element not allowed: ${ee}`);
                      continue;
                    }
                  } else
                    continue;
                  $.dispatchEvent(new Event("resetform"));
                }
                return this.enableScripting && ((te = this.linkService.eventBus) == null || te.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: "app",
                    ids: E,
                    name: "ResetForm"
                  }
                })), !1;
              };
            }
          }
          class r extends e {
            constructor(V) {
              var Y, J, ie;
              const L = !!(V.data.hasPopup || (Y = V.data.titleObj) != null && Y.str || (J = V.data.contentsObj) != null && J.str || (ie = V.data.richText) != null && ie.str);
              super(V, {
                isRenderable: L
              });
            }
            render() {
              this.container.className = "textAnnotation";
              const V = document.createElement("img");
              return V.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg", V.alt = "[{{type}} Annotation]", V.dataset.l10nId = "text_annotation_type", V.dataset.l10nArgs = JSON.stringify({
                type: this.data.name
              }), this.data.hasPopup || this._createPopup(V, this.data), this.container.append(V), this.container;
            }
          }
          class h extends e {
            render() {
              return this.data.alternativeText && (this.container.title = this.data.alternativeText), this.container;
            }
            _getKeyModifier(V) {
              const {
                isWin: L,
                isMac: Y
              } = e.platform;
              return L && V.ctrlKey || Y && V.metaKey;
            }
            _setEventListener(V, L, Y, J) {
              L.includes("mouse") ? V.addEventListener(L, (ie) => {
                var q;
                (q = this.linkService.eventBus) == null || q.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: this.data.id,
                    name: Y,
                    value: J(ie),
                    shift: ie.shiftKey,
                    modifier: this._getKeyModifier(ie)
                  }
                });
              }) : V.addEventListener(L, (ie) => {
                var q;
                (q = this.linkService.eventBus) == null || q.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: this.data.id,
                    name: Y,
                    value: J(ie)
                  }
                });
              });
            }
            _setEventListeners(V, L, Y) {
              var J;
              for (const [ie, q] of L)
                (q === "Action" || (J = this.data.actions) != null && J[q]) && this._setEventListener(V, ie, q, Y);
            }
            _setBackgroundColor(V) {
              const L = this.data.backgroundColor || null;
              V.style.backgroundColor = L === null ? "transparent" : de.Util.makeHexColor(L[0], L[1], L[2]);
            }
            _setTextStyle(V) {
              const L = ["left", "center", "right"], {
                fontColor: Y
              } = this.data.defaultAppearanceData, J = this.data.defaultAppearanceData.fontSize || t, ie = V.style;
              let q;
              if (this.data.multiLine) {
                const N = Math.abs(this.data.rect[3] - this.data.rect[1]), Z = Math.round(N / (de.LINE_FACTOR * J)) || 1, E = N / Z;
                q = Math.min(J, Math.round(E / de.LINE_FACTOR));
              } else {
                const N = Math.abs(this.data.rect[3] - this.data.rect[1]);
                q = Math.min(J, Math.round(N / de.LINE_FACTOR));
              }
              ie.fontSize = `calc(${q}px * var(--scale-factor))`, ie.color = de.Util.makeHexColor(Y[0], Y[1], Y[2]), this.data.textAlignment !== null && (ie.textAlign = L[this.data.textAlignment]);
            }
            _setRequired(V, L) {
              L ? V.setAttribute("required", !0) : V.removeAttribute("required"), V.setAttribute("aria-required", L);
            }
          }
          class g extends h {
            constructor(V) {
              const L = V.renderForms || !V.data.hasAppearance && !!V.data.fieldValue;
              super(V, {
                isRenderable: L
              });
            }
            setPropertyOnSiblings(V, L, Y, J) {
              const ie = this.annotationStorage;
              for (const q of this._getElementsByName(V.name, V.id))
                q.domElement && (q.domElement[L] = Y), ie.setValue(q.id, {
                  [J]: Y
                });
            }
            render() {
              var J;
              const V = this.annotationStorage, L = this.data.id;
              this.container.className = "textWidgetAnnotation";
              let Y = null;
              if (this.renderForms) {
                const ie = V.getValue(L, {
                  value: this.data.fieldValue
                });
                let q = ie.formattedValue || ie.value || "";
                const N = V.getValue(L, {
                  charLimit: this.data.maxLen
                }).charLimit;
                N && q.length > N && (q = q.slice(0, N));
                const Z = {
                  userValue: q,
                  formattedValue: null,
                  valueOnFocus: ""
                };
                this.data.multiLine ? (Y = document.createElement("textarea"), Y.textContent = q, this.data.doNotScroll && (Y.style.overflowY = "hidden")) : (Y = document.createElement("input"), Y.type = "text", Y.setAttribute("value", q), this.data.doNotScroll && (Y.style.overflowX = "hidden")), i.add(Y), Y.setAttribute("data-element-id", L), Y.disabled = this.data.readOnly, Y.name = this.data.fieldName, Y.tabIndex = P, this._setRequired(Y, this.data.required), N && (Y.maxLength = N), Y.addEventListener("input", (te) => {
                  V.setValue(L, {
                    value: te.target.value
                  }), this.setPropertyOnSiblings(Y, "value", te.target.value, "value");
                }), Y.addEventListener("resetform", (te) => {
                  const re = this.data.defaultFieldValue ?? "";
                  Y.value = Z.userValue = re, Z.formattedValue = null;
                });
                let E = (te) => {
                  const {
                    formattedValue: re
                  } = Z;
                  re != null && (te.target.value = re), te.target.scrollLeft = 0;
                };
                if (this.enableScripting && this.hasJSActions) {
                  Y.addEventListener("focus", (re) => {
                    Z.userValue && (re.target.value = Z.userValue), Z.valueOnFocus = re.target.value;
                  }), Y.addEventListener("updatefromsandbox", (re) => {
                    const ee = {
                      value($) {
                        Z.userValue = $.detail.value ?? "", V.setValue(L, {
                          value: Z.userValue.toString()
                        }), $.target.value = Z.userValue;
                      },
                      formattedValue($) {
                        const {
                          formattedValue: k
                        } = $.detail;
                        Z.formattedValue = k, k != null && $.target !== document.activeElement && ($.target.value = k), V.setValue(L, {
                          formattedValue: k
                        });
                      },
                      selRange($) {
                        $.target.setSelectionRange(...$.detail.selRange);
                      },
                      charLimit: ($) => {
                        var ae;
                        const {
                          charLimit: k
                        } = $.detail, {
                          target: H
                        } = $;
                        if (k === 0) {
                          H.removeAttribute("maxLength");
                          return;
                        }
                        H.setAttribute("maxLength", k);
                        let ne = Z.userValue;
                        !ne || ne.length <= k || (ne = ne.slice(0, k), H.value = Z.userValue = ne, V.setValue(L, {
                          value: ne
                        }), (ae = this.linkService.eventBus) == null || ae.dispatch("dispatcheventinsandbox", {
                          source: this,
                          detail: {
                            id: L,
                            name: "Keystroke",
                            value: ne,
                            willCommit: !0,
                            commitKey: 1,
                            selStart: H.selectionStart,
                            selEnd: H.selectionEnd
                          }
                        }));
                      }
                    };
                    this._dispatchEventFromSandbox(ee, re);
                  }), Y.addEventListener("keydown", (re) => {
                    var k;
                    let ee = -1;
                    if (re.key === "Escape" ? ee = 0 : re.key === "Enter" ? ee = 2 : re.key === "Tab" && (ee = 3), ee === -1)
                      return;
                    const {
                      value: $
                    } = re.target;
                    Z.valueOnFocus !== $ && (Z.userValue = $, (k = this.linkService.eventBus) == null || k.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id: L,
                        name: "Keystroke",
                        value: $,
                        willCommit: !0,
                        commitKey: ee,
                        selStart: re.target.selectionStart,
                        selEnd: re.target.selectionEnd
                      }
                    }));
                  });
                  const te = E;
                  E = null, Y.addEventListener("blur", (re) => {
                    var $;
                    const {
                      value: ee
                    } = re.target;
                    Z.userValue = ee, this._mouseState.isDown && Z.valueOnFocus !== ee && (($ = this.linkService.eventBus) == null || $.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id: L,
                        name: "Keystroke",
                        value: ee,
                        willCommit: !0,
                        commitKey: 1,
                        selStart: re.target.selectionStart,
                        selEnd: re.target.selectionEnd
                      }
                    })), te(re);
                  }), (J = this.data.actions) != null && J.Keystroke && Y.addEventListener("beforeinput", (re) => {
                    var ue;
                    const {
                      data: ee,
                      target: $
                    } = re, {
                      value: k,
                      selectionStart: H,
                      selectionEnd: ne
                    } = $;
                    let ae = H, he = ne;
                    switch (re.inputType) {
                      case "deleteWordBackward": {
                        const fe = k.substring(0, H).match(/\w*[^\w]*$/);
                        fe && (ae -= fe[0].length);
                        break;
                      }
                      case "deleteWordForward": {
                        const fe = k.substring(H).match(/^[^\w]*\w*/);
                        fe && (he += fe[0].length);
                        break;
                      }
                      case "deleteContentBackward":
                        H === ne && (ae -= 1);
                        break;
                      case "deleteContentForward":
                        H === ne && (he += 1);
                        break;
                    }
                    re.preventDefault(), (ue = this.linkService.eventBus) == null || ue.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id: L,
                        name: "Keystroke",
                        value: k,
                        change: ee || "",
                        willCommit: !1,
                        selStart: ae,
                        selEnd: he
                      }
                    });
                  }), this._setEventListeners(Y, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (re) => re.target.value);
                }
                if (E && Y.addEventListener("blur", E), this.data.comb) {
                  const re = (this.data.rect[2] - this.data.rect[0]) / N;
                  Y.classList.add("comb"), Y.style.letterSpacing = `calc(${re}px * var(--scale-factor) - 1ch)`;
                }
              } else
                Y = document.createElement("div"), Y.textContent = this.data.fieldValue, Y.style.verticalAlign = "middle", Y.style.display = "table-cell";
              return this._setTextStyle(Y), this._setBackgroundColor(Y), this._setDefaultPropertiesFromJS(Y), this.container.append(Y), this.container;
            }
          }
          class d extends h {
            constructor(V) {
              super(V, {
                isRenderable: V.renderForms
              });
            }
            render() {
              const V = this.annotationStorage, L = this.data, Y = L.id;
              let J = V.getValue(Y, {
                value: L.exportValue === L.fieldValue
              }).value;
              typeof J == "string" && (J = J !== "Off", V.setValue(Y, {
                value: J
              })), this.container.className = "buttonWidgetAnnotation checkBox";
              const ie = document.createElement("input");
              return i.add(ie), ie.setAttribute("data-element-id", Y), ie.disabled = L.readOnly, this._setRequired(ie, this.data.required), ie.type = "checkbox", ie.name = L.fieldName, J && ie.setAttribute("checked", !0), ie.setAttribute("exportValue", L.exportValue), ie.tabIndex = P, ie.addEventListener("change", (q) => {
                const {
                  name: N,
                  checked: Z
                } = q.target;
                for (const E of this._getElementsByName(N, Y)) {
                  const te = Z && E.exportValue === L.exportValue;
                  E.domElement && (E.domElement.checked = te), V.setValue(E.id, {
                    value: te
                  });
                }
                V.setValue(Y, {
                  value: Z
                });
              }), ie.addEventListener("resetform", (q) => {
                const N = L.defaultFieldValue || "Off";
                q.target.checked = N === L.exportValue;
              }), this.enableScripting && this.hasJSActions && (ie.addEventListener("updatefromsandbox", (q) => {
                const N = {
                  value(Z) {
                    Z.target.checked = Z.detail.value !== "Off", V.setValue(Y, {
                      value: Z.target.checked
                    });
                  }
                };
                this._dispatchEventFromSandbox(N, q);
              }), this._setEventListeners(ie, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (q) => q.target.checked)), this._setBackgroundColor(ie), this._setDefaultPropertiesFromJS(ie), this.container.append(ie), this.container;
            }
          }
          class c extends h {
            constructor(V) {
              super(V, {
                isRenderable: V.renderForms
              });
            }
            render() {
              this.container.className = "buttonWidgetAnnotation radioButton";
              const V = this.annotationStorage, L = this.data, Y = L.id;
              let J = V.getValue(Y, {
                value: L.fieldValue === L.buttonValue
              }).value;
              typeof J == "string" && (J = J !== L.buttonValue, V.setValue(Y, {
                value: J
              }));
              const ie = document.createElement("input");
              if (i.add(ie), ie.setAttribute("data-element-id", Y), ie.disabled = L.readOnly, this._setRequired(ie, this.data.required), ie.type = "radio", ie.name = L.fieldName, J && ie.setAttribute("checked", !0), ie.tabIndex = P, ie.addEventListener("change", (q) => {
                const {
                  name: N,
                  checked: Z
                } = q.target;
                for (const E of this._getElementsByName(N, Y))
                  V.setValue(E.id, {
                    value: !1
                  });
                V.setValue(Y, {
                  value: Z
                });
              }), ie.addEventListener("resetform", (q) => {
                const N = L.defaultFieldValue;
                q.target.checked = N != null && N === L.buttonValue;
              }), this.enableScripting && this.hasJSActions) {
                const q = L.buttonValue;
                ie.addEventListener("updatefromsandbox", (N) => {
                  const Z = {
                    value: (E) => {
                      const te = q === E.detail.value;
                      for (const re of this._getElementsByName(E.target.name)) {
                        const ee = te && re.id === Y;
                        re.domElement && (re.domElement.checked = ee), V.setValue(re.id, {
                          value: ee
                        });
                      }
                    }
                  };
                  this._dispatchEventFromSandbox(Z, N);
                }), this._setEventListeners(ie, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (N) => N.target.checked);
              }
              return this._setBackgroundColor(ie), this._setDefaultPropertiesFromJS(ie), this.container.append(ie), this.container;
            }
          }
          class n extends y {
            constructor(V) {
              super(V, {
                ignoreBorder: V.data.hasAppearance
              });
            }
            render() {
              const V = super.render();
              V.className = "buttonWidgetAnnotation pushButton", this.data.alternativeText && (V.title = this.data.alternativeText);
              const L = V.lastChild;
              return this.enableScripting && this.hasJSActions && L && (this._setDefaultPropertiesFromJS(L), L.addEventListener("updatefromsandbox", (Y) => {
                this._dispatchEventFromSandbox({}, Y);
              })), V;
            }
          }
          class o extends h {
            constructor(V) {
              super(V, {
                isRenderable: V.renderForms
              });
            }
            render() {
              this.container.className = "choiceWidgetAnnotation";
              const V = this.annotationStorage, L = this.data.id, Y = V.getValue(L, {
                value: this.data.fieldValue
              }), J = document.createElement("select");
              i.add(J), J.setAttribute("data-element-id", L), J.disabled = this.data.readOnly, this._setRequired(J, this.data.required), J.name = this.data.fieldName, J.tabIndex = P;
              let ie = this.data.combo && this.data.options.length > 0;
              this.data.combo || (J.size = this.data.options.length, this.data.multiSelect && (J.multiple = !0)), J.addEventListener("resetform", (E) => {
                const te = this.data.defaultFieldValue;
                for (const re of J.options)
                  re.selected = re.value === te;
              });
              for (const E of this.data.options) {
                const te = document.createElement("option");
                te.textContent = E.displayValue, te.value = E.exportValue, Y.value.includes(E.exportValue) && (te.setAttribute("selected", !0), ie = !1), J.append(te);
              }
              let q = null;
              if (ie) {
                const E = document.createElement("option");
                E.value = " ", E.setAttribute("hidden", !0), E.setAttribute("selected", !0), J.prepend(E), q = () => {
                  E.remove(), J.removeEventListener("input", q), q = null;
                }, J.addEventListener("input", q);
              }
              const N = (E, te) => {
                const re = te ? "value" : "textContent", ee = E.target.options;
                return E.target.multiple ? Array.prototype.filter.call(ee, ($) => $.selected).map(($) => $[re]) : ee.selectedIndex === -1 ? null : ee[ee.selectedIndex][re];
              }, Z = (E) => {
                const te = E.target.options;
                return Array.prototype.map.call(te, (re) => ({
                  displayValue: re.textContent,
                  exportValue: re.value
                }));
              };
              return this.enableScripting && this.hasJSActions ? (J.addEventListener("updatefromsandbox", (E) => {
                const te = {
                  value(re) {
                    q == null || q();
                    const ee = re.detail.value, $ = new Set(Array.isArray(ee) ? ee : [ee]);
                    for (const k of J.options)
                      k.selected = $.has(k.value);
                    V.setValue(L, {
                      value: N(re, !0)
                    });
                  },
                  multipleSelection(re) {
                    J.multiple = !0;
                  },
                  remove(re) {
                    const ee = J.options, $ = re.detail.remove;
                    ee[$].selected = !1, J.remove($), ee.length > 0 && Array.prototype.findIndex.call(ee, (H) => H.selected) === -1 && (ee[0].selected = !0), V.setValue(L, {
                      value: N(re, !0),
                      items: Z(re)
                    });
                  },
                  clear(re) {
                    for (; J.length !== 0; )
                      J.remove(0);
                    V.setValue(L, {
                      value: null,
                      items: []
                    });
                  },
                  insert(re) {
                    const {
                      index: ee,
                      displayValue: $,
                      exportValue: k
                    } = re.detail.insert, H = J.children[ee], ne = document.createElement("option");
                    ne.textContent = $, ne.value = k, H ? H.before(ne) : J.append(ne), V.setValue(L, {
                      value: N(re, !0),
                      items: Z(re)
                    });
                  },
                  items(re) {
                    const {
                      items: ee
                    } = re.detail;
                    for (; J.length !== 0; )
                      J.remove(0);
                    for (const $ of ee) {
                      const {
                        displayValue: k,
                        exportValue: H
                      } = $, ne = document.createElement("option");
                      ne.textContent = k, ne.value = H, J.append(ne);
                    }
                    J.options.length > 0 && (J.options[0].selected = !0), V.setValue(L, {
                      value: N(re, !0),
                      items: Z(re)
                    });
                  },
                  indices(re) {
                    const ee = new Set(re.detail.indices);
                    for (const $ of re.target.options)
                      $.selected = ee.has($.index);
                    V.setValue(L, {
                      value: N(re, !0)
                    });
                  },
                  editable(re) {
                    re.target.disabled = !re.detail.editable;
                  }
                };
                this._dispatchEventFromSandbox(te, E);
              }), J.addEventListener("input", (E) => {
                var ee;
                const te = N(E, !0), re = N(E, !1);
                V.setValue(L, {
                  value: te
                }), (ee = this.linkService.eventBus) == null || ee.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: L,
                    name: "Keystroke",
                    value: re,
                    changeEx: te,
                    willCommit: !0,
                    commitKey: 1,
                    keyDown: !1
                  }
                });
              }), this._setEventListeners(J, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"]], (E) => E.target.checked)) : J.addEventListener("input", function(E) {
                V.setValue(L, {
                  value: N(E, !0)
                });
              }), this.data.combo && this._setTextStyle(J), this._setBackgroundColor(J), this._setDefaultPropertiesFromJS(J), this.container.append(J), this.container;
            }
          }
          class x extends e {
            constructor(V) {
              var Y, J, ie;
              const L = !!((Y = V.data.titleObj) != null && Y.str || (J = V.data.contentsObj) != null && J.str || (ie = V.data.richText) != null && ie.str);
              super(V, {
                isRenderable: L
              });
            }
            render() {
              const V = ["Line", "Square", "Circle", "PolyLine", "Polygon", "Ink"];
              if (this.container.className = "popupAnnotation", V.includes(this.data.parentType))
                return this.container;
              const L = `[data-annotation-id="${this.data.parentId}"]`, Y = this.layer.querySelectorAll(L);
              if (Y.length === 0)
                return this.container;
              const J = new f({
                container: this.container,
                trigger: Array.from(Y),
                color: this.data.color,
                titleObj: this.data.titleObj,
                modificationDate: this.data.modificationDate,
                contentsObj: this.data.contentsObj,
                richText: this.data.richText
              }), ie = this.page, q = de.Util.normalizeRect([this.data.parentRect[0], ie.view[3] - this.data.parentRect[1] + ie.view[1], this.data.parentRect[2], ie.view[3] - this.data.parentRect[3] + ie.view[1]]), N = q[0] + this.data.parentRect[2] - this.data.parentRect[0], Z = q[1], [E, te, re, ee] = this.viewport.viewBox, $ = re - E, k = ee - te;
              return this.container.style.left = `${100 * (N - E) / $}%`, this.container.style.top = `${100 * (Z - te) / k}%`, this.container.append(J.render()), this.container;
            }
          }
          class f {
            constructor(V) {
              this.container = V.container, this.trigger = V.trigger, this.color = V.color, this.titleObj = V.titleObj, this.modificationDate = V.modificationDate, this.contentsObj = V.contentsObj, this.richText = V.richText, this.hideWrapper = V.hideWrapper || !1, this.pinned = !1;
            }
            render() {
              var N, Z;
              const L = document.createElement("div");
              L.className = "popupWrapper", this.hideElement = this.hideWrapper ? L : this.container, this.hideElement.hidden = !0;
              const Y = document.createElement("div");
              Y.className = "popup";
              const J = this.color;
              if (J) {
                const E = 0.7 * (255 - J[0]) + J[0], te = 0.7 * (255 - J[1]) + J[1], re = 0.7 * (255 - J[2]) + J[2];
                Y.style.backgroundColor = de.Util.makeHexColor(E | 0, te | 0, re | 0);
              }
              const ie = document.createElement("h1");
              ie.dir = this.titleObj.dir, ie.textContent = this.titleObj.str, Y.append(ie);
              const q = oe.PDFDateString.toDateObject(this.modificationDate);
              if (q) {
                const E = document.createElement("span");
                E.className = "popupDate", E.textContent = "{{date}}, {{time}}", E.dataset.l10nId = "annotation_date_string", E.dataset.l10nArgs = JSON.stringify({
                  date: q.toLocaleDateString(),
                  time: q.toLocaleTimeString()
                }), Y.append(E);
              }
              if ((N = this.richText) != null && N.str && (!((Z = this.contentsObj) != null && Z.str) || this.contentsObj.str === this.richText.str))
                u.XfaLayer.render({
                  xfaHtml: this.richText.html,
                  intent: "richText",
                  div: Y
                }), Y.lastChild.className = "richText popupContent";
              else {
                const E = this._formatContents(this.contentsObj);
                Y.append(E);
              }
              Array.isArray(this.trigger) || (this.trigger = [this.trigger]);
              for (const E of this.trigger)
                E.addEventListener("click", this._toggle.bind(this)), E.addEventListener("mouseover", this._show.bind(this, !1)), E.addEventListener("mouseout", this._hide.bind(this, !1));
              return Y.addEventListener("click", this._hide.bind(this, !0)), L.append(Y), L;
            }
            _formatContents({
              str: V,
              dir: L
            }) {
              const Y = document.createElement("p");
              Y.className = "popupContent", Y.dir = L;
              const J = V.split(/(?:\r\n?|\n)/);
              for (let ie = 0, q = J.length; ie < q; ++ie) {
                const N = J[ie];
                Y.append(document.createTextNode(N)), ie < q - 1 && Y.append(document.createElement("br"));
              }
              return Y;
            }
            _toggle() {
              this.pinned ? this._hide(!0) : this._show(!0);
            }
            _show(V = !1) {
              V && (this.pinned = !0), this.hideElement.hidden && (this.hideElement.hidden = !1, this.container.style.zIndex = parseInt(this.container.style.zIndex) + 1e3);
            }
            _hide(V = !0) {
              V && (this.pinned = !1), !this.hideElement.hidden && !this.pinned && (this.hideElement.hidden = !0, this.container.style.zIndex = parseInt(this.container.style.zIndex) - 1e3);
            }
          }
          class m extends e {
            constructor(V) {
              var Y, J, ie;
              const L = !!(V.data.hasPopup || (Y = V.data.titleObj) != null && Y.str || (J = V.data.contentsObj) != null && J.str || (ie = V.data.richText) != null && ie.str);
              super(V, {
                isRenderable: L,
                ignoreBorder: !0
              }), this.textContent = V.data.textContent;
            }
            render() {
              if (this.container.className = "freeTextAnnotation", this.textContent) {
                const V = document.createElement("div");
                V.className = "annotationTextContent", V.setAttribute("role", "comment");
                for (const L of this.textContent) {
                  const Y = document.createElement("span");
                  Y.textContent = L, V.append(Y);
                }
                this.container.append(V);
              }
              return this.data.hasPopup || this._createPopup(null, this.data), this.container;
            }
          }
          class C extends e {
            constructor(V) {
              var Y, J, ie;
              const L = !!(V.data.hasPopup || (Y = V.data.titleObj) != null && Y.str || (J = V.data.contentsObj) != null && J.str || (ie = V.data.richText) != null && ie.str);
              super(V, {
                isRenderable: L,
                ignoreBorder: !0
              });
            }
            render() {
              this.container.className = "lineAnnotation";
              const V = this.data, {
                width: L,
                height: Y
              } = v(V.rect), J = this.svgFactory.create(L, Y, !0), ie = this.svgFactory.createElement("svg:line");
              return ie.setAttribute("x1", V.rect[2] - V.lineCoordinates[0]), ie.setAttribute("y1", V.rect[3] - V.lineCoordinates[1]), ie.setAttribute("x2", V.rect[2] - V.lineCoordinates[2]), ie.setAttribute("y2", V.rect[3] - V.lineCoordinates[3]), ie.setAttribute("stroke-width", V.borderStyle.width || 1), ie.setAttribute("stroke", "transparent"), ie.setAttribute("fill", "transparent"), J.append(ie), this.container.append(J), this._createPopup(ie, V), this.container;
            }
          }
          class p extends e {
            constructor(V) {
              var Y, J, ie;
              const L = !!(V.data.hasPopup || (Y = V.data.titleObj) != null && Y.str || (J = V.data.contentsObj) != null && J.str || (ie = V.data.richText) != null && ie.str);
              super(V, {
                isRenderable: L,
                ignoreBorder: !0
              });
            }
            render() {
              this.container.className = "squareAnnotation";
              const V = this.data, {
                width: L,
                height: Y
              } = v(V.rect), J = this.svgFactory.create(L, Y, !0), ie = V.borderStyle.width, q = this.svgFactory.createElement("svg:rect");
              return q.setAttribute("x", ie / 2), q.setAttribute("y", ie / 2), q.setAttribute("width", L - ie), q.setAttribute("height", Y - ie), q.setAttribute("stroke-width", ie || 1), q.setAttribute("stroke", "transparent"), q.setAttribute("fill", "transparent"), J.append(q), this.container.append(J), this._createPopup(q, V), this.container;
            }
          }
          class w extends e {
            constructor(V) {
              var Y, J, ie;
              const L = !!(V.data.hasPopup || (Y = V.data.titleObj) != null && Y.str || (J = V.data.contentsObj) != null && J.str || (ie = V.data.richText) != null && ie.str);
              super(V, {
                isRenderable: L,
                ignoreBorder: !0
              });
            }
            render() {
              this.container.className = "circleAnnotation";
              const V = this.data, {
                width: L,
                height: Y
              } = v(V.rect), J = this.svgFactory.create(L, Y, !0), ie = V.borderStyle.width, q = this.svgFactory.createElement("svg:ellipse");
              return q.setAttribute("cx", L / 2), q.setAttribute("cy", Y / 2), q.setAttribute("rx", L / 2 - ie / 2), q.setAttribute("ry", Y / 2 - ie / 2), q.setAttribute("stroke-width", ie || 1), q.setAttribute("stroke", "transparent"), q.setAttribute("fill", "transparent"), J.append(q), this.container.append(J), this._createPopup(q, V), this.container;
            }
          }
          class X extends e {
            constructor(V) {
              var Y, J, ie;
              const L = !!(V.data.hasPopup || (Y = V.data.titleObj) != null && Y.str || (J = V.data.contentsObj) != null && J.str || (ie = V.data.richText) != null && ie.str);
              super(V, {
                isRenderable: L,
                ignoreBorder: !0
              }), this.containerClassName = "polylineAnnotation", this.svgElementName = "svg:polyline";
            }
            render() {
              this.container.className = this.containerClassName;
              const V = this.data, {
                width: L,
                height: Y
              } = v(V.rect), J = this.svgFactory.create(L, Y, !0);
              let ie = [];
              for (const N of V.vertices) {
                const Z = N.x - V.rect[0], E = V.rect[3] - N.y;
                ie.push(Z + "," + E);
              }
              ie = ie.join(" ");
              const q = this.svgFactory.createElement(this.svgElementName);
              return q.setAttribute("points", ie), q.setAttribute("stroke-width", V.borderStyle.width || 1), q.setAttribute("stroke", "transparent"), q.setAttribute("fill", "transparent"), J.append(q), this.container.append(J), this._createPopup(q, V), this.container;
            }
          }
          class M extends X {
            constructor(V) {
              super(V), this.containerClassName = "polygonAnnotation", this.svgElementName = "svg:polygon";
            }
          }
          class j extends e {
            constructor(V) {
              var Y, J, ie;
              const L = !!(V.data.hasPopup || (Y = V.data.titleObj) != null && Y.str || (J = V.data.contentsObj) != null && J.str || (ie = V.data.richText) != null && ie.str);
              super(V, {
                isRenderable: L,
                ignoreBorder: !0
              });
            }
            render() {
              return this.container.className = "caretAnnotation", this.data.hasPopup || this._createPopup(null, this.data), this.container;
            }
          }
          class B extends e {
            constructor(V) {
              var Y, J, ie;
              const L = !!(V.data.hasPopup || (Y = V.data.titleObj) != null && Y.str || (J = V.data.contentsObj) != null && J.str || (ie = V.data.richText) != null && ie.str);
              super(V, {
                isRenderable: L,
                ignoreBorder: !0
              }), this.containerClassName = "inkAnnotation", this.svgElementName = "svg:polyline";
            }
            render() {
              this.container.className = this.containerClassName;
              const V = this.data, {
                width: L,
                height: Y
              } = v(V.rect), J = this.svgFactory.create(L, Y, !0);
              for (const ie of V.inkLists) {
                let q = [];
                for (const Z of ie) {
                  const E = Z.x - V.rect[0], te = V.rect[3] - Z.y;
                  q.push(`${E},${te}`);
                }
                q = q.join(" ");
                const N = this.svgFactory.createElement(this.svgElementName);
                N.setAttribute("points", q), N.setAttribute("stroke-width", V.borderStyle.width || 1), N.setAttribute("stroke", "transparent"), N.setAttribute("fill", "transparent"), this._createPopup(N, V), J.append(N);
              }
              return this.container.append(J), this.container;
            }
          }
          class R extends e {
            constructor(V) {
              var Y, J, ie;
              const L = !!(V.data.hasPopup || (Y = V.data.titleObj) != null && Y.str || (J = V.data.contentsObj) != null && J.str || (ie = V.data.richText) != null && ie.str);
              super(V, {
                isRenderable: L,
                ignoreBorder: !0,
                createQuadrilaterals: !0
              });
            }
            render() {
              return this.data.hasPopup || this._createPopup(null, this.data), this.quadrilaterals ? this._renderQuadrilaterals("highlightAnnotation") : (this.container.className = "highlightAnnotation", this.container);
            }
          }
          class D extends e {
            constructor(V) {
              var Y, J, ie;
              const L = !!(V.data.hasPopup || (Y = V.data.titleObj) != null && Y.str || (J = V.data.contentsObj) != null && J.str || (ie = V.data.richText) != null && ie.str);
              super(V, {
                isRenderable: L,
                ignoreBorder: !0,
                createQuadrilaterals: !0
              });
            }
            render() {
              return this.data.hasPopup || this._createPopup(null, this.data), this.quadrilaterals ? this._renderQuadrilaterals("underlineAnnotation") : (this.container.className = "underlineAnnotation", this.container);
            }
          }
          class b extends e {
            constructor(V) {
              var Y, J, ie;
              const L = !!(V.data.hasPopup || (Y = V.data.titleObj) != null && Y.str || (J = V.data.contentsObj) != null && J.str || (ie = V.data.richText) != null && ie.str);
              super(V, {
                isRenderable: L,
                ignoreBorder: !0,
                createQuadrilaterals: !0
              });
            }
            render() {
              return this.data.hasPopup || this._createPopup(null, this.data), this.quadrilaterals ? this._renderQuadrilaterals("squigglyAnnotation") : (this.container.className = "squigglyAnnotation", this.container);
            }
          }
          class l extends e {
            constructor(V) {
              var Y, J, ie;
              const L = !!(V.data.hasPopup || (Y = V.data.titleObj) != null && Y.str || (J = V.data.contentsObj) != null && J.str || (ie = V.data.richText) != null && ie.str);
              super(V, {
                isRenderable: L,
                ignoreBorder: !0,
                createQuadrilaterals: !0
              });
            }
            render() {
              return this.data.hasPopup || this._createPopup(null, this.data), this.quadrilaterals ? this._renderQuadrilaterals("strikeoutAnnotation") : (this.container.className = "strikeoutAnnotation", this.container);
            }
          }
          class _ extends e {
            constructor(V) {
              var Y, J, ie;
              const L = !!(V.data.hasPopup || (Y = V.data.titleObj) != null && Y.str || (J = V.data.contentsObj) != null && J.str || (ie = V.data.richText) != null && ie.str);
              super(V, {
                isRenderable: L,
                ignoreBorder: !0
              });
            }
            render() {
              return this.container.className = "stampAnnotation", this.data.hasPopup || this._createPopup(null, this.data), this.container;
            }
          }
          class S extends e {
            constructor(V) {
              var J;
              super(V, {
                isRenderable: !0
              });
              const {
                filename: L,
                content: Y
              } = this.data.file;
              this.filename = (0, oe.getFilenameFromUrl)(L), this.content = Y, (J = this.linkService.eventBus) == null || J.dispatch("fileattachmentannotation", {
                source: this,
                filename: L,
                content: Y
              });
            }
            render() {
              var L, Y;
              this.container.className = "fileAttachmentAnnotation";
              const V = document.createElement("div");
              return V.className = "popupTriggerArea", V.addEventListener("dblclick", this._download.bind(this)), !this.data.hasPopup && ((L = this.data.titleObj) != null && L.str || (Y = this.data.contentsObj) != null && Y.str || this.data.richText) && this._createPopup(V, this.data), this.container.append(V), this.container;
            }
            _download() {
              var V;
              (V = this.downloadManager) == null || V.openOrDownloadData(this.container, this.content, this.filename);
            }
          }
          const W = class {
            static render(V) {
              var N, Z;
              const {
                annotations: L,
                div: Y,
                viewport: J,
                accessibilityManager: ie
              } = V;
              wt(this, O, _i).call(this, Y, J);
              let q = 0;
              for (const E of L) {
                if (E.annotationType !== de.AnnotationType.POPUP) {
                  const {
                    width: re,
                    height: ee
                  } = v(E.rect);
                  if (re <= 0 || ee <= 0)
                    continue;
                }
                const te = a.create({
                  data: E,
                  layer: Y,
                  page: V.page,
                  viewport: J,
                  linkService: V.linkService,
                  downloadManager: V.downloadManager,
                  imageResourcesPath: V.imageResourcesPath || "",
                  renderForms: V.renderForms !== !1,
                  svgFactory: new oe.DOMSVGFactory(),
                  annotationStorage: V.annotationStorage || new se.AnnotationStorage(),
                  enableScripting: V.enableScripting,
                  hasJSActions: V.hasJSActions,
                  fieldObjects: V.fieldObjects,
                  mouseState: V.mouseState || {
                    isDown: !1
                  }
                });
                if (te.isRenderable) {
                  const re = te.render();
                  if (E.hidden && (re.style.visibility = "hidden"), Array.isArray(re))
                    for (const ee of re)
                      ee.style.zIndex = q++, wt(N = W, F, Ti).call(N, ee, E.id, Y, ie);
                  else
                    re.style.zIndex = q++, te instanceof x ? Y.prepend(re) : wt(Z = W, F, Ti).call(Z, re, E.id, Y, ie);
                }
              }
              wt(this, G, Di).call(this, Y, V.annotationCanvasMap);
            }
            static update(V) {
              const {
                annotationCanvasMap: L,
                div: Y,
                viewport: J
              } = V;
              wt(this, O, _i).call(this, Y, J), wt(this, G, Di).call(this, Y, L), Y.hidden = !1;
            }
          };
          let A = W;
          F = new WeakSet(), Ti = function(V, L, Y, J) {
            const ie = V.firstChild || V;
            ie.id = `${oe.AnnotationPrefix}${L}`, Y.append(V), J == null || J.moveElementInDOM(Y, V, ie, !1);
          }, O = new WeakSet(), _i = function(V, {
            width: L,
            height: Y,
            rotation: J
          }) {
            const {
              style: ie
            } = V, q = J % 180 !== 0, N = Math.floor(L) + "px", Z = Math.floor(Y) + "px";
            ie.width = q ? Z : N, ie.height = q ? N : Z, V.setAttribute("data-main-rotation", J);
          }, G = new WeakSet(), Di = function(V, L) {
            if (L) {
              for (const [Y, J] of L) {
                const ie = V.querySelector(`[data-annotation-id="${Y}"]`);
                if (!ie)
                  continue;
                const {
                  firstChild: q
                } = ie;
                q ? q.nodeName === "CANVAS" ? q.replaceWith(J) : q.before(J) : ie.append(J);
              }
              L.clear();
            }
          }, ft(A, F), ft(A, O), ft(A, G), ge.AnnotationLayer = A;
        },
        /* 28 */
        /***/
        (Ee, ge) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.ColorConverters = void 0;
          function le(oe) {
            return Math.floor(Math.max(0, Math.min(1, oe)) * 255).toString(16).padStart(2, "0");
          }
          class de {
            static CMYK_G([se, Q, u, P]) {
              return ["G", 1 - Math.min(1, 0.3 * se + 0.59 * u + 0.11 * Q + P)];
            }
            static G_CMYK([se]) {
              return ["CMYK", 0, 0, 0, 1 - se];
            }
            static G_RGB([se]) {
              return ["RGB", se, se, se];
            }
            static G_HTML([se]) {
              const Q = le(se);
              return `#${Q}${Q}${Q}`;
            }
            static RGB_G([se, Q, u]) {
              return ["G", 0.3 * se + 0.59 * Q + 0.11 * u];
            }
            static RGB_HTML([se, Q, u]) {
              const P = le(se), t = le(Q), i = le(u);
              return `#${P}${t}${i}`;
            }
            static T_HTML() {
              return "#00000000";
            }
            static CMYK_RGB([se, Q, u, P]) {
              return ["RGB", 1 - Math.min(1, se + P), 1 - Math.min(1, u + P), 1 - Math.min(1, Q + P)];
            }
            static CMYK_HTML(se) {
              const Q = this.CMYK_RGB(se).slice(1);
              return this.RGB_HTML(Q);
            }
            static RGB_CMYK([se, Q, u]) {
              const P = 1 - se, t = 1 - Q, i = 1 - u, v = Math.min(P, t, i);
              return ["CMYK", P, t, i, v];
            }
          }
          ge.ColorConverters = de;
        },
        /* 29 */
        /***/
        (Ee, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.XfaLayer = void 0;
          var de = le(20);
          class oe {
            static setupStorage(Q, u, P, t, i) {
              const v = t.getValue(u, {
                value: null
              });
              switch (P.name) {
                case "textarea":
                  if (v.value !== null && (Q.textContent = v.value), i === "print")
                    break;
                  Q.addEventListener("input", (a) => {
                    t.setValue(u, {
                      value: a.target.value
                    });
                  });
                  break;
                case "input":
                  if (P.attributes.type === "radio" || P.attributes.type === "checkbox") {
                    if (v.value === P.attributes.xfaOn ? Q.setAttribute("checked", !0) : v.value === P.attributes.xfaOff && Q.removeAttribute("checked"), i === "print")
                      break;
                    Q.addEventListener("change", (a) => {
                      t.setValue(u, {
                        value: a.target.checked ? a.target.getAttribute("xfaOn") : a.target.getAttribute("xfaOff")
                      });
                    });
                  } else {
                    if (v.value !== null && Q.setAttribute("value", v.value), i === "print")
                      break;
                    Q.addEventListener("input", (a) => {
                      t.setValue(u, {
                        value: a.target.value
                      });
                    });
                  }
                  break;
                case "select":
                  if (v.value !== null)
                    for (const a of P.children)
                      a.attributes.value === v.value && (a.attributes.selected = !0);
                  Q.addEventListener("input", (a) => {
                    const e = a.target.options, y = e.selectedIndex === -1 ? "" : e[e.selectedIndex].value;
                    t.setValue(u, {
                      value: y
                    });
                  });
                  break;
              }
            }
            static setAttributes({
              html: Q,
              element: u,
              storage: P = null,
              intent: t,
              linkService: i
            }) {
              const {
                attributes: v
              } = u, a = Q instanceof HTMLAnchorElement;
              v.type === "radio" && (v.name = `${v.name}-${t}`);
              for (const [e, y] of Object.entries(v))
                if (y != null)
                  switch (e) {
                    case "class":
                      y.length && Q.setAttribute(e, y.join(" "));
                      break;
                    case "dataId":
                      break;
                    case "id":
                      Q.setAttribute("data-element-id", y);
                      break;
                    case "style":
                      Object.assign(Q.style, y);
                      break;
                    case "textContent":
                      Q.textContent = y;
                      break;
                    default:
                      (!a || e !== "href" && e !== "newWindow") && Q.setAttribute(e, y);
                  }
              a && i.addLinkAttributes(Q, v.href, v.newWindow), P && v.dataId && this.setupStorage(Q, v.dataId, u, P);
            }
            static render(Q) {
              var r;
              const u = Q.annotationStorage, P = Q.linkService, t = Q.xfaHtml, i = Q.intent || "display", v = document.createElement(t.name);
              t.attributes && this.setAttributes({
                html: v,
                element: t,
                intent: i,
                linkService: P
              });
              const a = [[t, -1, v]], e = Q.div;
              if (e.append(v), Q.viewport) {
                const h = `matrix(${Q.viewport.transform.join(",")})`;
                e.style.transform = h;
              }
              i !== "richText" && e.setAttribute("class", "xfaLayer xfaFont");
              const y = [];
              for (; a.length > 0; ) {
                const [h, g, d] = a.at(-1);
                if (g + 1 === h.children.length) {
                  a.pop();
                  continue;
                }
                const c = h.children[++a.at(-1)[1]];
                if (c === null)
                  continue;
                const {
                  name: n
                } = c;
                if (n === "#text") {
                  const x = document.createTextNode(c.value);
                  y.push(x), d.append(x);
                  continue;
                }
                let o;
                if ((r = c == null ? void 0 : c.attributes) != null && r.xmlns ? o = document.createElementNS(c.attributes.xmlns, n) : o = document.createElement(n), d.append(o), c.attributes && this.setAttributes({
                  html: o,
                  element: c,
                  storage: u,
                  intent: i,
                  linkService: P
                }), c.children && c.children.length > 0)
                  a.push([c, -1, o]);
                else if (c.value) {
                  const x = document.createTextNode(c.value);
                  de.XfaText.shouldBuildText(n) && y.push(x), o.append(x);
                }
              }
              for (const h of e.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea"))
                h.setAttribute("readOnly", !0);
              return {
                textDivs: y
              };
            }
            static update(Q) {
              const u = `matrix(${Q.viewport.transform.join(",")})`;
              Q.div.style.transform = u, Q.div.hidden = !1;
            }
          }
          ge.XfaLayer = oe;
        },
        /* 30 */
        /***/
        (Ee, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.TextLayerRenderTask = void 0, ge.renderTextLayer = d;
          var de = le(1), oe = le(8);
          const se = 1e5, Q = 30, u = 0.8, P = /* @__PURE__ */ new Map(), t = /^\s+$/g;
          function i(c, n) {
            const o = P.get(c);
            if (o)
              return o;
            n.save(), n.font = `${Q}px ${c}`;
            const x = n.measureText("");
            let f = x.fontBoundingBoxAscent, m = Math.abs(x.fontBoundingBoxDescent);
            if (f) {
              n.restore();
              const p = f / (f + m);
              return P.set(c, p), p;
            }
            n.strokeStyle = "red", n.clearRect(0, 0, Q, Q), n.strokeText("g", 0, 0);
            let C = n.getImageData(0, 0, Q, Q).data;
            m = 0;
            for (let p = C.length - 1 - 3; p >= 0; p -= 4)
              if (C[p] > 0) {
                m = Math.ceil(p / 4 / Q);
                break;
              }
            n.clearRect(0, 0, Q, Q), n.strokeText("A", 0, Q), C = n.getImageData(0, 0, Q, Q).data, f = 0;
            for (let p = 0, w = C.length; p < w; p += 4)
              if (C[p] > 0) {
                f = Q - Math.floor(p / 4 / Q);
                break;
              }
            if (n.restore(), f) {
              const p = f / (f + m);
              return P.set(c, p), p;
            }
            return P.set(c, u), u;
          }
          function v(c, n, o, x) {
            const f = document.createElement("span"), m = c._enhanceTextSelection ? {
              angle: 0,
              canvasWidth: 0,
              hasText: n.str !== "",
              hasEOL: n.hasEOL,
              originalTransform: null,
              paddingBottom: 0,
              paddingLeft: 0,
              paddingRight: 0,
              paddingTop: 0,
              scale: 1,
              fontSize: 0
            } : {
              angle: 0,
              canvasWidth: 0,
              hasText: n.str !== "",
              hasEOL: n.hasEOL,
              fontSize: 0
            };
            c._textDivs.push(f);
            const C = de.Util.transform(c._viewport.transform, n.transform);
            let p = Math.atan2(C[1], C[0]);
            const w = o[n.fontName];
            w.vertical && (p += Math.PI / 2);
            const X = Math.hypot(C[2], C[3]), M = X * i(w.fontFamily, x);
            let j, B;
            p === 0 ? (j = C[4], B = C[5] - M) : (j = C[4] + M * Math.sin(p), B = C[5] - M * Math.cos(p)), f.style.left = `${j}px`, f.style.top = `${B}px`, f.style.fontSize = `${X}px`, f.style.fontFamily = w.fontFamily, m.fontSize = X, f.setAttribute("role", "presentation"), f.textContent = n.str, f.dir = n.dir, c._fontInspectorEnabled && (f.dataset.fontName = n.fontName), p !== 0 && (m.angle = p * (180 / Math.PI));
            let R = !1;
            if (n.str.length > 1 || c._enhanceTextSelection && t.test(n.str))
              R = !0;
            else if (n.str !== " " && n.transform[0] !== n.transform[3]) {
              const D = Math.abs(n.transform[0]), b = Math.abs(n.transform[3]);
              D !== b && Math.max(D, b) / Math.min(D, b) > 1.5 && (R = !0);
            }
            if (R && (w.vertical ? m.canvasWidth = n.height * c._viewport.scale : m.canvasWidth = n.width * c._viewport.scale), c._textDivProperties.set(f, m), c._textContentStream && c._layoutText(f), c._enhanceTextSelection && m.hasText) {
              let D = 1, b = 0;
              p !== 0 && (D = Math.cos(p), b = Math.sin(p));
              const l = (w.vertical ? n.height : n.width) * c._viewport.scale, _ = X;
              let S, A;
              p !== 0 ? (S = [D, b, -b, D, j, B], A = de.Util.getAxialAlignedBoundingBox([0, 0, l, _], S)) : A = [j, B, j + l, B + _], c._bounds.push({
                left: A[0],
                top: A[1],
                right: A[2],
                bottom: A[3],
                div: f,
                size: [l, _],
                m: S
              });
            }
          }
          function a(c) {
            if (c._canceled)
              return;
            const n = c._textDivs, o = c._capability, x = n.length;
            if (x > se) {
              c._renderingDone = !0, o.resolve();
              return;
            }
            if (!c._textContentStream)
              for (let f = 0; f < x; f++)
                c._layoutText(n[f]);
            c._renderingDone = !0, o.resolve();
          }
          function e(c, n, o) {
            let x = 0;
            for (let f = 0; f < o; f++) {
              const m = c[n++];
              m > 0 && (x = x ? Math.min(m, x) : m);
            }
            return x;
          }
          function y(c) {
            const n = c._bounds, o = c._viewport, x = r(o.width, o.height, n);
            for (let f = 0; f < x.length; f++) {
              const m = n[f].div, C = c._textDivProperties.get(m);
              if (C.angle === 0) {
                C.paddingLeft = n[f].left - x[f].left, C.paddingTop = n[f].top - x[f].top, C.paddingRight = x[f].right - n[f].right, C.paddingBottom = x[f].bottom - n[f].bottom, c._textDivProperties.set(m, C);
                continue;
              }
              const p = x[f], w = n[f], X = w.m, M = X[0], j = X[1], B = [[0, 0], [0, w.size[1]], [w.size[0], 0], w.size], R = new Float64Array(64);
              for (let b = 0, l = B.length; b < l; b++) {
                const _ = de.Util.applyTransform(B[b], X);
                R[b + 0] = M && (p.left - _[0]) / M, R[b + 4] = j && (p.top - _[1]) / j, R[b + 8] = M && (p.right - _[0]) / M, R[b + 12] = j && (p.bottom - _[1]) / j, R[b + 16] = j && (p.left - _[0]) / -j, R[b + 20] = M && (p.top - _[1]) / M, R[b + 24] = j && (p.right - _[0]) / -j, R[b + 28] = M && (p.bottom - _[1]) / M, R[b + 32] = M && (p.left - _[0]) / -M, R[b + 36] = j && (p.top - _[1]) / -j, R[b + 40] = M && (p.right - _[0]) / -M, R[b + 44] = j && (p.bottom - _[1]) / -j, R[b + 48] = j && (p.left - _[0]) / j, R[b + 52] = M && (p.top - _[1]) / -M, R[b + 56] = j && (p.right - _[0]) / j, R[b + 60] = M && (p.bottom - _[1]) / -M;
              }
              const D = 1 + Math.min(Math.abs(M), Math.abs(j));
              C.paddingLeft = e(R, 32, 16) / D, C.paddingTop = e(R, 48, 16) / D, C.paddingRight = e(R, 0, 16) / D, C.paddingBottom = e(R, 16, 16) / D, c._textDivProperties.set(m, C);
            }
          }
          function r(c, n, o) {
            const x = o.map(function(m, C) {
              return {
                x1: m.left,
                y1: m.top,
                x2: m.right,
                y2: m.bottom,
                index: C,
                x1New: void 0,
                x2New: void 0
              };
            });
            h(c, x);
            const f = new Array(o.length);
            for (const m of x) {
              const C = m.index;
              f[C] = {
                left: m.x1New,
                top: 0,
                right: m.x2New,
                bottom: 0
              };
            }
            o.map(function(m, C) {
              const p = f[C], w = x[C];
              w.x1 = m.top, w.y1 = c - p.right, w.x2 = m.bottom, w.y2 = c - p.left, w.index = C, w.x1New = void 0, w.x2New = void 0;
            }), h(n, x);
            for (const m of x) {
              const C = m.index;
              f[C].top = m.x1New, f[C].bottom = m.x2New;
            }
            return f;
          }
          function h(c, n) {
            n.sort(function(f, m) {
              return f.x1 - m.x1 || f.index - m.index;
            });
            const x = [{
              start: -1 / 0,
              end: 1 / 0,
              boundary: {
                x1: -1 / 0,
                y1: -1 / 0,
                x2: 0,
                y2: 1 / 0,
                index: -1,
                x1New: 0,
                x2New: 0
              }
            }];
            for (const f of n) {
              let m = 0;
              for (; m < x.length && x[m].end <= f.y1; )
                m++;
              let C = x.length - 1;
              for (; C >= 0 && x[C].start >= f.y2; )
                C--;
              let p, w, X, M, j = -1 / 0;
              for (X = m; X <= C; X++) {
                p = x[X], w = p.boundary;
                let D;
                w.x2 > f.x1 ? D = w.index > f.index ? w.x1New : f.x1 : w.x2New === void 0 ? D = (w.x2 + f.x1) / 2 : D = w.x2New, D > j && (j = D);
              }
              for (f.x1New = j, X = m; X <= C; X++)
                p = x[X], w = p.boundary, w.x2New === void 0 ? w.x2 > f.x1 ? w.index > f.index && (w.x2New = w.x2) : w.x2New = j : w.x2New > j && (w.x2New = Math.max(j, w.x2));
              const B = [];
              let R = null;
              for (X = m; X <= C; X++) {
                p = x[X], w = p.boundary;
                const D = w.x2 > f.x2 ? w : f;
                R === D ? B.at(-1).end = p.end : (B.push({
                  start: p.start,
                  end: p.end,
                  boundary: D
                }), R = D);
              }
              for (x[m].start < f.y1 && (B[0].start = f.y1, B.unshift({
                start: x[m].start,
                end: f.y1,
                boundary: x[m].boundary
              })), f.y2 < x[C].end && (B.at(-1).end = f.y2, B.push({
                start: f.y2,
                end: x[C].end,
                boundary: x[C].boundary
              })), X = m; X <= C; X++) {
                if (p = x[X], w = p.boundary, w.x2New !== void 0)
                  continue;
                let D = !1;
                for (M = m - 1; !D && M >= 0 && x[M].start >= w.y1; M--)
                  D = x[M].boundary === w;
                for (M = C + 1; !D && M < x.length && x[M].end <= w.y2; M++)
                  D = x[M].boundary === w;
                for (M = 0; !D && M < B.length; M++)
                  D = B[M].boundary === w;
                D || (w.x2New = j);
              }
              Array.prototype.splice.apply(x, [m, C - m + 1, ...B]);
            }
            for (const f of x) {
              const m = f.boundary;
              m.x2New === void 0 && (m.x2New = Math.max(c, m.x2));
            }
          }
          class g {
            constructor({
              textContent: n,
              textContentStream: o,
              container: x,
              viewport: f,
              textDivs: m,
              textContentItemsStr: C,
              enhanceTextSelection: p
            }) {
              var w;
              p && (0, oe.deprecated)("The `enhanceTextSelection` functionality will be removed in the future."), this._textContent = n, this._textContentStream = o, this._container = x, this._document = x.ownerDocument, this._viewport = f, this._textDivs = m || [], this._textContentItemsStr = C || [], this._enhanceTextSelection = !!p, this._fontInspectorEnabled = !!((w = globalThis.FontInspector) != null && w.enabled), this._reader = null, this._layoutTextLastFontSize = null, this._layoutTextLastFontFamily = null, this._layoutTextCtx = null, this._textDivProperties = /* @__PURE__ */ new WeakMap(), this._renderingDone = !1, this._canceled = !1, this._capability = (0, de.createPromiseCapability)(), this._renderTimer = null, this._bounds = [], this._devicePixelRatio = globalThis.devicePixelRatio || 1, this._capability.promise.finally(() => {
                this._enhanceTextSelection || (this._textDivProperties = null), this._layoutTextCtx && (this._layoutTextCtx.canvas.width = 0, this._layoutTextCtx.canvas.height = 0, this._layoutTextCtx = null);
              }).catch(() => {
              });
            }
            get promise() {
              return this._capability.promise;
            }
            cancel() {
              this._canceled = !0, this._reader && (this._reader.cancel(new de.AbortException("TextLayer task cancelled.")).catch(() => {
              }), this._reader = null), this._renderTimer !== null && (clearTimeout(this._renderTimer), this._renderTimer = null), this._capability.reject(new Error("TextLayer task cancelled."));
            }
            _processItems(n, o) {
              for (let x = 0, f = n.length; x < f; x++) {
                if (n[x].str === void 0) {
                  if (n[x].type === "beginMarkedContentProps" || n[x].type === "beginMarkedContent") {
                    const m = this._container;
                    this._container = document.createElement("span"), this._container.classList.add("markedContent"), n[x].id !== null && this._container.setAttribute("id", `${n[x].id}`), m.append(this._container);
                  } else
                    n[x].type === "endMarkedContent" && (this._container = this._container.parentNode);
                  continue;
                }
                this._textContentItemsStr.push(n[x].str), v(this, n[x], o, this._layoutTextCtx);
              }
            }
            _layoutText(n) {
              const o = this._textDivProperties.get(n);
              let x = "";
              if (o.canvasWidth !== 0 && o.hasText) {
                const {
                  fontFamily: f
                } = n.style, {
                  fontSize: m
                } = o;
                (m !== this._layoutTextLastFontSize || f !== this._layoutTextLastFontFamily) && (this._layoutTextCtx.font = `${m * this._devicePixelRatio}px ${f}`, this._layoutTextLastFontSize = m, this._layoutTextLastFontFamily = f);
                const {
                  width: C
                } = this._layoutTextCtx.measureText(n.textContent);
                if (C > 0) {
                  const p = this._devicePixelRatio * o.canvasWidth / C;
                  this._enhanceTextSelection && (o.scale = p), x = `scaleX(${p})`;
                }
              }
              if (o.angle !== 0 && (x = `rotate(${o.angle}deg) ${x}`), x.length > 0 && (this._enhanceTextSelection && (o.originalTransform = x), n.style.transform = x), o.hasText && this._container.append(n), o.hasEOL) {
                const f = document.createElement("br");
                f.setAttribute("role", "presentation"), this._container.append(f);
              }
            }
            _render(n = 0) {
              const o = (0, de.createPromiseCapability)();
              let x = /* @__PURE__ */ Object.create(null);
              const f = this._document.createElement("canvas");
              if (f.height = f.width = Q, this._layoutTextCtx = f.getContext("2d", {
                alpha: !1
              }), this._textContent) {
                const m = this._textContent.items, C = this._textContent.styles;
                this._processItems(m, C), o.resolve();
              } else if (this._textContentStream) {
                const m = () => {
                  this._reader.read().then(({
                    value: C,
                    done: p
                  }) => {
                    if (p) {
                      o.resolve();
                      return;
                    }
                    Object.assign(x, C.styles), this._processItems(C.items, x), m();
                  }, o.reject);
                };
                this._reader = this._textContentStream.getReader(), m();
              } else
                throw new Error('Neither "textContent" nor "textContentStream" parameters specified.');
              o.promise.then(() => {
                x = null, n ? this._renderTimer = setTimeout(() => {
                  a(this), this._renderTimer = null;
                }, n) : a(this);
              }, this._capability.reject);
            }
            expandTextDivs(n = !1) {
              if (!this._enhanceTextSelection || !this._renderingDone)
                return;
              this._bounds !== null && (y(this), this._bounds = null);
              const o = [], x = [];
              for (let f = 0, m = this._textDivs.length; f < m; f++) {
                const C = this._textDivs[f], p = this._textDivProperties.get(C);
                p.hasText && (n ? (o.length = 0, x.length = 0, p.originalTransform && o.push(p.originalTransform), p.paddingTop > 0 ? (x.push(`${p.paddingTop}px`), o.push(`translateY(${-p.paddingTop}px)`)) : x.push(0), p.paddingRight > 0 ? x.push(`${p.paddingRight / p.scale}px`) : x.push(0), p.paddingBottom > 0 ? x.push(`${p.paddingBottom}px`) : x.push(0), p.paddingLeft > 0 ? (x.push(`${p.paddingLeft / p.scale}px`), o.push(`translateX(${-p.paddingLeft / p.scale}px)`)) : x.push(0), C.style.padding = x.join(" "), o.length && (C.style.transform = o.join(" "))) : (C.style.padding = null, C.style.transform = p.originalTransform));
              }
            }
          }
          ge.TextLayerRenderTask = g;
          function d(c) {
            const n = new g({
              textContent: c.textContent,
              textContentStream: c.textContentStream,
              container: c.container,
              viewport: c.viewport,
              textDivs: c.textDivs,
              textContentItemsStr: c.textContentItemsStr,
              enhanceTextSelection: c.enhanceTextSelection
            });
            return n._render(c.timeout), n;
          }
        },
        /* 31 */
        /***/
        (Ee, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.SVGGraphics = void 0;
          var de = le(8), oe = le(1), se = le(3);
          let Q = class {
            constructor() {
              (0, oe.unreachable)("Not implemented: SVGGraphics");
            }
          };
          ge.SVGGraphics = Q;
          {
            let d = function(m) {
              let C = [];
              const p = [];
              for (const w of m) {
                if (w.fn === "save") {
                  C.push({
                    fnId: 92,
                    fn: "group",
                    items: []
                  }), p.push(C), C = C.at(-1).items;
                  continue;
                }
                w.fn === "restore" ? C = p.pop() : C.push(w);
              }
              return C;
            }, c = function(m) {
              if (Number.isInteger(m))
                return m.toString();
              const C = m.toFixed(10);
              let p = C.length - 1;
              if (C[p] !== "0")
                return C;
              do
                p--;
              while (C[p] === "0");
              return C.substring(0, C[p] === "." ? p : p + 1);
            }, n = function(m) {
              if (m[4] === 0 && m[5] === 0) {
                if (m[1] === 0 && m[2] === 0)
                  return m[0] === 1 && m[3] === 1 ? "" : `scale(${c(m[0])} ${c(m[3])})`;
                if (m[0] === m[3] && m[1] === -m[2]) {
                  const C = Math.acos(m[0]) * 180 / Math.PI;
                  return `rotate(${c(C)})`;
                }
              } else if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1)
                return `translate(${c(m[4])} ${c(m[5])})`;
              return `matrix(${c(m[0])} ${c(m[1])} ${c(m[2])} ${c(m[3])} ${c(m[4])} ${c(m[5])})`;
            };
            var u = d, P = c, t = n;
            const i = {
              fontStyle: "normal",
              fontWeight: "normal",
              fillColor: "#000000"
            }, v = "http://www.w3.org/XML/1998/namespace", a = "http://www.w3.org/1999/xlink", e = ["butt", "round", "square"], y = ["miter", "round", "bevel"], r = function(m, C = "", p = !1) {
              if (URL.createObjectURL && typeof Blob < "u" && !p)
                return URL.createObjectURL(new Blob([m], {
                  type: C
                }));
              const w = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
              let X = `data:${C};base64,`;
              for (let M = 0, j = m.length; M < j; M += 3) {
                const B = m[M] & 255, R = m[M + 1] & 255, D = m[M + 2] & 255, b = B >> 2, l = (B & 3) << 4 | R >> 4, _ = M + 1 < j ? (R & 15) << 2 | D >> 6 : 64, S = M + 2 < j ? D & 63 : 64;
                X += w[b] + w[l] + w[_] + w[S];
              }
              return X;
            }, h = function() {
              const m = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]), C = 12, p = new Int32Array(256);
              for (let D = 0; D < 256; D++) {
                let b = D;
                for (let l = 0; l < 8; l++)
                  b & 1 ? b = 3988292384 ^ b >> 1 & 2147483647 : b = b >> 1 & 2147483647;
                p[D] = b;
              }
              function w(D, b, l) {
                let _ = -1;
                for (let S = b; S < l; S++) {
                  const A = (_ ^ D[S]) & 255, F = p[A];
                  _ = _ >>> 8 ^ F;
                }
                return _ ^ -1;
              }
              function X(D, b, l, _) {
                let S = _;
                const A = b.length;
                l[S] = A >> 24 & 255, l[S + 1] = A >> 16 & 255, l[S + 2] = A >> 8 & 255, l[S + 3] = A & 255, S += 4, l[S] = D.charCodeAt(0) & 255, l[S + 1] = D.charCodeAt(1) & 255, l[S + 2] = D.charCodeAt(2) & 255, l[S + 3] = D.charCodeAt(3) & 255, S += 4, l.set(b, S), S += b.length;
                const F = w(l, _ + 4, S);
                l[S] = F >> 24 & 255, l[S + 1] = F >> 16 & 255, l[S + 2] = F >> 8 & 255, l[S + 3] = F & 255;
              }
              function M(D, b, l) {
                let _ = 1, S = 0;
                for (let A = b; A < l; ++A)
                  _ = (_ + (D[A] & 255)) % 65521, S = (S + _) % 65521;
                return S << 16 | _;
              }
              function j(D) {
                if (!se.isNodeJS)
                  return B(D);
                try {
                  let b;
                  parseInt(process.versions.node) >= 8 ? b = D : b = Buffer.from(D);
                  const l = require$$5.deflateSync(b, {
                    level: 9
                  });
                  return l instanceof Uint8Array ? l : new Uint8Array(l);
                } catch (b) {
                  (0, oe.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + b);
                }
                return B(D);
              }
              function B(D) {
                let b = D.length;
                const l = 65535, _ = Math.ceil(b / l), S = new Uint8Array(2 + b + _ * 5 + 4);
                let A = 0;
                S[A++] = 120, S[A++] = 156;
                let F = 0;
                for (; b > l; )
                  S[A++] = 0, S[A++] = 255, S[A++] = 255, S[A++] = 0, S[A++] = 0, S.set(D.subarray(F, F + l), A), A += l, F += l, b -= l;
                S[A++] = 1, S[A++] = b & 255, S[A++] = b >> 8 & 255, S[A++] = ~b & 65535 & 255, S[A++] = (~b & 65535) >> 8 & 255, S.set(D.subarray(F), A), A += D.length - F;
                const T = M(D, 0, D.length);
                return S[A++] = T >> 24 & 255, S[A++] = T >> 16 & 255, S[A++] = T >> 8 & 255, S[A++] = T & 255, S;
              }
              function R(D, b, l, _) {
                const S = D.width, A = D.height;
                let F, T, O;
                const U = D.data;
                switch (b) {
                  case oe.ImageKind.GRAYSCALE_1BPP:
                    T = 0, F = 1, O = S + 7 >> 3;
                    break;
                  case oe.ImageKind.RGB_24BPP:
                    T = 2, F = 8, O = S * 3;
                    break;
                  case oe.ImageKind.RGBA_32BPP:
                    T = 6, F = 8, O = S * 4;
                    break;
                  default:
                    throw new Error("invalid format");
                }
                const G = new Uint8Array((1 + O) * A);
                let K = 0, W = 0;
                for (let ie = 0; ie < A; ++ie)
                  G[K++] = 0, G.set(U.subarray(W, W + O), K), W += O, K += O;
                if (b === oe.ImageKind.GRAYSCALE_1BPP && _) {
                  K = 0;
                  for (let ie = 0; ie < A; ie++) {
                    K++;
                    for (let q = 0; q < O; q++)
                      G[K++] ^= 255;
                  }
                }
                const z = new Uint8Array([S >> 24 & 255, S >> 16 & 255, S >> 8 & 255, S & 255, A >> 24 & 255, A >> 16 & 255, A >> 8 & 255, A & 255, F, T, 0, 0, 0]), V = j(G), L = m.length + C * 3 + z.length + V.length, Y = new Uint8Array(L);
                let J = 0;
                return Y.set(m, J), J += m.length, X("IHDR", z, Y, J), J += C + z.length, X("IDATA", V, Y, J), J += C + V.length, X("IEND", new Uint8Array(0), Y, J), r(Y, "image/png", l);
              }
              return function(b, l, _) {
                const S = b.kind === void 0 ? oe.ImageKind.GRAYSCALE_1BPP : b.kind;
                return R(b, S, l, _);
              };
            }();
            class g {
              constructor() {
                this.fontSizeScale = 1, this.fontWeight = i.fontWeight, this.fontSize = 0, this.textMatrix = oe.IDENTITY_MATRIX, this.fontMatrix = oe.FONT_IDENTITY_MATRIX, this.leading = 0, this.textRenderingMode = oe.TextRenderingMode.FILL, this.textMatrixScale = 1, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRise = 0, this.fillColor = i.fillColor, this.strokeColor = "#000000", this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.lineJoin = "", this.lineCap = "", this.miterLimit = 0, this.dashArray = [], this.dashPhase = 0, this.dependencies = [], this.activeClipUrl = null, this.clipGroup = null, this.maskId = "";
              }
              clone() {
                return Object.create(this);
              }
              setCurrentPoint(C, p) {
                this.x = C, this.y = p;
              }
            }
            let o = 0, x = 0, f = 0;
            ge.SVGGraphics = Q = class {
              constructor(m, C, p = !1) {
                (0, de.deprecated)("The SVG back-end is no longer maintained and *may* be removed in the future."), this.svgFactory = new de.DOMSVGFactory(), this.current = new g(), this.transformMatrix = oe.IDENTITY_MATRIX, this.transformStack = [], this.extraStack = [], this.commonObjs = m, this.objs = C, this.pendingClip = null, this.pendingEOFill = !1, this.embedFonts = !1, this.embeddedFonts = /* @__PURE__ */ Object.create(null), this.cssStyle = null, this.forceDataSchema = !!p, this._operatorIdMapping = [];
                for (const w in oe.OPS)
                  this._operatorIdMapping[oe.OPS[w]] = w;
              }
              save() {
                this.transformStack.push(this.transformMatrix);
                const m = this.current;
                this.extraStack.push(m), this.current = m.clone();
              }
              restore() {
                this.transformMatrix = this.transformStack.pop(), this.current = this.extraStack.pop(), this.pendingClip = null, this.tgrp = null;
              }
              group(m) {
                this.save(), this.executeOpTree(m), this.restore();
              }
              loadDependencies(m) {
                const C = m.fnArray, p = m.argsArray;
                for (let w = 0, X = C.length; w < X; w++)
                  if (C[w] === oe.OPS.dependency)
                    for (const M of p[w]) {
                      const j = M.startsWith("g_") ? this.commonObjs : this.objs, B = new Promise((R) => {
                        j.get(M, R);
                      });
                      this.current.dependencies.push(B);
                    }
                return Promise.all(this.current.dependencies);
              }
              transform(m, C, p, w, X, M) {
                const j = [m, C, p, w, X, M];
                this.transformMatrix = oe.Util.transform(this.transformMatrix, j), this.tgrp = null;
              }
              getSVG(m, C) {
                this.viewport = C;
                const p = this._initialize(C);
                return this.loadDependencies(m).then(() => (this.transformMatrix = oe.IDENTITY_MATRIX, this.executeOpTree(this.convertOpList(m)), p));
              }
              convertOpList(m) {
                const C = this._operatorIdMapping, p = m.argsArray, w = m.fnArray, X = [];
                for (let M = 0, j = w.length; M < j; M++) {
                  const B = w[M];
                  X.push({
                    fnId: B,
                    fn: C[B],
                    args: p[M]
                  });
                }
                return d(X);
              }
              executeOpTree(m) {
                for (const C of m) {
                  const p = C.fn, w = C.fnId, X = C.args;
                  switch (w | 0) {
                    case oe.OPS.beginText:
                      this.beginText();
                      break;
                    case oe.OPS.dependency:
                      break;
                    case oe.OPS.setLeading:
                      this.setLeading(X);
                      break;
                    case oe.OPS.setLeadingMoveText:
                      this.setLeadingMoveText(X[0], X[1]);
                      break;
                    case oe.OPS.setFont:
                      this.setFont(X);
                      break;
                    case oe.OPS.showText:
                      this.showText(X[0]);
                      break;
                    case oe.OPS.showSpacedText:
                      this.showText(X[0]);
                      break;
                    case oe.OPS.endText:
                      this.endText();
                      break;
                    case oe.OPS.moveText:
                      this.moveText(X[0], X[1]);
                      break;
                    case oe.OPS.setCharSpacing:
                      this.setCharSpacing(X[0]);
                      break;
                    case oe.OPS.setWordSpacing:
                      this.setWordSpacing(X[0]);
                      break;
                    case oe.OPS.setHScale:
                      this.setHScale(X[0]);
                      break;
                    case oe.OPS.setTextMatrix:
                      this.setTextMatrix(X[0], X[1], X[2], X[3], X[4], X[5]);
                      break;
                    case oe.OPS.setTextRise:
                      this.setTextRise(X[0]);
                      break;
                    case oe.OPS.setTextRenderingMode:
                      this.setTextRenderingMode(X[0]);
                      break;
                    case oe.OPS.setLineWidth:
                      this.setLineWidth(X[0]);
                      break;
                    case oe.OPS.setLineJoin:
                      this.setLineJoin(X[0]);
                      break;
                    case oe.OPS.setLineCap:
                      this.setLineCap(X[0]);
                      break;
                    case oe.OPS.setMiterLimit:
                      this.setMiterLimit(X[0]);
                      break;
                    case oe.OPS.setFillRGBColor:
                      this.setFillRGBColor(X[0], X[1], X[2]);
                      break;
                    case oe.OPS.setStrokeRGBColor:
                      this.setStrokeRGBColor(X[0], X[1], X[2]);
                      break;
                    case oe.OPS.setStrokeColorN:
                      this.setStrokeColorN(X);
                      break;
                    case oe.OPS.setFillColorN:
                      this.setFillColorN(X);
                      break;
                    case oe.OPS.shadingFill:
                      this.shadingFill(X[0]);
                      break;
                    case oe.OPS.setDash:
                      this.setDash(X[0], X[1]);
                      break;
                    case oe.OPS.setRenderingIntent:
                      this.setRenderingIntent(X[0]);
                      break;
                    case oe.OPS.setFlatness:
                      this.setFlatness(X[0]);
                      break;
                    case oe.OPS.setGState:
                      this.setGState(X[0]);
                      break;
                    case oe.OPS.fill:
                      this.fill();
                      break;
                    case oe.OPS.eoFill:
                      this.eoFill();
                      break;
                    case oe.OPS.stroke:
                      this.stroke();
                      break;
                    case oe.OPS.fillStroke:
                      this.fillStroke();
                      break;
                    case oe.OPS.eoFillStroke:
                      this.eoFillStroke();
                      break;
                    case oe.OPS.clip:
                      this.clip("nonzero");
                      break;
                    case oe.OPS.eoClip:
                      this.clip("evenodd");
                      break;
                    case oe.OPS.paintSolidColorImageMask:
                      this.paintSolidColorImageMask();
                      break;
                    case oe.OPS.paintImageXObject:
                      this.paintImageXObject(X[0]);
                      break;
                    case oe.OPS.paintInlineImageXObject:
                      this.paintInlineImageXObject(X[0]);
                      break;
                    case oe.OPS.paintImageMaskXObject:
                      this.paintImageMaskXObject(X[0]);
                      break;
                    case oe.OPS.paintFormXObjectBegin:
                      this.paintFormXObjectBegin(X[0], X[1]);
                      break;
                    case oe.OPS.paintFormXObjectEnd:
                      this.paintFormXObjectEnd();
                      break;
                    case oe.OPS.closePath:
                      this.closePath();
                      break;
                    case oe.OPS.closeStroke:
                      this.closeStroke();
                      break;
                    case oe.OPS.closeFillStroke:
                      this.closeFillStroke();
                      break;
                    case oe.OPS.closeEOFillStroke:
                      this.closeEOFillStroke();
                      break;
                    case oe.OPS.nextLine:
                      this.nextLine();
                      break;
                    case oe.OPS.transform:
                      this.transform(X[0], X[1], X[2], X[3], X[4], X[5]);
                      break;
                    case oe.OPS.constructPath:
                      this.constructPath(X[0], X[1]);
                      break;
                    case oe.OPS.endPath:
                      this.endPath();
                      break;
                    case 92:
                      this.group(C.items);
                      break;
                    default:
                      (0, oe.warn)(`Unimplemented operator ${p}`);
                      break;
                  }
                }
              }
              setWordSpacing(m) {
                this.current.wordSpacing = m;
              }
              setCharSpacing(m) {
                this.current.charSpacing = m;
              }
              nextLine() {
                this.moveText(0, this.current.leading);
              }
              setTextMatrix(m, C, p, w, X, M) {
                const j = this.current;
                j.textMatrix = j.lineMatrix = [m, C, p, w, X, M], j.textMatrixScale = Math.hypot(m, C), j.x = j.lineX = 0, j.y = j.lineY = 0, j.xcoords = [], j.ycoords = [], j.tspan = this.svgFactory.createElement("svg:tspan"), j.tspan.setAttributeNS(null, "font-family", j.fontFamily), j.tspan.setAttributeNS(null, "font-size", `${c(j.fontSize)}px`), j.tspan.setAttributeNS(null, "y", c(-j.y)), j.txtElement = this.svgFactory.createElement("svg:text"), j.txtElement.append(j.tspan);
              }
              beginText() {
                const m = this.current;
                m.x = m.lineX = 0, m.y = m.lineY = 0, m.textMatrix = oe.IDENTITY_MATRIX, m.lineMatrix = oe.IDENTITY_MATRIX, m.textMatrixScale = 1, m.tspan = this.svgFactory.createElement("svg:tspan"), m.txtElement = this.svgFactory.createElement("svg:text"), m.txtgrp = this.svgFactory.createElement("svg:g"), m.xcoords = [], m.ycoords = [];
              }
              moveText(m, C) {
                const p = this.current;
                p.x = p.lineX += m, p.y = p.lineY += C, p.xcoords = [], p.ycoords = [], p.tspan = this.svgFactory.createElement("svg:tspan"), p.tspan.setAttributeNS(null, "font-family", p.fontFamily), p.tspan.setAttributeNS(null, "font-size", `${c(p.fontSize)}px`), p.tspan.setAttributeNS(null, "y", c(-p.y));
              }
              showText(m) {
                const C = this.current, p = C.font, w = C.fontSize;
                if (w === 0)
                  return;
                const X = C.fontSizeScale, M = C.charSpacing, j = C.wordSpacing, B = C.fontDirection, R = C.textHScale * B, D = p.vertical, b = D ? 1 : -1, l = p.defaultVMetrics, _ = w * C.fontMatrix[0];
                let S = 0;
                for (const T of m) {
                  if (T === null) {
                    S += B * j;
                    continue;
                  } else if (typeof T == "number") {
                    S += b * T * w / 1e3;
                    continue;
                  }
                  const O = (T.isSpace ? j : 0) + M, U = T.fontChar;
                  let G, K, W = T.width;
                  if (D) {
                    let V;
                    const L = T.vmetric || l;
                    V = T.vmetric ? L[1] : W * 0.5, V = -V * _;
                    const Y = L[2] * _;
                    W = L ? -L[0] : W, G = V / X, K = (S + Y) / X;
                  } else
                    G = S / X, K = 0;
                  (T.isInFont || p.missingFile) && (C.xcoords.push(C.x + G), D && C.ycoords.push(-C.y + K), C.tspan.textContent += U);
                  let z;
                  D ? z = W * _ - O * B : z = W * _ + O * B, S += z;
                }
                C.tspan.setAttributeNS(null, "x", C.xcoords.map(c).join(" ")), D ? C.tspan.setAttributeNS(null, "y", C.ycoords.map(c).join(" ")) : C.tspan.setAttributeNS(null, "y", c(-C.y)), D ? C.y -= S : C.x += S * R, C.tspan.setAttributeNS(null, "font-family", C.fontFamily), C.tspan.setAttributeNS(null, "font-size", `${c(C.fontSize)}px`), C.fontStyle !== i.fontStyle && C.tspan.setAttributeNS(null, "font-style", C.fontStyle), C.fontWeight !== i.fontWeight && C.tspan.setAttributeNS(null, "font-weight", C.fontWeight);
                const A = C.textRenderingMode & oe.TextRenderingMode.FILL_STROKE_MASK;
                if (A === oe.TextRenderingMode.FILL || A === oe.TextRenderingMode.FILL_STROKE ? (C.fillColor !== i.fillColor && C.tspan.setAttributeNS(null, "fill", C.fillColor), C.fillAlpha < 1 && C.tspan.setAttributeNS(null, "fill-opacity", C.fillAlpha)) : C.textRenderingMode === oe.TextRenderingMode.ADD_TO_PATH ? C.tspan.setAttributeNS(null, "fill", "transparent") : C.tspan.setAttributeNS(null, "fill", "none"), A === oe.TextRenderingMode.STROKE || A === oe.TextRenderingMode.FILL_STROKE) {
                  const T = 1 / (C.textMatrixScale || 1);
                  this._setStrokeAttributes(C.tspan, T);
                }
                let F = C.textMatrix;
                C.textRise !== 0 && (F = F.slice(), F[5] += C.textRise), C.txtElement.setAttributeNS(null, "transform", `${n(F)} scale(${c(R)}, -1)`), C.txtElement.setAttributeNS(v, "xml:space", "preserve"), C.txtElement.append(C.tspan), C.txtgrp.append(C.txtElement), this._ensureTransformGroup().append(C.txtElement);
              }
              setLeadingMoveText(m, C) {
                this.setLeading(-C), this.moveText(m, C);
              }
              addFontStyle(m) {
                if (!m.data)
                  throw new Error('addFontStyle: No font data available, ensure that the "fontExtraProperties" API parameter is set.');
                this.cssStyle || (this.cssStyle = this.svgFactory.createElement("svg:style"), this.cssStyle.setAttributeNS(null, "type", "text/css"), this.defs.append(this.cssStyle));
                const C = r(m.data, m.mimetype, this.forceDataSchema);
                this.cssStyle.textContent += `@font-face { font-family: "${m.loadedName}"; src: url(${C}); }
`;
              }
              setFont(m) {
                const C = this.current, p = this.commonObjs.get(m[0]);
                let w = m[1];
                C.font = p, this.embedFonts && !p.missingFile && !this.embeddedFonts[p.loadedName] && (this.addFontStyle(p), this.embeddedFonts[p.loadedName] = p), C.fontMatrix = p.fontMatrix || oe.FONT_IDENTITY_MATRIX;
                let X = "normal";
                p.black ? X = "900" : p.bold && (X = "bold");
                const M = p.italic ? "italic" : "normal";
                w < 0 ? (w = -w, C.fontDirection = -1) : C.fontDirection = 1, C.fontSize = w, C.fontFamily = p.loadedName, C.fontWeight = X, C.fontStyle = M, C.tspan = this.svgFactory.createElement("svg:tspan"), C.tspan.setAttributeNS(null, "y", c(-C.y)), C.xcoords = [], C.ycoords = [];
              }
              endText() {
                var C;
                const m = this.current;
                m.textRenderingMode & oe.TextRenderingMode.ADD_TO_PATH_FLAG && ((C = m.txtElement) != null && C.hasChildNodes()) && (m.element = m.txtElement, this.clip("nonzero"), this.endPath());
              }
              setLineWidth(m) {
                m > 0 && (this.current.lineWidth = m);
              }
              setLineCap(m) {
                this.current.lineCap = e[m];
              }
              setLineJoin(m) {
                this.current.lineJoin = y[m];
              }
              setMiterLimit(m) {
                this.current.miterLimit = m;
              }
              setStrokeAlpha(m) {
                this.current.strokeAlpha = m;
              }
              setStrokeRGBColor(m, C, p) {
                this.current.strokeColor = oe.Util.makeHexColor(m, C, p);
              }
              setFillAlpha(m) {
                this.current.fillAlpha = m;
              }
              setFillRGBColor(m, C, p) {
                this.current.fillColor = oe.Util.makeHexColor(m, C, p), this.current.tspan = this.svgFactory.createElement("svg:tspan"), this.current.xcoords = [], this.current.ycoords = [];
              }
              setStrokeColorN(m) {
                this.current.strokeColor = this._makeColorN_Pattern(m);
              }
              setFillColorN(m) {
                this.current.fillColor = this._makeColorN_Pattern(m);
              }
              shadingFill(m) {
                const C = this.viewport.width, p = this.viewport.height, w = oe.Util.inverseTransform(this.transformMatrix), X = oe.Util.applyTransform([0, 0], w), M = oe.Util.applyTransform([0, p], w), j = oe.Util.applyTransform([C, 0], w), B = oe.Util.applyTransform([C, p], w), R = Math.min(X[0], M[0], j[0], B[0]), D = Math.min(X[1], M[1], j[1], B[1]), b = Math.max(X[0], M[0], j[0], B[0]), l = Math.max(X[1], M[1], j[1], B[1]), _ = this.svgFactory.createElement("svg:rect");
                _.setAttributeNS(null, "x", R), _.setAttributeNS(null, "y", D), _.setAttributeNS(null, "width", b - R), _.setAttributeNS(null, "height", l - D), _.setAttributeNS(null, "fill", this._makeShadingPattern(m)), this.current.fillAlpha < 1 && _.setAttributeNS(null, "fill-opacity", this.current.fillAlpha), this._ensureTransformGroup().append(_);
              }
              _makeColorN_Pattern(m) {
                return m[0] === "TilingPattern" ? this._makeTilingPattern(m) : this._makeShadingPattern(m);
              }
              _makeTilingPattern(m) {
                const C = m[1], p = m[2], w = m[3] || oe.IDENTITY_MATRIX, [X, M, j, B] = m[4], R = m[5], D = m[6], b = m[7], l = `shading${f++}`, [_, S, A, F] = oe.Util.normalizeRect([...oe.Util.applyTransform([X, M], w), ...oe.Util.applyTransform([j, B], w)]), [T, O] = oe.Util.singularValueDecompose2dScale(w), U = R * T, G = D * O, K = this.svgFactory.createElement("svg:pattern");
                K.setAttributeNS(null, "id", l), K.setAttributeNS(null, "patternUnits", "userSpaceOnUse"), K.setAttributeNS(null, "width", U), K.setAttributeNS(null, "height", G), K.setAttributeNS(null, "x", `${_}`), K.setAttributeNS(null, "y", `${S}`);
                const W = this.svg, z = this.transformMatrix, V = this.current.fillColor, L = this.current.strokeColor, Y = this.svgFactory.create(A - _, F - S);
                if (this.svg = Y, this.transformMatrix = w, b === 2) {
                  const J = oe.Util.makeHexColor(...C);
                  this.current.fillColor = J, this.current.strokeColor = J;
                }
                return this.executeOpTree(this.convertOpList(p)), this.svg = W, this.transformMatrix = z, this.current.fillColor = V, this.current.strokeColor = L, K.append(Y.childNodes[0]), this.defs.append(K), `url(#${l})`;
              }
              _makeShadingPattern(m) {
                switch (typeof m == "string" && (m = this.objs.get(m)), m[0]) {
                  case "RadialAxial":
                    const C = `shading${f++}`, p = m[3];
                    let w;
                    switch (m[1]) {
                      case "axial":
                        const X = m[4], M = m[5];
                        w = this.svgFactory.createElement("svg:linearGradient"), w.setAttributeNS(null, "id", C), w.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), w.setAttributeNS(null, "x1", X[0]), w.setAttributeNS(null, "y1", X[1]), w.setAttributeNS(null, "x2", M[0]), w.setAttributeNS(null, "y2", M[1]);
                        break;
                      case "radial":
                        const j = m[4], B = m[5], R = m[6], D = m[7];
                        w = this.svgFactory.createElement("svg:radialGradient"), w.setAttributeNS(null, "id", C), w.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), w.setAttributeNS(null, "cx", B[0]), w.setAttributeNS(null, "cy", B[1]), w.setAttributeNS(null, "r", D), w.setAttributeNS(null, "fx", j[0]), w.setAttributeNS(null, "fy", j[1]), w.setAttributeNS(null, "fr", R);
                        break;
                      default:
                        throw new Error(`Unknown RadialAxial type: ${m[1]}`);
                    }
                    for (const X of p) {
                      const M = this.svgFactory.createElement("svg:stop");
                      M.setAttributeNS(null, "offset", X[0]), M.setAttributeNS(null, "stop-color", X[1]), w.append(M);
                    }
                    return this.defs.append(w), `url(#${C})`;
                  case "Mesh":
                    return (0, oe.warn)("Unimplemented pattern Mesh"), null;
                  case "Dummy":
                    return "hotpink";
                  default:
                    throw new Error(`Unknown IR type: ${m[0]}`);
                }
              }
              setDash(m, C) {
                this.current.dashArray = m, this.current.dashPhase = C;
              }
              constructPath(m, C) {
                const p = this.current;
                let w = p.x, X = p.y, M = [], j = 0;
                for (const B of m)
                  switch (B | 0) {
                    case oe.OPS.rectangle:
                      w = C[j++], X = C[j++];
                      const R = C[j++], D = C[j++], b = w + R, l = X + D;
                      M.push("M", c(w), c(X), "L", c(b), c(X), "L", c(b), c(l), "L", c(w), c(l), "Z");
                      break;
                    case oe.OPS.moveTo:
                      w = C[j++], X = C[j++], M.push("M", c(w), c(X));
                      break;
                    case oe.OPS.lineTo:
                      w = C[j++], X = C[j++], M.push("L", c(w), c(X));
                      break;
                    case oe.OPS.curveTo:
                      w = C[j + 4], X = C[j + 5], M.push("C", c(C[j]), c(C[j + 1]), c(C[j + 2]), c(C[j + 3]), c(w), c(X)), j += 6;
                      break;
                    case oe.OPS.curveTo2:
                      M.push("C", c(w), c(X), c(C[j]), c(C[j + 1]), c(C[j + 2]), c(C[j + 3])), w = C[j + 2], X = C[j + 3], j += 4;
                      break;
                    case oe.OPS.curveTo3:
                      w = C[j + 2], X = C[j + 3], M.push("C", c(C[j]), c(C[j + 1]), c(w), c(X), c(w), c(X)), j += 4;
                      break;
                    case oe.OPS.closePath:
                      M.push("Z");
                      break;
                  }
                M = M.join(" "), p.path && m.length > 0 && m[0] !== oe.OPS.rectangle && m[0] !== oe.OPS.moveTo ? M = p.path.getAttributeNS(null, "d") + M : (p.path = this.svgFactory.createElement("svg:path"), this._ensureTransformGroup().append(p.path)), p.path.setAttributeNS(null, "d", M), p.path.setAttributeNS(null, "fill", "none"), p.element = p.path, p.setCurrentPoint(w, X);
              }
              endPath() {
                const m = this.current;
                if (m.path = null, !this.pendingClip)
                  return;
                if (!m.element) {
                  this.pendingClip = null;
                  return;
                }
                const C = `clippath${o++}`, p = this.svgFactory.createElement("svg:clipPath");
                p.setAttributeNS(null, "id", C), p.setAttributeNS(null, "transform", n(this.transformMatrix));
                const w = m.element.cloneNode(!0);
                if (this.pendingClip === "evenodd" ? w.setAttributeNS(null, "clip-rule", "evenodd") : w.setAttributeNS(null, "clip-rule", "nonzero"), this.pendingClip = null, p.append(w), this.defs.append(p), m.activeClipUrl) {
                  m.clipGroup = null;
                  for (const X of this.extraStack)
                    X.clipGroup = null;
                  p.setAttributeNS(null, "clip-path", m.activeClipUrl);
                }
                m.activeClipUrl = `url(#${C})`, this.tgrp = null;
              }
              clip(m) {
                this.pendingClip = m;
              }
              closePath() {
                const m = this.current;
                if (m.path) {
                  const C = `${m.path.getAttributeNS(null, "d")}Z`;
                  m.path.setAttributeNS(null, "d", C);
                }
              }
              setLeading(m) {
                this.current.leading = -m;
              }
              setTextRise(m) {
                this.current.textRise = m;
              }
              setTextRenderingMode(m) {
                this.current.textRenderingMode = m;
              }
              setHScale(m) {
                this.current.textHScale = m / 100;
              }
              setRenderingIntent(m) {
              }
              setFlatness(m) {
              }
              setGState(m) {
                for (const [C, p] of m)
                  switch (C) {
                    case "LW":
                      this.setLineWidth(p);
                      break;
                    case "LC":
                      this.setLineCap(p);
                      break;
                    case "LJ":
                      this.setLineJoin(p);
                      break;
                    case "ML":
                      this.setMiterLimit(p);
                      break;
                    case "D":
                      this.setDash(p[0], p[1]);
                      break;
                    case "RI":
                      this.setRenderingIntent(p);
                      break;
                    case "FL":
                      this.setFlatness(p);
                      break;
                    case "Font":
                      this.setFont(p);
                      break;
                    case "CA":
                      this.setStrokeAlpha(p);
                      break;
                    case "ca":
                      this.setFillAlpha(p);
                      break;
                    default:
                      (0, oe.warn)(`Unimplemented graphic state operator ${C}`);
                      break;
                  }
              }
              fill() {
                const m = this.current;
                m.element && (m.element.setAttributeNS(null, "fill", m.fillColor), m.element.setAttributeNS(null, "fill-opacity", m.fillAlpha), this.endPath());
              }
              stroke() {
                const m = this.current;
                m.element && (this._setStrokeAttributes(m.element), m.element.setAttributeNS(null, "fill", "none"), this.endPath());
              }
              _setStrokeAttributes(m, C = 1) {
                const p = this.current;
                let w = p.dashArray;
                C !== 1 && w.length > 0 && (w = w.map(function(X) {
                  return C * X;
                })), m.setAttributeNS(null, "stroke", p.strokeColor), m.setAttributeNS(null, "stroke-opacity", p.strokeAlpha), m.setAttributeNS(null, "stroke-miterlimit", c(p.miterLimit)), m.setAttributeNS(null, "stroke-linecap", p.lineCap), m.setAttributeNS(null, "stroke-linejoin", p.lineJoin), m.setAttributeNS(null, "stroke-width", c(C * p.lineWidth) + "px"), m.setAttributeNS(null, "stroke-dasharray", w.map(c).join(" ")), m.setAttributeNS(null, "stroke-dashoffset", c(C * p.dashPhase) + "px");
              }
              eoFill() {
                this.current.element && this.current.element.setAttributeNS(null, "fill-rule", "evenodd"), this.fill();
              }
              fillStroke() {
                this.stroke(), this.fill();
              }
              eoFillStroke() {
                this.current.element && this.current.element.setAttributeNS(null, "fill-rule", "evenodd"), this.fillStroke();
              }
              closeStroke() {
                this.closePath(), this.stroke();
              }
              closeFillStroke() {
                this.closePath(), this.fillStroke();
              }
              closeEOFillStroke() {
                this.closePath(), this.eoFillStroke();
              }
              paintSolidColorImageMask() {
                const m = this.svgFactory.createElement("svg:rect");
                m.setAttributeNS(null, "x", "0"), m.setAttributeNS(null, "y", "0"), m.setAttributeNS(null, "width", "1px"), m.setAttributeNS(null, "height", "1px"), m.setAttributeNS(null, "fill", this.current.fillColor), this._ensureTransformGroup().append(m);
              }
              paintImageXObject(m) {
                const C = m.startsWith("g_") ? this.commonObjs.get(m) : this.objs.get(m);
                if (!C) {
                  (0, oe.warn)(`Dependent image with object ID ${m} is not ready yet`);
                  return;
                }
                this.paintInlineImageXObject(C);
              }
              paintInlineImageXObject(m, C) {
                const p = m.width, w = m.height, X = h(m, this.forceDataSchema, !!C), M = this.svgFactory.createElement("svg:rect");
                M.setAttributeNS(null, "x", "0"), M.setAttributeNS(null, "y", "0"), M.setAttributeNS(null, "width", c(p)), M.setAttributeNS(null, "height", c(w)), this.current.element = M, this.clip("nonzero");
                const j = this.svgFactory.createElement("svg:image");
                j.setAttributeNS(a, "xlink:href", X), j.setAttributeNS(null, "x", "0"), j.setAttributeNS(null, "y", c(-w)), j.setAttributeNS(null, "width", c(p) + "px"), j.setAttributeNS(null, "height", c(w) + "px"), j.setAttributeNS(null, "transform", `scale(${c(1 / p)} ${c(-1 / w)})`), C ? C.append(j) : this._ensureTransformGroup().append(j);
              }
              paintImageMaskXObject(m) {
                const C = this.current, p = m.width, w = m.height, X = C.fillColor;
                C.maskId = `mask${x++}`;
                const M = this.svgFactory.createElement("svg:mask");
                M.setAttributeNS(null, "id", C.maskId);
                const j = this.svgFactory.createElement("svg:rect");
                j.setAttributeNS(null, "x", "0"), j.setAttributeNS(null, "y", "0"), j.setAttributeNS(null, "width", c(p)), j.setAttributeNS(null, "height", c(w)), j.setAttributeNS(null, "fill", X), j.setAttributeNS(null, "mask", `url(#${C.maskId})`), this.defs.append(M), this._ensureTransformGroup().append(j), this.paintInlineImageXObject(m, M);
              }
              paintFormXObjectBegin(m, C) {
                if (Array.isArray(m) && m.length === 6 && this.transform(m[0], m[1], m[2], m[3], m[4], m[5]), C) {
                  const p = C[2] - C[0], w = C[3] - C[1], X = this.svgFactory.createElement("svg:rect");
                  X.setAttributeNS(null, "x", C[0]), X.setAttributeNS(null, "y", C[1]), X.setAttributeNS(null, "width", c(p)), X.setAttributeNS(null, "height", c(w)), this.current.element = X, this.clip("nonzero"), this.endPath();
                }
              }
              paintFormXObjectEnd() {
              }
              _initialize(m) {
                const C = this.svgFactory.create(m.width, m.height), p = this.svgFactory.createElement("svg:defs");
                C.append(p), this.defs = p;
                const w = this.svgFactory.createElement("svg:g");
                return w.setAttributeNS(null, "transform", n(m.transform)), C.append(w), this.svg = w, C;
              }
              _ensureClipGroup() {
                if (!this.current.clipGroup) {
                  const m = this.svgFactory.createElement("svg:g");
                  m.setAttributeNS(null, "clip-path", this.current.activeClipUrl), this.svg.append(m), this.current.clipGroup = m;
                }
                return this.current.clipGroup;
              }
              _ensureTransformGroup() {
                return this.tgrp || (this.tgrp = this.svgFactory.createElement("svg:g"), this.tgrp.setAttributeNS(null, "transform", n(this.transformMatrix)), this.current.activeClipUrl ? this._ensureClipGroup().append(this.tgrp) : this.svg.append(this.tgrp)), this.tgrp;
              }
            };
          }
        },
        /* 32 */
        /***/
        (Ee, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.PDFNodeStream = void 0;
          var de = le(1), oe = le(33);
          const se = require$$5, Q = require$$5, u = require$$5, P = require$$5, t = /^file:\/\/\/[a-zA-Z]:\//;
          function i(c) {
            const n = P.parse(c);
            return n.protocol === "file:" || n.host ? n : /^[a-z]:[/\\]/i.test(c) ? P.parse(`file:///${c}`) : (n.host || (n.protocol = "file:"), n);
          }
          class v {
            constructor(n) {
              this.source = n, this.url = i(n.url), this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:", this.isFsUrl = this.url.protocol === "file:", this.httpHeaders = this.isHttp && n.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
            }
            get _progressiveDataLength() {
              var n;
              return ((n = this._fullRequestReader) == null ? void 0 : n._loaded) ?? 0;
            }
            getFullReader() {
              return (0, de.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once."), this._fullRequestReader = this.isFsUrl ? new g(this) : new r(this), this._fullRequestReader;
            }
            getRangeReader(n, o) {
              if (o <= this._progressiveDataLength)
                return null;
              const x = this.isFsUrl ? new d(this, n, o) : new h(this, n, o);
              return this._rangeRequestReaders.push(x), x;
            }
            cancelAllRequests(n) {
              this._fullRequestReader && this._fullRequestReader.cancel(n);
              for (const o of this._rangeRequestReaders.slice(0))
                o.cancel(n);
            }
          }
          ge.PDFNodeStream = v;
          class a {
            constructor(n) {
              this._url = n.url, this._done = !1, this._storedError = null, this.onProgress = null;
              const o = n.source;
              this._contentLength = o.length, this._loaded = 0, this._filename = null, this._disableRange = o.disableRange || !1, this._rangeChunkSize = o.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !o.disableStream, this._isRangeSupported = !o.disableRange, this._readableStream = null, this._readCapability = (0, de.createPromiseCapability)(), this._headersCapability = (0, de.createPromiseCapability)();
            }
            get headersReady() {
              return this._headersCapability.promise;
            }
            get filename() {
              return this._filename;
            }
            get contentLength() {
              return this._contentLength;
            }
            get isRangeSupported() {
              return this._isRangeSupported;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            async read() {
              if (await this._readCapability.promise, this._done)
                return {
                  value: void 0,
                  done: !0
                };
              if (this._storedError)
                throw this._storedError;
              const n = this._readableStream.read();
              return n === null ? (this._readCapability = (0, de.createPromiseCapability)(), this.read()) : (this._loaded += n.length, this.onProgress && this.onProgress({
                loaded: this._loaded,
                total: this._contentLength
              }), {
                value: new Uint8Array(n).buffer,
                done: !1
              });
            }
            cancel(n) {
              if (!this._readableStream) {
                this._error(n);
                return;
              }
              this._readableStream.destroy(n);
            }
            _error(n) {
              this._storedError = n, this._readCapability.resolve();
            }
            _setReadableStream(n) {
              this._readableStream = n, n.on("readable", () => {
                this._readCapability.resolve();
              }), n.on("end", () => {
                n.destroy(), this._done = !0, this._readCapability.resolve();
              }), n.on("error", (o) => {
                this._error(o);
              }), !this._isStreamingSupported && this._isRangeSupported && this._error(new de.AbortException("streaming is disabled")), this._storedError && this._readableStream.destroy(this._storedError);
            }
          }
          class e {
            constructor(n) {
              this._url = n.url, this._done = !1, this._storedError = null, this.onProgress = null, this._loaded = 0, this._readableStream = null, this._readCapability = (0, de.createPromiseCapability)();
              const o = n.source;
              this._isStreamingSupported = !o.disableStream;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            async read() {
              if (await this._readCapability.promise, this._done)
                return {
                  value: void 0,
                  done: !0
                };
              if (this._storedError)
                throw this._storedError;
              const n = this._readableStream.read();
              return n === null ? (this._readCapability = (0, de.createPromiseCapability)(), this.read()) : (this._loaded += n.length, this.onProgress && this.onProgress({
                loaded: this._loaded
              }), {
                value: new Uint8Array(n).buffer,
                done: !1
              });
            }
            cancel(n) {
              if (!this._readableStream) {
                this._error(n);
                return;
              }
              this._readableStream.destroy(n);
            }
            _error(n) {
              this._storedError = n, this._readCapability.resolve();
            }
            _setReadableStream(n) {
              this._readableStream = n, n.on("readable", () => {
                this._readCapability.resolve();
              }), n.on("end", () => {
                n.destroy(), this._done = !0, this._readCapability.resolve();
              }), n.on("error", (o) => {
                this._error(o);
              }), this._storedError && this._readableStream.destroy(this._storedError);
            }
          }
          function y(c, n) {
            return {
              protocol: c.protocol,
              auth: c.auth,
              host: c.hostname,
              port: c.port,
              path: c.path,
              method: "GET",
              headers: n
            };
          }
          class r extends a {
            constructor(n) {
              super(n);
              const o = (x) => {
                if (x.statusCode === 404) {
                  const p = new de.MissingPDFException(`Missing PDF "${this._url}".`);
                  this._storedError = p, this._headersCapability.reject(p);
                  return;
                }
                this._headersCapability.resolve(), this._setReadableStream(x);
                const f = (p) => this._readableStream.headers[p.toLowerCase()], {
                  allowRangeRequests: m,
                  suggestedLength: C
                } = (0, oe.validateRangeRequestCapabilities)({
                  getResponseHeader: f,
                  isHttp: n.isHttp,
                  rangeChunkSize: this._rangeChunkSize,
                  disableRange: this._disableRange
                });
                this._isRangeSupported = m, this._contentLength = C || this._contentLength, this._filename = (0, oe.extractFilenameFromHeader)(f);
              };
              this._request = null, this._url.protocol === "http:" ? this._request = Q.request(y(this._url, n.httpHeaders), o) : this._request = u.request(y(this._url, n.httpHeaders), o), this._request.on("error", (x) => {
                this._storedError = x, this._headersCapability.reject(x);
              }), this._request.end();
            }
          }
          class h extends e {
            constructor(n, o, x) {
              super(n), this._httpHeaders = {};
              for (const m in n.httpHeaders) {
                const C = n.httpHeaders[m];
                typeof C > "u" || (this._httpHeaders[m] = C);
              }
              this._httpHeaders.Range = `bytes=${o}-${x - 1}`;
              const f = (m) => {
                if (m.statusCode === 404) {
                  const C = new de.MissingPDFException(`Missing PDF "${this._url}".`);
                  this._storedError = C;
                  return;
                }
                this._setReadableStream(m);
              };
              this._request = null, this._url.protocol === "http:" ? this._request = Q.request(y(this._url, this._httpHeaders), f) : this._request = u.request(y(this._url, this._httpHeaders), f), this._request.on("error", (m) => {
                this._storedError = m;
              }), this._request.end();
            }
          }
          class g extends a {
            constructor(n) {
              super(n);
              let o = decodeURIComponent(this._url.path);
              t.test(this._url.href) && (o = o.replace(/^\//, "")), se.lstat(o, (x, f) => {
                if (x) {
                  x.code === "ENOENT" && (x = new de.MissingPDFException(`Missing PDF "${o}".`)), this._storedError = x, this._headersCapability.reject(x);
                  return;
                }
                this._contentLength = f.size, this._setReadableStream(se.createReadStream(o)), this._headersCapability.resolve();
              });
            }
          }
          class d extends e {
            constructor(n, o, x) {
              super(n);
              let f = decodeURIComponent(this._url.path);
              t.test(this._url.href) && (f = f.replace(/^\//, "")), this._setReadableStream(se.createReadStream(f, {
                start: o,
                end: x - 1
              }));
            }
          }
        },
        /* 33 */
        /***/
        (Ee, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.createResponseStatusError = P, ge.extractFilenameFromHeader = u, ge.validateRangeRequestCapabilities = Q, ge.validateResponseStatus = t;
          var de = le(1), oe = le(34), se = le(8);
          function Q({
            getResponseHeader: i,
            isHttp: v,
            rangeChunkSize: a,
            disableRange: e
          }) {
            const y = {
              allowRangeRequests: !1,
              suggestedLength: void 0
            }, r = parseInt(i("Content-Length"), 10);
            return !Number.isInteger(r) || (y.suggestedLength = r, r <= 2 * a) || e || !v || i("Accept-Ranges") !== "bytes" || (i("Content-Encoding") || "identity") !== "identity" || (y.allowRangeRequests = !0), y;
          }
          function u(i) {
            const v = i("Content-Disposition");
            if (v) {
              let a = (0, oe.getFilenameFromContentDispositionHeader)(v);
              if (a.includes("%"))
                try {
                  a = decodeURIComponent(a);
                } catch {
                }
              if ((0, se.isPdfFile)(a))
                return a;
            }
            return null;
          }
          function P(i, v) {
            return i === 404 || i === 0 && v.startsWith("file:") ? new de.MissingPDFException('Missing PDF "' + v + '".') : new de.UnexpectedResponseException(`Unexpected server response (${i}) while retrieving PDF "${v}".`, i);
          }
          function t(i) {
            return i === 200 || i === 206;
          }
        },
        /* 34 */
        /***/
        (Ee, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.getFilenameFromContentDispositionHeader = oe;
          var de = le(1);
          function oe(se) {
            let Q = !0, u = P("filename\\*", "i").exec(se);
            if (u) {
              u = u[1];
              let r = a(u);
              return r = unescape(r), r = e(r), r = y(r), i(r);
            }
            if (u = v(se), u) {
              const r = y(u);
              return i(r);
            }
            if (u = P("filename", "i").exec(se), u) {
              u = u[1];
              let r = a(u);
              return r = y(r), i(r);
            }
            function P(r, h) {
              return new RegExp("(?:^|;)\\s*" + r + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', h);
            }
            function t(r, h) {
              if (r) {
                if (!/^[\x00-\xFF]+$/.test(h))
                  return h;
                try {
                  const g = new TextDecoder(r, {
                    fatal: !0
                  }), d = (0, de.stringToBytes)(h);
                  h = g.decode(d), Q = !1;
                } catch {
                }
              }
              return h;
            }
            function i(r) {
              return Q && /[\x80-\xff]/.test(r) && (r = t("utf-8", r), Q && (r = t("iso-8859-1", r))), r;
            }
            function v(r) {
              const h = [];
              let g;
              const d = P("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
              for (; (g = d.exec(r)) !== null; ) {
                let [, n, o, x] = g;
                if (n = parseInt(n, 10), n in h) {
                  if (n === 0)
                    break;
                  continue;
                }
                h[n] = [o, x];
              }
              const c = [];
              for (let n = 0; n < h.length && n in h; ++n) {
                let [o, x] = h[n];
                x = a(x), o && (x = unescape(x), n === 0 && (x = e(x))), c.push(x);
              }
              return c.join("");
            }
            function a(r) {
              if (r.startsWith('"')) {
                const h = r.slice(1).split('\\"');
                for (let g = 0; g < h.length; ++g) {
                  const d = h[g].indexOf('"');
                  d !== -1 && (h[g] = h[g].slice(0, d), h.length = g + 1), h[g] = h[g].replace(/\\(.)/g, "$1");
                }
                r = h.join('"');
              }
              return r;
            }
            function e(r) {
              const h = r.indexOf("'");
              if (h === -1)
                return r;
              const g = r.slice(0, h), c = r.slice(h + 1).replace(/^[^']*'/, "");
              return t(g, c);
            }
            function y(r) {
              return !r.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(r) ? r : r.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(h, g, d, c) {
                if (d === "q" || d === "Q")
                  return c = c.replace(/_/g, " "), c = c.replace(/=([0-9a-fA-F]{2})/g, function(n, o) {
                    return String.fromCharCode(parseInt(o, 16));
                  }), t(g, c);
                try {
                  c = atob(c);
                } catch {
                }
                return t(g, c);
              });
            }
            return "";
          }
        },
        /* 35 */
        /***/
        (Ee, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.PDFNetworkStream = void 0;
          var de = le(1), oe = le(33);
          const se = 200, Q = 206;
          function u(a) {
            const e = a.response;
            return typeof e != "string" ? e : (0, de.stringToBytes)(e).buffer;
          }
          class P {
            constructor(e, y = {}) {
              this.url = e, this.isHttp = /^https?:/i.test(e), this.httpHeaders = this.isHttp && y.httpHeaders || /* @__PURE__ */ Object.create(null), this.withCredentials = y.withCredentials || !1, this.getXhr = y.getXhr || function() {
                return new XMLHttpRequest();
              }, this.currXhrId = 0, this.pendingRequests = /* @__PURE__ */ Object.create(null);
            }
            requestRange(e, y, r) {
              const h = {
                begin: e,
                end: y
              };
              for (const g in r)
                h[g] = r[g];
              return this.request(h);
            }
            requestFull(e) {
              return this.request(e);
            }
            request(e) {
              const y = this.getXhr(), r = this.currXhrId++, h = this.pendingRequests[r] = {
                xhr: y
              };
              y.open("GET", this.url), y.withCredentials = this.withCredentials;
              for (const g in this.httpHeaders) {
                const d = this.httpHeaders[g];
                typeof d > "u" || y.setRequestHeader(g, d);
              }
              return this.isHttp && "begin" in e && "end" in e ? (y.setRequestHeader("Range", `bytes=${e.begin}-${e.end - 1}`), h.expectedStatus = Q) : h.expectedStatus = se, y.responseType = "arraybuffer", e.onError && (y.onerror = function(g) {
                e.onError(y.status);
              }), y.onreadystatechange = this.onStateChange.bind(this, r), y.onprogress = this.onProgress.bind(this, r), h.onHeadersReceived = e.onHeadersReceived, h.onDone = e.onDone, h.onError = e.onError, h.onProgress = e.onProgress, y.send(null), r;
            }
            onProgress(e, y) {
              var h;
              const r = this.pendingRequests[e];
              r && ((h = r.onProgress) == null || h.call(r, y));
            }
            onStateChange(e, y) {
              var n, o, x;
              const r = this.pendingRequests[e];
              if (!r)
                return;
              const h = r.xhr;
              if (h.readyState >= 2 && r.onHeadersReceived && (r.onHeadersReceived(), delete r.onHeadersReceived), h.readyState !== 4 || !(e in this.pendingRequests))
                return;
              if (delete this.pendingRequests[e], h.status === 0 && this.isHttp) {
                (n = r.onError) == null || n.call(r, h.status);
                return;
              }
              const g = h.status || se;
              if (!(g === se && r.expectedStatus === Q) && g !== r.expectedStatus) {
                (o = r.onError) == null || o.call(r, h.status);
                return;
              }
              const c = u(h);
              if (g === Q) {
                const f = h.getResponseHeader("Content-Range"), m = /bytes (\d+)-(\d+)\/(\d+)/.exec(f);
                r.onDone({
                  begin: parseInt(m[1], 10),
                  chunk: c
                });
              } else
                c ? r.onDone({
                  begin: 0,
                  chunk: c
                }) : (x = r.onError) == null || x.call(r, h.status);
            }
            getRequestXhr(e) {
              return this.pendingRequests[e].xhr;
            }
            isPendingRequest(e) {
              return e in this.pendingRequests;
            }
            abortRequest(e) {
              const y = this.pendingRequests[e].xhr;
              delete this.pendingRequests[e], y.abort();
            }
          }
          class t {
            constructor(e) {
              this._source = e, this._manager = new P(e.url, {
                httpHeaders: e.httpHeaders,
                withCredentials: e.withCredentials
              }), this._rangeChunkSize = e.rangeChunkSize, this._fullRequestReader = null, this._rangeRequestReaders = [];
            }
            _onRangeRequestReaderClosed(e) {
              const y = this._rangeRequestReaders.indexOf(e);
              y >= 0 && this._rangeRequestReaders.splice(y, 1);
            }
            getFullReader() {
              return (0, de.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once."), this._fullRequestReader = new i(this._manager, this._source), this._fullRequestReader;
            }
            getRangeReader(e, y) {
              const r = new v(this._manager, e, y);
              return r.onClosed = this._onRangeRequestReaderClosed.bind(this), this._rangeRequestReaders.push(r), r;
            }
            cancelAllRequests(e) {
              var y;
              (y = this._fullRequestReader) == null || y.cancel(e);
              for (const r of this._rangeRequestReaders.slice(0))
                r.cancel(e);
            }
          }
          ge.PDFNetworkStream = t;
          class i {
            constructor(e, y) {
              this._manager = e;
              const r = {
                onHeadersReceived: this._onHeadersReceived.bind(this),
                onDone: this._onDone.bind(this),
                onError: this._onError.bind(this),
                onProgress: this._onProgress.bind(this)
              };
              this._url = y.url, this._fullRequestId = e.requestFull(r), this._headersReceivedCapability = (0, de.createPromiseCapability)(), this._disableRange = y.disableRange || !1, this._contentLength = y.length, this._rangeChunkSize = y.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !1, this._isRangeSupported = !1, this._cachedChunks = [], this._requests = [], this._done = !1, this._storedError = void 0, this._filename = null, this.onProgress = null;
            }
            _onHeadersReceived() {
              const e = this._fullRequestId, y = this._manager.getRequestXhr(e), r = (d) => y.getResponseHeader(d), {
                allowRangeRequests: h,
                suggestedLength: g
              } = (0, oe.validateRangeRequestCapabilities)({
                getResponseHeader: r,
                isHttp: this._manager.isHttp,
                rangeChunkSize: this._rangeChunkSize,
                disableRange: this._disableRange
              });
              h && (this._isRangeSupported = !0), this._contentLength = g || this._contentLength, this._filename = (0, oe.extractFilenameFromHeader)(r), this._isRangeSupported && this._manager.abortRequest(e), this._headersReceivedCapability.resolve();
            }
            _onDone(e) {
              if (e && (this._requests.length > 0 ? this._requests.shift().resolve({
                value: e.chunk,
                done: !1
              }) : this._cachedChunks.push(e.chunk)), this._done = !0, !(this._cachedChunks.length > 0)) {
                for (const y of this._requests)
                  y.resolve({
                    value: void 0,
                    done: !0
                  });
                this._requests.length = 0;
              }
            }
            _onError(e) {
              this._storedError = (0, oe.createResponseStatusError)(e, this._url), this._headersReceivedCapability.reject(this._storedError);
              for (const y of this._requests)
                y.reject(this._storedError);
              this._requests.length = 0, this._cachedChunks.length = 0;
            }
            _onProgress(e) {
              var y;
              (y = this.onProgress) == null || y.call(this, {
                loaded: e.loaded,
                total: e.lengthComputable ? e.total : this._contentLength
              });
            }
            get filename() {
              return this._filename;
            }
            get isRangeSupported() {
              return this._isRangeSupported;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            get contentLength() {
              return this._contentLength;
            }
            get headersReady() {
              return this._headersReceivedCapability.promise;
            }
            async read() {
              if (this._storedError)
                throw this._storedError;
              if (this._cachedChunks.length > 0)
                return {
                  value: this._cachedChunks.shift(),
                  done: !1
                };
              if (this._done)
                return {
                  value: void 0,
                  done: !0
                };
              const e = (0, de.createPromiseCapability)();
              return this._requests.push(e), e.promise;
            }
            cancel(e) {
              this._done = !0, this._headersReceivedCapability.reject(e);
              for (const y of this._requests)
                y.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0, this._manager.isPendingRequest(this._fullRequestId) && this._manager.abortRequest(this._fullRequestId), this._fullRequestReader = null;
            }
          }
          class v {
            constructor(e, y, r) {
              this._manager = e;
              const h = {
                onDone: this._onDone.bind(this),
                onError: this._onError.bind(this),
                onProgress: this._onProgress.bind(this)
              };
              this._url = e.url, this._requestId = e.requestRange(y, r, h), this._requests = [], this._queuedChunk = null, this._done = !1, this._storedError = void 0, this.onProgress = null, this.onClosed = null;
            }
            _close() {
              var e;
              (e = this.onClosed) == null || e.call(this, this);
            }
            _onDone(e) {
              const y = e.chunk;
              this._requests.length > 0 ? this._requests.shift().resolve({
                value: y,
                done: !1
              }) : this._queuedChunk = y, this._done = !0;
              for (const r of this._requests)
                r.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0, this._close();
            }
            _onError(e) {
              this._storedError = (0, oe.createResponseStatusError)(e, this._url);
              for (const y of this._requests)
                y.reject(this._storedError);
              this._requests.length = 0, this._queuedChunk = null;
            }
            _onProgress(e) {
              var y;
              this.isStreamingSupported || (y = this.onProgress) == null || y.call(this, {
                loaded: e.loaded
              });
            }
            get isStreamingSupported() {
              return !1;
            }
            async read() {
              if (this._storedError)
                throw this._storedError;
              if (this._queuedChunk !== null) {
                const y = this._queuedChunk;
                return this._queuedChunk = null, {
                  value: y,
                  done: !1
                };
              }
              if (this._done)
                return {
                  value: void 0,
                  done: !0
                };
              const e = (0, de.createPromiseCapability)();
              return this._requests.push(e), e.promise;
            }
            cancel(e) {
              this._done = !0;
              for (const y of this._requests)
                y.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0, this._manager.isPendingRequest(this._requestId) && this._manager.abortRequest(this._requestId), this._close();
            }
          }
        },
        /* 36 */
        /***/
        (Ee, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.PDFFetchStream = void 0;
          var de = le(1), oe = le(33);
          function se(i, v, a) {
            return {
              method: "GET",
              headers: i,
              signal: a.signal,
              mode: "cors",
              credentials: v ? "include" : "same-origin",
              redirect: "follow"
            };
          }
          function Q(i) {
            const v = new Headers();
            for (const a in i) {
              const e = i[a];
              typeof e > "u" || v.append(a, e);
            }
            return v;
          }
          class u {
            constructor(v) {
              this.source = v, this.isHttp = /^https?:/i.test(v.url), this.httpHeaders = this.isHttp && v.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
            }
            get _progressiveDataLength() {
              var v;
              return ((v = this._fullRequestReader) == null ? void 0 : v._loaded) ?? 0;
            }
            getFullReader() {
              return (0, de.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once."), this._fullRequestReader = new P(this), this._fullRequestReader;
            }
            getRangeReader(v, a) {
              if (a <= this._progressiveDataLength)
                return null;
              const e = new t(this, v, a);
              return this._rangeRequestReaders.push(e), e;
            }
            cancelAllRequests(v) {
              this._fullRequestReader && this._fullRequestReader.cancel(v);
              for (const a of this._rangeRequestReaders.slice(0))
                a.cancel(v);
            }
          }
          ge.PDFFetchStream = u;
          class P {
            constructor(v) {
              this._stream = v, this._reader = null, this._loaded = 0, this._filename = null;
              const a = v.source;
              this._withCredentials = a.withCredentials || !1, this._contentLength = a.length, this._headersCapability = (0, de.createPromiseCapability)(), this._disableRange = a.disableRange || !1, this._rangeChunkSize = a.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._abortController = new AbortController(), this._isStreamingSupported = !a.disableStream, this._isRangeSupported = !a.disableRange, this._headers = Q(this._stream.httpHeaders);
              const e = a.url;
              fetch(e, se(this._headers, this._withCredentials, this._abortController)).then((y) => {
                if (!(0, oe.validateResponseStatus)(y.status))
                  throw (0, oe.createResponseStatusError)(y.status, e);
                this._reader = y.body.getReader(), this._headersCapability.resolve();
                const r = (d) => y.headers.get(d), {
                  allowRangeRequests: h,
                  suggestedLength: g
                } = (0, oe.validateRangeRequestCapabilities)({
                  getResponseHeader: r,
                  isHttp: this._stream.isHttp,
                  rangeChunkSize: this._rangeChunkSize,
                  disableRange: this._disableRange
                });
                this._isRangeSupported = h, this._contentLength = g || this._contentLength, this._filename = (0, oe.extractFilenameFromHeader)(r), !this._isStreamingSupported && this._isRangeSupported && this.cancel(new de.AbortException("Streaming is disabled."));
              }).catch(this._headersCapability.reject), this.onProgress = null;
            }
            get headersReady() {
              return this._headersCapability.promise;
            }
            get filename() {
              return this._filename;
            }
            get contentLength() {
              return this._contentLength;
            }
            get isRangeSupported() {
              return this._isRangeSupported;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            async read() {
              await this._headersCapability.promise;
              const {
                value: v,
                done: a
              } = await this._reader.read();
              return a ? {
                value: v,
                done: a
              } : (this._loaded += v.byteLength, this.onProgress && this.onProgress({
                loaded: this._loaded,
                total: this._contentLength
              }), {
                value: new Uint8Array(v).buffer,
                done: !1
              });
            }
            cancel(v) {
              this._reader && this._reader.cancel(v), this._abortController.abort();
            }
          }
          class t {
            constructor(v, a, e) {
              this._stream = v, this._reader = null, this._loaded = 0;
              const y = v.source;
              this._withCredentials = y.withCredentials || !1, this._readCapability = (0, de.createPromiseCapability)(), this._isStreamingSupported = !y.disableStream, this._abortController = new AbortController(), this._headers = Q(this._stream.httpHeaders), this._headers.append("Range", `bytes=${a}-${e - 1}`);
              const r = y.url;
              fetch(r, se(this._headers, this._withCredentials, this._abortController)).then((h) => {
                if (!(0, oe.validateResponseStatus)(h.status))
                  throw (0, oe.createResponseStatusError)(h.status, r);
                this._readCapability.resolve(), this._reader = h.body.getReader();
              }).catch(this._readCapability.reject), this.onProgress = null;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            async read() {
              await this._readCapability.promise;
              const {
                value: v,
                done: a
              } = await this._reader.read();
              return a ? {
                value: v,
                done: a
              } : (this._loaded += v.byteLength, this.onProgress && this.onProgress({
                loaded: this._loaded
              }), {
                value: new Uint8Array(v).buffer,
                done: !1
              });
            }
            cancel(v) {
              this._reader && this._reader.cancel(v), this._abortController.abort();
            }
          }
        }
        /******/
      ], __webpack_module_cache__ = {};
      function __w_pdfjs_require__(Ee) {
        var ge = __webpack_module_cache__[Ee];
        if (ge !== void 0)
          return ge.exports;
        var le = __webpack_module_cache__[Ee] = {
          /******/
          // no module.id needed
          /******/
          // no module.loaded needed
          /******/
          exports: {}
          /******/
        };
        return __webpack_modules__[Ee](le, le.exports, __w_pdfjs_require__), le.exports;
      }
      var __webpack_exports__ = {};
      return (() => {
        var Ee = __webpack_exports__;
        Object.defineProperty(Ee, "__esModule", {
          value: !0
        }), Object.defineProperty(Ee, "AnnotationEditorLayer", {
          enumerable: !0,
          get: function() {
            return oe.AnnotationEditorLayer;
          }
        }), Object.defineProperty(Ee, "AnnotationEditorParamsType", {
          enumerable: !0,
          get: function() {
            return ge.AnnotationEditorParamsType;
          }
        }), Object.defineProperty(Ee, "AnnotationEditorType", {
          enumerable: !0,
          get: function() {
            return ge.AnnotationEditorType;
          }
        }), Object.defineProperty(Ee, "AnnotationEditorUIManager", {
          enumerable: !0,
          get: function() {
            return se.AnnotationEditorUIManager;
          }
        }), Object.defineProperty(Ee, "AnnotationLayer", {
          enumerable: !0,
          get: function() {
            return Q.AnnotationLayer;
          }
        }), Object.defineProperty(Ee, "AnnotationMode", {
          enumerable: !0,
          get: function() {
            return ge.AnnotationMode;
          }
        }), Object.defineProperty(Ee, "CMapCompressionType", {
          enumerable: !0,
          get: function() {
            return ge.CMapCompressionType;
          }
        }), Object.defineProperty(Ee, "GlobalWorkerOptions", {
          enumerable: !0,
          get: function() {
            return u.GlobalWorkerOptions;
          }
        }), Object.defineProperty(Ee, "InvalidPDFException", {
          enumerable: !0,
          get: function() {
            return ge.InvalidPDFException;
          }
        }), Object.defineProperty(Ee, "LoopbackPort", {
          enumerable: !0,
          get: function() {
            return le.LoopbackPort;
          }
        }), Object.defineProperty(Ee, "MissingPDFException", {
          enumerable: !0,
          get: function() {
            return ge.MissingPDFException;
          }
        }), Object.defineProperty(Ee, "OPS", {
          enumerable: !0,
          get: function() {
            return ge.OPS;
          }
        }), Object.defineProperty(Ee, "PDFDataRangeTransport", {
          enumerable: !0,
          get: function() {
            return le.PDFDataRangeTransport;
          }
        }), Object.defineProperty(Ee, "PDFDateString", {
          enumerable: !0,
          get: function() {
            return de.PDFDateString;
          }
        }), Object.defineProperty(Ee, "PDFWorker", {
          enumerable: !0,
          get: function() {
            return le.PDFWorker;
          }
        }), Object.defineProperty(Ee, "PasswordResponses", {
          enumerable: !0,
          get: function() {
            return ge.PasswordResponses;
          }
        }), Object.defineProperty(Ee, "PermissionFlag", {
          enumerable: !0,
          get: function() {
            return ge.PermissionFlag;
          }
        }), Object.defineProperty(Ee, "PixelsPerInch", {
          enumerable: !0,
          get: function() {
            return de.PixelsPerInch;
          }
        }), Object.defineProperty(Ee, "RenderingCancelledException", {
          enumerable: !0,
          get: function() {
            return de.RenderingCancelledException;
          }
        }), Object.defineProperty(Ee, "SVGGraphics", {
          enumerable: !0,
          get: function() {
            return i.SVGGraphics;
          }
        }), Object.defineProperty(Ee, "UNSUPPORTED_FEATURES", {
          enumerable: !0,
          get: function() {
            return ge.UNSUPPORTED_FEATURES;
          }
        }), Object.defineProperty(Ee, "UnexpectedResponseException", {
          enumerable: !0,
          get: function() {
            return ge.UnexpectedResponseException;
          }
        }), Object.defineProperty(Ee, "Util", {
          enumerable: !0,
          get: function() {
            return ge.Util;
          }
        }), Object.defineProperty(Ee, "VerbosityLevel", {
          enumerable: !0,
          get: function() {
            return ge.VerbosityLevel;
          }
        }), Object.defineProperty(Ee, "XfaLayer", {
          enumerable: !0,
          get: function() {
            return v.XfaLayer;
          }
        }), Object.defineProperty(Ee, "build", {
          enumerable: !0,
          get: function() {
            return le.build;
          }
        }), Object.defineProperty(Ee, "createPromiseCapability", {
          enumerable: !0,
          get: function() {
            return ge.createPromiseCapability;
          }
        }), Object.defineProperty(Ee, "createValidAbsoluteUrl", {
          enumerable: !0,
          get: function() {
            return ge.createValidAbsoluteUrl;
          }
        }), Object.defineProperty(Ee, "getDocument", {
          enumerable: !0,
          get: function() {
            return le.getDocument;
          }
        }), Object.defineProperty(Ee, "getFilenameFromUrl", {
          enumerable: !0,
          get: function() {
            return de.getFilenameFromUrl;
          }
        }), Object.defineProperty(Ee, "getPdfFilenameFromUrl", {
          enumerable: !0,
          get: function() {
            return de.getPdfFilenameFromUrl;
          }
        }), Object.defineProperty(Ee, "getXfaPageViewport", {
          enumerable: !0,
          get: function() {
            return de.getXfaPageViewport;
          }
        }), Object.defineProperty(Ee, "isPdfFile", {
          enumerable: !0,
          get: function() {
            return de.isPdfFile;
          }
        }), Object.defineProperty(Ee, "loadScript", {
          enumerable: !0,
          get: function() {
            return de.loadScript;
          }
        }), Object.defineProperty(Ee, "renderTextLayer", {
          enumerable: !0,
          get: function() {
            return t.renderTextLayer;
          }
        }), Object.defineProperty(Ee, "shadow", {
          enumerable: !0,
          get: function() {
            return ge.shadow;
          }
        }), Object.defineProperty(Ee, "version", {
          enumerable: !0,
          get: function() {
            return le.version;
          }
        });
        var ge = __w_pdfjs_require__(1), le = __w_pdfjs_require__(4), de = __w_pdfjs_require__(8), oe = __w_pdfjs_require__(22), se = __w_pdfjs_require__(7), Q = __w_pdfjs_require__(27), u = __w_pdfjs_require__(15), P = __w_pdfjs_require__(3), t = __w_pdfjs_require__(30), i = __w_pdfjs_require__(31), v = __w_pdfjs_require__(29);
        if (P.isNodeJS) {
          const {
            PDFNodeStream: a
          } = __w_pdfjs_require__(32);
          (0, le.setPDFNetworkStreamFactory)((e) => new a(e));
        } else {
          const {
            PDFNetworkStream: a
          } = __w_pdfjs_require__(35), {
            PDFFetchStream: e
          } = __w_pdfjs_require__(36);
          (0, le.setPDFNetworkStreamFactory)((y) => (0, de.isValidFetchUrl)(y.url) ? new e(y) : new a(y));
        }
      })(), __webpack_exports__;
    })()
  ));
})(pdf);
function _typeof(Ee) {
  return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ge) {
    return typeof ge;
  } : function(ge) {
    return ge && typeof Symbol == "function" && ge.constructor === Symbol && ge !== Symbol.prototype ? "symbol" : typeof ge;
  }, _typeof(Ee);
}
function _classCallCheck(Ee, ge) {
  if (!(Ee instanceof ge))
    throw new TypeError("Cannot call a class as a function");
}
function _toPrimitive(Ee, ge) {
  if (_typeof(Ee) !== "object" || Ee === null)
    return Ee;
  var le = Ee[Symbol.toPrimitive];
  if (le !== void 0) {
    var de = le.call(Ee, ge || "default");
    if (_typeof(de) !== "object")
      return de;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (ge === "string" ? String : Number)(Ee);
}
function _toPropertyKey(Ee) {
  var ge = _toPrimitive(Ee, "string");
  return _typeof(ge) === "symbol" ? ge : String(ge);
}
function _defineProperties(Ee, ge) {
  for (var le = 0; le < ge.length; le++) {
    var de = ge[le];
    de.enumerable = de.enumerable || !1, de.configurable = !0, "value" in de && (de.writable = !0), Object.defineProperty(Ee, _toPropertyKey(de.key), de);
  }
}
function _createClass(Ee, ge, le) {
  return ge && _defineProperties(Ee.prototype, ge), le && _defineProperties(Ee, le), Object.defineProperty(Ee, "prototype", {
    writable: !1
  }), Ee;
}
function _defineProperty(Ee, ge, le) {
  return ge = _toPropertyKey(ge), ge in Ee ? Object.defineProperty(Ee, ge, {
    value: le,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : Ee[ge] = le, Ee;
}
var propTypesExports = {}, propTypes = {
  get exports() {
    return propTypesExports;
  },
  set exports(Ee) {
    propTypesExports = Ee;
  }
}, reactIsExports = {}, reactIs = {
  get exports() {
    return reactIsExports;
  },
  set exports(Ee) {
    reactIsExports = Ee;
  }
}, reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
  if (hasRequiredReactIs_production_min)
    return reactIs_production_min;
  hasRequiredReactIs_production_min = 1;
  var Ee = typeof Symbol == "function" && Symbol.for, ge = Ee ? Symbol.for("react.element") : 60103, le = Ee ? Symbol.for("react.portal") : 60106, de = Ee ? Symbol.for("react.fragment") : 60107, oe = Ee ? Symbol.for("react.strict_mode") : 60108, se = Ee ? Symbol.for("react.profiler") : 60114, Q = Ee ? Symbol.for("react.provider") : 60109, u = Ee ? Symbol.for("react.context") : 60110, P = Ee ? Symbol.for("react.async_mode") : 60111, t = Ee ? Symbol.for("react.concurrent_mode") : 60111, i = Ee ? Symbol.for("react.forward_ref") : 60112, v = Ee ? Symbol.for("react.suspense") : 60113, a = Ee ? Symbol.for("react.suspense_list") : 60120, e = Ee ? Symbol.for("react.memo") : 60115, y = Ee ? Symbol.for("react.lazy") : 60116, r = Ee ? Symbol.for("react.block") : 60121, h = Ee ? Symbol.for("react.fundamental") : 60117, g = Ee ? Symbol.for("react.responder") : 60118, d = Ee ? Symbol.for("react.scope") : 60119;
  function c(o) {
    if (typeof o == "object" && o !== null) {
      var x = o.$$typeof;
      switch (x) {
        case ge:
          switch (o = o.type, o) {
            case P:
            case t:
            case de:
            case se:
            case oe:
            case v:
              return o;
            default:
              switch (o = o && o.$$typeof, o) {
                case u:
                case i:
                case y:
                case e:
                case Q:
                  return o;
                default:
                  return x;
              }
          }
        case le:
          return x;
      }
    }
  }
  function n(o) {
    return c(o) === t;
  }
  return reactIs_production_min.AsyncMode = P, reactIs_production_min.ConcurrentMode = t, reactIs_production_min.ContextConsumer = u, reactIs_production_min.ContextProvider = Q, reactIs_production_min.Element = ge, reactIs_production_min.ForwardRef = i, reactIs_production_min.Fragment = de, reactIs_production_min.Lazy = y, reactIs_production_min.Memo = e, reactIs_production_min.Portal = le, reactIs_production_min.Profiler = se, reactIs_production_min.StrictMode = oe, reactIs_production_min.Suspense = v, reactIs_production_min.isAsyncMode = function(o) {
    return n(o) || c(o) === P;
  }, reactIs_production_min.isConcurrentMode = n, reactIs_production_min.isContextConsumer = function(o) {
    return c(o) === u;
  }, reactIs_production_min.isContextProvider = function(o) {
    return c(o) === Q;
  }, reactIs_production_min.isElement = function(o) {
    return typeof o == "object" && o !== null && o.$$typeof === ge;
  }, reactIs_production_min.isForwardRef = function(o) {
    return c(o) === i;
  }, reactIs_production_min.isFragment = function(o) {
    return c(o) === de;
  }, reactIs_production_min.isLazy = function(o) {
    return c(o) === y;
  }, reactIs_production_min.isMemo = function(o) {
    return c(o) === e;
  }, reactIs_production_min.isPortal = function(o) {
    return c(o) === le;
  }, reactIs_production_min.isProfiler = function(o) {
    return c(o) === se;
  }, reactIs_production_min.isStrictMode = function(o) {
    return c(o) === oe;
  }, reactIs_production_min.isSuspense = function(o) {
    return c(o) === v;
  }, reactIs_production_min.isValidElementType = function(o) {
    return typeof o == "string" || typeof o == "function" || o === de || o === t || o === se || o === oe || o === v || o === a || typeof o == "object" && o !== null && (o.$$typeof === y || o.$$typeof === e || o.$$typeof === Q || o.$$typeof === u || o.$$typeof === i || o.$$typeof === h || o.$$typeof === g || o.$$typeof === d || o.$$typeof === r);
  }, reactIs_production_min.typeOf = c, reactIs_production_min;
}
var reactIs_development = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_development;
function requireReactIs_development() {
  return hasRequiredReactIs_development || (hasRequiredReactIs_development = 1, process.env.NODE_ENV !== "production" && function() {
    var Ee = typeof Symbol == "function" && Symbol.for, ge = Ee ? Symbol.for("react.element") : 60103, le = Ee ? Symbol.for("react.portal") : 60106, de = Ee ? Symbol.for("react.fragment") : 60107, oe = Ee ? Symbol.for("react.strict_mode") : 60108, se = Ee ? Symbol.for("react.profiler") : 60114, Q = Ee ? Symbol.for("react.provider") : 60109, u = Ee ? Symbol.for("react.context") : 60110, P = Ee ? Symbol.for("react.async_mode") : 60111, t = Ee ? Symbol.for("react.concurrent_mode") : 60111, i = Ee ? Symbol.for("react.forward_ref") : 60112, v = Ee ? Symbol.for("react.suspense") : 60113, a = Ee ? Symbol.for("react.suspense_list") : 60120, e = Ee ? Symbol.for("react.memo") : 60115, y = Ee ? Symbol.for("react.lazy") : 60116, r = Ee ? Symbol.for("react.block") : 60121, h = Ee ? Symbol.for("react.fundamental") : 60117, g = Ee ? Symbol.for("react.responder") : 60118, d = Ee ? Symbol.for("react.scope") : 60119;
    function c(L) {
      return typeof L == "string" || typeof L == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      L === de || L === t || L === se || L === oe || L === v || L === a || typeof L == "object" && L !== null && (L.$$typeof === y || L.$$typeof === e || L.$$typeof === Q || L.$$typeof === u || L.$$typeof === i || L.$$typeof === h || L.$$typeof === g || L.$$typeof === d || L.$$typeof === r);
    }
    function n(L) {
      if (typeof L == "object" && L !== null) {
        var Y = L.$$typeof;
        switch (Y) {
          case ge:
            var J = L.type;
            switch (J) {
              case P:
              case t:
              case de:
              case se:
              case oe:
              case v:
                return J;
              default:
                var ie = J && J.$$typeof;
                switch (ie) {
                  case u:
                  case i:
                  case y:
                  case e:
                  case Q:
                    return ie;
                  default:
                    return Y;
                }
            }
          case le:
            return Y;
        }
      }
    }
    var o = P, x = t, f = u, m = Q, C = ge, p = i, w = de, X = y, M = e, j = le, B = se, R = oe, D = v, b = !1;
    function l(L) {
      return b || (b = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), _(L) || n(L) === P;
    }
    function _(L) {
      return n(L) === t;
    }
    function S(L) {
      return n(L) === u;
    }
    function A(L) {
      return n(L) === Q;
    }
    function F(L) {
      return typeof L == "object" && L !== null && L.$$typeof === ge;
    }
    function T(L) {
      return n(L) === i;
    }
    function O(L) {
      return n(L) === de;
    }
    function U(L) {
      return n(L) === y;
    }
    function G(L) {
      return n(L) === e;
    }
    function K(L) {
      return n(L) === le;
    }
    function W(L) {
      return n(L) === se;
    }
    function z(L) {
      return n(L) === oe;
    }
    function V(L) {
      return n(L) === v;
    }
    reactIs_development.AsyncMode = o, reactIs_development.ConcurrentMode = x, reactIs_development.ContextConsumer = f, reactIs_development.ContextProvider = m, reactIs_development.Element = C, reactIs_development.ForwardRef = p, reactIs_development.Fragment = w, reactIs_development.Lazy = X, reactIs_development.Memo = M, reactIs_development.Portal = j, reactIs_development.Profiler = B, reactIs_development.StrictMode = R, reactIs_development.Suspense = D, reactIs_development.isAsyncMode = l, reactIs_development.isConcurrentMode = _, reactIs_development.isContextConsumer = S, reactIs_development.isContextProvider = A, reactIs_development.isElement = F, reactIs_development.isForwardRef = T, reactIs_development.isFragment = O, reactIs_development.isLazy = U, reactIs_development.isMemo = G, reactIs_development.isPortal = K, reactIs_development.isProfiler = W, reactIs_development.isStrictMode = z, reactIs_development.isSuspense = V, reactIs_development.isValidElementType = c, reactIs_development.typeOf = n;
  }()), reactIs_development;
}
var hasRequiredReactIs;
function requireReactIs() {
  return hasRequiredReactIs || (hasRequiredReactIs = 1, function(Ee) {
    process.env.NODE_ENV === "production" ? Ee.exports = requireReactIs_production_min() : Ee.exports = requireReactIs_development();
  }(reactIs)), reactIsExports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var objectAssign, hasRequiredObjectAssign;
function requireObjectAssign() {
  if (hasRequiredObjectAssign)
    return objectAssign;
  hasRequiredObjectAssign = 1;
  var Ee = Object.getOwnPropertySymbols, ge = Object.prototype.hasOwnProperty, le = Object.prototype.propertyIsEnumerable;
  function de(se) {
    if (se == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(se);
  }
  function oe() {
    try {
      if (!Object.assign)
        return !1;
      var se = new String("abc");
      if (se[5] = "de", Object.getOwnPropertyNames(se)[0] === "5")
        return !1;
      for (var Q = {}, u = 0; u < 10; u++)
        Q["_" + String.fromCharCode(u)] = u;
      var P = Object.getOwnPropertyNames(Q).map(function(i) {
        return Q[i];
      });
      if (P.join("") !== "0123456789")
        return !1;
      var t = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(i) {
        t[i] = i;
      }), Object.keys(Object.assign({}, t)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return objectAssign = oe() ? Object.assign : function(se, Q) {
    for (var u, P = de(se), t, i = 1; i < arguments.length; i++) {
      u = Object(arguments[i]);
      for (var v in u)
        ge.call(u, v) && (P[v] = u[v]);
      if (Ee) {
        t = Ee(u);
        for (var a = 0; a < t.length; a++)
          le.call(u, t[a]) && (P[t[a]] = u[t[a]]);
      }
    }
    return P;
  }, objectAssign;
}
var ReactPropTypesSecret_1, hasRequiredReactPropTypesSecret;
function requireReactPropTypesSecret() {
  if (hasRequiredReactPropTypesSecret)
    return ReactPropTypesSecret_1;
  hasRequiredReactPropTypesSecret = 1;
  var Ee = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return ReactPropTypesSecret_1 = Ee, ReactPropTypesSecret_1;
}
var has, hasRequiredHas;
function requireHas() {
  return hasRequiredHas || (hasRequiredHas = 1, has = Function.call.bind(Object.prototype.hasOwnProperty)), has;
}
var checkPropTypes_1, hasRequiredCheckPropTypes;
function requireCheckPropTypes() {
  if (hasRequiredCheckPropTypes)
    return checkPropTypes_1;
  hasRequiredCheckPropTypes = 1;
  var Ee = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var ge = requireReactPropTypesSecret(), le = {}, de = requireHas();
    Ee = function(se) {
      var Q = "Warning: " + se;
      typeof console < "u" && console.error(Q);
      try {
        throw new Error(Q);
      } catch {
      }
    };
  }
  function oe(se, Q, u, P, t) {
    if (process.env.NODE_ENV !== "production") {
      for (var i in se)
        if (de(se, i)) {
          var v;
          try {
            if (typeof se[i] != "function") {
              var a = Error(
                (P || "React class") + ": " + u + " type `" + i + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof se[i] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw a.name = "Invariant Violation", a;
            }
            v = se[i](Q, i, P, u, null, ge);
          } catch (y) {
            v = y;
          }
          if (v && !(v instanceof Error) && Ee(
            (P || "React class") + ": type specification of " + u + " `" + i + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof v + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), v instanceof Error && !(v.message in le)) {
            le[v.message] = !0;
            var e = t ? t() : "";
            Ee(
              "Failed " + u + " type: " + v.message + (e ?? "")
            );
          }
        }
    }
  }
  return oe.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (le = {});
  }, checkPropTypes_1 = oe, checkPropTypes_1;
}
var factoryWithTypeCheckers, hasRequiredFactoryWithTypeCheckers;
function requireFactoryWithTypeCheckers() {
  if (hasRequiredFactoryWithTypeCheckers)
    return factoryWithTypeCheckers;
  hasRequiredFactoryWithTypeCheckers = 1;
  var Ee = requireReactIs(), ge = requireObjectAssign(), le = requireReactPropTypesSecret(), de = requireHas(), oe = requireCheckPropTypes(), se = function() {
  };
  process.env.NODE_ENV !== "production" && (se = function(u) {
    var P = "Warning: " + u;
    typeof console < "u" && console.error(P);
    try {
      throw new Error(P);
    } catch {
    }
  });
  function Q() {
    return null;
  }
  return factoryWithTypeCheckers = function(u, P) {
    var t = typeof Symbol == "function" && Symbol.iterator, i = "@@iterator";
    function v(_) {
      var S = _ && (t && _[t] || _[i]);
      if (typeof S == "function")
        return S;
    }
    var a = "<<anonymous>>", e = {
      array: g("array"),
      bigint: g("bigint"),
      bool: g("boolean"),
      func: g("function"),
      number: g("number"),
      object: g("object"),
      string: g("string"),
      symbol: g("symbol"),
      any: d(),
      arrayOf: c,
      element: n(),
      elementType: o(),
      instanceOf: x,
      node: p(),
      objectOf: m,
      oneOf: f,
      oneOfType: C,
      shape: X,
      exact: M
    };
    function y(_, S) {
      return _ === S ? _ !== 0 || 1 / _ === 1 / S : _ !== _ && S !== S;
    }
    function r(_, S) {
      this.message = _, this.data = S && typeof S == "object" ? S : {}, this.stack = "";
    }
    r.prototype = Error.prototype;
    function h(_) {
      if (process.env.NODE_ENV !== "production")
        var S = {}, A = 0;
      function F(O, U, G, K, W, z, V) {
        if (K = K || a, z = z || G, V !== le) {
          if (P) {
            var L = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw L.name = "Invariant Violation", L;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var Y = K + ":" + G;
            !S[Y] && // Avoid spamming the console because they are often not actionable except for lib authors
            A < 3 && (se(
              "You are manually calling a React.PropTypes validation function for the `" + z + "` prop on `" + K + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), S[Y] = !0, A++);
          }
        }
        return U[G] == null ? O ? U[G] === null ? new r("The " + W + " `" + z + "` is marked as required " + ("in `" + K + "`, but its value is `null`.")) : new r("The " + W + " `" + z + "` is marked as required in " + ("`" + K + "`, but its value is `undefined`.")) : null : _(U, G, K, W, z);
      }
      var T = F.bind(null, !1);
      return T.isRequired = F.bind(null, !0), T;
    }
    function g(_) {
      function S(A, F, T, O, U, G) {
        var K = A[F], W = R(K);
        if (W !== _) {
          var z = D(K);
          return new r(
            "Invalid " + O + " `" + U + "` of type " + ("`" + z + "` supplied to `" + T + "`, expected ") + ("`" + _ + "`."),
            { expectedType: _ }
          );
        }
        return null;
      }
      return h(S);
    }
    function d() {
      return h(Q);
    }
    function c(_) {
      function S(A, F, T, O, U) {
        if (typeof _ != "function")
          return new r("Property `" + U + "` of component `" + T + "` has invalid PropType notation inside arrayOf.");
        var G = A[F];
        if (!Array.isArray(G)) {
          var K = R(G);
          return new r("Invalid " + O + " `" + U + "` of type " + ("`" + K + "` supplied to `" + T + "`, expected an array."));
        }
        for (var W = 0; W < G.length; W++) {
          var z = _(G, W, T, O, U + "[" + W + "]", le);
          if (z instanceof Error)
            return z;
        }
        return null;
      }
      return h(S);
    }
    function n() {
      function _(S, A, F, T, O) {
        var U = S[A];
        if (!u(U)) {
          var G = R(U);
          return new r("Invalid " + T + " `" + O + "` of type " + ("`" + G + "` supplied to `" + F + "`, expected a single ReactElement."));
        }
        return null;
      }
      return h(_);
    }
    function o() {
      function _(S, A, F, T, O) {
        var U = S[A];
        if (!Ee.isValidElementType(U)) {
          var G = R(U);
          return new r("Invalid " + T + " `" + O + "` of type " + ("`" + G + "` supplied to `" + F + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return h(_);
    }
    function x(_) {
      function S(A, F, T, O, U) {
        if (!(A[F] instanceof _)) {
          var G = _.name || a, K = l(A[F]);
          return new r("Invalid " + O + " `" + U + "` of type " + ("`" + K + "` supplied to `" + T + "`, expected ") + ("instance of `" + G + "`."));
        }
        return null;
      }
      return h(S);
    }
    function f(_) {
      if (!Array.isArray(_))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? se(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : se("Invalid argument supplied to oneOf, expected an array.")), Q;
      function S(A, F, T, O, U) {
        for (var G = A[F], K = 0; K < _.length; K++)
          if (y(G, _[K]))
            return null;
        var W = JSON.stringify(_, function(V, L) {
          var Y = D(L);
          return Y === "symbol" ? String(L) : L;
        });
        return new r("Invalid " + O + " `" + U + "` of value `" + String(G) + "` " + ("supplied to `" + T + "`, expected one of " + W + "."));
      }
      return h(S);
    }
    function m(_) {
      function S(A, F, T, O, U) {
        if (typeof _ != "function")
          return new r("Property `" + U + "` of component `" + T + "` has invalid PropType notation inside objectOf.");
        var G = A[F], K = R(G);
        if (K !== "object")
          return new r("Invalid " + O + " `" + U + "` of type " + ("`" + K + "` supplied to `" + T + "`, expected an object."));
        for (var W in G)
          if (de(G, W)) {
            var z = _(G, W, T, O, U + "." + W, le);
            if (z instanceof Error)
              return z;
          }
        return null;
      }
      return h(S);
    }
    function C(_) {
      if (!Array.isArray(_))
        return process.env.NODE_ENV !== "production" && se("Invalid argument supplied to oneOfType, expected an instance of array."), Q;
      for (var S = 0; S < _.length; S++) {
        var A = _[S];
        if (typeof A != "function")
          return se(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + b(A) + " at index " + S + "."
          ), Q;
      }
      function F(T, O, U, G, K) {
        for (var W = [], z = 0; z < _.length; z++) {
          var V = _[z], L = V(T, O, U, G, K, le);
          if (L == null)
            return null;
          L.data && de(L.data, "expectedType") && W.push(L.data.expectedType);
        }
        var Y = W.length > 0 ? ", expected one of type [" + W.join(", ") + "]" : "";
        return new r("Invalid " + G + " `" + K + "` supplied to " + ("`" + U + "`" + Y + "."));
      }
      return h(F);
    }
    function p() {
      function _(S, A, F, T, O) {
        return j(S[A]) ? null : new r("Invalid " + T + " `" + O + "` supplied to " + ("`" + F + "`, expected a ReactNode."));
      }
      return h(_);
    }
    function w(_, S, A, F, T) {
      return new r(
        (_ || "React class") + ": " + S + " type `" + A + "." + F + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + T + "`."
      );
    }
    function X(_) {
      function S(A, F, T, O, U) {
        var G = A[F], K = R(G);
        if (K !== "object")
          return new r("Invalid " + O + " `" + U + "` of type `" + K + "` " + ("supplied to `" + T + "`, expected `object`."));
        for (var W in _) {
          var z = _[W];
          if (typeof z != "function")
            return w(T, O, U, W, D(z));
          var V = z(G, W, T, O, U + "." + W, le);
          if (V)
            return V;
        }
        return null;
      }
      return h(S);
    }
    function M(_) {
      function S(A, F, T, O, U) {
        var G = A[F], K = R(G);
        if (K !== "object")
          return new r("Invalid " + O + " `" + U + "` of type `" + K + "` " + ("supplied to `" + T + "`, expected `object`."));
        var W = ge({}, A[F], _);
        for (var z in W) {
          var V = _[z];
          if (de(_, z) && typeof V != "function")
            return w(T, O, U, z, D(V));
          if (!V)
            return new r(
              "Invalid " + O + " `" + U + "` key `" + z + "` supplied to `" + T + "`.\nBad object: " + JSON.stringify(A[F], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(_), null, "  ")
            );
          var L = V(G, z, T, O, U + "." + z, le);
          if (L)
            return L;
        }
        return null;
      }
      return h(S);
    }
    function j(_) {
      switch (typeof _) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !_;
        case "object":
          if (Array.isArray(_))
            return _.every(j);
          if (_ === null || u(_))
            return !0;
          var S = v(_);
          if (S) {
            var A = S.call(_), F;
            if (S !== _.entries) {
              for (; !(F = A.next()).done; )
                if (!j(F.value))
                  return !1;
            } else
              for (; !(F = A.next()).done; ) {
                var T = F.value;
                if (T && !j(T[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function B(_, S) {
      return _ === "symbol" ? !0 : S ? S["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && S instanceof Symbol : !1;
    }
    function R(_) {
      var S = typeof _;
      return Array.isArray(_) ? "array" : _ instanceof RegExp ? "object" : B(S, _) ? "symbol" : S;
    }
    function D(_) {
      if (typeof _ > "u" || _ === null)
        return "" + _;
      var S = R(_);
      if (S === "object") {
        if (_ instanceof Date)
          return "date";
        if (_ instanceof RegExp)
          return "regexp";
      }
      return S;
    }
    function b(_) {
      var S = D(_);
      switch (S) {
        case "array":
        case "object":
          return "an " + S;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + S;
        default:
          return S;
      }
    }
    function l(_) {
      return !_.constructor || !_.constructor.name ? a : _.constructor.name;
    }
    return e.checkPropTypes = oe, e.resetWarningCache = oe.resetWarningCache, e.PropTypes = e, e;
  }, factoryWithTypeCheckers;
}
var factoryWithThrowingShims, hasRequiredFactoryWithThrowingShims;
function requireFactoryWithThrowingShims() {
  if (hasRequiredFactoryWithThrowingShims)
    return factoryWithThrowingShims;
  hasRequiredFactoryWithThrowingShims = 1;
  var Ee = requireReactPropTypesSecret();
  function ge() {
  }
  function le() {
  }
  return le.resetWarningCache = ge, factoryWithThrowingShims = function() {
    function de(Q, u, P, t, i, v) {
      if (v !== Ee) {
        var a = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw a.name = "Invariant Violation", a;
      }
    }
    de.isRequired = de;
    function oe() {
      return de;
    }
    var se = {
      array: de,
      bigint: de,
      bool: de,
      func: de,
      number: de,
      object: de,
      string: de,
      symbol: de,
      any: de,
      arrayOf: oe,
      element: de,
      elementType: de,
      instanceOf: oe,
      node: de,
      objectOf: oe,
      oneOf: oe,
      oneOfType: oe,
      shape: oe,
      exact: oe,
      checkPropTypes: le,
      resetWarningCache: ge
    };
    return se.PropTypes = se, se;
  }, factoryWithThrowingShims;
}
if (process.env.NODE_ENV !== "production") {
  var ReactIs = requireReactIs(), throwOnDirectAccess = !0;
  propTypes.exports = requireFactoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
} else
  propTypes.exports = requireFactoryWithThrowingShims()();
var __spreadArray = globalThis && globalThis.__spreadArray || function(Ee, ge, le) {
  if (le || arguments.length === 2)
    for (var de = 0, oe = ge.length, se; de < oe; de++)
      (se || !(de in ge)) && (se || (se = Array.prototype.slice.call(ge, 0, de)), se[de] = ge[de]);
  return Ee.concat(se || Array.prototype.slice.call(ge));
}, clipboardEvents = ["onCopy", "onCut", "onPaste"], compositionEvents = [
  "onCompositionEnd",
  "onCompositionStart",
  "onCompositionUpdate"
], keyboardEvents = ["onKeyDown", "onKeyPress", "onKeyUp"], focusEvents = ["onFocus", "onBlur"], formEvents = ["onChange", "onInput", "onInvalid", "onReset", "onSubmit"], genericEvents = ["onError", "onLoad"], mouseEvents = [
  "onClick",
  "onContextMenu",
  "onDoubleClick",
  "onDrag",
  "onDragEnd",
  "onDragEnter",
  "onDragExit",
  "onDragLeave",
  "onDragOver",
  "onDragStart",
  "onDrop",
  "onMouseDown",
  "onMouseEnter",
  "onMouseLeave",
  "onMouseMove",
  "onMouseOut",
  "onMouseOver",
  "onMouseUp"
], pointerEvents = [
  "onPointerDown",
  "onPointerMove",
  "onPointerUp",
  "onPointerCancel",
  "onGotPointerCapture",
  "onLostPointerCapture",
  "onPointerEnter",
  "onPointerLeave",
  "onPointerOver",
  "onPointerOut"
], selectionEvents = ["onSelect"], touchEvents = ["onTouchCancel", "onTouchEnd", "onTouchMove", "onTouchStart"], uiEvents = ["onScroll"], wheelEvents = ["onWheel"], mediaEvents = [
  "onAbort",
  "onCanPlay",
  "onCanPlayThrough",
  "onDurationChange",
  "onEmptied",
  "onEncrypted",
  "onEnded",
  "onError",
  "onLoadedData",
  "onLoadedMetadata",
  "onLoadStart",
  "onPause",
  "onPlay",
  "onPlaying",
  "onProgress",
  "onRateChange",
  "onSeeked",
  "onSeeking",
  "onStalled",
  "onSuspend",
  "onTimeUpdate",
  "onVolumeChange",
  "onWaiting"
], imageEvents = ["onLoad", "onError"], animationEvents = [
  "onAnimationStart",
  "onAnimationEnd",
  "onAnimationIteration"
], transitionEvents = ["onTransitionEnd"], otherEvents = ["onToggle"];
__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], clipboardEvents, !0), compositionEvents, !0), keyboardEvents, !0), focusEvents, !0), formEvents, !0), genericEvents, !0), mouseEvents, !0), pointerEvents, !0), selectionEvents, !0), touchEvents, !0), uiEvents, !0), wheelEvents, !0), mediaEvents, !0), imageEvents, !0), animationEvents, !0), transitionEvents, !0), otherEvents, !0);
var isProduction$1 = process.env.NODE_ENV === "production", prefix = "Invariant failed";
function invariant(Ee, ge) {
  if (!Ee) {
    if (isProduction$1)
      throw new Error(prefix);
    var le = typeof ge == "function" ? ge() : ge, de = le ? "".concat(prefix, ": ").concat(le) : prefix;
    throw new Error(de);
  }
}
var isProduction = process.env.NODE_ENV === "production";
function warning(Ee, ge) {
  if (!isProduction) {
    if (Ee)
      return;
    var le = "Warning: " + ge;
    typeof console < "u" && console.warn(le);
    try {
      throw Error(le);
    } catch {
    }
  }
}
propTypesExports.node, propTypesExports.oneOf(["error", "loading", "no-data"]).isRequired;
var DEFAULT_LINK_REL = "noopener noreferrer nofollow", LinkService = /* @__PURE__ */ function() {
  function Ee() {
    _classCallCheck(this, Ee), this.externalLinkTarget = null, this.externalLinkRel = null;
  }
  return _createClass(Ee, [{
    key: "setDocument",
    value: function(le) {
      this.pdfDocument = le;
    }
  }, {
    key: "setViewer",
    value: function(le) {
      this.pdfViewer = le;
    }
  }, {
    key: "setExternalLinkRel",
    value: function(le) {
      this.externalLinkRel = le;
    }
  }, {
    key: "setExternalLinkTarget",
    value: function(le) {
      this.externalLinkTarget = le;
    }
  }, {
    key: "setHistory",
    value: function() {
    }
  }, {
    key: "pagesCount",
    get: function() {
      return this.pdfDocument ? this.pdfDocument.numPages : 0;
    }
  }, {
    key: "page",
    get: function() {
      return this.pdfViewer.currentPageNumber;
    },
    set: function(le) {
      this.pdfViewer.currentPageNumber = le;
    }
  }, {
    key: "rotation",
    get: function() {
      return 0;
    },
    set: function(le) {
    }
  }, {
    key: "goToDestination",
    value: function(le) {
      var de = this;
      new Promise(function(oe) {
        typeof le == "string" ? de.pdfDocument.getDestination(le).then(oe) : Array.isArray(le) ? oe(le) : le.then(oe);
      }).then(function(oe) {
        invariant(Array.isArray(oe), '"'.concat(oe, '" is not a valid destination array.'));
        var se = oe[0];
        new Promise(function(Q) {
          se instanceof Object ? de.pdfDocument.getPageIndex(se).then(function(u) {
            Q(u);
          }).catch(function() {
            invariant(!1, '"'.concat(se, '" is not a valid page reference.'));
          }) : typeof se == "number" ? Q(se) : invariant(!1, '"'.concat(se, '" is not a valid destination reference.'));
        }).then(function(Q) {
          var u = Q + 1;
          invariant(u >= 1 && u <= de.pagesCount, '"'.concat(u, '" is not a valid page number.')), de.pdfViewer.scrollPageIntoView({
            dest: le,
            pageIndex: Q,
            pageNumber: u
          });
        });
      });
    }
  }, {
    key: "navigateTo",
    value: function(le) {
      this.goToDestination(le);
    }
  }, {
    key: "goToPage",
    value: function() {
    }
  }, {
    key: "addLinkAttributes",
    value: function(le, de, oe) {
      le.href = de, le.rel = this.externalLinkRel || DEFAULT_LINK_REL, le.target = oe ? "_blank" : this.externalLinkTarget || "";
    }
  }, {
    key: "getDestinationHash",
    value: function() {
      return "#";
    }
  }, {
    key: "getAnchorUrl",
    value: function() {
      return "#";
    }
  }, {
    key: "setHash",
    value: function() {
    }
  }, {
    key: "executeNamedAction",
    value: function() {
    }
  }, {
    key: "cachePageRef",
    value: function() {
    }
  }, {
    key: "isPageVisible",
    value: function() {
      return !0;
    }
  }, {
    key: "isPageCached",
    value: function() {
      return !0;
    }
  }]), Ee;
}();
function _arrayLikeToArray(Ee, ge) {
  (ge == null || ge > Ee.length) && (ge = Ee.length);
  for (var le = 0, de = new Array(ge); le < ge; le++)
    de[le] = Ee[le];
  return de;
}
function _unsupportedIterableToArray(Ee, ge) {
  if (Ee) {
    if (typeof Ee == "string")
      return _arrayLikeToArray(Ee, ge);
    var le = Object.prototype.toString.call(Ee).slice(8, -1);
    if (le === "Object" && Ee.constructor && (le = Ee.constructor.name), le === "Map" || le === "Set")
      return Array.from(Ee);
    if (le === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(le))
      return _arrayLikeToArray(Ee, ge);
  }
}
var isBrowser = typeof document < "u", isLocalFileSystem = isBrowser && window.location.protocol === "file:";
function isDefined(Ee) {
  return typeof Ee < "u";
}
var allowFileAccessFromFilesTip = "On Chromium based browsers, you can use --allow-file-access-from-files flag for debugging purposes.";
function displayWorkerWarning() {
  warning(!isLocalFileSystem, "Loading PDF.js worker may not work on protocols other than HTTP/HTTPS. ".concat(allowFileAccessFromFilesTip));
}
function _arrayWithoutHoles(Ee) {
  if (Array.isArray(Ee))
    return _arrayLikeToArray(Ee);
}
function _iterableToArray(Ee) {
  if (typeof Symbol < "u" && Ee[Symbol.iterator] != null || Ee["@@iterator"] != null)
    return Array.from(Ee);
}
function _nonIterableSpread() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _toConsumableArray(Ee) {
  return _arrayWithoutHoles(Ee) || _iterableToArray(Ee) || _unsupportedIterableToArray(Ee) || _nonIterableSpread();
}
var eventProps = function() {
  var Ee = {};
  return [].concat(_toConsumableArray(mouseEvents), _toConsumableArray(touchEvents), _toConsumableArray(keyboardEvents)).forEach(function(ge) {
    Ee[ge] = propTypesExports.func;
  }), Ee;
}(), fileTypes = [propTypesExports.string, propTypesExports.instanceOf(ArrayBuffer), propTypesExports.shape({
  data: propTypesExports.oneOfType([propTypesExports.object, propTypesExports.string]),
  httpHeaders: propTypesExports.object,
  range: propTypesExports.object,
  url: propTypesExports.string,
  withCredentials: propTypesExports.bool
})];
typeof File < "u" && fileTypes.push(propTypesExports.instanceOf(File));
typeof Blob < "u" && fileTypes.push(propTypesExports.instanceOf(Blob));
var isClassName = propTypesExports.oneOfType([propTypesExports.string, propTypesExports.arrayOf(propTypesExports.string)]), isFile = propTypesExports.oneOfType(fileTypes), isLinkService = propTypesExports.instanceOf(LinkService);
propTypesExports.oneOf(["_self", "_blank", "_parent", "_top"]);
var isPage = propTypesExports.shape({
  commonObjs: propTypesExports.shape({}).isRequired,
  getAnnotations: propTypesExports.func.isRequired,
  getTextContent: propTypesExports.func.isRequired,
  getViewport: propTypesExports.func.isRequired,
  render: propTypesExports.func.isRequired
}), isPageIndex = function Ee(ge, le, de) {
  var oe = ge[le], se = ge.pageNumber, Q = ge.pdf;
  if (!isDefined(Q))
    return null;
  if (isDefined(oe)) {
    if (typeof oe != "number")
      return new Error("`".concat(le, "` of type `").concat(_typeof(oe), "` supplied to `").concat(de, "`, expected `number`."));
    if (oe < 0)
      return new Error("Expected `".concat(le, "` to be greater or equal to 0."));
    var u = Q.numPages;
    if (oe + 1 > u)
      return new Error("Expected `".concat(le, "` to be less or equal to ").concat(u - 1, "."));
  } else if (!isDefined(se))
    return new Error("`".concat(le, "` not supplied. Either pageIndex or pageNumber must be supplied to `").concat(de, "`."));
  return null;
}, isPageNumber = function Ee(ge, le, de) {
  var oe = ge[le], se = ge.pageIndex, Q = ge.pdf;
  if (!isDefined(Q))
    return null;
  if (isDefined(oe)) {
    if (typeof oe != "number")
      return new Error("`".concat(le, "` of type `").concat(_typeof(oe), "` supplied to `").concat(de, "`, expected `number`."));
    if (oe < 1)
      return new Error("Expected `".concat(le, "` to be greater or equal to 1."));
    var u = Q.numPages;
    if (oe > u)
      return new Error("Expected `".concat(le, "` to be less or equal to ").concat(u, "."));
  } else if (!isDefined(se))
    return new Error("`".concat(le, "` not supplied. Either pageIndex or pageNumber must be supplied to `").concat(de, "`."));
  return null;
}, isPdf = propTypesExports.oneOfType([propTypesExports.shape({
  getDestination: propTypesExports.func.isRequired,
  getOutline: propTypesExports.func.isRequired,
  getPage: propTypesExports.func.isRequired,
  numPages: propTypesExports.number.isRequired
}), propTypesExports.bool]), isRef = propTypesExports.oneOfType([propTypesExports.func, propTypesExports.shape({
  current: propTypesExports.any
})]), isRenderMode = propTypesExports.oneOf(["canvas", "none", "svg"]), isRotate = propTypesExports.oneOf([0, 90, 180, 270]);
function ownKeys$2(Ee, ge) {
  var le = Object.keys(Ee);
  if (Object.getOwnPropertySymbols) {
    var de = Object.getOwnPropertySymbols(Ee);
    ge && (de = de.filter(function(oe) {
      return Object.getOwnPropertyDescriptor(Ee, oe).enumerable;
    })), le.push.apply(le, de);
  }
  return le;
}
function _objectSpread$2(Ee) {
  for (var ge = 1; ge < arguments.length; ge++) {
    var le = arguments[ge] != null ? arguments[ge] : {};
    ge % 2 ? ownKeys$2(Object(le), !0).forEach(function(de) {
      _defineProperty(Ee, de, le[de]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(Ee, Object.getOwnPropertyDescriptors(le)) : ownKeys$2(Object(le)).forEach(function(de) {
      Object.defineProperty(Ee, de, Object.getOwnPropertyDescriptor(le, de));
    });
  }
  return Ee;
}
var isFunctionOrNode$1 = propTypesExports.oneOfType([propTypesExports.func, propTypesExports.node]);
_objectSpread$2(_objectSpread$2({}, eventProps), {}, {
  children: propTypesExports.node,
  className: isClassName,
  error: isFunctionOrNode$1,
  externalLinkRel: propTypesExports.string,
  externalLinkTarget: propTypesExports.string,
  file: isFile,
  imageResourcesPath: propTypesExports.string,
  inputRef: isRef,
  loading: isFunctionOrNode$1,
  noData: isFunctionOrNode$1,
  onItemClick: propTypesExports.func,
  onLoadError: propTypesExports.func,
  onLoadProgress: propTypesExports.func,
  onLoadSuccess: propTypesExports.func,
  onPassword: propTypesExports.func,
  onSourceError: propTypesExports.func,
  onSourceSuccess: propTypesExports.func,
  rotate: propTypesExports.number
});
var isDestination = propTypesExports.oneOfType([propTypesExports.string, propTypesExports.arrayOf(propTypesExports.any)]);
propTypesExports.shape({
  dest: isDestination,
  items: propTypesExports.arrayOf(propTypesExports.shape({
    dest: isDestination,
    title: propTypesExports.string
  })),
  title: propTypesExports.string
}).isRequired, propTypesExports.func, isPdf.isRequired;
function ownKeys$1(Ee, ge) {
  var le = Object.keys(Ee);
  if (Object.getOwnPropertySymbols) {
    var de = Object.getOwnPropertySymbols(Ee);
    ge && (de = de.filter(function(oe) {
      return Object.getOwnPropertyDescriptor(Ee, oe).enumerable;
    })), le.push.apply(le, de);
  }
  return le;
}
function _objectSpread$1(Ee) {
  for (var ge = 1; ge < arguments.length; ge++) {
    var le = arguments[ge] != null ? arguments[ge] : {};
    ge % 2 ? ownKeys$1(Object(le), !0).forEach(function(de) {
      _defineProperty(Ee, de, le[de]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(Ee, Object.getOwnPropertyDescriptors(le)) : ownKeys$1(Object(le)).forEach(function(de) {
      Object.defineProperty(Ee, de, Object.getOwnPropertyDescriptor(le, de));
    });
  }
  return Ee;
}
_objectSpread$1({
  className: isClassName,
  inputRef: isRef,
  onItemClick: propTypesExports.func,
  onLoadError: propTypesExports.func,
  onLoadSuccess: propTypesExports.func,
  pdf: isPdf
}, eventProps);
propTypesExports.string, propTypesExports.number, propTypesExports.func, propTypesExports.func, isPage.isRequired, propTypesExports.bool, propTypesExports.number.isRequired;
propTypesExports.func, propTypesExports.func, isPage.isRequired, propTypesExports.number.isRequired;
propTypesExports.func, propTypesExports.func, propTypesExports.func, propTypesExports.func, propTypesExports.func, isPage.isRequired, propTypesExports.number.isRequired, propTypesExports.number.isRequired, propTypesExports.number;
propTypesExports.string, isLinkService.isRequired, propTypesExports.func, propTypesExports.func, propTypesExports.func, propTypesExports.func, propTypesExports.bool, propTypesExports.number;
function ownKeys(Ee, ge) {
  var le = Object.keys(Ee);
  if (Object.getOwnPropertySymbols) {
    var de = Object.getOwnPropertySymbols(Ee);
    ge && (de = de.filter(function(oe) {
      return Object.getOwnPropertyDescriptor(Ee, oe).enumerable;
    })), le.push.apply(le, de);
  }
  return le;
}
function _objectSpread(Ee) {
  for (var ge = 1; ge < arguments.length; ge++) {
    var le = arguments[ge] != null ? arguments[ge] : {};
    ge % 2 ? ownKeys(Object(le), !0).forEach(function(de) {
      _defineProperty(Ee, de, le[de]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(Ee, Object.getOwnPropertyDescriptors(le)) : ownKeys(Object(le)).forEach(function(de) {
      Object.defineProperty(Ee, de, Object.getOwnPropertyDescriptor(le, de));
    });
  }
  return Ee;
}
var isFunctionOrNode = propTypesExports.oneOfType([propTypesExports.func, propTypesExports.node]);
_objectSpread(_objectSpread({}, eventProps), {}, {
  canvasBackground: propTypesExports.string,
  children: propTypesExports.node,
  className: isClassName,
  customTextRenderer: propTypesExports.func,
  devicePixelRatio: propTypesExports.number,
  error: isFunctionOrNode,
  height: propTypesExports.number,
  imageResourcesPath: propTypesExports.string,
  inputRef: isRef,
  loading: isFunctionOrNode,
  noData: isFunctionOrNode,
  onGetTextError: propTypesExports.func,
  onGetTextSuccess: propTypesExports.func,
  onLoadError: propTypesExports.func,
  onLoadSuccess: propTypesExports.func,
  onRenderError: propTypesExports.func,
  onRenderSuccess: propTypesExports.func,
  onRenderTextLayerError: propTypesExports.func,
  onRenderTextLayerSuccess: propTypesExports.func,
  pageIndex: isPageIndex,
  pageNumber: isPageNumber,
  pdf: isPdf,
  registerPage: propTypesExports.func,
  renderAnnotationLayer: propTypesExports.bool,
  renderForms: propTypesExports.bool,
  renderInteractiveForms: propTypesExports.bool,
  // For backward compatibility
  renderMode: isRenderMode,
  renderTextLayer: propTypesExports.bool,
  rotate: isRotate,
  scale: propTypesExports.number,
  unregisterPage: propTypesExports.func,
  width: propTypesExports.number
});
displayWorkerWarning();
pdfExports.GlobalWorkerOptions.workerSrc = "pdf.worker.js";
var pdf_worker_entry = {}, pdf_workerExports = {}, pdf_worker = {
  get exports() {
    return pdf_workerExports;
  },
  set exports(Ee) {
    pdf_workerExports = Ee;
  }
};
(function(Ee, ge) {
  (function(de, oe) {
    Ee.exports = oe();
  })(globalThis, () => (
    /******/
    (() => {
      var le = [
        ,
        /* 1 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.WorkerTask = u.WorkerMessageHandler = void 0;
          var t = P(2), i = P(5), v = P(6), a = P(8), e = P(71), y = P(65), r = P(4), h = P(102), g = P(103);
          class d {
            constructor(x) {
              this.name = x, this.terminated = !1, this._capability = (0, t.createPromiseCapability)();
            }
            get finished() {
              return this._capability.promise;
            }
            finish() {
              this._capability.resolve();
            }
            terminate() {
              this.terminated = !0;
            }
            ensureNotTerminated() {
              if (this.terminated)
                throw new Error("Worker task was terminated");
            }
          }
          u.WorkerTask = d;
          class c {
            static setup(x, f) {
              let m = !1;
              x.on("test", function(p) {
                m || (m = !0, x.send("test", p instanceof Uint8Array));
              }), x.on("configure", function(p) {
                (0, t.setVerbosityLevel)(p.verbosity);
              }), x.on("GetDocRequest", function(p) {
                return c.createDocumentHandler(p, f);
              });
            }
            static createDocumentHandler(x, f) {
              let m, C = !1, p = null;
              const w = [], X = (0, t.getVerbosityLevel)(), M = x.apiVersion, j = "2.16.105";
              if (M !== j)
                throw new Error(`The API version "${M}" does not match the Worker version "${j}".`);
              const B = [];
              for (const U in [])
                B.push(U);
              if (B.length)
                throw new Error("The `Array.prototype` contains unexpected enumerable properties: " + B.join(", ") + "; thus breaking e.g. `for...in` iteration of `Array`s.");
              if (typeof ReadableStream > "u") {
                const U = "The browser/environment lacks native support for critical functionality used by the PDF.js library (e.g. `ReadableStream`); ";
                throw r.isNodeJS ? new Error(U + "please use a `legacy`-build instead.") : new Error(U + "please update to a supported browser.");
              }
              const R = x.docId, D = x.docBaseUrl, b = x.docId + "_worker";
              let l = new h.MessageHandler(b, R, f);
              function _() {
                if (C)
                  throw new Error("Worker was terminated");
              }
              function S(U) {
                w.push(U);
              }
              function A(U) {
                U.finish();
                const G = w.indexOf(U);
                w.splice(G, 1);
              }
              async function F(U) {
                await m.ensureDoc("checkHeader"), await m.ensureDoc("parseStartXRef"), await m.ensureDoc("parse", [U]), await m.ensureDoc("checkFirstPage", [U]), await m.ensureDoc("checkLastPage", [U]);
                const G = await m.ensureDoc("isPureXfa");
                if (G) {
                  const V = new d("loadXfaFonts");
                  S(V), await Promise.all([m.loadXfaFonts(l, V).catch((L) => {
                  }).then(() => A(V)), m.loadXfaImages()]);
                }
                const [K, W] = await Promise.all([m.ensureDoc("numPages"), m.ensureDoc("fingerprints")]), z = G ? await m.ensureDoc("htmlForXfa") : null;
                return {
                  numPages: K,
                  fingerprints: W,
                  htmlForXfa: z
                };
              }
              function T(U, G, K) {
                const W = (0, t.createPromiseCapability)();
                let z;
                const V = U.source;
                if (V.data) {
                  try {
                    z = new a.LocalPdfManager(R, V.data, V.password, l, G, K, D), W.resolve(z);
                  } catch (Z) {
                    W.reject(Z);
                  }
                  return W.promise;
                }
                let L, Y = [];
                try {
                  L = new g.PDFWorkerStream(l);
                } catch (Z) {
                  return W.reject(Z), W.promise;
                }
                const J = L.getFullReader();
                J.headersReady.then(function() {
                  if (!J.isRangeSupported)
                    return;
                  const Z = V.disableAutoFetch || J.isStreamingSupported;
                  z = new a.NetworkPdfManager(R, L, {
                    msgHandler: l,
                    password: V.password,
                    length: J.contentLength,
                    disableAutoFetch: Z,
                    rangeChunkSize: V.rangeChunkSize
                  }, G, K, D);
                  for (const E of Y)
                    z.sendProgressiveData(E);
                  Y = [], W.resolve(z), p = null;
                }).catch(function(Z) {
                  W.reject(Z), p = null;
                });
                let ie = 0;
                const q = function() {
                  const Z = (0, t.arraysToBytes)(Y);
                  V.length && Z.length !== V.length && (0, t.warn)("reported HTTP length is different from actual");
                  try {
                    z = new a.LocalPdfManager(R, Z, V.password, l, G, K, D), W.resolve(z);
                  } catch (E) {
                    W.reject(E);
                  }
                  Y = [];
                };
                return new Promise(function(Z, E) {
                  const te = function({
                    value: re,
                    done: ee
                  }) {
                    try {
                      if (_(), ee) {
                        z || q(), p = null;
                        return;
                      }
                      ie += (0, t.arrayByteLength)(re), J.isStreamingSupported || l.send("DocProgress", {
                        loaded: ie,
                        total: Math.max(ie, J.contentLength || 0)
                      }), z ? z.sendProgressiveData(re) : Y.push(re), J.read().then(te, E);
                    } catch ($) {
                      E($);
                    }
                  };
                  J.read().then(te, E);
                }).catch(function(Z) {
                  W.reject(Z), p = null;
                }), p = function(Z) {
                  L.cancelAllRequests(Z);
                }, W.promise;
              }
              function O(U) {
                function G(V) {
                  _(), l.send("GetDoc", {
                    pdfInfo: V
                  });
                }
                function K(V) {
                  if (_(), V instanceof t.PasswordException) {
                    const L = new d(`PasswordException: response ${V.code}`);
                    S(L), l.sendWithPromise("PasswordRequest", V).then(function({
                      password: Y
                    }) {
                      A(L), m.updatePassword(Y), W();
                    }).catch(function() {
                      A(L), l.send("DocException", V);
                    });
                  } else
                    V instanceof t.InvalidPDFException || V instanceof t.MissingPDFException || V instanceof t.UnexpectedResponseException || V instanceof t.UnknownErrorException ? l.send("DocException", V) : l.send("DocException", new t.UnknownErrorException(V.message, V.toString()));
                }
                function W() {
                  _(), F(!1).then(G, function(V) {
                    if (_(), !(V instanceof v.XRefParseException)) {
                      K(V);
                      return;
                    }
                    m.requestLoadedStream(), m.onLoadedStream().then(function() {
                      _(), F(!0).then(G, K);
                    });
                  });
                }
                _();
                const z = {
                  maxImageSize: U.maxImageSize,
                  disableFontFace: U.disableFontFace,
                  ignoreErrors: U.ignoreErrors,
                  isEvalSupported: U.isEvalSupported,
                  fontExtraProperties: U.fontExtraProperties,
                  useSystemFonts: U.useSystemFonts,
                  cMapUrl: U.cMapUrl,
                  standardFontDataUrl: U.standardFontDataUrl
                };
                T(U, z, U.enableXfa).then(function(V) {
                  if (C)
                    throw V.terminate(new t.AbortException("Worker was terminated.")), new Error("Worker was terminated");
                  m = V, m.onLoadedStream().then(function(L) {
                    l.send("DataLoaded", {
                      length: L.bytes.byteLength
                    });
                  });
                }).then(W, K);
              }
              return l.on("GetPage", function(G) {
                return m.getPage(G.pageIndex).then(function(K) {
                  return Promise.all([m.ensure(K, "rotate"), m.ensure(K, "ref"), m.ensure(K, "userUnit"), m.ensure(K, "view")]).then(function([W, z, V, L]) {
                    return {
                      rotate: W,
                      ref: z,
                      userUnit: V,
                      view: L
                    };
                  });
                });
              }), l.on("GetPageIndex", function(G) {
                const K = i.Ref.get(G.num, G.gen);
                return m.ensureCatalog("getPageIndex", [K]);
              }), l.on("GetDestinations", function(G) {
                return m.ensureCatalog("destinations");
              }), l.on("GetDestination", function(G) {
                return m.ensureCatalog("getDestination", [G.id]);
              }), l.on("GetPageLabels", function(G) {
                return m.ensureCatalog("pageLabels");
              }), l.on("GetPageLayout", function(G) {
                return m.ensureCatalog("pageLayout");
              }), l.on("GetPageMode", function(G) {
                return m.ensureCatalog("pageMode");
              }), l.on("GetViewerPreferences", function(U) {
                return m.ensureCatalog("viewerPreferences");
              }), l.on("GetOpenAction", function(U) {
                return m.ensureCatalog("openAction");
              }), l.on("GetAttachments", function(G) {
                return m.ensureCatalog("attachments");
              }), l.on("GetJavaScript", function(G) {
                return m.ensureCatalog("javaScript");
              }), l.on("GetDocJSActions", function(G) {
                return m.ensureCatalog("jsActions");
              }), l.on("GetPageJSActions", function({
                pageIndex: U
              }) {
                return m.getPage(U).then(function(G) {
                  return m.ensure(G, "jsActions");
                });
              }), l.on("GetOutline", function(G) {
                return m.ensureCatalog("documentOutline");
              }), l.on("GetOptionalContentConfig", function(U) {
                return m.ensureCatalog("optionalContentConfig");
              }), l.on("GetPermissions", function(U) {
                return m.ensureCatalog("permissions");
              }), l.on("GetMetadata", function(G) {
                return Promise.all([m.ensureDoc("documentInfo"), m.ensureCatalog("metadata")]);
              }), l.on("GetMarkInfo", function(G) {
                return m.ensureCatalog("markInfo");
              }), l.on("GetData", function(G) {
                return m.requestLoadedStream(), m.onLoadedStream().then(function(K) {
                  return K.bytes;
                });
              }), l.on("GetAnnotations", function({
                pageIndex: U,
                intent: G
              }) {
                return m.getPage(U).then(function(K) {
                  const W = new d(`GetAnnotations: page ${U}`);
                  return S(W), K.getAnnotationsData(l, W, G).then((z) => (A(W), z), (z) => {
                    A(W);
                  });
                });
              }), l.on("GetFieldObjects", function(U) {
                return m.ensureDoc("fieldObjects");
              }), l.on("HasJSActions", function(U) {
                return m.ensureDoc("hasJSActions");
              }), l.on("GetCalculationOrderIds", function(U) {
                return m.ensureDoc("calculationOrderIds");
              }), l.on("SaveDocument", function({
                isPureXfa: U,
                numPages: G,
                annotationStorage: K,
                filename: W
              }) {
                m.requestLoadedStream();
                const z = U ? null : (0, v.getNewAnnotationsMap)(K), V = [m.onLoadedStream(), m.ensureCatalog("acroForm"), m.ensureCatalog("acroFormRef"), m.ensureDoc("xref"), m.ensureDoc("startXRef")];
                if (z)
                  for (const [L, Y] of z)
                    V.push(m.getPage(L).then((J) => {
                      const ie = new d(`Save (editor): page ${L}`);
                      return J.saveNewAnnotations(l, ie, Y).finally(function() {
                        A(ie);
                      });
                    }));
                if (U)
                  V.push(m.serializeXfaData(K));
                else
                  for (let L = 0; L < G; L++)
                    V.push(m.getPage(L).then(function(Y) {
                      const J = new d(`Save: page ${L}`);
                      return Y.save(l, J, K).finally(function() {
                        A(J);
                      });
                    }));
                return Promise.all(V).then(function([L, Y, J, ie, q, ...N]) {
                  let Z = [], E = null;
                  if (U) {
                    if (E = N[0], !E)
                      return L.bytes;
                  } else if (Z = N.flat(2), Z.length === 0)
                    return L.bytes;
                  const te = Y instanceof i.Dict && Y.get("XFA") || null;
                  let re = null, ee = !1;
                  if (Array.isArray(te)) {
                    for (let k = 0, H = te.length; k < H; k += 2)
                      te[k] === "datasets" && (re = te[k + 1], J = null, ee = !0);
                    re === null && (re = ie.getNewRef());
                  } else
                    te && (J = null, (0, t.warn)("Unsupported XFA type."));
                  let $ = /* @__PURE__ */ Object.create(null);
                  if (ie.trailer) {
                    const k = /* @__PURE__ */ Object.create(null), H = ie.trailer.get("Info") || null;
                    H instanceof i.Dict && H.forEach((ne, ae) => {
                      typeof ae == "string" && (k[ne] = (0, t.stringToPDFString)(ae));
                    }), $ = {
                      rootRef: ie.trailer.getRaw("Root") || null,
                      encryptRef: ie.trailer.getRaw("Encrypt") || null,
                      newRef: ie.getNewRef(),
                      infoRef: ie.trailer.getRaw("Info") || null,
                      info: k,
                      fileIds: ie.trailer.get("ID") || null,
                      startXRef: q,
                      filename: W
                    };
                  }
                  return ie.resetNewRef(), (0, y.incrementalUpdate)({
                    originalData: L.bytes,
                    xrefInfo: $,
                    newRefs: Z,
                    xref: ie,
                    hasXfa: !!te,
                    xfaDatasetsRef: re,
                    hasXfaDatasetsEntry: ee,
                    acroFormRef: J,
                    acroForm: Y,
                    xfaData: E
                  });
                });
              }), l.on("GetOperatorList", function(G, K) {
                const W = G.pageIndex;
                m.getPage(W).then(function(z) {
                  const V = new d(`GetOperatorList: page ${W}`);
                  S(V);
                  const L = X >= t.VerbosityLevel.INFOS ? Date.now() : 0;
                  z.getOperatorList({
                    handler: l,
                    sink: K,
                    task: V,
                    intent: G.intent,
                    cacheKey: G.cacheKey,
                    annotationStorage: G.annotationStorage
                  }).then(function(Y) {
                    A(V), L && (0, t.info)(`page=${W + 1} - getOperatorList: time=${Date.now() - L}ms, len=${Y.length}`), K.close();
                  }, function(Y) {
                    A(V), !V.terminated && (l.send("UnsupportedFeature", {
                      featureId: t.UNSUPPORTED_FEATURES.errorOperatorList
                    }), K.error(Y));
                  });
                });
              }), l.on("GetTextContent", function(G, K) {
                const W = G.pageIndex;
                m.getPage(W).then(function(z) {
                  const V = new d("GetTextContent: page " + W);
                  S(V);
                  const L = X >= t.VerbosityLevel.INFOS ? Date.now() : 0;
                  z.extractTextContent({
                    handler: l,
                    task: V,
                    sink: K,
                    includeMarkedContent: G.includeMarkedContent,
                    combineTextItems: G.combineTextItems
                  }).then(function() {
                    A(V), L && (0, t.info)(`page=${W + 1} - getTextContent: time=${Date.now() - L}ms`), K.close();
                  }, function(Y) {
                    A(V), !V.terminated && K.error(Y);
                  });
                });
              }), l.on("GetStructTree", function(G) {
                return m.getPage(G.pageIndex).then(function(K) {
                  return m.ensure(K, "getStructTree");
                });
              }), l.on("FontFallback", function(U) {
                return m.fontFallback(U.id, l);
              }), l.on("Cleanup", function(G) {
                return m.cleanup(!0);
              }), l.on("Terminate", function(G) {
                C = !0;
                const K = [];
                if (m) {
                  m.terminate(new t.AbortException("Worker was terminated."));
                  const W = m.cleanup();
                  K.push(W), m = null;
                } else
                  (0, e.clearGlobalCaches)();
                p && p(new t.AbortException("Worker was terminated."));
                for (const W of w)
                  K.push(W.finished), W.terminate();
                return Promise.all(K).then(function() {
                  l.destroy(), l = null;
                });
              }), l.on("Ready", function(G) {
                O(x), x = null;
              }), b;
            }
            static initializeFromPort(x) {
              const f = new h.MessageHandler("worker", "main", x);
              c.setup(f, x), f.send("ready", null);
            }
          }
          u.WorkerMessageHandler = c;
          function n(o) {
            return typeof o.postMessage == "function" && "onmessage" in o;
          }
          typeof window > "u" && !r.isNodeJS && typeof self < "u" && n(self) && c.initializeFromPort(self);
        },
        /* 2 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.VerbosityLevel = u.Util = u.UnknownErrorException = u.UnexpectedResponseException = u.UNSUPPORTED_FEATURES = u.TextRenderingMode = u.StreamType = u.RenderingIntentFlag = u.PermissionFlag = u.PasswordResponses = u.PasswordException = u.PageActionEventType = u.OPS = u.MissingPDFException = u.LINE_FACTOR = u.LINE_DESCENT_FACTOR = u.InvalidPDFException = u.ImageKind = u.IDENTITY_MATRIX = u.FormatError = u.FontType = u.FeatureTest = u.FONT_IDENTITY_MATRIX = u.DocumentActionEventType = u.CMapCompressionType = u.BaseException = u.AnnotationType = u.AnnotationStateModelType = u.AnnotationReviewState = u.AnnotationReplyType = u.AnnotationMode = u.AnnotationMarkedState = u.AnnotationFlag = u.AnnotationFieldFlag = u.AnnotationEditorType = u.AnnotationEditorPrefix = u.AnnotationEditorParamsType = u.AnnotationBorderStyleType = u.AnnotationActionEventType = u.AbortException = void 0, u.arrayByteLength = $, u.arraysToBytes = k, u.assert = W, u.bytesToString = re, u.createPromiseCapability = nt, u.createValidAbsoluteUrl = V, u.escapeString = De, u.getModificationDate = ze, u.getVerbosityLevel = O, u.info = U, u.isArrayBuffer = be, u.isArrayEqual = Le, u.isAscii = xe, u.objectFromMap = ae, u.objectSize = ne, u.setVerbosityLevel = T, u.shadow = L, u.string32 = H, u.stringToBytes = ee, u.stringToPDFString = Ae, u.stringToUTF16BEString = Te, u.stringToUTF8String = ve, u.unreachable = K, u.utf8StringToString = Se, u.warn = G, P(3);
          const t = [1, 0, 0, 1, 0, 0];
          u.IDENTITY_MATRIX = t;
          const i = [1e-3, 0, 0, 1e-3, 0, 0];
          u.FONT_IDENTITY_MATRIX = i;
          const v = 1.35;
          u.LINE_FACTOR = v;
          const a = 0.35;
          u.LINE_DESCENT_FACTOR = a;
          const e = {
            ANY: 1,
            DISPLAY: 2,
            PRINT: 4,
            ANNOTATIONS_FORMS: 16,
            ANNOTATIONS_STORAGE: 32,
            ANNOTATIONS_DISABLE: 64,
            OPLIST: 256
          };
          u.RenderingIntentFlag = e;
          const y = {
            DISABLE: 0,
            ENABLE: 1,
            ENABLE_FORMS: 2,
            ENABLE_STORAGE: 3
          };
          u.AnnotationMode = y;
          const r = "pdfjs_internal_editor_";
          u.AnnotationEditorPrefix = r;
          const h = {
            DISABLE: -1,
            NONE: 0,
            FREETEXT: 3,
            INK: 15
          };
          u.AnnotationEditorType = h;
          const g = {
            FREETEXT_SIZE: 1,
            FREETEXT_COLOR: 2,
            FREETEXT_OPACITY: 3,
            INK_COLOR: 11,
            INK_THICKNESS: 12,
            INK_OPACITY: 13
          };
          u.AnnotationEditorParamsType = g;
          const d = {
            PRINT: 4,
            MODIFY_CONTENTS: 8,
            COPY: 16,
            MODIFY_ANNOTATIONS: 32,
            FILL_INTERACTIVE_FORMS: 256,
            COPY_FOR_ACCESSIBILITY: 512,
            ASSEMBLE: 1024,
            PRINT_HIGH_QUALITY: 2048
          };
          u.PermissionFlag = d;
          const c = {
            FILL: 0,
            STROKE: 1,
            FILL_STROKE: 2,
            INVISIBLE: 3,
            FILL_ADD_TO_PATH: 4,
            STROKE_ADD_TO_PATH: 5,
            FILL_STROKE_ADD_TO_PATH: 6,
            ADD_TO_PATH: 7,
            FILL_STROKE_MASK: 3,
            ADD_TO_PATH_FLAG: 4
          };
          u.TextRenderingMode = c;
          const n = {
            GRAYSCALE_1BPP: 1,
            RGB_24BPP: 2,
            RGBA_32BPP: 3
          };
          u.ImageKind = n;
          const o = {
            TEXT: 1,
            LINK: 2,
            FREETEXT: 3,
            LINE: 4,
            SQUARE: 5,
            CIRCLE: 6,
            POLYGON: 7,
            POLYLINE: 8,
            HIGHLIGHT: 9,
            UNDERLINE: 10,
            SQUIGGLY: 11,
            STRIKEOUT: 12,
            STAMP: 13,
            CARET: 14,
            INK: 15,
            POPUP: 16,
            FILEATTACHMENT: 17,
            SOUND: 18,
            MOVIE: 19,
            WIDGET: 20,
            SCREEN: 21,
            PRINTERMARK: 22,
            TRAPNET: 23,
            WATERMARK: 24,
            THREED: 25,
            REDACT: 26
          };
          u.AnnotationType = o;
          const x = {
            MARKED: "Marked",
            REVIEW: "Review"
          };
          u.AnnotationStateModelType = x;
          const f = {
            MARKED: "Marked",
            UNMARKED: "Unmarked"
          };
          u.AnnotationMarkedState = f;
          const m = {
            ACCEPTED: "Accepted",
            REJECTED: "Rejected",
            CANCELLED: "Cancelled",
            COMPLETED: "Completed",
            NONE: "None"
          };
          u.AnnotationReviewState = m;
          const C = {
            GROUP: "Group",
            REPLY: "R"
          };
          u.AnnotationReplyType = C;
          const p = {
            INVISIBLE: 1,
            HIDDEN: 2,
            PRINT: 4,
            NOZOOM: 8,
            NOROTATE: 16,
            NOVIEW: 32,
            READONLY: 64,
            LOCKED: 128,
            TOGGLENOVIEW: 256,
            LOCKEDCONTENTS: 512
          };
          u.AnnotationFlag = p;
          const w = {
            READONLY: 1,
            REQUIRED: 2,
            NOEXPORT: 4,
            MULTILINE: 4096,
            PASSWORD: 8192,
            NOTOGGLETOOFF: 16384,
            RADIO: 32768,
            PUSHBUTTON: 65536,
            COMBO: 131072,
            EDIT: 262144,
            SORT: 524288,
            FILESELECT: 1048576,
            MULTISELECT: 2097152,
            DONOTSPELLCHECK: 4194304,
            DONOTSCROLL: 8388608,
            COMB: 16777216,
            RICHTEXT: 33554432,
            RADIOSINUNISON: 33554432,
            COMMITONSELCHANGE: 67108864
          };
          u.AnnotationFieldFlag = w;
          const X = {
            SOLID: 1,
            DASHED: 2,
            BEVELED: 3,
            INSET: 4,
            UNDERLINE: 5
          };
          u.AnnotationBorderStyleType = X;
          const M = {
            E: "Mouse Enter",
            X: "Mouse Exit",
            D: "Mouse Down",
            U: "Mouse Up",
            Fo: "Focus",
            Bl: "Blur",
            PO: "PageOpen",
            PC: "PageClose",
            PV: "PageVisible",
            PI: "PageInvisible",
            K: "Keystroke",
            F: "Format",
            V: "Validate",
            C: "Calculate"
          };
          u.AnnotationActionEventType = M;
          const j = {
            WC: "WillClose",
            WS: "WillSave",
            DS: "DidSave",
            WP: "WillPrint",
            DP: "DidPrint"
          };
          u.DocumentActionEventType = j;
          const B = {
            O: "PageOpen",
            C: "PageClose"
          };
          u.PageActionEventType = B;
          const R = {
            UNKNOWN: "UNKNOWN",
            FLATE: "FLATE",
            LZW: "LZW",
            DCT: "DCT",
            JPX: "JPX",
            JBIG: "JBIG",
            A85: "A85",
            AHX: "AHX",
            CCF: "CCF",
            RLX: "RLX"
          };
          u.StreamType = R;
          const D = {
            UNKNOWN: "UNKNOWN",
            TYPE1: "TYPE1",
            TYPE1STANDARD: "TYPE1STANDARD",
            TYPE1C: "TYPE1C",
            CIDFONTTYPE0: "CIDFONTTYPE0",
            CIDFONTTYPE0C: "CIDFONTTYPE0C",
            TRUETYPE: "TRUETYPE",
            CIDFONTTYPE2: "CIDFONTTYPE2",
            TYPE3: "TYPE3",
            OPENTYPE: "OPENTYPE",
            TYPE0: "TYPE0",
            MMTYPE1: "MMTYPE1"
          };
          u.FontType = D;
          const b = {
            ERRORS: 0,
            WARNINGS: 1,
            INFOS: 5
          };
          u.VerbosityLevel = b;
          const l = {
            NONE: 0,
            BINARY: 1,
            STREAM: 2
          };
          u.CMapCompressionType = l;
          const _ = {
            dependency: 1,
            setLineWidth: 2,
            setLineCap: 3,
            setLineJoin: 4,
            setMiterLimit: 5,
            setDash: 6,
            setRenderingIntent: 7,
            setFlatness: 8,
            setGState: 9,
            save: 10,
            restore: 11,
            transform: 12,
            moveTo: 13,
            lineTo: 14,
            curveTo: 15,
            curveTo2: 16,
            curveTo3: 17,
            closePath: 18,
            rectangle: 19,
            stroke: 20,
            closeStroke: 21,
            fill: 22,
            eoFill: 23,
            fillStroke: 24,
            eoFillStroke: 25,
            closeFillStroke: 26,
            closeEOFillStroke: 27,
            endPath: 28,
            clip: 29,
            eoClip: 30,
            beginText: 31,
            endText: 32,
            setCharSpacing: 33,
            setWordSpacing: 34,
            setHScale: 35,
            setLeading: 36,
            setFont: 37,
            setTextRenderingMode: 38,
            setTextRise: 39,
            moveText: 40,
            setLeadingMoveText: 41,
            setTextMatrix: 42,
            nextLine: 43,
            showText: 44,
            showSpacedText: 45,
            nextLineShowText: 46,
            nextLineSetSpacingShowText: 47,
            setCharWidth: 48,
            setCharWidthAndBounds: 49,
            setStrokeColorSpace: 50,
            setFillColorSpace: 51,
            setStrokeColor: 52,
            setStrokeColorN: 53,
            setFillColor: 54,
            setFillColorN: 55,
            setStrokeGray: 56,
            setFillGray: 57,
            setStrokeRGBColor: 58,
            setFillRGBColor: 59,
            setStrokeCMYKColor: 60,
            setFillCMYKColor: 61,
            shadingFill: 62,
            beginInlineImage: 63,
            beginImageData: 64,
            endInlineImage: 65,
            paintXObject: 66,
            markPoint: 67,
            markPointProps: 68,
            beginMarkedContent: 69,
            beginMarkedContentProps: 70,
            endMarkedContent: 71,
            beginCompat: 72,
            endCompat: 73,
            paintFormXObjectBegin: 74,
            paintFormXObjectEnd: 75,
            beginGroup: 76,
            endGroup: 77,
            beginAnnotations: 78,
            endAnnotations: 79,
            beginAnnotation: 80,
            endAnnotation: 81,
            paintJpegXObject: 82,
            paintImageMaskXObject: 83,
            paintImageMaskXObjectGroup: 84,
            paintImageXObject: 85,
            paintInlineImageXObject: 86,
            paintInlineImageXObjectGroup: 87,
            paintImageXObjectRepeat: 88,
            paintImageMaskXObjectRepeat: 89,
            paintSolidColorImageMask: 90,
            constructPath: 91
          };
          u.OPS = _;
          const S = {
            unknown: "unknown",
            forms: "forms",
            javaScript: "javaScript",
            signatures: "signatures",
            smask: "smask",
            shadingPattern: "shadingPattern",
            font: "font",
            errorTilingPattern: "errorTilingPattern",
            errorExtGState: "errorExtGState",
            errorXObject: "errorXObject",
            errorFontLoadType3: "errorFontLoadType3",
            errorFontState: "errorFontState",
            errorFontMissing: "errorFontMissing",
            errorFontTranslate: "errorFontTranslate",
            errorColorSpace: "errorColorSpace",
            errorOperatorList: "errorOperatorList",
            errorFontToUnicode: "errorFontToUnicode",
            errorFontLoadNative: "errorFontLoadNative",
            errorFontBuildPath: "errorFontBuildPath",
            errorFontGetPath: "errorFontGetPath",
            errorMarkedContent: "errorMarkedContent",
            errorContentSubStream: "errorContentSubStream"
          };
          u.UNSUPPORTED_FEATURES = S;
          const A = {
            NEED_PASSWORD: 1,
            INCORRECT_PASSWORD: 2
          };
          u.PasswordResponses = A;
          let F = b.WARNINGS;
          function T(Ue) {
            Number.isInteger(Ue) && (F = Ue);
          }
          function O() {
            return F;
          }
          function U(Ue) {
            F >= b.INFOS && console.log(`Info: ${Ue}`);
          }
          function G(Ue) {
            F >= b.WARNINGS && console.log(`Warning: ${Ue}`);
          }
          function K(Ue) {
            throw new Error(Ue);
          }
          function W(Ue, Oe) {
            Ue || K(Oe);
          }
          function z(Ue) {
            if (!Ue)
              return !1;
            switch (Ue.protocol) {
              case "http:":
              case "https:":
              case "ftp:":
              case "mailto:":
              case "tel:":
                return !0;
              default:
                return !1;
            }
          }
          function V(Ue, Oe = null, _e = null) {
            if (!Ue)
              return null;
            try {
              if (_e && typeof Ue == "string") {
                if (_e.addDefaultProtocol && Ue.startsWith("www.")) {
                  const Je = Ue.match(/\./g);
                  Je && Je.length >= 2 && (Ue = `http://${Ue}`);
                }
                if (_e.tryConvertEncoding)
                  try {
                    Ue = ve(Ue);
                  } catch {
                  }
              }
              const at = Oe ? new URL(Ue, Oe) : new URL(Ue);
              if (z(at))
                return at;
            } catch {
            }
            return null;
          }
          function L(Ue, Oe, _e) {
            return Object.defineProperty(Ue, Oe, {
              value: _e,
              enumerable: !0,
              configurable: !0,
              writable: !1
            }), _e;
          }
          const Y = function() {
            function Oe(_e, at) {
              this.constructor === Oe && K("Cannot initialize BaseException."), this.message = _e, this.name = at;
            }
            return Oe.prototype = new Error(), Oe.constructor = Oe, Oe;
          }();
          u.BaseException = Y;
          class J extends Y {
            constructor(Oe, _e) {
              super(Oe, "PasswordException"), this.code = _e;
            }
          }
          u.PasswordException = J;
          class ie extends Y {
            constructor(Oe, _e) {
              super(Oe, "UnknownErrorException"), this.details = _e;
            }
          }
          u.UnknownErrorException = ie;
          class q extends Y {
            constructor(Oe) {
              super(Oe, "InvalidPDFException");
            }
          }
          u.InvalidPDFException = q;
          class N extends Y {
            constructor(Oe) {
              super(Oe, "MissingPDFException");
            }
          }
          u.MissingPDFException = N;
          class Z extends Y {
            constructor(Oe, _e) {
              super(Oe, "UnexpectedResponseException"), this.status = _e;
            }
          }
          u.UnexpectedResponseException = Z;
          class E extends Y {
            constructor(Oe) {
              super(Oe, "FormatError");
            }
          }
          u.FormatError = E;
          class te extends Y {
            constructor(Oe) {
              super(Oe, "AbortException");
            }
          }
          u.AbortException = te;
          function re(Ue) {
            (typeof Ue != "object" || Ue === null || Ue.length === void 0) && K("Invalid argument for bytesToString");
            const Oe = Ue.length, _e = 8192;
            if (Oe < _e)
              return String.fromCharCode.apply(null, Ue);
            const at = [];
            for (let Je = 0; Je < Oe; Je += _e) {
              const ot = Math.min(Je + _e, Oe), mt = Ue.subarray(Je, ot);
              at.push(String.fromCharCode.apply(null, mt));
            }
            return at.join("");
          }
          function ee(Ue) {
            typeof Ue != "string" && K("Invalid argument for stringToBytes");
            const Oe = Ue.length, _e = new Uint8Array(Oe);
            for (let at = 0; at < Oe; ++at)
              _e[at] = Ue.charCodeAt(at) & 255;
            return _e;
          }
          function $(Ue) {
            if (Ue.length !== void 0)
              return Ue.length;
            if (Ue.byteLength !== void 0)
              return Ue.byteLength;
            K("Invalid argument for arrayByteLength");
          }
          function k(Ue) {
            const Oe = Ue.length;
            if (Oe === 1 && Ue[0] instanceof Uint8Array)
              return Ue[0];
            let _e = 0;
            for (let ot = 0; ot < Oe; ot++)
              _e += $(Ue[ot]);
            let at = 0;
            const Je = new Uint8Array(_e);
            for (let ot = 0; ot < Oe; ot++) {
              let mt = Ue[ot];
              mt instanceof Uint8Array || (typeof mt == "string" ? mt = ee(mt) : mt = new Uint8Array(mt));
              const Ze = mt.byteLength;
              Je.set(mt, at), at += Ze;
            }
            return Je;
          }
          function H(Ue) {
            return String.fromCharCode(Ue >> 24 & 255, Ue >> 16 & 255, Ue >> 8 & 255, Ue & 255);
          }
          function ne(Ue) {
            return Object.keys(Ue).length;
          }
          function ae(Ue) {
            const Oe = /* @__PURE__ */ Object.create(null);
            for (const [_e, at] of Ue)
              Oe[_e] = at;
            return Oe;
          }
          function he() {
            const Ue = new Uint8Array(4);
            return Ue[0] = 1, new Uint32Array(Ue.buffer, 0, 1)[0] === 1;
          }
          function ue() {
            try {
              return new Function(""), !0;
            } catch {
              return !1;
            }
          }
          class fe {
            static get isLittleEndian() {
              return L(this, "isLittleEndian", he());
            }
            static get isEvalSupported() {
              return L(this, "isEvalSupported", ue());
            }
            static get isOffscreenCanvasSupported() {
              return L(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas < "u");
            }
          }
          u.FeatureTest = fe;
          const me = [...Array(256).keys()].map((Ue) => Ue.toString(16).padStart(2, "0"));
          class Fe {
            static makeHexColor(Oe, _e, at) {
              return `#${me[Oe]}${me[_e]}${me[at]}`;
            }
            static scaleMinMax(Oe, _e) {
              let at;
              Oe[0] ? (Oe[0] < 0 && (at = _e[0], _e[0] = _e[1], _e[1] = at), _e[0] *= Oe[0], _e[1] *= Oe[0], Oe[3] < 0 && (at = _e[2], _e[2] = _e[3], _e[3] = at), _e[2] *= Oe[3], _e[3] *= Oe[3]) : (at = _e[0], _e[0] = _e[2], _e[2] = at, at = _e[1], _e[1] = _e[3], _e[3] = at, Oe[1] < 0 && (at = _e[2], _e[2] = _e[3], _e[3] = at), _e[2] *= Oe[1], _e[3] *= Oe[1], Oe[2] < 0 && (at = _e[0], _e[0] = _e[1], _e[1] = at), _e[0] *= Oe[2], _e[1] *= Oe[2]), _e[0] += Oe[4], _e[1] += Oe[4], _e[2] += Oe[5], _e[3] += Oe[5];
            }
            static transform(Oe, _e) {
              return [Oe[0] * _e[0] + Oe[2] * _e[1], Oe[1] * _e[0] + Oe[3] * _e[1], Oe[0] * _e[2] + Oe[2] * _e[3], Oe[1] * _e[2] + Oe[3] * _e[3], Oe[0] * _e[4] + Oe[2] * _e[5] + Oe[4], Oe[1] * _e[4] + Oe[3] * _e[5] + Oe[5]];
            }
            static applyTransform(Oe, _e) {
              const at = Oe[0] * _e[0] + Oe[1] * _e[2] + _e[4], Je = Oe[0] * _e[1] + Oe[1] * _e[3] + _e[5];
              return [at, Je];
            }
            static applyInverseTransform(Oe, _e) {
              const at = _e[0] * _e[3] - _e[1] * _e[2], Je = (Oe[0] * _e[3] - Oe[1] * _e[2] + _e[2] * _e[5] - _e[4] * _e[3]) / at, ot = (-Oe[0] * _e[1] + Oe[1] * _e[0] + _e[4] * _e[1] - _e[5] * _e[0]) / at;
              return [Je, ot];
            }
            static getAxialAlignedBoundingBox(Oe, _e) {
              const at = Fe.applyTransform(Oe, _e), Je = Fe.applyTransform(Oe.slice(2, 4), _e), ot = Fe.applyTransform([Oe[0], Oe[3]], _e), mt = Fe.applyTransform([Oe[2], Oe[1]], _e);
              return [Math.min(at[0], Je[0], ot[0], mt[0]), Math.min(at[1], Je[1], ot[1], mt[1]), Math.max(at[0], Je[0], ot[0], mt[0]), Math.max(at[1], Je[1], ot[1], mt[1])];
            }
            static inverseTransform(Oe) {
              const _e = Oe[0] * Oe[3] - Oe[1] * Oe[2];
              return [Oe[3] / _e, -Oe[1] / _e, -Oe[2] / _e, Oe[0] / _e, (Oe[2] * Oe[5] - Oe[4] * Oe[3]) / _e, (Oe[4] * Oe[1] - Oe[5] * Oe[0]) / _e];
            }
            static apply3dTransform(Oe, _e) {
              return [Oe[0] * _e[0] + Oe[1] * _e[1] + Oe[2] * _e[2], Oe[3] * _e[0] + Oe[4] * _e[1] + Oe[5] * _e[2], Oe[6] * _e[0] + Oe[7] * _e[1] + Oe[8] * _e[2]];
            }
            static singularValueDecompose2dScale(Oe) {
              const _e = [Oe[0], Oe[2], Oe[1], Oe[3]], at = Oe[0] * _e[0] + Oe[1] * _e[2], Je = Oe[0] * _e[1] + Oe[1] * _e[3], ot = Oe[2] * _e[0] + Oe[3] * _e[2], mt = Oe[2] * _e[1] + Oe[3] * _e[3], Ze = (at + mt) / 2, pt = Math.sqrt((at + mt) ** 2 - 4 * (at * mt - ot * Je)) / 2, Ft = Ze + pt || 1, $e = Ze - pt || 1;
              return [Math.sqrt(Ft), Math.sqrt($e)];
            }
            static normalizeRect(Oe) {
              const _e = Oe.slice(0);
              return Oe[0] > Oe[2] && (_e[0] = Oe[2], _e[2] = Oe[0]), Oe[1] > Oe[3] && (_e[1] = Oe[3], _e[3] = Oe[1]), _e;
            }
            static intersect(Oe, _e) {
              const at = Math.max(Math.min(Oe[0], Oe[2]), Math.min(_e[0], _e[2])), Je = Math.min(Math.max(Oe[0], Oe[2]), Math.max(_e[0], _e[2]));
              if (at > Je)
                return null;
              const ot = Math.max(Math.min(Oe[1], Oe[3]), Math.min(_e[1], _e[3])), mt = Math.min(Math.max(Oe[1], Oe[3]), Math.max(_e[1], _e[3]));
              return ot > mt ? null : [at, ot, Je, mt];
            }
            static bezierBoundingBox(Oe, _e, at, Je, ot, mt, Ze, pt) {
              const Ft = [], $e = [[], []];
              let St, xt, Ie, Ve, st, ct, Rt, Lt;
              for (let tt = 0; tt < 2; ++tt) {
                if (tt === 0 ? (xt = 6 * Oe - 12 * at + 6 * ot, St = -3 * Oe + 9 * at - 9 * ot + 3 * Ze, Ie = 3 * at - 3 * Oe) : (xt = 6 * _e - 12 * Je + 6 * mt, St = -3 * _e + 9 * Je - 9 * mt + 3 * pt, Ie = 3 * Je - 3 * _e), Math.abs(St) < 1e-12) {
                  if (Math.abs(xt) < 1e-12)
                    continue;
                  Ve = -Ie / xt, 0 < Ve && Ve < 1 && Ft.push(Ve);
                  continue;
                }
                Rt = xt * xt - 4 * Ie * St, Lt = Math.sqrt(Rt), !(Rt < 0) && (st = (-xt + Lt) / (2 * St), 0 < st && st < 1 && Ft.push(st), ct = (-xt - Lt) / (2 * St), 0 < ct && ct < 1 && Ft.push(ct));
              }
              let Ge = Ft.length, Ne;
              const rt = Ge;
              for (; Ge--; )
                Ve = Ft[Ge], Ne = 1 - Ve, $e[0][Ge] = Ne * Ne * Ne * Oe + 3 * Ne * Ne * Ve * at + 3 * Ne * Ve * Ve * ot + Ve * Ve * Ve * Ze, $e[1][Ge] = Ne * Ne * Ne * _e + 3 * Ne * Ne * Ve * Je + 3 * Ne * Ve * Ve * mt + Ve * Ve * Ve * pt;
              return $e[0][rt] = Oe, $e[1][rt] = _e, $e[0][rt + 1] = Ze, $e[1][rt + 1] = pt, $e[0].length = $e[1].length = rt + 2, [Math.min(...$e[0]), Math.min(...$e[1]), Math.max(...$e[0]), Math.max(...$e[1])];
            }
          }
          u.Util = Fe;
          const we = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
          function Ae(Ue) {
            if (Ue[0] >= "ï") {
              let _e;
              if (Ue[0] === "þ" && Ue[1] === "ÿ" ? _e = "utf-16be" : Ue[0] === "ÿ" && Ue[1] === "þ" ? _e = "utf-16le" : Ue[0] === "ï" && Ue[1] === "»" && Ue[2] === "¿" && (_e = "utf-8"), _e)
                try {
                  const at = new TextDecoder(_e, {
                    fatal: !0
                  }), Je = ee(Ue);
                  return at.decode(Je);
                } catch (at) {
                  G(`stringToPDFString: "${at}".`);
                }
            }
            const Oe = [];
            for (let _e = 0, at = Ue.length; _e < at; _e++) {
              const Je = we[Ue.charCodeAt(_e)];
              Oe.push(Je ? String.fromCharCode(Je) : Ue.charAt(_e));
            }
            return Oe.join("");
          }
          function De(Ue) {
            return Ue.replace(/([()\\\n\r])/g, (Oe) => Oe === `
` ? "\\n" : Oe === "\r" ? "\\r" : `\\${Oe}`);
          }
          function xe(Ue) {
            return /^[\x00-\x7F]*$/.test(Ue);
          }
          function Te(Ue) {
            const Oe = ["þÿ"];
            for (let _e = 0, at = Ue.length; _e < at; _e++) {
              const Je = Ue.charCodeAt(_e);
              Oe.push(String.fromCharCode(Je >> 8 & 255), String.fromCharCode(Je & 255));
            }
            return Oe.join("");
          }
          function ve(Ue) {
            return decodeURIComponent(escape(Ue));
          }
          function Se(Ue) {
            return unescape(encodeURIComponent(Ue));
          }
          function be(Ue) {
            return typeof Ue == "object" && Ue !== null && Ue.byteLength !== void 0;
          }
          function Le(Ue, Oe) {
            if (Ue.length !== Oe.length)
              return !1;
            for (let _e = 0, at = Ue.length; _e < at; _e++)
              if (Ue[_e] !== Oe[_e])
                return !1;
            return !0;
          }
          function ze(Ue = new Date()) {
            return [Ue.getUTCFullYear().toString(), (Ue.getUTCMonth() + 1).toString().padStart(2, "0"), Ue.getUTCDate().toString().padStart(2, "0"), Ue.getUTCHours().toString().padStart(2, "0"), Ue.getUTCMinutes().toString().padStart(2, "0"), Ue.getUTCSeconds().toString().padStart(2, "0")].join("");
          }
          function nt() {
            const Ue = /* @__PURE__ */ Object.create(null);
            let Oe = !1;
            return Object.defineProperty(Ue, "settled", {
              get() {
                return Oe;
              }
            }), Ue.promise = new Promise(function(_e, at) {
              Ue.resolve = function(Je) {
                Oe = !0, _e(Je);
              }, Ue.reject = function(Je) {
                Oe = !0, at(Je);
              };
            }), Ue;
          }
        },
        /* 3 */
        /***/
        (Q, u, P) => {
          P(4);
        },
        /* 4 */
        /***/
        (Q, u) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.isNodeJS = void 0;
          const P = typeof process == "object" && process + "" == "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
          u.isNodeJS = P;
        },
        /* 5 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.RefSetCache = u.RefSet = u.Ref = u.Name = u.EOF = u.Dict = u.Cmd = u.CIRCULAR_REF = void 0, u.clearPrimitiveCaches = f, u.isCmd = n, u.isDict = o, u.isName = c, u.isRefsEqual = x;
          var t = P(2);
          const i = Symbol("CIRCULAR_REF");
          u.CIRCULAR_REF = i;
          const v = Symbol("EOF");
          u.EOF = v;
          const a = function() {
            let C = /* @__PURE__ */ Object.create(null);
            class p {
              constructor(X) {
                this.name = X;
              }
              static get(X) {
                return C[X] || (C[X] = new p(X));
              }
              static _clearCache() {
                C = /* @__PURE__ */ Object.create(null);
              }
            }
            return p;
          }();
          u.Name = a;
          const e = function() {
            let C = /* @__PURE__ */ Object.create(null);
            class p {
              constructor(X) {
                this.cmd = X;
              }
              static get(X) {
                return C[X] || (C[X] = new p(X));
              }
              static _clearCache() {
                C = /* @__PURE__ */ Object.create(null);
              }
            }
            return p;
          }();
          u.Cmd = e;
          const y = function() {
            return y;
          };
          class r {
            constructor(C = null) {
              this._map = /* @__PURE__ */ Object.create(null), this.xref = C, this.objId = null, this.suppressEncryption = !1, this.__nonSerializable__ = y;
            }
            assignXref(C) {
              this.xref = C;
            }
            get size() {
              return Object.keys(this._map).length;
            }
            get(C, p, w) {
              let X = this._map[C];
              return X === void 0 && p !== void 0 && (X = this._map[p], X === void 0 && w !== void 0 && (X = this._map[w])), X instanceof h && this.xref ? this.xref.fetch(X, this.suppressEncryption) : X;
            }
            async getAsync(C, p, w) {
              let X = this._map[C];
              return X === void 0 && p !== void 0 && (X = this._map[p], X === void 0 && w !== void 0 && (X = this._map[w])), X instanceof h && this.xref ? this.xref.fetchAsync(X, this.suppressEncryption) : X;
            }
            getArray(C, p, w) {
              let X = this._map[C];
              if (X === void 0 && p !== void 0 && (X = this._map[p], X === void 0 && w !== void 0 && (X = this._map[w])), X instanceof h && this.xref && (X = this.xref.fetch(X, this.suppressEncryption)), Array.isArray(X)) {
                X = X.slice();
                for (let M = 0, j = X.length; M < j; M++)
                  X[M] instanceof h && this.xref && (X[M] = this.xref.fetch(X[M], this.suppressEncryption));
              }
              return X;
            }
            getRaw(C) {
              return this._map[C];
            }
            getKeys() {
              return Object.keys(this._map);
            }
            getRawValues() {
              return Object.values(this._map);
            }
            set(C, p) {
              this._map[C] = p;
            }
            has(C) {
              return this._map[C] !== void 0;
            }
            forEach(C) {
              for (const p in this._map)
                C(p, this.get(p));
            }
            static get empty() {
              const C = new r(null);
              return C.set = (p, w) => {
                (0, t.unreachable)("Should not call `set` on the empty dictionary.");
              }, (0, t.shadow)(this, "empty", C);
            }
            static merge({
              xref: C,
              dictArray: p,
              mergeSubDicts: w = !1
            }) {
              const X = new r(C), M = /* @__PURE__ */ new Map();
              for (const j of p)
                if (j instanceof r)
                  for (const [B, R] of Object.entries(j._map)) {
                    let D = M.get(B);
                    if (D === void 0)
                      D = [], M.set(B, D);
                    else if (!w || !(R instanceof r))
                      continue;
                    D.push(R);
                  }
              for (const [j, B] of M) {
                if (B.length === 1 || !(B[0] instanceof r)) {
                  X._map[j] = B[0];
                  continue;
                }
                const R = new r(C);
                for (const D of B)
                  for (const [b, l] of Object.entries(D._map))
                    R._map[b] === void 0 && (R._map[b] = l);
                R.size > 0 && (X._map[j] = R);
              }
              return M.clear(), X.size > 0 ? X : r.empty;
            }
          }
          u.Dict = r;
          const h = function() {
            let C = /* @__PURE__ */ Object.create(null);
            class p {
              constructor(X, M) {
                this.num = X, this.gen = M;
              }
              toString() {
                return this.gen === 0 ? `${this.num}R` : `${this.num}R${this.gen}`;
              }
              static get(X, M) {
                const j = M === 0 ? `${X}R` : `${X}R${M}`;
                return C[j] || (C[j] = new p(X, M));
              }
              static _clearCache() {
                C = /* @__PURE__ */ Object.create(null);
              }
            }
            return p;
          }();
          u.Ref = h;
          class g {
            constructor(C = null) {
              this._set = new Set(C && C._set);
            }
            has(C) {
              return this._set.has(C.toString());
            }
            put(C) {
              this._set.add(C.toString());
            }
            remove(C) {
              this._set.delete(C.toString());
            }
            [Symbol.iterator]() {
              return this._set.values();
            }
            clear() {
              this._set.clear();
            }
          }
          u.RefSet = g;
          class d {
            constructor() {
              this._map = /* @__PURE__ */ new Map();
            }
            get size() {
              return this._map.size;
            }
            get(C) {
              return this._map.get(C.toString());
            }
            has(C) {
              return this._map.has(C.toString());
            }
            put(C, p) {
              this._map.set(C.toString(), p);
            }
            putAlias(C, p) {
              this._map.set(C.toString(), this.get(p));
            }
            [Symbol.iterator]() {
              return this._map.values();
            }
            clear() {
              this._map.clear();
            }
          }
          u.RefSetCache = d;
          function c(m, C) {
            return m instanceof a && (C === void 0 || m.name === C);
          }
          function n(m, C) {
            return m instanceof e && (C === void 0 || m.cmd === C);
          }
          function o(m, C) {
            return m instanceof r && (C === void 0 || c(m.get("Type"), C));
          }
          function x(m, C) {
            return m.num === C.num && m.gen === C.gen;
          }
          function f() {
            e._clearCache(), a._clearCache(), h._clearCache();
          }
        },
        /* 6 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.XRefParseException = u.XRefEntryException = u.ParserEOFException = u.MissingDataException = u.DocStats = void 0, u.collectActions = j, u.encodeToXmlString = R, u.escapePDFName = X, u.getArrayLookupTableFactory = e, u.getInheritableProperty = c, u.getLookupTableFactory = a, u.getNewAnnotationsMap = _, u.isWhiteSpace = p, u.log2 = x, u.numberToString = l, u.parseXFAPath = w, u.readInt8 = f, u.readUint16 = m, u.readUint32 = C, u.recoverJsURL = b, u.toRomanNumerals = o, u.validateCSSFont = D;
          var t = P(2), i = P(5), v = P(7);
          function a(S) {
            let A;
            return function() {
              return S && (A = /* @__PURE__ */ Object.create(null), S(A), S = null), A;
            };
          }
          function e(S) {
            let A;
            return function() {
              if (S) {
                let F = S();
                S = null, A = /* @__PURE__ */ Object.create(null);
                for (let T = 0, O = F.length; T < O; T += 2)
                  A[F[T]] = F[T + 1];
                F = null;
              }
              return A;
            };
          }
          class y extends t.BaseException {
            constructor(A, F) {
              super(`Missing data [${A}, ${F})`, "MissingDataException"), this.begin = A, this.end = F;
            }
          }
          u.MissingDataException = y;
          class r extends t.BaseException {
            constructor(A) {
              super(A, "ParserEOFException");
            }
          }
          u.ParserEOFException = r;
          class h extends t.BaseException {
            constructor(A) {
              super(A, "XRefEntryException");
            }
          }
          u.XRefEntryException = h;
          class g extends t.BaseException {
            constructor(A) {
              super(A, "XRefParseException");
            }
          }
          u.XRefParseException = g;
          class d {
            constructor(A) {
              this._handler = A, this._streamTypes = /* @__PURE__ */ new Set(), this._fontTypes = /* @__PURE__ */ new Set();
            }
            _send() {
              const A = /* @__PURE__ */ Object.create(null), F = /* @__PURE__ */ Object.create(null);
              for (const T of this._streamTypes)
                A[T] = !0;
              for (const T of this._fontTypes)
                F[T] = !0;
              this._handler.send("DocStats", {
                streamTypes: A,
                fontTypes: F
              });
            }
            addStreamType(A) {
              this._streamTypes.has(A) || (this._streamTypes.add(A), this._send());
            }
            addFontType(A) {
              this._fontTypes.has(A) || (this._fontTypes.add(A), this._send());
            }
          }
          u.DocStats = d;
          function c({
            dict: S,
            key: A,
            getArray: F = !1,
            stopWhenFound: T = !0
          }) {
            let O;
            const U = new i.RefSet();
            for (; S instanceof i.Dict && !(S.objId && U.has(S.objId)); ) {
              S.objId && U.put(S.objId);
              const G = F ? S.getArray(A) : S.get(A);
              if (G !== void 0) {
                if (T)
                  return G;
                O || (O = []), O.push(G);
              }
              S = S.get("Parent");
            }
            return O;
          }
          const n = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
          function o(S, A = !1) {
            (0, t.assert)(Number.isInteger(S) && S > 0, "The number should be a positive integer.");
            const F = [];
            let T;
            for (; S >= 1e3; )
              S -= 1e3, F.push("M");
            T = S / 100 | 0, S %= 100, F.push(n[T]), T = S / 10 | 0, S %= 10, F.push(n[10 + T]), F.push(n[20 + S]);
            const O = F.join("");
            return A ? O.toLowerCase() : O;
          }
          function x(S) {
            return S <= 0 ? 0 : Math.ceil(Math.log2(S));
          }
          function f(S, A) {
            return S[A] << 24 >> 24;
          }
          function m(S, A) {
            return S[A] << 8 | S[A + 1];
          }
          function C(S, A) {
            return (S[A] << 24 | S[A + 1] << 16 | S[A + 2] << 8 | S[A + 3]) >>> 0;
          }
          function p(S) {
            return S === 32 || S === 9 || S === 13 || S === 10;
          }
          function w(S) {
            const A = /(.+)\[(\d+)\]$/;
            return S.split(".").map((F) => {
              const T = F.match(A);
              return T ? {
                name: T[1],
                pos: parseInt(T[2], 10)
              } : {
                name: F,
                pos: 0
              };
            });
          }
          function X(S) {
            const A = [];
            let F = 0;
            for (let T = 0, O = S.length; T < O; T++) {
              const U = S.charCodeAt(T);
              (U < 33 || U > 126 || U === 35 || U === 40 || U === 41 || U === 60 || U === 62 || U === 91 || U === 93 || U === 123 || U === 125 || U === 47 || U === 37) && (F < T && A.push(S.substring(F, T)), A.push(`#${U.toString(16)}`), F = T + 1);
            }
            return A.length === 0 ? S : (F < S.length && A.push(S.substring(F, S.length)), A.join(""));
          }
          function M(S, A, F, T) {
            if (!S)
              return;
            let O = null;
            if (S instanceof i.Ref) {
              if (T.has(S))
                return;
              O = S, T.put(O), S = A.fetch(S);
            }
            if (Array.isArray(S))
              for (const U of S)
                M(U, A, F, T);
            else if (S instanceof i.Dict) {
              if ((0, i.isName)(S.get("S"), "JavaScript")) {
                const U = S.get("JS");
                let G;
                U instanceof v.BaseStream ? G = U.getString() : typeof U == "string" && (G = U), G = G && (0, t.stringToPDFString)(G).replace(/\u0000/g, ""), G && F.push(G);
              }
              M(S.getRaw("Next"), A, F, T);
            }
            O && T.remove(O);
          }
          function j(S, A, F) {
            const T = /* @__PURE__ */ Object.create(null), O = c({
              dict: A,
              key: "AA",
              stopWhenFound: !1
            });
            if (O)
              for (let U = O.length - 1; U >= 0; U--) {
                const G = O[U];
                if (G instanceof i.Dict)
                  for (const K of G.getKeys()) {
                    const W = F[K];
                    if (!W)
                      continue;
                    const z = G.getRaw(K), V = new i.RefSet(), L = [];
                    M(z, S, L, V), L.length > 0 && (T[W] = L);
                  }
              }
            if (A.has("A")) {
              const U = A.get("A"), G = new i.RefSet(), K = [];
              M(U, S, K, G), K.length > 0 && (T.Action = K);
            }
            return (0, t.objectSize)(T) > 0 ? T : null;
          }
          const B = {
            60: "&lt;",
            62: "&gt;",
            38: "&amp;",
            34: "&quot;",
            39: "&apos;"
          };
          function R(S) {
            const A = [];
            let F = 0;
            for (let T = 0, O = S.length; T < O; T++) {
              const U = S.codePointAt(T);
              if (32 <= U && U <= 126) {
                const G = B[U];
                G && (F < T && A.push(S.substring(F, T)), A.push(G), F = T + 1);
              } else
                F < T && A.push(S.substring(F, T)), A.push(`&#x${U.toString(16).toUpperCase()};`), U > 55295 && (U < 57344 || U > 65533) && T++, F = T + 1;
            }
            return A.length === 0 ? S : (F < S.length && A.push(S.substring(F, S.length)), A.join(""));
          }
          function D(S) {
            const A = "14", F = "400", T = /* @__PURE__ */ new Set(["100", "200", "300", "400", "500", "600", "700", "800", "900", "1000", "normal", "bold", "bolder", "lighter"]), {
              fontFamily: O,
              fontWeight: U,
              italicAngle: G
            } = S;
            if (/^".*"$/.test(O)) {
              if (/[^\\]"/.test(O.slice(1, O.length - 1)))
                return (0, t.warn)(`XFA - FontFamily contains some unescaped ": ${O}.`), !1;
            } else if (/^'.*'$/.test(O)) {
              if (/[^\\]'/.test(O.slice(1, O.length - 1)))
                return (0, t.warn)(`XFA - FontFamily contains some unescaped ': ${O}.`), !1;
            } else
              for (const z of O.split(/[ \t]+/))
                if (/^(\d|(-(\d|-)))/.test(z) || !/^[\w-\\]+$/.test(z))
                  return (0, t.warn)(`XFA - FontFamily contains some invalid <custom-ident>: ${O}.`), !1;
            const K = U ? U.toString() : "";
            S.fontWeight = T.has(K) ? K : F;
            const W = parseFloat(G);
            return S.italicAngle = isNaN(W) || W < -90 || W > 90 ? A : G.toString(), !0;
          }
          function b(S) {
            const A = ["app.launchURL", "window.open", "xfa.host.gotoURL"], T = new RegExp("^\\s*(" + A.join("|").split(".").join("\\.") + `)\\((?:'|")([^'"]*)(?:'|")(?:,\\s*(\\w+)\\)|\\))`, "i").exec(S);
            if (T && T[2]) {
              const O = T[2];
              let U = !1;
              return T[3] === "true" && T[1] === "app.launchURL" && (U = !0), {
                url: O,
                newWindow: U
              };
            }
            return null;
          }
          function l(S) {
            if (Number.isInteger(S))
              return S.toString();
            const A = Math.round(S * 100);
            return A % 100 === 0 ? (A / 100).toString() : A % 10 === 0 ? S.toFixed(1) : S.toFixed(2);
          }
          function _(S) {
            if (!S)
              return null;
            const A = /* @__PURE__ */ new Map();
            for (const [F, T] of S) {
              if (!F.startsWith(t.AnnotationEditorPrefix))
                continue;
              let O = A.get(T.pageIndex);
              O || (O = [], A.set(T.pageIndex, O)), O.push(T);
            }
            return A.size > 0 ? A : null;
          }
        },
        /* 7 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.BaseStream = void 0;
          var t = P(2);
          class i {
            constructor() {
              this.constructor === i && (0, t.unreachable)("Cannot initialize BaseStream.");
            }
            get length() {
              (0, t.unreachable)("Abstract getter `length` accessed");
            }
            get isEmpty() {
              (0, t.unreachable)("Abstract getter `isEmpty` accessed");
            }
            get isDataLoaded() {
              return (0, t.shadow)(this, "isDataLoaded", !0);
            }
            getByte() {
              (0, t.unreachable)("Abstract method `getByte` called");
            }
            getBytes(a) {
              (0, t.unreachable)("Abstract method `getBytes` called");
            }
            peekByte() {
              const a = this.getByte();
              return a !== -1 && this.pos--, a;
            }
            peekBytes(a) {
              const e = this.getBytes(a);
              return this.pos -= e.length, e;
            }
            getUint16() {
              const a = this.getByte(), e = this.getByte();
              return a === -1 || e === -1 ? -1 : (a << 8) + e;
            }
            getInt32() {
              const a = this.getByte(), e = this.getByte(), y = this.getByte(), r = this.getByte();
              return (a << 24) + (e << 16) + (y << 8) + r;
            }
            getByteRange(a, e) {
              (0, t.unreachable)("Abstract method `getByteRange` called");
            }
            getString(a) {
              return (0, t.bytesToString)(this.getBytes(a));
            }
            skip(a) {
              this.pos += a || 1;
            }
            reset() {
              (0, t.unreachable)("Abstract method `reset` called");
            }
            moveStart() {
              (0, t.unreachable)("Abstract method `moveStart` called");
            }
            makeSubStream(a, e, y = null) {
              (0, t.unreachable)("Abstract method `makeSubStream` called");
            }
            getBaseStreams() {
              return null;
            }
          }
          u.BaseStream = i;
        },
        /* 8 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.NetworkPdfManager = u.LocalPdfManager = void 0;
          var t = P(2), i = P(9), v = P(6), a = P(11), e = P(10);
          function y(d) {
            if (d) {
              const c = (0, t.createValidAbsoluteUrl)(d);
              if (c)
                return c.href;
              (0, t.warn)(`Invalid absolute docBaseUrl: "${d}".`);
            }
            return null;
          }
          class r {
            constructor() {
              this.constructor === r && (0, t.unreachable)("Cannot initialize BasePdfManager.");
            }
            get docId() {
              return this._docId;
            }
            get password() {
              return this._password;
            }
            get docBaseUrl() {
              const c = this.pdfDocument.catalog;
              return (0, t.shadow)(this, "docBaseUrl", c.baseUrl || this._docBaseUrl);
            }
            onLoadedStream() {
              (0, t.unreachable)("Abstract method `onLoadedStream` called");
            }
            ensureDoc(c, n) {
              return this.ensure(this.pdfDocument, c, n);
            }
            ensureXRef(c, n) {
              return this.ensure(this.pdfDocument.xref, c, n);
            }
            ensureCatalog(c, n) {
              return this.ensure(this.pdfDocument.catalog, c, n);
            }
            getPage(c) {
              return this.pdfDocument.getPage(c);
            }
            fontFallback(c, n) {
              return this.pdfDocument.fontFallback(c, n);
            }
            loadXfaFonts(c, n) {
              return this.pdfDocument.loadXfaFonts(c, n);
            }
            loadXfaImages() {
              return this.pdfDocument.loadXfaImages();
            }
            serializeXfaData(c) {
              return this.pdfDocument.serializeXfaData(c);
            }
            cleanup(c = !1) {
              return this.pdfDocument.cleanup(c);
            }
            async ensure(c, n, o) {
              (0, t.unreachable)("Abstract method `ensure` called");
            }
            requestRange(c, n) {
              (0, t.unreachable)("Abstract method `requestRange` called");
            }
            requestLoadedStream() {
              (0, t.unreachable)("Abstract method `requestLoadedStream` called");
            }
            sendProgressiveData(c) {
              (0, t.unreachable)("Abstract method `sendProgressiveData` called");
            }
            updatePassword(c) {
              this._password = c;
            }
            terminate(c) {
              (0, t.unreachable)("Abstract method `terminate` called");
            }
          }
          class h extends r {
            constructor(c, n, o, x, f, m, C) {
              super(), this._docId = c, this._password = o, this._docBaseUrl = y(C), this.msgHandler = x, this.evaluatorOptions = f, this.enableXfa = m;
              const p = new e.Stream(n);
              this.pdfDocument = new a.PDFDocument(this, p), this._loadedStreamPromise = Promise.resolve(p);
            }
            async ensure(c, n, o) {
              const x = c[n];
              return typeof x == "function" ? x.apply(c, o) : x;
            }
            requestRange(c, n) {
              return Promise.resolve();
            }
            requestLoadedStream() {
            }
            onLoadedStream() {
              return this._loadedStreamPromise;
            }
            terminate(c) {
            }
          }
          u.LocalPdfManager = h;
          class g extends r {
            constructor(c, n, o, x, f, m) {
              super(), this._docId = c, this._password = o.password, this._docBaseUrl = y(m), this.msgHandler = o.msgHandler, this.evaluatorOptions = x, this.enableXfa = f, this.streamManager = new i.ChunkedStreamManager(n, {
                msgHandler: o.msgHandler,
                length: o.length,
                disableAutoFetch: o.disableAutoFetch,
                rangeChunkSize: o.rangeChunkSize
              }), this.pdfDocument = new a.PDFDocument(this, this.streamManager.getStream());
            }
            async ensure(c, n, o) {
              try {
                const x = c[n];
                return typeof x == "function" ? x.apply(c, o) : x;
              } catch (x) {
                if (!(x instanceof v.MissingDataException))
                  throw x;
                return await this.requestRange(x.begin, x.end), this.ensure(c, n, o);
              }
            }
            requestRange(c, n) {
              return this.streamManager.requestRange(c, n);
            }
            requestLoadedStream() {
              this.streamManager.requestAllChunks();
            }
            sendProgressiveData(c) {
              this.streamManager.onReceiveData({
                chunk: c
              });
            }
            onLoadedStream() {
              return this.streamManager.onLoadedStream();
            }
            terminate(c) {
              this.streamManager.abort(c);
            }
          }
          u.NetworkPdfManager = g;
        },
        /* 9 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.ChunkedStreamManager = u.ChunkedStream = void 0;
          var t = P(2), i = P(6), v = P(10);
          class a extends v.Stream {
            constructor(r, h, g) {
              super(new Uint8Array(r), 0, r, null), this.chunkSize = h, this._loadedChunks = /* @__PURE__ */ new Set(), this.numChunks = Math.ceil(r / h), this.manager = g, this.progressiveDataLength = 0, this.lastSuccessfulEnsureByteChunk = -1;
            }
            getMissingChunks() {
              const r = [];
              for (let h = 0, g = this.numChunks; h < g; ++h)
                this._loadedChunks.has(h) || r.push(h);
              return r;
            }
            get numChunksLoaded() {
              return this._loadedChunks.size;
            }
            get isDataLoaded() {
              return this.numChunksLoaded === this.numChunks;
            }
            onReceiveData(r, h) {
              const g = this.chunkSize;
              if (r % g !== 0)
                throw new Error(`Bad begin offset: ${r}`);
              const d = r + h.byteLength;
              if (d % g !== 0 && d !== this.bytes.length)
                throw new Error(`Bad end offset: ${d}`);
              this.bytes.set(new Uint8Array(h), r);
              const c = Math.floor(r / g), n = Math.floor((d - 1) / g) + 1;
              for (let o = c; o < n; ++o)
                this._loadedChunks.add(o);
            }
            onReceiveProgressiveData(r) {
              let h = this.progressiveDataLength;
              const g = Math.floor(h / this.chunkSize);
              this.bytes.set(new Uint8Array(r), h), h += r.byteLength, this.progressiveDataLength = h;
              const d = h >= this.end ? this.numChunks : Math.floor(h / this.chunkSize);
              for (let c = g; c < d; ++c)
                this._loadedChunks.add(c);
            }
            ensureByte(r) {
              if (r < this.progressiveDataLength)
                return;
              const h = Math.floor(r / this.chunkSize);
              if (!(h > this.numChunks) && h !== this.lastSuccessfulEnsureByteChunk) {
                if (!this._loadedChunks.has(h))
                  throw new i.MissingDataException(r, r + 1);
                this.lastSuccessfulEnsureByteChunk = h;
              }
            }
            ensureRange(r, h) {
              if (r >= h || h <= this.progressiveDataLength)
                return;
              const g = Math.floor(r / this.chunkSize);
              if (g > this.numChunks)
                return;
              const d = Math.min(Math.floor((h - 1) / this.chunkSize) + 1, this.numChunks);
              for (let c = g; c < d; ++c)
                if (!this._loadedChunks.has(c))
                  throw new i.MissingDataException(r, h);
            }
            nextEmptyChunk(r) {
              const h = this.numChunks;
              for (let g = 0; g < h; ++g) {
                const d = (r + g) % h;
                if (!this._loadedChunks.has(d))
                  return d;
              }
              return null;
            }
            hasChunk(r) {
              return this._loadedChunks.has(r);
            }
            getByte() {
              const r = this.pos;
              return r >= this.end ? -1 : (r >= this.progressiveDataLength && this.ensureByte(r), this.bytes[this.pos++]);
            }
            getBytes(r) {
              const h = this.bytes, g = this.pos, d = this.end;
              if (!r)
                return d > this.progressiveDataLength && this.ensureRange(g, d), h.subarray(g, d);
              let c = g + r;
              return c > d && (c = d), c > this.progressiveDataLength && this.ensureRange(g, c), this.pos = c, h.subarray(g, c);
            }
            getByteRange(r, h) {
              return r < 0 && (r = 0), h > this.end && (h = this.end), h > this.progressiveDataLength && this.ensureRange(r, h), this.bytes.subarray(r, h);
            }
            makeSubStream(r, h, g = null) {
              h ? r + h > this.progressiveDataLength && this.ensureRange(r, r + h) : r >= this.progressiveDataLength && this.ensureByte(r);
              function d() {
              }
              d.prototype = Object.create(this), d.prototype.getMissingChunks = function() {
                const n = this.chunkSize, o = Math.floor(this.start / n), x = Math.floor((this.end - 1) / n) + 1, f = [];
                for (let m = o; m < x; ++m)
                  this._loadedChunks.has(m) || f.push(m);
                return f;
              }, Object.defineProperty(d.prototype, "isDataLoaded", {
                get() {
                  return this.numChunksLoaded === this.numChunks ? !0 : this.getMissingChunks().length === 0;
                },
                configurable: !0
              });
              const c = new d();
              return c.pos = c.start = r, c.end = r + h || this.end, c.dict = g, c;
            }
            getBaseStreams() {
              return [this];
            }
          }
          u.ChunkedStream = a;
          class e {
            constructor(r, h) {
              this.length = h.length, this.chunkSize = h.rangeChunkSize, this.stream = new a(this.length, this.chunkSize, this), this.pdfNetworkStream = r, this.disableAutoFetch = h.disableAutoFetch, this.msgHandler = h.msgHandler, this.currRequestId = 0, this._chunksNeededByRequest = /* @__PURE__ */ new Map(), this._requestsByChunk = /* @__PURE__ */ new Map(), this._promisesByRequest = /* @__PURE__ */ new Map(), this.progressiveDataLength = 0, this.aborted = !1, this._loadedStreamCapability = (0, t.createPromiseCapability)();
            }
            onLoadedStream() {
              return this._loadedStreamCapability.promise;
            }
            sendRequest(r, h) {
              const g = this.pdfNetworkStream.getRangeReader(r, h);
              g.isStreamingSupported || (g.onProgress = this.onProgress.bind(this));
              let d = [], c = 0;
              return new Promise((n, o) => {
                const x = (f) => {
                  try {
                    if (!f.done) {
                      const C = f.value;
                      d.push(C), c += (0, t.arrayByteLength)(C), g.isStreamingSupported && this.onProgress({
                        loaded: c
                      }), g.read().then(x, o);
                      return;
                    }
                    const m = (0, t.arraysToBytes)(d);
                    d = null, n(m);
                  } catch (m) {
                    o(m);
                  }
                };
                g.read().then(x, o);
              }).then((n) => {
                this.aborted || this.onReceiveData({
                  chunk: n,
                  begin: r
                });
              });
            }
            requestAllChunks() {
              const r = this.stream.getMissingChunks();
              return this._requestChunks(r), this._loadedStreamCapability.promise;
            }
            _requestChunks(r) {
              const h = this.currRequestId++, g = /* @__PURE__ */ new Set();
              this._chunksNeededByRequest.set(h, g);
              for (const n of r)
                this.stream.hasChunk(n) || g.add(n);
              if (g.size === 0)
                return Promise.resolve();
              const d = (0, t.createPromiseCapability)();
              this._promisesByRequest.set(h, d);
              const c = [];
              for (const n of g) {
                let o = this._requestsByChunk.get(n);
                o || (o = [], this._requestsByChunk.set(n, o), c.push(n)), o.push(h);
              }
              if (c.length > 0) {
                const n = this.groupChunks(c);
                for (const o of n) {
                  const x = o.beginChunk * this.chunkSize, f = Math.min(o.endChunk * this.chunkSize, this.length);
                  this.sendRequest(x, f).catch(d.reject);
                }
              }
              return d.promise.catch((n) => {
                if (!this.aborted)
                  throw n;
              });
            }
            getStream() {
              return this.stream;
            }
            requestRange(r, h) {
              h = Math.min(h, this.length);
              const g = this.getBeginChunk(r), d = this.getEndChunk(h), c = [];
              for (let n = g; n < d; ++n)
                c.push(n);
              return this._requestChunks(c);
            }
            requestRanges(r = []) {
              const h = [];
              for (const g of r) {
                const d = this.getBeginChunk(g.begin), c = this.getEndChunk(g.end);
                for (let n = d; n < c; ++n)
                  h.includes(n) || h.push(n);
              }
              return h.sort(function(g, d) {
                return g - d;
              }), this._requestChunks(h);
            }
            groupChunks(r) {
              const h = [];
              let g = -1, d = -1;
              for (let c = 0, n = r.length; c < n; ++c) {
                const o = r[c];
                g < 0 && (g = o), d >= 0 && d + 1 !== o && (h.push({
                  beginChunk: g,
                  endChunk: d + 1
                }), g = o), c + 1 === r.length && h.push({
                  beginChunk: g,
                  endChunk: o + 1
                }), d = o;
              }
              return h;
            }
            onProgress(r) {
              this.msgHandler.send("DocProgress", {
                loaded: this.stream.numChunksLoaded * this.chunkSize + r.loaded,
                total: this.length
              });
            }
            onReceiveData(r) {
              const h = r.chunk, g = r.begin === void 0, d = g ? this.progressiveDataLength : r.begin, c = d + h.byteLength, n = Math.floor(d / this.chunkSize), o = c < this.length ? Math.floor(c / this.chunkSize) : Math.ceil(c / this.chunkSize);
              g ? (this.stream.onReceiveProgressiveData(h), this.progressiveDataLength = c) : this.stream.onReceiveData(d, h), this.stream.isDataLoaded && this._loadedStreamCapability.resolve(this.stream);
              const x = [];
              for (let f = n; f < o; ++f) {
                const m = this._requestsByChunk.get(f);
                if (m) {
                  this._requestsByChunk.delete(f);
                  for (const C of m) {
                    const p = this._chunksNeededByRequest.get(C);
                    p.has(f) && p.delete(f), !(p.size > 0) && x.push(C);
                  }
                }
              }
              if (!this.disableAutoFetch && this._requestsByChunk.size === 0) {
                let f;
                if (this.stream.numChunksLoaded === 1) {
                  const m = this.stream.numChunks - 1;
                  this.stream.hasChunk(m) || (f = m);
                } else
                  f = this.stream.nextEmptyChunk(o);
                Number.isInteger(f) && this._requestChunks([f]);
              }
              for (const f of x) {
                const m = this._promisesByRequest.get(f);
                this._promisesByRequest.delete(f), m.resolve();
              }
              this.msgHandler.send("DocProgress", {
                loaded: this.stream.numChunksLoaded * this.chunkSize,
                total: this.length
              });
            }
            onError(r) {
              this._loadedStreamCapability.reject(r);
            }
            getBeginChunk(r) {
              return Math.floor(r / this.chunkSize);
            }
            getEndChunk(r) {
              return Math.floor((r - 1) / this.chunkSize) + 1;
            }
            abort(r) {
              this.aborted = !0, this.pdfNetworkStream && this.pdfNetworkStream.cancelAllRequests(r);
              for (const h of this._promisesByRequest.values())
                h.reject(r);
            }
          }
          u.ChunkedStreamManager = e;
        },
        /* 10 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.StringStream = u.Stream = u.NullStream = void 0;
          var t = P(7), i = P(2);
          class v extends t.BaseStream {
            constructor(r, h, g, d) {
              super(), this.bytes = r instanceof Uint8Array ? r : new Uint8Array(r), this.start = h || 0, this.pos = this.start, this.end = h + g || this.bytes.length, this.dict = d;
            }
            get length() {
              return this.end - this.start;
            }
            get isEmpty() {
              return this.length === 0;
            }
            getByte() {
              return this.pos >= this.end ? -1 : this.bytes[this.pos++];
            }
            getBytes(r) {
              const h = this.bytes, g = this.pos, d = this.end;
              if (!r)
                return h.subarray(g, d);
              let c = g + r;
              return c > d && (c = d), this.pos = c, h.subarray(g, c);
            }
            getByteRange(r, h) {
              return r < 0 && (r = 0), h > this.end && (h = this.end), this.bytes.subarray(r, h);
            }
            reset() {
              this.pos = this.start;
            }
            moveStart() {
              this.start = this.pos;
            }
            makeSubStream(r, h, g = null) {
              return new v(this.bytes.buffer, r, h, g);
            }
          }
          u.Stream = v;
          class a extends v {
            constructor(r) {
              super((0, i.stringToBytes)(r));
            }
          }
          u.StringStream = a;
          class e extends v {
            constructor() {
              super(new Uint8Array(0));
            }
          }
          u.NullStream = e;
        },
        /* 11 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.Page = u.PDFDocument = void 0;
          var t = P(12), i = P(2), v = P(6), a = P(5), e = P(51), y = P(7), r = P(67), h = P(69), g = P(71), d = P(100), c = P(17), n = P(10), o = P(75), x = P(62), f = P(15), m = P(19), C = P(74), p = P(65), w = P(76), X = P(101);
          const M = 1, j = [0, 0, 612, 792];
          class B {
            constructor({
              pdfManager: O,
              xref: U,
              pageIndex: G,
              pageDict: K,
              ref: W,
              globalIdFactory: z,
              fontCache: V,
              builtInCMapCache: L,
              standardFontDataCache: Y,
              globalImageCache: J,
              nonBlendModesSet: ie,
              xfaFactory: q
            }) {
              this.pdfManager = O, this.pageIndex = G, this.pageDict = K, this.xref = U, this.ref = W, this.fontCache = V, this.builtInCMapCache = L, this.standardFontDataCache = Y, this.globalImageCache = J, this.nonBlendModesSet = ie, this.evaluatorOptions = O.evaluatorOptions, this.resourcesPromise = null, this.xfaFactory = q;
              const N = {
                obj: 0
              };
              this._localIdFactory = class extends z {
                static createObjId() {
                  return `p${G}_${++N.obj}`;
                }
                static getPageObjId() {
                  return `page${W.toString()}`;
                }
              };
            }
            _getInheritableProperty(O, U = !1) {
              const G = (0, v.getInheritableProperty)({
                dict: this.pageDict,
                key: O,
                getArray: U,
                stopWhenFound: !1
              });
              return Array.isArray(G) ? G.length === 1 || !(G[0] instanceof a.Dict) ? G[0] : a.Dict.merge({
                xref: this.xref,
                dictArray: G
              }) : G;
            }
            get content() {
              return this.pageDict.getArray("Contents");
            }
            get resources() {
              const O = this._getInheritableProperty("Resources");
              return (0, i.shadow)(this, "resources", O instanceof a.Dict ? O : a.Dict.empty);
            }
            _getBoundingBox(O) {
              if (this.xfaData)
                return this.xfaData.bbox;
              const U = this._getInheritableProperty(O, !0);
              if (Array.isArray(U) && U.length === 4) {
                if (U[2] - U[0] !== 0 && U[3] - U[1] !== 0)
                  return U;
                (0, i.warn)(`Empty /${O} entry.`);
              }
              return null;
            }
            get mediaBox() {
              return (0, i.shadow)(this, "mediaBox", this._getBoundingBox("MediaBox") || j);
            }
            get cropBox() {
              return (0, i.shadow)(this, "cropBox", this._getBoundingBox("CropBox") || this.mediaBox);
            }
            get userUnit() {
              let O = this.pageDict.get("UserUnit");
              return (typeof O != "number" || O <= 0) && (O = M), (0, i.shadow)(this, "userUnit", O);
            }
            get view() {
              const {
                cropBox: O,
                mediaBox: U
              } = this;
              let G;
              if (O === U || (0, i.isArrayEqual)(O, U))
                G = U;
              else {
                const K = i.Util.intersect(O, U);
                K && K[2] - K[0] !== 0 && K[3] - K[1] !== 0 ? G = K : (0, i.warn)("Empty /CropBox and /MediaBox intersection.");
              }
              return (0, i.shadow)(this, "view", G || U);
            }
            get rotate() {
              let O = this._getInheritableProperty("Rotate") || 0;
              return O % 90 !== 0 ? O = 0 : O >= 360 ? O %= 360 : O < 0 && (O = (O % 360 + 360) % 360), (0, i.shadow)(this, "rotate", O);
            }
            _onSubStreamError(O, U, G) {
              if (this.evaluatorOptions.ignoreErrors) {
                O.send("UnsupportedFeature", {
                  featureId: i.UNSUPPORTED_FEATURES.errorContentSubStream
                }), (0, i.warn)(`getContentStream - ignoring sub-stream (${G}): "${U}".`);
                return;
              }
              throw U;
            }
            getContentStream(O) {
              return this.pdfManager.ensure(this, "content").then((U) => U instanceof y.BaseStream ? U : Array.isArray(U) ? new m.StreamsSequenceStream(U, this._onSubStreamError.bind(this, O)) : new n.NullStream());
            }
            get xfaData() {
              return (0, i.shadow)(this, "xfaData", this.xfaFactory ? {
                bbox: this.xfaFactory.getBoundingBox(this.pageIndex)
              } : null);
            }
            async saveNewAnnotations(O, U, G) {
              if (this.xfaFactory)
                throw new Error("XFA: Cannot save new annotations.");
              const K = new f.PartialEvaluator({
                xref: this.xref,
                handler: O,
                pageIndex: this.pageIndex,
                idFactory: this._localIdFactory,
                fontCache: this.fontCache,
                builtInCMapCache: this.builtInCMapCache,
                standardFontDataCache: this.standardFontDataCache,
                globalImageCache: this.globalImageCache,
                options: this.evaluatorOptions
              }), W = this.pageDict, z = this.annotations.slice(), V = await t.AnnotationFactory.saveNewAnnotations(K, U, G);
              for (const {
                ref: q
              } of V.annotations)
                z.push(q);
              const L = W.get("Annots");
              W.set("Annots", z);
              const Y = [];
              let J = null;
              this.xref.encrypt && (J = this.xref.encrypt.createCipherTransform(this.ref.num, this.ref.gen)), (0, p.writeObject)(this.ref, W, Y, J), L && W.set("Annots", L);
              const ie = V.dependencies;
              return ie.push({
                ref: this.ref,
                data: Y.join("")
              }, ...V.annotations), ie;
            }
            save(O, U, G) {
              const K = new f.PartialEvaluator({
                xref: this.xref,
                handler: O,
                pageIndex: this.pageIndex,
                idFactory: this._localIdFactory,
                fontCache: this.fontCache,
                builtInCMapCache: this.builtInCMapCache,
                standardFontDataCache: this.standardFontDataCache,
                globalImageCache: this.globalImageCache,
                options: this.evaluatorOptions
              });
              return this._parsedAnnotations.then(function(W) {
                const z = [];
                for (const V of W)
                  V.mustBePrinted(G) && z.push(V.save(K, U, G).catch(function(L) {
                    return (0, i.warn)(`save - ignoring annotation data during "${U.name}" task: "${L}".`), null;
                  }));
                return Promise.all(z).then(function(V) {
                  return V.filter((L) => !!L);
                });
              });
            }
            loadResources(O) {
              return this.resourcesPromise || (this.resourcesPromise = this.pdfManager.ensure(this, "resources")), this.resourcesPromise.then(() => new o.ObjectLoader(this.resources, O, this.xref).load());
            }
            getOperatorList({
              handler: O,
              sink: U,
              task: G,
              intent: K,
              cacheKey: W,
              annotationStorage: z = null
            }) {
              const V = this.getContentStream(O), L = this.loadResources(["ColorSpace", "ExtGState", "Font", "Pattern", "Properties", "Shading", "XObject"]), Y = new f.PartialEvaluator({
                xref: this.xref,
                handler: O,
                pageIndex: this.pageIndex,
                idFactory: this._localIdFactory,
                fontCache: this.fontCache,
                builtInCMapCache: this.builtInCMapCache,
                standardFontDataCache: this.standardFontDataCache,
                globalImageCache: this.globalImageCache,
                options: this.evaluatorOptions
              }), J = this.xfaFactory ? null : (0, v.getNewAnnotationsMap)(z);
              let ie = Promise.resolve(null);
              if (J) {
                const Z = J.get(this.pageIndex);
                Z && (ie = t.AnnotationFactory.printNewAnnotations(Y, G, Z));
              }
              const N = Promise.all([V, L]).then(([Z]) => {
                const E = new x.OperatorList(K, U);
                return O.send("StartRenderPage", {
                  transparency: Y.hasBlendModes(this.resources, this.nonBlendModesSet),
                  pageIndex: this.pageIndex,
                  cacheKey: W
                }), Y.getOperatorList({
                  stream: Z,
                  task: G,
                  resources: this.resources,
                  operatorList: E
                }).then(function() {
                  return E;
                });
              });
              return Promise.all([N, this._parsedAnnotations, ie]).then(function([Z, E, te]) {
                if (te && (E = E.concat(te)), E.length === 0 || K & i.RenderingIntentFlag.ANNOTATIONS_DISABLE)
                  return Z.flush(!0), {
                    length: Z.totalLength
                  };
                const re = !!(K & i.RenderingIntentFlag.ANNOTATIONS_FORMS), ee = !!(K & i.RenderingIntentFlag.ANY), $ = !!(K & i.RenderingIntentFlag.DISPLAY), k = !!(K & i.RenderingIntentFlag.PRINT), H = [];
                for (const ne of E)
                  (ee || $ && ne.mustBeViewed(z) || k && ne.mustBePrinted(z)) && H.push(ne.getOperatorList(Y, G, K, re, z).catch(function(ae) {
                    return (0, i.warn)(`getOperatorList - ignoring annotation data during "${G.name}" task: "${ae}".`), null;
                  }));
                return Promise.all(H).then(function(ne) {
                  let ae = !1, he = !1;
                  for (const {
                    opList: ue,
                    separateForm: fe,
                    separateCanvas: me
                  } of ne)
                    Z.addOpList(ue), fe && (ae = fe), me && (he = me);
                  return Z.flush(!0, {
                    form: ae,
                    canvas: he
                  }), {
                    length: Z.totalLength
                  };
                });
              });
            }
            extractTextContent({
              handler: O,
              task: U,
              includeMarkedContent: G,
              sink: K,
              combineTextItems: W
            }) {
              const z = this.getContentStream(O), V = this.loadResources(["ExtGState", "Font", "Properties", "XObject"]);
              return Promise.all([z, V]).then(([Y]) => new f.PartialEvaluator({
                xref: this.xref,
                handler: O,
                pageIndex: this.pageIndex,
                idFactory: this._localIdFactory,
                fontCache: this.fontCache,
                builtInCMapCache: this.builtInCMapCache,
                standardFontDataCache: this.standardFontDataCache,
                globalImageCache: this.globalImageCache,
                options: this.evaluatorOptions
              }).getTextContent({
                stream: Y,
                task: U,
                resources: this.resources,
                includeMarkedContent: G,
                combineTextItems: W,
                sink: K,
                viewBox: this.view
              }));
            }
            async getStructTree() {
              const O = await this.pdfManager.ensureCatalog("structTreeRoot");
              return O ? (await this.pdfManager.ensure(this, "_parseStructTree", [O])).serializable : null;
            }
            _parseStructTree(O) {
              const U = new C.StructTreePage(O, this.pageDict);
              return U.parse(), U;
            }
            async getAnnotationsData(O, U, G) {
              const K = await this._parsedAnnotations;
              if (K.length === 0)
                return [];
              const W = [], z = [];
              let V;
              const L = !!(G & i.RenderingIntentFlag.ANY), Y = !!(G & i.RenderingIntentFlag.DISPLAY), J = !!(G & i.RenderingIntentFlag.PRINT);
              for (const ie of K) {
                const q = L || Y && ie.viewable;
                (q || J && ie.printable) && z.push(ie.data), ie.hasTextContent && q && (V || (V = new f.PartialEvaluator({
                  xref: this.xref,
                  handler: O,
                  pageIndex: this.pageIndex,
                  idFactory: this._localIdFactory,
                  fontCache: this.fontCache,
                  builtInCMapCache: this.builtInCMapCache,
                  standardFontDataCache: this.standardFontDataCache,
                  globalImageCache: this.globalImageCache,
                  options: this.evaluatorOptions
                })), W.push(ie.extractTextContent(V, U, this.view).catch(function(N) {
                  (0, i.warn)(`getAnnotationsData - ignoring textContent during "${U.name}" task: "${N}".`);
                })));
              }
              return await Promise.all(W), z;
            }
            get annotations() {
              const O = this._getInheritableProperty("Annots");
              return (0, i.shadow)(this, "annotations", Array.isArray(O) ? O : []);
            }
            get _parsedAnnotations() {
              const O = this.pdfManager.ensure(this, "annotations").then(() => {
                const U = [];
                for (const G of this.annotations)
                  U.push(t.AnnotationFactory.create(this.xref, G, this.pdfManager, this._localIdFactory, !1).catch(function(K) {
                    return (0, i.warn)(`_parsedAnnotations: "${K}".`), null;
                  }));
                return Promise.all(U).then(function(G) {
                  if (G.length === 0)
                    return G;
                  const K = [];
                  let W;
                  for (const z of G)
                    if (z) {
                      if (z instanceof t.PopupAnnotation) {
                        W || (W = []), W.push(z);
                        continue;
                      }
                      K.push(z);
                    }
                  return W && K.push(...W), K;
                });
              });
              return (0, i.shadow)(this, "_parsedAnnotations", O);
            }
            get jsActions() {
              const O = (0, v.collectActions)(this.xref, this.pageDict, i.PageActionEventType);
              return (0, i.shadow)(this, "jsActions", O);
            }
          }
          u.Page = B;
          const R = new Uint8Array([37, 80, 68, 70, 45]), D = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]), b = new Uint8Array([101, 110, 100, 111, 98, 106]), l = 1024, _ = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", S = /^[1-9]\.\d$/;
          function A(T, O, U = 1024, G = !1) {
            const K = O.length, W = T.peekBytes(U), z = W.length - K;
            if (z <= 0)
              return !1;
            if (G) {
              const V = K - 1;
              let L = W.length - 1;
              for (; L >= V; ) {
                let Y = 0;
                for (; Y < K && W[L - Y] === O[V - Y]; )
                  Y++;
                if (Y >= K)
                  return T.pos += L - V, !0;
                L--;
              }
            } else {
              let V = 0;
              for (; V <= z; ) {
                let L = 0;
                for (; L < K && W[V + L] === O[L]; )
                  L++;
                if (L >= K)
                  return T.pos += V, !0;
                V++;
              }
            }
            return !1;
          }
          class F {
            constructor(O, U) {
              if (U.length <= 0)
                throw new i.InvalidPDFException("The PDF file is empty, i.e. its size is zero bytes.");
              this.pdfManager = O, this.stream = U, this.xref = new X.XRef(U, O), this._pagePromises = /* @__PURE__ */ new Map(), this._version = null;
              const G = {
                font: 0
              };
              this._globalIdFactory = class {
                static getDocId() {
                  return `g_${O.docId}`;
                }
                static createFontId() {
                  return `f${++G.font}`;
                }
                static createObjId() {
                  (0, i.unreachable)("Abstract method `createObjId` called.");
                }
                static getPageObjId() {
                  (0, i.unreachable)("Abstract method `getPageObjId` called.");
                }
              };
            }
            parse(O) {
              this.xref.parse(O), this.catalog = new h.Catalog(this.pdfManager, this.xref), this.catalog.version && (this._version = this.catalog.version);
            }
            get linearization() {
              let O = null;
              try {
                O = c.Linearization.create(this.stream);
              } catch (U) {
                if (U instanceof v.MissingDataException)
                  throw U;
                (0, i.info)(U);
              }
              return (0, i.shadow)(this, "linearization", O);
            }
            get startXRef() {
              const O = this.stream;
              let U = 0;
              if (this.linearization)
                O.reset(), A(O, b) && (U = O.pos + 6 - O.start);
              else {
                const K = D.length;
                let W = !1, z = O.end;
                for (; !W && z > 0; )
                  z -= 1024 - K, z < 0 && (z = 0), O.pos = z, W = A(O, D, 1024, !0);
                if (W) {
                  O.skip(9);
                  let V;
                  do
                    V = O.getByte();
                  while ((0, v.isWhiteSpace)(V));
                  let L = "";
                  for (; V >= 32 && V <= 57; )
                    L += String.fromCharCode(V), V = O.getByte();
                  U = parseInt(L, 10), isNaN(U) && (U = 0);
                }
              }
              return (0, i.shadow)(this, "startXRef", U);
            }
            checkHeader() {
              const O = this.stream;
              if (O.reset(), !A(O, R))
                return;
              O.moveStart();
              const U = 12;
              let G = "", K;
              for (; (K = O.getByte()) > 32 && !(G.length >= U); )
                G += String.fromCharCode(K);
              this._version || (this._version = G.substring(5));
            }
            parseStartXRef() {
              this.xref.setStartXRef(this.startXRef);
            }
            get numPages() {
              let O = 0;
              return this.catalog.hasActualNumPages ? O = this.catalog.numPages : this.xfaFactory ? O = this.xfaFactory.getNumPages() : this.linearization ? O = this.linearization.numPages : O = this.catalog.numPages, (0, i.shadow)(this, "numPages", O);
            }
            _hasOnlyDocumentSignatures(O, U = 0) {
              return Array.isArray(O) ? O.every((K) => {
                if (K = this.xref.fetchIfRef(K), !(K instanceof a.Dict))
                  return !1;
                if (K.has("Kids"))
                  return ++U > 10 ? ((0, i.warn)("_hasOnlyDocumentSignatures: maximum recursion depth reached"), !1) : this._hasOnlyDocumentSignatures(K.get("Kids"), U);
                const W = (0, a.isName)(K.get("FT"), "Sig"), z = K.get("Rect"), V = Array.isArray(z) && z.every((L) => L === 0);
                return W && V;
              }) : !1;
            }
            get _xfaStreams() {
              const O = this.catalog.acroForm;
              if (!O)
                return null;
              const U = O.get("XFA"), G = {
                "xdp:xdp": "",
                template: "",
                datasets: "",
                config: "",
                connectionSet: "",
                localeSet: "",
                stylesheet: "",
                "/xdp:xdp": ""
              };
              if (U instanceof y.BaseStream && !U.isEmpty)
                return G["xdp:xdp"] = U, G;
              if (!Array.isArray(U) || U.length === 0)
                return null;
              for (let K = 0, W = U.length; K < W; K += 2) {
                let z;
                if (K === 0 ? z = "xdp:xdp" : K === W - 2 ? z = "/xdp:xdp" : z = U[K], !G.hasOwnProperty(z))
                  continue;
                const V = this.xref.fetchIfRef(U[K + 1]);
                !(V instanceof y.BaseStream) || V.isEmpty || (G[z] = V);
              }
              return G;
            }
            get xfaDatasets() {
              const O = this._xfaStreams;
              if (!O)
                return (0, i.shadow)(this, "xfaDatasets", null);
              for (const U of ["datasets", "xdp:xdp"]) {
                const G = O[U];
                if (G)
                  try {
                    const K = (0, i.stringToUTF8String)(G.getString()), W = {
                      [U]: K
                    };
                    return (0, i.shadow)(this, "xfaDatasets", new d.DatasetReader(W));
                  } catch {
                    (0, i.warn)("XFA - Invalid utf-8 string.");
                    break;
                  }
              }
              return (0, i.shadow)(this, "xfaDatasets", null);
            }
            get xfaData() {
              const O = this._xfaStreams;
              if (!O)
                return null;
              const U = /* @__PURE__ */ Object.create(null);
              for (const [G, K] of Object.entries(O))
                if (K)
                  try {
                    U[G] = (0, i.stringToUTF8String)(K.getString());
                  } catch {
                    return (0, i.warn)("XFA - Invalid utf-8 string."), null;
                  }
              return U;
            }
            get xfaFactory() {
              let O;
              return this.pdfManager.enableXfa && this.catalog.needsRendering && this.formInfo.hasXfa && !this.formInfo.hasAcroForm && (O = this.xfaData), (0, i.shadow)(this, "xfaFactory", O ? new w.XFAFactory(O) : null);
            }
            get isPureXfa() {
              return this.xfaFactory ? this.xfaFactory.isValid() : !1;
            }
            get htmlForXfa() {
              return this.xfaFactory ? this.xfaFactory.getPages() : null;
            }
            async loadXfaImages() {
              const O = await this.pdfManager.ensureCatalog("xfaImages");
              if (!O)
                return;
              const U = O.getKeys();
              await new o.ObjectLoader(O, U, this.xref).load();
              const K = /* @__PURE__ */ new Map();
              for (const W of U) {
                const z = O.get(W);
                z instanceof y.BaseStream && K.set(W, z.getBytes());
              }
              this.xfaFactory.setImages(K);
            }
            async loadXfaFonts(O, U) {
              const G = await this.pdfManager.ensureCatalog("acroForm");
              if (!G)
                return;
              const K = await G.getAsync("DR");
              if (!(K instanceof a.Dict))
                return;
              await new o.ObjectLoader(K, ["Font"], this.xref).load();
              const z = K.get("Font");
              if (!(z instanceof a.Dict))
                return;
              const V = Object.assign(/* @__PURE__ */ Object.create(null), this.pdfManager.evaluatorOptions);
              V.useSystemFonts = !1;
              const L = new f.PartialEvaluator({
                xref: this.xref,
                handler: O,
                pageIndex: -1,
                idFactory: this._globalIdFactory,
                fontCache: this.catalog.fontCache,
                builtInCMapCache: this.catalog.builtInCMapCache,
                standardFontDataCache: this.catalog.standardFontDataCache,
                options: V
              }), Y = new x.OperatorList(), J = [], ie = {
                get font() {
                  return J.at(-1);
                },
                set font(te) {
                  J.push(te);
                },
                clone() {
                  return this;
                }
              }, q = /* @__PURE__ */ new Map();
              z.forEach((te, re) => {
                q.set(te, re);
              });
              const N = [];
              for (const [te, re] of q) {
                const ee = re.get("FontDescriptor");
                if (!(ee instanceof a.Dict))
                  continue;
                let $ = ee.get("FontFamily");
                $ = $.replace(/[ ]+(\d)/g, "$1");
                const k = ee.get("FontWeight"), H = -ee.get("ItalicAngle"), ne = {
                  fontFamily: $,
                  fontWeight: k,
                  italicAngle: H
                };
                (0, v.validateCSSFont)(ne) && N.push(L.handleSetFont(K, [a.Name.get(te), 1], null, Y, U, ie, null, ne).catch(function(ae) {
                  return (0, i.warn)(`loadXfaFonts: "${ae}".`), null;
                }));
              }
              await Promise.all(N);
              const Z = this.xfaFactory.setFonts(J);
              if (!Z)
                return;
              V.ignoreErrors = !0, N.length = 0, J.length = 0;
              const E = /* @__PURE__ */ new Set();
              for (const te of Z)
                (0, e.getXfaFontName)(`${te}-Regular`) || E.add(te);
              E.size && Z.push("PdfJS-Fallback");
              for (const te of Z)
                if (!E.has(te))
                  for (const re of [{
                    name: "Regular",
                    fontWeight: 400,
                    italicAngle: 0
                  }, {
                    name: "Bold",
                    fontWeight: 700,
                    italicAngle: 0
                  }, {
                    name: "Italic",
                    fontWeight: 400,
                    italicAngle: 12
                  }, {
                    name: "BoldItalic",
                    fontWeight: 700,
                    italicAngle: 12
                  }]) {
                    const ee = `${te}-${re.name}`, $ = (0, e.getXfaFontDict)(ee);
                    N.push(L.handleSetFont(K, [a.Name.get(ee), 1], null, Y, U, ie, $, {
                      fontFamily: te,
                      fontWeight: re.fontWeight,
                      italicAngle: re.italicAngle
                    }).catch(function(k) {
                      return (0, i.warn)(`loadXfaFonts: "${k}".`), null;
                    }));
                  }
              await Promise.all(N), this.xfaFactory.appendFonts(J, E);
            }
            async serializeXfaData(O) {
              return this.xfaFactory ? this.xfaFactory.serializeData(O) : null;
            }
            get formInfo() {
              const O = {
                hasFields: !1,
                hasAcroForm: !1,
                hasXfa: !1,
                hasSignatures: !1
              }, U = this.catalog.acroForm;
              if (!U)
                return (0, i.shadow)(this, "formInfo", O);
              try {
                const G = U.get("Fields"), K = Array.isArray(G) && G.length > 0;
                O.hasFields = K;
                const W = U.get("XFA");
                O.hasXfa = Array.isArray(W) && W.length > 0 || W instanceof y.BaseStream && !W.isEmpty;
                const V = !!(U.get("SigFlags") & 1), L = V && this._hasOnlyDocumentSignatures(G);
                O.hasAcroForm = K && !L, O.hasSignatures = V;
              } catch (G) {
                if (G instanceof v.MissingDataException)
                  throw G;
                (0, i.warn)(`Cannot fetch form information: "${G}".`);
              }
              return (0, i.shadow)(this, "formInfo", O);
            }
            get documentInfo() {
              let O = this._version;
              (typeof O != "string" || !S.test(O)) && ((0, i.warn)(`Invalid PDF header version number: ${O}`), O = null);
              const U = {
                PDFFormatVersion: O,
                Language: this.catalog.lang,
                EncryptFilterName: this.xref.encrypt ? this.xref.encrypt.filterName : null,
                IsLinearized: !!this.linearization,
                IsAcroFormPresent: this.formInfo.hasAcroForm,
                IsXFAPresent: this.formInfo.hasXfa,
                IsCollectionPresent: !!this.catalog.collection,
                IsSignaturesPresent: this.formInfo.hasSignatures
              };
              let G;
              try {
                G = this.xref.trailer.get("Info");
              } catch (K) {
                if (K instanceof v.MissingDataException)
                  throw K;
                (0, i.info)("The document information dictionary is invalid.");
              }
              if (!(G instanceof a.Dict))
                return (0, i.shadow)(this, "documentInfo", U);
              for (const K of G.getKeys()) {
                const W = G.get(K);
                switch (K) {
                  case "Title":
                  case "Author":
                  case "Subject":
                  case "Keywords":
                  case "Creator":
                  case "Producer":
                  case "CreationDate":
                  case "ModDate":
                    if (typeof W == "string") {
                      U[K] = (0, i.stringToPDFString)(W);
                      continue;
                    }
                    break;
                  case "Trapped":
                    if (W instanceof a.Name) {
                      U[K] = W;
                      continue;
                    }
                    break;
                  default:
                    let z;
                    switch (typeof W) {
                      case "string":
                        z = (0, i.stringToPDFString)(W);
                        break;
                      case "number":
                      case "boolean":
                        z = W;
                        break;
                      default:
                        W instanceof a.Name && (z = W);
                        break;
                    }
                    if (z === void 0) {
                      (0, i.warn)(`Bad value, for custom key "${K}", in Info: ${W}.`);
                      continue;
                    }
                    U.Custom || (U.Custom = /* @__PURE__ */ Object.create(null)), U.Custom[K] = z;
                    continue;
                }
                (0, i.warn)(`Bad value, for key "${K}", in Info: ${W}.`);
              }
              return (0, i.shadow)(this, "documentInfo", U);
            }
            get fingerprints() {
              function O(z) {
                return typeof z == "string" && z.length > 0 && z !== _;
              }
              function U(z) {
                const V = [];
                for (let L = 0, Y = z.length; L < Y; L++) {
                  const J = z[L].toString(16);
                  V.push(J.padStart(2, "0"));
                }
                return V.join("");
              }
              const G = this.xref.trailer.get("ID");
              let K, W;
              return Array.isArray(G) && O(G[0]) ? (K = (0, i.stringToBytes)(G[0]), G[1] !== G[0] && O(G[1]) && (W = (0, i.stringToBytes)(G[1]))) : K = (0, r.calculateMD5)(this.stream.getByteRange(0, l), 0, l), (0, i.shadow)(this, "fingerprints", [U(K), W ? U(W) : null]);
            }
            async _getLinearizationPage(O) {
              const {
                catalog: U,
                linearization: G,
                xref: K
              } = this, W = a.Ref.get(G.objectNumberFirst, 0);
              try {
                const z = await K.fetchAsync(W);
                if (z instanceof a.Dict) {
                  let V = z.getRaw("Type");
                  if (V instanceof a.Ref && (V = await K.fetchAsync(V)), (0, a.isName)(V, "Page") || !z.has("Type") && !z.has("Kids"))
                    return U.pageKidsCountCache.has(W) || U.pageKidsCountCache.put(W, 1), U.pageIndexCache.has(W) || U.pageIndexCache.put(W, 0), [z, W];
                }
                throw new i.FormatError("The Linearization dictionary doesn't point to a valid Page dictionary.");
              } catch (z) {
                return (0, i.warn)(`_getLinearizationPage: "${z.message}".`), U.getPageDict(O);
              }
            }
            getPage(O) {
              const U = this._pagePromises.get(O);
              if (U)
                return U;
              const {
                catalog: G,
                linearization: K,
                xfaFactory: W
              } = this;
              let z;
              return W ? z = Promise.resolve([a.Dict.empty, null]) : K && K.pageFirst === O ? z = this._getLinearizationPage(O) : z = G.getPageDict(O), z = z.then(([V, L]) => new B({
                pdfManager: this.pdfManager,
                xref: this.xref,
                pageIndex: O,
                pageDict: V,
                ref: L,
                globalIdFactory: this._globalIdFactory,
                fontCache: G.fontCache,
                builtInCMapCache: G.builtInCMapCache,
                standardFontDataCache: G.standardFontDataCache,
                globalImageCache: G.globalImageCache,
                nonBlendModesSet: G.nonBlendModesSet,
                xfaFactory: W
              })), this._pagePromises.set(O, z), z;
            }
            async checkFirstPage(O = !1) {
              if (!O)
                try {
                  await this.getPage(0);
                } catch (U) {
                  if (U instanceof v.XRefEntryException)
                    throw this._pagePromises.delete(0), await this.cleanup(), new v.XRefParseException();
                }
            }
            async checkLastPage(O = !1) {
              const {
                catalog: U,
                pdfManager: G
              } = this;
              U.setActualNumPages();
              let K;
              try {
                if (await Promise.all([G.ensureDoc("xfaFactory"), G.ensureDoc("linearization"), G.ensureCatalog("numPages")]), this.xfaFactory)
                  return;
                if (this.linearization ? K = this.linearization.numPages : K = U.numPages, Number.isInteger(K)) {
                  if (K <= 1)
                    return;
                } else
                  throw new i.FormatError("Page count is not an integer.");
                await this.getPage(K - 1);
              } catch (W) {
                if (this._pagePromises.delete(K - 1), await this.cleanup(), W instanceof v.XRefEntryException && !O)
                  throw new v.XRefParseException();
                (0, i.warn)(`checkLastPage - invalid /Pages tree /Count: ${K}.`);
                let z;
                try {
                  z = await U.getAllPageDicts(O);
                } catch (V) {
                  if (V instanceof v.XRefEntryException && !O)
                    throw new v.XRefParseException();
                  U.setActualNumPages(1);
                  return;
                }
                for (const [V, [L, Y]] of z) {
                  let J;
                  L instanceof Error ? (J = Promise.reject(L), J.catch(() => {
                  })) : J = Promise.resolve(new B({
                    pdfManager: G,
                    xref: this.xref,
                    pageIndex: V,
                    pageDict: L,
                    ref: Y,
                    globalIdFactory: this._globalIdFactory,
                    fontCache: U.fontCache,
                    builtInCMapCache: U.builtInCMapCache,
                    standardFontDataCache: U.standardFontDataCache,
                    globalImageCache: U.globalImageCache,
                    nonBlendModesSet: U.nonBlendModesSet,
                    xfaFactory: null
                  })), this._pagePromises.set(V, J);
                }
                U.setActualNumPages(z.size);
              }
            }
            fontFallback(O, U) {
              return this.catalog.fontFallback(O, U);
            }
            async cleanup(O = !1) {
              return this.catalog ? this.catalog.cleanup(O) : (0, g.clearGlobalCaches)();
            }
            _collectFieldObjects(O, U, G) {
              const K = this.xref.fetchIfRef(U);
              if (K.has("T")) {
                const W = (0, i.stringToPDFString)(K.get("T"));
                O === "" ? O = W : O = `${O}.${W}`;
              }
              if (G.has(O) || G.set(O, []), G.get(O).push(t.AnnotationFactory.create(this.xref, U, this.pdfManager, this._localIdFactory, !0).then((W) => W && W.getFieldObject()).catch(function(W) {
                return (0, i.warn)(`_collectFieldObjects: "${W}".`), null;
              })), K.has("Kids")) {
                const W = K.get("Kids");
                for (const z of W)
                  this._collectFieldObjects(O, z, G);
              }
            }
            get fieldObjects() {
              if (!this.formInfo.hasFields)
                return (0, i.shadow)(this, "fieldObjects", Promise.resolve(null));
              const O = /* @__PURE__ */ Object.create(null), U = /* @__PURE__ */ new Map();
              for (const K of this.catalog.acroForm.get("Fields"))
                this._collectFieldObjects("", K, U);
              const G = [];
              for (const [K, W] of U)
                G.push(Promise.all(W).then((z) => {
                  z = z.filter((V) => !!V), z.length > 0 && (O[K] = z);
                }));
              return (0, i.shadow)(this, "fieldObjects", Promise.all(G).then(() => O));
            }
            get hasJSActions() {
              const O = this.pdfManager.ensureDoc("_parseHasJSActions");
              return (0, i.shadow)(this, "hasJSActions", O);
            }
            async _parseHasJSActions() {
              const [O, U] = await Promise.all([this.pdfManager.ensureCatalog("jsActions"), this.pdfManager.ensureDoc("fieldObjects")]);
              return O ? !0 : U ? Object.values(U).some((G) => G.some((K) => K.actions !== null)) : !1;
            }
            get calculationOrderIds() {
              const O = this.catalog.acroForm;
              if (!O || !O.has("CO"))
                return (0, i.shadow)(this, "calculationOrderIds", null);
              const U = O.get("CO");
              if (!Array.isArray(U) || U.length === 0)
                return (0, i.shadow)(this, "calculationOrderIds", null);
              const G = [];
              for (const K of U)
                K instanceof a.Ref && G.push(K.toString());
              return G.length === 0 ? (0, i.shadow)(this, "calculationOrderIds", null) : (0, i.shadow)(this, "calculationOrderIds", G);
            }
          }
          u.PDFDocument = F;
        },
        /* 12 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.PopupAnnotation = u.MarkupAnnotation = u.AnnotationFactory = u.AnnotationBorderStyle = u.Annotation = void 0, u.getQuadPoints = C;
          var t = P(2), i = P(6), v = P(13), a = P(5), e = P(65), y = P(7), r = P(60), h = P(69), g = P(14), d = P(72), c = P(75), n = P(62), o = P(10), x = P(76);
          class f {
            static create(N, Z, E, te, re) {
              return Promise.all([E.ensureCatalog("acroForm"), E.ensureCatalog("baseUrl"), E.ensureDoc("xfaDatasets"), re ? this._getPageIndex(N, Z, E) : -1]).then(([ee, $, k, H]) => E.ensure(this, "_create", [N, Z, E, te, ee, k, re, H]));
            }
            static _create(N, Z, E, te, re, ee, $, k = -1) {
              const H = N.fetchIfRef(Z);
              if (!(H instanceof a.Dict))
                return;
              const ne = Z instanceof a.Ref ? Z.toString() : `annot_${te.createObjId()}`;
              let ae = H.get("Subtype");
              ae = ae instanceof a.Name ? ae.name : null;
              const he = {
                xref: N,
                ref: Z,
                dict: H,
                subtype: ae,
                id: ne,
                pdfManager: E,
                acroForm: re instanceof a.Dict ? re : a.Dict.empty,
                xfaDatasets: ee,
                collectFields: $,
                pageIndex: k
              };
              switch (ae) {
                case "Link":
                  return new _(he);
                case "Text":
                  return new l(he);
                case "Widget":
                  let ue = (0, i.getInheritableProperty)({
                    dict: H,
                    key: "FT"
                  });
                  switch (ue = ue instanceof a.Name ? ue.name : null, ue) {
                    case "Tx":
                      return new B(he);
                    case "Btn":
                      return new R(he);
                    case "Ch":
                      return new D(he);
                    case "Sig":
                      return new b(he);
                  }
                  return (0, t.warn)(`Unimplemented widget field type "${ue}", falling back to base field type.`), new j(he);
                case "Popup":
                  return new S(he);
                case "FreeText":
                  return new A(he);
                case "Line":
                  return new F(he);
                case "Square":
                  return new T(he);
                case "Circle":
                  return new O(he);
                case "PolyLine":
                  return new U(he);
                case "Polygon":
                  return new G(he);
                case "Caret":
                  return new K(he);
                case "Ink":
                  return new W(he);
                case "Highlight":
                  return new z(he);
                case "Underline":
                  return new V(he);
                case "Squiggly":
                  return new L(he);
                case "StrikeOut":
                  return new Y(he);
                case "Stamp":
                  return new J(he);
                case "FileAttachment":
                  return new ie(he);
                default:
                  return $ || (ae ? (0, t.warn)(`Unimplemented annotation type "${ae}", falling back to base annotation.`) : (0, t.warn)("Annotation is missing the required /Subtype.")), new w(he);
              }
            }
            static async _getPageIndex(N, Z, E) {
              try {
                const te = await N.fetchIfRefAsync(Z);
                if (!(te instanceof a.Dict))
                  return -1;
                const re = te.getRaw("P");
                return re instanceof a.Ref ? await E.ensureCatalog("getPageIndex", [re]) : -1;
              } catch (te) {
                return (0, t.warn)(`_getPageIndex: "${te}".`), -1;
              }
            }
            static async saveNewAnnotations(N, Z, E) {
              const te = N.xref;
              let re;
              const ee = [], $ = [];
              for (const k of E)
                switch (k.annotationType) {
                  case t.AnnotationEditorType.FREETEXT:
                    if (!re) {
                      const H = new a.Dict(te);
                      H.set("BaseFont", a.Name.get("Helvetica")), H.set("Type", a.Name.get("Font")), H.set("Subtype", a.Name.get("Type1")), H.set("Encoding", a.Name.get("WinAnsiEncoding"));
                      const ne = [];
                      re = te.getNewRef(), (0, e.writeObject)(re, H, ne, null), ee.push({
                        ref: re,
                        data: ne.join("")
                      });
                    }
                    $.push(A.createNewAnnotation(te, k, ee, {
                      evaluator: N,
                      task: Z,
                      baseFontRef: re
                    }));
                    break;
                  case t.AnnotationEditorType.INK:
                    $.push(W.createNewAnnotation(te, k, ee));
                }
              return {
                annotations: await Promise.all($),
                dependencies: ee
              };
            }
            static async printNewAnnotations(N, Z, E) {
              if (!E)
                return null;
              const te = N.xref, re = [];
              for (const ee of E)
                switch (ee.annotationType) {
                  case t.AnnotationEditorType.FREETEXT:
                    re.push(A.createNewPrintAnnotation(te, ee, {
                      evaluator: N,
                      task: Z
                    }));
                    break;
                  case t.AnnotationEditorType.INK:
                    re.push(W.createNewPrintAnnotation(te, ee));
                    break;
                }
              return Promise.all(re);
            }
          }
          u.AnnotationFactory = f;
          function m(q, N = new Uint8ClampedArray(3)) {
            if (!Array.isArray(q))
              return N;
            const Z = N || new Uint8ClampedArray(3);
            switch (q.length) {
              case 0:
                return null;
              case 1:
                return g.ColorSpace.singletons.gray.getRgbItem(q, 0, Z, 0), Z;
              case 3:
                return g.ColorSpace.singletons.rgb.getRgbItem(q, 0, Z, 0), Z;
              case 4:
                return g.ColorSpace.singletons.cmyk.getRgbItem(q, 0, Z, 0), Z;
              default:
                return N;
            }
          }
          function C(q, N) {
            if (!q.has("QuadPoints"))
              return null;
            const Z = q.getArray("QuadPoints");
            if (!Array.isArray(Z) || Z.length === 0 || Z.length % 8 > 0)
              return null;
            const E = [];
            for (let te = 0, re = Z.length / 8; te < re; te++) {
              E.push([]);
              for (let ee = te * 8, $ = te * 8 + 8; ee < $; ee += 2) {
                const k = Z[ee], H = Z[ee + 1];
                if (N !== null && (k < N[0] || k > N[2] || H < N[1] || H > N[3]))
                  return null;
                E[te].push({
                  x: k,
                  y: H
                });
              }
            }
            return E.map((te) => {
              const [re, ee, $, k] = te.reduce(([H, ne, ae, he], ue) => [Math.min(H, ue.x), Math.max(ne, ue.x), Math.min(ae, ue.y), Math.max(he, ue.y)], [Number.MAX_VALUE, Number.MIN_VALUE, Number.MAX_VALUE, Number.MIN_VALUE]);
              return [{
                x: re,
                y: k
              }, {
                x: ee,
                y: k
              }, {
                x: re,
                y: $
              }, {
                x: ee,
                y: $
              }];
            });
          }
          function p(q, N, Z) {
            const [E, te, re, ee] = t.Util.getAxialAlignedBoundingBox(N, Z);
            if (E === re || te === ee)
              return [1, 0, 0, 1, q[0], q[1]];
            const $ = (q[2] - q[0]) / (re - E), k = (q[3] - q[1]) / (ee - te);
            return [$, 0, 0, k, q[0] - E * $, q[1] - te * k];
          }
          class w {
            constructor(N) {
              const Z = N.dict;
              this.setTitle(Z.get("T")), this.setContents(Z.get("Contents")), this.setModificationDate(Z.get("M")), this.setFlags(Z.get("F")), this.setRectangle(Z.getArray("Rect")), this.setColor(Z.getArray("C")), this.setBorderStyle(Z), this.setAppearance(Z), this.setOptionalContent(Z);
              const E = Z.get("MK");
              if (this.setBorderAndBackgroundColors(E), this.setRotation(E), this._streams = [], this.appearance && this._streams.push(this.appearance), this.data = {
                annotationFlags: this.flags,
                borderStyle: this.borderStyle,
                color: this.color,
                backgroundColor: this.backgroundColor,
                borderColor: this.borderColor,
                rotation: this.rotation,
                contentsObj: this._contents,
                hasAppearance: !!this.appearance,
                id: N.id,
                modificationDate: this.modificationDate,
                rect: this.rectangle,
                subtype: N.subtype,
                hasOwnCanvas: !1
              }, N.collectFields) {
                const te = Z.get("Kids");
                if (Array.isArray(te)) {
                  const re = [];
                  for (const ee of te)
                    ee instanceof a.Ref && re.push(ee.toString());
                  re.length !== 0 && (this.data.kidIds = re);
                }
                this.data.actions = (0, i.collectActions)(N.xref, Z, t.AnnotationActionEventType), this.data.fieldName = this._constructFieldName(Z), this.data.pageIndex = N.pageIndex;
              }
              this._fallbackFontDict = null;
            }
            _hasFlag(N, Z) {
              return !!(N & Z);
            }
            _isViewable(N) {
              return !this._hasFlag(N, t.AnnotationFlag.INVISIBLE) && !this._hasFlag(N, t.AnnotationFlag.NOVIEW);
            }
            _isPrintable(N) {
              return this._hasFlag(N, t.AnnotationFlag.PRINT) && !this._hasFlag(N, t.AnnotationFlag.INVISIBLE);
            }
            mustBeViewed(N) {
              const Z = N && N.get(this.data.id);
              return Z && Z.hidden !== void 0 ? !Z.hidden : this.viewable && !this._hasFlag(this.flags, t.AnnotationFlag.HIDDEN);
            }
            mustBePrinted(N) {
              const Z = N && N.get(this.data.id);
              return Z && Z.print !== void 0 ? Z.print : this.printable;
            }
            get viewable() {
              return this.data.quadPoints === null ? !1 : this.flags === 0 ? !0 : this._isViewable(this.flags);
            }
            get printable() {
              return this.data.quadPoints === null || this.flags === 0 ? !1 : this._isPrintable(this.flags);
            }
            _parseStringHelper(N) {
              const Z = typeof N == "string" ? (0, t.stringToPDFString)(N) : "", E = Z && (0, r.bidi)(Z).dir === "rtl" ? "rtl" : "ltr";
              return {
                str: Z,
                dir: E
              };
            }
            setTitle(N) {
              this._title = this._parseStringHelper(N);
            }
            setContents(N) {
              this._contents = this._parseStringHelper(N);
            }
            setModificationDate(N) {
              this.modificationDate = typeof N == "string" ? N : null;
            }
            setFlags(N) {
              this.flags = Number.isInteger(N) && N > 0 ? N : 0;
            }
            hasFlag(N) {
              return this._hasFlag(this.flags, N);
            }
            setRectangle(N) {
              Array.isArray(N) && N.length === 4 ? this.rectangle = t.Util.normalizeRect(N) : this.rectangle = [0, 0, 0, 0];
            }
            setColor(N) {
              this.color = m(N);
            }
            setLineEndings(N) {
              if (this.lineEndings = ["None", "None"], Array.isArray(N) && N.length === 2)
                for (let Z = 0; Z < 2; Z++) {
                  const E = N[Z];
                  if (E instanceof a.Name)
                    switch (E.name) {
                      case "None":
                        continue;
                      case "Square":
                      case "Circle":
                      case "Diamond":
                      case "OpenArrow":
                      case "ClosedArrow":
                      case "Butt":
                      case "ROpenArrow":
                      case "RClosedArrow":
                      case "Slash":
                        this.lineEndings[Z] = E.name;
                        continue;
                    }
                  (0, t.warn)(`Ignoring invalid lineEnding: ${E}`);
                }
            }
            setRotation(N) {
              if (this.rotation = 0, N instanceof a.Dict) {
                let Z = N.get("R") || 0;
                Number.isInteger(Z) && Z !== 0 && (Z %= 360, Z < 0 && (Z += 360), Z % 90 === 0 && (this.rotation = Z));
              }
            }
            setBorderAndBackgroundColors(N) {
              N instanceof a.Dict ? (this.borderColor = m(N.getArray("BC"), null), this.backgroundColor = m(N.getArray("BG"), null)) : this.borderColor = this.backgroundColor = null;
            }
            setBorderStyle(N) {
              if (this.borderStyle = new X(), N instanceof a.Dict)
                if (N.has("BS")) {
                  const Z = N.get("BS"), E = Z.get("Type");
                  (!E || (0, a.isName)(E, "Border")) && (this.borderStyle.setWidth(Z.get("W"), this.rectangle), this.borderStyle.setStyle(Z.get("S")), this.borderStyle.setDashArray(Z.getArray("D")));
                } else if (N.has("Border")) {
                  const Z = N.getArray("Border");
                  Array.isArray(Z) && Z.length >= 3 && (this.borderStyle.setHorizontalCornerRadius(Z[0]), this.borderStyle.setVerticalCornerRadius(Z[1]), this.borderStyle.setWidth(Z[2], this.rectangle), Z.length === 4 && this.borderStyle.setDashArray(Z[3], !0));
                } else
                  this.borderStyle.setWidth(0);
            }
            setAppearance(N) {
              this.appearance = null;
              const Z = N.get("AP");
              if (!(Z instanceof a.Dict))
                return;
              const E = Z.get("N");
              if (E instanceof y.BaseStream) {
                this.appearance = E;
                return;
              }
              if (!(E instanceof a.Dict))
                return;
              const te = N.get("AS");
              !(te instanceof a.Name) || !E.has(te.name) || (this.appearance = E.get(te.name));
            }
            setOptionalContent(N) {
              this.oc = null;
              const Z = N.get("OC");
              Z instanceof a.Name ? (0, t.warn)("setOptionalContent: Support for /Name-entry is not implemented.") : Z instanceof a.Dict && (this.oc = Z);
            }
            loadResources(N, Z) {
              return Z.dict.getAsync("Resources").then((E) => E ? new c.ObjectLoader(E, N, E.xref).load().then(function() {
                return E;
              }) : void 0);
            }
            async getOperatorList(N, Z, E, te, re) {
              const ee = this.data;
              let $ = this.appearance;
              const k = !!(this.data.hasOwnCanvas && E & t.RenderingIntentFlag.DISPLAY);
              if (!$) {
                if (!k)
                  return {
                    opList: new n.OperatorList(),
                    separateForm: !1,
                    separateCanvas: !1
                  };
                $ = new o.StringStream(""), $.dict = new a.Dict();
              }
              const H = $.dict, ne = await this.loadResources(["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"], $), ae = H.getArray("BBox") || [0, 0, 1, 1], he = H.getArray("Matrix") || [1, 0, 0, 1, 0, 0], ue = p(ee.rect, ae, he), fe = new n.OperatorList();
              let me;
              return this.oc && (me = await N.parseMarkedContentProps(this.oc, null)), me !== void 0 && fe.addOp(t.OPS.beginMarkedContentProps, ["OC", me]), fe.addOp(t.OPS.beginAnnotation, [ee.id, ee.rect, ue, he, k]), await N.getOperatorList({
                stream: $,
                task: Z,
                resources: ne,
                operatorList: fe,
                fallbackFontDict: this._fallbackFontDict
              }), fe.addOp(t.OPS.endAnnotation, []), me !== void 0 && fe.addOp(t.OPS.endMarkedContent, []), this.reset(), {
                opList: fe,
                separateForm: !1,
                separateCanvas: k
              };
            }
            async save(N, Z, E) {
              return null;
            }
            get hasTextContent() {
              return !1;
            }
            async extractTextContent(N, Z, E) {
              if (!this.appearance)
                return;
              const te = await this.loadResources(["ExtGState", "Font", "Properties", "XObject"], this.appearance), re = [], ee = [], $ = {
                desiredSize: Math.Infinity,
                ready: !0,
                enqueue(k, H) {
                  for (const ne of k.items)
                    ee.push(ne.str), ne.hasEOL && (re.push(ee.join("")), ee.length = 0);
                }
              };
              await N.getTextContent({
                stream: this.appearance,
                task: Z,
                resources: te,
                includeMarkedContent: !0,
                combineTextItems: !0,
                sink: $,
                viewBox: E
              }), this.reset(), ee.length && re.push(ee.join("")), re.length > 0 && (this.data.textContent = re);
            }
            getFieldObject() {
              return this.data.kidIds ? {
                id: this.data.id,
                actions: this.data.actions,
                name: this.data.fieldName,
                strokeColor: this.data.borderColor,
                fillColor: this.data.backgroundColor,
                type: "",
                kidIds: this.data.kidIds,
                page: this.data.pageIndex,
                rotation: this.rotation
              } : null;
            }
            reset() {
              for (const N of this._streams)
                N.reset();
            }
            _constructFieldName(N) {
              if (!N.has("T") && !N.has("Parent"))
                return (0, t.warn)("Unknown field name, falling back to empty field name."), "";
              if (!N.has("Parent"))
                return (0, t.stringToPDFString)(N.get("T"));
              const Z = [];
              N.has("T") && Z.unshift((0, t.stringToPDFString)(N.get("T")));
              let E = N;
              const te = new a.RefSet();
              for (N.objId && te.put(N.objId); E.has("Parent") && (E = E.get("Parent"), !(!(E instanceof a.Dict) || E.objId && te.has(E.objId))); )
                E.objId && te.put(E.objId), E.has("T") && Z.unshift((0, t.stringToPDFString)(E.get("T")));
              return Z.join(".");
            }
          }
          u.Annotation = w;
          class X {
            constructor() {
              this.width = 1, this.style = t.AnnotationBorderStyleType.SOLID, this.dashArray = [3], this.horizontalCornerRadius = 0, this.verticalCornerRadius = 0;
            }
            setWidth(N, Z = [0, 0, 0, 0]) {
              if (N instanceof a.Name) {
                this.width = 0;
                return;
              }
              if (typeof N == "number") {
                if (N > 0) {
                  const E = (Z[2] - Z[0]) / 2, te = (Z[3] - Z[1]) / 2;
                  E > 0 && te > 0 && (N > E || N > te) && ((0, t.warn)(`AnnotationBorderStyle.setWidth - ignoring width: ${N}`), N = 1);
                }
                this.width = N;
              }
            }
            setStyle(N) {
              if (N instanceof a.Name)
                switch (N.name) {
                  case "S":
                    this.style = t.AnnotationBorderStyleType.SOLID;
                    break;
                  case "D":
                    this.style = t.AnnotationBorderStyleType.DASHED;
                    break;
                  case "B":
                    this.style = t.AnnotationBorderStyleType.BEVELED;
                    break;
                  case "I":
                    this.style = t.AnnotationBorderStyleType.INSET;
                    break;
                  case "U":
                    this.style = t.AnnotationBorderStyleType.UNDERLINE;
                    break;
                }
            }
            setDashArray(N, Z = !1) {
              if (Array.isArray(N) && N.length > 0) {
                let E = !0, te = !0;
                for (const re of N)
                  if (+re >= 0)
                    re > 0 && (te = !1);
                  else {
                    E = !1;
                    break;
                  }
                E && !te ? (this.dashArray = N, Z && this.setStyle(a.Name.get("D"))) : this.width = 0;
              } else
                N && (this.width = 0);
            }
            setHorizontalCornerRadius(N) {
              Number.isInteger(N) && (this.horizontalCornerRadius = N);
            }
            setVerticalCornerRadius(N) {
              Number.isInteger(N) && (this.verticalCornerRadius = N);
            }
          }
          u.AnnotationBorderStyle = X;
          class M extends w {
            constructor(N) {
              super(N);
              const Z = N.dict;
              if (Z.has("IRT")) {
                const E = Z.getRaw("IRT");
                this.data.inReplyTo = E instanceof a.Ref ? E.toString() : null;
                const te = Z.get("RT");
                this.data.replyType = te instanceof a.Name ? te.name : t.AnnotationReplyType.REPLY;
              }
              if (this.data.replyType === t.AnnotationReplyType.GROUP) {
                const E = Z.get("IRT");
                this.setTitle(E.get("T")), this.data.titleObj = this._title, this.setContents(E.get("Contents")), this.data.contentsObj = this._contents, E.has("CreationDate") ? (this.setCreationDate(E.get("CreationDate")), this.data.creationDate = this.creationDate) : this.data.creationDate = null, E.has("M") ? (this.setModificationDate(E.get("M")), this.data.modificationDate = this.modificationDate) : this.data.modificationDate = null, this.data.hasPopup = E.has("Popup"), E.has("C") ? (this.setColor(E.getArray("C")), this.data.color = this.color) : this.data.color = null;
              } else
                this.data.titleObj = this._title, this.setCreationDate(Z.get("CreationDate")), this.data.creationDate = this.creationDate, this.data.hasPopup = Z.has("Popup"), Z.has("C") || (this.data.color = null);
              Z.has("RC") && (this.data.richText = x.XFAFactory.getRichTextAsHtml(Z.get("RC")));
            }
            setCreationDate(N) {
              this.creationDate = typeof N == "string" ? N : null;
            }
            _setDefaultAppearance({
              xref: N,
              extra: Z,
              strokeColor: E,
              fillColor: te,
              blendMode: re,
              strokeAlpha: ee,
              fillAlpha: $,
              pointsCallback: k
            }) {
              let H = Number.MAX_VALUE, ne = Number.MAX_VALUE, ae = Number.MIN_VALUE, he = Number.MIN_VALUE;
              const ue = ["q"];
              Z && ue.push(Z), E && ue.push(`${E[0]} ${E[1]} ${E[2]} RG`), te && ue.push(`${te[0]} ${te[1]} ${te[2]} rg`);
              let fe = this.data.quadPoints;
              fe || (fe = [[{
                x: this.rectangle[0],
                y: this.rectangle[3]
              }, {
                x: this.rectangle[2],
                y: this.rectangle[3]
              }, {
                x: this.rectangle[0],
                y: this.rectangle[1]
              }, {
                x: this.rectangle[2],
                y: this.rectangle[1]
              }]]);
              for (const Se of fe) {
                const [be, Le, ze, nt] = k(ue, Se);
                H = Math.min(H, be), ae = Math.max(ae, Le), ne = Math.min(ne, ze), he = Math.max(he, nt);
              }
              ue.push("Q");
              const me = new a.Dict(N), Fe = new a.Dict(N);
              Fe.set("Subtype", a.Name.get("Form"));
              const we = new o.StringStream(ue.join(" "));
              we.dict = Fe, me.set("Fm0", we);
              const Ae = new a.Dict(N);
              re && Ae.set("BM", a.Name.get(re)), typeof ee == "number" && Ae.set("CA", ee), typeof $ == "number" && Ae.set("ca", $);
              const De = new a.Dict(N);
              De.set("GS0", Ae);
              const xe = new a.Dict(N);
              xe.set("ExtGState", De), xe.set("XObject", me);
              const Te = new a.Dict(N);
              Te.set("Resources", xe);
              const ve = this.data.rect = [H, ne, ae, he];
              Te.set("BBox", ve), this.appearance = new o.StringStream("/GS0 gs /Fm0 Do"), this.appearance.dict = Te, this._streams.push(this.appearance, we);
            }
            static async createNewAnnotation(N, Z, E, te) {
              const re = N.getNewRef(), ee = N.getNewRef(), $ = this.createNewDict(Z, N, {
                apRef: ee
              }), k = await this.createNewAppearanceStream(Z, N, te), H = [];
              let ne = N.encrypt ? N.encrypt.createCipherTransform(ee.num, ee.gen) : null;
              return (0, e.writeObject)(ee, k, H, ne), E.push({
                ref: ee,
                data: H.join("")
              }), H.length = 0, ne = N.encrypt ? N.encrypt.createCipherTransform(re.num, re.gen) : null, (0, e.writeObject)(re, $, H, ne), {
                ref: re,
                data: H.join("")
              };
            }
            static async createNewPrintAnnotation(N, Z, E) {
              const te = await this.createNewAppearanceStream(Z, N, E), re = this.createNewDict(Z, N, {
                ap: te
              });
              return new this.prototype.constructor({
                dict: re,
                xref: N
              });
            }
          }
          u.MarkupAnnotation = M;
          class j extends w {
            constructor(N) {
              super(N);
              const Z = N.dict, E = this.data;
              this.ref = N.ref, E.annotationType = t.AnnotationType.WIDGET, E.fieldName === void 0 && (E.fieldName = this._constructFieldName(Z)), E.actions === void 0 && (E.actions = (0, i.collectActions)(N.xref, Z, t.AnnotationActionEventType));
              let te = (0, i.getInheritableProperty)({
                dict: Z,
                key: "V",
                getArray: !0
              });
              E.fieldValue = this._decodeFormValue(te);
              const re = (0, i.getInheritableProperty)({
                dict: Z,
                key: "DV",
                getArray: !0
              });
              if (E.defaultFieldValue = this._decodeFormValue(re), te === void 0 && N.xfaDatasets) {
                const ae = this._title.str;
                ae && (this._hasValueFromXFA = !0, E.fieldValue = te = N.xfaDatasets.getValue(ae));
              }
              te === void 0 && E.defaultFieldValue !== null && (E.fieldValue = E.defaultFieldValue), E.alternativeText = (0, t.stringToPDFString)(Z.get("TU") || "");
              const ee = (0, i.getInheritableProperty)({
                dict: Z,
                key: "DA"
              }) || N.acroForm.get("DA");
              this._defaultAppearance = typeof ee == "string" ? ee : "", E.defaultAppearanceData = (0, v.parseDefaultAppearance)(this._defaultAppearance);
              const $ = (0, i.getInheritableProperty)({
                dict: Z,
                key: "FT"
              });
              E.fieldType = $ instanceof a.Name ? $.name : null;
              const k = (0, i.getInheritableProperty)({
                dict: Z,
                key: "DR"
              }), H = N.acroForm.get("DR"), ne = this.appearance && this.appearance.dict.get("Resources");
              this._fieldResources = {
                localResources: k,
                acroFormResources: H,
                appearanceResources: ne,
                mergedResources: a.Dict.merge({
                  xref: N.xref,
                  dictArray: [k, ne, H],
                  mergeSubDicts: !0
                })
              }, E.fieldFlags = (0, i.getInheritableProperty)({
                dict: Z,
                key: "Ff"
              }), (!Number.isInteger(E.fieldFlags) || E.fieldFlags < 0) && (E.fieldFlags = 0), E.readOnly = this.hasFieldFlag(t.AnnotationFieldFlag.READONLY), E.required = this.hasFieldFlag(t.AnnotationFieldFlag.REQUIRED), E.hidden = this._hasFlag(E.annotationFlags, t.AnnotationFlag.HIDDEN);
            }
            _decodeFormValue(N) {
              return Array.isArray(N) ? N.filter((Z) => typeof Z == "string").map((Z) => (0, t.stringToPDFString)(Z)) : N instanceof a.Name ? (0, t.stringToPDFString)(N.name) : typeof N == "string" ? (0, t.stringToPDFString)(N) : null;
            }
            hasFieldFlag(N) {
              return !!(this.data.fieldFlags & N);
            }
            static _getRotationMatrix(N, Z, E) {
              switch (N) {
                case 90:
                  return [0, 1, -1, 0, Z, 0];
                case 180:
                  return [-1, 0, 0, -1, Z, E];
                case 270:
                  return [0, -1, 1, 0, 0, E];
                default:
                  throw new Error("Invalid rotation");
              }
            }
            getRotationMatrix(N) {
              const Z = N ? N.get(this.data.id) : void 0;
              let E = Z && Z.rotation;
              if (E === void 0 && (E = this.rotation), E === 0)
                return t.IDENTITY_MATRIX;
              const te = this.data.rect[2] - this.data.rect[0], re = this.data.rect[3] - this.data.rect[1];
              return j._getRotationMatrix(E, te, re);
            }
            getBorderAndBackgroundAppearances(N) {
              const Z = N ? N.get(this.data.id) : void 0;
              let E = Z && Z.rotation;
              if (E === void 0 && (E = this.rotation), !this.backgroundColor && !this.borderColor)
                return "";
              const te = this.data.rect[2] - this.data.rect[0], re = this.data.rect[3] - this.data.rect[1], ee = E === 0 || E === 180 ? `0 0 ${te} ${re} re` : `0 0 ${re} ${te} re`;
              let $ = "";
              if (this.backgroundColor && ($ = `${(0, v.getPdfColor)(this.backgroundColor, !0)} ${ee} f `), this.borderColor) {
                const k = this.borderStyle.width || 1;
                $ += `${k} w ${(0, v.getPdfColor)(this.borderColor, !1)} ${ee} S `;
              }
              return $;
            }
            async getOperatorList(N, Z, E, te, re) {
              if (te && !(this instanceof b))
                return {
                  opList: new n.OperatorList(),
                  separateForm: !0,
                  separateCanvas: !1
                };
              if (!this._hasText)
                return super.getOperatorList(N, Z, E, te, re);
              const ee = await this._getAppearance(N, Z, re);
              if (this.appearance && ee === null)
                return super.getOperatorList(N, Z, E, te, re);
              const $ = new n.OperatorList();
              if (!this._defaultAppearance || ee === null)
                return {
                  opList: $,
                  separateForm: !1,
                  separateCanvas: !1
                };
              const k = [1, 0, 0, 1, 0, 0], H = [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]], ne = p(this.data.rect, H, k);
              let ae;
              this.oc && (ae = await N.parseMarkedContentProps(this.oc, null)), ae !== void 0 && $.addOp(t.OPS.beginMarkedContentProps, ["OC", ae]), $.addOp(t.OPS.beginAnnotation, [this.data.id, this.data.rect, ne, this.getRotationMatrix(re), !1]);
              const he = new o.StringStream(ee);
              return await N.getOperatorList({
                stream: he,
                task: Z,
                resources: this._fieldResources.mergedResources,
                operatorList: $
              }), $.addOp(t.OPS.endAnnotation, []), ae !== void 0 && $.addOp(t.OPS.endMarkedContent, []), {
                opList: $,
                separateForm: !1,
                separateCanvas: !1
              };
            }
            _getMKDict(N) {
              const Z = new a.Dict(null);
              return N && Z.set("R", N), this.borderColor && Z.set("BC", Array.from(this.borderColor).map((E) => E / 255)), this.backgroundColor && Z.set("BG", Array.from(this.backgroundColor).map((E) => E / 255)), Z.size > 0 ? Z : null;
            }
            async save(N, Z, E) {
              const te = E ? E.get(this.data.id) : void 0;
              let re = te && te.value, ee = te && te.rotation;
              if (re === this.data.fieldValue || re === void 0) {
                if (!this._hasValueFromXFA && ee === void 0)
                  return null;
                re = re || this.data.fieldValue;
              }
              if (ee === void 0 && !this._hasValueFromXFA && Array.isArray(re) && Array.isArray(this.data.fieldValue) && re.length === this.data.fieldValue.length && re.every((Se, be) => Se === this.data.fieldValue[be]))
                return null;
              ee === void 0 && (ee = this.rotation);
              let $ = await this._getAppearance(N, Z, E);
              if ($ === null)
                return null;
              const {
                xref: k
              } = N, H = k.fetchIfRef(this.ref);
              if (!(H instanceof a.Dict))
                return null;
              const ne = [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]], ae = {
                path: (0, t.stringToPDFString)(H.get("T") || ""),
                value: re
              }, he = k.getNewRef(), ue = new a.Dict(k);
              ue.set("N", he);
              const fe = k.encrypt;
              let me = null, Fe = null;
              fe && (me = fe.createCipherTransform(this.ref.num, this.ref.gen), Fe = fe.createCipherTransform(he.num, he.gen), $ = Fe.encryptString($));
              const we = (Se) => (0, t.isAscii)(Se) ? Se : (0, t.stringToUTF16BEString)(Se);
              H.set("V", Array.isArray(re) ? re.map(we) : we(re)), H.set("AP", ue), H.set("M", `D:${(0, t.getModificationDate)()}`);
              const Ae = this._getMKDict(ee);
              Ae && H.set("MK", Ae);
              const De = new a.Dict(k);
              De.set("Length", $.length), De.set("Subtype", a.Name.get("Form")), De.set("Resources", this._getSaveFieldResources(k)), De.set("BBox", ne);
              const xe = this.getRotationMatrix(E);
              xe !== t.IDENTITY_MATRIX && De.set("Matrix", xe);
              const Te = [`${this.ref.num} ${this.ref.gen} obj
`];
              (0, e.writeDict)(H, Te, me), Te.push(`
endobj
`);
              const ve = [`${he.num} ${he.gen} obj
`];
              return (0, e.writeDict)(De, ve, Fe), ve.push(` stream
`, $, `
endstream
endobj
`), [{
                ref: this.ref,
                data: Te.join(""),
                xfa: ae
              }, {
                ref: he,
                data: ve.join(""),
                xfa: null
              }];
            }
            async _getAppearance(N, Z, E) {
              if (this.hasFieldFlag(t.AnnotationFieldFlag.PASSWORD))
                return null;
              const re = E ? E.get(this.data.id) : void 0;
              let ee, $;
              if (re && (ee = re.formattedValue || re.value, $ = re.rotation), $ === void 0 && ee === void 0 && (!this._hasValueFromXFA || this.appearance))
                return null;
              if (ee === void 0 && (ee = this.data.fieldValue, !ee) || (Array.isArray(ee) && ee.length === 1 && (ee = ee[0]), (0, t.assert)(typeof ee == "string", "Expected `value` to be a string."), ee = ee.trim(), ee === ""))
                return "";
              $ === void 0 && ($ = this.rotation);
              let k = -1;
              this.data.multiLine && (k = ee.split(/\r\n|\r|\n/).length);
              const H = 2, ne = H;
              let ae = this.data.rect[3] - this.data.rect[1], he = this.data.rect[2] - this.data.rect[0];
              ($ === 90 || $ === 270) && ([he, ae] = [ae, he]), this._defaultAppearance || (this.data.defaultAppearanceData = (0, v.parseDefaultAppearance)(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
              const ue = await j._getFontData(N, Z, this.data.defaultAppearanceData, this._fieldResources.mergedResources), [fe, me] = this._computeFontSize(ae - H, he - 2 * ne, ee, ue, k);
              let Fe = ue.descent;
              isNaN(Fe) && (Fe = 0);
              const Ae = Math.min(Math.floor((ae - me) / 2), H) + Math.abs(Fe) * me, De = this.data.textAlignment;
              if (this.data.multiLine)
                return this._getMultilineAppearance(fe, ee, ue, me, he, ae, De, ne, Ae, E);
              const xe = ue.encodeString(ee).join("");
              if (this.data.comb)
                return this._getCombAppearance(fe, ue, xe, he, ne, Ae, E);
              const Te = this.getBorderAndBackgroundAppearances(E);
              if (De === 0 || De > 2)
                return `/Tx BMC q ${Te}BT ` + fe + ` 1 0 0 1 ${ne} ${Ae} Tm (${(0, t.escapeString)(xe)}) Tj ET Q EMC`;
              const ve = this._renderText(xe, ue, me, he, De, ne, Ae);
              return `/Tx BMC q ${Te}BT ` + fe + ` 1 0 0 1 0 0 Tm ${ve} ET Q EMC`;
            }
            static async _getFontData(N, Z, E, te) {
              const re = new n.OperatorList(), ee = {
                font: null,
                clone() {
                  return this;
                }
              }, {
                fontName: $,
                fontSize: k
              } = E;
              return await N.handleSetFont(te, [$ && a.Name.get($), k], null, re, Z, ee, null), ee.font;
            }
            _getTextWidth(N, Z) {
              return Z.charsToGlyphs(N).reduce((E, te) => E + te.width, 0) / 1e3;
            }
            _computeFontSize(N, Z, E, te, re) {
              let {
                fontSize: ee
              } = this.data.defaultAppearanceData;
              if (!ee) {
                const $ = (ne) => Math.floor(ne * 100) / 100;
                if (re === -1) {
                  const ne = this._getTextWidth(E, te);
                  ee = $(Math.min(N / t.LINE_FACTOR, Z / ne));
                } else {
                  const ne = E.split(/\r\n?|\n/), ae = [];
                  for (const me of ne) {
                    const Fe = te.encodeString(me).join(""), we = te.charsToGlyphs(Fe), Ae = te.getCharPositions(Fe);
                    ae.push({
                      line: Fe,
                      glyphs: we,
                      positions: Ae
                    });
                  }
                  const he = (me) => {
                    let Fe = 0;
                    for (const we of ae) {
                      const Ae = this._splitLine(null, te, me, Z, we);
                      if (Fe += Ae.length * me, Fe > N)
                        return !0;
                    }
                    return !1;
                  };
                  ee = 12;
                  let ue = ee * t.LINE_FACTOR, fe = Math.round(N / ue);
                  for (fe = Math.max(fe, re); ; ) {
                    if (ue = N / fe, ee = $(ue / t.LINE_FACTOR), he(ee)) {
                      fe++;
                      continue;
                    }
                    break;
                  }
                }
                const {
                  fontName: k,
                  fontColor: H
                } = this.data.defaultAppearanceData;
                this._defaultAppearance = (0, v.createDefaultAppearance)({
                  fontSize: ee,
                  fontName: k,
                  fontColor: H
                });
              }
              return [this._defaultAppearance, ee];
            }
            _renderText(N, Z, E, te, re, ee, $) {
              let k;
              if (re === 1) {
                const H = this._getTextWidth(N, Z) * E;
                k = (te - H) / 2;
              } else if (re === 2) {
                const H = this._getTextWidth(N, Z) * E;
                k = te - H - ee;
              } else
                k = ee;
              return k = (0, i.numberToString)(k), $ = (0, i.numberToString)($), `${k} ${$} Td (${(0, t.escapeString)(N)}) Tj`;
            }
            _getSaveFieldResources(N) {
              const {
                localResources: Z,
                appearanceResources: E,
                acroFormResources: te
              } = this._fieldResources, re = this.data.defaultAppearanceData && this.data.defaultAppearanceData.fontName;
              if (!re)
                return Z || a.Dict.empty;
              for (const ee of [Z, E])
                if (ee instanceof a.Dict) {
                  const $ = ee.get("Font");
                  if ($ instanceof a.Dict && $.has(re))
                    return ee;
                }
              if (te instanceof a.Dict) {
                const ee = te.get("Font");
                if (ee instanceof a.Dict && ee.has(re)) {
                  const $ = new a.Dict(N);
                  $.set(re, ee.getRaw(re));
                  const k = new a.Dict(N);
                  return k.set("Font", $), a.Dict.merge({
                    xref: N,
                    dictArray: [k, Z],
                    mergeSubDicts: !0
                  });
                }
              }
              return Z || a.Dict.empty;
            }
            getFieldObject() {
              return null;
            }
          }
          class B extends j {
            constructor(N) {
              super(N), this._hasText = !0;
              const Z = N.dict;
              typeof this.data.fieldValue != "string" && (this.data.fieldValue = "");
              let E = (0, i.getInheritableProperty)({
                dict: Z,
                key: "Q"
              });
              (!Number.isInteger(E) || E < 0 || E > 2) && (E = null), this.data.textAlignment = E;
              let te = (0, i.getInheritableProperty)({
                dict: Z,
                key: "MaxLen"
              });
              (!Number.isInteger(te) || te < 0) && (te = 0), this.data.maxLen = te, this.data.multiLine = this.hasFieldFlag(t.AnnotationFieldFlag.MULTILINE), this.data.comb = this.hasFieldFlag(t.AnnotationFieldFlag.COMB) && !this.hasFieldFlag(t.AnnotationFieldFlag.MULTILINE) && !this.hasFieldFlag(t.AnnotationFieldFlag.PASSWORD) && !this.hasFieldFlag(t.AnnotationFieldFlag.FILESELECT) && this.data.maxLen !== 0, this.data.doNotScroll = this.hasFieldFlag(t.AnnotationFieldFlag.DONOTSCROLL);
            }
            _getCombAppearance(N, Z, E, te, re, ee, $) {
              const k = (0, i.numberToString)(te / this.data.maxLen), H = [], ne = Z.getCharPositions(E);
              for (const [ue, fe] of ne)
                H.push(`(${(0, t.escapeString)(E.substring(ue, fe))}) Tj`);
              const ae = this.getBorderAndBackgroundAppearances($), he = H.join(` ${k} 0 Td `);
              return `/Tx BMC q ${ae}BT ` + N + ` 1 0 0 1 ${re} ${ee} Tm ${he} ET Q EMC`;
            }
            _getMultilineAppearance(N, Z, E, te, re, ee, $, k, H, ne) {
              const ae = Z.split(/\r\n?|\n/), he = [], ue = re - 2 * k;
              for (const Fe of ae) {
                const we = this._splitLine(Fe, E, te, ue);
                for (const Ae of we) {
                  const De = he.length === 0 ? k : 0;
                  he.push(this._renderText(Ae, E, te, re, $, De, -te));
                }
              }
              const fe = he.join(`
`);
              return `/Tx BMC q ${this.getBorderAndBackgroundAppearances(ne)}BT ` + N + ` 1 0 0 1 0 ${ee} Tm ${fe} ET Q EMC`;
            }
            _splitLine(N, Z, E, te, re = {}) {
              N = re.line || Z.encodeString(N).join("");
              const ee = re.glyphs || Z.charsToGlyphs(N);
              if (ee.length <= 1)
                return [N];
              const $ = re.positions || Z.getCharPositions(N), k = E / 1e3, H = [];
              let ne = -1, ae = -1, he = -1, ue = 0, fe = 0;
              for (let me = 0, Fe = ee.length; me < Fe; me++) {
                const [we, Ae] = $[me], De = ee[me], xe = De.width * k;
                De.unicode === " " ? fe + xe > te ? (H.push(N.substring(ue, we)), ue = we, fe = xe, ne = -1, he = -1) : (fe += xe, ne = we, ae = Ae, he = me) : fe + xe > te ? ne !== -1 ? (H.push(N.substring(ue, ae)), ue = ae, me = he + 1, ne = -1, fe = 0) : (H.push(N.substring(ue, we)), ue = we, fe = xe) : fe += xe;
              }
              return ue < N.length && H.push(N.substring(ue, N.length)), H;
            }
            getFieldObject() {
              return {
                id: this.data.id,
                value: this.data.fieldValue,
                defaultValue: this.data.defaultFieldValue || "",
                multiline: this.data.multiLine,
                password: this.hasFieldFlag(t.AnnotationFieldFlag.PASSWORD),
                charLimit: this.data.maxLen,
                comb: this.data.comb,
                editable: !this.data.readOnly,
                hidden: this.data.hidden,
                name: this.data.fieldName,
                rect: this.data.rect,
                actions: this.data.actions,
                page: this.data.pageIndex,
                strokeColor: this.data.borderColor,
                fillColor: this.data.backgroundColor,
                rotation: this.rotation,
                type: "text"
              };
            }
          }
          class R extends j {
            constructor(N) {
              super(N), this.checkedAppearance = null, this.uncheckedAppearance = null, this.data.checkBox = !this.hasFieldFlag(t.AnnotationFieldFlag.RADIO) && !this.hasFieldFlag(t.AnnotationFieldFlag.PUSHBUTTON), this.data.radioButton = this.hasFieldFlag(t.AnnotationFieldFlag.RADIO) && !this.hasFieldFlag(t.AnnotationFieldFlag.PUSHBUTTON), this.data.pushButton = this.hasFieldFlag(t.AnnotationFieldFlag.PUSHBUTTON), this.data.isTooltipOnly = !1, this.data.checkBox ? this._processCheckBox(N) : this.data.radioButton ? this._processRadioButton(N) : this.data.pushButton ? (this.data.hasOwnCanvas = !0, this._processPushButton(N)) : (0, t.warn)("Invalid field flags for button widget annotation");
            }
            async getOperatorList(N, Z, E, te, re) {
              if (this.data.pushButton)
                return super.getOperatorList(N, Z, E, !1, re);
              let ee = null, $ = null;
              if (re) {
                const H = re.get(this.data.id);
                ee = H ? H.value : null, $ = H ? H.rotation : null;
              }
              if (ee === null && this.appearance)
                return super.getOperatorList(N, Z, E, te, re);
              ee == null && (this.data.checkBox ? ee = this.data.fieldValue === this.data.exportValue : ee = this.data.fieldValue === this.data.buttonValue);
              const k = ee ? this.checkedAppearance : this.uncheckedAppearance;
              if (k) {
                const H = this.appearance, ne = k.dict.getArray("Matrix") || t.IDENTITY_MATRIX;
                $ && k.dict.set("Matrix", this.getRotationMatrix(re)), this.appearance = k;
                const ae = super.getOperatorList(N, Z, E, te, re);
                return this.appearance = H, k.dict.set("Matrix", ne), ae;
              }
              return {
                opList: new n.OperatorList(),
                separateForm: !1,
                separateCanvas: !1
              };
            }
            async save(N, Z, E) {
              return this.data.checkBox ? this._saveCheckbox(N, Z, E) : this.data.radioButton ? this._saveRadioButton(N, Z, E) : null;
            }
            async _saveCheckbox(N, Z, E) {
              if (!E)
                return null;
              const te = E.get(this.data.id);
              let re = te && te.rotation, ee = te && te.value;
              if (re === void 0 && (ee === void 0 || this.data.fieldValue === this.data.exportValue === ee))
                return null;
              const $ = N.xref.fetchIfRef(this.ref);
              if (!($ instanceof a.Dict))
                return null;
              re === void 0 && (re = this.rotation), ee === void 0 && (ee = this.data.fieldValue === this.data.exportValue);
              const k = {
                path: (0, t.stringToPDFString)($.get("T") || ""),
                value: ee ? this.data.exportValue : ""
              }, H = a.Name.get(ee ? this.data.exportValue : "Off");
              $.set("V", H), $.set("AS", H), $.set("M", `D:${(0, t.getModificationDate)()}`);
              const ne = this._getMKDict(re);
              ne && $.set("MK", ne);
              const ae = N.xref.encrypt;
              let he = null;
              ae && (he = ae.createCipherTransform(this.ref.num, this.ref.gen));
              const ue = [`${this.ref.num} ${this.ref.gen} obj
`];
              return (0, e.writeDict)($, ue, he), ue.push(`
endobj
`), [{
                ref: this.ref,
                data: ue.join(""),
                xfa: k
              }];
            }
            async _saveRadioButton(N, Z, E) {
              if (!E)
                return null;
              const te = E.get(this.data.id);
              let re = te && te.rotation, ee = te && te.value;
              if (re === void 0 && (ee === void 0 || this.data.fieldValue === this.data.buttonValue === ee))
                return null;
              const $ = N.xref.fetchIfRef(this.ref);
              if (!($ instanceof a.Dict))
                return null;
              ee === void 0 && (ee = this.data.fieldValue === this.data.buttonValue), re === void 0 && (re = this.rotation);
              const k = {
                path: (0, t.stringToPDFString)($.get("T") || ""),
                value: ee ? this.data.buttonValue : ""
              }, H = a.Name.get(ee ? this.data.buttonValue : "Off");
              let ne = null;
              const ae = N.xref.encrypt;
              if (ee)
                if (this.parent instanceof a.Ref) {
                  const Fe = N.xref.fetch(this.parent);
                  let we = null;
                  ae && (we = ae.createCipherTransform(this.parent.num, this.parent.gen)), Fe.set("V", H), ne = [`${this.parent.num} ${this.parent.gen} obj
`], (0, e.writeDict)(Fe, ne, we), ne.push(`
endobj
`);
                } else
                  this.parent instanceof a.Dict && this.parent.set("V", H);
              $.set("AS", H), $.set("M", `D:${(0, t.getModificationDate)()}`);
              const he = this._getMKDict(re);
              he && $.set("MK", he);
              let ue = null;
              ae && (ue = ae.createCipherTransform(this.ref.num, this.ref.gen));
              const fe = [`${this.ref.num} ${this.ref.gen} obj
`];
              (0, e.writeDict)($, fe, ue), fe.push(`
endobj
`);
              const me = [{
                ref: this.ref,
                data: fe.join(""),
                xfa: k
              }];
              return ne !== null && me.push({
                ref: this.parent,
                data: ne.join(""),
                xfa: null
              }), me;
            }
            _getDefaultCheckedAppearance(N, Z) {
              const E = this.data.rect[2] - this.data.rect[0], te = this.data.rect[3] - this.data.rect[1], re = [0, 0, E, te], ee = 0.8, $ = Math.min(E, te) * ee;
              let k, H;
              Z === "check" ? (k = {
                width: 0.755 * $,
                height: 0.705 * $
              }, H = "3") : Z === "disc" ? (k = {
                width: 0.791 * $,
                height: 0.705 * $
              }, H = "l") : (0, t.unreachable)(`_getDefaultCheckedAppearance - unsupported type: ${Z}`);
              const ne = (0, i.numberToString)((E - k.width) / 2), ae = (0, i.numberToString)((te - k.height) / 2), he = `q BT /PdfJsZaDb ${$} Tf 0 g ${ne} ${ae} Td (${H}) Tj ET Q`, ue = new a.Dict(N.xref);
              ue.set("FormType", 1), ue.set("Subtype", a.Name.get("Form")), ue.set("Type", a.Name.get("XObject")), ue.set("BBox", re), ue.set("Matrix", [1, 0, 0, 1, 0, 0]), ue.set("Length", he.length);
              const fe = new a.Dict(N.xref), me = new a.Dict(N.xref);
              me.set("PdfJsZaDb", this.fallbackFontDict), fe.set("Font", me), ue.set("Resources", fe), this.checkedAppearance = new o.StringStream(he), this.checkedAppearance.dict = ue, this._streams.push(this.checkedAppearance);
            }
            _processCheckBox(N) {
              const Z = N.dict.get("AP");
              if (!(Z instanceof a.Dict))
                return;
              const E = Z.get("N");
              if (!(E instanceof a.Dict))
                return;
              const te = this._decodeFormValue(N.dict.get("AS"));
              typeof te == "string" && (this.data.fieldValue = te);
              const re = this.data.fieldValue !== null && this.data.fieldValue !== "Off" ? this.data.fieldValue : "Yes", ee = E.getKeys();
              if (ee.length === 0)
                ee.push("Off", re);
              else if (ee.length === 1)
                ee[0] === "Off" ? ee.push(re) : ee.unshift("Off");
              else if (ee.includes(re))
                ee.length = 0, ee.push("Off", re);
              else {
                const $ = ee.find((k) => k !== "Off");
                ee.length = 0, ee.push("Off", $);
              }
              ee.includes(this.data.fieldValue) || (this.data.fieldValue = "Off"), this.data.exportValue = ee[1], this.checkedAppearance = E.get(this.data.exportValue) || null, this.uncheckedAppearance = E.get("Off") || null, this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(N, "check"), this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance), this._fallbackFontDict = this.fallbackFontDict;
            }
            _processRadioButton(N) {
              this.data.fieldValue = this.data.buttonValue = null;
              const Z = N.dict.get("Parent");
              if (Z instanceof a.Dict) {
                this.parent = N.dict.getRaw("Parent");
                const re = Z.get("V");
                re instanceof a.Name && (this.data.fieldValue = this._decodeFormValue(re));
              }
              const E = N.dict.get("AP");
              if (!(E instanceof a.Dict))
                return;
              const te = E.get("N");
              if (te instanceof a.Dict) {
                for (const re of te.getKeys())
                  if (re !== "Off") {
                    this.data.buttonValue = this._decodeFormValue(re);
                    break;
                  }
                this.checkedAppearance = te.get(this.data.buttonValue) || null, this.uncheckedAppearance = te.get("Off") || null, this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(N, "disc"), this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance), this._fallbackFontDict = this.fallbackFontDict;
              }
            }
            _processPushButton(N) {
              if (!N.dict.has("A") && !N.dict.has("AA") && !this.data.alternativeText) {
                (0, t.warn)("Push buttons without action dictionaries are not supported");
                return;
              }
              this.data.isTooltipOnly = !N.dict.has("A") && !N.dict.has("AA"), h.Catalog.parseDestDictionary({
                destDict: N.dict,
                resultObj: this.data,
                docBaseUrl: N.pdfManager.docBaseUrl
              });
            }
            getFieldObject() {
              let N = "button", Z;
              return this.data.checkBox ? (N = "checkbox", Z = this.data.exportValue) : this.data.radioButton && (N = "radiobutton", Z = this.data.buttonValue), {
                id: this.data.id,
                value: this.data.fieldValue || "Off",
                defaultValue: this.data.defaultFieldValue,
                exportValues: Z,
                editable: !this.data.readOnly,
                name: this.data.fieldName,
                rect: this.data.rect,
                hidden: this.data.hidden,
                actions: this.data.actions,
                page: this.data.pageIndex,
                strokeColor: this.data.borderColor,
                fillColor: this.data.backgroundColor,
                rotation: this.rotation,
                type: N
              };
            }
            get fallbackFontDict() {
              const N = new a.Dict();
              return N.set("BaseFont", a.Name.get("ZapfDingbats")), N.set("Type", a.Name.get("FallbackType")), N.set("Subtype", a.Name.get("FallbackType")), N.set("Encoding", a.Name.get("ZapfDingbatsEncoding")), (0, t.shadow)(this, "fallbackFontDict", N);
            }
          }
          class D extends j {
            constructor(N) {
              super(N), this.data.options = [];
              const Z = (0, i.getInheritableProperty)({
                dict: N.dict,
                key: "Opt"
              });
              if (Array.isArray(Z)) {
                const E = N.xref;
                for (let te = 0, re = Z.length; te < re; te++) {
                  const ee = E.fetchIfRef(Z[te]), $ = Array.isArray(ee);
                  this.data.options[te] = {
                    exportValue: this._decodeFormValue($ ? E.fetchIfRef(ee[0]) : ee),
                    displayValue: this._decodeFormValue($ ? E.fetchIfRef(ee[1]) : ee)
                  };
                }
              }
              typeof this.data.fieldValue == "string" ? this.data.fieldValue = [this.data.fieldValue] : this.data.fieldValue || (this.data.fieldValue = []), this.data.combo = this.hasFieldFlag(t.AnnotationFieldFlag.COMBO), this.data.multiSelect = this.hasFieldFlag(t.AnnotationFieldFlag.MULTISELECT), this._hasText = !0;
            }
            getFieldObject() {
              const N = this.data.combo ? "combobox" : "listbox", Z = this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
              return {
                id: this.data.id,
                value: Z,
                defaultValue: this.data.defaultFieldValue,
                editable: !this.data.readOnly,
                name: this.data.fieldName,
                rect: this.data.rect,
                numItems: this.data.fieldValue.length,
                multipleSelection: this.data.multiSelect,
                hidden: this.data.hidden,
                actions: this.data.actions,
                items: this.data.options,
                page: this.data.pageIndex,
                strokeColor: this.data.borderColor,
                fillColor: this.data.backgroundColor,
                rotation: this.rotation,
                type: N
              };
            }
            async _getAppearance(N, Z, E) {
              if (this.data.combo)
                return super._getAppearance(N, Z, E);
              if (!E)
                return null;
              const te = E.get(this.data.id);
              if (!te)
                return null;
              const re = te.rotation;
              let ee = te.value;
              if (re === void 0 && ee === void 0)
                return null;
              ee === void 0 ? ee = this.data.fieldValue : Array.isArray(ee) || (ee = [ee]);
              const $ = 2, k = $;
              let H = this.data.rect[3] - this.data.rect[1], ne = this.data.rect[2] - this.data.rect[0];
              (re === 90 || re === 270) && ([ne, H] = [H, ne]);
              const ae = this.data.options.length, he = [];
              for (let ve = 0; ve < ae; ve++) {
                const {
                  exportValue: Se
                } = this.data.options[ve];
                ee.includes(Se) && he.push(ve);
              }
              this._defaultAppearance || (this.data.defaultAppearanceData = (0, v.parseDefaultAppearance)(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
              const ue = await j._getFontData(N, Z, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
              let fe, {
                fontSize: me
              } = this.data.defaultAppearanceData;
              if (me)
                fe = this._defaultAppearance;
              else {
                const ve = (H - $) / ae;
                let Se = -1, be;
                for (const {
                  displayValue: Le
                } of this.data.options) {
                  const ze = this._getTextWidth(Le, ue);
                  ze > Se && (Se = ze, be = Le);
                }
                [fe, me] = this._computeFontSize(ve, ne - 2 * k, be, ue, -1);
              }
              const Fe = me * t.LINE_FACTOR, we = (Fe - me) / 2, Ae = Math.floor(H / Fe);
              let De;
              if (he.length === 1) {
                const ve = he[0], Se = ve % Ae;
                De = ve - Se;
              } else
                De = he.length ? he[0] : 0;
              const xe = Math.min(De + Ae + 1, ae), Te = ["/Tx BMC q", `1 1 ${ne} ${H} re W n`];
              if (he.length) {
                Te.push("0.600006 0.756866 0.854904 rg");
                for (const ve of he)
                  De <= ve && ve < xe && Te.push(`1 ${H - (ve - De + 1) * Fe} ${ne} ${Fe} re f`);
              }
              Te.push("BT", fe, `1 0 0 1 0 ${H} Tm`);
              for (let ve = De; ve < xe; ve++) {
                const {
                  displayValue: Se
                } = this.data.options[ve], be = ve === De ? k : 0, Le = ve === De ? we : 0;
                Te.push(this._renderText(Se, ue, me, ne, 0, be, -Fe + Le));
              }
              return Te.push("ET Q EMC"), Te.join(`
`);
            }
          }
          class b extends j {
            constructor(N) {
              super(N), this.data.fieldValue = null;
            }
            getFieldObject() {
              return {
                id: this.data.id,
                value: null,
                page: this.data.pageIndex,
                type: "signature"
              };
            }
          }
          class l extends M {
            constructor(N) {
              super(N);
              const E = N.dict;
              this.data.annotationType = t.AnnotationType.TEXT, this.data.hasAppearance ? this.data.name = "NoIcon" : (this.data.rect[1] = this.data.rect[3] - 22, this.data.rect[2] = this.data.rect[0] + 22, this.data.name = E.has("Name") ? E.get("Name").name : "Note"), E.has("State") ? (this.data.state = E.get("State") || null, this.data.stateModel = E.get("StateModel") || null) : (this.data.state = null, this.data.stateModel = null);
            }
          }
          class _ extends w {
            constructor(N) {
              super(N), this.data.annotationType = t.AnnotationType.LINK;
              const Z = C(N.dict, this.rectangle);
              Z && (this.data.quadPoints = Z), this.data.borderColor = this.data.borderColor || this.data.color, h.Catalog.parseDestDictionary({
                destDict: N.dict,
                resultObj: this.data,
                docBaseUrl: N.pdfManager.docBaseUrl
              });
            }
          }
          class S extends w {
            constructor(N) {
              super(N), this.data.annotationType = t.AnnotationType.POPUP;
              let Z = N.dict.get("Parent");
              if (!Z) {
                (0, t.warn)("Popup annotation has a missing or invalid parent annotation.");
                return;
              }
              const E = Z.get("Subtype");
              this.data.parentType = E instanceof a.Name ? E.name : null;
              const te = N.dict.getRaw("Parent");
              this.data.parentId = te instanceof a.Ref ? te.toString() : null;
              const re = Z.getArray("Rect");
              Array.isArray(re) && re.length === 4 ? this.data.parentRect = t.Util.normalizeRect(re) : this.data.parentRect = [0, 0, 0, 0];
              const ee = Z.get("RT");
              if ((0, a.isName)(ee, t.AnnotationReplyType.GROUP) && (Z = Z.get("IRT")), Z.has("M") ? (this.setModificationDate(Z.get("M")), this.data.modificationDate = this.modificationDate) : this.data.modificationDate = null, Z.has("C") ? (this.setColor(Z.getArray("C")), this.data.color = this.color) : this.data.color = null, !this.viewable) {
                const $ = Z.get("F");
                this._isViewable($) && this.setFlags($);
              }
              this.setTitle(Z.get("T")), this.data.titleObj = this._title, this.setContents(Z.get("Contents")), this.data.contentsObj = this._contents, Z.has("RC") && (this.data.richText = x.XFAFactory.getRichTextAsHtml(Z.get("RC")));
            }
          }
          u.PopupAnnotation = S;
          class A extends M {
            constructor(N) {
              super(N), this.data.annotationType = t.AnnotationType.FREETEXT;
            }
            get hasTextContent() {
              return !!this.appearance;
            }
            static createNewDict(N, Z, {
              apRef: E,
              ap: te
            }) {
              const {
                color: re,
                fontSize: ee,
                rect: $,
                rotation: k,
                user: H,
                value: ne
              } = N, ae = new a.Dict(Z);
              ae.set("Type", a.Name.get("Annot")), ae.set("Subtype", a.Name.get("FreeText")), ae.set("CreationDate", `D:${(0, t.getModificationDate)()}`), ae.set("Rect", $);
              const he = `/Helv ${ee} Tf ${(0, v.getPdfColor)(re, !0)}`;
              ae.set("DA", he), ae.set("Contents", ne), ae.set("F", 4), ae.set("Border", [0, 0, 0]), ae.set("Rotate", k), H && ae.set("T", (0, t.stringToUTF8String)(H));
              const ue = new a.Dict(Z);
              return ae.set("AP", ue), E ? ue.set("N", E) : ue.set("N", te), ae;
            }
            static async createNewAppearanceStream(N, Z, E) {
              const {
                baseFontRef: te,
                evaluator: re,
                task: ee
              } = E, {
                color: $,
                fontSize: k,
                rect: H,
                rotation: ne,
                value: ae
              } = N, he = new a.Dict(Z), ue = new a.Dict(Z);
              if (te)
                ue.set("Helv", te);
              else {
                const Ft = new a.Dict(Z);
                Ft.set("BaseFont", a.Name.get("Helvetica")), Ft.set("Type", a.Name.get("Font")), Ft.set("Subtype", a.Name.get("Type1")), Ft.set("Encoding", a.Name.get("WinAnsiEncoding")), ue.set("Helv", Ft);
              }
              he.set("Font", ue);
              const fe = await j._getFontData(re, ee, {
                fontName: "Helvetica",
                fontSize: k
              }, he), [me, Fe, we, Ae] = H;
              let De = we - me, xe = Ae - Fe;
              ne % 180 !== 0 && ([De, xe] = [xe, De]);
              const Te = ae.split(`
`), ve = k / 1e3;
              let Se = -1 / 0;
              const be = [];
              for (let Ft of Te) {
                Ft = fe.encodeString(Ft).join(""), be.push(Ft);
                let $e = 0;
                const St = fe.charsToGlyphs(Ft);
                for (const xt of St)
                  $e += xt.width * ve;
                Se = Math.max(Se, $e);
              }
              let Le = 1;
              Se > De && (Le = De / Se);
              let ze = 1;
              const nt = t.LINE_FACTOR * k, Ue = t.LINE_DESCENT_FACTOR * k, Oe = nt * Te.length;
              Oe > xe && (ze = xe / Oe);
              const _e = Math.min(Le, ze), at = k * _e, Je = ["q", `0 0 ${(0, i.numberToString)(De)} ${(0, i.numberToString)(xe)} re W n`, "BT", `1 0 0 1 0 ${(0, i.numberToString)(xe + Ue)} Tm 0 Tc ${(0, v.getPdfColor)($, !0)}`, `/Helv ${(0, i.numberToString)(at)} Tf`], ot = (0, i.numberToString)(nt);
              for (const Ft of be)
                Je.push(`0 -${ot} Td (${(0, t.escapeString)(Ft)}) Tj`);
              Je.push("ET", "Q");
              const mt = Je.join(`
`), Ze = new a.Dict(Z);
              if (Ze.set("FormType", 1), Ze.set("Subtype", a.Name.get("Form")), Ze.set("Type", a.Name.get("XObject")), Ze.set("BBox", [0, 0, De, xe]), Ze.set("Length", mt.length), Ze.set("Resources", he), ne) {
                const Ft = j._getRotationMatrix(ne, De, xe);
                Ze.set("Matrix", Ft);
              }
              const pt = new o.StringStream(mt);
              return pt.dict = Ze, pt;
            }
          }
          class F extends M {
            constructor(N) {
              super(N);
              const {
                dict: Z
              } = N;
              this.data.annotationType = t.AnnotationType.LINE;
              const E = Z.getArray("L");
              if (this.data.lineCoordinates = t.Util.normalizeRect(E), this.setLineEndings(Z.getArray("LE")), this.data.lineEndings = this.lineEndings, !this.appearance) {
                const te = this.color ? Array.from(this.color).map((he) => he / 255) : [0, 0, 0], re = Z.get("CA");
                let ee = null, $ = Z.getArray("IC");
                $ && ($ = m($, null), ee = $ ? Array.from($).map((he) => he / 255) : null);
                const k = ee ? re : null, H = this.borderStyle.width || 1, ne = 2 * H, ae = [this.data.lineCoordinates[0] - ne, this.data.lineCoordinates[1] - ne, this.data.lineCoordinates[2] + ne, this.data.lineCoordinates[3] + ne];
                t.Util.intersect(this.rectangle, ae) || (this.rectangle = ae), this._setDefaultAppearance({
                  xref: N.xref,
                  extra: `${H} w`,
                  strokeColor: te,
                  fillColor: ee,
                  strokeAlpha: re,
                  fillAlpha: k,
                  pointsCallback: (he, ue) => (he.push(`${E[0]} ${E[1]} m`, `${E[2]} ${E[3]} l`, "S"), [ue[0].x - H, ue[1].x + H, ue[3].y - H, ue[1].y + H])
                });
              }
            }
          }
          class T extends M {
            constructor(N) {
              if (super(N), this.data.annotationType = t.AnnotationType.SQUARE, !this.appearance) {
                const Z = this.color ? Array.from(this.color).map(($) => $ / 255) : [0, 0, 0], E = N.dict.get("CA");
                let te = null, re = N.dict.getArray("IC");
                re && (re = m(re, null), te = re ? Array.from(re).map(($) => $ / 255) : null);
                const ee = te ? E : null;
                if (this.borderStyle.width === 0 && !te)
                  return;
                this._setDefaultAppearance({
                  xref: N.xref,
                  extra: `${this.borderStyle.width} w`,
                  strokeColor: Z,
                  fillColor: te,
                  strokeAlpha: E,
                  fillAlpha: ee,
                  pointsCallback: ($, k) => {
                    const H = k[2].x + this.borderStyle.width / 2, ne = k[2].y + this.borderStyle.width / 2, ae = k[3].x - k[2].x - this.borderStyle.width, he = k[1].y - k[3].y - this.borderStyle.width;
                    return $.push(`${H} ${ne} ${ae} ${he} re`), te ? $.push("B") : $.push("S"), [k[0].x, k[1].x, k[3].y, k[1].y];
                  }
                });
              }
            }
          }
          class O extends M {
            constructor(N) {
              if (super(N), this.data.annotationType = t.AnnotationType.CIRCLE, !this.appearance) {
                const Z = this.color ? Array.from(this.color).map((k) => k / 255) : [0, 0, 0], E = N.dict.get("CA");
                let te = null, re = N.dict.getArray("IC");
                re && (re = m(re, null), te = re ? Array.from(re).map((k) => k / 255) : null);
                const ee = te ? E : null;
                if (this.borderStyle.width === 0 && !te)
                  return;
                const $ = 4 / 3 * Math.tan(Math.PI / (2 * 4));
                this._setDefaultAppearance({
                  xref: N.xref,
                  extra: `${this.borderStyle.width} w`,
                  strokeColor: Z,
                  fillColor: te,
                  strokeAlpha: E,
                  fillAlpha: ee,
                  pointsCallback: (k, H) => {
                    const ne = H[0].x + this.borderStyle.width / 2, ae = H[0].y - this.borderStyle.width / 2, he = H[3].x - this.borderStyle.width / 2, ue = H[3].y + this.borderStyle.width / 2, fe = ne + (he - ne) / 2, me = ae + (ue - ae) / 2, Fe = (he - ne) / 2 * $, we = (ue - ae) / 2 * $;
                    return k.push(`${fe} ${ue} m`, `${fe + Fe} ${ue} ${he} ${me + we} ${he} ${me} c`, `${he} ${me - we} ${fe + Fe} ${ae} ${fe} ${ae} c`, `${fe - Fe} ${ae} ${ne} ${me - we} ${ne} ${me} c`, `${ne} ${me + we} ${fe - Fe} ${ue} ${fe} ${ue} c`, "h"), te ? k.push("B") : k.push("S"), [H[0].x, H[1].x, H[3].y, H[1].y];
                  }
                });
              }
            }
          }
          class U extends M {
            constructor(N) {
              super(N);
              const {
                dict: Z
              } = N;
              this.data.annotationType = t.AnnotationType.POLYLINE, this.data.vertices = [], this instanceof G || (this.setLineEndings(Z.getArray("LE")), this.data.lineEndings = this.lineEndings);
              const E = Z.getArray("Vertices");
              if (Array.isArray(E)) {
                for (let te = 0, re = E.length; te < re; te += 2)
                  this.data.vertices.push({
                    x: E[te],
                    y: E[te + 1]
                  });
                if (!this.appearance) {
                  const te = this.color ? Array.from(this.color).map((H) => H / 255) : [0, 0, 0], re = Z.get("CA"), ee = this.borderStyle.width || 1, $ = 2 * ee, k = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                  for (const H of this.data.vertices)
                    k[0] = Math.min(k[0], H.x - $), k[1] = Math.min(k[1], H.y - $), k[2] = Math.max(k[2], H.x + $), k[3] = Math.max(k[3], H.y + $);
                  t.Util.intersect(this.rectangle, k) || (this.rectangle = k), this._setDefaultAppearance({
                    xref: N.xref,
                    extra: `${ee} w`,
                    strokeColor: te,
                    strokeAlpha: re,
                    pointsCallback: (H, ne) => {
                      const ae = this.data.vertices;
                      for (let he = 0, ue = ae.length; he < ue; he++)
                        H.push(`${ae[he].x} ${ae[he].y} ${he === 0 ? "m" : "l"}`);
                      return H.push("S"), [ne[0].x, ne[1].x, ne[3].y, ne[1].y];
                    }
                  });
                }
              }
            }
          }
          class G extends U {
            constructor(N) {
              super(N), this.data.annotationType = t.AnnotationType.POLYGON;
            }
          }
          class K extends M {
            constructor(N) {
              super(N), this.data.annotationType = t.AnnotationType.CARET;
            }
          }
          class W extends M {
            constructor(N) {
              super(N), this.data.annotationType = t.AnnotationType.INK, this.data.inkLists = [];
              const Z = N.dict.getArray("InkList");
              if (!Array.isArray(Z))
                return;
              const E = N.xref;
              for (let te = 0, re = Z.length; te < re; ++te) {
                this.data.inkLists.push([]);
                for (let ee = 0, $ = Z[te].length; ee < $; ee += 2)
                  this.data.inkLists[te].push({
                    x: E.fetchIfRef(Z[te][ee]),
                    y: E.fetchIfRef(Z[te][ee + 1])
                  });
              }
              if (!this.appearance) {
                const te = this.color ? Array.from(this.color).map((H) => H / 255) : [0, 0, 0], re = N.dict.get("CA"), ee = this.borderStyle.width || 1, $ = 2 * ee, k = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                for (const H of this.data.inkLists)
                  for (const ne of H)
                    k[0] = Math.min(k[0], ne.x - $), k[1] = Math.min(k[1], ne.y - $), k[2] = Math.max(k[2], ne.x + $), k[3] = Math.max(k[3], ne.y + $);
                t.Util.intersect(this.rectangle, k) || (this.rectangle = k), this._setDefaultAppearance({
                  xref: N.xref,
                  extra: `${ee} w`,
                  strokeColor: te,
                  strokeAlpha: re,
                  pointsCallback: (H, ne) => {
                    for (const ae of this.data.inkLists) {
                      for (let he = 0, ue = ae.length; he < ue; he++)
                        H.push(`${ae[he].x} ${ae[he].y} ${he === 0 ? "m" : "l"}`);
                      H.push("S");
                    }
                    return [ne[0].x, ne[1].x, ne[3].y, ne[1].y];
                  }
                });
              }
            }
            static createNewDict(N, Z, {
              apRef: E,
              ap: te
            }) {
              const {
                paths: re,
                rect: ee,
                rotation: $
              } = N, k = new a.Dict(Z);
              k.set("Type", a.Name.get("Annot")), k.set("Subtype", a.Name.get("Ink")), k.set("CreationDate", `D:${(0, t.getModificationDate)()}`), k.set("Rect", ee), k.set("InkList", re.map((ne) => ne.points)), k.set("F", 4), k.set("Border", [0, 0, 0]), k.set("Rotate", $);
              const H = new a.Dict(Z);
              return k.set("AP", H), E ? H.set("N", E) : H.set("N", te), k;
            }
            static async createNewAppearanceStream(N, Z, E) {
              const {
                color: te,
                rect: re,
                rotation: ee,
                paths: $,
                thickness: k,
                opacity: H
              } = N, [ne, ae, he, ue] = re;
              let fe = he - ne, me = ue - ae;
              ee % 180 !== 0 && ([fe, me] = [me, fe]);
              const Fe = [`${k} w 1 J 1 j`, `${(0, v.getPdfColor)(te, !1)}`];
              H !== 1 && Fe.push("/R0 gs");
              const we = [];
              for (const {
                bezier: Te
              } of $) {
                we.length = 0, we.push(`${(0, i.numberToString)(Te[0])} ${(0, i.numberToString)(Te[1])} m`);
                for (let ve = 2, Se = Te.length; ve < Se; ve += 6) {
                  const be = Te.slice(ve, ve + 6).map(i.numberToString).join(" ");
                  we.push(`${be} c`);
                }
                we.push("S"), Fe.push(we.join(`
`));
              }
              const Ae = Fe.join(`
`), De = new a.Dict(Z);
              if (De.set("FormType", 1), De.set("Subtype", a.Name.get("Form")), De.set("Type", a.Name.get("XObject")), De.set("BBox", [0, 0, fe, me]), De.set("Length", Ae.length), ee) {
                const Te = j._getRotationMatrix(ee, fe, me);
                De.set("Matrix", Te);
              }
              if (H !== 1) {
                const Te = new a.Dict(Z), ve = new a.Dict(Z), Se = new a.Dict(Z);
                Se.set("CA", H), Se.set("Type", a.Name.get("ExtGState")), ve.set("R0", Se), Te.set("ExtGState", ve), De.set("Resources", Te);
              }
              const xe = new o.StringStream(Ae);
              return xe.dict = De, xe;
            }
          }
          class z extends M {
            constructor(N) {
              if (super(N), this.data.annotationType = t.AnnotationType.HIGHLIGHT, this.data.quadPoints = C(N.dict, null)) {
                const E = this.appearance && this.appearance.dict.get("Resources");
                if (!this.appearance || !(E && E.has("ExtGState"))) {
                  this.appearance && (0, t.warn)("HighlightAnnotation - ignoring built-in appearance stream.");
                  const te = this.color ? Array.from(this.color).map((ee) => ee / 255) : [1, 1, 0], re = N.dict.get("CA");
                  this._setDefaultAppearance({
                    xref: N.xref,
                    fillColor: te,
                    blendMode: "Multiply",
                    fillAlpha: re,
                    pointsCallback: (ee, $) => (ee.push(`${$[0].x} ${$[0].y} m`, `${$[1].x} ${$[1].y} l`, `${$[3].x} ${$[3].y} l`, `${$[2].x} ${$[2].y} l`, "f"), [$[0].x, $[1].x, $[3].y, $[1].y])
                  });
                }
              } else
                this.data.hasPopup = !1;
            }
          }
          class V extends M {
            constructor(N) {
              if (super(N), this.data.annotationType = t.AnnotationType.UNDERLINE, this.data.quadPoints = C(N.dict, null)) {
                if (!this.appearance) {
                  const E = this.color ? Array.from(this.color).map((re) => re / 255) : [0, 0, 0], te = N.dict.get("CA");
                  this._setDefaultAppearance({
                    xref: N.xref,
                    extra: "[] 0 d 1 w",
                    strokeColor: E,
                    strokeAlpha: te,
                    pointsCallback: (re, ee) => (re.push(`${ee[2].x} ${ee[2].y} m`, `${ee[3].x} ${ee[3].y} l`, "S"), [ee[0].x, ee[1].x, ee[3].y, ee[1].y])
                  });
                }
              } else
                this.data.hasPopup = !1;
            }
          }
          class L extends M {
            constructor(N) {
              if (super(N), this.data.annotationType = t.AnnotationType.SQUIGGLY, this.data.quadPoints = C(N.dict, null)) {
                if (!this.appearance) {
                  const E = this.color ? Array.from(this.color).map((re) => re / 255) : [0, 0, 0], te = N.dict.get("CA");
                  this._setDefaultAppearance({
                    xref: N.xref,
                    extra: "[] 0 d 1 w",
                    strokeColor: E,
                    strokeAlpha: te,
                    pointsCallback: (re, ee) => {
                      const $ = (ee[0].y - ee[2].y) / 6;
                      let k = $, H = ee[2].x;
                      const ne = ee[2].y, ae = ee[3].x;
                      re.push(`${H} ${ne + k} m`);
                      do
                        H += 2, k = k === 0 ? $ : 0, re.push(`${H} ${ne + k} l`);
                      while (H < ae);
                      return re.push("S"), [ee[2].x, ae, ne - 2 * $, ne + 2 * $];
                    }
                  });
                }
              } else
                this.data.hasPopup = !1;
            }
          }
          class Y extends M {
            constructor(N) {
              if (super(N), this.data.annotationType = t.AnnotationType.STRIKEOUT, this.data.quadPoints = C(N.dict, null)) {
                if (!this.appearance) {
                  const E = this.color ? Array.from(this.color).map((re) => re / 255) : [0, 0, 0], te = N.dict.get("CA");
                  this._setDefaultAppearance({
                    xref: N.xref,
                    extra: "[] 0 d 1 w",
                    strokeColor: E,
                    strokeAlpha: te,
                    pointsCallback: (re, ee) => (re.push(`${(ee[0].x + ee[2].x) / 2} ${(ee[0].y + ee[2].y) / 2} m`, `${(ee[1].x + ee[3].x) / 2} ${(ee[1].y + ee[3].y) / 2} l`, "S"), [ee[0].x, ee[1].x, ee[3].y, ee[1].y])
                  });
                }
              } else
                this.data.hasPopup = !1;
            }
          }
          class J extends M {
            constructor(N) {
              super(N), this.data.annotationType = t.AnnotationType.STAMP;
            }
          }
          class ie extends M {
            constructor(N) {
              super(N);
              const Z = new d.FileSpec(N.dict.get("FS"), N.xref);
              this.data.annotationType = t.AnnotationType.FILEATTACHMENT, this.data.file = Z.serializable;
            }
          }
        },
        /* 13 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.createDefaultAppearance = d, u.getPdfColor = g, u.parseDefaultAppearance = h;
          var t = P(6), i = P(2), v = P(14), a = P(15), e = P(5), y = P(10);
          class r extends a.EvaluatorPreprocessor {
            constructor(n) {
              super(new y.StringStream(n));
            }
            parse() {
              const n = {
                fn: 0,
                args: []
              }, o = {
                fontSize: 0,
                fontName: "",
                fontColor: new Uint8ClampedArray(3)
              };
              try {
                for (; n.args.length = 0, !!this.read(n); ) {
                  if (this.savedStatesDepth !== 0)
                    continue;
                  const {
                    fn: x,
                    args: f
                  } = n;
                  switch (x | 0) {
                    case i.OPS.setFont:
                      const [m, C] = f;
                      m instanceof e.Name && (o.fontName = m.name), typeof C == "number" && C > 0 && (o.fontSize = C);
                      break;
                    case i.OPS.setFillRGBColor:
                      v.ColorSpace.singletons.rgb.getRgbItem(f, 0, o.fontColor, 0);
                      break;
                    case i.OPS.setFillGray:
                      v.ColorSpace.singletons.gray.getRgbItem(f, 0, o.fontColor, 0);
                      break;
                    case i.OPS.setFillColorSpace:
                      v.ColorSpace.singletons.cmyk.getRgbItem(f, 0, o.fontColor, 0);
                      break;
                  }
                }
              } catch (x) {
                (0, i.warn)(`parseDefaultAppearance - ignoring errors: "${x}".`);
              }
              return o;
            }
          }
          function h(c) {
            return new r(c).parse();
          }
          function g(c, n) {
            if (c[0] === c[1] && c[1] === c[2]) {
              const o = c[0] / 255;
              return `${(0, t.numberToString)(o)} ${n ? "g" : "G"}`;
            }
            return Array.from(c).map((o) => (0, t.numberToString)(o / 255)).join(" ") + ` ${n ? "rg" : "RG"}`;
          }
          function d({
            fontSize: c,
            fontName: n,
            fontColor: o
          }) {
            return `/${(0, t.escapePDFName)(n)} ${c} Tf ${g(o, !0)}`;
          }
        },
        /* 14 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.ColorSpace = void 0;
          var t = P(2), i = P(5), v = P(7), a = P(6);
          function e(m, C, p, w, X, M, j) {
            j = j !== 1 ? 0 : j;
            const R = p / X, D = w / M;
            let b = 0, l;
            const _ = new Uint16Array(X), S = p * 3;
            for (let A = 0; A < X; A++)
              _[A] = Math.floor(A * R) * 3;
            for (let A = 0; A < M; A++) {
              const F = Math.floor(A * D) * S;
              for (let T = 0; T < X; T++)
                l = F + _[T], C[b++] = m[l++], C[b++] = m[l++], C[b++] = m[l++], b += j;
            }
          }
          class y {
            constructor(C, p) {
              this.constructor === y && (0, t.unreachable)("Cannot initialize ColorSpace."), this.name = C, this.numComps = p;
            }
            getRgb(C, p) {
              const w = new Uint8ClampedArray(3);
              return this.getRgbItem(C, p, w, 0), w;
            }
            getRgbItem(C, p, w, X) {
              (0, t.unreachable)("Should not call ColorSpace.getRgbItem");
            }
            getRgbBuffer(C, p, w, X, M, j, B) {
              (0, t.unreachable)("Should not call ColorSpace.getRgbBuffer");
            }
            getOutputLength(C, p) {
              (0, t.unreachable)("Should not call ColorSpace.getOutputLength");
            }
            isPassthrough(C) {
              return !1;
            }
            isDefaultDecode(C, p) {
              return y.isDefaultDecode(C, this.numComps);
            }
            fillRgb(C, p, w, X, M, j, B, R, D) {
              const b = p * w;
              let l = null;
              const _ = 1 << B, S = w !== M || p !== X;
              if (this.isPassthrough(B))
                l = R;
              else if (this.numComps === 1 && b > _ && this.name !== "DeviceGray" && this.name !== "DeviceRGB") {
                const A = B <= 8 ? new Uint8Array(_) : new Uint16Array(_);
                for (let T = 0; T < _; T++)
                  A[T] = T;
                const F = new Uint8ClampedArray(_ * 3);
                if (this.getRgbBuffer(A, 0, _, F, 0, B, 0), S) {
                  l = new Uint8Array(b * 3);
                  let T = 0;
                  for (let O = 0; O < b; ++O) {
                    const U = R[O] * 3;
                    l[T++] = F[U], l[T++] = F[U + 1], l[T++] = F[U + 2];
                  }
                } else {
                  let T = 0;
                  for (let O = 0; O < b; ++O) {
                    const U = R[O] * 3;
                    C[T++] = F[U], C[T++] = F[U + 1], C[T++] = F[U + 2], T += D;
                  }
                }
              } else
                S ? (l = new Uint8ClampedArray(b * 3), this.getRgbBuffer(R, 0, b, l, 0, B, 0)) : this.getRgbBuffer(R, 0, X * j, C, 0, B, D);
              if (l)
                if (S)
                  e(l, C, p, w, X, M, D);
                else {
                  let A = 0, F = 0;
                  for (let T = 0, O = X * j; T < O; T++)
                    C[A++] = l[F++], C[A++] = l[F++], C[A++] = l[F++], A += D;
                }
            }
            get usesZeroToOneRange() {
              return (0, t.shadow)(this, "usesZeroToOneRange", !0);
            }
            static _cache(C, p, w, X) {
              if (!w)
                throw new Error('ColorSpace._cache - expected "localColorSpaceCache" argument.');
              if (!X)
                throw new Error('ColorSpace._cache - expected "parsedColorSpace" argument.');
              let M, j;
              C instanceof i.Ref && (j = C, C = p.fetch(C)), C instanceof i.Name && (M = C.name), (M || j) && w.set(M, j, X);
            }
            static getCached(C, p, w) {
              if (!w)
                throw new Error('ColorSpace.getCached - expected "localColorSpaceCache" argument.');
              if (C instanceof i.Ref) {
                const X = w.getByRef(C);
                if (X)
                  return X;
                try {
                  C = p.fetch(C);
                } catch (M) {
                  if (M instanceof a.MissingDataException)
                    throw M;
                }
              }
              if (C instanceof i.Name) {
                const X = w.getByName(C.name);
                if (X)
                  return X;
              }
              return null;
            }
            static async parseAsync({
              cs: C,
              xref: p,
              resources: w = null,
              pdfFunctionFactory: X,
              localColorSpaceCache: M
            }) {
              const j = this._parse(C, p, w, X);
              return this._cache(C, p, M, j), j;
            }
            static parse({
              cs: C,
              xref: p,
              resources: w = null,
              pdfFunctionFactory: X,
              localColorSpaceCache: M
            }) {
              const j = this.getCached(C, p, M);
              if (j)
                return j;
              const B = this._parse(C, p, w, X);
              return this._cache(C, p, M, B), B;
            }
            static _parse(C, p, w = null, X) {
              if (C = p.fetchIfRef(C), C instanceof i.Name)
                switch (C.name) {
                  case "G":
                  case "DeviceGray":
                    return this.singletons.gray;
                  case "RGB":
                  case "DeviceRGB":
                    return this.singletons.rgb;
                  case "CMYK":
                  case "DeviceCMYK":
                    return this.singletons.cmyk;
                  case "Pattern":
                    return new h(null);
                  default:
                    if (w instanceof i.Dict) {
                      const M = w.get("ColorSpace");
                      if (M instanceof i.Dict) {
                        const j = M.get(C.name);
                        if (j) {
                          if (j instanceof i.Name)
                            return this._parse(j, p, w, X);
                          C = j;
                          break;
                        }
                      }
                    }
                    throw new t.FormatError(`Unrecognized ColorSpace: ${C.name}`);
                }
              if (Array.isArray(C)) {
                const M = p.fetchIfRef(C[0]).name;
                let j, B, R, D, b, l;
                switch (M) {
                  case "G":
                  case "DeviceGray":
                    return this.singletons.gray;
                  case "RGB":
                  case "DeviceRGB":
                    return this.singletons.rgb;
                  case "CMYK":
                  case "DeviceCMYK":
                    return this.singletons.cmyk;
                  case "CalGray":
                    return j = p.fetchIfRef(C[1]), D = j.getArray("WhitePoint"), b = j.getArray("BlackPoint"), l = j.get("Gamma"), new o(D, b, l);
                  case "CalRGB":
                    j = p.fetchIfRef(C[1]), D = j.getArray("WhitePoint"), b = j.getArray("BlackPoint"), l = j.getArray("Gamma");
                    const _ = j.getArray("Matrix");
                    return new x(D, b, l, _);
                  case "ICCBased":
                    const A = p.fetchIfRef(C[1]).dict;
                    B = A.get("N");
                    const F = A.get("Alternate");
                    if (F) {
                      const W = this._parse(F, p, w, X);
                      if (W.numComps === B)
                        return W;
                      (0, t.warn)("ICCBased color space: Ignoring incorrect /Alternate entry.");
                    }
                    if (B === 1)
                      return this.singletons.gray;
                    if (B === 3)
                      return this.singletons.rgb;
                    if (B === 4)
                      return this.singletons.cmyk;
                    break;
                  case "Pattern":
                    return R = C[1] || null, R && (R = this._parse(R, p, w, X)), new h(R);
                  case "I":
                  case "Indexed":
                    R = this._parse(C[1], p, w, X);
                    const T = p.fetchIfRef(C[2]) + 1, O = p.fetchIfRef(C[3]);
                    return new g(R, T, O);
                  case "Separation":
                  case "DeviceN":
                    const U = p.fetchIfRef(C[1]);
                    B = Array.isArray(U) ? U.length : 1, R = this._parse(C[2], p, w, X);
                    const G = X.create(C[3]);
                    return new r(B, R, G);
                  case "Lab":
                    j = p.fetchIfRef(C[1]), D = j.getArray("WhitePoint"), b = j.getArray("BlackPoint");
                    const K = j.getArray("Range");
                    return new f(D, b, K);
                  default:
                    throw new t.FormatError(`Unimplemented ColorSpace object: ${M}`);
                }
              }
              throw new t.FormatError(`Unrecognized ColorSpace object: ${C}`);
            }
            static isDefaultDecode(C, p) {
              if (!Array.isArray(C))
                return !0;
              if (p * 2 !== C.length)
                return (0, t.warn)("The decode map is not the correct length"), !0;
              for (let w = 0, X = C.length; w < X; w += 2)
                if (C[w] !== 0 || C[w + 1] !== 1)
                  return !1;
              return !0;
            }
            static get singletons() {
              return (0, t.shadow)(this, "singletons", {
                get gray() {
                  return (0, t.shadow)(this, "gray", new d());
                },
                get rgb() {
                  return (0, t.shadow)(this, "rgb", new c());
                },
                get cmyk() {
                  return (0, t.shadow)(this, "cmyk", new n());
                }
              });
            }
          }
          u.ColorSpace = y;
          class r extends y {
            constructor(C, p, w) {
              super("Alternate", C), this.base = p, this.tintFn = w, this.tmpBuf = new Float32Array(p.numComps);
            }
            getRgbItem(C, p, w, X) {
              const M = this.tmpBuf;
              this.tintFn(C, p, M, 0), this.base.getRgbItem(M, 0, w, X);
            }
            getRgbBuffer(C, p, w, X, M, j, B) {
              const R = this.tintFn, D = this.base, b = 1 / ((1 << j) - 1), l = D.numComps, _ = D.usesZeroToOneRange, S = (D.isPassthrough(8) || !_) && B === 0;
              let A = S ? M : 0;
              const F = S ? X : new Uint8ClampedArray(l * w), T = this.numComps, O = new Float32Array(T), U = new Float32Array(l);
              let G, K;
              for (G = 0; G < w; G++) {
                for (K = 0; K < T; K++)
                  O[K] = C[p++] * b;
                if (R(O, 0, U, 0), _)
                  for (K = 0; K < l; K++)
                    F[A++] = U[K] * 255;
                else
                  D.getRgbItem(U, 0, F, A), A += l;
              }
              S || D.getRgbBuffer(F, 0, w, X, M, 8, B);
            }
            getOutputLength(C, p) {
              return this.base.getOutputLength(C * this.base.numComps / this.numComps, p);
            }
          }
          class h extends y {
            constructor(C) {
              super("Pattern", null), this.base = C;
            }
            isDefaultDecode(C, p) {
              (0, t.unreachable)("Should not call PatternCS.isDefaultDecode");
            }
          }
          class g extends y {
            constructor(C, p, w) {
              super("Indexed", 1), this.base = C, this.highVal = p;
              const X = C.numComps * p;
              if (this.lookup = new Uint8Array(X), w instanceof v.BaseStream) {
                const M = w.getBytes(X);
                this.lookup.set(M);
              } else if (typeof w == "string")
                for (let M = 0; M < X; ++M)
                  this.lookup[M] = w.charCodeAt(M) & 255;
              else
                throw new t.FormatError(`IndexedCS - unrecognized lookup table: ${w}`);
            }
            getRgbItem(C, p, w, X) {
              const M = this.base.numComps, j = C[p] * M;
              this.base.getRgbBuffer(this.lookup, j, 1, w, X, 8, 0);
            }
            getRgbBuffer(C, p, w, X, M, j, B) {
              const R = this.base, D = R.numComps, b = R.getOutputLength(D, B), l = this.lookup;
              for (let _ = 0; _ < w; ++_) {
                const S = C[p++] * D;
                R.getRgbBuffer(l, S, 1, X, M, 8, B), M += b;
              }
            }
            getOutputLength(C, p) {
              return this.base.getOutputLength(C * this.base.numComps, p);
            }
            isDefaultDecode(C, p) {
              return Array.isArray(C) ? C.length !== 2 ? ((0, t.warn)("Decode map length is not correct"), !0) : !Number.isInteger(p) || p < 1 ? ((0, t.warn)("Bits per component is not correct"), !0) : C[0] === 0 && C[1] === (1 << p) - 1 : !0;
            }
          }
          class d extends y {
            constructor() {
              super("DeviceGray", 1);
            }
            getRgbItem(C, p, w, X) {
              const M = C[p] * 255;
              w[X] = w[X + 1] = w[X + 2] = M;
            }
            getRgbBuffer(C, p, w, X, M, j, B) {
              const R = 255 / ((1 << j) - 1);
              let D = p, b = M;
              for (let l = 0; l < w; ++l) {
                const _ = R * C[D++];
                X[b++] = _, X[b++] = _, X[b++] = _, b += B;
              }
            }
            getOutputLength(C, p) {
              return C * (3 + p);
            }
          }
          class c extends y {
            constructor() {
              super("DeviceRGB", 3);
            }
            getRgbItem(C, p, w, X) {
              w[X] = C[p] * 255, w[X + 1] = C[p + 1] * 255, w[X + 2] = C[p + 2] * 255;
            }
            getRgbBuffer(C, p, w, X, M, j, B) {
              if (j === 8 && B === 0) {
                X.set(C.subarray(p, p + w * 3), M);
                return;
              }
              const R = 255 / ((1 << j) - 1);
              let D = p, b = M;
              for (let l = 0; l < w; ++l)
                X[b++] = R * C[D++], X[b++] = R * C[D++], X[b++] = R * C[D++], b += B;
            }
            getOutputLength(C, p) {
              return C * (3 + p) / 3 | 0;
            }
            isPassthrough(C) {
              return C === 8;
            }
          }
          const n = function() {
            function C(w, X, M, j, B) {
              const R = w[X] * M, D = w[X + 1] * M, b = w[X + 2] * M, l = w[X + 3] * M;
              j[B] = 255 + R * (-4.387332384609988 * R + 54.48615194189176 * D + 18.82290502165302 * b + 212.25662451639585 * l + -285.2331026137004) + D * (1.7149763477362134 * D - 5.6096736904047315 * b + -17.873870861415444 * l - 5.497006427196366) + b * (-2.5217340131683033 * b - 21.248923337353073 * l + 17.5119270841813) + l * (-21.86122147463605 * l - 189.48180835922747), j[B + 1] = 255 + R * (8.841041422036149 * R + 60.118027045597366 * D + 6.871425592049007 * b + 31.159100130055922 * l + -79.2970844816548) + D * (-15.310361306967817 * D + 17.575251261109482 * b + 131.35250912493976 * l - 190.9453302588951) + b * (4.444339102852739 * b + 9.8632861493405 * l - 24.86741582555878) + l * (-20.737325471181034 * l - 187.80453709719578), j[B + 2] = 255 + R * (0.8842522430003296 * R + 8.078677503112928 * D + 30.89978309703729 * b - 0.23883238689178934 * l + -14.183576799673286) + D * (10.49593273432072 * D + 63.02378494754052 * b + 50.606957656360734 * l - 112.23884253719248) + b * (0.03296041114873217 * b + 115.60384449646641 * l + -193.58209356861505) + l * (-22.33816807309886 * l - 180.12613974708367);
            }
            class p extends y {
              constructor() {
                super("DeviceCMYK", 4);
              }
              getRgbItem(X, M, j, B) {
                C(X, M, 1, j, B);
              }
              getRgbBuffer(X, M, j, B, R, D, b) {
                const l = 1 / ((1 << D) - 1);
                for (let _ = 0; _ < j; _++)
                  C(X, M, l, B, R), M += 4, R += 3 + b;
              }
              getOutputLength(X, M) {
                return X / 4 * (3 + M) | 0;
              }
            }
            return p;
          }(), o = function() {
            function C(w, X, M, j, B, R) {
              const b = (X[M] * R) ** w.G, l = w.YW * b, _ = Math.max(295.8 * l ** 0.3333333333333333 - 40.8, 0);
              j[B] = _, j[B + 1] = _, j[B + 2] = _;
            }
            class p extends y {
              constructor(X, M, j) {
                if (super("CalGray", 1), !X)
                  throw new t.FormatError("WhitePoint missing - required for color space CalGray");
                if (M = M || [0, 0, 0], j = j || 1, this.XW = X[0], this.YW = X[1], this.ZW = X[2], this.XB = M[0], this.YB = M[1], this.ZB = M[2], this.G = j, this.XW < 0 || this.ZW < 0 || this.YW !== 1)
                  throw new t.FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
                (this.XB < 0 || this.YB < 0 || this.ZB < 0) && ((0, t.info)(`Invalid BlackPoint for ${this.name}, falling back to default.`), this.XB = this.YB = this.ZB = 0), (this.XB !== 0 || this.YB !== 0 || this.ZB !== 0) && (0, t.warn)(`${this.name}, BlackPoint: XB: ${this.XB}, YB: ${this.YB}, ZB: ${this.ZB}, only default values are supported.`), this.G < 1 && ((0, t.info)(`Invalid Gamma: ${this.G} for ${this.name}, falling back to default.`), this.G = 1);
              }
              getRgbItem(X, M, j, B) {
                C(this, X, M, j, B, 1);
              }
              getRgbBuffer(X, M, j, B, R, D, b) {
                const l = 1 / ((1 << D) - 1);
                for (let _ = 0; _ < j; ++_)
                  C(this, X, M, B, R, l), M += 1, R += 3 + b;
              }
              getOutputLength(X, M) {
                return X * (3 + M);
              }
            }
            return p;
          }(), x = function() {
            const C = new Float32Array([0.8951, 0.2664, -0.1614, -0.7502, 1.7135, 0.0367, 0.0389, -0.0685, 1.0296]), p = new Float32Array([0.9869929, -0.1470543, 0.1599627, 0.4323053, 0.5183603, 0.0492912, -85287e-7, 0.0400428, 0.9684867]), w = new Float32Array([3.2404542, -1.5371385, -0.4985314, -0.969266, 1.8760108, 0.041556, 0.0556434, -0.2040259, 1.0572252]), X = new Float32Array([1, 1, 1]), M = new Float32Array(3), j = new Float32Array(3), B = new Float32Array(3), R = ((8 + 16) / 116) ** 3 / 8;
            function D(K, W, z) {
              z[0] = K[0] * W[0] + K[1] * W[1] + K[2] * W[2], z[1] = K[3] * W[0] + K[4] * W[1] + K[5] * W[2], z[2] = K[6] * W[0] + K[7] * W[1] + K[8] * W[2];
            }
            function b(K, W, z) {
              z[0] = W[0] * 1 / K[0], z[1] = W[1] * 1 / K[1], z[2] = W[2] * 1 / K[2];
            }
            function l(K, W, z) {
              z[0] = W[0] * 0.95047 / K[0], z[1] = W[1] * 1 / K[1], z[2] = W[2] * 1.08883 / K[2];
            }
            function _(K) {
              return K <= 31308e-7 ? S(0, 1, 12.92 * K) : K >= 0.99554525 ? 1 : S(0, 1, (1 + 0.055) * K ** (1 / 2.4) - 0.055);
            }
            function S(K, W, z) {
              return Math.max(K, Math.min(W, z));
            }
            function A(K) {
              return K < 0 ? -A(-K) : K > 8 ? ((K + 16) / 116) ** 3 : K * R;
            }
            function F(K, W, z) {
              if (K[0] === 0 && K[1] === 0 && K[2] === 0) {
                z[0] = W[0], z[1] = W[1], z[2] = W[2];
                return;
              }
              const V = A(0), L = V, Y = A(K[0]), J = V, ie = A(K[1]), q = V, N = A(K[2]), Z = (1 - L) / (1 - Y), E = 1 - Z, te = (1 - J) / (1 - ie), re = 1 - te, ee = (1 - q) / (1 - N), $ = 1 - ee;
              z[0] = W[0] * Z + E, z[1] = W[1] * te + re, z[2] = W[2] * ee + $;
            }
            function T(K, W, z) {
              if (K[0] === 1 && K[2] === 1) {
                z[0] = W[0], z[1] = W[1], z[2] = W[2];
                return;
              }
              const V = z;
              D(C, W, V);
              const L = M;
              b(K, V, L), D(p, L, z);
            }
            function O(K, W, z) {
              const V = z;
              D(C, W, V);
              const L = M;
              l(K, V, L), D(p, L, z);
            }
            function U(K, W, z, V, L, Y) {
              const J = S(0, 1, W[z] * Y), ie = S(0, 1, W[z + 1] * Y), q = S(0, 1, W[z + 2] * Y), N = J === 1 ? 1 : J ** K.GR, Z = ie === 1 ? 1 : ie ** K.GG, E = q === 1 ? 1 : q ** K.GB, te = K.MXA * N + K.MXB * Z + K.MXC * E, re = K.MYA * N + K.MYB * Z + K.MYC * E, ee = K.MZA * N + K.MZB * Z + K.MZC * E, $ = j;
              $[0] = te, $[1] = re, $[2] = ee;
              const k = B;
              T(K.whitePoint, $, k);
              const H = j;
              F(K.blackPoint, k, H);
              const ne = B;
              O(X, H, ne);
              const ae = j;
              D(w, ne, ae), V[L] = _(ae[0]) * 255, V[L + 1] = _(ae[1]) * 255, V[L + 2] = _(ae[2]) * 255;
            }
            class G extends y {
              constructor(W, z, V, L) {
                if (super("CalRGB", 3), !W)
                  throw new t.FormatError("WhitePoint missing - required for color space CalRGB");
                z = z || new Float32Array(3), V = V || new Float32Array([1, 1, 1]), L = L || new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
                const Y = W[0], J = W[1], ie = W[2];
                this.whitePoint = W;
                const q = z[0], N = z[1], Z = z[2];
                if (this.blackPoint = z, this.GR = V[0], this.GG = V[1], this.GB = V[2], this.MXA = L[0], this.MYA = L[1], this.MZA = L[2], this.MXB = L[3], this.MYB = L[4], this.MZB = L[5], this.MXC = L[6], this.MYC = L[7], this.MZC = L[8], Y < 0 || ie < 0 || J !== 1)
                  throw new t.FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
                (q < 0 || N < 0 || Z < 0) && ((0, t.info)(`Invalid BlackPoint for ${this.name} [${q}, ${N}, ${Z}], falling back to default.`), this.blackPoint = new Float32Array(3)), (this.GR < 0 || this.GG < 0 || this.GB < 0) && ((0, t.info)(`Invalid Gamma [${this.GR}, ${this.GG}, ${this.GB}] for ${this.name}, falling back to default.`), this.GR = this.GG = this.GB = 1);
              }
              getRgbItem(W, z, V, L) {
                U(this, W, z, V, L, 1);
              }
              getRgbBuffer(W, z, V, L, Y, J, ie) {
                const q = 1 / ((1 << J) - 1);
                for (let N = 0; N < V; ++N)
                  U(this, W, z, L, Y, q), z += 3, Y += 3 + ie;
              }
              getOutputLength(W, z) {
                return W * (3 + z) / 3 | 0;
              }
            }
            return G;
          }(), f = function() {
            function C(M) {
              let j;
              return M >= 6 / 29 ? j = M ** 3 : j = 108 / 841 * (M - 4 / 29), j;
            }
            function p(M, j, B, R) {
              return B + M * (R - B) / j;
            }
            function w(M, j, B, R, D, b) {
              let l = j[B], _ = j[B + 1], S = j[B + 2];
              R !== !1 && (l = p(l, R, 0, 100), _ = p(_, R, M.amin, M.amax), S = p(S, R, M.bmin, M.bmax)), _ > M.amax ? _ = M.amax : _ < M.amin && (_ = M.amin), S > M.bmax ? S = M.bmax : S < M.bmin && (S = M.bmin);
              const A = (l + 16) / 116, F = A + _ / 500, T = A - S / 200, O = M.XW * C(F), U = M.YW * C(A), G = M.ZW * C(T);
              let K, W, z;
              M.ZW < 1 ? (K = O * 3.1339 + U * -1.617 + G * -0.4906, W = O * -0.9785 + U * 1.916 + G * 0.0333, z = O * 0.072 + U * -0.229 + G * 1.4057) : (K = O * 3.2406 + U * -1.5372 + G * -0.4986, W = O * -0.9689 + U * 1.8758 + G * 0.0415, z = O * 0.0557 + U * -0.204 + G * 1.057), D[b] = Math.sqrt(K) * 255, D[b + 1] = Math.sqrt(W) * 255, D[b + 2] = Math.sqrt(z) * 255;
            }
            class X extends y {
              constructor(j, B, R) {
                if (super("Lab", 3), !j)
                  throw new t.FormatError("WhitePoint missing - required for color space Lab");
                if (B = B || [0, 0, 0], R = R || [-100, 100, -100, 100], this.XW = j[0], this.YW = j[1], this.ZW = j[2], this.amin = R[0], this.amax = R[1], this.bmin = R[2], this.bmax = R[3], this.XB = B[0], this.YB = B[1], this.ZB = B[2], this.XW < 0 || this.ZW < 0 || this.YW !== 1)
                  throw new t.FormatError("Invalid WhitePoint components, no fallback available");
                (this.XB < 0 || this.YB < 0 || this.ZB < 0) && ((0, t.info)("Invalid BlackPoint, falling back to default"), this.XB = this.YB = this.ZB = 0), (this.amin > this.amax || this.bmin > this.bmax) && ((0, t.info)("Invalid Range, falling back to defaults"), this.amin = -100, this.amax = 100, this.bmin = -100, this.bmax = 100);
              }
              getRgbItem(j, B, R, D) {
                w(this, j, B, !1, R, D);
              }
              getRgbBuffer(j, B, R, D, b, l, _) {
                const S = (1 << l) - 1;
                for (let A = 0; A < R; A++)
                  w(this, j, B, S, D, b), B += 3, b += 3 + _;
              }
              getOutputLength(j, B) {
                return j * (3 + B) / 3 | 0;
              }
              isDefaultDecode(j, B) {
                return !0;
              }
              get usesZeroToOneRange() {
                return (0, t.shadow)(this, "usesZeroToOneRange", !1);
              }
            }
            return X;
          }();
        },
        /* 15 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.PartialEvaluator = u.EvaluatorPreprocessor = void 0;
          var t = P(2), i = P(16), v = P(5), a = P(34), e = P(38), y = P(37), r = P(41), h = P(40), g = P(50), d = P(51), c = P(42), n = P(57), o = P(17), x = P(59), f = P(10), m = P(7), C = P(60), p = P(14), w = P(19), X = P(39), M = P(6), j = P(45), B = P(61), R = P(62), D = P(63);
          const b = Object.freeze({
            maxImageSize: -1,
            disableFontFace: !1,
            ignoreErrors: !1,
            isEvalSupported: !0,
            fontExtraProperties: !1,
            useSystemFonts: !0,
            cMapUrl: null,
            standardFontDataUrl: null
          }), l = {
            TILING: 1,
            SHADING: 2
          }, _ = 10, S = Promise.resolve();
          function A(V, L = !1) {
            if (Array.isArray(V)) {
              for (let Y = 0, J = V.length; Y < J; Y++) {
                const ie = A(V[Y], !0);
                if (ie)
                  return ie;
              }
              return (0, t.warn)(`Unsupported blend mode Array: ${V}`), "source-over";
            }
            if (!(V instanceof v.Name))
              return L ? null : "source-over";
            switch (V.name) {
              case "Normal":
              case "Compatible":
                return "source-over";
              case "Multiply":
                return "multiply";
              case "Screen":
                return "screen";
              case "Overlay":
                return "overlay";
              case "Darken":
                return "darken";
              case "Lighten":
                return "lighten";
              case "ColorDodge":
                return "color-dodge";
              case "ColorBurn":
                return "color-burn";
              case "HardLight":
                return "hard-light";
              case "SoftLight":
                return "soft-light";
              case "Difference":
                return "difference";
              case "Exclusion":
                return "exclusion";
              case "Hue":
                return "hue";
              case "Saturation":
                return "saturation";
              case "Color":
                return "color";
              case "Luminosity":
                return "luminosity";
            }
            return L ? null : ((0, t.warn)(`Unsupported blend mode: ${V.name}`), "source-over");
          }
          function F(V) {
            V.fn === t.OPS.paintImageMaskXObject && V.args[0] && V.args[0].count > 0 && V.args[0].count++;
          }
          class T {
            static get TIME_SLOT_DURATION_MS() {
              return (0, t.shadow)(this, "TIME_SLOT_DURATION_MS", 20);
            }
            static get CHECK_TIME_EVERY() {
              return (0, t.shadow)(this, "CHECK_TIME_EVERY", 100);
            }
            constructor() {
              this.reset();
            }
            check() {
              return ++this.checked < T.CHECK_TIME_EVERY ? !1 : (this.checked = 0, this.endTime <= Date.now());
            }
            reset() {
              this.endTime = Date.now() + T.TIME_SLOT_DURATION_MS, this.checked = 0;
            }
          }
          class O {
            constructor({
              xref: L,
              handler: Y,
              pageIndex: J,
              idFactory: ie,
              fontCache: q,
              builtInCMapCache: N,
              standardFontDataCache: Z,
              globalImageCache: E,
              options: te = null
            }) {
              this.xref = L, this.handler = Y, this.pageIndex = J, this.idFactory = ie, this.fontCache = q, this.builtInCMapCache = N, this.standardFontDataCache = Z, this.globalImageCache = E, this.options = te || b, this.parsingType3Font = !1, this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);
            }
            get _pdfFunctionFactory() {
              const L = new n.PDFFunctionFactory({
                xref: this.xref,
                isEvalSupported: this.options.isEvalSupported
              });
              return (0, t.shadow)(this, "_pdfFunctionFactory", L);
            }
            clone(L = null) {
              const Y = Object.create(this);
              return Y.options = Object.assign(/* @__PURE__ */ Object.create(null), this.options, L), Y;
            }
            hasBlendModes(L, Y) {
              if (!(L instanceof v.Dict) || L.objId && Y.has(L.objId))
                return !1;
              const J = new v.RefSet(Y);
              L.objId && J.put(L.objId);
              const ie = [L], q = this.xref;
              for (; ie.length; ) {
                const N = ie.shift(), Z = N.get("ExtGState");
                if (Z instanceof v.Dict)
                  for (let te of Z.getRawValues()) {
                    if (te instanceof v.Ref) {
                      if (J.has(te))
                        continue;
                      try {
                        te = q.fetch(te);
                      } catch (ee) {
                        J.put(te), (0, t.info)(`hasBlendModes - ignoring ExtGState: "${ee}".`);
                        continue;
                      }
                    }
                    if (!(te instanceof v.Dict))
                      continue;
                    te.objId && J.put(te.objId);
                    const re = te.get("BM");
                    if (re instanceof v.Name) {
                      if (re.name !== "Normal")
                        return !0;
                      continue;
                    }
                    if (re !== void 0 && Array.isArray(re)) {
                      for (const ee of re)
                        if (ee instanceof v.Name && ee.name !== "Normal")
                          return !0;
                    }
                  }
                const E = N.get("XObject");
                if (E instanceof v.Dict)
                  for (let te of E.getRawValues()) {
                    if (te instanceof v.Ref) {
                      if (J.has(te))
                        continue;
                      try {
                        te = q.fetch(te);
                      } catch (ee) {
                        J.put(te), (0, t.info)(`hasBlendModes - ignoring XObject: "${ee}".`);
                        continue;
                      }
                    }
                    if (!(te instanceof m.BaseStream))
                      continue;
                    te.dict.objId && J.put(te.dict.objId);
                    const re = te.dict.get("Resources");
                    re instanceof v.Dict && (re.objId && J.has(re.objId) || (ie.push(re), re.objId && J.put(re.objId)));
                  }
              }
              for (const N of J)
                Y.put(N);
              return !1;
            }
            async fetchBuiltInCMap(L) {
              const Y = this.builtInCMapCache.get(L);
              if (Y)
                return Y;
              let J;
              if (this.options.cMapUrl !== null) {
                const ie = `${this.options.cMapUrl}${L}.bcmap`, q = await fetch(ie);
                if (!q.ok)
                  throw new Error(`fetchBuiltInCMap: failed to fetch file "${ie}" with "${q.statusText}".`);
                J = {
                  cMapData: new Uint8Array(await q.arrayBuffer()),
                  compressionType: t.CMapCompressionType.BINARY
                };
              } else
                J = await this.handler.sendWithPromise("FetchBuiltInCMap", {
                  name: L
                });
              return J.compressionType !== t.CMapCompressionType.NONE && this.builtInCMapCache.set(L, J), J;
            }
            async fetchStandardFontData(L) {
              const Y = this.standardFontDataCache.get(L);
              if (Y)
                return new f.Stream(Y);
              if (this.options.useSystemFonts && L !== "Symbol" && L !== "ZapfDingbats")
                return null;
              const J = (0, r.getFontNameToFileMap)(), ie = J[L];
              let q;
              if (this.options.standardFontDataUrl !== null) {
                const N = `${this.options.standardFontDataUrl}${ie}`, Z = await fetch(N);
                Z.ok ? q = await Z.arrayBuffer() : (0, t.warn)(`fetchStandardFontData: failed to fetch file "${N}" with "${Z.statusText}".`);
              } else
                try {
                  q = await this.handler.sendWithPromise("FetchStandardFontData", {
                    filename: ie
                  });
                } catch (N) {
                  (0, t.warn)(`fetchStandardFontData: failed to fetch file "${ie}" with "${N}".`);
                }
              return q ? (this.standardFontDataCache.set(L, q), new f.Stream(q)) : null;
            }
            async buildFormXObject(L, Y, J, ie, q, N, Z) {
              const E = Y.dict, te = E.getArray("Matrix");
              let re = E.getArray("BBox");
              Array.isArray(re) && re.length === 4 ? re = t.Util.normalizeRect(re) : re = null;
              let ee, $;
              E.has("OC") && (ee = await this.parseMarkedContentProps(E.get("OC"), L)), ee !== void 0 && ie.addOp(t.OPS.beginMarkedContentProps, ["OC", ee]);
              const k = E.get("Group");
              if (k) {
                $ = {
                  matrix: te,
                  bbox: re,
                  smask: J,
                  isolated: !1,
                  knockout: !1
                };
                const ne = k.get("S");
                let ae = null;
                if ((0, v.isName)(ne, "Transparency") && ($.isolated = k.get("I") || !1, $.knockout = k.get("K") || !1, k.has("CS"))) {
                  const he = k.getRaw("CS"), ue = p.ColorSpace.getCached(he, this.xref, Z);
                  ue ? ae = ue : ae = await this.parseColorSpace({
                    cs: he,
                    resources: L,
                    localColorSpaceCache: Z
                  });
                }
                J && J.backdrop && (ae = ae || p.ColorSpace.singletons.rgb, J.backdrop = ae.getRgb(J.backdrop, 0)), ie.addOp(t.OPS.beginGroup, [$]);
              }
              const H = k ? [te, null] : [te, re];
              return ie.addOp(t.OPS.paintFormXObjectBegin, H), this.getOperatorList({
                stream: Y,
                task: q,
                resources: E.get("Resources") || L,
                operatorList: ie,
                initialState: N
              }).then(function() {
                ie.addOp(t.OPS.paintFormXObjectEnd, []), k && ie.addOp(t.OPS.endGroup, [$]), ee !== void 0 && ie.addOp(t.OPS.endMarkedContent, []);
              });
            }
            _sendImgData(L, Y, J = !1) {
              const ie = Y ? [Y.bitmap || Y.data.buffer] : null;
              return this.parsingType3Font || J ? this.handler.send("commonobj", [L, "Image", Y], ie) : this.handler.send("obj", [L, this.pageIndex, "Image", Y], ie);
            }
            async buildPaintImageXObject({
              resources: L,
              image: Y,
              isInline: J = !1,
              operatorList: ie,
              cacheKey: q,
              localImageCache: N,
              localColorSpaceCache: Z
            }) {
              const E = Y.dict, te = E.objId, re = E.get("W", "Width"), ee = E.get("H", "Height");
              if (!(re && typeof re == "number") || !(ee && typeof ee == "number")) {
                (0, t.warn)("Image dimensions are missing, or not numbers.");
                return;
              }
              const $ = this.options.maxImageSize;
              if ($ !== -1 && re * ee > $) {
                const we = "Image exceeded maximum allowed size and was removed.";
                if (this.options.ignoreErrors) {
                  (0, t.warn)(we);
                  return;
                }
                throw new Error(we);
              }
              let k;
              E.has("OC") && (k = await this.parseMarkedContentProps(E.get("OC"), L));
              const H = E.get("IM", "ImageMask") || !1;
              let ne, ae;
              if (H) {
                const we = E.get("I", "Interpolate"), Ae = re + 7 >> 3, De = Y.getBytes(Ae * ee), xe = E.getArray("D", "Decode");
                if (this.parsingType3Font) {
                  ne = D.PDFImage.createRawMask({
                    imgArray: De,
                    width: re,
                    height: ee,
                    imageIsFromDecodeStream: Y instanceof w.DecodeStream,
                    inverseDecode: !!xe && xe[0] > 0,
                    interpolate: we
                  }), ne.cached = !!q, ae = [ne], ie.addImageOps(t.OPS.paintImageMaskXObject, ae, k), q && N.set(q, te, {
                    fn: t.OPS.paintImageMaskXObject,
                    args: ae,
                    optionalContent: k
                  });
                  return;
                }
                if (ne = D.PDFImage.createMask({
                  imgArray: De,
                  width: re,
                  height: ee,
                  imageIsFromDecodeStream: Y instanceof w.DecodeStream,
                  inverseDecode: !!xe && xe[0] > 0,
                  interpolate: we
                }), ne.isSingleOpaquePixel) {
                  ie.addImageOps(t.OPS.paintSolidColorImageMask, [], k), q && N.set(q, te, {
                    fn: t.OPS.paintSolidColorImageMask,
                    args: [],
                    optionalContent: k
                  });
                  return;
                }
                const Te = `mask_${this.idFactory.createObjId()}`;
                ie.addDependency(Te), this._sendImgData(Te, ne), ae = [{
                  data: Te,
                  width: ne.width,
                  height: ne.height,
                  interpolate: ne.interpolate,
                  count: 1
                }], ie.addImageOps(t.OPS.paintImageMaskXObject, ae, k), q && N.set(q, te, {
                  fn: t.OPS.paintImageMaskXObject,
                  args: ae,
                  optionalContent: k
                });
                return;
              }
              const he = E.get("SM", "SMask") || !1, ue = E.get("Mask") || !1, fe = 200;
              if (J && !he && !ue && re + ee < fe) {
                ne = new D.PDFImage({
                  xref: this.xref,
                  res: L,
                  image: Y,
                  isInline: J,
                  pdfFunctionFactory: this._pdfFunctionFactory,
                  localColorSpaceCache: Z
                }).createImageData(!0), ie.addImageOps(t.OPS.paintInlineImageXObject, [ne], k);
                return;
              }
              let me = `img_${this.idFactory.createObjId()}`, Fe = !1;
              this.parsingType3Font ? me = `${this.idFactory.getDocId()}_type3_${me}` : te && (Fe = this.globalImageCache.shouldCache(te, this.pageIndex), Fe && (me = `${this.idFactory.getDocId()}_${me}`)), ie.addDependency(me), ae = [me, re, ee], D.PDFImage.buildImage({
                xref: this.xref,
                res: L,
                image: Y,
                isInline: J,
                pdfFunctionFactory: this._pdfFunctionFactory,
                localColorSpaceCache: Z
              }).then((we) => (ne = we.createImageData(!1), q && te && Fe && this.globalImageCache.addByteSize(te, ne.data.length), this._sendImgData(me, ne, Fe))).catch((we) => ((0, t.warn)(`Unable to decode image "${me}": "${we}".`), this._sendImgData(me, null, Fe))), ie.addImageOps(t.OPS.paintImageXObject, ae, k), q && (N.set(q, te, {
                fn: t.OPS.paintImageXObject,
                args: ae,
                optionalContent: k
              }), te && ((0, t.assert)(!J, "Cannot cache an inline image globally."), this.globalImageCache.addPageIndex(te, this.pageIndex), Fe && this.globalImageCache.setData(te, {
                objId: me,
                fn: t.OPS.paintImageXObject,
                args: ae,
                optionalContent: k,
                byteSize: 0
              })));
            }
            handleSMask(L, Y, J, ie, q, N) {
              const Z = L.get("G"), E = {
                subtype: L.get("S").name,
                backdrop: L.get("BC")
              }, te = L.get("TR");
              if ((0, n.isPDFFunction)(te)) {
                const re = this._pdfFunctionFactory.create(te), ee = new Uint8Array(256), $ = new Float32Array(1);
                for (let k = 0; k < 256; k++)
                  $[0] = k / 255, re($, 0, $, 0), ee[k] = $[0] * 255 | 0;
                E.transferMap = ee;
              }
              return this.buildFormXObject(Y, Z, E, J, ie, q.state.clone(), N);
            }
            handleTransferFunction(L) {
              let Y;
              if (Array.isArray(L))
                Y = L;
              else if ((0, n.isPDFFunction)(L))
                Y = [L];
              else
                return null;
              const J = [];
              let ie = 0, q = 0;
              for (const N of Y) {
                const Z = this.xref.fetchIfRef(N);
                if (ie++, (0, v.isName)(Z, "Identity")) {
                  J.push(null);
                  continue;
                } else if (!(0, n.isPDFFunction)(Z))
                  return null;
                const E = this._pdfFunctionFactory.create(Z), te = new Uint8Array(256), re = new Float32Array(1);
                for (let ee = 0; ee < 256; ee++)
                  re[0] = ee / 255, E(re, 0, re, 0), te[ee] = re[0] * 255 | 0;
                J.push(te), q++;
              }
              return !(ie === 1 || ie === 4) || q === 0 ? null : J;
            }
            handleTilingType(L, Y, J, ie, q, N, Z, E) {
              const te = new R.OperatorList(), re = v.Dict.merge({
                xref: this.xref,
                dictArray: [q.get("Resources"), J]
              });
              return this.getOperatorList({
                stream: ie,
                task: Z,
                resources: re,
                operatorList: te
              }).then(function() {
                const ee = te.getIR(), $ = (0, g.getTilingPatternIR)(ee, q, Y);
                N.addDependencies(te.dependencies), N.addOp(L, $), q.objId && E.set(null, q.objId, {
                  operatorListIR: ee,
                  dict: q
                });
              }).catch((ee) => {
                if (!(ee instanceof t.AbortException)) {
                  if (this.options.ignoreErrors) {
                    this.handler.send("UnsupportedFeature", {
                      featureId: t.UNSUPPORTED_FEATURES.errorTilingPattern
                    }), (0, t.warn)(`handleTilingType - ignoring pattern: "${ee}".`);
                    return;
                  }
                  throw ee;
                }
              });
            }
            handleSetFont(L, Y, J, ie, q, N, Z = null, E = null) {
              const te = Y && Y[0] instanceof v.Name ? Y[0].name : null;
              return this.loadFont(te, J, L, Z, E).then((re) => re.font.isType3Font ? re.loadType3Data(this, L, q).then(function() {
                return ie.addDependencies(re.type3Dependencies), re;
              }).catch((ee) => (this.handler.send("UnsupportedFeature", {
                featureId: t.UNSUPPORTED_FEATURES.errorFontLoadType3
              }), new U({
                loadedName: "g_font_error",
                font: new a.ErrorFont(`Type3 font load error: ${ee}`),
                dict: re.font,
                evaluatorOptions: this.options
              }))) : re).then((re) => (N.font = re.font, re.send(this.handler), re.loadedName));
            }
            handleText(L, Y) {
              const J = Y.font, ie = J.charsToGlyphs(L);
              return J.data && (Y.textRenderingMode & t.TextRenderingMode.ADD_TO_PATH_FLAG || Y.fillColorSpace.name === "Pattern" || J.disableFontFace || this.options.disableFontFace) && O.buildFontPaths(J, ie, this.handler, this.options), ie;
            }
            ensureStateFont(L) {
              if (L.font)
                return;
              const Y = new t.FormatError("Missing setFont (Tf) operator before text rendering operator.");
              if (this.options.ignoreErrors) {
                this.handler.send("UnsupportedFeature", {
                  featureId: t.UNSUPPORTED_FEATURES.errorFontState
                }), (0, t.warn)(`ensureStateFont: "${Y}".`);
                return;
              }
              throw Y;
            }
            async setGState({
              resources: L,
              gState: Y,
              operatorList: J,
              cacheKey: ie,
              task: q,
              stateManager: N,
              localGStateCache: Z,
              localColorSpaceCache: E
            }) {
              const te = Y.objId;
              let re = !0;
              const ee = [], $ = Y.getKeys();
              let k = Promise.resolve();
              for (let H = 0, ne = $.length; H < ne; H++) {
                const ae = $[H], he = Y.get(ae);
                switch (ae) {
                  case "Type":
                    break;
                  case "LW":
                  case "LC":
                  case "LJ":
                  case "ML":
                  case "D":
                  case "RI":
                  case "FL":
                  case "CA":
                  case "ca":
                    ee.push([ae, he]);
                    break;
                  case "Font":
                    re = !1, k = k.then(() => this.handleSetFont(L, null, he[0], J, q, N.state).then(function(fe) {
                      J.addDependency(fe), ee.push([ae, [fe, he[1]]]);
                    }));
                    break;
                  case "BM":
                    ee.push([ae, A(he)]);
                    break;
                  case "SMask":
                    if ((0, v.isName)(he, "None")) {
                      ee.push([ae, !1]);
                      break;
                    }
                    he instanceof v.Dict ? (re = !1, k = k.then(() => this.handleSMask(he, L, J, q, N, E)), ee.push([ae, !0])) : (0, t.warn)("Unsupported SMask type");
                    break;
                  case "TR":
                    const ue = this.handleTransferFunction(he);
                    ee.push([ae, ue]);
                    break;
                  case "OP":
                  case "op":
                  case "OPM":
                  case "BG":
                  case "BG2":
                  case "UCR":
                  case "UCR2":
                  case "TR2":
                  case "HT":
                  case "SM":
                  case "SA":
                  case "AIS":
                  case "TK":
                    (0, t.info)("graphic state operator " + ae);
                    break;
                  default:
                    (0, t.info)("Unknown graphic state operator " + ae);
                    break;
                }
              }
              return k.then(function() {
                ee.length > 0 && J.addOp(t.OPS.setGState, [ee]), re && Z.set(ie, te, ee);
              });
            }
            loadFont(L, Y, J, ie = null, q = null) {
              const N = async () => new U({
                loadedName: "g_font_error",
                font: new a.ErrorFont(`Font "${L}" is not available.`),
                dict: Y,
                evaluatorOptions: this.options
              }), Z = this.xref;
              let E;
              if (Y)
                Y instanceof v.Ref && (E = Y);
              else {
                const ne = J.get("Font");
                ne && (E = ne.getRaw(L));
              }
              if (!E) {
                const ne = `Font "${L || Y && Y.toString()}" is not available`;
                if (!this.options.ignoreErrors && !this.parsingType3Font)
                  return (0, t.warn)(`${ne}.`), N();
                this.handler.send("UnsupportedFeature", {
                  featureId: t.UNSUPPORTED_FEATURES.errorFontMissing
                }), (0, t.warn)(`${ne} -- attempting to fallback to a default font.`), ie ? E = ie : E = O.fallbackFontDict;
              }
              if (this.parsingType3Font && this.type3FontRefs.has(E))
                return N();
              if (this.fontCache.has(E))
                return this.fontCache.get(E);
              if (Y = Z.fetchIfRef(E), !(Y instanceof v.Dict))
                return N();
              if (Y.cacheKey && this.fontCache.has(Y.cacheKey))
                return this.fontCache.get(Y.cacheKey);
              const te = (0, t.createPromiseCapability)();
              let re;
              try {
                re = this.preEvaluateFont(Y), re.cssFontInfo = q;
              } catch (ne) {
                return (0, t.warn)(`loadFont - preEvaluateFont failed: "${ne}".`), N();
              }
              const {
                descriptor: ee,
                hash: $
              } = re, k = E instanceof v.Ref;
              let H;
              if (k && (H = `f${E.toString()}`), $ && ee instanceof v.Dict) {
                ee.fontAliases || (ee.fontAliases = /* @__PURE__ */ Object.create(null));
                const ne = ee.fontAliases;
                if (ne[$]) {
                  const ae = ne[$].aliasRef;
                  if (k && ae && this.fontCache.has(ae))
                    return this.fontCache.putAlias(E, ae), this.fontCache.get(E);
                } else
                  ne[$] = {
                    fontID: this.idFactory.createFontId()
                  };
                k && (ne[$].aliasRef = E), H = ne[$].fontID;
              }
              return k ? this.fontCache.put(E, te.promise) : (H || (H = this.idFactory.createFontId()), Y.cacheKey = `cacheKey_${H}`, this.fontCache.put(Y.cacheKey, te.promise)), (0, t.assert)(H && H.startsWith("f"), 'The "fontID" must be (correctly) defined.'), Y.loadedName = `${this.idFactory.getDocId()}_${H}`, this.translateFont(re).then((ne) => {
                ne.fontType !== void 0 && Z.stats.addFontType(ne.fontType), te.resolve(new U({
                  loadedName: Y.loadedName,
                  font: ne,
                  dict: Y,
                  evaluatorOptions: this.options
                }));
              }).catch((ne) => {
                this.handler.send("UnsupportedFeature", {
                  featureId: t.UNSUPPORTED_FEATURES.errorFontTranslate
                }), (0, t.warn)(`loadFont - translateFont failed: "${ne}".`);
                try {
                  const ae = ee && ee.get("FontFile3"), he = ae && ae.get("Subtype"), ue = (0, e.getFontType)(re.type, he && he.name);
                  ue !== void 0 && Z.stats.addFontType(ue);
                } catch {
                }
                te.resolve(new U({
                  loadedName: Y.loadedName,
                  font: new a.ErrorFont(ne instanceof Error ? ne.message : ne),
                  dict: Y,
                  evaluatorOptions: this.options
                }));
              }), te.promise;
            }
            buildPath(L, Y, J, ie = !1) {
              const q = L.length - 1;
              J || (J = []);
              let N;
              if (q < 0 || L.fnArray[q] !== t.OPS.constructPath)
                ie && ((0, t.warn)(`Encountered path operator "${Y}" inside of a text object.`), L.addOp(t.OPS.save, null)), N = [1 / 0, -1 / 0, 1 / 0, -1 / 0], L.addOp(t.OPS.constructPath, [[Y], J, N]), ie && L.addOp(t.OPS.restore, null);
              else {
                const Z = L.argsArray[q];
                Z[0].push(Y), Array.prototype.push.apply(Z[1], J), N = Z[2];
              }
              switch (Y) {
                case t.OPS.rectangle:
                  N[0] = Math.min(N[0], J[0], J[0] + J[2]), N[1] = Math.max(N[1], J[0], J[0] + J[2]), N[2] = Math.min(N[2], J[1], J[1] + J[3]), N[3] = Math.max(N[3], J[1], J[1] + J[3]);
                  break;
                case t.OPS.moveTo:
                case t.OPS.lineTo:
                  N[0] = Math.min(N[0], J[0]), N[1] = Math.max(N[1], J[0]), N[2] = Math.min(N[2], J[1]), N[3] = Math.max(N[3], J[1]);
                  break;
              }
            }
            parseColorSpace({
              cs: L,
              resources: Y,
              localColorSpaceCache: J
            }) {
              return p.ColorSpace.parseAsync({
                cs: L,
                xref: this.xref,
                resources: Y,
                pdfFunctionFactory: this._pdfFunctionFactory,
                localColorSpaceCache: J
              }).catch((ie) => {
                if (ie instanceof t.AbortException)
                  return null;
                if (this.options.ignoreErrors)
                  return this.handler.send("UnsupportedFeature", {
                    featureId: t.UNSUPPORTED_FEATURES.errorColorSpace
                  }), (0, t.warn)(`parseColorSpace - ignoring ColorSpace: "${ie}".`), null;
                throw ie;
              });
            }
            parseShading({
              shading: L,
              resources: Y,
              localColorSpaceCache: J,
              localShadingPatternCache: ie
            }) {
              let q = ie.get(L);
              if (!q) {
                var N = g.Pattern.parseShading(L, this.xref, Y, this.handler, this._pdfFunctionFactory, J);
                const Z = N.getIR();
                q = `pattern_${this.idFactory.createObjId()}`, ie.set(L, q), this.handler.send("obj", [q, this.pageIndex, "Pattern", Z]);
              }
              return q;
            }
            handleColorN(L, Y, J, ie, q, N, Z, E, te, re) {
              const ee = J.pop();
              if (ee instanceof v.Name) {
                const $ = q.getRaw(ee.name), k = $ instanceof v.Ref && te.getByRef($);
                if (k)
                  try {
                    const ne = ie.base ? ie.base.getRgb(J, 0) : null, ae = (0, g.getTilingPatternIR)(k.operatorListIR, k.dict, ne);
                    L.addOp(Y, ae);
                    return;
                  } catch {
                  }
                const H = this.xref.fetchIfRef($);
                if (H) {
                  const ne = H instanceof m.BaseStream ? H.dict : H, ae = ne.get("PatternType");
                  if (ae === l.TILING) {
                    const he = ie.base ? ie.base.getRgb(J, 0) : null;
                    return this.handleTilingType(Y, he, N, H, ne, L, Z, te);
                  } else if (ae === l.SHADING) {
                    const he = ne.get("Shading"), ue = ne.getArray("Matrix"), fe = this.parseShading({
                      shading: he,
                      resources: N,
                      localColorSpaceCache: E,
                      localShadingPatternCache: re
                    });
                    L.addOp(Y, ["Shading", fe, ue]);
                    return;
                  }
                  throw new t.FormatError(`Unknown PatternType: ${ae}`);
                }
              }
              throw new t.FormatError(`Unknown PatternName: ${ee}`);
            }
            _parseVisibilityExpression(L, Y, J) {
              if (++Y > 10) {
                (0, t.warn)("Visibility expression is too deeply nested");
                return;
              }
              const q = L.length, N = this.xref.fetchIfRef(L[0]);
              if (q < 2 || !(N instanceof v.Name)) {
                (0, t.warn)("Invalid visibility expression");
                return;
              }
              switch (N.name) {
                case "And":
                case "Or":
                case "Not":
                  J.push(N.name);
                  break;
                default:
                  (0, t.warn)(`Invalid operator ${N.name} in visibility expression`);
                  return;
              }
              for (let Z = 1; Z < q; Z++) {
                const E = L[Z], te = this.xref.fetchIfRef(E);
                if (Array.isArray(te)) {
                  const re = [];
                  J.push(re), this._parseVisibilityExpression(te, Y, re);
                } else
                  E instanceof v.Ref && J.push(E.toString());
              }
            }
            async parseMarkedContentProps(L, Y) {
              let J;
              if (L instanceof v.Name)
                J = Y.get("Properties").get(L.name);
              else if (L instanceof v.Dict)
                J = L;
              else
                throw new t.FormatError("Optional content properties malformed.");
              const ie = J.get("Type").name;
              if (ie === "OCG")
                return {
                  type: ie,
                  id: J.objId
                };
              if (ie === "OCMD") {
                const q = J.get("VE");
                if (Array.isArray(q)) {
                  const Z = [];
                  if (this._parseVisibilityExpression(q, 0, Z), Z.length > 0)
                    return {
                      type: "OCMD",
                      expression: Z
                    };
                }
                const N = J.get("OCGs");
                if (Array.isArray(N) || N instanceof v.Dict) {
                  const Z = [];
                  if (Array.isArray(N))
                    for (const E of N)
                      Z.push(E.toString());
                  else
                    Z.push(N.objId);
                  return {
                    type: ie,
                    ids: Z,
                    policy: J.get("P") instanceof v.Name ? J.get("P").name : null,
                    expression: null
                  };
                } else if (N instanceof v.Ref)
                  return {
                    type: ie,
                    id: N.toString()
                  };
              }
              return null;
            }
            getOperatorList({
              stream: L,
              task: Y,
              resources: J,
              operatorList: ie,
              initialState: q = null,
              fallbackFontDict: N = null
            }) {
              if (J = J || v.Dict.empty, q = q || new W(), !ie)
                throw new Error('getOperatorList: missing "operatorList" parameter');
              const Z = this, E = this.xref;
              let te = !1;
              const re = new x.LocalImageCache(), ee = new x.LocalColorSpaceCache(), $ = new x.LocalGStateCache(), k = new x.LocalTilingPatternCache(), H = /* @__PURE__ */ new Map(), ne = J.get("XObject") || v.Dict.empty, ae = J.get("Pattern") || v.Dict.empty, he = new G(q), ue = new z(L, E, he), fe = new T();
              function me(Fe) {
                for (let we = 0, Ae = ue.savedStatesDepth; we < Ae; we++)
                  ie.addOp(t.OPS.restore, []);
              }
              return new Promise(function Fe(we, Ae) {
                const De = function(Ze) {
                  Promise.all([Ze, ie.ready]).then(function() {
                    try {
                      Fe(we, Ae);
                    } catch (pt) {
                      Ae(pt);
                    }
                  }, Ae);
                };
                Y.ensureNotTerminated(), fe.reset();
                const xe = {};
                let Te, ve, Se, be, Le, ze;
                for (; !(Te = fe.check()) && (xe.args = null, !!ue.read(xe)); ) {
                  let Ze = xe.args, pt = xe.fn;
                  switch (pt | 0) {
                    case t.OPS.paintXObject:
                      if (ze = Ze[0] instanceof v.Name, Le = Ze[0].name, ze) {
                        const $e = re.getByName(Le);
                        if ($e) {
                          ie.addImageOps($e.fn, $e.args, $e.optionalContent), F($e), Ze = null;
                          continue;
                        }
                      }
                      De(new Promise(function($e, St) {
                        if (!ze)
                          throw new t.FormatError("XObject must be referred to by name.");
                        let xt = ne.getRaw(Le);
                        if (xt instanceof v.Ref) {
                          const Ve = re.getByRef(xt);
                          if (Ve) {
                            ie.addImageOps(Ve.fn, Ve.args, Ve.optionalContent), F(Ve), $e();
                            return;
                          }
                          const st = Z.globalImageCache.getData(xt, Z.pageIndex);
                          if (st) {
                            ie.addDependency(st.objId), ie.addImageOps(st.fn, st.args, st.optionalContent), $e();
                            return;
                          }
                          xt = E.fetch(xt);
                        }
                        if (!(xt instanceof m.BaseStream))
                          throw new t.FormatError("XObject should be a stream");
                        const Ie = xt.dict.get("Subtype");
                        if (!(Ie instanceof v.Name))
                          throw new t.FormatError("XObject should have a Name subtype");
                        if (Ie.name === "Form") {
                          he.save(), Z.buildFormXObject(J, xt, null, ie, Y, he.state.clone(), ee).then(function() {
                            he.restore(), $e();
                          }, St);
                          return;
                        } else if (Ie.name === "Image") {
                          Z.buildPaintImageXObject({
                            resources: J,
                            image: xt,
                            operatorList: ie,
                            cacheKey: Le,
                            localImageCache: re,
                            localColorSpaceCache: ee
                          }).then($e, St);
                          return;
                        } else if (Ie.name === "PS")
                          (0, t.info)("Ignored XObject subtype PS");
                        else
                          throw new t.FormatError(`Unhandled XObject subtype ${Ie.name}`);
                        $e();
                      }).catch(function($e) {
                        if (!($e instanceof t.AbortException)) {
                          if (Z.options.ignoreErrors) {
                            Z.handler.send("UnsupportedFeature", {
                              featureId: t.UNSUPPORTED_FEATURES.errorXObject
                            }), (0, t.warn)(`getOperatorList - ignoring XObject: "${$e}".`);
                            return;
                          }
                          throw $e;
                        }
                      }));
                      return;
                    case t.OPS.setFont:
                      var nt = Ze[1];
                      De(Z.handleSetFont(J, Ze, null, ie, Y, he.state, N).then(function($e) {
                        ie.addDependency($e), ie.addOp(t.OPS.setFont, [$e, nt]);
                      }));
                      return;
                    case t.OPS.beginText:
                      te = !0;
                      break;
                    case t.OPS.endText:
                      te = !1;
                      break;
                    case t.OPS.endInlineImage:
                      var Ue = Ze[0].cacheKey;
                      if (Ue) {
                        const $e = re.getByName(Ue);
                        if ($e) {
                          ie.addImageOps($e.fn, $e.args, $e.optionalContent), F($e), Ze = null;
                          continue;
                        }
                      }
                      De(Z.buildPaintImageXObject({
                        resources: J,
                        image: Ze[0],
                        isInline: !0,
                        operatorList: ie,
                        cacheKey: Ue,
                        localImageCache: re,
                        localColorSpaceCache: ee
                      }));
                      return;
                    case t.OPS.showText:
                      if (!he.state.font) {
                        Z.ensureStateFont(he.state);
                        continue;
                      }
                      Ze[0] = Z.handleText(Ze[0], he.state);
                      break;
                    case t.OPS.showSpacedText:
                      if (!he.state.font) {
                        Z.ensureStateFont(he.state);
                        continue;
                      }
                      var Oe = Ze[0], _e = [], at = Oe.length, Je = he.state;
                      for (ve = 0; ve < at; ++ve) {
                        const $e = Oe[ve];
                        typeof $e == "string" ? Array.prototype.push.apply(_e, Z.handleText($e, Je)) : typeof $e == "number" && _e.push($e);
                      }
                      Ze[0] = _e, pt = t.OPS.showText;
                      break;
                    case t.OPS.nextLineShowText:
                      if (!he.state.font) {
                        Z.ensureStateFont(he.state);
                        continue;
                      }
                      ie.addOp(t.OPS.nextLine), Ze[0] = Z.handleText(Ze[0], he.state), pt = t.OPS.showText;
                      break;
                    case t.OPS.nextLineSetSpacingShowText:
                      if (!he.state.font) {
                        Z.ensureStateFont(he.state);
                        continue;
                      }
                      ie.addOp(t.OPS.nextLine), ie.addOp(t.OPS.setWordSpacing, [Ze.shift()]), ie.addOp(t.OPS.setCharSpacing, [Ze.shift()]), Ze[0] = Z.handleText(Ze[0], he.state), pt = t.OPS.showText;
                      break;
                    case t.OPS.setTextRenderingMode:
                      he.state.textRenderingMode = Ze[0];
                      break;
                    case t.OPS.setFillColorSpace: {
                      const $e = p.ColorSpace.getCached(Ze[0], E, ee);
                      if ($e) {
                        he.state.fillColorSpace = $e;
                        continue;
                      }
                      De(Z.parseColorSpace({
                        cs: Ze[0],
                        resources: J,
                        localColorSpaceCache: ee
                      }).then(function(St) {
                        St && (he.state.fillColorSpace = St);
                      }));
                      return;
                    }
                    case t.OPS.setStrokeColorSpace: {
                      const $e = p.ColorSpace.getCached(Ze[0], E, ee);
                      if ($e) {
                        he.state.strokeColorSpace = $e;
                        continue;
                      }
                      De(Z.parseColorSpace({
                        cs: Ze[0],
                        resources: J,
                        localColorSpaceCache: ee
                      }).then(function(St) {
                        St && (he.state.strokeColorSpace = St);
                      }));
                      return;
                    }
                    case t.OPS.setFillColor:
                      be = he.state.fillColorSpace, Ze = be.getRgb(Ze, 0), pt = t.OPS.setFillRGBColor;
                      break;
                    case t.OPS.setStrokeColor:
                      be = he.state.strokeColorSpace, Ze = be.getRgb(Ze, 0), pt = t.OPS.setStrokeRGBColor;
                      break;
                    case t.OPS.setFillGray:
                      he.state.fillColorSpace = p.ColorSpace.singletons.gray, Ze = p.ColorSpace.singletons.gray.getRgb(Ze, 0), pt = t.OPS.setFillRGBColor;
                      break;
                    case t.OPS.setStrokeGray:
                      he.state.strokeColorSpace = p.ColorSpace.singletons.gray, Ze = p.ColorSpace.singletons.gray.getRgb(Ze, 0), pt = t.OPS.setStrokeRGBColor;
                      break;
                    case t.OPS.setFillCMYKColor:
                      he.state.fillColorSpace = p.ColorSpace.singletons.cmyk, Ze = p.ColorSpace.singletons.cmyk.getRgb(Ze, 0), pt = t.OPS.setFillRGBColor;
                      break;
                    case t.OPS.setStrokeCMYKColor:
                      he.state.strokeColorSpace = p.ColorSpace.singletons.cmyk, Ze = p.ColorSpace.singletons.cmyk.getRgb(Ze, 0), pt = t.OPS.setStrokeRGBColor;
                      break;
                    case t.OPS.setFillRGBColor:
                      he.state.fillColorSpace = p.ColorSpace.singletons.rgb, Ze = p.ColorSpace.singletons.rgb.getRgb(Ze, 0);
                      break;
                    case t.OPS.setStrokeRGBColor:
                      he.state.strokeColorSpace = p.ColorSpace.singletons.rgb, Ze = p.ColorSpace.singletons.rgb.getRgb(Ze, 0);
                      break;
                    case t.OPS.setFillColorN:
                      if (be = he.state.fillColorSpace, be.name === "Pattern") {
                        De(Z.handleColorN(ie, t.OPS.setFillColorN, Ze, be, ae, J, Y, ee, k, H));
                        return;
                      }
                      Ze = be.getRgb(Ze, 0), pt = t.OPS.setFillRGBColor;
                      break;
                    case t.OPS.setStrokeColorN:
                      if (be = he.state.strokeColorSpace, be.name === "Pattern") {
                        De(Z.handleColorN(ie, t.OPS.setStrokeColorN, Ze, be, ae, J, Y, ee, k, H));
                        return;
                      }
                      Ze = be.getRgb(Ze, 0), pt = t.OPS.setStrokeRGBColor;
                      break;
                    case t.OPS.shadingFill:
                      var ot = J.get("Shading");
                      if (!ot)
                        throw new t.FormatError("No shading resource found");
                      var mt = ot.get(Ze[0].name);
                      if (!mt)
                        throw new t.FormatError("No shading object found");
                      Ze = [Z.parseShading({
                        shading: mt,
                        resources: J,
                        localColorSpaceCache: ee,
                        localShadingPatternCache: H
                      })], pt = t.OPS.shadingFill;
                      break;
                    case t.OPS.setGState:
                      if (ze = Ze[0] instanceof v.Name, Le = Ze[0].name, ze) {
                        const $e = $.getByName(Le);
                        if ($e) {
                          $e.length > 0 && ie.addOp(t.OPS.setGState, [$e]), Ze = null;
                          continue;
                        }
                      }
                      De(new Promise(function($e, St) {
                        if (!ze)
                          throw new t.FormatError("GState must be referred to by name.");
                        const xt = J.get("ExtGState");
                        if (!(xt instanceof v.Dict))
                          throw new t.FormatError("ExtGState should be a dictionary.");
                        const Ie = xt.get(Le);
                        if (!(Ie instanceof v.Dict))
                          throw new t.FormatError("GState should be a dictionary.");
                        Z.setGState({
                          resources: J,
                          gState: Ie,
                          operatorList: ie,
                          cacheKey: Le,
                          task: Y,
                          stateManager: he,
                          localGStateCache: $,
                          localColorSpaceCache: ee
                        }).then($e, St);
                      }).catch(function($e) {
                        if (!($e instanceof t.AbortException)) {
                          if (Z.options.ignoreErrors) {
                            Z.handler.send("UnsupportedFeature", {
                              featureId: t.UNSUPPORTED_FEATURES.errorExtGState
                            }), (0, t.warn)(`getOperatorList - ignoring ExtGState: "${$e}".`);
                            return;
                          }
                          throw $e;
                        }
                      }));
                      return;
                    case t.OPS.moveTo:
                    case t.OPS.lineTo:
                    case t.OPS.curveTo:
                    case t.OPS.curveTo2:
                    case t.OPS.curveTo3:
                    case t.OPS.closePath:
                    case t.OPS.rectangle:
                      Z.buildPath(ie, pt, Ze, te);
                      continue;
                    case t.OPS.markPoint:
                    case t.OPS.markPointProps:
                    case t.OPS.beginCompat:
                    case t.OPS.endCompat:
                      continue;
                    case t.OPS.beginMarkedContentProps:
                      if (!(Ze[0] instanceof v.Name)) {
                        (0, t.warn)(`Expected name for beginMarkedContentProps arg0=${Ze[0]}`);
                        continue;
                      }
                      if (Ze[0].name === "OC") {
                        De(Z.parseMarkedContentProps(Ze[1], J).then(($e) => {
                          ie.addOp(t.OPS.beginMarkedContentProps, ["OC", $e]);
                        }).catch(($e) => {
                          if (!($e instanceof t.AbortException)) {
                            if (Z.options.ignoreErrors) {
                              Z.handler.send("UnsupportedFeature", {
                                featureId: t.UNSUPPORTED_FEATURES.errorMarkedContent
                              }), (0, t.warn)(`getOperatorList - ignoring beginMarkedContentProps: "${$e}".`);
                              return;
                            }
                            throw $e;
                          }
                        }));
                        return;
                      }
                      Ze = [Ze[0].name, Ze[1] instanceof v.Dict ? Ze[1].get("MCID") : null];
                      break;
                    case t.OPS.beginMarkedContent:
                    case t.OPS.endMarkedContent:
                    default:
                      if (Ze !== null) {
                        for (ve = 0, Se = Ze.length; ve < Se && !(Ze[ve] instanceof v.Dict); ve++)
                          ;
                        if (ve < Se) {
                          (0, t.warn)("getOperatorList - ignoring operator: " + pt);
                          continue;
                        }
                      }
                  }
                  ie.addOp(pt, Ze);
                }
                if (Te) {
                  De(S);
                  return;
                }
                me(), we();
              }).catch((Fe) => {
                if (!(Fe instanceof t.AbortException)) {
                  if (this.options.ignoreErrors) {
                    this.handler.send("UnsupportedFeature", {
                      featureId: t.UNSUPPORTED_FEATURES.errorOperatorList
                    }), (0, t.warn)(`getOperatorList - ignoring errors during "${Y.name}" task: "${Fe}".`), me();
                    return;
                  }
                  throw Fe;
                }
              });
            }
            getTextContent({
              stream: L,
              task: Y,
              resources: J,
              stateManager: ie = null,
              combineTextItems: q = !1,
              includeMarkedContent: N = !1,
              sink: Z,
              seenStyles: E = /* @__PURE__ */ new Set(),
              viewBox: te
            }) {
              J = J || v.Dict.empty, ie = ie || new G(new K());
              const re = (0, h.getNormalizedUnicodes)(), ee = {
                items: [],
                styles: /* @__PURE__ */ Object.create(null)
              }, $ = {
                initialized: !1,
                str: [],
                totalWidth: 0,
                totalHeight: 0,
                width: 0,
                height: 0,
                vertical: !1,
                prevTransform: null,
                textAdvanceScale: 0,
                spaceInFlowMin: 0,
                spaceInFlowMax: 0,
                trackingSpaceMin: 1 / 0,
                negativeSpaceMax: -1 / 0,
                notASpace: -1 / 0,
                transform: null,
                fontName: null,
                hasEOL: !1
              }, k = [" ", " "];
              let H = 0;
              function ne($e) {
                const St = (H + 1) % 2, xt = k[H] !== " " && k[St] === " ";
                return k[H] = $e, H = St, xt;
              }
              function ae() {
                k[0] = k[1] = " ", H = 0;
              }
              const he = 0.1, ue = 0.03, fe = -0.2, me = 0.1, Fe = 0.6, we = this, Ae = this.xref, De = [];
              let xe = null;
              const Te = new x.LocalImageCache(), ve = new x.LocalGStateCache(), Se = new z(L, Ae, ie);
              let be;
              function Le() {
                const $e = be.font, St = [be.fontSize * be.textHScale, 0, 0, be.fontSize, 0, be.textRise];
                if ($e.isType3Font && (be.fontSize <= 1 || $e.isCharBBox) && !(0, t.isArrayEqual)(be.fontMatrix, t.FONT_IDENTITY_MATRIX)) {
                  const xt = $e.bbox[3] - $e.bbox[1];
                  xt > 0 && (St[3] *= xt * be.fontMatrix[3]);
                }
                return t.Util.transform(be.ctm, t.Util.transform(be.textMatrix, St));
              }
              function ze() {
                if ($.initialized)
                  return $;
                const $e = be.font, St = $e.loadedName;
                E.has(St) || (E.add(St), ee.styles[St] = {
                  fontFamily: $e.fallbackName,
                  ascent: $e.ascent,
                  descent: $e.descent,
                  vertical: $e.vertical
                }), $.fontName = St;
                const xt = $.transform = Le();
                $e.vertical ? ($.width = $.totalWidth = Math.hypot(xt[0], xt[1]), $.height = $.totalHeight = 0, $.vertical = !0) : ($.width = $.totalWidth = 0, $.height = $.totalHeight = Math.hypot(xt[2], xt[3]), $.vertical = !1);
                const Ie = Math.hypot(be.textLineMatrix[0], be.textLineMatrix[1]), Ve = Math.hypot(be.ctm[0], be.ctm[1]);
                return $.textAdvanceScale = Ve * Ie, $.trackingSpaceMin = be.fontSize * he, $.notASpace = be.fontSize * ue, $.negativeSpaceMax = be.fontSize * fe, $.spaceInFlowMin = be.fontSize * me, $.spaceInFlowMax = be.fontSize * Fe, $.hasEOL = !1, $.initialized = !0, $;
              }
              function nt() {
                if (!$.initialized)
                  return;
                const $e = Math.hypot(be.textLineMatrix[0], be.textLineMatrix[1]), xt = Math.hypot(be.ctm[0], be.ctm[1]) * $e;
                xt !== $.textAdvanceScale && ($.vertical ? ($.totalHeight += $.height * $.textAdvanceScale, $.height = 0) : ($.totalWidth += $.width * $.textAdvanceScale, $.width = 0), $.textAdvanceScale = xt);
              }
              function Ue($e) {
                const St = $e.str.join(""), xt = (0, C.bidi)(St, -1, $e.vertical);
                return {
                  str: xt.str,
                  dir: xt.dir,
                  width: Math.abs($e.totalWidth),
                  height: Math.abs($e.totalHeight),
                  transform: $e.transform,
                  fontName: $e.fontName,
                  hasEOL: $e.hasEOL
                };
              }
              function Oe($e, St) {
                return we.loadFont($e, St, J).then(function(xt) {
                  return xt.font.isType3Font ? xt.loadType3Data(we, J, Y).catch(function() {
                  }).then(function() {
                    return xt;
                  }) : xt;
                }).then(function(xt) {
                  be.font = xt.font, be.fontMatrix = xt.font.fontMatrix || t.FONT_IDENTITY_MATRIX;
                });
              }
              function _e($e, St, xt) {
                const Ie = Math.hypot(xt[0], xt[1]);
                return [(xt[0] * $e + xt[1] * St) / Ie, (xt[2] * $e + xt[3] * St) / Ie];
              }
              function at() {
                const $e = Le();
                let St = $e[4], xt = $e[5];
                const Ie = St - te[0], Ve = xt - te[1];
                if (Ie < 0 || Ie > te[2] || Ve < 0 || Ve > te[3])
                  return !1;
                if (!q || !be.font || !$.prevTransform)
                  return !0;
                let st = $.prevTransform[4], ct = $.prevTransform[5];
                if (st === St && ct === xt)
                  return !0;
                let Rt = -1;
                switch ($e[0] && $e[1] === 0 && $e[2] === 0 ? Rt = $e[0] > 0 ? 0 : 180 : $e[1] && $e[0] === 0 && $e[3] === 0 && (Rt = $e[1] > 0 ? 90 : 270), Rt) {
                  case 0:
                    break;
                  case 90:
                    [St, xt] = [xt, St], [st, ct] = [ct, st];
                    break;
                  case 180:
                    [St, xt, st, ct] = [-St, -xt, -st, -ct];
                    break;
                  case 270:
                    [St, xt] = [-xt, -St], [st, ct] = [-ct, -st];
                    break;
                  default:
                    [St, xt] = _e(St, xt, $e), [st, ct] = _e(st, ct, $.prevTransform);
                }
                if (be.font.vertical) {
                  const rt = (ct - xt) / $.textAdvanceScale, tt = St - st, dt = Math.sign($.height);
                  return rt < dt * $.negativeSpaceMax ? Math.abs(tt) > 0.5 * $.width ? (ot(), !0) : (ae(), Ze(), !0) : Math.abs(tt) > $.width ? (ot(), !0) : (rt <= dt * $.notASpace && ae(), rt <= dt * $.trackingSpaceMin ? $.height += rt : mt(rt, $.prevTransform, dt) || ($.str.length === 0 ? (ae(), ee.items.push({
                    str: " ",
                    dir: "ltr",
                    width: 0,
                    height: Math.abs(rt),
                    transform: $.prevTransform,
                    fontName: $.fontName,
                    hasEOL: !1
                  })) : $.height += rt), !0);
                }
                const Lt = (St - st) / $.textAdvanceScale, Ge = xt - ct, Ne = Math.sign($.width);
                return Lt < Ne * $.negativeSpaceMax ? Math.abs(Ge) > 0.5 * $.height ? (ot(), !0) : (ae(), Ze(), !0) : Math.abs(Ge) > $.height ? (ot(), !0) : (Lt <= Ne * $.notASpace && ae(), Lt <= Ne * $.trackingSpaceMin ? $.width += Lt : mt(Lt, $.prevTransform, Ne) || ($.str.length === 0 ? (ae(), ee.items.push({
                  str: " ",
                  dir: "ltr",
                  width: Math.abs(Lt),
                  height: 0,
                  transform: $.prevTransform,
                  fontName: $.fontName,
                  hasEOL: !1
                })) : $.width += Lt), !0);
              }
              function Je({
                chars: $e,
                extraSpacing: St
              }) {
                const xt = be.font;
                if (!$e) {
                  const st = be.charSpacing + St;
                  st && (xt.vertical ? be.translateTextMatrix(0, -st) : be.translateTextMatrix(st * be.textHScale, 0));
                  return;
                }
                const Ie = xt.charsToGlyphs($e), Ve = be.fontMatrix[0] * be.fontSize;
                for (let st = 0, ct = Ie.length; st < ct; st++) {
                  const Rt = Ie[st];
                  if (Rt.isInvisibleFormatMark)
                    continue;
                  let Lt = be.charSpacing + (st + 1 === ct ? St : 0), Ge = Rt.width;
                  xt.vertical && (Ge = Rt.vmetric ? Rt.vmetric[0] : -Ge);
                  let Ne = Ge * Ve;
                  if (Rt.isWhitespace) {
                    xt.vertical ? (Lt += -Ne + be.wordSpacing, be.translateTextMatrix(0, -Lt)) : (Lt += Ne + be.wordSpacing, be.translateTextMatrix(Lt * be.textHScale, 0)), ne(" ");
                    continue;
                  }
                  if (!at())
                    continue;
                  const rt = ze();
                  Rt.isZeroWidthDiacritic && (Ne = 0), xt.vertical ? (be.translateTextMatrix(0, Ne), Ne = Math.abs(Ne), rt.height += Ne) : (Ne *= be.textHScale, be.translateTextMatrix(Ne, 0), rt.width += Ne), Ne && (rt.prevTransform = Le());
                  let tt = Rt.unicode;
                  tt = re[tt] || tt, tt = (0, h.reverseIfRtl)(tt), ne(tt) && rt.str.push(" "), rt.str.push(tt), Lt && (xt.vertical ? be.translateTextMatrix(0, -Lt) : be.translateTextMatrix(Lt * be.textHScale, 0));
                }
              }
              function ot() {
                ae(), $.initialized ? ($.hasEOL = !0, Ze()) : ee.items.push({
                  str: "",
                  dir: "ltr",
                  width: 0,
                  height: 0,
                  transform: Le(),
                  fontName: be.font.loadedName,
                  hasEOL: !0
                });
              }
              function mt($e, St, xt) {
                if (xt * $.spaceInFlowMin <= $e && $e <= xt * $.spaceInFlowMax)
                  return $.initialized && (ae(), $.str.push(" ")), !1;
                const Ie = $.fontName;
                let Ve = 0;
                return $.vertical && (Ve = $e, $e = 0), Ze(), ae(), ee.items.push({
                  str: " ",
                  dir: "ltr",
                  width: Math.abs($e),
                  height: Math.abs(Ve),
                  transform: St || Le(),
                  fontName: Ie,
                  hasEOL: !1
                }), !0;
              }
              function Ze() {
                !$.initialized || !$.str || ($.vertical ? $.totalHeight += $.height * $.textAdvanceScale : $.totalWidth += $.width * $.textAdvanceScale, ee.items.push(Ue($)), $.initialized = !1, $.str.length = 0);
              }
              function pt($e = !1) {
                const St = ee.items.length;
                St !== 0 && ($e && St < _ || (Z.enqueue(ee, St), ee.items = [], ee.styles = /* @__PURE__ */ Object.create(null)));
              }
              const Ft = new T();
              return new Promise(function $e(St, xt) {
                const Ie = function(rt) {
                  pt(!0), Promise.all([rt, Z.ready]).then(function() {
                    try {
                      $e(St, xt);
                    } catch (tt) {
                      xt(tt);
                    }
                  }, xt);
                };
                Y.ensureNotTerminated(), Ft.reset();
                const Ve = {};
                let st, ct = [];
                for (; !(st = Ft.check()) && (ct.length = 0, Ve.args = ct, !!Se.read(Ve)); ) {
                  be = ie.state;
                  const rt = Ve.fn;
                  switch (ct = Ve.args, rt | 0) {
                    case t.OPS.setFont:
                      var Rt = ct[0].name, Lt = ct[1];
                      if (be.font && Rt === be.fontName && Lt === be.fontSize)
                        break;
                      Ze(), be.fontName = Rt, be.fontSize = Lt, Ie(Oe(Rt, null));
                      return;
                    case t.OPS.setTextRise:
                      be.textRise = ct[0];
                      break;
                    case t.OPS.setHScale:
                      be.textHScale = ct[0] / 100;
                      break;
                    case t.OPS.setLeading:
                      be.leading = ct[0];
                      break;
                    case t.OPS.moveText:
                      be.translateTextLineMatrix(ct[0], ct[1]), be.textMatrix = be.textLineMatrix.slice();
                      break;
                    case t.OPS.setLeadingMoveText:
                      be.leading = -ct[1], be.translateTextLineMatrix(ct[0], ct[1]), be.textMatrix = be.textLineMatrix.slice();
                      break;
                    case t.OPS.nextLine:
                      be.carriageReturn();
                      break;
                    case t.OPS.setTextMatrix:
                      be.setTextMatrix(ct[0], ct[1], ct[2], ct[3], ct[4], ct[5]), be.setTextLineMatrix(ct[0], ct[1], ct[2], ct[3], ct[4], ct[5]), nt();
                      break;
                    case t.OPS.setCharSpacing:
                      be.charSpacing = ct[0];
                      break;
                    case t.OPS.setWordSpacing:
                      be.wordSpacing = ct[0];
                      break;
                    case t.OPS.beginText:
                      be.textMatrix = t.IDENTITY_MATRIX.slice(), be.textLineMatrix = t.IDENTITY_MATRIX.slice();
                      break;
                    case t.OPS.showSpacedText:
                      if (!ie.state.font) {
                        we.ensureStateFont(ie.state);
                        continue;
                      }
                      const tt = (be.font.vertical ? 1 : -1) * be.fontSize / 1e3, dt = ct[0];
                      for (let bt = 0, ht = dt.length; bt < ht - 1; bt++) {
                        const vt = dt[bt];
                        if (typeof vt == "string")
                          De.push(vt);
                        else if (typeof vt == "number" && vt !== 0) {
                          const _t = De.join("");
                          De.length = 0, Je({
                            chars: _t,
                            extraSpacing: vt * tt
                          });
                        }
                      }
                      const Ct = dt.at(-1);
                      if (typeof Ct == "string" && De.push(Ct), De.length > 0) {
                        const bt = De.join("");
                        De.length = 0, Je({
                          chars: bt,
                          extraSpacing: 0
                        });
                      }
                      break;
                    case t.OPS.showText:
                      if (!ie.state.font) {
                        we.ensureStateFont(ie.state);
                        continue;
                      }
                      Je({
                        chars: ct[0],
                        extraSpacing: 0
                      });
                      break;
                    case t.OPS.nextLineShowText:
                      if (!ie.state.font) {
                        we.ensureStateFont(ie.state);
                        continue;
                      }
                      be.carriageReturn(), Je({
                        chars: ct[0],
                        extraSpacing: 0
                      });
                      break;
                    case t.OPS.nextLineSetSpacingShowText:
                      if (!ie.state.font) {
                        we.ensureStateFont(ie.state);
                        continue;
                      }
                      be.wordSpacing = ct[0], be.charSpacing = ct[1], be.carriageReturn(), Je({
                        chars: ct[2],
                        extraSpacing: 0
                      });
                      break;
                    case t.OPS.paintXObject:
                      Ze(), xe || (xe = J.get("XObject") || v.Dict.empty);
                      var Ge = ct[0] instanceof v.Name, Ne = ct[0].name;
                      if (Ge && Te.getByName(Ne))
                        break;
                      Ie(new Promise(function(bt, ht) {
                        if (!Ge)
                          throw new t.FormatError("XObject must be referred to by name.");
                        let vt = xe.getRaw(Ne);
                        if (vt instanceof v.Ref) {
                          if (Te.getByRef(vt)) {
                            bt();
                            return;
                          }
                          if (we.globalImageCache.getData(vt, we.pageIndex)) {
                            bt();
                            return;
                          }
                          vt = Ae.fetch(vt);
                        }
                        if (!(vt instanceof m.BaseStream))
                          throw new t.FormatError("XObject should be a stream");
                        const _t = vt.dict.get("Subtype");
                        if (!(_t instanceof v.Name))
                          throw new t.FormatError("XObject should have a Name subtype");
                        if (_t.name !== "Form") {
                          Te.set(Ne, vt.dict.objId, !0), bt();
                          return;
                        }
                        const Nt = ie.state.clone(), Mt = new G(Nt), Et = vt.dict.getArray("Matrix");
                        Array.isArray(Et) && Et.length === 6 && Mt.transform(Et), pt();
                        const Re = {
                          enqueueInvoked: !1,
                          enqueue(We, it) {
                            this.enqueueInvoked = !0, Z.enqueue(We, it);
                          },
                          get desiredSize() {
                            return Z.desiredSize;
                          },
                          get ready() {
                            return Z.ready;
                          }
                        };
                        we.getTextContent({
                          stream: vt,
                          task: Y,
                          resources: vt.dict.get("Resources") || J,
                          stateManager: Mt,
                          combineTextItems: q,
                          includeMarkedContent: N,
                          sink: Re,
                          seenStyles: E,
                          viewBox: te
                        }).then(function() {
                          Re.enqueueInvoked || Te.set(Ne, vt.dict.objId, !0), bt();
                        }, ht);
                      }).catch(function(bt) {
                        if (!(bt instanceof t.AbortException)) {
                          if (we.options.ignoreErrors) {
                            (0, t.warn)(`getTextContent - ignoring XObject: "${bt}".`);
                            return;
                          }
                          throw bt;
                        }
                      }));
                      return;
                    case t.OPS.setGState:
                      if (Ge = ct[0] instanceof v.Name, Ne = ct[0].name, Ge && ve.getByName(Ne))
                        break;
                      Ie(new Promise(function(bt, ht) {
                        if (!Ge)
                          throw new t.FormatError("GState must be referred to by name.");
                        const vt = J.get("ExtGState");
                        if (!(vt instanceof v.Dict))
                          throw new t.FormatError("ExtGState should be a dictionary.");
                        const _t = vt.get(Ne);
                        if (!(_t instanceof v.Dict))
                          throw new t.FormatError("GState should be a dictionary.");
                        const Nt = _t.get("Font");
                        if (!Nt) {
                          ve.set(Ne, _t.objId, !0), bt();
                          return;
                        }
                        Ze(), be.fontName = null, be.fontSize = Nt[1], Oe(null, Nt[0]).then(bt, ht);
                      }).catch(function(bt) {
                        if (!(bt instanceof t.AbortException)) {
                          if (we.options.ignoreErrors) {
                            (0, t.warn)(`getTextContent - ignoring ExtGState: "${bt}".`);
                            return;
                          }
                          throw bt;
                        }
                      }));
                      return;
                    case t.OPS.beginMarkedContent:
                      Ze(), N && ee.items.push({
                        type: "beginMarkedContent",
                        tag: ct[0] instanceof v.Name ? ct[0].name : null
                      });
                      break;
                    case t.OPS.beginMarkedContentProps:
                      if (Ze(), N) {
                        let bt = null;
                        ct[1] instanceof v.Dict && (bt = ct[1].get("MCID")), ee.items.push({
                          type: "beginMarkedContentProps",
                          id: Number.isInteger(bt) ? `${we.idFactory.getPageObjId()}_mcid${bt}` : null,
                          tag: ct[0] instanceof v.Name ? ct[0].name : null
                        });
                      }
                      break;
                    case t.OPS.endMarkedContent:
                      Ze(), N && ee.items.push({
                        type: "endMarkedContent"
                      });
                      break;
                  }
                  if (ee.items.length >= Z.desiredSize) {
                    st = !0;
                    break;
                  }
                }
                if (st) {
                  Ie(S);
                  return;
                }
                Ze(), pt(), St();
              }).catch(($e) => {
                if (!($e instanceof t.AbortException)) {
                  if (this.options.ignoreErrors) {
                    (0, t.warn)(`getTextContent - ignoring errors during "${Y.name}" task: "${$e}".`), Ze(), pt();
                    return;
                  }
                  throw $e;
                }
              });
            }
            extractDataStructures(L, Y, J) {
              const ie = this.xref;
              let q;
              const N = this.readToUnicode(J.toUnicode || L.get("ToUnicode") || Y.get("ToUnicode"));
              if (J.composite) {
                const re = L.get("CIDSystemInfo");
                re instanceof v.Dict && (J.cidSystemInfo = {
                  registry: (0, t.stringToPDFString)(re.get("Registry")),
                  ordering: (0, t.stringToPDFString)(re.get("Ordering")),
                  supplement: re.get("Supplement")
                });
                try {
                  const ee = L.get("CIDToGIDMap");
                  ee instanceof m.BaseStream && (q = ee.getBytes());
                } catch (ee) {
                  if (!this.options.ignoreErrors)
                    throw ee;
                  (0, t.warn)(`extractDataStructures - ignoring CIDToGIDMap data: "${ee}".`);
                }
              }
              const Z = [];
              let E = null, te;
              if (L.has("Encoding")) {
                if (te = L.get("Encoding"), te instanceof v.Dict) {
                  if (E = te.get("BaseEncoding"), E = E instanceof v.Name ? E.name : null, te.has("Differences")) {
                    const re = te.get("Differences");
                    let ee = 0;
                    for (let $ = 0, k = re.length; $ < k; $++) {
                      const H = ie.fetchIfRef(re[$]);
                      if (typeof H == "number")
                        ee = H;
                      else if (H instanceof v.Name)
                        Z[ee++] = H.name;
                      else
                        throw new t.FormatError(`Invalid entry in 'Differences' array: ${H}`);
                    }
                  }
                } else if (te instanceof v.Name)
                  E = te.name;
                else {
                  const re = "Encoding is not a Name nor a Dict";
                  if (!this.options.ignoreErrors)
                    throw new t.FormatError(re);
                  (0, t.warn)(re);
                }
                E !== "MacRomanEncoding" && E !== "MacExpertEncoding" && E !== "WinAnsiEncoding" && (E = null);
              }
              if (E)
                J.defaultEncoding = (0, y.getEncoding)(E);
              else {
                const re = !!(J.flags & e.FontFlags.Symbolic), ee = !!(J.flags & e.FontFlags.Nonsymbolic);
                te = y.StandardEncoding, J.type === "TrueType" && !ee && (te = y.WinAnsiEncoding), re && (te = y.MacRomanEncoding, (!J.file || J.isInternalFont) && (/Symbol/i.test(J.name) ? te = y.SymbolSetEncoding : /Dingbats|Wingdings/i.test(J.name) && (te = y.ZapfDingbatsEncoding))), J.defaultEncoding = te;
              }
              return J.differences = Z, J.baseEncodingName = E, J.hasEncoding = !!E || Z.length > 0, J.dict = L, N.then((re) => (J.toUnicode = re, this.buildToUnicode(J))).then((re) => (J.toUnicode = re, q && (J.cidToGidMap = this.readCidToGidMap(q, re)), J));
            }
            _simpleFontToUnicode(L, Y = !1) {
              (0, t.assert)(!L.composite, "Must be a simple font.");
              const J = [], ie = L.defaultEncoding.slice(), q = L.baseEncodingName, N = L.differences;
              for (const E in N) {
                const te = N[E];
                te !== ".notdef" && (ie[E] = te);
              }
              const Z = (0, X.getGlyphsUnicode)();
              for (const E in ie) {
                let te = ie[E];
                if (te !== "") {
                  if (Z[te] === void 0) {
                    let re = 0;
                    switch (te[0]) {
                      case "G":
                        te.length === 3 && (re = parseInt(te.substring(1), 16));
                        break;
                      case "g":
                        te.length === 5 && (re = parseInt(te.substring(1), 16));
                        break;
                      case "C":
                      case "c":
                        if (te.length >= 3 && te.length <= 4) {
                          const $ = te.substring(1);
                          if (Y) {
                            re = parseInt($, 16);
                            break;
                          }
                          if (re = +$, Number.isNaN(re) && Number.isInteger(parseInt($, 16)))
                            return this._simpleFontToUnicode(L, !0);
                        }
                        break;
                      default:
                        const ee = (0, h.getUnicodeForGlyph)(te, Z);
                        ee !== -1 && (re = ee);
                    }
                    if (re > 0 && re <= 1114111 && Number.isInteger(re)) {
                      if (q && re === +E) {
                        const ee = (0, y.getEncoding)(q);
                        if (ee && (te = ee[E])) {
                          J[E] = String.fromCharCode(Z[te]);
                          continue;
                        }
                      }
                      J[E] = String.fromCodePoint(re);
                    }
                    continue;
                  }
                  J[E] = String.fromCharCode(Z[te]);
                }
              }
              return J;
            }
            async buildToUnicode(L) {
              if (L.hasIncludedToUnicodeMap = !!L.toUnicode && L.toUnicode.length > 0, L.hasIncludedToUnicodeMap)
                return !L.composite && L.hasEncoding && (L.fallbackToUnicode = this._simpleFontToUnicode(L)), L.toUnicode;
              if (!L.composite)
                return new c.ToUnicodeMap(this._simpleFontToUnicode(L));
              if (L.composite && (L.cMap.builtInCMap && !(L.cMap instanceof i.IdentityCMap) || L.cidSystemInfo.registry === "Adobe" && (L.cidSystemInfo.ordering === "GB1" || L.cidSystemInfo.ordering === "CNS1" || L.cidSystemInfo.ordering === "Japan1" || L.cidSystemInfo.ordering === "Korea1"))) {
                const {
                  registry: Y,
                  ordering: J
                } = L.cidSystemInfo, ie = v.Name.get(`${Y}-${J}-UCS2`), q = await i.CMapFactory.create({
                  encoding: ie,
                  fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                  useCMap: null
                }), N = [];
                return L.cMap.forEach(function(Z, E) {
                  if (E > 65535)
                    throw new t.FormatError("Max size of CID is 65,535");
                  const te = q.lookup(E);
                  te && (N[Z] = String.fromCharCode((te.charCodeAt(0) << 8) + te.charCodeAt(1)));
                }), new c.ToUnicodeMap(N);
              }
              return new c.IdentityToUnicodeMap(L.firstChar, L.lastChar);
            }
            readToUnicode(L) {
              return L ? L instanceof v.Name ? i.CMapFactory.create({
                encoding: L,
                fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                useCMap: null
              }).then(function(Y) {
                return Y instanceof i.IdentityCMap ? new c.IdentityToUnicodeMap(0, 65535) : new c.ToUnicodeMap(Y.getMap());
              }) : L instanceof m.BaseStream ? i.CMapFactory.create({
                encoding: L,
                fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                useCMap: null
              }).then(function(Y) {
                if (Y instanceof i.IdentityCMap)
                  return new c.IdentityToUnicodeMap(0, 65535);
                const J = new Array(Y.length);
                return Y.forEach(function(ie, q) {
                  if (typeof q == "number") {
                    J[ie] = String.fromCodePoint(q);
                    return;
                  }
                  const N = [];
                  for (let Z = 0; Z < q.length; Z += 2) {
                    const E = q.charCodeAt(Z) << 8 | q.charCodeAt(Z + 1);
                    if ((E & 63488) !== 55296) {
                      N.push(E);
                      continue;
                    }
                    Z += 2;
                    const te = q.charCodeAt(Z) << 8 | q.charCodeAt(Z + 1);
                    N.push(((E & 1023) << 10) + (te & 1023) + 65536);
                  }
                  J[ie] = String.fromCodePoint(...N);
                }), new c.ToUnicodeMap(J);
              }, (Y) => {
                if (Y instanceof t.AbortException)
                  return null;
                if (this.options.ignoreErrors)
                  return this.handler.send("UnsupportedFeature", {
                    featureId: t.UNSUPPORTED_FEATURES.errorFontToUnicode
                  }), (0, t.warn)(`readToUnicode - ignoring ToUnicode data: "${Y}".`), null;
                throw Y;
              }) : Promise.resolve(null) : Promise.resolve(null);
            }
            readCidToGidMap(L, Y) {
              const J = [];
              for (let ie = 0, q = L.length; ie < q; ie++) {
                const N = L[ie++] << 8 | L[ie], Z = ie >> 1;
                N === 0 && !Y.has(Z) || (J[Z] = N);
              }
              return J;
            }
            extractWidths(L, Y, J) {
              const ie = this.xref;
              let q = [], N = 0;
              const Z = [];
              let E, te, re, ee, $, k, H, ne;
              if (J.composite) {
                if (N = L.has("DW") ? L.get("DW") : 1e3, ne = L.get("W"), ne)
                  for (te = 0, re = ne.length; te < re; te++)
                    if (k = ie.fetchIfRef(ne[te++]), H = ie.fetchIfRef(ne[te]), Array.isArray(H))
                      for (ee = 0, $ = H.length; ee < $; ee++)
                        q[k++] = ie.fetchIfRef(H[ee]);
                    else {
                      const ue = ie.fetchIfRef(ne[++te]);
                      for (ee = k; ee <= H; ee++)
                        q[ee] = ue;
                    }
                if (J.vertical) {
                  let ue = L.getArray("DW2") || [880, -1e3];
                  if (E = [ue[1], N * 0.5, ue[0]], ue = L.get("W2"), ue)
                    for (te = 0, re = ue.length; te < re; te++)
                      if (k = ie.fetchIfRef(ue[te++]), H = ie.fetchIfRef(ue[te]), Array.isArray(H))
                        for (ee = 0, $ = H.length; ee < $; ee++)
                          Z[k++] = [ie.fetchIfRef(H[ee++]), ie.fetchIfRef(H[ee++]), ie.fetchIfRef(H[ee])];
                      else {
                        const fe = [ie.fetchIfRef(ue[++te]), ie.fetchIfRef(ue[++te]), ie.fetchIfRef(ue[++te])];
                        for (ee = k; ee <= H; ee++)
                          Z[ee] = fe;
                      }
                }
              } else {
                const ue = J.firstChar;
                if (ne = L.get("Widths"), ne) {
                  for (ee = ue, te = 0, re = ne.length; te < re; te++)
                    q[ee++] = ie.fetchIfRef(ne[te]);
                  N = parseFloat(Y.get("MissingWidth")) || 0;
                } else {
                  const fe = L.get("BaseFont");
                  if (fe instanceof v.Name) {
                    const me = this.getBaseFontMetrics(fe.name);
                    q = this.buildCharCodeToWidth(me.widths, J), N = me.defaultWidth;
                  }
                }
              }
              let ae = !0, he = N;
              for (const ue in q) {
                const fe = q[ue];
                if (fe) {
                  if (!he) {
                    he = fe;
                    continue;
                  }
                  if (he !== fe) {
                    ae = !1;
                    break;
                  }
                }
              }
              ae && (J.flags |= e.FontFlags.FixedPitch), J.defaultWidth = N, J.widths = q, J.defaultVMetrics = E, J.vmetrics = Z;
            }
            isSerifFont(L) {
              const Y = L.split("-")[0];
              return Y in (0, r.getSerifFonts)() || Y.search(/serif/gi) !== -1;
            }
            getBaseFontMetrics(L) {
              let Y = 0, J = /* @__PURE__ */ Object.create(null), ie = !1, N = (0, r.getStdFontMap)()[L] || L;
              const Z = (0, j.getMetrics)();
              N in Z || (this.isSerifFont(L) ? N = "Times-Roman" : N = "Helvetica");
              const E = Z[N];
              return typeof E == "number" ? (Y = E, ie = !0) : J = E(), {
                defaultWidth: Y,
                monospace: ie,
                widths: J
              };
            }
            buildCharCodeToWidth(L, Y) {
              const J = /* @__PURE__ */ Object.create(null), ie = Y.differences, q = Y.defaultEncoding;
              for (let N = 0; N < 256; N++) {
                if (N in ie && L[ie[N]]) {
                  J[N] = L[ie[N]];
                  continue;
                }
                if (N in q && L[q[N]]) {
                  J[N] = L[q[N]];
                  continue;
                }
              }
              return J;
            }
            preEvaluateFont(L) {
              const Y = L;
              let J = L.get("Subtype");
              if (!(J instanceof v.Name))
                throw new t.FormatError("invalid font Subtype");
              let ie = !1, q, N;
              if (J.name === "Type0") {
                const re = L.get("DescendantFonts");
                if (!re)
                  throw new t.FormatError("Descendant fonts are not specified");
                if (L = Array.isArray(re) ? this.xref.fetchIfRef(re[0]) : re, !(L instanceof v.Dict))
                  throw new t.FormatError("Descendant font is not a dictionary.");
                if (J = L.get("Subtype"), !(J instanceof v.Name))
                  throw new t.FormatError("invalid font Subtype");
                ie = !0;
              }
              const Z = L.get("FirstChar") || 0, E = L.get("LastChar") || (ie ? 65535 : 255), te = L.get("FontDescriptor");
              if (te) {
                q = new B.MurmurHash3_64();
                const re = Y.getRaw("Encoding");
                if (re instanceof v.Name)
                  q.update(re.name);
                else if (re instanceof v.Ref)
                  q.update(re.toString());
                else if (re instanceof v.Dict) {
                  for (const $ of re.getRawValues())
                    if ($ instanceof v.Name)
                      q.update($.name);
                    else if ($ instanceof v.Ref)
                      q.update($.toString());
                    else if (Array.isArray($)) {
                      const k = $.length, H = new Array(k);
                      for (let ne = 0; ne < k; ne++) {
                        const ae = $[ne];
                        ae instanceof v.Name ? H[ne] = ae.name : (typeof ae == "number" || ae instanceof v.Ref) && (H[ne] = ae.toString());
                      }
                      q.update(H.join());
                    }
                }
                if (q.update(`${Z}-${E}`), N = L.get("ToUnicode") || Y.get("ToUnicode"), N instanceof m.BaseStream) {
                  const $ = N.str || N, k = $.buffer ? new Uint8Array($.buffer.buffer, 0, $.bufferLength) : new Uint8Array($.bytes.buffer, $.start, $.end - $.start);
                  q.update(k);
                } else
                  N instanceof v.Name && q.update(N.name);
                const ee = L.get("Widths") || Y.get("Widths");
                if (Array.isArray(ee)) {
                  const $ = [];
                  for (const k of ee)
                    (typeof k == "number" || k instanceof v.Ref) && $.push(k.toString());
                  q.update($.join());
                }
                if (ie) {
                  q.update("compositeFont");
                  const $ = L.get("W") || Y.get("W");
                  if (Array.isArray($)) {
                    const H = [];
                    for (const ne of $)
                      if (typeof ne == "number" || ne instanceof v.Ref)
                        H.push(ne.toString());
                      else if (Array.isArray(ne)) {
                        const ae = [];
                        for (const he of ne)
                          (typeof he == "number" || he instanceof v.Ref) && ae.push(he.toString());
                        H.push(`[${ae.join()}]`);
                      }
                    q.update(H.join());
                  }
                  const k = L.getRaw("CIDToGIDMap") || Y.getRaw("CIDToGIDMap");
                  k instanceof v.Name ? q.update(k.name) : k instanceof v.Ref ? q.update(k.toString()) : k instanceof m.BaseStream && q.update(k.peekBytes());
                }
              }
              return {
                descriptor: te,
                dict: L,
                baseDict: Y,
                composite: ie,
                type: J.name,
                firstChar: Z,
                lastChar: E,
                toUnicode: N,
                hash: q ? q.hexdigest() : ""
              };
            }
            async translateFont({
              descriptor: L,
              dict: Y,
              baseDict: J,
              composite: ie,
              type: q,
              firstChar: N,
              lastChar: Z,
              toUnicode: E,
              cssFontInfo: te
            }) {
              const re = q === "Type3";
              let ee;
              if (!L)
                if (re)
                  L = new v.Dict(null), L.set("FontName", v.Name.get(q)), L.set("FontBBox", Y.getArray("FontBBox") || [0, 0, 0, 0]);
                else {
                  let we = Y.get("BaseFont");
                  if (!(we instanceof v.Name))
                    throw new t.FormatError("Base font is not specified");
                  we = we.name.replace(/[,_]/g, "-");
                  const Ae = this.getBaseFontMetrics(we), De = we.split("-")[0], xe = (this.isSerifFont(De) ? e.FontFlags.Serif : 0) | (Ae.monospace ? e.FontFlags.FixedPitch : 0) | ((0, r.getSymbolsFonts)()[De] ? e.FontFlags.Symbolic : e.FontFlags.Nonsymbolic);
                  ee = {
                    type: q,
                    name: we,
                    loadedName: J.loadedName,
                    widths: Ae.widths,
                    defaultWidth: Ae.defaultWidth,
                    isSimulatedFlags: !0,
                    flags: xe,
                    firstChar: N,
                    lastChar: Z,
                    toUnicode: E,
                    xHeight: 0,
                    capHeight: 0,
                    italicAngle: 0,
                    isType3Font: re
                  };
                  const Te = Y.get("Widths"), ve = (0, r.getStandardFontName)(we);
                  let Se = null;
                  return ve && (ee.isStandardFont = !0, Se = await this.fetchStandardFontData(ve), ee.isInternalFont = !!Se), this.extractDataStructures(Y, Y, ee).then((be) => {
                    if (Te) {
                      const Le = [];
                      let ze = N;
                      for (let nt = 0, Ue = Te.length; nt < Ue; nt++)
                        Le[ze++] = this.xref.fetchIfRef(Te[nt]);
                      be.widths = Le;
                    } else
                      be.widths = this.buildCharCodeToWidth(Ae.widths, be);
                    return new a.Font(we, Se, be);
                  });
                }
              let $ = L.get("FontName"), k = Y.get("BaseFont");
              if (typeof $ == "string" && ($ = v.Name.get($)), typeof k == "string" && (k = v.Name.get(k)), !re) {
                const we = $ && $.name, Ae = k && k.name;
                we !== Ae && ((0, t.info)(`The FontDescriptor's FontName is "${we}" but should be the same as the Font's BaseFont "${Ae}".`), we && Ae && Ae.startsWith(we) && ($ = k));
              }
              if ($ = $ || k, !($ instanceof v.Name))
                throw new t.FormatError("invalid font name");
              let H, ne, ae, he, ue;
              try {
                H = L.get("FontFile", "FontFile2", "FontFile3");
              } catch (we) {
                if (!this.options.ignoreErrors)
                  throw we;
                (0, t.warn)(`translateFont - fetching "${$.name}" font file: "${we}".`), H = new f.NullStream();
              }
              let fe = !1, me = !1, Fe = null;
              if (H) {
                if (H.dict) {
                  const we = H.dict.get("Subtype");
                  we instanceof v.Name && (ne = we.name), ae = H.dict.get("Length1"), he = H.dict.get("Length2"), ue = H.dict.get("Length3");
                }
              } else if (te) {
                const we = (0, d.getXfaFontName)($.name);
                we && (te.fontFamily = `${te.fontFamily}-PdfJS-XFA`, te.metrics = we.metrics || null, Fe = we.factors || null, H = await this.fetchStandardFontData(we.name), me = !!H, J = Y = (0, d.getXfaFontDict)($.name), ie = !0);
              } else if (!re) {
                const we = (0, r.getStandardFontName)($.name);
                we && (fe = !0, H = await this.fetchStandardFontData(we), me = !!H);
              }
              if (ee = {
                type: q,
                name: $.name,
                subtype: ne,
                file: H,
                length1: ae,
                length2: he,
                length3: ue,
                isStandardFont: fe,
                isInternalFont: me,
                loadedName: J.loadedName,
                composite: ie,
                fixedPitch: !1,
                fontMatrix: Y.getArray("FontMatrix") || t.FONT_IDENTITY_MATRIX,
                firstChar: N,
                lastChar: Z,
                toUnicode: E,
                bbox: L.getArray("FontBBox") || Y.getArray("FontBBox"),
                ascent: L.get("Ascent"),
                descent: L.get("Descent"),
                xHeight: L.get("XHeight") || 0,
                capHeight: L.get("CapHeight") || 0,
                flags: L.get("Flags"),
                italicAngle: L.get("ItalicAngle") || 0,
                isType3Font: re,
                cssFontInfo: te,
                scaleFactors: Fe
              }, ie) {
                const we = J.get("Encoding");
                we instanceof v.Name && (ee.cidEncoding = we.name);
                const Ae = await i.CMapFactory.create({
                  encoding: we,
                  fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                  useCMap: null
                });
                ee.cMap = Ae, ee.vertical = ee.cMap.vertical;
              }
              return this.extractDataStructures(Y, J, ee).then((we) => (this.extractWidths(Y, L, we), new a.Font($.name, H, we)));
            }
            static buildFontPaths(L, Y, J, ie) {
              function q(N) {
                const Z = `${L.loadedName}_path_${N}`;
                try {
                  if (L.renderer.hasBuiltPath(N))
                    return;
                  J.send("commonobj", [Z, "FontPath", L.renderer.getPathJs(N)]);
                } catch (E) {
                  if (ie.ignoreErrors) {
                    J.send("UnsupportedFeature", {
                      featureId: t.UNSUPPORTED_FEATURES.errorFontBuildPath
                    }), (0, t.warn)(`buildFontPaths - ignoring ${Z} glyph: "${E}".`);
                    return;
                  }
                  throw E;
                }
              }
              for (const N of Y) {
                q(N.fontChar);
                const Z = N.accent;
                Z && Z.fontChar && q(Z.fontChar);
              }
            }
            static get fallbackFontDict() {
              const L = new v.Dict();
              return L.set("BaseFont", v.Name.get("PDFJS-FallbackFont")), L.set("Type", v.Name.get("FallbackType")), L.set("Subtype", v.Name.get("FallbackType")), L.set("Encoding", v.Name.get("WinAnsiEncoding")), (0, t.shadow)(this, "fallbackFontDict", L);
            }
          }
          u.PartialEvaluator = O;
          class U {
            constructor({
              loadedName: L,
              font: Y,
              dict: J,
              evaluatorOptions: ie
            }) {
              this.loadedName = L, this.font = Y, this.dict = J, this._evaluatorOptions = ie || b, this.type3Loaded = null, this.type3Dependencies = Y.isType3Font ? /* @__PURE__ */ new Set() : null, this.sent = !1;
            }
            send(L) {
              this.sent || (this.sent = !0, L.send("commonobj", [this.loadedName, "Font", this.font.exportData(this._evaluatorOptions.fontExtraProperties)]));
            }
            fallback(L) {
              this.font.data && (this.font.disableFontFace = !0, O.buildFontPaths(this.font, this.font.glyphCacheValues, L, this._evaluatorOptions));
            }
            loadType3Data(L, Y, J) {
              if (this.type3Loaded)
                return this.type3Loaded;
              if (!this.font.isType3Font)
                throw new Error("Must be a Type3 font.");
              const ie = L.clone({
                ignoreErrors: !1
              });
              ie.parsingType3Font = !0;
              const q = new v.RefSet(L.type3FontRefs);
              this.dict.objId && !q.has(this.dict.objId) && q.put(this.dict.objId), ie.type3FontRefs = q;
              const N = this.font, Z = this.type3Dependencies;
              let E = Promise.resolve();
              const te = this.dict.get("CharProcs"), re = this.dict.get("Resources") || Y, ee = /* @__PURE__ */ Object.create(null), $ = t.Util.normalizeRect(N.bbox || [0, 0, 0, 0]), k = $[2] - $[0], H = $[3] - $[1], ne = Math.hypot(k, H);
              for (const ae of te.getKeys())
                E = E.then(() => {
                  const he = te.get(ae), ue = new R.OperatorList();
                  return ie.getOperatorList({
                    stream: he,
                    task: J,
                    resources: re,
                    operatorList: ue
                  }).then(() => {
                    ue.fnArray[0] === t.OPS.setCharWidthAndBounds && this._removeType3ColorOperators(ue, ne), ee[ae] = ue.getIR();
                    for (const fe of ue.dependencies)
                      Z.add(fe);
                  }).catch(function(fe) {
                    (0, t.warn)(`Type3 font resource "${ae}" is not available.`);
                    const me = new R.OperatorList();
                    ee[ae] = me.getIR();
                  });
                });
              return this.type3Loaded = E.then(() => {
                N.charProcOperatorList = ee, this._bbox && (N.isCharBBox = !0, N.bbox = this._bbox);
              }), this.type3Loaded;
            }
            _removeType3ColorOperators(L, Y = NaN) {
              const J = t.Util.normalizeRect(L.argsArray[0].slice(2)), ie = J[2] - J[0], q = J[3] - J[1], N = Math.hypot(ie, q);
              ie === 0 || q === 0 ? (L.fnArray.splice(0, 1), L.argsArray.splice(0, 1)) : (Y === 0 || Math.round(N / Y) >= 10) && (this._bbox || (this._bbox = [1 / 0, 1 / 0, -1 / 0, -1 / 0]), this._bbox[0] = Math.min(this._bbox[0], J[0]), this._bbox[1] = Math.min(this._bbox[1], J[1]), this._bbox[2] = Math.max(this._bbox[2], J[2]), this._bbox[3] = Math.max(this._bbox[3], J[3]));
              let Z = 0, E = L.length;
              for (; Z < E; ) {
                switch (L.fnArray[Z]) {
                  case t.OPS.setCharWidthAndBounds:
                    break;
                  case t.OPS.setStrokeColorSpace:
                  case t.OPS.setFillColorSpace:
                  case t.OPS.setStrokeColor:
                  case t.OPS.setStrokeColorN:
                  case t.OPS.setFillColor:
                  case t.OPS.setFillColorN:
                  case t.OPS.setStrokeGray:
                  case t.OPS.setFillGray:
                  case t.OPS.setStrokeRGBColor:
                  case t.OPS.setFillRGBColor:
                  case t.OPS.setStrokeCMYKColor:
                  case t.OPS.setFillCMYKColor:
                  case t.OPS.shadingFill:
                  case t.OPS.setRenderingIntent:
                    L.fnArray.splice(Z, 1), L.argsArray.splice(Z, 1), E--;
                    continue;
                  case t.OPS.setGState:
                    const [te] = L.argsArray[Z];
                    let re = 0, ee = te.length;
                    for (; re < ee; ) {
                      const [$] = te[re];
                      switch ($) {
                        case "TR":
                        case "TR2":
                        case "HT":
                        case "BG":
                        case "BG2":
                        case "UCR":
                        case "UCR2":
                          te.splice(re, 1), ee--;
                          continue;
                      }
                      re++;
                    }
                    break;
                }
                Z++;
              }
            }
          }
          class G {
            constructor(L = new W()) {
              this.state = L, this.stateStack = [];
            }
            save() {
              const L = this.state;
              this.stateStack.push(this.state), this.state = L.clone();
            }
            restore() {
              const L = this.stateStack.pop();
              L && (this.state = L);
            }
            transform(L) {
              this.state.ctm = t.Util.transform(this.state.ctm, L);
            }
          }
          class K {
            constructor() {
              this.ctm = new Float32Array(t.IDENTITY_MATRIX), this.fontName = null, this.fontSize = 0, this.font = null, this.fontMatrix = t.FONT_IDENTITY_MATRIX, this.textMatrix = t.IDENTITY_MATRIX.slice(), this.textLineMatrix = t.IDENTITY_MATRIX.slice(), this.charSpacing = 0, this.wordSpacing = 0, this.leading = 0, this.textHScale = 1, this.textRise = 0;
            }
            setTextMatrix(L, Y, J, ie, q, N) {
              const Z = this.textMatrix;
              Z[0] = L, Z[1] = Y, Z[2] = J, Z[3] = ie, Z[4] = q, Z[5] = N;
            }
            setTextLineMatrix(L, Y, J, ie, q, N) {
              const Z = this.textLineMatrix;
              Z[0] = L, Z[1] = Y, Z[2] = J, Z[3] = ie, Z[4] = q, Z[5] = N;
            }
            translateTextMatrix(L, Y) {
              const J = this.textMatrix;
              J[4] = J[0] * L + J[2] * Y + J[4], J[5] = J[1] * L + J[3] * Y + J[5];
            }
            translateTextLineMatrix(L, Y) {
              const J = this.textLineMatrix;
              J[4] = J[0] * L + J[2] * Y + J[4], J[5] = J[1] * L + J[3] * Y + J[5];
            }
            carriageReturn() {
              this.translateTextLineMatrix(0, -this.leading), this.textMatrix = this.textLineMatrix.slice();
            }
            clone() {
              const L = Object.create(this);
              return L.textMatrix = this.textMatrix.slice(), L.textLineMatrix = this.textLineMatrix.slice(), L.fontMatrix = this.fontMatrix.slice(), L;
            }
          }
          class W {
            constructor() {
              this.ctm = new Float32Array(t.IDENTITY_MATRIX), this.font = null, this.textRenderingMode = t.TextRenderingMode.FILL, this.fillColorSpace = p.ColorSpace.singletons.gray, this.strokeColorSpace = p.ColorSpace.singletons.gray;
            }
            clone() {
              return Object.create(this);
            }
          }
          class z {
            static get opMap() {
              const L = (0, M.getLookupTableFactory)(function(Y) {
                Y.w = {
                  id: t.OPS.setLineWidth,
                  numArgs: 1,
                  variableArgs: !1
                }, Y.J = {
                  id: t.OPS.setLineCap,
                  numArgs: 1,
                  variableArgs: !1
                }, Y.j = {
                  id: t.OPS.setLineJoin,
                  numArgs: 1,
                  variableArgs: !1
                }, Y.M = {
                  id: t.OPS.setMiterLimit,
                  numArgs: 1,
                  variableArgs: !1
                }, Y.d = {
                  id: t.OPS.setDash,
                  numArgs: 2,
                  variableArgs: !1
                }, Y.ri = {
                  id: t.OPS.setRenderingIntent,
                  numArgs: 1,
                  variableArgs: !1
                }, Y.i = {
                  id: t.OPS.setFlatness,
                  numArgs: 1,
                  variableArgs: !1
                }, Y.gs = {
                  id: t.OPS.setGState,
                  numArgs: 1,
                  variableArgs: !1
                }, Y.q = {
                  id: t.OPS.save,
                  numArgs: 0,
                  variableArgs: !1
                }, Y.Q = {
                  id: t.OPS.restore,
                  numArgs: 0,
                  variableArgs: !1
                }, Y.cm = {
                  id: t.OPS.transform,
                  numArgs: 6,
                  variableArgs: !1
                }, Y.m = {
                  id: t.OPS.moveTo,
                  numArgs: 2,
                  variableArgs: !1
                }, Y.l = {
                  id: t.OPS.lineTo,
                  numArgs: 2,
                  variableArgs: !1
                }, Y.c = {
                  id: t.OPS.curveTo,
                  numArgs: 6,
                  variableArgs: !1
                }, Y.v = {
                  id: t.OPS.curveTo2,
                  numArgs: 4,
                  variableArgs: !1
                }, Y.y = {
                  id: t.OPS.curveTo3,
                  numArgs: 4,
                  variableArgs: !1
                }, Y.h = {
                  id: t.OPS.closePath,
                  numArgs: 0,
                  variableArgs: !1
                }, Y.re = {
                  id: t.OPS.rectangle,
                  numArgs: 4,
                  variableArgs: !1
                }, Y.S = {
                  id: t.OPS.stroke,
                  numArgs: 0,
                  variableArgs: !1
                }, Y.s = {
                  id: t.OPS.closeStroke,
                  numArgs: 0,
                  variableArgs: !1
                }, Y.f = {
                  id: t.OPS.fill,
                  numArgs: 0,
                  variableArgs: !1
                }, Y.F = {
                  id: t.OPS.fill,
                  numArgs: 0,
                  variableArgs: !1
                }, Y["f*"] = {
                  id: t.OPS.eoFill,
                  numArgs: 0,
                  variableArgs: !1
                }, Y.B = {
                  id: t.OPS.fillStroke,
                  numArgs: 0,
                  variableArgs: !1
                }, Y["B*"] = {
                  id: t.OPS.eoFillStroke,
                  numArgs: 0,
                  variableArgs: !1
                }, Y.b = {
                  id: t.OPS.closeFillStroke,
                  numArgs: 0,
                  variableArgs: !1
                }, Y["b*"] = {
                  id: t.OPS.closeEOFillStroke,
                  numArgs: 0,
                  variableArgs: !1
                }, Y.n = {
                  id: t.OPS.endPath,
                  numArgs: 0,
                  variableArgs: !1
                }, Y.W = {
                  id: t.OPS.clip,
                  numArgs: 0,
                  variableArgs: !1
                }, Y["W*"] = {
                  id: t.OPS.eoClip,
                  numArgs: 0,
                  variableArgs: !1
                }, Y.BT = {
                  id: t.OPS.beginText,
                  numArgs: 0,
                  variableArgs: !1
                }, Y.ET = {
                  id: t.OPS.endText,
                  numArgs: 0,
                  variableArgs: !1
                }, Y.Tc = {
                  id: t.OPS.setCharSpacing,
                  numArgs: 1,
                  variableArgs: !1
                }, Y.Tw = {
                  id: t.OPS.setWordSpacing,
                  numArgs: 1,
                  variableArgs: !1
                }, Y.Tz = {
                  id: t.OPS.setHScale,
                  numArgs: 1,
                  variableArgs: !1
                }, Y.TL = {
                  id: t.OPS.setLeading,
                  numArgs: 1,
                  variableArgs: !1
                }, Y.Tf = {
                  id: t.OPS.setFont,
                  numArgs: 2,
                  variableArgs: !1
                }, Y.Tr = {
                  id: t.OPS.setTextRenderingMode,
                  numArgs: 1,
                  variableArgs: !1
                }, Y.Ts = {
                  id: t.OPS.setTextRise,
                  numArgs: 1,
                  variableArgs: !1
                }, Y.Td = {
                  id: t.OPS.moveText,
                  numArgs: 2,
                  variableArgs: !1
                }, Y.TD = {
                  id: t.OPS.setLeadingMoveText,
                  numArgs: 2,
                  variableArgs: !1
                }, Y.Tm = {
                  id: t.OPS.setTextMatrix,
                  numArgs: 6,
                  variableArgs: !1
                }, Y["T*"] = {
                  id: t.OPS.nextLine,
                  numArgs: 0,
                  variableArgs: !1
                }, Y.Tj = {
                  id: t.OPS.showText,
                  numArgs: 1,
                  variableArgs: !1
                }, Y.TJ = {
                  id: t.OPS.showSpacedText,
                  numArgs: 1,
                  variableArgs: !1
                }, Y["'"] = {
                  id: t.OPS.nextLineShowText,
                  numArgs: 1,
                  variableArgs: !1
                }, Y['"'] = {
                  id: t.OPS.nextLineSetSpacingShowText,
                  numArgs: 3,
                  variableArgs: !1
                }, Y.d0 = {
                  id: t.OPS.setCharWidth,
                  numArgs: 2,
                  variableArgs: !1
                }, Y.d1 = {
                  id: t.OPS.setCharWidthAndBounds,
                  numArgs: 6,
                  variableArgs: !1
                }, Y.CS = {
                  id: t.OPS.setStrokeColorSpace,
                  numArgs: 1,
                  variableArgs: !1
                }, Y.cs = {
                  id: t.OPS.setFillColorSpace,
                  numArgs: 1,
                  variableArgs: !1
                }, Y.SC = {
                  id: t.OPS.setStrokeColor,
                  numArgs: 4,
                  variableArgs: !0
                }, Y.SCN = {
                  id: t.OPS.setStrokeColorN,
                  numArgs: 33,
                  variableArgs: !0
                }, Y.sc = {
                  id: t.OPS.setFillColor,
                  numArgs: 4,
                  variableArgs: !0
                }, Y.scn = {
                  id: t.OPS.setFillColorN,
                  numArgs: 33,
                  variableArgs: !0
                }, Y.G = {
                  id: t.OPS.setStrokeGray,
                  numArgs: 1,
                  variableArgs: !1
                }, Y.g = {
                  id: t.OPS.setFillGray,
                  numArgs: 1,
                  variableArgs: !1
                }, Y.RG = {
                  id: t.OPS.setStrokeRGBColor,
                  numArgs: 3,
                  variableArgs: !1
                }, Y.rg = {
                  id: t.OPS.setFillRGBColor,
                  numArgs: 3,
                  variableArgs: !1
                }, Y.K = {
                  id: t.OPS.setStrokeCMYKColor,
                  numArgs: 4,
                  variableArgs: !1
                }, Y.k = {
                  id: t.OPS.setFillCMYKColor,
                  numArgs: 4,
                  variableArgs: !1
                }, Y.sh = {
                  id: t.OPS.shadingFill,
                  numArgs: 1,
                  variableArgs: !1
                }, Y.BI = {
                  id: t.OPS.beginInlineImage,
                  numArgs: 0,
                  variableArgs: !1
                }, Y.ID = {
                  id: t.OPS.beginImageData,
                  numArgs: 0,
                  variableArgs: !1
                }, Y.EI = {
                  id: t.OPS.endInlineImage,
                  numArgs: 1,
                  variableArgs: !1
                }, Y.Do = {
                  id: t.OPS.paintXObject,
                  numArgs: 1,
                  variableArgs: !1
                }, Y.MP = {
                  id: t.OPS.markPoint,
                  numArgs: 1,
                  variableArgs: !1
                }, Y.DP = {
                  id: t.OPS.markPointProps,
                  numArgs: 2,
                  variableArgs: !1
                }, Y.BMC = {
                  id: t.OPS.beginMarkedContent,
                  numArgs: 1,
                  variableArgs: !1
                }, Y.BDC = {
                  id: t.OPS.beginMarkedContentProps,
                  numArgs: 2,
                  variableArgs: !1
                }, Y.EMC = {
                  id: t.OPS.endMarkedContent,
                  numArgs: 0,
                  variableArgs: !1
                }, Y.BX = {
                  id: t.OPS.beginCompat,
                  numArgs: 0,
                  variableArgs: !1
                }, Y.EX = {
                  id: t.OPS.endCompat,
                  numArgs: 0,
                  variableArgs: !1
                }, Y.BM = null, Y.BD = null, Y.true = null, Y.fa = null, Y.fal = null, Y.fals = null, Y.false = null, Y.nu = null, Y.nul = null, Y.null = null;
              });
              return (0, t.shadow)(this, "opMap", L());
            }
            static get MAX_INVALID_PATH_OPS() {
              return (0, t.shadow)(this, "MAX_INVALID_PATH_OPS", 10);
            }
            constructor(L, Y, J = new G()) {
              this.parser = new o.Parser({
                lexer: new o.Lexer(L, z.opMap),
                xref: Y
              }), this.stateManager = J, this.nonProcessedArgs = [], this._isPathOp = !1, this._numInvalidPathOPS = 0;
            }
            get savedStatesDepth() {
              return this.stateManager.stateStack.length;
            }
            read(L) {
              let Y = L.args;
              for (; ; ) {
                const J = this.parser.getObj();
                if (J instanceof v.Cmd) {
                  const ie = J.cmd, q = z.opMap[ie];
                  if (!q) {
                    (0, t.warn)(`Unknown command "${ie}".`);
                    continue;
                  }
                  const N = q.id, Z = q.numArgs;
                  let E = Y !== null ? Y.length : 0;
                  if (this._isPathOp || (this._numInvalidPathOPS = 0), this._isPathOp = N >= t.OPS.moveTo && N <= t.OPS.endPath, q.variableArgs)
                    E > Z && (0, t.info)(`Command ${ie}: expected [0, ${Z}] args, but received ${E} args.`);
                  else {
                    if (E !== Z) {
                      const te = this.nonProcessedArgs;
                      for (; E > Z; )
                        te.push(Y.shift()), E--;
                      for (; E < Z && te.length !== 0; )
                        Y === null && (Y = []), Y.unshift(te.pop()), E++;
                    }
                    if (E < Z) {
                      const te = `command ${ie}: expected ${Z} args, but received ${E} args.`;
                      if (this._isPathOp && ++this._numInvalidPathOPS > z.MAX_INVALID_PATH_OPS)
                        throw new t.FormatError(`Invalid ${te}`);
                      (0, t.warn)(`Skipping ${te}`), Y !== null && (Y.length = 0);
                      continue;
                    }
                  }
                  return this.preprocessCommand(N, Y), L.fn = N, L.args = Y, !0;
                }
                if (J === v.EOF)
                  return !1;
                if (J !== null && (Y === null && (Y = []), Y.push(J), Y.length > 33))
                  throw new t.FormatError("Too many arguments");
              }
            }
            preprocessCommand(L, Y) {
              switch (L | 0) {
                case t.OPS.save:
                  this.stateManager.save();
                  break;
                case t.OPS.restore:
                  this.stateManager.restore();
                  break;
                case t.OPS.transform:
                  this.stateManager.transform(Y);
                  break;
              }
            }
          }
          u.EvaluatorPreprocessor = z;
        },
        /* 16 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.IdentityCMap = u.CMapFactory = u.CMap = void 0;
          var t = P(2), i = P(5), v = P(7), a = P(17), e = P(6), y = P(10);
          const r = ["Adobe-GB1-UCS2", "Adobe-CNS1-UCS2", "Adobe-Japan1-UCS2", "Adobe-Korea1-UCS2", "78-EUC-H", "78-EUC-V", "78-H", "78-RKSJ-H", "78-RKSJ-V", "78-V", "78ms-RKSJ-H", "78ms-RKSJ-V", "83pv-RKSJ-H", "90ms-RKSJ-H", "90ms-RKSJ-V", "90msp-RKSJ-H", "90msp-RKSJ-V", "90pv-RKSJ-H", "90pv-RKSJ-V", "Add-H", "Add-RKSJ-H", "Add-RKSJ-V", "Add-V", "Adobe-CNS1-0", "Adobe-CNS1-1", "Adobe-CNS1-2", "Adobe-CNS1-3", "Adobe-CNS1-4", "Adobe-CNS1-5", "Adobe-CNS1-6", "Adobe-GB1-0", "Adobe-GB1-1", "Adobe-GB1-2", "Adobe-GB1-3", "Adobe-GB1-4", "Adobe-GB1-5", "Adobe-Japan1-0", "Adobe-Japan1-1", "Adobe-Japan1-2", "Adobe-Japan1-3", "Adobe-Japan1-4", "Adobe-Japan1-5", "Adobe-Japan1-6", "Adobe-Korea1-0", "Adobe-Korea1-1", "Adobe-Korea1-2", "B5-H", "B5-V", "B5pc-H", "B5pc-V", "CNS-EUC-H", "CNS-EUC-V", "CNS1-H", "CNS1-V", "CNS2-H", "CNS2-V", "ETHK-B5-H", "ETHK-B5-V", "ETen-B5-H", "ETen-B5-V", "ETenms-B5-H", "ETenms-B5-V", "EUC-H", "EUC-V", "Ext-H", "Ext-RKSJ-H", "Ext-RKSJ-V", "Ext-V", "GB-EUC-H", "GB-EUC-V", "GB-H", "GB-V", "GBK-EUC-H", "GBK-EUC-V", "GBK2K-H", "GBK2K-V", "GBKp-EUC-H", "GBKp-EUC-V", "GBT-EUC-H", "GBT-EUC-V", "GBT-H", "GBT-V", "GBTpc-EUC-H", "GBTpc-EUC-V", "GBpc-EUC-H", "GBpc-EUC-V", "H", "HKdla-B5-H", "HKdla-B5-V", "HKdlb-B5-H", "HKdlb-B5-V", "HKgccs-B5-H", "HKgccs-B5-V", "HKm314-B5-H", "HKm314-B5-V", "HKm471-B5-H", "HKm471-B5-V", "HKscs-B5-H", "HKscs-B5-V", "Hankaku", "Hiragana", "KSC-EUC-H", "KSC-EUC-V", "KSC-H", "KSC-Johab-H", "KSC-Johab-V", "KSC-V", "KSCms-UHC-H", "KSCms-UHC-HW-H", "KSCms-UHC-HW-V", "KSCms-UHC-V", "KSCpc-EUC-H", "KSCpc-EUC-V", "Katakana", "NWP-H", "NWP-V", "RKSJ-H", "RKSJ-V", "Roman", "UniCNS-UCS2-H", "UniCNS-UCS2-V", "UniCNS-UTF16-H", "UniCNS-UTF16-V", "UniCNS-UTF32-H", "UniCNS-UTF32-V", "UniCNS-UTF8-H", "UniCNS-UTF8-V", "UniGB-UCS2-H", "UniGB-UCS2-V", "UniGB-UTF16-H", "UniGB-UTF16-V", "UniGB-UTF32-H", "UniGB-UTF32-V", "UniGB-UTF8-H", "UniGB-UTF8-V", "UniJIS-UCS2-H", "UniJIS-UCS2-HW-H", "UniJIS-UCS2-HW-V", "UniJIS-UCS2-V", "UniJIS-UTF16-H", "UniJIS-UTF16-V", "UniJIS-UTF32-H", "UniJIS-UTF32-V", "UniJIS-UTF8-H", "UniJIS-UTF8-V", "UniJIS2004-UTF16-H", "UniJIS2004-UTF16-V", "UniJIS2004-UTF32-H", "UniJIS2004-UTF32-V", "UniJIS2004-UTF8-H", "UniJIS2004-UTF8-V", "UniJISPro-UCS2-HW-V", "UniJISPro-UCS2-V", "UniJISPro-UTF8-V", "UniJISX0213-UTF32-H", "UniJISX0213-UTF32-V", "UniJISX02132004-UTF32-H", "UniJISX02132004-UTF32-V", "UniKS-UCS2-H", "UniKS-UCS2-V", "UniKS-UTF16-H", "UniKS-UTF16-V", "UniKS-UTF32-H", "UniKS-UTF32-V", "UniKS-UTF8-H", "UniKS-UTF8-V", "V", "WP-Symbol"], h = 2 ** 24 - 1;
          class g {
            constructor(x = !1) {
              this.codespaceRanges = [[], [], [], []], this.numCodespaceRanges = 0, this._map = [], this.name = "", this.vertical = !1, this.useCMap = null, this.builtInCMap = x;
            }
            addCodespaceRange(x, f, m) {
              this.codespaceRanges[x - 1].push(f, m), this.numCodespaceRanges++;
            }
            mapCidRange(x, f, m) {
              if (f - x > h)
                throw new Error("mapCidRange - ignoring data above MAX_MAP_RANGE.");
              for (; x <= f; )
                this._map[x++] = m++;
            }
            mapBfRange(x, f, m) {
              if (f - x > h)
                throw new Error("mapBfRange - ignoring data above MAX_MAP_RANGE.");
              const C = m.length - 1;
              for (; x <= f; ) {
                this._map[x++] = m;
                const p = m.charCodeAt(C) + 1;
                if (p > 255) {
                  m = m.substring(0, C - 1) + String.fromCharCode(m.charCodeAt(C - 1) + 1) + "\0";
                  continue;
                }
                m = m.substring(0, C) + String.fromCharCode(p);
              }
            }
            mapBfRangeToArray(x, f, m) {
              if (f - x > h)
                throw new Error("mapBfRangeToArray - ignoring data above MAX_MAP_RANGE.");
              const C = m.length;
              let p = 0;
              for (; x <= f && p < C; )
                this._map[x] = m[p++], ++x;
            }
            mapOne(x, f) {
              this._map[x] = f;
            }
            lookup(x) {
              return this._map[x];
            }
            contains(x) {
              return this._map[x] !== void 0;
            }
            forEach(x) {
              const f = this._map, m = f.length;
              if (m <= 65536)
                for (let C = 0; C < m; C++)
                  f[C] !== void 0 && x(C, f[C]);
              else
                for (const C in f)
                  x(C, f[C]);
            }
            charCodeOf(x) {
              const f = this._map;
              if (f.length <= 65536)
                return f.indexOf(x);
              for (const m in f)
                if (f[m] === x)
                  return m | 0;
              return -1;
            }
            getMap() {
              return this._map;
            }
            readCharCode(x, f, m) {
              let C = 0;
              const p = this.codespaceRanges;
              for (let w = 0, X = p.length; w < X; w++) {
                C = (C << 8 | x.charCodeAt(f + w)) >>> 0;
                const M = p[w];
                for (let j = 0, B = M.length; j < B; ) {
                  const R = M[j++], D = M[j++];
                  if (C >= R && C <= D) {
                    m.charcode = C, m.length = w + 1;
                    return;
                  }
                }
              }
              m.charcode = 0, m.length = 1;
            }
            getCharCodeLength(x) {
              const f = this.codespaceRanges;
              for (let m = 0, C = f.length; m < C; m++) {
                const p = f[m];
                for (let w = 0, X = p.length; w < X; ) {
                  const M = p[w++], j = p[w++];
                  if (x >= M && x <= j)
                    return m + 1;
                }
              }
              return 1;
            }
            get length() {
              return this._map.length;
            }
            get isIdentityCMap() {
              if (!(this.name === "Identity-H" || this.name === "Identity-V") || this._map.length !== 65536)
                return !1;
              for (let x = 0; x < 65536; x++)
                if (this._map[x] !== x)
                  return !1;
              return !0;
            }
          }
          u.CMap = g;
          class d extends g {
            constructor(x, f) {
              super(), this.vertical = x, this.addCodespaceRange(f, 0, 65535);
            }
            mapCidRange(x, f, m) {
              (0, t.unreachable)("should not call mapCidRange");
            }
            mapBfRange(x, f, m) {
              (0, t.unreachable)("should not call mapBfRange");
            }
            mapBfRangeToArray(x, f, m) {
              (0, t.unreachable)("should not call mapBfRangeToArray");
            }
            mapOne(x, f) {
              (0, t.unreachable)("should not call mapCidOne");
            }
            lookup(x) {
              return Number.isInteger(x) && x <= 65535 ? x : void 0;
            }
            contains(x) {
              return Number.isInteger(x) && x <= 65535;
            }
            forEach(x) {
              for (let f = 0; f <= 65535; f++)
                x(f, f);
            }
            charCodeOf(x) {
              return Number.isInteger(x) && x <= 65535 ? x : -1;
            }
            getMap() {
              const x = new Array(65536);
              for (let f = 0; f <= 65535; f++)
                x[f] = f;
              return x;
            }
            get length() {
              return 65536;
            }
            get isIdentityCMap() {
              (0, t.unreachable)("should not access .isIdentityCMap");
            }
          }
          u.IdentityCMap = d;
          const c = function() {
            function x(j, B) {
              let R = 0;
              for (let D = 0; D <= B; D++)
                R = R << 8 | j[D];
              return R >>> 0;
            }
            function f(j, B) {
              return B === 1 ? String.fromCharCode(j[0], j[1]) : B === 3 ? String.fromCharCode(j[0], j[1], j[2], j[3]) : String.fromCharCode.apply(null, j.subarray(0, B + 1));
            }
            function m(j, B, R) {
              let D = 0;
              for (let b = R; b >= 0; b--)
                D += j[b] + B[b], j[b] = D & 255, D >>= 8;
            }
            function C(j, B) {
              let R = 1;
              for (let D = B; D >= 0 && R > 0; D--)
                R += j[D], j[D] = R & 255, R >>= 8;
            }
            const p = 16, w = 19;
            class X {
              constructor(B) {
                this.buffer = B, this.pos = 0, this.end = B.length, this.tmpBuf = new Uint8Array(w);
              }
              readByte() {
                return this.pos >= this.end ? -1 : this.buffer[this.pos++];
              }
              readNumber() {
                let B = 0, R;
                do {
                  const D = this.readByte();
                  if (D < 0)
                    throw new t.FormatError("unexpected EOF in bcmap");
                  R = !(D & 128), B = B << 7 | D & 127;
                } while (!R);
                return B;
              }
              readSigned() {
                const B = this.readNumber();
                return B & 1 ? ~(B >>> 1) : B >>> 1;
              }
              readHex(B, R) {
                B.set(this.buffer.subarray(this.pos, this.pos + R + 1)), this.pos += R + 1;
              }
              readHexNumber(B, R) {
                let D;
                const b = this.tmpBuf;
                let l = 0;
                do {
                  const F = this.readByte();
                  if (F < 0)
                    throw new t.FormatError("unexpected EOF in bcmap");
                  D = !(F & 128), b[l++] = F & 127;
                } while (!D);
                let _ = R, S = 0, A = 0;
                for (; _ >= 0; ) {
                  for (; A < 8 && b.length > 0; )
                    S |= b[--l] << A, A += 7;
                  B[_] = S & 255, _--, S >>= 8, A -= 8;
                }
              }
              readHexSigned(B, R) {
                this.readHexNumber(B, R);
                const D = B[R] & 1 ? 255 : 0;
                let b = 0;
                for (let l = 0; l <= R; l++)
                  b = (b & 1) << 8 | B[l], B[l] = b >> 1 ^ D;
              }
              readString() {
                const B = this.readNumber();
                let R = "";
                for (let D = 0; D < B; D++)
                  R += String.fromCharCode(this.readNumber());
                return R;
              }
            }
            class M {
              async process(B, R, D) {
                const b = new X(B), l = b.readByte();
                R.vertical = !!(l & 1);
                let _ = null;
                const S = new Uint8Array(p), A = new Uint8Array(p), F = new Uint8Array(p), T = new Uint8Array(p), O = new Uint8Array(p);
                let U, G;
                for (; (G = b.readByte()) >= 0; ) {
                  const K = G >> 5;
                  if (K === 7) {
                    switch (G & 31) {
                      case 0:
                        b.readString();
                        break;
                      case 1:
                        _ = b.readString();
                        break;
                    }
                    continue;
                  }
                  const W = !!(G & 16), z = G & 15;
                  if (z + 1 > p)
                    throw new Error("BinaryCMapReader.process: Invalid dataSize.");
                  const V = 1, L = b.readNumber();
                  switch (K) {
                    case 0:
                      b.readHex(S, z), b.readHexNumber(A, z), m(A, S, z), R.addCodespaceRange(z + 1, x(S, z), x(A, z));
                      for (let Y = 1; Y < L; Y++)
                        C(A, z), b.readHexNumber(S, z), m(S, A, z), b.readHexNumber(A, z), m(A, S, z), R.addCodespaceRange(z + 1, x(S, z), x(A, z));
                      break;
                    case 1:
                      b.readHex(S, z), b.readHexNumber(A, z), m(A, S, z), b.readNumber();
                      for (let Y = 1; Y < L; Y++)
                        C(A, z), b.readHexNumber(S, z), m(S, A, z), b.readHexNumber(A, z), m(A, S, z), b.readNumber();
                      break;
                    case 2:
                      b.readHex(F, z), U = b.readNumber(), R.mapOne(x(F, z), U);
                      for (let Y = 1; Y < L; Y++)
                        C(F, z), W || (b.readHexNumber(O, z), m(F, O, z)), U = b.readSigned() + (U + 1), R.mapOne(x(F, z), U);
                      break;
                    case 3:
                      b.readHex(S, z), b.readHexNumber(A, z), m(A, S, z), U = b.readNumber(), R.mapCidRange(x(S, z), x(A, z), U);
                      for (let Y = 1; Y < L; Y++)
                        C(A, z), W ? S.set(A) : (b.readHexNumber(S, z), m(S, A, z)), b.readHexNumber(A, z), m(A, S, z), U = b.readNumber(), R.mapCidRange(x(S, z), x(A, z), U);
                      break;
                    case 4:
                      b.readHex(F, V), b.readHex(T, z), R.mapOne(x(F, V), f(T, z));
                      for (let Y = 1; Y < L; Y++)
                        C(F, V), W || (b.readHexNumber(O, V), m(F, O, V)), C(T, z), b.readHexSigned(O, z), m(T, O, z), R.mapOne(x(F, V), f(T, z));
                      break;
                    case 5:
                      b.readHex(S, V), b.readHexNumber(A, V), m(A, S, V), b.readHex(T, z), R.mapBfRange(x(S, V), x(A, V), f(T, z));
                      for (let Y = 1; Y < L; Y++)
                        C(A, V), W ? S.set(A) : (b.readHexNumber(S, V), m(S, A, V)), b.readHexNumber(A, V), m(A, S, V), b.readHex(T, z), R.mapBfRange(x(S, V), x(A, V), f(T, z));
                      break;
                    default:
                      throw new Error(`BinaryCMapReader.process - unknown type: ${K}`);
                  }
                }
                return _ ? D(_) : R;
              }
            }
            return M;
          }(), n = function() {
            function x(l) {
              let _ = 0;
              for (let S = 0; S < l.length; S++)
                _ = _ << 8 | l.charCodeAt(S);
              return _ >>> 0;
            }
            function f(l) {
              if (typeof l != "string")
                throw new t.FormatError("Malformed CMap: expected string.");
            }
            function m(l) {
              if (!Number.isInteger(l))
                throw new t.FormatError("Malformed CMap: expected int.");
            }
            function C(l, _) {
              for (; ; ) {
                let S = _.getObj();
                if (S === i.EOF)
                  break;
                if ((0, i.isCmd)(S, "endbfchar"))
                  return;
                f(S);
                const A = x(S);
                S = _.getObj(), f(S);
                const F = S;
                l.mapOne(A, F);
              }
            }
            function p(l, _) {
              for (; ; ) {
                let S = _.getObj();
                if (S === i.EOF)
                  break;
                if ((0, i.isCmd)(S, "endbfrange"))
                  return;
                f(S);
                const A = x(S);
                S = _.getObj(), f(S);
                const F = x(S);
                if (S = _.getObj(), Number.isInteger(S) || typeof S == "string") {
                  const T = Number.isInteger(S) ? String.fromCharCode(S) : S;
                  l.mapBfRange(A, F, T);
                } else if ((0, i.isCmd)(S, "[")) {
                  S = _.getObj();
                  const T = [];
                  for (; !(0, i.isCmd)(S, "]") && S !== i.EOF; )
                    T.push(S), S = _.getObj();
                  l.mapBfRangeToArray(A, F, T);
                } else
                  break;
              }
              throw new t.FormatError("Invalid bf range.");
            }
            function w(l, _) {
              for (; ; ) {
                let S = _.getObj();
                if (S === i.EOF)
                  break;
                if ((0, i.isCmd)(S, "endcidchar"))
                  return;
                f(S);
                const A = x(S);
                S = _.getObj(), m(S);
                const F = S;
                l.mapOne(A, F);
              }
            }
            function X(l, _) {
              for (; ; ) {
                let S = _.getObj();
                if (S === i.EOF)
                  break;
                if ((0, i.isCmd)(S, "endcidrange"))
                  return;
                f(S);
                const A = x(S);
                S = _.getObj(), f(S);
                const F = x(S);
                S = _.getObj(), m(S);
                const T = S;
                l.mapCidRange(A, F, T);
              }
            }
            function M(l, _) {
              for (; ; ) {
                let S = _.getObj();
                if (S === i.EOF)
                  break;
                if ((0, i.isCmd)(S, "endcodespacerange"))
                  return;
                if (typeof S != "string")
                  break;
                const A = x(S);
                if (S = _.getObj(), typeof S != "string")
                  break;
                const F = x(S);
                l.addCodespaceRange(S.length, A, F);
              }
              throw new t.FormatError("Invalid codespace range.");
            }
            function j(l, _) {
              const S = _.getObj();
              Number.isInteger(S) && (l.vertical = !!S);
            }
            function B(l, _) {
              const S = _.getObj();
              S instanceof i.Name && (l.name = S.name);
            }
            async function R(l, _, S, A) {
              let F, T;
              e:
                for (; ; )
                  try {
                    const O = _.getObj();
                    if (O === i.EOF)
                      break;
                    if (O instanceof i.Name)
                      O.name === "WMode" ? j(l, _) : O.name === "CMapName" && B(l, _), F = O;
                    else if (O instanceof i.Cmd)
                      switch (O.cmd) {
                        case "endcmap":
                          break e;
                        case "usecmap":
                          F instanceof i.Name && (T = F.name);
                          break;
                        case "begincodespacerange":
                          M(l, _);
                          break;
                        case "beginbfchar":
                          C(l, _);
                          break;
                        case "begincidchar":
                          w(l, _);
                          break;
                        case "beginbfrange":
                          p(l, _);
                          break;
                        case "begincidrange":
                          X(l, _);
                          break;
                      }
                  } catch (O) {
                    if (O instanceof e.MissingDataException)
                      throw O;
                    (0, t.warn)("Invalid cMap data: " + O);
                    continue;
                  }
              return !A && T && (A = T), A ? D(l, S, A) : l;
            }
            async function D(l, _, S) {
              if (l.useCMap = await b(S, _), l.numCodespaceRanges === 0) {
                const A = l.useCMap.codespaceRanges;
                for (let F = 0; F < A.length; F++)
                  l.codespaceRanges[F] = A[F].slice();
                l.numCodespaceRanges = l.useCMap.numCodespaceRanges;
              }
              return l.useCMap.forEach(function(A, F) {
                l.contains(A) || l.mapOne(A, l.useCMap.lookup(A));
              }), l;
            }
            async function b(l, _) {
              if (l === "Identity-H")
                return new d(!1, 2);
              if (l === "Identity-V")
                return new d(!0, 2);
              if (!r.includes(l))
                throw new Error("Unknown CMap name: " + l);
              if (!_)
                throw new Error("Built-in CMap parameters are not provided.");
              const {
                cMapData: S,
                compressionType: A
              } = await _(l), F = new g(!0);
              if (A === t.CMapCompressionType.BINARY)
                return new c().process(S, F, (T) => D(F, _, T));
              if (A === t.CMapCompressionType.NONE) {
                const T = new a.Lexer(new y.Stream(S));
                return R(F, T, _, null);
              }
              throw new Error("TODO: Only BINARY/NONE CMap compression is currently supported.");
            }
            return {
              async create(l) {
                const _ = l.encoding, S = l.fetchBuiltInCMap, A = l.useCMap;
                if (_ instanceof i.Name)
                  return b(_.name, S);
                if (_ instanceof v.BaseStream) {
                  const F = await R(new g(), new a.Lexer(_), S, A);
                  return F.isIdentityCMap ? b(F.name, S) : F;
                }
                throw new Error("Encoding required.");
              }
            };
          }();
          u.CMapFactory = n;
        },
        /* 17 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.Parser = u.Linearization = u.Lexer = void 0;
          var t = P(2), i = P(5), v = P(6), a = P(18), e = P(20), y = P(21), r = P(23), h = P(24), g = P(27), d = P(29), c = P(31), n = P(10), o = P(32), x = P(33);
          const f = 1e3, m = 5552;
          function C(B) {
            const R = B.length;
            let D = 1, b = 0;
            for (let l = 0; l < R; ++l)
              D += B[l] & 255, b += D;
            return b % 65521 << 16 | D % 65521;
          }
          class p {
            constructor({
              lexer: R,
              xref: D,
              allowStreams: b = !1,
              recoveryMode: l = !1
            }) {
              this.lexer = R, this.xref = D, this.allowStreams = b, this.recoveryMode = l, this.imageCache = /* @__PURE__ */ Object.create(null), this.refill();
            }
            refill() {
              this.buf1 = this.lexer.getObj(), this.buf2 = this.lexer.getObj();
            }
            shift() {
              this.buf2 instanceof i.Cmd && this.buf2.cmd === "ID" ? (this.buf1 = this.buf2, this.buf2 = null) : (this.buf1 = this.buf2, this.buf2 = this.lexer.getObj());
            }
            tryShift() {
              try {
                return this.shift(), !0;
              } catch (R) {
                if (R instanceof v.MissingDataException)
                  throw R;
                return !1;
              }
            }
            getObj(R = null) {
              const D = this.buf1;
              if (this.shift(), D instanceof i.Cmd)
                switch (D.cmd) {
                  case "BI":
                    return this.makeInlineImage(R);
                  case "[":
                    const b = [];
                    for (; !(0, i.isCmd)(this.buf1, "]") && this.buf1 !== i.EOF; )
                      b.push(this.getObj(R));
                    if (this.buf1 === i.EOF) {
                      if (this.recoveryMode)
                        return b;
                      throw new v.ParserEOFException("End of file inside array.");
                    }
                    return this.shift(), b;
                  case "<<":
                    const l = new i.Dict(this.xref);
                    for (; !(0, i.isCmd)(this.buf1, ">>") && this.buf1 !== i.EOF; ) {
                      if (!(this.buf1 instanceof i.Name)) {
                        (0, t.info)("Malformed dictionary: key must be a name object"), this.shift();
                        continue;
                      }
                      const _ = this.buf1.name;
                      if (this.shift(), this.buf1 === i.EOF)
                        break;
                      l.set(_, this.getObj(R));
                    }
                    if (this.buf1 === i.EOF) {
                      if (this.recoveryMode)
                        return l;
                      throw new v.ParserEOFException("End of file inside dictionary.");
                    }
                    return (0, i.isCmd)(this.buf2, "stream") ? this.allowStreams ? this.makeStream(l, R) : l : (this.shift(), l);
                  default:
                    return D;
                }
              if (Number.isInteger(D)) {
                if (Number.isInteger(this.buf1) && (0, i.isCmd)(this.buf2, "R")) {
                  const b = i.Ref.get(D, this.buf1);
                  return this.shift(), this.shift(), b;
                }
                return D;
              }
              return typeof D == "string" && R ? R.decryptString(D) : D;
            }
            findDefaultInlineStreamEnd(R) {
              const F = this.lexer, T = R.pos, O = 10;
              let U = 0, G, K;
              for (; (G = R.getByte()) !== -1; )
                if (U === 0)
                  U = G === 69 ? 1 : 0;
                else if (U === 1)
                  U = G === 73 ? 2 : 0;
                else if ((0, t.assert)(U === 2, "findDefaultInlineStreamEnd - invalid state."), G === 32 || G === 10 || G === 13) {
                  K = R.pos;
                  const z = R.peekBytes(O);
                  for (let V = 0, L = z.length; V < L; V++)
                    if (G = z[V], !(G === 0 && z[V + 1] !== 0) && G !== 10 && G !== 13 && (G < 32 || G > 127)) {
                      U = 0;
                      break;
                    }
                  if (U !== 2)
                    continue;
                  if (F.knownCommands) {
                    const V = F.peekObj();
                    V instanceof i.Cmd && !F.knownCommands[V.cmd] && (U = 0);
                  } else
                    (0, t.warn)("findDefaultInlineStreamEnd - `lexer.knownCommands` is undefined.");
                  if (U === 2)
                    break;
                } else
                  U = 0;
              G === -1 && ((0, t.warn)("findDefaultInlineStreamEnd: Reached the end of the stream without finding a valid EI marker"), K && ((0, t.warn)('... trying to recover by using the last "EI" occurrence.'), R.skip(-(R.pos - K))));
              let W = 4;
              return R.skip(-W), G = R.peekByte(), R.skip(W), (0, v.isWhiteSpace)(G) || W--, R.pos - W - T;
            }
            findDCTDecodeInlineStreamEnd(R) {
              const D = R.pos;
              let b = !1, l, _;
              for (; (l = R.getByte()) !== -1; )
                if (l === 255) {
                  switch (R.getByte()) {
                    case 0:
                      break;
                    case 255:
                      R.skip(-1);
                      break;
                    case 217:
                      b = !0;
                      break;
                    case 192:
                    case 193:
                    case 194:
                    case 195:
                    case 197:
                    case 198:
                    case 199:
                    case 201:
                    case 202:
                    case 203:
                    case 205:
                    case 206:
                    case 207:
                    case 196:
                    case 204:
                    case 218:
                    case 219:
                    case 220:
                    case 221:
                    case 222:
                    case 223:
                    case 224:
                    case 225:
                    case 226:
                    case 227:
                    case 228:
                    case 229:
                    case 230:
                    case 231:
                    case 232:
                    case 233:
                    case 234:
                    case 235:
                    case 236:
                    case 237:
                    case 238:
                    case 239:
                    case 254:
                      _ = R.getUint16(), _ > 2 ? R.skip(_ - 2) : R.skip(-2);
                      break;
                  }
                  if (b)
                    break;
                }
              const S = R.pos - D;
              return l === -1 ? ((0, t.warn)("Inline DCTDecode image stream: EOI marker not found, searching for /EI/ instead."), R.skip(-S), this.findDefaultInlineStreamEnd(R)) : (this.inlineStreamSkipEI(R), S);
            }
            findASCII85DecodeInlineStreamEnd(R) {
              const l = R.pos;
              let _;
              for (; (_ = R.getByte()) !== -1; )
                if (_ === 126) {
                  const A = R.pos;
                  for (_ = R.peekByte(); (0, v.isWhiteSpace)(_); )
                    R.skip(), _ = R.peekByte();
                  if (_ === 62) {
                    R.skip();
                    break;
                  }
                  if (R.pos > A) {
                    const F = R.peekBytes(2);
                    if (F[0] === 69 && F[1] === 73)
                      break;
                  }
                }
              const S = R.pos - l;
              return _ === -1 ? ((0, t.warn)("Inline ASCII85Decode image stream: EOD marker not found, searching for /EI/ instead."), R.skip(-S), this.findDefaultInlineStreamEnd(R)) : (this.inlineStreamSkipEI(R), S);
            }
            findASCIIHexDecodeInlineStreamEnd(R) {
              const b = R.pos;
              let l;
              for (; (l = R.getByte()) !== -1 && l !== 62; )
                ;
              const _ = R.pos - b;
              return l === -1 ? ((0, t.warn)("Inline ASCIIHexDecode image stream: EOD marker not found, searching for /EI/ instead."), R.skip(-_), this.findDefaultInlineStreamEnd(R)) : (this.inlineStreamSkipEI(R), _);
            }
            inlineStreamSkipEI(R) {
              let l = 0, _;
              for (; (_ = R.getByte()) !== -1; )
                if (l === 0)
                  l = _ === 69 ? 1 : 0;
                else if (l === 1)
                  l = _ === 73 ? 2 : 0;
                else if (l === 2)
                  break;
            }
            makeInlineImage(R) {
              const D = this.lexer, b = D.stream, l = new i.Dict(this.xref);
              let _;
              for (; !(0, i.isCmd)(this.buf1, "ID") && this.buf1 !== i.EOF; ) {
                if (!(this.buf1 instanceof i.Name))
                  throw new t.FormatError("Dictionary key must be a name object");
                const G = this.buf1.name;
                if (this.shift(), this.buf1 === i.EOF)
                  break;
                l.set(G, this.getObj(R));
              }
              D.beginInlineImagePos !== -1 && (_ = b.pos - D.beginInlineImagePos);
              const S = l.get("F", "Filter");
              let A;
              if (S instanceof i.Name)
                A = S.name;
              else if (Array.isArray(S)) {
                const G = this.xref.fetchIfRef(S[0]);
                G instanceof i.Name && (A = G.name);
              }
              const F = b.pos;
              let T;
              switch (A) {
                case "DCT":
                case "DCTDecode":
                  T = this.findDCTDecodeInlineStreamEnd(b);
                  break;
                case "A85":
                case "ASCII85Decode":
                  T = this.findASCII85DecodeInlineStreamEnd(b);
                  break;
                case "AHx":
                case "ASCIIHexDecode":
                  T = this.findASCIIHexDecodeInlineStreamEnd(b);
                  break;
                default:
                  T = this.findDefaultInlineStreamEnd(b);
              }
              let O = b.makeSubStream(F, T, l), U;
              if (T < f && _ < m) {
                const G = O.getBytes();
                O.reset();
                const K = b.pos;
                b.pos = D.beginInlineImagePos;
                const W = b.getBytes(_);
                b.pos = K, U = C(G) + "_" + C(W);
                const z = this.imageCache[U];
                if (z !== void 0)
                  return this.buf2 = i.Cmd.get("EI"), this.shift(), z.reset(), z;
              }
              return R && (O = R.createStream(O, T)), O = this.filter(O, l, T), O.dict = l, U !== void 0 && (O.cacheKey = `inline_${T}_${U}`, this.imageCache[U] = O), this.buf2 = i.Cmd.get("EI"), this.shift(), O;
            }
            _findStreamLength(R, D) {
              const {
                stream: b
              } = this.lexer;
              b.pos = R;
              const l = 2048, _ = D.length;
              for (; b.pos < b.end; ) {
                const S = b.peekBytes(l), A = S.length - _;
                if (A <= 0)
                  break;
                let F = 0;
                for (; F < A; ) {
                  let T = 0;
                  for (; T < _ && S[F + T] === D[T]; )
                    T++;
                  if (T >= _)
                    return b.pos += F, b.pos - R;
                  F++;
                }
                b.pos += A;
              }
              return -1;
            }
            makeStream(R, D) {
              const b = this.lexer;
              let l = b.stream;
              b.skipToNextLine();
              const _ = l.pos - 1;
              let S = R.get("Length");
              if (Number.isInteger(S) || ((0, t.info)(`Bad length "${S && S.toString()}" in stream.`), S = 0), l.pos = _ + S, b.nextChar(), this.tryShift() && (0, i.isCmd)(this.buf2, "endstream"))
                this.shift();
              else {
                const A = new Uint8Array([101, 110, 100, 115, 116, 114, 101, 97, 109]);
                let F = this._findStreamLength(_, A);
                if (F < 0) {
                  for (let O = 1; O <= 1; O++) {
                    const U = A.length - O, G = A.slice(0, U), K = this._findStreamLength(_, G);
                    if (K >= 0) {
                      const W = l.peekBytes(U + 1)[U];
                      if (!(0, v.isWhiteSpace)(W))
                        break;
                      (0, t.info)(`Found "${(0, t.bytesToString)(G)}" when searching for endstream command.`), F = K;
                      break;
                    }
                  }
                  if (F < 0)
                    throw new t.FormatError("Missing endstream command.");
                }
                S = F, b.nextChar(), this.shift(), this.shift();
              }
              return this.shift(), l = l.makeSubStream(_, S, R), D && (l = D.createStream(l, S)), l = this.filter(l, R, S), l.dict = R, l;
            }
            filter(R, D, b) {
              let l = D.get("F", "Filter"), _ = D.get("DP", "DecodeParms");
              if (l instanceof i.Name)
                return Array.isArray(_) && (0, t.warn)("/DecodeParms should not be an Array, when /Filter is a Name."), this.makeFilter(R, l.name, b, _);
              let S = b;
              if (Array.isArray(l)) {
                const A = l, F = _;
                for (let T = 0, O = A.length; T < O; ++T) {
                  if (l = this.xref.fetchIfRef(A[T]), !(l instanceof i.Name))
                    throw new t.FormatError(`Bad filter name "${l}"`);
                  _ = null, Array.isArray(F) && T in F && (_ = this.xref.fetchIfRef(F[T])), R = this.makeFilter(R, l.name, S, _), S = null;
                }
              }
              return R;
            }
            makeFilter(R, D, b, l) {
              if (b === 0)
                return (0, t.warn)(`Empty "${D}" stream.`), new n.NullStream();
              const _ = this.xref.stats;
              try {
                switch (D) {
                  case "Fl":
                  case "FlateDecode":
                    return _.addStreamType(t.StreamType.FLATE), l ? new o.PredictorStream(new r.FlateStream(R, b), b, l) : new r.FlateStream(R, b);
                  case "LZW":
                  case "LZWDecode":
                    _.addStreamType(t.StreamType.LZW);
                    let S = 1;
                    return l ? (l.has("EarlyChange") && (S = l.get("EarlyChange")), new o.PredictorStream(new c.LZWStream(R, b, S), b, l)) : new c.LZWStream(R, b, S);
                  case "DCT":
                  case "DCTDecode":
                    return _.addStreamType(t.StreamType.DCT), new g.JpegStream(R, b, l);
                  case "JPX":
                  case "JPXDecode":
                    return _.addStreamType(t.StreamType.JPX), new d.JpxStream(R, b, l);
                  case "A85":
                  case "ASCII85Decode":
                    return _.addStreamType(t.StreamType.A85), new a.Ascii85Stream(R, b);
                  case "AHx":
                  case "ASCIIHexDecode":
                    return _.addStreamType(t.StreamType.AHX), new e.AsciiHexStream(R, b);
                  case "CCF":
                  case "CCITTFaxDecode":
                    return _.addStreamType(t.StreamType.CCF), new y.CCITTFaxStream(R, b, l);
                  case "RL":
                  case "RunLengthDecode":
                    return _.addStreamType(t.StreamType.RLX), new x.RunLengthStream(R, b);
                  case "JBIG2Decode":
                    return _.addStreamType(t.StreamType.JBIG), new h.Jbig2Stream(R, b, l);
                }
                return (0, t.warn)(`Filter "${D}" is not supported.`), R;
              } catch (S) {
                if (S instanceof v.MissingDataException)
                  throw S;
                return (0, t.warn)(`Invalid stream: "${S}"`), new n.NullStream();
              }
            }
          }
          u.Parser = p;
          const w = [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          function X(B) {
            return B >= 48 && B <= 57 ? B & 15 : B >= 65 && B <= 70 || B >= 97 && B <= 102 ? (B & 15) + 9 : -1;
          }
          class M {
            constructor(R, D = null) {
              this.stream = R, this.nextChar(), this.strBuf = [], this.knownCommands = D, this._hexStringNumWarn = 0, this.beginInlineImagePos = -1;
            }
            nextChar() {
              return this.currentChar = this.stream.getByte();
            }
            peekChar() {
              return this.stream.peekByte();
            }
            getNumber() {
              let R = this.currentChar, D = !1, b = 0, l = 0;
              if (R === 45 ? (l = -1, R = this.nextChar(), R === 45 && (R = this.nextChar())) : R === 43 && (l = 1, R = this.nextChar()), R === 10 || R === 13)
                do
                  R = this.nextChar();
                while (R === 10 || R === 13);
              if (R === 46 && (b = 10, R = this.nextChar()), R < 48 || R > 57) {
                if ((0, v.isWhiteSpace)(R) || R === -1) {
                  if (b === 10 && l === 0)
                    return (0, t.warn)("Lexer.getNumber - treating a single decimal point as zero."), 0;
                  if (b === 0 && l === -1)
                    return (0, t.warn)("Lexer.getNumber - treating a single minus sign as zero."), 0;
                }
                throw new t.FormatError(`Invalid number: ${String.fromCharCode(R)} (charCode ${R})`);
              }
              l = l || 1;
              let _ = R - 48, S = 0, A = 1;
              for (; (R = this.nextChar()) >= 0; )
                if (R >= 48 && R <= 57) {
                  const F = R - 48;
                  D ? S = S * 10 + F : (b !== 0 && (b *= 10), _ = _ * 10 + F);
                } else if (R === 46)
                  if (b === 0)
                    b = 1;
                  else
                    break;
                else if (R === 45)
                  (0, t.warn)("Badly formatted number: minus sign in the middle");
                else if (R === 69 || R === 101) {
                  if (R = this.peekChar(), R === 43 || R === 45)
                    A = R === 45 ? -1 : 1, this.nextChar();
                  else if (R < 48 || R > 57)
                    break;
                  D = !0;
                } else
                  break;
              return b !== 0 && (_ /= b), D && (_ *= 10 ** (A * S)), l * _;
            }
            getString() {
              let R = 1, D = !1;
              const b = this.strBuf;
              b.length = 0;
              let l = this.nextChar();
              for (; ; ) {
                let _ = !1;
                switch (l | 0) {
                  case -1:
                    (0, t.warn)("Unterminated string"), D = !0;
                    break;
                  case 40:
                    ++R, b.push("(");
                    break;
                  case 41:
                    --R === 0 ? (this.nextChar(), D = !0) : b.push(")");
                    break;
                  case 92:
                    switch (l = this.nextChar(), l) {
                      case -1:
                        (0, t.warn)("Unterminated string"), D = !0;
                        break;
                      case 110:
                        b.push(`
`);
                        break;
                      case 114:
                        b.push("\r");
                        break;
                      case 116:
                        b.push("	");
                        break;
                      case 98:
                        b.push("\b");
                        break;
                      case 102:
                        b.push("\f");
                        break;
                      case 92:
                      case 40:
                      case 41:
                        b.push(String.fromCharCode(l));
                        break;
                      case 48:
                      case 49:
                      case 50:
                      case 51:
                      case 52:
                      case 53:
                      case 54:
                      case 55:
                        let S = l & 15;
                        l = this.nextChar(), _ = !0, l >= 48 && l <= 55 && (S = (S << 3) + (l & 15), l = this.nextChar(), l >= 48 && l <= 55 && (_ = !1, S = (S << 3) + (l & 15))), b.push(String.fromCharCode(S));
                        break;
                      case 13:
                        this.peekChar() === 10 && this.nextChar();
                        break;
                      case 10:
                        break;
                      default:
                        b.push(String.fromCharCode(l));
                        break;
                    }
                    break;
                  default:
                    b.push(String.fromCharCode(l));
                    break;
                }
                if (D)
                  break;
                _ || (l = this.nextChar());
              }
              return b.join("");
            }
            getName() {
              let R, D;
              const b = this.strBuf;
              for (b.length = 0; (R = this.nextChar()) >= 0 && !w[R]; )
                if (R === 35) {
                  if (R = this.nextChar(), w[R]) {
                    (0, t.warn)("Lexer_getName: NUMBER SIGN (#) should be followed by a hexadecimal number."), b.push("#");
                    break;
                  }
                  const l = X(R);
                  if (l !== -1) {
                    D = R, R = this.nextChar();
                    const _ = X(R);
                    if (_ === -1) {
                      if ((0, t.warn)(`Lexer_getName: Illegal digit (${String.fromCharCode(R)}) in hexadecimal number.`), b.push("#", String.fromCharCode(D)), w[R])
                        break;
                      b.push(String.fromCharCode(R));
                      continue;
                    }
                    b.push(String.fromCharCode(l << 4 | _));
                  } else
                    b.push("#", String.fromCharCode(R));
                } else
                  b.push(String.fromCharCode(R));
              return b.length > 127 && (0, t.warn)(`Name token is longer than allowed by the spec: ${b.length}`), i.Name.get(b.join(""));
            }
            _hexStringWarn(R) {
              if (this._hexStringNumWarn++ === 5) {
                (0, t.warn)("getHexString - ignoring additional invalid characters.");
                return;
              }
              this._hexStringNumWarn > 5 || (0, t.warn)(`getHexString - ignoring invalid character: ${R}`);
            }
            getHexString() {
              const R = this.strBuf;
              R.length = 0;
              let D = this.currentChar, b = !0, l, _;
              for (this._hexStringNumWarn = 0; ; )
                if (D < 0) {
                  (0, t.warn)("Unterminated hex string");
                  break;
                } else if (D === 62) {
                  this.nextChar();
                  break;
                } else if (w[D] === 1) {
                  D = this.nextChar();
                  continue;
                } else {
                  if (b) {
                    if (l = X(D), l === -1) {
                      this._hexStringWarn(D), D = this.nextChar();
                      continue;
                    }
                  } else {
                    if (_ = X(D), _ === -1) {
                      this._hexStringWarn(D), D = this.nextChar();
                      continue;
                    }
                    R.push(String.fromCharCode(l << 4 | _));
                  }
                  b = !b, D = this.nextChar();
                }
              return R.join("");
            }
            getObj() {
              let R = !1, D = this.currentChar;
              for (; ; ) {
                if (D < 0)
                  return i.EOF;
                if (R)
                  (D === 10 || D === 13) && (R = !1);
                else if (D === 37)
                  R = !0;
                else if (w[D] !== 1)
                  break;
                D = this.nextChar();
              }
              switch (D | 0) {
                case 48:
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                case 43:
                case 45:
                case 46:
                  return this.getNumber();
                case 40:
                  return this.getString();
                case 47:
                  return this.getName();
                case 91:
                  return this.nextChar(), i.Cmd.get("[");
                case 93:
                  return this.nextChar(), i.Cmd.get("]");
                case 60:
                  return D = this.nextChar(), D === 60 ? (this.nextChar(), i.Cmd.get("<<")) : this.getHexString();
                case 62:
                  return D = this.nextChar(), D === 62 ? (this.nextChar(), i.Cmd.get(">>")) : i.Cmd.get(">");
                case 123:
                  return this.nextChar(), i.Cmd.get("{");
                case 125:
                  return this.nextChar(), i.Cmd.get("}");
                case 41:
                  throw this.nextChar(), new t.FormatError(`Illegal character: ${D}`);
              }
              let b = String.fromCharCode(D);
              if (D < 32 || D > 127) {
                const S = this.peekChar();
                if (S >= 32 && S <= 127)
                  return this.nextChar(), i.Cmd.get(b);
              }
              const l = this.knownCommands;
              let _ = l && l[b] !== void 0;
              for (; (D = this.nextChar()) >= 0 && !w[D]; ) {
                const S = b + String.fromCharCode(D);
                if (_ && l[S] === void 0)
                  break;
                if (b.length === 128)
                  throw new t.FormatError(`Command token too long: ${b.length}`);
                b = S, _ = l && l[b] !== void 0;
              }
              return b === "true" ? !0 : b === "false" ? !1 : b === "null" ? null : (b === "BI" && (this.beginInlineImagePos = this.stream.pos), i.Cmd.get(b));
            }
            peekObj() {
              const R = this.stream.pos, D = this.currentChar, b = this.beginInlineImagePos;
              let l;
              try {
                l = this.getObj();
              } catch (_) {
                if (_ instanceof v.MissingDataException)
                  throw _;
                (0, t.warn)(`peekObj: ${_}`);
              }
              return this.stream.pos = R, this.currentChar = D, this.beginInlineImagePos = b, l;
            }
            skipToNextLine() {
              let R = this.currentChar;
              for (; R >= 0; ) {
                if (R === 13) {
                  R = this.nextChar(), R === 10 && this.nextChar();
                  break;
                } else if (R === 10) {
                  this.nextChar();
                  break;
                }
                R = this.nextChar();
              }
            }
          }
          u.Lexer = M;
          class j {
            static create(R) {
              function D(U, G, K = !1) {
                const W = U.get(G);
                if (Number.isInteger(W) && (K ? W >= 0 : W > 0))
                  return W;
                throw new Error(`The "${G}" parameter in the linearization dictionary is invalid.`);
              }
              function b(U) {
                const G = U.get("H");
                let K;
                if (Array.isArray(G) && ((K = G.length) === 2 || K === 4)) {
                  for (let W = 0; W < K; W++) {
                    const z = G[W];
                    if (!(Number.isInteger(z) && z > 0))
                      throw new Error(`Hint (${W}) in the linearization dictionary is invalid.`);
                  }
                  return G;
                }
                throw new Error("Hint array in the linearization dictionary is invalid.");
              }
              const l = new p({
                lexer: new M(R),
                xref: null
              }), _ = l.getObj(), S = l.getObj(), A = l.getObj(), F = l.getObj();
              let T, O;
              if (Number.isInteger(_) && Number.isInteger(S) && (0, i.isCmd)(A, "obj") && F instanceof i.Dict && typeof (T = F.get("Linearized")) == "number" && T > 0) {
                if ((O = D(F, "L")) !== R.length)
                  throw new Error('The "L" parameter in the linearization dictionary does not equal the stream length.');
              } else
                return null;
              return {
                length: O,
                hints: b(F),
                objectNumberFirst: D(F, "O"),
                endFirst: D(F, "E"),
                numPages: D(F, "N"),
                mainXRefEntriesOffset: D(F, "T"),
                pageFirst: F.has("P") ? D(F, "P", !0) : 0
              };
            }
          }
          u.Linearization = j;
        },
        /* 18 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.Ascii85Stream = void 0;
          var t = P(19), i = P(6);
          class v extends t.DecodeStream {
            constructor(e, y) {
              y && (y *= 0.8), super(y), this.str = e, this.dict = e.dict, this.input = new Uint8Array(5);
            }
            readBlock() {
              const h = this.str;
              let g = h.getByte();
              for (; (0, i.isWhiteSpace)(g); )
                g = h.getByte();
              if (g === -1 || g === 126) {
                this.eof = !0;
                return;
              }
              const d = this.bufferLength;
              let c, n;
              if (g === 122) {
                for (c = this.ensureBuffer(d + 4), n = 0; n < 4; ++n)
                  c[d + n] = 0;
                this.bufferLength += 4;
              } else {
                const o = this.input;
                for (o[0] = g, n = 1; n < 5; ++n) {
                  for (g = h.getByte(); (0, i.isWhiteSpace)(g); )
                    g = h.getByte();
                  if (o[n] = g, g === -1 || g === 126)
                    break;
                }
                if (c = this.ensureBuffer(d + n - 1), this.bufferLength += n - 1, n < 5) {
                  for (; n < 5; ++n)
                    o[n] = 117;
                  this.eof = !0;
                }
                let x = 0;
                for (n = 0; n < 5; ++n)
                  x = x * 85 + (o[n] - 33);
                for (n = 3; n >= 0; --n)
                  c[d + n] = x & 255, x >>= 8;
              }
            }
          }
          u.Ascii85Stream = v;
        },
        /* 19 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.StreamsSequenceStream = u.DecodeStream = void 0;
          var t = P(7), i = P(10);
          const v = new Uint8Array(0);
          class a extends t.BaseStream {
            constructor(r) {
              if (super(), this._rawMinBufferLength = r || 0, this.pos = 0, this.bufferLength = 0, this.eof = !1, this.buffer = v, this.minBufferLength = 512, r)
                for (; this.minBufferLength < r; )
                  this.minBufferLength *= 2;
            }
            get isEmpty() {
              for (; !this.eof && this.bufferLength === 0; )
                this.readBlock();
              return this.bufferLength === 0;
            }
            ensureBuffer(r) {
              const h = this.buffer;
              if (r <= h.byteLength)
                return h;
              let g = this.minBufferLength;
              for (; g < r; )
                g *= 2;
              const d = new Uint8Array(g);
              return d.set(h), this.buffer = d;
            }
            getByte() {
              const r = this.pos;
              for (; this.bufferLength <= r; ) {
                if (this.eof)
                  return -1;
                this.readBlock();
              }
              return this.buffer[this.pos++];
            }
            getBytes(r) {
              const h = this.pos;
              let g;
              if (r) {
                for (this.ensureBuffer(h + r), g = h + r; !this.eof && this.bufferLength < g; )
                  this.readBlock();
                const d = this.bufferLength;
                g > d && (g = d);
              } else {
                for (; !this.eof; )
                  this.readBlock();
                g = this.bufferLength;
              }
              return this.pos = g, this.buffer.subarray(h, g);
            }
            reset() {
              this.pos = 0;
            }
            makeSubStream(r, h, g = null) {
              if (h === void 0)
                for (; !this.eof; )
                  this.readBlock();
              else {
                const d = r + h;
                for (; this.bufferLength <= d && !this.eof; )
                  this.readBlock();
              }
              return new i.Stream(this.buffer, r, h, g);
            }
            getBaseStreams() {
              return this.str ? this.str.getBaseStreams() : null;
            }
          }
          u.DecodeStream = a;
          class e extends a {
            constructor(r, h = null) {
              let g = 0;
              for (const d of r)
                g += d instanceof a ? d._rawMinBufferLength : d.length;
              super(g), this.streams = r, this._onError = h;
            }
            readBlock() {
              const r = this.streams;
              if (r.length === 0) {
                this.eof = !0;
                return;
              }
              const h = r.shift();
              let g;
              try {
                g = h.getBytes();
              } catch (o) {
                if (this._onError) {
                  this._onError(o, h.dict && h.dict.objId);
                  return;
                }
                throw o;
              }
              const d = this.bufferLength, c = d + g.length;
              this.ensureBuffer(c).set(g, d), this.bufferLength = c;
            }
            getBaseStreams() {
              const r = [];
              for (const h of this.streams) {
                const g = h.getBaseStreams();
                g && r.push(...g);
              }
              return r.length > 0 ? r : null;
            }
          }
          u.StreamsSequenceStream = e;
        },
        /* 20 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.AsciiHexStream = void 0;
          var t = P(19);
          class i extends t.DecodeStream {
            constructor(a, e) {
              e && (e *= 0.5), super(e), this.str = a, this.dict = a.dict, this.firstDigit = -1;
            }
            readBlock() {
              const e = this.str.getBytes(8e3);
              if (!e.length) {
                this.eof = !0;
                return;
              }
              const y = e.length + 1 >> 1, r = this.ensureBuffer(this.bufferLength + y);
              let h = this.bufferLength, g = this.firstDigit;
              for (const d of e) {
                let c;
                if (d >= 48 && d <= 57)
                  c = d & 15;
                else if (d >= 65 && d <= 70 || d >= 97 && d <= 102)
                  c = (d & 15) + 9;
                else if (d === 62) {
                  this.eof = !0;
                  break;
                } else
                  continue;
                g < 0 ? g = c : (r[h++] = g << 4 | c, g = -1);
              }
              g >= 0 && this.eof && (r[h++] = g << 4, g = -1), this.firstDigit = g, this.bufferLength = h;
            }
          }
          u.AsciiHexStream = i;
        },
        /* 21 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.CCITTFaxStream = void 0;
          var t = P(22), i = P(19), v = P(5);
          class a extends i.DecodeStream {
            constructor(y, r, h) {
              super(r), this.str = y, this.dict = y.dict, h instanceof v.Dict || (h = v.Dict.empty);
              const g = {
                next() {
                  return y.getByte();
                }
              };
              this.ccittFaxDecoder = new t.CCITTFaxDecoder(g, {
                K: h.get("K"),
                EndOfLine: h.get("EndOfLine"),
                EncodedByteAlign: h.get("EncodedByteAlign"),
                Columns: h.get("Columns"),
                Rows: h.get("Rows"),
                EndOfBlock: h.get("EndOfBlock"),
                BlackIs1: h.get("BlackIs1")
              });
            }
            readBlock() {
              for (; !this.eof; ) {
                const y = this.ccittFaxDecoder.readNextChar();
                if (y === -1) {
                  this.eof = !0;
                  return;
                }
                this.ensureBuffer(this.bufferLength + 1), this.buffer[this.bufferLength++] = y;
              }
            }
          }
          u.CCITTFaxStream = a;
        },
        /* 22 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.CCITTFaxDecoder = void 0;
          var t = P(2);
          const i = -2, v = -1, a = 0, e = 1, y = 2, r = 3, h = 4, g = 5, d = 6, c = 7, n = 8, o = [[-1, -1], [-1, -1], [7, n], [7, c], [6, d], [6, d], [6, g], [6, g], [4, a], [4, a], [4, a], [4, a], [4, a], [4, a], [4, a], [4, a], [3, e], [3, e], [3, e], [3, e], [3, e], [3, e], [3, e], [3, e], [3, e], [3, e], [3, e], [3, e], [3, e], [3, e], [3, e], [3, e], [3, h], [3, h], [3, h], [3, h], [3, h], [3, h], [3, h], [3, h], [3, h], [3, h], [3, h], [3, h], [3, h], [3, h], [3, h], [3, h], [3, r], [3, r], [3, r], [3, r], [3, r], [3, r], [3, r], [3, r], [3, r], [3, r], [3, r], [3, r], [3, r], [3, r], [3, r], [3, r], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y]], x = [[-1, -1], [12, i], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [12, 1984], [12, 2048], [12, 2112], [12, 2176], [12, 2240], [12, 2304], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [12, 2368], [12, 2432], [12, 2496], [12, 2560]], f = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [8, 29], [8, 29], [8, 30], [8, 30], [8, 45], [8, 45], [8, 46], [8, 46], [7, 22], [7, 22], [7, 22], [7, 22], [7, 23], [7, 23], [7, 23], [7, 23], [8, 47], [8, 47], [8, 48], [8, 48], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [7, 20], [7, 20], [7, 20], [7, 20], [8, 33], [8, 33], [8, 34], [8, 34], [8, 35], [8, 35], [8, 36], [8, 36], [8, 37], [8, 37], [8, 38], [8, 38], [7, 19], [7, 19], [7, 19], [7, 19], [8, 31], [8, 31], [8, 32], [8, 32], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [8, 53], [8, 53], [8, 54], [8, 54], [7, 26], [7, 26], [7, 26], [7, 26], [8, 39], [8, 39], [8, 40], [8, 40], [8, 41], [8, 41], [8, 42], [8, 42], [8, 43], [8, 43], [8, 44], [8, 44], [7, 21], [7, 21], [7, 21], [7, 21], [7, 28], [7, 28], [7, 28], [7, 28], [8, 61], [8, 61], [8, 62], [8, 62], [8, 63], [8, 63], [8, 0], [8, 0], [8, 320], [8, 320], [8, 384], [8, 384], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [7, 27], [7, 27], [7, 27], [7, 27], [8, 59], [8, 59], [8, 60], [8, 60], [9, 1472], [9, 1536], [9, 1600], [9, 1728], [7, 18], [7, 18], [7, 18], [7, 18], [7, 24], [7, 24], [7, 24], [7, 24], [8, 49], [8, 49], [8, 50], [8, 50], [8, 51], [8, 51], [8, 52], [8, 52], [7, 25], [7, 25], [7, 25], [7, 25], [8, 55], [8, 55], [8, 56], [8, 56], [8, 57], [8, 57], [8, 58], [8, 58], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [8, 448], [8, 448], [8, 512], [8, 512], [9, 704], [9, 768], [8, 640], [8, 640], [8, 576], [8, 576], [9, 832], [9, 896], [9, 960], [9, 1024], [9, 1088], [9, 1152], [9, 1216], [9, 1280], [9, 1344], [9, 1408], [7, 256], [7, 256], [7, 256], [7, 256], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7]], m = [[-1, -1], [-1, -1], [12, i], [12, i], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [11, 1792], [11, 1792], [12, 1984], [12, 1984], [12, 2048], [12, 2048], [12, 2112], [12, 2112], [12, 2176], [12, 2176], [12, 2240], [12, 2240], [12, 2304], [12, 2304], [11, 1856], [11, 1856], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [11, 1920], [11, 1920], [12, 2368], [12, 2368], [12, 2432], [12, 2432], [12, 2496], [12, 2496], [12, 2560], [12, 2560], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [12, 52], [12, 52], [13, 640], [13, 704], [13, 768], [13, 832], [12, 55], [12, 55], [12, 56], [12, 56], [13, 1280], [13, 1344], [13, 1408], [13, 1472], [12, 59], [12, 59], [12, 60], [12, 60], [13, 1536], [13, 1600], [11, 24], [11, 24], [11, 24], [11, 24], [11, 25], [11, 25], [11, 25], [11, 25], [13, 1664], [13, 1728], [12, 320], [12, 320], [12, 384], [12, 384], [12, 448], [12, 448], [13, 512], [13, 576], [12, 53], [12, 53], [12, 54], [12, 54], [13, 896], [13, 960], [13, 1024], [13, 1088], [13, 1152], [13, 1216], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64]], C = [[8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [11, 23], [11, 23], [12, 50], [12, 51], [12, 44], [12, 45], [12, 46], [12, 47], [12, 57], [12, 58], [12, 61], [12, 256], [10, 16], [10, 16], [10, 16], [10, 16], [10, 17], [10, 17], [10, 17], [10, 17], [12, 48], [12, 49], [12, 62], [12, 63], [12, 30], [12, 31], [12, 32], [12, 33], [12, 40], [12, 41], [11, 22], [11, 22], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [12, 128], [12, 192], [12, 26], [12, 27], [12, 28], [12, 29], [11, 19], [11, 19], [11, 20], [11, 20], [12, 34], [12, 35], [12, 36], [12, 37], [12, 38], [12, 39], [11, 21], [11, 21], [12, 42], [12, 43], [10, 0], [10, 0], [10, 0], [10, 0], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12]], p = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [6, 9], [6, 8], [5, 7], [5, 7], [4, 6], [4, 6], [4, 6], [4, 6], [4, 5], [4, 5], [4, 5], [4, 5], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2]];
          class w {
            constructor(M, j = {}) {
              if (!M || typeof M.next != "function")
                throw new Error('CCITTFaxDecoder - invalid "source" parameter.');
              this.source = M, this.eof = !1, this.encoding = j.K || 0, this.eoline = j.EndOfLine || !1, this.byteAlign = j.EncodedByteAlign || !1, this.columns = j.Columns || 1728, this.rows = j.Rows || 0;
              let B = j.EndOfBlock;
              B == null && (B = !0), this.eoblock = B, this.black = j.BlackIs1 || !1, this.codingLine = new Uint32Array(this.columns + 1), this.refLine = new Uint32Array(this.columns + 2), this.codingLine[0] = this.columns, this.codingPos = 0, this.row = 0, this.nextLine2D = this.encoding < 0, this.inputBits = 0, this.inputBuf = 0, this.outputBits = 0, this.rowsDone = !1;
              let R;
              for (; (R = this._lookBits(12)) === 0; )
                this._eatBits(1);
              R === 1 && this._eatBits(12), this.encoding > 0 && (this.nextLine2D = !this._lookBits(1), this._eatBits(1));
            }
            readNextChar() {
              if (this.eof)
                return -1;
              const M = this.refLine, j = this.codingLine, B = this.columns;
              let R, D, b, l;
              if (this.outputBits === 0) {
                if (this.rowsDone && (this.eof = !0), this.eof)
                  return -1;
                this.err = !1;
                let S, A, F;
                if (this.nextLine2D) {
                  for (l = 0; j[l] < B; ++l)
                    M[l] = j[l];
                  for (M[l++] = B, M[l] = B, j[0] = 0, this.codingPos = 0, R = 0, D = 0; j[this.codingPos] < B; )
                    switch (S = this._getTwoDimCode(), S) {
                      case a:
                        this._addPixels(M[R + 1], D), M[R + 1] < B && (R += 2);
                        break;
                      case e:
                        if (S = A = 0, D) {
                          do
                            S += F = this._getBlackCode();
                          while (F >= 64);
                          do
                            A += F = this._getWhiteCode();
                          while (F >= 64);
                        } else {
                          do
                            S += F = this._getWhiteCode();
                          while (F >= 64);
                          do
                            A += F = this._getBlackCode();
                          while (F >= 64);
                        }
                        for (this._addPixels(j[this.codingPos] + S, D), j[this.codingPos] < B && this._addPixels(j[this.codingPos] + A, D ^ 1); M[R] <= j[this.codingPos] && M[R] < B; )
                          R += 2;
                        break;
                      case c:
                        if (this._addPixels(M[R] + 3, D), D ^= 1, j[this.codingPos] < B)
                          for (++R; M[R] <= j[this.codingPos] && M[R] < B; )
                            R += 2;
                        break;
                      case g:
                        if (this._addPixels(M[R] + 2, D), D ^= 1, j[this.codingPos] < B)
                          for (++R; M[R] <= j[this.codingPos] && M[R] < B; )
                            R += 2;
                        break;
                      case r:
                        if (this._addPixels(M[R] + 1, D), D ^= 1, j[this.codingPos] < B)
                          for (++R; M[R] <= j[this.codingPos] && M[R] < B; )
                            R += 2;
                        break;
                      case y:
                        if (this._addPixels(M[R], D), D ^= 1, j[this.codingPos] < B)
                          for (++R; M[R] <= j[this.codingPos] && M[R] < B; )
                            R += 2;
                        break;
                      case n:
                        if (this._addPixelsNeg(M[R] - 3, D), D ^= 1, j[this.codingPos] < B)
                          for (R > 0 ? --R : ++R; M[R] <= j[this.codingPos] && M[R] < B; )
                            R += 2;
                        break;
                      case d:
                        if (this._addPixelsNeg(M[R] - 2, D), D ^= 1, j[this.codingPos] < B)
                          for (R > 0 ? --R : ++R; M[R] <= j[this.codingPos] && M[R] < B; )
                            R += 2;
                        break;
                      case h:
                        if (this._addPixelsNeg(M[R] - 1, D), D ^= 1, j[this.codingPos] < B)
                          for (R > 0 ? --R : ++R; M[R] <= j[this.codingPos] && M[R] < B; )
                            R += 2;
                        break;
                      case v:
                        this._addPixels(B, 0), this.eof = !0;
                        break;
                      default:
                        (0, t.info)("bad 2d code"), this._addPixels(B, 0), this.err = !0;
                    }
                } else
                  for (j[0] = 0, this.codingPos = 0, D = 0; j[this.codingPos] < B; ) {
                    if (S = 0, D)
                      do
                        S += F = this._getBlackCode();
                      while (F >= 64);
                    else
                      do
                        S += F = this._getWhiteCode();
                      while (F >= 64);
                    this._addPixels(j[this.codingPos] + S, D), D ^= 1;
                  }
                let T = !1;
                if (this.byteAlign && (this.inputBits &= -8), !this.eoblock && this.row === this.rows - 1)
                  this.rowsDone = !0;
                else {
                  if (S = this._lookBits(12), this.eoline)
                    for (; S !== v && S !== 1; )
                      this._eatBits(1), S = this._lookBits(12);
                  else
                    for (; S === 0; )
                      this._eatBits(1), S = this._lookBits(12);
                  S === 1 ? (this._eatBits(12), T = !0) : S === v && (this.eof = !0);
                }
                if (!this.eof && this.encoding > 0 && !this.rowsDone && (this.nextLine2D = !this._lookBits(1), this._eatBits(1)), this.eoblock && T && this.byteAlign) {
                  if (S = this._lookBits(12), S === 1) {
                    if (this._eatBits(12), this.encoding > 0 && (this._lookBits(1), this._eatBits(1)), this.encoding >= 0)
                      for (l = 0; l < 4; ++l)
                        S = this._lookBits(12), S !== 1 && (0, t.info)("bad rtc code: " + S), this._eatBits(12), this.encoding > 0 && (this._lookBits(1), this._eatBits(1));
                    this.eof = !0;
                  }
                } else if (this.err && this.eoline) {
                  for (; ; ) {
                    if (S = this._lookBits(13), S === v)
                      return this.eof = !0, -1;
                    if (S >> 1 === 1)
                      break;
                    this._eatBits(1);
                  }
                  this._eatBits(12), this.encoding > 0 && (this._eatBits(1), this.nextLine2D = !(S & 1));
                }
                j[0] > 0 ? this.outputBits = j[this.codingPos = 0] : this.outputBits = j[this.codingPos = 1], this.row++;
              }
              let _;
              if (this.outputBits >= 8)
                _ = this.codingPos & 1 ? 0 : 255, this.outputBits -= 8, this.outputBits === 0 && j[this.codingPos] < B && (this.codingPos++, this.outputBits = j[this.codingPos] - j[this.codingPos - 1]);
              else {
                b = 8, _ = 0;
                do {
                  if (typeof this.outputBits != "number")
                    throw new t.FormatError('Invalid /CCITTFaxDecode data, "outputBits" must be a number.');
                  this.outputBits > b ? (_ <<= b, this.codingPos & 1 || (_ |= 255 >> 8 - b), this.outputBits -= b, b = 0) : (_ <<= this.outputBits, this.codingPos & 1 || (_ |= 255 >> 8 - this.outputBits), b -= this.outputBits, this.outputBits = 0, j[this.codingPos] < B ? (this.codingPos++, this.outputBits = j[this.codingPos] - j[this.codingPos - 1]) : b > 0 && (_ <<= b, b = 0));
                } while (b);
              }
              return this.black && (_ ^= 255), _;
            }
            _addPixels(M, j) {
              const B = this.codingLine;
              let R = this.codingPos;
              M > B[R] && (M > this.columns && ((0, t.info)("row is wrong length"), this.err = !0, M = this.columns), R & 1 ^ j && ++R, B[R] = M), this.codingPos = R;
            }
            _addPixelsNeg(M, j) {
              const B = this.codingLine;
              let R = this.codingPos;
              if (M > B[R])
                M > this.columns && ((0, t.info)("row is wrong length"), this.err = !0, M = this.columns), R & 1 ^ j && ++R, B[R] = M;
              else if (M < B[R]) {
                for (M < 0 && ((0, t.info)("invalid code"), this.err = !0, M = 0); R > 0 && M < B[R - 1]; )
                  --R;
                B[R] = M;
              }
              this.codingPos = R;
            }
            _findTableCode(M, j, B, R) {
              const D = R || 0;
              for (let b = M; b <= j; ++b) {
                let l = this._lookBits(b);
                if (l === v)
                  return [!0, 1, !1];
                if (b < j && (l <<= j - b), !D || l >= D) {
                  const _ = B[l - D];
                  if (_[0] === b)
                    return this._eatBits(b), [!0, _[1], !0];
                }
              }
              return [!1, 0, !1];
            }
            _getTwoDimCode() {
              let M = 0, j;
              if (this.eoblock) {
                if (M = this._lookBits(7), j = o[M], j && j[0] > 0)
                  return this._eatBits(j[0]), j[1];
              } else {
                const B = this._findTableCode(1, 7, o);
                if (B[0] && B[2])
                  return B[1];
              }
              return (0, t.info)("Bad two dim code"), v;
            }
            _getWhiteCode() {
              let M = 0, j;
              if (this.eoblock) {
                if (M = this._lookBits(12), M === v)
                  return 1;
                if (M >> 5 ? j = f[M >> 3] : j = x[M], j[0] > 0)
                  return this._eatBits(j[0]), j[1];
              } else {
                let B = this._findTableCode(1, 9, f);
                if (B[0] || (B = this._findTableCode(11, 12, x), B[0]))
                  return B[1];
              }
              return (0, t.info)("bad white code"), this._eatBits(1), 1;
            }
            _getBlackCode() {
              let M, j;
              if (this.eoblock) {
                if (M = this._lookBits(13), M === v)
                  return 1;
                if (M >> 7 ? !(M >> 9) && M >> 7 ? j = C[(M >> 1) - 64] : j = p[M >> 7] : j = m[M], j[0] > 0)
                  return this._eatBits(j[0]), j[1];
              } else {
                let B = this._findTableCode(2, 6, p);
                if (B[0] || (B = this._findTableCode(7, 12, C, 64), B[0]) || (B = this._findTableCode(10, 13, m), B[0]))
                  return B[1];
              }
              return (0, t.info)("bad black code"), this._eatBits(1), 1;
            }
            _lookBits(M) {
              let j;
              for (; this.inputBits < M; ) {
                if ((j = this.source.next()) === -1)
                  return this.inputBits === 0 ? v : this.inputBuf << M - this.inputBits & 65535 >> 16 - M;
                this.inputBuf = this.inputBuf << 8 | j, this.inputBits += 8;
              }
              return this.inputBuf >> this.inputBits - M & 65535 >> 16 - M;
            }
            _eatBits(M) {
              (this.inputBits -= M) < 0 && (this.inputBits = 0);
            }
          }
          u.CCITTFaxDecoder = w;
        },
        /* 23 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.FlateStream = void 0;
          var t = P(19), i = P(2);
          const v = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), a = new Int32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]), e = new Int32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353, 876545]), y = [new Int32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9], r = [new Int32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5];
          class h extends t.DecodeStream {
            constructor(d, c) {
              super(c), this.str = d, this.dict = d.dict;
              const n = d.getByte(), o = d.getByte();
              if (n === -1 || o === -1)
                throw new i.FormatError(`Invalid header in flate stream: ${n}, ${o}`);
              if ((n & 15) !== 8)
                throw new i.FormatError(`Unknown compression method in flate stream: ${n}, ${o}`);
              if (((n << 8) + o) % 31 !== 0)
                throw new i.FormatError(`Bad FCHECK in flate stream: ${n}, ${o}`);
              if (o & 32)
                throw new i.FormatError(`FDICT bit set in flate stream: ${n}, ${o}`);
              this.codeSize = 0, this.codeBuf = 0;
            }
            getBits(d) {
              const c = this.str;
              let n = this.codeSize, o = this.codeBuf, x;
              for (; n < d; ) {
                if ((x = c.getByte()) === -1)
                  throw new i.FormatError("Bad encoding in flate stream");
                o |= x << n, n += 8;
              }
              return x = o & (1 << d) - 1, this.codeBuf = o >> d, this.codeSize = n -= d, x;
            }
            getCode(d) {
              const c = this.str, n = d[0], o = d[1];
              let x = this.codeSize, f = this.codeBuf, m;
              for (; x < o && (m = c.getByte()) !== -1; )
                f |= m << x, x += 8;
              const C = n[f & (1 << o) - 1], p = C >> 16, w = C & 65535;
              if (p < 1 || x < p)
                throw new i.FormatError("Bad encoding in flate stream");
              return this.codeBuf = f >> p, this.codeSize = x - p, w;
            }
            generateHuffmanTable(d) {
              const c = d.length;
              let n = 0, o;
              for (o = 0; o < c; ++o)
                d[o] > n && (n = d[o]);
              const x = 1 << n, f = new Int32Array(x);
              for (let m = 1, C = 0, p = 2; m <= n; ++m, C <<= 1, p <<= 1)
                for (let w = 0; w < c; ++w)
                  if (d[w] === m) {
                    let X = 0, M = C;
                    for (o = 0; o < m; ++o)
                      X = X << 1 | M & 1, M >>= 1;
                    for (o = X; o < x; o += p)
                      f[o] = m << 16 | w;
                    ++C;
                  }
              return [f, n];
            }
            readBlock() {
              let d, c;
              const n = this.str;
              let o = this.getBits(3);
              if (o & 1 && (this.eof = !0), o >>= 1, o === 0) {
                let p;
                if ((p = n.getByte()) === -1)
                  throw new i.FormatError("Bad block header in flate stream");
                let w = p;
                if ((p = n.getByte()) === -1)
                  throw new i.FormatError("Bad block header in flate stream");
                if (w |= p << 8, (p = n.getByte()) === -1)
                  throw new i.FormatError("Bad block header in flate stream");
                let X = p;
                if ((p = n.getByte()) === -1)
                  throw new i.FormatError("Bad block header in flate stream");
                if (X |= p << 8, X !== (~w & 65535) && (w !== 0 || X !== 0))
                  throw new i.FormatError("Bad uncompressed block length in flate stream");
                this.codeBuf = 0, this.codeSize = 0;
                const M = this.bufferLength, j = M + w;
                if (d = this.ensureBuffer(j), this.bufferLength = j, w === 0)
                  n.peekByte() === -1 && (this.eof = !0);
                else {
                  const B = n.getBytes(w);
                  d.set(B, M), B.length < w && (this.eof = !0);
                }
                return;
              }
              let x, f;
              if (o === 1)
                x = y, f = r;
              else if (o === 2) {
                const p = this.getBits(5) + 257, w = this.getBits(5) + 1, X = this.getBits(4) + 4, M = new Uint8Array(v.length);
                let j;
                for (j = 0; j < X; ++j)
                  M[v[j]] = this.getBits(3);
                const B = this.generateHuffmanTable(M);
                c = 0, j = 0;
                const R = p + w, D = new Uint8Array(R);
                let b, l, _;
                for (; j < R; ) {
                  const S = this.getCode(B);
                  if (S === 16)
                    b = 2, l = 3, _ = c;
                  else if (S === 17)
                    b = 3, l = 3, _ = c = 0;
                  else if (S === 18)
                    b = 7, l = 11, _ = c = 0;
                  else {
                    D[j++] = c = S;
                    continue;
                  }
                  let A = this.getBits(b) + l;
                  for (; A-- > 0; )
                    D[j++] = _;
                }
                x = this.generateHuffmanTable(D.subarray(0, p)), f = this.generateHuffmanTable(D.subarray(p, R));
              } else
                throw new i.FormatError("Unknown block type in flate stream");
              d = this.buffer;
              let m = d ? d.length : 0, C = this.bufferLength;
              for (; ; ) {
                let p = this.getCode(x);
                if (p < 256) {
                  C + 1 >= m && (d = this.ensureBuffer(C + 1), m = d.length), d[C++] = p;
                  continue;
                }
                if (p === 256) {
                  this.bufferLength = C;
                  return;
                }
                p -= 257, p = a[p];
                let w = p >> 16;
                w > 0 && (w = this.getBits(w)), c = (p & 65535) + w, p = this.getCode(f), p = e[p], w = p >> 16, w > 0 && (w = this.getBits(w));
                const X = (p & 65535) + w;
                C + c >= m && (d = this.ensureBuffer(C + c), m = d.length);
                for (let M = 0; M < c; ++M, ++C)
                  d[C] = d[C - X];
              }
            }
          }
          u.FlateStream = h;
        },
        /* 24 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.Jbig2Stream = void 0;
          var t = P(7), i = P(19), v = P(5), a = P(25), e = P(2);
          class y extends i.DecodeStream {
            constructor(h, g, d) {
              super(g), this.stream = h, this.dict = h.dict, this.maybeLength = g, this.params = d;
            }
            get bytes() {
              return (0, e.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
            }
            ensureBuffer(h) {
            }
            readBlock() {
              if (this.eof)
                return;
              const h = new a.Jbig2Image(), g = [];
              if (this.params instanceof v.Dict) {
                const n = this.params.get("JBIG2Globals");
                if (n instanceof t.BaseStream) {
                  const o = n.getBytes();
                  g.push({
                    data: o,
                    start: 0,
                    end: o.length
                  });
                }
              }
              g.push({
                data: this.bytes,
                start: 0,
                end: this.bytes.length
              });
              const d = h.parseChunks(g), c = d.length;
              for (let n = 0; n < c; n++)
                d[n] ^= 255;
              this.buffer = d, this.bufferLength = c, this.eof = !0;
            }
          }
          u.Jbig2Stream = y;
        },
        /* 25 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.Jbig2Image = void 0;
          var t = P(2), i = P(6), v = P(26), a = P(22);
          class e extends t.BaseException {
            constructor(q) {
              super(`JBIG2 error: ${q}`, "Jbig2Error");
            }
          }
          class y {
            getContexts(q) {
              return q in this ? this[q] : this[q] = new Int8Array(65536);
            }
          }
          class r {
            constructor(q, N, Z) {
              this.data = q, this.start = N, this.end = Z;
            }
            get decoder() {
              const q = new v.ArithmeticDecoder(this.data, this.start, this.end);
              return (0, t.shadow)(this, "decoder", q);
            }
            get contextCache() {
              const q = new y();
              return (0, t.shadow)(this, "contextCache", q);
            }
          }
          function h(ie, q, N) {
            const Z = ie.getContexts(q);
            let E = 1;
            function te($) {
              let k = 0;
              for (let H = 0; H < $; H++) {
                const ne = N.readBit(Z, E);
                E = E < 256 ? E << 1 | ne : (E << 1 | ne) & 511 | 256, k = k << 1 | ne;
              }
              return k >>> 0;
            }
            const re = te(1), ee = te(1) ? te(1) ? te(1) ? te(1) ? te(1) ? te(32) + 4436 : te(12) + 340 : te(8) + 84 : te(6) + 20 : te(4) + 4 : te(2);
            return re === 0 ? ee : ee > 0 ? -ee : null;
          }
          function g(ie, q, N) {
            const Z = ie.getContexts("IAID");
            let E = 1;
            for (let te = 0; te < N; te++) {
              const re = q.readBit(Z, E);
              E = E << 1 | re;
            }
            return N < 31 ? E & (1 << N) - 1 : E & 2147483647;
          }
          const d = ["SymbolDictionary", null, null, null, "IntermediateTextRegion", null, "ImmediateTextRegion", "ImmediateLosslessTextRegion", null, null, null, null, null, null, null, null, "PatternDictionary", null, null, null, "IntermediateHalftoneRegion", null, "ImmediateHalftoneRegion", "ImmediateLosslessHalftoneRegion", null, null, null, null, null, null, null, null, null, null, null, null, "IntermediateGenericRegion", null, "ImmediateGenericRegion", "ImmediateLosslessGenericRegion", "IntermediateGenericRefinementRegion", null, "ImmediateGenericRefinementRegion", "ImmediateLosslessGenericRefinementRegion", null, null, null, null, "PageInformation", "EndOfPage", "EndOfStripe", "EndOfFile", "Profiles", "Tables", null, null, null, null, null, null, null, null, "Extension"], c = [[{
            x: -1,
            y: -2
          }, {
            x: 0,
            y: -2
          }, {
            x: 1,
            y: -2
          }, {
            x: -2,
            y: -1
          }, {
            x: -1,
            y: -1
          }, {
            x: 0,
            y: -1
          }, {
            x: 1,
            y: -1
          }, {
            x: 2,
            y: -1
          }, {
            x: -4,
            y: 0
          }, {
            x: -3,
            y: 0
          }, {
            x: -2,
            y: 0
          }, {
            x: -1,
            y: 0
          }], [{
            x: -1,
            y: -2
          }, {
            x: 0,
            y: -2
          }, {
            x: 1,
            y: -2
          }, {
            x: 2,
            y: -2
          }, {
            x: -2,
            y: -1
          }, {
            x: -1,
            y: -1
          }, {
            x: 0,
            y: -1
          }, {
            x: 1,
            y: -1
          }, {
            x: 2,
            y: -1
          }, {
            x: -3,
            y: 0
          }, {
            x: -2,
            y: 0
          }, {
            x: -1,
            y: 0
          }], [{
            x: -1,
            y: -2
          }, {
            x: 0,
            y: -2
          }, {
            x: 1,
            y: -2
          }, {
            x: -2,
            y: -1
          }, {
            x: -1,
            y: -1
          }, {
            x: 0,
            y: -1
          }, {
            x: 1,
            y: -1
          }, {
            x: -2,
            y: 0
          }, {
            x: -1,
            y: 0
          }], [{
            x: -3,
            y: -1
          }, {
            x: -2,
            y: -1
          }, {
            x: -1,
            y: -1
          }, {
            x: 0,
            y: -1
          }, {
            x: 1,
            y: -1
          }, {
            x: -4,
            y: 0
          }, {
            x: -3,
            y: 0
          }, {
            x: -2,
            y: 0
          }, {
            x: -1,
            y: 0
          }]], n = [{
            coding: [{
              x: 0,
              y: -1
            }, {
              x: 1,
              y: -1
            }, {
              x: -1,
              y: 0
            }],
            reference: [{
              x: 0,
              y: -1
            }, {
              x: 1,
              y: -1
            }, {
              x: -1,
              y: 0
            }, {
              x: 0,
              y: 0
            }, {
              x: 1,
              y: 0
            }, {
              x: -1,
              y: 1
            }, {
              x: 0,
              y: 1
            }, {
              x: 1,
              y: 1
            }]
          }, {
            coding: [{
              x: -1,
              y: -1
            }, {
              x: 0,
              y: -1
            }, {
              x: 1,
              y: -1
            }, {
              x: -1,
              y: 0
            }],
            reference: [{
              x: 0,
              y: -1
            }, {
              x: -1,
              y: 0
            }, {
              x: 0,
              y: 0
            }, {
              x: 1,
              y: 0
            }, {
              x: 0,
              y: 1
            }, {
              x: 1,
              y: 1
            }]
          }], o = [39717, 1941, 229, 405], x = [32, 8];
          function f(ie, q, N) {
            const Z = N.decoder, E = N.contextCache.getContexts("GB"), te = [];
            let re, ee, $, k, H, ne, ae;
            const he = 31735;
            for (ee = 0; ee < q; ee++)
              for (H = te[ee] = new Uint8Array(ie), ne = ee < 1 ? H : te[ee - 1], ae = ee < 2 ? H : te[ee - 2], re = ae[0] << 13 | ae[1] << 12 | ae[2] << 11 | ne[0] << 7 | ne[1] << 6 | ne[2] << 5 | ne[3] << 4, $ = 0; $ < ie; $++)
                H[$] = k = Z.readBit(E, re), re = (re & he) << 1 | ($ + 3 < ie ? ae[$ + 3] << 11 : 0) | ($ + 4 < ie ? ne[$ + 4] << 4 : 0) | k;
            return te;
          }
          function m(ie, q, N, Z, E, te, re, ee) {
            if (ie) {
              const $e = new K(ee.data, ee.start, ee.end);
              return Y($e, q, N, !1);
            }
            if (Z === 0 && !te && !E && re.length === 4 && re[0].x === 3 && re[0].y === -1 && re[1].x === -3 && re[1].y === -1 && re[2].x === 2 && re[2].y === -2 && re[3].x === -2 && re[3].y === -2)
              return f(q, N, ee);
            const $ = !!te, k = c[Z].concat(re);
            k.sort(function($e, St) {
              return $e.y - St.y || $e.x - St.x;
            });
            const H = k.length, ne = new Int8Array(H), ae = new Int8Array(H), he = [];
            let ue = 0, fe = 0, me = 0, Fe = 0, we, Ae;
            for (Ae = 0; Ae < H; Ae++)
              ne[Ae] = k[Ae].x, ae[Ae] = k[Ae].y, fe = Math.min(fe, k[Ae].x), me = Math.max(me, k[Ae].x), Fe = Math.min(Fe, k[Ae].y), Ae < H - 1 && k[Ae].y === k[Ae + 1].y && k[Ae].x === k[Ae + 1].x - 1 ? ue |= 1 << H - 1 - Ae : he.push(Ae);
            const De = he.length, xe = new Int8Array(De), Te = new Int8Array(De), ve = new Uint16Array(De);
            for (we = 0; we < De; we++)
              Ae = he[we], xe[we] = k[Ae].x, Te[we] = k[Ae].y, ve[we] = 1 << H - 1 - Ae;
            const Se = -fe, be = -Fe, Le = q - me, ze = o[Z];
            let nt = new Uint8Array(q);
            const Ue = [], Oe = ee.decoder, _e = ee.contextCache.getContexts("GB");
            let at = 0, Je, ot, mt, Ze = 0, pt, Ft;
            for (let $e = 0; $e < N; $e++) {
              if (E) {
                const St = Oe.readBit(_e, ze);
                if (at ^= St, at) {
                  Ue.push(nt);
                  continue;
                }
              }
              for (nt = new Uint8Array(nt), Ue.push(nt), Je = 0; Je < q; Je++) {
                if ($ && te[$e][Je]) {
                  nt[Je] = 0;
                  continue;
                }
                if (Je >= Se && Je < Le && $e >= be)
                  for (Ze = Ze << 1 & ue, Ae = 0; Ae < De; Ae++)
                    ot = $e + Te[Ae], mt = Je + xe[Ae], pt = Ue[ot][mt], pt && (pt = ve[Ae], Ze |= pt);
                else
                  for (Ze = 0, Ft = H - 1, Ae = 0; Ae < H; Ae++, Ft--)
                    mt = Je + ne[Ae], mt >= 0 && mt < q && (ot = $e + ae[Ae], ot >= 0 && (pt = Ue[ot][mt], pt && (Ze |= pt << Ft)));
                const St = Oe.readBit(_e, Ze);
                nt[Je] = St;
              }
            }
            return Ue;
          }
          function C(ie, q, N, Z, E, te, re, ee, $) {
            let k = n[N].coding;
            N === 0 && (k = k.concat([ee[0]]));
            const H = k.length, ne = new Int32Array(H), ae = new Int32Array(H);
            let he;
            for (he = 0; he < H; he++)
              ne[he] = k[he].x, ae[he] = k[he].y;
            let ue = n[N].reference;
            N === 0 && (ue = ue.concat([ee[1]]));
            const fe = ue.length, me = new Int32Array(fe), Fe = new Int32Array(fe);
            for (he = 0; he < fe; he++)
              me[he] = ue[he].x, Fe[he] = ue[he].y;
            const we = Z[0].length, Ae = Z.length, De = x[N], xe = [], Te = $.decoder, ve = $.contextCache.getContexts("GR");
            let Se = 0;
            for (let be = 0; be < q; be++) {
              if (re) {
                const ze = Te.readBit(ve, De);
                if (Se ^= ze, Se)
                  throw new e("prediction is not supported");
              }
              const Le = new Uint8Array(ie);
              xe.push(Le);
              for (let ze = 0; ze < ie; ze++) {
                let nt, Ue, Oe = 0;
                for (he = 0; he < H; he++)
                  nt = be + ae[he], Ue = ze + ne[he], nt < 0 || Ue < 0 || Ue >= ie ? Oe <<= 1 : Oe = Oe << 1 | xe[nt][Ue];
                for (he = 0; he < fe; he++)
                  nt = be + Fe[he] - te, Ue = ze + me[he] - E, nt < 0 || nt >= Ae || Ue < 0 || Ue >= we ? Oe <<= 1 : Oe = Oe << 1 | Z[nt][Ue];
                const _e = Te.readBit(ve, Oe);
                Le[ze] = _e;
              }
            }
            return xe;
          }
          function p(ie, q, N, Z, E, te, re, ee, $, k, H, ne) {
            if (ie && q)
              throw new e("symbol refinement with Huffman is not supported");
            const ae = [];
            let he = 0, ue = (0, i.log2)(N.length + Z);
            const fe = H.decoder, me = H.contextCache;
            let Fe, we;
            for (ie && (Fe = G(1), we = [], ue = Math.max(ue, 1)); ae.length < Z; ) {
              const be = ie ? te.tableDeltaHeight.decode(ne) : h(me, "IADH", fe);
              he += be;
              let Le = 0, ze = 0;
              const nt = ie ? we.length : 0;
              for (; ; ) {
                const Ue = ie ? te.tableDeltaWidth.decode(ne) : h(me, "IADW", fe);
                if (Ue === null)
                  break;
                Le += Ue, ze += Le;
                let Oe;
                if (q) {
                  const _e = h(me, "IAAI", fe);
                  if (_e > 1)
                    Oe = w(ie, q, Le, he, 0, _e, 1, N.concat(ae), ue, 0, 0, 1, 0, te, $, k, H, 0, ne);
                  else {
                    const at = g(me, fe, ue), Je = h(me, "IARDX", fe), ot = h(me, "IARDY", fe), mt = at < N.length ? N[at] : ae[at - N.length];
                    Oe = C(Le, he, $, mt, Je, ot, !1, k, H);
                  }
                  ae.push(Oe);
                } else
                  ie ? we.push(Le) : (Oe = m(!1, Le, he, re, !1, null, ee, H), ae.push(Oe));
              }
              if (ie && !q) {
                const Ue = te.tableBitmapSize.decode(ne);
                ne.byteAlign();
                let Oe;
                if (Ue === 0)
                  Oe = L(ne, ze, he);
                else {
                  const at = ne.end, Je = ne.position + Ue;
                  ne.end = Je, Oe = Y(ne, ze, he, !1), ne.end = at, ne.position = Je;
                }
                const _e = we.length;
                if (nt === _e - 1)
                  ae.push(Oe);
                else {
                  let at, Je, ot = 0, mt, Ze, pt;
                  for (at = nt; at < _e; at++) {
                    for (Ze = we[at], mt = ot + Ze, pt = [], Je = 0; Je < he; Je++)
                      pt.push(Oe[Je].subarray(ot, mt));
                    ae.push(pt), ot = mt;
                  }
                }
              }
            }
            const Ae = [], De = [];
            let xe = !1, Te, ve;
            const Se = N.length + Z;
            for (; De.length < Se; ) {
              let be = ie ? Fe.decode(ne) : h(me, "IAEX", fe);
              for (; be--; )
                De.push(xe);
              xe = !xe;
            }
            for (Te = 0, ve = N.length; Te < ve; Te++)
              De[Te] && Ae.push(N[Te]);
            for (let be = 0; be < Z; Te++, be++)
              De[Te] && Ae.push(ae[be]);
            return Ae;
          }
          function w(ie, q, N, Z, E, te, re, ee, $, k, H, ne, ae, he, ue, fe, me, Fe, we) {
            if (ie && q)
              throw new e("refinement with Huffman is not supported");
            const Ae = [];
            let De, xe;
            for (De = 0; De < Z; De++) {
              if (xe = new Uint8Array(N), E)
                for (let Le = 0; Le < N; Le++)
                  xe[Le] = E;
              Ae.push(xe);
            }
            const Te = me.decoder, ve = me.contextCache;
            let Se = ie ? -he.tableDeltaT.decode(we) : -h(ve, "IADT", Te), be = 0;
            for (De = 0; De < te; ) {
              const Le = ie ? he.tableDeltaT.decode(we) : h(ve, "IADT", Te);
              Se += Le;
              const ze = ie ? he.tableFirstS.decode(we) : h(ve, "IAFS", Te);
              be += ze;
              let nt = be;
              do {
                let Ue = 0;
                re > 1 && (Ue = ie ? we.readBits(Fe) : h(ve, "IAIT", Te));
                const Oe = re * Se + Ue, _e = ie ? he.symbolIDTable.decode(we) : g(ve, Te, $), at = q && (ie ? we.readBit() : h(ve, "IARI", Te));
                let Je = ee[_e], ot = Je[0].length, mt = Je.length;
                if (at) {
                  const Ie = h(ve, "IARDW", Te), Ve = h(ve, "IARDH", Te), st = h(ve, "IARDX", Te), ct = h(ve, "IARDY", Te);
                  ot += Ie, mt += Ve, Je = C(ot, mt, ue, Je, (Ie >> 1) + st, (Ve >> 1) + ct, !1, fe, me);
                }
                const Ze = Oe - (ne & 1 ? 0 : mt - 1), pt = nt - (ne & 2 ? ot - 1 : 0);
                let Ft, $e, St;
                if (k) {
                  for (Ft = 0; Ft < mt; Ft++) {
                    if (xe = Ae[pt + Ft], !xe)
                      continue;
                    St = Je[Ft];
                    const Ie = Math.min(N - Ze, ot);
                    switch (ae) {
                      case 0:
                        for ($e = 0; $e < Ie; $e++)
                          xe[Ze + $e] |= St[$e];
                        break;
                      case 2:
                        for ($e = 0; $e < Ie; $e++)
                          xe[Ze + $e] ^= St[$e];
                        break;
                      default:
                        throw new e(`operator ${ae} is not supported`);
                    }
                  }
                  nt += mt - 1;
                } else {
                  for ($e = 0; $e < mt; $e++)
                    if (xe = Ae[Ze + $e], !!xe)
                      switch (St = Je[$e], ae) {
                        case 0:
                          for (Ft = 0; Ft < ot; Ft++)
                            xe[pt + Ft] |= St[Ft];
                          break;
                        case 2:
                          for (Ft = 0; Ft < ot; Ft++)
                            xe[pt + Ft] ^= St[Ft];
                          break;
                        default:
                          throw new e(`operator ${ae} is not supported`);
                      }
                  nt += ot - 1;
                }
                De++;
                const xt = ie ? he.tableDeltaS.decode(we) : h(ve, "IADS", Te);
                if (xt === null)
                  break;
                nt += xt + H;
              } while (!0);
            }
            return Ae;
          }
          function X(ie, q, N, Z, E, te) {
            const re = [];
            ie || (re.push({
              x: -q,
              y: 0
            }), E === 0 && re.push({
              x: -3,
              y: -1
            }, {
              x: 2,
              y: -2
            }, {
              x: -2,
              y: -2
            }));
            const ee = (Z + 1) * q, $ = m(ie, ee, N, E, !1, null, re, te), k = [];
            for (let H = 0; H <= Z; H++) {
              const ne = [], ae = q * H, he = ae + q;
              for (let ue = 0; ue < N; ue++)
                ne.push($[ue].subarray(ae, he));
              k.push(ne);
            }
            return k;
          }
          function M(ie, q, N, Z, E, te, re, ee, $, k, H, ne, ae, he, ue) {
            if (re)
              throw new e("skip is not supported");
            if (ee !== 0)
              throw new e(`operator "${ee}" is not supported in halftone region`);
            const me = [];
            let Fe, we, Ae;
            for (Fe = 0; Fe < E; Fe++) {
              if (Ae = new Uint8Array(Z), te)
                for (we = 0; we < Z; we++)
                  Ae[we] = te;
              me.push(Ae);
            }
            const De = q.length, xe = q[0], Te = xe[0].length, ve = xe.length, Se = (0, i.log2)(De), be = [];
            ie || (be.push({
              x: N <= 1 ? 3 : 2,
              y: -1
            }), N === 0 && be.push({
              x: -3,
              y: -1
            }, {
              x: 2,
              y: -2
            }, {
              x: -2,
              y: -2
            }));
            const Le = [];
            let ze, nt;
            for (ie && (ze = new K(ue.data, ue.start, ue.end)), Fe = Se - 1; Fe >= 0; Fe--)
              ie ? nt = Y(ze, $, k, !0) : nt = m(!1, $, k, N, !1, null, be, ue), Le[Fe] = nt;
            let Ue, Oe, _e, at, Je, ot, mt, Ze, pt;
            for (Ue = 0; Ue < k; Ue++)
              for (Oe = 0; Oe < $; Oe++) {
                for (_e = 0, at = 0, we = Se - 1; we >= 0; we--)
                  _e ^= Le[we][Ue][Oe], at |= _e << we;
                if (Je = q[at], ot = H + Ue * he + Oe * ae >> 8, mt = ne + Ue * ae - Oe * he >> 8, ot >= 0 && ot + Te <= Z && mt >= 0 && mt + ve <= E)
                  for (Fe = 0; Fe < ve; Fe++)
                    for (pt = me[mt + Fe], Ze = Je[Fe], we = 0; we < Te; we++)
                      pt[ot + we] |= Ze[we];
                else {
                  let Ft, $e;
                  for (Fe = 0; Fe < ve; Fe++)
                    if ($e = mt + Fe, !($e < 0 || $e >= E))
                      for (pt = me[$e], Ze = Je[Fe], we = 0; we < Te; we++)
                        Ft = ot + we, Ft >= 0 && Ft < Z && (pt[Ft] |= Ze[we]);
                }
              }
            return me;
          }
          function j(ie, q) {
            const N = {};
            N.number = (0, i.readUint32)(ie, q);
            const Z = ie[q + 4], E = Z & 63;
            if (!d[E])
              throw new e("invalid segment type: " + E);
            N.type = E, N.typeName = d[E], N.deferredNonRetain = !!(Z & 128);
            const te = !!(Z & 64), re = ie[q + 5];
            let ee = re >> 5 & 7;
            const $ = [re & 31];
            let k = q + 6;
            if (re === 7) {
              ee = (0, i.readUint32)(ie, k - 1) & 536870911, k += 3;
              let ue = ee + 7 >> 3;
              for ($[0] = ie[k++]; --ue > 0; )
                $.push(ie[k++]);
            } else if (re === 5 || re === 6)
              throw new e("invalid referred-to flags");
            N.retainBits = $;
            let H = 4;
            N.number <= 256 ? H = 1 : N.number <= 65536 && (H = 2);
            const ne = [];
            let ae, he;
            for (ae = 0; ae < ee; ae++) {
              let ue;
              H === 1 ? ue = ie[k] : H === 2 ? ue = (0, i.readUint16)(ie, k) : ue = (0, i.readUint32)(ie, k), ne.push(ue), k += H;
            }
            if (N.referredTo = ne, te ? (N.pageAssociation = (0, i.readUint32)(ie, k), k += 4) : N.pageAssociation = ie[k++], N.length = (0, i.readUint32)(ie, k), k += 4, N.length === 4294967295)
              if (E === 38) {
                const ue = R(ie, k), me = !!(ie[k + D] & 1), Fe = 6, we = new Uint8Array(Fe);
                for (me || (we[0] = 255, we[1] = 172), we[2] = ue.height >>> 24 & 255, we[3] = ue.height >> 16 & 255, we[4] = ue.height >> 8 & 255, we[5] = ue.height & 255, ae = k, he = ie.length; ae < he; ae++) {
                  let Ae = 0;
                  for (; Ae < Fe && we[Ae] === ie[ae + Ae]; )
                    Ae++;
                  if (Ae === Fe) {
                    N.length = ae + Fe;
                    break;
                  }
                }
                if (N.length === 4294967295)
                  throw new e("segment end was not found");
              } else
                throw new e("invalid unknown segment length");
            return N.headerEnd = k, N;
          }
          function B(ie, q, N, Z) {
            const E = [];
            let te = N;
            for (; te < Z; ) {
              const re = j(q, te);
              te = re.headerEnd;
              const ee = {
                header: re,
                data: q
              };
              if (ie.randomAccess || (ee.start = te, te += re.length, ee.end = te), E.push(ee), re.type === 51)
                break;
            }
            if (ie.randomAccess)
              for (let re = 0, ee = E.length; re < ee; re++)
                E[re].start = te, te += E[re].header.length, E[re].end = te;
            return E;
          }
          function R(ie, q) {
            return {
              width: (0, i.readUint32)(ie, q),
              height: (0, i.readUint32)(ie, q + 4),
              x: (0, i.readUint32)(ie, q + 8),
              y: (0, i.readUint32)(ie, q + 12),
              combinationOperator: ie[q + 16] & 7
            };
          }
          const D = 17;
          function b(ie, q) {
            const N = ie.header, Z = ie.data, E = ie.end;
            let te = ie.start, re, ee, $, k;
            switch (N.type) {
              case 0:
                const ne = {}, ae = (0, i.readUint16)(Z, te);
                if (ne.huffman = !!(ae & 1), ne.refinement = !!(ae & 2), ne.huffmanDHSelector = ae >> 2 & 3, ne.huffmanDWSelector = ae >> 4 & 3, ne.bitmapSizeSelector = ae >> 6 & 1, ne.aggregationInstancesSelector = ae >> 7 & 1, ne.bitmapCodingContextUsed = !!(ae & 256), ne.bitmapCodingContextRetained = !!(ae & 512), ne.template = ae >> 10 & 3, ne.refinementTemplate = ae >> 12 & 1, te += 2, !ne.huffman) {
                  for (k = ne.template === 0 ? 4 : 1, ee = [], $ = 0; $ < k; $++)
                    ee.push({
                      x: (0, i.readInt8)(Z, te),
                      y: (0, i.readInt8)(Z, te + 1)
                    }), te += 2;
                  ne.at = ee;
                }
                if (ne.refinement && !ne.refinementTemplate) {
                  for (ee = [], $ = 0; $ < 2; $++)
                    ee.push({
                      x: (0, i.readInt8)(Z, te),
                      y: (0, i.readInt8)(Z, te + 1)
                    }), te += 2;
                  ne.refinementAt = ee;
                }
                ne.numberOfExportedSymbols = (0, i.readUint32)(Z, te), te += 4, ne.numberOfNewSymbols = (0, i.readUint32)(Z, te), te += 4, re = [ne, N.number, N.referredTo, Z, te, E];
                break;
              case 6:
              case 7:
                const he = {};
                he.info = R(Z, te), te += D;
                const ue = (0, i.readUint16)(Z, te);
                if (te += 2, he.huffman = !!(ue & 1), he.refinement = !!(ue & 2), he.logStripSize = ue >> 2 & 3, he.stripSize = 1 << he.logStripSize, he.referenceCorner = ue >> 4 & 3, he.transposed = !!(ue & 64), he.combinationOperator = ue >> 7 & 3, he.defaultPixelValue = ue >> 9 & 1, he.dsOffset = ue << 17 >> 27, he.refinementTemplate = ue >> 15 & 1, he.huffman) {
                  const ve = (0, i.readUint16)(Z, te);
                  te += 2, he.huffmanFS = ve & 3, he.huffmanDS = ve >> 2 & 3, he.huffmanDT = ve >> 4 & 3, he.huffmanRefinementDW = ve >> 6 & 3, he.huffmanRefinementDH = ve >> 8 & 3, he.huffmanRefinementDX = ve >> 10 & 3, he.huffmanRefinementDY = ve >> 12 & 3, he.huffmanRefinementSizeSelector = !!(ve & 16384);
                }
                if (he.refinement && !he.refinementTemplate) {
                  for (ee = [], $ = 0; $ < 2; $++)
                    ee.push({
                      x: (0, i.readInt8)(Z, te),
                      y: (0, i.readInt8)(Z, te + 1)
                    }), te += 2;
                  he.refinementAt = ee;
                }
                he.numberOfSymbolInstances = (0, i.readUint32)(Z, te), te += 4, re = [he, N.referredTo, Z, te, E];
                break;
              case 16:
                const fe = {}, me = Z[te++];
                fe.mmr = !!(me & 1), fe.template = me >> 1 & 3, fe.patternWidth = Z[te++], fe.patternHeight = Z[te++], fe.maxPatternIndex = (0, i.readUint32)(Z, te), te += 4, re = [fe, N.number, Z, te, E];
                break;
              case 22:
              case 23:
                const Fe = {};
                Fe.info = R(Z, te), te += D;
                const we = Z[te++];
                Fe.mmr = !!(we & 1), Fe.template = we >> 1 & 3, Fe.enableSkip = !!(we & 8), Fe.combinationOperator = we >> 4 & 7, Fe.defaultPixelValue = we >> 7 & 1, Fe.gridWidth = (0, i.readUint32)(Z, te), te += 4, Fe.gridHeight = (0, i.readUint32)(Z, te), te += 4, Fe.gridOffsetX = (0, i.readUint32)(Z, te) & 4294967295, te += 4, Fe.gridOffsetY = (0, i.readUint32)(Z, te) & 4294967295, te += 4, Fe.gridVectorX = (0, i.readUint16)(Z, te), te += 2, Fe.gridVectorY = (0, i.readUint16)(Z, te), te += 2, re = [Fe, N.referredTo, Z, te, E];
                break;
              case 38:
              case 39:
                const Ae = {};
                Ae.info = R(Z, te), te += D;
                const De = Z[te++];
                if (Ae.mmr = !!(De & 1), Ae.template = De >> 1 & 3, Ae.prediction = !!(De & 8), !Ae.mmr) {
                  for (k = Ae.template === 0 ? 4 : 1, ee = [], $ = 0; $ < k; $++)
                    ee.push({
                      x: (0, i.readInt8)(Z, te),
                      y: (0, i.readInt8)(Z, te + 1)
                    }), te += 2;
                  Ae.at = ee;
                }
                re = [Ae, Z, te, E];
                break;
              case 48:
                const xe = {
                  width: (0, i.readUint32)(Z, te),
                  height: (0, i.readUint32)(Z, te + 4),
                  resolutionX: (0, i.readUint32)(Z, te + 8),
                  resolutionY: (0, i.readUint32)(Z, te + 12)
                };
                xe.height === 4294967295 && delete xe.height;
                const Te = Z[te + 16];
                (0, i.readUint16)(Z, te + 17), xe.lossless = !!(Te & 1), xe.refinement = !!(Te & 2), xe.defaultPixelValue = Te >> 2 & 1, xe.combinationOperator = Te >> 3 & 3, xe.requiresBuffer = !!(Te & 32), xe.combinationOperatorOverride = !!(Te & 64), re = [xe];
                break;
              case 49:
                break;
              case 50:
                break;
              case 51:
                break;
              case 53:
                re = [N.number, Z, te, E];
                break;
              case 62:
                break;
              default:
                throw new e(`segment type ${N.typeName}(${N.type}) is not implemented`);
            }
            const H = "on" + N.typeName;
            H in q && q[H].apply(q, re);
          }
          function l(ie, q) {
            for (let N = 0, Z = ie.length; N < Z; N++)
              b(ie[N], q);
          }
          function _(ie) {
            const q = new S();
            for (let N = 0, Z = ie.length; N < Z; N++) {
              const E = ie[N], te = B({}, E.data, E.start, E.end);
              l(te, q);
            }
            return q.buffer;
          }
          class S {
            onPageInformation(q) {
              this.currentPageInfo = q;
              const N = q.width + 7 >> 3, Z = new Uint8ClampedArray(N * q.height);
              q.defaultPixelValue && Z.fill(255), this.buffer = Z;
            }
            drawBitmap(q, N) {
              const Z = this.currentPageInfo, E = q.width, te = q.height, re = Z.width + 7 >> 3, ee = Z.combinationOperatorOverride ? q.combinationOperator : Z.combinationOperator, $ = this.buffer, k = 128 >> (q.x & 7);
              let H = q.y * re + (q.x >> 3), ne, ae, he, ue;
              switch (ee) {
                case 0:
                  for (ne = 0; ne < te; ne++) {
                    for (he = k, ue = H, ae = 0; ae < E; ae++)
                      N[ne][ae] && ($[ue] |= he), he >>= 1, he || (he = 128, ue++);
                    H += re;
                  }
                  break;
                case 2:
                  for (ne = 0; ne < te; ne++) {
                    for (he = k, ue = H, ae = 0; ae < E; ae++)
                      N[ne][ae] && ($[ue] ^= he), he >>= 1, he || (he = 128, ue++);
                    H += re;
                  }
                  break;
                default:
                  throw new e(`operator ${ee} is not supported`);
              }
            }
            onImmediateGenericRegion(q, N, Z, E) {
              const te = q.info, re = new r(N, Z, E), ee = m(q.mmr, te.width, te.height, q.template, q.prediction, null, q.at, re);
              this.drawBitmap(te, ee);
            }
            onImmediateLosslessGenericRegion() {
              this.onImmediateGenericRegion(...arguments);
            }
            onSymbolDictionary(q, N, Z, E, te, re) {
              let ee, $;
              q.huffman && (ee = V(q, Z, this.customTables), $ = new K(E, te, re));
              let k = this.symbols;
              k || (this.symbols = k = {});
              const H = [];
              for (const ae of Z) {
                const he = k[ae];
                he && H.push(...he);
              }
              const ne = new r(E, te, re);
              k[N] = p(q.huffman, q.refinement, H, q.numberOfNewSymbols, q.numberOfExportedSymbols, ee, q.template, q.at, q.refinementTemplate, q.refinementAt, ne, $);
            }
            onImmediateTextRegion(q, N, Z, E, te) {
              const re = q.info;
              let ee, $;
              const k = this.symbols, H = [];
              for (const ue of N) {
                const fe = k[ue];
                fe && H.push(...fe);
              }
              const ne = (0, i.log2)(H.length);
              q.huffman && ($ = new K(Z, E, te), ee = z(q, N, this.customTables, H.length, $));
              const ae = new r(Z, E, te), he = w(q.huffman, q.refinement, re.width, re.height, q.defaultPixelValue, q.numberOfSymbolInstances, q.stripSize, H, ne, q.transposed, q.dsOffset, q.referenceCorner, q.combinationOperator, ee, q.refinementTemplate, q.refinementAt, ae, q.logStripSize, $);
              this.drawBitmap(re, he);
            }
            onImmediateLosslessTextRegion() {
              this.onImmediateTextRegion(...arguments);
            }
            onPatternDictionary(q, N, Z, E, te) {
              let re = this.patterns;
              re || (this.patterns = re = {});
              const ee = new r(Z, E, te);
              re[N] = X(q.mmr, q.patternWidth, q.patternHeight, q.maxPatternIndex, q.template, ee);
            }
            onImmediateHalftoneRegion(q, N, Z, E, te) {
              const re = this.patterns[N[0]], ee = q.info, $ = new r(Z, E, te), k = M(q.mmr, re, q.template, ee.width, ee.height, q.defaultPixelValue, q.enableSkip, q.combinationOperator, q.gridWidth, q.gridHeight, q.gridOffsetX, q.gridOffsetY, q.gridVectorX, q.gridVectorY, $);
              this.drawBitmap(ee, k);
            }
            onImmediateLosslessHalftoneRegion() {
              this.onImmediateHalftoneRegion(...arguments);
            }
            onTables(q, N, Z, E) {
              let te = this.customTables;
              te || (this.customTables = te = {}), te[q] = O(N, Z, E);
            }
          }
          class A {
            constructor(q) {
              q.length === 2 ? (this.isOOB = !0, this.rangeLow = 0, this.prefixLength = q[0], this.rangeLength = 0, this.prefixCode = q[1], this.isLowerRange = !1) : (this.isOOB = !1, this.rangeLow = q[0], this.prefixLength = q[1], this.rangeLength = q[2], this.prefixCode = q[3], this.isLowerRange = q[4] === "lower");
            }
          }
          class F {
            constructor(q) {
              this.children = [], q ? (this.isLeaf = !0, this.rangeLength = q.rangeLength, this.rangeLow = q.rangeLow, this.isLowerRange = q.isLowerRange, this.isOOB = q.isOOB) : this.isLeaf = !1;
            }
            buildTree(q, N) {
              const Z = q.prefixCode >> N & 1;
              if (N <= 0)
                this.children[Z] = new F(q);
              else {
                let E = this.children[Z];
                E || (this.children[Z] = E = new F(null)), E.buildTree(q, N - 1);
              }
            }
            decodeNode(q) {
              if (this.isLeaf) {
                if (this.isOOB)
                  return null;
                const Z = q.readBits(this.rangeLength);
                return this.rangeLow + (this.isLowerRange ? -Z : Z);
              }
              const N = this.children[q.readBit()];
              if (!N)
                throw new e("invalid Huffman data");
              return N.decodeNode(q);
            }
          }
          class T {
            constructor(q, N) {
              N || this.assignPrefixCodes(q), this.rootNode = new F(null);
              for (let Z = 0, E = q.length; Z < E; Z++) {
                const te = q[Z];
                te.prefixLength > 0 && this.rootNode.buildTree(te, te.prefixLength - 1);
              }
            }
            decode(q) {
              return this.rootNode.decodeNode(q);
            }
            assignPrefixCodes(q) {
              const N = q.length;
              let Z = 0;
              for (let H = 0; H < N; H++)
                Z = Math.max(Z, q[H].prefixLength);
              const E = new Uint32Array(Z + 1);
              for (let H = 0; H < N; H++)
                E[q[H].prefixLength]++;
              let te = 1, re = 0, ee, $, k;
              for (E[0] = 0; te <= Z; ) {
                for (re = re + E[te - 1] << 1, ee = re, $ = 0; $ < N; )
                  k = q[$], k.prefixLength === te && (k.prefixCode = ee, ee++), $++;
                te++;
              }
            }
          }
          function O(ie, q, N) {
            const Z = ie[q], E = (0, i.readUint32)(ie, q + 1) & 4294967295, te = (0, i.readUint32)(ie, q + 5) & 4294967295, re = new K(ie, q + 9, N), ee = (Z >> 1 & 7) + 1, $ = (Z >> 4 & 7) + 1, k = [];
            let H, ne, ae = E;
            do
              H = re.readBits(ee), ne = re.readBits($), k.push(new A([ae, H, ne, 0])), ae += 1 << ne;
            while (ae < te);
            return H = re.readBits(ee), k.push(new A([E - 1, H, 32, 0, "lower"])), H = re.readBits(ee), k.push(new A([te, H, 32, 0])), Z & 1 && (H = re.readBits(ee), k.push(new A([H, 0]))), new T(k, !1);
          }
          const U = {};
          function G(ie) {
            let q = U[ie];
            if (q)
              return q;
            let N;
            switch (ie) {
              case 1:
                N = [[0, 1, 4, 0], [16, 2, 8, 2], [272, 3, 16, 6], [65808, 3, 32, 7]];
                break;
              case 2:
                N = [[0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [75, 6, 32, 62], [6, 63]];
                break;
              case 3:
                N = [[-256, 8, 8, 254], [0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [-257, 8, 32, 255, "lower"], [75, 7, 32, 126], [6, 62]];
                break;
              case 4:
                N = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [76, 5, 32, 31]];
                break;
              case 5:
                N = [[-255, 7, 8, 126], [1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [-256, 7, 32, 127, "lower"], [76, 6, 32, 62]];
                break;
              case 6:
                N = [[-2048, 5, 10, 28], [-1024, 4, 9, 8], [-512, 4, 8, 9], [-256, 4, 7, 10], [-128, 5, 6, 29], [-64, 5, 5, 30], [-32, 4, 5, 11], [0, 2, 7, 0], [128, 3, 7, 2], [256, 3, 8, 3], [512, 4, 9, 12], [1024, 4, 10, 13], [-2049, 6, 32, 62, "lower"], [2048, 6, 32, 63]];
                break;
              case 7:
                N = [[-1024, 4, 9, 8], [-512, 3, 8, 0], [-256, 4, 7, 9], [-128, 5, 6, 26], [-64, 5, 5, 27], [-32, 4, 5, 10], [0, 4, 5, 11], [32, 5, 5, 28], [64, 5, 6, 29], [128, 4, 7, 12], [256, 3, 8, 1], [512, 3, 9, 2], [1024, 3, 10, 3], [-1025, 5, 32, 30, "lower"], [2048, 5, 32, 31]];
                break;
              case 8:
                N = [[-15, 8, 3, 252], [-7, 9, 1, 508], [-5, 8, 1, 253], [-3, 9, 0, 509], [-2, 7, 0, 124], [-1, 4, 0, 10], [0, 2, 1, 0], [2, 5, 0, 26], [3, 6, 0, 58], [4, 3, 4, 4], [20, 6, 1, 59], [22, 4, 4, 11], [38, 4, 5, 12], [70, 5, 6, 27], [134, 5, 7, 28], [262, 6, 7, 60], [390, 7, 8, 125], [646, 6, 10, 61], [-16, 9, 32, 510, "lower"], [1670, 9, 32, 511], [2, 1]];
                break;
              case 9:
                N = [[-31, 8, 4, 252], [-15, 9, 2, 508], [-11, 8, 2, 253], [-7, 9, 1, 509], [-5, 7, 1, 124], [-3, 4, 1, 10], [-1, 3, 1, 2], [1, 3, 1, 3], [3, 5, 1, 26], [5, 6, 1, 58], [7, 3, 5, 4], [39, 6, 2, 59], [43, 4, 5, 11], [75, 4, 6, 12], [139, 5, 7, 27], [267, 5, 8, 28], [523, 6, 8, 60], [779, 7, 9, 125], [1291, 6, 11, 61], [-32, 9, 32, 510, "lower"], [3339, 9, 32, 511], [2, 0]];
                break;
              case 10:
                N = [[-21, 7, 4, 122], [-5, 8, 0, 252], [-4, 7, 0, 123], [-3, 5, 0, 24], [-2, 2, 2, 0], [2, 5, 0, 25], [3, 6, 0, 54], [4, 7, 0, 124], [5, 8, 0, 253], [6, 2, 6, 1], [70, 5, 5, 26], [102, 6, 5, 55], [134, 6, 6, 56], [198, 6, 7, 57], [326, 6, 8, 58], [582, 6, 9, 59], [1094, 6, 10, 60], [2118, 7, 11, 125], [-22, 8, 32, 254, "lower"], [4166, 8, 32, 255], [2, 2]];
                break;
              case 11:
                N = [[1, 1, 0, 0], [2, 2, 1, 2], [4, 4, 0, 12], [5, 4, 1, 13], [7, 5, 1, 28], [9, 5, 2, 29], [13, 6, 2, 60], [17, 7, 2, 122], [21, 7, 3, 123], [29, 7, 4, 124], [45, 7, 5, 125], [77, 7, 6, 126], [141, 7, 32, 127]];
                break;
              case 12:
                N = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 1, 6], [5, 5, 0, 28], [6, 5, 1, 29], [8, 6, 1, 60], [10, 7, 0, 122], [11, 7, 1, 123], [13, 7, 2, 124], [17, 7, 3, 125], [25, 7, 4, 126], [41, 8, 5, 254], [73, 8, 32, 255]];
                break;
              case 13:
                N = [[1, 1, 0, 0], [2, 3, 0, 4], [3, 4, 0, 12], [4, 5, 0, 28], [5, 4, 1, 13], [7, 3, 3, 5], [15, 6, 1, 58], [17, 6, 2, 59], [21, 6, 3, 60], [29, 6, 4, 61], [45, 6, 5, 62], [77, 7, 6, 126], [141, 7, 32, 127]];
                break;
              case 14:
                N = [[-2, 3, 0, 4], [-1, 3, 0, 5], [0, 1, 0, 0], [1, 3, 0, 6], [2, 3, 0, 7]];
                break;
              case 15:
                N = [[-24, 7, 4, 124], [-8, 6, 2, 60], [-4, 5, 1, 28], [-2, 4, 0, 12], [-1, 3, 0, 4], [0, 1, 0, 0], [1, 3, 0, 5], [2, 4, 0, 13], [3, 5, 1, 29], [5, 6, 2, 61], [9, 7, 4, 125], [-25, 7, 32, 126, "lower"], [25, 7, 32, 127]];
                break;
              default:
                throw new e(`standard table B.${ie} does not exist`);
            }
            for (let Z = 0, E = N.length; Z < E; Z++)
              N[Z] = new A(N[Z]);
            return q = new T(N, !0), U[ie] = q, q;
          }
          class K {
            constructor(q, N, Z) {
              this.data = q, this.start = N, this.end = Z, this.position = N, this.shift = -1, this.currentByte = 0;
            }
            readBit() {
              if (this.shift < 0) {
                if (this.position >= this.end)
                  throw new e("end of data while reading bit");
                this.currentByte = this.data[this.position++], this.shift = 7;
              }
              const q = this.currentByte >> this.shift & 1;
              return this.shift--, q;
            }
            readBits(q) {
              let N = 0, Z;
              for (Z = q - 1; Z >= 0; Z--)
                N |= this.readBit() << Z;
              return N;
            }
            byteAlign() {
              this.shift = -1;
            }
            next() {
              return this.position >= this.end ? -1 : this.data[this.position++];
            }
          }
          function W(ie, q, N) {
            let Z = 0;
            for (let E = 0, te = q.length; E < te; E++) {
              const re = N[q[E]];
              if (re) {
                if (ie === Z)
                  return re;
                Z++;
              }
            }
            throw new e("can't find custom Huffman table");
          }
          function z(ie, q, N, Z, E) {
            const te = [];
            for (let ae = 0; ae <= 34; ae++) {
              const he = E.readBits(4);
              te.push(new A([ae, he, 0, 0]));
            }
            const re = new T(te, !1);
            te.length = 0;
            for (let ae = 0; ae < Z; ) {
              const he = re.decode(E);
              if (he >= 32) {
                let ue, fe, me;
                switch (he) {
                  case 32:
                    if (ae === 0)
                      throw new e("no previous value in symbol ID table");
                    fe = E.readBits(2) + 3, ue = te[ae - 1].prefixLength;
                    break;
                  case 33:
                    fe = E.readBits(3) + 3, ue = 0;
                    break;
                  case 34:
                    fe = E.readBits(7) + 11, ue = 0;
                    break;
                  default:
                    throw new e("invalid code length in symbol ID table");
                }
                for (me = 0; me < fe; me++)
                  te.push(new A([ae, ue, 0, 0])), ae++;
              } else
                te.push(new A([ae, he, 0, 0])), ae++;
            }
            E.byteAlign();
            const ee = new T(te, !1);
            let $ = 0, k, H, ne;
            switch (ie.huffmanFS) {
              case 0:
              case 1:
                k = G(ie.huffmanFS + 6);
                break;
              case 3:
                k = W($, q, N), $++;
                break;
              default:
                throw new e("invalid Huffman FS selector");
            }
            switch (ie.huffmanDS) {
              case 0:
              case 1:
              case 2:
                H = G(ie.huffmanDS + 8);
                break;
              case 3:
                H = W($, q, N), $++;
                break;
              default:
                throw new e("invalid Huffman DS selector");
            }
            switch (ie.huffmanDT) {
              case 0:
              case 1:
              case 2:
                ne = G(ie.huffmanDT + 11);
                break;
              case 3:
                ne = W($, q, N), $++;
                break;
              default:
                throw new e("invalid Huffman DT selector");
            }
            if (ie.refinement)
              throw new e("refinement with Huffman is not supported");
            return {
              symbolIDTable: ee,
              tableFirstS: k,
              tableDeltaS: H,
              tableDeltaT: ne
            };
          }
          function V(ie, q, N) {
            let Z = 0, E, te;
            switch (ie.huffmanDHSelector) {
              case 0:
              case 1:
                E = G(ie.huffmanDHSelector + 4);
                break;
              case 3:
                E = W(Z, q, N), Z++;
                break;
              default:
                throw new e("invalid Huffman DH selector");
            }
            switch (ie.huffmanDWSelector) {
              case 0:
              case 1:
                te = G(ie.huffmanDWSelector + 2);
                break;
              case 3:
                te = W(Z, q, N), Z++;
                break;
              default:
                throw new e("invalid Huffman DW selector");
            }
            let re, ee;
            return ie.bitmapSizeSelector ? (re = W(Z, q, N), Z++) : re = G(1), ie.aggregationInstancesSelector ? ee = W(Z, q, N) : ee = G(1), {
              tableDeltaHeight: E,
              tableDeltaWidth: te,
              tableBitmapSize: re,
              tableAggregateInstances: ee
            };
          }
          function L(ie, q, N) {
            const Z = [];
            for (let E = 0; E < N; E++) {
              const te = new Uint8Array(q);
              Z.push(te);
              for (let re = 0; re < q; re++)
                te[re] = ie.readBit();
              ie.byteAlign();
            }
            return Z;
          }
          function Y(ie, q, N, Z) {
            const E = {
              K: -1,
              Columns: q,
              Rows: N,
              BlackIs1: !0,
              EndOfBlock: Z
            }, te = new a.CCITTFaxDecoder(ie, E), re = [];
            let ee, $ = !1;
            for (let k = 0; k < N; k++) {
              const H = new Uint8Array(q);
              re.push(H);
              let ne = -1;
              for (let ae = 0; ae < q; ae++)
                ne < 0 && (ee = te.readNextChar(), ee === -1 && (ee = 0, $ = !0), ne = 7), H[ae] = ee >> ne & 1, ne--;
            }
            if (Z && !$)
              for (let H = 0; H < 5 && te.readNextChar() !== -1; H++)
                ;
            return re;
          }
          class J {
            parseChunks(q) {
              return _(q);
            }
            parse(q) {
              throw new Error("Not implemented: Jbig2Image.parse");
            }
          }
          u.Jbig2Image = J;
        },
        /* 26 */
        /***/
        (Q, u) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.ArithmeticDecoder = void 0;
          const P = [{
            qe: 22017,
            nmps: 1,
            nlps: 1,
            switchFlag: 1
          }, {
            qe: 13313,
            nmps: 2,
            nlps: 6,
            switchFlag: 0
          }, {
            qe: 6145,
            nmps: 3,
            nlps: 9,
            switchFlag: 0
          }, {
            qe: 2753,
            nmps: 4,
            nlps: 12,
            switchFlag: 0
          }, {
            qe: 1313,
            nmps: 5,
            nlps: 29,
            switchFlag: 0
          }, {
            qe: 545,
            nmps: 38,
            nlps: 33,
            switchFlag: 0
          }, {
            qe: 22017,
            nmps: 7,
            nlps: 6,
            switchFlag: 1
          }, {
            qe: 21505,
            nmps: 8,
            nlps: 14,
            switchFlag: 0
          }, {
            qe: 18433,
            nmps: 9,
            nlps: 14,
            switchFlag: 0
          }, {
            qe: 14337,
            nmps: 10,
            nlps: 14,
            switchFlag: 0
          }, {
            qe: 12289,
            nmps: 11,
            nlps: 17,
            switchFlag: 0
          }, {
            qe: 9217,
            nmps: 12,
            nlps: 18,
            switchFlag: 0
          }, {
            qe: 7169,
            nmps: 13,
            nlps: 20,
            switchFlag: 0
          }, {
            qe: 5633,
            nmps: 29,
            nlps: 21,
            switchFlag: 0
          }, {
            qe: 22017,
            nmps: 15,
            nlps: 14,
            switchFlag: 1
          }, {
            qe: 21505,
            nmps: 16,
            nlps: 14,
            switchFlag: 0
          }, {
            qe: 20737,
            nmps: 17,
            nlps: 15,
            switchFlag: 0
          }, {
            qe: 18433,
            nmps: 18,
            nlps: 16,
            switchFlag: 0
          }, {
            qe: 14337,
            nmps: 19,
            nlps: 17,
            switchFlag: 0
          }, {
            qe: 13313,
            nmps: 20,
            nlps: 18,
            switchFlag: 0
          }, {
            qe: 12289,
            nmps: 21,
            nlps: 19,
            switchFlag: 0
          }, {
            qe: 10241,
            nmps: 22,
            nlps: 19,
            switchFlag: 0
          }, {
            qe: 9217,
            nmps: 23,
            nlps: 20,
            switchFlag: 0
          }, {
            qe: 8705,
            nmps: 24,
            nlps: 21,
            switchFlag: 0
          }, {
            qe: 7169,
            nmps: 25,
            nlps: 22,
            switchFlag: 0
          }, {
            qe: 6145,
            nmps: 26,
            nlps: 23,
            switchFlag: 0
          }, {
            qe: 5633,
            nmps: 27,
            nlps: 24,
            switchFlag: 0
          }, {
            qe: 5121,
            nmps: 28,
            nlps: 25,
            switchFlag: 0
          }, {
            qe: 4609,
            nmps: 29,
            nlps: 26,
            switchFlag: 0
          }, {
            qe: 4353,
            nmps: 30,
            nlps: 27,
            switchFlag: 0
          }, {
            qe: 2753,
            nmps: 31,
            nlps: 28,
            switchFlag: 0
          }, {
            qe: 2497,
            nmps: 32,
            nlps: 29,
            switchFlag: 0
          }, {
            qe: 2209,
            nmps: 33,
            nlps: 30,
            switchFlag: 0
          }, {
            qe: 1313,
            nmps: 34,
            nlps: 31,
            switchFlag: 0
          }, {
            qe: 1089,
            nmps: 35,
            nlps: 32,
            switchFlag: 0
          }, {
            qe: 673,
            nmps: 36,
            nlps: 33,
            switchFlag: 0
          }, {
            qe: 545,
            nmps: 37,
            nlps: 34,
            switchFlag: 0
          }, {
            qe: 321,
            nmps: 38,
            nlps: 35,
            switchFlag: 0
          }, {
            qe: 273,
            nmps: 39,
            nlps: 36,
            switchFlag: 0
          }, {
            qe: 133,
            nmps: 40,
            nlps: 37,
            switchFlag: 0
          }, {
            qe: 73,
            nmps: 41,
            nlps: 38,
            switchFlag: 0
          }, {
            qe: 37,
            nmps: 42,
            nlps: 39,
            switchFlag: 0
          }, {
            qe: 21,
            nmps: 43,
            nlps: 40,
            switchFlag: 0
          }, {
            qe: 9,
            nmps: 44,
            nlps: 41,
            switchFlag: 0
          }, {
            qe: 5,
            nmps: 45,
            nlps: 42,
            switchFlag: 0
          }, {
            qe: 1,
            nmps: 45,
            nlps: 43,
            switchFlag: 0
          }, {
            qe: 22017,
            nmps: 46,
            nlps: 46,
            switchFlag: 0
          }];
          class t {
            constructor(v, a, e) {
              this.data = v, this.bp = a, this.dataEnd = e, this.chigh = v[a], this.clow = 0, this.byteIn(), this.chigh = this.chigh << 7 & 65535 | this.clow >> 9 & 127, this.clow = this.clow << 7 & 65535, this.ct -= 7, this.a = 32768;
            }
            byteIn() {
              const v = this.data;
              let a = this.bp;
              v[a] === 255 ? v[a + 1] > 143 ? (this.clow += 65280, this.ct = 8) : (a++, this.clow += v[a] << 9, this.ct = 7, this.bp = a) : (a++, this.clow += a < this.dataEnd ? v[a] << 8 : 65280, this.ct = 8, this.bp = a), this.clow > 65535 && (this.chigh += this.clow >> 16, this.clow &= 65535);
            }
            readBit(v, a) {
              let e = v[a] >> 1, y = v[a] & 1;
              const r = P[e], h = r.qe;
              let g, d = this.a - h;
              if (this.chigh < h)
                d < h ? (d = h, g = y, e = r.nmps) : (d = h, g = 1 ^ y, r.switchFlag === 1 && (y = g), e = r.nlps);
              else {
                if (this.chigh -= h, d & 32768)
                  return this.a = d, y;
                d < h ? (g = 1 ^ y, r.switchFlag === 1 && (y = g), e = r.nlps) : (g = y, e = r.nmps);
              }
              do
                this.ct === 0 && this.byteIn(), d <<= 1, this.chigh = this.chigh << 1 & 65535 | this.clow >> 15 & 1, this.clow = this.clow << 1 & 65535, this.ct--;
              while (!(d & 32768));
              return this.a = d, v[a] = e << 1 | y, g;
            }
          }
          u.ArithmeticDecoder = t;
        },
        /* 27 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.JpegStream = void 0;
          var t = P(19), i = P(5), v = P(28), a = P(2);
          class e extends t.DecodeStream {
            constructor(r, h, g) {
              let d;
              for (; (d = r.getByte()) !== -1; )
                if (d === 255) {
                  r.skip(-1);
                  break;
                }
              super(h), this.stream = r, this.dict = r.dict, this.maybeLength = h, this.params = g;
            }
            get bytes() {
              return (0, a.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
            }
            ensureBuffer(r) {
            }
            readBlock() {
              if (this.eof)
                return;
              const r = {
                decodeTransform: void 0,
                colorTransform: void 0
              }, h = this.dict.getArray("D", "Decode");
              if (this.forceRGB && Array.isArray(h)) {
                const c = this.dict.get("BPC", "BitsPerComponent") || 8, n = h.length, o = new Int32Array(n);
                let x = !1;
                const f = (1 << c) - 1;
                for (let m = 0; m < n; m += 2)
                  o[m] = (h[m + 1] - h[m]) * 256 | 0, o[m + 1] = h[m] * f | 0, (o[m] !== 256 || o[m + 1] !== 0) && (x = !0);
                x && (r.decodeTransform = o);
              }
              if (this.params instanceof i.Dict) {
                const c = this.params.get("ColorTransform");
                Number.isInteger(c) && (r.colorTransform = c);
              }
              const g = new v.JpegImage(r);
              g.parse(this.bytes);
              const d = g.getData({
                width: this.drawWidth,
                height: this.drawHeight,
                forceRGB: this.forceRGB,
                isSourcePDF: !0
              });
              this.buffer = d, this.bufferLength = d.length, this.eof = !0;
            }
          }
          u.JpegStream = e;
        },
        /* 28 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.JpegImage = void 0;
          var t = P(2), i = P(6);
          class v extends t.BaseException {
            constructor(B) {
              super(`JPEG error: ${B}`, "JpegError");
            }
          }
          class a extends t.BaseException {
            constructor(B, R) {
              super(B, "DNLMarkerError"), this.scanLines = R;
            }
          }
          class e extends t.BaseException {
            constructor(B) {
              super(B, "EOIMarkerError");
            }
          }
          const y = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), r = 4017, h = 799, g = 3406, d = 2276, c = 1567, n = 3784, o = 5793, x = 2896;
          function f(j, B) {
            let R = 0, D, b, l = 16;
            for (; l > 0 && !j[l - 1]; )
              l--;
            const _ = [{
              children: [],
              index: 0
            }];
            let S = _[0], A;
            for (D = 0; D < l; D++) {
              for (b = 0; b < j[D]; b++) {
                for (S = _.pop(), S.children[S.index] = B[R]; S.index > 0; )
                  S = _.pop();
                for (S.index++, _.push(S); _.length <= D; )
                  _.push(A = {
                    children: [],
                    index: 0
                  }), S.children[S.index] = A.children, S = A;
                R++;
              }
              D + 1 < l && (_.push(A = {
                children: [],
                index: 0
              }), S.children[S.index] = A.children, S = A);
            }
            return _[0].children;
          }
          function m(j, B, R) {
            return 64 * ((j.blocksPerLine + 1) * B + R);
          }
          function C(j, B, R, D, b, l, _, S, A, F = !1) {
            const T = R.mcusPerLine, O = R.progressive, U = B;
            let G = 0, K = 0;
            function W() {
              if (K > 0)
                return K--, G >> K & 1;
              if (G = j[B++], G === 255) {
                const xe = j[B++];
                if (xe) {
                  if (xe === 220 && F) {
                    B += 2;
                    const Te = (0, i.readUint16)(j, B);
                    if (B += 2, Te > 0 && Te !== R.scanLines)
                      throw new a("Found DNL marker (0xFFDC) while parsing scan data", Te);
                  } else if (xe === 217) {
                    if (F) {
                      const Te = re * (R.precision === 8 ? 8 : 0);
                      if (Te > 0 && Math.round(R.scanLines / Te) >= 10)
                        throw new a("Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter", Te);
                    }
                    throw new e("Found EOI marker (0xFFD9) while parsing scan data");
                  }
                  throw new v(`unexpected marker ${(G << 8 | xe).toString(16)}`);
                }
              }
              return K = 7, G >>> 7;
            }
            function z(xe) {
              let Te = xe;
              for (; ; ) {
                switch (Te = Te[W()], typeof Te) {
                  case "number":
                    return Te;
                  case "object":
                    continue;
                }
                throw new v("invalid huffman sequence");
              }
            }
            function V(xe) {
              let Te = 0;
              for (; xe > 0; )
                Te = Te << 1 | W(), xe--;
              return Te;
            }
            function L(xe) {
              if (xe === 1)
                return W() === 1 ? 1 : -1;
              const Te = V(xe);
              return Te >= 1 << xe - 1 ? Te : Te + (-1 << xe) + 1;
            }
            function Y(xe, Te) {
              const ve = z(xe.huffmanTableDC), Se = ve === 0 ? 0 : L(ve);
              xe.blockData[Te] = xe.pred += Se;
              let be = 1;
              for (; be < 64; ) {
                const Le = z(xe.huffmanTableAC), ze = Le & 15, nt = Le >> 4;
                if (ze === 0) {
                  if (nt < 15)
                    break;
                  be += 16;
                  continue;
                }
                be += nt;
                const Ue = y[be];
                xe.blockData[Te + Ue] = L(ze), be++;
              }
            }
            function J(xe, Te) {
              const ve = z(xe.huffmanTableDC), Se = ve === 0 ? 0 : L(ve) << A;
              xe.blockData[Te] = xe.pred += Se;
            }
            function ie(xe, Te) {
              xe.blockData[Te] |= W() << A;
            }
            let q = 0;
            function N(xe, Te) {
              if (q > 0) {
                q--;
                return;
              }
              let ve = l;
              const Se = _;
              for (; ve <= Se; ) {
                const be = z(xe.huffmanTableAC), Le = be & 15, ze = be >> 4;
                if (Le === 0) {
                  if (ze < 15) {
                    q = V(ze) + (1 << ze) - 1;
                    break;
                  }
                  ve += 16;
                  continue;
                }
                ve += ze;
                const nt = y[ve];
                xe.blockData[Te + nt] = L(Le) * (1 << A), ve++;
              }
            }
            let Z = 0, E;
            function te(xe, Te) {
              let ve = l;
              const Se = _;
              let be = 0, Le, ze;
              for (; ve <= Se; ) {
                const nt = Te + y[ve], Ue = xe.blockData[nt] < 0 ? -1 : 1;
                switch (Z) {
                  case 0:
                    if (ze = z(xe.huffmanTableAC), Le = ze & 15, be = ze >> 4, Le === 0)
                      be < 15 ? (q = V(be) + (1 << be), Z = 4) : (be = 16, Z = 1);
                    else {
                      if (Le !== 1)
                        throw new v("invalid ACn encoding");
                      E = L(Le), Z = be ? 2 : 3;
                    }
                    continue;
                  case 1:
                  case 2:
                    xe.blockData[nt] ? xe.blockData[nt] += Ue * (W() << A) : (be--, be === 0 && (Z = Z === 2 ? 3 : 0));
                    break;
                  case 3:
                    xe.blockData[nt] ? xe.blockData[nt] += Ue * (W() << A) : (xe.blockData[nt] = E << A, Z = 0);
                    break;
                  case 4:
                    xe.blockData[nt] && (xe.blockData[nt] += Ue * (W() << A));
                    break;
                }
                ve++;
              }
              Z === 4 && (q--, q === 0 && (Z = 0));
            }
            let re = 0;
            function ee(xe, Te, ve, Se, be) {
              const Le = ve / T | 0, ze = ve % T;
              re = Le * xe.v + Se;
              const nt = ze * xe.h + be, Ue = m(xe, re, nt);
              Te(xe, Ue);
            }
            function $(xe, Te, ve) {
              re = ve / xe.blocksPerLine | 0;
              const Se = ve % xe.blocksPerLine, be = m(xe, re, Se);
              Te(xe, be);
            }
            const k = D.length;
            let H, ne, ae, he, ue, fe;
            O ? l === 0 ? fe = S === 0 ? J : ie : fe = S === 0 ? N : te : fe = Y;
            let me = 0, Fe, we;
            k === 1 ? we = D[0].blocksPerLine * D[0].blocksPerColumn : we = T * R.mcusPerColumn;
            let Ae, De;
            for (; me <= we; ) {
              const xe = b ? Math.min(we - me, b) : we;
              if (xe > 0) {
                for (ne = 0; ne < k; ne++)
                  D[ne].pred = 0;
                if (q = 0, k === 1)
                  for (H = D[0], ue = 0; ue < xe; ue++)
                    $(H, fe, me), me++;
                else
                  for (ue = 0; ue < xe; ue++) {
                    for (ne = 0; ne < k; ne++)
                      for (H = D[ne], Ae = H.h, De = H.v, ae = 0; ae < De; ae++)
                        for (he = 0; he < Ae; he++)
                          ee(H, fe, me, ae, he);
                    me++;
                  }
              }
              if (K = 0, Fe = X(j, B), !Fe)
                break;
              if (Fe.invalid) {
                const Te = xe > 0 ? "unexpected" : "excessive";
                (0, t.warn)(`decodeScan - ${Te} MCU data, current marker is: ${Fe.invalid}`), B = Fe.offset;
              }
              if (Fe.marker >= 65488 && Fe.marker <= 65495)
                B += 2;
              else
                break;
            }
            return B - U;
          }
          function p(j, B, R) {
            const D = j.quantizationTable, b = j.blockData;
            let l, _, S, A, F, T, O, U, G, K, W, z, V, L, Y, J, ie;
            if (!D)
              throw new v("missing required Quantization Table.");
            for (let q = 0; q < 64; q += 8) {
              if (G = b[B + q], K = b[B + q + 1], W = b[B + q + 2], z = b[B + q + 3], V = b[B + q + 4], L = b[B + q + 5], Y = b[B + q + 6], J = b[B + q + 7], G *= D[q], !(K | W | z | V | L | Y | J)) {
                ie = o * G + 512 >> 10, R[q] = ie, R[q + 1] = ie, R[q + 2] = ie, R[q + 3] = ie, R[q + 4] = ie, R[q + 5] = ie, R[q + 6] = ie, R[q + 7] = ie;
                continue;
              }
              K *= D[q + 1], W *= D[q + 2], z *= D[q + 3], V *= D[q + 4], L *= D[q + 5], Y *= D[q + 6], J *= D[q + 7], l = o * G + 128 >> 8, _ = o * V + 128 >> 8, S = W, A = Y, F = x * (K - J) + 128 >> 8, U = x * (K + J) + 128 >> 8, T = z << 4, O = L << 4, l = l + _ + 1 >> 1, _ = l - _, ie = S * n + A * c + 128 >> 8, S = S * c - A * n + 128 >> 8, A = ie, F = F + O + 1 >> 1, O = F - O, U = U + T + 1 >> 1, T = U - T, l = l + A + 1 >> 1, A = l - A, _ = _ + S + 1 >> 1, S = _ - S, ie = F * d + U * g + 2048 >> 12, F = F * g - U * d + 2048 >> 12, U = ie, ie = T * h + O * r + 2048 >> 12, T = T * r - O * h + 2048 >> 12, O = ie, R[q] = l + U, R[q + 7] = l - U, R[q + 1] = _ + O, R[q + 6] = _ - O, R[q + 2] = S + T, R[q + 5] = S - T, R[q + 3] = A + F, R[q + 4] = A - F;
            }
            for (let q = 0; q < 8; ++q) {
              if (G = R[q], K = R[q + 8], W = R[q + 16], z = R[q + 24], V = R[q + 32], L = R[q + 40], Y = R[q + 48], J = R[q + 56], !(K | W | z | V | L | Y | J)) {
                ie = o * G + 8192 >> 14, ie < -2040 ? ie = 0 : ie >= 2024 ? ie = 255 : ie = ie + 2056 >> 4, b[B + q] = ie, b[B + q + 8] = ie, b[B + q + 16] = ie, b[B + q + 24] = ie, b[B + q + 32] = ie, b[B + q + 40] = ie, b[B + q + 48] = ie, b[B + q + 56] = ie;
                continue;
              }
              l = o * G + 2048 >> 12, _ = o * V + 2048 >> 12, S = W, A = Y, F = x * (K - J) + 2048 >> 12, U = x * (K + J) + 2048 >> 12, T = z, O = L, l = (l + _ + 1 >> 1) + 4112, _ = l - _, ie = S * n + A * c + 2048 >> 12, S = S * c - A * n + 2048 >> 12, A = ie, F = F + O + 1 >> 1, O = F - O, U = U + T + 1 >> 1, T = U - T, l = l + A + 1 >> 1, A = l - A, _ = _ + S + 1 >> 1, S = _ - S, ie = F * d + U * g + 2048 >> 12, F = F * g - U * d + 2048 >> 12, U = ie, ie = T * h + O * r + 2048 >> 12, T = T * r - O * h + 2048 >> 12, O = ie, G = l + U, J = l - U, K = _ + O, Y = _ - O, W = S + T, L = S - T, z = A + F, V = A - F, G < 16 ? G = 0 : G >= 4080 ? G = 255 : G >>= 4, K < 16 ? K = 0 : K >= 4080 ? K = 255 : K >>= 4, W < 16 ? W = 0 : W >= 4080 ? W = 255 : W >>= 4, z < 16 ? z = 0 : z >= 4080 ? z = 255 : z >>= 4, V < 16 ? V = 0 : V >= 4080 ? V = 255 : V >>= 4, L < 16 ? L = 0 : L >= 4080 ? L = 255 : L >>= 4, Y < 16 ? Y = 0 : Y >= 4080 ? Y = 255 : Y >>= 4, J < 16 ? J = 0 : J >= 4080 ? J = 255 : J >>= 4, b[B + q] = G, b[B + q + 8] = K, b[B + q + 16] = W, b[B + q + 24] = z, b[B + q + 32] = V, b[B + q + 40] = L, b[B + q + 48] = Y, b[B + q + 56] = J;
            }
          }
          function w(j, B) {
            const R = B.blocksPerLine, D = B.blocksPerColumn, b = new Int16Array(64);
            for (let l = 0; l < D; l++)
              for (let _ = 0; _ < R; _++) {
                const S = m(B, l, _);
                p(B, S, b);
              }
            return B.blockData;
          }
          function X(j, B, R = B) {
            const D = j.length - 1;
            let b = R < B ? R : B;
            if (B >= D)
              return null;
            const l = (0, i.readUint16)(j, B);
            if (l >= 65472 && l <= 65534)
              return {
                invalid: null,
                marker: l,
                offset: B
              };
            let _ = (0, i.readUint16)(j, b);
            for (; !(_ >= 65472 && _ <= 65534); ) {
              if (++b >= D)
                return null;
              _ = (0, i.readUint16)(j, b);
            }
            return {
              invalid: l.toString(16),
              marker: _,
              offset: b
            };
          }
          class M {
            constructor({
              decodeTransform: B = null,
              colorTransform: R = -1
            } = {}) {
              this._decodeTransform = B, this._colorTransform = R;
            }
            parse(B, {
              dnlScanLines: R = null
            } = {}) {
              function D() {
                const W = (0, i.readUint16)(B, l);
                l += 2;
                let z = l + W - 2;
                const V = X(B, z, l);
                V && V.invalid && ((0, t.warn)("readDataBlock - incorrect length, current marker is: " + V.invalid), z = V.offset);
                const L = B.subarray(l, z);
                return l += L.length, L;
              }
              function b(W) {
                const z = Math.ceil(W.samplesPerLine / 8 / W.maxH), V = Math.ceil(W.scanLines / 8 / W.maxV);
                for (let L = 0, Y = W.components.length; L < Y; L++) {
                  const J = W.components[L], ie = Math.ceil(Math.ceil(W.samplesPerLine / 8) * J.h / W.maxH), q = Math.ceil(Math.ceil(W.scanLines / 8) * J.v / W.maxV), N = z * J.h, E = 64 * (V * J.v) * (N + 1);
                  J.blockData = new Int16Array(E), J.blocksPerLine = ie, J.blocksPerColumn = q;
                }
                W.mcusPerLine = z, W.mcusPerColumn = V;
              }
              let l = 0, _ = null, S = null, A, F, T = 0;
              const O = [], U = [], G = [];
              let K = (0, i.readUint16)(B, l);
              if (l += 2, K !== 65496)
                throw new v("SOI not found");
              K = (0, i.readUint16)(B, l), l += 2;
              e:
                for (; K !== 65497; ) {
                  let W, z, V;
                  switch (K) {
                    case 65504:
                    case 65505:
                    case 65506:
                    case 65507:
                    case 65508:
                    case 65509:
                    case 65510:
                    case 65511:
                    case 65512:
                    case 65513:
                    case 65514:
                    case 65515:
                    case 65516:
                    case 65517:
                    case 65518:
                    case 65519:
                    case 65534:
                      const L = D();
                      K === 65504 && L[0] === 74 && L[1] === 70 && L[2] === 73 && L[3] === 70 && L[4] === 0 && (_ = {
                        version: {
                          major: L[5],
                          minor: L[6]
                        },
                        densityUnits: L[7],
                        xDensity: L[8] << 8 | L[9],
                        yDensity: L[10] << 8 | L[11],
                        thumbWidth: L[12],
                        thumbHeight: L[13],
                        thumbData: L.subarray(14, 14 + 3 * L[12] * L[13])
                      }), K === 65518 && L[0] === 65 && L[1] === 100 && L[2] === 111 && L[3] === 98 && L[4] === 101 && (S = {
                        version: L[5] << 8 | L[6],
                        flags0: L[7] << 8 | L[8],
                        flags1: L[9] << 8 | L[10],
                        transformCode: L[11]
                      });
                      break;
                    case 65499:
                      const Y = (0, i.readUint16)(B, l);
                      l += 2;
                      const J = Y + l - 2;
                      let ie;
                      for (; l < J; ) {
                        const he = B[l++], ue = new Uint16Array(64);
                        if (he >> 4)
                          if (he >> 4 === 1)
                            for (z = 0; z < 64; z++)
                              ie = y[z], ue[ie] = (0, i.readUint16)(B, l), l += 2;
                          else
                            throw new v("DQT - invalid table spec");
                        else
                          for (z = 0; z < 64; z++)
                            ie = y[z], ue[ie] = B[l++];
                        O[he & 15] = ue;
                      }
                      break;
                    case 65472:
                    case 65473:
                    case 65474:
                      if (A)
                        throw new v("Only single frame JPEGs supported");
                      l += 2, A = {}, A.extended = K === 65473, A.progressive = K === 65474, A.precision = B[l++];
                      const q = (0, i.readUint16)(B, l);
                      l += 2, A.scanLines = R || q, A.samplesPerLine = (0, i.readUint16)(B, l), l += 2, A.components = [], A.componentIds = {};
                      const N = B[l++];
                      let Z = 0, E = 0;
                      for (W = 0; W < N; W++) {
                        const he = B[l], ue = B[l + 1] >> 4, fe = B[l + 1] & 15;
                        Z < ue && (Z = ue), E < fe && (E = fe);
                        const me = B[l + 2];
                        V = A.components.push({
                          h: ue,
                          v: fe,
                          quantizationId: me,
                          quantizationTable: null
                        }), A.componentIds[he] = V - 1, l += 3;
                      }
                      A.maxH = Z, A.maxV = E, b(A);
                      break;
                    case 65476:
                      const te = (0, i.readUint16)(B, l);
                      for (l += 2, W = 2; W < te; ) {
                        const he = B[l++], ue = new Uint8Array(16);
                        let fe = 0;
                        for (z = 0; z < 16; z++, l++)
                          fe += ue[z] = B[l];
                        const me = new Uint8Array(fe);
                        for (z = 0; z < fe; z++, l++)
                          me[z] = B[l];
                        W += 17 + fe, (he >> 4 ? U : G)[he & 15] = f(ue, me);
                      }
                      break;
                    case 65501:
                      l += 2, F = (0, i.readUint16)(B, l), l += 2;
                      break;
                    case 65498:
                      const re = ++T === 1 && !R;
                      l += 2;
                      const ee = B[l++], $ = [];
                      for (W = 0; W < ee; W++) {
                        const he = B[l++], ue = A.componentIds[he], fe = A.components[ue];
                        fe.index = he;
                        const me = B[l++];
                        fe.huffmanTableDC = G[me >> 4], fe.huffmanTableAC = U[me & 15], $.push(fe);
                      }
                      const k = B[l++], H = B[l++], ne = B[l++];
                      try {
                        const he = C(B, l, A, $, F, k, H, ne >> 4, ne & 15, re);
                        l += he;
                      } catch (he) {
                        if (he instanceof a)
                          return (0, t.warn)(`${he.message} -- attempting to re-parse the JPEG image.`), this.parse(B, {
                            dnlScanLines: he.scanLines
                          });
                        if (he instanceof e) {
                          (0, t.warn)(`${he.message} -- ignoring the rest of the image data.`);
                          break e;
                        }
                        throw he;
                      }
                      break;
                    case 65500:
                      l += 4;
                      break;
                    case 65535:
                      B[l] !== 255 && l--;
                      break;
                    default:
                      const ae = X(B, l - 2, l - 3);
                      if (ae && ae.invalid) {
                        (0, t.warn)("JpegImage.parse - unexpected data, current marker is: " + ae.invalid), l = ae.offset;
                        break;
                      }
                      if (!ae || l >= B.length - 1) {
                        (0, t.warn)("JpegImage.parse - reached the end of the image data without finding an EOI marker (0xFFD9).");
                        break e;
                      }
                      throw new v("JpegImage.parse - unknown marker: " + K.toString(16));
                  }
                  K = (0, i.readUint16)(B, l), l += 2;
                }
              this.width = A.samplesPerLine, this.height = A.scanLines, this.jfif = _, this.adobe = S, this.components = [];
              for (let W = 0, z = A.components.length; W < z; W++) {
                const V = A.components[W], L = O[V.quantizationId];
                L && (V.quantizationTable = L), this.components.push({
                  index: V.index,
                  output: w(A, V),
                  scaleX: V.h / A.maxH,
                  scaleY: V.v / A.maxV,
                  blocksPerLine: V.blocksPerLine,
                  blocksPerColumn: V.blocksPerColumn
                });
              }
              this.numComponents = this.components.length;
            }
            _getLinearizedBlockData(B, R, D = !1) {
              const b = this.width / B, l = this.height / R;
              let _, S, A, F, T, O, U, G, K, W, z = 0, V;
              const L = this.components.length, Y = B * R * L, J = new Uint8ClampedArray(Y), ie = new Uint32Array(B), q = 4294967288;
              let N;
              for (U = 0; U < L; U++) {
                if (_ = this.components[U], S = _.scaleX * b, A = _.scaleY * l, z = U, V = _.output, F = _.blocksPerLine + 1 << 3, S !== N) {
                  for (T = 0; T < B; T++)
                    G = 0 | T * S, ie[T] = (G & q) << 3 | G & 7;
                  N = S;
                }
                for (O = 0; O < R; O++)
                  for (G = 0 | O * A, W = F * (G & q) | (G & 7) << 3, T = 0; T < B; T++)
                    J[z] = V[W + ie[T]], z += L;
              }
              let Z = this._decodeTransform;
              if (!D && L === 4 && !Z && (Z = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255])), Z)
                for (U = 0; U < Y; )
                  for (G = 0, K = 0; G < L; G++, U++, K += 2)
                    J[U] = (J[U] * Z[K] >> 8) + Z[K + 1];
              return J;
            }
            get _isColorConversionNeeded() {
              return this.adobe ? !!this.adobe.transformCode : this.numComponents === 3 ? this._colorTransform === 0 ? !1 : !(this.components[0].index === 82 && this.components[1].index === 71 && this.components[2].index === 66) : this._colorTransform === 1;
            }
            _convertYccToRgb(B) {
              let R, D, b;
              for (let l = 0, _ = B.length; l < _; l += 3)
                R = B[l], D = B[l + 1], b = B[l + 2], B[l] = R - 179.456 + 1.402 * b, B[l + 1] = R + 135.459 - 0.344 * D - 0.714 * b, B[l + 2] = R - 226.816 + 1.772 * D;
              return B;
            }
            _convertYcckToRgb(B) {
              let R, D, b, l, _ = 0;
              for (let S = 0, A = B.length; S < A; S += 4)
                R = B[S], D = B[S + 1], b = B[S + 2], l = B[S + 3], B[_++] = -122.67195406894 + D * (-660635669420364e-19 * D + 437130475926232e-18 * b - 54080610064599e-18 * R + 48449797120281e-17 * l - 0.154362151871126) + b * (-957964378445773e-18 * b + 817076911346625e-18 * R - 0.00477271405408747 * l + 1.53380253221734) + R * (961250184130688e-18 * R - 0.00266257332283933 * l + 0.48357088451265) + l * (-336197177618394e-18 * l + 0.484791561490776), B[_++] = 107.268039397724 + D * (219927104525741e-19 * D - 640992018297945e-18 * b + 659397001245577e-18 * R + 426105652938837e-18 * l - 0.176491792462875) + b * (-778269941513683e-18 * b + 0.00130872261408275 * R + 770482631801132e-18 * l - 0.151051492775562) + R * (0.00126935368114843 * R - 0.00265090189010898 * l + 0.25802910206845) + l * (-318913117588328e-18 * l - 0.213742400323665), B[_++] = -20.810012546947 + D * (-570115196973677e-18 * D - 263409051004589e-19 * b + 0.0020741088115012 * R - 0.00288260236853442 * l + 0.814272968359295) + b * (-153496057440975e-19 * b - 132689043961446e-18 * R + 560833691242812e-18 * l - 0.195152027534049) + R * (0.00174418132927582 * R - 0.00255243321439347 * l + 0.116935020465145) + l * (-343531996510555e-18 * l + 0.24165260232407);
              return B.subarray(0, _);
            }
            _convertYcckToCmyk(B) {
              let R, D, b;
              for (let l = 0, _ = B.length; l < _; l += 4)
                R = B[l], D = B[l + 1], b = B[l + 2], B[l] = 434.456 - R - 1.402 * b, B[l + 1] = 119.541 - R + 0.344 * D + 0.714 * b, B[l + 2] = 481.816 - R - 1.772 * D;
              return B;
            }
            _convertCmykToRgb(B) {
              let R, D, b, l, _ = 0;
              for (let S = 0, A = B.length; S < A; S += 4)
                R = B[S], D = B[S + 1], b = B[S + 2], l = B[S + 3], B[_++] = 255 + R * (-6747147073602441e-20 * R + 8379262121013727e-19 * D + 2894718188643294e-19 * b + 0.003264231057537806 * l - 1.1185611867203937) + D * (26374107616089405e-21 * D - 8626949158638572e-20 * b - 2748769067499491e-19 * l - 0.02155688794978967) + b * (-3878099212869363e-20 * b - 3267808279485286e-19 * l + 0.0686742238595345) - l * (3361971776183937e-19 * l + 0.7430659151342254), B[_++] = 255 + R * (13596372813588848e-20 * R + 924537132573585e-18 * D + 10567359618683593e-20 * b + 4791864687436512e-19 * l - 0.3109689587515875) + D * (-23545346108370344e-20 * D + 2702845253534714e-19 * b + 0.0020200308977307156 * l - 0.7488052167015494) + b * (6834815998235662e-20 * b + 15168452363460973e-20 * l - 0.09751927774728933) - l * (3189131175883281e-19 * l + 0.7364883807733168), B[_++] = 255 + R * (13598650411385307e-21 * R + 12423956175490851e-20 * D + 4751985097583589e-19 * b - 36729317476630422e-22 * l - 0.05562186980264034) + D * (16141380598724676e-20 * D + 9692239130725186e-19 * b + 7782692450036253e-19 * l - 0.44015232367526463) + b * (5068882914068769e-22 * b + 0.0017778369011375071 * l - 0.7591454649749609) - l * (3435319965105553e-19 * l + 0.7063770186160144);
              return B.subarray(0, _);
            }
            getData({
              width: B,
              height: R,
              forceRGB: D = !1,
              isSourcePDF: b = !1
            }) {
              if (this.numComponents > 4)
                throw new v("Unsupported color mode");
              const l = this._getLinearizedBlockData(B, R, b);
              if (this.numComponents === 1 && D) {
                const _ = l.length, S = new Uint8ClampedArray(_ * 3);
                let A = 0;
                for (let F = 0; F < _; F++) {
                  const T = l[F];
                  S[A++] = T, S[A++] = T, S[A++] = T;
                }
                return S;
              } else {
                if (this.numComponents === 3 && this._isColorConversionNeeded)
                  return this._convertYccToRgb(l);
                if (this.numComponents === 4) {
                  if (this._isColorConversionNeeded)
                    return D ? this._convertYcckToRgb(l) : this._convertYcckToCmyk(l);
                  if (D)
                    return this._convertCmykToRgb(l);
                }
              }
              return l;
            }
          }
          u.JpegImage = M;
        },
        /* 29 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.JpxStream = void 0;
          var t = P(19), i = P(30), v = P(2);
          class a extends t.DecodeStream {
            constructor(y, r, h) {
              super(r), this.stream = y, this.dict = y.dict, this.maybeLength = r, this.params = h;
            }
            get bytes() {
              return (0, v.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
            }
            ensureBuffer(y) {
            }
            readBlock() {
              if (this.eof)
                return;
              const y = new i.JpxImage();
              y.parse(this.bytes);
              const r = y.width, h = y.height, g = y.componentsCount, d = y.tiles.length;
              if (d === 1)
                this.buffer = y.tiles[0].items;
              else {
                const c = new Uint8ClampedArray(r * h * g);
                for (let n = 0; n < d; n++) {
                  const o = y.tiles[n], x = o.width, f = o.height, m = o.left, C = o.top, p = o.items;
                  let w = 0, X = (r * C + m) * g;
                  const M = r * g, j = x * g;
                  for (let B = 0; B < f; B++) {
                    const R = p.subarray(w, w + j);
                    c.set(R, X), w += j, X += M;
                  }
                }
                this.buffer = c;
              }
              this.bufferLength = this.buffer.length, this.eof = !0;
            }
          }
          u.JpxStream = a;
        },
        /* 30 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.JpxImage = void 0;
          var t = P(2), i = P(6), v = P(26);
          class a extends t.BaseException {
            constructor(O) {
              super(`JPX error: ${O}`, "JpxError");
            }
          }
          const e = {
            LL: 0,
            LH: 1,
            HL: 1,
            HH: 2
          };
          class y {
            constructor() {
              this.failOnCorruptedImage = !1;
            }
            parse(O) {
              if ((0, i.readUint16)(O, 0) === 65359) {
                this.parseCodestream(O, 0, O.length);
                return;
              }
              const G = O.length;
              let K = 0;
              for (; K < G; ) {
                let W = 8, z = (0, i.readUint32)(O, K);
                const V = (0, i.readUint32)(O, K + 4);
                if (K += W, z === 1 && (z = (0, i.readUint32)(O, K) * 4294967296 + (0, i.readUint32)(O, K + 4), K += 8, W += 8), z === 0 && (z = G - K + W), z < W)
                  throw new a("Invalid box field size");
                const L = z - W;
                let Y = !0;
                switch (V) {
                  case 1785737832:
                    Y = !1;
                    break;
                  case 1668246642:
                    const J = O[K];
                    if (J === 1) {
                      const q = (0, i.readUint32)(O, K + 3);
                      switch (q) {
                        case 16:
                        case 17:
                        case 18:
                          break;
                        default:
                          (0, t.warn)("Unknown colorspace " + q);
                          break;
                      }
                    } else
                      J === 2 && (0, t.info)("ICC profile not supported");
                    break;
                  case 1785737827:
                    this.parseCodestream(O, K, K + L);
                    break;
                  case 1783636e3:
                    (0, i.readUint32)(O, K) !== 218793738 && (0, t.warn)("Invalid JP2 signature");
                    break;
                  case 1783634458:
                  case 1718909296:
                  case 1920099697:
                  case 1919251232:
                  case 1768449138:
                    break;
                  default:
                    const ie = String.fromCharCode(V >> 24 & 255, V >> 16 & 255, V >> 8 & 255, V & 255);
                    (0, t.warn)(`Unsupported header type ${V} (${ie}).`);
                    break;
                }
                Y && (K += L);
              }
            }
            parseImageProperties(O) {
              let U = O.getByte();
              for (; U >= 0; ) {
                const G = U;
                if (U = O.getByte(), (G << 8 | U) === 65361) {
                  O.skip(4);
                  const W = O.getInt32() >>> 0, z = O.getInt32() >>> 0, V = O.getInt32() >>> 0, L = O.getInt32() >>> 0;
                  O.skip(16);
                  const Y = O.getUint16();
                  this.width = W - V, this.height = z - L, this.componentsCount = Y, this.bitsPerComponent = 8;
                  return;
                }
              }
              throw new a("No size marker found in JPX stream");
            }
            parseCodestream(O, U, G) {
              const K = {};
              let W = !1;
              try {
                let z = U;
                for (; z + 1 < G; ) {
                  const V = (0, i.readUint16)(O, z);
                  z += 2;
                  let L = 0, Y, J, ie, q, N, Z;
                  switch (V) {
                    case 65359:
                      K.mainHeader = !0;
                      break;
                    case 65497:
                      break;
                    case 65361:
                      L = (0, i.readUint16)(O, z);
                      const E = {};
                      E.Xsiz = (0, i.readUint32)(O, z + 4), E.Ysiz = (0, i.readUint32)(O, z + 8), E.XOsiz = (0, i.readUint32)(O, z + 12), E.YOsiz = (0, i.readUint32)(O, z + 16), E.XTsiz = (0, i.readUint32)(O, z + 20), E.YTsiz = (0, i.readUint32)(O, z + 24), E.XTOsiz = (0, i.readUint32)(O, z + 28), E.YTOsiz = (0, i.readUint32)(O, z + 32);
                      const te = (0, i.readUint16)(O, z + 36);
                      E.Csiz = te;
                      const re = [];
                      Y = z + 38;
                      for (let ue = 0; ue < te; ue++) {
                        const fe = {
                          precision: (O[Y] & 127) + 1,
                          isSigned: !!(O[Y] & 128),
                          XRsiz: O[Y + 1],
                          YRsiz: O[Y + 2]
                        };
                        Y += 3, r(fe, E), re.push(fe);
                      }
                      K.SIZ = E, K.components = re, h(K, re), K.QCC = [], K.COC = [];
                      break;
                    case 65372:
                      L = (0, i.readUint16)(O, z);
                      const ee = {};
                      switch (Y = z + 2, J = O[Y++], J & 31) {
                        case 0:
                          q = 8, N = !0;
                          break;
                        case 1:
                          q = 16, N = !1;
                          break;
                        case 2:
                          q = 16, N = !0;
                          break;
                        default:
                          throw new Error("Invalid SQcd value " + J);
                      }
                      for (ee.noQuantization = q === 8, ee.scalarExpounded = N, ee.guardBits = J >> 5, ie = []; Y < L + z; ) {
                        const ue = {};
                        q === 8 ? (ue.epsilon = O[Y++] >> 3, ue.mu = 0) : (ue.epsilon = O[Y] >> 3, ue.mu = (O[Y] & 7) << 8 | O[Y + 1], Y += 2), ie.push(ue);
                      }
                      ee.SPqcds = ie, K.mainHeader ? K.QCD = ee : (K.currentTile.QCD = ee, K.currentTile.QCC = []);
                      break;
                    case 65373:
                      L = (0, i.readUint16)(O, z);
                      const $ = {};
                      Y = z + 2;
                      let k;
                      switch (K.SIZ.Csiz < 257 ? k = O[Y++] : (k = (0, i.readUint16)(O, Y), Y += 2), J = O[Y++], J & 31) {
                        case 0:
                          q = 8, N = !0;
                          break;
                        case 1:
                          q = 16, N = !1;
                          break;
                        case 2:
                          q = 16, N = !0;
                          break;
                        default:
                          throw new Error("Invalid SQcd value " + J);
                      }
                      for ($.noQuantization = q === 8, $.scalarExpounded = N, $.guardBits = J >> 5, ie = []; Y < L + z; ) {
                        const ue = {};
                        q === 8 ? (ue.epsilon = O[Y++] >> 3, ue.mu = 0) : (ue.epsilon = O[Y] >> 3, ue.mu = (O[Y] & 7) << 8 | O[Y + 1], Y += 2), ie.push(ue);
                      }
                      $.SPqcds = ie, K.mainHeader ? K.QCC[k] = $ : K.currentTile.QCC[k] = $;
                      break;
                    case 65362:
                      L = (0, i.readUint16)(O, z);
                      const H = {};
                      Y = z + 2;
                      const ne = O[Y++];
                      H.entropyCoderWithCustomPrecincts = !!(ne & 1), H.sopMarkerUsed = !!(ne & 2), H.ephMarkerUsed = !!(ne & 4), H.progressionOrder = O[Y++], H.layersCount = (0, i.readUint16)(O, Y), Y += 2, H.multipleComponentTransform = O[Y++], H.decompositionLevelsCount = O[Y++], H.xcb = (O[Y++] & 15) + 2, H.ycb = (O[Y++] & 15) + 2;
                      const ae = O[Y++];
                      if (H.selectiveArithmeticCodingBypass = !!(ae & 1), H.resetContextProbabilities = !!(ae & 2), H.terminationOnEachCodingPass = !!(ae & 4), H.verticallyStripe = !!(ae & 8), H.predictableTermination = !!(ae & 16), H.segmentationSymbolUsed = !!(ae & 32), H.reversibleTransformation = O[Y++], H.entropyCoderWithCustomPrecincts) {
                        const ue = [];
                        for (; Y < L + z; ) {
                          const fe = O[Y++];
                          ue.push({
                            PPx: fe & 15,
                            PPy: fe >> 4
                          });
                        }
                        H.precinctsSizes = ue;
                      }
                      const he = [];
                      H.selectiveArithmeticCodingBypass && he.push("selectiveArithmeticCodingBypass"), H.terminationOnEachCodingPass && he.push("terminationOnEachCodingPass"), H.verticallyStripe && he.push("verticallyStripe"), H.predictableTermination && he.push("predictableTermination"), he.length > 0 && (W = !0, (0, t.warn)(`JPX: Unsupported COD options (${he.join(", ")}).`)), K.mainHeader ? K.COD = H : (K.currentTile.COD = H, K.currentTile.COC = []);
                      break;
                    case 65424:
                      L = (0, i.readUint16)(O, z), Z = {}, Z.index = (0, i.readUint16)(O, z + 2), Z.length = (0, i.readUint32)(O, z + 4), Z.dataEnd = Z.length + z - 2, Z.partIndex = O[z + 8], Z.partsCount = O[z + 9], K.mainHeader = !1, Z.partIndex === 0 && (Z.COD = K.COD, Z.COC = K.COC.slice(0), Z.QCD = K.QCD, Z.QCC = K.QCC.slice(0)), K.currentTile = Z;
                      break;
                    case 65427:
                      Z = K.currentTile, Z.partIndex === 0 && (D(K, Z.index), X(K)), L = Z.dataEnd - z, M(K, O, z, L);
                      break;
                    case 65363:
                      (0, t.warn)("JPX: Codestream code 0xFF53 (COC) is not implemented.");
                    case 65365:
                    case 65367:
                    case 65368:
                    case 65380:
                      L = (0, i.readUint16)(O, z);
                      break;
                    default:
                      throw new Error("Unknown codestream code: " + V.toString(16));
                  }
                  z += L;
                }
              } catch (z) {
                if (W || this.failOnCorruptedImage)
                  throw new a(z.message);
                (0, t.warn)(`JPX: Trying to recover from: "${z.message}".`);
              }
              this.tiles = R(K), this.width = K.SIZ.Xsiz - K.SIZ.XOsiz, this.height = K.SIZ.Ysiz - K.SIZ.YOsiz, this.componentsCount = K.SIZ.Csiz;
            }
          }
          u.JpxImage = y;
          function r(T, O) {
            T.x0 = Math.ceil(O.XOsiz / T.XRsiz), T.x1 = Math.ceil(O.Xsiz / T.XRsiz), T.y0 = Math.ceil(O.YOsiz / T.YRsiz), T.y1 = Math.ceil(O.Ysiz / T.YRsiz), T.width = T.x1 - T.x0, T.height = T.y1 - T.y0;
          }
          function h(T, O) {
            const U = T.SIZ, G = [];
            let K;
            const W = Math.ceil((U.Xsiz - U.XTOsiz) / U.XTsiz), z = Math.ceil((U.Ysiz - U.YTOsiz) / U.YTsiz);
            for (let L = 0; L < z; L++)
              for (let Y = 0; Y < W; Y++)
                K = {}, K.tx0 = Math.max(U.XTOsiz + Y * U.XTsiz, U.XOsiz), K.ty0 = Math.max(U.YTOsiz + L * U.YTsiz, U.YOsiz), K.tx1 = Math.min(U.XTOsiz + (Y + 1) * U.XTsiz, U.Xsiz), K.ty1 = Math.min(U.YTOsiz + (L + 1) * U.YTsiz, U.Ysiz), K.width = K.tx1 - K.tx0, K.height = K.ty1 - K.ty0, K.components = [], G.push(K);
            T.tiles = G;
            const V = U.Csiz;
            for (let L = 0, Y = V; L < Y; L++) {
              const J = O[L];
              for (let ie = 0, q = G.length; ie < q; ie++) {
                const N = {};
                K = G[ie], N.tcx0 = Math.ceil(K.tx0 / J.XRsiz), N.tcy0 = Math.ceil(K.ty0 / J.YRsiz), N.tcx1 = Math.ceil(K.tx1 / J.XRsiz), N.tcy1 = Math.ceil(K.ty1 / J.YRsiz), N.width = N.tcx1 - N.tcx0, N.height = N.tcy1 - N.tcy0, K.components[L] = N;
              }
            }
          }
          function g(T, O, U) {
            const G = O.codingStyleParameters, K = {};
            return G.entropyCoderWithCustomPrecincts ? (K.PPx = G.precinctsSizes[U].PPx, K.PPy = G.precinctsSizes[U].PPy) : (K.PPx = 15, K.PPy = 15), K.xcb_ = U > 0 ? Math.min(G.xcb, K.PPx - 1) : Math.min(G.xcb, K.PPx), K.ycb_ = U > 0 ? Math.min(G.ycb, K.PPy - 1) : Math.min(G.ycb, K.PPy), K;
          }
          function d(T, O, U) {
            const G = 1 << U.PPx, K = 1 << U.PPy, W = O.resLevel === 0, z = 1 << U.PPx + (W ? 0 : -1), V = 1 << U.PPy + (W ? 0 : -1), L = O.trx1 > O.trx0 ? Math.ceil(O.trx1 / G) - Math.floor(O.trx0 / G) : 0, Y = O.try1 > O.try0 ? Math.ceil(O.try1 / K) - Math.floor(O.try0 / K) : 0, J = L * Y;
            O.precinctParameters = {
              precinctWidth: G,
              precinctHeight: K,
              numprecinctswide: L,
              numprecinctshigh: Y,
              numprecincts: J,
              precinctWidthInSubband: z,
              precinctHeightInSubband: V
            };
          }
          function c(T, O, U) {
            const G = U.xcb_, K = U.ycb_, W = 1 << G, z = 1 << K, V = O.tbx0 >> G, L = O.tby0 >> K, Y = O.tbx1 + W - 1 >> G, J = O.tby1 + z - 1 >> K, ie = O.resolution.precinctParameters, q = [], N = [];
            let Z, E, te, re;
            for (E = L; E < J; E++)
              for (Z = V; Z < Y; Z++) {
                te = {
                  cbx: Z,
                  cby: E,
                  tbx0: W * Z,
                  tby0: z * E,
                  tbx1: W * (Z + 1),
                  tby1: z * (E + 1)
                }, te.tbx0_ = Math.max(O.tbx0, te.tbx0), te.tby0_ = Math.max(O.tby0, te.tby0), te.tbx1_ = Math.min(O.tbx1, te.tbx1), te.tby1_ = Math.min(O.tby1, te.tby1);
                const ee = Math.floor((te.tbx0_ - O.tbx0) / ie.precinctWidthInSubband), $ = Math.floor((te.tby0_ - O.tby0) / ie.precinctHeightInSubband);
                if (re = ee + $ * ie.numprecinctswide, te.precinctNumber = re, te.subbandType = O.type, te.Lblock = 3, te.tbx1_ <= te.tbx0_ || te.tby1_ <= te.tby0_)
                  continue;
                q.push(te);
                let k = N[re];
                k !== void 0 ? (Z < k.cbxMin ? k.cbxMin = Z : Z > k.cbxMax && (k.cbxMax = Z), E < k.cbyMin ? k.cbxMin = E : E > k.cbyMax && (k.cbyMax = E)) : N[re] = k = {
                  cbxMin: Z,
                  cbyMin: E,
                  cbxMax: Z,
                  cbyMax: E
                }, te.precinct = k;
              }
            O.codeblockParameters = {
              codeblockWidth: G,
              codeblockHeight: K,
              numcodeblockwide: Y - V + 1,
              numcodeblockhigh: J - L + 1
            }, O.codeblocks = q, O.precincts = N;
          }
          function n(T, O, U) {
            const G = [], K = T.subbands;
            for (let W = 0, z = K.length; W < z; W++) {
              const L = K[W].codeblocks;
              for (let Y = 0, J = L.length; Y < J; Y++) {
                const ie = L[Y];
                ie.precinctNumber === O && G.push(ie);
              }
            }
            return {
              layerNumber: U,
              codeblocks: G
            };
          }
          function o(T) {
            const O = T.SIZ, U = T.currentTile.index, G = T.tiles[U], K = G.codingStyleDefaultParameters.layersCount, W = O.Csiz;
            let z = 0;
            for (let ie = 0; ie < W; ie++)
              z = Math.max(z, G.components[ie].codingStyleParameters.decompositionLevelsCount);
            let V = 0, L = 0, Y = 0, J = 0;
            this.nextPacket = function() {
              for (; V < K; V++) {
                for (; L <= z; L++) {
                  for (; Y < W; Y++) {
                    const q = G.components[Y];
                    if (L > q.codingStyleParameters.decompositionLevelsCount)
                      continue;
                    const N = q.resolutions[L], Z = N.precinctParameters.numprecincts;
                    for (; J < Z; ) {
                      const E = n(N, J, V);
                      return J++, E;
                    }
                    J = 0;
                  }
                  Y = 0;
                }
                L = 0;
              }
              throw new a("Out of packets");
            };
          }
          function x(T) {
            const O = T.SIZ, U = T.currentTile.index, G = T.tiles[U], K = G.codingStyleDefaultParameters.layersCount, W = O.Csiz;
            let z = 0;
            for (let ie = 0; ie < W; ie++)
              z = Math.max(z, G.components[ie].codingStyleParameters.decompositionLevelsCount);
            let V = 0, L = 0, Y = 0, J = 0;
            this.nextPacket = function() {
              for (; V <= z; V++) {
                for (; L < K; L++) {
                  for (; Y < W; Y++) {
                    const q = G.components[Y];
                    if (V > q.codingStyleParameters.decompositionLevelsCount)
                      continue;
                    const N = q.resolutions[V], Z = N.precinctParameters.numprecincts;
                    for (; J < Z; ) {
                      const E = n(N, J, L);
                      return J++, E;
                    }
                    J = 0;
                  }
                  Y = 0;
                }
                L = 0;
              }
              throw new a("Out of packets");
            };
          }
          function f(T) {
            const O = T.SIZ, U = T.currentTile.index, G = T.tiles[U], K = G.codingStyleDefaultParameters.layersCount, W = O.Csiz;
            let z, V, L, Y, J = 0;
            for (L = 0; L < W; L++) {
              const q = G.components[L];
              J = Math.max(J, q.codingStyleParameters.decompositionLevelsCount);
            }
            const ie = new Int32Array(J + 1);
            for (V = 0; V <= J; ++V) {
              let q = 0;
              for (L = 0; L < W; ++L) {
                const N = G.components[L].resolutions;
                V < N.length && (q = Math.max(q, N[V].precinctParameters.numprecincts));
              }
              ie[V] = q;
            }
            z = 0, V = 0, L = 0, Y = 0, this.nextPacket = function() {
              for (; V <= J; V++) {
                for (; Y < ie[V]; Y++) {
                  for (; L < W; L++) {
                    const N = G.components[L];
                    if (V > N.codingStyleParameters.decompositionLevelsCount)
                      continue;
                    const Z = N.resolutions[V], E = Z.precinctParameters.numprecincts;
                    if (!(Y >= E)) {
                      for (; z < K; ) {
                        const te = n(Z, Y, z);
                        return z++, te;
                      }
                      z = 0;
                    }
                  }
                  L = 0;
                }
                Y = 0;
              }
              throw new a("Out of packets");
            };
          }
          function m(T) {
            const O = T.SIZ, U = T.currentTile.index, G = T.tiles[U], K = G.codingStyleDefaultParameters.layersCount, W = O.Csiz, z = w(G), V = z;
            let L = 0, Y = 0, J = 0, ie = 0, q = 0;
            this.nextPacket = function() {
              for (; q < V.maxNumHigh; q++) {
                for (; ie < V.maxNumWide; ie++) {
                  for (; J < W; J++) {
                    const Z = G.components[J], E = Z.codingStyleParameters.decompositionLevelsCount;
                    for (; Y <= E; Y++) {
                      const te = Z.resolutions[Y], re = z.components[J].resolutions[Y], ee = p(ie, q, re, V, te);
                      if (ee !== null) {
                        for (; L < K; ) {
                          const $ = n(te, ee, L);
                          return L++, $;
                        }
                        L = 0;
                      }
                    }
                    Y = 0;
                  }
                  J = 0;
                }
                ie = 0;
              }
              throw new a("Out of packets");
            };
          }
          function C(T) {
            const O = T.SIZ, U = T.currentTile.index, G = T.tiles[U], K = G.codingStyleDefaultParameters.layersCount, W = O.Csiz, z = w(G);
            let V = 0, L = 0, Y = 0, J = 0, ie = 0;
            this.nextPacket = function() {
              for (; Y < W; ++Y) {
                const N = G.components[Y], Z = z.components[Y], E = N.codingStyleParameters.decompositionLevelsCount;
                for (; ie < Z.maxNumHigh; ie++) {
                  for (; J < Z.maxNumWide; J++) {
                    for (; L <= E; L++) {
                      const te = N.resolutions[L], re = Z.resolutions[L], ee = p(J, ie, re, Z, te);
                      if (ee !== null) {
                        for (; V < K; ) {
                          const $ = n(te, ee, V);
                          return V++, $;
                        }
                        V = 0;
                      }
                    }
                    L = 0;
                  }
                  J = 0;
                }
                ie = 0;
              }
              throw new a("Out of packets");
            };
          }
          function p(T, O, U, G, K) {
            const W = T * G.minWidth, z = O * G.minHeight;
            if (W % U.width !== 0 || z % U.height !== 0)
              return null;
            const V = z / U.width * K.precinctParameters.numprecinctswide;
            return W / U.height + V;
          }
          function w(T) {
            const O = T.components.length;
            let U = Number.MAX_VALUE, G = Number.MAX_VALUE, K = 0, W = 0;
            const z = new Array(O);
            for (let V = 0; V < O; V++) {
              const L = T.components[V], Y = L.codingStyleParameters.decompositionLevelsCount, J = new Array(Y + 1);
              let ie = Number.MAX_VALUE, q = Number.MAX_VALUE, N = 0, Z = 0, E = 1;
              for (let te = Y; te >= 0; --te) {
                const re = L.resolutions[te], ee = E * re.precinctParameters.precinctWidth, $ = E * re.precinctParameters.precinctHeight;
                ie = Math.min(ie, ee), q = Math.min(q, $), N = Math.max(N, re.precinctParameters.numprecinctswide), Z = Math.max(Z, re.precinctParameters.numprecinctshigh), J[te] = {
                  width: ee,
                  height: $
                }, E <<= 1;
              }
              U = Math.min(U, ie), G = Math.min(G, q), K = Math.max(K, N), W = Math.max(W, Z), z[V] = {
                resolutions: J,
                minWidth: ie,
                minHeight: q,
                maxNumWide: N,
                maxNumHigh: Z
              };
            }
            return {
              components: z,
              minWidth: U,
              minHeight: G,
              maxNumWide: K,
              maxNumHigh: W
            };
          }
          function X(T) {
            const O = T.SIZ, U = T.currentTile.index, G = T.tiles[U], K = O.Csiz;
            for (let z = 0; z < K; z++) {
              const V = G.components[z], L = V.codingStyleParameters.decompositionLevelsCount, Y = [], J = [];
              for (let ie = 0; ie <= L; ie++) {
                const q = g(T, V, ie), N = {}, Z = 1 << L - ie;
                N.trx0 = Math.ceil(V.tcx0 / Z), N.try0 = Math.ceil(V.tcy0 / Z), N.trx1 = Math.ceil(V.tcx1 / Z), N.try1 = Math.ceil(V.tcy1 / Z), N.resLevel = ie, d(T, N, q), Y.push(N);
                let E;
                if (ie === 0)
                  E = {}, E.type = "LL", E.tbx0 = Math.ceil(V.tcx0 / Z), E.tby0 = Math.ceil(V.tcy0 / Z), E.tbx1 = Math.ceil(V.tcx1 / Z), E.tby1 = Math.ceil(V.tcy1 / Z), E.resolution = N, c(T, E, q), J.push(E), N.subbands = [E];
                else {
                  const te = 1 << L - ie + 1, re = [];
                  E = {}, E.type = "HL", E.tbx0 = Math.ceil(V.tcx0 / te - 0.5), E.tby0 = Math.ceil(V.tcy0 / te), E.tbx1 = Math.ceil(V.tcx1 / te - 0.5), E.tby1 = Math.ceil(V.tcy1 / te), E.resolution = N, c(T, E, q), J.push(E), re.push(E), E = {}, E.type = "LH", E.tbx0 = Math.ceil(V.tcx0 / te), E.tby0 = Math.ceil(V.tcy0 / te - 0.5), E.tbx1 = Math.ceil(V.tcx1 / te), E.tby1 = Math.ceil(V.tcy1 / te - 0.5), E.resolution = N, c(T, E, q), J.push(E), re.push(E), E = {}, E.type = "HH", E.tbx0 = Math.ceil(V.tcx0 / te - 0.5), E.tby0 = Math.ceil(V.tcy0 / te - 0.5), E.tbx1 = Math.ceil(V.tcx1 / te - 0.5), E.tby1 = Math.ceil(V.tcy1 / te - 0.5), E.resolution = N, c(T, E, q), J.push(E), re.push(E), N.subbands = re;
                }
              }
              V.resolutions = Y, V.subbands = J;
            }
            const W = G.codingStyleDefaultParameters.progressionOrder;
            switch (W) {
              case 0:
                G.packetsIterator = new o(T);
                break;
              case 1:
                G.packetsIterator = new x(T);
                break;
              case 2:
                G.packetsIterator = new f(T);
                break;
              case 3:
                G.packetsIterator = new m(T);
                break;
              case 4:
                G.packetsIterator = new C(T);
                break;
              default:
                throw new a(`Unsupported progression order ${W}`);
            }
          }
          function M(T, O, U, G) {
            let K = 0, W, z = 0, V = !1;
            function L(ee) {
              for (; z < ee; ) {
                const $ = O[U + K];
                K++, V ? (W = W << 7 | $, z += 7, V = !1) : (W = W << 8 | $, z += 8), $ === 255 && (V = !0);
              }
              return z -= ee, W >>> z & (1 << ee) - 1;
            }
            function Y(ee) {
              return O[U + K - 1] === 255 && O[U + K] === ee ? (J(1), !0) : O[U + K] === 255 && O[U + K + 1] === ee ? (J(2), !0) : !1;
            }
            function J(ee) {
              K += ee;
            }
            function ie() {
              z = 0, V && (K++, V = !1);
            }
            function q() {
              if (L(1) === 0)
                return 1;
              if (L(1) === 0)
                return 2;
              let ee = L(2);
              return ee < 3 ? ee + 3 : (ee = L(5), ee < 31 ? ee + 6 : (ee = L(7), ee + 37));
            }
            const N = T.currentTile.index, Z = T.tiles[N], E = T.COD.sopMarkerUsed, te = T.COD.ephMarkerUsed, re = Z.packetsIterator;
            for (; K < G; ) {
              ie(), E && Y(145) && J(4);
              const ee = re.nextPacket();
              if (!L(1))
                continue;
              const $ = ee.layerNumber, k = [];
              let H;
              for (let ne = 0, ae = ee.codeblocks.length; ne < ae; ne++) {
                H = ee.codeblocks[ne];
                let he = H.precinct;
                const ue = H.cbx - he.cbxMin, fe = H.cby - he.cbyMin;
                let me = !1, Fe = !1, we, Ae;
                if (H.included !== void 0)
                  me = !!L(1);
                else {
                  he = H.precinct;
                  let Se;
                  if (he.inclusionTree !== void 0)
                    Se = he.inclusionTree;
                  else {
                    const be = he.cbxMax - he.cbxMin + 1, Le = he.cbyMax - he.cbyMin + 1;
                    Se = new l(be, Le, $), Ae = new b(be, Le), he.inclusionTree = Se, he.zeroBitPlanesTree = Ae;
                    for (let ze = 0; ze < $; ze++)
                      if (L(1) !== 0)
                        throw new a("Invalid tag tree");
                  }
                  if (Se.reset(ue, fe, $))
                    for (; ; )
                      if (L(1)) {
                        if (we = !Se.nextLevel(), we) {
                          H.included = !0, me = Fe = !0;
                          break;
                        }
                      } else {
                        Se.incrementValue($);
                        break;
                      }
                }
                if (!me)
                  continue;
                if (Fe) {
                  for (Ae = he.zeroBitPlanesTree, Ae.reset(ue, fe); ; )
                    if (L(1)) {
                      if (we = !Ae.nextLevel(), we)
                        break;
                    } else
                      Ae.incrementValue();
                  H.zeroBitPlanes = Ae.value;
                }
                const De = q();
                for (; L(1); )
                  H.Lblock++;
                const xe = (0, i.log2)(De), Te = (De < 1 << xe ? xe - 1 : xe) + H.Lblock, ve = L(Te);
                k.push({
                  codeblock: H,
                  codingpasses: De,
                  dataLength: ve
                });
              }
              for (ie(), te && Y(146); k.length > 0; ) {
                const ne = k.shift();
                H = ne.codeblock, H.data === void 0 && (H.data = []), H.data.push({
                  data: O,
                  start: U + K,
                  end: U + K + ne.dataLength,
                  codingpasses: ne.codingpasses
                }), K += ne.dataLength;
              }
            }
            return K;
          }
          function j(T, O, U, G, K, W, z, V, L) {
            const Y = G.tbx0, J = G.tby0, ie = G.tbx1 - G.tbx0, q = G.codeblocks, N = G.type.charAt(0) === "H" ? 1 : 0, Z = G.type.charAt(1) === "H" ? O : 0;
            for (let E = 0, te = q.length; E < te; ++E) {
              const re = q[E], ee = re.tbx1_ - re.tbx0_, $ = re.tby1_ - re.tby0_;
              if (ee === 0 || $ === 0 || re.data === void 0)
                continue;
              const k = new _(ee, $, re.subbandType, re.zeroBitPlanes, W);
              let H = 2;
              const ne = re.data;
              let ae = 0, he = 0, ue, fe, me;
              for (ue = 0, fe = ne.length; ue < fe; ue++)
                me = ne[ue], ae += me.end - me.start, he += me.codingpasses;
              const Fe = new Uint8Array(ae);
              let we = 0;
              for (ue = 0, fe = ne.length; ue < fe; ue++) {
                me = ne[ue];
                const Ue = me.data.subarray(me.start, me.end);
                Fe.set(Ue, we), we += Ue.length;
              }
              const Ae = new v.ArithmeticDecoder(Fe, 0, ae);
              for (k.setDecoder(Ae), ue = 0; ue < he; ue++) {
                switch (H) {
                  case 0:
                    k.runSignificancePropagationPass();
                    break;
                  case 1:
                    k.runMagnitudeRefinementPass();
                    break;
                  case 2:
                    k.runCleanupPass(), V && k.checkSegmentationSymbol();
                    break;
                }
                L && k.reset(), H = (H + 1) % 3;
              }
              let De = re.tbx0_ - Y + (re.tby0_ - J) * ie;
              const xe = k.coefficentsSign, Te = k.coefficentsMagnitude, ve = k.bitsDecoded, Se = z ? 0 : 0.5;
              let be, Le, ze;
              we = 0;
              const nt = G.type !== "LL";
              for (ue = 0; ue < $; ue++) {
                const Oe = 2 * (De / ie | 0) * (O - ie) + N + Z;
                for (be = 0; be < ee; be++) {
                  if (Le = Te[we], Le !== 0) {
                    Le = (Le + Se) * K, xe[we] !== 0 && (Le = -Le), ze = ve[we];
                    const _e = nt ? Oe + (De << 1) : De;
                    z && ze >= W ? T[_e] = Le : T[_e] = Le * (1 << W - ze);
                  }
                  De++, we++;
                }
                De += ie - ee;
              }
            }
          }
          function B(T, O, U) {
            const G = O.components[U], K = G.codingStyleParameters, W = G.quantizationParameters, z = K.decompositionLevelsCount, V = W.SPqcds, L = W.scalarExpounded, Y = W.guardBits, J = K.segmentationSymbolUsed, ie = K.resetContextProbabilities, q = T.components[U].precision, N = K.reversibleTransformation, Z = N ? new F() : new A(), E = [];
            let te = 0;
            for (let ee = 0; ee <= z; ee++) {
              const $ = G.resolutions[ee], k = $.trx1 - $.trx0, H = $.try1 - $.try0, ne = new Float32Array(k * H);
              for (let ae = 0, he = $.subbands.length; ae < he; ae++) {
                let ue, fe;
                L ? (ue = V[te].mu, fe = V[te].epsilon, te++) : (ue = V[0].mu, fe = V[0].epsilon + (ee > 0 ? 1 - ee : 0));
                const me = $.subbands[ae], Fe = e[me.type], we = N ? 1 : 2 ** (q + Fe - fe) * (1 + ue / 2048), Ae = Y + fe - 1;
                j(ne, k, H, me, we, Ae, N, J, ie);
              }
              E.push({
                width: k,
                height: H,
                items: ne
              });
            }
            const re = Z.calculate(E, G.tcx0, G.tcy0);
            return {
              left: G.tcx0,
              top: G.tcy0,
              width: re.width,
              height: re.height,
              items: re.items
            };
          }
          function R(T) {
            const O = T.SIZ, U = T.components, G = O.Csiz, K = [];
            for (let W = 0, z = T.tiles.length; W < z; W++) {
              const V = T.tiles[W], L = [];
              for (let k = 0; k < G; k++)
                L[k] = B(T, V, k);
              const Y = L[0], J = new Uint8ClampedArray(Y.items.length * G), ie = {
                left: Y.left,
                top: Y.top,
                width: Y.width,
                height: Y.height,
                items: J
              };
              let q, N, Z = 0, E, te, re, ee, $;
              if (V.codingStyleDefaultParameters.multipleComponentTransform) {
                const k = G === 4, H = L[0].items, ne = L[1].items, ae = L[2].items, he = k ? L[3].items : null;
                q = U[0].precision - 8, N = (128 << q) + 0.5;
                const ue = V.components[0], fe = G - 3;
                if (te = H.length, ue.codingStyleParameters.reversibleTransformation)
                  for (E = 0; E < te; E++, Z += fe) {
                    re = H[E] + N, ee = ne[E], $ = ae[E];
                    const me = re - ($ + ee >> 2);
                    J[Z++] = me + $ >> q, J[Z++] = me >> q, J[Z++] = me + ee >> q;
                  }
                else
                  for (E = 0; E < te; E++, Z += fe)
                    re = H[E] + N, ee = ne[E], $ = ae[E], J[Z++] = re + 1.402 * $ >> q, J[Z++] = re - 0.34413 * ee - 0.71414 * $ >> q, J[Z++] = re + 1.772 * ee >> q;
                if (k)
                  for (E = 0, Z = 3; E < te; E++, Z += 4)
                    J[Z] = he[E] + N >> q;
              } else
                for (let k = 0; k < G; k++) {
                  const H = L[k].items;
                  for (q = U[k].precision - 8, N = (128 << q) + 0.5, Z = k, E = 0, te = H.length; E < te; E++)
                    J[Z] = H[E] + N >> q, Z += G;
                }
              K.push(ie);
            }
            return K;
          }
          function D(T, O) {
            const G = T.SIZ.Csiz, K = T.tiles[O];
            for (let W = 0; W < G; W++) {
              const z = K.components[W], V = T.currentTile.QCC[W] !== void 0 ? T.currentTile.QCC[W] : T.currentTile.QCD;
              z.quantizationParameters = V;
              const L = T.currentTile.COC[W] !== void 0 ? T.currentTile.COC[W] : T.currentTile.COD;
              z.codingStyleParameters = L;
            }
            K.codingStyleDefaultParameters = T.currentTile.COD;
          }
          class b {
            constructor(O, U) {
              const G = (0, i.log2)(Math.max(O, U)) + 1;
              this.levels = [];
              for (let K = 0; K < G; K++) {
                const W = {
                  width: O,
                  height: U,
                  items: []
                };
                this.levels.push(W), O = Math.ceil(O / 2), U = Math.ceil(U / 2);
              }
            }
            reset(O, U) {
              let G = 0, K = 0, W;
              for (; G < this.levels.length; ) {
                W = this.levels[G];
                const z = O + U * W.width;
                if (W.items[z] !== void 0) {
                  K = W.items[z];
                  break;
                }
                W.index = z, O >>= 1, U >>= 1, G++;
              }
              G--, W = this.levels[G], W.items[W.index] = K, this.currentLevel = G, delete this.value;
            }
            incrementValue() {
              const O = this.levels[this.currentLevel];
              O.items[O.index]++;
            }
            nextLevel() {
              let O = this.currentLevel, U = this.levels[O];
              const G = U.items[U.index];
              return O--, O < 0 ? (this.value = G, !1) : (this.currentLevel = O, U = this.levels[O], U.items[U.index] = G, !0);
            }
          }
          class l {
            constructor(O, U, G) {
              const K = (0, i.log2)(Math.max(O, U)) + 1;
              this.levels = [];
              for (let W = 0; W < K; W++) {
                const z = new Uint8Array(O * U);
                for (let L = 0, Y = z.length; L < Y; L++)
                  z[L] = G;
                const V = {
                  width: O,
                  height: U,
                  items: z
                };
                this.levels.push(V), O = Math.ceil(O / 2), U = Math.ceil(U / 2);
              }
            }
            reset(O, U, G) {
              let K = 0;
              for (; K < this.levels.length; ) {
                const W = this.levels[K], z = O + U * W.width;
                W.index = z;
                const V = W.items[z];
                if (V === 255)
                  break;
                if (V > G)
                  return this.currentLevel = K, this.propagateValues(), !1;
                O >>= 1, U >>= 1, K++;
              }
              return this.currentLevel = K - 1, !0;
            }
            incrementValue(O) {
              const U = this.levels[this.currentLevel];
              U.items[U.index] = O + 1, this.propagateValues();
            }
            propagateValues() {
              let O = this.currentLevel, U = this.levels[O];
              const G = U.items[U.index];
              for (; --O >= 0; )
                U = this.levels[O], U.items[U.index] = G;
            }
            nextLevel() {
              let O = this.currentLevel, U = this.levels[O];
              const G = U.items[U.index];
              return U.items[U.index] = 255, O--, O < 0 ? !1 : (this.currentLevel = O, U = this.levels[O], U.items[U.index] = G, !0);
            }
          }
          const _ = function() {
            const G = new Uint8Array([0, 5, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 1, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8]), K = new Uint8Array([0, 3, 4, 0, 5, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 1, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8]), W = new Uint8Array([0, 1, 2, 0, 1, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 3, 4, 5, 0, 4, 5, 5, 0, 5, 5, 5, 0, 0, 0, 0, 0, 6, 7, 7, 0, 7, 7, 7, 0, 7, 7, 7, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8]);
            class z {
              constructor(L, Y, J, ie, q) {
                this.width = L, this.height = Y;
                let N;
                J === "HH" ? N = W : J === "HL" ? N = K : N = G, this.contextLabelTable = N;
                const Z = L * Y;
                this.neighborsSignificance = new Uint8Array(Z), this.coefficentsSign = new Uint8Array(Z);
                let E;
                q > 14 ? E = new Uint32Array(Z) : q > 6 ? E = new Uint16Array(Z) : E = new Uint8Array(Z), this.coefficentsMagnitude = E, this.processingFlags = new Uint8Array(Z);
                const te = new Uint8Array(Z);
                if (ie !== 0)
                  for (let re = 0; re < Z; re++)
                    te[re] = ie;
                this.bitsDecoded = te, this.reset();
              }
              setDecoder(L) {
                this.decoder = L;
              }
              reset() {
                this.contexts = new Int8Array(19), this.contexts[0] = 4 << 1 | 0, this.contexts[17] = 46 << 1 | 0, this.contexts[18] = 3 << 1 | 0;
              }
              setNeighborsSignificance(L, Y, J) {
                const ie = this.neighborsSignificance, q = this.width, N = this.height, Z = Y > 0, E = Y + 1 < q;
                let te;
                L > 0 && (te = J - q, Z && (ie[te - 1] += 16), E && (ie[te + 1] += 16), ie[te] += 4), L + 1 < N && (te = J + q, Z && (ie[te - 1] += 16), E && (ie[te + 1] += 16), ie[te] += 4), Z && (ie[J - 1] += 1), E && (ie[J + 1] += 1), ie[J] |= 128;
              }
              runSignificancePropagationPass() {
                const L = this.decoder, Y = this.width, J = this.height, ie = this.coefficentsMagnitude, q = this.coefficentsSign, N = this.neighborsSignificance, Z = this.processingFlags, E = this.contexts, te = this.contextLabelTable, re = this.bitsDecoded, ee = -2, $ = 1, k = 2;
                for (let H = 0; H < J; H += 4)
                  for (let ne = 0; ne < Y; ne++) {
                    let ae = H * Y + ne;
                    for (let he = 0; he < 4; he++, ae += Y) {
                      const ue = H + he;
                      if (ue >= J)
                        break;
                      if (Z[ae] &= ee, ie[ae] || !N[ae])
                        continue;
                      const fe = te[N[ae]];
                      if (L.readBit(E, fe)) {
                        const Fe = this.decodeSignBit(ue, ne, ae);
                        q[ae] = Fe, ie[ae] = 1, this.setNeighborsSignificance(ue, ne, ae), Z[ae] |= k;
                      }
                      re[ae]++, Z[ae] |= $;
                    }
                  }
              }
              decodeSignBit(L, Y, J) {
                const ie = this.width, q = this.height, N = this.coefficentsMagnitude, Z = this.coefficentsSign;
                let E, te, re, ee, $, k;
                ee = Y > 0 && N[J - 1] !== 0, Y + 1 < ie && N[J + 1] !== 0 ? (re = Z[J + 1], ee ? (te = Z[J - 1], E = 1 - re - te) : E = 1 - re - re) : ee ? (te = Z[J - 1], E = 1 - te - te) : E = 0;
                const H = 3 * E;
                return ee = L > 0 && N[J - ie] !== 0, L + 1 < q && N[J + ie] !== 0 ? (re = Z[J + ie], ee ? (te = Z[J - ie], E = 1 - re - te + H) : E = 1 - re - re + H) : ee ? (te = Z[J - ie], E = 1 - te - te + H) : E = H, E >= 0 ? ($ = 9 + E, k = this.decoder.readBit(this.contexts, $)) : ($ = 9 - E, k = this.decoder.readBit(this.contexts, $) ^ 1), k;
              }
              runMagnitudeRefinementPass() {
                const L = this.decoder, Y = this.width, J = this.height, ie = this.coefficentsMagnitude, q = this.neighborsSignificance, N = this.contexts, Z = this.bitsDecoded, E = this.processingFlags, te = 1, re = 2, ee = Y * J, $ = Y * 4;
                for (let k = 0, H; k < ee; k = H) {
                  H = Math.min(ee, k + $);
                  for (let ne = 0; ne < Y; ne++)
                    for (let ae = k + ne; ae < H; ae += Y) {
                      if (!ie[ae] || E[ae] & te)
                        continue;
                      let he = 16;
                      E[ae] & re && (E[ae] ^= re, he = (q[ae] & 127) === 0 ? 15 : 14);
                      const ue = L.readBit(N, he);
                      ie[ae] = ie[ae] << 1 | ue, Z[ae]++, E[ae] |= te;
                    }
                }
              }
              runCleanupPass() {
                const L = this.decoder, Y = this.width, J = this.height, ie = this.neighborsSignificance, q = this.coefficentsMagnitude, N = this.coefficentsSign, Z = this.contexts, E = this.contextLabelTable, te = this.bitsDecoded, re = this.processingFlags, ee = 1, $ = 2, k = Y, H = Y * 2, ne = Y * 3;
                let ae;
                for (let he = 0; he < J; he = ae) {
                  ae = Math.min(he + 4, J);
                  const ue = he * Y, fe = he + 3 < J;
                  for (let me = 0; me < Y; me++) {
                    const Fe = ue + me, we = fe && re[Fe] === 0 && re[Fe + k] === 0 && re[Fe + H] === 0 && re[Fe + ne] === 0 && ie[Fe] === 0 && ie[Fe + k] === 0 && ie[Fe + H] === 0 && ie[Fe + ne] === 0;
                    let Ae = 0, De = Fe, xe = he, Te;
                    if (we) {
                      if (!L.readBit(Z, 18)) {
                        te[Fe]++, te[Fe + k]++, te[Fe + H]++, te[Fe + ne]++;
                        continue;
                      }
                      Ae = L.readBit(Z, 17) << 1 | L.readBit(Z, 17), Ae !== 0 && (xe = he + Ae, De += Ae * Y), Te = this.decodeSignBit(xe, me, De), N[De] = Te, q[De] = 1, this.setNeighborsSignificance(xe, me, De), re[De] |= $, De = Fe;
                      for (let Se = he; Se <= xe; Se++, De += Y)
                        te[De]++;
                      Ae++;
                    }
                    for (xe = he + Ae; xe < ae; xe++, De += Y) {
                      if (q[De] || re[De] & ee)
                        continue;
                      const ve = E[ie[De]];
                      L.readBit(Z, ve) === 1 && (Te = this.decodeSignBit(xe, me, De), N[De] = Te, q[De] = 1, this.setNeighborsSignificance(xe, me, De), re[De] |= $), te[De]++;
                    }
                  }
                }
              }
              checkSegmentationSymbol() {
                const L = this.decoder, Y = this.contexts;
                if ((L.readBit(Y, 17) << 3 | L.readBit(Y, 17) << 2 | L.readBit(Y, 17) << 1 | L.readBit(Y, 17)) !== 10)
                  throw new a("Invalid segmentation symbol");
              }
            }
            return z;
          }();
          class S {
            constructor() {
              this.constructor === S && (0, t.unreachable)("Cannot initialize Transform.");
            }
            calculate(O, U, G) {
              let K = O[0];
              for (let W = 1, z = O.length; W < z; W++)
                K = this.iterate(K, O[W], U, G);
              return K;
            }
            extend(O, U, G) {
              let K = U - 1, W = U + 1, z = U + G - 2, V = U + G;
              O[K--] = O[W++], O[V++] = O[z--], O[K--] = O[W++], O[V++] = O[z--], O[K--] = O[W++], O[V++] = O[z--], O[K] = O[W], O[V] = O[z];
            }
            filter(O, U, G) {
              (0, t.unreachable)("Abstract method `filter` called");
            }
            iterate(O, U, G, K) {
              const W = O.width, z = O.height;
              let V = O.items;
              const L = U.width, Y = U.height, J = U.items;
              let ie, q, N, Z, E, te;
              for (N = 0, ie = 0; ie < z; ie++)
                for (Z = ie * 2 * L, q = 0; q < W; q++, N++, Z += 2)
                  J[Z] = V[N];
              V = O.items = null;
              const re = 4, ee = new Float32Array(L + 2 * re);
              if (L === 1) {
                if (G & 1)
                  for (te = 0, N = 0; te < Y; te++, N += L)
                    J[N] *= 0.5;
              } else
                for (te = 0, N = 0; te < Y; te++, N += L)
                  ee.set(J.subarray(N, N + L), re), this.extend(ee, re, L), this.filter(ee, re, L), J.set(ee.subarray(re, re + L), N);
              let $ = 16;
              const k = [];
              for (ie = 0; ie < $; ie++)
                k.push(new Float32Array(Y + 2 * re));
              let H, ne = 0;
              if (O = re + Y, Y === 1) {
                if (K & 1)
                  for (E = 0; E < L; E++)
                    J[E] *= 0.5;
              } else
                for (E = 0; E < L; E++) {
                  if (ne === 0) {
                    for ($ = Math.min(L - E, $), N = E, Z = re; Z < O; N += L, Z++)
                      for (H = 0; H < $; H++)
                        k[H][Z] = J[N + H];
                    ne = $;
                  }
                  ne--;
                  const ae = k[ne];
                  if (this.extend(ae, re, Y), this.filter(ae, re, Y), ne === 0)
                    for (N = E - $ + 1, Z = re; Z < O; N += L, Z++)
                      for (H = 0; H < $; H++)
                        J[N + H] = k[H][Z];
                }
              return {
                width: L,
                height: Y,
                items: J
              };
            }
          }
          class A extends S {
            filter(O, U, G) {
              const K = G >> 1;
              U |= 0;
              let W, z, V, L;
              const Y = -1.586134342059924, J = -0.052980118572961, ie = 0.882911075530934, q = 0.443506852043971, N = 1.230174104914001, Z = 1 / N;
              for (W = U - 3, z = K + 4; z--; W += 2)
                O[W] *= Z;
              for (W = U - 2, V = q * O[W - 1], z = K + 3; z-- && (L = q * O[W + 1], O[W] = N * O[W] - V - L, z--); W += 2)
                W += 2, V = q * O[W + 1], O[W] = N * O[W] - V - L;
              for (W = U - 1, V = ie * O[W - 1], z = K + 2; z-- && (L = ie * O[W + 1], O[W] -= V + L, z--); W += 2)
                W += 2, V = ie * O[W + 1], O[W] -= V + L;
              for (W = U, V = J * O[W - 1], z = K + 1; z-- && (L = J * O[W + 1], O[W] -= V + L, z--); W += 2)
                W += 2, V = J * O[W + 1], O[W] -= V + L;
              if (K !== 0)
                for (W = U + 1, V = Y * O[W - 1], z = K; z-- && (L = Y * O[W + 1], O[W] -= V + L, z--); W += 2)
                  W += 2, V = Y * O[W + 1], O[W] -= V + L;
            }
          }
          class F extends S {
            filter(O, U, G) {
              const K = G >> 1;
              U |= 0;
              let W, z;
              for (W = U, z = K + 1; z--; W += 2)
                O[W] -= O[W - 1] + O[W + 1] + 2 >> 2;
              for (W = U + 1, z = K; z--; W += 2)
                O[W] += O[W - 1] + O[W + 1] >> 1;
            }
          }
        },
        /* 31 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.LZWStream = void 0;
          var t = P(19);
          class i extends t.DecodeStream {
            constructor(a, e, y) {
              super(e), this.str = a, this.dict = a.dict, this.cachedData = 0, this.bitsCached = 0;
              const r = 4096, h = {
                earlyChange: y,
                codeLength: 9,
                nextCode: 258,
                dictionaryValues: new Uint8Array(r),
                dictionaryLengths: new Uint16Array(r),
                dictionaryPrevCodes: new Uint16Array(r),
                currentSequence: new Uint8Array(r),
                currentSequenceLength: 0
              };
              for (let g = 0; g < 256; ++g)
                h.dictionaryValues[g] = g, h.dictionaryLengths[g] = 1;
              this.lzwState = h;
            }
            readBits(a) {
              let e = this.bitsCached, y = this.cachedData;
              for (; e < a; ) {
                const r = this.str.getByte();
                if (r === -1)
                  return this.eof = !0, null;
                y = y << 8 | r, e += 8;
              }
              return this.bitsCached = e -= a, this.cachedData = y, this.lastCode = null, y >>> e & (1 << a) - 1;
            }
            readBlock() {
              let y = 1024, r, h, g;
              const d = this.lzwState;
              if (!d)
                return;
              const c = d.earlyChange;
              let n = d.nextCode;
              const o = d.dictionaryValues, x = d.dictionaryLengths, f = d.dictionaryPrevCodes;
              let m = d.codeLength, C = d.prevCode;
              const p = d.currentSequence;
              let w = d.currentSequenceLength, X = 0, M = this.bufferLength, j = this.ensureBuffer(this.bufferLength + y);
              for (r = 0; r < 512; r++) {
                const B = this.readBits(m), R = w > 0;
                if (B < 256)
                  p[0] = B, w = 1;
                else if (B >= 258)
                  if (B < n)
                    for (w = x[B], h = w - 1, g = B; h >= 0; h--)
                      p[h] = o[g], g = f[g];
                  else
                    p[w++] = p[0];
                else if (B === 256) {
                  m = 9, n = 258, w = 0;
                  continue;
                } else {
                  this.eof = !0, delete this.lzwState;
                  break;
                }
                if (R && (f[n] = C, x[n] = x[C] + 1, o[n] = p[0], n++, m = n + c & n + c - 1 ? m : Math.min(Math.log(n + c) / 0.6931471805599453 + 1, 12) | 0), C = B, X += w, y < X) {
                  do
                    y += 512;
                  while (y < X);
                  j = this.ensureBuffer(this.bufferLength + y);
                }
                for (h = 0; h < w; h++)
                  j[M++] = p[h];
              }
              d.nextCode = n, d.codeLength = m, d.prevCode = C, d.currentSequenceLength = w, this.bufferLength = M;
            }
          }
          u.LZWStream = i;
        },
        /* 32 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.PredictorStream = void 0;
          var t = P(19), i = P(5), v = P(2);
          class a extends t.DecodeStream {
            constructor(y, r, h) {
              if (super(r), !(h instanceof i.Dict))
                return y;
              const g = this.predictor = h.get("Predictor") || 1;
              if (g <= 1)
                return y;
              if (g !== 2 && (g < 10 || g > 15))
                throw new v.FormatError(`Unsupported predictor: ${g}`);
              g === 2 ? this.readBlock = this.readBlockTiff : this.readBlock = this.readBlockPng, this.str = y, this.dict = y.dict;
              const d = this.colors = h.get("Colors") || 1, c = this.bits = h.get("BPC", "BitsPerComponent") || 8, n = this.columns = h.get("Columns") || 1;
              return this.pixBytes = d * c + 7 >> 3, this.rowBytes = n * d * c + 7 >> 3, this;
            }
            readBlockTiff() {
              const y = this.rowBytes, r = this.bufferLength, h = this.ensureBuffer(r + y), g = this.bits, d = this.colors, c = this.str.getBytes(y);
              if (this.eof = !c.length, this.eof)
                return;
              let n = 0, o = 0, x = 0, f = 0, m = r, C;
              if (g === 1 && d === 1)
                for (C = 0; C < y; ++C) {
                  let p = c[C] ^ n;
                  p ^= p >> 1, p ^= p >> 2, p ^= p >> 4, n = (p & 1) << 7, h[m++] = p;
                }
              else if (g === 8) {
                for (C = 0; C < d; ++C)
                  h[m++] = c[C];
                for (; C < y; ++C)
                  h[m] = h[m - d] + c[C], m++;
              } else if (g === 16) {
                const p = d * 2;
                for (C = 0; C < p; ++C)
                  h[m++] = c[C];
                for (; C < y; C += 2) {
                  const w = ((c[C] & 255) << 8) + (c[C + 1] & 255) + ((h[m - p] & 255) << 8) + (h[m - p + 1] & 255);
                  h[m++] = w >> 8 & 255, h[m++] = w & 255;
                }
              } else {
                const p = new Uint8Array(d + 1), w = (1 << g) - 1;
                let X = 0, M = r;
                const j = this.columns;
                for (C = 0; C < j; ++C)
                  for (let B = 0; B < d; ++B)
                    x < g && (n = n << 8 | c[X++] & 255, x += 8), p[B] = p[B] + (n >> x - g) & w, x -= g, o = o << g | p[B], f += g, f >= 8 && (h[M++] = o >> f - 8 & 255, f -= 8);
                f > 0 && (h[M++] = (o << 8 - f) + (n & (1 << 8 - f) - 1));
              }
              this.bufferLength += y;
            }
            readBlockPng() {
              const y = this.rowBytes, r = this.pixBytes, h = this.str.getByte(), g = this.str.getBytes(y);
              if (this.eof = !g.length, this.eof)
                return;
              const d = this.bufferLength, c = this.ensureBuffer(d + y);
              let n = c.subarray(d - y, d);
              n.length === 0 && (n = new Uint8Array(y));
              let o, x = d, f, m;
              switch (h) {
                case 0:
                  for (o = 0; o < y; ++o)
                    c[x++] = g[o];
                  break;
                case 1:
                  for (o = 0; o < r; ++o)
                    c[x++] = g[o];
                  for (; o < y; ++o)
                    c[x] = c[x - r] + g[o] & 255, x++;
                  break;
                case 2:
                  for (o = 0; o < y; ++o)
                    c[x++] = n[o] + g[o] & 255;
                  break;
                case 3:
                  for (o = 0; o < r; ++o)
                    c[x++] = (n[o] >> 1) + g[o];
                  for (; o < y; ++o)
                    c[x] = (n[o] + c[x - r] >> 1) + g[o] & 255, x++;
                  break;
                case 4:
                  for (o = 0; o < r; ++o)
                    f = n[o], m = g[o], c[x++] = f + m;
                  for (; o < y; ++o) {
                    f = n[o];
                    const C = n[o - r], p = c[x - r], w = p + f - C;
                    let X = w - p;
                    X < 0 && (X = -X);
                    let M = w - f;
                    M < 0 && (M = -M);
                    let j = w - C;
                    j < 0 && (j = -j), m = g[o], X <= M && X <= j ? c[x++] = p + m : M <= j ? c[x++] = f + m : c[x++] = C + m;
                  }
                  break;
                default:
                  throw new v.FormatError(`Unsupported predictor: ${h}`);
              }
              this.bufferLength += y;
            }
          }
          u.PredictorStream = a;
        },
        /* 33 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.RunLengthStream = void 0;
          var t = P(19);
          class i extends t.DecodeStream {
            constructor(a, e) {
              super(e), this.str = a, this.dict = a.dict;
            }
            readBlock() {
              const a = this.str.getBytes(2);
              if (!a || a.length < 2 || a[0] === 128) {
                this.eof = !0;
                return;
              }
              let e, y = this.bufferLength, r = a[0];
              if (r < 128) {
                if (e = this.ensureBuffer(y + r + 1), e[y++] = a[1], r > 0) {
                  const h = this.str.getBytes(r);
                  e.set(h, y), y += r;
                }
              } else {
                r = 257 - r;
                const h = a[1];
                e = this.ensureBuffer(y + r + 1);
                for (let g = 0; g < r; g++)
                  e[y++] = h;
              }
              this.bufferLength = y;
            }
          }
          u.RunLengthStream = i;
        },
        /* 34 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.Font = u.ErrorFont = void 0;
          var t = P(2), i = P(35), v = P(38), a = P(40), e = P(39), y = P(37), r = P(41), h = P(42), g = P(43), d = P(44), c = P(45), n = P(46), o = P(16), x = P(47), f = P(6), m = P(10), C = P(48);
          const p = [[57344, 63743], [1048576, 1114109]], w = 1e3, X = ["ascent", "bbox", "black", "bold", "charProcOperatorList", "composite", "cssFontInfo", "data", "defaultVMetrics", "defaultWidth", "descent", "fallbackName", "fontMatrix", "fontType", "isType3Font", "italic", "loadedName", "mimetype", "missingFile", "name", "remeasure", "subtype", "type", "vertical"], M = ["cMap", "defaultEncoding", "differences", "isMonospace", "isSerifFont", "isSymbolicFont", "seacMap", "toFontChar", "toUnicode", "vmetrics", "widths"];
          function j($) {
            if (!$.fontMatrix || $.fontMatrix[0] === t.FONT_IDENTITY_MATRIX[0])
              return;
            const k = 1e-3 / $.fontMatrix[0], H = $.widths;
            for (const ne in H)
              H[ne] *= k;
            $.defaultWidth *= k;
          }
          function B($, k) {
            if ($.isInternalFont || k === $.defaultEncoding || $.toUnicode instanceof h.IdentityToUnicodeMap)
              return;
            const H = [], ne = (0, e.getGlyphsUnicode)();
            for (const ae in k) {
              if ($.hasIncludedToUnicodeMap) {
                if ($.toUnicode.has(ae))
                  continue;
              } else if ($.hasEncoding && ($.differences.length === 0 || $.differences[ae] !== void 0))
                continue;
              const he = k[ae], ue = (0, a.getUnicodeForGlyph)(he, ne);
              ue !== -1 && (H[ae] = String.fromCharCode(ue));
            }
            H.length > 0 && $.toUnicode.amend(H);
          }
          function R($) {
            if (!$.fallbackToUnicode || $.toUnicode instanceof h.IdentityToUnicodeMap)
              return;
            const k = [];
            for (const H in $.fallbackToUnicode)
              $.toUnicode.has(H) || (k[H] = $.fallbackToUnicode[H]);
            k.length > 0 && $.toUnicode.amend(k);
          }
          class D {
            constructor(k, H, ne, ae, he, ue, fe, me, Fe) {
              this.originalCharCode = k, this.fontChar = H, this.unicode = ne, this.accent = ae, this.width = he, this.vmetric = ue, this.operatorListId = fe, this.isSpace = me, this.isInFont = Fe;
              const we = (0, a.getCharUnicodeCategory)(ne);
              this.isWhitespace = we.isWhitespace, this.isZeroWidthDiacritic = we.isZeroWidthDiacritic, this.isInvisibleFormatMark = we.isInvisibleFormatMark;
            }
            matchesForCache(k, H, ne, ae, he, ue, fe, me, Fe) {
              return this.originalCharCode === k && this.fontChar === H && this.unicode === ne && this.accent === ae && this.width === he && this.vmetric === ue && this.operatorListId === fe && this.isSpace === me && this.isInFont === Fe;
            }
          }
          function b($, k) {
            return ($ << 8) + k;
          }
          function l($, k, H) {
            $[k + 1] = H, $[k] = H >>> 8;
          }
          function _($, k) {
            const H = ($ << 8) + k;
            return H & 32768 ? H - 65536 : H;
          }
          function S($, k, H, ne) {
            return ($ << 24) + (k << 16) + (H << 8) + ne;
          }
          function A($) {
            return String.fromCharCode($ >> 8 & 255, $ & 255);
          }
          function F($) {
            return $ > 32767 ? $ = 32767 : $ < -32768 && ($ = -32768), String.fromCharCode($ >> 8 & 255, $ & 255);
          }
          function T($) {
            const k = $.peekBytes(4);
            return (0, f.readUint32)(k, 0) === 65536 || (0, t.bytesToString)(k) === "true";
          }
          function O($) {
            const k = $.peekBytes(4);
            return (0, t.bytesToString)(k) === "ttcf";
          }
          function U($) {
            const k = $.peekBytes(4);
            return (0, t.bytesToString)(k) === "OTTO";
          }
          function G($) {
            const k = $.peekBytes(2);
            return k[0] === 37 && k[1] === 33 || k[0] === 128 && k[1] === 1;
          }
          function K($) {
            const k = $.peekBytes(4);
            return k[0] >= 1 && k[3] >= 1 && k[3] <= 4;
          }
          function W($, {
            type: k,
            subtype: H,
            composite: ne
          }) {
            let ae, he;
            return T($) || O($) ? ne ? ae = "CIDFontType2" : ae = "TrueType" : U($) ? ne ? ae = "CIDFontType2" : ae = "OpenType" : G($) ? ne ? ae = "CIDFontType0" : ae = k === "MMType1" ? "MMType1" : "Type1" : K($) ? ne ? (ae = "CIDFontType0", he = "CIDFontType0C") : (ae = k === "MMType1" ? "MMType1" : "Type1", he = "Type1C") : ((0, t.warn)("getFontFileType: Unable to detect correct font file Type/Subtype."), ae = k, he = H), [ae, he];
          }
          function z($, k) {
            for (const H in k)
              $[+H] = k[H];
          }
          function V($, k, H) {
            const ne = [];
            let ae;
            for (let he = 0, ue = $.length; he < ue; he++)
              ae = (0, a.getUnicodeForGlyph)($[he], k), ae !== -1 && (ne[he] = ae);
            for (const he in H)
              ae = (0, a.getUnicodeForGlyph)(H[he], k), ae !== -1 && (ne[+he] = ae);
            return ne;
          }
          function L($, k, H = !1) {
            switch (k.length) {
              case 1:
                return k.charCodeAt(0);
              case 2:
                return k.charCodeAt(0) << 8 | k.charCodeAt(1);
            }
            const ne = `Unsupported CID string (charCode ${$}): "${k}".`;
            if (H)
              throw new t.FormatError(ne);
            return (0, t.warn)(ne), k;
          }
          function Y($, k, H, ne) {
            const ae = /* @__PURE__ */ Object.create(null), he = /* @__PURE__ */ new Map(), ue = [], fe = /* @__PURE__ */ new Set();
            let me = 0;
            const Fe = p[me][0];
            let we = Fe, Ae = p[me][1];
            for (let De in $) {
              De |= 0;
              let xe = $[De];
              if (!k(xe))
                continue;
              if (we > Ae) {
                if (me++, me >= p.length) {
                  (0, t.warn)("Ran out of space in font private use area.");
                  break;
                }
                we = p[me][0], Ae = p[me][1];
              }
              const Te = we++;
              xe === 0 && (xe = H);
              let ve = ne.get(De);
              typeof ve == "string" && (ve = ve.codePointAt(0)), ve && ve < Fe && !fe.has(xe) && (he.set(ve, xe), fe.add(xe)), ae[Te] = xe, ue[De] = Te;
            }
            return {
              toFontChar: ue,
              charCodeToGlyphId: ae,
              toUnicodeExtraMap: he,
              nextAvailableFontCharCode: we
            };
          }
          function J($, k, H) {
            const ne = [];
            for (const ue in $)
              $[ue] >= H || ne.push({
                fontCharCode: ue | 0,
                glyphId: $[ue]
              });
            if (k)
              for (const [ue, fe] of k)
                fe >= H || ne.push({
                  fontCharCode: ue,
                  glyphId: fe
                });
            ne.length === 0 && ne.push({
              fontCharCode: 0,
              glyphId: 0
            }), ne.sort(function(fe, me) {
              return fe.fontCharCode - me.fontCharCode;
            });
            const ae = [], he = ne.length;
            for (let ue = 0; ue < he; ) {
              const fe = ne[ue].fontCharCode, me = [ne[ue].glyphId];
              ++ue;
              let Fe = fe;
              for (; ue < he && Fe + 1 === ne[ue].fontCharCode && (me.push(ne[ue].glyphId), ++Fe, ++ue, Fe !== 65535); )
                ;
              ae.push([fe, Fe, me]);
            }
            return ae;
          }
          function ie($, k, H) {
            const ne = J($, k, H), ae = ne.at(-1)[1] > 65535 ? 2 : 1;
            let he = "\0\0" + A(ae) + "\0\0" + (0, t.string32)(4 + ae * 8), ue, fe, me, Fe;
            for (ue = ne.length - 1; ue >= 0 && !(ne[ue][0] <= 65535); --ue)
              ;
            const we = ue + 1;
            ne[ue][0] < 65535 && ne[ue][1] === 65535 && (ne[ue][1] = 65534);
            const Ae = ne[ue][1] < 65535 ? 1 : 0, De = we + Ae, xe = x.OpenTypeFileBuilder.getSearchParams(De, 2);
            let Te = "", ve = "", Se = "", be = "", Le = "", ze = 0, nt, Ue, Oe, _e;
            for (ue = 0, fe = we; ue < fe; ue++) {
              nt = ne[ue], Ue = nt[0], Oe = nt[1], Te += A(Ue), ve += A(Oe), _e = nt[2];
              let mt = !0;
              for (me = 1, Fe = _e.length; me < Fe; ++me)
                if (_e[me] !== _e[me - 1] + 1) {
                  mt = !1;
                  break;
                }
              if (mt) {
                const Ze = _e[0];
                Se += A(Ze - Ue & 65535), be += A(0);
              } else {
                const Ze = (De - ue) * 2 + ze * 2;
                for (ze += Oe - Ue + 1, Se += A(0), be += A(Ze), me = 0, Fe = _e.length; me < Fe; ++me)
                  Le += A(_e[me]);
              }
            }
            Ae > 0 && (ve += "ÿÿ", Te += "ÿÿ", Se += "\0", be += "\0\0");
            const at = "\0\0" + A(2 * De) + A(xe.range) + A(xe.entry) + A(xe.rangeShift) + ve + "\0\0" + Te + Se + be + Le;
            let Je = "", ot = "";
            if (ae > 1) {
              for (he += `\0\0
` + (0, t.string32)(4 + ae * 8 + 4 + at.length), Je = "", ue = 0, fe = ne.length; ue < fe; ue++) {
                nt = ne[ue], Ue = nt[0], _e = nt[2];
                let mt = _e[0];
                for (me = 1, Fe = _e.length; me < Fe; ++me)
                  _e[me] !== _e[me - 1] + 1 && (Oe = nt[0] + me - 1, Je += (0, t.string32)(Ue) + (0, t.string32)(Oe) + (0, t.string32)(mt), Ue = Oe + 1, mt = _e[me]);
                Je += (0, t.string32)(Ue) + (0, t.string32)(nt[1]) + (0, t.string32)(mt);
              }
              ot = "\0\f\0\0" + (0, t.string32)(Je.length + 16) + "\0\0\0\0" + (0, t.string32)(Je.length / 12);
            }
            return he + "\0" + A(at.length + 4) + at + ot + Je;
          }
          function q($, k) {
            k.pos = (k.start || 0) + $.offset;
            const H = k.getUint16();
            k.skip(60);
            const ne = k.getUint16();
            if (H < 4 && ne & 768)
              return !1;
            const ae = k.getUint16(), he = k.getUint16();
            return ae > he || (k.skip(6), k.getUint16() === 0) ? !1 : ($.data[8] = $.data[9] = 0, !0);
          }
          function N($, k, H) {
            H = H || {
              unitsPerEm: 0,
              yMax: 0,
              yMin: 0,
              ascent: 0,
              descent: 0
            };
            let ne = 0, ae = 0, he = 0, ue = 0, fe = null, me = 0;
            if (k) {
              for (let Se in k) {
                Se |= 0, (fe > Se || !fe) && (fe = Se), me < Se && (me = Se);
                const be = (0, a.getUnicodeRangeFor)(Se);
                if (be < 32)
                  ne |= 1 << be;
                else if (be < 64)
                  ae |= 1 << be - 32;
                else if (be < 96)
                  he |= 1 << be - 64;
                else if (be < 123)
                  ue |= 1 << be - 96;
                else
                  throw new t.FormatError("Unicode ranges Bits > 123 are reserved for internal usage");
              }
              me > 65535 && (me = 65535);
            } else
              fe = 0, me = 255;
            const Fe = $.bbox || [0, 0, 0, 0], we = H.unitsPerEm || 1 / ($.fontMatrix || t.FONT_IDENTITY_MATRIX)[0], Ae = $.ascentScaled ? 1 : we / w, De = H.ascent || Math.round(Ae * ($.ascent || Fe[3]));
            let xe = H.descent || Math.round(Ae * ($.descent || Fe[1]));
            xe > 0 && $.descent > 0 && Fe[1] < 0 && (xe = -xe);
            const Te = H.yMax || De, ve = -H.yMin || -xe;
            return "\0$ô\0\0\0»\0\0\0»\0\0ß\x001\0\0\0\0" + String.fromCharCode($.fixedPitch ? 9 : 0) + "\0\0\0\0\0\0" + (0, t.string32)(ne) + (0, t.string32)(ae) + (0, t.string32)(he) + (0, t.string32)(ue) + "*21*" + A($.italicAngle ? 1 : 0) + A(fe || $.firstChar) + A(me || $.lastChar) + A(De) + A(xe) + "\0d" + A(Te) + A(ve) + "\0\0\0\0\0\0\0\0" + A($.xHeight) + A($.capHeight) + A(0) + A(fe || $.firstChar) + "\0";
          }
          function Z($) {
            const k = Math.floor($.italicAngle * 65536);
            return "\0\0\0" + (0, t.string32)(k) + "\0\0\0\0" + (0, t.string32)($.fixedPitch ? 1 : 0) + "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
          }
          function E($) {
            return $.replace(/[^\x21-\x7E]|[[\](){}<>/%]/g, "").slice(0, 63);
          }
          function te($, k) {
            k || (k = [[], []]);
            const H = [k[0][0] || "Original licence", k[0][1] || $, k[0][2] || "Unknown", k[0][3] || "uniqueID", k[0][4] || $, k[0][5] || "Version 0.11", k[0][6] || E($), k[0][7] || "Unknown", k[0][8] || "Unknown", k[0][9] || "Unknown"], ne = [];
            let ae, he, ue, fe, me;
            for (ae = 0, he = H.length; ae < he; ae++) {
              me = k[1][ae] || H[ae];
              const Se = [];
              for (ue = 0, fe = me.length; ue < fe; ue++)
                Se.push(A(me.charCodeAt(ue)));
              ne.push(Se.join(""));
            }
            const Fe = [H, ne], we = ["\0", "\0"], Ae = ["\0\0", "\0"], De = ["\0\0", "	"], xe = H.length * we.length;
            let Te = "\0\0" + A(xe) + A(xe * 12 + 6), ve = 0;
            for (ae = 0, he = we.length; ae < he; ae++) {
              const Se = Fe[ae];
              for (ue = 0, fe = Se.length; ue < fe; ue++) {
                me = Se[ue];
                const be = we[ae] + Ae[ae] + De[ae] + A(ue) + A(me.length) + A(ve);
                Te += be, ve += me.length;
              }
            }
            return Te += H.join("") + ne.join(""), Te;
          }
          class re {
            constructor(k, H, ne) {
              this.name = k, this.psName = null, this.mimetype = null, this.disableFontFace = !1, this.loadedName = ne.loadedName, this.isType3Font = ne.isType3Font, this.missingFile = !1, this.cssFontInfo = ne.cssFontInfo, this._charsCache = /* @__PURE__ */ Object.create(null), this._glyphCache = /* @__PURE__ */ Object.create(null);
              let ae = !!(ne.flags & v.FontFlags.Serif);
              if (!ae && !ne.isSimulatedFlags) {
                const Fe = k.replace(/[,_]/g, "-").split("-")[0], we = (0, r.getSerifFonts)();
                for (const Ae of Fe.split("+"))
                  if (we[Ae]) {
                    ae = !0;
                    break;
                  }
              }
              this.isSerifFont = ae, this.isSymbolicFont = !!(ne.flags & v.FontFlags.Symbolic), this.isMonospace = !!(ne.flags & v.FontFlags.FixedPitch);
              let he = ne.type, ue = ne.subtype;
              this.type = he, this.subtype = ue;
              let fe = "sans-serif";
              if (this.isMonospace ? fe = "monospace" : this.isSerifFont && (fe = "serif"), this.fallbackName = fe, this.differences = ne.differences, this.widths = ne.widths, this.defaultWidth = ne.defaultWidth, this.composite = ne.composite, this.cMap = ne.cMap, this.capHeight = ne.capHeight / w, this.ascent = ne.ascent / w, this.descent = ne.descent / w, this.lineHeight = this.ascent - this.descent, this.fontMatrix = ne.fontMatrix, this.bbox = ne.bbox, this.defaultEncoding = ne.defaultEncoding, this.toUnicode = ne.toUnicode, this.toFontChar = [], ne.type === "Type3") {
                for (let Fe = 0; Fe < 256; Fe++)
                  this.toFontChar[Fe] = this.differences[Fe] || ne.defaultEncoding[Fe];
                this.fontType = t.FontType.TYPE3;
                return;
              }
              if (this.cidEncoding = ne.cidEncoding || "", this.vertical = !!ne.vertical, this.vertical && (this.vmetrics = ne.vmetrics, this.defaultVMetrics = ne.defaultVMetrics), !H || H.isEmpty) {
                H && (0, t.warn)('Font file is empty in "' + k + '" (' + this.loadedName + ")"), this.fallbackToSystemFont(ne);
                return;
              }
              [he, ue] = W(H, ne), (he !== this.type || ue !== this.subtype) && (0, t.info)(`Inconsistent font file Type/SubType, expected: ${this.type}/${this.subtype} but found: ${he}/${ue}.`);
              let me;
              try {
                switch (he) {
                  case "MMType1":
                    (0, t.info)("MMType1 font (" + k + "), falling back to Type1.");
                  case "Type1":
                  case "CIDFontType0":
                    this.mimetype = "font/opentype";
                    const Fe = ue === "Type1C" || ue === "CIDFontType0C" ? new g.CFFFont(H, ne) : new C.Type1Font(k, H, ne);
                    j(ne), me = this.convert(k, Fe, ne);
                    break;
                  case "OpenType":
                  case "TrueType":
                  case "CIDFontType2":
                    this.mimetype = "font/opentype", me = this.checkAndRepair(k, H, ne), this.isOpenType && (j(ne), he = "OpenType");
                    break;
                  default:
                    throw new t.FormatError(`Font ${he} is not supported`);
                }
              } catch (Fe) {
                (0, t.warn)(Fe), this.fallbackToSystemFont(ne);
                return;
              }
              R(ne), this.data = me, this.fontType = (0, v.getFontType)(he, ue, ne.isStandardFont), this.fontMatrix = ne.fontMatrix, this.widths = ne.widths, this.defaultWidth = ne.defaultWidth, this.toUnicode = ne.toUnicode, this.seacMap = ne.seacMap;
            }
            get renderer() {
              const k = d.FontRendererFactory.create(this, v.SEAC_ANALYSIS_ENABLED);
              return (0, t.shadow)(this, "renderer", k);
            }
            exportData(k = !1) {
              const H = k ? [...X, ...M] : X, ne = /* @__PURE__ */ Object.create(null);
              let ae, he;
              for (ae of H)
                he = this[ae], he !== void 0 && (ne[ae] = he);
              return ne;
            }
            fallbackToSystemFont(k) {
              this.missingFile = !0;
              const H = this.name, ne = this.type, ae = this.subtype;
              let he = (0, v.normalizeFontName)(H);
              const ue = (0, r.getStdFontMap)(), fe = (0, r.getNonStdFontMap)(), me = !!ue[he], Fe = !!(fe[he] && ue[fe[he]]);
              he = ue[he] || fe[he] || he;
              const Ae = (0, c.getFontBasicMetrics)()[he];
              Ae && (isNaN(this.ascent) && (this.ascent = Ae.ascent / w), isNaN(this.descent) && (this.descent = Ae.descent / w), isNaN(this.capHeight) && (this.capHeight = Ae.capHeight / w)), this.bold = he.search(/bold/gi) !== -1, this.italic = he.search(/oblique/gi) !== -1 || he.search(/italic/gi) !== -1, this.black = H.search(/Black/g) !== -1;
              const De = H.search(/Narrow/g) !== -1;
              if (this.remeasure = (!me || De) && Object.keys(this.widths).length > 0, (me || Fe) && ne === "CIDFontType2" && this.cidEncoding.startsWith("Identity-")) {
                const xe = k.cidToGidMap, Te = [];
                if (z(Te, (0, r.getGlyphMapForStandardFonts)()), /Arial-?Black/i.test(H) ? z(Te, (0, r.getSupplementalGlyphMapForArialBlack)()) : /Calibri/i.test(H) && z(Te, (0, r.getSupplementalGlyphMapForCalibri)()), xe) {
                  for (const ve in Te) {
                    const Se = Te[ve];
                    xe[Se] !== void 0 && (Te[+ve] = xe[Se]);
                  }
                  xe.length !== this.toUnicode.length && k.hasIncludedToUnicodeMap && this.toUnicode instanceof h.IdentityToUnicodeMap && this.toUnicode.forEach(function(ve, Se) {
                    const be = Te[ve];
                    xe[be] === void 0 && (Te[+ve] = Se);
                  });
                }
                this.toUnicode instanceof h.IdentityToUnicodeMap || this.toUnicode.forEach(function(ve, Se) {
                  Te[+ve] = Se;
                }), this.toFontChar = Te, this.toUnicode = new h.ToUnicodeMap(Te);
              } else if (/Symbol/i.test(he))
                this.toFontChar = V(y.SymbolSetEncoding, (0, e.getGlyphsUnicode)(), this.differences);
              else if (/Dingbats/i.test(he))
                /Wingdings/i.test(H) && (0, t.warn)("Non-embedded Wingdings font, falling back to ZapfDingbats."), this.toFontChar = V(y.ZapfDingbatsEncoding, (0, e.getDingbatsGlyphsUnicode)(), this.differences);
              else if (me) {
                const xe = V(this.defaultEncoding, (0, e.getGlyphsUnicode)(), this.differences);
                ne === "CIDFontType2" && !this.cidEncoding.startsWith("Identity-") && !(this.toUnicode instanceof h.IdentityToUnicodeMap) && this.toUnicode.forEach(function(Te, ve) {
                  xe[+Te] = ve;
                }), this.toFontChar = xe;
              } else {
                const xe = (0, e.getGlyphsUnicode)(), Te = [];
                this.toUnicode.forEach((ve, Se) => {
                  if (!this.composite) {
                    const be = this.differences[ve] || this.defaultEncoding[ve], Le = (0, a.getUnicodeForGlyph)(be, xe);
                    Le !== -1 && (Se = Le);
                  }
                  Te[+ve] = Se;
                }), this.composite && this.toUnicode instanceof h.IdentityToUnicodeMap && /Verdana/i.test(H) && z(Te, (0, r.getGlyphMapForStandardFonts)()), this.toFontChar = Te;
              }
              R(k), this.loadedName = he.split("-")[0], this.fontType = (0, v.getFontType)(ne, ae, k.isStandardFont);
            }
            checkAndRepair(k, H, ne) {
              const ae = ["OS/2", "cmap", "head", "hhea", "hmtx", "maxp", "name", "post", "loca", "glyf", "fpgm", "prep", "cvt ", "CFF "];
              function he(Ge, Ne) {
                const rt = /* @__PURE__ */ Object.create(null);
                rt["OS/2"] = null, rt.cmap = null, rt.head = null, rt.hhea = null, rt.hmtx = null, rt.maxp = null, rt.name = null, rt.post = null;
                for (let tt = 0; tt < Ne; tt++) {
                  const dt = ue(Ge);
                  ae.includes(dt.tag) && dt.length !== 0 && (rt[dt.tag] = dt);
                }
                return rt;
              }
              function ue(Ge) {
                const Ne = Ge.getString(4), rt = Ge.getInt32() >>> 0, tt = Ge.getInt32() >>> 0, dt = Ge.getInt32() >>> 0, Ct = Ge.pos;
                Ge.pos = Ge.start || 0, Ge.skip(tt);
                const bt = Ge.getBytes(dt);
                return Ge.pos = Ct, Ne === "head" && (bt[8] = bt[9] = bt[10] = bt[11] = 0, bt[17] |= 32), {
                  tag: Ne,
                  checksum: rt,
                  length: dt,
                  offset: tt,
                  data: bt
                };
              }
              function fe(Ge) {
                return {
                  version: Ge.getString(4),
                  numTables: Ge.getUint16(),
                  searchRange: Ge.getUint16(),
                  entrySelector: Ge.getUint16(),
                  rangeShift: Ge.getUint16()
                };
              }
              function me(Ge) {
                const Ne = Ge.getString(4);
                (0, t.assert)(Ne === "ttcf", "Must be a TrueType Collection font.");
                const rt = Ge.getUint16(), tt = Ge.getUint16(), dt = Ge.getInt32() >>> 0, Ct = [];
                for (let ht = 0; ht < dt; ht++)
                  Ct.push(Ge.getInt32() >>> 0);
                const bt = {
                  ttcTag: Ne,
                  majorVersion: rt,
                  minorVersion: tt,
                  numFonts: dt,
                  offsetTable: Ct
                };
                switch (rt) {
                  case 1:
                    return bt;
                  case 2:
                    return bt.dsigTag = Ge.getInt32() >>> 0, bt.dsigLength = Ge.getInt32() >>> 0, bt.dsigOffset = Ge.getInt32() >>> 0, bt;
                }
                throw new t.FormatError(`Invalid TrueType Collection majorVersion: ${rt}.`);
              }
              function Fe(Ge, Ne) {
                const {
                  numFonts: rt,
                  offsetTable: tt
                } = me(Ge), dt = Ne.split("+");
                let Ct;
                for (let bt = 0; bt < rt; bt++) {
                  Ge.pos = (Ge.start || 0) + tt[bt];
                  const ht = fe(Ge), vt = he(Ge, ht.numTables);
                  if (!vt.name)
                    throw new t.FormatError('TrueType Collection font must contain a "name" table.');
                  const _t = Se(vt.name);
                  for (let Nt = 0, Mt = _t.length; Nt < Mt; Nt++)
                    for (let Et = 0, Re = _t[Nt].length; Et < Re; Et++) {
                      const We = _t[Nt][Et] && _t[Nt][Et].replace(/\s/g, "");
                      if (We) {
                        if (We === Ne)
                          return {
                            header: ht,
                            tables: vt
                          };
                        if (!(dt.length < 2))
                          for (const it of dt)
                            We === it && (Ct = {
                              name: it,
                              header: ht,
                              tables: vt
                            });
                      }
                    }
                }
                if (Ct)
                  return (0, t.warn)(`TrueType Collection does not contain "${Ne}" font, falling back to "${Ct.name}" font instead.`), {
                    header: Ct.header,
                    tables: Ct.tables
                  };
                throw new t.FormatError(`TrueType Collection does not contain "${Ne}" font.`);
              }
              function we(Ge, Ne, rt, tt) {
                if (!Ge)
                  return (0, t.warn)("No cmap table available."), {
                    platformId: -1,
                    encodingId: -1,
                    mappings: [],
                    hasShortCmap: !1
                  };
                let dt, Ct = (Ne.start || 0) + Ge.offset;
                Ne.pos = Ct, Ne.skip(2);
                const bt = Ne.getUint16();
                let ht, vt = !1;
                for (let We = 0; We < bt; We++) {
                  const it = Ne.getUint16(), et = Ne.getUint16(), At = Ne.getInt32() >>> 0;
                  let It = !1;
                  if (!(ht && ht.platformId === it && ht.encodingId === et)) {
                    if (it === 0 && (et === 0 || et === 1 || et === 3))
                      It = !0;
                    else if (it === 1 && et === 0)
                      It = !0;
                    else if (it === 3 && et === 1 && (tt || !ht))
                      It = !0, rt || (vt = !0);
                    else if (rt && it === 3 && et === 0) {
                      It = !0;
                      let Vt = !0;
                      if (We < bt - 1) {
                        const Ut = Ne.peekBytes(2);
                        b(Ut[0], Ut[1]) < it && (Vt = !1);
                      }
                      Vt && (vt = !0);
                    }
                    if (It && (ht = {
                      platformId: it,
                      encodingId: et,
                      offset: At
                    }), vt)
                      break;
                  }
                }
                if (ht && (Ne.pos = Ct + ht.offset), !ht || Ne.peekByte() === -1)
                  return (0, t.warn)("Could not find a preferred cmap table."), {
                    platformId: -1,
                    encodingId: -1,
                    mappings: [],
                    hasShortCmap: !1
                  };
                const _t = Ne.getUint16();
                let Nt = !1;
                const Mt = [];
                let Et, Re;
                if (_t === 0) {
                  for (Ne.skip(4), Et = 0; Et < 256; Et++) {
                    const We = Ne.getByte();
                    We && Mt.push({
                      charCode: Et,
                      glyphId: We
                    });
                  }
                  Nt = !0;
                } else if (_t === 2) {
                  Ne.skip(4);
                  const We = [];
                  let it = 0;
                  for (let At = 0; At < 256; At++) {
                    const It = Ne.getUint16() >> 3;
                    We.push(It), it = Math.max(It, it);
                  }
                  const et = [];
                  for (let At = 0; At <= it; At++)
                    et.push({
                      firstCode: Ne.getUint16(),
                      entryCount: Ne.getUint16(),
                      idDelta: _(Ne.getByte(), Ne.getByte()),
                      idRangePos: Ne.pos + Ne.getUint16()
                    });
                  for (let At = 0; At < 256; At++)
                    if (We[At] === 0)
                      Ne.pos = et[0].idRangePos + 2 * At, Re = Ne.getUint16(), Mt.push({
                        charCode: At,
                        glyphId: Re
                      });
                    else {
                      const It = et[We[At]];
                      for (Et = 0; Et < It.entryCount; Et++) {
                        const Vt = (At << 8) + Et + It.firstCode;
                        Ne.pos = It.idRangePos + 2 * Et, Re = Ne.getUint16(), Re !== 0 && (Re = (Re + It.idDelta) % 65536), Mt.push({
                          charCode: Vt,
                          glyphId: Re
                        });
                      }
                    }
                } else if (_t === 4) {
                  Ne.skip(4);
                  const We = Ne.getUint16() >> 1;
                  Ne.skip(6);
                  const it = [];
                  let et;
                  for (et = 0; et < We; et++)
                    it.push({
                      end: Ne.getUint16()
                    });
                  for (Ne.skip(2), et = 0; et < We; et++)
                    it[et].start = Ne.getUint16();
                  for (et = 0; et < We; et++)
                    it[et].delta = Ne.getUint16();
                  let At = 0, It;
                  for (et = 0; et < We; et++) {
                    dt = it[et];
                    const Ut = Ne.getUint16();
                    if (!Ut) {
                      dt.offsetIndex = -1;
                      continue;
                    }
                    It = (Ut >> 1) - (We - et), dt.offsetIndex = It, At = Math.max(At, It + dt.end - dt.start + 1);
                  }
                  const Vt = [];
                  for (Et = 0; Et < At; Et++)
                    Vt.push(Ne.getUint16());
                  for (et = 0; et < We; et++) {
                    dt = it[et], Ct = dt.start;
                    const Ut = dt.end, Wt = dt.delta;
                    for (It = dt.offsetIndex, Et = Ct; Et <= Ut; Et++)
                      Et !== 65535 && (Re = It < 0 ? Et : Vt[It + Et - Ct], Re = Re + Wt & 65535, Mt.push({
                        charCode: Et,
                        glyphId: Re
                      }));
                  }
                } else if (_t === 6) {
                  Ne.skip(4);
                  const We = Ne.getUint16(), it = Ne.getUint16();
                  for (Et = 0; Et < it; Et++) {
                    Re = Ne.getUint16();
                    const et = We + Et;
                    Mt.push({
                      charCode: et,
                      glyphId: Re
                    });
                  }
                } else if (_t === 12) {
                  Ne.skip(10);
                  const We = Ne.getInt32() >>> 0;
                  for (Et = 0; Et < We; Et++) {
                    const it = Ne.getInt32() >>> 0, et = Ne.getInt32() >>> 0;
                    let At = Ne.getInt32() >>> 0;
                    for (let It = it; It <= et; It++)
                      Mt.push({
                        charCode: It,
                        glyphId: At++
                      });
                  }
                } else
                  return (0, t.warn)("cmap table has unsupported format: " + _t), {
                    platformId: -1,
                    encodingId: -1,
                    mappings: [],
                    hasShortCmap: !1
                  };
                Mt.sort(function(We, it) {
                  return We.charCode - it.charCode;
                });
                for (let We = 1; We < Mt.length; We++)
                  Mt[We - 1].charCode === Mt[We].charCode && (Mt.splice(We, 1), We--);
                return {
                  platformId: ht.platformId,
                  encodingId: ht.encodingId,
                  mappings: Mt,
                  hasShortCmap: Nt
                };
              }
              function Ae(Ge, Ne, rt, tt, dt, Ct) {
                if (!Ne) {
                  rt && (rt.data = null);
                  return;
                }
                Ge.pos = (Ge.start || 0) + Ne.offset, Ge.pos += 4, Ge.pos += 2, Ge.pos += 2, Ge.pos += 2, Ge.pos += 2, Ge.pos += 2, Ge.pos += 2, Ge.pos += 2, Ge.pos += 2, Ge.pos += 2;
                const bt = Ge.getUint16();
                Ge.pos += 8, Ge.pos += 2;
                let ht = Ge.getUint16();
                bt !== 0 && (b(tt.data[44], tt.data[45]) & 2 || (Ne.data[22] = 0, Ne.data[23] = 0)), ht > dt && ((0, t.info)(`The numOfMetrics (${ht}) should not be greater than the numGlyphs (${dt}).`), ht = dt, Ne.data[34] = (ht & 65280) >> 8, Ne.data[35] = ht & 255);
                const _t = dt - ht - (rt.length - ht * 4 >> 1);
                if (_t > 0) {
                  const Nt = new Uint8Array(rt.length + _t * 2);
                  Nt.set(rt.data), Ct && (Nt[rt.length] = rt.data[2], Nt[rt.length + 1] = rt.data[3]), rt.data = Nt;
                }
              }
              function De(Ge, Ne, rt, tt, dt, Ct) {
                const bt = {
                  length: 0,
                  sizeOfInstructions: 0
                };
                if (rt - Ne <= 12)
                  return bt;
                const ht = Ge.subarray(Ne, rt);
                let vt = _(ht[0], ht[1]);
                if (vt < 0)
                  return vt = -1, l(ht, 0, vt), tt.set(ht, dt), bt.length = ht.length, bt;
                let _t, Nt = 10, Mt = 0;
                for (_t = 0; _t < vt; _t++)
                  Mt = (ht[Nt] << 8 | ht[Nt + 1]) + 1, Nt += 2;
                const Et = Nt, Re = ht[Nt] << 8 | ht[Nt + 1];
                bt.sizeOfInstructions = Re, Nt += 2 + Re;
                const We = Nt;
                let it = 0;
                for (_t = 0; _t < Mt; _t++) {
                  const At = ht[Nt++];
                  At & 192 && (ht[Nt - 1] = At & 63);
                  let It = 2;
                  At & 2 ? It = 1 : At & 16 && (It = 0);
                  let Vt = 2;
                  At & 4 ? Vt = 1 : At & 32 && (Vt = 0);
                  const Ut = It + Vt;
                  if (it += Ut, At & 8) {
                    const Wt = ht[Nt++];
                    _t += Wt, it += Wt * Ut;
                  }
                }
                if (it === 0)
                  return bt;
                let et = Nt + it;
                return et > ht.length ? bt : !Ct && Re > 0 ? (tt.set(ht.subarray(0, Et), dt), tt.set([0, 0], dt + Et), tt.set(ht.subarray(We, et), dt + Et + 2), et -= Re, ht.length - et > 3 && (et = et + 3 & -4), bt.length = et, bt) : ht.length - et > 3 ? (et = et + 3 & -4, tt.set(ht.subarray(0, et), dt), bt.length = et, bt) : (tt.set(ht, dt), bt.length = ht.length, bt);
              }
              function xe(Ge, Ne, rt) {
                const tt = Ge.data, dt = S(tt[0], tt[1], tt[2], tt[3]);
                dt >> 16 !== 1 && ((0, t.info)("Attempting to fix invalid version in head table: " + dt), tt[0] = 0, tt[1] = 1, tt[2] = 0, tt[3] = 0);
                const Ct = b(tt[50], tt[51]);
                if (Ct < 0 || Ct > 1) {
                  (0, t.info)("Attempting to fix invalid indexToLocFormat in head table: " + Ct);
                  const bt = Ne + 1;
                  if (rt === bt << 1)
                    tt[50] = 0, tt[51] = 0;
                  else if (rt === bt << 2)
                    tt[50] = 0, tt[51] = 1;
                  else
                    throw new t.FormatError("Could not fix indexToLocFormat: " + Ct);
                }
              }
              function Te(Ge, Ne, rt, tt, dt, Ct, bt) {
                let ht, vt, _t;
                tt ? (ht = 4, vt = function(Kt, rn) {
                  return Kt[rn] << 24 | Kt[rn + 1] << 16 | Kt[rn + 2] << 8 | Kt[rn + 3];
                }, _t = function(Kt, rn, ln) {
                  Kt[rn] = ln >>> 24 & 255, Kt[rn + 1] = ln >> 16 & 255, Kt[rn + 2] = ln >> 8 & 255, Kt[rn + 3] = ln & 255;
                }) : (ht = 2, vt = function(Kt, rn) {
                  return Kt[rn] << 9 | Kt[rn + 1] << 1;
                }, _t = function(Kt, rn, ln) {
                  Kt[rn] = ln >> 9 & 255, Kt[rn + 1] = ln >> 1 & 255;
                });
                const Nt = Ct ? rt + 1 : rt, Mt = ht * (1 + Nt), Et = new Uint8Array(Mt);
                Et.set(Ge.data.subarray(0, Mt)), Ge.data = Et;
                const Re = Ne.data, We = Re.length, it = new Uint8Array(We);
                let et, At;
                const It = [];
                for (et = 0, At = 0; et < rt + 1; et++, At += ht) {
                  let Wt = vt(Et, At);
                  Wt > We && (Wt = We), It.push({
                    index: et,
                    offset: Wt,
                    endOffset: 0
                  });
                }
                for (It.sort((Wt, Kt) => Wt.offset - Kt.offset), et = 0; et < rt; et++)
                  It[et].endOffset = It[et + 1].offset;
                for (It.sort((Wt, Kt) => Wt.index - Kt.index), et = 0; et < rt; et++) {
                  const {
                    offset: Wt,
                    endOffset: Kt
                  } = It[et];
                  if (Wt !== 0 || Kt !== 0)
                    break;
                  const rn = It[et + 1].offset;
                  if (rn !== 0) {
                    It[et].endOffset = rn;
                    break;
                  }
                }
                const Vt = /* @__PURE__ */ Object.create(null);
                let Ut = 0;
                for (_t(Et, 0, Ut), et = 0, At = ht; et < rt; et++, At += ht) {
                  const Wt = De(Re, It[et].offset, It[et].endOffset, it, Ut, dt), Kt = Wt.length;
                  Kt === 0 && (Vt[et] = !0), Wt.sizeOfInstructions > bt && (bt = Wt.sizeOfInstructions), Ut += Kt, _t(Et, At, Ut);
                }
                if (Ut === 0) {
                  const Wt = new Uint8Array([0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0]);
                  for (et = 0, At = ht; et < Nt; et++, At += ht)
                    _t(Et, At, Wt.length);
                  Ne.data = Wt;
                } else if (Ct) {
                  const Wt = vt(Et, ht);
                  it.length > Wt + Ut ? Ne.data = it.subarray(0, Wt + Ut) : (Ne.data = new Uint8Array(Wt + Ut), Ne.data.set(it.subarray(0, Ut))), Ne.data.set(it.subarray(0, Wt), Ut), _t(Ge.data, Et.length - ht, Ut + Wt);
                } else
                  Ne.data = it.subarray(0, Ut);
                return {
                  missingGlyphs: Vt,
                  maxSizeOfInstructions: bt
                };
              }
              function ve(Ge, Ne, rt) {
                const tt = (H.start || 0) + Ge.offset;
                H.pos = tt;
                const dt = Ge.length, Ct = tt + dt, bt = H.getInt32();
                H.skip(28);
                let ht, vt = !0, _t;
                switch (bt) {
                  case 65536:
                    ht = v.MacStandardGlyphOrdering;
                    break;
                  case 131072:
                    const Nt = H.getUint16();
                    if (Nt !== rt) {
                      vt = !1;
                      break;
                    }
                    const Mt = [];
                    for (_t = 0; _t < Nt; ++_t) {
                      const We = H.getUint16();
                      if (We >= 32768) {
                        vt = !1;
                        break;
                      }
                      Mt.push(We);
                    }
                    if (!vt)
                      break;
                    const Et = [], Re = [];
                    for (; H.pos < Ct; ) {
                      const We = H.getByte();
                      for (Re.length = We, _t = 0; _t < We; ++_t)
                        Re[_t] = String.fromCharCode(H.getByte());
                      Et.push(Re.join(""));
                    }
                    for (ht = [], _t = 0; _t < Nt; ++_t) {
                      const We = Mt[_t];
                      if (We < 258) {
                        ht.push(v.MacStandardGlyphOrdering[We]);
                        continue;
                      }
                      ht.push(Et[We - 258]);
                    }
                    break;
                  case 196608:
                    break;
                  default:
                    (0, t.warn)("Unknown/unsupported post table version " + bt), vt = !1, Ne.defaultEncoding && (ht = Ne.defaultEncoding);
                    break;
                }
                return Ne.glyphNames = ht, vt;
              }
              function Se(Ge) {
                const Ne = (H.start || 0) + Ge.offset;
                H.pos = Ne;
                const rt = [[], []], tt = Ge.length, dt = Ne + tt;
                if (H.getUint16() !== 0 || tt < 6)
                  return rt;
                const ht = H.getUint16(), vt = H.getUint16(), _t = [], Nt = 12;
                let Mt, Et;
                for (Mt = 0; Mt < ht && H.pos + Nt <= dt; Mt++) {
                  const Re = {
                    platform: H.getUint16(),
                    encoding: H.getUint16(),
                    language: H.getUint16(),
                    name: H.getUint16(),
                    length: H.getUint16(),
                    offset: H.getUint16()
                  };
                  (Re.platform === 1 && Re.encoding === 0 && Re.language === 0 || Re.platform === 3 && Re.encoding === 1 && Re.language === 1033) && _t.push(Re);
                }
                for (Mt = 0, Et = _t.length; Mt < Et; Mt++) {
                  const Re = _t[Mt];
                  if (Re.length <= 0)
                    continue;
                  const We = Ne + vt + Re.offset;
                  if (We + Re.length > dt)
                    continue;
                  H.pos = We;
                  const it = Re.name;
                  if (Re.encoding) {
                    let et = "";
                    for (let At = 0, It = Re.length; At < It; At += 2)
                      et += String.fromCharCode(H.getUint16());
                    rt[1][it] = et;
                  } else
                    rt[0][it] = H.getString(Re.length);
                }
                return rt;
              }
              const be = [0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1, 0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2, 0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1, -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];
              function Le(Ge, Ne) {
                let rt = Ge.data, tt = 0, dt, Ct, bt, ht, vt, _t = 0, Nt = 0;
                const Mt = [], Et = [], Re = [];
                let We = Ne.tooComplexToFollowFunctions, it = !1, et = 0, At = 0;
                for (let Vt = rt.length; tt < Vt; ) {
                  const Ut = rt[tt++];
                  if (Ut === 64)
                    if (Ct = rt[tt++], it || At)
                      tt += Ct;
                    else
                      for (dt = 0; dt < Ct; dt++)
                        Mt.push(rt[tt++]);
                  else if (Ut === 65)
                    if (Ct = rt[tt++], it || At)
                      tt += Ct * 2;
                    else
                      for (dt = 0; dt < Ct; dt++)
                        bt = rt[tt++], Mt.push(bt << 8 | rt[tt++]);
                  else if ((Ut & 248) === 176)
                    if (Ct = Ut - 176 + 1, it || At)
                      tt += Ct;
                    else
                      for (dt = 0; dt < Ct; dt++)
                        Mt.push(rt[tt++]);
                  else if ((Ut & 248) === 184)
                    if (Ct = Ut - 184 + 1, it || At)
                      tt += Ct * 2;
                    else
                      for (dt = 0; dt < Ct; dt++)
                        bt = rt[tt++], Mt.push(bt << 8 | rt[tt++]);
                  else if (Ut === 43 && !We) {
                    if (!it && !At) {
                      if (ht = Mt.at(-1), isNaN(ht))
                        (0, t.info)("TT: CALL empty stack (or invalid entry).");
                      else if (Ne.functionsUsed[ht] = !0, ht in Ne.functionsStackDeltas) {
                        const Wt = Mt.length + Ne.functionsStackDeltas[ht];
                        if (Wt < 0) {
                          (0, t.warn)("TT: CALL invalid functions stack delta."), Ne.hintsValid = !1;
                          return;
                        }
                        Mt.length = Wt;
                      } else if (ht in Ne.functionsDefined && !Re.includes(ht)) {
                        if (Et.push({
                          data: rt,
                          i: tt,
                          stackTop: Mt.length - 1
                        }), Re.push(ht), vt = Ne.functionsDefined[ht], !vt) {
                          (0, t.warn)("TT: CALL non-existent function"), Ne.hintsValid = !1;
                          return;
                        }
                        rt = vt.data, tt = vt.i;
                      }
                    }
                  } else if (Ut === 44 && !We)
                    (it || At) && ((0, t.warn)("TT: nested FDEFs not allowed"), We = !0), it = !0, Nt = tt, ht = Mt.pop(), Ne.functionsDefined[ht] = {
                      data: rt,
                      i: tt
                    };
                  else if (Ut === 45)
                    if (it)
                      it = !1, _t = tt;
                    else {
                      if (vt = Et.pop(), !vt) {
                        (0, t.warn)("TT: ENDF bad stack"), Ne.hintsValid = !1;
                        return;
                      }
                      ht = Re.pop(), rt = vt.data, tt = vt.i, Ne.functionsStackDeltas[ht] = Mt.length - vt.stackTop;
                    }
                  else if (Ut === 137)
                    (it || At) && ((0, t.warn)("TT: nested IDEFs not allowed"), We = !0), it = !0, Nt = tt;
                  else if (Ut === 88)
                    ++et;
                  else if (Ut === 27)
                    At = et;
                  else if (Ut === 89)
                    At === et && (At = 0), --et;
                  else if (Ut === 28 && !it && !At) {
                    const Wt = Mt.at(-1);
                    Wt > 0 && (tt += Wt - 1);
                  }
                  if (!it && !At) {
                    let Wt = 0;
                    for (Ut <= 142 ? Wt = be[Ut] : Ut >= 192 && Ut <= 223 ? Wt = -1 : Ut >= 224 && (Wt = -2), Ut >= 113 && Ut <= 117 && (Ct = Mt.pop(), isNaN(Ct) || (Wt = -Ct * 2)); Wt < 0 && Mt.length > 0; )
                      Mt.pop(), Wt++;
                    for (; Wt > 0; )
                      Mt.push(NaN), Wt--;
                  }
                }
                Ne.tooComplexToFollowFunctions = We;
                const It = [rt];
                tt > rt.length && It.push(new Uint8Array(tt - rt.length)), Nt > _t && ((0, t.warn)("TT: complementing a missing function tail"), It.push(new Uint8Array([34, 45]))), nt(Ge, It);
              }
              function ze(Ge, Ne) {
                if (!Ge.tooComplexToFollowFunctions) {
                  if (Ge.functionsDefined.length > Ne) {
                    (0, t.warn)("TT: more functions defined than expected"), Ge.hintsValid = !1;
                    return;
                  }
                  for (let rt = 0, tt = Ge.functionsUsed.length; rt < tt; rt++) {
                    if (rt > Ne) {
                      (0, t.warn)("TT: invalid function id: " + rt), Ge.hintsValid = !1;
                      return;
                    }
                    if (Ge.functionsUsed[rt] && !Ge.functionsDefined[rt]) {
                      (0, t.warn)("TT: undefined function: " + rt), Ge.hintsValid = !1;
                      return;
                    }
                  }
                }
              }
              function nt(Ge, Ne) {
                if (Ne.length > 1) {
                  let rt = 0, tt, dt;
                  for (tt = 0, dt = Ne.length; tt < dt; tt++)
                    rt += Ne[tt].length;
                  rt = rt + 3 & -4;
                  const Ct = new Uint8Array(rt);
                  let bt = 0;
                  for (tt = 0, dt = Ne.length; tt < dt; tt++)
                    Ct.set(Ne[tt], bt), bt += Ne[tt].length;
                  Ge.data = Ct, Ge.length = rt;
                }
              }
              function Ue(Ge, Ne, rt, tt) {
                const dt = {
                  functionsDefined: [],
                  functionsUsed: [],
                  functionsStackDeltas: [],
                  tooComplexToFollowFunctions: !1,
                  hintsValid: !0
                };
                if (Ge && Le(Ge, dt), Ne && Le(Ne, dt), Ge && ze(dt, tt), rt && rt.length & 1) {
                  const Ct = new Uint8Array(rt.length + 1);
                  Ct.set(rt.data), rt.data = Ct;
                }
                return dt.hintsValid;
              }
              H = new m.Stream(new Uint8Array(H.getBytes()));
              let Oe, _e;
              if (O(H)) {
                const Ge = Fe(H, this.name);
                Oe = Ge.header, _e = Ge.tables;
              } else
                Oe = fe(H), _e = he(H, Oe.numTables);
              let at, Je;
              const ot = !_e["CFF "];
              if (ot) {
                if (!_e.loca)
                  throw new t.FormatError('Required "loca" table is not found');
                _e.glyf || ((0, t.warn)('Required "glyf" table is not found -- trying to recover.'), _e.glyf = {
                  tag: "glyf",
                  data: new Uint8Array(0)
                }), this.isOpenType = !1;
              } else {
                const Ge = ne.composite && ((ne.cidToGidMap || []).length > 0 || !(ne.cMap instanceof o.IdentityCMap));
                if (Oe.version === "OTTO" && !Ge || !_e.head || !_e.hhea || !_e.maxp || !_e.post)
                  return Je = new m.Stream(_e["CFF "].data), at = new g.CFFFont(Je, ne), j(ne), this.convert(k, at, ne);
                delete _e.glyf, delete _e.loca, delete _e.fpgm, delete _e.prep, delete _e["cvt "], this.isOpenType = !0;
              }
              if (!_e.maxp)
                throw new t.FormatError('Required "maxp" table is not found');
              H.pos = (H.start || 0) + _e.maxp.offset;
              const mt = H.getInt32(), Ze = H.getUint16();
              if (ne.scaleFactors && ne.scaleFactors.length === Ze && ot) {
                const {
                  scaleFactors: Ge
                } = ne, Ne = b(_e.head.data[50], _e.head.data[51]), rt = new n.GlyfTable({
                  glyfTable: _e.glyf.data,
                  isGlyphLocationsLong: Ne,
                  locaTable: _e.loca.data,
                  numGlyphs: Ze
                });
                rt.scale(Ge);
                const {
                  glyf: tt,
                  loca: dt,
                  isLocationLong: Ct
                } = rt.write();
                _e.glyf.data = tt, _e.loca.data = dt, Ct !== !!Ne && (_e.head.data[50] = 0, _e.head.data[51] = Ct ? 1 : 0);
                const bt = _e.hmtx.data;
                for (let ht = 0; ht < Ze; ht++) {
                  const vt = 4 * ht, _t = Math.round(Ge[ht] * b(bt[vt], bt[vt + 1]));
                  bt[vt] = _t >> 8 & 255, bt[vt + 1] = _t & 255;
                  const Nt = Math.round(Ge[ht] * _(bt[vt + 2], bt[vt + 3]));
                  l(bt, vt + 2, Nt);
                }
              }
              let pt = Ze + 1, Ft = !0;
              pt > 65535 && (Ft = !1, pt = Ze, (0, t.warn)("Not enough space in glyfs to duplicate first glyph."));
              let $e = 0, St = 0;
              mt >= 65536 && _e.maxp.length >= 22 && (H.pos += 8, H.getUint16() > 2 && (_e.maxp.data[14] = 0, _e.maxp.data[15] = 2), H.pos += 4, $e = H.getUint16(), H.pos += 4, St = H.getUint16()), _e.maxp.data[4] = pt >> 8, _e.maxp.data[5] = pt & 255;
              const xt = Ue(_e.fpgm, _e.prep, _e["cvt "], $e);
              if (xt || (delete _e.fpgm, delete _e.prep, delete _e["cvt "]), Ae(H, _e.hhea, _e.hmtx, _e.head, pt, Ft), !_e.head)
                throw new t.FormatError('Required "head" table is not found');
              xe(_e.head, Ze, ot ? _e.loca.length : 0);
              let Ie = /* @__PURE__ */ Object.create(null);
              if (ot) {
                const Ge = b(_e.head.data[50], _e.head.data[51]), Ne = Te(_e.loca, _e.glyf, Ze, Ge, xt, Ft, St);
                Ie = Ne.missingGlyphs, mt >= 65536 && _e.maxp.length >= 22 && (_e.maxp.data[26] = Ne.maxSizeOfInstructions >> 8, _e.maxp.data[27] = Ne.maxSizeOfInstructions & 255);
              }
              if (!_e.hhea)
                throw new t.FormatError('Required "hhea" table is not found');
              _e.hhea.data[10] === 0 && _e.hhea.data[11] === 0 && (_e.hhea.data[10] = 255, _e.hhea.data[11] = 255);
              const Ve = {
                unitsPerEm: b(_e.head.data[18], _e.head.data[19]),
                yMax: b(_e.head.data[42], _e.head.data[43]),
                yMin: _(_e.head.data[38], _e.head.data[39]),
                ascent: _(_e.hhea.data[4], _e.hhea.data[5]),
                descent: _(_e.hhea.data[6], _e.hhea.data[7]),
                lineGap: _(_e.hhea.data[8], _e.hhea.data[9])
              };
              this.ascent = Ve.ascent / Ve.unitsPerEm, this.descent = Ve.descent / Ve.unitsPerEm, this.lineGap = Ve.lineGap / Ve.unitsPerEm, this.cssFontInfo && this.cssFontInfo.lineHeight ? (this.lineHeight = this.cssFontInfo.metrics.lineHeight, this.lineGap = this.cssFontInfo.metrics.lineGap) : this.lineHeight = this.ascent - this.descent + this.lineGap, _e.post && ve(_e.post, ne, Ze), _e.post = {
                tag: "post",
                data: Z(ne)
              };
              const st = [];
              function ct(Ge) {
                return !Ie[Ge];
              }
              if (ne.composite) {
                const Ge = ne.cidToGidMap || [], Ne = Ge.length === 0;
                ne.cMap.forEach(function(rt, tt) {
                  if (typeof tt == "string" && (tt = L(rt, tt, !0)), tt > 65535)
                    throw new t.FormatError("Max size of CID is 65,535");
                  let dt = -1;
                  Ne ? dt = tt : Ge[tt] !== void 0 && (dt = Ge[tt]), dt >= 0 && dt < Ze && ct(dt) && (st[rt] = dt);
                });
              } else {
                const Ge = we(_e.cmap, H, this.isSymbolicFont, ne.hasEncoding), Ne = Ge.platformId, rt = Ge.encodingId, tt = Ge.mappings, dt = tt.length;
                let Ct = [], bt = !1;
                if (ne.hasEncoding && (ne.baseEncodingName === "MacRomanEncoding" || ne.baseEncodingName === "WinAnsiEncoding") && (Ct = (0, y.getEncoding)(ne.baseEncodingName)), ne.hasEncoding && !this.isSymbolicFont && (Ne === 3 && rt === 1 || Ne === 1 && rt === 0)) {
                  const ht = (0, e.getGlyphsUnicode)();
                  for (let vt = 0; vt < 256; vt++) {
                    let _t;
                    if (this.differences[vt] !== void 0 ? _t = this.differences[vt] : Ct.length && Ct[vt] !== "" ? _t = Ct[vt] : _t = y.StandardEncoding[vt], !_t)
                      continue;
                    const Nt = (0, v.recoverGlyphName)(_t, ht);
                    let Mt;
                    if (Ne === 3 && rt === 1 ? Mt = ht[Nt] : Ne === 1 && rt === 0 && (Mt = y.MacRomanEncoding.indexOf(Nt)), Mt === void 0) {
                      if (!ne.glyphNames && ne.hasIncludedToUnicodeMap && !(this.toUnicode instanceof h.IdentityToUnicodeMap)) {
                        const Et = this.toUnicode.get(vt);
                        Et && (Mt = Et.codePointAt(0));
                      }
                      if (Mt === void 0)
                        continue;
                    }
                    for (let Et = 0; Et < dt; ++Et)
                      if (tt[Et].charCode === Mt) {
                        st[vt] = tt[Et].glyphId;
                        break;
                      }
                  }
                } else if (Ne === 0) {
                  for (let ht = 0; ht < dt; ++ht)
                    st[tt[ht].charCode] = tt[ht].glyphId;
                  bt = !0;
                } else
                  for (let ht = 0; ht < dt; ++ht) {
                    let vt = tt[ht].charCode;
                    Ne === 3 && vt >= 61440 && vt <= 61695 && (vt &= 255), st[vt] = tt[ht].glyphId;
                  }
                if (ne.glyphNames && (Ct.length || this.differences.length))
                  for (let ht = 0; ht < 256; ++ht) {
                    if (!bt && st[ht] !== void 0)
                      continue;
                    const vt = this.differences[ht] || Ct[ht];
                    if (!vt)
                      continue;
                    const _t = ne.glyphNames.indexOf(vt);
                    _t > 0 && ct(_t) && (st[ht] = _t);
                  }
              }
              st.length === 0 && (st[0] = 0);
              let Rt = pt - 1;
              if (Ft || (Rt = 0), !ne.cssFontInfo) {
                const Ge = Y(st, ct, Rt, this.toUnicode);
                this.toFontChar = Ge.toFontChar, _e.cmap = {
                  tag: "cmap",
                  data: ie(Ge.charCodeToGlyphId, Ge.toUnicodeExtraMap, pt)
                }, (!_e["OS/2"] || !q(_e["OS/2"], H)) && (_e["OS/2"] = {
                  tag: "OS/2",
                  data: N(ne, Ge.charCodeToGlyphId, Ve)
                });
              }
              if (!ot)
                try {
                  Je = new m.Stream(_e["CFF "].data), at = new i.CFFParser(Je, ne, v.SEAC_ANALYSIS_ENABLED).parse(), at.duplicateFirstGlyph();
                  const Ne = new i.CFFCompiler(at);
                  _e["CFF "].data = Ne.compile();
                } catch {
                  (0, t.warn)("Failed to compile font " + ne.loadedName);
                }
              if (!_e.name)
                _e.name = {
                  tag: "name",
                  data: te(this.name)
                };
              else {
                const Ge = Se(_e.name);
                _e.name.data = te(k, Ge), this.psName = Ge[0][6] || null;
              }
              const Lt = new x.OpenTypeFileBuilder(Oe.version);
              for (const Ge in _e)
                Lt.addTable(Ge, _e[Ge].data);
              return Lt.toArray();
            }
            convert(k, H, ne) {
              ne.fixedPitch = !1, ne.builtInEncoding && B(ne, ne.builtInEncoding);
              let ae = 1;
              H instanceof g.CFFFont && (ae = H.numGlyphs - 1);
              const he = H.getGlyphMapping(ne);
              let ue = null, fe = he, me = null;
              ne.cssFontInfo || (ue = Y(he, H.hasGlyphId.bind(H), ae, this.toUnicode), this.toFontChar = ue.toFontChar, fe = ue.charCodeToGlyphId, me = ue.toUnicodeExtraMap);
              const Fe = H.numGlyphs;
              function we(ve, Se) {
                let be = null;
                for (const Le in ve)
                  Se === ve[Le] && (be || (be = []), be.push(Le | 0));
                return be;
              }
              function Ae(ve, Se) {
                for (const be in ve)
                  if (Se === ve[be])
                    return be | 0;
                return ue.charCodeToGlyphId[ue.nextAvailableFontCharCode] = Se, ue.nextAvailableFontCharCode++;
              }
              const De = H.seacs;
              if (ue && v.SEAC_ANALYSIS_ENABLED && De && De.length) {
                const ve = ne.fontMatrix || t.FONT_IDENTITY_MATRIX, Se = H.getCharset(), be = /* @__PURE__ */ Object.create(null);
                for (let Le in De) {
                  Le |= 0;
                  const ze = De[Le], nt = y.StandardEncoding[ze[2]], Ue = y.StandardEncoding[ze[3]], Oe = Se.indexOf(nt), _e = Se.indexOf(Ue);
                  if (Oe < 0 || _e < 0)
                    continue;
                  const at = {
                    x: ze[0] * ve[0] + ze[1] * ve[2] + ve[4],
                    y: ze[0] * ve[1] + ze[1] * ve[3] + ve[5]
                  }, Je = we(he, Le);
                  if (Je)
                    for (let ot = 0, mt = Je.length; ot < mt; ot++) {
                      const Ze = Je[ot], pt = ue.charCodeToGlyphId, Ft = Ae(pt, Oe), $e = Ae(pt, _e);
                      be[Ze] = {
                        baseFontCharCode: Ft,
                        accentFontCharCode: $e,
                        accentOffset: at
                      };
                    }
                }
                ne.seacMap = be;
              }
              const xe = 1 / (ne.fontMatrix || t.FONT_IDENTITY_MATRIX)[0], Te = new x.OpenTypeFileBuilder("OTTO");
              return Te.addTable("CFF ", H.data), Te.addTable("OS/2", N(ne, fe)), Te.addTable("cmap", ie(fe, me, Fe)), Te.addTable("head", "\0\0\0\0\0\0\0\0\0\0_<õ\0\0" + F(xe) + "\0\0\0\0\v~'\0\0\0\0\v~'\0\0" + F(ne.descent) + "ÿ" + F(ne.ascent) + A(ne.italicAngle ? 2 : 0) + "\0\0\0\0\0\0\0"), Te.addTable("hhea", "\0\0\0" + F(ne.ascent) + F(ne.descent) + "\0\0ÿÿ\0\0\0\0\0\0" + F(ne.capHeight) + F(Math.tan(ne.italicAngle) * ne.xHeight) + "\0\0\0\0\0\0\0\0\0\0\0\0" + A(Fe)), Te.addTable("hmtx", function() {
                const Se = H.charstrings, be = H.cff ? H.cff.widths : null;
                let Le = "\0\0\0\0";
                for (let ze = 1, nt = Fe; ze < nt; ze++) {
                  let Ue = 0;
                  if (Se) {
                    const Oe = Se[ze - 1];
                    Ue = "width" in Oe ? Oe.width : 0;
                  } else
                    be && (Ue = Math.ceil(be[ze] || 0));
                  Le += A(Ue) + A(0);
                }
                return Le;
              }()), Te.addTable("maxp", "\0\0P\0" + A(Fe)), Te.addTable("name", te(k)), Te.addTable("post", Z(ne)), Te.toArray();
            }
            get spaceWidth() {
              const k = ["space", "minus", "one", "i", "I"];
              let H;
              for (let ne = 0, ae = k.length; ne < ae; ne++) {
                const he = k[ne];
                if (he in this.widths) {
                  H = this.widths[he];
                  break;
                }
                const fe = (0, e.getGlyphsUnicode)()[he];
                let me = 0;
                if (this.composite && this.cMap.contains(fe) && (me = this.cMap.lookup(fe), typeof me == "string" && (me = L(fe, me))), !me && this.toUnicode && (me = this.toUnicode.charCodeOf(fe)), me <= 0 && (me = fe), H = this.widths[me], H)
                  break;
              }
              return H = H || this.defaultWidth, (0, t.shadow)(this, "spaceWidth", H);
            }
            _charToGlyph(k, H = !1) {
              let ne, ae, he, ue = k;
              this.cMap && this.cMap.contains(k) && (ue = this.cMap.lookup(k), typeof ue == "string" && (ue = L(k, ue))), ae = this.widths[ue], typeof ae != "number" && (ae = this.defaultWidth);
              const fe = this.vmetrics && this.vmetrics[ue];
              let me = this.toUnicode.get(k) || k;
              typeof me == "number" && (me = String.fromCharCode(me));
              let Fe = this.toFontChar[k] !== void 0;
              if (ne = this.toFontChar[k] || k, this.missingFile) {
                const xe = this.differences[k] || this.defaultEncoding[k];
                (xe === ".notdef" || xe === "") && this.type === "Type1" && (ne = 32), ne = (0, a.mapSpecialUnicodeValues)(ne);
              }
              this.isType3Font && (he = ne);
              let we = null;
              if (this.seacMap && this.seacMap[k]) {
                Fe = !0;
                const xe = this.seacMap[k];
                ne = xe.baseFontCharCode, we = {
                  fontChar: String.fromCodePoint(xe.accentFontCharCode),
                  offset: xe.accentOffset
                };
              }
              let Ae = "";
              typeof ne == "number" && (ne <= 1114111 ? Ae = String.fromCodePoint(ne) : (0, t.warn)(`charToGlyph - invalid fontCharCode: ${ne}`));
              let De = this._glyphCache[k];
              return (!De || !De.matchesForCache(k, Ae, me, we, ae, fe, he, H, Fe)) && (De = new D(k, Ae, me, we, ae, fe, he, H, Fe), this._glyphCache[k] = De), De;
            }
            charsToGlyphs(k) {
              let H = this._charsCache[k];
              if (H)
                return H;
              if (H = [], this.cMap) {
                const ne = /* @__PURE__ */ Object.create(null), ae = k.length;
                let he = 0;
                for (; he < ae; ) {
                  this.cMap.readCharCode(k, he, ne);
                  const {
                    charcode: ue,
                    length: fe
                  } = ne;
                  he += fe;
                  const me = this._charToGlyph(ue, fe === 1 && k.charCodeAt(he - 1) === 32);
                  H.push(me);
                }
              } else
                for (let ne = 0, ae = k.length; ne < ae; ++ne) {
                  const he = k.charCodeAt(ne), ue = this._charToGlyph(he, he === 32);
                  H.push(ue);
                }
              return this._charsCache[k] = H;
            }
            getCharPositions(k) {
              const H = [];
              if (this.cMap) {
                const ne = /* @__PURE__ */ Object.create(null);
                let ae = 0;
                for (; ae < k.length; ) {
                  this.cMap.readCharCode(k, ae, ne);
                  const he = ne.length;
                  H.push([ae, ae + he]), ae += he;
                }
              } else
                for (let ne = 0, ae = k.length; ne < ae; ++ne)
                  H.push([ne, ne + 1]);
              return H;
            }
            get glyphCacheValues() {
              return Object.values(this._glyphCache);
            }
            encodeString(k) {
              const H = [], ne = [], ae = () => H.length % 2 === 1, he = this.toUnicode instanceof h.IdentityToUnicodeMap ? (ue) => this.toUnicode.charCodeOf(ue) : (ue) => this.toUnicode.charCodeOf(String.fromCodePoint(ue));
              for (let ue = 0, fe = k.length; ue < fe; ue++) {
                const me = k.codePointAt(ue);
                if (me > 55295 && (me < 57344 || me > 65533) && ue++, this.toUnicode) {
                  const Fe = he(me);
                  if (Fe !== -1) {
                    ae() && (H.push(ne.join("")), ne.length = 0);
                    const we = this.cMap ? this.cMap.getCharCodeLength(Fe) : 1;
                    for (let Ae = we - 1; Ae >= 0; Ae--)
                      ne.push(String.fromCharCode(Fe >> 8 * Ae & 255));
                    continue;
                  }
                }
                ae() || (H.push(ne.join("")), ne.length = 0), ne.push(String.fromCodePoint(me));
              }
              return H.push(ne.join("")), H;
            }
          }
          u.Font = re;
          class ee {
            constructor(k) {
              this.error = k, this.loadedName = "g_font_error", this.missingFile = !0;
            }
            charsToGlyphs() {
              return [];
            }
            encodeString(k) {
              return [k];
            }
            exportData(k = !1) {
              return {
                error: this.error
              };
            }
          }
          u.ErrorFont = ee;
        },
        /* 35 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.CFFTopDict = u.CFFStrings = u.CFFStandardStrings = u.CFFPrivateDict = u.CFFParser = u.CFFIndex = u.CFFHeader = u.CFFFDSelect = u.CFFCompiler = u.CFFCharset = u.CFF = void 0;
          var t = P(2), i = P(36), v = P(37);
          const a = 10, e = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"];
          u.CFFStandardStrings = e;
          const y = 391, r = [null, {
            id: "hstem",
            min: 2,
            stackClearing: !0,
            stem: !0
          }, null, {
            id: "vstem",
            min: 2,
            stackClearing: !0,
            stem: !0
          }, {
            id: "vmoveto",
            min: 1,
            stackClearing: !0
          }, {
            id: "rlineto",
            min: 2,
            resetStack: !0
          }, {
            id: "hlineto",
            min: 1,
            resetStack: !0
          }, {
            id: "vlineto",
            min: 1,
            resetStack: !0
          }, {
            id: "rrcurveto",
            min: 6,
            resetStack: !0
          }, null, {
            id: "callsubr",
            min: 1,
            undefStack: !0
          }, {
            id: "return",
            min: 0,
            undefStack: !0
          }, null, null, {
            id: "endchar",
            min: 0,
            stackClearing: !0
          }, null, null, null, {
            id: "hstemhm",
            min: 2,
            stackClearing: !0,
            stem: !0
          }, {
            id: "hintmask",
            min: 0,
            stackClearing: !0
          }, {
            id: "cntrmask",
            min: 0,
            stackClearing: !0
          }, {
            id: "rmoveto",
            min: 2,
            stackClearing: !0
          }, {
            id: "hmoveto",
            min: 1,
            stackClearing: !0
          }, {
            id: "vstemhm",
            min: 2,
            stackClearing: !0,
            stem: !0
          }, {
            id: "rcurveline",
            min: 8,
            resetStack: !0
          }, {
            id: "rlinecurve",
            min: 8,
            resetStack: !0
          }, {
            id: "vvcurveto",
            min: 4,
            resetStack: !0
          }, {
            id: "hhcurveto",
            min: 4,
            resetStack: !0
          }, null, {
            id: "callgsubr",
            min: 1,
            undefStack: !0
          }, {
            id: "vhcurveto",
            min: 4,
            resetStack: !0
          }, {
            id: "hvcurveto",
            min: 4,
            resetStack: !0
          }], h = [null, null, null, {
            id: "and",
            min: 2,
            stackDelta: -1
          }, {
            id: "or",
            min: 2,
            stackDelta: -1
          }, {
            id: "not",
            min: 1,
            stackDelta: 0
          }, null, null, null, {
            id: "abs",
            min: 1,
            stackDelta: 0
          }, {
            id: "add",
            min: 2,
            stackDelta: -1,
            stackFn(D, b) {
              D[b - 2] = D[b - 2] + D[b - 1];
            }
          }, {
            id: "sub",
            min: 2,
            stackDelta: -1,
            stackFn(D, b) {
              D[b - 2] = D[b - 2] - D[b - 1];
            }
          }, {
            id: "div",
            min: 2,
            stackDelta: -1,
            stackFn(D, b) {
              D[b - 2] = D[b - 2] / D[b - 1];
            }
          }, null, {
            id: "neg",
            min: 1,
            stackDelta: 0,
            stackFn(D, b) {
              D[b - 1] = -D[b - 1];
            }
          }, {
            id: "eq",
            min: 2,
            stackDelta: -1
          }, null, null, {
            id: "drop",
            min: 1,
            stackDelta: -1
          }, null, {
            id: "put",
            min: 2,
            stackDelta: -2
          }, {
            id: "get",
            min: 1,
            stackDelta: 0
          }, {
            id: "ifelse",
            min: 4,
            stackDelta: -3
          }, {
            id: "random",
            min: 0,
            stackDelta: 1
          }, {
            id: "mul",
            min: 2,
            stackDelta: -1,
            stackFn(D, b) {
              D[b - 2] = D[b - 2] * D[b - 1];
            }
          }, null, {
            id: "sqrt",
            min: 1,
            stackDelta: 0
          }, {
            id: "dup",
            min: 1,
            stackDelta: 1
          }, {
            id: "exch",
            min: 2,
            stackDelta: 0
          }, {
            id: "index",
            min: 2,
            stackDelta: 0
          }, {
            id: "roll",
            min: 3,
            stackDelta: -2
          }, null, null, null, {
            id: "hflex",
            min: 7,
            resetStack: !0
          }, {
            id: "flex",
            min: 13,
            resetStack: !0
          }, {
            id: "hflex1",
            min: 9,
            resetStack: !0
          }, {
            id: "flex1",
            min: 11,
            resetStack: !0
          }];
          class g {
            constructor(b, l, _) {
              this.bytes = b.getBytes(), this.properties = l, this.seacAnalysisEnabled = !!_;
            }
            parse() {
              const b = this.properties, l = new d();
              this.cff = l;
              const _ = this.parseHeader(), S = this.parseIndex(_.endPos), A = this.parseIndex(S.endPos), F = this.parseIndex(A.endPos), T = this.parseIndex(F.endPos), O = this.parseDict(A.obj.get(0)), U = this.createDict(m, O, l.strings);
              l.header = _.obj, l.names = this.parseNameIndex(S.obj), l.strings = this.parseStringIndex(F.obj), l.topDict = U, l.globalSubrIndex = T.obj, this.parsePrivateDict(l.topDict), l.isCIDFont = U.hasName("ROS");
              const G = U.getByName("CharStrings"), K = this.parseIndex(G).obj, W = U.getByName("FontMatrix");
              W && (b.fontMatrix = W);
              const z = U.getByName("FontBBox");
              z && (b.ascent = Math.max(z[3], z[1]), b.descent = Math.min(z[1], z[3]), b.ascentScaled = !0);
              let V, L;
              if (l.isCIDFont) {
                const J = this.parseIndex(U.getByName("FDArray")).obj;
                for (let ie = 0, q = J.count; ie < q; ++ie) {
                  const N = J.get(ie), Z = this.createDict(m, this.parseDict(N), l.strings);
                  this.parsePrivateDict(Z), l.fdArray.push(Z);
                }
                L = null, V = this.parseCharsets(U.getByName("charset"), K.count, l.strings, !0), l.fdSelect = this.parseFDSelect(U.getByName("FDSelect"), K.count);
              } else
                V = this.parseCharsets(U.getByName("charset"), K.count, l.strings, !1), L = this.parseEncoding(U.getByName("Encoding"), b, l.strings, V.charset);
              l.charset = V, l.encoding = L;
              const Y = this.parseCharStrings({
                charStrings: K,
                localSubrIndex: U.privateDict.subrsIndex,
                globalSubrIndex: T.obj,
                fdSelect: l.fdSelect,
                fdArray: l.fdArray,
                privateDict: U.privateDict
              });
              return l.charStrings = Y.charStrings, l.seacs = Y.seacs, l.widths = Y.widths, l;
            }
            parseHeader() {
              let b = this.bytes;
              const l = b.length;
              let _ = 0;
              for (; _ < l && b[_] !== 1; )
                ++_;
              if (_ >= l)
                throw new t.FormatError("Invalid CFF header");
              _ !== 0 && ((0, t.info)("cff data is shifted"), b = b.subarray(_), this.bytes = b);
              const S = b[0], A = b[1], F = b[2], T = b[3];
              return {
                obj: new c(S, A, F, T),
                endPos: F
              };
            }
            parseDict(b) {
              let l = 0;
              function _() {
                let O = b[l++];
                return O === 30 ? S() : O === 28 ? (O = b[l++], O = (O << 24 | b[l++] << 16) >> 16, O) : O === 29 ? (O = b[l++], O = O << 8 | b[l++], O = O << 8 | b[l++], O = O << 8 | b[l++], O) : O >= 32 && O <= 246 ? O - 139 : O >= 247 && O <= 250 ? (O - 247) * 256 + b[l++] + 108 : O >= 251 && O <= 254 ? -((O - 251) * 256) - b[l++] - 108 : ((0, t.warn)('CFFParser_parseDict: "' + O + '" is a reserved command.'), NaN);
              }
              function S() {
                let O = "";
                const G = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"], K = b.length;
                for (; l < K; ) {
                  const W = b[l++], z = W >> 4, V = W & 15;
                  if (z === 15 || (O += G[z], V === 15))
                    break;
                  O += G[V];
                }
                return parseFloat(O);
              }
              let A = [];
              const F = [];
              l = 0;
              const T = b.length;
              for (; l < T; ) {
                let O = b[l];
                O <= 21 ? (O === 12 && (O = O << 8 | b[++l]), F.push([O, A]), A = [], ++l) : A.push(_());
              }
              return F;
            }
            parseIndex(b) {
              const l = new o(), _ = this.bytes, S = _[b++] << 8 | _[b++], A = [];
              let F = b, T, O;
              if (S !== 0) {
                const U = _[b++], G = b + (S + 1) * U - 1;
                for (T = 0, O = S + 1; T < O; ++T) {
                  let K = 0;
                  for (let W = 0; W < U; ++W)
                    K <<= 8, K += _[b++];
                  A.push(G + K);
                }
                F = A[S];
              }
              for (T = 0, O = A.length - 1; T < O; ++T) {
                const U = A[T], G = A[T + 1];
                l.add(_.subarray(U, G));
              }
              return {
                obj: l,
                endPos: F
              };
            }
            parseNameIndex(b) {
              const l = [];
              for (let _ = 0, S = b.count; _ < S; ++_) {
                const A = b.get(_);
                l.push((0, t.bytesToString)(A));
              }
              return l;
            }
            parseStringIndex(b) {
              const l = new n();
              for (let _ = 0, S = b.count; _ < S; ++_) {
                const A = b.get(_);
                l.add((0, t.bytesToString)(A));
              }
              return l;
            }
            createDict(b, l, _) {
              const S = new b(_);
              for (let A = 0, F = l.length; A < F; ++A) {
                const T = l[A], O = T[0], U = T[1];
                S.setByKey(O, U);
              }
              return S;
            }
            parseCharString(b, l, _, S) {
              if (!l || b.callDepth > a)
                return !1;
              let A = b.stackSize;
              const F = b.stack, T = l.length;
              for (let O = 0; O < T; ) {
                const U = l[O++];
                let G = null;
                if (U === 12) {
                  const K = l[O++];
                  K === 0 ? (l[O - 2] = 139, l[O - 1] = 22, A = 0) : G = h[K];
                } else if (U === 28)
                  F[A] = (l[O] << 24 | l[O + 1] << 16) >> 16, O += 2, A++;
                else if (U === 14) {
                  if (A >= 4 && (A -= 4, this.seacAnalysisEnabled))
                    return b.seac = F.slice(A, A + 4), !1;
                  G = r[U];
                } else if (U >= 32 && U <= 246)
                  F[A] = U - 139, A++;
                else if (U >= 247 && U <= 254)
                  F[A] = U < 251 ? (U - 247 << 8) + l[O] + 108 : -(U - 251 << 8) - l[O] - 108, O++, A++;
                else if (U === 255)
                  F[A] = (l[O] << 24 | l[O + 1] << 16 | l[O + 2] << 8 | l[O + 3]) / 65536, O += 4, A++;
                else if (U === 19 || U === 20)
                  b.hints += A >> 1, O += b.hints + 7 >> 3, A %= 2, G = r[U];
                else if (U === 10 || U === 29) {
                  let K;
                  if (U === 10 ? K = _ : K = S, !K)
                    return G = r[U], (0, t.warn)("Missing subrsIndex for " + G.id), !1;
                  let W = 32768;
                  K.count < 1240 ? W = 107 : K.count < 33900 && (W = 1131);
                  const z = F[--A] + W;
                  if (z < 0 || z >= K.count || isNaN(z))
                    return G = r[U], (0, t.warn)("Out of bounds subrIndex for " + G.id), !1;
                  if (b.stackSize = A, b.callDepth++, !this.parseCharString(b, K.get(z), _, S))
                    return !1;
                  b.callDepth--, A = b.stackSize;
                  continue;
                } else {
                  if (U === 11)
                    return b.stackSize = A, !0;
                  U === 0 && O === l.length ? (l[O - 1] = 14, G = r[14]) : G = r[U];
                }
                if (G) {
                  if (G.stem && (b.hints += A >> 1, U === 3 || U === 23 ? b.hasVStems = !0 : b.hasVStems && (U === 1 || U === 18) && ((0, t.warn)("CFF stem hints are in wrong order"), l[O - 1] = U === 1 ? 3 : 23)), "min" in G && !b.undefStack && A < G.min)
                    return (0, t.warn)("Not enough parameters for " + G.id + "; actual: " + A + ", expected: " + G.min), A === 0 ? (l[O - 1] = 14, !0) : !1;
                  b.firstStackClearing && G.stackClearing && (b.firstStackClearing = !1, A -= G.min, A >= 2 && G.stem ? A %= 2 : A > 1 && (0, t.warn)("Found too many parameters for stack-clearing command"), A > 0 && (b.width = F[A - 1])), "stackDelta" in G ? ("stackFn" in G && G.stackFn(F, A), A += G.stackDelta) : G.stackClearing ? A = 0 : G.resetStack ? (A = 0, b.undefStack = !1) : G.undefStack && (A = 0, b.undefStack = !0, b.firstStackClearing = !1);
                }
              }
              return b.stackSize = A, !0;
            }
            parseCharStrings({
              charStrings: b,
              localSubrIndex: l,
              globalSubrIndex: _,
              fdSelect: S,
              fdArray: A,
              privateDict: F
            }) {
              const T = [], O = [], U = b.count;
              for (let G = 0; G < U; G++) {
                const K = b.get(G), W = {
                  callDepth: 0,
                  stackSize: 0,
                  stack: [],
                  undefStack: !0,
                  hints: 0,
                  firstStackClearing: !0,
                  seac: null,
                  width: null,
                  hasVStems: !1
                };
                let z = !0, V = null, L = F;
                if (S && A.length) {
                  const Y = S.getFDIndex(G);
                  Y === -1 && ((0, t.warn)("Glyph index is not in fd select."), z = !1), Y >= A.length && ((0, t.warn)("Invalid fd index for glyph index."), z = !1), z && (L = A[Y].privateDict, V = L.subrsIndex);
                } else
                  l && (V = l);
                if (z && (z = this.parseCharString(W, K, V, _)), W.width !== null) {
                  const Y = L.getByName("nominalWidthX");
                  O[G] = Y + W.width;
                } else {
                  const Y = L.getByName("defaultWidthX");
                  O[G] = Y;
                }
                W.seac !== null && (T[G] = W.seac), z || b.set(G, new Uint8Array([14]));
              }
              return {
                charStrings: b,
                seacs: T,
                widths: O
              };
            }
            emptyPrivateDictionary(b) {
              const l = this.createDict(p, [], b.strings);
              b.setByKey(18, [0, 0]), b.privateDict = l;
            }
            parsePrivateDict(b) {
              if (!b.hasName("Private")) {
                this.emptyPrivateDictionary(b);
                return;
              }
              const l = b.getByName("Private");
              if (!Array.isArray(l) || l.length !== 2) {
                b.removeByName("Private");
                return;
              }
              const _ = l[0], S = l[1];
              if (_ === 0 || S >= this.bytes.length) {
                this.emptyPrivateDictionary(b);
                return;
              }
              const A = S + _, F = this.bytes.subarray(S, A), T = this.parseDict(F), O = this.createDict(p, T, b.strings);
              if (b.privateDict = O, !O.getByName("Subrs"))
                return;
              const U = O.getByName("Subrs"), G = S + U;
              if (U === 0 || G >= this.bytes.length) {
                this.emptyPrivateDictionary(b);
                return;
              }
              const K = this.parseIndex(G);
              O.subrsIndex = K.obj;
            }
            parseCharsets(b, l, _, S) {
              if (b === 0)
                return new X(!0, w.ISO_ADOBE, i.ISOAdobeCharset);
              if (b === 1)
                return new X(!0, w.EXPERT, i.ExpertCharset);
              if (b === 2)
                return new X(!0, w.EXPERT_SUBSET, i.ExpertSubsetCharset);
              const A = this.bytes, F = b, T = A[b++], O = [S ? 0 : ".notdef"];
              let U, G, K;
              switch (l -= 1, T) {
                case 0:
                  for (K = 0; K < l; K++)
                    U = A[b++] << 8 | A[b++], O.push(S ? U : _.get(U));
                  break;
                case 1:
                  for (; O.length <= l; )
                    for (U = A[b++] << 8 | A[b++], G = A[b++], K = 0; K <= G; K++)
                      O.push(S ? U++ : _.get(U++));
                  break;
                case 2:
                  for (; O.length <= l; )
                    for (U = A[b++] << 8 | A[b++], G = A[b++] << 8 | A[b++], K = 0; K <= G; K++)
                      O.push(S ? U++ : _.get(U++));
                  break;
                default:
                  throw new t.FormatError("Unknown charset format");
              }
              const W = b, z = A.subarray(F, W);
              return new X(!1, T, O, z);
            }
            parseEncoding(b, l, _, S) {
              const A = /* @__PURE__ */ Object.create(null), F = this.bytes;
              let T = !1, O, U, G, K = null;
              function W() {
                const z = F[b++];
                for (U = 0; U < z; U++) {
                  const V = F[b++], L = (F[b++] << 8) + (F[b++] & 255);
                  A[V] = S.indexOf(_.get(L));
                }
              }
              if (b === 0 || b === 1) {
                T = !0, O = b;
                const z = b ? v.ExpertEncoding : v.StandardEncoding;
                for (U = 0, G = S.length; U < G; U++) {
                  const V = z.indexOf(S[U]);
                  V !== -1 && (A[V] = U);
                }
              } else {
                const z = b;
                switch (O = F[b++], O & 127) {
                  case 0:
                    const L = F[b++];
                    for (U = 1; U <= L; U++)
                      A[F[b++]] = U;
                    break;
                  case 1:
                    const Y = F[b++];
                    let J = 1;
                    for (U = 0; U < Y; U++) {
                      const ie = F[b++], q = F[b++];
                      for (let N = ie; N <= ie + q; N++)
                        A[N] = J++;
                    }
                    break;
                  default:
                    throw new t.FormatError(`Unknown encoding format: ${O} in CFF`);
                }
                const V = b;
                O & 128 && (F[z] &= 127, W()), K = F.subarray(z, V);
              }
              return O &= 127, new M(T, O, A, K);
            }
            parseFDSelect(b, l) {
              const _ = this.bytes, S = _[b++], A = [];
              let F;
              switch (S) {
                case 0:
                  for (F = 0; F < l; ++F) {
                    const O = _[b++];
                    A.push(O);
                  }
                  break;
                case 3:
                  const T = _[b++] << 8 | _[b++];
                  for (F = 0; F < T; ++F) {
                    let O = _[b++] << 8 | _[b++];
                    F === 0 && O !== 0 && ((0, t.warn)("parseFDSelect: The first range must have a first GID of 0 -- trying to recover."), O = 0);
                    const U = _[b++], G = _[b] << 8 | _[b + 1];
                    for (let K = O; K < G; ++K)
                      A.push(U);
                  }
                  b += 2;
                  break;
                default:
                  throw new t.FormatError(`parseFDSelect: Unknown format "${S}".`);
              }
              if (A.length !== l)
                throw new t.FormatError("parseFDSelect: Invalid font data.");
              return new j(S, A);
            }
          }
          u.CFFParser = g;
          class d {
            constructor() {
              this.header = null, this.names = [], this.topDict = null, this.strings = new n(), this.globalSubrIndex = null, this.encoding = null, this.charset = null, this.charStrings = null, this.fdArray = [], this.fdSelect = null, this.isCIDFont = !1;
            }
            duplicateFirstGlyph() {
              if (this.charStrings.count >= 65535) {
                (0, t.warn)("Not enough space in charstrings to duplicate first glyph.");
                return;
              }
              const b = this.charStrings.get(0);
              this.charStrings.add(b), this.isCIDFont && this.fdSelect.fdSelect.push(this.fdSelect.fdSelect[0]);
            }
            hasGlyphId(b) {
              return b < 0 || b >= this.charStrings.count ? !1 : this.charStrings.get(b).length > 0;
            }
          }
          u.CFF = d;
          class c {
            constructor(b, l, _, S) {
              this.major = b, this.minor = l, this.hdrSize = _, this.offSize = S;
            }
          }
          u.CFFHeader = c;
          class n {
            constructor() {
              this.strings = [];
            }
            get(b) {
              return b >= 0 && b <= y - 1 ? e[b] : b - y <= this.strings.length ? this.strings[b - y] : e[0];
            }
            getSID(b) {
              let l = e.indexOf(b);
              return l !== -1 ? l : (l = this.strings.indexOf(b), l !== -1 ? l + y : -1);
            }
            add(b) {
              this.strings.push(b);
            }
            get count() {
              return this.strings.length;
            }
          }
          u.CFFStrings = n;
          class o {
            constructor() {
              this.objects = [], this.length = 0;
            }
            add(b) {
              this.length += b.length, this.objects.push(b);
            }
            set(b, l) {
              this.length += l.length - this.objects[b].length, this.objects[b] = l;
            }
            get(b) {
              return this.objects[b];
            }
            get count() {
              return this.objects.length;
            }
          }
          u.CFFIndex = o;
          class x {
            constructor(b, l) {
              this.keyToNameMap = b.keyToNameMap, this.nameToKeyMap = b.nameToKeyMap, this.defaults = b.defaults, this.types = b.types, this.opcodes = b.opcodes, this.order = b.order, this.strings = l, this.values = /* @__PURE__ */ Object.create(null);
            }
            setByKey(b, l) {
              if (!(b in this.keyToNameMap))
                return !1;
              const _ = l.length;
              if (_ === 0)
                return !0;
              for (let A = 0; A < _; A++)
                if (isNaN(l[A]))
                  return (0, t.warn)('Invalid CFFDict value: "' + l + '" for key "' + b + '".'), !0;
              const S = this.types[b];
              return (S === "num" || S === "sid" || S === "offset") && (l = l[0]), this.values[b] = l, !0;
            }
            setByName(b, l) {
              if (!(b in this.nameToKeyMap))
                throw new t.FormatError(`Invalid dictionary name "${b}"`);
              this.values[this.nameToKeyMap[b]] = l;
            }
            hasName(b) {
              return this.nameToKeyMap[b] in this.values;
            }
            getByName(b) {
              if (!(b in this.nameToKeyMap))
                throw new t.FormatError(`Invalid dictionary name ${b}"`);
              const l = this.nameToKeyMap[b];
              return l in this.values ? this.values[l] : this.defaults[l];
            }
            removeByName(b) {
              delete this.values[this.nameToKeyMap[b]];
            }
            static createTables(b) {
              const l = {
                keyToNameMap: {},
                nameToKeyMap: {},
                defaults: {},
                types: {},
                opcodes: {},
                order: []
              };
              for (let _ = 0, S = b.length; _ < S; ++_) {
                const A = b[_], F = Array.isArray(A[0]) ? (A[0][0] << 8) + A[0][1] : A[0];
                l.keyToNameMap[F] = A[1], l.nameToKeyMap[A[1]] = F, l.types[F] = A[2], l.defaults[F] = A[3], l.opcodes[F] = Array.isArray(A[0]) ? A[0] : [A[0]], l.order.push(F);
              }
              return l;
            }
          }
          const f = [[[12, 30], "ROS", ["sid", "sid", "num"], null], [[12, 20], "SyntheticBase", "num", null], [0, "version", "sid", null], [1, "Notice", "sid", null], [[12, 0], "Copyright", "sid", null], [2, "FullName", "sid", null], [3, "FamilyName", "sid", null], [4, "Weight", "sid", null], [[12, 1], "isFixedPitch", "num", 0], [[12, 2], "ItalicAngle", "num", 0], [[12, 3], "UnderlinePosition", "num", -100], [[12, 4], "UnderlineThickness", "num", 50], [[12, 5], "PaintType", "num", 0], [[12, 6], "CharstringType", "num", 2], [[12, 7], "FontMatrix", ["num", "num", "num", "num", "num", "num"], [1e-3, 0, 0, 1e-3, 0, 0]], [13, "UniqueID", "num", null], [5, "FontBBox", ["num", "num", "num", "num"], [0, 0, 0, 0]], [[12, 8], "StrokeWidth", "num", 0], [14, "XUID", "array", null], [15, "charset", "offset", 0], [16, "Encoding", "offset", 0], [17, "CharStrings", "offset", 0], [18, "Private", ["offset", "offset"], null], [[12, 21], "PostScript", "sid", null], [[12, 22], "BaseFontName", "sid", null], [[12, 23], "BaseFontBlend", "delta", null], [[12, 31], "CIDFontVersion", "num", 0], [[12, 32], "CIDFontRevision", "num", 0], [[12, 33], "CIDFontType", "num", 0], [[12, 34], "CIDCount", "num", 8720], [[12, 35], "UIDBase", "num", null], [[12, 37], "FDSelect", "offset", null], [[12, 36], "FDArray", "offset", null], [[12, 38], "FontName", "sid", null]];
          class m extends x {
            static get tables() {
              return (0, t.shadow)(this, "tables", this.createTables(f));
            }
            constructor(b) {
              super(m.tables, b), this.privateDict = null;
            }
          }
          u.CFFTopDict = m;
          const C = [[6, "BlueValues", "delta", null], [7, "OtherBlues", "delta", null], [8, "FamilyBlues", "delta", null], [9, "FamilyOtherBlues", "delta", null], [[12, 9], "BlueScale", "num", 0.039625], [[12, 10], "BlueShift", "num", 7], [[12, 11], "BlueFuzz", "num", 1], [10, "StdHW", "num", null], [11, "StdVW", "num", null], [[12, 12], "StemSnapH", "delta", null], [[12, 13], "StemSnapV", "delta", null], [[12, 14], "ForceBold", "num", 0], [[12, 17], "LanguageGroup", "num", 0], [[12, 18], "ExpansionFactor", "num", 0.06], [[12, 19], "initialRandomSeed", "num", 0], [20, "defaultWidthX", "num", 0], [21, "nominalWidthX", "num", 0], [19, "Subrs", "offset", null]];
          class p extends x {
            static get tables() {
              return (0, t.shadow)(this, "tables", this.createTables(C));
            }
            constructor(b) {
              super(p.tables, b), this.subrsIndex = null;
            }
          }
          u.CFFPrivateDict = p;
          const w = {
            ISO_ADOBE: 0,
            EXPERT: 1,
            EXPERT_SUBSET: 2
          };
          class X {
            constructor(b, l, _, S) {
              this.predefined = b, this.format = l, this.charset = _, this.raw = S;
            }
          }
          u.CFFCharset = X;
          class M {
            constructor(b, l, _, S) {
              this.predefined = b, this.format = l, this.encoding = _, this.raw = S;
            }
          }
          class j {
            constructor(b, l) {
              this.format = b, this.fdSelect = l;
            }
            getFDIndex(b) {
              return b < 0 || b >= this.fdSelect.length ? -1 : this.fdSelect[b];
            }
          }
          u.CFFFDSelect = j;
          class B {
            constructor() {
              this.offsets = /* @__PURE__ */ Object.create(null);
            }
            isTracking(b) {
              return b in this.offsets;
            }
            track(b, l) {
              if (b in this.offsets)
                throw new t.FormatError(`Already tracking location of ${b}`);
              this.offsets[b] = l;
            }
            offset(b) {
              for (const l in this.offsets)
                this.offsets[l] += b;
            }
            setEntryLocation(b, l, _) {
              if (!(b in this.offsets))
                throw new t.FormatError(`Not tracking location of ${b}`);
              const S = _.data, A = this.offsets[b], F = 5;
              for (let T = 0, O = l.length; T < O; ++T) {
                const U = T * F + A, G = U + 1, K = U + 2, W = U + 3, z = U + 4;
                if (S[U] !== 29 || S[G] !== 0 || S[K] !== 0 || S[W] !== 0 || S[z] !== 0)
                  throw new t.FormatError("writing to an offset that is not empty");
                const V = l[T];
                S[U] = 29, S[G] = V >> 24 & 255, S[K] = V >> 16 & 255, S[W] = V >> 8 & 255, S[z] = V & 255;
              }
            }
          }
          class R {
            constructor(b) {
              this.cff = b;
            }
            compile() {
              const b = this.cff, l = {
                data: [],
                length: 0,
                add(W) {
                  this.data = this.data.concat(W), this.length = this.data.length;
                }
              }, _ = this.compileHeader(b.header);
              l.add(_);
              const S = this.compileNameIndex(b.names);
              if (l.add(S), b.isCIDFont && b.topDict.hasName("FontMatrix")) {
                const W = b.topDict.getByName("FontMatrix");
                b.topDict.removeByName("FontMatrix");
                for (let z = 0, V = b.fdArray.length; z < V; z++) {
                  const L = b.fdArray[z];
                  let Y = W.slice(0);
                  L.hasName("FontMatrix") && (Y = t.Util.transform(Y, L.getByName("FontMatrix"))), L.setByName("FontMatrix", Y);
                }
              }
              const A = b.topDict.getByName("XUID");
              A && A.length > 16 && b.topDict.removeByName("XUID"), b.topDict.setByName("charset", 0);
              let F = this.compileTopDicts([b.topDict], l.length, b.isCIDFont);
              l.add(F.output);
              const T = F.trackers[0], O = this.compileStringIndex(b.strings.strings);
              l.add(O);
              const U = this.compileIndex(b.globalSubrIndex);
              if (l.add(U), b.encoding && b.topDict.hasName("Encoding"))
                if (b.encoding.predefined)
                  T.setEntryLocation("Encoding", [b.encoding.format], l);
                else {
                  const W = this.compileEncoding(b.encoding);
                  T.setEntryLocation("Encoding", [l.length], l), l.add(W);
                }
              const G = this.compileCharset(b.charset, b.charStrings.count, b.strings, b.isCIDFont);
              T.setEntryLocation("charset", [l.length], l), l.add(G);
              const K = this.compileCharStrings(b.charStrings);
              if (T.setEntryLocation("CharStrings", [l.length], l), l.add(K), b.isCIDFont) {
                T.setEntryLocation("FDSelect", [l.length], l);
                const W = this.compileFDSelect(b.fdSelect);
                l.add(W), F = this.compileTopDicts(b.fdArray, l.length, !0), T.setEntryLocation("FDArray", [l.length], l), l.add(F.output);
                const z = F.trackers;
                this.compilePrivateDicts(b.fdArray, z, l);
              }
              return this.compilePrivateDicts([b.topDict], [T], l), l.add([0]), l.data;
            }
            encodeNumber(b) {
              return Number.isInteger(b) ? this.encodeInteger(b) : this.encodeFloat(b);
            }
            static get EncodeFloatRegExp() {
              return (0, t.shadow)(this, "EncodeFloatRegExp", /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/);
            }
            encodeFloat(b) {
              let l = b.toString();
              const _ = R.EncodeFloatRegExp.exec(l);
              if (_) {
                const O = parseFloat("1e" + ((_[2] ? +_[2] : 0) + _[1].length));
                l = (Math.round(b * O) / O).toString();
              }
              let S = "", A, F;
              for (A = 0, F = l.length; A < F; ++A) {
                const O = l[A];
                O === "e" ? S += l[++A] === "-" ? "c" : "b" : O === "." ? S += "a" : O === "-" ? S += "e" : S += O;
              }
              S += S.length & 1 ? "f" : "ff";
              const T = [30];
              for (A = 0, F = S.length; A < F; A += 2)
                T.push(parseInt(S.substring(A, A + 2), 16));
              return T;
            }
            encodeInteger(b) {
              let l;
              return b >= -107 && b <= 107 ? l = [b + 139] : b >= 108 && b <= 1131 ? (b -= 108, l = [(b >> 8) + 247, b & 255]) : b >= -1131 && b <= -108 ? (b = -b - 108, l = [(b >> 8) + 251, b & 255]) : b >= -32768 && b <= 32767 ? l = [28, b >> 8 & 255, b & 255] : l = [29, b >> 24 & 255, b >> 16 & 255, b >> 8 & 255, b & 255], l;
            }
            compileHeader(b) {
              return [b.major, b.minor, 4, b.offSize];
            }
            compileNameIndex(b) {
              const l = new o();
              for (let _ = 0, S = b.length; _ < S; ++_) {
                const A = b[_], F = Math.min(A.length, 127);
                let T = new Array(F);
                for (let O = 0; O < F; O++) {
                  let U = A[O];
                  (U < "!" || U > "~" || U === "[" || U === "]" || U === "(" || U === ")" || U === "{" || U === "}" || U === "<" || U === ">" || U === "/" || U === "%") && (U = "_"), T[O] = U;
                }
                T = T.join(""), T === "" && (T = "Bad_Font_Name"), l.add((0, t.stringToBytes)(T));
              }
              return this.compileIndex(l);
            }
            compileTopDicts(b, l, _) {
              const S = [];
              let A = new o();
              for (let F = 0, T = b.length; F < T; ++F) {
                const O = b[F];
                _ && (O.removeByName("CIDFontVersion"), O.removeByName("CIDFontRevision"), O.removeByName("CIDFontType"), O.removeByName("CIDCount"), O.removeByName("UIDBase"));
                const U = new B(), G = this.compileDict(O, U);
                S.push(U), A.add(G), U.offset(l);
              }
              return A = this.compileIndex(A, S), {
                trackers: S,
                output: A
              };
            }
            compilePrivateDicts(b, l, _) {
              for (let S = 0, A = b.length; S < A; ++S) {
                const F = b[S], T = F.privateDict;
                if (!T || !F.hasName("Private"))
                  throw new t.FormatError("There must be a private dictionary.");
                const O = new B(), U = this.compileDict(T, O);
                let G = _.length;
                if (O.offset(G), U.length || (G = 0), l[S].setEntryLocation("Private", [U.length, G], _), _.add(U), T.subrsIndex && T.hasName("Subrs")) {
                  const K = this.compileIndex(T.subrsIndex);
                  O.setEntryLocation("Subrs", [U.length], _), _.add(K);
                }
              }
            }
            compileDict(b, l) {
              const _ = [];
              for (const S of b.order) {
                if (!(S in b.values))
                  continue;
                let A = b.values[S], F = b.types[S];
                if (Array.isArray(F) || (F = [F]), Array.isArray(A) || (A = [A]), A.length !== 0) {
                  for (let T = 0, O = F.length; T < O; ++T) {
                    const U = F[T], G = A[T];
                    switch (U) {
                      case "num":
                      case "sid":
                        _.push(...this.encodeNumber(G));
                        break;
                      case "offset":
                        const K = b.keyToNameMap[S];
                        l.isTracking(K) || l.track(K, _.length), _.push(29, 0, 0, 0, 0);
                        break;
                      case "array":
                      case "delta":
                        _.push(...this.encodeNumber(G));
                        for (let W = 1, z = A.length; W < z; ++W)
                          _.push(...this.encodeNumber(A[W]));
                        break;
                      default:
                        throw new t.FormatError(`Unknown data type of ${U}`);
                    }
                  }
                  _.push(...b.opcodes[S]);
                }
              }
              return _;
            }
            compileStringIndex(b) {
              const l = new o();
              for (let _ = 0, S = b.length; _ < S; ++_)
                l.add((0, t.stringToBytes)(b[_]));
              return this.compileIndex(l);
            }
            compileGlobalSubrIndex() {
              const b = this.cff.globalSubrIndex;
              this.out.writeByteArray(this.compileIndex(b));
            }
            compileCharStrings(b) {
              const l = new o();
              for (let _ = 0; _ < b.count; _++) {
                const S = b.get(_);
                if (S.length === 0) {
                  l.add(new Uint8Array([139, 14]));
                  continue;
                }
                l.add(S);
              }
              return this.compileIndex(l);
            }
            compileCharset(b, l, _, S) {
              let A;
              const F = l - 1;
              if (S)
                A = new Uint8Array([2, 0, 0, F >> 8 & 255, F & 255]);
              else {
                const T = 1 + F * 2;
                A = new Uint8Array(T), A[0] = 0;
                let O = 0;
                const U = b.charset.length;
                let G = !1;
                for (let K = 1; K < A.length; K += 2) {
                  let W = 0;
                  if (O < U) {
                    const z = b.charset[O++];
                    W = _.getSID(z), W === -1 && (W = 0, G || (G = !0, (0, t.warn)(`Couldn't find ${z} in CFF strings`)));
                  }
                  A[K] = W >> 8 & 255, A[K + 1] = W & 255;
                }
              }
              return this.compileTypedArray(A);
            }
            compileEncoding(b) {
              return this.compileTypedArray(b.raw);
            }
            compileFDSelect(b) {
              const l = b.format;
              let _, S;
              switch (l) {
                case 0:
                  for (_ = new Uint8Array(1 + b.fdSelect.length), _[0] = l, S = 0; S < b.fdSelect.length; S++)
                    _[S + 1] = b.fdSelect[S];
                  break;
                case 3:
                  const A = 0;
                  let F = b.fdSelect[0];
                  const T = [l, 0, 0, A >> 8 & 255, A & 255, F];
                  for (S = 1; S < b.fdSelect.length; S++) {
                    const U = b.fdSelect[S];
                    U !== F && (T.push(S >> 8 & 255, S & 255, U), F = U);
                  }
                  const O = (T.length - 3) / 3;
                  T[1] = O >> 8 & 255, T[2] = O & 255, T.push(S >> 8 & 255, S & 255), _ = new Uint8Array(T);
                  break;
              }
              return this.compileTypedArray(_);
            }
            compileTypedArray(b) {
              const l = [];
              for (let _ = 0, S = b.length; _ < S; ++_)
                l[_] = b[_];
              return l;
            }
            compileIndex(b, l = []) {
              const _ = b.objects, S = _.length;
              if (S === 0)
                return [0, 0];
              const A = [S >> 8 & 255, S & 255];
              let F = 1, T;
              for (T = 0; T < S; ++T)
                F += _[T].length;
              let O;
              F < 256 ? O = 1 : F < 65536 ? O = 2 : F < 16777216 ? O = 3 : O = 4, A.push(O);
              let U = 1;
              for (T = 0; T < S + 1; T++)
                O === 1 ? A.push(U & 255) : O === 2 ? A.push(U >> 8 & 255, U & 255) : O === 3 ? A.push(U >> 16 & 255, U >> 8 & 255, U & 255) : A.push(U >>> 24 & 255, U >> 16 & 255, U >> 8 & 255, U & 255), _[T] && (U += _[T].length);
              for (T = 0; T < S; T++) {
                l[T] && l[T].offset(A.length);
                for (let G = 0, K = _[T].length; G < K; G++)
                  A.push(_[T][G]);
              }
              return A;
            }
          }
          u.CFFCompiler = R;
        },
        /* 36 */
        /***/
        (Q, u) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.ISOAdobeCharset = u.ExpertSubsetCharset = u.ExpertCharset = void 0;
          const P = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron"];
          u.ISOAdobeCharset = P;
          const t = [".notdef", "space", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
          u.ExpertCharset = t;
          const i = [".notdef", "space", "dollaroldstyle", "dollarsuperior", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "hyphensuperior", "colonmonetary", "onefitted", "rupiah", "centoldstyle", "figuredash", "hypheninferior", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior"];
          u.ExpertSubsetCharset = i;
        },
        /* 37 */
        /***/
        (Q, u) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.ZapfDingbatsEncoding = u.WinAnsiEncoding = u.SymbolSetEncoding = u.StandardEncoding = u.MacRomanEncoding = u.ExpertEncoding = void 0, u.getEncoding = r;
          const P = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
          u.ExpertEncoding = P;
          const t = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "centoldstyle", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "", "threequartersemdash", "", "questionsmall", "", "", "", "", "Ethsmall", "", "", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "", "", "", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hypheninferior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "asuperior", "centsuperior", "", "", "", "", "Aacutesmall", "Agravesmall", "Acircumflexsmall", "Adieresissmall", "Atildesmall", "Aringsmall", "Ccedillasmall", "Eacutesmall", "Egravesmall", "Ecircumflexsmall", "Edieresissmall", "Iacutesmall", "Igravesmall", "Icircumflexsmall", "Idieresissmall", "Ntildesmall", "Oacutesmall", "Ogravesmall", "Ocircumflexsmall", "Odieresissmall", "Otildesmall", "Uacutesmall", "Ugravesmall", "Ucircumflexsmall", "Udieresissmall", "", "eightsuperior", "fourinferior", "threeinferior", "sixinferior", "eightinferior", "seveninferior", "Scaronsmall", "", "centinferior", "twoinferior", "", "Dieresissmall", "", "Caronsmall", "osuperior", "fiveinferior", "", "commainferior", "periodinferior", "Yacutesmall", "", "dollarinferior", "", "", "Thornsmall", "", "nineinferior", "zeroinferior", "Zcaronsmall", "AEsmall", "Oslashsmall", "questiondownsmall", "oneinferior", "Lslashsmall", "", "", "", "", "", "", "Cedillasmall", "", "", "", "", "", "OEsmall", "figuredash", "hyphensuperior", "", "", "", "", "exclamdownsmall", "", "Ydieresissmall", "", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "ninesuperior", "zerosuperior", "", "esuperior", "rsuperior", "tsuperior", "", "", "isuperior", "ssuperior", "dsuperior", "", "", "", "", "", "lsuperior", "Ogoneksmall", "Brevesmall", "Macronsmall", "bsuperior", "nsuperior", "msuperior", "commasuperior", "periodsuperior", "Dotaccentsmall", "Ringsmall", "", "", "", ""], i = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "space", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron"];
          u.MacRomanEncoding = i;
          const v = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls", "", "", "", ""];
          u.StandardEncoding = v;
          const a = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "bullet", "Euro", "bullet", "quotesinglbase", "florin", "quotedblbase", "ellipsis", "dagger", "daggerdbl", "circumflex", "perthousand", "Scaron", "guilsinglleft", "OE", "bullet", "Zcaron", "bullet", "bullet", "quoteleft", "quoteright", "quotedblleft", "quotedblright", "bullet", "endash", "emdash", "tilde", "trademark", "scaron", "guilsinglright", "oe", "bullet", "zcaron", "Ydieresis", "space", "exclamdown", "cent", "sterling", "currency", "yen", "brokenbar", "section", "dieresis", "copyright", "ordfeminine", "guillemotleft", "logicalnot", "hyphen", "registered", "macron", "degree", "plusminus", "twosuperior", "threesuperior", "acute", "mu", "paragraph", "periodcentered", "cedilla", "onesuperior", "ordmasculine", "guillemotright", "onequarter", "onehalf", "threequarters", "questiondown", "Agrave", "Aacute", "Acircumflex", "Atilde", "Adieresis", "Aring", "AE", "Ccedilla", "Egrave", "Eacute", "Ecircumflex", "Edieresis", "Igrave", "Iacute", "Icircumflex", "Idieresis", "Eth", "Ntilde", "Ograve", "Oacute", "Ocircumflex", "Otilde", "Odieresis", "multiply", "Oslash", "Ugrave", "Uacute", "Ucircumflex", "Udieresis", "Yacute", "Thorn", "germandbls", "agrave", "aacute", "acircumflex", "atilde", "adieresis", "aring", "ae", "ccedilla", "egrave", "eacute", "ecircumflex", "edieresis", "igrave", "iacute", "icircumflex", "idieresis", "eth", "ntilde", "ograve", "oacute", "ocircumflex", "otilde", "odieresis", "divide", "oslash", "ugrave", "uacute", "ucircumflex", "udieresis", "yacute", "thorn", "ydieresis"];
          u.WinAnsiEncoding = a;
          const e = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "universal", "numbersign", "existential", "percent", "ampersand", "suchthat", "parenleft", "parenright", "asteriskmath", "plus", "comma", "minus", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "congruent", "Alpha", "Beta", "Chi", "Delta", "Epsilon", "Phi", "Gamma", "Eta", "Iota", "theta1", "Kappa", "Lambda", "Mu", "Nu", "Omicron", "Pi", "Theta", "Rho", "Sigma", "Tau", "Upsilon", "sigma1", "Omega", "Xi", "Psi", "Zeta", "bracketleft", "therefore", "bracketright", "perpendicular", "underscore", "radicalex", "alpha", "beta", "chi", "delta", "epsilon", "phi", "gamma", "eta", "iota", "phi1", "kappa", "lambda", "mu", "nu", "omicron", "pi", "theta", "rho", "sigma", "tau", "upsilon", "omega1", "omega", "xi", "psi", "zeta", "braceleft", "bar", "braceright", "similar", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Euro", "Upsilon1", "minute", "lessequal", "fraction", "infinity", "florin", "club", "diamond", "heart", "spade", "arrowboth", "arrowleft", "arrowup", "arrowright", "arrowdown", "degree", "plusminus", "second", "greaterequal", "multiply", "proportional", "partialdiff", "bullet", "divide", "notequal", "equivalence", "approxequal", "ellipsis", "arrowvertex", "arrowhorizex", "carriagereturn", "aleph", "Ifraktur", "Rfraktur", "weierstrass", "circlemultiply", "circleplus", "emptyset", "intersection", "union", "propersuperset", "reflexsuperset", "notsubset", "propersubset", "reflexsubset", "element", "notelement", "angle", "gradient", "registerserif", "copyrightserif", "trademarkserif", "product", "radical", "dotmath", "logicalnot", "logicaland", "logicalor", "arrowdblboth", "arrowdblleft", "arrowdblup", "arrowdblright", "arrowdbldown", "lozenge", "angleleft", "registersans", "copyrightsans", "trademarksans", "summation", "parenlefttp", "parenleftex", "parenleftbt", "bracketlefttp", "bracketleftex", "bracketleftbt", "bracelefttp", "braceleftmid", "braceleftbt", "braceex", "", "angleright", "integral", "integraltp", "integralex", "integralbt", "parenrighttp", "parenrightex", "parenrightbt", "bracketrighttp", "bracketrightex", "bracketrightbt", "bracerighttp", "bracerightmid", "bracerightbt", ""];
          u.SymbolSetEncoding = e;
          const y = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "a1", "a2", "a202", "a3", "a4", "a5", "a119", "a118", "a117", "a11", "a12", "a13", "a14", "a15", "a16", "a105", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24", "a25", "a26", "a27", "a28", "a6", "a7", "a8", "a9", "a10", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36", "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48", "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60", "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72", "a73", "a74", "a203", "a75", "a204", "a76", "a77", "a78", "a79", "a81", "a82", "a83", "a84", "a97", "a98", "a99", "a100", "", "a89", "a90", "a93", "a94", "a91", "a92", "a205", "a85", "a206", "a86", "a87", "a88", "a95", "a96", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "a101", "a102", "a103", "a104", "a106", "a107", "a108", "a112", "a111", "a110", "a109", "a120", "a121", "a122", "a123", "a124", "a125", "a126", "a127", "a128", "a129", "a130", "a131", "a132", "a133", "a134", "a135", "a136", "a137", "a138", "a139", "a140", "a141", "a142", "a143", "a144", "a145", "a146", "a147", "a148", "a149", "a150", "a151", "a152", "a153", "a154", "a155", "a156", "a157", "a158", "a159", "a160", "a161", "a163", "a164", "a196", "a165", "a192", "a166", "a167", "a168", "a169", "a170", "a171", "a172", "a173", "a162", "a174", "a175", "a176", "a177", "a178", "a179", "a193", "a180", "a199", "a181", "a200", "a182", "", "a201", "a183", "a184", "a197", "a185", "a194", "a198", "a186", "a195", "a187", "a188", "a189", "a190", "a191", ""];
          u.ZapfDingbatsEncoding = y;
          function r(h) {
            switch (h) {
              case "WinAnsiEncoding":
                return a;
              case "StandardEncoding":
                return v;
              case "MacRomanEncoding":
                return i;
              case "SymbolSetEncoding":
                return e;
              case "ZapfDingbatsEncoding":
                return y;
              case "ExpertEncoding":
                return P;
              case "MacExpertEncoding":
                return t;
              default:
                return null;
            }
          }
        },
        /* 38 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.SEAC_ANALYSIS_ENABLED = u.MacStandardGlyphOrdering = u.FontFlags = void 0, u.getFontType = h, u.normalizeFontName = c, u.recoverGlyphName = g, u.type1FontGlyphMapping = d;
          var t = P(2), i = P(37), v = P(39), a = P(40);
          const e = !0;
          u.SEAC_ANALYSIS_ENABLED = e;
          const y = {
            FixedPitch: 1,
            Serif: 2,
            Symbolic: 4,
            Script: 8,
            Nonsymbolic: 32,
            Italic: 64,
            AllCap: 65536,
            SmallCap: 131072,
            ForceBold: 262144
          };
          u.FontFlags = y;
          const r = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];
          u.MacStandardGlyphOrdering = r;
          function h(n, o, x = !1) {
            switch (n) {
              case "Type1":
                return x ? t.FontType.TYPE1STANDARD : o === "Type1C" ? t.FontType.TYPE1C : t.FontType.TYPE1;
              case "CIDFontType0":
                return o === "CIDFontType0C" ? t.FontType.CIDFONTTYPE0C : t.FontType.CIDFONTTYPE0;
              case "OpenType":
                return t.FontType.OPENTYPE;
              case "TrueType":
                return t.FontType.TRUETYPE;
              case "CIDFontType2":
                return t.FontType.CIDFONTTYPE2;
              case "MMType1":
                return t.FontType.MMTYPE1;
              case "Type0":
                return t.FontType.TYPE0;
              default:
                return t.FontType.UNKNOWN;
            }
          }
          function g(n, o) {
            if (o[n] !== void 0)
              return n;
            const x = (0, a.getUnicodeForGlyph)(n, o);
            if (x !== -1) {
              for (const f in o)
                if (o[f] === x)
                  return f;
            }
            return (0, t.info)("Unable to recover a standard glyph name for: " + n), n;
          }
          function d(n, o, x) {
            const f = /* @__PURE__ */ Object.create(null);
            let m, C, p;
            const w = !!(n.flags & y.Symbolic);
            if (n.isInternalFont)
              for (p = o, C = 0; C < p.length; C++)
                m = x.indexOf(p[C]), m >= 0 ? f[C] = m : f[C] = 0;
            else if (n.baseEncodingName)
              for (p = (0, i.getEncoding)(n.baseEncodingName), C = 0; C < p.length; C++)
                m = x.indexOf(p[C]), m >= 0 ? f[C] = m : f[C] = 0;
            else if (w)
              for (C in o)
                f[C] = o[C];
            else
              for (p = i.StandardEncoding, C = 0; C < p.length; C++)
                m = x.indexOf(p[C]), m >= 0 ? f[C] = m : f[C] = 0;
            const X = n.differences;
            let M;
            if (X)
              for (C in X) {
                const j = X[C];
                if (m = x.indexOf(j), m === -1) {
                  M || (M = (0, v.getGlyphsUnicode)());
                  const B = g(j, M);
                  B !== j && (m = x.indexOf(B));
                }
                m >= 0 ? f[C] = m : f[C] = 0;
              }
            return f;
          }
          function c(n) {
            return n.replace(/[,_]/g, "-").replace(/\s/g, "");
          }
        },
        /* 39 */
        /***/
        (Q, u, P) => {
          P.r(u), P.d(u, {
            /* harmony export */
            getDingbatsGlyphsUnicode: () => (
              /* binding */
              v
            ),
            /* harmony export */
            getGlyphsUnicode: () => (
              /* binding */
              i
            )
            /* harmony export */
          });
          var t = P(6);
          const i = (0, t.getArrayLookupTableFactory)(function() {
            return [
              "A",
              65,
              "AE",
              198,
              "AEacute",
              508,
              "AEmacron",
              482,
              "AEsmall",
              63462,
              "Aacute",
              193,
              "Aacutesmall",
              63457,
              "Abreve",
              258,
              "Abreveacute",
              7854,
              "Abrevecyrillic",
              1232,
              "Abrevedotbelow",
              7862,
              "Abrevegrave",
              7856,
              "Abrevehookabove",
              7858,
              "Abrevetilde",
              7860,
              "Acaron",
              461,
              "Acircle",
              9398,
              "Acircumflex",
              194,
              "Acircumflexacute",
              7844,
              "Acircumflexdotbelow",
              7852,
              "Acircumflexgrave",
              7846,
              "Acircumflexhookabove",
              7848,
              "Acircumflexsmall",
              63458,
              "Acircumflextilde",
              7850,
              "Acute",
              63177,
              "Acutesmall",
              63412,
              "Acyrillic",
              1040,
              "Adblgrave",
              512,
              "Adieresis",
              196,
              "Adieresiscyrillic",
              1234,
              "Adieresismacron",
              478,
              "Adieresissmall",
              63460,
              "Adotbelow",
              7840,
              "Adotmacron",
              480,
              "Agrave",
              192,
              "Agravesmall",
              63456,
              "Ahookabove",
              7842,
              "Aiecyrillic",
              1236,
              "Ainvertedbreve",
              514,
              "Alpha",
              913,
              "Alphatonos",
              902,
              "Amacron",
              256,
              "Amonospace",
              65313,
              "Aogonek",
              260,
              "Aring",
              197,
              "Aringacute",
              506,
              "Aringbelow",
              7680,
              "Aringsmall",
              63461,
              "Asmall",
              63329,
              "Atilde",
              195,
              "Atildesmall",
              63459,
              "Aybarmenian",
              1329,
              "B",
              66,
              "Bcircle",
              9399,
              "Bdotaccent",
              7682,
              "Bdotbelow",
              7684,
              "Becyrillic",
              1041,
              "Benarmenian",
              1330,
              "Beta",
              914,
              "Bhook",
              385,
              "Blinebelow",
              7686,
              "Bmonospace",
              65314,
              "Brevesmall",
              63220,
              "Bsmall",
              63330,
              "Btopbar",
              386,
              "C",
              67,
              "Caarmenian",
              1342,
              "Cacute",
              262,
              "Caron",
              63178,
              "Caronsmall",
              63221,
              "Ccaron",
              268,
              "Ccedilla",
              199,
              "Ccedillaacute",
              7688,
              "Ccedillasmall",
              63463,
              "Ccircle",
              9400,
              "Ccircumflex",
              264,
              "Cdot",
              266,
              "Cdotaccent",
              266,
              "Cedillasmall",
              63416,
              "Chaarmenian",
              1353,
              "Cheabkhasiancyrillic",
              1212,
              "Checyrillic",
              1063,
              "Chedescenderabkhasiancyrillic",
              1214,
              "Chedescendercyrillic",
              1206,
              "Chedieresiscyrillic",
              1268,
              "Cheharmenian",
              1347,
              "Chekhakassiancyrillic",
              1227,
              "Cheverticalstrokecyrillic",
              1208,
              "Chi",
              935,
              "Chook",
              391,
              "Circumflexsmall",
              63222,
              "Cmonospace",
              65315,
              "Coarmenian",
              1361,
              "Csmall",
              63331,
              "D",
              68,
              "DZ",
              497,
              "DZcaron",
              452,
              "Daarmenian",
              1332,
              "Dafrican",
              393,
              "Dcaron",
              270,
              "Dcedilla",
              7696,
              "Dcircle",
              9401,
              "Dcircumflexbelow",
              7698,
              "Dcroat",
              272,
              "Ddotaccent",
              7690,
              "Ddotbelow",
              7692,
              "Decyrillic",
              1044,
              "Deicoptic",
              1006,
              "Delta",
              8710,
              "Deltagreek",
              916,
              "Dhook",
              394,
              "Dieresis",
              63179,
              "DieresisAcute",
              63180,
              "DieresisGrave",
              63181,
              "Dieresissmall",
              63400,
              "Digammagreek",
              988,
              "Djecyrillic",
              1026,
              "Dlinebelow",
              7694,
              "Dmonospace",
              65316,
              "Dotaccentsmall",
              63223,
              "Dslash",
              272,
              "Dsmall",
              63332,
              "Dtopbar",
              395,
              "Dz",
              498,
              "Dzcaron",
              453,
              "Dzeabkhasiancyrillic",
              1248,
              "Dzecyrillic",
              1029,
              "Dzhecyrillic",
              1039,
              "E",
              69,
              "Eacute",
              201,
              "Eacutesmall",
              63465,
              "Ebreve",
              276,
              "Ecaron",
              282,
              "Ecedillabreve",
              7708,
              "Echarmenian",
              1333,
              "Ecircle",
              9402,
              "Ecircumflex",
              202,
              "Ecircumflexacute",
              7870,
              "Ecircumflexbelow",
              7704,
              "Ecircumflexdotbelow",
              7878,
              "Ecircumflexgrave",
              7872,
              "Ecircumflexhookabove",
              7874,
              "Ecircumflexsmall",
              63466,
              "Ecircumflextilde",
              7876,
              "Ecyrillic",
              1028,
              "Edblgrave",
              516,
              "Edieresis",
              203,
              "Edieresissmall",
              63467,
              "Edot",
              278,
              "Edotaccent",
              278,
              "Edotbelow",
              7864,
              "Efcyrillic",
              1060,
              "Egrave",
              200,
              "Egravesmall",
              63464,
              "Eharmenian",
              1335,
              "Ehookabove",
              7866,
              "Eightroman",
              8551,
              "Einvertedbreve",
              518,
              "Eiotifiedcyrillic",
              1124,
              "Elcyrillic",
              1051,
              "Elevenroman",
              8554,
              "Emacron",
              274,
              "Emacronacute",
              7702,
              "Emacrongrave",
              7700,
              "Emcyrillic",
              1052,
              "Emonospace",
              65317,
              "Encyrillic",
              1053,
              "Endescendercyrillic",
              1186,
              "Eng",
              330,
              "Enghecyrillic",
              1188,
              "Enhookcyrillic",
              1223,
              "Eogonek",
              280,
              "Eopen",
              400,
              "Epsilon",
              917,
              "Epsilontonos",
              904,
              "Ercyrillic",
              1056,
              "Ereversed",
              398,
              "Ereversedcyrillic",
              1069,
              "Escyrillic",
              1057,
              "Esdescendercyrillic",
              1194,
              "Esh",
              425,
              "Esmall",
              63333,
              "Eta",
              919,
              "Etarmenian",
              1336,
              "Etatonos",
              905,
              "Eth",
              208,
              "Ethsmall",
              63472,
              "Etilde",
              7868,
              "Etildebelow",
              7706,
              "Euro",
              8364,
              "Ezh",
              439,
              "Ezhcaron",
              494,
              "Ezhreversed",
              440,
              "F",
              70,
              "Fcircle",
              9403,
              "Fdotaccent",
              7710,
              "Feharmenian",
              1366,
              "Feicoptic",
              996,
              "Fhook",
              401,
              "Fitacyrillic",
              1138,
              "Fiveroman",
              8548,
              "Fmonospace",
              65318,
              "Fourroman",
              8547,
              "Fsmall",
              63334,
              "G",
              71,
              "GBsquare",
              13191,
              "Gacute",
              500,
              "Gamma",
              915,
              "Gammaafrican",
              404,
              "Gangiacoptic",
              1002,
              "Gbreve",
              286,
              "Gcaron",
              486,
              "Gcedilla",
              290,
              "Gcircle",
              9404,
              "Gcircumflex",
              284,
              "Gcommaaccent",
              290,
              "Gdot",
              288,
              "Gdotaccent",
              288,
              "Gecyrillic",
              1043,
              "Ghadarmenian",
              1346,
              "Ghemiddlehookcyrillic",
              1172,
              "Ghestrokecyrillic",
              1170,
              "Gheupturncyrillic",
              1168,
              "Ghook",
              403,
              "Gimarmenian",
              1331,
              "Gjecyrillic",
              1027,
              "Gmacron",
              7712,
              "Gmonospace",
              65319,
              "Grave",
              63182,
              "Gravesmall",
              63328,
              "Gsmall",
              63335,
              "Gsmallhook",
              667,
              "Gstroke",
              484,
              "H",
              72,
              "H18533",
              9679,
              "H18543",
              9642,
              "H18551",
              9643,
              "H22073",
              9633,
              "HPsquare",
              13259,
              "Haabkhasiancyrillic",
              1192,
              "Hadescendercyrillic",
              1202,
              "Hardsigncyrillic",
              1066,
              "Hbar",
              294,
              "Hbrevebelow",
              7722,
              "Hcedilla",
              7720,
              "Hcircle",
              9405,
              "Hcircumflex",
              292,
              "Hdieresis",
              7718,
              "Hdotaccent",
              7714,
              "Hdotbelow",
              7716,
              "Hmonospace",
              65320,
              "Hoarmenian",
              1344,
              "Horicoptic",
              1e3,
              "Hsmall",
              63336,
              "Hungarumlaut",
              63183,
              "Hungarumlautsmall",
              63224,
              "Hzsquare",
              13200,
              "I",
              73,
              "IAcyrillic",
              1071,
              "IJ",
              306,
              "IUcyrillic",
              1070,
              "Iacute",
              205,
              "Iacutesmall",
              63469,
              "Ibreve",
              300,
              "Icaron",
              463,
              "Icircle",
              9406,
              "Icircumflex",
              206,
              "Icircumflexsmall",
              63470,
              "Icyrillic",
              1030,
              "Idblgrave",
              520,
              "Idieresis",
              207,
              "Idieresisacute",
              7726,
              "Idieresiscyrillic",
              1252,
              "Idieresissmall",
              63471,
              "Idot",
              304,
              "Idotaccent",
              304,
              "Idotbelow",
              7882,
              "Iebrevecyrillic",
              1238,
              "Iecyrillic",
              1045,
              "Ifraktur",
              8465,
              "Igrave",
              204,
              "Igravesmall",
              63468,
              "Ihookabove",
              7880,
              "Iicyrillic",
              1048,
              "Iinvertedbreve",
              522,
              "Iishortcyrillic",
              1049,
              "Imacron",
              298,
              "Imacroncyrillic",
              1250,
              "Imonospace",
              65321,
              "Iniarmenian",
              1339,
              "Iocyrillic",
              1025,
              "Iogonek",
              302,
              "Iota",
              921,
              "Iotaafrican",
              406,
              "Iotadieresis",
              938,
              "Iotatonos",
              906,
              "Ismall",
              63337,
              "Istroke",
              407,
              "Itilde",
              296,
              "Itildebelow",
              7724,
              "Izhitsacyrillic",
              1140,
              "Izhitsadblgravecyrillic",
              1142,
              "J",
              74,
              "Jaarmenian",
              1345,
              "Jcircle",
              9407,
              "Jcircumflex",
              308,
              "Jecyrillic",
              1032,
              "Jheharmenian",
              1355,
              "Jmonospace",
              65322,
              "Jsmall",
              63338,
              "K",
              75,
              "KBsquare",
              13189,
              "KKsquare",
              13261,
              "Kabashkircyrillic",
              1184,
              "Kacute",
              7728,
              "Kacyrillic",
              1050,
              "Kadescendercyrillic",
              1178,
              "Kahookcyrillic",
              1219,
              "Kappa",
              922,
              "Kastrokecyrillic",
              1182,
              "Kaverticalstrokecyrillic",
              1180,
              "Kcaron",
              488,
              "Kcedilla",
              310,
              "Kcircle",
              9408,
              "Kcommaaccent",
              310,
              "Kdotbelow",
              7730,
              "Keharmenian",
              1364,
              "Kenarmenian",
              1343,
              "Khacyrillic",
              1061,
              "Kheicoptic",
              998,
              "Khook",
              408,
              "Kjecyrillic",
              1036,
              "Klinebelow",
              7732,
              "Kmonospace",
              65323,
              "Koppacyrillic",
              1152,
              "Koppagreek",
              990,
              "Ksicyrillic",
              1134,
              "Ksmall",
              63339,
              "L",
              76,
              "LJ",
              455,
              "LL",
              63167,
              "Lacute",
              313,
              "Lambda",
              923,
              "Lcaron",
              317,
              "Lcedilla",
              315,
              "Lcircle",
              9409,
              "Lcircumflexbelow",
              7740,
              "Lcommaaccent",
              315,
              "Ldot",
              319,
              "Ldotaccent",
              319,
              "Ldotbelow",
              7734,
              "Ldotbelowmacron",
              7736,
              "Liwnarmenian",
              1340,
              "Lj",
              456,
              "Ljecyrillic",
              1033,
              "Llinebelow",
              7738,
              "Lmonospace",
              65324,
              "Lslash",
              321,
              "Lslashsmall",
              63225,
              "Lsmall",
              63340,
              "M",
              77,
              "MBsquare",
              13190,
              "Macron",
              63184,
              "Macronsmall",
              63407,
              "Macute",
              7742,
              "Mcircle",
              9410,
              "Mdotaccent",
              7744,
              "Mdotbelow",
              7746,
              "Menarmenian",
              1348,
              "Mmonospace",
              65325,
              "Msmall",
              63341,
              "Mturned",
              412,
              "Mu",
              924,
              "N",
              78,
              "NJ",
              458,
              "Nacute",
              323,
              "Ncaron",
              327,
              "Ncedilla",
              325,
              "Ncircle",
              9411,
              "Ncircumflexbelow",
              7754,
              "Ncommaaccent",
              325,
              "Ndotaccent",
              7748,
              "Ndotbelow",
              7750,
              "Nhookleft",
              413,
              "Nineroman",
              8552,
              "Nj",
              459,
              "Njecyrillic",
              1034,
              "Nlinebelow",
              7752,
              "Nmonospace",
              65326,
              "Nowarmenian",
              1350,
              "Nsmall",
              63342,
              "Ntilde",
              209,
              "Ntildesmall",
              63473,
              "Nu",
              925,
              "O",
              79,
              "OE",
              338,
              "OEsmall",
              63226,
              "Oacute",
              211,
              "Oacutesmall",
              63475,
              "Obarredcyrillic",
              1256,
              "Obarreddieresiscyrillic",
              1258,
              "Obreve",
              334,
              "Ocaron",
              465,
              "Ocenteredtilde",
              415,
              "Ocircle",
              9412,
              "Ocircumflex",
              212,
              "Ocircumflexacute",
              7888,
              "Ocircumflexdotbelow",
              7896,
              "Ocircumflexgrave",
              7890,
              "Ocircumflexhookabove",
              7892,
              "Ocircumflexsmall",
              63476,
              "Ocircumflextilde",
              7894,
              "Ocyrillic",
              1054,
              "Odblacute",
              336,
              "Odblgrave",
              524,
              "Odieresis",
              214,
              "Odieresiscyrillic",
              1254,
              "Odieresissmall",
              63478,
              "Odotbelow",
              7884,
              "Ogoneksmall",
              63227,
              "Ograve",
              210,
              "Ogravesmall",
              63474,
              "Oharmenian",
              1365,
              "Ohm",
              8486,
              "Ohookabove",
              7886,
              "Ohorn",
              416,
              "Ohornacute",
              7898,
              "Ohorndotbelow",
              7906,
              "Ohorngrave",
              7900,
              "Ohornhookabove",
              7902,
              "Ohorntilde",
              7904,
              "Ohungarumlaut",
              336,
              "Oi",
              418,
              "Oinvertedbreve",
              526,
              "Omacron",
              332,
              "Omacronacute",
              7762,
              "Omacrongrave",
              7760,
              "Omega",
              8486,
              "Omegacyrillic",
              1120,
              "Omegagreek",
              937,
              "Omegaroundcyrillic",
              1146,
              "Omegatitlocyrillic",
              1148,
              "Omegatonos",
              911,
              "Omicron",
              927,
              "Omicrontonos",
              908,
              "Omonospace",
              65327,
              "Oneroman",
              8544,
              "Oogonek",
              490,
              "Oogonekmacron",
              492,
              "Oopen",
              390,
              "Oslash",
              216,
              "Oslashacute",
              510,
              "Oslashsmall",
              63480,
              "Osmall",
              63343,
              "Ostrokeacute",
              510,
              "Otcyrillic",
              1150,
              "Otilde",
              213,
              "Otildeacute",
              7756,
              "Otildedieresis",
              7758,
              "Otildesmall",
              63477,
              "P",
              80,
              "Pacute",
              7764,
              "Pcircle",
              9413,
              "Pdotaccent",
              7766,
              "Pecyrillic",
              1055,
              "Peharmenian",
              1354,
              "Pemiddlehookcyrillic",
              1190,
              "Phi",
              934,
              "Phook",
              420,
              "Pi",
              928,
              "Piwrarmenian",
              1363,
              "Pmonospace",
              65328,
              "Psi",
              936,
              "Psicyrillic",
              1136,
              "Psmall",
              63344,
              "Q",
              81,
              "Qcircle",
              9414,
              "Qmonospace",
              65329,
              "Qsmall",
              63345,
              "R",
              82,
              "Raarmenian",
              1356,
              "Racute",
              340,
              "Rcaron",
              344,
              "Rcedilla",
              342,
              "Rcircle",
              9415,
              "Rcommaaccent",
              342,
              "Rdblgrave",
              528,
              "Rdotaccent",
              7768,
              "Rdotbelow",
              7770,
              "Rdotbelowmacron",
              7772,
              "Reharmenian",
              1360,
              "Rfraktur",
              8476,
              "Rho",
              929,
              "Ringsmall",
              63228,
              "Rinvertedbreve",
              530,
              "Rlinebelow",
              7774,
              "Rmonospace",
              65330,
              "Rsmall",
              63346,
              "Rsmallinverted",
              641,
              "Rsmallinvertedsuperior",
              694,
              "S",
              83,
              "SF010000",
              9484,
              "SF020000",
              9492,
              "SF030000",
              9488,
              "SF040000",
              9496,
              "SF050000",
              9532,
              "SF060000",
              9516,
              "SF070000",
              9524,
              "SF080000",
              9500,
              "SF090000",
              9508,
              "SF100000",
              9472,
              "SF110000",
              9474,
              "SF190000",
              9569,
              "SF200000",
              9570,
              "SF210000",
              9558,
              "SF220000",
              9557,
              "SF230000",
              9571,
              "SF240000",
              9553,
              "SF250000",
              9559,
              "SF260000",
              9565,
              "SF270000",
              9564,
              "SF280000",
              9563,
              "SF360000",
              9566,
              "SF370000",
              9567,
              "SF380000",
              9562,
              "SF390000",
              9556,
              "SF400000",
              9577,
              "SF410000",
              9574,
              "SF420000",
              9568,
              "SF430000",
              9552,
              "SF440000",
              9580,
              "SF450000",
              9575,
              "SF460000",
              9576,
              "SF470000",
              9572,
              "SF480000",
              9573,
              "SF490000",
              9561,
              "SF500000",
              9560,
              "SF510000",
              9554,
              "SF520000",
              9555,
              "SF530000",
              9579,
              "SF540000",
              9578,
              "Sacute",
              346,
              "Sacutedotaccent",
              7780,
              "Sampigreek",
              992,
              "Scaron",
              352,
              "Scarondotaccent",
              7782,
              "Scaronsmall",
              63229,
              "Scedilla",
              350,
              "Schwa",
              399,
              "Schwacyrillic",
              1240,
              "Schwadieresiscyrillic",
              1242,
              "Scircle",
              9416,
              "Scircumflex",
              348,
              "Scommaaccent",
              536,
              "Sdotaccent",
              7776,
              "Sdotbelow",
              7778,
              "Sdotbelowdotaccent",
              7784,
              "Seharmenian",
              1357,
              "Sevenroman",
              8550,
              "Shaarmenian",
              1351,
              "Shacyrillic",
              1064,
              "Shchacyrillic",
              1065,
              "Sheicoptic",
              994,
              "Shhacyrillic",
              1210,
              "Shimacoptic",
              1004,
              "Sigma",
              931,
              "Sixroman",
              8549,
              "Smonospace",
              65331,
              "Softsigncyrillic",
              1068,
              "Ssmall",
              63347,
              "Stigmagreek",
              986,
              "T",
              84,
              "Tau",
              932,
              "Tbar",
              358,
              "Tcaron",
              356,
              "Tcedilla",
              354,
              "Tcircle",
              9417,
              "Tcircumflexbelow",
              7792,
              "Tcommaaccent",
              354,
              "Tdotaccent",
              7786,
              "Tdotbelow",
              7788,
              "Tecyrillic",
              1058,
              "Tedescendercyrillic",
              1196,
              "Tenroman",
              8553,
              "Tetsecyrillic",
              1204,
              "Theta",
              920,
              "Thook",
              428,
              "Thorn",
              222,
              "Thornsmall",
              63486,
              "Threeroman",
              8546,
              "Tildesmall",
              63230,
              "Tiwnarmenian",
              1359,
              "Tlinebelow",
              7790,
              "Tmonospace",
              65332,
              "Toarmenian",
              1337,
              "Tonefive",
              444,
              "Tonesix",
              388,
              "Tonetwo",
              423,
              "Tretroflexhook",
              430,
              "Tsecyrillic",
              1062,
              "Tshecyrillic",
              1035,
              "Tsmall",
              63348,
              "Twelveroman",
              8555,
              "Tworoman",
              8545,
              "U",
              85,
              "Uacute",
              218,
              "Uacutesmall",
              63482,
              "Ubreve",
              364,
              "Ucaron",
              467,
              "Ucircle",
              9418,
              "Ucircumflex",
              219,
              "Ucircumflexbelow",
              7798,
              "Ucircumflexsmall",
              63483,
              "Ucyrillic",
              1059,
              "Udblacute",
              368,
              "Udblgrave",
              532,
              "Udieresis",
              220,
              "Udieresisacute",
              471,
              "Udieresisbelow",
              7794,
              "Udieresiscaron",
              473,
              "Udieresiscyrillic",
              1264,
              "Udieresisgrave",
              475,
              "Udieresismacron",
              469,
              "Udieresissmall",
              63484,
              "Udotbelow",
              7908,
              "Ugrave",
              217,
              "Ugravesmall",
              63481,
              "Uhookabove",
              7910,
              "Uhorn",
              431,
              "Uhornacute",
              7912,
              "Uhorndotbelow",
              7920,
              "Uhorngrave",
              7914,
              "Uhornhookabove",
              7916,
              "Uhorntilde",
              7918,
              "Uhungarumlaut",
              368,
              "Uhungarumlautcyrillic",
              1266,
              "Uinvertedbreve",
              534,
              "Ukcyrillic",
              1144,
              "Umacron",
              362,
              "Umacroncyrillic",
              1262,
              "Umacrondieresis",
              7802,
              "Umonospace",
              65333,
              "Uogonek",
              370,
              "Upsilon",
              933,
              "Upsilon1",
              978,
              "Upsilonacutehooksymbolgreek",
              979,
              "Upsilonafrican",
              433,
              "Upsilondieresis",
              939,
              "Upsilondieresishooksymbolgreek",
              980,
              "Upsilonhooksymbol",
              978,
              "Upsilontonos",
              910,
              "Uring",
              366,
              "Ushortcyrillic",
              1038,
              "Usmall",
              63349,
              "Ustraightcyrillic",
              1198,
              "Ustraightstrokecyrillic",
              1200,
              "Utilde",
              360,
              "Utildeacute",
              7800,
              "Utildebelow",
              7796,
              "V",
              86,
              "Vcircle",
              9419,
              "Vdotbelow",
              7806,
              "Vecyrillic",
              1042,
              "Vewarmenian",
              1358,
              "Vhook",
              434,
              "Vmonospace",
              65334,
              "Voarmenian",
              1352,
              "Vsmall",
              63350,
              "Vtilde",
              7804,
              "W",
              87,
              "Wacute",
              7810,
              "Wcircle",
              9420,
              "Wcircumflex",
              372,
              "Wdieresis",
              7812,
              "Wdotaccent",
              7814,
              "Wdotbelow",
              7816,
              "Wgrave",
              7808,
              "Wmonospace",
              65335,
              "Wsmall",
              63351,
              "X",
              88,
              "Xcircle",
              9421,
              "Xdieresis",
              7820,
              "Xdotaccent",
              7818,
              "Xeharmenian",
              1341,
              "Xi",
              926,
              "Xmonospace",
              65336,
              "Xsmall",
              63352,
              "Y",
              89,
              "Yacute",
              221,
              "Yacutesmall",
              63485,
              "Yatcyrillic",
              1122,
              "Ycircle",
              9422,
              "Ycircumflex",
              374,
              "Ydieresis",
              376,
              "Ydieresissmall",
              63487,
              "Ydotaccent",
              7822,
              "Ydotbelow",
              7924,
              "Yericyrillic",
              1067,
              "Yerudieresiscyrillic",
              1272,
              "Ygrave",
              7922,
              "Yhook",
              435,
              "Yhookabove",
              7926,
              "Yiarmenian",
              1349,
              "Yicyrillic",
              1031,
              "Yiwnarmenian",
              1362,
              "Ymonospace",
              65337,
              "Ysmall",
              63353,
              "Ytilde",
              7928,
              "Yusbigcyrillic",
              1130,
              "Yusbigiotifiedcyrillic",
              1132,
              "Yuslittlecyrillic",
              1126,
              "Yuslittleiotifiedcyrillic",
              1128,
              "Z",
              90,
              "Zaarmenian",
              1334,
              "Zacute",
              377,
              "Zcaron",
              381,
              "Zcaronsmall",
              63231,
              "Zcircle",
              9423,
              "Zcircumflex",
              7824,
              "Zdot",
              379,
              "Zdotaccent",
              379,
              "Zdotbelow",
              7826,
              "Zecyrillic",
              1047,
              "Zedescendercyrillic",
              1176,
              "Zedieresiscyrillic",
              1246,
              "Zeta",
              918,
              "Zhearmenian",
              1338,
              "Zhebrevecyrillic",
              1217,
              "Zhecyrillic",
              1046,
              "Zhedescendercyrillic",
              1174,
              "Zhedieresiscyrillic",
              1244,
              "Zlinebelow",
              7828,
              "Zmonospace",
              65338,
              "Zsmall",
              63354,
              "Zstroke",
              437,
              "a",
              97,
              "aabengali",
              2438,
              "aacute",
              225,
              "aadeva",
              2310,
              "aagujarati",
              2694,
              "aagurmukhi",
              2566,
              "aamatragurmukhi",
              2622,
              "aarusquare",
              13059,
              "aavowelsignbengali",
              2494,
              "aavowelsigndeva",
              2366,
              "aavowelsigngujarati",
              2750,
              "abbreviationmarkarmenian",
              1375,
              "abbreviationsigndeva",
              2416,
              "abengali",
              2437,
              "abopomofo",
              12570,
              "abreve",
              259,
              "abreveacute",
              7855,
              "abrevecyrillic",
              1233,
              "abrevedotbelow",
              7863,
              "abrevegrave",
              7857,
              "abrevehookabove",
              7859,
              "abrevetilde",
              7861,
              "acaron",
              462,
              "acircle",
              9424,
              "acircumflex",
              226,
              "acircumflexacute",
              7845,
              "acircumflexdotbelow",
              7853,
              "acircumflexgrave",
              7847,
              "acircumflexhookabove",
              7849,
              "acircumflextilde",
              7851,
              "acute",
              180,
              "acutebelowcmb",
              791,
              "acutecmb",
              769,
              "acutecomb",
              769,
              "acutedeva",
              2388,
              "acutelowmod",
              719,
              "acutetonecmb",
              833,
              "acyrillic",
              1072,
              "adblgrave",
              513,
              "addakgurmukhi",
              2673,
              "adeva",
              2309,
              "adieresis",
              228,
              "adieresiscyrillic",
              1235,
              "adieresismacron",
              479,
              "adotbelow",
              7841,
              "adotmacron",
              481,
              "ae",
              230,
              "aeacute",
              509,
              "aekorean",
              12624,
              "aemacron",
              483,
              "afii00208",
              8213,
              "afii08941",
              8356,
              "afii10017",
              1040,
              "afii10018",
              1041,
              "afii10019",
              1042,
              "afii10020",
              1043,
              "afii10021",
              1044,
              "afii10022",
              1045,
              "afii10023",
              1025,
              "afii10024",
              1046,
              "afii10025",
              1047,
              "afii10026",
              1048,
              "afii10027",
              1049,
              "afii10028",
              1050,
              "afii10029",
              1051,
              "afii10030",
              1052,
              "afii10031",
              1053,
              "afii10032",
              1054,
              "afii10033",
              1055,
              "afii10034",
              1056,
              "afii10035",
              1057,
              "afii10036",
              1058,
              "afii10037",
              1059,
              "afii10038",
              1060,
              "afii10039",
              1061,
              "afii10040",
              1062,
              "afii10041",
              1063,
              "afii10042",
              1064,
              "afii10043",
              1065,
              "afii10044",
              1066,
              "afii10045",
              1067,
              "afii10046",
              1068,
              "afii10047",
              1069,
              "afii10048",
              1070,
              "afii10049",
              1071,
              "afii10050",
              1168,
              "afii10051",
              1026,
              "afii10052",
              1027,
              "afii10053",
              1028,
              "afii10054",
              1029,
              "afii10055",
              1030,
              "afii10056",
              1031,
              "afii10057",
              1032,
              "afii10058",
              1033,
              "afii10059",
              1034,
              "afii10060",
              1035,
              "afii10061",
              1036,
              "afii10062",
              1038,
              "afii10063",
              63172,
              "afii10064",
              63173,
              "afii10065",
              1072,
              "afii10066",
              1073,
              "afii10067",
              1074,
              "afii10068",
              1075,
              "afii10069",
              1076,
              "afii10070",
              1077,
              "afii10071",
              1105,
              "afii10072",
              1078,
              "afii10073",
              1079,
              "afii10074",
              1080,
              "afii10075",
              1081,
              "afii10076",
              1082,
              "afii10077",
              1083,
              "afii10078",
              1084,
              "afii10079",
              1085,
              "afii10080",
              1086,
              "afii10081",
              1087,
              "afii10082",
              1088,
              "afii10083",
              1089,
              "afii10084",
              1090,
              "afii10085",
              1091,
              "afii10086",
              1092,
              "afii10087",
              1093,
              "afii10088",
              1094,
              "afii10089",
              1095,
              "afii10090",
              1096,
              "afii10091",
              1097,
              "afii10092",
              1098,
              "afii10093",
              1099,
              "afii10094",
              1100,
              "afii10095",
              1101,
              "afii10096",
              1102,
              "afii10097",
              1103,
              "afii10098",
              1169,
              "afii10099",
              1106,
              "afii10100",
              1107,
              "afii10101",
              1108,
              "afii10102",
              1109,
              "afii10103",
              1110,
              "afii10104",
              1111,
              "afii10105",
              1112,
              "afii10106",
              1113,
              "afii10107",
              1114,
              "afii10108",
              1115,
              "afii10109",
              1116,
              "afii10110",
              1118,
              "afii10145",
              1039,
              "afii10146",
              1122,
              "afii10147",
              1138,
              "afii10148",
              1140,
              "afii10192",
              63174,
              "afii10193",
              1119,
              "afii10194",
              1123,
              "afii10195",
              1139,
              "afii10196",
              1141,
              "afii10831",
              63175,
              "afii10832",
              63176,
              "afii10846",
              1241,
              "afii299",
              8206,
              "afii300",
              8207,
              "afii301",
              8205,
              "afii57381",
              1642,
              "afii57388",
              1548,
              "afii57392",
              1632,
              "afii57393",
              1633,
              "afii57394",
              1634,
              "afii57395",
              1635,
              "afii57396",
              1636,
              "afii57397",
              1637,
              "afii57398",
              1638,
              "afii57399",
              1639,
              "afii57400",
              1640,
              "afii57401",
              1641,
              "afii57403",
              1563,
              "afii57407",
              1567,
              "afii57409",
              1569,
              "afii57410",
              1570,
              "afii57411",
              1571,
              "afii57412",
              1572,
              "afii57413",
              1573,
              "afii57414",
              1574,
              "afii57415",
              1575,
              "afii57416",
              1576,
              "afii57417",
              1577,
              "afii57418",
              1578,
              "afii57419",
              1579,
              "afii57420",
              1580,
              "afii57421",
              1581,
              "afii57422",
              1582,
              "afii57423",
              1583,
              "afii57424",
              1584,
              "afii57425",
              1585,
              "afii57426",
              1586,
              "afii57427",
              1587,
              "afii57428",
              1588,
              "afii57429",
              1589,
              "afii57430",
              1590,
              "afii57431",
              1591,
              "afii57432",
              1592,
              "afii57433",
              1593,
              "afii57434",
              1594,
              "afii57440",
              1600,
              "afii57441",
              1601,
              "afii57442",
              1602,
              "afii57443",
              1603,
              "afii57444",
              1604,
              "afii57445",
              1605,
              "afii57446",
              1606,
              "afii57448",
              1608,
              "afii57449",
              1609,
              "afii57450",
              1610,
              "afii57451",
              1611,
              "afii57452",
              1612,
              "afii57453",
              1613,
              "afii57454",
              1614,
              "afii57455",
              1615,
              "afii57456",
              1616,
              "afii57457",
              1617,
              "afii57458",
              1618,
              "afii57470",
              1607,
              "afii57505",
              1700,
              "afii57506",
              1662,
              "afii57507",
              1670,
              "afii57508",
              1688,
              "afii57509",
              1711,
              "afii57511",
              1657,
              "afii57512",
              1672,
              "afii57513",
              1681,
              "afii57514",
              1722,
              "afii57519",
              1746,
              "afii57534",
              1749,
              "afii57636",
              8362,
              "afii57645",
              1470,
              "afii57658",
              1475,
              "afii57664",
              1488,
              "afii57665",
              1489,
              "afii57666",
              1490,
              "afii57667",
              1491,
              "afii57668",
              1492,
              "afii57669",
              1493,
              "afii57670",
              1494,
              "afii57671",
              1495,
              "afii57672",
              1496,
              "afii57673",
              1497,
              "afii57674",
              1498,
              "afii57675",
              1499,
              "afii57676",
              1500,
              "afii57677",
              1501,
              "afii57678",
              1502,
              "afii57679",
              1503,
              "afii57680",
              1504,
              "afii57681",
              1505,
              "afii57682",
              1506,
              "afii57683",
              1507,
              "afii57684",
              1508,
              "afii57685",
              1509,
              "afii57686",
              1510,
              "afii57687",
              1511,
              "afii57688",
              1512,
              "afii57689",
              1513,
              "afii57690",
              1514,
              "afii57694",
              64298,
              "afii57695",
              64299,
              "afii57700",
              64331,
              "afii57705",
              64287,
              "afii57716",
              1520,
              "afii57717",
              1521,
              "afii57718",
              1522,
              "afii57723",
              64309,
              "afii57793",
              1460,
              "afii57794",
              1461,
              "afii57795",
              1462,
              "afii57796",
              1467,
              "afii57797",
              1464,
              "afii57798",
              1463,
              "afii57799",
              1456,
              "afii57800",
              1458,
              "afii57801",
              1457,
              "afii57802",
              1459,
              "afii57803",
              1474,
              "afii57804",
              1473,
              "afii57806",
              1465,
              "afii57807",
              1468,
              "afii57839",
              1469,
              "afii57841",
              1471,
              "afii57842",
              1472,
              "afii57929",
              700,
              "afii61248",
              8453,
              "afii61289",
              8467,
              "afii61352",
              8470,
              "afii61573",
              8236,
              "afii61574",
              8237,
              "afii61575",
              8238,
              "afii61664",
              8204,
              "afii63167",
              1645,
              "afii64937",
              701,
              "agrave",
              224,
              "agujarati",
              2693,
              "agurmukhi",
              2565,
              "ahiragana",
              12354,
              "ahookabove",
              7843,
              "aibengali",
              2448,
              "aibopomofo",
              12574,
              "aideva",
              2320,
              "aiecyrillic",
              1237,
              "aigujarati",
              2704,
              "aigurmukhi",
              2576,
              "aimatragurmukhi",
              2632,
              "ainarabic",
              1593,
              "ainfinalarabic",
              65226,
              "aininitialarabic",
              65227,
              "ainmedialarabic",
              65228,
              "ainvertedbreve",
              515,
              "aivowelsignbengali",
              2504,
              "aivowelsigndeva",
              2376,
              "aivowelsigngujarati",
              2760,
              "akatakana",
              12450,
              "akatakanahalfwidth",
              65393,
              "akorean",
              12623,
              "alef",
              1488,
              "alefarabic",
              1575,
              "alefdageshhebrew",
              64304,
              "aleffinalarabic",
              65166,
              "alefhamzaabovearabic",
              1571,
              "alefhamzaabovefinalarabic",
              65156,
              "alefhamzabelowarabic",
              1573,
              "alefhamzabelowfinalarabic",
              65160,
              "alefhebrew",
              1488,
              "aleflamedhebrew",
              64335,
              "alefmaddaabovearabic",
              1570,
              "alefmaddaabovefinalarabic",
              65154,
              "alefmaksuraarabic",
              1609,
              "alefmaksurafinalarabic",
              65264,
              "alefmaksurainitialarabic",
              65267,
              "alefmaksuramedialarabic",
              65268,
              "alefpatahhebrew",
              64302,
              "alefqamatshebrew",
              64303,
              "aleph",
              8501,
              "allequal",
              8780,
              "alpha",
              945,
              "alphatonos",
              940,
              "amacron",
              257,
              "amonospace",
              65345,
              "ampersand",
              38,
              "ampersandmonospace",
              65286,
              "ampersandsmall",
              63270,
              "amsquare",
              13250,
              "anbopomofo",
              12578,
              "angbopomofo",
              12580,
              "angbracketleft",
              12296,
              "angbracketright",
              12297,
              "angkhankhuthai",
              3674,
              "angle",
              8736,
              "anglebracketleft",
              12296,
              "anglebracketleftvertical",
              65087,
              "anglebracketright",
              12297,
              "anglebracketrightvertical",
              65088,
              "angleleft",
              9001,
              "angleright",
              9002,
              "angstrom",
              8491,
              "anoteleia",
              903,
              "anudattadeva",
              2386,
              "anusvarabengali",
              2434,
              "anusvaradeva",
              2306,
              "anusvaragujarati",
              2690,
              "aogonek",
              261,
              "apaatosquare",
              13056,
              "aparen",
              9372,
              "apostrophearmenian",
              1370,
              "apostrophemod",
              700,
              "apple",
              63743,
              "approaches",
              8784,
              "approxequal",
              8776,
              "approxequalorimage",
              8786,
              "approximatelyequal",
              8773,
              "araeaekorean",
              12686,
              "araeakorean",
              12685,
              "arc",
              8978,
              "arighthalfring",
              7834,
              "aring",
              229,
              "aringacute",
              507,
              "aringbelow",
              7681,
              "arrowboth",
              8596,
              "arrowdashdown",
              8675,
              "arrowdashleft",
              8672,
              "arrowdashright",
              8674,
              "arrowdashup",
              8673,
              "arrowdblboth",
              8660,
              "arrowdbldown",
              8659,
              "arrowdblleft",
              8656,
              "arrowdblright",
              8658,
              "arrowdblup",
              8657,
              "arrowdown",
              8595,
              "arrowdownleft",
              8601,
              "arrowdownright",
              8600,
              "arrowdownwhite",
              8681,
              "arrowheaddownmod",
              709,
              "arrowheadleftmod",
              706,
              "arrowheadrightmod",
              707,
              "arrowheadupmod",
              708,
              "arrowhorizex",
              63719,
              "arrowleft",
              8592,
              "arrowleftdbl",
              8656,
              "arrowleftdblstroke",
              8653,
              "arrowleftoverright",
              8646,
              "arrowleftwhite",
              8678,
              "arrowright",
              8594,
              "arrowrightdblstroke",
              8655,
              "arrowrightheavy",
              10142,
              "arrowrightoverleft",
              8644,
              "arrowrightwhite",
              8680,
              "arrowtableft",
              8676,
              "arrowtabright",
              8677,
              "arrowup",
              8593,
              "arrowupdn",
              8597,
              "arrowupdnbse",
              8616,
              "arrowupdownbase",
              8616,
              "arrowupleft",
              8598,
              "arrowupleftofdown",
              8645,
              "arrowupright",
              8599,
              "arrowupwhite",
              8679,
              "arrowvertex",
              63718,
              "asciicircum",
              94,
              "asciicircummonospace",
              65342,
              "asciitilde",
              126,
              "asciitildemonospace",
              65374,
              "ascript",
              593,
              "ascriptturned",
              594,
              "asmallhiragana",
              12353,
              "asmallkatakana",
              12449,
              "asmallkatakanahalfwidth",
              65383,
              "asterisk",
              42,
              "asteriskaltonearabic",
              1645,
              "asteriskarabic",
              1645,
              "asteriskmath",
              8727,
              "asteriskmonospace",
              65290,
              "asterisksmall",
              65121,
              "asterism",
              8258,
              "asuperior",
              63209,
              "asymptoticallyequal",
              8771,
              "at",
              64,
              "atilde",
              227,
              "atmonospace",
              65312,
              "atsmall",
              65131,
              "aturned",
              592,
              "aubengali",
              2452,
              "aubopomofo",
              12576,
              "audeva",
              2324,
              "augujarati",
              2708,
              "augurmukhi",
              2580,
              "aulengthmarkbengali",
              2519,
              "aumatragurmukhi",
              2636,
              "auvowelsignbengali",
              2508,
              "auvowelsigndeva",
              2380,
              "auvowelsigngujarati",
              2764,
              "avagrahadeva",
              2365,
              "aybarmenian",
              1377,
              "ayin",
              1506,
              "ayinaltonehebrew",
              64288,
              "ayinhebrew",
              1506,
              "b",
              98,
              "babengali",
              2476,
              "backslash",
              92,
              "backslashmonospace",
              65340,
              "badeva",
              2348,
              "bagujarati",
              2732,
              "bagurmukhi",
              2604,
              "bahiragana",
              12400,
              "bahtthai",
              3647,
              "bakatakana",
              12496,
              "bar",
              124,
              "barmonospace",
              65372,
              "bbopomofo",
              12549,
              "bcircle",
              9425,
              "bdotaccent",
              7683,
              "bdotbelow",
              7685,
              "beamedsixteenthnotes",
              9836,
              "because",
              8757,
              "becyrillic",
              1073,
              "beharabic",
              1576,
              "behfinalarabic",
              65168,
              "behinitialarabic",
              65169,
              "behiragana",
              12409,
              "behmedialarabic",
              65170,
              "behmeeminitialarabic",
              64671,
              "behmeemisolatedarabic",
              64520,
              "behnoonfinalarabic",
              64621,
              "bekatakana",
              12505,
              "benarmenian",
              1378,
              "bet",
              1489,
              "beta",
              946,
              "betasymbolgreek",
              976,
              "betdagesh",
              64305,
              "betdageshhebrew",
              64305,
              "bethebrew",
              1489,
              "betrafehebrew",
              64332,
              "bhabengali",
              2477,
              "bhadeva",
              2349,
              "bhagujarati",
              2733,
              "bhagurmukhi",
              2605,
              "bhook",
              595,
              "bihiragana",
              12403,
              "bikatakana",
              12499,
              "bilabialclick",
              664,
              "bindigurmukhi",
              2562,
              "birusquare",
              13105,
              "blackcircle",
              9679,
              "blackdiamond",
              9670,
              "blackdownpointingtriangle",
              9660,
              "blackleftpointingpointer",
              9668,
              "blackleftpointingtriangle",
              9664,
              "blacklenticularbracketleft",
              12304,
              "blacklenticularbracketleftvertical",
              65083,
              "blacklenticularbracketright",
              12305,
              "blacklenticularbracketrightvertical",
              65084,
              "blacklowerlefttriangle",
              9699,
              "blacklowerrighttriangle",
              9698,
              "blackrectangle",
              9644,
              "blackrightpointingpointer",
              9658,
              "blackrightpointingtriangle",
              9654,
              "blacksmallsquare",
              9642,
              "blacksmilingface",
              9787,
              "blacksquare",
              9632,
              "blackstar",
              9733,
              "blackupperlefttriangle",
              9700,
              "blackupperrighttriangle",
              9701,
              "blackuppointingsmalltriangle",
              9652,
              "blackuppointingtriangle",
              9650,
              "blank",
              9251,
              "blinebelow",
              7687,
              "block",
              9608,
              "bmonospace",
              65346,
              "bobaimaithai",
              3610,
              "bohiragana",
              12412,
              "bokatakana",
              12508,
              "bparen",
              9373,
              "bqsquare",
              13251,
              "braceex",
              63732,
              "braceleft",
              123,
              "braceleftbt",
              63731,
              "braceleftmid",
              63730,
              "braceleftmonospace",
              65371,
              "braceleftsmall",
              65115,
              "bracelefttp",
              63729,
              "braceleftvertical",
              65079,
              "braceright",
              125,
              "bracerightbt",
              63742,
              "bracerightmid",
              63741,
              "bracerightmonospace",
              65373,
              "bracerightsmall",
              65116,
              "bracerighttp",
              63740,
              "bracerightvertical",
              65080,
              "bracketleft",
              91,
              "bracketleftbt",
              63728,
              "bracketleftex",
              63727,
              "bracketleftmonospace",
              65339,
              "bracketlefttp",
              63726,
              "bracketright",
              93,
              "bracketrightbt",
              63739,
              "bracketrightex",
              63738,
              "bracketrightmonospace",
              65341,
              "bracketrighttp",
              63737,
              "breve",
              728,
              "brevebelowcmb",
              814,
              "brevecmb",
              774,
              "breveinvertedbelowcmb",
              815,
              "breveinvertedcmb",
              785,
              "breveinverteddoublecmb",
              865,
              "bridgebelowcmb",
              810,
              "bridgeinvertedbelowcmb",
              826,
              "brokenbar",
              166,
              "bstroke",
              384,
              "bsuperior",
              63210,
              "btopbar",
              387,
              "buhiragana",
              12406,
              "bukatakana",
              12502,
              "bullet",
              8226,
              "bulletinverse",
              9688,
              "bulletoperator",
              8729,
              "bullseye",
              9678,
              "c",
              99,
              "caarmenian",
              1390,
              "cabengali",
              2458,
              "cacute",
              263,
              "cadeva",
              2330,
              "cagujarati",
              2714,
              "cagurmukhi",
              2586,
              "calsquare",
              13192,
              "candrabindubengali",
              2433,
              "candrabinducmb",
              784,
              "candrabindudeva",
              2305,
              "candrabindugujarati",
              2689,
              "capslock",
              8682,
              "careof",
              8453,
              "caron",
              711,
              "caronbelowcmb",
              812,
              "caroncmb",
              780,
              "carriagereturn",
              8629,
              "cbopomofo",
              12568,
              "ccaron",
              269,
              "ccedilla",
              231,
              "ccedillaacute",
              7689,
              "ccircle",
              9426,
              "ccircumflex",
              265,
              "ccurl",
              597,
              "cdot",
              267,
              "cdotaccent",
              267,
              "cdsquare",
              13253,
              "cedilla",
              184,
              "cedillacmb",
              807,
              "cent",
              162,
              "centigrade",
              8451,
              "centinferior",
              63199,
              "centmonospace",
              65504,
              "centoldstyle",
              63394,
              "centsuperior",
              63200,
              "chaarmenian",
              1401,
              "chabengali",
              2459,
              "chadeva",
              2331,
              "chagujarati",
              2715,
              "chagurmukhi",
              2587,
              "chbopomofo",
              12564,
              "cheabkhasiancyrillic",
              1213,
              "checkmark",
              10003,
              "checyrillic",
              1095,
              "chedescenderabkhasiancyrillic",
              1215,
              "chedescendercyrillic",
              1207,
              "chedieresiscyrillic",
              1269,
              "cheharmenian",
              1395,
              "chekhakassiancyrillic",
              1228,
              "cheverticalstrokecyrillic",
              1209,
              "chi",
              967,
              "chieuchacirclekorean",
              12919,
              "chieuchaparenkorean",
              12823,
              "chieuchcirclekorean",
              12905,
              "chieuchkorean",
              12618,
              "chieuchparenkorean",
              12809,
              "chochangthai",
              3594,
              "chochanthai",
              3592,
              "chochingthai",
              3593,
              "chochoethai",
              3596,
              "chook",
              392,
              "cieucacirclekorean",
              12918,
              "cieucaparenkorean",
              12822,
              "cieuccirclekorean",
              12904,
              "cieuckorean",
              12616,
              "cieucparenkorean",
              12808,
              "cieucuparenkorean",
              12828,
              "circle",
              9675,
              "circlecopyrt",
              169,
              "circlemultiply",
              8855,
              "circleot",
              8857,
              "circleplus",
              8853,
              "circlepostalmark",
              12342,
              "circlewithlefthalfblack",
              9680,
              "circlewithrighthalfblack",
              9681,
              "circumflex",
              710,
              "circumflexbelowcmb",
              813,
              "circumflexcmb",
              770,
              "clear",
              8999,
              "clickalveolar",
              450,
              "clickdental",
              448,
              "clicklateral",
              449,
              "clickretroflex",
              451,
              "club",
              9827,
              "clubsuitblack",
              9827,
              "clubsuitwhite",
              9831,
              "cmcubedsquare",
              13220,
              "cmonospace",
              65347,
              "cmsquaredsquare",
              13216,
              "coarmenian",
              1409,
              "colon",
              58,
              "colonmonetary",
              8353,
              "colonmonospace",
              65306,
              "colonsign",
              8353,
              "colonsmall",
              65109,
              "colontriangularhalfmod",
              721,
              "colontriangularmod",
              720,
              "comma",
              44,
              "commaabovecmb",
              787,
              "commaaboverightcmb",
              789,
              "commaaccent",
              63171,
              "commaarabic",
              1548,
              "commaarmenian",
              1373,
              "commainferior",
              63201,
              "commamonospace",
              65292,
              "commareversedabovecmb",
              788,
              "commareversedmod",
              701,
              "commasmall",
              65104,
              "commasuperior",
              63202,
              "commaturnedabovecmb",
              786,
              "commaturnedmod",
              699,
              "compass",
              9788,
              "congruent",
              8773,
              "contourintegral",
              8750,
              "control",
              8963,
              "controlACK",
              6,
              "controlBEL",
              7,
              "controlBS",
              8,
              "controlCAN",
              24,
              "controlCR",
              13,
              "controlDC1",
              17,
              "controlDC2",
              18,
              "controlDC3",
              19,
              "controlDC4",
              20,
              "controlDEL",
              127,
              "controlDLE",
              16,
              "controlEM",
              25,
              "controlENQ",
              5,
              "controlEOT",
              4,
              "controlESC",
              27,
              "controlETB",
              23,
              "controlETX",
              3,
              "controlFF",
              12,
              "controlFS",
              28,
              "controlGS",
              29,
              "controlHT",
              9,
              "controlLF",
              10,
              "controlNAK",
              21,
              "controlNULL",
              0,
              "controlRS",
              30,
              "controlSI",
              15,
              "controlSO",
              14,
              "controlSOT",
              2,
              "controlSTX",
              1,
              "controlSUB",
              26,
              "controlSYN",
              22,
              "controlUS",
              31,
              "controlVT",
              11,
              "copyright",
              169,
              "copyrightsans",
              63721,
              "copyrightserif",
              63193,
              "cornerbracketleft",
              12300,
              "cornerbracketlefthalfwidth",
              65378,
              "cornerbracketleftvertical",
              65089,
              "cornerbracketright",
              12301,
              "cornerbracketrighthalfwidth",
              65379,
              "cornerbracketrightvertical",
              65090,
              "corporationsquare",
              13183,
              "cosquare",
              13255,
              "coverkgsquare",
              13254,
              "cparen",
              9374,
              "cruzeiro",
              8354,
              "cstretched",
              663,
              "curlyand",
              8911,
              "curlyor",
              8910,
              "currency",
              164,
              "cyrBreve",
              63185,
              "cyrFlex",
              63186,
              "cyrbreve",
              63188,
              "cyrflex",
              63189,
              "d",
              100,
              "daarmenian",
              1380,
              "dabengali",
              2470,
              "dadarabic",
              1590,
              "dadeva",
              2342,
              "dadfinalarabic",
              65214,
              "dadinitialarabic",
              65215,
              "dadmedialarabic",
              65216,
              "dagesh",
              1468,
              "dageshhebrew",
              1468,
              "dagger",
              8224,
              "daggerdbl",
              8225,
              "dagujarati",
              2726,
              "dagurmukhi",
              2598,
              "dahiragana",
              12384,
              "dakatakana",
              12480,
              "dalarabic",
              1583,
              "dalet",
              1491,
              "daletdagesh",
              64307,
              "daletdageshhebrew",
              64307,
              "dalethebrew",
              1491,
              "dalfinalarabic",
              65194,
              "dammaarabic",
              1615,
              "dammalowarabic",
              1615,
              "dammatanaltonearabic",
              1612,
              "dammatanarabic",
              1612,
              "danda",
              2404,
              "dargahebrew",
              1447,
              "dargalefthebrew",
              1447,
              "dasiapneumatacyrilliccmb",
              1157,
              "dblGrave",
              63187,
              "dblanglebracketleft",
              12298,
              "dblanglebracketleftvertical",
              65085,
              "dblanglebracketright",
              12299,
              "dblanglebracketrightvertical",
              65086,
              "dblarchinvertedbelowcmb",
              811,
              "dblarrowleft",
              8660,
              "dblarrowright",
              8658,
              "dbldanda",
              2405,
              "dblgrave",
              63190,
              "dblgravecmb",
              783,
              "dblintegral",
              8748,
              "dbllowline",
              8215,
              "dbllowlinecmb",
              819,
              "dbloverlinecmb",
              831,
              "dblprimemod",
              698,
              "dblverticalbar",
              8214,
              "dblverticallineabovecmb",
              782,
              "dbopomofo",
              12553,
              "dbsquare",
              13256,
              "dcaron",
              271,
              "dcedilla",
              7697,
              "dcircle",
              9427,
              "dcircumflexbelow",
              7699,
              "dcroat",
              273,
              "ddabengali",
              2465,
              "ddadeva",
              2337,
              "ddagujarati",
              2721,
              "ddagurmukhi",
              2593,
              "ddalarabic",
              1672,
              "ddalfinalarabic",
              64393,
              "dddhadeva",
              2396,
              "ddhabengali",
              2466,
              "ddhadeva",
              2338,
              "ddhagujarati",
              2722,
              "ddhagurmukhi",
              2594,
              "ddotaccent",
              7691,
              "ddotbelow",
              7693,
              "decimalseparatorarabic",
              1643,
              "decimalseparatorpersian",
              1643,
              "decyrillic",
              1076,
              "degree",
              176,
              "dehihebrew",
              1453,
              "dehiragana",
              12391,
              "deicoptic",
              1007,
              "dekatakana",
              12487,
              "deleteleft",
              9003,
              "deleteright",
              8998,
              "delta",
              948,
              "deltaturned",
              397,
              "denominatorminusonenumeratorbengali",
              2552,
              "dezh",
              676,
              "dhabengali",
              2471,
              "dhadeva",
              2343,
              "dhagujarati",
              2727,
              "dhagurmukhi",
              2599,
              "dhook",
              599,
              "dialytikatonos",
              901,
              "dialytikatonoscmb",
              836,
              "diamond",
              9830,
              "diamondsuitwhite",
              9826,
              "dieresis",
              168,
              "dieresisacute",
              63191,
              "dieresisbelowcmb",
              804,
              "dieresiscmb",
              776,
              "dieresisgrave",
              63192,
              "dieresistonos",
              901,
              "dihiragana",
              12386,
              "dikatakana",
              12482,
              "dittomark",
              12291,
              "divide",
              247,
              "divides",
              8739,
              "divisionslash",
              8725,
              "djecyrillic",
              1106,
              "dkshade",
              9619,
              "dlinebelow",
              7695,
              "dlsquare",
              13207,
              "dmacron",
              273,
              "dmonospace",
              65348,
              "dnblock",
              9604,
              "dochadathai",
              3598,
              "dodekthai",
              3604,
              "dohiragana",
              12393,
              "dokatakana",
              12489,
              "dollar",
              36,
              "dollarinferior",
              63203,
              "dollarmonospace",
              65284,
              "dollaroldstyle",
              63268,
              "dollarsmall",
              65129,
              "dollarsuperior",
              63204,
              "dong",
              8363,
              "dorusquare",
              13094,
              "dotaccent",
              729,
              "dotaccentcmb",
              775,
              "dotbelowcmb",
              803,
              "dotbelowcomb",
              803,
              "dotkatakana",
              12539,
              "dotlessi",
              305,
              "dotlessj",
              63166,
              "dotlessjstrokehook",
              644,
              "dotmath",
              8901,
              "dottedcircle",
              9676,
              "doubleyodpatah",
              64287,
              "doubleyodpatahhebrew",
              64287,
              "downtackbelowcmb",
              798,
              "downtackmod",
              725,
              "dparen",
              9375,
              "dsuperior",
              63211,
              "dtail",
              598,
              "dtopbar",
              396,
              "duhiragana",
              12389,
              "dukatakana",
              12485,
              "dz",
              499,
              "dzaltone",
              675,
              "dzcaron",
              454,
              "dzcurl",
              677,
              "dzeabkhasiancyrillic",
              1249,
              "dzecyrillic",
              1109,
              "dzhecyrillic",
              1119,
              "e",
              101,
              "eacute",
              233,
              "earth",
              9793,
              "ebengali",
              2447,
              "ebopomofo",
              12572,
              "ebreve",
              277,
              "ecandradeva",
              2317,
              "ecandragujarati",
              2701,
              "ecandravowelsigndeva",
              2373,
              "ecandravowelsigngujarati",
              2757,
              "ecaron",
              283,
              "ecedillabreve",
              7709,
              "echarmenian",
              1381,
              "echyiwnarmenian",
              1415,
              "ecircle",
              9428,
              "ecircumflex",
              234,
              "ecircumflexacute",
              7871,
              "ecircumflexbelow",
              7705,
              "ecircumflexdotbelow",
              7879,
              "ecircumflexgrave",
              7873,
              "ecircumflexhookabove",
              7875,
              "ecircumflextilde",
              7877,
              "ecyrillic",
              1108,
              "edblgrave",
              517,
              "edeva",
              2319,
              "edieresis",
              235,
              "edot",
              279,
              "edotaccent",
              279,
              "edotbelow",
              7865,
              "eegurmukhi",
              2575,
              "eematragurmukhi",
              2631,
              "efcyrillic",
              1092,
              "egrave",
              232,
              "egujarati",
              2703,
              "eharmenian",
              1383,
              "ehbopomofo",
              12573,
              "ehiragana",
              12360,
              "ehookabove",
              7867,
              "eibopomofo",
              12575,
              "eight",
              56,
              "eightarabic",
              1640,
              "eightbengali",
              2542,
              "eightcircle",
              9319,
              "eightcircleinversesansserif",
              10129,
              "eightdeva",
              2414,
              "eighteencircle",
              9329,
              "eighteenparen",
              9349,
              "eighteenperiod",
              9369,
              "eightgujarati",
              2798,
              "eightgurmukhi",
              2670,
              "eighthackarabic",
              1640,
              "eighthangzhou",
              12328,
              "eighthnotebeamed",
              9835,
              "eightideographicparen",
              12839,
              "eightinferior",
              8328,
              "eightmonospace",
              65304,
              "eightoldstyle",
              63288,
              "eightparen",
              9339,
              "eightperiod",
              9359,
              "eightpersian",
              1784,
              "eightroman",
              8567,
              "eightsuperior",
              8312,
              "eightthai",
              3672,
              "einvertedbreve",
              519,
              "eiotifiedcyrillic",
              1125,
              "ekatakana",
              12456,
              "ekatakanahalfwidth",
              65396,
              "ekonkargurmukhi",
              2676,
              "ekorean",
              12628,
              "elcyrillic",
              1083,
              "element",
              8712,
              "elevencircle",
              9322,
              "elevenparen",
              9342,
              "elevenperiod",
              9362,
              "elevenroman",
              8570,
              "ellipsis",
              8230,
              "ellipsisvertical",
              8942,
              "emacron",
              275,
              "emacronacute",
              7703,
              "emacrongrave",
              7701,
              "emcyrillic",
              1084,
              "emdash",
              8212,
              "emdashvertical",
              65073,
              "emonospace",
              65349,
              "emphasismarkarmenian",
              1371,
              "emptyset",
              8709,
              "enbopomofo",
              12579,
              "encyrillic",
              1085,
              "endash",
              8211,
              "endashvertical",
              65074,
              "endescendercyrillic",
              1187,
              "eng",
              331,
              "engbopomofo",
              12581,
              "enghecyrillic",
              1189,
              "enhookcyrillic",
              1224,
              "enspace",
              8194,
              "eogonek",
              281,
              "eokorean",
              12627,
              "eopen",
              603,
              "eopenclosed",
              666,
              "eopenreversed",
              604,
              "eopenreversedclosed",
              606,
              "eopenreversedhook",
              605,
              "eparen",
              9376,
              "epsilon",
              949,
              "epsilontonos",
              941,
              "equal",
              61,
              "equalmonospace",
              65309,
              "equalsmall",
              65126,
              "equalsuperior",
              8316,
              "equivalence",
              8801,
              "erbopomofo",
              12582,
              "ercyrillic",
              1088,
              "ereversed",
              600,
              "ereversedcyrillic",
              1101,
              "escyrillic",
              1089,
              "esdescendercyrillic",
              1195,
              "esh",
              643,
              "eshcurl",
              646,
              "eshortdeva",
              2318,
              "eshortvowelsigndeva",
              2374,
              "eshreversedloop",
              426,
              "eshsquatreversed",
              645,
              "esmallhiragana",
              12359,
              "esmallkatakana",
              12455,
              "esmallkatakanahalfwidth",
              65386,
              "estimated",
              8494,
              "esuperior",
              63212,
              "eta",
              951,
              "etarmenian",
              1384,
              "etatonos",
              942,
              "eth",
              240,
              "etilde",
              7869,
              "etildebelow",
              7707,
              "etnahtafoukhhebrew",
              1425,
              "etnahtafoukhlefthebrew",
              1425,
              "etnahtahebrew",
              1425,
              "etnahtalefthebrew",
              1425,
              "eturned",
              477,
              "eukorean",
              12641,
              "euro",
              8364,
              "evowelsignbengali",
              2503,
              "evowelsigndeva",
              2375,
              "evowelsigngujarati",
              2759,
              "exclam",
              33,
              "exclamarmenian",
              1372,
              "exclamdbl",
              8252,
              "exclamdown",
              161,
              "exclamdownsmall",
              63393,
              "exclammonospace",
              65281,
              "exclamsmall",
              63265,
              "existential",
              8707,
              "ezh",
              658,
              "ezhcaron",
              495,
              "ezhcurl",
              659,
              "ezhreversed",
              441,
              "ezhtail",
              442,
              "f",
              102,
              "fadeva",
              2398,
              "fagurmukhi",
              2654,
              "fahrenheit",
              8457,
              "fathaarabic",
              1614,
              "fathalowarabic",
              1614,
              "fathatanarabic",
              1611,
              "fbopomofo",
              12552,
              "fcircle",
              9429,
              "fdotaccent",
              7711,
              "feharabic",
              1601,
              "feharmenian",
              1414,
              "fehfinalarabic",
              65234,
              "fehinitialarabic",
              65235,
              "fehmedialarabic",
              65236,
              "feicoptic",
              997,
              "female",
              9792,
              "ff",
              64256,
              "f_f",
              64256,
              "ffi",
              64259,
              "ffl",
              64260,
              "fi",
              64257,
              "fifteencircle",
              9326,
              "fifteenparen",
              9346,
              "fifteenperiod",
              9366,
              "figuredash",
              8210,
              "filledbox",
              9632,
              "filledrect",
              9644,
              "finalkaf",
              1498,
              "finalkafdagesh",
              64314,
              "finalkafdageshhebrew",
              64314,
              "finalkafhebrew",
              1498,
              "finalmem",
              1501,
              "finalmemhebrew",
              1501,
              "finalnun",
              1503,
              "finalnunhebrew",
              1503,
              "finalpe",
              1507,
              "finalpehebrew",
              1507,
              "finaltsadi",
              1509,
              "finaltsadihebrew",
              1509,
              "firsttonechinese",
              713,
              "fisheye",
              9673,
              "fitacyrillic",
              1139,
              "five",
              53,
              "fivearabic",
              1637,
              "fivebengali",
              2539,
              "fivecircle",
              9316,
              "fivecircleinversesansserif",
              10126,
              "fivedeva",
              2411,
              "fiveeighths",
              8541,
              "fivegujarati",
              2795,
              "fivegurmukhi",
              2667,
              "fivehackarabic",
              1637,
              "fivehangzhou",
              12325,
              "fiveideographicparen",
              12836,
              "fiveinferior",
              8325,
              "fivemonospace",
              65301,
              "fiveoldstyle",
              63285,
              "fiveparen",
              9336,
              "fiveperiod",
              9356,
              "fivepersian",
              1781,
              "fiveroman",
              8564,
              "fivesuperior",
              8309,
              "fivethai",
              3669,
              "fl",
              64258,
              "florin",
              402,
              "fmonospace",
              65350,
              "fmsquare",
              13209,
              "fofanthai",
              3615,
              "fofathai",
              3613,
              "fongmanthai",
              3663,
              "forall",
              8704,
              "four",
              52,
              "fourarabic",
              1636,
              "fourbengali",
              2538,
              "fourcircle",
              9315,
              "fourcircleinversesansserif",
              10125,
              "fourdeva",
              2410,
              "fourgujarati",
              2794,
              "fourgurmukhi",
              2666,
              "fourhackarabic",
              1636,
              "fourhangzhou",
              12324,
              "fourideographicparen",
              12835,
              "fourinferior",
              8324,
              "fourmonospace",
              65300,
              "fournumeratorbengali",
              2551,
              "fouroldstyle",
              63284,
              "fourparen",
              9335,
              "fourperiod",
              9355,
              "fourpersian",
              1780,
              "fourroman",
              8563,
              "foursuperior",
              8308,
              "fourteencircle",
              9325,
              "fourteenparen",
              9345,
              "fourteenperiod",
              9365,
              "fourthai",
              3668,
              "fourthtonechinese",
              715,
              "fparen",
              9377,
              "fraction",
              8260,
              "franc",
              8355,
              "g",
              103,
              "gabengali",
              2455,
              "gacute",
              501,
              "gadeva",
              2327,
              "gafarabic",
              1711,
              "gaffinalarabic",
              64403,
              "gafinitialarabic",
              64404,
              "gafmedialarabic",
              64405,
              "gagujarati",
              2711,
              "gagurmukhi",
              2583,
              "gahiragana",
              12364,
              "gakatakana",
              12460,
              "gamma",
              947,
              "gammalatinsmall",
              611,
              "gammasuperior",
              736,
              "gangiacoptic",
              1003,
              "gbopomofo",
              12557,
              "gbreve",
              287,
              "gcaron",
              487,
              "gcedilla",
              291,
              "gcircle",
              9430,
              "gcircumflex",
              285,
              "gcommaaccent",
              291,
              "gdot",
              289,
              "gdotaccent",
              289,
              "gecyrillic",
              1075,
              "gehiragana",
              12370,
              "gekatakana",
              12466,
              "geometricallyequal",
              8785,
              "gereshaccenthebrew",
              1436,
              "gereshhebrew",
              1523,
              "gereshmuqdamhebrew",
              1437,
              "germandbls",
              223,
              "gershayimaccenthebrew",
              1438,
              "gershayimhebrew",
              1524,
              "getamark",
              12307,
              "ghabengali",
              2456,
              "ghadarmenian",
              1394,
              "ghadeva",
              2328,
              "ghagujarati",
              2712,
              "ghagurmukhi",
              2584,
              "ghainarabic",
              1594,
              "ghainfinalarabic",
              65230,
              "ghaininitialarabic",
              65231,
              "ghainmedialarabic",
              65232,
              "ghemiddlehookcyrillic",
              1173,
              "ghestrokecyrillic",
              1171,
              "gheupturncyrillic",
              1169,
              "ghhadeva",
              2394,
              "ghhagurmukhi",
              2650,
              "ghook",
              608,
              "ghzsquare",
              13203,
              "gihiragana",
              12366,
              "gikatakana",
              12462,
              "gimarmenian",
              1379,
              "gimel",
              1490,
              "gimeldagesh",
              64306,
              "gimeldageshhebrew",
              64306,
              "gimelhebrew",
              1490,
              "gjecyrillic",
              1107,
              "glottalinvertedstroke",
              446,
              "glottalstop",
              660,
              "glottalstopinverted",
              662,
              "glottalstopmod",
              704,
              "glottalstopreversed",
              661,
              "glottalstopreversedmod",
              705,
              "glottalstopreversedsuperior",
              740,
              "glottalstopstroke",
              673,
              "glottalstopstrokereversed",
              674,
              "gmacron",
              7713,
              "gmonospace",
              65351,
              "gohiragana",
              12372,
              "gokatakana",
              12468,
              "gparen",
              9378,
              "gpasquare",
              13228,
              "gradient",
              8711,
              "grave",
              96,
              "gravebelowcmb",
              790,
              "gravecmb",
              768,
              "gravecomb",
              768,
              "gravedeva",
              2387,
              "gravelowmod",
              718,
              "gravemonospace",
              65344,
              "gravetonecmb",
              832,
              "greater",
              62,
              "greaterequal",
              8805,
              "greaterequalorless",
              8923,
              "greatermonospace",
              65310,
              "greaterorequivalent",
              8819,
              "greaterorless",
              8823,
              "greateroverequal",
              8807,
              "greatersmall",
              65125,
              "gscript",
              609,
              "gstroke",
              485,
              "guhiragana",
              12368,
              "guillemotleft",
              171,
              "guillemotright",
              187,
              "guilsinglleft",
              8249,
              "guilsinglright",
              8250,
              "gukatakana",
              12464,
              "guramusquare",
              13080,
              "gysquare",
              13257,
              "h",
              104,
              "haabkhasiancyrillic",
              1193,
              "haaltonearabic",
              1729,
              "habengali",
              2489,
              "hadescendercyrillic",
              1203,
              "hadeva",
              2361,
              "hagujarati",
              2745,
              "hagurmukhi",
              2617,
              "haharabic",
              1581,
              "hahfinalarabic",
              65186,
              "hahinitialarabic",
              65187,
              "hahiragana",
              12399,
              "hahmedialarabic",
              65188,
              "haitusquare",
              13098,
              "hakatakana",
              12495,
              "hakatakanahalfwidth",
              65418,
              "halantgurmukhi",
              2637,
              "hamzaarabic",
              1569,
              "hamzalowarabic",
              1569,
              "hangulfiller",
              12644,
              "hardsigncyrillic",
              1098,
              "harpoonleftbarbup",
              8636,
              "harpoonrightbarbup",
              8640,
              "hasquare",
              13258,
              "hatafpatah",
              1458,
              "hatafpatah16",
              1458,
              "hatafpatah23",
              1458,
              "hatafpatah2f",
              1458,
              "hatafpatahhebrew",
              1458,
              "hatafpatahnarrowhebrew",
              1458,
              "hatafpatahquarterhebrew",
              1458,
              "hatafpatahwidehebrew",
              1458,
              "hatafqamats",
              1459,
              "hatafqamats1b",
              1459,
              "hatafqamats28",
              1459,
              "hatafqamats34",
              1459,
              "hatafqamatshebrew",
              1459,
              "hatafqamatsnarrowhebrew",
              1459,
              "hatafqamatsquarterhebrew",
              1459,
              "hatafqamatswidehebrew",
              1459,
              "hatafsegol",
              1457,
              "hatafsegol17",
              1457,
              "hatafsegol24",
              1457,
              "hatafsegol30",
              1457,
              "hatafsegolhebrew",
              1457,
              "hatafsegolnarrowhebrew",
              1457,
              "hatafsegolquarterhebrew",
              1457,
              "hatafsegolwidehebrew",
              1457,
              "hbar",
              295,
              "hbopomofo",
              12559,
              "hbrevebelow",
              7723,
              "hcedilla",
              7721,
              "hcircle",
              9431,
              "hcircumflex",
              293,
              "hdieresis",
              7719,
              "hdotaccent",
              7715,
              "hdotbelow",
              7717,
              "he",
              1492,
              "heart",
              9829,
              "heartsuitblack",
              9829,
              "heartsuitwhite",
              9825,
              "hedagesh",
              64308,
              "hedageshhebrew",
              64308,
              "hehaltonearabic",
              1729,
              "heharabic",
              1607,
              "hehebrew",
              1492,
              "hehfinalaltonearabic",
              64423,
              "hehfinalalttwoarabic",
              65258,
              "hehfinalarabic",
              65258,
              "hehhamzaabovefinalarabic",
              64421,
              "hehhamzaaboveisolatedarabic",
              64420,
              "hehinitialaltonearabic",
              64424,
              "hehinitialarabic",
              65259,
              "hehiragana",
              12408,
              "hehmedialaltonearabic",
              64425,
              "hehmedialarabic",
              65260,
              "heiseierasquare",
              13179,
              "hekatakana",
              12504,
              "hekatakanahalfwidth",
              65421,
              "hekutaarusquare",
              13110,
              "henghook",
              615,
              "herutusquare",
              13113,
              "het",
              1495,
              "hethebrew",
              1495,
              "hhook",
              614,
              "hhooksuperior",
              689,
              "hieuhacirclekorean",
              12923,
              "hieuhaparenkorean",
              12827,
              "hieuhcirclekorean",
              12909,
              "hieuhkorean",
              12622,
              "hieuhparenkorean",
              12813,
              "hihiragana",
              12402,
              "hikatakana",
              12498,
              "hikatakanahalfwidth",
              65419,
              "hiriq",
              1460,
              "hiriq14",
              1460,
              "hiriq21",
              1460,
              "hiriq2d",
              1460,
              "hiriqhebrew",
              1460,
              "hiriqnarrowhebrew",
              1460,
              "hiriqquarterhebrew",
              1460,
              "hiriqwidehebrew",
              1460,
              "hlinebelow",
              7830,
              "hmonospace",
              65352,
              "hoarmenian",
              1392,
              "hohipthai",
              3627,
              "hohiragana",
              12411,
              "hokatakana",
              12507,
              "hokatakanahalfwidth",
              65422,
              "holam",
              1465,
              "holam19",
              1465,
              "holam26",
              1465,
              "holam32",
              1465,
              "holamhebrew",
              1465,
              "holamnarrowhebrew",
              1465,
              "holamquarterhebrew",
              1465,
              "holamwidehebrew",
              1465,
              "honokhukthai",
              3630,
              "hookabovecomb",
              777,
              "hookcmb",
              777,
              "hookpalatalizedbelowcmb",
              801,
              "hookretroflexbelowcmb",
              802,
              "hoonsquare",
              13122,
              "horicoptic",
              1001,
              "horizontalbar",
              8213,
              "horncmb",
              795,
              "hotsprings",
              9832,
              "house",
              8962,
              "hparen",
              9379,
              "hsuperior",
              688,
              "hturned",
              613,
              "huhiragana",
              12405,
              "huiitosquare",
              13107,
              "hukatakana",
              12501,
              "hukatakanahalfwidth",
              65420,
              "hungarumlaut",
              733,
              "hungarumlautcmb",
              779,
              "hv",
              405,
              "hyphen",
              45,
              "hypheninferior",
              63205,
              "hyphenmonospace",
              65293,
              "hyphensmall",
              65123,
              "hyphensuperior",
              63206,
              "hyphentwo",
              8208,
              "i",
              105,
              "iacute",
              237,
              "iacyrillic",
              1103,
              "ibengali",
              2439,
              "ibopomofo",
              12583,
              "ibreve",
              301,
              "icaron",
              464,
              "icircle",
              9432,
              "icircumflex",
              238,
              "icyrillic",
              1110,
              "idblgrave",
              521,
              "ideographearthcircle",
              12943,
              "ideographfirecircle",
              12939,
              "ideographicallianceparen",
              12863,
              "ideographiccallparen",
              12858,
              "ideographiccentrecircle",
              12965,
              "ideographicclose",
              12294,
              "ideographiccomma",
              12289,
              "ideographiccommaleft",
              65380,
              "ideographiccongratulationparen",
              12855,
              "ideographiccorrectcircle",
              12963,
              "ideographicearthparen",
              12847,
              "ideographicenterpriseparen",
              12861,
              "ideographicexcellentcircle",
              12957,
              "ideographicfestivalparen",
              12864,
              "ideographicfinancialcircle",
              12950,
              "ideographicfinancialparen",
              12854,
              "ideographicfireparen",
              12843,
              "ideographichaveparen",
              12850,
              "ideographichighcircle",
              12964,
              "ideographiciterationmark",
              12293,
              "ideographiclaborcircle",
              12952,
              "ideographiclaborparen",
              12856,
              "ideographicleftcircle",
              12967,
              "ideographiclowcircle",
              12966,
              "ideographicmedicinecircle",
              12969,
              "ideographicmetalparen",
              12846,
              "ideographicmoonparen",
              12842,
              "ideographicnameparen",
              12852,
              "ideographicperiod",
              12290,
              "ideographicprintcircle",
              12958,
              "ideographicreachparen",
              12867,
              "ideographicrepresentparen",
              12857,
              "ideographicresourceparen",
              12862,
              "ideographicrightcircle",
              12968,
              "ideographicsecretcircle",
              12953,
              "ideographicselfparen",
              12866,
              "ideographicsocietyparen",
              12851,
              "ideographicspace",
              12288,
              "ideographicspecialparen",
              12853,
              "ideographicstockparen",
              12849,
              "ideographicstudyparen",
              12859,
              "ideographicsunparen",
              12848,
              "ideographicsuperviseparen",
              12860,
              "ideographicwaterparen",
              12844,
              "ideographicwoodparen",
              12845,
              "ideographiczero",
              12295,
              "ideographmetalcircle",
              12942,
              "ideographmooncircle",
              12938,
              "ideographnamecircle",
              12948,
              "ideographsuncircle",
              12944,
              "ideographwatercircle",
              12940,
              "ideographwoodcircle",
              12941,
              "ideva",
              2311,
              "idieresis",
              239,
              "idieresisacute",
              7727,
              "idieresiscyrillic",
              1253,
              "idotbelow",
              7883,
              "iebrevecyrillic",
              1239,
              "iecyrillic",
              1077,
              "ieungacirclekorean",
              12917,
              "ieungaparenkorean",
              12821,
              "ieungcirclekorean",
              12903,
              "ieungkorean",
              12615,
              "ieungparenkorean",
              12807,
              "igrave",
              236,
              "igujarati",
              2695,
              "igurmukhi",
              2567,
              "ihiragana",
              12356,
              "ihookabove",
              7881,
              "iibengali",
              2440,
              "iicyrillic",
              1080,
              "iideva",
              2312,
              "iigujarati",
              2696,
              "iigurmukhi",
              2568,
              "iimatragurmukhi",
              2624,
              "iinvertedbreve",
              523,
              "iishortcyrillic",
              1081,
              "iivowelsignbengali",
              2496,
              "iivowelsigndeva",
              2368,
              "iivowelsigngujarati",
              2752,
              "ij",
              307,
              "ikatakana",
              12452,
              "ikatakanahalfwidth",
              65394,
              "ikorean",
              12643,
              "ilde",
              732,
              "iluyhebrew",
              1452,
              "imacron",
              299,
              "imacroncyrillic",
              1251,
              "imageorapproximatelyequal",
              8787,
              "imatragurmukhi",
              2623,
              "imonospace",
              65353,
              "increment",
              8710,
              "infinity",
              8734,
              "iniarmenian",
              1387,
              "integral",
              8747,
              "integralbottom",
              8993,
              "integralbt",
              8993,
              "integralex",
              63733,
              "integraltop",
              8992,
              "integraltp",
              8992,
              "intersection",
              8745,
              "intisquare",
              13061,
              "invbullet",
              9688,
              "invcircle",
              9689,
              "invsmileface",
              9787,
              "iocyrillic",
              1105,
              "iogonek",
              303,
              "iota",
              953,
              "iotadieresis",
              970,
              "iotadieresistonos",
              912,
              "iotalatin",
              617,
              "iotatonos",
              943,
              "iparen",
              9380,
              "irigurmukhi",
              2674,
              "ismallhiragana",
              12355,
              "ismallkatakana",
              12451,
              "ismallkatakanahalfwidth",
              65384,
              "issharbengali",
              2554,
              "istroke",
              616,
              "isuperior",
              63213,
              "iterationhiragana",
              12445,
              "iterationkatakana",
              12541,
              "itilde",
              297,
              "itildebelow",
              7725,
              "iubopomofo",
              12585,
              "iucyrillic",
              1102,
              "ivowelsignbengali",
              2495,
              "ivowelsigndeva",
              2367,
              "ivowelsigngujarati",
              2751,
              "izhitsacyrillic",
              1141,
              "izhitsadblgravecyrillic",
              1143,
              "j",
              106,
              "jaarmenian",
              1393,
              "jabengali",
              2460,
              "jadeva",
              2332,
              "jagujarati",
              2716,
              "jagurmukhi",
              2588,
              "jbopomofo",
              12560,
              "jcaron",
              496,
              "jcircle",
              9433,
              "jcircumflex",
              309,
              "jcrossedtail",
              669,
              "jdotlessstroke",
              607,
              "jecyrillic",
              1112,
              "jeemarabic",
              1580,
              "jeemfinalarabic",
              65182,
              "jeeminitialarabic",
              65183,
              "jeemmedialarabic",
              65184,
              "jeharabic",
              1688,
              "jehfinalarabic",
              64395,
              "jhabengali",
              2461,
              "jhadeva",
              2333,
              "jhagujarati",
              2717,
              "jhagurmukhi",
              2589,
              "jheharmenian",
              1403,
              "jis",
              12292,
              "jmonospace",
              65354,
              "jparen",
              9381,
              "jsuperior",
              690,
              "k",
              107,
              "kabashkircyrillic",
              1185,
              "kabengali",
              2453,
              "kacute",
              7729,
              "kacyrillic",
              1082,
              "kadescendercyrillic",
              1179,
              "kadeva",
              2325,
              "kaf",
              1499,
              "kafarabic",
              1603,
              "kafdagesh",
              64315,
              "kafdageshhebrew",
              64315,
              "kaffinalarabic",
              65242,
              "kafhebrew",
              1499,
              "kafinitialarabic",
              65243,
              "kafmedialarabic",
              65244,
              "kafrafehebrew",
              64333,
              "kagujarati",
              2709,
              "kagurmukhi",
              2581,
              "kahiragana",
              12363,
              "kahookcyrillic",
              1220,
              "kakatakana",
              12459,
              "kakatakanahalfwidth",
              65398,
              "kappa",
              954,
              "kappasymbolgreek",
              1008,
              "kapyeounmieumkorean",
              12657,
              "kapyeounphieuphkorean",
              12676,
              "kapyeounpieupkorean",
              12664,
              "kapyeounssangpieupkorean",
              12665,
              "karoriisquare",
              13069,
              "kashidaautoarabic",
              1600,
              "kashidaautonosidebearingarabic",
              1600,
              "kasmallkatakana",
              12533,
              "kasquare",
              13188,
              "kasraarabic",
              1616,
              "kasratanarabic",
              1613,
              "kastrokecyrillic",
              1183,
              "katahiraprolongmarkhalfwidth",
              65392,
              "kaverticalstrokecyrillic",
              1181,
              "kbopomofo",
              12558,
              "kcalsquare",
              13193,
              "kcaron",
              489,
              "kcedilla",
              311,
              "kcircle",
              9434,
              "kcommaaccent",
              311,
              "kdotbelow",
              7731,
              "keharmenian",
              1412,
              "kehiragana",
              12369,
              "kekatakana",
              12465,
              "kekatakanahalfwidth",
              65401,
              "kenarmenian",
              1391,
              "kesmallkatakana",
              12534,
              "kgreenlandic",
              312,
              "khabengali",
              2454,
              "khacyrillic",
              1093,
              "khadeva",
              2326,
              "khagujarati",
              2710,
              "khagurmukhi",
              2582,
              "khaharabic",
              1582,
              "khahfinalarabic",
              65190,
              "khahinitialarabic",
              65191,
              "khahmedialarabic",
              65192,
              "kheicoptic",
              999,
              "khhadeva",
              2393,
              "khhagurmukhi",
              2649,
              "khieukhacirclekorean",
              12920,
              "khieukhaparenkorean",
              12824,
              "khieukhcirclekorean",
              12906,
              "khieukhkorean",
              12619,
              "khieukhparenkorean",
              12810,
              "khokhaithai",
              3586,
              "khokhonthai",
              3589,
              "khokhuatthai",
              3587,
              "khokhwaithai",
              3588,
              "khomutthai",
              3675,
              "khook",
              409,
              "khorakhangthai",
              3590,
              "khzsquare",
              13201,
              "kihiragana",
              12365,
              "kikatakana",
              12461,
              "kikatakanahalfwidth",
              65399,
              "kiroguramusquare",
              13077,
              "kiromeetorusquare",
              13078,
              "kirosquare",
              13076,
              "kiyeokacirclekorean",
              12910,
              "kiyeokaparenkorean",
              12814,
              "kiyeokcirclekorean",
              12896,
              "kiyeokkorean",
              12593,
              "kiyeokparenkorean",
              12800,
              "kiyeoksioskorean",
              12595,
              "kjecyrillic",
              1116,
              "klinebelow",
              7733,
              "klsquare",
              13208,
              "kmcubedsquare",
              13222,
              "kmonospace",
              65355,
              "kmsquaredsquare",
              13218,
              "kohiragana",
              12371,
              "kohmsquare",
              13248,
              "kokaithai",
              3585,
              "kokatakana",
              12467,
              "kokatakanahalfwidth",
              65402,
              "kooposquare",
              13086,
              "koppacyrillic",
              1153,
              "koreanstandardsymbol",
              12927,
              "koroniscmb",
              835,
              "kparen",
              9382,
              "kpasquare",
              13226,
              "ksicyrillic",
              1135,
              "ktsquare",
              13263,
              "kturned",
              670,
              "kuhiragana",
              12367,
              "kukatakana",
              12463,
              "kukatakanahalfwidth",
              65400,
              "kvsquare",
              13240,
              "kwsquare",
              13246,
              "l",
              108,
              "labengali",
              2482,
              "lacute",
              314,
              "ladeva",
              2354,
              "lagujarati",
              2738,
              "lagurmukhi",
              2610,
              "lakkhangyaothai",
              3653,
              "lamaleffinalarabic",
              65276,
              "lamalefhamzaabovefinalarabic",
              65272,
              "lamalefhamzaaboveisolatedarabic",
              65271,
              "lamalefhamzabelowfinalarabic",
              65274,
              "lamalefhamzabelowisolatedarabic",
              65273,
              "lamalefisolatedarabic",
              65275,
              "lamalefmaddaabovefinalarabic",
              65270,
              "lamalefmaddaaboveisolatedarabic",
              65269,
              "lamarabic",
              1604,
              "lambda",
              955,
              "lambdastroke",
              411,
              "lamed",
              1500,
              "lameddagesh",
              64316,
              "lameddageshhebrew",
              64316,
              "lamedhebrew",
              1500,
              "lamfinalarabic",
              65246,
              "lamhahinitialarabic",
              64714,
              "laminitialarabic",
              65247,
              "lamjeeminitialarabic",
              64713,
              "lamkhahinitialarabic",
              64715,
              "lamlamhehisolatedarabic",
              65010,
              "lammedialarabic",
              65248,
              "lammeemhahinitialarabic",
              64904,
              "lammeeminitialarabic",
              64716,
              "largecircle",
              9711,
              "lbar",
              410,
              "lbelt",
              620,
              "lbopomofo",
              12556,
              "lcaron",
              318,
              "lcedilla",
              316,
              "lcircle",
              9435,
              "lcircumflexbelow",
              7741,
              "lcommaaccent",
              316,
              "ldot",
              320,
              "ldotaccent",
              320,
              "ldotbelow",
              7735,
              "ldotbelowmacron",
              7737,
              "leftangleabovecmb",
              794,
              "lefttackbelowcmb",
              792,
              "less",
              60,
              "lessequal",
              8804,
              "lessequalorgreater",
              8922,
              "lessmonospace",
              65308,
              "lessorequivalent",
              8818,
              "lessorgreater",
              8822,
              "lessoverequal",
              8806,
              "lesssmall",
              65124,
              "lezh",
              622,
              "lfblock",
              9612,
              "lhookretroflex",
              621,
              "lira",
              8356,
              "liwnarmenian",
              1388,
              "lj",
              457,
              "ljecyrillic",
              1113,
              "ll",
              63168,
              "lladeva",
              2355,
              "llagujarati",
              2739,
              "llinebelow",
              7739,
              "llladeva",
              2356,
              "llvocalicbengali",
              2529,
              "llvocalicdeva",
              2401,
              "llvocalicvowelsignbengali",
              2531,
              "llvocalicvowelsigndeva",
              2403,
              "lmiddletilde",
              619,
              "lmonospace",
              65356,
              "lmsquare",
              13264,
              "lochulathai",
              3628,
              "logicaland",
              8743,
              "logicalnot",
              172,
              "logicalnotreversed",
              8976,
              "logicalor",
              8744,
              "lolingthai",
              3621,
              "longs",
              383,
              "lowlinecenterline",
              65102,
              "lowlinecmb",
              818,
              "lowlinedashed",
              65101,
              "lozenge",
              9674,
              "lparen",
              9383,
              "lslash",
              322,
              "lsquare",
              8467,
              "lsuperior",
              63214,
              "ltshade",
              9617,
              "luthai",
              3622,
              "lvocalicbengali",
              2444,
              "lvocalicdeva",
              2316,
              "lvocalicvowelsignbengali",
              2530,
              "lvocalicvowelsigndeva",
              2402,
              "lxsquare",
              13267,
              "m",
              109,
              "mabengali",
              2478,
              "macron",
              175,
              "macronbelowcmb",
              817,
              "macroncmb",
              772,
              "macronlowmod",
              717,
              "macronmonospace",
              65507,
              "macute",
              7743,
              "madeva",
              2350,
              "magujarati",
              2734,
              "magurmukhi",
              2606,
              "mahapakhhebrew",
              1444,
              "mahapakhlefthebrew",
              1444,
              "mahiragana",
              12414,
              "maichattawalowleftthai",
              63637,
              "maichattawalowrightthai",
              63636,
              "maichattawathai",
              3659,
              "maichattawaupperleftthai",
              63635,
              "maieklowleftthai",
              63628,
              "maieklowrightthai",
              63627,
              "maiekthai",
              3656,
              "maiekupperleftthai",
              63626,
              "maihanakatleftthai",
              63620,
              "maihanakatthai",
              3633,
              "maitaikhuleftthai",
              63625,
              "maitaikhuthai",
              3655,
              "maitholowleftthai",
              63631,
              "maitholowrightthai",
              63630,
              "maithothai",
              3657,
              "maithoupperleftthai",
              63629,
              "maitrilowleftthai",
              63634,
              "maitrilowrightthai",
              63633,
              "maitrithai",
              3658,
              "maitriupperleftthai",
              63632,
              "maiyamokthai",
              3654,
              "makatakana",
              12510,
              "makatakanahalfwidth",
              65423,
              "male",
              9794,
              "mansyonsquare",
              13127,
              "maqafhebrew",
              1470,
              "mars",
              9794,
              "masoracirclehebrew",
              1455,
              "masquare",
              13187,
              "mbopomofo",
              12551,
              "mbsquare",
              13268,
              "mcircle",
              9436,
              "mcubedsquare",
              13221,
              "mdotaccent",
              7745,
              "mdotbelow",
              7747,
              "meemarabic",
              1605,
              "meemfinalarabic",
              65250,
              "meeminitialarabic",
              65251,
              "meemmedialarabic",
              65252,
              "meemmeeminitialarabic",
              64721,
              "meemmeemisolatedarabic",
              64584,
              "meetorusquare",
              13133,
              "mehiragana",
              12417,
              "meizierasquare",
              13182,
              "mekatakana",
              12513,
              "mekatakanahalfwidth",
              65426,
              "mem",
              1502,
              "memdagesh",
              64318,
              "memdageshhebrew",
              64318,
              "memhebrew",
              1502,
              "menarmenian",
              1396,
              "merkhahebrew",
              1445,
              "merkhakefulahebrew",
              1446,
              "merkhakefulalefthebrew",
              1446,
              "merkhalefthebrew",
              1445,
              "mhook",
              625,
              "mhzsquare",
              13202,
              "middledotkatakanahalfwidth",
              65381,
              "middot",
              183,
              "mieumacirclekorean",
              12914,
              "mieumaparenkorean",
              12818,
              "mieumcirclekorean",
              12900,
              "mieumkorean",
              12609,
              "mieumpansioskorean",
              12656,
              "mieumparenkorean",
              12804,
              "mieumpieupkorean",
              12654,
              "mieumsioskorean",
              12655,
              "mihiragana",
              12415,
              "mikatakana",
              12511,
              "mikatakanahalfwidth",
              65424,
              "minus",
              8722,
              "minusbelowcmb",
              800,
              "minuscircle",
              8854,
              "minusmod",
              727,
              "minusplus",
              8723,
              "minute",
              8242,
              "miribaarusquare",
              13130,
              "mirisquare",
              13129,
              "mlonglegturned",
              624,
              "mlsquare",
              13206,
              "mmcubedsquare",
              13219,
              "mmonospace",
              65357,
              "mmsquaredsquare",
              13215,
              "mohiragana",
              12418,
              "mohmsquare",
              13249,
              "mokatakana",
              12514,
              "mokatakanahalfwidth",
              65427,
              "molsquare",
              13270,
              "momathai",
              3617,
              "moverssquare",
              13223,
              "moverssquaredsquare",
              13224,
              "mparen",
              9384,
              "mpasquare",
              13227,
              "mssquare",
              13235,
              "msuperior",
              63215,
              "mturned",
              623,
              "mu",
              181,
              "mu1",
              181,
              "muasquare",
              13186,
              "muchgreater",
              8811,
              "muchless",
              8810,
              "mufsquare",
              13196,
              "mugreek",
              956,
              "mugsquare",
              13197,
              "muhiragana",
              12416,
              "mukatakana",
              12512,
              "mukatakanahalfwidth",
              65425,
              "mulsquare",
              13205,
              "multiply",
              215,
              "mumsquare",
              13211,
              "munahhebrew",
              1443,
              "munahlefthebrew",
              1443,
              "musicalnote",
              9834,
              "musicalnotedbl",
              9835,
              "musicflatsign",
              9837,
              "musicsharpsign",
              9839,
              "mussquare",
              13234,
              "muvsquare",
              13238,
              "muwsquare",
              13244,
              "mvmegasquare",
              13241,
              "mvsquare",
              13239,
              "mwmegasquare",
              13247,
              "mwsquare",
              13245,
              "n",
              110,
              "nabengali",
              2472,
              "nabla",
              8711,
              "nacute",
              324,
              "nadeva",
              2344,
              "nagujarati",
              2728,
              "nagurmukhi",
              2600,
              "nahiragana",
              12394,
              "nakatakana",
              12490,
              "nakatakanahalfwidth",
              65413,
              "napostrophe",
              329,
              "nasquare",
              13185,
              "nbopomofo",
              12555,
              "nbspace",
              160,
              "ncaron",
              328,
              "ncedilla",
              326,
              "ncircle",
              9437,
              "ncircumflexbelow",
              7755,
              "ncommaaccent",
              326,
              "ndotaccent",
              7749,
              "ndotbelow",
              7751,
              "nehiragana",
              12397,
              "nekatakana",
              12493,
              "nekatakanahalfwidth",
              65416,
              "newsheqelsign",
              8362,
              "nfsquare",
              13195,
              "ngabengali",
              2457,
              "ngadeva",
              2329,
              "ngagujarati",
              2713,
              "ngagurmukhi",
              2585,
              "ngonguthai",
              3591,
              "nhiragana",
              12435,
              "nhookleft",
              626,
              "nhookretroflex",
              627,
              "nieunacirclekorean",
              12911,
              "nieunaparenkorean",
              12815,
              "nieuncieuckorean",
              12597,
              "nieuncirclekorean",
              12897,
              "nieunhieuhkorean",
              12598,
              "nieunkorean",
              12596,
              "nieunpansioskorean",
              12648,
              "nieunparenkorean",
              12801,
              "nieunsioskorean",
              12647,
              "nieuntikeutkorean",
              12646,
              "nihiragana",
              12395,
              "nikatakana",
              12491,
              "nikatakanahalfwidth",
              65414,
              "nikhahitleftthai",
              63641,
              "nikhahitthai",
              3661,
              "nine",
              57,
              "ninearabic",
              1641,
              "ninebengali",
              2543,
              "ninecircle",
              9320,
              "ninecircleinversesansserif",
              10130,
              "ninedeva",
              2415,
              "ninegujarati",
              2799,
              "ninegurmukhi",
              2671,
              "ninehackarabic",
              1641,
              "ninehangzhou",
              12329,
              "nineideographicparen",
              12840,
              "nineinferior",
              8329,
              "ninemonospace",
              65305,
              "nineoldstyle",
              63289,
              "nineparen",
              9340,
              "nineperiod",
              9360,
              "ninepersian",
              1785,
              "nineroman",
              8568,
              "ninesuperior",
              8313,
              "nineteencircle",
              9330,
              "nineteenparen",
              9350,
              "nineteenperiod",
              9370,
              "ninethai",
              3673,
              "nj",
              460,
              "njecyrillic",
              1114,
              "nkatakana",
              12531,
              "nkatakanahalfwidth",
              65437,
              "nlegrightlong",
              414,
              "nlinebelow",
              7753,
              "nmonospace",
              65358,
              "nmsquare",
              13210,
              "nnabengali",
              2467,
              "nnadeva",
              2339,
              "nnagujarati",
              2723,
              "nnagurmukhi",
              2595,
              "nnnadeva",
              2345,
              "nohiragana",
              12398,
              "nokatakana",
              12494,
              "nokatakanahalfwidth",
              65417,
              "nonbreakingspace",
              160,
              "nonenthai",
              3603,
              "nonuthai",
              3609,
              "noonarabic",
              1606,
              "noonfinalarabic",
              65254,
              "noonghunnaarabic",
              1722,
              "noonghunnafinalarabic",
              64415,
              "nooninitialarabic",
              65255,
              "noonjeeminitialarabic",
              64722,
              "noonjeemisolatedarabic",
              64587,
              "noonmedialarabic",
              65256,
              "noonmeeminitialarabic",
              64725,
              "noonmeemisolatedarabic",
              64590,
              "noonnoonfinalarabic",
              64653,
              "notcontains",
              8716,
              "notelement",
              8713,
              "notelementof",
              8713,
              "notequal",
              8800,
              "notgreater",
              8815,
              "notgreaternorequal",
              8817,
              "notgreaternorless",
              8825,
              "notidentical",
              8802,
              "notless",
              8814,
              "notlessnorequal",
              8816,
              "notparallel",
              8742,
              "notprecedes",
              8832,
              "notsubset",
              8836,
              "notsucceeds",
              8833,
              "notsuperset",
              8837,
              "nowarmenian",
              1398,
              "nparen",
              9385,
              "nssquare",
              13233,
              "nsuperior",
              8319,
              "ntilde",
              241,
              "nu",
              957,
              "nuhiragana",
              12396,
              "nukatakana",
              12492,
              "nukatakanahalfwidth",
              65415,
              "nuktabengali",
              2492,
              "nuktadeva",
              2364,
              "nuktagujarati",
              2748,
              "nuktagurmukhi",
              2620,
              "numbersign",
              35,
              "numbersignmonospace",
              65283,
              "numbersignsmall",
              65119,
              "numeralsigngreek",
              884,
              "numeralsignlowergreek",
              885,
              "numero",
              8470,
              "nun",
              1504,
              "nundagesh",
              64320,
              "nundageshhebrew",
              64320,
              "nunhebrew",
              1504,
              "nvsquare",
              13237,
              "nwsquare",
              13243,
              "nyabengali",
              2462,
              "nyadeva",
              2334,
              "nyagujarati",
              2718,
              "nyagurmukhi",
              2590,
              "o",
              111,
              "oacute",
              243,
              "oangthai",
              3629,
              "obarred",
              629,
              "obarredcyrillic",
              1257,
              "obarreddieresiscyrillic",
              1259,
              "obengali",
              2451,
              "obopomofo",
              12571,
              "obreve",
              335,
              "ocandradeva",
              2321,
              "ocandragujarati",
              2705,
              "ocandravowelsigndeva",
              2377,
              "ocandravowelsigngujarati",
              2761,
              "ocaron",
              466,
              "ocircle",
              9438,
              "ocircumflex",
              244,
              "ocircumflexacute",
              7889,
              "ocircumflexdotbelow",
              7897,
              "ocircumflexgrave",
              7891,
              "ocircumflexhookabove",
              7893,
              "ocircumflextilde",
              7895,
              "ocyrillic",
              1086,
              "odblacute",
              337,
              "odblgrave",
              525,
              "odeva",
              2323,
              "odieresis",
              246,
              "odieresiscyrillic",
              1255,
              "odotbelow",
              7885,
              "oe",
              339,
              "oekorean",
              12634,
              "ogonek",
              731,
              "ogonekcmb",
              808,
              "ograve",
              242,
              "ogujarati",
              2707,
              "oharmenian",
              1413,
              "ohiragana",
              12362,
              "ohookabove",
              7887,
              "ohorn",
              417,
              "ohornacute",
              7899,
              "ohorndotbelow",
              7907,
              "ohorngrave",
              7901,
              "ohornhookabove",
              7903,
              "ohorntilde",
              7905,
              "ohungarumlaut",
              337,
              "oi",
              419,
              "oinvertedbreve",
              527,
              "okatakana",
              12458,
              "okatakanahalfwidth",
              65397,
              "okorean",
              12631,
              "olehebrew",
              1451,
              "omacron",
              333,
              "omacronacute",
              7763,
              "omacrongrave",
              7761,
              "omdeva",
              2384,
              "omega",
              969,
              "omega1",
              982,
              "omegacyrillic",
              1121,
              "omegalatinclosed",
              631,
              "omegaroundcyrillic",
              1147,
              "omegatitlocyrillic",
              1149,
              "omegatonos",
              974,
              "omgujarati",
              2768,
              "omicron",
              959,
              "omicrontonos",
              972,
              "omonospace",
              65359,
              "one",
              49,
              "onearabic",
              1633,
              "onebengali",
              2535,
              "onecircle",
              9312,
              "onecircleinversesansserif",
              10122,
              "onedeva",
              2407,
              "onedotenleader",
              8228,
              "oneeighth",
              8539,
              "onefitted",
              63196,
              "onegujarati",
              2791,
              "onegurmukhi",
              2663,
              "onehackarabic",
              1633,
              "onehalf",
              189,
              "onehangzhou",
              12321,
              "oneideographicparen",
              12832,
              "oneinferior",
              8321,
              "onemonospace",
              65297,
              "onenumeratorbengali",
              2548,
              "oneoldstyle",
              63281,
              "oneparen",
              9332,
              "oneperiod",
              9352,
              "onepersian",
              1777,
              "onequarter",
              188,
              "oneroman",
              8560,
              "onesuperior",
              185,
              "onethai",
              3665,
              "onethird",
              8531,
              "oogonek",
              491,
              "oogonekmacron",
              493,
              "oogurmukhi",
              2579,
              "oomatragurmukhi",
              2635,
              "oopen",
              596,
              "oparen",
              9386,
              "openbullet",
              9702,
              "option",
              8997,
              "ordfeminine",
              170,
              "ordmasculine",
              186,
              "orthogonal",
              8735,
              "oshortdeva",
              2322,
              "oshortvowelsigndeva",
              2378,
              "oslash",
              248,
              "oslashacute",
              511,
              "osmallhiragana",
              12361,
              "osmallkatakana",
              12457,
              "osmallkatakanahalfwidth",
              65387,
              "ostrokeacute",
              511,
              "osuperior",
              63216,
              "otcyrillic",
              1151,
              "otilde",
              245,
              "otildeacute",
              7757,
              "otildedieresis",
              7759,
              "oubopomofo",
              12577,
              "overline",
              8254,
              "overlinecenterline",
              65098,
              "overlinecmb",
              773,
              "overlinedashed",
              65097,
              "overlinedblwavy",
              65100,
              "overlinewavy",
              65099,
              "overscore",
              175,
              "ovowelsignbengali",
              2507,
              "ovowelsigndeva",
              2379,
              "ovowelsigngujarati",
              2763,
              "p",
              112,
              "paampssquare",
              13184,
              "paasentosquare",
              13099,
              "pabengali",
              2474,
              "pacute",
              7765,
              "padeva",
              2346,
              "pagedown",
              8671,
              "pageup",
              8670,
              "pagujarati",
              2730,
              "pagurmukhi",
              2602,
              "pahiragana",
              12401,
              "paiyannoithai",
              3631,
              "pakatakana",
              12497,
              "palatalizationcyrilliccmb",
              1156,
              "palochkacyrillic",
              1216,
              "pansioskorean",
              12671,
              "paragraph",
              182,
              "parallel",
              8741,
              "parenleft",
              40,
              "parenleftaltonearabic",
              64830,
              "parenleftbt",
              63725,
              "parenleftex",
              63724,
              "parenleftinferior",
              8333,
              "parenleftmonospace",
              65288,
              "parenleftsmall",
              65113,
              "parenleftsuperior",
              8317,
              "parenlefttp",
              63723,
              "parenleftvertical",
              65077,
              "parenright",
              41,
              "parenrightaltonearabic",
              64831,
              "parenrightbt",
              63736,
              "parenrightex",
              63735,
              "parenrightinferior",
              8334,
              "parenrightmonospace",
              65289,
              "parenrightsmall",
              65114,
              "parenrightsuperior",
              8318,
              "parenrighttp",
              63734,
              "parenrightvertical",
              65078,
              "partialdiff",
              8706,
              "paseqhebrew",
              1472,
              "pashtahebrew",
              1433,
              "pasquare",
              13225,
              "patah",
              1463,
              "patah11",
              1463,
              "patah1d",
              1463,
              "patah2a",
              1463,
              "patahhebrew",
              1463,
              "patahnarrowhebrew",
              1463,
              "patahquarterhebrew",
              1463,
              "patahwidehebrew",
              1463,
              "pazerhebrew",
              1441,
              "pbopomofo",
              12550,
              "pcircle",
              9439,
              "pdotaccent",
              7767,
              "pe",
              1508,
              "pecyrillic",
              1087,
              "pedagesh",
              64324,
              "pedageshhebrew",
              64324,
              "peezisquare",
              13115,
              "pefinaldageshhebrew",
              64323,
              "peharabic",
              1662,
              "peharmenian",
              1402,
              "pehebrew",
              1508,
              "pehfinalarabic",
              64343,
              "pehinitialarabic",
              64344,
              "pehiragana",
              12410,
              "pehmedialarabic",
              64345,
              "pekatakana",
              12506,
              "pemiddlehookcyrillic",
              1191,
              "perafehebrew",
              64334,
              "percent",
              37,
              "percentarabic",
              1642,
              "percentmonospace",
              65285,
              "percentsmall",
              65130,
              "period",
              46,
              "periodarmenian",
              1417,
              "periodcentered",
              183,
              "periodhalfwidth",
              65377,
              "periodinferior",
              63207,
              "periodmonospace",
              65294,
              "periodsmall",
              65106,
              "periodsuperior",
              63208,
              "perispomenigreekcmb",
              834,
              "perpendicular",
              8869,
              "perthousand",
              8240,
              "peseta",
              8359,
              "pfsquare",
              13194,
              "phabengali",
              2475,
              "phadeva",
              2347,
              "phagujarati",
              2731,
              "phagurmukhi",
              2603,
              "phi",
              966,
              "phi1",
              981,
              "phieuphacirclekorean",
              12922,
              "phieuphaparenkorean",
              12826,
              "phieuphcirclekorean",
              12908,
              "phieuphkorean",
              12621,
              "phieuphparenkorean",
              12812,
              "philatin",
              632,
              "phinthuthai",
              3642,
              "phisymbolgreek",
              981,
              "phook",
              421,
              "phophanthai",
              3614,
              "phophungthai",
              3612,
              "phosamphaothai",
              3616,
              "pi",
              960,
              "pieupacirclekorean",
              12915,
              "pieupaparenkorean",
              12819,
              "pieupcieuckorean",
              12662,
              "pieupcirclekorean",
              12901,
              "pieupkiyeokkorean",
              12658,
              "pieupkorean",
              12610,
              "pieupparenkorean",
              12805,
              "pieupsioskiyeokkorean",
              12660,
              "pieupsioskorean",
              12612,
              "pieupsiostikeutkorean",
              12661,
              "pieupthieuthkorean",
              12663,
              "pieuptikeutkorean",
              12659,
              "pihiragana",
              12404,
              "pikatakana",
              12500,
              "pisymbolgreek",
              982,
              "piwrarmenian",
              1411,
              "plus",
              43,
              "plusbelowcmb",
              799,
              "pluscircle",
              8853,
              "plusminus",
              177,
              "plusmod",
              726,
              "plusmonospace",
              65291,
              "plussmall",
              65122,
              "plussuperior",
              8314,
              "pmonospace",
              65360,
              "pmsquare",
              13272,
              "pohiragana",
              12413,
              "pointingindexdownwhite",
              9759,
              "pointingindexleftwhite",
              9756,
              "pointingindexrightwhite",
              9758,
              "pointingindexupwhite",
              9757,
              "pokatakana",
              12509,
              "poplathai",
              3611,
              "postalmark",
              12306,
              "postalmarkface",
              12320,
              "pparen",
              9387,
              "precedes",
              8826,
              "prescription",
              8478,
              "primemod",
              697,
              "primereversed",
              8245,
              "product",
              8719,
              "projective",
              8965,
              "prolongedkana",
              12540,
              "propellor",
              8984,
              "propersubset",
              8834,
              "propersuperset",
              8835,
              "proportion",
              8759,
              "proportional",
              8733,
              "psi",
              968,
              "psicyrillic",
              1137,
              "psilipneumatacyrilliccmb",
              1158,
              "pssquare",
              13232,
              "puhiragana",
              12407,
              "pukatakana",
              12503,
              "pvsquare",
              13236,
              "pwsquare",
              13242,
              "q",
              113,
              "qadeva",
              2392,
              "qadmahebrew",
              1448,
              "qafarabic",
              1602,
              "qaffinalarabic",
              65238,
              "qafinitialarabic",
              65239,
              "qafmedialarabic",
              65240,
              "qamats",
              1464,
              "qamats10",
              1464,
              "qamats1a",
              1464,
              "qamats1c",
              1464,
              "qamats27",
              1464,
              "qamats29",
              1464,
              "qamats33",
              1464,
              "qamatsde",
              1464,
              "qamatshebrew",
              1464,
              "qamatsnarrowhebrew",
              1464,
              "qamatsqatanhebrew",
              1464,
              "qamatsqatannarrowhebrew",
              1464,
              "qamatsqatanquarterhebrew",
              1464,
              "qamatsqatanwidehebrew",
              1464,
              "qamatsquarterhebrew",
              1464,
              "qamatswidehebrew",
              1464,
              "qarneyparahebrew",
              1439,
              "qbopomofo",
              12561,
              "qcircle",
              9440,
              "qhook",
              672,
              "qmonospace",
              65361,
              "qof",
              1511,
              "qofdagesh",
              64327,
              "qofdageshhebrew",
              64327,
              "qofhebrew",
              1511,
              "qparen",
              9388,
              "quarternote",
              9833,
              "qubuts",
              1467,
              "qubuts18",
              1467,
              "qubuts25",
              1467,
              "qubuts31",
              1467,
              "qubutshebrew",
              1467,
              "qubutsnarrowhebrew",
              1467,
              "qubutsquarterhebrew",
              1467,
              "qubutswidehebrew",
              1467,
              "question",
              63,
              "questionarabic",
              1567,
              "questionarmenian",
              1374,
              "questiondown",
              191,
              "questiondownsmall",
              63423,
              "questiongreek",
              894,
              "questionmonospace",
              65311,
              "questionsmall",
              63295,
              "quotedbl",
              34,
              "quotedblbase",
              8222,
              "quotedblleft",
              8220,
              "quotedblmonospace",
              65282,
              "quotedblprime",
              12318,
              "quotedblprimereversed",
              12317,
              "quotedblright",
              8221,
              "quoteleft",
              8216,
              "quoteleftreversed",
              8219,
              "quotereversed",
              8219,
              "quoteright",
              8217,
              "quoterightn",
              329,
              "quotesinglbase",
              8218,
              "quotesingle",
              39,
              "quotesinglemonospace",
              65287,
              "r",
              114,
              "raarmenian",
              1404,
              "rabengali",
              2480,
              "racute",
              341,
              "radeva",
              2352,
              "radical",
              8730,
              "radicalex",
              63717,
              "radoverssquare",
              13230,
              "radoverssquaredsquare",
              13231,
              "radsquare",
              13229,
              "rafe",
              1471,
              "rafehebrew",
              1471,
              "ragujarati",
              2736,
              "ragurmukhi",
              2608,
              "rahiragana",
              12425,
              "rakatakana",
              12521,
              "rakatakanahalfwidth",
              65431,
              "ralowerdiagonalbengali",
              2545,
              "ramiddlediagonalbengali",
              2544,
              "ramshorn",
              612,
              "ratio",
              8758,
              "rbopomofo",
              12566,
              "rcaron",
              345,
              "rcedilla",
              343,
              "rcircle",
              9441,
              "rcommaaccent",
              343,
              "rdblgrave",
              529,
              "rdotaccent",
              7769,
              "rdotbelow",
              7771,
              "rdotbelowmacron",
              7773,
              "referencemark",
              8251,
              "reflexsubset",
              8838,
              "reflexsuperset",
              8839,
              "registered",
              174,
              "registersans",
              63720,
              "registerserif",
              63194,
              "reharabic",
              1585,
              "reharmenian",
              1408,
              "rehfinalarabic",
              65198,
              "rehiragana",
              12428,
              "rekatakana",
              12524,
              "rekatakanahalfwidth",
              65434,
              "resh",
              1512,
              "reshdageshhebrew",
              64328,
              "reshhebrew",
              1512,
              "reversedtilde",
              8765,
              "reviahebrew",
              1431,
              "reviamugrashhebrew",
              1431,
              "revlogicalnot",
              8976,
              "rfishhook",
              638,
              "rfishhookreversed",
              639,
              "rhabengali",
              2525,
              "rhadeva",
              2397,
              "rho",
              961,
              "rhook",
              637,
              "rhookturned",
              635,
              "rhookturnedsuperior",
              693,
              "rhosymbolgreek",
              1009,
              "rhotichookmod",
              734,
              "rieulacirclekorean",
              12913,
              "rieulaparenkorean",
              12817,
              "rieulcirclekorean",
              12899,
              "rieulhieuhkorean",
              12608,
              "rieulkiyeokkorean",
              12602,
              "rieulkiyeoksioskorean",
              12649,
              "rieulkorean",
              12601,
              "rieulmieumkorean",
              12603,
              "rieulpansioskorean",
              12652,
              "rieulparenkorean",
              12803,
              "rieulphieuphkorean",
              12607,
              "rieulpieupkorean",
              12604,
              "rieulpieupsioskorean",
              12651,
              "rieulsioskorean",
              12605,
              "rieulthieuthkorean",
              12606,
              "rieultikeutkorean",
              12650,
              "rieulyeorinhieuhkorean",
              12653,
              "rightangle",
              8735,
              "righttackbelowcmb",
              793,
              "righttriangle",
              8895,
              "rihiragana",
              12426,
              "rikatakana",
              12522,
              "rikatakanahalfwidth",
              65432,
              "ring",
              730,
              "ringbelowcmb",
              805,
              "ringcmb",
              778,
              "ringhalfleft",
              703,
              "ringhalfleftarmenian",
              1369,
              "ringhalfleftbelowcmb",
              796,
              "ringhalfleftcentered",
              723,
              "ringhalfright",
              702,
              "ringhalfrightbelowcmb",
              825,
              "ringhalfrightcentered",
              722,
              "rinvertedbreve",
              531,
              "rittorusquare",
              13137,
              "rlinebelow",
              7775,
              "rlongleg",
              636,
              "rlonglegturned",
              634,
              "rmonospace",
              65362,
              "rohiragana",
              12429,
              "rokatakana",
              12525,
              "rokatakanahalfwidth",
              65435,
              "roruathai",
              3619,
              "rparen",
              9389,
              "rrabengali",
              2524,
              "rradeva",
              2353,
              "rragurmukhi",
              2652,
              "rreharabic",
              1681,
              "rrehfinalarabic",
              64397,
              "rrvocalicbengali",
              2528,
              "rrvocalicdeva",
              2400,
              "rrvocalicgujarati",
              2784,
              "rrvocalicvowelsignbengali",
              2500,
              "rrvocalicvowelsigndeva",
              2372,
              "rrvocalicvowelsigngujarati",
              2756,
              "rsuperior",
              63217,
              "rtblock",
              9616,
              "rturned",
              633,
              "rturnedsuperior",
              692,
              "ruhiragana",
              12427,
              "rukatakana",
              12523,
              "rukatakanahalfwidth",
              65433,
              "rupeemarkbengali",
              2546,
              "rupeesignbengali",
              2547,
              "rupiah",
              63197,
              "ruthai",
              3620,
              "rvocalicbengali",
              2443,
              "rvocalicdeva",
              2315,
              "rvocalicgujarati",
              2699,
              "rvocalicvowelsignbengali",
              2499,
              "rvocalicvowelsigndeva",
              2371,
              "rvocalicvowelsigngujarati",
              2755,
              "s",
              115,
              "sabengali",
              2488,
              "sacute",
              347,
              "sacutedotaccent",
              7781,
              "sadarabic",
              1589,
              "sadeva",
              2360,
              "sadfinalarabic",
              65210,
              "sadinitialarabic",
              65211,
              "sadmedialarabic",
              65212,
              "sagujarati",
              2744,
              "sagurmukhi",
              2616,
              "sahiragana",
              12373,
              "sakatakana",
              12469,
              "sakatakanahalfwidth",
              65403,
              "sallallahoualayhewasallamarabic",
              65018,
              "samekh",
              1505,
              "samekhdagesh",
              64321,
              "samekhdageshhebrew",
              64321,
              "samekhhebrew",
              1505,
              "saraaathai",
              3634,
              "saraaethai",
              3649,
              "saraaimaimalaithai",
              3652,
              "saraaimaimuanthai",
              3651,
              "saraamthai",
              3635,
              "saraathai",
              3632,
              "saraethai",
              3648,
              "saraiileftthai",
              63622,
              "saraiithai",
              3637,
              "saraileftthai",
              63621,
              "saraithai",
              3636,
              "saraothai",
              3650,
              "saraueeleftthai",
              63624,
              "saraueethai",
              3639,
              "saraueleftthai",
              63623,
              "sarauethai",
              3638,
              "sarauthai",
              3640,
              "sarauuthai",
              3641,
              "sbopomofo",
              12569,
              "scaron",
              353,
              "scarondotaccent",
              7783,
              "scedilla",
              351,
              "schwa",
              601,
              "schwacyrillic",
              1241,
              "schwadieresiscyrillic",
              1243,
              "schwahook",
              602,
              "scircle",
              9442,
              "scircumflex",
              349,
              "scommaaccent",
              537,
              "sdotaccent",
              7777,
              "sdotbelow",
              7779,
              "sdotbelowdotaccent",
              7785,
              "seagullbelowcmb",
              828,
              "second",
              8243,
              "secondtonechinese",
              714,
              "section",
              167,
              "seenarabic",
              1587,
              "seenfinalarabic",
              65202,
              "seeninitialarabic",
              65203,
              "seenmedialarabic",
              65204,
              "segol",
              1462,
              "segol13",
              1462,
              "segol1f",
              1462,
              "segol2c",
              1462,
              "segolhebrew",
              1462,
              "segolnarrowhebrew",
              1462,
              "segolquarterhebrew",
              1462,
              "segoltahebrew",
              1426,
              "segolwidehebrew",
              1462,
              "seharmenian",
              1405,
              "sehiragana",
              12379,
              "sekatakana",
              12475,
              "sekatakanahalfwidth",
              65406,
              "semicolon",
              59,
              "semicolonarabic",
              1563,
              "semicolonmonospace",
              65307,
              "semicolonsmall",
              65108,
              "semivoicedmarkkana",
              12444,
              "semivoicedmarkkanahalfwidth",
              65439,
              "sentisquare",
              13090,
              "sentosquare",
              13091,
              "seven",
              55,
              "sevenarabic",
              1639,
              "sevenbengali",
              2541,
              "sevencircle",
              9318,
              "sevencircleinversesansserif",
              10128,
              "sevendeva",
              2413,
              "seveneighths",
              8542,
              "sevengujarati",
              2797,
              "sevengurmukhi",
              2669,
              "sevenhackarabic",
              1639,
              "sevenhangzhou",
              12327,
              "sevenideographicparen",
              12838,
              "seveninferior",
              8327,
              "sevenmonospace",
              65303,
              "sevenoldstyle",
              63287,
              "sevenparen",
              9338,
              "sevenperiod",
              9358,
              "sevenpersian",
              1783,
              "sevenroman",
              8566,
              "sevensuperior",
              8311,
              "seventeencircle",
              9328,
              "seventeenparen",
              9348,
              "seventeenperiod",
              9368,
              "seventhai",
              3671,
              "sfthyphen",
              173,
              "shaarmenian",
              1399,
              "shabengali",
              2486,
              "shacyrillic",
              1096,
              "shaddaarabic",
              1617,
              "shaddadammaarabic",
              64609,
              "shaddadammatanarabic",
              64606,
              "shaddafathaarabic",
              64608,
              "shaddakasraarabic",
              64610,
              "shaddakasratanarabic",
              64607,
              "shade",
              9618,
              "shadedark",
              9619,
              "shadelight",
              9617,
              "shademedium",
              9618,
              "shadeva",
              2358,
              "shagujarati",
              2742,
              "shagurmukhi",
              2614,
              "shalshelethebrew",
              1427,
              "shbopomofo",
              12565,
              "shchacyrillic",
              1097,
              "sheenarabic",
              1588,
              "sheenfinalarabic",
              65206,
              "sheeninitialarabic",
              65207,
              "sheenmedialarabic",
              65208,
              "sheicoptic",
              995,
              "sheqel",
              8362,
              "sheqelhebrew",
              8362,
              "sheva",
              1456,
              "sheva115",
              1456,
              "sheva15",
              1456,
              "sheva22",
              1456,
              "sheva2e",
              1456,
              "shevahebrew",
              1456,
              "shevanarrowhebrew",
              1456,
              "shevaquarterhebrew",
              1456,
              "shevawidehebrew",
              1456,
              "shhacyrillic",
              1211,
              "shimacoptic",
              1005,
              "shin",
              1513,
              "shindagesh",
              64329,
              "shindageshhebrew",
              64329,
              "shindageshshindot",
              64300,
              "shindageshshindothebrew",
              64300,
              "shindageshsindot",
              64301,
              "shindageshsindothebrew",
              64301,
              "shindothebrew",
              1473,
              "shinhebrew",
              1513,
              "shinshindot",
              64298,
              "shinshindothebrew",
              64298,
              "shinsindot",
              64299,
              "shinsindothebrew",
              64299,
              "shook",
              642,
              "sigma",
              963,
              "sigma1",
              962,
              "sigmafinal",
              962,
              "sigmalunatesymbolgreek",
              1010,
              "sihiragana",
              12375,
              "sikatakana",
              12471,
              "sikatakanahalfwidth",
              65404,
              "siluqhebrew",
              1469,
              "siluqlefthebrew",
              1469,
              "similar",
              8764,
              "sindothebrew",
              1474,
              "siosacirclekorean",
              12916,
              "siosaparenkorean",
              12820,
              "sioscieuckorean",
              12670,
              "sioscirclekorean",
              12902,
              "sioskiyeokkorean",
              12666,
              "sioskorean",
              12613,
              "siosnieunkorean",
              12667,
              "siosparenkorean",
              12806,
              "siospieupkorean",
              12669,
              "siostikeutkorean",
              12668,
              "six",
              54,
              "sixarabic",
              1638,
              "sixbengali",
              2540,
              "sixcircle",
              9317,
              "sixcircleinversesansserif",
              10127,
              "sixdeva",
              2412,
              "sixgujarati",
              2796,
              "sixgurmukhi",
              2668,
              "sixhackarabic",
              1638,
              "sixhangzhou",
              12326,
              "sixideographicparen",
              12837,
              "sixinferior",
              8326,
              "sixmonospace",
              65302,
              "sixoldstyle",
              63286,
              "sixparen",
              9337,
              "sixperiod",
              9357,
              "sixpersian",
              1782,
              "sixroman",
              8565,
              "sixsuperior",
              8310,
              "sixteencircle",
              9327,
              "sixteencurrencydenominatorbengali",
              2553,
              "sixteenparen",
              9347,
              "sixteenperiod",
              9367,
              "sixthai",
              3670,
              "slash",
              47,
              "slashmonospace",
              65295,
              "slong",
              383,
              "slongdotaccent",
              7835,
              "smileface",
              9786,
              "smonospace",
              65363,
              "sofpasuqhebrew",
              1475,
              "softhyphen",
              173,
              "softsigncyrillic",
              1100,
              "sohiragana",
              12381,
              "sokatakana",
              12477,
              "sokatakanahalfwidth",
              65407,
              "soliduslongoverlaycmb",
              824,
              "solidusshortoverlaycmb",
              823,
              "sorusithai",
              3625,
              "sosalathai",
              3624,
              "sosothai",
              3595,
              "sosuathai",
              3626,
              "space",
              32,
              "spacehackarabic",
              32,
              "spade",
              9824,
              "spadesuitblack",
              9824,
              "spadesuitwhite",
              9828,
              "sparen",
              9390,
              "squarebelowcmb",
              827,
              "squarecc",
              13252,
              "squarecm",
              13213,
              "squarediagonalcrosshatchfill",
              9641,
              "squarehorizontalfill",
              9636,
              "squarekg",
              13199,
              "squarekm",
              13214,
              "squarekmcapital",
              13262,
              "squareln",
              13265,
              "squarelog",
              13266,
              "squaremg",
              13198,
              "squaremil",
              13269,
              "squaremm",
              13212,
              "squaremsquared",
              13217,
              "squareorthogonalcrosshatchfill",
              9638,
              "squareupperlefttolowerrightfill",
              9639,
              "squareupperrighttolowerleftfill",
              9640,
              "squareverticalfill",
              9637,
              "squarewhitewithsmallblack",
              9635,
              "srsquare",
              13275,
              "ssabengali",
              2487,
              "ssadeva",
              2359,
              "ssagujarati",
              2743,
              "ssangcieuckorean",
              12617,
              "ssanghieuhkorean",
              12677,
              "ssangieungkorean",
              12672,
              "ssangkiyeokkorean",
              12594,
              "ssangnieunkorean",
              12645,
              "ssangpieupkorean",
              12611,
              "ssangsioskorean",
              12614,
              "ssangtikeutkorean",
              12600,
              "ssuperior",
              63218,
              "sterling",
              163,
              "sterlingmonospace",
              65505,
              "strokelongoverlaycmb",
              822,
              "strokeshortoverlaycmb",
              821,
              "subset",
              8834,
              "subsetnotequal",
              8842,
              "subsetorequal",
              8838,
              "succeeds",
              8827,
              "suchthat",
              8715,
              "suhiragana",
              12377,
              "sukatakana",
              12473,
              "sukatakanahalfwidth",
              65405,
              "sukunarabic",
              1618,
              "summation",
              8721,
              "sun",
              9788,
              "superset",
              8835,
              "supersetnotequal",
              8843,
              "supersetorequal",
              8839,
              "svsquare",
              13276,
              "syouwaerasquare",
              13180,
              "t",
              116,
              "tabengali",
              2468,
              "tackdown",
              8868,
              "tackleft",
              8867,
              "tadeva",
              2340,
              "tagujarati",
              2724,
              "tagurmukhi",
              2596,
              "taharabic",
              1591,
              "tahfinalarabic",
              65218,
              "tahinitialarabic",
              65219,
              "tahiragana",
              12383,
              "tahmedialarabic",
              65220,
              "taisyouerasquare",
              13181,
              "takatakana",
              12479,
              "takatakanahalfwidth",
              65408,
              "tatweelarabic",
              1600,
              "tau",
              964,
              "tav",
              1514,
              "tavdages",
              64330,
              "tavdagesh",
              64330,
              "tavdageshhebrew",
              64330,
              "tavhebrew",
              1514,
              "tbar",
              359,
              "tbopomofo",
              12554,
              "tcaron",
              357,
              "tccurl",
              680,
              "tcedilla",
              355,
              "tcheharabic",
              1670,
              "tchehfinalarabic",
              64379,
              "tchehinitialarabic",
              64380,
              "tchehmedialarabic",
              64381,
              "tcircle",
              9443,
              "tcircumflexbelow",
              7793,
              "tcommaaccent",
              355,
              "tdieresis",
              7831,
              "tdotaccent",
              7787,
              "tdotbelow",
              7789,
              "tecyrillic",
              1090,
              "tedescendercyrillic",
              1197,
              "teharabic",
              1578,
              "tehfinalarabic",
              65174,
              "tehhahinitialarabic",
              64674,
              "tehhahisolatedarabic",
              64524,
              "tehinitialarabic",
              65175,
              "tehiragana",
              12390,
              "tehjeeminitialarabic",
              64673,
              "tehjeemisolatedarabic",
              64523,
              "tehmarbutaarabic",
              1577,
              "tehmarbutafinalarabic",
              65172,
              "tehmedialarabic",
              65176,
              "tehmeeminitialarabic",
              64676,
              "tehmeemisolatedarabic",
              64526,
              "tehnoonfinalarabic",
              64627,
              "tekatakana",
              12486,
              "tekatakanahalfwidth",
              65411,
              "telephone",
              8481,
              "telephoneblack",
              9742,
              "telishagedolahebrew",
              1440,
              "telishaqetanahebrew",
              1449,
              "tencircle",
              9321,
              "tenideographicparen",
              12841,
              "tenparen",
              9341,
              "tenperiod",
              9361,
              "tenroman",
              8569,
              "tesh",
              679,
              "tet",
              1496,
              "tetdagesh",
              64312,
              "tetdageshhebrew",
              64312,
              "tethebrew",
              1496,
              "tetsecyrillic",
              1205,
              "tevirhebrew",
              1435,
              "tevirlefthebrew",
              1435,
              "thabengali",
              2469,
              "thadeva",
              2341,
              "thagujarati",
              2725,
              "thagurmukhi",
              2597,
              "thalarabic",
              1584,
              "thalfinalarabic",
              65196,
              "thanthakhatlowleftthai",
              63640,
              "thanthakhatlowrightthai",
              63639,
              "thanthakhatthai",
              3660,
              "thanthakhatupperleftthai",
              63638,
              "theharabic",
              1579,
              "thehfinalarabic",
              65178,
              "thehinitialarabic",
              65179,
              "thehmedialarabic",
              65180,
              "thereexists",
              8707,
              "therefore",
              8756,
              "theta",
              952,
              "theta1",
              977,
              "thetasymbolgreek",
              977,
              "thieuthacirclekorean",
              12921,
              "thieuthaparenkorean",
              12825,
              "thieuthcirclekorean",
              12907,
              "thieuthkorean",
              12620,
              "thieuthparenkorean",
              12811,
              "thirteencircle",
              9324,
              "thirteenparen",
              9344,
              "thirteenperiod",
              9364,
              "thonangmonthothai",
              3601,
              "thook",
              429,
              "thophuthaothai",
              3602,
              "thorn",
              254,
              "thothahanthai",
              3607,
              "thothanthai",
              3600,
              "thothongthai",
              3608,
              "thothungthai",
              3606,
              "thousandcyrillic",
              1154,
              "thousandsseparatorarabic",
              1644,
              "thousandsseparatorpersian",
              1644,
              "three",
              51,
              "threearabic",
              1635,
              "threebengali",
              2537,
              "threecircle",
              9314,
              "threecircleinversesansserif",
              10124,
              "threedeva",
              2409,
              "threeeighths",
              8540,
              "threegujarati",
              2793,
              "threegurmukhi",
              2665,
              "threehackarabic",
              1635,
              "threehangzhou",
              12323,
              "threeideographicparen",
              12834,
              "threeinferior",
              8323,
              "threemonospace",
              65299,
              "threenumeratorbengali",
              2550,
              "threeoldstyle",
              63283,
              "threeparen",
              9334,
              "threeperiod",
              9354,
              "threepersian",
              1779,
              "threequarters",
              190,
              "threequartersemdash",
              63198,
              "threeroman",
              8562,
              "threesuperior",
              179,
              "threethai",
              3667,
              "thzsquare",
              13204,
              "tihiragana",
              12385,
              "tikatakana",
              12481,
              "tikatakanahalfwidth",
              65409,
              "tikeutacirclekorean",
              12912,
              "tikeutaparenkorean",
              12816,
              "tikeutcirclekorean",
              12898,
              "tikeutkorean",
              12599,
              "tikeutparenkorean",
              12802,
              "tilde",
              732,
              "tildebelowcmb",
              816,
              "tildecmb",
              771,
              "tildecomb",
              771,
              "tildedoublecmb",
              864,
              "tildeoperator",
              8764,
              "tildeoverlaycmb",
              820,
              "tildeverticalcmb",
              830,
              "timescircle",
              8855,
              "tipehahebrew",
              1430,
              "tipehalefthebrew",
              1430,
              "tippigurmukhi",
              2672,
              "titlocyrilliccmb",
              1155,
              "tiwnarmenian",
              1407,
              "tlinebelow",
              7791,
              "tmonospace",
              65364,
              "toarmenian",
              1385,
              "tohiragana",
              12392,
              "tokatakana",
              12488,
              "tokatakanahalfwidth",
              65412,
              "tonebarextrahighmod",
              741,
              "tonebarextralowmod",
              745,
              "tonebarhighmod",
              742,
              "tonebarlowmod",
              744,
              "tonebarmidmod",
              743,
              "tonefive",
              445,
              "tonesix",
              389,
              "tonetwo",
              424,
              "tonos",
              900,
              "tonsquare",
              13095,
              "topatakthai",
              3599,
              "tortoiseshellbracketleft",
              12308,
              "tortoiseshellbracketleftsmall",
              65117,
              "tortoiseshellbracketleftvertical",
              65081,
              "tortoiseshellbracketright",
              12309,
              "tortoiseshellbracketrightsmall",
              65118,
              "tortoiseshellbracketrightvertical",
              65082,
              "totaothai",
              3605,
              "tpalatalhook",
              427,
              "tparen",
              9391,
              "trademark",
              8482,
              "trademarksans",
              63722,
              "trademarkserif",
              63195,
              "tretroflexhook",
              648,
              "triagdn",
              9660,
              "triaglf",
              9668,
              "triagrt",
              9658,
              "triagup",
              9650,
              "ts",
              678,
              "tsadi",
              1510,
              "tsadidagesh",
              64326,
              "tsadidageshhebrew",
              64326,
              "tsadihebrew",
              1510,
              "tsecyrillic",
              1094,
              "tsere",
              1461,
              "tsere12",
              1461,
              "tsere1e",
              1461,
              "tsere2b",
              1461,
              "tserehebrew",
              1461,
              "tserenarrowhebrew",
              1461,
              "tserequarterhebrew",
              1461,
              "tserewidehebrew",
              1461,
              "tshecyrillic",
              1115,
              "tsuperior",
              63219,
              "ttabengali",
              2463,
              "ttadeva",
              2335,
              "ttagujarati",
              2719,
              "ttagurmukhi",
              2591,
              "tteharabic",
              1657,
              "ttehfinalarabic",
              64359,
              "ttehinitialarabic",
              64360,
              "ttehmedialarabic",
              64361,
              "tthabengali",
              2464,
              "tthadeva",
              2336,
              "tthagujarati",
              2720,
              "tthagurmukhi",
              2592,
              "tturned",
              647,
              "tuhiragana",
              12388,
              "tukatakana",
              12484,
              "tukatakanahalfwidth",
              65410,
              "tusmallhiragana",
              12387,
              "tusmallkatakana",
              12483,
              "tusmallkatakanahalfwidth",
              65391,
              "twelvecircle",
              9323,
              "twelveparen",
              9343,
              "twelveperiod",
              9363,
              "twelveroman",
              8571,
              "twentycircle",
              9331,
              "twentyhangzhou",
              21316,
              "twentyparen",
              9351,
              "twentyperiod",
              9371,
              "two",
              50,
              "twoarabic",
              1634,
              "twobengali",
              2536,
              "twocircle",
              9313,
              "twocircleinversesansserif",
              10123,
              "twodeva",
              2408,
              "twodotenleader",
              8229,
              "twodotleader",
              8229,
              "twodotleadervertical",
              65072,
              "twogujarati",
              2792,
              "twogurmukhi",
              2664,
              "twohackarabic",
              1634,
              "twohangzhou",
              12322,
              "twoideographicparen",
              12833,
              "twoinferior",
              8322,
              "twomonospace",
              65298,
              "twonumeratorbengali",
              2549,
              "twooldstyle",
              63282,
              "twoparen",
              9333,
              "twoperiod",
              9353,
              "twopersian",
              1778,
              "tworoman",
              8561,
              "twostroke",
              443,
              "twosuperior",
              178,
              "twothai",
              3666,
              "twothirds",
              8532,
              "u",
              117,
              "uacute",
              250,
              "ubar",
              649,
              "ubengali",
              2441,
              "ubopomofo",
              12584,
              "ubreve",
              365,
              "ucaron",
              468,
              "ucircle",
              9444,
              "ucircumflex",
              251,
              "ucircumflexbelow",
              7799,
              "ucyrillic",
              1091,
              "udattadeva",
              2385,
              "udblacute",
              369,
              "udblgrave",
              533,
              "udeva",
              2313,
              "udieresis",
              252,
              "udieresisacute",
              472,
              "udieresisbelow",
              7795,
              "udieresiscaron",
              474,
              "udieresiscyrillic",
              1265,
              "udieresisgrave",
              476,
              "udieresismacron",
              470,
              "udotbelow",
              7909,
              "ugrave",
              249,
              "ugujarati",
              2697,
              "ugurmukhi",
              2569,
              "uhiragana",
              12358,
              "uhookabove",
              7911,
              "uhorn",
              432,
              "uhornacute",
              7913,
              "uhorndotbelow",
              7921,
              "uhorngrave",
              7915,
              "uhornhookabove",
              7917,
              "uhorntilde",
              7919,
              "uhungarumlaut",
              369,
              "uhungarumlautcyrillic",
              1267,
              "uinvertedbreve",
              535,
              "ukatakana",
              12454,
              "ukatakanahalfwidth",
              65395,
              "ukcyrillic",
              1145,
              "ukorean",
              12636,
              "umacron",
              363,
              "umacroncyrillic",
              1263,
              "umacrondieresis",
              7803,
              "umatragurmukhi",
              2625,
              "umonospace",
              65365,
              "underscore",
              95,
              "underscoredbl",
              8215,
              "underscoremonospace",
              65343,
              "underscorevertical",
              65075,
              "underscorewavy",
              65103,
              "union",
              8746,
              "universal",
              8704,
              "uogonek",
              371,
              "uparen",
              9392,
              "upblock",
              9600,
              "upperdothebrew",
              1476,
              "upsilon",
              965,
              "upsilondieresis",
              971,
              "upsilondieresistonos",
              944,
              "upsilonlatin",
              650,
              "upsilontonos",
              973,
              "uptackbelowcmb",
              797,
              "uptackmod",
              724,
              "uragurmukhi",
              2675,
              "uring",
              367,
              "ushortcyrillic",
              1118,
              "usmallhiragana",
              12357,
              "usmallkatakana",
              12453,
              "usmallkatakanahalfwidth",
              65385,
              "ustraightcyrillic",
              1199,
              "ustraightstrokecyrillic",
              1201,
              "utilde",
              361,
              "utildeacute",
              7801,
              "utildebelow",
              7797,
              "uubengali",
              2442,
              "uudeva",
              2314,
              "uugujarati",
              2698,
              "uugurmukhi",
              2570,
              "uumatragurmukhi",
              2626,
              "uuvowelsignbengali",
              2498,
              "uuvowelsigndeva",
              2370,
              "uuvowelsigngujarati",
              2754,
              "uvowelsignbengali",
              2497,
              "uvowelsigndeva",
              2369,
              "uvowelsigngujarati",
              2753,
              "v",
              118,
              "vadeva",
              2357,
              "vagujarati",
              2741,
              "vagurmukhi",
              2613,
              "vakatakana",
              12535,
              "vav",
              1493,
              "vavdagesh",
              64309,
              "vavdagesh65",
              64309,
              "vavdageshhebrew",
              64309,
              "vavhebrew",
              1493,
              "vavholam",
              64331,
              "vavholamhebrew",
              64331,
              "vavvavhebrew",
              1520,
              "vavyodhebrew",
              1521,
              "vcircle",
              9445,
              "vdotbelow",
              7807,
              "vecyrillic",
              1074,
              "veharabic",
              1700,
              "vehfinalarabic",
              64363,
              "vehinitialarabic",
              64364,
              "vehmedialarabic",
              64365,
              "vekatakana",
              12537,
              "venus",
              9792,
              "verticalbar",
              124,
              "verticallineabovecmb",
              781,
              "verticallinebelowcmb",
              809,
              "verticallinelowmod",
              716,
              "verticallinemod",
              712,
              "vewarmenian",
              1406,
              "vhook",
              651,
              "vikatakana",
              12536,
              "viramabengali",
              2509,
              "viramadeva",
              2381,
              "viramagujarati",
              2765,
              "visargabengali",
              2435,
              "visargadeva",
              2307,
              "visargagujarati",
              2691,
              "vmonospace",
              65366,
              "voarmenian",
              1400,
              "voicediterationhiragana",
              12446,
              "voicediterationkatakana",
              12542,
              "voicedmarkkana",
              12443,
              "voicedmarkkanahalfwidth",
              65438,
              "vokatakana",
              12538,
              "vparen",
              9393,
              "vtilde",
              7805,
              "vturned",
              652,
              "vuhiragana",
              12436,
              "vukatakana",
              12532,
              "w",
              119,
              "wacute",
              7811,
              "waekorean",
              12633,
              "wahiragana",
              12431,
              "wakatakana",
              12527,
              "wakatakanahalfwidth",
              65436,
              "wakorean",
              12632,
              "wasmallhiragana",
              12430,
              "wasmallkatakana",
              12526,
              "wattosquare",
              13143,
              "wavedash",
              12316,
              "wavyunderscorevertical",
              65076,
              "wawarabic",
              1608,
              "wawfinalarabic",
              65262,
              "wawhamzaabovearabic",
              1572,
              "wawhamzaabovefinalarabic",
              65158,
              "wbsquare",
              13277,
              "wcircle",
              9446,
              "wcircumflex",
              373,
              "wdieresis",
              7813,
              "wdotaccent",
              7815,
              "wdotbelow",
              7817,
              "wehiragana",
              12433,
              "weierstrass",
              8472,
              "wekatakana",
              12529,
              "wekorean",
              12638,
              "weokorean",
              12637,
              "wgrave",
              7809,
              "whitebullet",
              9702,
              "whitecircle",
              9675,
              "whitecircleinverse",
              9689,
              "whitecornerbracketleft",
              12302,
              "whitecornerbracketleftvertical",
              65091,
              "whitecornerbracketright",
              12303,
              "whitecornerbracketrightvertical",
              65092,
              "whitediamond",
              9671,
              "whitediamondcontainingblacksmalldiamond",
              9672,
              "whitedownpointingsmalltriangle",
              9663,
              "whitedownpointingtriangle",
              9661,
              "whiteleftpointingsmalltriangle",
              9667,
              "whiteleftpointingtriangle",
              9665,
              "whitelenticularbracketleft",
              12310,
              "whitelenticularbracketright",
              12311,
              "whiterightpointingsmalltriangle",
              9657,
              "whiterightpointingtriangle",
              9655,
              "whitesmallsquare",
              9643,
              "whitesmilingface",
              9786,
              "whitesquare",
              9633,
              "whitestar",
              9734,
              "whitetelephone",
              9743,
              "whitetortoiseshellbracketleft",
              12312,
              "whitetortoiseshellbracketright",
              12313,
              "whiteuppointingsmalltriangle",
              9653,
              "whiteuppointingtriangle",
              9651,
              "wihiragana",
              12432,
              "wikatakana",
              12528,
              "wikorean",
              12639,
              "wmonospace",
              65367,
              "wohiragana",
              12434,
              "wokatakana",
              12530,
              "wokatakanahalfwidth",
              65382,
              "won",
              8361,
              "wonmonospace",
              65510,
              "wowaenthai",
              3623,
              "wparen",
              9394,
              "wring",
              7832,
              "wsuperior",
              695,
              "wturned",
              653,
              "wynn",
              447,
              "x",
              120,
              "xabovecmb",
              829,
              "xbopomofo",
              12562,
              "xcircle",
              9447,
              "xdieresis",
              7821,
              "xdotaccent",
              7819,
              "xeharmenian",
              1389,
              "xi",
              958,
              "xmonospace",
              65368,
              "xparen",
              9395,
              "xsuperior",
              739,
              "y",
              121,
              "yaadosquare",
              13134,
              "yabengali",
              2479,
              "yacute",
              253,
              "yadeva",
              2351,
              "yaekorean",
              12626,
              "yagujarati",
              2735,
              "yagurmukhi",
              2607,
              "yahiragana",
              12420,
              "yakatakana",
              12516,
              "yakatakanahalfwidth",
              65428,
              "yakorean",
              12625,
              "yamakkanthai",
              3662,
              "yasmallhiragana",
              12419,
              "yasmallkatakana",
              12515,
              "yasmallkatakanahalfwidth",
              65388,
              "yatcyrillic",
              1123,
              "ycircle",
              9448,
              "ycircumflex",
              375,
              "ydieresis",
              255,
              "ydotaccent",
              7823,
              "ydotbelow",
              7925,
              "yeharabic",
              1610,
              "yehbarreearabic",
              1746,
              "yehbarreefinalarabic",
              64431,
              "yehfinalarabic",
              65266,
              "yehhamzaabovearabic",
              1574,
              "yehhamzaabovefinalarabic",
              65162,
              "yehhamzaaboveinitialarabic",
              65163,
              "yehhamzaabovemedialarabic",
              65164,
              "yehinitialarabic",
              65267,
              "yehmedialarabic",
              65268,
              "yehmeeminitialarabic",
              64733,
              "yehmeemisolatedarabic",
              64600,
              "yehnoonfinalarabic",
              64660,
              "yehthreedotsbelowarabic",
              1745,
              "yekorean",
              12630,
              "yen",
              165,
              "yenmonospace",
              65509,
              "yeokorean",
              12629,
              "yeorinhieuhkorean",
              12678,
              "yerahbenyomohebrew",
              1450,
              "yerahbenyomolefthebrew",
              1450,
              "yericyrillic",
              1099,
              "yerudieresiscyrillic",
              1273,
              "yesieungkorean",
              12673,
              "yesieungpansioskorean",
              12675,
              "yesieungsioskorean",
              12674,
              "yetivhebrew",
              1434,
              "ygrave",
              7923,
              "yhook",
              436,
              "yhookabove",
              7927,
              "yiarmenian",
              1397,
              "yicyrillic",
              1111,
              "yikorean",
              12642,
              "yinyang",
              9775,
              "yiwnarmenian",
              1410,
              "ymonospace",
              65369,
              "yod",
              1497,
              "yoddagesh",
              64313,
              "yoddageshhebrew",
              64313,
              "yodhebrew",
              1497,
              "yodyodhebrew",
              1522,
              "yodyodpatahhebrew",
              64287,
              "yohiragana",
              12424,
              "yoikorean",
              12681,
              "yokatakana",
              12520,
              "yokatakanahalfwidth",
              65430,
              "yokorean",
              12635,
              "yosmallhiragana",
              12423,
              "yosmallkatakana",
              12519,
              "yosmallkatakanahalfwidth",
              65390,
              "yotgreek",
              1011,
              "yoyaekorean",
              12680,
              "yoyakorean",
              12679,
              "yoyakthai",
              3618,
              "yoyingthai",
              3597,
              "yparen",
              9396,
              "ypogegrammeni",
              890,
              "ypogegrammenigreekcmb",
              837,
              "yr",
              422,
              "yring",
              7833,
              "ysuperior",
              696,
              "ytilde",
              7929,
              "yturned",
              654,
              "yuhiragana",
              12422,
              "yuikorean",
              12684,
              "yukatakana",
              12518,
              "yukatakanahalfwidth",
              65429,
              "yukorean",
              12640,
              "yusbigcyrillic",
              1131,
              "yusbigiotifiedcyrillic",
              1133,
              "yuslittlecyrillic",
              1127,
              "yuslittleiotifiedcyrillic",
              1129,
              "yusmallhiragana",
              12421,
              "yusmallkatakana",
              12517,
              "yusmallkatakanahalfwidth",
              65389,
              "yuyekorean",
              12683,
              "yuyeokorean",
              12682,
              "yyabengali",
              2527,
              "yyadeva",
              2399,
              "z",
              122,
              "zaarmenian",
              1382,
              "zacute",
              378,
              "zadeva",
              2395,
              "zagurmukhi",
              2651,
              "zaharabic",
              1592,
              "zahfinalarabic",
              65222,
              "zahinitialarabic",
              65223,
              "zahiragana",
              12374,
              "zahmedialarabic",
              65224,
              "zainarabic",
              1586,
              "zainfinalarabic",
              65200,
              "zakatakana",
              12470,
              "zaqefgadolhebrew",
              1429,
              "zaqefqatanhebrew",
              1428,
              "zarqahebrew",
              1432,
              "zayin",
              1494,
              "zayindagesh",
              64310,
              "zayindageshhebrew",
              64310,
              "zayinhebrew",
              1494,
              "zbopomofo",
              12567,
              "zcaron",
              382,
              "zcircle",
              9449,
              "zcircumflex",
              7825,
              "zcurl",
              657,
              "zdot",
              380,
              "zdotaccent",
              380,
              "zdotbelow",
              7827,
              "zecyrillic",
              1079,
              "zedescendercyrillic",
              1177,
              "zedieresiscyrillic",
              1247,
              "zehiragana",
              12380,
              "zekatakana",
              12476,
              "zero",
              48,
              "zeroarabic",
              1632,
              "zerobengali",
              2534,
              "zerodeva",
              2406,
              "zerogujarati",
              2790,
              "zerogurmukhi",
              2662,
              "zerohackarabic",
              1632,
              "zeroinferior",
              8320,
              "zeromonospace",
              65296,
              "zerooldstyle",
              63280,
              "zeropersian",
              1776,
              "zerosuperior",
              8304,
              "zerothai",
              3664,
              "zerowidthjoiner",
              65279,
              "zerowidthnonjoiner",
              8204,
              "zerowidthspace",
              8203,
              "zeta",
              950,
              "zhbopomofo",
              12563,
              "zhearmenian",
              1386,
              "zhebrevecyrillic",
              1218,
              "zhecyrillic",
              1078,
              "zhedescendercyrillic",
              1175,
              "zhedieresiscyrillic",
              1245,
              "zihiragana",
              12376,
              "zikatakana",
              12472,
              "zinorhebrew",
              1454,
              "zlinebelow",
              7829,
              "zmonospace",
              65370,
              "zohiragana",
              12382,
              "zokatakana",
              12478,
              "zparen",
              9397,
              "zretroflexhook",
              656,
              "zstroke",
              438,
              "zuhiragana",
              12378,
              "zukatakana",
              12474,
              ".notdef",
              0,
              "angbracketleftbig",
              9001,
              "angbracketleftBig",
              9001,
              "angbracketleftbigg",
              9001,
              "angbracketleftBigg",
              9001,
              "angbracketrightBig",
              9002,
              "angbracketrightbig",
              9002,
              "angbracketrightBigg",
              9002,
              "angbracketrightbigg",
              9002,
              "arrowhookleft",
              8618,
              "arrowhookright",
              8617,
              "arrowlefttophalf",
              8636,
              "arrowleftbothalf",
              8637,
              "arrownortheast",
              8599,
              "arrownorthwest",
              8598,
              "arrowrighttophalf",
              8640,
              "arrowrightbothalf",
              8641,
              "arrowsoutheast",
              8600,
              "arrowsouthwest",
              8601,
              "backslashbig",
              8726,
              "backslashBig",
              8726,
              "backslashBigg",
              8726,
              "backslashbigg",
              8726,
              "bardbl",
              8214,
              "bracehtipdownleft",
              65079,
              "bracehtipdownright",
              65079,
              "bracehtipupleft",
              65080,
              "bracehtipupright",
              65080,
              "braceleftBig",
              123,
              "braceleftbig",
              123,
              "braceleftbigg",
              123,
              "braceleftBigg",
              123,
              "bracerightBig",
              125,
              "bracerightbig",
              125,
              "bracerightbigg",
              125,
              "bracerightBigg",
              125,
              "bracketleftbig",
              91,
              "bracketleftBig",
              91,
              "bracketleftbigg",
              91,
              "bracketleftBigg",
              91,
              "bracketrightBig",
              93,
              "bracketrightbig",
              93,
              "bracketrightbigg",
              93,
              "bracketrightBigg",
              93,
              "ceilingleftbig",
              8968,
              "ceilingleftBig",
              8968,
              "ceilingleftBigg",
              8968,
              "ceilingleftbigg",
              8968,
              "ceilingrightbig",
              8969,
              "ceilingrightBig",
              8969,
              "ceilingrightbigg",
              8969,
              "ceilingrightBigg",
              8969,
              "circledotdisplay",
              8857,
              "circledottext",
              8857,
              "circlemultiplydisplay",
              8855,
              "circlemultiplytext",
              8855,
              "circleplusdisplay",
              8853,
              "circleplustext",
              8853,
              "contintegraldisplay",
              8750,
              "contintegraltext",
              8750,
              "coproductdisplay",
              8720,
              "coproducttext",
              8720,
              "floorleftBig",
              8970,
              "floorleftbig",
              8970,
              "floorleftbigg",
              8970,
              "floorleftBigg",
              8970,
              "floorrightbig",
              8971,
              "floorrightBig",
              8971,
              "floorrightBigg",
              8971,
              "floorrightbigg",
              8971,
              "hatwide",
              770,
              "hatwider",
              770,
              "hatwidest",
              770,
              "intercal",
              7488,
              "integraldisplay",
              8747,
              "integraltext",
              8747,
              "intersectiondisplay",
              8898,
              "intersectiontext",
              8898,
              "logicalanddisplay",
              8743,
              "logicalandtext",
              8743,
              "logicalordisplay",
              8744,
              "logicalortext",
              8744,
              "parenleftBig",
              40,
              "parenleftbig",
              40,
              "parenleftBigg",
              40,
              "parenleftbigg",
              40,
              "parenrightBig",
              41,
              "parenrightbig",
              41,
              "parenrightBigg",
              41,
              "parenrightbigg",
              41,
              "prime",
              8242,
              "productdisplay",
              8719,
              "producttext",
              8719,
              "radicalbig",
              8730,
              "radicalBig",
              8730,
              "radicalBigg",
              8730,
              "radicalbigg",
              8730,
              "radicalbt",
              8730,
              "radicaltp",
              8730,
              "radicalvertex",
              8730,
              "slashbig",
              47,
              "slashBig",
              47,
              "slashBigg",
              47,
              "slashbigg",
              47,
              "summationdisplay",
              8721,
              "summationtext",
              8721,
              "tildewide",
              732,
              "tildewider",
              732,
              "tildewidest",
              732,
              "uniondisplay",
              8899,
              "unionmultidisplay",
              8846,
              "unionmultitext",
              8846,
              "unionsqdisplay",
              8852,
              "unionsqtext",
              8852,
              "uniontext",
              8899,
              "vextenddouble",
              8741,
              "vextendsingle",
              8739
            ];
          }), v = (0, t.getArrayLookupTableFactory)(function() {
            return [
              "space",
              32,
              "a1",
              9985,
              "a2",
              9986,
              "a202",
              9987,
              "a3",
              9988,
              "a4",
              9742,
              "a5",
              9990,
              "a119",
              9991,
              "a118",
              9992,
              "a117",
              9993,
              "a11",
              9755,
              "a12",
              9758,
              "a13",
              9996,
              "a14",
              9997,
              "a15",
              9998,
              "a16",
              9999,
              "a105",
              1e4,
              "a17",
              10001,
              "a18",
              10002,
              "a19",
              10003,
              "a20",
              10004,
              "a21",
              10005,
              "a22",
              10006,
              "a23",
              10007,
              "a24",
              10008,
              "a25",
              10009,
              "a26",
              10010,
              "a27",
              10011,
              "a28",
              10012,
              "a6",
              10013,
              "a7",
              10014,
              "a8",
              10015,
              "a9",
              10016,
              "a10",
              10017,
              "a29",
              10018,
              "a30",
              10019,
              "a31",
              10020,
              "a32",
              10021,
              "a33",
              10022,
              "a34",
              10023,
              "a35",
              9733,
              "a36",
              10025,
              "a37",
              10026,
              "a38",
              10027,
              "a39",
              10028,
              "a40",
              10029,
              "a41",
              10030,
              "a42",
              10031,
              "a43",
              10032,
              "a44",
              10033,
              "a45",
              10034,
              "a46",
              10035,
              "a47",
              10036,
              "a48",
              10037,
              "a49",
              10038,
              "a50",
              10039,
              "a51",
              10040,
              "a52",
              10041,
              "a53",
              10042,
              "a54",
              10043,
              "a55",
              10044,
              "a56",
              10045,
              "a57",
              10046,
              "a58",
              10047,
              "a59",
              10048,
              "a60",
              10049,
              "a61",
              10050,
              "a62",
              10051,
              "a63",
              10052,
              "a64",
              10053,
              "a65",
              10054,
              "a66",
              10055,
              "a67",
              10056,
              "a68",
              10057,
              "a69",
              10058,
              "a70",
              10059,
              "a71",
              9679,
              "a72",
              10061,
              "a73",
              9632,
              "a74",
              10063,
              "a203",
              10064,
              "a75",
              10065,
              "a204",
              10066,
              "a76",
              9650,
              "a77",
              9660,
              "a78",
              9670,
              "a79",
              10070,
              "a81",
              9687,
              "a82",
              10072,
              "a83",
              10073,
              "a84",
              10074,
              "a97",
              10075,
              "a98",
              10076,
              "a99",
              10077,
              "a100",
              10078,
              "a101",
              10081,
              "a102",
              10082,
              "a103",
              10083,
              "a104",
              10084,
              "a106",
              10085,
              "a107",
              10086,
              "a108",
              10087,
              "a112",
              9827,
              "a111",
              9830,
              "a110",
              9829,
              "a109",
              9824,
              "a120",
              9312,
              "a121",
              9313,
              "a122",
              9314,
              "a123",
              9315,
              "a124",
              9316,
              "a125",
              9317,
              "a126",
              9318,
              "a127",
              9319,
              "a128",
              9320,
              "a129",
              9321,
              "a130",
              10102,
              "a131",
              10103,
              "a132",
              10104,
              "a133",
              10105,
              "a134",
              10106,
              "a135",
              10107,
              "a136",
              10108,
              "a137",
              10109,
              "a138",
              10110,
              "a139",
              10111,
              "a140",
              10112,
              "a141",
              10113,
              "a142",
              10114,
              "a143",
              10115,
              "a144",
              10116,
              "a145",
              10117,
              "a146",
              10118,
              "a147",
              10119,
              "a148",
              10120,
              "a149",
              10121,
              "a150",
              10122,
              "a151",
              10123,
              "a152",
              10124,
              "a153",
              10125,
              "a154",
              10126,
              "a155",
              10127,
              "a156",
              10128,
              "a157",
              10129,
              "a158",
              10130,
              "a159",
              10131,
              "a160",
              10132,
              "a161",
              8594,
              "a163",
              8596,
              "a164",
              8597,
              "a196",
              10136,
              "a165",
              10137,
              "a192",
              10138,
              "a166",
              10139,
              "a167",
              10140,
              "a168",
              10141,
              "a169",
              10142,
              "a170",
              10143,
              "a171",
              10144,
              "a172",
              10145,
              "a173",
              10146,
              "a162",
              10147,
              "a174",
              10148,
              "a175",
              10149,
              "a176",
              10150,
              "a177",
              10151,
              "a178",
              10152,
              "a179",
              10153,
              "a193",
              10154,
              "a180",
              10155,
              "a199",
              10156,
              "a181",
              10157,
              "a200",
              10158,
              "a182",
              10159,
              "a201",
              10161,
              "a183",
              10162,
              "a184",
              10163,
              "a197",
              10164,
              "a185",
              10165,
              "a194",
              10166,
              "a198",
              10167,
              "a186",
              10168,
              "a195",
              10169,
              "a187",
              10170,
              "a188",
              10171,
              "a189",
              10172,
              "a190",
              10173,
              "a191",
              10174,
              "a89",
              10088,
              "a90",
              10089,
              "a93",
              10090,
              "a94",
              10091,
              "a91",
              10092,
              "a92",
              10093,
              "a205",
              10094,
              "a85",
              10095,
              "a206",
              10096,
              "a86",
              10097,
              "a87",
              10098,
              "a88",
              10099,
              "a95",
              10100,
              "a96",
              10101,
              ".notdef",
              0
            ];
          });
        },
        /* 40 */
        /***/
        (Q, u, P) => {
          P.r(u), P.d(u, {
            /* harmony export */
            clearUnicodeCaches: () => (
              /* binding */
              o
            ),
            /* harmony export */
            getCharUnicodeCategory: () => (
              /* binding */
              n
            ),
            /* harmony export */
            getNormalizedUnicodes: () => (
              /* binding */
              h
            ),
            /* harmony export */
            getUnicodeForGlyph: () => (
              /* binding */
              a
            ),
            /* harmony export */
            getUnicodeRangeFor: () => (
              /* binding */
              y
            ),
            /* harmony export */
            mapSpecialUnicodeValues: () => (
              /* binding */
              v
            ),
            /* harmony export */
            reverseIfRtl: () => (
              /* binding */
              g
            )
            /* harmony export */
          });
          var t = P(6);
          const i = (0, t.getLookupTableFactory)(function(x) {
            x[63721] = 169, x[63193] = 169, x[63720] = 174, x[63194] = 174, x[63722] = 8482, x[63195] = 8482, x[63729] = 9127, x[63730] = 9128, x[63731] = 9129, x[63740] = 9131, x[63741] = 9132, x[63742] = 9133, x[63726] = 9121, x[63727] = 9122, x[63728] = 9123, x[63737] = 9124, x[63738] = 9125, x[63739] = 9126, x[63723] = 9115, x[63724] = 9116, x[63725] = 9117, x[63734] = 9118, x[63735] = 9119, x[63736] = 9120;
          });
          function v(x) {
            return x >= 65520 && x <= 65535 ? 0 : x >= 62976 && x <= 63743 ? i()[x] || x : x === 173 ? 45 : x;
          }
          function a(x, f) {
            let m = f[x];
            if (m !== void 0)
              return m;
            if (!x)
              return -1;
            if (x[0] === "u") {
              const C = x.length;
              let p;
              if (C === 7 && x[1] === "n" && x[2] === "i")
                p = x.substring(3);
              else if (C >= 5 && C <= 7)
                p = x.substring(1);
              else
                return -1;
              if (p === p.toUpperCase() && (m = parseInt(p, 16), m >= 0))
                return m;
            }
            return -1;
          }
          const e = [
            {
              begin: 0,
              end: 127
            },
            {
              begin: 128,
              end: 255
            },
            {
              begin: 256,
              end: 383
            },
            {
              begin: 384,
              end: 591
            },
            {
              begin: 592,
              end: 687
            },
            {
              begin: 688,
              end: 767
            },
            {
              begin: 768,
              end: 879
            },
            {
              begin: 880,
              end: 1023
            },
            {
              begin: 11392,
              end: 11519
            },
            {
              begin: 1024,
              end: 1279
            },
            {
              begin: 1328,
              end: 1423
            },
            {
              begin: 1424,
              end: 1535
            },
            {
              begin: 42240,
              end: 42559
            },
            {
              begin: 1536,
              end: 1791
            },
            {
              begin: 1984,
              end: 2047
            },
            {
              begin: 2304,
              end: 2431
            },
            {
              begin: 2432,
              end: 2559
            },
            {
              begin: 2560,
              end: 2687
            },
            {
              begin: 2688,
              end: 2815
            },
            {
              begin: 2816,
              end: 2943
            },
            {
              begin: 2944,
              end: 3071
            },
            {
              begin: 3072,
              end: 3199
            },
            {
              begin: 3200,
              end: 3327
            },
            {
              begin: 3328,
              end: 3455
            },
            {
              begin: 3584,
              end: 3711
            },
            {
              begin: 3712,
              end: 3839
            },
            {
              begin: 4256,
              end: 4351
            },
            {
              begin: 6912,
              end: 7039
            },
            {
              begin: 4352,
              end: 4607
            },
            {
              begin: 7680,
              end: 7935
            },
            {
              begin: 7936,
              end: 8191
            },
            {
              begin: 8192,
              end: 8303
            },
            {
              begin: 8304,
              end: 8351
            },
            {
              begin: 8352,
              end: 8399
            },
            {
              begin: 8400,
              end: 8447
            },
            {
              begin: 8448,
              end: 8527
            },
            {
              begin: 8528,
              end: 8591
            },
            {
              begin: 8592,
              end: 8703
            },
            {
              begin: 8704,
              end: 8959
            },
            {
              begin: 8960,
              end: 9215
            },
            {
              begin: 9216,
              end: 9279
            },
            {
              begin: 9280,
              end: 9311
            },
            {
              begin: 9312,
              end: 9471
            },
            {
              begin: 9472,
              end: 9599
            },
            {
              begin: 9600,
              end: 9631
            },
            {
              begin: 9632,
              end: 9727
            },
            {
              begin: 9728,
              end: 9983
            },
            {
              begin: 9984,
              end: 10175
            },
            {
              begin: 12288,
              end: 12351
            },
            {
              begin: 12352,
              end: 12447
            },
            {
              begin: 12448,
              end: 12543
            },
            {
              begin: 12544,
              end: 12591
            },
            {
              begin: 12592,
              end: 12687
            },
            {
              begin: 43072,
              end: 43135
            },
            {
              begin: 12800,
              end: 13055
            },
            {
              begin: 13056,
              end: 13311
            },
            {
              begin: 44032,
              end: 55215
            },
            {
              begin: 55296,
              end: 57343
            },
            {
              begin: 67840,
              end: 67871
            },
            {
              begin: 19968,
              end: 40959
            },
            {
              begin: 57344,
              end: 63743
            },
            {
              begin: 12736,
              end: 12783
            },
            {
              begin: 64256,
              end: 64335
            },
            {
              begin: 64336,
              end: 65023
            },
            {
              begin: 65056,
              end: 65071
            },
            {
              begin: 65040,
              end: 65055
            },
            {
              begin: 65104,
              end: 65135
            },
            {
              begin: 65136,
              end: 65279
            },
            {
              begin: 65280,
              end: 65519
            },
            {
              begin: 65520,
              end: 65535
            },
            {
              begin: 3840,
              end: 4095
            },
            {
              begin: 1792,
              end: 1871
            },
            {
              begin: 1920,
              end: 1983
            },
            {
              begin: 3456,
              end: 3583
            },
            {
              begin: 4096,
              end: 4255
            },
            {
              begin: 4608,
              end: 4991
            },
            {
              begin: 5024,
              end: 5119
            },
            {
              begin: 5120,
              end: 5759
            },
            {
              begin: 5760,
              end: 5791
            },
            {
              begin: 5792,
              end: 5887
            },
            {
              begin: 6016,
              end: 6143
            },
            {
              begin: 6144,
              end: 6319
            },
            {
              begin: 10240,
              end: 10495
            },
            {
              begin: 40960,
              end: 42127
            },
            {
              begin: 5888,
              end: 5919
            },
            {
              begin: 66304,
              end: 66351
            },
            {
              begin: 66352,
              end: 66383
            },
            {
              begin: 66560,
              end: 66639
            },
            {
              begin: 118784,
              end: 119039
            },
            {
              begin: 119808,
              end: 120831
            },
            {
              begin: 1044480,
              end: 1048573
            },
            {
              begin: 65024,
              end: 65039
            },
            {
              begin: 917504,
              end: 917631
            },
            {
              begin: 6400,
              end: 6479
            },
            {
              begin: 6480,
              end: 6527
            },
            {
              begin: 6528,
              end: 6623
            },
            {
              begin: 6656,
              end: 6687
            },
            {
              begin: 11264,
              end: 11359
            },
            {
              begin: 11568,
              end: 11647
            },
            {
              begin: 19904,
              end: 19967
            },
            {
              begin: 43008,
              end: 43055
            },
            {
              begin: 65536,
              end: 65663
            },
            {
              begin: 65856,
              end: 65935
            },
            {
              begin: 66432,
              end: 66463
            },
            {
              begin: 66464,
              end: 66527
            },
            {
              begin: 66640,
              end: 66687
            },
            {
              begin: 66688,
              end: 66735
            },
            {
              begin: 67584,
              end: 67647
            },
            {
              begin: 68096,
              end: 68191
            },
            {
              begin: 119552,
              end: 119647
            },
            {
              begin: 73728,
              end: 74751
            },
            {
              begin: 119648,
              end: 119679
            },
            {
              begin: 7040,
              end: 7103
            },
            {
              begin: 7168,
              end: 7247
            },
            {
              begin: 7248,
              end: 7295
            },
            {
              begin: 43136,
              end: 43231
            },
            {
              begin: 43264,
              end: 43311
            },
            {
              begin: 43312,
              end: 43359
            },
            {
              begin: 43520,
              end: 43615
            },
            {
              begin: 65936,
              end: 65999
            },
            {
              begin: 66e3,
              end: 66047
            },
            {
              begin: 66208,
              end: 66271
            },
            {
              begin: 127024,
              end: 127135
            }
          ];
          function y(x) {
            for (let f = 0, m = e.length; f < m; f++) {
              const C = e[f];
              if (x >= C.begin && x < C.end)
                return f;
            }
            return -1;
          }
          function r(x) {
            let f = e[13];
            return x >= f.begin && x < f.end || (f = e[11], x >= f.begin && x < f.end);
          }
          const h = (0, t.getArrayLookupTableFactory)(function() {
            return [
              "¨",
              " ̈",
              "¯",
              " ̄",
              "´",
              " ́",
              "µ",
              "μ",
              "¸",
              " ̧",
              "Ĳ",
              "IJ",
              "ĳ",
              "ij",
              "Ŀ",
              "L·",
              "ŀ",
              "l·",
              "ŉ",
              "ʼn",
              "ſ",
              "s",
              "Ǆ",
              "DŽ",
              "ǅ",
              "Dž",
              "ǆ",
              "dž",
              "Ǉ",
              "LJ",
              "ǈ",
              "Lj",
              "ǉ",
              "lj",
              "Ǌ",
              "NJ",
              "ǋ",
              "Nj",
              "ǌ",
              "nj",
              "Ǳ",
              "DZ",
              "ǲ",
              "Dz",
              "ǳ",
              "dz",
              "˘",
              " ̆",
              "˙",
              " ̇",
              "˚",
              " ̊",
              "˛",
              " ̨",
              "˜",
              " ̃",
              "˝",
              " ̋",
              "ͺ",
              " ͅ",
              "΄",
              " ́",
              "ϐ",
              "β",
              "ϑ",
              "θ",
              "ϒ",
              "Υ",
              "ϕ",
              "φ",
              "ϖ",
              "π",
              "ϰ",
              "κ",
              "ϱ",
              "ρ",
              "ϲ",
              "ς",
              "ϴ",
              "Θ",
              "ϵ",
              "ε",
              "Ϲ",
              "Σ",
              "և",
              "եւ",
              "ٵ",
              "اٴ",
              "ٶ",
              "وٴ",
              "ٷ",
              "ۇٴ",
              "ٸ",
              "يٴ",
              "ำ",
              "ํา",
              "ຳ",
              "ໍາ",
              "ໜ",
              "ຫນ",
              "ໝ",
              "ຫມ",
              "ཷ",
              "ྲཱྀ",
              "ཹ",
              "ླཱྀ",
              "ẚ",
              "aʾ",
              "᾽",
              " ̓",
              "᾿",
              " ̓",
              "῀",
              " ͂",
              "῾",
              " ̔",
              " ",
              " ",
              " ",
              " ",
              " ",
              " ",
              " ",
              " ",
              " ",
              " ",
              " ",
              " ",
              " ",
              " ",
              " ",
              " ",
              "‗",
              " ̳",
              "․",
              ".",
              "‥",
              "..",
              "…",
              "...",
              "″",
              "′′",
              "‴",
              "′′′",
              "‶",
              "‵‵",
              "‷",
              "‵‵‵",
              "‼",
              "!!",
              "‾",
              " ̅",
              "⁇",
              "??",
              "⁈",
              "?!",
              "⁉",
              "!?",
              "⁗",
              "′′′′",
              " ",
              " ",
              "₨",
              "Rs",
              "℀",
              "a/c",
              "℁",
              "a/s",
              "℃",
              "°C",
              "℅",
              "c/o",
              "℆",
              "c/u",
              "ℇ",
              "Ɛ",
              "℉",
              "°F",
              "№",
              "No",
              "℡",
              "TEL",
              "ℵ",
              "א",
              "ℶ",
              "ב",
              "ℷ",
              "ג",
              "ℸ",
              "ד",
              "℻",
              "FAX",
              "Ⅰ",
              "I",
              "Ⅱ",
              "II",
              "Ⅲ",
              "III",
              "Ⅳ",
              "IV",
              "Ⅴ",
              "V",
              "Ⅵ",
              "VI",
              "Ⅶ",
              "VII",
              "Ⅷ",
              "VIII",
              "Ⅸ",
              "IX",
              "Ⅹ",
              "X",
              "Ⅺ",
              "XI",
              "Ⅻ",
              "XII",
              "Ⅼ",
              "L",
              "Ⅽ",
              "C",
              "Ⅾ",
              "D",
              "Ⅿ",
              "M",
              "ⅰ",
              "i",
              "ⅱ",
              "ii",
              "ⅲ",
              "iii",
              "ⅳ",
              "iv",
              "ⅴ",
              "v",
              "ⅵ",
              "vi",
              "ⅶ",
              "vii",
              "ⅷ",
              "viii",
              "ⅸ",
              "ix",
              "ⅹ",
              "x",
              "ⅺ",
              "xi",
              "ⅻ",
              "xii",
              "ⅼ",
              "l",
              "ⅽ",
              "c",
              "ⅾ",
              "d",
              "ⅿ",
              "m",
              "∬",
              "∫∫",
              "∭",
              "∫∫∫",
              "∯",
              "∮∮",
              "∰",
              "∮∮∮",
              "⑴",
              "(1)",
              "⑵",
              "(2)",
              "⑶",
              "(3)",
              "⑷",
              "(4)",
              "⑸",
              "(5)",
              "⑹",
              "(6)",
              "⑺",
              "(7)",
              "⑻",
              "(8)",
              "⑼",
              "(9)",
              "⑽",
              "(10)",
              "⑾",
              "(11)",
              "⑿",
              "(12)",
              "⒀",
              "(13)",
              "⒁",
              "(14)",
              "⒂",
              "(15)",
              "⒃",
              "(16)",
              "⒄",
              "(17)",
              "⒅",
              "(18)",
              "⒆",
              "(19)",
              "⒇",
              "(20)",
              "⒈",
              "1.",
              "⒉",
              "2.",
              "⒊",
              "3.",
              "⒋",
              "4.",
              "⒌",
              "5.",
              "⒍",
              "6.",
              "⒎",
              "7.",
              "⒏",
              "8.",
              "⒐",
              "9.",
              "⒑",
              "10.",
              "⒒",
              "11.",
              "⒓",
              "12.",
              "⒔",
              "13.",
              "⒕",
              "14.",
              "⒖",
              "15.",
              "⒗",
              "16.",
              "⒘",
              "17.",
              "⒙",
              "18.",
              "⒚",
              "19.",
              "⒛",
              "20.",
              "⒜",
              "(a)",
              "⒝",
              "(b)",
              "⒞",
              "(c)",
              "⒟",
              "(d)",
              "⒠",
              "(e)",
              "⒡",
              "(f)",
              "⒢",
              "(g)",
              "⒣",
              "(h)",
              "⒤",
              "(i)",
              "⒥",
              "(j)",
              "⒦",
              "(k)",
              "⒧",
              "(l)",
              "⒨",
              "(m)",
              "⒩",
              "(n)",
              "⒪",
              "(o)",
              "⒫",
              "(p)",
              "⒬",
              "(q)",
              "⒭",
              "(r)",
              "⒮",
              "(s)",
              "⒯",
              "(t)",
              "⒰",
              "(u)",
              "⒱",
              "(v)",
              "⒲",
              "(w)",
              "⒳",
              "(x)",
              "⒴",
              "(y)",
              "⒵",
              "(z)",
              "⨌",
              "∫∫∫∫",
              "⩴",
              "::=",
              "⩵",
              "==",
              "⩶",
              "===",
              "⺟",
              "母",
              "⻳",
              "龟",
              "⼀",
              "一",
              "⼁",
              "丨",
              "⼂",
              "丶",
              "⼃",
              "丿",
              "⼄",
              "乙",
              "⼅",
              "亅",
              "⼆",
              "二",
              "⼇",
              "亠",
              "⼈",
              "人",
              "⼉",
              "儿",
              "⼊",
              "入",
              "⼋",
              "八",
              "⼌",
              "冂",
              "⼍",
              "冖",
              "⼎",
              "冫",
              "⼏",
              "几",
              "⼐",
              "凵",
              "⼑",
              "刀",
              "⼒",
              "力",
              "⼓",
              "勹",
              "⼔",
              "匕",
              "⼕",
              "匚",
              "⼖",
              "匸",
              "⼗",
              "十",
              "⼘",
              "卜",
              "⼙",
              "卩",
              "⼚",
              "厂",
              "⼛",
              "厶",
              "⼜",
              "又",
              "⼝",
              "口",
              "⼞",
              "囗",
              "⼟",
              "土",
              "⼠",
              "士",
              "⼡",
              "夂",
              "⼢",
              "夊",
              "⼣",
              "夕",
              "⼤",
              "大",
              "⼥",
              "女",
              "⼦",
              "子",
              "⼧",
              "宀",
              "⼨",
              "寸",
              "⼩",
              "小",
              "⼪",
              "尢",
              "⼫",
              "尸",
              "⼬",
              "屮",
              "⼭",
              "山",
              "⼮",
              "巛",
              "⼯",
              "工",
              "⼰",
              "己",
              "⼱",
              "巾",
              "⼲",
              "干",
              "⼳",
              "幺",
              "⼴",
              "广",
              "⼵",
              "廴",
              "⼶",
              "廾",
              "⼷",
              "弋",
              "⼸",
              "弓",
              "⼹",
              "彐",
              "⼺",
              "彡",
              "⼻",
              "彳",
              "⼼",
              "心",
              "⼽",
              "戈",
              "⼾",
              "戶",
              "⼿",
              "手",
              "⽀",
              "支",
              "⽁",
              "攴",
              "⽂",
              "文",
              "⽃",
              "斗",
              "⽄",
              "斤",
              "⽅",
              "方",
              "⽆",
              "无",
              "⽇",
              "日",
              "⽈",
              "曰",
              "⽉",
              "月",
              "⽊",
              "木",
              "⽋",
              "欠",
              "⽌",
              "止",
              "⽍",
              "歹",
              "⽎",
              "殳",
              "⽏",
              "毋",
              "⽐",
              "比",
              "⽑",
              "毛",
              "⽒",
              "氏",
              "⽓",
              "气",
              "⽔",
              "水",
              "⽕",
              "火",
              "⽖",
              "爪",
              "⽗",
              "父",
              "⽘",
              "爻",
              "⽙",
              "爿",
              "⽚",
              "片",
              "⽛",
              "牙",
              "⽜",
              "牛",
              "⽝",
              "犬",
              "⽞",
              "玄",
              "⽟",
              "玉",
              "⽠",
              "瓜",
              "⽡",
              "瓦",
              "⽢",
              "甘",
              "⽣",
              "生",
              "⽤",
              "用",
              "⽥",
              "田",
              "⽦",
              "疋",
              "⽧",
              "疒",
              "⽨",
              "癶",
              "⽩",
              "白",
              "⽪",
              "皮",
              "⽫",
              "皿",
              "⽬",
              "目",
              "⽭",
              "矛",
              "⽮",
              "矢",
              "⽯",
              "石",
              "⽰",
              "示",
              "⽱",
              "禸",
              "⽲",
              "禾",
              "⽳",
              "穴",
              "⽴",
              "立",
              "⽵",
              "竹",
              "⽶",
              "米",
              "⽷",
              "糸",
              "⽸",
              "缶",
              "⽹",
              "网",
              "⽺",
              "羊",
              "⽻",
              "羽",
              "⽼",
              "老",
              "⽽",
              "而",
              "⽾",
              "耒",
              "⽿",
              "耳",
              "⾀",
              "聿",
              "⾁",
              "肉",
              "⾂",
              "臣",
              "⾃",
              "自",
              "⾄",
              "至",
              "⾅",
              "臼",
              "⾆",
              "舌",
              "⾇",
              "舛",
              "⾈",
              "舟",
              "⾉",
              "艮",
              "⾊",
              "色",
              "⾋",
              "艸",
              "⾌",
              "虍",
              "⾍",
              "虫",
              "⾎",
              "血",
              "⾏",
              "行",
              "⾐",
              "衣",
              "⾑",
              "襾",
              "⾒",
              "見",
              "⾓",
              "角",
              "⾔",
              "言",
              "⾕",
              "谷",
              "⾖",
              "豆",
              "⾗",
              "豕",
              "⾘",
              "豸",
              "⾙",
              "貝",
              "⾚",
              "赤",
              "⾛",
              "走",
              "⾜",
              "足",
              "⾝",
              "身",
              "⾞",
              "車",
              "⾟",
              "辛",
              "⾠",
              "辰",
              "⾡",
              "辵",
              "⾢",
              "邑",
              "⾣",
              "酉",
              "⾤",
              "釆",
              "⾥",
              "里",
              "⾦",
              "金",
              "⾧",
              "長",
              "⾨",
              "門",
              "⾩",
              "阜",
              "⾪",
              "隶",
              "⾫",
              "隹",
              "⾬",
              "雨",
              "⾭",
              "靑",
              "⾮",
              "非",
              "⾯",
              "面",
              "⾰",
              "革",
              "⾱",
              "韋",
              "⾲",
              "韭",
              "⾳",
              "音",
              "⾴",
              "頁",
              "⾵",
              "風",
              "⾶",
              "飛",
              "⾷",
              "食",
              "⾸",
              "首",
              "⾹",
              "香",
              "⾺",
              "馬",
              "⾻",
              "骨",
              "⾼",
              "高",
              "⾽",
              "髟",
              "⾾",
              "鬥",
              "⾿",
              "鬯",
              "⿀",
              "鬲",
              "⿁",
              "鬼",
              "⿂",
              "魚",
              "⿃",
              "鳥",
              "⿄",
              "鹵",
              "⿅",
              "鹿",
              "⿆",
              "麥",
              "⿇",
              "麻",
              "⿈",
              "黃",
              "⿉",
              "黍",
              "⿊",
              "黑",
              "⿋",
              "黹",
              "⿌",
              "黽",
              "⿍",
              "鼎",
              "⿎",
              "鼓",
              "⿏",
              "鼠",
              "⿐",
              "鼻",
              "⿑",
              "齊",
              "⿒",
              "齒",
              "⿓",
              "龍",
              "⿔",
              "龜",
              "⿕",
              "龠",
              "〶",
              "〒",
              "〸",
              "十",
              "〹",
              "卄",
              "〺",
              "卅",
              "゛",
              " ゙",
              "゜",
              " ゚",
              "ㄱ",
              "ᄀ",
              "ㄲ",
              "ᄁ",
              "ㄳ",
              "ᆪ",
              "ㄴ",
              "ᄂ",
              "ㄵ",
              "ᆬ",
              "ㄶ",
              "ᆭ",
              "ㄷ",
              "ᄃ",
              "ㄸ",
              "ᄄ",
              "ㄹ",
              "ᄅ",
              "ㄺ",
              "ᆰ",
              "ㄻ",
              "ᆱ",
              "ㄼ",
              "ᆲ",
              "ㄽ",
              "ᆳ",
              "ㄾ",
              "ᆴ",
              "ㄿ",
              "ᆵ",
              "ㅀ",
              "ᄚ",
              "ㅁ",
              "ᄆ",
              "ㅂ",
              "ᄇ",
              "ㅃ",
              "ᄈ",
              "ㅄ",
              "ᄡ",
              "ㅅ",
              "ᄉ",
              "ㅆ",
              "ᄊ",
              "ㅇ",
              "ᄋ",
              "ㅈ",
              "ᄌ",
              "ㅉ",
              "ᄍ",
              "ㅊ",
              "ᄎ",
              "ㅋ",
              "ᄏ",
              "ㅌ",
              "ᄐ",
              "ㅍ",
              "ᄑ",
              "ㅎ",
              "ᄒ",
              "ㅏ",
              "ᅡ",
              "ㅐ",
              "ᅢ",
              "ㅑ",
              "ᅣ",
              "ㅒ",
              "ᅤ",
              "ㅓ",
              "ᅥ",
              "ㅔ",
              "ᅦ",
              "ㅕ",
              "ᅧ",
              "ㅖ",
              "ᅨ",
              "ㅗ",
              "ᅩ",
              "ㅘ",
              "ᅪ",
              "ㅙ",
              "ᅫ",
              "ㅚ",
              "ᅬ",
              "ㅛ",
              "ᅭ",
              "ㅜ",
              "ᅮ",
              "ㅝ",
              "ᅯ",
              "ㅞ",
              "ᅰ",
              "ㅟ",
              "ᅱ",
              "ㅠ",
              "ᅲ",
              "ㅡ",
              "ᅳ",
              "ㅢ",
              "ᅴ",
              "ㅣ",
              "ᅵ",
              "ㅤ",
              "ᅠ",
              "ㅥ",
              "ᄔ",
              "ㅦ",
              "ᄕ",
              "ㅧ",
              "ᇇ",
              "ㅨ",
              "ᇈ",
              "ㅩ",
              "ᇌ",
              "ㅪ",
              "ᇎ",
              "ㅫ",
              "ᇓ",
              "ㅬ",
              "ᇗ",
              "ㅭ",
              "ᇙ",
              "ㅮ",
              "ᄜ",
              "ㅯ",
              "ᇝ",
              "ㅰ",
              "ᇟ",
              "ㅱ",
              "ᄝ",
              "ㅲ",
              "ᄞ",
              "ㅳ",
              "ᄠ",
              "ㅴ",
              "ᄢ",
              "ㅵ",
              "ᄣ",
              "ㅶ",
              "ᄧ",
              "ㅷ",
              "ᄩ",
              "ㅸ",
              "ᄫ",
              "ㅹ",
              "ᄬ",
              "ㅺ",
              "ᄭ",
              "ㅻ",
              "ᄮ",
              "ㅼ",
              "ᄯ",
              "ㅽ",
              "ᄲ",
              "ㅾ",
              "ᄶ",
              "ㅿ",
              "ᅀ",
              "ㆀ",
              "ᅇ",
              "ㆁ",
              "ᅌ",
              "ㆂ",
              "ᇱ",
              "ㆃ",
              "ᇲ",
              "ㆄ",
              "ᅗ",
              "ㆅ",
              "ᅘ",
              "ㆆ",
              "ᅙ",
              "ㆇ",
              "ᆄ",
              "ㆈ",
              "ᆅ",
              "ㆉ",
              "ᆈ",
              "ㆊ",
              "ᆑ",
              "ㆋ",
              "ᆒ",
              "ㆌ",
              "ᆔ",
              "ㆍ",
              "ᆞ",
              "ㆎ",
              "ᆡ",
              "㈀",
              "(ᄀ)",
              "㈁",
              "(ᄂ)",
              "㈂",
              "(ᄃ)",
              "㈃",
              "(ᄅ)",
              "㈄",
              "(ᄆ)",
              "㈅",
              "(ᄇ)",
              "㈆",
              "(ᄉ)",
              "㈇",
              "(ᄋ)",
              "㈈",
              "(ᄌ)",
              "㈉",
              "(ᄎ)",
              "㈊",
              "(ᄏ)",
              "㈋",
              "(ᄐ)",
              "㈌",
              "(ᄑ)",
              "㈍",
              "(ᄒ)",
              "㈎",
              "(가)",
              "㈏",
              "(나)",
              "㈐",
              "(다)",
              "㈑",
              "(라)",
              "㈒",
              "(마)",
              "㈓",
              "(바)",
              "㈔",
              "(사)",
              "㈕",
              "(아)",
              "㈖",
              "(자)",
              "㈗",
              "(차)",
              "㈘",
              "(카)",
              "㈙",
              "(타)",
              "㈚",
              "(파)",
              "㈛",
              "(하)",
              "㈜",
              "(주)",
              "㈝",
              "(오전)",
              "㈞",
              "(오후)",
              "㈠",
              "(一)",
              "㈡",
              "(二)",
              "㈢",
              "(三)",
              "㈣",
              "(四)",
              "㈤",
              "(五)",
              "㈥",
              "(六)",
              "㈦",
              "(七)",
              "㈧",
              "(八)",
              "㈨",
              "(九)",
              "㈩",
              "(十)",
              "㈪",
              "(月)",
              "㈫",
              "(火)",
              "㈬",
              "(水)",
              "㈭",
              "(木)",
              "㈮",
              "(金)",
              "㈯",
              "(土)",
              "㈰",
              "(日)",
              "㈱",
              "(株)",
              "㈲",
              "(有)",
              "㈳",
              "(社)",
              "㈴",
              "(名)",
              "㈵",
              "(特)",
              "㈶",
              "(財)",
              "㈷",
              "(祝)",
              "㈸",
              "(労)",
              "㈹",
              "(代)",
              "㈺",
              "(呼)",
              "㈻",
              "(学)",
              "㈼",
              "(監)",
              "㈽",
              "(企)",
              "㈾",
              "(資)",
              "㈿",
              "(協)",
              "㉀",
              "(祭)",
              "㉁",
              "(休)",
              "㉂",
              "(自)",
              "㉃",
              "(至)",
              "㋀",
              "1月",
              "㋁",
              "2月",
              "㋂",
              "3月",
              "㋃",
              "4月",
              "㋄",
              "5月",
              "㋅",
              "6月",
              "㋆",
              "7月",
              "㋇",
              "8月",
              "㋈",
              "9月",
              "㋉",
              "10月",
              "㋊",
              "11月",
              "㋋",
              "12月",
              "㍘",
              "0点",
              "㍙",
              "1点",
              "㍚",
              "2点",
              "㍛",
              "3点",
              "㍜",
              "4点",
              "㍝",
              "5点",
              "㍞",
              "6点",
              "㍟",
              "7点",
              "㍠",
              "8点",
              "㍡",
              "9点",
              "㍢",
              "10点",
              "㍣",
              "11点",
              "㍤",
              "12点",
              "㍥",
              "13点",
              "㍦",
              "14点",
              "㍧",
              "15点",
              "㍨",
              "16点",
              "㍩",
              "17点",
              "㍪",
              "18点",
              "㍫",
              "19点",
              "㍬",
              "20点",
              "㍭",
              "21点",
              "㍮",
              "22点",
              "㍯",
              "23点",
              "㍰",
              "24点",
              "㏠",
              "1日",
              "㏡",
              "2日",
              "㏢",
              "3日",
              "㏣",
              "4日",
              "㏤",
              "5日",
              "㏥",
              "6日",
              "㏦",
              "7日",
              "㏧",
              "8日",
              "㏨",
              "9日",
              "㏩",
              "10日",
              "㏪",
              "11日",
              "㏫",
              "12日",
              "㏬",
              "13日",
              "㏭",
              "14日",
              "㏮",
              "15日",
              "㏯",
              "16日",
              "㏰",
              "17日",
              "㏱",
              "18日",
              "㏲",
              "19日",
              "㏳",
              "20日",
              "㏴",
              "21日",
              "㏵",
              "22日",
              "㏶",
              "23日",
              "㏷",
              "24日",
              "㏸",
              "25日",
              "㏹",
              "26日",
              "㏺",
              "27日",
              "㏻",
              "28日",
              "㏼",
              "29日",
              "㏽",
              "30日",
              "㏾",
              "31日",
              "ﬀ",
              "ff",
              "ﬁ",
              "fi",
              "ﬂ",
              "fl",
              "ﬃ",
              "ffi",
              "ﬄ",
              "ffl",
              "ﬅ",
              "ſt",
              "ﬆ",
              "st",
              "ﬓ",
              "մն",
              "ﬔ",
              "մե",
              "ﬕ",
              "մի",
              "ﬖ",
              "վն",
              "ﬗ",
              "մխ",
              "ﭏ",
              "אל",
              "ﭐ",
              "ٱ",
              "ﭑ",
              "ٱ",
              "ﭒ",
              "ٻ",
              "ﭓ",
              "ٻ",
              "ﭔ",
              "ٻ",
              "ﭕ",
              "ٻ",
              "ﭖ",
              "پ",
              "ﭗ",
              "پ",
              "ﭘ",
              "پ",
              "ﭙ",
              "پ",
              "ﭚ",
              "ڀ",
              "ﭛ",
              "ڀ",
              "ﭜ",
              "ڀ",
              "ﭝ",
              "ڀ",
              "ﭞ",
              "ٺ",
              "ﭟ",
              "ٺ",
              "ﭠ",
              "ٺ",
              "ﭡ",
              "ٺ",
              "ﭢ",
              "ٿ",
              "ﭣ",
              "ٿ",
              "ﭤ",
              "ٿ",
              "ﭥ",
              "ٿ",
              "ﭦ",
              "ٹ",
              "ﭧ",
              "ٹ",
              "ﭨ",
              "ٹ",
              "ﭩ",
              "ٹ",
              "ﭪ",
              "ڤ",
              "ﭫ",
              "ڤ",
              "ﭬ",
              "ڤ",
              "ﭭ",
              "ڤ",
              "ﭮ",
              "ڦ",
              "ﭯ",
              "ڦ",
              "ﭰ",
              "ڦ",
              "ﭱ",
              "ڦ",
              "ﭲ",
              "ڄ",
              "ﭳ",
              "ڄ",
              "ﭴ",
              "ڄ",
              "ﭵ",
              "ڄ",
              "ﭶ",
              "ڃ",
              "ﭷ",
              "ڃ",
              "ﭸ",
              "ڃ",
              "ﭹ",
              "ڃ",
              "ﭺ",
              "چ",
              "ﭻ",
              "چ",
              "ﭼ",
              "چ",
              "ﭽ",
              "چ",
              "ﭾ",
              "ڇ",
              "ﭿ",
              "ڇ",
              "ﮀ",
              "ڇ",
              "ﮁ",
              "ڇ",
              "ﮂ",
              "ڍ",
              "ﮃ",
              "ڍ",
              "ﮄ",
              "ڌ",
              "ﮅ",
              "ڌ",
              "ﮆ",
              "ڎ",
              "ﮇ",
              "ڎ",
              "ﮈ",
              "ڈ",
              "ﮉ",
              "ڈ",
              "ﮊ",
              "ژ",
              "ﮋ",
              "ژ",
              "ﮌ",
              "ڑ",
              "ﮍ",
              "ڑ",
              "ﮎ",
              "ک",
              "ﮏ",
              "ک",
              "ﮐ",
              "ک",
              "ﮑ",
              "ک",
              "ﮒ",
              "گ",
              "ﮓ",
              "گ",
              "ﮔ",
              "گ",
              "ﮕ",
              "گ",
              "ﮖ",
              "ڳ",
              "ﮗ",
              "ڳ",
              "ﮘ",
              "ڳ",
              "ﮙ",
              "ڳ",
              "ﮚ",
              "ڱ",
              "ﮛ",
              "ڱ",
              "ﮜ",
              "ڱ",
              "ﮝ",
              "ڱ",
              "ﮞ",
              "ں",
              "ﮟ",
              "ں",
              "ﮠ",
              "ڻ",
              "ﮡ",
              "ڻ",
              "ﮢ",
              "ڻ",
              "ﮣ",
              "ڻ",
              "ﮤ",
              "ۀ",
              "ﮥ",
              "ۀ",
              "ﮦ",
              "ہ",
              "ﮧ",
              "ہ",
              "ﮨ",
              "ہ",
              "ﮩ",
              "ہ",
              "ﮪ",
              "ھ",
              "ﮫ",
              "ھ",
              "ﮬ",
              "ھ",
              "ﮭ",
              "ھ",
              "ﮮ",
              "ے",
              "ﮯ",
              "ے",
              "ﮰ",
              "ۓ",
              "ﮱ",
              "ۓ",
              "ﯓ",
              "ڭ",
              "ﯔ",
              "ڭ",
              "ﯕ",
              "ڭ",
              "ﯖ",
              "ڭ",
              "ﯗ",
              "ۇ",
              "ﯘ",
              "ۇ",
              "ﯙ",
              "ۆ",
              "ﯚ",
              "ۆ",
              "ﯛ",
              "ۈ",
              "ﯜ",
              "ۈ",
              "ﯝ",
              "ٷ",
              "ﯞ",
              "ۋ",
              "ﯟ",
              "ۋ",
              "ﯠ",
              "ۅ",
              "ﯡ",
              "ۅ",
              "ﯢ",
              "ۉ",
              "ﯣ",
              "ۉ",
              "ﯤ",
              "ې",
              "ﯥ",
              "ې",
              "ﯦ",
              "ې",
              "ﯧ",
              "ې",
              "ﯨ",
              "ى",
              "ﯩ",
              "ى",
              "ﯪ",
              "ئا",
              "ﯫ",
              "ئا",
              "ﯬ",
              "ئە",
              "ﯭ",
              "ئە",
              "ﯮ",
              "ئو",
              "ﯯ",
              "ئو",
              "ﯰ",
              "ئۇ",
              "ﯱ",
              "ئۇ",
              "ﯲ",
              "ئۆ",
              "ﯳ",
              "ئۆ",
              "ﯴ",
              "ئۈ",
              "ﯵ",
              "ئۈ",
              "ﯶ",
              "ئې",
              "ﯷ",
              "ئې",
              "ﯸ",
              "ئې",
              "ﯹ",
              "ئى",
              "ﯺ",
              "ئى",
              "ﯻ",
              "ئى",
              "ﯼ",
              "ی",
              "ﯽ",
              "ی",
              "ﯾ",
              "ی",
              "ﯿ",
              "ی",
              "ﰀ",
              "ئج",
              "ﰁ",
              "ئح",
              "ﰂ",
              "ئم",
              "ﰃ",
              "ئى",
              "ﰄ",
              "ئي",
              "ﰅ",
              "بج",
              "ﰆ",
              "بح",
              "ﰇ",
              "بخ",
              "ﰈ",
              "بم",
              "ﰉ",
              "بى",
              "ﰊ",
              "بي",
              "ﰋ",
              "تج",
              "ﰌ",
              "تح",
              "ﰍ",
              "تخ",
              "ﰎ",
              "تم",
              "ﰏ",
              "تى",
              "ﰐ",
              "تي",
              "ﰑ",
              "ثج",
              "ﰒ",
              "ثم",
              "ﰓ",
              "ثى",
              "ﰔ",
              "ثي",
              "ﰕ",
              "جح",
              "ﰖ",
              "جم",
              "ﰗ",
              "حج",
              "ﰘ",
              "حم",
              "ﰙ",
              "خج",
              "ﰚ",
              "خح",
              "ﰛ",
              "خم",
              "ﰜ",
              "سج",
              "ﰝ",
              "سح",
              "ﰞ",
              "سخ",
              "ﰟ",
              "سم",
              "ﰠ",
              "صح",
              "ﰡ",
              "صم",
              "ﰢ",
              "ضج",
              "ﰣ",
              "ضح",
              "ﰤ",
              "ضخ",
              "ﰥ",
              "ضم",
              "ﰦ",
              "طح",
              "ﰧ",
              "طم",
              "ﰨ",
              "ظم",
              "ﰩ",
              "عج",
              "ﰪ",
              "عم",
              "ﰫ",
              "غج",
              "ﰬ",
              "غم",
              "ﰭ",
              "فج",
              "ﰮ",
              "فح",
              "ﰯ",
              "فخ",
              "ﰰ",
              "فم",
              "ﰱ",
              "فى",
              "ﰲ",
              "في",
              "ﰳ",
              "قح",
              "ﰴ",
              "قم",
              "ﰵ",
              "قى",
              "ﰶ",
              "قي",
              "ﰷ",
              "كا",
              "ﰸ",
              "كج",
              "ﰹ",
              "كح",
              "ﰺ",
              "كخ",
              "ﰻ",
              "كل",
              "ﰼ",
              "كم",
              "ﰽ",
              "كى",
              "ﰾ",
              "كي",
              "ﰿ",
              "لج",
              "ﱀ",
              "لح",
              "ﱁ",
              "لخ",
              "ﱂ",
              "لم",
              "ﱃ",
              "لى",
              "ﱄ",
              "لي",
              "ﱅ",
              "مج",
              "ﱆ",
              "مح",
              "ﱇ",
              "مخ",
              "ﱈ",
              "مم",
              "ﱉ",
              "مى",
              "ﱊ",
              "مي",
              "ﱋ",
              "نج",
              "ﱌ",
              "نح",
              "ﱍ",
              "نخ",
              "ﱎ",
              "نم",
              "ﱏ",
              "نى",
              "ﱐ",
              "ني",
              "ﱑ",
              "هج",
              "ﱒ",
              "هم",
              "ﱓ",
              "هى",
              "ﱔ",
              "هي",
              "ﱕ",
              "يج",
              "ﱖ",
              "يح",
              "ﱗ",
              "يخ",
              "ﱘ",
              "يم",
              "ﱙ",
              "يى",
              "ﱚ",
              "يي",
              "ﱛ",
              "ذٰ",
              "ﱜ",
              "رٰ",
              "ﱝ",
              "ىٰ",
              "ﱞ",
              " ٌّ",
              "ﱟ",
              " ٍّ",
              "ﱠ",
              " َّ",
              "ﱡ",
              " ُّ",
              "ﱢ",
              " ِّ",
              "ﱣ",
              " ّٰ",
              "ﱤ",
              "ئر",
              "ﱥ",
              "ئز",
              "ﱦ",
              "ئم",
              "ﱧ",
              "ئن",
              "ﱨ",
              "ئى",
              "ﱩ",
              "ئي",
              "ﱪ",
              "بر",
              "ﱫ",
              "بز",
              "ﱬ",
              "بم",
              "ﱭ",
              "بن",
              "ﱮ",
              "بى",
              "ﱯ",
              "بي",
              "ﱰ",
              "تر",
              "ﱱ",
              "تز",
              "ﱲ",
              "تم",
              "ﱳ",
              "تن",
              "ﱴ",
              "تى",
              "ﱵ",
              "تي",
              "ﱶ",
              "ثر",
              "ﱷ",
              "ثز",
              "ﱸ",
              "ثم",
              "ﱹ",
              "ثن",
              "ﱺ",
              "ثى",
              "ﱻ",
              "ثي",
              "ﱼ",
              "فى",
              "ﱽ",
              "في",
              "ﱾ",
              "قى",
              "ﱿ",
              "قي",
              "ﲀ",
              "كا",
              "ﲁ",
              "كل",
              "ﲂ",
              "كم",
              "ﲃ",
              "كى",
              "ﲄ",
              "كي",
              "ﲅ",
              "لم",
              "ﲆ",
              "لى",
              "ﲇ",
              "لي",
              "ﲈ",
              "ما",
              "ﲉ",
              "مم",
              "ﲊ",
              "نر",
              "ﲋ",
              "نز",
              "ﲌ",
              "نم",
              "ﲍ",
              "نن",
              "ﲎ",
              "نى",
              "ﲏ",
              "ني",
              "ﲐ",
              "ىٰ",
              "ﲑ",
              "ير",
              "ﲒ",
              "يز",
              "ﲓ",
              "يم",
              "ﲔ",
              "ين",
              "ﲕ",
              "يى",
              "ﲖ",
              "يي",
              "ﲗ",
              "ئج",
              "ﲘ",
              "ئح",
              "ﲙ",
              "ئخ",
              "ﲚ",
              "ئم",
              "ﲛ",
              "ئه",
              "ﲜ",
              "بج",
              "ﲝ",
              "بح",
              "ﲞ",
              "بخ",
              "ﲟ",
              "بم",
              "ﲠ",
              "به",
              "ﲡ",
              "تج",
              "ﲢ",
              "تح",
              "ﲣ",
              "تخ",
              "ﲤ",
              "تم",
              "ﲥ",
              "ته",
              "ﲦ",
              "ثم",
              "ﲧ",
              "جح",
              "ﲨ",
              "جم",
              "ﲩ",
              "حج",
              "ﲪ",
              "حم",
              "ﲫ",
              "خج",
              "ﲬ",
              "خم",
              "ﲭ",
              "سج",
              "ﲮ",
              "سح",
              "ﲯ",
              "سخ",
              "ﲰ",
              "سم",
              "ﲱ",
              "صح",
              "ﲲ",
              "صخ",
              "ﲳ",
              "صم",
              "ﲴ",
              "ضج",
              "ﲵ",
              "ضح",
              "ﲶ",
              "ضخ",
              "ﲷ",
              "ضم",
              "ﲸ",
              "طح",
              "ﲹ",
              "ظم",
              "ﲺ",
              "عج",
              "ﲻ",
              "عم",
              "ﲼ",
              "غج",
              "ﲽ",
              "غم",
              "ﲾ",
              "فج",
              "ﲿ",
              "فح",
              "ﳀ",
              "فخ",
              "ﳁ",
              "فم",
              "ﳂ",
              "قح",
              "ﳃ",
              "قم",
              "ﳄ",
              "كج",
              "ﳅ",
              "كح",
              "ﳆ",
              "كخ",
              "ﳇ",
              "كل",
              "ﳈ",
              "كم",
              "ﳉ",
              "لج",
              "ﳊ",
              "لح",
              "ﳋ",
              "لخ",
              "ﳌ",
              "لم",
              "ﳍ",
              "له",
              "ﳎ",
              "مج",
              "ﳏ",
              "مح",
              "ﳐ",
              "مخ",
              "ﳑ",
              "مم",
              "ﳒ",
              "نج",
              "ﳓ",
              "نح",
              "ﳔ",
              "نخ",
              "ﳕ",
              "نم",
              "ﳖ",
              "نه",
              "ﳗ",
              "هج",
              "ﳘ",
              "هم",
              "ﳙ",
              "هٰ",
              "ﳚ",
              "يج",
              "ﳛ",
              "يح",
              "ﳜ",
              "يخ",
              "ﳝ",
              "يم",
              "ﳞ",
              "يه",
              "ﳟ",
              "ئم",
              "ﳠ",
              "ئه",
              "ﳡ",
              "بم",
              "ﳢ",
              "به",
              "ﳣ",
              "تم",
              "ﳤ",
              "ته",
              "ﳥ",
              "ثم",
              "ﳦ",
              "ثه",
              "ﳧ",
              "سم",
              "ﳨ",
              "سه",
              "ﳩ",
              "شم",
              "ﳪ",
              "شه",
              "ﳫ",
              "كل",
              "ﳬ",
              "كم",
              "ﳭ",
              "لم",
              "ﳮ",
              "نم",
              "ﳯ",
              "نه",
              "ﳰ",
              "يم",
              "ﳱ",
              "يه",
              "ﳲ",
              "ـَّ",
              "ﳳ",
              "ـُّ",
              "ﳴ",
              "ـِّ",
              "ﳵ",
              "طى",
              "ﳶ",
              "طي",
              "ﳷ",
              "عى",
              "ﳸ",
              "عي",
              "ﳹ",
              "غى",
              "ﳺ",
              "غي",
              "ﳻ",
              "سى",
              "ﳼ",
              "سي",
              "ﳽ",
              "شى",
              "ﳾ",
              "شي",
              "ﳿ",
              "حى",
              "ﴀ",
              "حي",
              "ﴁ",
              "جى",
              "ﴂ",
              "جي",
              "ﴃ",
              "خى",
              "ﴄ",
              "خي",
              "ﴅ",
              "صى",
              "ﴆ",
              "صي",
              "ﴇ",
              "ضى",
              "ﴈ",
              "ضي",
              "ﴉ",
              "شج",
              "ﴊ",
              "شح",
              "ﴋ",
              "شخ",
              "ﴌ",
              "شم",
              "ﴍ",
              "شر",
              "ﴎ",
              "سر",
              "ﴏ",
              "صر",
              "ﴐ",
              "ضر",
              "ﴑ",
              "طى",
              "ﴒ",
              "طي",
              "ﴓ",
              "عى",
              "ﴔ",
              "عي",
              "ﴕ",
              "غى",
              "ﴖ",
              "غي",
              "ﴗ",
              "سى",
              "ﴘ",
              "سي",
              "ﴙ",
              "شى",
              "ﴚ",
              "شي",
              "ﴛ",
              "حى",
              "ﴜ",
              "حي",
              "ﴝ",
              "جى",
              "ﴞ",
              "جي",
              "ﴟ",
              "خى",
              "ﴠ",
              "خي",
              "ﴡ",
              "صى",
              "ﴢ",
              "صي",
              "ﴣ",
              "ضى",
              "ﴤ",
              "ضي",
              "ﴥ",
              "شج",
              "ﴦ",
              "شح",
              "ﴧ",
              "شخ",
              "ﴨ",
              "شم",
              "ﴩ",
              "شر",
              "ﴪ",
              "سر",
              "ﴫ",
              "صر",
              "ﴬ",
              "ضر",
              "ﴭ",
              "شج",
              "ﴮ",
              "شح",
              "ﴯ",
              "شخ",
              "ﴰ",
              "شم",
              "ﴱ",
              "سه",
              "ﴲ",
              "شه",
              "ﴳ",
              "طم",
              "ﴴ",
              "سج",
              "ﴵ",
              "سح",
              "ﴶ",
              "سخ",
              "ﴷ",
              "شج",
              "ﴸ",
              "شح",
              "ﴹ",
              "شخ",
              "ﴺ",
              "طم",
              "ﴻ",
              "ظم",
              "ﴼ",
              "اً",
              "ﴽ",
              "اً",
              "ﵐ",
              "تجم",
              "ﵑ",
              "تحج",
              "ﵒ",
              "تحج",
              "ﵓ",
              "تحم",
              "ﵔ",
              "تخم",
              "ﵕ",
              "تمج",
              "ﵖ",
              "تمح",
              "ﵗ",
              "تمخ",
              "ﵘ",
              "جمح",
              "ﵙ",
              "جمح",
              "ﵚ",
              "حمي",
              "ﵛ",
              "حمى",
              "ﵜ",
              "سحج",
              "ﵝ",
              "سجح",
              "ﵞ",
              "سجى",
              "ﵟ",
              "سمح",
              "ﵠ",
              "سمح",
              "ﵡ",
              "سمج",
              "ﵢ",
              "سمم",
              "ﵣ",
              "سمم",
              "ﵤ",
              "صحح",
              "ﵥ",
              "صحح",
              "ﵦ",
              "صمم",
              "ﵧ",
              "شحم",
              "ﵨ",
              "شحم",
              "ﵩ",
              "شجي",
              "ﵪ",
              "شمخ",
              "ﵫ",
              "شمخ",
              "ﵬ",
              "شمم",
              "ﵭ",
              "شمم",
              "ﵮ",
              "ضحى",
              "ﵯ",
              "ضخم",
              "ﵰ",
              "ضخم",
              "ﵱ",
              "طمح",
              "ﵲ",
              "طمح",
              "ﵳ",
              "طمم",
              "ﵴ",
              "طمي",
              "ﵵ",
              "عجم",
              "ﵶ",
              "عمم",
              "ﵷ",
              "عمم",
              "ﵸ",
              "عمى",
              "ﵹ",
              "غمم",
              "ﵺ",
              "غمي",
              "ﵻ",
              "غمى",
              "ﵼ",
              "فخم",
              "ﵽ",
              "فخم",
              "ﵾ",
              "قمح",
              "ﵿ",
              "قمم",
              "ﶀ",
              "لحم",
              "ﶁ",
              "لحي",
              "ﶂ",
              "لحى",
              "ﶃ",
              "لجج",
              "ﶄ",
              "لجج",
              "ﶅ",
              "لخم",
              "ﶆ",
              "لخم",
              "ﶇ",
              "لمح",
              "ﶈ",
              "لمح",
              "ﶉ",
              "محج",
              "ﶊ",
              "محم",
              "ﶋ",
              "محي",
              "ﶌ",
              "مجح",
              "ﶍ",
              "مجم",
              "ﶎ",
              "مخج",
              "ﶏ",
              "مخم",
              "ﶒ",
              "مجخ",
              "ﶓ",
              "همج",
              "ﶔ",
              "همم",
              "ﶕ",
              "نحم",
              "ﶖ",
              "نحى",
              "ﶗ",
              "نجم",
              "ﶘ",
              "نجم",
              "ﶙ",
              "نجى",
              "ﶚ",
              "نمي",
              "ﶛ",
              "نمى",
              "ﶜ",
              "يمم",
              "ﶝ",
              "يمم",
              "ﶞ",
              "بخي",
              "ﶟ",
              "تجي",
              "ﶠ",
              "تجى",
              "ﶡ",
              "تخي",
              "ﶢ",
              "تخى",
              "ﶣ",
              "تمي",
              "ﶤ",
              "تمى",
              "ﶥ",
              "جمي",
              "ﶦ",
              "جحى",
              "ﶧ",
              "جمى",
              "ﶨ",
              "سخى",
              "ﶩ",
              "صحي",
              "ﶪ",
              "شحي",
              "ﶫ",
              "ضحي",
              "ﶬ",
              "لجي",
              "ﶭ",
              "لمي",
              "ﶮ",
              "يحي",
              "ﶯ",
              "يجي",
              "ﶰ",
              "يمي",
              "ﶱ",
              "ممي",
              "ﶲ",
              "قمي",
              "ﶳ",
              "نحي",
              "ﶴ",
              "قمح",
              "ﶵ",
              "لحم",
              "ﶶ",
              "عمي",
              "ﶷ",
              "كمي",
              "ﶸ",
              "نجح",
              "ﶹ",
              "مخي",
              "ﶺ",
              "لجم",
              "ﶻ",
              "كمم",
              "ﶼ",
              "لجم",
              "ﶽ",
              "نجح",
              "ﶾ",
              "جحي",
              "ﶿ",
              "حجي",
              "ﷀ",
              "مجي",
              "ﷁ",
              "فمي",
              "ﷂ",
              "بحي",
              "ﷃ",
              "كمم",
              "ﷄ",
              "عجم",
              "ﷅ",
              "صمم",
              "ﷆ",
              "سخي",
              "ﷇ",
              "نجي",
              "﹉",
              "‾",
              "﹊",
              "‾",
              "﹋",
              "‾",
              "﹌",
              "‾",
              "﹍",
              "_",
              "﹎",
              "_",
              "﹏",
              "_",
              "ﺀ",
              "ء",
              "ﺁ",
              "آ",
              "ﺂ",
              "آ",
              "ﺃ",
              "أ",
              "ﺄ",
              "أ",
              "ﺅ",
              "ؤ",
              "ﺆ",
              "ؤ",
              "ﺇ",
              "إ",
              "ﺈ",
              "إ",
              "ﺉ",
              "ئ",
              "ﺊ",
              "ئ",
              "ﺋ",
              "ئ",
              "ﺌ",
              "ئ",
              "ﺍ",
              "ا",
              "ﺎ",
              "ا",
              "ﺏ",
              "ب",
              "ﺐ",
              "ب",
              "ﺑ",
              "ب",
              "ﺒ",
              "ب",
              "ﺓ",
              "ة",
              "ﺔ",
              "ة",
              "ﺕ",
              "ت",
              "ﺖ",
              "ت",
              "ﺗ",
              "ت",
              "ﺘ",
              "ت",
              "ﺙ",
              "ث",
              "ﺚ",
              "ث",
              "ﺛ",
              "ث",
              "ﺜ",
              "ث",
              "ﺝ",
              "ج",
              "ﺞ",
              "ج",
              "ﺟ",
              "ج",
              "ﺠ",
              "ج",
              "ﺡ",
              "ح",
              "ﺢ",
              "ح",
              "ﺣ",
              "ح",
              "ﺤ",
              "ح",
              "ﺥ",
              "خ",
              "ﺦ",
              "خ",
              "ﺧ",
              "خ",
              "ﺨ",
              "خ",
              "ﺩ",
              "د",
              "ﺪ",
              "د",
              "ﺫ",
              "ذ",
              "ﺬ",
              "ذ",
              "ﺭ",
              "ر",
              "ﺮ",
              "ر",
              "ﺯ",
              "ز",
              "ﺰ",
              "ز",
              "ﺱ",
              "س",
              "ﺲ",
              "س",
              "ﺳ",
              "س",
              "ﺴ",
              "س",
              "ﺵ",
              "ش",
              "ﺶ",
              "ش",
              "ﺷ",
              "ش",
              "ﺸ",
              "ش",
              "ﺹ",
              "ص",
              "ﺺ",
              "ص",
              "ﺻ",
              "ص",
              "ﺼ",
              "ص",
              "ﺽ",
              "ض",
              "ﺾ",
              "ض",
              "ﺿ",
              "ض",
              "ﻀ",
              "ض",
              "ﻁ",
              "ط",
              "ﻂ",
              "ط",
              "ﻃ",
              "ط",
              "ﻄ",
              "ط",
              "ﻅ",
              "ظ",
              "ﻆ",
              "ظ",
              "ﻇ",
              "ظ",
              "ﻈ",
              "ظ",
              "ﻉ",
              "ع",
              "ﻊ",
              "ع",
              "ﻋ",
              "ع",
              "ﻌ",
              "ع",
              "ﻍ",
              "غ",
              "ﻎ",
              "غ",
              "ﻏ",
              "غ",
              "ﻐ",
              "غ",
              "ﻑ",
              "ف",
              "ﻒ",
              "ف",
              "ﻓ",
              "ف",
              "ﻔ",
              "ف",
              "ﻕ",
              "ق",
              "ﻖ",
              "ق",
              "ﻗ",
              "ق",
              "ﻘ",
              "ق",
              "ﻙ",
              "ك",
              "ﻚ",
              "ك",
              "ﻛ",
              "ك",
              "ﻜ",
              "ك",
              "ﻝ",
              "ل",
              "ﻞ",
              "ل",
              "ﻟ",
              "ل",
              "ﻠ",
              "ل",
              "ﻡ",
              "م",
              "ﻢ",
              "م",
              "ﻣ",
              "م",
              "ﻤ",
              "م",
              "ﻥ",
              "ن",
              "ﻦ",
              "ن",
              "ﻧ",
              "ن",
              "ﻨ",
              "ن",
              "ﻩ",
              "ه",
              "ﻪ",
              "ه",
              "ﻫ",
              "ه",
              "ﻬ",
              "ه",
              "ﻭ",
              "و",
              "ﻮ",
              "و",
              "ﻯ",
              "ى",
              "ﻰ",
              "ى",
              "ﻱ",
              "ي",
              "ﻲ",
              "ي",
              "ﻳ",
              "ي",
              "ﻴ",
              "ي",
              "ﻵ",
              "لآ",
              "ﻶ",
              "لآ",
              "ﻷ",
              "لأ",
              "ﻸ",
              "لأ",
              "ﻹ",
              "لإ",
              "ﻺ",
              "لإ",
              "ﻻ",
              "لا",
              "ﻼ",
              "لا"
            ];
          });
          function g(x) {
            const f = x.length;
            if (f <= 1 || !r(x.charCodeAt(0)))
              return x;
            const m = [];
            for (let C = f - 1; C >= 0; C--)
              m.push(x[C]);
            return m.join("");
          }
          const d = new RegExp("^(\\s)|(\\p{Mn})|(\\p{Cf})$", "u"), c = /* @__PURE__ */ new Map();
          function n(x) {
            const f = c.get(x);
            if (f)
              return f;
            const m = x.match(d), C = {
              isWhitespace: !!(m && m[1]),
              isZeroWidthDiacritic: !!(m && m[2]),
              isInvisibleFormatMark: !!(m && m[3])
            };
            return c.set(x, C), C;
          }
          function o() {
            c.clear();
          }
        },
        /* 41 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.getSerifFonts = u.getNonStdFontMap = u.getGlyphMapForStandardFonts = u.getFontNameToFileMap = void 0, u.getStandardFontName = c, u.getSymbolsFonts = u.getSupplementalGlyphMapForCalibri = u.getSupplementalGlyphMapForArialBlack = u.getStdFontMap = void 0;
          var t = P(6), i = P(38);
          const v = (0, t.getLookupTableFactory)(function(n) {
            n["Times-Roman"] = "Times-Roman", n.Helvetica = "Helvetica", n.Courier = "Courier", n.Symbol = "Symbol", n["Times-Bold"] = "Times-Bold", n["Helvetica-Bold"] = "Helvetica-Bold", n["Courier-Bold"] = "Courier-Bold", n.ZapfDingbats = "ZapfDingbats", n["Times-Italic"] = "Times-Italic", n["Helvetica-Oblique"] = "Helvetica-Oblique", n["Courier-Oblique"] = "Courier-Oblique", n["Times-BoldItalic"] = "Times-BoldItalic", n["Helvetica-BoldOblique"] = "Helvetica-BoldOblique", n["Courier-BoldOblique"] = "Courier-BoldOblique", n.ArialNarrow = "Helvetica", n["ArialNarrow-Bold"] = "Helvetica-Bold", n["ArialNarrow-BoldItalic"] = "Helvetica-BoldOblique", n["ArialNarrow-Italic"] = "Helvetica-Oblique", n.ArialBlack = "Helvetica", n["ArialBlack-Bold"] = "Helvetica-Bold", n["ArialBlack-BoldItalic"] = "Helvetica-BoldOblique", n["ArialBlack-Italic"] = "Helvetica-Oblique", n["Arial-Black"] = "Helvetica", n["Arial-Black-Bold"] = "Helvetica-Bold", n["Arial-Black-BoldItalic"] = "Helvetica-BoldOblique", n["Arial-Black-Italic"] = "Helvetica-Oblique", n.Arial = "Helvetica", n["Arial-Bold"] = "Helvetica-Bold", n["Arial-BoldItalic"] = "Helvetica-BoldOblique", n["Arial-Italic"] = "Helvetica-Oblique", n.ArialMT = "Helvetica", n["Arial-BoldItalicMT"] = "Helvetica-BoldOblique", n["Arial-BoldMT"] = "Helvetica-Bold", n["Arial-ItalicMT"] = "Helvetica-Oblique", n.ArialUnicodeMS = "Helvetica", n["ArialUnicodeMS-Bold"] = "Helvetica-Bold", n["ArialUnicodeMS-BoldItalic"] = "Helvetica-BoldOblique", n["ArialUnicodeMS-Italic"] = "Helvetica-Oblique", n["Courier-BoldItalic"] = "Courier-BoldOblique", n["Courier-Italic"] = "Courier-Oblique", n.CourierNew = "Courier", n["CourierNew-Bold"] = "Courier-Bold", n["CourierNew-BoldItalic"] = "Courier-BoldOblique", n["CourierNew-Italic"] = "Courier-Oblique", n["CourierNewPS-BoldItalicMT"] = "Courier-BoldOblique", n["CourierNewPS-BoldMT"] = "Courier-Bold", n["CourierNewPS-ItalicMT"] = "Courier-Oblique", n.CourierNewPSMT = "Courier", n["Helvetica-BoldItalic"] = "Helvetica-BoldOblique", n["Helvetica-Italic"] = "Helvetica-Oblique", n["Symbol-Bold"] = "Symbol", n["Symbol-BoldItalic"] = "Symbol", n["Symbol-Italic"] = "Symbol", n.TimesNewRoman = "Times-Roman", n["TimesNewRoman-Bold"] = "Times-Bold", n["TimesNewRoman-BoldItalic"] = "Times-BoldItalic", n["TimesNewRoman-Italic"] = "Times-Italic", n.TimesNewRomanPS = "Times-Roman", n["TimesNewRomanPS-Bold"] = "Times-Bold", n["TimesNewRomanPS-BoldItalic"] = "Times-BoldItalic", n["TimesNewRomanPS-BoldItalicMT"] = "Times-BoldItalic", n["TimesNewRomanPS-BoldMT"] = "Times-Bold", n["TimesNewRomanPS-Italic"] = "Times-Italic", n["TimesNewRomanPS-ItalicMT"] = "Times-Italic", n.TimesNewRomanPSMT = "Times-Roman", n["TimesNewRomanPSMT-Bold"] = "Times-Bold", n["TimesNewRomanPSMT-BoldItalic"] = "Times-BoldItalic", n["TimesNewRomanPSMT-Italic"] = "Times-Italic";
          });
          u.getStdFontMap = v;
          const a = (0, t.getLookupTableFactory)(function(n) {
            n.Courier = "FoxitFixed.pfb", n["Courier-Bold"] = "FoxitFixedBold.pfb", n["Courier-BoldOblique"] = "FoxitFixedBoldItalic.pfb", n["Courier-Oblique"] = "FoxitFixedItalic.pfb", n.Helvetica = "FoxitSans.pfb", n["Helvetica-Bold"] = "FoxitSansBold.pfb", n["Helvetica-BoldOblique"] = "FoxitSansBoldItalic.pfb", n["Helvetica-Oblique"] = "FoxitSansItalic.pfb", n["Times-Roman"] = "FoxitSerif.pfb", n["Times-Bold"] = "FoxitSerifBold.pfb", n["Times-BoldItalic"] = "FoxitSerifBoldItalic.pfb", n["Times-Italic"] = "FoxitSerifItalic.pfb", n.Symbol = "FoxitSymbol.pfb", n.ZapfDingbats = "FoxitDingbats.pfb", n["LiberationSans-Regular"] = "LiberationSans-Regular.ttf", n["LiberationSans-Bold"] = "LiberationSans-Bold.ttf", n["LiberationSans-Italic"] = "LiberationSans-Italic.ttf", n["LiberationSans-BoldItalic"] = "LiberationSans-BoldItalic.ttf";
          });
          u.getFontNameToFileMap = a;
          const e = (0, t.getLookupTableFactory)(function(n) {
            n.Calibri = "Helvetica", n["Calibri-Bold"] = "Helvetica-Bold", n["Calibri-BoldItalic"] = "Helvetica-BoldOblique", n["Calibri-Italic"] = "Helvetica-Oblique", n.CenturyGothic = "Helvetica", n["CenturyGothic-Bold"] = "Helvetica-Bold", n["CenturyGothic-BoldItalic"] = "Helvetica-BoldOblique", n["CenturyGothic-Italic"] = "Helvetica-Oblique", n.ComicSansMS = "Comic Sans MS", n["ComicSansMS-Bold"] = "Comic Sans MS-Bold", n["ComicSansMS-BoldItalic"] = "Comic Sans MS-BoldItalic", n["ComicSansMS-Italic"] = "Comic Sans MS-Italic", n["ItcSymbol-Bold"] = "Helvetica-Bold", n["ItcSymbol-BoldItalic"] = "Helvetica-BoldOblique", n["ItcSymbol-Book"] = "Helvetica", n["ItcSymbol-BookItalic"] = "Helvetica-Oblique", n["ItcSymbol-Medium"] = "Helvetica", n["ItcSymbol-MediumItalic"] = "Helvetica-Oblique", n.LucidaConsole = "Courier", n["LucidaConsole-Bold"] = "Courier-Bold", n["LucidaConsole-BoldItalic"] = "Courier-BoldOblique", n["LucidaConsole-Italic"] = "Courier-Oblique", n["LucidaSans-Demi"] = "Helvetica-Bold", n["MS-Gothic"] = "MS Gothic", n["MS-Gothic-Bold"] = "MS Gothic-Bold", n["MS-Gothic-BoldItalic"] = "MS Gothic-BoldItalic", n["MS-Gothic-Italic"] = "MS Gothic-Italic", n["MS-Mincho"] = "MS Mincho", n["MS-Mincho-Bold"] = "MS Mincho-Bold", n["MS-Mincho-BoldItalic"] = "MS Mincho-BoldItalic", n["MS-Mincho-Italic"] = "MS Mincho-Italic", n["MS-PGothic"] = "MS PGothic", n["MS-PGothic-Bold"] = "MS PGothic-Bold", n["MS-PGothic-BoldItalic"] = "MS PGothic-BoldItalic", n["MS-PGothic-Italic"] = "MS PGothic-Italic", n["MS-PMincho"] = "MS PMincho", n["MS-PMincho-Bold"] = "MS PMincho-Bold", n["MS-PMincho-BoldItalic"] = "MS PMincho-BoldItalic", n["MS-PMincho-Italic"] = "MS PMincho-Italic", n.NuptialScript = "Times-Italic", n.SegoeUISymbol = "Helvetica", n.Wingdings = "ZapfDingbats", n["Wingdings-Regular"] = "ZapfDingbats";
          });
          u.getNonStdFontMap = e;
          const y = (0, t.getLookupTableFactory)(function(n) {
            n["Adobe Jenson"] = !0, n["Adobe Text"] = !0, n.Albertus = !0, n.Aldus = !0, n.Alexandria = !0, n.Algerian = !0, n["American Typewriter"] = !0, n.Antiqua = !0, n.Apex = !0, n.Arno = !0, n.Aster = !0, n.Aurora = !0, n.Baskerville = !0, n.Bell = !0, n.Bembo = !0, n["Bembo Schoolbook"] = !0, n.Benguiat = !0, n["Berkeley Old Style"] = !0, n["Bernhard Modern"] = !0, n["Berthold City"] = !0, n.Bodoni = !0, n["Bauer Bodoni"] = !0, n["Book Antiqua"] = !0, n.Bookman = !0, n["Bordeaux Roman"] = !0, n["Californian FB"] = !0, n.Calisto = !0, n.Calvert = !0, n.Capitals = !0, n.Cambria = !0, n.Cartier = !0, n.Caslon = !0, n.Catull = !0, n.Centaur = !0, n["Century Old Style"] = !0, n["Century Schoolbook"] = !0, n.Chaparral = !0, n["Charis SIL"] = !0, n.Cheltenham = !0, n["Cholla Slab"] = !0, n.Clarendon = !0, n.Clearface = !0, n.Cochin = !0, n.Colonna = !0, n["Computer Modern"] = !0, n["Concrete Roman"] = !0, n.Constantia = !0, n["Cooper Black"] = !0, n.Corona = !0, n.Ecotype = !0, n.Egyptienne = !0, n.Elephant = !0, n.Excelsior = !0, n.Fairfield = !0, n["FF Scala"] = !0, n.Folkard = !0, n.Footlight = !0, n.FreeSerif = !0, n["Friz Quadrata"] = !0, n.Garamond = !0, n.Gentium = !0, n.Georgia = !0, n.Gloucester = !0, n["Goudy Old Style"] = !0, n["Goudy Schoolbook"] = !0, n["Goudy Pro Font"] = !0, n.Granjon = !0, n["Guardian Egyptian"] = !0, n.Heather = !0, n.Hercules = !0, n["High Tower Text"] = !0, n.Hiroshige = !0, n["Hoefler Text"] = !0, n["Humana Serif"] = !0, n.Imprint = !0, n["Ionic No. 5"] = !0, n.Janson = !0, n.Joanna = !0, n.Korinna = !0, n.Lexicon = !0, n.LiberationSerif = !0, n["Liberation Serif"] = !0, n["Linux Libertine"] = !0, n.Literaturnaya = !0, n.Lucida = !0, n["Lucida Bright"] = !0, n.Melior = !0, n.Memphis = !0, n.Miller = !0, n.Minion = !0, n.Modern = !0, n["Mona Lisa"] = !0, n["Mrs Eaves"] = !0, n["MS Serif"] = !0, n["Museo Slab"] = !0, n["New York"] = !0, n["Nimbus Roman"] = !0, n["NPS Rawlinson Roadway"] = !0, n.NuptialScript = !0, n.Palatino = !0, n.Perpetua = !0, n.Plantin = !0, n["Plantin Schoolbook"] = !0, n.Playbill = !0, n["Poor Richard"] = !0, n["Rawlinson Roadway"] = !0, n.Renault = !0, n.Requiem = !0, n.Rockwell = !0, n.Roman = !0, n["Rotis Serif"] = !0, n.Sabon = !0, n.Scala = !0, n.Seagull = !0, n.Sistina = !0, n.Souvenir = !0, n.STIX = !0, n["Stone Informal"] = !0, n["Stone Serif"] = !0, n.Sylfaen = !0, n.Times = !0, n.Trajan = !0, n.Trinité = !0, n["Trump Mediaeval"] = !0, n.Utopia = !0, n["Vale Type"] = !0, n["Bitstream Vera"] = !0, n["Vera Serif"] = !0, n.Versailles = !0, n.Wanted = !0, n.Weiss = !0, n["Wide Latin"] = !0, n.Windsor = !0, n.XITS = !0;
          });
          u.getSerifFonts = y;
          const r = (0, t.getLookupTableFactory)(function(n) {
            n.Dingbats = !0, n.Symbol = !0, n.ZapfDingbats = !0;
          });
          u.getSymbolsFonts = r;
          const h = (0, t.getLookupTableFactory)(function(n) {
            n[2] = 10, n[3] = 32, n[4] = 33, n[5] = 34, n[6] = 35, n[7] = 36, n[8] = 37, n[9] = 38, n[10] = 39, n[11] = 40, n[12] = 41, n[13] = 42, n[14] = 43, n[15] = 44, n[16] = 45, n[17] = 46, n[18] = 47, n[19] = 48, n[20] = 49, n[21] = 50, n[22] = 51, n[23] = 52, n[24] = 53, n[25] = 54, n[26] = 55, n[27] = 56, n[28] = 57, n[29] = 58, n[30] = 894, n[31] = 60, n[32] = 61, n[33] = 62, n[34] = 63, n[35] = 64, n[36] = 65, n[37] = 66, n[38] = 67, n[39] = 68, n[40] = 69, n[41] = 70, n[42] = 71, n[43] = 72, n[44] = 73, n[45] = 74, n[46] = 75, n[47] = 76, n[48] = 77, n[49] = 78, n[50] = 79, n[51] = 80, n[52] = 81, n[53] = 82, n[54] = 83, n[55] = 84, n[56] = 85, n[57] = 86, n[58] = 87, n[59] = 88, n[60] = 89, n[61] = 90, n[62] = 91, n[63] = 92, n[64] = 93, n[65] = 94, n[66] = 95, n[67] = 96, n[68] = 97, n[69] = 98, n[70] = 99, n[71] = 100, n[72] = 101, n[73] = 102, n[74] = 103, n[75] = 104, n[76] = 105, n[77] = 106, n[78] = 107, n[79] = 108, n[80] = 109, n[81] = 110, n[82] = 111, n[83] = 112, n[84] = 113, n[85] = 114, n[86] = 115, n[87] = 116, n[88] = 117, n[89] = 118, n[90] = 119, n[91] = 120, n[92] = 121, n[93] = 122, n[94] = 123, n[95] = 124, n[96] = 125, n[97] = 126, n[98] = 196, n[99] = 197, n[100] = 199, n[101] = 201, n[102] = 209, n[103] = 214, n[104] = 220, n[105] = 225, n[106] = 224, n[107] = 226, n[108] = 228, n[109] = 227, n[110] = 229, n[111] = 231, n[112] = 233, n[113] = 232, n[114] = 234, n[115] = 235, n[116] = 237, n[117] = 236, n[118] = 238, n[119] = 239, n[120] = 241, n[121] = 243, n[122] = 242, n[123] = 244, n[124] = 246, n[125] = 245, n[126] = 250, n[127] = 249, n[128] = 251, n[129] = 252, n[130] = 8224, n[131] = 176, n[132] = 162, n[133] = 163, n[134] = 167, n[135] = 8226, n[136] = 182, n[137] = 223, n[138] = 174, n[139] = 169, n[140] = 8482, n[141] = 180, n[142] = 168, n[143] = 8800, n[144] = 198, n[145] = 216, n[146] = 8734, n[147] = 177, n[148] = 8804, n[149] = 8805, n[150] = 165, n[151] = 181, n[152] = 8706, n[153] = 8721, n[154] = 8719, n[156] = 8747, n[157] = 170, n[158] = 186, n[159] = 8486, n[160] = 230, n[161] = 248, n[162] = 191, n[163] = 161, n[164] = 172, n[165] = 8730, n[166] = 402, n[167] = 8776, n[168] = 8710, n[169] = 171, n[170] = 187, n[171] = 8230, n[200] = 193, n[203] = 205, n[210] = 218, n[223] = 711, n[224] = 321, n[225] = 322, n[226] = 352, n[227] = 353, n[228] = 381, n[229] = 382, n[233] = 221, n[234] = 253, n[252] = 263, n[253] = 268, n[254] = 269, n[258] = 258, n[260] = 260, n[261] = 261, n[265] = 280, n[266] = 281, n[267] = 282, n[268] = 283, n[269] = 313, n[275] = 323, n[276] = 324, n[278] = 328, n[283] = 344, n[284] = 345, n[285] = 346, n[286] = 347, n[292] = 367, n[295] = 377, n[296] = 378, n[298] = 380, n[305] = 963, n[306] = 964, n[307] = 966, n[308] = 8215, n[309] = 8252, n[310] = 8319, n[311] = 8359, n[312] = 8592, n[313] = 8593, n[337] = 9552, n[493] = 1039, n[494] = 1040, n[672] = 1488, n[673] = 1489, n[674] = 1490, n[675] = 1491, n[676] = 1492, n[677] = 1493, n[678] = 1494, n[679] = 1495, n[680] = 1496, n[681] = 1497, n[682] = 1498, n[683] = 1499, n[684] = 1500, n[685] = 1501, n[686] = 1502, n[687] = 1503, n[688] = 1504, n[689] = 1505, n[690] = 1506, n[691] = 1507, n[692] = 1508, n[693] = 1509, n[694] = 1510, n[695] = 1511, n[696] = 1512, n[697] = 1513, n[698] = 1514, n[705] = 1524, n[706] = 8362, n[710] = 64288, n[711] = 64298, n[759] = 1617, n[761] = 1776, n[763] = 1778, n[775] = 1652, n[777] = 1764, n[778] = 1780, n[779] = 1781, n[780] = 1782, n[782] = 771, n[783] = 64726, n[786] = 8363, n[788] = 8532, n[790] = 768, n[791] = 769, n[792] = 768, n[795] = 803, n[797] = 64336, n[798] = 64337, n[799] = 64342, n[800] = 64343, n[801] = 64344, n[802] = 64345, n[803] = 64362, n[804] = 64363, n[805] = 64364, n[2424] = 7821, n[2425] = 7822, n[2426] = 7823, n[2427] = 7824, n[2428] = 7825, n[2429] = 7826, n[2430] = 7827, n[2433] = 7682, n[2678] = 8045, n[2679] = 8046, n[2830] = 1552, n[2838] = 686, n[2840] = 751, n[2842] = 753, n[2843] = 754, n[2844] = 755, n[2846] = 757, n[2856] = 767, n[2857] = 848, n[2858] = 849, n[2862] = 853, n[2863] = 854, n[2864] = 855, n[2865] = 861, n[2866] = 862, n[2906] = 7460, n[2908] = 7462, n[2909] = 7463, n[2910] = 7464, n[2912] = 7466, n[2913] = 7467, n[2914] = 7468, n[2916] = 7470, n[2917] = 7471, n[2918] = 7472, n[2920] = 7474, n[2921] = 7475, n[2922] = 7476, n[2924] = 7478, n[2925] = 7479, n[2926] = 7480, n[2928] = 7482, n[2929] = 7483, n[2930] = 7484, n[2932] = 7486, n[2933] = 7487, n[2934] = 7488, n[2936] = 7490, n[2937] = 7491, n[2938] = 7492, n[2940] = 7494, n[2941] = 7495, n[2942] = 7496, n[2944] = 7498, n[2946] = 7500, n[2948] = 7502, n[2950] = 7504, n[2951] = 7505, n[2952] = 7506, n[2954] = 7508, n[2955] = 7509, n[2956] = 7510, n[2958] = 7512, n[2959] = 7513, n[2960] = 7514, n[2962] = 7516, n[2963] = 7517, n[2964] = 7518, n[2966] = 7520, n[2967] = 7521, n[2968] = 7522, n[2970] = 7524, n[2971] = 7525, n[2972] = 7526, n[2974] = 7528, n[2975] = 7529, n[2976] = 7530, n[2978] = 1537, n[2979] = 1538, n[2980] = 1539, n[2982] = 1549, n[2983] = 1551, n[2984] = 1552, n[2986] = 1554, n[2987] = 1555, n[2988] = 1556, n[2990] = 1623, n[2991] = 1624, n[2995] = 1775, n[2999] = 1791, n[3002] = 64290, n[3003] = 64291, n[3004] = 64292, n[3006] = 64294, n[3007] = 64295, n[3008] = 64296, n[3011] = 1900, n[3014] = 8223, n[3015] = 8244, n[3017] = 7532, n[3018] = 7533, n[3019] = 7534, n[3075] = 7590, n[3076] = 7591, n[3079] = 7594, n[3080] = 7595, n[3083] = 7598, n[3084] = 7599, n[3087] = 7602, n[3088] = 7603, n[3091] = 7606, n[3092] = 7607, n[3095] = 7610, n[3096] = 7611, n[3099] = 7614, n[3100] = 7615, n[3103] = 7618, n[3104] = 7619, n[3107] = 8337, n[3108] = 8338, n[3116] = 1884, n[3119] = 1885, n[3120] = 1885, n[3123] = 1886, n[3124] = 1886, n[3127] = 1887, n[3128] = 1887, n[3131] = 1888, n[3132] = 1888, n[3135] = 1889, n[3136] = 1889, n[3139] = 1890, n[3140] = 1890, n[3143] = 1891, n[3144] = 1891, n[3147] = 1892, n[3148] = 1892, n[3153] = 580, n[3154] = 581, n[3157] = 584, n[3158] = 585, n[3161] = 588, n[3162] = 589, n[3165] = 891, n[3166] = 892, n[3169] = 1274, n[3170] = 1275, n[3173] = 1278, n[3174] = 1279, n[3181] = 7622, n[3182] = 7623, n[3282] = 11799, n[3316] = 578, n[3379] = 42785, n[3393] = 1159, n[3416] = 8377;
          });
          u.getGlyphMapForStandardFonts = h;
          const g = (0, t.getLookupTableFactory)(function(n) {
            n[227] = 322, n[264] = 261, n[291] = 346;
          });
          u.getSupplementalGlyphMapForArialBlack = g;
          const d = (0, t.getLookupTableFactory)(function(n) {
            n[1] = 32, n[4] = 65, n[6] = 193, n[17] = 66, n[18] = 67, n[21] = 268, n[24] = 68, n[28] = 69, n[30] = 201, n[32] = 282, n[38] = 70, n[39] = 71, n[44] = 72, n[47] = 73, n[49] = 205, n[58] = 74, n[60] = 75, n[62] = 76, n[68] = 77, n[69] = 78, n[75] = 79, n[87] = 80, n[89] = 81, n[90] = 82, n[92] = 344, n[94] = 83, n[97] = 352, n[100] = 84, n[104] = 85, n[115] = 86, n[116] = 87, n[121] = 88, n[122] = 89, n[124] = 221, n[127] = 90, n[129] = 381, n[258] = 97, n[260] = 225, n[268] = 261, n[271] = 98, n[272] = 99, n[273] = 263, n[275] = 269, n[282] = 100, n[286] = 101, n[288] = 233, n[290] = 283, n[295] = 281, n[296] = 102, n[336] = 103, n[346] = 104, n[349] = 105, n[351] = 237, n[361] = 106, n[364] = 107, n[367] = 108, n[371] = 322, n[373] = 109, n[374] = 110, n[381] = 111, n[383] = 243, n[393] = 112, n[395] = 113, n[396] = 114, n[398] = 345, n[400] = 115, n[401] = 347, n[403] = 353, n[410] = 116, n[437] = 117, n[448] = 118, n[449] = 119, n[454] = 120, n[455] = 121, n[457] = 253, n[460] = 122, n[462] = 382, n[463] = 380, n[853] = 44, n[855] = 58, n[856] = 46, n[876] = 47, n[878] = 45, n[882] = 45, n[894] = 40, n[895] = 41, n[896] = 91, n[897] = 93, n[923] = 64, n[1004] = 48, n[1005] = 49, n[1006] = 50, n[1007] = 51, n[1008] = 52, n[1009] = 53, n[1010] = 54, n[1011] = 55, n[1012] = 56, n[1013] = 57, n[1081] = 37, n[1085] = 43, n[1086] = 45;
          });
          u.getSupplementalGlyphMapForCalibri = d;
          function c(n) {
            const o = (0, i.normalizeFontName)(n);
            return v()[o];
          }
        },
        /* 42 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.ToUnicodeMap = u.IdentityToUnicodeMap = void 0;
          var t = P(2);
          class i {
            constructor(e = []) {
              this._map = e;
            }
            get length() {
              return this._map.length;
            }
            forEach(e) {
              for (const y in this._map)
                e(y, this._map[y].charCodeAt(0));
            }
            has(e) {
              return this._map[e] !== void 0;
            }
            get(e) {
              return this._map[e];
            }
            charCodeOf(e) {
              const y = this._map;
              if (y.length <= 65536)
                return y.indexOf(e);
              for (const r in y)
                if (y[r] === e)
                  return r | 0;
              return -1;
            }
            amend(e) {
              for (const y in e)
                this._map[y] = e[y];
            }
          }
          u.ToUnicodeMap = i;
          class v {
            constructor(e, y) {
              this.firstChar = e, this.lastChar = y;
            }
            get length() {
              return this.lastChar + 1 - this.firstChar;
            }
            forEach(e) {
              for (let y = this.firstChar, r = this.lastChar; y <= r; y++)
                e(y, y);
            }
            has(e) {
              return this.firstChar <= e && e <= this.lastChar;
            }
            get(e) {
              if (this.firstChar <= e && e <= this.lastChar)
                return String.fromCharCode(e);
            }
            charCodeOf(e) {
              return Number.isInteger(e) && e >= this.firstChar && e <= this.lastChar ? e : -1;
            }
            amend(e) {
              (0, t.unreachable)("Should not call amend()");
            }
          }
          u.IdentityToUnicodeMap = v;
        },
        /* 43 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.CFFFont = void 0;
          var t = P(35), i = P(38), v = P(2);
          class a {
            constructor(y, r) {
              this.properties = r;
              const h = new t.CFFParser(y, r, i.SEAC_ANALYSIS_ENABLED);
              this.cff = h.parse(), this.cff.duplicateFirstGlyph();
              const g = new t.CFFCompiler(this.cff);
              this.seacs = this.cff.seacs;
              try {
                this.data = g.compile();
              } catch {
                (0, v.warn)("Failed to compile font " + r.loadedName), this.data = y;
              }
              this._createBuiltInEncoding();
            }
            get numGlyphs() {
              return this.cff.charStrings.count;
            }
            getCharset() {
              return this.cff.charset.charset;
            }
            getGlyphMapping() {
              const y = this.cff, r = this.properties, h = y.charset.charset;
              let g, d;
              if (r.composite) {
                g = /* @__PURE__ */ Object.create(null);
                let n;
                if (y.isCIDFont)
                  for (d = 0; d < h.length; d++) {
                    const o = h[d];
                    n = r.cMap.charCodeOf(o), g[n] = d;
                  }
                else
                  for (d = 0; d < y.charStrings.count; d++)
                    n = r.cMap.charCodeOf(d), g[n] = d;
                return g;
              }
              let c = y.encoding ? y.encoding.encoding : null;
              return r.isInternalFont && (c = r.defaultEncoding), g = (0, i.type1FontGlyphMapping)(r, c, h), g;
            }
            hasGlyphId(y) {
              return this.cff.hasGlyphId(y);
            }
            _createBuiltInEncoding() {
              const {
                charset: y,
                encoding: r
              } = this.cff;
              if (!y || !r)
                return;
              const h = y.charset, g = r.encoding, d = [];
              for (const c in g) {
                const n = g[c];
                if (n >= 0) {
                  const o = h[n];
                  o && (d[c] = o);
                }
              }
              d.length > 0 && (this.properties.builtInEncoding = d);
            }
          }
          u.CFFFont = a;
        },
        /* 44 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.FontRendererFactory = void 0;
          var t = P(2), i = P(35), v = P(39), a = P(37), e = P(10);
          function y(B, R) {
            return (B[R] << 24 | B[R + 1] << 16 | B[R + 2] << 8 | B[R + 3]) >>> 0;
          }
          function r(B, R) {
            return B[R] << 8 | B[R + 1];
          }
          function h(B, R) {
            return (B[R] << 24 | B[R + 1] << 16) >> 16;
          }
          function g(B, R) {
            return B[R] << 24 >> 24;
          }
          function d(B, R) {
            return h(B, R) / 16384;
          }
          function c(B) {
            const R = B.length;
            let D = 32768;
            return R < 1240 ? D = 107 : R < 33900 && (D = 1131), D;
          }
          function n(B, R, D) {
            const b = r(B, R + 2) === 1 ? y(B, R + 8) : y(B, R + 16), l = r(B, R + b);
            let _, S, A;
            if (l === 4) {
              r(B, R + b + 2);
              const F = r(B, R + b + 6) >> 1;
              for (S = R + b + 14, _ = [], A = 0; A < F; A++, S += 2)
                _[A] = {
                  end: r(B, S)
                };
              for (S += 2, A = 0; A < F; A++, S += 2)
                _[A].start = r(B, S);
              for (A = 0; A < F; A++, S += 2)
                _[A].idDelta = r(B, S);
              for (A = 0; A < F; A++, S += 2) {
                let T = r(B, S);
                if (T !== 0) {
                  _[A].ids = [];
                  for (let O = 0, U = _[A].end - _[A].start + 1; O < U; O++)
                    _[A].ids[O] = r(B, S + T), T += 2;
                }
              }
              return _;
            } else if (l === 12) {
              const F = y(B, R + b + 12);
              for (S = R + b + 16, _ = [], A = 0; A < F; A++)
                R = y(B, S), _.push({
                  start: R,
                  end: y(B, S + 4),
                  idDelta: y(B, S + 8) - R
                }), S += 12;
              return _;
            }
            throw new t.FormatError(`unsupported cmap: ${l}`);
          }
          function o(B, R, D, b) {
            const l = {}, S = new i.CFFParser(new e.Stream(B, R, D - R), l, b).parse();
            return {
              glyphs: S.charStrings.objects,
              subrs: S.topDict.privateDict && S.topDict.privateDict.subrsIndex && S.topDict.privateDict.subrsIndex.objects,
              gsubrs: S.globalSubrIndex && S.globalSubrIndex.objects,
              isCFFCIDFont: S.isCIDFont,
              fdSelect: S.fdSelect,
              fdArray: S.fdArray
            };
          }
          function x(B, R, D) {
            let b, l;
            D ? (b = 4, l = y) : (b = 2, l = (A, F) => 2 * r(A, F));
            const _ = [];
            let S = l(R, 0);
            for (let A = b; A < R.length; A += b) {
              const F = l(R, A);
              _.push(B.subarray(S, F)), S = F;
            }
            return _;
          }
          function f(B, R) {
            const D = R.codePointAt(0);
            let b = 0, l = 0, _ = B.length - 1;
            for (; l < _; ) {
              const S = l + _ + 1 >> 1;
              D < B[S].start ? _ = S - 1 : l = S;
            }
            return B[l].start <= D && D <= B[l].end && (b = B[l].idDelta + (B[l].ids ? B[l].ids[D - B[l].start] : D) & 65535), {
              charCode: D,
              glyphId: b
            };
          }
          function m(B, R, D) {
            function b(U, G) {
              R.push({
                cmd: "moveTo",
                args: [U, G]
              });
            }
            function l(U, G) {
              R.push({
                cmd: "lineTo",
                args: [U, G]
              });
            }
            function _(U, G, K, W) {
              R.push({
                cmd: "quadraticCurveTo",
                args: [U, G, K, W]
              });
            }
            let S = 0;
            const A = h(B, S);
            let F, T = 0, O = 0;
            if (S += 10, A < 0)
              do {
                F = r(B, S);
                const U = r(B, S + 2);
                S += 4;
                let G, K;
                F & 1 ? (F & 2 ? (G = h(B, S), K = h(B, S + 2)) : (G = r(B, S), K = r(B, S + 2)), S += 4) : F & 2 ? (G = g(B, S++), K = g(B, S++)) : (G = B[S++], K = B[S++]), F & 2 ? (T = G, O = K) : (T = 0, O = 0);
                let W = 1, z = 1, V = 0, L = 0;
                F & 8 ? (W = z = d(B, S), S += 2) : F & 64 ? (W = d(B, S), z = d(B, S + 2), S += 4) : F & 128 && (W = d(B, S), V = d(B, S + 2), L = d(B, S + 4), z = d(B, S + 6), S += 8);
                const Y = D.glyphs[U];
                Y && (R.push({
                  cmd: "save"
                }, {
                  cmd: "transform",
                  args: [W, V, L, z, T, O]
                }), m(Y, R, D), R.push({
                  cmd: "restore"
                }));
              } while (F & 32);
            else {
              const U = [];
              let G, K;
              for (G = 0; G < A; G++)
                U.push(r(B, S)), S += 2;
              const W = r(B, S);
              S += 2 + W;
              const z = U.at(-1) + 1, V = [];
              for (; V.length < z; ) {
                F = B[S++];
                let Y = 1;
                for (F & 8 && (Y += B[S++]); Y-- > 0; )
                  V.push({
                    flags: F
                  });
              }
              for (G = 0; G < z; G++) {
                switch (V[G].flags & 18) {
                  case 0:
                    T += h(B, S), S += 2;
                    break;
                  case 2:
                    T -= B[S++];
                    break;
                  case 18:
                    T += B[S++];
                    break;
                }
                V[G].x = T;
              }
              for (G = 0; G < z; G++) {
                switch (V[G].flags & 36) {
                  case 0:
                    O += h(B, S), S += 2;
                    break;
                  case 4:
                    O -= B[S++];
                    break;
                  case 36:
                    O += B[S++];
                    break;
                }
                V[G].y = O;
              }
              let L = 0;
              for (S = 0; S < A; S++) {
                const Y = U[S], J = V.slice(L, Y + 1);
                if (J[0].flags & 1)
                  J.push(J[0]);
                else if (J.at(-1).flags & 1)
                  J.unshift(J.at(-1));
                else {
                  const ie = {
                    flags: 1,
                    x: (J[0].x + J.at(-1).x) / 2,
                    y: (J[0].y + J.at(-1).y) / 2
                  };
                  J.unshift(ie), J.push(ie);
                }
                for (b(J[0].x, J[0].y), G = 1, K = J.length; G < K; G++)
                  J[G].flags & 1 ? l(J[G].x, J[G].y) : J[G + 1].flags & 1 ? (_(J[G].x, J[G].y, J[G + 1].x, J[G + 1].y), G++) : _(J[G].x, J[G].y, (J[G].x + J[G + 1].x) / 2, (J[G].y + J[G + 1].y) / 2);
                L = Y + 1;
              }
            }
          }
          function C(B, R, D, b) {
            function l(G, K) {
              R.push({
                cmd: "moveTo",
                args: [G, K]
              });
            }
            function _(G, K) {
              R.push({
                cmd: "lineTo",
                args: [G, K]
              });
            }
            function S(G, K, W, z, V, L) {
              R.push({
                cmd: "bezierCurveTo",
                args: [G, K, W, z, V, L]
              });
            }
            const A = [];
            let F = 0, T = 0, O = 0;
            function U(G) {
              let K = 0;
              for (; K < G.length; ) {
                let W = !1, z = G[K++], V, L, Y, J, ie, q, N, Z, E;
                switch (z) {
                  case 1:
                    O += A.length >> 1, W = !0;
                    break;
                  case 3:
                    O += A.length >> 1, W = !0;
                    break;
                  case 4:
                    T += A.pop(), l(F, T), W = !0;
                    break;
                  case 5:
                    for (; A.length > 0; )
                      F += A.shift(), T += A.shift(), _(F, T);
                    break;
                  case 6:
                    for (; A.length > 0 && (F += A.shift(), _(F, T), A.length !== 0); )
                      T += A.shift(), _(F, T);
                    break;
                  case 7:
                    for (; A.length > 0 && (T += A.shift(), _(F, T), A.length !== 0); )
                      F += A.shift(), _(F, T);
                    break;
                  case 8:
                    for (; A.length > 0; )
                      V = F + A.shift(), Y = T + A.shift(), L = V + A.shift(), J = Y + A.shift(), F = L + A.shift(), T = J + A.shift(), S(V, Y, L, J, F, T);
                    break;
                  case 10:
                    if (Z = A.pop(), E = null, D.isCFFCIDFont) {
                      const te = D.fdSelect.getFDIndex(b);
                      if (te >= 0 && te < D.fdArray.length) {
                        const re = D.fdArray[te];
                        let ee;
                        re.privateDict && re.privateDict.subrsIndex && (ee = re.privateDict.subrsIndex.objects), ee && (Z += c(ee), E = ee[Z]);
                      } else
                        (0, t.warn)("Invalid fd index for glyph index.");
                    } else
                      E = D.subrs[Z + D.subrsBias];
                    E && U(E);
                    break;
                  case 11:
                    return;
                  case 12:
                    switch (z = G[K++], z) {
                      case 34:
                        V = F + A.shift(), L = V + A.shift(), ie = T + A.shift(), F = L + A.shift(), S(V, T, L, ie, F, ie), V = F + A.shift(), L = V + A.shift(), F = L + A.shift(), S(V, ie, L, T, F, T);
                        break;
                      case 35:
                        V = F + A.shift(), Y = T + A.shift(), L = V + A.shift(), J = Y + A.shift(), F = L + A.shift(), T = J + A.shift(), S(V, Y, L, J, F, T), V = F + A.shift(), Y = T + A.shift(), L = V + A.shift(), J = Y + A.shift(), F = L + A.shift(), T = J + A.shift(), S(V, Y, L, J, F, T), A.pop();
                        break;
                      case 36:
                        V = F + A.shift(), ie = T + A.shift(), L = V + A.shift(), q = ie + A.shift(), F = L + A.shift(), S(V, ie, L, q, F, q), V = F + A.shift(), L = V + A.shift(), N = q + A.shift(), F = L + A.shift(), S(V, q, L, N, F, T);
                        break;
                      case 37:
                        const te = F, re = T;
                        V = F + A.shift(), Y = T + A.shift(), L = V + A.shift(), J = Y + A.shift(), F = L + A.shift(), T = J + A.shift(), S(V, Y, L, J, F, T), V = F + A.shift(), Y = T + A.shift(), L = V + A.shift(), J = Y + A.shift(), F = L, T = J, Math.abs(F - te) > Math.abs(T - re) ? F += A.shift() : T += A.shift(), S(V, Y, L, J, F, T);
                        break;
                      default:
                        throw new t.FormatError(`unknown operator: 12 ${z}`);
                    }
                    break;
                  case 14:
                    if (A.length >= 4) {
                      const te = A.pop(), re = A.pop();
                      T = A.pop(), F = A.pop(), R.push({
                        cmd: "save"
                      }, {
                        cmd: "translate",
                        args: [F, T]
                      });
                      let ee = f(D.cmap, String.fromCharCode(D.glyphNameMap[a.StandardEncoding[te]]));
                      C(D.glyphs[ee.glyphId], R, D, ee.glyphId), R.push({
                        cmd: "restore"
                      }), ee = f(D.cmap, String.fromCharCode(D.glyphNameMap[a.StandardEncoding[re]])), C(D.glyphs[ee.glyphId], R, D, ee.glyphId);
                    }
                    return;
                  case 18:
                    O += A.length >> 1, W = !0;
                    break;
                  case 19:
                    O += A.length >> 1, K += O + 7 >> 3, W = !0;
                    break;
                  case 20:
                    O += A.length >> 1, K += O + 7 >> 3, W = !0;
                    break;
                  case 21:
                    T += A.pop(), F += A.pop(), l(F, T), W = !0;
                    break;
                  case 22:
                    F += A.pop(), l(F, T), W = !0;
                    break;
                  case 23:
                    O += A.length >> 1, W = !0;
                    break;
                  case 24:
                    for (; A.length > 2; )
                      V = F + A.shift(), Y = T + A.shift(), L = V + A.shift(), J = Y + A.shift(), F = L + A.shift(), T = J + A.shift(), S(V, Y, L, J, F, T);
                    F += A.shift(), T += A.shift(), _(F, T);
                    break;
                  case 25:
                    for (; A.length > 6; )
                      F += A.shift(), T += A.shift(), _(F, T);
                    V = F + A.shift(), Y = T + A.shift(), L = V + A.shift(), J = Y + A.shift(), F = L + A.shift(), T = J + A.shift(), S(V, Y, L, J, F, T);
                    break;
                  case 26:
                    for (A.length % 2 && (F += A.shift()); A.length > 0; )
                      V = F, Y = T + A.shift(), L = V + A.shift(), J = Y + A.shift(), F = L, T = J + A.shift(), S(V, Y, L, J, F, T);
                    break;
                  case 27:
                    for (A.length % 2 && (T += A.shift()); A.length > 0; )
                      V = F + A.shift(), Y = T, L = V + A.shift(), J = Y + A.shift(), F = L + A.shift(), T = J, S(V, Y, L, J, F, T);
                    break;
                  case 28:
                    A.push((G[K] << 24 | G[K + 1] << 16) >> 16), K += 2;
                    break;
                  case 29:
                    Z = A.pop() + D.gsubrsBias, E = D.gsubrs[Z], E && U(E);
                    break;
                  case 30:
                    for (; A.length > 0 && (V = F, Y = T + A.shift(), L = V + A.shift(), J = Y + A.shift(), F = L + A.shift(), T = J + (A.length === 1 ? A.shift() : 0), S(V, Y, L, J, F, T), A.length !== 0); )
                      V = F + A.shift(), Y = T, L = V + A.shift(), J = Y + A.shift(), T = J + A.shift(), F = L + (A.length === 1 ? A.shift() : 0), S(V, Y, L, J, F, T);
                    break;
                  case 31:
                    for (; A.length > 0 && (V = F + A.shift(), Y = T, L = V + A.shift(), J = Y + A.shift(), T = J + A.shift(), F = L + (A.length === 1 ? A.shift() : 0), S(V, Y, L, J, F, T), A.length !== 0); )
                      V = F, Y = T + A.shift(), L = V + A.shift(), J = Y + A.shift(), F = L + A.shift(), T = J + (A.length === 1 ? A.shift() : 0), S(V, Y, L, J, F, T);
                    break;
                  default:
                    if (z < 32)
                      throw new t.FormatError(`unknown operator: ${z}`);
                    z < 247 ? A.push(z - 139) : z < 251 ? A.push((z - 247) * 256 + G[K++] + 108) : z < 255 ? A.push(-(z - 251) * 256 - G[K++] - 108) : (A.push((G[K] << 24 | G[K + 1] << 16 | G[K + 2] << 8 | G[K + 3]) / 65536), K += 4);
                    break;
                }
                W && (A.length = 0);
              }
            }
            U(B);
          }
          const p = [];
          class w {
            constructor(R) {
              this.constructor === w && (0, t.unreachable)("Cannot initialize CompiledFont."), this.fontMatrix = R, this.compiledGlyphs = /* @__PURE__ */ Object.create(null), this.compiledCharCodeToGlyphId = /* @__PURE__ */ Object.create(null);
            }
            getPathJs(R) {
              const {
                charCode: D,
                glyphId: b
              } = f(this.cmap, R);
              let l = this.compiledGlyphs[b];
              if (!l)
                try {
                  l = this.compileGlyph(this.glyphs[b], b), this.compiledGlyphs[b] = l;
                } catch (_) {
                  throw this.compiledGlyphs[b] = p, this.compiledCharCodeToGlyphId[D] === void 0 && (this.compiledCharCodeToGlyphId[D] = b), _;
                }
              return this.compiledCharCodeToGlyphId[D] === void 0 && (this.compiledCharCodeToGlyphId[D] = b), l;
            }
            compileGlyph(R, D) {
              if (!R || R.length === 0 || R[0] === 14)
                return p;
              let b = this.fontMatrix;
              if (this.isCFFCIDFont) {
                const _ = this.fdSelect.getFDIndex(D);
                _ >= 0 && _ < this.fdArray.length ? b = this.fdArray[_].getByName("FontMatrix") || t.FONT_IDENTITY_MATRIX : (0, t.warn)("Invalid fd index for glyph index.");
              }
              const l = [{
                cmd: "save"
              }, {
                cmd: "transform",
                args: b.slice()
              }, {
                cmd: "scale",
                args: ["size", "-size"]
              }];
              return this.compileGlyphImpl(R, l, D), l.push({
                cmd: "restore"
              }), l;
            }
            compileGlyphImpl() {
              (0, t.unreachable)("Children classes should implement this.");
            }
            hasBuiltPath(R) {
              const {
                charCode: D,
                glyphId: b
              } = f(this.cmap, R);
              return this.compiledGlyphs[b] !== void 0 && this.compiledCharCodeToGlyphId[D] !== void 0;
            }
          }
          class X extends w {
            constructor(R, D, b) {
              super(b || [488e-6, 0, 0, 488e-6, 0, 0]), this.glyphs = R, this.cmap = D;
            }
            compileGlyphImpl(R, D) {
              m(R, D, this);
            }
          }
          class M extends w {
            constructor(R, D, b, l) {
              super(b || [1e-3, 0, 0, 1e-3, 0, 0]), this.glyphs = R.glyphs, this.gsubrs = R.gsubrs || [], this.subrs = R.subrs || [], this.cmap = D, this.glyphNameMap = l || (0, v.getGlyphsUnicode)(), this.gsubrsBias = c(this.gsubrs), this.subrsBias = c(this.subrs), this.isCFFCIDFont = R.isCFFCIDFont, this.fdSelect = R.fdSelect, this.fdArray = R.fdArray;
            }
            compileGlyphImpl(R, D, b) {
              C(R, D, this, b);
            }
          }
          class j {
            static create(R, D) {
              const b = new Uint8Array(R.data);
              let l, _, S, A, F, T;
              const O = r(b, 4);
              for (let U = 0, G = 12; U < O; U++, G += 16) {
                const K = (0, t.bytesToString)(b.subarray(G, G + 4)), W = y(b, G + 8), z = y(b, G + 12);
                switch (K) {
                  case "cmap":
                    l = n(b, W);
                    break;
                  case "glyf":
                    _ = b.subarray(W, W + z);
                    break;
                  case "loca":
                    S = b.subarray(W, W + z);
                    break;
                  case "head":
                    T = r(b, W + 18), F = r(b, W + 50);
                    break;
                  case "CFF ":
                    A = o(b, W, W + z, D);
                    break;
                }
              }
              if (_) {
                const U = T ? [1 / T, 0, 0, 1 / T, 0, 0] : R.fontMatrix;
                return new X(x(_, S, F), l, U);
              }
              return new M(A, l, R.fontMatrix, R.glyphNameMap);
            }
          }
          u.FontRendererFactory = j;
        },
        /* 45 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.getMetrics = u.getFontBasicMetrics = void 0;
          var t = P(6);
          const i = (0, t.getLookupTableFactory)(function(a) {
            a.Courier = 600, a["Courier-Bold"] = 600, a["Courier-BoldOblique"] = 600, a["Courier-Oblique"] = 600, a.Helvetica = (0, t.getLookupTableFactory)(function(e) {
              e.space = 278, e.exclam = 278, e.quotedbl = 355, e.numbersign = 556, e.dollar = 556, e.percent = 889, e.ampersand = 667, e.quoteright = 222, e.parenleft = 333, e.parenright = 333, e.asterisk = 389, e.plus = 584, e.comma = 278, e.hyphen = 333, e.period = 278, e.slash = 278, e.zero = 556, e.one = 556, e.two = 556, e.three = 556, e.four = 556, e.five = 556, e.six = 556, e.seven = 556, e.eight = 556, e.nine = 556, e.colon = 278, e.semicolon = 278, e.less = 584, e.equal = 584, e.greater = 584, e.question = 556, e.at = 1015, e.A = 667, e.B = 667, e.C = 722, e.D = 722, e.E = 667, e.F = 611, e.G = 778, e.H = 722, e.I = 278, e.J = 500, e.K = 667, e.L = 556, e.M = 833, e.N = 722, e.O = 778, e.P = 667, e.Q = 778, e.R = 722, e.S = 667, e.T = 611, e.U = 722, e.V = 667, e.W = 944, e.X = 667, e.Y = 667, e.Z = 611, e.bracketleft = 278, e.backslash = 278, e.bracketright = 278, e.asciicircum = 469, e.underscore = 556, e.quoteleft = 222, e.a = 556, e.b = 556, e.c = 500, e.d = 556, e.e = 556, e.f = 278, e.g = 556, e.h = 556, e.i = 222, e.j = 222, e.k = 500, e.l = 222, e.m = 833, e.n = 556, e.o = 556, e.p = 556, e.q = 556, e.r = 333, e.s = 500, e.t = 278, e.u = 556, e.v = 500, e.w = 722, e.x = 500, e.y = 500, e.z = 500, e.braceleft = 334, e.bar = 260, e.braceright = 334, e.asciitilde = 584, e.exclamdown = 333, e.cent = 556, e.sterling = 556, e.fraction = 167, e.yen = 556, e.florin = 556, e.section = 556, e.currency = 556, e.quotesingle = 191, e.quotedblleft = 333, e.guillemotleft = 556, e.guilsinglleft = 333, e.guilsinglright = 333, e.fi = 500, e.fl = 500, e.endash = 556, e.dagger = 556, e.daggerdbl = 556, e.periodcentered = 278, e.paragraph = 537, e.bullet = 350, e.quotesinglbase = 222, e.quotedblbase = 333, e.quotedblright = 333, e.guillemotright = 556, e.ellipsis = 1e3, e.perthousand = 1e3, e.questiondown = 611, e.grave = 333, e.acute = 333, e.circumflex = 333, e.tilde = 333, e.macron = 333, e.breve = 333, e.dotaccent = 333, e.dieresis = 333, e.ring = 333, e.cedilla = 333, e.hungarumlaut = 333, e.ogonek = 333, e.caron = 333, e.emdash = 1e3, e.AE = 1e3, e.ordfeminine = 370, e.Lslash = 556, e.Oslash = 778, e.OE = 1e3, e.ordmasculine = 365, e.ae = 889, e.dotlessi = 278, e.lslash = 222, e.oslash = 611, e.oe = 944, e.germandbls = 611, e.Idieresis = 278, e.eacute = 556, e.abreve = 556, e.uhungarumlaut = 556, e.ecaron = 556, e.Ydieresis = 667, e.divide = 584, e.Yacute = 667, e.Acircumflex = 667, e.aacute = 556, e.Ucircumflex = 722, e.yacute = 500, e.scommaaccent = 500, e.ecircumflex = 556, e.Uring = 722, e.Udieresis = 722, e.aogonek = 556, e.Uacute = 722, e.uogonek = 556, e.Edieresis = 667, e.Dcroat = 722, e.commaaccent = 250, e.copyright = 737, e.Emacron = 667, e.ccaron = 500, e.aring = 556, e.Ncommaaccent = 722, e.lacute = 222, e.agrave = 556, e.Tcommaaccent = 611, e.Cacute = 722, e.atilde = 556, e.Edotaccent = 667, e.scaron = 500, e.scedilla = 500, e.iacute = 278, e.lozenge = 471, e.Rcaron = 722, e.Gcommaaccent = 778, e.ucircumflex = 556, e.acircumflex = 556, e.Amacron = 667, e.rcaron = 333, e.ccedilla = 500, e.Zdotaccent = 611, e.Thorn = 667, e.Omacron = 778, e.Racute = 722, e.Sacute = 667, e.dcaron = 643, e.Umacron = 722, e.uring = 556, e.threesuperior = 333, e.Ograve = 778, e.Agrave = 667, e.Abreve = 667, e.multiply = 584, e.uacute = 556, e.Tcaron = 611, e.partialdiff = 476, e.ydieresis = 500, e.Nacute = 722, e.icircumflex = 278, e.Ecircumflex = 667, e.adieresis = 556, e.edieresis = 556, e.cacute = 500, e.nacute = 556, e.umacron = 556, e.Ncaron = 722, e.Iacute = 278, e.plusminus = 584, e.brokenbar = 260, e.registered = 737, e.Gbreve = 778, e.Idotaccent = 278, e.summation = 600, e.Egrave = 667, e.racute = 333, e.omacron = 556, e.Zacute = 611, e.Zcaron = 611, e.greaterequal = 549, e.Eth = 722, e.Ccedilla = 722, e.lcommaaccent = 222, e.tcaron = 317, e.eogonek = 556, e.Uogonek = 722, e.Aacute = 667, e.Adieresis = 667, e.egrave = 556, e.zacute = 500, e.iogonek = 222, e.Oacute = 778, e.oacute = 556, e.amacron = 556, e.sacute = 500, e.idieresis = 278, e.Ocircumflex = 778, e.Ugrave = 722, e.Delta = 612, e.thorn = 556, e.twosuperior = 333, e.Odieresis = 778, e.mu = 556, e.igrave = 278, e.ohungarumlaut = 556, e.Eogonek = 667, e.dcroat = 556, e.threequarters = 834, e.Scedilla = 667, e.lcaron = 299, e.Kcommaaccent = 667, e.Lacute = 556, e.trademark = 1e3, e.edotaccent = 556, e.Igrave = 278, e.Imacron = 278, e.Lcaron = 556, e.onehalf = 834, e.lessequal = 549, e.ocircumflex = 556, e.ntilde = 556, e.Uhungarumlaut = 722, e.Eacute = 667, e.emacron = 556, e.gbreve = 556, e.onequarter = 834, e.Scaron = 667, e.Scommaaccent = 667, e.Ohungarumlaut = 778, e.degree = 400, e.ograve = 556, e.Ccaron = 722, e.ugrave = 556, e.radical = 453, e.Dcaron = 722, e.rcommaaccent = 333, e.Ntilde = 722, e.otilde = 556, e.Rcommaaccent = 722, e.Lcommaaccent = 556, e.Atilde = 667, e.Aogonek = 667, e.Aring = 667, e.Otilde = 778, e.zdotaccent = 500, e.Ecaron = 667, e.Iogonek = 278, e.kcommaaccent = 500, e.minus = 584, e.Icircumflex = 278, e.ncaron = 556, e.tcommaaccent = 278, e.logicalnot = 584, e.odieresis = 556, e.udieresis = 556, e.notequal = 549, e.gcommaaccent = 556, e.eth = 556, e.zcaron = 500, e.ncommaaccent = 556, e.onesuperior = 333, e.imacron = 278, e.Euro = 556;
            }), a["Helvetica-Bold"] = (0, t.getLookupTableFactory)(function(e) {
              e.space = 278, e.exclam = 333, e.quotedbl = 474, e.numbersign = 556, e.dollar = 556, e.percent = 889, e.ampersand = 722, e.quoteright = 278, e.parenleft = 333, e.parenright = 333, e.asterisk = 389, e.plus = 584, e.comma = 278, e.hyphen = 333, e.period = 278, e.slash = 278, e.zero = 556, e.one = 556, e.two = 556, e.three = 556, e.four = 556, e.five = 556, e.six = 556, e.seven = 556, e.eight = 556, e.nine = 556, e.colon = 333, e.semicolon = 333, e.less = 584, e.equal = 584, e.greater = 584, e.question = 611, e.at = 975, e.A = 722, e.B = 722, e.C = 722, e.D = 722, e.E = 667, e.F = 611, e.G = 778, e.H = 722, e.I = 278, e.J = 556, e.K = 722, e.L = 611, e.M = 833, e.N = 722, e.O = 778, e.P = 667, e.Q = 778, e.R = 722, e.S = 667, e.T = 611, e.U = 722, e.V = 667, e.W = 944, e.X = 667, e.Y = 667, e.Z = 611, e.bracketleft = 333, e.backslash = 278, e.bracketright = 333, e.asciicircum = 584, e.underscore = 556, e.quoteleft = 278, e.a = 556, e.b = 611, e.c = 556, e.d = 611, e.e = 556, e.f = 333, e.g = 611, e.h = 611, e.i = 278, e.j = 278, e.k = 556, e.l = 278, e.m = 889, e.n = 611, e.o = 611, e.p = 611, e.q = 611, e.r = 389, e.s = 556, e.t = 333, e.u = 611, e.v = 556, e.w = 778, e.x = 556, e.y = 556, e.z = 500, e.braceleft = 389, e.bar = 280, e.braceright = 389, e.asciitilde = 584, e.exclamdown = 333, e.cent = 556, e.sterling = 556, e.fraction = 167, e.yen = 556, e.florin = 556, e.section = 556, e.currency = 556, e.quotesingle = 238, e.quotedblleft = 500, e.guillemotleft = 556, e.guilsinglleft = 333, e.guilsinglright = 333, e.fi = 611, e.fl = 611, e.endash = 556, e.dagger = 556, e.daggerdbl = 556, e.periodcentered = 278, e.paragraph = 556, e.bullet = 350, e.quotesinglbase = 278, e.quotedblbase = 500, e.quotedblright = 500, e.guillemotright = 556, e.ellipsis = 1e3, e.perthousand = 1e3, e.questiondown = 611, e.grave = 333, e.acute = 333, e.circumflex = 333, e.tilde = 333, e.macron = 333, e.breve = 333, e.dotaccent = 333, e.dieresis = 333, e.ring = 333, e.cedilla = 333, e.hungarumlaut = 333, e.ogonek = 333, e.caron = 333, e.emdash = 1e3, e.AE = 1e3, e.ordfeminine = 370, e.Lslash = 611, e.Oslash = 778, e.OE = 1e3, e.ordmasculine = 365, e.ae = 889, e.dotlessi = 278, e.lslash = 278, e.oslash = 611, e.oe = 944, e.germandbls = 611, e.Idieresis = 278, e.eacute = 556, e.abreve = 556, e.uhungarumlaut = 611, e.ecaron = 556, e.Ydieresis = 667, e.divide = 584, e.Yacute = 667, e.Acircumflex = 722, e.aacute = 556, e.Ucircumflex = 722, e.yacute = 556, e.scommaaccent = 556, e.ecircumflex = 556, e.Uring = 722, e.Udieresis = 722, e.aogonek = 556, e.Uacute = 722, e.uogonek = 611, e.Edieresis = 667, e.Dcroat = 722, e.commaaccent = 250, e.copyright = 737, e.Emacron = 667, e.ccaron = 556, e.aring = 556, e.Ncommaaccent = 722, e.lacute = 278, e.agrave = 556, e.Tcommaaccent = 611, e.Cacute = 722, e.atilde = 556, e.Edotaccent = 667, e.scaron = 556, e.scedilla = 556, e.iacute = 278, e.lozenge = 494, e.Rcaron = 722, e.Gcommaaccent = 778, e.ucircumflex = 611, e.acircumflex = 556, e.Amacron = 722, e.rcaron = 389, e.ccedilla = 556, e.Zdotaccent = 611, e.Thorn = 667, e.Omacron = 778, e.Racute = 722, e.Sacute = 667, e.dcaron = 743, e.Umacron = 722, e.uring = 611, e.threesuperior = 333, e.Ograve = 778, e.Agrave = 722, e.Abreve = 722, e.multiply = 584, e.uacute = 611, e.Tcaron = 611, e.partialdiff = 494, e.ydieresis = 556, e.Nacute = 722, e.icircumflex = 278, e.Ecircumflex = 667, e.adieresis = 556, e.edieresis = 556, e.cacute = 556, e.nacute = 611, e.umacron = 611, e.Ncaron = 722, e.Iacute = 278, e.plusminus = 584, e.brokenbar = 280, e.registered = 737, e.Gbreve = 778, e.Idotaccent = 278, e.summation = 600, e.Egrave = 667, e.racute = 389, e.omacron = 611, e.Zacute = 611, e.Zcaron = 611, e.greaterequal = 549, e.Eth = 722, e.Ccedilla = 722, e.lcommaaccent = 278, e.tcaron = 389, e.eogonek = 556, e.Uogonek = 722, e.Aacute = 722, e.Adieresis = 722, e.egrave = 556, e.zacute = 500, e.iogonek = 278, e.Oacute = 778, e.oacute = 611, e.amacron = 556, e.sacute = 556, e.idieresis = 278, e.Ocircumflex = 778, e.Ugrave = 722, e.Delta = 612, e.thorn = 611, e.twosuperior = 333, e.Odieresis = 778, e.mu = 611, e.igrave = 278, e.ohungarumlaut = 611, e.Eogonek = 667, e.dcroat = 611, e.threequarters = 834, e.Scedilla = 667, e.lcaron = 400, e.Kcommaaccent = 722, e.Lacute = 611, e.trademark = 1e3, e.edotaccent = 556, e.Igrave = 278, e.Imacron = 278, e.Lcaron = 611, e.onehalf = 834, e.lessequal = 549, e.ocircumflex = 611, e.ntilde = 611, e.Uhungarumlaut = 722, e.Eacute = 667, e.emacron = 556, e.gbreve = 611, e.onequarter = 834, e.Scaron = 667, e.Scommaaccent = 667, e.Ohungarumlaut = 778, e.degree = 400, e.ograve = 611, e.Ccaron = 722, e.ugrave = 611, e.radical = 549, e.Dcaron = 722, e.rcommaaccent = 389, e.Ntilde = 722, e.otilde = 611, e.Rcommaaccent = 722, e.Lcommaaccent = 611, e.Atilde = 722, e.Aogonek = 722, e.Aring = 722, e.Otilde = 778, e.zdotaccent = 500, e.Ecaron = 667, e.Iogonek = 278, e.kcommaaccent = 556, e.minus = 584, e.Icircumflex = 278, e.ncaron = 611, e.tcommaaccent = 333, e.logicalnot = 584, e.odieresis = 611, e.udieresis = 611, e.notequal = 549, e.gcommaaccent = 611, e.eth = 611, e.zcaron = 500, e.ncommaaccent = 611, e.onesuperior = 333, e.imacron = 278, e.Euro = 556;
            }), a["Helvetica-BoldOblique"] = (0, t.getLookupTableFactory)(function(e) {
              e.space = 278, e.exclam = 333, e.quotedbl = 474, e.numbersign = 556, e.dollar = 556, e.percent = 889, e.ampersand = 722, e.quoteright = 278, e.parenleft = 333, e.parenright = 333, e.asterisk = 389, e.plus = 584, e.comma = 278, e.hyphen = 333, e.period = 278, e.slash = 278, e.zero = 556, e.one = 556, e.two = 556, e.three = 556, e.four = 556, e.five = 556, e.six = 556, e.seven = 556, e.eight = 556, e.nine = 556, e.colon = 333, e.semicolon = 333, e.less = 584, e.equal = 584, e.greater = 584, e.question = 611, e.at = 975, e.A = 722, e.B = 722, e.C = 722, e.D = 722, e.E = 667, e.F = 611, e.G = 778, e.H = 722, e.I = 278, e.J = 556, e.K = 722, e.L = 611, e.M = 833, e.N = 722, e.O = 778, e.P = 667, e.Q = 778, e.R = 722, e.S = 667, e.T = 611, e.U = 722, e.V = 667, e.W = 944, e.X = 667, e.Y = 667, e.Z = 611, e.bracketleft = 333, e.backslash = 278, e.bracketright = 333, e.asciicircum = 584, e.underscore = 556, e.quoteleft = 278, e.a = 556, e.b = 611, e.c = 556, e.d = 611, e.e = 556, e.f = 333, e.g = 611, e.h = 611, e.i = 278, e.j = 278, e.k = 556, e.l = 278, e.m = 889, e.n = 611, e.o = 611, e.p = 611, e.q = 611, e.r = 389, e.s = 556, e.t = 333, e.u = 611, e.v = 556, e.w = 778, e.x = 556, e.y = 556, e.z = 500, e.braceleft = 389, e.bar = 280, e.braceright = 389, e.asciitilde = 584, e.exclamdown = 333, e.cent = 556, e.sterling = 556, e.fraction = 167, e.yen = 556, e.florin = 556, e.section = 556, e.currency = 556, e.quotesingle = 238, e.quotedblleft = 500, e.guillemotleft = 556, e.guilsinglleft = 333, e.guilsinglright = 333, e.fi = 611, e.fl = 611, e.endash = 556, e.dagger = 556, e.daggerdbl = 556, e.periodcentered = 278, e.paragraph = 556, e.bullet = 350, e.quotesinglbase = 278, e.quotedblbase = 500, e.quotedblright = 500, e.guillemotright = 556, e.ellipsis = 1e3, e.perthousand = 1e3, e.questiondown = 611, e.grave = 333, e.acute = 333, e.circumflex = 333, e.tilde = 333, e.macron = 333, e.breve = 333, e.dotaccent = 333, e.dieresis = 333, e.ring = 333, e.cedilla = 333, e.hungarumlaut = 333, e.ogonek = 333, e.caron = 333, e.emdash = 1e3, e.AE = 1e3, e.ordfeminine = 370, e.Lslash = 611, e.Oslash = 778, e.OE = 1e3, e.ordmasculine = 365, e.ae = 889, e.dotlessi = 278, e.lslash = 278, e.oslash = 611, e.oe = 944, e.germandbls = 611, e.Idieresis = 278, e.eacute = 556, e.abreve = 556, e.uhungarumlaut = 611, e.ecaron = 556, e.Ydieresis = 667, e.divide = 584, e.Yacute = 667, e.Acircumflex = 722, e.aacute = 556, e.Ucircumflex = 722, e.yacute = 556, e.scommaaccent = 556, e.ecircumflex = 556, e.Uring = 722, e.Udieresis = 722, e.aogonek = 556, e.Uacute = 722, e.uogonek = 611, e.Edieresis = 667, e.Dcroat = 722, e.commaaccent = 250, e.copyright = 737, e.Emacron = 667, e.ccaron = 556, e.aring = 556, e.Ncommaaccent = 722, e.lacute = 278, e.agrave = 556, e.Tcommaaccent = 611, e.Cacute = 722, e.atilde = 556, e.Edotaccent = 667, e.scaron = 556, e.scedilla = 556, e.iacute = 278, e.lozenge = 494, e.Rcaron = 722, e.Gcommaaccent = 778, e.ucircumflex = 611, e.acircumflex = 556, e.Amacron = 722, e.rcaron = 389, e.ccedilla = 556, e.Zdotaccent = 611, e.Thorn = 667, e.Omacron = 778, e.Racute = 722, e.Sacute = 667, e.dcaron = 743, e.Umacron = 722, e.uring = 611, e.threesuperior = 333, e.Ograve = 778, e.Agrave = 722, e.Abreve = 722, e.multiply = 584, e.uacute = 611, e.Tcaron = 611, e.partialdiff = 494, e.ydieresis = 556, e.Nacute = 722, e.icircumflex = 278, e.Ecircumflex = 667, e.adieresis = 556, e.edieresis = 556, e.cacute = 556, e.nacute = 611, e.umacron = 611, e.Ncaron = 722, e.Iacute = 278, e.plusminus = 584, e.brokenbar = 280, e.registered = 737, e.Gbreve = 778, e.Idotaccent = 278, e.summation = 600, e.Egrave = 667, e.racute = 389, e.omacron = 611, e.Zacute = 611, e.Zcaron = 611, e.greaterequal = 549, e.Eth = 722, e.Ccedilla = 722, e.lcommaaccent = 278, e.tcaron = 389, e.eogonek = 556, e.Uogonek = 722, e.Aacute = 722, e.Adieresis = 722, e.egrave = 556, e.zacute = 500, e.iogonek = 278, e.Oacute = 778, e.oacute = 611, e.amacron = 556, e.sacute = 556, e.idieresis = 278, e.Ocircumflex = 778, e.Ugrave = 722, e.Delta = 612, e.thorn = 611, e.twosuperior = 333, e.Odieresis = 778, e.mu = 611, e.igrave = 278, e.ohungarumlaut = 611, e.Eogonek = 667, e.dcroat = 611, e.threequarters = 834, e.Scedilla = 667, e.lcaron = 400, e.Kcommaaccent = 722, e.Lacute = 611, e.trademark = 1e3, e.edotaccent = 556, e.Igrave = 278, e.Imacron = 278, e.Lcaron = 611, e.onehalf = 834, e.lessequal = 549, e.ocircumflex = 611, e.ntilde = 611, e.Uhungarumlaut = 722, e.Eacute = 667, e.emacron = 556, e.gbreve = 611, e.onequarter = 834, e.Scaron = 667, e.Scommaaccent = 667, e.Ohungarumlaut = 778, e.degree = 400, e.ograve = 611, e.Ccaron = 722, e.ugrave = 611, e.radical = 549, e.Dcaron = 722, e.rcommaaccent = 389, e.Ntilde = 722, e.otilde = 611, e.Rcommaaccent = 722, e.Lcommaaccent = 611, e.Atilde = 722, e.Aogonek = 722, e.Aring = 722, e.Otilde = 778, e.zdotaccent = 500, e.Ecaron = 667, e.Iogonek = 278, e.kcommaaccent = 556, e.minus = 584, e.Icircumflex = 278, e.ncaron = 611, e.tcommaaccent = 333, e.logicalnot = 584, e.odieresis = 611, e.udieresis = 611, e.notequal = 549, e.gcommaaccent = 611, e.eth = 611, e.zcaron = 500, e.ncommaaccent = 611, e.onesuperior = 333, e.imacron = 278, e.Euro = 556;
            }), a["Helvetica-Oblique"] = (0, t.getLookupTableFactory)(function(e) {
              e.space = 278, e.exclam = 278, e.quotedbl = 355, e.numbersign = 556, e.dollar = 556, e.percent = 889, e.ampersand = 667, e.quoteright = 222, e.parenleft = 333, e.parenright = 333, e.asterisk = 389, e.plus = 584, e.comma = 278, e.hyphen = 333, e.period = 278, e.slash = 278, e.zero = 556, e.one = 556, e.two = 556, e.three = 556, e.four = 556, e.five = 556, e.six = 556, e.seven = 556, e.eight = 556, e.nine = 556, e.colon = 278, e.semicolon = 278, e.less = 584, e.equal = 584, e.greater = 584, e.question = 556, e.at = 1015, e.A = 667, e.B = 667, e.C = 722, e.D = 722, e.E = 667, e.F = 611, e.G = 778, e.H = 722, e.I = 278, e.J = 500, e.K = 667, e.L = 556, e.M = 833, e.N = 722, e.O = 778, e.P = 667, e.Q = 778, e.R = 722, e.S = 667, e.T = 611, e.U = 722, e.V = 667, e.W = 944, e.X = 667, e.Y = 667, e.Z = 611, e.bracketleft = 278, e.backslash = 278, e.bracketright = 278, e.asciicircum = 469, e.underscore = 556, e.quoteleft = 222, e.a = 556, e.b = 556, e.c = 500, e.d = 556, e.e = 556, e.f = 278, e.g = 556, e.h = 556, e.i = 222, e.j = 222, e.k = 500, e.l = 222, e.m = 833, e.n = 556, e.o = 556, e.p = 556, e.q = 556, e.r = 333, e.s = 500, e.t = 278, e.u = 556, e.v = 500, e.w = 722, e.x = 500, e.y = 500, e.z = 500, e.braceleft = 334, e.bar = 260, e.braceright = 334, e.asciitilde = 584, e.exclamdown = 333, e.cent = 556, e.sterling = 556, e.fraction = 167, e.yen = 556, e.florin = 556, e.section = 556, e.currency = 556, e.quotesingle = 191, e.quotedblleft = 333, e.guillemotleft = 556, e.guilsinglleft = 333, e.guilsinglright = 333, e.fi = 500, e.fl = 500, e.endash = 556, e.dagger = 556, e.daggerdbl = 556, e.periodcentered = 278, e.paragraph = 537, e.bullet = 350, e.quotesinglbase = 222, e.quotedblbase = 333, e.quotedblright = 333, e.guillemotright = 556, e.ellipsis = 1e3, e.perthousand = 1e3, e.questiondown = 611, e.grave = 333, e.acute = 333, e.circumflex = 333, e.tilde = 333, e.macron = 333, e.breve = 333, e.dotaccent = 333, e.dieresis = 333, e.ring = 333, e.cedilla = 333, e.hungarumlaut = 333, e.ogonek = 333, e.caron = 333, e.emdash = 1e3, e.AE = 1e3, e.ordfeminine = 370, e.Lslash = 556, e.Oslash = 778, e.OE = 1e3, e.ordmasculine = 365, e.ae = 889, e.dotlessi = 278, e.lslash = 222, e.oslash = 611, e.oe = 944, e.germandbls = 611, e.Idieresis = 278, e.eacute = 556, e.abreve = 556, e.uhungarumlaut = 556, e.ecaron = 556, e.Ydieresis = 667, e.divide = 584, e.Yacute = 667, e.Acircumflex = 667, e.aacute = 556, e.Ucircumflex = 722, e.yacute = 500, e.scommaaccent = 500, e.ecircumflex = 556, e.Uring = 722, e.Udieresis = 722, e.aogonek = 556, e.Uacute = 722, e.uogonek = 556, e.Edieresis = 667, e.Dcroat = 722, e.commaaccent = 250, e.copyright = 737, e.Emacron = 667, e.ccaron = 500, e.aring = 556, e.Ncommaaccent = 722, e.lacute = 222, e.agrave = 556, e.Tcommaaccent = 611, e.Cacute = 722, e.atilde = 556, e.Edotaccent = 667, e.scaron = 500, e.scedilla = 500, e.iacute = 278, e.lozenge = 471, e.Rcaron = 722, e.Gcommaaccent = 778, e.ucircumflex = 556, e.acircumflex = 556, e.Amacron = 667, e.rcaron = 333, e.ccedilla = 500, e.Zdotaccent = 611, e.Thorn = 667, e.Omacron = 778, e.Racute = 722, e.Sacute = 667, e.dcaron = 643, e.Umacron = 722, e.uring = 556, e.threesuperior = 333, e.Ograve = 778, e.Agrave = 667, e.Abreve = 667, e.multiply = 584, e.uacute = 556, e.Tcaron = 611, e.partialdiff = 476, e.ydieresis = 500, e.Nacute = 722, e.icircumflex = 278, e.Ecircumflex = 667, e.adieresis = 556, e.edieresis = 556, e.cacute = 500, e.nacute = 556, e.umacron = 556, e.Ncaron = 722, e.Iacute = 278, e.plusminus = 584, e.brokenbar = 260, e.registered = 737, e.Gbreve = 778, e.Idotaccent = 278, e.summation = 600, e.Egrave = 667, e.racute = 333, e.omacron = 556, e.Zacute = 611, e.Zcaron = 611, e.greaterequal = 549, e.Eth = 722, e.Ccedilla = 722, e.lcommaaccent = 222, e.tcaron = 317, e.eogonek = 556, e.Uogonek = 722, e.Aacute = 667, e.Adieresis = 667, e.egrave = 556, e.zacute = 500, e.iogonek = 222, e.Oacute = 778, e.oacute = 556, e.amacron = 556, e.sacute = 500, e.idieresis = 278, e.Ocircumflex = 778, e.Ugrave = 722, e.Delta = 612, e.thorn = 556, e.twosuperior = 333, e.Odieresis = 778, e.mu = 556, e.igrave = 278, e.ohungarumlaut = 556, e.Eogonek = 667, e.dcroat = 556, e.threequarters = 834, e.Scedilla = 667, e.lcaron = 299, e.Kcommaaccent = 667, e.Lacute = 556, e.trademark = 1e3, e.edotaccent = 556, e.Igrave = 278, e.Imacron = 278, e.Lcaron = 556, e.onehalf = 834, e.lessequal = 549, e.ocircumflex = 556, e.ntilde = 556, e.Uhungarumlaut = 722, e.Eacute = 667, e.emacron = 556, e.gbreve = 556, e.onequarter = 834, e.Scaron = 667, e.Scommaaccent = 667, e.Ohungarumlaut = 778, e.degree = 400, e.ograve = 556, e.Ccaron = 722, e.ugrave = 556, e.radical = 453, e.Dcaron = 722, e.rcommaaccent = 333, e.Ntilde = 722, e.otilde = 556, e.Rcommaaccent = 722, e.Lcommaaccent = 556, e.Atilde = 667, e.Aogonek = 667, e.Aring = 667, e.Otilde = 778, e.zdotaccent = 500, e.Ecaron = 667, e.Iogonek = 278, e.kcommaaccent = 500, e.minus = 584, e.Icircumflex = 278, e.ncaron = 556, e.tcommaaccent = 278, e.logicalnot = 584, e.odieresis = 556, e.udieresis = 556, e.notequal = 549, e.gcommaaccent = 556, e.eth = 556, e.zcaron = 500, e.ncommaaccent = 556, e.onesuperior = 333, e.imacron = 278, e.Euro = 556;
            }), a.Symbol = (0, t.getLookupTableFactory)(function(e) {
              e.space = 250, e.exclam = 333, e.universal = 713, e.numbersign = 500, e.existential = 549, e.percent = 833, e.ampersand = 778, e.suchthat = 439, e.parenleft = 333, e.parenright = 333, e.asteriskmath = 500, e.plus = 549, e.comma = 250, e.minus = 549, e.period = 250, e.slash = 278, e.zero = 500, e.one = 500, e.two = 500, e.three = 500, e.four = 500, e.five = 500, e.six = 500, e.seven = 500, e.eight = 500, e.nine = 500, e.colon = 278, e.semicolon = 278, e.less = 549, e.equal = 549, e.greater = 549, e.question = 444, e.congruent = 549, e.Alpha = 722, e.Beta = 667, e.Chi = 722, e.Delta = 612, e.Epsilon = 611, e.Phi = 763, e.Gamma = 603, e.Eta = 722, e.Iota = 333, e.theta1 = 631, e.Kappa = 722, e.Lambda = 686, e.Mu = 889, e.Nu = 722, e.Omicron = 722, e.Pi = 768, e.Theta = 741, e.Rho = 556, e.Sigma = 592, e.Tau = 611, e.Upsilon = 690, e.sigma1 = 439, e.Omega = 768, e.Xi = 645, e.Psi = 795, e.Zeta = 611, e.bracketleft = 333, e.therefore = 863, e.bracketright = 333, e.perpendicular = 658, e.underscore = 500, e.radicalex = 500, e.alpha = 631, e.beta = 549, e.chi = 549, e.delta = 494, e.epsilon = 439, e.phi = 521, e.gamma = 411, e.eta = 603, e.iota = 329, e.phi1 = 603, e.kappa = 549, e.lambda = 549, e.mu = 576, e.nu = 521, e.omicron = 549, e.pi = 549, e.theta = 521, e.rho = 549, e.sigma = 603, e.tau = 439, e.upsilon = 576, e.omega1 = 713, e.omega = 686, e.xi = 493, e.psi = 686, e.zeta = 494, e.braceleft = 480, e.bar = 200, e.braceright = 480, e.similar = 549, e.Euro = 750, e.Upsilon1 = 620, e.minute = 247, e.lessequal = 549, e.fraction = 167, e.infinity = 713, e.florin = 500, e.club = 753, e.diamond = 753, e.heart = 753, e.spade = 753, e.arrowboth = 1042, e.arrowleft = 987, e.arrowup = 603, e.arrowright = 987, e.arrowdown = 603, e.degree = 400, e.plusminus = 549, e.second = 411, e.greaterequal = 549, e.multiply = 549, e.proportional = 713, e.partialdiff = 494, e.bullet = 460, e.divide = 549, e.notequal = 549, e.equivalence = 549, e.approxequal = 549, e.ellipsis = 1e3, e.arrowvertex = 603, e.arrowhorizex = 1e3, e.carriagereturn = 658, e.aleph = 823, e.Ifraktur = 686, e.Rfraktur = 795, e.weierstrass = 987, e.circlemultiply = 768, e.circleplus = 768, e.emptyset = 823, e.intersection = 768, e.union = 768, e.propersuperset = 713, e.reflexsuperset = 713, e.notsubset = 713, e.propersubset = 713, e.reflexsubset = 713, e.element = 713, e.notelement = 713, e.angle = 768, e.gradient = 713, e.registerserif = 790, e.copyrightserif = 790, e.trademarkserif = 890, e.product = 823, e.radical = 549, e.dotmath = 250, e.logicalnot = 713, e.logicaland = 603, e.logicalor = 603, e.arrowdblboth = 1042, e.arrowdblleft = 987, e.arrowdblup = 603, e.arrowdblright = 987, e.arrowdbldown = 603, e.lozenge = 494, e.angleleft = 329, e.registersans = 790, e.copyrightsans = 790, e.trademarksans = 786, e.summation = 713, e.parenlefttp = 384, e.parenleftex = 384, e.parenleftbt = 384, e.bracketlefttp = 384, e.bracketleftex = 384, e.bracketleftbt = 384, e.bracelefttp = 494, e.braceleftmid = 494, e.braceleftbt = 494, e.braceex = 494, e.angleright = 329, e.integral = 274, e.integraltp = 686, e.integralex = 686, e.integralbt = 686, e.parenrighttp = 384, e.parenrightex = 384, e.parenrightbt = 384, e.bracketrighttp = 384, e.bracketrightex = 384, e.bracketrightbt = 384, e.bracerighttp = 494, e.bracerightmid = 494, e.bracerightbt = 494, e.apple = 790;
            }), a["Times-Roman"] = (0, t.getLookupTableFactory)(function(e) {
              e.space = 250, e.exclam = 333, e.quotedbl = 408, e.numbersign = 500, e.dollar = 500, e.percent = 833, e.ampersand = 778, e.quoteright = 333, e.parenleft = 333, e.parenright = 333, e.asterisk = 500, e.plus = 564, e.comma = 250, e.hyphen = 333, e.period = 250, e.slash = 278, e.zero = 500, e.one = 500, e.two = 500, e.three = 500, e.four = 500, e.five = 500, e.six = 500, e.seven = 500, e.eight = 500, e.nine = 500, e.colon = 278, e.semicolon = 278, e.less = 564, e.equal = 564, e.greater = 564, e.question = 444, e.at = 921, e.A = 722, e.B = 667, e.C = 667, e.D = 722, e.E = 611, e.F = 556, e.G = 722, e.H = 722, e.I = 333, e.J = 389, e.K = 722, e.L = 611, e.M = 889, e.N = 722, e.O = 722, e.P = 556, e.Q = 722, e.R = 667, e.S = 556, e.T = 611, e.U = 722, e.V = 722, e.W = 944, e.X = 722, e.Y = 722, e.Z = 611, e.bracketleft = 333, e.backslash = 278, e.bracketright = 333, e.asciicircum = 469, e.underscore = 500, e.quoteleft = 333, e.a = 444, e.b = 500, e.c = 444, e.d = 500, e.e = 444, e.f = 333, e.g = 500, e.h = 500, e.i = 278, e.j = 278, e.k = 500, e.l = 278, e.m = 778, e.n = 500, e.o = 500, e.p = 500, e.q = 500, e.r = 333, e.s = 389, e.t = 278, e.u = 500, e.v = 500, e.w = 722, e.x = 500, e.y = 500, e.z = 444, e.braceleft = 480, e.bar = 200, e.braceright = 480, e.asciitilde = 541, e.exclamdown = 333, e.cent = 500, e.sterling = 500, e.fraction = 167, e.yen = 500, e.florin = 500, e.section = 500, e.currency = 500, e.quotesingle = 180, e.quotedblleft = 444, e.guillemotleft = 500, e.guilsinglleft = 333, e.guilsinglright = 333, e.fi = 556, e.fl = 556, e.endash = 500, e.dagger = 500, e.daggerdbl = 500, e.periodcentered = 250, e.paragraph = 453, e.bullet = 350, e.quotesinglbase = 333, e.quotedblbase = 444, e.quotedblright = 444, e.guillemotright = 500, e.ellipsis = 1e3, e.perthousand = 1e3, e.questiondown = 444, e.grave = 333, e.acute = 333, e.circumflex = 333, e.tilde = 333, e.macron = 333, e.breve = 333, e.dotaccent = 333, e.dieresis = 333, e.ring = 333, e.cedilla = 333, e.hungarumlaut = 333, e.ogonek = 333, e.caron = 333, e.emdash = 1e3, e.AE = 889, e.ordfeminine = 276, e.Lslash = 611, e.Oslash = 722, e.OE = 889, e.ordmasculine = 310, e.ae = 667, e.dotlessi = 278, e.lslash = 278, e.oslash = 500, e.oe = 722, e.germandbls = 500, e.Idieresis = 333, e.eacute = 444, e.abreve = 444, e.uhungarumlaut = 500, e.ecaron = 444, e.Ydieresis = 722, e.divide = 564, e.Yacute = 722, e.Acircumflex = 722, e.aacute = 444, e.Ucircumflex = 722, e.yacute = 500, e.scommaaccent = 389, e.ecircumflex = 444, e.Uring = 722, e.Udieresis = 722, e.aogonek = 444, e.Uacute = 722, e.uogonek = 500, e.Edieresis = 611, e.Dcroat = 722, e.commaaccent = 250, e.copyright = 760, e.Emacron = 611, e.ccaron = 444, e.aring = 444, e.Ncommaaccent = 722, e.lacute = 278, e.agrave = 444, e.Tcommaaccent = 611, e.Cacute = 667, e.atilde = 444, e.Edotaccent = 611, e.scaron = 389, e.scedilla = 389, e.iacute = 278, e.lozenge = 471, e.Rcaron = 667, e.Gcommaaccent = 722, e.ucircumflex = 500, e.acircumflex = 444, e.Amacron = 722, e.rcaron = 333, e.ccedilla = 444, e.Zdotaccent = 611, e.Thorn = 556, e.Omacron = 722, e.Racute = 667, e.Sacute = 556, e.dcaron = 588, e.Umacron = 722, e.uring = 500, e.threesuperior = 300, e.Ograve = 722, e.Agrave = 722, e.Abreve = 722, e.multiply = 564, e.uacute = 500, e.Tcaron = 611, e.partialdiff = 476, e.ydieresis = 500, e.Nacute = 722, e.icircumflex = 278, e.Ecircumflex = 611, e.adieresis = 444, e.edieresis = 444, e.cacute = 444, e.nacute = 500, e.umacron = 500, e.Ncaron = 722, e.Iacute = 333, e.plusminus = 564, e.brokenbar = 200, e.registered = 760, e.Gbreve = 722, e.Idotaccent = 333, e.summation = 600, e.Egrave = 611, e.racute = 333, e.omacron = 500, e.Zacute = 611, e.Zcaron = 611, e.greaterequal = 549, e.Eth = 722, e.Ccedilla = 667, e.lcommaaccent = 278, e.tcaron = 326, e.eogonek = 444, e.Uogonek = 722, e.Aacute = 722, e.Adieresis = 722, e.egrave = 444, e.zacute = 444, e.iogonek = 278, e.Oacute = 722, e.oacute = 500, e.amacron = 444, e.sacute = 389, e.idieresis = 278, e.Ocircumflex = 722, e.Ugrave = 722, e.Delta = 612, e.thorn = 500, e.twosuperior = 300, e.Odieresis = 722, e.mu = 500, e.igrave = 278, e.ohungarumlaut = 500, e.Eogonek = 611, e.dcroat = 500, e.threequarters = 750, e.Scedilla = 556, e.lcaron = 344, e.Kcommaaccent = 722, e.Lacute = 611, e.trademark = 980, e.edotaccent = 444, e.Igrave = 333, e.Imacron = 333, e.Lcaron = 611, e.onehalf = 750, e.lessequal = 549, e.ocircumflex = 500, e.ntilde = 500, e.Uhungarumlaut = 722, e.Eacute = 611, e.emacron = 444, e.gbreve = 500, e.onequarter = 750, e.Scaron = 556, e.Scommaaccent = 556, e.Ohungarumlaut = 722, e.degree = 400, e.ograve = 500, e.Ccaron = 667, e.ugrave = 500, e.radical = 453, e.Dcaron = 722, e.rcommaaccent = 333, e.Ntilde = 722, e.otilde = 500, e.Rcommaaccent = 667, e.Lcommaaccent = 611, e.Atilde = 722, e.Aogonek = 722, e.Aring = 722, e.Otilde = 722, e.zdotaccent = 444, e.Ecaron = 611, e.Iogonek = 333, e.kcommaaccent = 500, e.minus = 564, e.Icircumflex = 333, e.ncaron = 500, e.tcommaaccent = 278, e.logicalnot = 564, e.odieresis = 500, e.udieresis = 500, e.notequal = 549, e.gcommaaccent = 500, e.eth = 500, e.zcaron = 444, e.ncommaaccent = 500, e.onesuperior = 300, e.imacron = 278, e.Euro = 500;
            }), a["Times-Bold"] = (0, t.getLookupTableFactory)(function(e) {
              e.space = 250, e.exclam = 333, e.quotedbl = 555, e.numbersign = 500, e.dollar = 500, e.percent = 1e3, e.ampersand = 833, e.quoteright = 333, e.parenleft = 333, e.parenright = 333, e.asterisk = 500, e.plus = 570, e.comma = 250, e.hyphen = 333, e.period = 250, e.slash = 278, e.zero = 500, e.one = 500, e.two = 500, e.three = 500, e.four = 500, e.five = 500, e.six = 500, e.seven = 500, e.eight = 500, e.nine = 500, e.colon = 333, e.semicolon = 333, e.less = 570, e.equal = 570, e.greater = 570, e.question = 500, e.at = 930, e.A = 722, e.B = 667, e.C = 722, e.D = 722, e.E = 667, e.F = 611, e.G = 778, e.H = 778, e.I = 389, e.J = 500, e.K = 778, e.L = 667, e.M = 944, e.N = 722, e.O = 778, e.P = 611, e.Q = 778, e.R = 722, e.S = 556, e.T = 667, e.U = 722, e.V = 722, e.W = 1e3, e.X = 722, e.Y = 722, e.Z = 667, e.bracketleft = 333, e.backslash = 278, e.bracketright = 333, e.asciicircum = 581, e.underscore = 500, e.quoteleft = 333, e.a = 500, e.b = 556, e.c = 444, e.d = 556, e.e = 444, e.f = 333, e.g = 500, e.h = 556, e.i = 278, e.j = 333, e.k = 556, e.l = 278, e.m = 833, e.n = 556, e.o = 500, e.p = 556, e.q = 556, e.r = 444, e.s = 389, e.t = 333, e.u = 556, e.v = 500, e.w = 722, e.x = 500, e.y = 500, e.z = 444, e.braceleft = 394, e.bar = 220, e.braceright = 394, e.asciitilde = 520, e.exclamdown = 333, e.cent = 500, e.sterling = 500, e.fraction = 167, e.yen = 500, e.florin = 500, e.section = 500, e.currency = 500, e.quotesingle = 278, e.quotedblleft = 500, e.guillemotleft = 500, e.guilsinglleft = 333, e.guilsinglright = 333, e.fi = 556, e.fl = 556, e.endash = 500, e.dagger = 500, e.daggerdbl = 500, e.periodcentered = 250, e.paragraph = 540, e.bullet = 350, e.quotesinglbase = 333, e.quotedblbase = 500, e.quotedblright = 500, e.guillemotright = 500, e.ellipsis = 1e3, e.perthousand = 1e3, e.questiondown = 500, e.grave = 333, e.acute = 333, e.circumflex = 333, e.tilde = 333, e.macron = 333, e.breve = 333, e.dotaccent = 333, e.dieresis = 333, e.ring = 333, e.cedilla = 333, e.hungarumlaut = 333, e.ogonek = 333, e.caron = 333, e.emdash = 1e3, e.AE = 1e3, e.ordfeminine = 300, e.Lslash = 667, e.Oslash = 778, e.OE = 1e3, e.ordmasculine = 330, e.ae = 722, e.dotlessi = 278, e.lslash = 278, e.oslash = 500, e.oe = 722, e.germandbls = 556, e.Idieresis = 389, e.eacute = 444, e.abreve = 500, e.uhungarumlaut = 556, e.ecaron = 444, e.Ydieresis = 722, e.divide = 570, e.Yacute = 722, e.Acircumflex = 722, e.aacute = 500, e.Ucircumflex = 722, e.yacute = 500, e.scommaaccent = 389, e.ecircumflex = 444, e.Uring = 722, e.Udieresis = 722, e.aogonek = 500, e.Uacute = 722, e.uogonek = 556, e.Edieresis = 667, e.Dcroat = 722, e.commaaccent = 250, e.copyright = 747, e.Emacron = 667, e.ccaron = 444, e.aring = 500, e.Ncommaaccent = 722, e.lacute = 278, e.agrave = 500, e.Tcommaaccent = 667, e.Cacute = 722, e.atilde = 500, e.Edotaccent = 667, e.scaron = 389, e.scedilla = 389, e.iacute = 278, e.lozenge = 494, e.Rcaron = 722, e.Gcommaaccent = 778, e.ucircumflex = 556, e.acircumflex = 500, e.Amacron = 722, e.rcaron = 444, e.ccedilla = 444, e.Zdotaccent = 667, e.Thorn = 611, e.Omacron = 778, e.Racute = 722, e.Sacute = 556, e.dcaron = 672, e.Umacron = 722, e.uring = 556, e.threesuperior = 300, e.Ograve = 778, e.Agrave = 722, e.Abreve = 722, e.multiply = 570, e.uacute = 556, e.Tcaron = 667, e.partialdiff = 494, e.ydieresis = 500, e.Nacute = 722, e.icircumflex = 278, e.Ecircumflex = 667, e.adieresis = 500, e.edieresis = 444, e.cacute = 444, e.nacute = 556, e.umacron = 556, e.Ncaron = 722, e.Iacute = 389, e.plusminus = 570, e.brokenbar = 220, e.registered = 747, e.Gbreve = 778, e.Idotaccent = 389, e.summation = 600, e.Egrave = 667, e.racute = 444, e.omacron = 500, e.Zacute = 667, e.Zcaron = 667, e.greaterequal = 549, e.Eth = 722, e.Ccedilla = 722, e.lcommaaccent = 278, e.tcaron = 416, e.eogonek = 444, e.Uogonek = 722, e.Aacute = 722, e.Adieresis = 722, e.egrave = 444, e.zacute = 444, e.iogonek = 278, e.Oacute = 778, e.oacute = 500, e.amacron = 500, e.sacute = 389, e.idieresis = 278, e.Ocircumflex = 778, e.Ugrave = 722, e.Delta = 612, e.thorn = 556, e.twosuperior = 300, e.Odieresis = 778, e.mu = 556, e.igrave = 278, e.ohungarumlaut = 500, e.Eogonek = 667, e.dcroat = 556, e.threequarters = 750, e.Scedilla = 556, e.lcaron = 394, e.Kcommaaccent = 778, e.Lacute = 667, e.trademark = 1e3, e.edotaccent = 444, e.Igrave = 389, e.Imacron = 389, e.Lcaron = 667, e.onehalf = 750, e.lessequal = 549, e.ocircumflex = 500, e.ntilde = 556, e.Uhungarumlaut = 722, e.Eacute = 667, e.emacron = 444, e.gbreve = 500, e.onequarter = 750, e.Scaron = 556, e.Scommaaccent = 556, e.Ohungarumlaut = 778, e.degree = 400, e.ograve = 500, e.Ccaron = 722, e.ugrave = 556, e.radical = 549, e.Dcaron = 722, e.rcommaaccent = 444, e.Ntilde = 722, e.otilde = 500, e.Rcommaaccent = 722, e.Lcommaaccent = 667, e.Atilde = 722, e.Aogonek = 722, e.Aring = 722, e.Otilde = 778, e.zdotaccent = 444, e.Ecaron = 667, e.Iogonek = 389, e.kcommaaccent = 556, e.minus = 570, e.Icircumflex = 389, e.ncaron = 556, e.tcommaaccent = 333, e.logicalnot = 570, e.odieresis = 500, e.udieresis = 556, e.notequal = 549, e.gcommaaccent = 500, e.eth = 500, e.zcaron = 444, e.ncommaaccent = 556, e.onesuperior = 300, e.imacron = 278, e.Euro = 500;
            }), a["Times-BoldItalic"] = (0, t.getLookupTableFactory)(function(e) {
              e.space = 250, e.exclam = 389, e.quotedbl = 555, e.numbersign = 500, e.dollar = 500, e.percent = 833, e.ampersand = 778, e.quoteright = 333, e.parenleft = 333, e.parenright = 333, e.asterisk = 500, e.plus = 570, e.comma = 250, e.hyphen = 333, e.period = 250, e.slash = 278, e.zero = 500, e.one = 500, e.two = 500, e.three = 500, e.four = 500, e.five = 500, e.six = 500, e.seven = 500, e.eight = 500, e.nine = 500, e.colon = 333, e.semicolon = 333, e.less = 570, e.equal = 570, e.greater = 570, e.question = 500, e.at = 832, e.A = 667, e.B = 667, e.C = 667, e.D = 722, e.E = 667, e.F = 667, e.G = 722, e.H = 778, e.I = 389, e.J = 500, e.K = 667, e.L = 611, e.M = 889, e.N = 722, e.O = 722, e.P = 611, e.Q = 722, e.R = 667, e.S = 556, e.T = 611, e.U = 722, e.V = 667, e.W = 889, e.X = 667, e.Y = 611, e.Z = 611, e.bracketleft = 333, e.backslash = 278, e.bracketright = 333, e.asciicircum = 570, e.underscore = 500, e.quoteleft = 333, e.a = 500, e.b = 500, e.c = 444, e.d = 500, e.e = 444, e.f = 333, e.g = 500, e.h = 556, e.i = 278, e.j = 278, e.k = 500, e.l = 278, e.m = 778, e.n = 556, e.o = 500, e.p = 500, e.q = 500, e.r = 389, e.s = 389, e.t = 278, e.u = 556, e.v = 444, e.w = 667, e.x = 500, e.y = 444, e.z = 389, e.braceleft = 348, e.bar = 220, e.braceright = 348, e.asciitilde = 570, e.exclamdown = 389, e.cent = 500, e.sterling = 500, e.fraction = 167, e.yen = 500, e.florin = 500, e.section = 500, e.currency = 500, e.quotesingle = 278, e.quotedblleft = 500, e.guillemotleft = 500, e.guilsinglleft = 333, e.guilsinglright = 333, e.fi = 556, e.fl = 556, e.endash = 500, e.dagger = 500, e.daggerdbl = 500, e.periodcentered = 250, e.paragraph = 500, e.bullet = 350, e.quotesinglbase = 333, e.quotedblbase = 500, e.quotedblright = 500, e.guillemotright = 500, e.ellipsis = 1e3, e.perthousand = 1e3, e.questiondown = 500, e.grave = 333, e.acute = 333, e.circumflex = 333, e.tilde = 333, e.macron = 333, e.breve = 333, e.dotaccent = 333, e.dieresis = 333, e.ring = 333, e.cedilla = 333, e.hungarumlaut = 333, e.ogonek = 333, e.caron = 333, e.emdash = 1e3, e.AE = 944, e.ordfeminine = 266, e.Lslash = 611, e.Oslash = 722, e.OE = 944, e.ordmasculine = 300, e.ae = 722, e.dotlessi = 278, e.lslash = 278, e.oslash = 500, e.oe = 722, e.germandbls = 500, e.Idieresis = 389, e.eacute = 444, e.abreve = 500, e.uhungarumlaut = 556, e.ecaron = 444, e.Ydieresis = 611, e.divide = 570, e.Yacute = 611, e.Acircumflex = 667, e.aacute = 500, e.Ucircumflex = 722, e.yacute = 444, e.scommaaccent = 389, e.ecircumflex = 444, e.Uring = 722, e.Udieresis = 722, e.aogonek = 500, e.Uacute = 722, e.uogonek = 556, e.Edieresis = 667, e.Dcroat = 722, e.commaaccent = 250, e.copyright = 747, e.Emacron = 667, e.ccaron = 444, e.aring = 500, e.Ncommaaccent = 722, e.lacute = 278, e.agrave = 500, e.Tcommaaccent = 611, e.Cacute = 667, e.atilde = 500, e.Edotaccent = 667, e.scaron = 389, e.scedilla = 389, e.iacute = 278, e.lozenge = 494, e.Rcaron = 667, e.Gcommaaccent = 722, e.ucircumflex = 556, e.acircumflex = 500, e.Amacron = 667, e.rcaron = 389, e.ccedilla = 444, e.Zdotaccent = 611, e.Thorn = 611, e.Omacron = 722, e.Racute = 667, e.Sacute = 556, e.dcaron = 608, e.Umacron = 722, e.uring = 556, e.threesuperior = 300, e.Ograve = 722, e.Agrave = 667, e.Abreve = 667, e.multiply = 570, e.uacute = 556, e.Tcaron = 611, e.partialdiff = 494, e.ydieresis = 444, e.Nacute = 722, e.icircumflex = 278, e.Ecircumflex = 667, e.adieresis = 500, e.edieresis = 444, e.cacute = 444, e.nacute = 556, e.umacron = 556, e.Ncaron = 722, e.Iacute = 389, e.plusminus = 570, e.brokenbar = 220, e.registered = 747, e.Gbreve = 722, e.Idotaccent = 389, e.summation = 600, e.Egrave = 667, e.racute = 389, e.omacron = 500, e.Zacute = 611, e.Zcaron = 611, e.greaterequal = 549, e.Eth = 722, e.Ccedilla = 667, e.lcommaaccent = 278, e.tcaron = 366, e.eogonek = 444, e.Uogonek = 722, e.Aacute = 667, e.Adieresis = 667, e.egrave = 444, e.zacute = 389, e.iogonek = 278, e.Oacute = 722, e.oacute = 500, e.amacron = 500, e.sacute = 389, e.idieresis = 278, e.Ocircumflex = 722, e.Ugrave = 722, e.Delta = 612, e.thorn = 500, e.twosuperior = 300, e.Odieresis = 722, e.mu = 576, e.igrave = 278, e.ohungarumlaut = 500, e.Eogonek = 667, e.dcroat = 500, e.threequarters = 750, e.Scedilla = 556, e.lcaron = 382, e.Kcommaaccent = 667, e.Lacute = 611, e.trademark = 1e3, e.edotaccent = 444, e.Igrave = 389, e.Imacron = 389, e.Lcaron = 611, e.onehalf = 750, e.lessequal = 549, e.ocircumflex = 500, e.ntilde = 556, e.Uhungarumlaut = 722, e.Eacute = 667, e.emacron = 444, e.gbreve = 500, e.onequarter = 750, e.Scaron = 556, e.Scommaaccent = 556, e.Ohungarumlaut = 722, e.degree = 400, e.ograve = 500, e.Ccaron = 667, e.ugrave = 556, e.radical = 549, e.Dcaron = 722, e.rcommaaccent = 389, e.Ntilde = 722, e.otilde = 500, e.Rcommaaccent = 667, e.Lcommaaccent = 611, e.Atilde = 667, e.Aogonek = 667, e.Aring = 667, e.Otilde = 722, e.zdotaccent = 389, e.Ecaron = 667, e.Iogonek = 389, e.kcommaaccent = 500, e.minus = 606, e.Icircumflex = 389, e.ncaron = 556, e.tcommaaccent = 278, e.logicalnot = 606, e.odieresis = 500, e.udieresis = 556, e.notequal = 549, e.gcommaaccent = 500, e.eth = 500, e.zcaron = 389, e.ncommaaccent = 556, e.onesuperior = 300, e.imacron = 278, e.Euro = 500;
            }), a["Times-Italic"] = (0, t.getLookupTableFactory)(function(e) {
              e.space = 250, e.exclam = 333, e.quotedbl = 420, e.numbersign = 500, e.dollar = 500, e.percent = 833, e.ampersand = 778, e.quoteright = 333, e.parenleft = 333, e.parenright = 333, e.asterisk = 500, e.plus = 675, e.comma = 250, e.hyphen = 333, e.period = 250, e.slash = 278, e.zero = 500, e.one = 500, e.two = 500, e.three = 500, e.four = 500, e.five = 500, e.six = 500, e.seven = 500, e.eight = 500, e.nine = 500, e.colon = 333, e.semicolon = 333, e.less = 675, e.equal = 675, e.greater = 675, e.question = 500, e.at = 920, e.A = 611, e.B = 611, e.C = 667, e.D = 722, e.E = 611, e.F = 611, e.G = 722, e.H = 722, e.I = 333, e.J = 444, e.K = 667, e.L = 556, e.M = 833, e.N = 667, e.O = 722, e.P = 611, e.Q = 722, e.R = 611, e.S = 500, e.T = 556, e.U = 722, e.V = 611, e.W = 833, e.X = 611, e.Y = 556, e.Z = 556, e.bracketleft = 389, e.backslash = 278, e.bracketright = 389, e.asciicircum = 422, e.underscore = 500, e.quoteleft = 333, e.a = 500, e.b = 500, e.c = 444, e.d = 500, e.e = 444, e.f = 278, e.g = 500, e.h = 500, e.i = 278, e.j = 278, e.k = 444, e.l = 278, e.m = 722, e.n = 500, e.o = 500, e.p = 500, e.q = 500, e.r = 389, e.s = 389, e.t = 278, e.u = 500, e.v = 444, e.w = 667, e.x = 444, e.y = 444, e.z = 389, e.braceleft = 400, e.bar = 275, e.braceright = 400, e.asciitilde = 541, e.exclamdown = 389, e.cent = 500, e.sterling = 500, e.fraction = 167, e.yen = 500, e.florin = 500, e.section = 500, e.currency = 500, e.quotesingle = 214, e.quotedblleft = 556, e.guillemotleft = 500, e.guilsinglleft = 333, e.guilsinglright = 333, e.fi = 500, e.fl = 500, e.endash = 500, e.dagger = 500, e.daggerdbl = 500, e.periodcentered = 250, e.paragraph = 523, e.bullet = 350, e.quotesinglbase = 333, e.quotedblbase = 556, e.quotedblright = 556, e.guillemotright = 500, e.ellipsis = 889, e.perthousand = 1e3, e.questiondown = 500, e.grave = 333, e.acute = 333, e.circumflex = 333, e.tilde = 333, e.macron = 333, e.breve = 333, e.dotaccent = 333, e.dieresis = 333, e.ring = 333, e.cedilla = 333, e.hungarumlaut = 333, e.ogonek = 333, e.caron = 333, e.emdash = 889, e.AE = 889, e.ordfeminine = 276, e.Lslash = 556, e.Oslash = 722, e.OE = 944, e.ordmasculine = 310, e.ae = 667, e.dotlessi = 278, e.lslash = 278, e.oslash = 500, e.oe = 667, e.germandbls = 500, e.Idieresis = 333, e.eacute = 444, e.abreve = 500, e.uhungarumlaut = 500, e.ecaron = 444, e.Ydieresis = 556, e.divide = 675, e.Yacute = 556, e.Acircumflex = 611, e.aacute = 500, e.Ucircumflex = 722, e.yacute = 444, e.scommaaccent = 389, e.ecircumflex = 444, e.Uring = 722, e.Udieresis = 722, e.aogonek = 500, e.Uacute = 722, e.uogonek = 500, e.Edieresis = 611, e.Dcroat = 722, e.commaaccent = 250, e.copyright = 760, e.Emacron = 611, e.ccaron = 444, e.aring = 500, e.Ncommaaccent = 667, e.lacute = 278, e.agrave = 500, e.Tcommaaccent = 556, e.Cacute = 667, e.atilde = 500, e.Edotaccent = 611, e.scaron = 389, e.scedilla = 389, e.iacute = 278, e.lozenge = 471, e.Rcaron = 611, e.Gcommaaccent = 722, e.ucircumflex = 500, e.acircumflex = 500, e.Amacron = 611, e.rcaron = 389, e.ccedilla = 444, e.Zdotaccent = 556, e.Thorn = 611, e.Omacron = 722, e.Racute = 611, e.Sacute = 500, e.dcaron = 544, e.Umacron = 722, e.uring = 500, e.threesuperior = 300, e.Ograve = 722, e.Agrave = 611, e.Abreve = 611, e.multiply = 675, e.uacute = 500, e.Tcaron = 556, e.partialdiff = 476, e.ydieresis = 444, e.Nacute = 667, e.icircumflex = 278, e.Ecircumflex = 611, e.adieresis = 500, e.edieresis = 444, e.cacute = 444, e.nacute = 500, e.umacron = 500, e.Ncaron = 667, e.Iacute = 333, e.plusminus = 675, e.brokenbar = 275, e.registered = 760, e.Gbreve = 722, e.Idotaccent = 333, e.summation = 600, e.Egrave = 611, e.racute = 389, e.omacron = 500, e.Zacute = 556, e.Zcaron = 556, e.greaterequal = 549, e.Eth = 722, e.Ccedilla = 667, e.lcommaaccent = 278, e.tcaron = 300, e.eogonek = 444, e.Uogonek = 722, e.Aacute = 611, e.Adieresis = 611, e.egrave = 444, e.zacute = 389, e.iogonek = 278, e.Oacute = 722, e.oacute = 500, e.amacron = 500, e.sacute = 389, e.idieresis = 278, e.Ocircumflex = 722, e.Ugrave = 722, e.Delta = 612, e.thorn = 500, e.twosuperior = 300, e.Odieresis = 722, e.mu = 500, e.igrave = 278, e.ohungarumlaut = 500, e.Eogonek = 611, e.dcroat = 500, e.threequarters = 750, e.Scedilla = 500, e.lcaron = 300, e.Kcommaaccent = 667, e.Lacute = 556, e.trademark = 980, e.edotaccent = 444, e.Igrave = 333, e.Imacron = 333, e.Lcaron = 611, e.onehalf = 750, e.lessequal = 549, e.ocircumflex = 500, e.ntilde = 500, e.Uhungarumlaut = 722, e.Eacute = 611, e.emacron = 444, e.gbreve = 500, e.onequarter = 750, e.Scaron = 500, e.Scommaaccent = 500, e.Ohungarumlaut = 722, e.degree = 400, e.ograve = 500, e.Ccaron = 667, e.ugrave = 500, e.radical = 453, e.Dcaron = 722, e.rcommaaccent = 389, e.Ntilde = 667, e.otilde = 500, e.Rcommaaccent = 611, e.Lcommaaccent = 556, e.Atilde = 611, e.Aogonek = 611, e.Aring = 611, e.Otilde = 722, e.zdotaccent = 389, e.Ecaron = 611, e.Iogonek = 333, e.kcommaaccent = 444, e.minus = 675, e.Icircumflex = 333, e.ncaron = 500, e.tcommaaccent = 278, e.logicalnot = 675, e.odieresis = 500, e.udieresis = 500, e.notequal = 549, e.gcommaaccent = 500, e.eth = 500, e.zcaron = 389, e.ncommaaccent = 500, e.onesuperior = 300, e.imacron = 278, e.Euro = 500;
            }), a.ZapfDingbats = (0, t.getLookupTableFactory)(function(e) {
              e.space = 278, e.a1 = 974, e.a2 = 961, e.a202 = 974, e.a3 = 980, e.a4 = 719, e.a5 = 789, e.a119 = 790, e.a118 = 791, e.a117 = 690, e.a11 = 960, e.a12 = 939, e.a13 = 549, e.a14 = 855, e.a15 = 911, e.a16 = 933, e.a105 = 911, e.a17 = 945, e.a18 = 974, e.a19 = 755, e.a20 = 846, e.a21 = 762, e.a22 = 761, e.a23 = 571, e.a24 = 677, e.a25 = 763, e.a26 = 760, e.a27 = 759, e.a28 = 754, e.a6 = 494, e.a7 = 552, e.a8 = 537, e.a9 = 577, e.a10 = 692, e.a29 = 786, e.a30 = 788, e.a31 = 788, e.a32 = 790, e.a33 = 793, e.a34 = 794, e.a35 = 816, e.a36 = 823, e.a37 = 789, e.a38 = 841, e.a39 = 823, e.a40 = 833, e.a41 = 816, e.a42 = 831, e.a43 = 923, e.a44 = 744, e.a45 = 723, e.a46 = 749, e.a47 = 790, e.a48 = 792, e.a49 = 695, e.a50 = 776, e.a51 = 768, e.a52 = 792, e.a53 = 759, e.a54 = 707, e.a55 = 708, e.a56 = 682, e.a57 = 701, e.a58 = 826, e.a59 = 815, e.a60 = 789, e.a61 = 789, e.a62 = 707, e.a63 = 687, e.a64 = 696, e.a65 = 689, e.a66 = 786, e.a67 = 787, e.a68 = 713, e.a69 = 791, e.a70 = 785, e.a71 = 791, e.a72 = 873, e.a73 = 761, e.a74 = 762, e.a203 = 762, e.a75 = 759, e.a204 = 759, e.a76 = 892, e.a77 = 892, e.a78 = 788, e.a79 = 784, e.a81 = 438, e.a82 = 138, e.a83 = 277, e.a84 = 415, e.a97 = 392, e.a98 = 392, e.a99 = 668, e.a100 = 668, e.a89 = 390, e.a90 = 390, e.a93 = 317, e.a94 = 317, e.a91 = 276, e.a92 = 276, e.a205 = 509, e.a85 = 509, e.a206 = 410, e.a86 = 410, e.a87 = 234, e.a88 = 234, e.a95 = 334, e.a96 = 334, e.a101 = 732, e.a102 = 544, e.a103 = 544, e.a104 = 910, e.a106 = 667, e.a107 = 760, e.a108 = 760, e.a112 = 776, e.a111 = 595, e.a110 = 694, e.a109 = 626, e.a120 = 788, e.a121 = 788, e.a122 = 788, e.a123 = 788, e.a124 = 788, e.a125 = 788, e.a126 = 788, e.a127 = 788, e.a128 = 788, e.a129 = 788, e.a130 = 788, e.a131 = 788, e.a132 = 788, e.a133 = 788, e.a134 = 788, e.a135 = 788, e.a136 = 788, e.a137 = 788, e.a138 = 788, e.a139 = 788, e.a140 = 788, e.a141 = 788, e.a142 = 788, e.a143 = 788, e.a144 = 788, e.a145 = 788, e.a146 = 788, e.a147 = 788, e.a148 = 788, e.a149 = 788, e.a150 = 788, e.a151 = 788, e.a152 = 788, e.a153 = 788, e.a154 = 788, e.a155 = 788, e.a156 = 788, e.a157 = 788, e.a158 = 788, e.a159 = 788, e.a160 = 894, e.a161 = 838, e.a163 = 1016, e.a164 = 458, e.a196 = 748, e.a165 = 924, e.a192 = 748, e.a166 = 918, e.a167 = 927, e.a168 = 928, e.a169 = 928, e.a170 = 834, e.a171 = 873, e.a172 = 828, e.a173 = 924, e.a162 = 924, e.a174 = 917, e.a175 = 930, e.a176 = 931, e.a177 = 463, e.a178 = 883, e.a179 = 836, e.a193 = 836, e.a180 = 867, e.a199 = 867, e.a181 = 696, e.a200 = 696, e.a182 = 874, e.a201 = 874, e.a183 = 760, e.a184 = 946, e.a197 = 771, e.a185 = 865, e.a194 = 771, e.a198 = 888, e.a186 = 967, e.a195 = 888, e.a187 = 831, e.a188 = 873, e.a189 = 927, e.a190 = 970, e.a191 = 918;
            });
          });
          u.getMetrics = i;
          const v = (0, t.getLookupTableFactory)(function(a) {
            a.Courier = {
              ascent: 629,
              descent: -157,
              capHeight: 562,
              xHeight: -426
            }, a["Courier-Bold"] = {
              ascent: 629,
              descent: -157,
              capHeight: 562,
              xHeight: 439
            }, a["Courier-Oblique"] = {
              ascent: 629,
              descent: -157,
              capHeight: 562,
              xHeight: 426
            }, a["Courier-BoldOblique"] = {
              ascent: 629,
              descent: -157,
              capHeight: 562,
              xHeight: 426
            }, a.Helvetica = {
              ascent: 718,
              descent: -207,
              capHeight: 718,
              xHeight: 523
            }, a["Helvetica-Bold"] = {
              ascent: 718,
              descent: -207,
              capHeight: 718,
              xHeight: 532
            }, a["Helvetica-Oblique"] = {
              ascent: 718,
              descent: -207,
              capHeight: 718,
              xHeight: 523
            }, a["Helvetica-BoldOblique"] = {
              ascent: 718,
              descent: -207,
              capHeight: 718,
              xHeight: 532
            }, a["Times-Roman"] = {
              ascent: 683,
              descent: -217,
              capHeight: 662,
              xHeight: 450
            }, a["Times-Bold"] = {
              ascent: 683,
              descent: -217,
              capHeight: 676,
              xHeight: 461
            }, a["Times-Italic"] = {
              ascent: 683,
              descent: -217,
              capHeight: 653,
              xHeight: 441
            }, a["Times-BoldItalic"] = {
              ascent: 683,
              descent: -217,
              capHeight: 669,
              xHeight: 462
            }, a.Symbol = {
              ascent: Math.NaN,
              descent: Math.NaN,
              capHeight: Math.NaN,
              xHeight: Math.NaN
            }, a.ZapfDingbats = {
              ascent: Math.NaN,
              descent: Math.NaN,
              capHeight: Math.NaN,
              xHeight: Math.NaN
            };
          });
          u.getFontBasicMetrics = v;
        },
        /* 46 */
        /***/
        (Q, u) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.GlyfTable = void 0;
          const P = 1 << 0, t = 1 << 1, i = 1 << 2, v = 1 << 3, a = 1 << 4, e = 1 << 5, y = 1 << 6, r = 1 << 0, h = 1 << 1, g = 1 << 3, d = 1 << 5, c = 1 << 6, n = 1 << 7, o = 1 << 8;
          class x {
            constructor({
              glyfTable: M,
              isGlyphLocationsLong: j,
              locaTable: B,
              numGlyphs: R
            }) {
              this.glyphs = [];
              const D = new DataView(B.buffer, B.byteOffset, B.byteLength), b = new DataView(M.buffer, M.byteOffset, M.byteLength), l = j ? 4 : 2;
              let _ = j ? D.getUint32(0) : 2 * D.getUint16(0), S = 0;
              for (let A = 0; A < R; A++) {
                S += l;
                const F = j ? D.getUint32(S) : 2 * D.getUint16(S);
                if (F === _) {
                  this.glyphs.push(new f({}));
                  continue;
                }
                const T = f.parse(_, b);
                this.glyphs.push(T), _ = F;
              }
            }
            getSize() {
              return this.glyphs.reduce((M, j) => {
                const B = j.getSize();
                return M + (B + 3 & -4);
              }, 0);
            }
            write() {
              const M = this.getSize(), j = new DataView(new ArrayBuffer(M)), B = M > 131070, R = B ? 4 : 2, D = new DataView(new ArrayBuffer((this.glyphs.length + 1) * R));
              B ? D.setUint32(0, 0) : D.setUint16(0, 0);
              let b = 0, l = 0;
              for (const _ of this.glyphs)
                b += _.write(b, j), b = b + 3 & -4, l += R, B ? D.setUint32(l, b) : D.setUint16(l, b >> 1);
              return {
                isLocationLong: B,
                loca: new Uint8Array(D.buffer),
                glyf: new Uint8Array(j.buffer)
              };
            }
            scale(M) {
              for (let j = 0, B = this.glyphs.length; j < B; j++)
                this.glyphs[j].scale(M[j]);
            }
          }
          u.GlyfTable = x;
          class f {
            constructor({
              header: M = null,
              simple: j = null,
              composites: B = null
            }) {
              this.header = M, this.simple = j, this.composites = B;
            }
            static parse(M, j) {
              const [B, R] = m.parse(M, j);
              if (M += B, R.numberOfContours < 0) {
                const b = [];
                for (; ; ) {
                  const [l, _] = w.parse(M, j);
                  if (M += l, b.push(_), !(_.flags & d))
                    break;
                }
                return new f({
                  header: R,
                  composites: b
                });
              }
              const D = p.parse(M, j, R.numberOfContours);
              return new f({
                header: R,
                simple: D
              });
            }
            getSize() {
              if (!this.header)
                return 0;
              const M = this.simple ? this.simple.getSize() : this.composites.reduce((j, B) => j + B.getSize(), 0);
              return this.header.getSize() + M;
            }
            write(M, j) {
              if (!this.header)
                return 0;
              const B = M;
              if (M += this.header.write(M, j), this.simple)
                M += this.simple.write(M, j);
              else
                for (const R of this.composites)
                  M += R.write(M, j);
              return M - B;
            }
            scale(M) {
              if (!this.header)
                return;
              const j = (this.header.xMin + this.header.xMax) / 2;
              if (this.header.scale(j, M), this.simple)
                this.simple.scale(j, M);
              else
                for (const B of this.composites)
                  B.scale(j, M);
            }
          }
          class m {
            constructor({
              numberOfContours: M,
              xMin: j,
              yMin: B,
              xMax: R,
              yMax: D
            }) {
              this.numberOfContours = M, this.xMin = j, this.yMin = B, this.xMax = R, this.yMax = D;
            }
            static parse(M, j) {
              return [10, new m({
                numberOfContours: j.getInt16(M),
                xMin: j.getInt16(M + 2),
                yMin: j.getInt16(M + 4),
                xMax: j.getInt16(M + 6),
                yMax: j.getInt16(M + 8)
              })];
            }
            getSize() {
              return 10;
            }
            write(M, j) {
              return j.setInt16(M, this.numberOfContours), j.setInt16(M + 2, this.xMin), j.setInt16(M + 4, this.yMin), j.setInt16(M + 6, this.xMax), j.setInt16(M + 8, this.yMax), 10;
            }
            scale(M, j) {
              this.xMin = Math.round(M + (this.xMin - M) * j), this.xMax = Math.round(M + (this.xMax - M) * j);
            }
          }
          class C {
            constructor({
              flags: M,
              xCoordinates: j,
              yCoordinates: B
            }) {
              this.xCoordinates = j, this.yCoordinates = B, this.flags = M;
            }
          }
          class p {
            constructor({
              contours: M,
              instructions: j
            }) {
              this.contours = M, this.instructions = j;
            }
            static parse(M, j, B) {
              const R = [];
              for (let K = 0; K < B; K++) {
                const W = j.getUint16(M);
                M += 2, R.push(W);
              }
              const D = R[B - 1] + 1, b = j.getUint16(M);
              M += 2;
              const l = new Uint8Array(j).slice(M, M + b);
              M += b;
              const _ = [];
              for (let K = 0; K < D; M++, K++) {
                let W = j.getUint8(M);
                if (_.push(W), W & v) {
                  const z = j.getUint8(++M);
                  W ^= v;
                  for (let V = 0; V < z; V++)
                    _.push(W);
                  K += z;
                }
              }
              const S = [];
              let A = [], F = [], T = [];
              const O = [];
              let U = 0, G = 0;
              for (let K = 0; K < D; K++) {
                const W = _[K];
                if (W & t) {
                  const z = j.getUint8(M++);
                  G += W & a ? z : -z, A.push(G);
                } else
                  W & a || (G += j.getInt16(M), M += 2), A.push(G);
                R[U] === K && (U++, S.push(A), A = []);
              }
              G = 0, U = 0;
              for (let K = 0; K < D; K++) {
                const W = _[K];
                if (W & i) {
                  const z = j.getUint8(M++);
                  G += W & e ? z : -z, F.push(G);
                } else
                  W & e || (G += j.getInt16(M), M += 2), F.push(G);
                T.push(W & P | W & y), R[U] === K && (A = S[U], U++, O.push(new C({
                  flags: T,
                  xCoordinates: A,
                  yCoordinates: F
                })), F = [], T = []);
              }
              return new p({
                contours: O,
                instructions: l
              });
            }
            getSize() {
              let M = this.contours.length * 2 + 2 + this.instructions.length, j = 0, B = 0;
              for (const R of this.contours) {
                M += R.flags.length;
                for (let D = 0, b = R.xCoordinates.length; D < b; D++) {
                  const l = R.xCoordinates[D], _ = R.yCoordinates[D];
                  let S = Math.abs(l - j);
                  S > 255 ? M += 2 : S > 0 && (M += 1), j = l, S = Math.abs(_ - B), S > 255 ? M += 2 : S > 0 && (M += 1), B = _;
                }
              }
              return M;
            }
            write(M, j) {
              const B = M, R = [], D = [], b = [];
              let l = 0, _ = 0;
              for (const S of this.contours) {
                for (let A = 0, F = S.xCoordinates.length; A < F; A++) {
                  let T = S.flags[A];
                  const O = S.xCoordinates[A];
                  let U = O - l;
                  if (U === 0)
                    T |= a, R.push(0);
                  else {
                    const K = Math.abs(U);
                    K <= 255 ? (T |= U >= 0 ? t | a : t, R.push(K)) : R.push(U);
                  }
                  l = O;
                  const G = S.yCoordinates[A];
                  if (U = G - _, U === 0)
                    T |= e, D.push(0);
                  else {
                    const K = Math.abs(U);
                    K <= 255 ? (T |= U >= 0 ? i | e : i, D.push(K)) : D.push(U);
                  }
                  _ = G, b.push(T);
                }
                j.setUint16(M, R.length - 1), M += 2;
              }
              j.setUint16(M, this.instructions.length), M += 2, this.instructions.length && (new Uint8Array(j.buffer, 0, j.buffer.byteLength).set(this.instructions, M), M += this.instructions.length);
              for (const S of b)
                j.setUint8(M++, S);
              for (let S = 0, A = R.length; S < A; S++) {
                const F = R[S], T = b[S];
                T & t ? j.setUint8(M++, F) : T & a || (j.setInt16(M, F), M += 2);
              }
              for (let S = 0, A = D.length; S < A; S++) {
                const F = D[S], T = b[S];
                T & i ? j.setUint8(M++, F) : T & e || (j.setInt16(M, F), M += 2);
              }
              return M - B;
            }
            scale(M, j) {
              for (const B of this.contours)
                if (B.xCoordinates.length !== 0)
                  for (let R = 0, D = B.xCoordinates.length; R < D; R++)
                    B.xCoordinates[R] = Math.round(M + (B.xCoordinates[R] - M) * j);
            }
          }
          class w {
            constructor({
              flags: M,
              glyphIndex: j,
              argument1: B,
              argument2: R,
              transf: D,
              instructions: b
            }) {
              this.flags = M, this.glyphIndex = j, this.argument1 = B, this.argument2 = R, this.transf = D, this.instructions = b;
            }
            static parse(M, j) {
              const B = M, R = [];
              let D = j.getUint16(M);
              const b = j.getUint16(M + 2);
              M += 4;
              let l, _;
              D & r ? (D & h ? (l = j.getInt16(M), _ = j.getInt16(M + 2)) : (l = j.getUint16(M), _ = j.getUint16(M + 2)), M += 4, D ^= r) : (D & h ? (l = j.getInt8(M), _ = j.getInt8(M + 1)) : (l = j.getUint8(M), _ = j.getUint8(M + 1)), M += 2), D & g ? (R.push(j.getUint16(M)), M += 2) : D & c ? (R.push(j.getUint16(M), j.getUint16(M + 2)), M += 4) : D & n && (R.push(j.getUint16(M), j.getUint16(M + 2), j.getUint16(M + 4), j.getUint16(M + 6)), M += 8);
              let S = null;
              if (D & o) {
                const A = j.getUint16(M);
                M += 2, S = new Uint8Array(j).slice(M, M + A), M += A;
              }
              return [M - B, new w({
                flags: D,
                glyphIndex: b,
                argument1: l,
                argument2: _,
                transf: R,
                instructions: S
              })];
            }
            getSize() {
              let M = 4 + this.transf.length * 2;
              return this.flags & o && (M += 2 + this.instructions.length), M += 2, this.flags & 2 ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (M += 2) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (M += 2), M;
            }
            write(M, j) {
              const B = M;
              return this.flags & h ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (this.flags |= r) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (this.flags |= r), j.setUint16(M, this.flags), j.setUint16(M + 2, this.glyphIndex), M += 4, this.flags & r ? (this.flags & h ? (j.setInt16(M, this.argument1), j.setInt16(M + 2, this.argument2)) : (j.setUint16(M, this.argument1), j.setUint16(M + 2, this.argument2)), M += 4) : (j.setUint8(M, this.argument1), j.setUint8(M + 1, this.argument2), M += 2), this.flags & o && (j.setUint16(M, this.instructions.length), M += 2, this.instructions.length && (new Uint8Array(j.buffer, 0, j.buffer.byteLength).set(this.instructions, M), M += this.instructions.length)), M - B;
            }
            scale(M, j) {
            }
          }
        },
        /* 47 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.OpenTypeFileBuilder = void 0;
          var t = P(6), i = P(2);
          function v(g, d, c) {
            g[d] = c >> 8 & 255, g[d + 1] = c & 255;
          }
          function a(g, d, c) {
            g[d] = c >> 24 & 255, g[d + 1] = c >> 16 & 255, g[d + 2] = c >> 8 & 255, g[d + 3] = c & 255;
          }
          function e(g, d, c) {
            if (c instanceof Uint8Array)
              g.set(c, d);
            else if (typeof c == "string")
              for (let n = 0, o = c.length; n < o; n++)
                g[d++] = c.charCodeAt(n) & 255;
            else
              for (let n = 0, o = c.length; n < o; n++)
                g[d++] = c[n] & 255;
          }
          const y = 12, r = 16;
          class h {
            constructor(d) {
              this.sfnt = d, this.tables = /* @__PURE__ */ Object.create(null);
            }
            static getSearchParams(d, c) {
              let n = 1, o = 0;
              for (; (n ^ d) > n; )
                n <<= 1, o++;
              const x = n * c;
              return {
                range: x,
                entry: o,
                rangeShift: c * d - x
              };
            }
            toArray() {
              let d = this.sfnt;
              const c = this.tables, n = Object.keys(c);
              n.sort();
              const o = n.length;
              let x, f, m, C, p, w = y + o * r;
              const X = [w];
              for (x = 0; x < o; x++) {
                C = c[n[x]];
                const B = (C.length + 3 & -4) >>> 0;
                w += B, X.push(w);
              }
              const M = new Uint8Array(w);
              for (x = 0; x < o; x++)
                C = c[n[x]], e(M, X[x], C);
              d === "true" && (d = (0, i.string32)(65536)), M[0] = d.charCodeAt(0) & 255, M[1] = d.charCodeAt(1) & 255, M[2] = d.charCodeAt(2) & 255, M[3] = d.charCodeAt(3) & 255, v(M, 4, o);
              const j = h.getSearchParams(o, 16);
              for (v(M, 6, j.range), v(M, 8, j.entry), v(M, 10, j.rangeShift), w = y, x = 0; x < o; x++) {
                p = n[x], M[w] = p.charCodeAt(0) & 255, M[w + 1] = p.charCodeAt(1) & 255, M[w + 2] = p.charCodeAt(2) & 255, M[w + 3] = p.charCodeAt(3) & 255;
                let B = 0;
                for (f = X[x], m = X[x + 1]; f < m; f += 4) {
                  const R = (0, t.readUint32)(M, f);
                  B = B + R >>> 0;
                }
                a(M, w + 4, B), a(M, w + 8, X[x]), a(M, w + 12, c[p].length), w += r;
              }
              return M;
            }
            addTable(d, c) {
              if (d in this.tables)
                throw new Error("Table " + d + " already exists");
              this.tables[d] = c;
            }
          }
          u.OpenTypeFileBuilder = h;
        },
        /* 48 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.Type1Font = void 0;
          var t = P(35), i = P(38), v = P(6), a = P(10), e = P(49), y = P(2);
          function r(c, n, o) {
            const x = c.length, f = n.length, m = x - f;
            let C = o, p = !1;
            for (; C < m; ) {
              let w = 0;
              for (; w < f && c[C + w] === n[w]; )
                w++;
              if (w >= f) {
                for (C += w; C < x && (0, v.isWhiteSpace)(c[C]); )
                  C++;
                p = !0;
                break;
              }
              C++;
            }
            return {
              found: p,
              length: C
            };
          }
          function h(c, n) {
            const o = [101, 101, 120, 101, 99], x = c.pos;
            let f, m, C;
            try {
              f = c.getBytes(n), m = f.length;
            } catch {
            }
            if (m === n && (C = r(f, o, n - 2 * o.length), C.found && C.length === n))
              return {
                stream: new a.Stream(f),
                length: n
              };
            (0, y.warn)('Invalid "Length1" property in Type1 font -- trying to recover.'), c.pos = x;
            const p = 2048;
            let w;
            for (; ; ) {
              const X = c.peekBytes(p);
              if (C = r(X, o, 0), C.length === 0)
                break;
              if (c.pos += C.length, C.found) {
                w = c.pos - x;
                break;
              }
            }
            return c.pos = x, w ? {
              stream: new a.Stream(c.getBytes(w)),
              length: w
            } : ((0, y.warn)('Unable to recover "Length1" property in Type1 font -- using as is.'), {
              stream: new a.Stream(c.getBytes(n)),
              length: n
            });
          }
          function g(c, n) {
            const o = c.getBytes();
            return {
              stream: new a.Stream(o),
              length: o.length
            };
          }
          class d {
            constructor(n, o, x) {
              let m = x.length1;
              x.length2;
              let C = o.peekBytes(6);
              const p = C[0] === 128 && C[1] === 1;
              p && (o.skip(6), m = C[5] << 24 | C[4] << 16 | C[3] << 8 | C[2]);
              const w = h(o, m);
              new e.Type1Parser(w.stream, !1, i.SEAC_ANALYSIS_ENABLED).extractFontHeader(x), p && (C = o.getBytes(6), C[5] << 24 | C[4] << 16 | C[3] << 8 | C[2]);
              const M = g(o), B = new e.Type1Parser(M.stream, !0, i.SEAC_ANALYSIS_ENABLED).extractFontProgram(x);
              for (const l in B.properties)
                x[l] = B.properties[l];
              const R = B.charstrings, D = this.getType2Charstrings(R), b = this.getType2Subrs(B.subrs);
              this.charstrings = R, this.data = this.wrap(n, D, this.charstrings, b, x), this.seacs = this.getSeacs(B.charstrings);
            }
            get numGlyphs() {
              return this.charstrings.length + 1;
            }
            getCharset() {
              const n = [".notdef"];
              for (const {
                glyphName: o
              } of this.charstrings)
                n.push(o);
              return n;
            }
            getGlyphMapping(n) {
              const o = this.charstrings;
              if (n.composite) {
                const p = /* @__PURE__ */ Object.create(null);
                for (let w = 0, X = o.length; w < X; w++) {
                  const M = n.cMap.charCodeOf(w);
                  p[M] = w + 1;
                }
                return p;
              }
              const x = [".notdef"];
              let f, m;
              for (m = 0; m < o.length; m++)
                x.push(o[m].glyphName);
              const C = n.builtInEncoding;
              if (C) {
                f = /* @__PURE__ */ Object.create(null);
                for (const p in C)
                  m = x.indexOf(C[p]), m >= 0 && (f[p] = m);
              }
              return (0, i.type1FontGlyphMapping)(n, f, x);
            }
            hasGlyphId(n) {
              return n < 0 || n >= this.numGlyphs ? !1 : n === 0 ? !0 : this.charstrings[n - 1].charstring.length > 0;
            }
            getSeacs(n) {
              const o = [];
              for (let x = 0, f = n.length; x < f; x++) {
                const m = n[x];
                m.seac && (o[x + 1] = m.seac);
              }
              return o;
            }
            getType2Charstrings(n) {
              const o = [];
              for (let x = 0, f = n.length; x < f; x++)
                o.push(n[x].charstring);
              return o;
            }
            getType2Subrs(n) {
              let o = 0;
              const x = n.length;
              x < 1133 ? o = 107 : x < 33769 ? o = 1131 : o = 32768;
              const f = [];
              let m;
              for (m = 0; m < o; m++)
                f.push([11]);
              for (m = 0; m < x; m++)
                f.push(n[m]);
              return f;
            }
            wrap(n, o, x, f, m) {
              const C = new t.CFF();
              C.header = new t.CFFHeader(1, 0, 4, 4), C.names = [n];
              const p = new t.CFFTopDict();
              p.setByName("version", 391), p.setByName("Notice", 392), p.setByName("FullName", 393), p.setByName("FamilyName", 394), p.setByName("Weight", 395), p.setByName("Encoding", null), p.setByName("FontMatrix", m.fontMatrix), p.setByName("FontBBox", m.bbox), p.setByName("charset", null), p.setByName("CharStrings", null), p.setByName("Private", null), C.topDict = p;
              const w = new t.CFFStrings();
              w.add("Version 0.11"), w.add("See original notice"), w.add(n), w.add(n), w.add("Medium"), C.strings = w, C.globalSubrIndex = new t.CFFIndex();
              const X = o.length, M = [".notdef"];
              let j, B;
              for (j = 0; j < X; j++) {
                const S = x[j].glyphName;
                t.CFFStandardStrings.indexOf(S) === -1 && w.add(S), M.push(S);
              }
              C.charset = new t.CFFCharset(!1, 0, M);
              const R = new t.CFFIndex();
              for (R.add([139, 14]), j = 0; j < X; j++)
                R.add(o[j]);
              C.charStrings = R;
              const D = new t.CFFPrivateDict();
              D.setByName("Subrs", null);
              const b = ["BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StemSnapH", "StemSnapV", "BlueShift", "BlueFuzz", "BlueScale", "LanguageGroup", "ExpansionFactor", "ForceBold", "StdHW", "StdVW"];
              for (j = 0, B = b.length; j < B; j++) {
                const S = b[j];
                if (!(S in m.privateData))
                  continue;
                const A = m.privateData[S];
                if (Array.isArray(A))
                  for (let F = A.length - 1; F > 0; F--)
                    A[F] -= A[F - 1];
                D.setByName(S, A);
              }
              C.topDict.privateDict = D;
              const l = new t.CFFIndex();
              for (j = 0, B = f.length; j < B; j++)
                l.add(f[j]);
              return D.subrsIndex = l, new t.CFFCompiler(C).compile();
            }
          }
          u.Type1Font = d;
        },
        /* 49 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.Type1Parser = void 0;
          var t = P(37), i = P(6), v = P(10), a = P(2);
          const e = !1, y = {
            hstem: [1],
            vstem: [3],
            vmoveto: [4],
            rlineto: [5],
            hlineto: [6],
            vlineto: [7],
            rrcurveto: [8],
            callsubr: [10],
            flex: [12, 35],
            drop: [12, 18],
            endchar: [14],
            rmoveto: [21],
            hmoveto: [22],
            vhcurveto: [30],
            hvcurveto: [31]
          };
          class r {
            constructor() {
              this.width = 0, this.lsb = 0, this.flexing = !1, this.output = [], this.stack = [];
            }
            convert(m, C, p) {
              const w = m.length;
              let X = !1, M, j, B;
              for (let R = 0; R < w; R++) {
                let D = m[R];
                if (D < 32) {
                  switch (D === 12 && (D = (D << 8) + m[++R]), D) {
                    case 1: {
                      this.stack = [];
                      break;
                    }
                    case 3: {
                      this.stack = [];
                      break;
                    }
                    case 4:
                      if (this.flexing) {
                        if (this.stack.length < 1) {
                          X = !0;
                          break;
                        }
                        const A = this.stack.pop();
                        this.stack.push(0, A);
                        break;
                      }
                      X = this.executeCommand(1, y.vmoveto);
                      break;
                    case 5:
                      X = this.executeCommand(2, y.rlineto);
                      break;
                    case 6:
                      X = this.executeCommand(1, y.hlineto);
                      break;
                    case 7:
                      X = this.executeCommand(1, y.vlineto);
                      break;
                    case 8:
                      X = this.executeCommand(6, y.rrcurveto);
                      break;
                    case 9:
                      this.stack = [];
                      break;
                    case 10:
                      if (this.stack.length < 1) {
                        X = !0;
                        break;
                      }
                      if (B = this.stack.pop(), !C[B]) {
                        X = !0;
                        break;
                      }
                      X = this.convert(C[B], C, p);
                      break;
                    case 11:
                      return X;
                    case 13:
                      if (this.stack.length < 2) {
                        X = !0;
                        break;
                      }
                      M = this.stack.pop(), j = this.stack.pop(), this.lsb = j, this.width = M, this.stack.push(M, j), X = this.executeCommand(2, y.hmoveto);
                      break;
                    case 14:
                      this.output.push(y.endchar[0]);
                      break;
                    case 21:
                      if (this.flexing)
                        break;
                      X = this.executeCommand(2, y.rmoveto);
                      break;
                    case 22:
                      if (this.flexing) {
                        this.stack.push(0);
                        break;
                      }
                      X = this.executeCommand(1, y.hmoveto);
                      break;
                    case 30:
                      X = this.executeCommand(4, y.vhcurveto);
                      break;
                    case 31:
                      X = this.executeCommand(4, y.hvcurveto);
                      break;
                    case 3072:
                      this.stack = [];
                      break;
                    case 3073: {
                      this.stack = [];
                      break;
                    }
                    case 3074: {
                      this.stack = [];
                      break;
                    }
                    case 3078:
                      if (p) {
                        const A = this.stack.at(-5);
                        this.seac = this.stack.splice(-4, 4), this.seac[0] += this.lsb - A, X = this.executeCommand(0, y.endchar);
                      } else
                        X = this.executeCommand(4, y.endchar);
                      break;
                    case 3079:
                      if (this.stack.length < 4) {
                        X = !0;
                        break;
                      }
                      this.stack.pop(), M = this.stack.pop();
                      const b = this.stack.pop();
                      j = this.stack.pop(), this.lsb = j, this.width = M, this.stack.push(M, j, b), X = this.executeCommand(3, y.rmoveto);
                      break;
                    case 3084:
                      if (this.stack.length < 2) {
                        X = !0;
                        break;
                      }
                      const l = this.stack.pop(), _ = this.stack.pop();
                      this.stack.push(_ / l);
                      break;
                    case 3088:
                      if (this.stack.length < 2) {
                        X = !0;
                        break;
                      }
                      B = this.stack.pop();
                      const S = this.stack.pop();
                      if (B === 0 && S === 3) {
                        const A = this.stack.splice(this.stack.length - 17, 17);
                        this.stack.push(A[2] + A[0], A[3] + A[1], A[4], A[5], A[6], A[7], A[8], A[9], A[10], A[11], A[12], A[13], A[14]), X = this.executeCommand(13, y.flex, !0), this.flexing = !1, this.stack.push(A[15], A[16]);
                      } else
                        B === 1 && S === 0 && (this.flexing = !0);
                      break;
                    case 3089:
                      break;
                    case 3105:
                      this.stack = [];
                      break;
                    default:
                      (0, a.warn)('Unknown type 1 charstring command of "' + D + '"');
                      break;
                  }
                  if (X)
                    break;
                  continue;
                } else
                  D <= 246 ? D -= 139 : D <= 250 ? D = (D - 247) * 256 + m[++R] + 108 : D <= 254 ? D = -((D - 251) * 256) - m[++R] - 108 : D = (m[++R] & 255) << 24 | (m[++R] & 255) << 16 | (m[++R] & 255) << 8 | (m[++R] & 255) << 0;
                this.stack.push(D);
              }
              return X;
            }
            executeCommand(m, C, p) {
              const w = this.stack.length;
              if (m > w)
                return !0;
              const X = w - m;
              for (let M = X; M < w; M++) {
                let j = this.stack[M];
                Number.isInteger(j) ? this.output.push(28, j >> 8 & 255, j & 255) : (j = 65536 * j | 0, this.output.push(255, j >> 24 & 255, j >> 16 & 255, j >> 8 & 255, j & 255));
              }
              return this.output.push(...C), p ? this.stack.splice(X, m) : this.stack.length = 0, !1;
            }
          }
          const h = 55665, g = 4330;
          function d(f) {
            return f >= 48 && f <= 57 || f >= 65 && f <= 70 || f >= 97 && f <= 102;
          }
          function c(f, m, C) {
            if (C >= f.length)
              return new Uint8Array(0);
            const p = 52845, w = 22719;
            let X = m | 0, M, j;
            for (M = 0; M < C; M++)
              X = (f[M] + X) * p + w & 65535;
            const B = f.length - C, R = new Uint8Array(B);
            for (M = C, j = 0; j < B; M++, j++) {
              const D = f[M];
              R[j] = D ^ X >> 8, X = (D + X) * p + w & 65535;
            }
            return R;
          }
          function n(f, m, C) {
            let X = m | 0;
            const M = f.length, j = M >>> 1, B = new Uint8Array(j);
            let R, D;
            for (R = 0, D = 0; R < M; R++) {
              const b = f[R];
              if (!d(b))
                continue;
              R++;
              let l;
              for (; R < M && !d(l = f[R]); )
                R++;
              if (R < M) {
                const _ = parseInt(String.fromCharCode(b, l), 16);
                B[D++] = _ ^ X >> 8, X = (_ + X) * 52845 + 22719 & 65535;
              }
            }
            return B.slice(C, D);
          }
          function o(f) {
            return f === 47 || f === 91 || f === 93 || f === 123 || f === 125 || f === 40 || f === 41;
          }
          class x {
            constructor(m, C, p) {
              if (C) {
                const w = m.getBytes(), X = !((d(w[0]) || (0, i.isWhiteSpace)(w[0])) && d(w[1]) && d(w[2]) && d(w[3]) && d(w[4]) && d(w[5]) && d(w[6]) && d(w[7]));
                m = new v.Stream(X ? c(w, h, 4) : n(w, h, 4));
              }
              this.seacAnalysisEnabled = !!p, this.stream = m, this.nextChar();
            }
            readNumberArray() {
              this.getToken();
              const m = [];
              for (; ; ) {
                const C = this.getToken();
                if (C === null || C === "]" || C === "}")
                  break;
                m.push(parseFloat(C || 0));
              }
              return m;
            }
            readNumber() {
              const m = this.getToken();
              return parseFloat(m || 0);
            }
            readInt() {
              const m = this.getToken();
              return parseInt(m || 0, 10) | 0;
            }
            readBoolean() {
              return this.getToken() === "true" ? 1 : 0;
            }
            nextChar() {
              return this.currentChar = this.stream.getByte();
            }
            prevChar() {
              return this.stream.skip(-2), this.currentChar = this.stream.getByte();
            }
            getToken() {
              let m = !1, C = this.currentChar;
              for (; ; ) {
                if (C === -1)
                  return null;
                if (m)
                  (C === 10 || C === 13) && (m = !1);
                else if (C === 37)
                  m = !0;
                else if (!(0, i.isWhiteSpace)(C))
                  break;
                C = this.nextChar();
              }
              if (o(C))
                return this.nextChar(), String.fromCharCode(C);
              let p = "";
              do
                p += String.fromCharCode(C), C = this.nextChar();
              while (C >= 0 && !(0, i.isWhiteSpace)(C) && !o(C));
              return p;
            }
            readCharStrings(m, C) {
              return C === -1 ? m : c(m, g, C);
            }
            extractFontProgram(m) {
              const C = this.stream, p = [], w = [], X = /* @__PURE__ */ Object.create(null);
              X.lenIV = 4;
              const M = {
                subrs: [],
                charstrings: [],
                properties: {
                  privateData: X
                }
              };
              let j, B, R, D;
              for (; (j = this.getToken()) !== null; )
                if (j === "/")
                  switch (j = this.getToken(), j) {
                    case "CharStrings":
                      for (this.getToken(), this.getToken(), this.getToken(), this.getToken(); j = this.getToken(), !(j === null || j === "end"); ) {
                        if (j !== "/")
                          continue;
                        const l = this.getToken();
                        B = this.readInt(), this.getToken(), R = B > 0 ? C.getBytes(B) : new Uint8Array(0), D = M.properties.privateData.lenIV;
                        const _ = this.readCharStrings(R, D);
                        this.nextChar(), j = this.getToken(), j === "noaccess" ? this.getToken() : j === "/" && this.prevChar(), w.push({
                          glyph: l,
                          encoded: _
                        });
                      }
                      break;
                    case "Subrs":
                      for (this.readInt(), this.getToken(); this.getToken() === "dup"; ) {
                        const l = this.readInt();
                        B = this.readInt(), this.getToken(), R = B > 0 ? C.getBytes(B) : new Uint8Array(0), D = M.properties.privateData.lenIV;
                        const _ = this.readCharStrings(R, D);
                        this.nextChar(), j = this.getToken(), j === "noaccess" && this.getToken(), p[l] = _;
                      }
                      break;
                    case "BlueValues":
                    case "OtherBlues":
                    case "FamilyBlues":
                    case "FamilyOtherBlues":
                      const b = this.readNumberArray();
                      b.length > 0 && b.length % 2 === 0 && e && (M.properties.privateData[j] = b);
                      break;
                    case "StemSnapH":
                    case "StemSnapV":
                      M.properties.privateData[j] = this.readNumberArray();
                      break;
                    case "StdHW":
                    case "StdVW":
                      M.properties.privateData[j] = this.readNumberArray()[0];
                      break;
                    case "BlueShift":
                    case "lenIV":
                    case "BlueFuzz":
                    case "BlueScale":
                    case "LanguageGroup":
                    case "ExpansionFactor":
                      M.properties.privateData[j] = this.readNumber();
                      break;
                    case "ForceBold":
                      M.properties.privateData[j] = this.readBoolean();
                      break;
                  }
              for (const {
                encoded: b,
                glyph: l
              } of w) {
                const _ = new r(), S = _.convert(b, p, this.seacAnalysisEnabled);
                let A = _.output;
                S && (A = [14]);
                const F = {
                  glyphName: l,
                  charstring: A,
                  width: _.width,
                  lsb: _.lsb,
                  seac: _.seac
                };
                if (l === ".notdef" ? M.charstrings.unshift(F) : M.charstrings.push(F), m.builtInEncoding) {
                  const T = m.builtInEncoding.indexOf(l);
                  T > -1 && m.widths[T] === void 0 && T >= m.firstChar && T <= m.lastChar && (m.widths[T] = _.width);
                }
              }
              return M;
            }
            extractFontHeader(m) {
              let C;
              for (; (C = this.getToken()) !== null; )
                if (C === "/")
                  switch (C = this.getToken(), C) {
                    case "FontMatrix":
                      const p = this.readNumberArray();
                      m.fontMatrix = p;
                      break;
                    case "Encoding":
                      const w = this.getToken();
                      let X;
                      if (!/^\d+$/.test(w))
                        X = (0, t.getEncoding)(w);
                      else {
                        X = [];
                        const j = parseInt(w, 10) | 0;
                        this.getToken();
                        for (let B = 0; B < j; B++) {
                          for (C = this.getToken(); C !== "dup" && C !== "def"; )
                            if (C = this.getToken(), C === null)
                              return;
                          if (C === "def")
                            break;
                          const R = this.readInt();
                          this.getToken();
                          const D = this.getToken();
                          X[R] = D, this.getToken();
                        }
                      }
                      m.builtInEncoding = X;
                      break;
                    case "FontBBox":
                      const M = this.readNumberArray();
                      m.ascent = Math.max(M[3], M[1]), m.descent = Math.min(M[1], M[3]), m.ascentScaled = !0;
                      break;
                  }
            }
          }
          u.Type1Parser = x;
        },
        /* 50 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.Pattern = void 0, u.getTilingPatternIR = o;
          var t = P(2), i = P(7), v = P(14), a = P(6);
          const e = {
            FUNCTION_BASED: 1,
            AXIAL: 2,
            RADIAL: 3,
            FREE_FORM_MESH: 4,
            LATTICE_FORM_MESH: 5,
            COONS_PATCH_MESH: 6,
            TENSOR_PATCH_MESH: 7
          };
          class y {
            constructor() {
              (0, t.unreachable)("Cannot initialize Pattern.");
            }
            static parseShading(f, m, C, p, w, X) {
              const M = f instanceof i.BaseStream ? f.dict : f, j = M.get("ShadingType");
              try {
                switch (j) {
                  case e.AXIAL:
                  case e.RADIAL:
                    return new h(M, m, C, w, X);
                  case e.FREE_FORM_MESH:
                  case e.LATTICE_FORM_MESH:
                  case e.COONS_PATCH_MESH:
                  case e.TENSOR_PATCH_MESH:
                    return new c(f, m, C, w, X);
                  default:
                    throw new t.FormatError("Unsupported ShadingType: " + j);
                }
              } catch (B) {
                if (B instanceof a.MissingDataException)
                  throw B;
                return p.send("UnsupportedFeature", {
                  featureId: t.UNSUPPORTED_FEATURES.shadingPattern
                }), (0, t.warn)(B), new n();
              }
            }
          }
          u.Pattern = y;
          class r {
            static get SMALL_NUMBER() {
              return (0, t.shadow)(this, "SMALL_NUMBER", 1e-6);
            }
            constructor() {
              this.constructor === r && (0, t.unreachable)("Cannot initialize BaseShading.");
            }
            getIR() {
              (0, t.unreachable)("Abstract method `getIR` called.");
            }
          }
          class h extends r {
            constructor(f, m, C, p, w) {
              super(), this.coordsArr = f.getArray("Coords"), this.shadingType = f.get("ShadingType");
              const X = v.ColorSpace.parse({
                cs: f.getRaw("CS") || f.getRaw("ColorSpace"),
                xref: m,
                resources: C,
                pdfFunctionFactory: p,
                localColorSpaceCache: w
              }), M = f.getArray("BBox");
              Array.isArray(M) && M.length === 4 ? this.bbox = t.Util.normalizeRect(M) : this.bbox = null;
              let j = 0, B = 1;
              if (f.has("Domain")) {
                const G = f.getArray("Domain");
                j = G[0], B = G[1];
              }
              let R = !1, D = !1;
              if (f.has("Extend")) {
                const G = f.getArray("Extend");
                R = G[0], D = G[1];
              }
              if (this.shadingType === e.RADIAL && (!R || !D)) {
                const [G, K, W, z, V, L] = this.coordsArr, Y = Math.hypot(G - z, K - V);
                W <= L + Y && L <= W + Y && (0, t.warn)("Unsupported radial gradient.");
              }
              this.extendStart = R, this.extendEnd = D;
              const b = f.getRaw("Function"), l = p.createFromArray(b), _ = 10, S = (B - j) / _, A = this.colorStops = [];
              if (j >= B || S <= 0) {
                (0, t.info)("Bad shading domain.");
                return;
              }
              const F = new Float32Array(X.numComps), T = new Float32Array(1);
              let O;
              for (let G = 0; G <= _; G++) {
                T[0] = j + G * S, l(T, 0, F, 0), O = X.getRgb(F, 0);
                const K = t.Util.makeHexColor(O[0], O[1], O[2]);
                A.push([G / _, K]);
              }
              let U = "transparent";
              f.has("Background") && (O = X.getRgb(f.get("Background"), 0), U = t.Util.makeHexColor(O[0], O[1], O[2])), R || (A.unshift([0, U]), A[1][0] += r.SMALL_NUMBER), D || (A.at(-1)[0] -= r.SMALL_NUMBER, A.push([1, U])), this.colorStops = A;
            }
            getIR() {
              const f = this.coordsArr, m = this.shadingType;
              let C, p, w, X, M;
              return m === e.AXIAL ? (p = [f[0], f[1]], w = [f[2], f[3]], X = null, M = null, C = "axial") : m === e.RADIAL ? (p = [f[0], f[1]], w = [f[3], f[4]], X = f[2], M = f[5], C = "radial") : (0, t.unreachable)(`getPattern type unknown: ${m}`), ["RadialAxial", C, this.bbox, this.colorStops, p, w, X, M];
            }
          }
          class g {
            constructor(f, m) {
              this.stream = f, this.context = m, this.buffer = 0, this.bufferLength = 0;
              const C = m.numComps;
              this.tmpCompsBuf = new Float32Array(C);
              const p = m.colorSpace.numComps;
              this.tmpCsCompsBuf = m.colorFn ? new Float32Array(p) : this.tmpCompsBuf;
            }
            get hasData() {
              if (this.stream.end)
                return this.stream.pos < this.stream.end;
              if (this.bufferLength > 0)
                return !0;
              const f = this.stream.getByte();
              return f < 0 ? !1 : (this.buffer = f, this.bufferLength = 8, !0);
            }
            readBits(f) {
              let m = this.buffer, C = this.bufferLength;
              if (f === 32) {
                if (C === 0)
                  return (this.stream.getByte() << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte()) >>> 0;
                m = m << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte();
                const p = this.stream.getByte();
                return this.buffer = p & (1 << C) - 1, (m << 8 - C | (p & 255) >> C) >>> 0;
              }
              if (f === 8 && C === 0)
                return this.stream.getByte();
              for (; C < f; )
                m = m << 8 | this.stream.getByte(), C += 8;
              return C -= f, this.bufferLength = C, this.buffer = m & (1 << C) - 1, m >> C;
            }
            align() {
              this.buffer = 0, this.bufferLength = 0;
            }
            readFlag() {
              return this.readBits(this.context.bitsPerFlag);
            }
            readCoordinate() {
              const f = this.context.bitsPerCoordinate, m = this.readBits(f), C = this.readBits(f), p = this.context.decode, w = f < 32 ? 1 / ((1 << f) - 1) : 23283064365386963e-26;
              return [m * w * (p[1] - p[0]) + p[0], C * w * (p[3] - p[2]) + p[2]];
            }
            readComponents() {
              const f = this.context.numComps, m = this.context.bitsPerComponent, C = m < 32 ? 1 / ((1 << m) - 1) : 23283064365386963e-26, p = this.context.decode, w = this.tmpCompsBuf;
              for (let M = 0, j = 4; M < f; M++, j += 2) {
                const B = this.readBits(m);
                w[M] = B * C * (p[j + 1] - p[j]) + p[j];
              }
              const X = this.tmpCsCompsBuf;
              return this.context.colorFn && this.context.colorFn(w, 0, X, 0), this.context.colorSpace.getRgb(X, 0);
            }
          }
          const d = function() {
            function f(C) {
              const p = [];
              for (let w = 0; w <= C; w++) {
                const X = w / C, M = 1 - X;
                p.push(new Float32Array([M * M * M, 3 * X * M * M, 3 * X * X * M, X * X * X]));
              }
              return p;
            }
            const m = [];
            return function(C) {
              return m[C] || (m[C] = f(C)), m[C];
            };
          }();
          class c extends r {
            static get MIN_SPLIT_PATCH_CHUNKS_AMOUNT() {
              return (0, t.shadow)(this, "MIN_SPLIT_PATCH_CHUNKS_AMOUNT", 3);
            }
            static get MAX_SPLIT_PATCH_CHUNKS_AMOUNT() {
              return (0, t.shadow)(this, "MAX_SPLIT_PATCH_CHUNKS_AMOUNT", 20);
            }
            static get TRIANGLE_DENSITY() {
              return (0, t.shadow)(this, "TRIANGLE_DENSITY", 20);
            }
            constructor(f, m, C, p, w) {
              if (super(), !(f instanceof i.BaseStream))
                throw new t.FormatError("Mesh data is not a stream");
              const X = f.dict;
              this.shadingType = X.get("ShadingType");
              const M = X.getArray("BBox");
              Array.isArray(M) && M.length === 4 ? this.bbox = t.Util.normalizeRect(M) : this.bbox = null;
              const j = v.ColorSpace.parse({
                cs: X.getRaw("CS") || X.getRaw("ColorSpace"),
                xref: m,
                resources: C,
                pdfFunctionFactory: p,
                localColorSpaceCache: w
              });
              this.background = X.has("Background") ? j.getRgb(X.get("Background"), 0) : null;
              const B = X.getRaw("Function"), R = B ? p.createFromArray(B) : null;
              this.coords = [], this.colors = [], this.figures = [];
              const D = {
                bitsPerCoordinate: X.get("BitsPerCoordinate"),
                bitsPerComponent: X.get("BitsPerComponent"),
                bitsPerFlag: X.get("BitsPerFlag"),
                decode: X.getArray("Decode"),
                colorFn: R,
                colorSpace: j,
                numComps: R ? 1 : j.numComps
              }, b = new g(f, D);
              let l = !1;
              switch (this.shadingType) {
                case e.FREE_FORM_MESH:
                  this._decodeType4Shading(b);
                  break;
                case e.LATTICE_FORM_MESH:
                  const _ = X.get("VerticesPerRow") | 0;
                  if (_ < 2)
                    throw new t.FormatError("Invalid VerticesPerRow");
                  this._decodeType5Shading(b, _);
                  break;
                case e.COONS_PATCH_MESH:
                  this._decodeType6Shading(b), l = !0;
                  break;
                case e.TENSOR_PATCH_MESH:
                  this._decodeType7Shading(b), l = !0;
                  break;
                default:
                  (0, t.unreachable)("Unsupported mesh type.");
                  break;
              }
              if (l) {
                this._updateBounds();
                for (let _ = 0, S = this.figures.length; _ < S; _++)
                  this._buildFigureFromPatch(_);
              }
              this._updateBounds(), this._packData();
            }
            _decodeType4Shading(f) {
              const m = this.coords, C = this.colors, p = [];
              let w = 0;
              for (; f.hasData; ) {
                const X = f.readFlag(), M = f.readCoordinate(), j = f.readComponents();
                if (w === 0) {
                  if (!(0 <= X && X <= 2))
                    throw new t.FormatError("Unknown type4 flag");
                  switch (X) {
                    case 0:
                      w = 3;
                      break;
                    case 1:
                      p.push(p.at(-2), p.at(-1)), w = 1;
                      break;
                    case 2:
                      p.push(p.at(-3), p.at(-1)), w = 1;
                      break;
                  }
                }
                p.push(m.length), m.push(M), C.push(j), w--, f.align();
              }
              this.figures.push({
                type: "triangles",
                coords: new Int32Array(p),
                colors: new Int32Array(p)
              });
            }
            _decodeType5Shading(f, m) {
              const C = this.coords, p = this.colors, w = [];
              for (; f.hasData; ) {
                const X = f.readCoordinate(), M = f.readComponents();
                w.push(C.length), C.push(X), p.push(M);
              }
              this.figures.push({
                type: "lattice",
                coords: new Int32Array(w),
                colors: new Int32Array(w),
                verticesPerRow: m
              });
            }
            _decodeType6Shading(f) {
              const m = this.coords, C = this.colors, p = new Int32Array(16), w = new Int32Array(4);
              for (; f.hasData; ) {
                const X = f.readFlag();
                if (!(0 <= X && X <= 3))
                  throw new t.FormatError("Unknown type6 flag");
                const M = m.length;
                for (let l = 0, _ = X !== 0 ? 8 : 12; l < _; l++)
                  m.push(f.readCoordinate());
                const j = C.length;
                for (let l = 0, _ = X !== 0 ? 2 : 4; l < _; l++)
                  C.push(f.readComponents());
                let B, R, D, b;
                switch (X) {
                  case 0:
                    p[12] = M + 3, p[13] = M + 4, p[14] = M + 5, p[15] = M + 6, p[8] = M + 2, p[11] = M + 7, p[4] = M + 1, p[7] = M + 8, p[0] = M, p[1] = M + 11, p[2] = M + 10, p[3] = M + 9, w[2] = j + 1, w[3] = j + 2, w[0] = j, w[1] = j + 3;
                    break;
                  case 1:
                    B = p[12], R = p[13], D = p[14], b = p[15], p[12] = b, p[13] = M + 0, p[14] = M + 1, p[15] = M + 2, p[8] = D, p[11] = M + 3, p[4] = R, p[7] = M + 4, p[0] = B, p[1] = M + 7, p[2] = M + 6, p[3] = M + 5, B = w[2], R = w[3], w[2] = R, w[3] = j, w[0] = B, w[1] = j + 1;
                    break;
                  case 2:
                    B = p[15], R = p[11], p[12] = p[3], p[13] = M + 0, p[14] = M + 1, p[15] = M + 2, p[8] = p[7], p[11] = M + 3, p[4] = R, p[7] = M + 4, p[0] = B, p[1] = M + 7, p[2] = M + 6, p[3] = M + 5, B = w[3], w[2] = w[1], w[3] = j, w[0] = B, w[1] = j + 1;
                    break;
                  case 3:
                    p[12] = p[0], p[13] = M + 0, p[14] = M + 1, p[15] = M + 2, p[8] = p[1], p[11] = M + 3, p[4] = p[2], p[7] = M + 4, p[0] = p[3], p[1] = M + 7, p[2] = M + 6, p[3] = M + 5, w[2] = w[0], w[3] = j, w[0] = w[1], w[1] = j + 1;
                    break;
                }
                p[5] = m.length, m.push([(-4 * m[p[0]][0] - m[p[15]][0] + 6 * (m[p[4]][0] + m[p[1]][0]) - 2 * (m[p[12]][0] + m[p[3]][0]) + 3 * (m[p[13]][0] + m[p[7]][0])) / 9, (-4 * m[p[0]][1] - m[p[15]][1] + 6 * (m[p[4]][1] + m[p[1]][1]) - 2 * (m[p[12]][1] + m[p[3]][1]) + 3 * (m[p[13]][1] + m[p[7]][1])) / 9]), p[6] = m.length, m.push([(-4 * m[p[3]][0] - m[p[12]][0] + 6 * (m[p[2]][0] + m[p[7]][0]) - 2 * (m[p[0]][0] + m[p[15]][0]) + 3 * (m[p[4]][0] + m[p[14]][0])) / 9, (-4 * m[p[3]][1] - m[p[12]][1] + 6 * (m[p[2]][1] + m[p[7]][1]) - 2 * (m[p[0]][1] + m[p[15]][1]) + 3 * (m[p[4]][1] + m[p[14]][1])) / 9]), p[9] = m.length, m.push([(-4 * m[p[12]][0] - m[p[3]][0] + 6 * (m[p[8]][0] + m[p[13]][0]) - 2 * (m[p[0]][0] + m[p[15]][0]) + 3 * (m[p[11]][0] + m[p[1]][0])) / 9, (-4 * m[p[12]][1] - m[p[3]][1] + 6 * (m[p[8]][1] + m[p[13]][1]) - 2 * (m[p[0]][1] + m[p[15]][1]) + 3 * (m[p[11]][1] + m[p[1]][1])) / 9]), p[10] = m.length, m.push([(-4 * m[p[15]][0] - m[p[0]][0] + 6 * (m[p[11]][0] + m[p[14]][0]) - 2 * (m[p[12]][0] + m[p[3]][0]) + 3 * (m[p[2]][0] + m[p[8]][0])) / 9, (-4 * m[p[15]][1] - m[p[0]][1] + 6 * (m[p[11]][1] + m[p[14]][1]) - 2 * (m[p[12]][1] + m[p[3]][1]) + 3 * (m[p[2]][1] + m[p[8]][1])) / 9]), this.figures.push({
                  type: "patch",
                  coords: new Int32Array(p),
                  colors: new Int32Array(w)
                });
              }
            }
            _decodeType7Shading(f) {
              const m = this.coords, C = this.colors, p = new Int32Array(16), w = new Int32Array(4);
              for (; f.hasData; ) {
                const X = f.readFlag();
                if (!(0 <= X && X <= 3))
                  throw new t.FormatError("Unknown type7 flag");
                const M = m.length;
                for (let l = 0, _ = X !== 0 ? 12 : 16; l < _; l++)
                  m.push(f.readCoordinate());
                const j = C.length;
                for (let l = 0, _ = X !== 0 ? 2 : 4; l < _; l++)
                  C.push(f.readComponents());
                let B, R, D, b;
                switch (X) {
                  case 0:
                    p[12] = M + 3, p[13] = M + 4, p[14] = M + 5, p[15] = M + 6, p[8] = M + 2, p[9] = M + 13, p[10] = M + 14, p[11] = M + 7, p[4] = M + 1, p[5] = M + 12, p[6] = M + 15, p[7] = M + 8, p[0] = M, p[1] = M + 11, p[2] = M + 10, p[3] = M + 9, w[2] = j + 1, w[3] = j + 2, w[0] = j, w[1] = j + 3;
                    break;
                  case 1:
                    B = p[12], R = p[13], D = p[14], b = p[15], p[12] = b, p[13] = M + 0, p[14] = M + 1, p[15] = M + 2, p[8] = D, p[9] = M + 9, p[10] = M + 10, p[11] = M + 3, p[4] = R, p[5] = M + 8, p[6] = M + 11, p[7] = M + 4, p[0] = B, p[1] = M + 7, p[2] = M + 6, p[3] = M + 5, B = w[2], R = w[3], w[2] = R, w[3] = j, w[0] = B, w[1] = j + 1;
                    break;
                  case 2:
                    B = p[15], R = p[11], p[12] = p[3], p[13] = M + 0, p[14] = M + 1, p[15] = M + 2, p[8] = p[7], p[9] = M + 9, p[10] = M + 10, p[11] = M + 3, p[4] = R, p[5] = M + 8, p[6] = M + 11, p[7] = M + 4, p[0] = B, p[1] = M + 7, p[2] = M + 6, p[3] = M + 5, B = w[3], w[2] = w[1], w[3] = j, w[0] = B, w[1] = j + 1;
                    break;
                  case 3:
                    p[12] = p[0], p[13] = M + 0, p[14] = M + 1, p[15] = M + 2, p[8] = p[1], p[9] = M + 9, p[10] = M + 10, p[11] = M + 3, p[4] = p[2], p[5] = M + 8, p[6] = M + 11, p[7] = M + 4, p[0] = p[3], p[1] = M + 7, p[2] = M + 6, p[3] = M + 5, w[2] = w[0], w[3] = j, w[0] = w[1], w[1] = j + 1;
                    break;
                }
                this.figures.push({
                  type: "patch",
                  coords: new Int32Array(p),
                  colors: new Int32Array(w)
                });
              }
            }
            _buildFigureFromPatch(f) {
              const m = this.figures[f];
              (0, t.assert)(m.type === "patch", "Unexpected patch mesh figure");
              const C = this.coords, p = this.colors, w = m.coords, X = m.colors, M = Math.min(C[w[0]][0], C[w[3]][0], C[w[12]][0], C[w[15]][0]), j = Math.min(C[w[0]][1], C[w[3]][1], C[w[12]][1], C[w[15]][1]), B = Math.max(C[w[0]][0], C[w[3]][0], C[w[12]][0], C[w[15]][0]), R = Math.max(C[w[0]][1], C[w[3]][1], C[w[12]][1], C[w[15]][1]);
              let D = Math.ceil((B - M) * c.TRIANGLE_DENSITY / (this.bounds[2] - this.bounds[0]));
              D = Math.max(c.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(c.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, D));
              let b = Math.ceil((R - j) * c.TRIANGLE_DENSITY / (this.bounds[3] - this.bounds[1]));
              b = Math.max(c.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(c.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, b));
              const l = D + 1, _ = new Int32Array((b + 1) * l), S = new Int32Array((b + 1) * l);
              let A = 0;
              const F = new Uint8Array(3), T = new Uint8Array(3), O = p[X[0]], U = p[X[1]], G = p[X[2]], K = p[X[3]], W = d(b), z = d(D);
              for (let V = 0; V <= b; V++) {
                F[0] = (O[0] * (b - V) + G[0] * V) / b | 0, F[1] = (O[1] * (b - V) + G[1] * V) / b | 0, F[2] = (O[2] * (b - V) + G[2] * V) / b | 0, T[0] = (U[0] * (b - V) + K[0] * V) / b | 0, T[1] = (U[1] * (b - V) + K[1] * V) / b | 0, T[2] = (U[2] * (b - V) + K[2] * V) / b | 0;
                for (let L = 0; L <= D; L++, A++) {
                  if ((V === 0 || V === b) && (L === 0 || L === D))
                    continue;
                  let Y = 0, J = 0, ie = 0;
                  for (let N = 0; N <= 3; N++)
                    for (let Z = 0; Z <= 3; Z++, ie++) {
                      const E = W[V][N] * z[L][Z];
                      Y += C[w[ie]][0] * E, J += C[w[ie]][1] * E;
                    }
                  _[A] = C.length, C.push([Y, J]), S[A] = p.length;
                  const q = new Uint8Array(3);
                  q[0] = (F[0] * (D - L) + T[0] * L) / D | 0, q[1] = (F[1] * (D - L) + T[1] * L) / D | 0, q[2] = (F[2] * (D - L) + T[2] * L) / D | 0, p.push(q);
                }
              }
              _[0] = w[0], S[0] = X[0], _[D] = w[3], S[D] = X[1], _[l * b] = w[12], S[l * b] = X[2], _[l * b + D] = w[15], S[l * b + D] = X[3], this.figures[f] = {
                type: "lattice",
                coords: _,
                colors: S,
                verticesPerRow: l
              };
            }
            _updateBounds() {
              let f = this.coords[0][0], m = this.coords[0][1], C = f, p = m;
              for (let w = 1, X = this.coords.length; w < X; w++) {
                const M = this.coords[w][0], j = this.coords[w][1];
                f = f > M ? M : f, m = m > j ? j : m, C = C < M ? M : C, p = p < j ? j : p;
              }
              this.bounds = [f, m, C, p];
            }
            _packData() {
              let f, m, C, p;
              const w = this.coords, X = new Float32Array(w.length * 2);
              for (f = 0, C = 0, m = w.length; f < m; f++) {
                const R = w[f];
                X[C++] = R[0], X[C++] = R[1];
              }
              this.coords = X;
              const M = this.colors, j = new Uint8Array(M.length * 3);
              for (f = 0, C = 0, m = M.length; f < m; f++) {
                const R = M[f];
                j[C++] = R[0], j[C++] = R[1], j[C++] = R[2];
              }
              this.colors = j;
              const B = this.figures;
              for (f = 0, m = B.length; f < m; f++) {
                const R = B[f], D = R.coords, b = R.colors;
                for (C = 0, p = D.length; C < p; C++)
                  D[C] *= 2, b[C] *= 3;
              }
            }
            getIR() {
              return ["Mesh", this.shadingType, this.coords, this.colors, this.figures, this.bounds, this.bbox, this.background];
            }
          }
          class n extends r {
            getIR() {
              return ["Dummy"];
            }
          }
          function o(x, f, m) {
            const C = f.getArray("Matrix"), p = t.Util.normalizeRect(f.getArray("BBox")), w = f.get("XStep"), X = f.get("YStep"), M = f.get("PaintType"), j = f.get("TilingType");
            if (p[2] - p[0] === 0 || p[3] - p[1] === 0)
              throw new t.FormatError(`Invalid getTilingPatternIR /BBox array: [${p}].`);
            return ["TilingPattern", m, x, C, p, w, X, M, j];
          }
        },
        /* 51 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.getXfaFontDict = n, u.getXfaFontName = d;
          var t = P(52), i = P(5), v = P(53), a = P(54), e = P(55), y = P(56), r = P(6), h = P(38);
          const g = (0, r.getLookupTableFactory)(function(o) {
            o["MyriadPro-Regular"] = o["PdfJS-Fallback-Regular"] = {
              name: "LiberationSans-Regular",
              factors: e.MyriadProRegularFactors,
              baseWidths: a.LiberationSansRegularWidths,
              baseMapping: a.LiberationSansRegularMapping,
              metrics: e.MyriadProRegularMetrics
            }, o["MyriadPro-Bold"] = o["PdfJS-Fallback-Bold"] = {
              name: "LiberationSans-Bold",
              factors: e.MyriadProBoldFactors,
              baseWidths: a.LiberationSansBoldWidths,
              baseMapping: a.LiberationSansBoldMapping,
              metrics: e.MyriadProBoldMetrics
            }, o["MyriadPro-It"] = o["MyriadPro-Italic"] = o["PdfJS-Fallback-Italic"] = {
              name: "LiberationSans-Italic",
              factors: e.MyriadProItalicFactors,
              baseWidths: a.LiberationSansItalicWidths,
              baseMapping: a.LiberationSansItalicMapping,
              metrics: e.MyriadProItalicMetrics
            }, o["MyriadPro-BoldIt"] = o["MyriadPro-BoldItalic"] = o["PdfJS-Fallback-BoldItalic"] = {
              name: "LiberationSans-BoldItalic",
              factors: e.MyriadProBoldItalicFactors,
              baseWidths: a.LiberationSansBoldItalicWidths,
              baseMapping: a.LiberationSansBoldItalicMapping,
              metrics: e.MyriadProBoldItalicMetrics
            }, o.ArialMT = o.Arial = o["Arial-Regular"] = {
              name: "LiberationSans-Regular",
              baseWidths: a.LiberationSansRegularWidths,
              baseMapping: a.LiberationSansRegularMapping
            }, o["Arial-BoldMT"] = o["Arial-Bold"] = {
              name: "LiberationSans-Bold",
              baseWidths: a.LiberationSansBoldWidths,
              baseMapping: a.LiberationSansBoldMapping
            }, o["Arial-ItalicMT"] = o["Arial-Italic"] = {
              name: "LiberationSans-Italic",
              baseWidths: a.LiberationSansItalicWidths,
              baseMapping: a.LiberationSansItalicMapping
            }, o["Arial-BoldItalicMT"] = o["Arial-BoldItalic"] = {
              name: "LiberationSans-BoldItalic",
              baseWidths: a.LiberationSansBoldItalicWidths,
              baseMapping: a.LiberationSansBoldItalicMapping
            }, o["Calibri-Regular"] = {
              name: "LiberationSans-Regular",
              factors: t.CalibriRegularFactors,
              baseWidths: a.LiberationSansRegularWidths,
              baseMapping: a.LiberationSansRegularMapping,
              metrics: t.CalibriRegularMetrics
            }, o["Calibri-Bold"] = {
              name: "LiberationSans-Bold",
              factors: t.CalibriBoldFactors,
              baseWidths: a.LiberationSansBoldWidths,
              baseMapping: a.LiberationSansBoldMapping,
              metrics: t.CalibriBoldMetrics
            }, o["Calibri-Italic"] = {
              name: "LiberationSans-Italic",
              factors: t.CalibriItalicFactors,
              baseWidths: a.LiberationSansItalicWidths,
              baseMapping: a.LiberationSansItalicMapping,
              metrics: t.CalibriItalicMetrics
            }, o["Calibri-BoldItalic"] = {
              name: "LiberationSans-BoldItalic",
              factors: t.CalibriBoldItalicFactors,
              baseWidths: a.LiberationSansBoldItalicWidths,
              baseMapping: a.LiberationSansBoldItalicMapping,
              metrics: t.CalibriBoldItalicMetrics
            }, o["Segoeui-Regular"] = {
              name: "LiberationSans-Regular",
              factors: y.SegoeuiRegularFactors,
              baseWidths: a.LiberationSansRegularWidths,
              baseMapping: a.LiberationSansRegularMapping,
              metrics: y.SegoeuiRegularMetrics
            }, o["Segoeui-Bold"] = {
              name: "LiberationSans-Bold",
              factors: y.SegoeuiBoldFactors,
              baseWidths: a.LiberationSansBoldWidths,
              baseMapping: a.LiberationSansBoldMapping,
              metrics: y.SegoeuiBoldMetrics
            }, o["Segoeui-Italic"] = {
              name: "LiberationSans-Italic",
              factors: y.SegoeuiItalicFactors,
              baseWidths: a.LiberationSansItalicWidths,
              baseMapping: a.LiberationSansItalicMapping,
              metrics: y.SegoeuiItalicMetrics
            }, o["Segoeui-BoldItalic"] = {
              name: "LiberationSans-BoldItalic",
              factors: y.SegoeuiBoldItalicFactors,
              baseWidths: a.LiberationSansBoldItalicWidths,
              baseMapping: a.LiberationSansBoldItalicMapping,
              metrics: y.SegoeuiBoldItalicMetrics
            }, o["Helvetica-Regular"] = o.Helvetica = {
              name: "LiberationSans-Regular",
              factors: v.HelveticaRegularFactors,
              baseWidths: a.LiberationSansRegularWidths,
              baseMapping: a.LiberationSansRegularMapping,
              metrics: v.HelveticaRegularMetrics
            }, o["Helvetica-Bold"] = {
              name: "LiberationSans-Bold",
              factors: v.HelveticaBoldFactors,
              baseWidths: a.LiberationSansBoldWidths,
              baseMapping: a.LiberationSansBoldMapping,
              metrics: v.HelveticaBoldMetrics
            }, o["Helvetica-Italic"] = {
              name: "LiberationSans-Italic",
              factors: v.HelveticaItalicFactors,
              baseWidths: a.LiberationSansItalicWidths,
              baseMapping: a.LiberationSansItalicMapping,
              metrics: v.HelveticaItalicMetrics
            }, o["Helvetica-BoldItalic"] = {
              name: "LiberationSans-BoldItalic",
              factors: v.HelveticaBoldItalicFactors,
              baseWidths: a.LiberationSansBoldItalicWidths,
              baseMapping: a.LiberationSansBoldItalicMapping,
              metrics: v.HelveticaBoldItalicMetrics
            };
          });
          function d(o) {
            const x = (0, h.normalizeFontName)(o);
            return g()[x];
          }
          function c(o) {
            const x = d(o);
            if (!x)
              return null;
            const {
              baseWidths: f,
              baseMapping: m,
              factors: C
            } = x;
            let p;
            C ? p = f.map((j, B) => j * C[B]) : p = f;
            let w = -2, X;
            const M = [];
            for (const [j, B] of m.map((R, D) => [R, D]).sort(([R], [D]) => R - D))
              j !== -1 && (j === w + 1 ? (X.push(p[B]), w += 1) : (w = j, X = [p[B]], M.push(j, X)));
            return M;
          }
          function n(o) {
            const x = c(o), f = new i.Dict(null);
            f.set("BaseFont", i.Name.get(o)), f.set("Type", i.Name.get("Font")), f.set("Subtype", i.Name.get("CIDFontType2")), f.set("Encoding", i.Name.get("Identity-H")), f.set("CIDToGIDMap", i.Name.get("Identity")), f.set("W", x), f.set("FirstChar", x[0]), f.set("LastChar", x.at(-2) + x.at(-1).length - 1);
            const m = new i.Dict(null);
            f.set("FontDescriptor", m);
            const C = new i.Dict(null);
            return C.set("Ordering", "Identity"), C.set("Registry", "Adobe"), C.set("Supplement", 0), f.set("CIDSystemInfo", C), f;
          }
        },
        /* 52 */
        /***/
        (Q, u) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.CalibriRegularMetrics = u.CalibriRegularFactors = u.CalibriItalicMetrics = u.CalibriItalicFactors = u.CalibriBoldMetrics = u.CalibriBoldItalicMetrics = u.CalibriBoldItalicFactors = u.CalibriBoldFactors = void 0;
          const P = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.54657, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.73293, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.9121, 0.86943, 0.79795, 0.88198, 0.77958, 0.70864, 0.81055, 0.90399, 0.88653, 0.96017, 0.82577, 0.77892, 0.78257, 0.97507, 1.54657, 0.97507, 0.85284, 0.89552, 0.90176, 0.88762, 0.8785, 0.75241, 0.8785, 0.90518, 0.95015, 0.77618, 0.8785, 0.88401, 0.91916, 0.86304, 0.88401, 0.91488, 0.8785, 0.8801, 0.8785, 0.8785, 0.91343, 0.7173, 1.04106, 0.8785, 0.85075, 0.95794, 0.82616, 0.85162, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.12401, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.73293, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.9121, 0.86943, 0.86943, 0.86943, 0.86943, 0.86943, 0.85284, 0.87508, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.8715, 0.75241, 0.90518, 0.90518, 0.90518, 0.90518, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.8785, 0.8801, 0.8801, 0.8801, 0.8801, 0.8801, 0.90747, 0.89049, 0.8785, 0.8785, 0.8785, 0.8785, 0.85162, 0.8785, 0.85162, 0.83908, 0.88762, 0.83908, 0.88762, 0.83908, 0.88762, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.87289, 0.83016, 0.88506, 0.93125, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.81921, 0.77618, 0.81921, 0.77618, 0.81921, 0.77618, 1, 1, 0.87356, 0.8785, 0.91075, 0.89608, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76229, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.79468, 0.91926, 0.88175, 0.70823, 0.94903, 0.9121, 0.8785, 1, 1, 0.9121, 0.8785, 0.87802, 0.88656, 0.8785, 0.86943, 0.8801, 0.86943, 0.8801, 0.86943, 0.8801, 0.87402, 0.89291, 0.77958, 0.91343, 1, 1, 0.77958, 0.91343, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.96017, 0.95794, 0.77892, 0.85162, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.88762, 0.77539, 0.8715, 0.87508, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70674, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.06303, 0.83908, 0.80352, 0.57184, 0.6965, 0.56289, 0.82001, 0.56029, 0.81235, 1.02988, 0.83908, 0.7762, 0.68156, 0.80367, 0.73133, 0.78257, 0.87356, 0.86943, 0.95958, 0.75727, 0.89019, 1.04924, 0.9121, 0.7648, 0.86943, 0.87356, 0.79795, 0.78275, 0.81055, 0.77892, 0.9762, 0.82577, 0.99819, 0.84896, 0.95958, 0.77892, 0.96108, 1.01407, 0.89049, 1.02988, 0.94211, 0.96108, 0.8936, 0.84021, 0.87842, 0.96399, 0.79109, 0.89049, 1.00813, 1.02988, 0.86077, 0.87445, 0.92099, 0.84723, 0.86513, 0.8801, 0.75638, 0.85714, 0.78216, 0.79586, 0.87965, 0.94211, 0.97747, 0.78287, 0.97926, 0.84971, 1.02988, 0.94211, 0.8801, 0.94211, 0.84971, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90264, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90518, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90548, 1, 1, 1, 1, 1, 1, 0.96017, 0.95794, 0.96017, 0.95794, 0.96017, 0.95794, 0.77892, 0.85162, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.92794, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71143, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.93835, 0.83406, 0.91133, 0.84107, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90527, 1.81055, 0.90527, 1.81055, 1.31006, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          u.CalibriBoldFactors = P;
          const t = {
            lineHeight: 1.2207,
            lineGap: 0.2207
          };
          u.CalibriBoldMetrics = t;
          const i = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.56239, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.71805, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.90872, 0.85938, 0.79795, 0.87068, 0.77958, 0.69766, 0.81055, 0.90399, 0.88653, 0.96068, 0.82577, 0.77892, 0.78257, 0.97507, 1.529, 0.97507, 0.85284, 0.89552, 0.90176, 0.94908, 0.86411, 0.74012, 0.86411, 0.88323, 0.95015, 0.86411, 0.86331, 0.88401, 0.91916, 0.86304, 0.88401, 0.9039, 0.86331, 0.86331, 0.86411, 0.86411, 0.90464, 0.70852, 1.04106, 0.86331, 0.84372, 0.95794, 0.82616, 0.84548, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.19129, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.71805, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.90872, 0.85938, 0.85938, 0.85938, 0.85938, 0.85938, 0.85284, 0.87068, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.85887, 0.74012, 0.88323, 0.88323, 0.88323, 0.88323, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.90747, 0.89049, 0.86331, 0.86331, 0.86331, 0.86331, 0.84548, 0.86411, 0.84548, 0.83908, 0.94908, 0.83908, 0.94908, 0.83908, 0.94908, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.87289, 0.79538, 0.88506, 0.92726, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.81921, 0.86411, 0.81921, 0.86411, 0.81921, 0.86411, 1, 1, 0.87356, 0.86331, 0.91075, 0.8777, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76467, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.77312, 0.91926, 0.88175, 0.70823, 0.94903, 0.90872, 0.86331, 1, 1, 0.90872, 0.86331, 0.86906, 0.88116, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.87402, 0.86549, 0.77958, 0.90464, 1, 1, 0.77958, 0.90464, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.96068, 0.95794, 0.77892, 0.84548, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.94908, 0.77539, 0.85887, 0.87068, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70088, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.48387, 0.83908, 0.80352, 0.57118, 0.6965, 0.56347, 0.79179, 0.55853, 0.80346, 1.02988, 0.83908, 0.7762, 0.67174, 0.86036, 0.73133, 0.78257, 0.87356, 0.86441, 0.95958, 0.75727, 0.89019, 1.04924, 0.90872, 0.74889, 0.85938, 0.87891, 0.79795, 0.7957, 0.81055, 0.77892, 0.97447, 0.82577, 0.97466, 0.87179, 0.95958, 0.77892, 0.94252, 0.95612, 0.8753, 1.02988, 0.92733, 0.94252, 0.87411, 0.84021, 0.8728, 0.95612, 0.74081, 0.8753, 1.02189, 1.02988, 0.84814, 0.87445, 0.91822, 0.84723, 0.85668, 0.86331, 0.81344, 0.87581, 0.76422, 0.82046, 0.96057, 0.92733, 0.99375, 0.78022, 0.95452, 0.86015, 1.02988, 0.92733, 0.86331, 0.92733, 0.86015, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90631, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88323, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85174, 1, 1, 1, 1, 1, 1, 0.96068, 0.95794, 0.96068, 0.95794, 0.96068, 0.95794, 0.77892, 0.84548, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.89807, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71094, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.92972, 0.83406, 0.91133, 0.83326, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90616, 1.81055, 0.90527, 1.81055, 1.3107, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          u.CalibriBoldItalicFactors = i;
          const v = {
            lineHeight: 1.2207,
            lineGap: 0.2207
          };
          u.CalibriBoldItalicMetrics = v;
          const a = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39543, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.72346, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89249, 0.84118, 0.77452, 0.85374, 0.75186, 0.67789, 0.79776, 0.88844, 0.85066, 0.94309, 0.77818, 0.7306, 0.76659, 1.10369, 1.38313, 1.10369, 1.06139, 0.89552, 0.8739, 0.9245, 0.9245, 0.83203, 0.9245, 0.85865, 1.09842, 0.9245, 0.9245, 1.03297, 1.07692, 0.90918, 1.03297, 0.94959, 0.9245, 0.92274, 0.9245, 0.9245, 1.02933, 0.77832, 1.20562, 0.9245, 0.8916, 0.98986, 0.86621, 0.89453, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.16359, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.72346, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89249, 0.84118, 0.84118, 0.84118, 0.84118, 0.84118, 0.85284, 0.84557, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.84843, 0.83203, 0.85865, 0.85865, 0.85865, 0.85865, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.9245, 0.92274, 0.92274, 0.92274, 0.92274, 0.92274, 0.90747, 0.86651, 0.9245, 0.9245, 0.9245, 0.9245, 0.89453, 0.9245, 0.89453, 0.8675, 0.9245, 0.8675, 0.9245, 0.8675, 0.9245, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.85193, 0.8875, 0.86477, 0.99034, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.81105, 0.9245, 0.81105, 0.9245, 0.81105, 0.9245, 1, 1, 0.86275, 0.9245, 0.90872, 0.93591, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77896, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.9375, 0.98156, 0.93407, 0.77261, 1.11429, 0.89249, 0.9245, 1, 1, 0.89249, 0.9245, 0.92534, 0.86698, 0.9245, 0.84118, 0.92274, 0.84118, 0.92274, 0.84118, 0.92274, 0.8667, 0.86291, 0.75186, 1.02933, 1, 1, 0.75186, 1.02933, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 1, 1, 0.79776, 0.97655, 0.79776, 1.23023, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.94309, 0.98986, 0.7306, 0.89453, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.9245, 0.76318, 0.84843, 0.84557, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67009, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.8675, 0.90861, 0.6192, 0.7363, 0.64824, 0.82411, 0.56321, 0.85696, 1.23516, 0.8675, 0.81552, 0.7286, 0.84134, 0.73206, 0.76659, 0.86275, 0.84369, 0.90685, 0.77892, 0.85871, 1.02638, 0.89249, 0.75828, 0.84118, 0.85984, 0.77452, 0.76466, 0.79776, 0.7306, 0.90782, 0.77818, 0.903, 0.87291, 0.90685, 0.7306, 0.99058, 1.03667, 0.94635, 1.23516, 0.9849, 0.99058, 0.92393, 0.8916, 0.942, 1.03667, 0.75026, 0.94635, 1.0297, 1.23516, 0.90918, 0.94048, 0.98217, 0.89746, 0.84153, 0.92274, 0.82507, 0.88832, 0.84438, 0.88178, 1.03525, 0.9849, 1.00225, 0.78086, 0.97248, 0.89404, 1.23516, 0.9849, 0.92274, 0.9849, 0.89404, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89693, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85865, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90933, 1, 1, 1, 1, 1, 1, 0.94309, 0.98986, 0.94309, 0.98986, 0.94309, 0.98986, 0.7306, 0.89453, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.68994, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.97858, 0.82616, 0.91133, 0.83437, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90572, 1.81055, 0.90749, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85284, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          u.CalibriItalicFactors = a;
          const e = {
            lineHeight: 1.2207,
            lineGap: 0.2207
          };
          u.CalibriItalicMetrics = e;
          const y = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39016, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.73834, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89385, 0.85122, 0.77452, 0.86503, 0.75186, 0.68887, 0.79776, 0.88844, 0.85066, 0.94258, 0.77818, 0.7306, 0.76659, 1.10369, 1.39016, 1.10369, 1.06139, 0.89552, 0.8739, 0.86128, 0.94469, 0.8457, 0.94469, 0.89464, 1.09842, 0.84636, 0.94469, 1.03297, 1.07692, 0.90918, 1.03297, 0.95897, 0.94469, 0.9482, 0.94469, 0.94469, 1.04692, 0.78223, 1.20562, 0.94469, 0.90332, 0.98986, 0.86621, 0.90527, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.08707, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.73834, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89385, 0.85122, 0.85122, 0.85122, 0.85122, 0.85122, 0.85284, 0.85311, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.8693, 0.8457, 0.89464, 0.89464, 0.89464, 0.89464, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.94469, 0.9482, 0.9482, 0.9482, 0.9482, 0.9482, 0.90747, 0.86651, 0.94469, 0.94469, 0.94469, 0.94469, 0.90527, 0.94469, 0.90527, 0.8675, 0.86128, 0.8675, 0.86128, 0.8675, 0.86128, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.85193, 0.92454, 0.86477, 0.9921, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.81105, 0.84636, 0.81105, 0.84636, 0.81105, 0.84636, 1, 1, 0.86275, 0.94469, 0.90872, 0.95786, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77741, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.90452, 0.98156, 1.11842, 0.77261, 1.11429, 0.89385, 0.94469, 1, 1, 0.89385, 0.94469, 0.95877, 0.86901, 0.94469, 0.85122, 0.9482, 0.85122, 0.9482, 0.85122, 0.9482, 0.8667, 0.90016, 0.75186, 1.04692, 1, 1, 0.75186, 1.04692, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 1, 1, 0.79776, 0.92188, 0.79776, 1.23023, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.94258, 0.98986, 0.7306, 0.90527, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.86128, 0.76318, 0.8693, 0.85311, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67742, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.86686, 0.90861, 0.62267, 0.74359, 0.65649, 0.85498, 0.56963, 0.88254, 1.23516, 0.8675, 0.81552, 0.75443, 0.84503, 0.73206, 0.76659, 0.86275, 0.85122, 0.90685, 0.77892, 0.85746, 1.02638, 0.89385, 0.75657, 0.85122, 0.86275, 0.77452, 0.74171, 0.79776, 0.7306, 0.95165, 0.77818, 0.89772, 0.88831, 0.90685, 0.7306, 0.98142, 1.02191, 0.96576, 1.23516, 0.99018, 0.98142, 0.9236, 0.89258, 0.94035, 1.02191, 0.78848, 0.96576, 0.9561, 1.23516, 0.90918, 0.92578, 0.95424, 0.89746, 0.83969, 0.9482, 0.80113, 0.89442, 0.85208, 0.86155, 0.98022, 0.99018, 1.00452, 0.81209, 0.99247, 0.89181, 1.23516, 0.99018, 0.9482, 0.99018, 0.89181, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88844, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89464, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96766, 1, 1, 1, 1, 1, 1, 0.94258, 0.98986, 0.94258, 0.98986, 0.94258, 0.98986, 0.7306, 0.90527, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.69043, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.99331, 0.82616, 0.91133, 0.84286, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90527, 1.81055, 0.90527, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1.07185, 0.99413, 0.96334, 1.08065, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          u.CalibriRegularFactors = y;
          const r = {
            lineHeight: 1.2207,
            lineGap: 0.2207
          };
          u.CalibriRegularMetrics = r;
        },
        /* 53 */
        /***/
        (Q, u) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.HelveticaRegularMetrics = u.HelveticaRegularFactors = u.HelveticaItalicMetrics = u.HelveticaItalicFactors = u.HelveticaBoldMetrics = u.HelveticaBoldItalicMetrics = u.HelveticaBoldItalicFactors = u.HelveticaBoldFactors = void 0;
          const P = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.03374, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.00042, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.03828, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00034, 0.99977, 1, 0.99997, 1.00026, 1.00078, 1.00036, 0.99973, 1.00013, 1.0006, 0.99977, 0.99977, 0.99988, 0.85148, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 1.00069, 1.00022, 0.99977, 1.00001, 0.99984, 1.00026, 1.00001, 1.00024, 1.00001, 0.9999, 1, 1.0006, 1.00001, 1.00041, 0.99962, 1.00026, 1.0006, 0.99995, 1.00041, 0.99942, 0.99973, 0.99927, 1.00082, 0.99902, 1.00026, 1.00087, 1.0006, 1.00069, 0.99973, 0.99867, 0.99973, 0.9993, 1.00026, 1.00049, 1.00056, 1, 0.99988, 0.99935, 0.99995, 0.99954, 1.00055, 0.99945, 1.00032, 1.0006, 0.99995, 1.00026, 0.99995, 1.00032, 1.00001, 1.00008, 0.99971, 1.00019, 0.9994, 1.00001, 1.0006, 1.00044, 0.99973, 1.00023, 1.00047, 1, 0.99942, 0.99561, 0.99989, 1.00035, 0.99977, 1.00035, 0.99977, 1.00019, 0.99944, 1.00001, 1.00021, 0.99926, 1.00035, 1.00035, 0.99942, 1.00048, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.99989, 1.00057, 1.00001, 0.99936, 1.00052, 1.00012, 0.99996, 1.00043, 1, 1.00035, 0.9994, 0.99976, 1.00035, 0.99973, 1.00052, 1.00041, 1.00119, 1.00037, 0.99973, 1.00002, 0.99986, 1.00041, 1.00041, 0.99902, 0.9996, 1.00034, 0.99999, 1.00026, 0.99999, 1.00026, 0.99973, 1.00052, 0.99973, 1, 0.99973, 1.00041, 1.00075, 0.9994, 1.0003, 0.99999, 1, 1.00041, 0.99955, 1, 0.99915, 0.99973, 0.99973, 1.00026, 1.00119, 0.99955, 0.99973, 1.0006, 0.99911, 1.0006, 1.00026, 0.99972, 1.00026, 0.99902, 1.00041, 0.99973, 0.99999, 1, 1, 1.00038, 1.0005, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 1.00047, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          u.HelveticaBoldFactors = P;
          const t = {
            lineHeight: 1.2,
            lineGap: 0.2
          };
          u.HelveticaBoldMetrics = t;
          const i = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.0044, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99971, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.01011, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99977, 1, 1, 1.00026, 0.99969, 0.99972, 0.99981, 0.9998, 1.0006, 0.99977, 0.99977, 1.00022, 0.91155, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 0.99966, 1.00022, 1.00032, 1.00001, 0.99944, 1.00026, 1.00001, 0.99968, 1.00001, 1.00047, 1, 1.0006, 1.00001, 0.99981, 1.00101, 1.00026, 1.0006, 0.99948, 0.99981, 1.00064, 0.99973, 0.99942, 1.00101, 1.00061, 1.00026, 1.00069, 1.0006, 1.00014, 0.99973, 1.01322, 0.99973, 1.00065, 1.00026, 1.00012, 0.99923, 1, 1.00064, 1.00076, 0.99948, 1.00055, 1.00063, 1.00007, 0.99943, 1.0006, 0.99948, 1.00026, 0.99948, 0.99943, 1.00001, 1.00001, 1.00029, 1.00038, 1.00035, 1.00001, 1.0006, 1.0006, 0.99973, 0.99978, 1.00001, 1.00057, 0.99989, 0.99967, 0.99964, 0.99967, 0.99977, 0.99999, 0.99977, 1.00038, 0.99977, 1.00001, 0.99973, 1.00066, 0.99967, 0.99967, 1.00041, 0.99998, 0.99999, 0.99977, 1.00022, 0.99967, 1.00001, 0.99977, 1.00026, 0.99964, 1.00031, 1.00001, 0.99999, 0.99999, 1, 1.00023, 1, 1, 0.99999, 1.00035, 1.00001, 0.99999, 0.99973, 0.99977, 0.99999, 1.00058, 0.99973, 0.99973, 0.99955, 0.9995, 1.00026, 1.00026, 1.00032, 0.99989, 1.00034, 0.99999, 1.00026, 1.00026, 1.00026, 0.99973, 0.45998, 0.99973, 1.00026, 0.99973, 1.00001, 0.99999, 0.99982, 0.99994, 0.99996, 1, 1.00042, 1.00044, 1.00029, 1.00023, 0.99973, 0.99973, 1.00026, 0.99949, 1.00002, 0.99973, 1.0006, 1.0006, 1.0006, 0.99975, 1.00026, 1.00026, 1.00032, 0.98685, 0.99973, 1.00026, 1, 1, 0.99966, 1.00044, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1, 0.99973, 0.99971, 0.99978, 1, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00098, 1, 1, 1, 1.00049, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          u.HelveticaBoldItalicFactors = i;
          const v = {
            lineHeight: 1.35,
            lineGap: 0.2
          };
          u.HelveticaBoldItalicMetrics = v;
          const a = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.0288, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 0.99946, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.06311, 0.99973, 1.00024, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00041, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.89547, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00001, 1, 1.00054, 0.99977, 1.00084, 1.00007, 0.99973, 1.00013, 0.99924, 1.00001, 1.00001, 0.99945, 0.91221, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00001, 0.99999, 0.99977, 0.99933, 1.00022, 1.00054, 1.00001, 1.00065, 1.00026, 1.00001, 1.0001, 1.00001, 1.00052, 1, 1.0006, 1.00001, 0.99945, 0.99897, 0.99968, 0.99924, 1.00036, 0.99945, 0.99949, 1, 1.0006, 0.99897, 0.99918, 0.99968, 0.99911, 0.99924, 1, 0.99962, 1.01487, 1, 1.0005, 0.99973, 1.00012, 1.00043, 1, 0.99995, 0.99994, 1.00036, 0.99947, 1.00019, 1.00063, 1.00025, 0.99924, 1.00036, 0.99973, 1.00036, 1.00025, 1.00001, 1.00001, 1.00027, 1.0001, 1.00068, 1.00001, 1.0006, 1.0006, 1, 1.00008, 0.99957, 0.99972, 0.9994, 0.99954, 0.99975, 1.00051, 1.00001, 1.00019, 1.00001, 1.0001, 0.99986, 1.00001, 1.00001, 1.00038, 0.99954, 0.99954, 0.9994, 1.00066, 0.99999, 0.99977, 1.00022, 1.00054, 1.00001, 0.99977, 1.00026, 0.99975, 1.0001, 1.00001, 0.99993, 0.9995, 0.99955, 1.00016, 0.99978, 0.99974, 1.00019, 1.00022, 0.99955, 1.00053, 0.99973, 1.00089, 1.00005, 0.99967, 1.00048, 0.99973, 1.00002, 1.00034, 0.99973, 0.99973, 0.99964, 1.00006, 1.00066, 0.99947, 0.99973, 0.98894, 0.99973, 1, 0.44898, 1, 0.99946, 1, 1.00039, 1.00082, 0.99991, 0.99991, 0.99985, 1.00022, 1.00023, 1.00061, 1.00006, 0.99966, 0.99973, 0.99973, 0.99973, 1.00019, 1.0008, 1, 0.99924, 0.99924, 0.99924, 0.99983, 1.00044, 0.99973, 0.99964, 0.98332, 1, 0.99973, 1, 1, 0.99962, 0.99895, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 1.00423, 0.99925, 0.99999, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00049, 1, 1.00245, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 1.00003, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          u.HelveticaItalicFactors = a;
          const e = {
            lineHeight: 1.35,
            lineGap: 0.2
          };
          u.HelveticaItalicMetrics = e;
          const y = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.04596, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 1.00019, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.02572, 0.99973, 1.00005, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99999, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.84533, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99928, 1, 0.99977, 1.00013, 1.00055, 0.99947, 0.99945, 0.99941, 0.99924, 1.00001, 1.00001, 1.0004, 0.91621, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00005, 0.99999, 0.99977, 1.00015, 1.00022, 0.99977, 1.00001, 0.99973, 1.00026, 1.00001, 1.00019, 1.00001, 0.99946, 1, 1.0006, 1.00001, 0.99978, 1.00045, 0.99973, 0.99924, 1.00023, 0.99978, 0.99966, 1, 1.00065, 1.00045, 1.00019, 0.99973, 0.99973, 0.99924, 1, 1, 0.96499, 1, 1.00055, 0.99973, 1.00008, 1.00027, 1, 0.9997, 0.99995, 1.00023, 0.99933, 1.00019, 1.00015, 1.00031, 0.99924, 1.00023, 0.99973, 1.00023, 1.00031, 1.00001, 0.99928, 1.00029, 1.00092, 1.00035, 1.00001, 1.0006, 1.0006, 1, 0.99988, 0.99975, 1, 1.00082, 0.99561, 0.9996, 1.00035, 1.00001, 0.99962, 1.00001, 1.00092, 0.99964, 1.00001, 0.99963, 0.99999, 1.00035, 1.00035, 1.00082, 0.99962, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.9996, 0.99967, 1.00001, 1.00034, 1.00074, 1.00054, 1.00053, 1.00063, 0.99971, 0.99962, 1.00035, 0.99975, 0.99977, 0.99973, 1.00043, 0.99953, 1.0007, 0.99915, 0.99973, 1.00008, 0.99892, 1.00073, 1.00073, 1.00114, 0.99915, 1.00073, 0.99955, 0.99973, 1.00092, 0.99973, 1, 0.99998, 1, 1.0003, 1, 1.00043, 1.00001, 0.99969, 1.0003, 1, 1.00035, 1.00001, 0.9995, 1, 1.00092, 0.99973, 0.99973, 0.99973, 1.0007, 0.9995, 1, 0.99924, 1.0006, 0.99924, 0.99972, 1.00062, 0.99973, 1.00114, 1.00073, 1, 0.99955, 1, 1, 1.00047, 0.99968, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 0.99925, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          u.HelveticaRegularFactors = y;
          const r = {
            lineHeight: 1.2,
            lineGap: 0.2
          };
          u.HelveticaRegularMetrics = r;
        },
        /* 54 */
        /***/
        (Q, u) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.LiberationSansRegularWidths = u.LiberationSansRegularMapping = u.LiberationSansItalicWidths = u.LiberationSansItalicMapping = u.LiberationSansBoldWidths = u.LiberationSansBoldMapping = u.LiberationSansBoldItalicWidths = u.LiberationSansBoldItalicMapping = void 0;
          const P = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 719, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 785, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 385, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 465, 722, 333, 853, 906, 474, 825, 927, 838, 278, 722, 722, 601, 719, 667, 611, 722, 778, 278, 722, 667, 833, 722, 644, 778, 722, 667, 600, 611, 667, 821, 667, 809, 802, 278, 667, 615, 451, 611, 278, 582, 615, 610, 556, 606, 475, 460, 611, 541, 278, 558, 556, 612, 556, 445, 611, 766, 619, 520, 684, 446, 582, 715, 576, 753, 845, 278, 582, 611, 582, 845, 667, 669, 885, 567, 711, 667, 278, 276, 556, 1094, 1062, 875, 610, 722, 622, 719, 722, 719, 722, 567, 712, 667, 904, 626, 719, 719, 610, 702, 833, 722, 778, 719, 667, 722, 611, 622, 854, 667, 730, 703, 1005, 1019, 870, 979, 719, 711, 1031, 719, 556, 618, 615, 417, 635, 556, 709, 497, 615, 615, 500, 635, 740, 604, 611, 604, 611, 556, 490, 556, 875, 556, 615, 581, 833, 844, 729, 854, 615, 552, 854, 583, 556, 556, 611, 417, 552, 556, 278, 281, 278, 969, 906, 611, 500, 615, 556, 604, 778, 611, 487, 447, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1094, 556, 885, 489, 1115, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333];
          u.LiberationSansBoldWidths = P;
          const t = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
          u.LiberationSansBoldMapping = t;
          const i = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 740, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 782, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 396, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 722, 333, 854, 906, 473, 844, 930, 847, 278, 722, 722, 610, 671, 667, 611, 722, 778, 278, 722, 667, 833, 722, 657, 778, 718, 667, 590, 611, 667, 822, 667, 829, 781, 278, 667, 620, 479, 611, 278, 591, 620, 621, 556, 610, 479, 492, 611, 558, 278, 566, 556, 603, 556, 450, 611, 712, 605, 532, 664, 409, 591, 704, 578, 773, 834, 278, 591, 611, 591, 834, 667, 667, 886, 614, 719, 667, 278, 278, 556, 1094, 1042, 854, 622, 719, 677, 719, 722, 708, 722, 614, 722, 667, 927, 643, 719, 719, 615, 687, 833, 722, 778, 719, 667, 722, 611, 677, 781, 667, 729, 708, 979, 989, 854, 1e3, 708, 719, 1042, 729, 556, 619, 604, 534, 618, 556, 736, 510, 611, 611, 507, 622, 740, 604, 611, 611, 611, 556, 889, 556, 885, 556, 646, 583, 889, 935, 707, 854, 594, 552, 865, 589, 556, 556, 611, 469, 563, 556, 278, 278, 278, 969, 906, 611, 507, 619, 556, 611, 778, 611, 575, 467, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1104, 556, 885, 516, 1146, 1e3, 768, 600, 834, 834, 834, 834, 999, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333];
          u.LiberationSansBoldItalicWidths = i;
          const v = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
          u.LiberationSansBoldItalicMapping = v;
          const a = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 625, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 733, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 281, 556, 400, 556, 222, 722, 556, 722, 556, 722, 556, 615, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 354, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 789, 846, 389, 794, 865, 775, 222, 667, 667, 570, 671, 667, 611, 722, 778, 278, 667, 667, 833, 722, 648, 778, 725, 667, 600, 611, 667, 837, 667, 831, 761, 278, 667, 570, 439, 555, 222, 550, 570, 571, 500, 556, 439, 463, 555, 542, 222, 500, 492, 548, 500, 447, 556, 670, 573, 486, 603, 374, 550, 652, 546, 728, 779, 222, 550, 556, 550, 779, 667, 667, 843, 544, 708, 667, 278, 278, 500, 1066, 982, 844, 589, 715, 639, 724, 667, 651, 667, 544, 704, 667, 917, 614, 715, 715, 589, 686, 833, 722, 778, 725, 667, 722, 611, 639, 795, 667, 727, 673, 920, 923, 805, 886, 651, 694, 1022, 682, 556, 562, 522, 493, 553, 556, 688, 465, 556, 556, 472, 564, 686, 550, 556, 556, 556, 500, 833, 500, 835, 500, 572, 518, 830, 851, 621, 736, 526, 492, 752, 534, 556, 556, 556, 378, 496, 500, 222, 222, 222, 910, 828, 556, 472, 565, 500, 556, 778, 556, 492, 339, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1083, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 998, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 584, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285];
          u.LiberationSansItalicWidths = a;
          const e = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
          u.LiberationSansItalicMapping = e;
          const y = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 615, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 735, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 292, 556, 334, 556, 222, 722, 556, 722, 556, 722, 556, 604, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 375, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 784, 838, 384, 774, 855, 752, 222, 667, 667, 551, 668, 667, 611, 722, 778, 278, 667, 668, 833, 722, 650, 778, 722, 667, 618, 611, 667, 798, 667, 835, 748, 278, 667, 578, 446, 556, 222, 547, 578, 575, 500, 557, 446, 441, 556, 556, 222, 500, 500, 576, 500, 448, 556, 690, 569, 482, 617, 395, 547, 648, 525, 713, 781, 222, 547, 556, 547, 781, 667, 667, 865, 542, 719, 667, 278, 278, 500, 1057, 1010, 854, 583, 722, 635, 719, 667, 656, 667, 542, 677, 667, 923, 604, 719, 719, 583, 656, 833, 722, 778, 719, 667, 722, 611, 635, 760, 667, 740, 667, 917, 938, 792, 885, 656, 719, 1010, 722, 556, 573, 531, 365, 583, 556, 669, 458, 559, 559, 438, 583, 688, 552, 556, 542, 556, 500, 458, 500, 823, 500, 573, 521, 802, 823, 625, 719, 521, 510, 750, 542, 556, 556, 556, 365, 510, 500, 222, 278, 222, 906, 812, 556, 438, 559, 500, 552, 778, 556, 489, 411, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1073, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285];
          u.LiberationSansRegularWidths = y;
          const r = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
          u.LiberationSansRegularMapping = r;
        },
        /* 55 */
        /***/
        (Q, u) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.MyriadProRegularMetrics = u.MyriadProRegularFactors = u.MyriadProItalicMetrics = u.MyriadProItalicFactors = u.MyriadProBoldMetrics = u.MyriadProBoldItalicMetrics = u.MyriadProBoldItalicFactors = u.MyriadProBoldFactors = void 0;
          const P = [1.36898, 1, 1, 0.72706, 0.80479, 0.83734, 0.98894, 0.99793, 0.9897, 0.93884, 0.86209, 0.94292, 0.94292, 1.16661, 1.02058, 0.93582, 0.96694, 0.93582, 1.19137, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.72851, 0.78966, 0.90838, 0.83637, 0.82391, 0.96376, 0.80061, 0.86275, 0.8768, 0.95407, 1.0258, 0.73901, 0.85022, 0.83655, 1.0156, 0.95546, 0.92179, 0.87107, 0.92179, 0.82114, 0.8096, 0.89713, 0.94438, 0.95353, 0.94083, 0.91905, 0.90406, 0.9446, 0.94292, 1.18777, 0.94292, 1.02058, 0.89903, 0.90088, 0.94938, 0.97898, 0.81093, 0.97571, 0.94938, 1.024, 0.9577, 0.95933, 0.98621, 1.0474, 0.97455, 0.98981, 0.9672, 0.95933, 0.9446, 0.97898, 0.97407, 0.97646, 0.78036, 1.10208, 0.95442, 0.95298, 0.97579, 0.9332, 0.94039, 0.938, 0.80687, 1.01149, 0.80687, 1.02058, 0.80479, 0.99793, 0.99793, 0.99793, 0.99793, 1.01149, 1.00872, 0.90088, 0.91882, 1.0213, 0.8361, 1.02058, 0.62295, 0.54324, 0.89022, 1.08595, 1, 1, 0.90088, 1, 0.97455, 0.93582, 0.90088, 1, 1.05686, 0.8361, 0.99642, 0.99642, 0.99642, 0.72851, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.868, 0.82391, 0.80061, 0.80061, 0.80061, 0.80061, 1.0258, 1.0258, 1.0258, 1.0258, 0.97484, 0.95546, 0.92179, 0.92179, 0.92179, 0.92179, 0.92179, 1.02058, 0.92179, 0.94438, 0.94438, 0.94438, 0.94438, 0.90406, 0.86958, 0.98225, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.9031, 0.81093, 0.94938, 0.94938, 0.94938, 0.94938, 0.98621, 0.98621, 0.98621, 0.98621, 0.93969, 0.95933, 0.9446, 0.9446, 0.9446, 0.9446, 0.9446, 1.08595, 0.9446, 0.95442, 0.95442, 0.95442, 0.95442, 0.94039, 0.97898, 0.94039, 0.90838, 0.94938, 0.90838, 0.94938, 0.90838, 0.94938, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.96376, 0.84313, 0.97484, 0.97571, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.8768, 0.9577, 0.8768, 0.9577, 0.8768, 0.9577, 1, 1, 0.95407, 0.95933, 0.97069, 0.95933, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 0.887, 1.01591, 0.73901, 1.0474, 1, 1, 0.97455, 0.83655, 0.98981, 1, 1, 0.83655, 0.73977, 0.83655, 0.73903, 0.84638, 1.033, 0.95546, 0.95933, 1, 1, 0.95546, 0.95933, 0.8271, 0.95417, 0.95933, 0.92179, 0.9446, 0.92179, 0.9446, 0.92179, 0.9446, 0.936, 0.91964, 0.82114, 0.97646, 1, 1, 0.82114, 0.97646, 0.8096, 0.78036, 0.8096, 0.78036, 1, 1, 0.8096, 0.78036, 1, 1, 0.89713, 0.77452, 0.89713, 1.10208, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94083, 0.97579, 0.90406, 0.94039, 0.90406, 0.9446, 0.938, 0.9446, 0.938, 0.9446, 0.938, 1, 0.99793, 0.90838, 0.94938, 0.868, 0.9031, 0.92179, 0.9446, 1, 1, 0.89713, 1.10208, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90989, 0.9358, 0.91945, 0.83181, 0.75261, 0.87992, 0.82976, 0.96034, 0.83689, 0.97268, 1.0078, 0.90838, 0.83637, 0.8019, 0.90157, 0.80061, 0.9446, 0.95407, 0.92436, 1.0258, 0.85022, 0.97153, 1.0156, 0.95546, 0.89192, 0.92179, 0.92361, 0.87107, 0.96318, 0.89713, 0.93704, 0.95638, 0.91905, 0.91709, 0.92796, 1.0258, 0.93704, 0.94836, 1.0373, 0.95933, 1.0078, 0.95871, 0.94836, 0.96174, 0.92601, 0.9498, 0.98607, 0.95776, 0.95933, 1.05453, 1.0078, 0.98275, 0.9314, 0.95617, 0.91701, 1.05993, 0.9446, 0.78367, 0.9553, 1, 0.86832, 1.0128, 0.95871, 0.99394, 0.87548, 0.96361, 0.86774, 1.0078, 0.95871, 0.9446, 0.95871, 0.86774, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.94083, 0.97579, 0.94083, 0.97579, 0.94083, 0.97579, 0.90406, 0.94039, 0.96694, 1, 0.89903, 1, 1, 1, 0.93582, 0.93582, 0.93582, 1, 0.908, 0.908, 0.918, 0.94219, 0.94219, 0.96544, 1, 1.285, 1, 1, 0.81079, 0.81079, 1, 1, 0.74854, 1, 1, 1, 1, 0.99793, 1, 1, 1, 0.65, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.17173, 1, 0.80535, 0.76169, 1.02058, 1.0732, 1.05486, 1, 1, 1.30692, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.16161, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          u.MyriadProBoldFactors = P;
          const t = {
            lineHeight: 1.2,
            lineGap: 0.2
          };
          u.MyriadProBoldMetrics = t;
          const i = [1.36898, 1, 1, 0.66227, 0.80779, 0.81625, 0.97276, 0.97276, 0.97733, 0.92222, 0.83266, 0.94292, 0.94292, 1.16148, 1.02058, 0.93582, 0.96694, 0.93582, 1.17337, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.71541, 0.76813, 0.85576, 0.80591, 0.80729, 0.94299, 0.77512, 0.83655, 0.86523, 0.92222, 0.98621, 0.71743, 0.81698, 0.79726, 0.98558, 0.92222, 0.90637, 0.83809, 0.90637, 0.80729, 0.76463, 0.86275, 0.90699, 0.91605, 0.9154, 0.85308, 0.85458, 0.90531, 0.94292, 1.21296, 0.94292, 1.02058, 0.89903, 1.18616, 0.99613, 0.91677, 0.78216, 0.91677, 0.90083, 0.98796, 0.9135, 0.92168, 0.95381, 0.98981, 0.95298, 0.95381, 0.93459, 0.92168, 0.91513, 0.92004, 0.91677, 0.95077, 0.748, 1.04502, 0.91677, 0.92061, 0.94236, 0.89544, 0.89364, 0.9, 0.80687, 0.8578, 0.80687, 1.02058, 0.80779, 0.97276, 0.97276, 0.97276, 0.97276, 0.8578, 0.99973, 1.18616, 0.91339, 1.08074, 0.82891, 1.02058, 0.55509, 0.71526, 0.89022, 1.08595, 1, 1, 1.18616, 1, 0.96736, 0.93582, 1.18616, 1, 1.04864, 0.82711, 0.99043, 0.99043, 0.99043, 0.71541, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.845, 0.80729, 0.77512, 0.77512, 0.77512, 0.77512, 0.98621, 0.98621, 0.98621, 0.98621, 0.95961, 0.92222, 0.90637, 0.90637, 0.90637, 0.90637, 0.90637, 1.02058, 0.90251, 0.90699, 0.90699, 0.90699, 0.90699, 0.85458, 0.83659, 0.94951, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.85811, 0.78216, 0.90083, 0.90083, 0.90083, 0.90083, 0.95381, 0.95381, 0.95381, 0.95381, 0.9135, 0.92168, 0.91513, 0.91513, 0.91513, 0.91513, 0.91513, 1.08595, 0.91677, 0.91677, 0.91677, 0.91677, 0.91677, 0.89364, 0.92332, 0.89364, 0.85576, 0.99613, 0.85576, 0.99613, 0.85576, 0.99613, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.94299, 0.76783, 0.95961, 0.91677, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.86523, 0.9135, 0.86523, 0.9135, 0.86523, 0.9135, 1, 1, 0.92222, 0.92168, 0.92222, 0.92168, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.86036, 0.97096, 0.71743, 0.98981, 1, 1, 0.95298, 0.79726, 0.95381, 1, 1, 0.79726, 0.6894, 0.79726, 0.74321, 0.81691, 1.0006, 0.92222, 0.92168, 1, 1, 0.92222, 0.92168, 0.79464, 0.92098, 0.92168, 0.90637, 0.91513, 0.90637, 0.91513, 0.90637, 0.91513, 0.909, 0.87514, 0.80729, 0.95077, 1, 1, 0.80729, 0.95077, 0.76463, 0.748, 0.76463, 0.748, 1, 1, 0.76463, 0.748, 1, 1, 0.86275, 0.72651, 0.86275, 1.04502, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.9154, 0.94236, 0.85458, 0.89364, 0.85458, 0.90531, 0.9, 0.90531, 0.9, 0.90531, 0.9, 1, 0.97276, 0.85576, 0.99613, 0.845, 0.85811, 0.90251, 0.91677, 1, 1, 0.86275, 1.04502, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.00899, 1.30628, 0.85576, 0.80178, 0.66862, 0.7927, 0.69323, 0.88127, 0.72459, 0.89711, 0.95381, 0.85576, 0.80591, 0.7805, 0.94729, 0.77512, 0.90531, 0.92222, 0.90637, 0.98621, 0.81698, 0.92655, 0.98558, 0.92222, 0.85359, 0.90637, 0.90976, 0.83809, 0.94523, 0.86275, 0.83509, 0.93157, 0.85308, 0.83392, 0.92346, 0.98621, 0.83509, 0.92886, 0.91324, 0.92168, 0.95381, 0.90646, 0.92886, 0.90557, 0.86847, 0.90276, 0.91324, 0.86842, 0.92168, 0.99531, 0.95381, 0.9224, 0.85408, 0.92699, 0.86847, 1.0051, 0.91513, 0.80487, 0.93481, 1, 0.88159, 1.05214, 0.90646, 0.97355, 0.81539, 0.89398, 0.85923, 0.95381, 0.90646, 0.91513, 0.90646, 0.85923, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9154, 0.94236, 0.9154, 0.94236, 0.9154, 0.94236, 0.85458, 0.89364, 0.96694, 1, 0.89903, 1, 1, 1, 0.91782, 0.91782, 0.91782, 1, 0.896, 0.896, 0.896, 0.9332, 0.9332, 0.95973, 1, 1.26, 1, 1, 0.80479, 0.80178, 1, 1, 0.85633, 1, 1, 1, 1, 0.97276, 1, 1, 1, 0.698, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.14542, 1, 0.79199, 0.78694, 1.02058, 1.03493, 1.05486, 1, 1, 1.23026, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.20006, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          u.MyriadProBoldItalicFactors = i;
          const v = {
            lineHeight: 1.2,
            lineGap: 0.2
          };
          u.MyriadProBoldItalicMetrics = v;
          const a = [1.36898, 1, 1, 0.65507, 0.84943, 0.85639, 0.88465, 0.88465, 0.86936, 0.88307, 0.86948, 0.85283, 0.85283, 1.06383, 1.02058, 0.75945, 0.9219, 0.75945, 1.17337, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.75945, 0.75945, 1.02058, 1.02058, 1.02058, 0.69046, 0.70926, 0.85158, 0.77812, 0.76852, 0.89591, 0.70466, 0.76125, 0.80094, 0.86822, 0.83864, 0.728, 0.77212, 0.79475, 0.93637, 0.87514, 0.8588, 0.76013, 0.8588, 0.72421, 0.69866, 0.77598, 0.85991, 0.80811, 0.87832, 0.78112, 0.77512, 0.8562, 1.0222, 1.18417, 1.0222, 1.27014, 0.89903, 1.15012, 0.93859, 0.94399, 0.846, 0.94399, 0.81453, 1.0186, 0.94219, 0.96017, 1.03075, 1.02175, 0.912, 1.03075, 0.96998, 0.96017, 0.93859, 0.94399, 0.94399, 0.95493, 0.746, 1.12658, 0.94578, 0.91, 0.979, 0.882, 0.882, 0.83, 0.85034, 0.83537, 0.85034, 1.02058, 0.70869, 0.88465, 0.88465, 0.88465, 0.88465, 0.83537, 0.90083, 1.15012, 0.9161, 0.94565, 0.73541, 1.02058, 0.53609, 0.69353, 0.79519, 1.08595, 1, 1, 1.15012, 1, 0.91974, 0.75945, 1.15012, 1, 0.9446, 0.73361, 0.9005, 0.9005, 0.9005, 0.62864, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.773, 0.76852, 0.70466, 0.70466, 0.70466, 0.70466, 0.83864, 0.83864, 0.83864, 0.83864, 0.90561, 0.87514, 0.8588, 0.8588, 0.8588, 0.8588, 0.8588, 1.02058, 0.85751, 0.85991, 0.85991, 0.85991, 0.85991, 0.77512, 0.76013, 0.88075, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.8075, 0.846, 0.81453, 0.81453, 0.81453, 0.81453, 0.82424, 0.82424, 0.82424, 0.82424, 0.9278, 0.96017, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 1.08595, 0.8562, 0.94578, 0.94578, 0.94578, 0.94578, 0.882, 0.94578, 0.882, 0.85158, 0.93859, 0.85158, 0.93859, 0.85158, 0.93859, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.89591, 0.8544, 0.90561, 0.94399, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.80094, 0.94219, 0.80094, 0.94219, 0.80094, 0.94219, 1, 1, 0.86822, 0.96017, 0.86822, 0.96017, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 1.03075, 0.83864, 0.82424, 0.81402, 1.02738, 0.728, 1.02175, 1, 1, 0.912, 0.79475, 1.03075, 1, 1, 0.79475, 0.83911, 0.79475, 0.66266, 0.80553, 1.06676, 0.87514, 0.96017, 1, 1, 0.87514, 0.96017, 0.86865, 0.87396, 0.96017, 0.8588, 0.93859, 0.8588, 0.93859, 0.8588, 0.93859, 0.867, 0.84759, 0.72421, 0.95493, 1, 1, 0.72421, 0.95493, 0.69866, 0.746, 0.69866, 0.746, 1, 1, 0.69866, 0.746, 1, 1, 0.77598, 0.88417, 0.77598, 1.12658, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.87832, 0.979, 0.77512, 0.882, 0.77512, 0.8562, 0.83, 0.8562, 0.83, 0.8562, 0.83, 1, 0.88465, 0.85158, 0.93859, 0.773, 0.8075, 0.85751, 0.8562, 1, 1, 0.77598, 1.12658, 1.15012, 1.15012, 1.15012, 1.15012, 1.15012, 1.15313, 1.15012, 1.15012, 1.15012, 1.08106, 1.03901, 0.85158, 0.77025, 0.62264, 0.7646, 0.65351, 0.86026, 0.69461, 0.89947, 1.03075, 0.85158, 0.77812, 0.76449, 0.88836, 0.70466, 0.8562, 0.86822, 0.8588, 0.83864, 0.77212, 0.85308, 0.93637, 0.87514, 0.82352, 0.8588, 0.85701, 0.76013, 0.89058, 0.77598, 0.8156, 0.82565, 0.78112, 0.77899, 0.89386, 0.83864, 0.8156, 0.9486, 0.92388, 0.96186, 1.03075, 0.91123, 0.9486, 0.93298, 0.878, 0.93942, 0.92388, 0.84596, 0.96186, 0.95119, 1.03075, 0.922, 0.88787, 0.95829, 0.88, 0.93559, 0.93859, 0.78815, 0.93758, 1, 0.89217, 1.03737, 0.91123, 0.93969, 0.77487, 0.85769, 0.86799, 1.03075, 0.91123, 0.93859, 0.91123, 0.86799, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87832, 0.979, 0.87832, 0.979, 0.87832, 0.979, 0.77512, 0.882, 0.9219, 1, 0.89903, 1, 1, 1, 0.87321, 0.87321, 0.87321, 1, 1.027, 1.027, 1.027, 0.86847, 0.86847, 0.79121, 1, 1.124, 1, 1, 0.73572, 0.73572, 1, 1, 0.85034, 1, 1, 1, 1, 0.88465, 1, 1, 1, 0.669, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04828, 1, 0.74948, 0.75187, 1.02058, 0.98391, 1.02119, 1, 1, 1.06233, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05233, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          u.MyriadProItalicFactors = a;
          const e = {
            lineHeight: 1.2,
            lineGap: 0.2
          };
          u.MyriadProItalicMetrics = e;
          const y = [1.36898, 1, 1, 0.76305, 0.82784, 0.94935, 0.89364, 0.92241, 0.89073, 0.90706, 0.98472, 0.85283, 0.85283, 1.0664, 1.02058, 0.74505, 0.9219, 0.74505, 1.23456, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.74505, 0.74505, 1.02058, 1.02058, 1.02058, 0.73002, 0.72601, 0.91755, 0.8126, 0.80314, 0.92222, 0.73764, 0.79726, 0.83051, 0.90284, 0.86023, 0.74, 0.8126, 0.84869, 0.96518, 0.91115, 0.8858, 0.79761, 0.8858, 0.74498, 0.73914, 0.81363, 0.89591, 0.83659, 0.89633, 0.85608, 0.8111, 0.90531, 1.0222, 1.22736, 1.0222, 1.27014, 0.89903, 0.90088, 0.86667, 1.0231, 0.896, 1.01411, 0.90083, 1.05099, 1.00512, 0.99793, 1.05326, 1.09377, 0.938, 1.06226, 1.00119, 0.99793, 0.98714, 1.0231, 1.01231, 0.98196, 0.792, 1.19137, 0.99074, 0.962, 1.01915, 0.926, 0.942, 0.856, 0.85034, 0.92006, 0.85034, 1.02058, 0.69067, 0.92241, 0.92241, 0.92241, 0.92241, 0.92006, 0.9332, 0.90088, 0.91882, 0.93484, 0.75339, 1.02058, 0.56866, 0.54324, 0.79519, 1.08595, 1, 1, 0.90088, 1, 0.95325, 0.74505, 0.90088, 1, 0.97198, 0.75339, 0.91009, 0.91009, 0.91009, 0.66466, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.788, 0.80314, 0.73764, 0.73764, 0.73764, 0.73764, 0.86023, 0.86023, 0.86023, 0.86023, 0.92915, 0.91115, 0.8858, 0.8858, 0.8858, 0.8858, 0.8858, 1.02058, 0.8858, 0.89591, 0.89591, 0.89591, 0.89591, 0.8111, 0.79611, 0.89713, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86936, 0.896, 0.90083, 0.90083, 0.90083, 0.90083, 0.84224, 0.84224, 0.84224, 0.84224, 0.97276, 0.99793, 0.98714, 0.98714, 0.98714, 0.98714, 0.98714, 1.08595, 0.89876, 0.99074, 0.99074, 0.99074, 0.99074, 0.942, 1.0231, 0.942, 0.91755, 0.86667, 0.91755, 0.86667, 0.91755, 0.86667, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.92222, 0.93372, 0.92915, 1.01411, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.83051, 1.00512, 0.83051, 1.00512, 0.83051, 1.00512, 1, 1, 0.90284, 0.99793, 0.90976, 0.99793, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 1.05326, 0.86023, 0.84224, 0.82873, 1.07469, 0.74, 1.09377, 1, 1, 0.938, 0.84869, 1.06226, 1, 1, 0.84869, 0.83704, 0.84869, 0.81441, 0.85588, 1.08927, 0.91115, 0.99793, 1, 1, 0.91115, 0.99793, 0.91887, 0.90991, 0.99793, 0.8858, 0.98714, 0.8858, 0.98714, 0.8858, 0.98714, 0.894, 0.91434, 0.74498, 0.98196, 1, 1, 0.74498, 0.98196, 0.73914, 0.792, 0.73914, 0.792, 1, 1, 0.73914, 0.792, 1, 1, 0.81363, 0.904, 0.81363, 1.19137, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89633, 1.01915, 0.8111, 0.942, 0.8111, 0.90531, 0.856, 0.90531, 0.856, 0.90531, 0.856, 1, 0.92241, 0.91755, 0.86667, 0.788, 0.86936, 0.8858, 0.89876, 1, 1, 0.81363, 1.19137, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90388, 1.03901, 0.92138, 0.78105, 0.7154, 0.86169, 0.80513, 0.94007, 0.82528, 0.98612, 1.06226, 0.91755, 0.8126, 0.81884, 0.92819, 0.73764, 0.90531, 0.90284, 0.8858, 0.86023, 0.8126, 0.91172, 0.96518, 0.91115, 0.83089, 0.8858, 0.87791, 0.79761, 0.89297, 0.81363, 0.88157, 0.89992, 0.85608, 0.81992, 0.94307, 0.86023, 0.88157, 0.95308, 0.98699, 0.99793, 1.06226, 0.95817, 0.95308, 0.97358, 0.928, 0.98088, 0.98699, 0.92761, 0.99793, 0.96017, 1.06226, 0.986, 0.944, 0.95978, 0.938, 0.96705, 0.98714, 0.80442, 0.98972, 1, 0.89762, 1.04552, 0.95817, 0.99007, 0.87064, 0.91879, 0.88888, 1.06226, 0.95817, 0.98714, 0.95817, 0.88888, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89633, 1.01915, 0.89633, 1.01915, 0.89633, 1.01915, 0.8111, 0.942, 0.9219, 1, 0.89903, 1, 1, 1, 0.93173, 0.93173, 0.93173, 1, 1.06304, 1.06304, 1.06904, 0.89903, 0.89903, 0.80549, 1, 1.156, 1, 1, 0.76575, 0.76575, 1, 1, 0.72458, 1, 1, 1, 1, 0.92241, 1, 1, 1, 0.619, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.07257, 1, 0.74705, 0.71119, 1.02058, 1.024, 1.02119, 1, 1, 1.1536, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05638, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          u.MyriadProRegularFactors = y;
          const r = {
            lineHeight: 1.2,
            lineGap: 0.2
          };
          u.MyriadProRegularMetrics = r;
        },
        /* 56 */
        /***/
        (Q, u) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.SegoeuiRegularMetrics = u.SegoeuiRegularFactors = u.SegoeuiItalicMetrics = u.SegoeuiItalicFactors = u.SegoeuiBoldMetrics = u.SegoeuiBoldItalicMetrics = u.SegoeuiBoldItalicFactors = u.SegoeuiBoldFactors = void 0;
          const P = [1.76738, 1, 1, 0.99297, 0.9824, 1.04016, 1.06497, 1.03424, 0.97529, 1.17647, 1.23203, 1.1085, 1.1085, 1.16939, 1.2107, 0.9754, 1.21408, 0.9754, 1.59578, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 0.81378, 0.81378, 1.2107, 1.2107, 1.2107, 0.71703, 0.97847, 0.97363, 0.88776, 0.8641, 1.02096, 0.79795, 0.85132, 0.914, 1.06085, 1.1406, 0.8007, 0.89858, 0.83693, 1.14889, 1.09398, 0.97489, 0.92094, 0.97489, 0.90399, 0.84041, 0.95923, 1.00135, 1, 1.06467, 0.98243, 0.90996, 0.99361, 1.1085, 1.56942, 1.1085, 1.2107, 0.74627, 0.94282, 0.96752, 1.01519, 0.86304, 1.01359, 0.97278, 1.15103, 1.01359, 0.98561, 1.02285, 1.02285, 1.00527, 1.02285, 1.0302, 0.99041, 1.0008, 1.01519, 1.01359, 1.02258, 0.79104, 1.16862, 0.99041, 0.97454, 1.02511, 0.99298, 0.96752, 0.95801, 0.94856, 1.16579, 0.94856, 1.2107, 0.9824, 1.03424, 1.03424, 1, 1.03424, 1.16579, 0.8727, 1.3871, 1.18622, 1.10818, 1.04478, 1.2107, 1.18622, 0.75155, 0.94994, 1.28826, 1.21408, 1.21408, 0.91056, 1, 0.91572, 0.9754, 0.64663, 1.18328, 1.24866, 1.04478, 1.14169, 1.15749, 1.17389, 0.71703, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.93506, 0.8641, 0.79795, 0.79795, 0.79795, 0.79795, 1.1406, 1.1406, 1.1406, 1.1406, 1.02096, 1.09398, 0.97426, 0.97426, 0.97426, 0.97426, 0.97426, 1.2107, 0.97489, 1.00135, 1.00135, 1.00135, 1.00135, 0.90996, 0.92094, 1.02798, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.93136, 0.86304, 0.97278, 0.97278, 0.97278, 0.97278, 1.02285, 1.02285, 1.02285, 1.02285, 0.97122, 0.99041, 1, 1, 1, 1, 1, 1.28826, 1.0008, 0.99041, 0.99041, 0.99041, 0.99041, 0.96752, 1.01519, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 1.02096, 1.03057, 1.02096, 1.03517, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.914, 1.01359, 0.914, 1.01359, 0.914, 1.01359, 1, 1, 1.06085, 0.98561, 1.06085, 1.00879, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 0.97138, 1.08692, 0.8007, 1.02285, 1, 1, 1.00527, 0.83693, 1.02285, 1, 1, 0.83693, 0.9455, 0.83693, 0.90418, 0.83693, 1.13005, 1.09398, 0.99041, 1, 1, 1.09398, 0.99041, 0.96692, 1.09251, 0.99041, 0.97489, 1.0008, 0.97489, 1.0008, 0.97489, 1.0008, 0.93994, 0.97931, 0.90399, 1.02258, 1, 1, 0.90399, 1.02258, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 1, 1, 0.95923, 1.07034, 0.95923, 1.16862, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.06467, 1.02511, 0.90996, 0.96752, 0.90996, 0.99361, 0.95801, 0.99361, 0.95801, 0.99361, 0.95801, 1.07733, 1.03424, 0.97363, 0.96752, 0.93506, 0.93136, 0.97489, 1.0008, 1, 1, 0.95923, 1.16862, 1.15103, 1.15103, 1.01173, 1.03959, 0.75953, 0.81378, 0.79912, 1.15103, 1.21994, 0.95161, 0.87815, 1.01149, 0.81525, 0.7676, 0.98167, 1.01134, 1.02546, 0.84097, 1.03089, 1.18102, 0.97363, 0.88776, 0.85134, 0.97826, 0.79795, 0.99361, 1.06085, 0.97489, 1.1406, 0.89858, 1.0388, 1.14889, 1.09398, 0.86039, 0.97489, 1.0595, 0.92094, 0.94793, 0.95923, 0.90996, 0.99346, 0.98243, 1.02112, 0.95493, 1.1406, 0.90996, 1.03574, 1.02597, 1.0008, 1.18102, 1.06628, 1.03574, 1.0192, 1.01932, 1.00886, 0.97531, 1.0106, 1.0008, 1.13189, 1.18102, 1.02277, 0.98683, 1.0016, 0.99561, 1.07237, 1.0008, 0.90434, 0.99921, 0.93803, 0.8965, 1.23085, 1.06628, 1.04983, 0.96268, 1.0499, 0.98439, 1.18102, 1.06628, 1.0008, 1.06628, 0.98439, 0.79795, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09466, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.97278, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.02065, 1, 1, 1, 1, 1, 1, 1.06467, 1.02511, 1.06467, 1.02511, 1.06467, 1.02511, 0.90996, 0.96752, 1, 1.21408, 0.89903, 1, 1, 0.75155, 1.04394, 1.04394, 1.04394, 1.04394, 0.98633, 0.98633, 0.98633, 0.73047, 0.73047, 1.20642, 0.91211, 1.25635, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.12454, 0.93503, 1.03424, 1.19687, 1.03424, 1, 1, 1, 0.771, 1, 1, 1.15749, 1.15749, 1.15749, 1.10948, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.16897, 1, 0.96085, 0.90137, 1.2107, 1.18416, 1.13973, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21172, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18874, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.09193, 1.09193, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          u.SegoeuiBoldFactors = P;
          const t = {
            lineHeight: 1.33008,
            lineGap: 0
          };
          u.SegoeuiBoldMetrics = t;
          const i = [1.76738, 1, 1, 0.98946, 1.03959, 1.04016, 1.02809, 1.036, 0.97639, 1.10953, 1.23203, 1.11144, 1.11144, 1.16939, 1.21237, 0.9754, 1.21261, 0.9754, 1.59754, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 0.81378, 0.81378, 1.21237, 1.21237, 1.21237, 0.73541, 0.97847, 0.97363, 0.89723, 0.87897, 1.0426, 0.79429, 0.85292, 0.91149, 1.05815, 1.1406, 0.79631, 0.90128, 0.83853, 1.04396, 1.10615, 0.97552, 0.94436, 0.97552, 0.88641, 0.80527, 0.96083, 1.00135, 1, 1.06777, 0.9817, 0.91142, 0.99361, 1.11144, 1.57293, 1.11144, 1.21237, 0.74627, 1.31818, 1.06585, 0.97042, 0.83055, 0.97042, 0.93503, 1.1261, 0.97042, 0.97922, 1.14236, 0.94552, 1.01054, 1.14236, 1.02471, 0.97922, 0.94165, 0.97042, 0.97042, 1.0276, 0.78929, 1.1261, 0.97922, 0.95874, 1.02197, 0.98507, 0.96752, 0.97168, 0.95107, 1.16579, 0.95107, 1.21237, 1.03959, 1.036, 1.036, 1, 1.036, 1.16579, 0.87357, 1.31818, 1.18754, 1.26781, 1.05356, 1.21237, 1.18622, 0.79487, 0.94994, 1.29004, 1.24047, 1.24047, 1.31818, 1, 0.91484, 0.9754, 1.31818, 1.1349, 1.24866, 1.05356, 1.13934, 1.15574, 1.17389, 0.73541, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.94385, 0.87897, 0.79429, 0.79429, 0.79429, 0.79429, 1.1406, 1.1406, 1.1406, 1.1406, 1.0426, 1.10615, 0.97552, 0.97552, 0.97552, 0.97552, 0.97552, 1.21237, 0.97552, 1.00135, 1.00135, 1.00135, 1.00135, 0.91142, 0.94436, 0.98721, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 0.96705, 0.83055, 0.93503, 0.93503, 0.93503, 0.93503, 1.14236, 1.14236, 1.14236, 1.14236, 0.93125, 0.97922, 0.94165, 0.94165, 0.94165, 0.94165, 0.94165, 1.29004, 0.94165, 0.97922, 0.97922, 0.97922, 0.97922, 0.96752, 0.97042, 0.96752, 0.97363, 1.06585, 0.97363, 1.06585, 0.97363, 1.06585, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 1.0426, 1.0033, 1.0426, 0.97042, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.91149, 0.97042, 0.91149, 0.97042, 0.91149, 0.97042, 1, 1, 1.05815, 0.97922, 1.05815, 0.97922, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 0.97441, 1.04302, 0.79631, 1.01582, 1, 1, 1.01054, 0.83853, 1.14236, 1, 1, 0.83853, 1.09125, 0.83853, 0.90418, 0.83853, 1.19508, 1.10615, 0.97922, 1, 1, 1.10615, 0.97922, 1.01034, 1.10466, 0.97922, 0.97552, 0.94165, 0.97552, 0.94165, 0.97552, 0.94165, 0.91602, 0.91981, 0.88641, 1.0276, 1, 1, 0.88641, 1.0276, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 1, 1, 0.96083, 1.05403, 0.95923, 1.16862, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.06777, 1.02197, 0.91142, 0.96752, 0.91142, 0.99361, 0.97168, 0.99361, 0.97168, 0.99361, 0.97168, 1.23199, 1.036, 0.97363, 1.06585, 0.94385, 0.96705, 0.97552, 0.94165, 1, 1, 0.96083, 1.1261, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 0.95161, 1.27126, 1.00811, 0.83284, 0.77702, 0.99137, 0.95253, 1.0347, 0.86142, 1.07205, 1.14236, 0.97363, 0.89723, 0.86869, 1.09818, 0.79429, 0.99361, 1.05815, 0.97552, 1.1406, 0.90128, 1.06662, 1.04396, 1.10615, 0.84918, 0.97552, 1.04694, 0.94436, 0.98015, 0.96083, 0.91142, 1.00356, 0.9817, 1.01945, 0.98999, 1.1406, 0.91142, 1.04961, 0.9898, 1.00639, 1.14236, 1.07514, 1.04961, 0.99607, 1.02897, 1.008, 0.9898, 0.95134, 1.00639, 1.11121, 1.14236, 1.00518, 0.97981, 1.02186, 1, 1.08578, 0.94165, 0.99314, 0.98387, 0.93028, 0.93377, 1.35125, 1.07514, 1.10687, 0.93491, 1.04232, 1.00351, 1.14236, 1.07514, 0.94165, 1.07514, 1.00351, 0.79429, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09097, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.93503, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96609, 1, 1, 1, 1, 1, 1, 1.06777, 1.02197, 1.06777, 1.02197, 1.06777, 1.02197, 0.91142, 0.96752, 1, 1.21261, 0.89903, 1, 1, 0.75155, 1.04745, 1.04745, 1.04745, 1.04394, 0.98633, 0.98633, 0.98633, 0.72959, 0.72959, 1.20502, 0.91406, 1.26514, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.09125, 0.93327, 1.03336, 1.16541, 1.036, 1, 1, 1, 0.771, 1, 1, 1.15574, 1.15574, 1.15574, 1.15574, 0.86364, 0.94434, 0.86279, 0.94434, 0.86224, 1, 1, 1.16798, 1, 0.96085, 0.90068, 1.21237, 1.18416, 1.13904, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21339, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18775, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.13269, 1.13269, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          u.SegoeuiBoldItalicFactors = i;
          const v = {
            lineHeight: 1.33008,
            lineGap: 0
          };
          u.SegoeuiBoldItalicMetrics = v;
          const a = [1.76738, 1, 1, 0.98946, 1.14763, 1.05365, 1.06234, 0.96927, 0.92586, 1.15373, 1.18414, 0.91349, 0.91349, 1.07403, 1.17308, 0.78383, 1.20088, 0.78383, 1.42531, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78383, 0.78383, 1.17308, 1.17308, 1.17308, 0.77349, 0.94565, 0.94729, 0.85944, 0.88506, 0.9858, 0.74817, 0.80016, 0.88449, 0.98039, 0.95782, 0.69238, 0.89898, 0.83231, 0.98183, 1.03989, 0.96924, 0.86237, 0.96924, 0.80595, 0.74524, 0.86091, 0.95402, 0.94143, 0.98448, 0.8858, 0.83089, 0.93285, 1.0949, 1.39016, 1.0949, 1.45994, 0.74627, 1.04839, 0.97454, 0.97454, 0.87207, 0.97454, 0.87533, 1.06151, 0.97454, 1.00176, 1.16484, 1.08132, 0.98047, 1.16484, 1.02989, 1.01054, 0.96225, 0.97454, 0.97454, 1.06598, 0.79004, 1.16344, 1.00351, 0.94629, 0.9973, 0.91016, 0.96777, 0.9043, 0.91082, 0.92481, 0.91082, 1.17308, 0.95748, 0.96927, 0.96927, 1, 0.96927, 0.92481, 0.80597, 1.04839, 1.23393, 1.1781, 0.9245, 1.17308, 1.20808, 0.63218, 0.94261, 1.24822, 1.09971, 1.09971, 1.04839, 1, 0.85273, 0.78032, 1.04839, 1.09971, 1.22326, 0.9245, 1.09836, 1.13525, 1.15222, 0.70424, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.85498, 0.88506, 0.74817, 0.74817, 0.74817, 0.74817, 0.95782, 0.95782, 0.95782, 0.95782, 0.9858, 1.03989, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.17308, 0.96924, 0.95402, 0.95402, 0.95402, 0.95402, 0.83089, 0.86237, 0.88409, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.92916, 0.87207, 0.87533, 0.87533, 0.87533, 0.87533, 0.93146, 0.93146, 0.93146, 0.93146, 0.93854, 1.01054, 0.96225, 0.96225, 0.96225, 0.96225, 0.96225, 1.24822, 0.8761, 1.00351, 1.00351, 1.00351, 1.00351, 0.96777, 0.97454, 0.96777, 0.94729, 0.97454, 0.94729, 0.97454, 0.94729, 0.97454, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.9858, 0.95391, 0.9858, 0.97454, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.88449, 0.97454, 0.88449, 0.97454, 0.88449, 0.97454, 1, 1, 0.98039, 1.00176, 0.98039, 1.00176, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 1.16484, 0.95782, 0.93146, 0.84421, 1.12761, 0.69238, 1.08132, 1, 1, 0.98047, 0.83231, 1.16484, 1, 1, 0.84723, 1.04861, 0.84723, 0.78755, 0.83231, 1.23736, 1.03989, 1.01054, 1, 1, 1.03989, 1.01054, 0.9857, 1.03849, 1.01054, 0.96924, 0.96225, 0.96924, 0.96225, 0.96924, 0.96225, 0.92383, 0.90171, 0.80595, 1.06598, 1, 1, 0.80595, 1.06598, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 1, 1, 0.86091, 1.02759, 0.85771, 1.16344, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.98448, 0.9973, 0.83089, 0.96777, 0.83089, 0.93285, 0.9043, 0.93285, 0.9043, 0.93285, 0.9043, 1.31868, 0.96927, 0.94729, 0.97454, 0.85498, 0.92916, 0.96924, 0.8761, 1, 1, 0.86091, 1.16344, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 0.81965, 0.81965, 0.94729, 0.78032, 0.71022, 0.90883, 0.84171, 0.99877, 0.77596, 1.05734, 1.2, 0.94729, 0.85944, 0.82791, 0.9607, 0.74817, 0.93285, 0.98039, 0.96924, 0.95782, 0.89898, 0.98316, 0.98183, 1.03989, 0.78614, 0.96924, 0.97642, 0.86237, 0.86075, 0.86091, 0.83089, 0.90082, 0.8858, 0.97296, 1.01284, 0.95782, 0.83089, 1.0976, 1.04, 1.03342, 1.2, 1.0675, 1.0976, 0.98205, 1.03809, 1.05097, 1.04, 0.95364, 1.03342, 1.05401, 1.2, 1.02148, 1.0119, 1.04724, 1.0127, 1.02732, 0.96225, 0.8965, 0.97783, 0.93574, 0.94818, 1.30679, 1.0675, 1.11826, 0.99821, 1.0557, 1.0326, 1.2, 1.0675, 0.96225, 1.0675, 1.0326, 0.74817, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03754, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87533, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.98705, 1, 1, 1, 1, 1, 1, 0.98448, 0.9973, 0.98448, 0.9973, 0.98448, 0.9973, 0.83089, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 0.94945, 0.94945, 0.94945, 0.94945, 1.12317, 1.12317, 1.12317, 0.67603, 0.67603, 1.15621, 0.73584, 1.21191, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87709, 0.96927, 1.01473, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.09836, 1.09836, 1.09836, 1.01522, 0.86321, 0.94434, 0.8649, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86438, 1.17308, 1.18416, 1.14589, 0.69825, 0.97622, 1.96791, 1.24822, 1.24822, 1.17308, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.17984, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10742, 1.10742, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          u.SegoeuiItalicFactors = a;
          const e = {
            lineHeight: 1.33008,
            lineGap: 0
          };
          u.SegoeuiItalicMetrics = e;
          const y = [1.76738, 1, 1, 0.98594, 1.02285, 1.10454, 1.06234, 0.96927, 0.92037, 1.19985, 1.2046, 0.90616, 0.90616, 1.07152, 1.1714, 0.78032, 1.20088, 0.78032, 1.40246, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78032, 0.78032, 1.1714, 1.1714, 1.1714, 0.80597, 0.94084, 0.96706, 0.85944, 0.85734, 0.97093, 0.75842, 0.79936, 0.88198, 0.9831, 0.95782, 0.71387, 0.86969, 0.84636, 1.07796, 1.03584, 0.96924, 0.83968, 0.96924, 0.82826, 0.79649, 0.85771, 0.95132, 0.93119, 0.98965, 0.88433, 0.8287, 0.93365, 1.08612, 1.3638, 1.08612, 1.45786, 0.74627, 0.80499, 0.91484, 1.05707, 0.92383, 1.05882, 0.9403, 1.12654, 1.05882, 1.01756, 1.09011, 1.09011, 0.99414, 1.09011, 1.034, 1.01756, 1.05356, 1.05707, 1.05882, 1.04399, 0.84863, 1.21968, 1.01756, 0.95801, 1.00068, 0.91797, 0.96777, 0.9043, 0.90351, 0.92105, 0.90351, 1.1714, 0.85337, 0.96927, 0.96927, 0.99912, 0.96927, 0.92105, 0.80597, 1.2434, 1.20808, 1.05937, 0.90957, 1.1714, 1.20808, 0.75155, 0.94261, 1.24644, 1.09971, 1.09971, 0.84751, 1, 0.85273, 0.78032, 0.61584, 1.05425, 1.17914, 0.90957, 1.08665, 1.11593, 1.14169, 0.73381, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.86035, 0.85734, 0.75842, 0.75842, 0.75842, 0.75842, 0.95782, 0.95782, 0.95782, 0.95782, 0.97093, 1.03584, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.1714, 0.96924, 0.95132, 0.95132, 0.95132, 0.95132, 0.8287, 0.83968, 0.89049, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.93575, 0.92383, 0.9403, 0.9403, 0.9403, 0.9403, 0.8717, 0.8717, 0.8717, 0.8717, 1.00527, 1.01756, 1.05356, 1.05356, 1.05356, 1.05356, 1.05356, 1.24644, 0.95923, 1.01756, 1.01756, 1.01756, 1.01756, 0.96777, 1.05707, 0.96777, 0.96706, 0.91484, 0.96706, 0.91484, 0.96706, 0.91484, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.97093, 1.0969, 0.97093, 1.05882, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.88198, 1.05882, 0.88198, 1.05882, 0.88198, 1.05882, 1, 1, 0.9831, 1.01756, 0.9831, 1.01756, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 1.09011, 0.95782, 0.8717, 0.84784, 1.11551, 0.71387, 1.09011, 1, 1, 0.99414, 0.84636, 1.09011, 1, 1, 0.84636, 1.0536, 0.84636, 0.94298, 0.84636, 1.23297, 1.03584, 1.01756, 1, 1, 1.03584, 1.01756, 1.00323, 1.03444, 1.01756, 0.96924, 1.05356, 0.96924, 1.05356, 0.96924, 1.05356, 0.93066, 0.98293, 0.82826, 1.04399, 1, 1, 0.82826, 1.04399, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 1, 1, 0.85771, 1.17318, 0.85771, 1.21968, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.98965, 1.00068, 0.8287, 0.96777, 0.8287, 0.93365, 0.9043, 0.93365, 0.9043, 0.93365, 0.9043, 1.08571, 0.96927, 0.96706, 0.91484, 0.86035, 0.93575, 0.96924, 0.95923, 1, 1, 0.85771, 1.21968, 1.11437, 1.11437, 0.93109, 0.91202, 0.60411, 0.84164, 0.55572, 1.01173, 0.97361, 0.81818, 0.81818, 0.96635, 0.78032, 0.72727, 0.92366, 0.98601, 1.03405, 0.77968, 1.09799, 1.2, 0.96706, 0.85944, 0.85638, 0.96491, 0.75842, 0.93365, 0.9831, 0.96924, 0.95782, 0.86969, 0.94152, 1.07796, 1.03584, 0.78437, 0.96924, 0.98715, 0.83968, 0.83491, 0.85771, 0.8287, 0.94492, 0.88433, 0.9287, 1.0098, 0.95782, 0.8287, 1.0625, 0.98248, 1.03424, 1.2, 1.01071, 1.0625, 0.95246, 1.03809, 1.04912, 0.98248, 1.00221, 1.03424, 1.05443, 1.2, 1.04785, 0.99609, 1.00169, 1.05176, 0.99346, 1.05356, 0.9087, 1.03004, 0.95542, 0.93117, 1.23362, 1.01071, 1.07831, 1.02512, 1.05205, 1.03502, 1.2, 1.01071, 1.05356, 1.01071, 1.03502, 0.75842, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03719, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9403, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04021, 1, 1, 1, 1, 1, 1, 0.98965, 1.00068, 0.98965, 1.00068, 0.98965, 1.00068, 0.8287, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 1.03077, 1.03077, 1.03077, 1.03077, 1.13196, 1.13196, 1.13196, 0.67428, 0.67428, 1.16039, 0.73291, 1.20996, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87796, 0.96927, 1.01518, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.10539, 1.10539, 1.11358, 1.06967, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86507, 1.1714, 1.18416, 1.14589, 0.69825, 0.97622, 1.9697, 1.24822, 1.24822, 1.17238, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18083, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10938, 1.10938, 1, 1, 1, 1.05425, 1.09971, 1.09971, 1.09971, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          u.SegoeuiRegularFactors = y;
          const r = {
            lineHeight: 1.33008,
            lineGap: 0
          };
          u.SegoeuiRegularMetrics = r;
        },
        /* 57 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.PostScriptEvaluator = u.PostScriptCompiler = u.PDFFunctionFactory = void 0, u.isPDFFunction = g;
          var t = P(5), i = P(2), v = P(58), a = P(7), e = P(59);
          class y {
            constructor({
              xref: b,
              isEvalSupported: l = !0
            }) {
              this.xref = b, this.isEvalSupported = l !== !1;
            }
            create(b) {
              const l = this.getCached(b);
              if (l)
                return l;
              const _ = h.parse({
                xref: this.xref,
                isEvalSupported: this.isEvalSupported,
                fn: b instanceof t.Ref ? this.xref.fetch(b) : b
              });
              return this._cache(b, _), _;
            }
            createFromArray(b) {
              const l = this.getCached(b);
              if (l)
                return l;
              const _ = h.parseArray({
                xref: this.xref,
                isEvalSupported: this.isEvalSupported,
                fnObj: b instanceof t.Ref ? this.xref.fetch(b) : b
              });
              return this._cache(b, _), _;
            }
            getCached(b) {
              let l;
              if (b instanceof t.Ref ? l = b : b instanceof t.Dict ? l = b.objId : b instanceof a.BaseStream && (l = b.dict && b.dict.objId), l) {
                const _ = this._localFunctionCache.getByRef(l);
                if (_)
                  return _;
              }
              return null;
            }
            _cache(b, l) {
              if (!l)
                throw new Error('PDFFunctionFactory._cache - expected "parsedFunction" argument.');
              let _;
              b instanceof t.Ref ? _ = b : b instanceof t.Dict ? _ = b.objId : b instanceof a.BaseStream && (_ = b.dict && b.dict.objId), _ && this._localFunctionCache.set(null, _, l);
            }
            get _localFunctionCache() {
              return (0, i.shadow)(this, "_localFunctionCache", new e.LocalFunctionCache());
            }
          }
          u.PDFFunctionFactory = y;
          function r(D) {
            if (!Array.isArray(D))
              return null;
            const b = D.length;
            for (let l = 0; l < b; l++)
              if (typeof D[l] != "number") {
                const _ = new Array(b);
                for (let S = 0; S < b; S++)
                  _[S] = +D[S];
                return _;
              }
            return D;
          }
          class h {
            static getSampleArray(b, l, _, S) {
              let A, F, T = 1;
              for (A = 0, F = b.length; A < F; A++)
                T *= b[A];
              T *= l;
              const O = new Array(T);
              let U = 0, G = 0;
              const K = 1 / (2 ** _ - 1), W = S.getBytes((T * _ + 7) / 8);
              let z = 0;
              for (A = 0; A < T; A++) {
                for (; U < _; )
                  G <<= 8, G |= W[z++], U += 8;
                U -= _, O[A] = (G >> U) * K, G &= (1 << U) - 1;
              }
              return O;
            }
            static parse({
              xref: b,
              isEvalSupported: l,
              fn: _
            }) {
              const S = _.dict || _;
              switch (S.get("FunctionType")) {
                case 0:
                  return this.constructSampled({
                    xref: b,
                    isEvalSupported: l,
                    fn: _,
                    dict: S
                  });
                case 1:
                  break;
                case 2:
                  return this.constructInterpolated({
                    xref: b,
                    isEvalSupported: l,
                    dict: S
                  });
                case 3:
                  return this.constructStiched({
                    xref: b,
                    isEvalSupported: l,
                    dict: S
                  });
                case 4:
                  return this.constructPostScript({
                    xref: b,
                    isEvalSupported: l,
                    fn: _,
                    dict: S
                  });
              }
              throw new i.FormatError("Unknown type of function");
            }
            static parseArray({
              xref: b,
              isEvalSupported: l,
              fnObj: _
            }) {
              if (!Array.isArray(_))
                return this.parse({
                  xref: b,
                  isEvalSupported: l,
                  fn: _
                });
              const S = [];
              for (let A = 0, F = _.length; A < F; A++)
                S.push(this.parse({
                  xref: b,
                  isEvalSupported: l,
                  fn: b.fetchIfRef(_[A])
                }));
              return function(A, F, T, O) {
                for (let U = 0, G = S.length; U < G; U++)
                  S[U](A, F, T, O + U);
              };
            }
            static constructSampled({
              xref: b,
              isEvalSupported: l,
              fn: _,
              dict: S
            }) {
              function A(J) {
                const ie = J.length, q = [];
                let N = 0;
                for (let Z = 0; Z < ie; Z += 2)
                  q[N++] = [J[Z], J[Z + 1]];
                return q;
              }
              function F(J, ie, q, N, Z) {
                return N + (J - ie) * ((Z - N) / (q - ie));
              }
              let T = r(S.getArray("Domain")), O = r(S.getArray("Range"));
              if (!T || !O)
                throw new i.FormatError("No domain or range");
              const U = T.length / 2, G = O.length / 2;
              T = A(T), O = A(O);
              const K = r(S.getArray("Size")), W = S.get("BitsPerSample"), z = S.get("Order") || 1;
              z !== 1 && (0, i.info)("No support for cubic spline interpolation: " + z);
              let V = r(S.getArray("Encode"));
              if (V)
                V = A(V);
              else {
                V = [];
                for (let J = 0; J < U; ++J)
                  V.push([0, K[J] - 1]);
              }
              let L = r(S.getArray("Decode"));
              L ? L = A(L) : L = O;
              const Y = this.getSampleArray(K, G, W, _);
              return function(ie, q, N, Z) {
                const E = 1 << U, te = new Float64Array(E), re = new Uint32Array(E);
                let ee, $;
                for ($ = 0; $ < E; $++)
                  te[$] = 1;
                let k = G, H = 1;
                for (ee = 0; ee < U; ++ee) {
                  const ne = T[ee][0], ae = T[ee][1], he = Math.min(Math.max(ie[q + ee], ne), ae);
                  let ue = F(he, ne, ae, V[ee][0], V[ee][1]);
                  const fe = K[ee];
                  ue = Math.min(Math.max(ue, 0), fe - 1);
                  const me = ue < fe - 1 ? Math.floor(ue) : ue - 1, Fe = me + 1 - ue, we = ue - me, Ae = me * k, De = Ae + k;
                  for ($ = 0; $ < E; $++)
                    $ & H ? (te[$] *= we, re[$] += De) : (te[$] *= Fe, re[$] += Ae);
                  k *= fe, H <<= 1;
                }
                for ($ = 0; $ < G; ++$) {
                  let ne = 0;
                  for (ee = 0; ee < E; ee++)
                    ne += Y[re[ee] + $] * te[ee];
                  ne = F(ne, 0, 1, L[$][0], L[$][1]), N[Z + $] = Math.min(Math.max(ne, O[$][0]), O[$][1]);
                }
              };
            }
            static constructInterpolated({
              xref: b,
              isEvalSupported: l,
              dict: _
            }) {
              const S = r(_.getArray("C0")) || [0], A = r(_.getArray("C1")) || [1], F = _.get("N"), T = [];
              for (let U = 0, G = S.length; U < G; ++U)
                T.push(A[U] - S[U]);
              const O = T.length;
              return function(G, K, W, z) {
                const V = F === 1 ? G[K] : G[K] ** F;
                for (let L = 0; L < O; ++L)
                  W[z + L] = S[L] + V * T[L];
              };
            }
            static constructStiched({
              xref: b,
              isEvalSupported: l,
              dict: _
            }) {
              const S = r(_.getArray("Domain"));
              if (!S)
                throw new i.FormatError("No domain");
              if (S.length / 2 !== 1)
                throw new i.FormatError("Bad domain for stiched function");
              const F = _.get("Functions"), T = [];
              for (let K = 0, W = F.length; K < W; ++K)
                T.push(this.parse({
                  xref: b,
                  isEvalSupported: l,
                  fn: b.fetchIfRef(F[K])
                }));
              const O = r(_.getArray("Bounds")), U = r(_.getArray("Encode")), G = new Float32Array(1);
              return function(W, z, V, L) {
                const J = function(ee, $, k) {
                  return ee > k ? ee = k : ee < $ && (ee = $), ee;
                }(W[z], S[0], S[1]), ie = O.length;
                let q;
                for (q = 0; q < ie && !(J < O[q]); ++q)
                  ;
                let N = S[0];
                q > 0 && (N = O[q - 1]);
                let Z = S[1];
                q < O.length && (Z = O[q]);
                const E = U[2 * q], te = U[2 * q + 1];
                G[0] = N === Z ? E : E + (J - N) * (te - E) / (Z - N), T[q](G, 0, V, L);
              };
            }
            static constructPostScript({
              xref: b,
              isEvalSupported: l,
              fn: _,
              dict: S
            }) {
              const A = r(S.getArray("Domain")), F = r(S.getArray("Range"));
              if (!A)
                throw new i.FormatError("No domain.");
              if (!F)
                throw new i.FormatError("No range.");
              const T = new v.PostScriptLexer(_), U = new v.PostScriptParser(T).parse();
              if (l && i.FeatureTest.isEvalSupported) {
                const J = new R().compile(U, A, F);
                if (J)
                  return new Function("src", "srcOffset", "dest", "destOffset", J);
              }
              (0, i.info)("Unable to compile PS function");
              const G = F.length >> 1, K = A.length >> 1, W = new c(U), z = /* @__PURE__ */ Object.create(null);
              let L = 2048 * 4;
              const Y = new Float32Array(K);
              return function(ie, q, N, Z) {
                let E, te, re = "";
                const ee = Y;
                for (E = 0; E < K; E++)
                  te = ie[q + E], ee[E] = te, re += te + "_";
                const $ = z[re];
                if ($ !== void 0) {
                  N.set($, Z);
                  return;
                }
                const k = new Float32Array(G), H = W.execute(ee), ne = H.length - G;
                for (E = 0; E < G; E++) {
                  te = H[ne + E];
                  let ae = F[E * 2];
                  te < ae ? te = ae : (ae = F[E * 2 + 1], te > ae && (te = ae)), k[E] = te;
                }
                L > 0 && (L--, z[re] = k), N.set(k, Z);
              };
            }
          }
          function g(D) {
            let b;
            if (typeof D != "object")
              return !1;
            if (D instanceof t.Dict)
              b = D;
            else if (D instanceof a.BaseStream)
              b = D.dict;
            else
              return !1;
            return b.has("FunctionType");
          }
          class d {
            static get MAX_STACK_SIZE() {
              return (0, i.shadow)(this, "MAX_STACK_SIZE", 100);
            }
            constructor(b) {
              this.stack = b ? Array.prototype.slice.call(b, 0) : [];
            }
            push(b) {
              if (this.stack.length >= d.MAX_STACK_SIZE)
                throw new Error("PostScript function stack overflow.");
              this.stack.push(b);
            }
            pop() {
              if (this.stack.length <= 0)
                throw new Error("PostScript function stack underflow.");
              return this.stack.pop();
            }
            copy(b) {
              if (this.stack.length + b >= d.MAX_STACK_SIZE)
                throw new Error("PostScript function stack overflow.");
              const l = this.stack;
              for (let _ = l.length - b, S = b - 1; S >= 0; S--, _++)
                l.push(l[_]);
            }
            index(b) {
              this.push(this.stack[this.stack.length - b - 1]);
            }
            roll(b, l) {
              const _ = this.stack, S = _.length - b, A = _.length - 1, F = S + (l - Math.floor(l / b) * b);
              for (let T = S, O = A; T < O; T++, O--) {
                const U = _[T];
                _[T] = _[O], _[O] = U;
              }
              for (let T = S, O = F - 1; T < O; T++, O--) {
                const U = _[T];
                _[T] = _[O], _[O] = U;
              }
              for (let T = F, O = A; T < O; T++, O--) {
                const U = _[T];
                _[T] = _[O], _[O] = U;
              }
            }
          }
          class c {
            constructor(b) {
              this.operators = b;
            }
            execute(b) {
              const l = new d(b);
              let _ = 0;
              const S = this.operators, A = S.length;
              let F, T, O;
              for (; _ < A; ) {
                if (F = S[_++], typeof F == "number") {
                  l.push(F);
                  continue;
                }
                switch (F) {
                  case "jz":
                    O = l.pop(), T = l.pop(), T || (_ = O);
                    break;
                  case "j":
                    T = l.pop(), _ = T;
                    break;
                  case "abs":
                    T = l.pop(), l.push(Math.abs(T));
                    break;
                  case "add":
                    O = l.pop(), T = l.pop(), l.push(T + O);
                    break;
                  case "and":
                    O = l.pop(), T = l.pop(), typeof T == "boolean" && typeof O == "boolean" ? l.push(T && O) : l.push(T & O);
                    break;
                  case "atan":
                    T = l.pop(), l.push(Math.atan(T));
                    break;
                  case "bitshift":
                    O = l.pop(), T = l.pop(), T > 0 ? l.push(T << O) : l.push(T >> O);
                    break;
                  case "ceiling":
                    T = l.pop(), l.push(Math.ceil(T));
                    break;
                  case "copy":
                    T = l.pop(), l.copy(T);
                    break;
                  case "cos":
                    T = l.pop(), l.push(Math.cos(T));
                    break;
                  case "cvi":
                    T = l.pop() | 0, l.push(T);
                    break;
                  case "cvr":
                    break;
                  case "div":
                    O = l.pop(), T = l.pop(), l.push(T / O);
                    break;
                  case "dup":
                    l.copy(1);
                    break;
                  case "eq":
                    O = l.pop(), T = l.pop(), l.push(T === O);
                    break;
                  case "exch":
                    l.roll(2, 1);
                    break;
                  case "exp":
                    O = l.pop(), T = l.pop(), l.push(T ** O);
                    break;
                  case "false":
                    l.push(!1);
                    break;
                  case "floor":
                    T = l.pop(), l.push(Math.floor(T));
                    break;
                  case "ge":
                    O = l.pop(), T = l.pop(), l.push(T >= O);
                    break;
                  case "gt":
                    O = l.pop(), T = l.pop(), l.push(T > O);
                    break;
                  case "idiv":
                    O = l.pop(), T = l.pop(), l.push(T / O | 0);
                    break;
                  case "index":
                    T = l.pop(), l.index(T);
                    break;
                  case "le":
                    O = l.pop(), T = l.pop(), l.push(T <= O);
                    break;
                  case "ln":
                    T = l.pop(), l.push(Math.log(T));
                    break;
                  case "log":
                    T = l.pop(), l.push(Math.log(T) / Math.LN10);
                    break;
                  case "lt":
                    O = l.pop(), T = l.pop(), l.push(T < O);
                    break;
                  case "mod":
                    O = l.pop(), T = l.pop(), l.push(T % O);
                    break;
                  case "mul":
                    O = l.pop(), T = l.pop(), l.push(T * O);
                    break;
                  case "ne":
                    O = l.pop(), T = l.pop(), l.push(T !== O);
                    break;
                  case "neg":
                    T = l.pop(), l.push(-T);
                    break;
                  case "not":
                    T = l.pop(), typeof T == "boolean" ? l.push(!T) : l.push(~T);
                    break;
                  case "or":
                    O = l.pop(), T = l.pop(), typeof T == "boolean" && typeof O == "boolean" ? l.push(T || O) : l.push(T | O);
                    break;
                  case "pop":
                    l.pop();
                    break;
                  case "roll":
                    O = l.pop(), T = l.pop(), l.roll(T, O);
                    break;
                  case "round":
                    T = l.pop(), l.push(Math.round(T));
                    break;
                  case "sin":
                    T = l.pop(), l.push(Math.sin(T));
                    break;
                  case "sqrt":
                    T = l.pop(), l.push(Math.sqrt(T));
                    break;
                  case "sub":
                    O = l.pop(), T = l.pop(), l.push(T - O);
                    break;
                  case "true":
                    l.push(!0);
                    break;
                  case "truncate":
                    T = l.pop(), T = T < 0 ? Math.ceil(T) : Math.floor(T), l.push(T);
                    break;
                  case "xor":
                    O = l.pop(), T = l.pop(), typeof T == "boolean" && typeof O == "boolean" ? l.push(T !== O) : l.push(T ^ O);
                    break;
                  default:
                    throw new i.FormatError(`Unknown operator ${F}`);
                }
              }
              return l.stack;
            }
          }
          u.PostScriptEvaluator = c;
          class n {
            constructor(b) {
              this.type = b;
            }
            visit(b) {
              (0, i.unreachable)("abstract method");
            }
          }
          class o extends n {
            constructor(b, l, _) {
              super("args"), this.index = b, this.min = l, this.max = _;
            }
            visit(b) {
              b.visitArgument(this);
            }
          }
          class x extends n {
            constructor(b) {
              super("literal"), this.number = b, this.min = b, this.max = b;
            }
            visit(b) {
              b.visitLiteral(this);
            }
          }
          class f extends n {
            constructor(b, l, _, S, A) {
              super("binary"), this.op = b, this.arg1 = l, this.arg2 = _, this.min = S, this.max = A;
            }
            visit(b) {
              b.visitBinaryOperation(this);
            }
          }
          class m extends n {
            constructor(b, l) {
              super("max"), this.arg = b, this.min = b.min, this.max = l;
            }
            visit(b) {
              b.visitMin(this);
            }
          }
          class C extends n {
            constructor(b, l, _) {
              super("var"), this.index = b, this.min = l, this.max = _;
            }
            visit(b) {
              b.visitVariable(this);
            }
          }
          class p extends n {
            constructor(b, l) {
              super("definition"), this.variable = b, this.arg = l;
            }
            visit(b) {
              b.visitVariableDefinition(this);
            }
          }
          class w {
            constructor() {
              this.parts = [];
            }
            visitArgument(b) {
              this.parts.push("Math.max(", b.min, ", Math.min(", b.max, ", src[srcOffset + ", b.index, "]))");
            }
            visitVariable(b) {
              this.parts.push("v", b.index);
            }
            visitLiteral(b) {
              this.parts.push(b.number);
            }
            visitBinaryOperation(b) {
              this.parts.push("("), b.arg1.visit(this), this.parts.push(" ", b.op, " "), b.arg2.visit(this), this.parts.push(")");
            }
            visitVariableDefinition(b) {
              this.parts.push("var "), b.variable.visit(this), this.parts.push(" = "), b.arg.visit(this), this.parts.push(";");
            }
            visitMin(b) {
              this.parts.push("Math.min("), b.arg.visit(this), this.parts.push(", ", b.max, ")");
            }
            toString() {
              return this.parts.join("");
            }
          }
          function X(D, b) {
            return b.type === "literal" && b.number === 0 ? D : D.type === "literal" && D.number === 0 ? b : b.type === "literal" && D.type === "literal" ? new x(D.number + b.number) : new f("+", D, b, D.min + b.min, D.max + b.max);
          }
          function M(D, b) {
            if (b.type === "literal") {
              if (b.number === 0)
                return new x(0);
              if (b.number === 1)
                return D;
              if (D.type === "literal")
                return new x(D.number * b.number);
            }
            if (D.type === "literal") {
              if (D.number === 0)
                return new x(0);
              if (D.number === 1)
                return b;
            }
            const l = Math.min(D.min * b.min, D.min * b.max, D.max * b.min, D.max * b.max), _ = Math.max(D.min * b.min, D.min * b.max, D.max * b.min, D.max * b.max);
            return new f("*", D, b, l, _);
          }
          function j(D, b) {
            if (b.type === "literal") {
              if (b.number === 0)
                return D;
              if (D.type === "literal")
                return new x(D.number - b.number);
            }
            return b.type === "binary" && b.op === "-" && D.type === "literal" && D.number === 1 && b.arg1.type === "literal" && b.arg1.number === 1 ? b.arg2 : new f("-", D, b, D.min - b.max, D.max - b.min);
          }
          function B(D, b) {
            return D.min >= b ? new x(b) : D.max <= b ? D : new m(D, b);
          }
          class R {
            compile(b, l, _) {
              const S = [], A = [], F = l.length >> 1, T = _.length >> 1;
              let O = 0, U, G, K, W, z, V, L, Y;
              for (let ie = 0; ie < F; ie++)
                S.push(new o(ie, l[ie * 2], l[ie * 2 + 1]));
              for (let ie = 0, q = b.length; ie < q; ie++) {
                if (Y = b[ie], typeof Y == "number") {
                  S.push(new x(Y));
                  continue;
                }
                switch (Y) {
                  case "add":
                    if (S.length < 2)
                      return null;
                    W = S.pop(), K = S.pop(), S.push(X(K, W));
                    break;
                  case "cvr":
                    if (S.length < 1)
                      return null;
                    break;
                  case "mul":
                    if (S.length < 2)
                      return null;
                    W = S.pop(), K = S.pop(), S.push(M(K, W));
                    break;
                  case "sub":
                    if (S.length < 2)
                      return null;
                    W = S.pop(), K = S.pop(), S.push(j(K, W));
                    break;
                  case "exch":
                    if (S.length < 2)
                      return null;
                    z = S.pop(), V = S.pop(), S.push(z, V);
                    break;
                  case "pop":
                    if (S.length < 1)
                      return null;
                    S.pop();
                    break;
                  case "index":
                    if (S.length < 1 || (K = S.pop(), K.type !== "literal") || (U = K.number, U < 0 || !Number.isInteger(U) || S.length < U))
                      return null;
                    if (z = S[S.length - U - 1], z.type === "literal" || z.type === "var") {
                      S.push(z);
                      break;
                    }
                    L = new C(O++, z.min, z.max), S[S.length - U - 1] = L, S.push(L), A.push(new p(L, z));
                    break;
                  case "dup":
                    if (S.length < 1)
                      return null;
                    if (typeof b[ie + 1] == "number" && b[ie + 2] === "gt" && b[ie + 3] === ie + 7 && b[ie + 4] === "jz" && b[ie + 5] === "pop" && b[ie + 6] === b[ie + 1]) {
                      K = S.pop(), S.push(B(K, b[ie + 1])), ie += 6;
                      break;
                    }
                    if (z = S.at(-1), z.type === "literal" || z.type === "var") {
                      S.push(z);
                      break;
                    }
                    L = new C(O++, z.min, z.max), S[S.length - 1] = L, S.push(L), A.push(new p(L, z));
                    break;
                  case "roll":
                    if (S.length < 2 || (W = S.pop(), K = S.pop(), W.type !== "literal" || K.type !== "literal") || (G = W.number, U = K.number, U <= 0 || !Number.isInteger(U) || !Number.isInteger(G) || S.length < U))
                      return null;
                    if (G = (G % U + U) % U, G === 0)
                      break;
                    Array.prototype.push.apply(S, S.splice(S.length - U, U - G));
                    break;
                  default:
                    return null;
                }
              }
              if (S.length !== T)
                return null;
              const J = [];
              for (const ie of A) {
                const q = new w();
                ie.visit(q), J.push(q.toString());
              }
              for (let ie = 0, q = S.length; ie < q; ie++) {
                const N = S[ie], Z = new w();
                N.visit(Z);
                const E = _[ie * 2], te = _[ie * 2 + 1], re = [Z.toString()];
                E > N.min && (re.unshift("Math.max(", E, ", "), re.push(")")), te < N.max && (re.unshift("Math.min(", te, ", "), re.push(")")), re.unshift("dest[destOffset + ", ie, "] = "), re.push(";"), J.push(re.join(""));
              }
              return J.join(`
`);
            }
          }
          u.PostScriptCompiler = R;
        },
        /* 58 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.PostScriptParser = u.PostScriptLexer = void 0;
          var t = P(2), i = P(5), v = P(6);
          class a {
            constructor(g) {
              this.lexer = g, this.operators = [], this.token = null, this.prev = null;
            }
            nextToken() {
              this.prev = this.token, this.token = this.lexer.getToken();
            }
            accept(g) {
              return this.token.type === g ? (this.nextToken(), !0) : !1;
            }
            expect(g) {
              if (this.accept(g))
                return !0;
              throw new t.FormatError(`Unexpected symbol: found ${this.token.type} expected ${g}.`);
            }
            parse() {
              return this.nextToken(), this.expect(e.LBRACE), this.parseBlock(), this.expect(e.RBRACE), this.operators;
            }
            parseBlock() {
              for (; ; )
                if (this.accept(e.NUMBER))
                  this.operators.push(this.prev.value);
                else if (this.accept(e.OPERATOR))
                  this.operators.push(this.prev.value);
                else if (this.accept(e.LBRACE))
                  this.parseCondition();
                else
                  return;
            }
            parseCondition() {
              const g = this.operators.length;
              if (this.operators.push(null, null), this.parseBlock(), this.expect(e.RBRACE), this.accept(e.IF))
                this.operators[g] = this.operators.length, this.operators[g + 1] = "jz";
              else if (this.accept(e.LBRACE)) {
                const d = this.operators.length;
                this.operators.push(null, null);
                const c = this.operators.length;
                this.parseBlock(), this.expect(e.RBRACE), this.expect(e.IFELSE), this.operators[d] = this.operators.length, this.operators[d + 1] = "j", this.operators[g] = c, this.operators[g + 1] = "jz";
              } else
                throw new t.FormatError("PS Function: error parsing conditional.");
            }
          }
          u.PostScriptParser = a;
          const e = {
            LBRACE: 0,
            RBRACE: 1,
            NUMBER: 2,
            OPERATOR: 3,
            IF: 4,
            IFELSE: 5
          };
          class y {
            static get opCache() {
              return (0, t.shadow)(this, "opCache", /* @__PURE__ */ Object.create(null));
            }
            constructor(g, d) {
              this.type = g, this.value = d;
            }
            static getOperator(g) {
              const d = y.opCache[g];
              return d || (y.opCache[g] = new y(e.OPERATOR, g));
            }
            static get LBRACE() {
              return (0, t.shadow)(this, "LBRACE", new y(e.LBRACE, "{"));
            }
            static get RBRACE() {
              return (0, t.shadow)(this, "RBRACE", new y(e.RBRACE, "}"));
            }
            static get IF() {
              return (0, t.shadow)(this, "IF", new y(e.IF, "IF"));
            }
            static get IFELSE() {
              return (0, t.shadow)(this, "IFELSE", new y(e.IFELSE, "IFELSE"));
            }
          }
          class r {
            constructor(g) {
              this.stream = g, this.nextChar(), this.strBuf = [];
            }
            nextChar() {
              return this.currentChar = this.stream.getByte();
            }
            getToken() {
              let g = !1, d = this.currentChar;
              for (; ; ) {
                if (d < 0)
                  return i.EOF;
                if (g)
                  (d === 10 || d === 13) && (g = !1);
                else if (d === 37)
                  g = !0;
                else if (!(0, v.isWhiteSpace)(d))
                  break;
                d = this.nextChar();
              }
              switch (d | 0) {
                case 48:
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                case 43:
                case 45:
                case 46:
                  return new y(e.NUMBER, this.getNumber());
                case 123:
                  return this.nextChar(), y.LBRACE;
                case 125:
                  return this.nextChar(), y.RBRACE;
              }
              const c = this.strBuf;
              for (c.length = 0, c[0] = String.fromCharCode(d); (d = this.nextChar()) >= 0 && (d >= 65 && d <= 90 || d >= 97 && d <= 122); )
                c.push(String.fromCharCode(d));
              const n = c.join("");
              switch (n.toLowerCase()) {
                case "if":
                  return y.IF;
                case "ifelse":
                  return y.IFELSE;
                default:
                  return y.getOperator(n);
              }
            }
            getNumber() {
              let g = this.currentChar;
              const d = this.strBuf;
              for (d.length = 0, d[0] = String.fromCharCode(g); (g = this.nextChar()) >= 0 && (g >= 48 && g <= 57 || g === 45 || g === 46); )
                d.push(String.fromCharCode(g));
              const c = parseFloat(d.join(""));
              if (isNaN(c))
                throw new t.FormatError(`Invalid floating point number: ${c}`);
              return c;
            }
          }
          u.PostScriptLexer = r;
        },
        /* 59 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.LocalTilingPatternCache = u.LocalImageCache = u.LocalGStateCache = u.LocalFunctionCache = u.LocalColorSpaceCache = u.GlobalImageCache = void 0;
          var t = P(2), i = P(5);
          class v {
            constructor(c) {
              this.constructor === v && (0, t.unreachable)("Cannot initialize BaseLocalCache."), this._onlyRefs = (c && c.onlyRefs) === !0, this._onlyRefs || (this._nameRefMap = /* @__PURE__ */ new Map(), this._imageMap = /* @__PURE__ */ new Map()), this._imageCache = new i.RefSetCache();
            }
            getByName(c) {
              this._onlyRefs && (0, t.unreachable)("Should not call `getByName` method.");
              const n = this._nameRefMap.get(c);
              return n ? this.getByRef(n) : this._imageMap.get(c) || null;
            }
            getByRef(c) {
              return this._imageCache.get(c) || null;
            }
            set(c, n, o) {
              (0, t.unreachable)("Abstract method `set` called.");
            }
          }
          class a extends v {
            set(c, n = null, o) {
              if (typeof c != "string")
                throw new Error('LocalImageCache.set - expected "name" argument.');
              if (n) {
                if (this._imageCache.has(n))
                  return;
                this._nameRefMap.set(c, n), this._imageCache.put(n, o);
                return;
              }
              this._imageMap.has(c) || this._imageMap.set(c, o);
            }
          }
          u.LocalImageCache = a;
          class e extends v {
            set(c = null, n = null, o) {
              if (typeof c != "string" && !n)
                throw new Error('LocalColorSpaceCache.set - expected "name" and/or "ref" argument.');
              if (n) {
                if (this._imageCache.has(n))
                  return;
                c !== null && this._nameRefMap.set(c, n), this._imageCache.put(n, o);
                return;
              }
              this._imageMap.has(c) || this._imageMap.set(c, o);
            }
          }
          u.LocalColorSpaceCache = e;
          class y extends v {
            constructor(c) {
              super({
                onlyRefs: !0
              });
            }
            set(c = null, n, o) {
              if (!n)
                throw new Error('LocalFunctionCache.set - expected "ref" argument.');
              this._imageCache.has(n) || this._imageCache.put(n, o);
            }
          }
          u.LocalFunctionCache = y;
          class r extends v {
            set(c, n = null, o) {
              if (typeof c != "string")
                throw new Error('LocalGStateCache.set - expected "name" argument.');
              if (n) {
                if (this._imageCache.has(n))
                  return;
                this._nameRefMap.set(c, n), this._imageCache.put(n, o);
                return;
              }
              this._imageMap.has(c) || this._imageMap.set(c, o);
            }
          }
          u.LocalGStateCache = r;
          class h extends v {
            constructor(c) {
              super({
                onlyRefs: !0
              });
            }
            set(c = null, n, o) {
              if (!n)
                throw new Error('LocalTilingPatternCache.set - expected "ref" argument.');
              this._imageCache.has(n) || this._imageCache.put(n, o);
            }
          }
          u.LocalTilingPatternCache = h;
          class g {
            static get NUM_PAGES_THRESHOLD() {
              return (0, t.shadow)(this, "NUM_PAGES_THRESHOLD", 2);
            }
            static get MIN_IMAGES_TO_CACHE() {
              return (0, t.shadow)(this, "MIN_IMAGES_TO_CACHE", 10);
            }
            static get MAX_BYTE_SIZE() {
              return (0, t.shadow)(this, "MAX_BYTE_SIZE", 4e7);
            }
            constructor() {
              this._refCache = new i.RefSetCache(), this._imageCache = new i.RefSetCache();
            }
            get _byteSize() {
              let c = 0;
              for (const n of this._imageCache)
                c += n.byteSize;
              return c;
            }
            get _cacheLimitReached() {
              return !(this._imageCache.size < g.MIN_IMAGES_TO_CACHE || this._byteSize < g.MAX_BYTE_SIZE);
            }
            shouldCache(c, n) {
              const o = this._refCache.get(c);
              return !((o ? o.size + (o.has(n) ? 0 : 1) : 1) < g.NUM_PAGES_THRESHOLD || !this._imageCache.has(c) && this._cacheLimitReached);
            }
            addPageIndex(c, n) {
              let o = this._refCache.get(c);
              o || (o = /* @__PURE__ */ new Set(), this._refCache.put(c, o)), o.add(n);
            }
            addByteSize(c, n) {
              const o = this._imageCache.get(c);
              o && (o.byteSize || (o.byteSize = n));
            }
            getData(c, n) {
              const o = this._refCache.get(c);
              if (!o || o.size < g.NUM_PAGES_THRESHOLD)
                return null;
              const x = this._imageCache.get(c);
              return x ? (o.add(n), x) : null;
            }
            setData(c, n) {
              if (!this._refCache.has(c))
                throw new Error('GlobalImageCache.setData - expected "addPageIndex" to have been called.');
              if (!this._imageCache.has(c)) {
                if (this._cacheLimitReached) {
                  (0, t.warn)("GlobalImageCache.setData - cache limit reached.");
                  return;
                }
                this._imageCache.put(c, n);
              }
            }
            clear(c = !1) {
              c || this._refCache.clear(), this._imageCache.clear();
            }
          }
          u.GlobalImageCache = g;
        },
        /* 60 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.bidi = n;
          var t = P(2);
          const i = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "ON", "ON", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "ON", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "ON", "ET", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "L", "ON", "ON", "BN", "ON", "ON", "ET", "ET", "EN", "EN", "ON", "L", "ON", "ON", "ON", "EN", "L", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L"], v = ["AN", "AN", "AN", "AN", "AN", "AN", "ON", "ON", "AL", "ET", "ET", "AL", "CS", "AL", "ON", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "ON", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL"];
          function a(o) {
            return (o & 1) !== 0;
          }
          function e(o) {
            return (o & 1) === 0;
          }
          function y(o, x, f) {
            let m, C;
            for (m = x, C = o.length; m < C; ++m)
              if (o[m] !== f)
                return m;
            return m;
          }
          function r(o, x, f, m) {
            for (let C = x; C < f; ++C)
              o[C] = m;
          }
          function h(o, x, f) {
            for (let m = x, C = f - 1; m < C; ++m, --C) {
              const p = o[m];
              o[m] = o[C], o[C] = p;
            }
          }
          function g(o, x, f = !1) {
            let m = "ltr";
            return f ? m = "ttb" : x || (m = "rtl"), {
              str: o,
              dir: m
            };
          }
          const d = [], c = [];
          function n(o, x = -1, f = !1) {
            let m = !0;
            const C = o.length;
            if (C === 0 || f)
              return g(o, m, f);
            d.length = C, c.length = C;
            let p = 0, w, X;
            for (w = 0; w < C; ++w) {
              d[w] = o.charAt(w);
              const A = o.charCodeAt(w);
              let F = "L";
              A <= 255 ? F = i[A] : 1424 <= A && A <= 1524 ? F = "R" : 1536 <= A && A <= 1791 ? (F = v[A & 255], F || (0, t.warn)("Bidi: invalid Unicode character " + A.toString(16))) : 1792 <= A && A <= 2220 && (F = "AL"), (F === "R" || F === "AL" || F === "AN") && p++, c[w] = F;
            }
            if (p === 0)
              return m = !0, g(o, m);
            x === -1 && (p / C < 0.3 && C > 4 ? (m = !0, x = 0) : (m = !1, x = 1));
            const M = [];
            for (w = 0; w < C; ++w)
              M[w] = x;
            const j = a(x) ? "R" : "L", B = j, R = B;
            let D = B;
            for (w = 0; w < C; ++w)
              c[w] === "NSM" ? c[w] = D : D = c[w];
            D = B;
            let b;
            for (w = 0; w < C; ++w)
              b = c[w], b === "EN" ? c[w] = D === "AL" ? "AN" : "EN" : (b === "R" || b === "L" || b === "AL") && (D = b);
            for (w = 0; w < C; ++w)
              b = c[w], b === "AL" && (c[w] = "R");
            for (w = 1; w < C - 1; ++w)
              c[w] === "ES" && c[w - 1] === "EN" && c[w + 1] === "EN" && (c[w] = "EN"), c[w] === "CS" && (c[w - 1] === "EN" || c[w - 1] === "AN") && c[w + 1] === c[w - 1] && (c[w] = c[w - 1]);
            for (w = 0; w < C; ++w)
              if (c[w] === "EN") {
                for (let A = w - 1; A >= 0 && c[A] === "ET"; --A)
                  c[A] = "EN";
                for (let A = w + 1; A < C && c[A] === "ET"; ++A)
                  c[A] = "EN";
              }
            for (w = 0; w < C; ++w)
              b = c[w], (b === "WS" || b === "ES" || b === "ET" || b === "CS") && (c[w] = "ON");
            for (D = B, w = 0; w < C; ++w)
              b = c[w], b === "EN" ? c[w] = D === "L" ? "L" : "EN" : (b === "R" || b === "L") && (D = b);
            for (w = 0; w < C; ++w)
              if (c[w] === "ON") {
                const A = y(c, w + 1, "ON");
                let F = B;
                w > 0 && (F = c[w - 1]);
                let T = R;
                A + 1 < C && (T = c[A + 1]), F !== "L" && (F = "R"), T !== "L" && (T = "R"), F === T && r(c, w, A, F), w = A - 1;
              }
            for (w = 0; w < C; ++w)
              c[w] === "ON" && (c[w] = j);
            for (w = 0; w < C; ++w)
              b = c[w], e(M[w]) ? b === "R" ? M[w] += 1 : (b === "AN" || b === "EN") && (M[w] += 2) : (b === "L" || b === "AN" || b === "EN") && (M[w] += 1);
            let l = -1, _ = 99, S;
            for (w = 0, X = M.length; w < X; ++w)
              S = M[w], l < S && (l = S), _ > S && a(S) && (_ = S);
            for (S = l; S >= _; --S) {
              let A = -1;
              for (w = 0, X = M.length; w < X; ++w)
                M[w] < S ? A >= 0 && (h(d, A, w), A = -1) : A < 0 && (A = w);
              A >= 0 && h(d, A, M.length);
            }
            for (w = 0, X = d.length; w < X; ++w) {
              const A = d[w];
              (A === "<" || A === ">") && (d[w] = "");
            }
            return g(d.join(""), m);
          }
        },
        /* 61 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.MurmurHash3_64 = void 0;
          var t = P(2);
          const i = 3285377520, v = 4294901760, a = 65535;
          class e {
            constructor(r) {
              this.h1 = r ? r & 4294967295 : i, this.h2 = r ? r & 4294967295 : i;
            }
            update(r) {
              let h, g;
              if (typeof r == "string") {
                h = new Uint8Array(r.length * 2), g = 0;
                for (let M = 0, j = r.length; M < j; M++) {
                  const B = r.charCodeAt(M);
                  B <= 255 ? h[g++] = B : (h[g++] = B >>> 8, h[g++] = B & 255);
                }
              } else if ((0, t.isArrayBuffer)(r))
                h = r.slice(), g = h.byteLength;
              else
                throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");
              const d = g >> 2, c = g - d * 4, n = new Uint32Array(h.buffer, 0, d);
              let o = 0, x = 0, f = this.h1, m = this.h2;
              const C = 3432918353, p = 461845907, w = C & a, X = p & a;
              for (let M = 0; M < d; M++)
                M & 1 ? (o = n[M], o = o * C & v | o * w & a, o = o << 15 | o >>> 17, o = o * p & v | o * X & a, f ^= o, f = f << 13 | f >>> 19, f = f * 5 + 3864292196) : (x = n[M], x = x * C & v | x * w & a, x = x << 15 | x >>> 17, x = x * p & v | x * X & a, m ^= x, m = m << 13 | m >>> 19, m = m * 5 + 3864292196);
              switch (o = 0, c) {
                case 3:
                  o ^= h[d * 4 + 2] << 16;
                case 2:
                  o ^= h[d * 4 + 1] << 8;
                case 1:
                  o ^= h[d * 4], o = o * C & v | o * w & a, o = o << 15 | o >>> 17, o = o * p & v | o * X & a, d & 1 ? f ^= o : m ^= o;
              }
              this.h1 = f, this.h2 = m;
            }
            hexdigest() {
              let r = this.h1, h = this.h2;
              r ^= h >>> 1, r = r * 3981806797 & v | r * 36045 & a, h = h * 4283543511 & v | ((h << 16 | r >>> 16) * 2950163797 & v) >>> 16, r ^= h >>> 1, r = r * 444984403 & v | r * 60499 & a, h = h * 3301882366 & v | ((h << 16 | r >>> 16) * 3120437893 & v) >>> 16, r ^= h >>> 1;
              const g = (r >>> 0).toString(16), d = (h >>> 0).toString(16);
              return g.padStart(8, "0") + d.padStart(8, "0");
            }
          }
          u.MurmurHash3_64 = e;
        },
        /* 62 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.OperatorList = void 0;
          var t = P(2);
          function i(r, h, g, d, c) {
            let n = r;
            for (let o = 0, x = h.length - 1; o < x; o++) {
              const f = h[o];
              n = n[f] || (n[f] = []);
            }
            n[h.at(-1)] = {
              checkFn: g,
              iterateFn: d,
              processFn: c
            };
          }
          const v = [];
          i(v, [t.OPS.save, t.OPS.transform, t.OPS.paintInlineImageXObject, t.OPS.restore], null, function(h, g) {
            const d = h.fnArray, c = h.iCurr - 3, n = (g - c) % 4;
            switch (n) {
              case 0:
                return d[g] === t.OPS.save;
              case 1:
                return d[g] === t.OPS.transform;
              case 2:
                return d[g] === t.OPS.paintInlineImageXObject;
              case 3:
                return d[g] === t.OPS.restore;
            }
            throw new Error(`iterateInlineImageGroup - invalid pos: ${n}`);
          }, function(h, g) {
            const x = h.fnArray, f = h.argsArray, m = h.iCurr, C = m - 3, p = m - 2, w = m - 1, X = Math.min(Math.floor((g - C) / 4), 200);
            if (X < 10)
              return g - (g - C) % 4;
            let M = 0;
            const j = [];
            let B = 0, R = 1, D = 1;
            for (let A = 0; A < X; A++) {
              const F = f[p + (A << 2)], T = f[w + (A << 2)][0];
              R + T.width > 1e3 && (M = Math.max(M, R), D += B + 2, R = 0, B = 0), j.push({
                transform: F,
                x: R,
                y: D,
                w: T.width,
                h: T.height
              }), R += T.width + 2, B = Math.max(B, T.height);
            }
            const b = Math.max(M, R) + 1, l = D + B + 1, _ = new Uint8Array(b * l * 4), S = b << 2;
            for (let A = 0; A < X; A++) {
              const F = f[w + (A << 2)][0].data, T = j[A].w << 2;
              let O = 0, U = j[A].x + j[A].y * b << 2;
              _.set(F.subarray(0, T), U - S);
              for (let G = 0, K = j[A].h; G < K; G++)
                _.set(F.subarray(O, O + T), U), O += T, U += S;
              for (_.set(F.subarray(O - T, O), U); U >= 0; )
                F[U - 4] = F[U], F[U - 3] = F[U + 1], F[U - 2] = F[U + 2], F[U - 1] = F[U + 3], F[U + T] = F[U + T - 4], F[U + T + 1] = F[U + T - 3], F[U + T + 2] = F[U + T - 2], F[U + T + 3] = F[U + T - 1], U -= S;
            }
            return x.splice(C, X * 4, t.OPS.paintInlineImageXObjectGroup), f.splice(C, X * 4, [{
              width: b,
              height: l,
              kind: t.ImageKind.RGBA_32BPP,
              data: _
            }, j]), C + 1;
          }), i(v, [t.OPS.save, t.OPS.transform, t.OPS.paintImageMaskXObject, t.OPS.restore], null, function(h, g) {
            const d = h.fnArray, c = h.iCurr - 3, n = (g - c) % 4;
            switch (n) {
              case 0:
                return d[g] === t.OPS.save;
              case 1:
                return d[g] === t.OPS.transform;
              case 2:
                return d[g] === t.OPS.paintImageMaskXObject;
              case 3:
                return d[g] === t.OPS.restore;
            }
            throw new Error(`iterateImageMaskGroup - invalid pos: ${n}`);
          }, function(h, g) {
            const o = h.fnArray, x = h.argsArray, f = h.iCurr, m = f - 3, C = f - 2, p = f - 1;
            let w = Math.floor((g - m) / 4);
            if (w < 10)
              return g - (g - m) % 4;
            let X = !1, M, j;
            const B = x[p][0], R = x[C][0], D = x[C][1], b = x[C][2], l = x[C][3];
            if (D === b) {
              X = !0, M = C + 4;
              let _ = p + 4;
              for (let S = 1; S < w; S++, M += 4, _ += 4)
                if (j = x[M], x[_][0] !== B || j[0] !== R || j[1] !== D || j[2] !== b || j[3] !== l) {
                  S < 10 ? X = !1 : w = S;
                  break;
                }
            }
            if (X) {
              w = Math.min(w, 1e3);
              const _ = new Float32Array(w * 2);
              M = C;
              for (let S = 0; S < w; S++, M += 4)
                j = x[M], _[S << 1] = j[4], _[(S << 1) + 1] = j[5];
              o.splice(m, w * 4, t.OPS.paintImageMaskXObjectRepeat), x.splice(m, w * 4, [B, R, D, b, l, _]);
            } else {
              w = Math.min(w, 100);
              const _ = [];
              for (let S = 0; S < w; S++) {
                j = x[C + (S << 2)];
                const A = x[p + (S << 2)][0];
                _.push({
                  data: A.data,
                  width: A.width,
                  height: A.height,
                  interpolate: A.interpolate,
                  count: A.count,
                  transform: j
                });
              }
              o.splice(m, w * 4, t.OPS.paintImageMaskXObjectGroup), x.splice(m, w * 4, [_]);
            }
            return m + 1;
          }), i(v, [t.OPS.save, t.OPS.transform, t.OPS.paintImageXObject, t.OPS.restore], function(r) {
            const h = r.argsArray, g = r.iCurr - 2;
            return h[g][1] === 0 && h[g][2] === 0;
          }, function(h, g) {
            const d = h.fnArray, c = h.argsArray, n = h.iCurr - 3, o = (g - n) % 4;
            switch (o) {
              case 0:
                return d[g] === t.OPS.save;
              case 1:
                if (d[g] !== t.OPS.transform)
                  return !1;
                const x = h.iCurr - 2, f = c[x][0], m = c[x][3];
                return !(c[g][0] !== f || c[g][1] !== 0 || c[g][2] !== 0 || c[g][3] !== m);
              case 2:
                if (d[g] !== t.OPS.paintImageXObject)
                  return !1;
                const C = h.iCurr - 1, p = c[C][0];
                return c[g][0] === p;
              case 3:
                return d[g] === t.OPS.restore;
            }
            throw new Error(`iterateImageGroup - invalid pos: ${o}`);
          }, function(r, h) {
            const c = r.fnArray, n = r.argsArray, o = r.iCurr, x = o - 3, f = o - 2, m = o - 1, C = n[m][0], p = n[f][0], w = n[f][3], X = Math.min(Math.floor((h - x) / 4), 1e3);
            if (X < 3)
              return h - (h - x) % 4;
            const M = new Float32Array(X * 2);
            let j = f;
            for (let R = 0; R < X; R++, j += 4) {
              const D = n[j];
              M[R << 1] = D[4], M[(R << 1) + 1] = D[5];
            }
            const B = [C, p, w, M];
            return c.splice(x, X * 4, t.OPS.paintImageXObjectRepeat), n.splice(x, X * 4, B), x + 1;
          }), i(v, [t.OPS.beginText, t.OPS.setFont, t.OPS.setTextMatrix, t.OPS.showText, t.OPS.endText], null, function(h, g) {
            const d = h.fnArray, c = h.argsArray, n = h.iCurr - 4, o = (g - n) % 5;
            switch (o) {
              case 0:
                return d[g] === t.OPS.beginText;
              case 1:
                return d[g] === t.OPS.setFont;
              case 2:
                return d[g] === t.OPS.setTextMatrix;
              case 3:
                if (d[g] !== t.OPS.showText)
                  return !1;
                const x = h.iCurr - 3, f = c[x][0], m = c[x][1];
                return !(c[g][0] !== f || c[g][1] !== m);
              case 4:
                return d[g] === t.OPS.endText;
            }
            throw new Error(`iterateShowTextGroup - invalid pos: ${o}`);
          }, function(r, h) {
            const c = r.fnArray, n = r.argsArray, o = r.iCurr, x = o - 4, f = o - 3, m = o - 2, C = o - 1, p = o, w = n[f][0], X = n[f][1];
            let M = Math.min(Math.floor((h - x) / 5), 1e3);
            if (M < 3)
              return h - (h - x) % 5;
            let j = x;
            x >= 4 && c[x - 4] === c[f] && c[x - 3] === c[m] && c[x - 2] === c[C] && c[x - 1] === c[p] && n[x - 4][0] === w && n[x - 4][1] === X && (M++, j -= 5);
            let B = j + 4;
            for (let R = 1; R < M; R++)
              c.splice(B, 3), n.splice(B, 3), B += 2;
            return B + 1;
          });
          class a {
            constructor(h) {
              this.queue = h;
            }
            _optimize() {
            }
            push(h, g) {
              this.queue.fnArray.push(h), this.queue.argsArray.push(g), this._optimize();
            }
            flush() {
            }
            reset() {
            }
          }
          class e extends a {
            constructor(h) {
              super(h), this.state = null, this.context = {
                iCurr: 0,
                fnArray: h.fnArray,
                argsArray: h.argsArray
              }, this.match = null, this.lastProcessed = 0;
            }
            _optimize() {
              const h = this.queue.fnArray;
              let g = this.lastProcessed, d = h.length, c = this.state, n = this.match;
              if (!c && !n && g + 1 === d && !v[h[g]]) {
                this.lastProcessed = d;
                return;
              }
              const o = this.context;
              for (; g < d; ) {
                if (n) {
                  if ((0, n.iterateFn)(o, g)) {
                    g++;
                    continue;
                  }
                  if (g = (0, n.processFn)(o, g + 1), d = h.length, n = null, c = null, g >= d)
                    break;
                }
                if (c = (c || v)[h[g]], !c || Array.isArray(c)) {
                  g++;
                  continue;
                }
                if (o.iCurr = g, g++, c.checkFn && !(0, c.checkFn)(o)) {
                  c = null;
                  continue;
                }
                n = c, c = null;
              }
              this.state = c, this.match = n, this.lastProcessed = g;
            }
            flush() {
              for (; this.match; ) {
                const h = this.queue.fnArray.length;
                this.lastProcessed = (0, this.match.processFn)(this.context, h), this.match = null, this.state = null, this._optimize();
              }
            }
            reset() {
              this.state = null, this.match = null, this.lastProcessed = 0;
            }
          }
          class y {
            static get CHUNK_SIZE() {
              return (0, t.shadow)(this, "CHUNK_SIZE", 1e3);
            }
            static get CHUNK_SIZE_ABOUT() {
              return (0, t.shadow)(this, "CHUNK_SIZE_ABOUT", this.CHUNK_SIZE - 5);
            }
            constructor(h = 0, g) {
              this._streamSink = g, this.fnArray = [], this.argsArray = [], g && !(h & t.RenderingIntentFlag.OPLIST) ? this.optimizer = new e(this) : this.optimizer = new a(this), this.dependencies = /* @__PURE__ */ new Set(), this._totalLength = 0, this.weight = 0, this._resolved = g ? null : Promise.resolve();
            }
            get length() {
              return this.argsArray.length;
            }
            get ready() {
              return this._resolved || this._streamSink.ready;
            }
            get totalLength() {
              return this._totalLength + this.length;
            }
            addOp(h, g) {
              this.optimizer.push(h, g), this.weight++, this._streamSink && (this.weight >= y.CHUNK_SIZE ? this.flush() : this.weight >= y.CHUNK_SIZE_ABOUT && (h === t.OPS.restore || h === t.OPS.endText) && this.flush());
            }
            addImageOps(h, g, d) {
              d !== void 0 && this.addOp(t.OPS.beginMarkedContentProps, ["OC", d]), this.addOp(h, g), d !== void 0 && this.addOp(t.OPS.endMarkedContent, []);
            }
            addDependency(h) {
              this.dependencies.has(h) || (this.dependencies.add(h), this.addOp(t.OPS.dependency, [h]));
            }
            addDependencies(h) {
              for (const g of h)
                this.addDependency(g);
            }
            addOpList(h) {
              if (!(h instanceof y)) {
                (0, t.warn)('addOpList - ignoring invalid "opList" parameter.');
                return;
              }
              for (const g of h.dependencies)
                this.dependencies.add(g);
              for (let g = 0, d = h.length; g < d; g++)
                this.addOp(h.fnArray[g], h.argsArray[g]);
            }
            getIR() {
              return {
                fnArray: this.fnArray,
                argsArray: this.argsArray,
                length: this.length
              };
            }
            get _transfers() {
              const h = [], {
                fnArray: g,
                argsArray: d,
                length: c
              } = this;
              for (let n = 0; n < c; n++)
                switch (g[n]) {
                  case t.OPS.paintInlineImageXObject:
                  case t.OPS.paintInlineImageXObjectGroup:
                  case t.OPS.paintImageMaskXObject:
                    const o = d[n][0];
                    !o.cached && o.data && o.data.buffer instanceof ArrayBuffer && h.push(o.data.buffer);
                    break;
                }
              return h;
            }
            flush(h = !1, g = null) {
              this.optimizer.flush();
              const d = this.length;
              this._totalLength += d, this._streamSink.enqueue({
                fnArray: this.fnArray,
                argsArray: this.argsArray,
                lastChunk: h,
                separateAnnots: g,
                length: d
              }, 1, this._transfers), this.dependencies.clear(), this.fnArray.length = 0, this.argsArray.length = 0, this.weight = 0, this.optimizer.reset();
            }
          }
          u.OperatorList = y;
        },
        /* 63 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.PDFImage = void 0;
          var t = P(2), i = P(64), v = P(7), a = P(14), e = P(19), y = P(27), r = P(30), h = P(5);
          function g(n, o, x, f) {
            return n = o + n * x, n < 0 ? n = 0 : n > f && (n = f), n;
          }
          function d(n, o, x, f, m, C) {
            const p = m * C;
            let w;
            o <= 8 ? w = new Uint8Array(p) : o <= 16 ? w = new Uint16Array(p) : w = new Uint32Array(p);
            const X = x / m, M = f / C;
            let j, B, R, D = 0, b;
            const l = new Uint16Array(m), _ = x;
            for (j = 0; j < m; j++)
              l[j] = Math.floor(j * X);
            for (j = 0; j < C; j++)
              for (R = Math.floor(j * M) * _, B = 0; B < m; B++)
                b = R + l[B], w[D++] = n[b];
            return w;
          }
          class c {
            constructor({
              xref: o,
              res: x,
              image: f,
              isInline: m = !1,
              smask: C = null,
              mask: p = null,
              isMask: w = !1,
              pdfFunctionFactory: X,
              localColorSpaceCache: M
            }) {
              this.image = f;
              const j = f.dict, B = j.get("F", "Filter");
              let R;
              if (B instanceof h.Name)
                R = B.name;
              else if (Array.isArray(B)) {
                const _ = o.fetchIfRef(B[0]);
                _ instanceof h.Name && (R = _.name);
              }
              switch (R) {
                case "JPXDecode":
                  const _ = new r.JpxImage();
                  _.parseImageProperties(f.stream), f.stream.reset(), f.width = _.width, f.height = _.height, f.bitsPerComponent = _.bitsPerComponent, f.numComps = _.componentsCount;
                  break;
                case "JBIG2Decode":
                  f.bitsPerComponent = 1, f.numComps = 1;
                  break;
              }
              let D = j.get("W", "Width"), b = j.get("H", "Height");
              if (Number.isInteger(f.width) && f.width > 0 && Number.isInteger(f.height) && f.height > 0 && (f.width !== D || f.height !== b) && ((0, t.warn)("PDFImage - using the Width/Height of the image data, rather than the image dictionary."), D = f.width, b = f.height), D < 1 || b < 1)
                throw new t.FormatError(`Invalid image width: ${D} or height: ${b}`);
              this.width = D, this.height = b, this.interpolate = j.get("I", "Interpolate"), this.imageMask = j.get("IM", "ImageMask") || !1, this.matte = j.get("Matte") || !1;
              let l = f.bitsPerComponent;
              if (!l && (l = j.get("BPC", "BitsPerComponent"), !l))
                if (this.imageMask)
                  l = 1;
                else
                  throw new t.FormatError(`Bits per component missing in image: ${this.imageMask}`);
              if (this.bpc = l, !this.imageMask) {
                let _ = j.getRaw("CS") || j.getRaw("ColorSpace");
                if (!_)
                  switch ((0, t.info)("JPX images (which do not require color spaces)"), f.numComps) {
                    case 1:
                      _ = h.Name.get("DeviceGray");
                      break;
                    case 3:
                      _ = h.Name.get("DeviceRGB");
                      break;
                    case 4:
                      _ = h.Name.get("DeviceCMYK");
                      break;
                    default:
                      throw new Error(`JPX images with ${f.numComps} color components not supported.`);
                  }
                this.colorSpace = a.ColorSpace.parse({
                  cs: _,
                  xref: o,
                  resources: m ? x : null,
                  pdfFunctionFactory: X,
                  localColorSpaceCache: M
                }), this.numComps = this.colorSpace.numComps;
              }
              if (this.decode = j.getArray("D", "Decode"), this.needsDecode = !1, this.decode && (this.colorSpace && !this.colorSpace.isDefaultDecode(this.decode, l) || w && !a.ColorSpace.isDefaultDecode(this.decode, 1))) {
                this.needsDecode = !0;
                const _ = (1 << l) - 1;
                this.decodeCoefficients = [], this.decodeAddends = [];
                const S = this.colorSpace && this.colorSpace.name === "Indexed";
                for (let A = 0, F = 0; A < this.decode.length; A += 2, ++F) {
                  const T = this.decode[A], O = this.decode[A + 1];
                  this.decodeCoefficients[F] = S ? (O - T) / _ : O - T, this.decodeAddends[F] = S ? T : _ * T;
                }
              }
              C ? this.smask = new c({
                xref: o,
                res: x,
                image: C,
                isInline: m,
                pdfFunctionFactory: X,
                localColorSpaceCache: M
              }) : p && (p instanceof v.BaseStream ? p.dict.get("IM", "ImageMask") ? this.mask = new c({
                xref: o,
                res: x,
                image: p,
                isInline: m,
                isMask: !0,
                pdfFunctionFactory: X,
                localColorSpaceCache: M
              }) : (0, t.warn)("Ignoring /Mask in image without /ImageMask.") : this.mask = p);
            }
            static async buildImage({
              xref: o,
              res: x,
              image: f,
              isInline: m = !1,
              pdfFunctionFactory: C,
              localColorSpaceCache: p
            }) {
              const w = f;
              let X = null, M = null;
              const j = f.dict.get("SMask"), B = f.dict.get("Mask");
              return j ? j instanceof v.BaseStream ? X = j : (0, t.warn)("Unsupported /SMask format.") : B && (B instanceof v.BaseStream || Array.isArray(B) ? M = B : (0, t.warn)("Unsupported /Mask format.")), new c({
                xref: o,
                res: x,
                image: w,
                isInline: m,
                smask: X,
                mask: M,
                pdfFunctionFactory: C,
                localColorSpaceCache: p
              });
            }
            static createRawMask({
              imgArray: o,
              width: x,
              height: f,
              imageIsFromDecodeStream: m,
              inverseDecode: C,
              interpolate: p
            }) {
              const w = (x + 7 >> 3) * f, X = o.byteLength, M = w === X;
              let j, B;
              if (m && (!C || M) ? j = o : C ? (j = new Uint8Array(w), j.set(o), j.fill(255, X)) : j = new Uint8Array(o), C)
                for (B = 0; B < X; B++)
                  j[B] ^= 255;
              return {
                data: j,
                width: x,
                height: f,
                interpolate: p
              };
            }
            static createMask({
              imgArray: o,
              width: x,
              height: f,
              imageIsFromDecodeStream: m,
              inverseDecode: C,
              interpolate: p
            }) {
              const w = x === 1 && f === 1 && C === (o.length === 0 || !!(o[0] & 128));
              if (w)
                return {
                  isSingleOpaquePixel: w
                };
              if (t.FeatureTest.isOffscreenCanvasSupported) {
                const X = new OffscreenCanvas(x, f), M = X.getContext("2d"), j = M.createImageData(x, f);
                (0, i.applyMaskImageData)({
                  src: o,
                  dest: j.data,
                  width: x,
                  height: f,
                  inverseDecode: C
                }), M.putImageData(j, 0, 0);
                const B = X.transferToImageBitmap();
                return {
                  data: null,
                  width: x,
                  height: f,
                  interpolate: p,
                  bitmap: B
                };
              }
              return this.createRawMask({
                imgArray: o,
                width: x,
                height: f,
                inverseDecode: C,
                imageIsFromDecodeStream: m,
                interpolate: p
              });
            }
            get drawWidth() {
              return Math.max(this.width, this.smask && this.smask.width || 0, this.mask && this.mask.width || 0);
            }
            get drawHeight() {
              return Math.max(this.height, this.smask && this.smask.height || 0, this.mask && this.mask.height || 0);
            }
            decodeBuffer(o) {
              const x = this.bpc, f = this.numComps, m = this.decodeAddends, C = this.decodeCoefficients, p = (1 << x) - 1;
              let w, X;
              if (x === 1) {
                for (w = 0, X = o.length; w < X; w++)
                  o[w] = +!o[w];
                return;
              }
              let M = 0;
              for (w = 0, X = this.width * this.height; w < X; w++)
                for (let j = 0; j < f; j++)
                  o[M] = g(o[M], m[j], C[j], p), M++;
            }
            getComponents(o) {
              const x = this.bpc;
              if (x === 8)
                return o;
              const f = this.width, m = this.height, C = this.numComps, p = f * m * C;
              let w = 0, X;
              x <= 8 ? X = new Uint8Array(p) : x <= 16 ? X = new Uint16Array(p) : X = new Uint32Array(p);
              const M = f * C, j = (1 << x) - 1;
              let B = 0, R, D;
              if (x === 1) {
                let b, l, _;
                for (let S = 0; S < m; S++) {
                  for (l = B + (M & -8), _ = B + M; B < l; )
                    D = o[w++], X[B] = D >> 7 & 1, X[B + 1] = D >> 6 & 1, X[B + 2] = D >> 5 & 1, X[B + 3] = D >> 4 & 1, X[B + 4] = D >> 3 & 1, X[B + 5] = D >> 2 & 1, X[B + 6] = D >> 1 & 1, X[B + 7] = D & 1, B += 8;
                  if (B < _)
                    for (D = o[w++], b = 128; B < _; )
                      X[B++] = +!!(D & b), b >>= 1;
                }
              } else {
                let b = 0;
                for (D = 0, B = 0, R = p; B < R; ++B) {
                  for (B % M === 0 && (D = 0, b = 0); b < x; )
                    D = D << 8 | o[w++], b += 8;
                  const l = b - x;
                  let _ = D >> l;
                  _ < 0 ? _ = 0 : _ > j && (_ = j), X[B] = _, D &= (1 << l) - 1, b = l;
                }
              }
              return X;
            }
            fillOpacity(o, x, f, m, C) {
              const p = this.smask, w = this.mask;
              let X, M, j, B, R, D;
              if (p)
                M = p.width, j = p.height, X = new Uint8ClampedArray(M * j), p.fillGrayBuffer(X), (M !== x || j !== f) && (X = d(X, p.bpc, M, j, x, f));
              else if (w)
                if (w instanceof c) {
                  for (M = w.width, j = w.height, X = new Uint8ClampedArray(M * j), w.numComps = 1, w.fillGrayBuffer(X), B = 0, R = M * j; B < R; ++B)
                    X[B] = 255 - X[B];
                  (M !== x || j !== f) && (X = d(X, w.bpc, M, j, x, f));
                } else if (Array.isArray(w)) {
                  X = new Uint8ClampedArray(x * f);
                  const b = this.numComps;
                  for (B = 0, R = x * f; B < R; ++B) {
                    let l = 0;
                    const _ = B * b;
                    for (D = 0; D < b; ++D) {
                      const S = C[_ + D], A = D * 2;
                      if (S < w[A] || S > w[A + 1]) {
                        l = 255;
                        break;
                      }
                    }
                    X[B] = l;
                  }
                } else
                  throw new t.FormatError("Unknown mask format.");
              if (X)
                for (B = 0, D = 3, R = x * m; B < R; ++B, D += 4)
                  o[D] = X[B];
              else
                for (B = 0, D = 3, R = x * m; B < R; ++B, D += 4)
                  o[D] = 255;
            }
            undoPreblend(o, x, f) {
              const m = this.smask && this.smask.matte;
              if (!m)
                return;
              const C = this.colorSpace.getRgb(m, 0), p = C[0], w = C[1], X = C[2], M = x * f * 4;
              for (let j = 0; j < M; j += 4) {
                const B = o[j + 3];
                if (B === 0) {
                  o[j] = 255, o[j + 1] = 255, o[j + 2] = 255;
                  continue;
                }
                const R = 255 / B;
                o[j] = (o[j] - p) * R + p, o[j + 1] = (o[j + 1] - w) * R + w, o[j + 2] = (o[j + 2] - X) * R + X;
              }
            }
            createImageData(o = !1) {
              const x = this.drawWidth, f = this.drawHeight, m = {
                width: x,
                height: f,
                interpolate: this.interpolate,
                kind: 0,
                data: null
              }, C = this.numComps, p = this.width, w = this.height, X = this.bpc, M = p * C * X + 7 >> 3;
              if (!o) {
                let l;
                if (this.colorSpace.name === "DeviceGray" && X === 1 ? l = t.ImageKind.GRAYSCALE_1BPP : this.colorSpace.name === "DeviceRGB" && X === 8 && !this.needsDecode && (l = t.ImageKind.RGB_24BPP), l && !this.smask && !this.mask && x === p && f === w) {
                  if (m.kind = l, m.data = this.getImageBytes(w * M, {}), this.needsDecode) {
                    (0, t.assert)(l === t.ImageKind.GRAYSCALE_1BPP, "PDFImage.createImageData: The image must be grayscale.");
                    const _ = m.data;
                    for (let S = 0, A = _.length; S < A; S++)
                      _[S] ^= 255;
                  }
                  return m;
                }
                if (this.image instanceof y.JpegStream && !this.smask && !this.mask) {
                  let _ = w * M;
                  switch (this.colorSpace.name) {
                    case "DeviceGray":
                      _ *= 3;
                    case "DeviceRGB":
                    case "DeviceCMYK":
                      return m.kind = t.ImageKind.RGB_24BPP, m.data = this.getImageBytes(_, {
                        drawWidth: x,
                        drawHeight: f,
                        forceRGB: !0
                      }), m;
                  }
                }
              }
              const j = this.getImageBytes(w * M, {
                internal: !0
              }), B = 0 | j.length / M * f / w, R = this.getComponents(j);
              let D, b;
              return !o && !this.smask && !this.mask ? (m.kind = t.ImageKind.RGB_24BPP, m.data = new Uint8ClampedArray(x * f * 3), D = 0, b = !1) : (m.kind = t.ImageKind.RGBA_32BPP, m.data = new Uint8ClampedArray(x * f * 4), D = 1, b = !0, this.fillOpacity(m.data, x, f, B, R)), this.needsDecode && this.decodeBuffer(R), this.colorSpace.fillRgb(m.data, p, w, x, f, B, X, R, D), b && this.undoPreblend(m.data, x, B), m;
            }
            fillGrayBuffer(o) {
              const x = this.numComps;
              if (x !== 1)
                throw new t.FormatError(`Reading gray scale from a color image: ${x}`);
              const f = this.width, m = this.height, C = this.bpc, p = f * x * C + 7 >> 3, w = this.getImageBytes(m * p, {
                internal: !0
              }), X = this.getComponents(w);
              let M, j;
              if (C === 1) {
                if (j = f * m, this.needsDecode)
                  for (M = 0; M < j; ++M)
                    o[M] = X[M] - 1 & 255;
                else
                  for (M = 0; M < j; ++M)
                    o[M] = -X[M] & 255;
                return;
              }
              this.needsDecode && this.decodeBuffer(X), j = f * m;
              const B = 255 / ((1 << C) - 1);
              for (M = 0; M < j; ++M)
                o[M] = B * X[M];
            }
            getImageBytes(o, {
              drawWidth: x,
              drawHeight: f,
              forceRGB: m = !1,
              internal: C = !1
            }) {
              this.image.reset(), this.image.drawWidth = x || this.width, this.image.drawHeight = f || this.height, this.image.forceRGB = !!m;
              const p = this.image.getBytes(o);
              return C || this.image instanceof e.DecodeStream ? p : ((0, t.assert)(p instanceof Uint8Array, 'PDFImage.getImageBytes: Unsupported "imageBytes" type.'), new Uint8Array(p));
            }
          }
          u.PDFImage = c;
        },
        /* 64 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.applyMaskImageData = i;
          var t = P(2);
          function i({
            src: v,
            srcPos: a = 0,
            dest: e,
            destPos: y = 0,
            width: r,
            height: h,
            inverseDecode: g = !1
          }) {
            const d = t.FeatureTest.isLittleEndian ? 4278190080 : 255, [c, n] = g ? [0, d] : [d, 0], o = r >> 3, x = r & 7, f = v.length;
            e = new Uint32Array(e.buffer);
            for (let m = 0; m < h; m++) {
              for (const p = a + o; a < p; a++) {
                const w = a < f ? v[a] : 255;
                e[y++] = w & 128 ? n : c, e[y++] = w & 64 ? n : c, e[y++] = w & 32 ? n : c, e[y++] = w & 16 ? n : c, e[y++] = w & 8 ? n : c, e[y++] = w & 4 ? n : c, e[y++] = w & 2 ? n : c, e[y++] = w & 1 ? n : c;
              }
              if (x === 0)
                continue;
              const C = a < f ? v[a++] : 255;
              for (let p = 0; p < x; p++)
                e[y++] = C & 1 << 7 - p ? n : c;
            }
            return {
              srcPos: a,
              destPos: y
            };
          }
        },
        /* 65 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.incrementalUpdate = C, u.writeDict = h, u.writeObject = r;
          var t = P(2), i = P(5), v = P(6), a = P(66), e = P(7), y = P(67);
          function r(p, w, X, M) {
            X.push(`${p.num} ${p.gen} obj
`), w instanceof i.Dict ? h(w, X, M) : w instanceof e.BaseStream && g(w, X, M), X.push(`
endobj
`);
          }
          function h(p, w, X) {
            w.push("<<");
            for (const M of p.getKeys())
              w.push(` /${(0, v.escapePDFName)(M)} `), c(p.getRaw(M), w, X);
            w.push(">>");
          }
          function g(p, w, X) {
            h(p.dict, w, X), w.push(` stream
`);
            let M = p.getString();
            X !== null && (M = X.encryptString(M)), w.push(M, `
endstream
`);
          }
          function d(p, w, X) {
            w.push("[");
            let M = !0;
            for (const j of p)
              M ? M = !1 : w.push(" "), c(j, w, X);
            w.push("]");
          }
          function c(p, w, X) {
            p instanceof i.Name ? w.push(`/${(0, v.escapePDFName)(p.name)}`) : p instanceof i.Ref ? w.push(`${p.num} ${p.gen} R`) : Array.isArray(p) ? d(p, w, X) : typeof p == "string" ? (X !== null && (p = X.encryptString(p)), w.push(`(${(0, t.escapeString)(p)})`)) : typeof p == "number" ? w.push((0, v.numberToString)(p)) : typeof p == "boolean" ? w.push(p.toString()) : p instanceof i.Dict ? h(p, w, X) : p instanceof e.BaseStream ? g(p, w, X) : p === null ? w.push("null") : (0, t.warn)(`Unhandled value in writer: ${typeof p}, please file a bug.`);
          }
          function n(p, w, X, M) {
            for (let j = w + X - 1; j > X - 1; j--)
              M[j] = p & 255, p >>= 8;
            return X + w;
          }
          function o(p, w, X) {
            for (let M = 0, j = p.length; M < j; M++)
              X[w + M] = p.charCodeAt(M) & 255;
          }
          function x(p, w) {
            const X = Math.floor(Date.now() / 1e3), M = w.filename || "", j = [X.toString(), M, p.toString()];
            let B = j.reduce((b, l) => b + l.length, 0);
            for (const b of Object.values(w.info))
              j.push(b), B += b.length;
            const R = new Uint8Array(B);
            let D = 0;
            for (const b of j)
              o(b, D, R), D += b.length;
            return (0, t.bytesToString)((0, y.calculateMD5)(R));
          }
          function f(p, w) {
            const X = new a.SimpleXMLParser({
              hasAttributes: !0
            }).parseFromString(p);
            for (const {
              xfa: j
            } of w) {
              if (!j)
                continue;
              const {
                path: B,
                value: R
              } = j;
              if (!B)
                continue;
              const D = X.documentElement.searchNode((0, v.parseXFAPath)(B), 0);
              D ? Array.isArray(R) ? D.childNodes = R.map((b) => new a.SimpleDOMNode("value", b)) : D.childNodes = [new a.SimpleDOMNode("#text", R)] : (0, t.warn)(`Node not found for path: ${B}`);
            }
            const M = [];
            return X.documentElement.dump(M), M.join("");
          }
          function m({
            xfaData: p,
            xfaDatasetsRef: w,
            hasXfaDatasetsEntry: X,
            acroFormRef: M,
            acroForm: j,
            newRefs: B,
            xref: R,
            xrefInfo: D
          }) {
            if (R === null)
              return;
            if (!X) {
              if (!M) {
                (0, t.warn)("XFA - Cannot save it");
                return;
              }
              const _ = j.get("XFA"), S = _.slice();
              S.splice(2, 0, "datasets"), S.splice(3, 0, w), j.set("XFA", S);
              const A = R.encrypt;
              let F = null;
              A && (F = A.createCipherTransform(M.num, M.gen));
              const T = [`${M.num} ${M.gen} obj
`];
              h(j, T, F), T.push(`
`), j.set("XFA", _), B.push({
                ref: M,
                data: T.join("")
              });
            }
            if (p === null) {
              const _ = R.fetchIfRef(w);
              p = f(_.getString(), B);
            }
            const b = R.encrypt;
            b && (p = b.createCipherTransform(w.num, w.gen).encryptString(p));
            const l = `${w.num} ${w.gen} obj
<< /Type /EmbeddedFile /Length ${p.length}>>
stream
` + p + `
endstream
endobj
`;
            B.push({
              ref: w,
              data: l
            });
          }
          function C({
            originalData: p,
            xrefInfo: w,
            newRefs: X,
            xref: M = null,
            hasXfa: j = !1,
            xfaDatasetsRef: B = null,
            hasXfaDatasetsEntry: R = !1,
            acroFormRef: D = null,
            acroForm: b = null,
            xfaData: l = null
          }) {
            j && m({
              xfaData: l,
              xfaDatasetsRef: B,
              hasXfaDatasetsEntry: R,
              acroFormRef: D,
              acroForm: b,
              newRefs: X,
              xref: M,
              xrefInfo: w
            });
            const _ = new i.Dict(null), S = w.newRef;
            let A, F;
            const T = p.at(-1);
            T === 10 || T === 13 ? (A = [], F = p.length) : (A = [`
`], F = p.length + 1), _.set("Size", S.num + 1), _.set("Prev", w.startXRef), _.set("Type", i.Name.get("XRef")), w.rootRef !== null && _.set("Root", w.rootRef), w.infoRef !== null && _.set("Info", w.infoRef), w.encryptRef !== null && _.set("Encrypt", w.encryptRef), X.push({
              ref: S,
              data: ""
            }), X = X.sort((q, N) => q.ref.num - N.ref.num);
            const O = [[0, 1, 65535]], U = [0, 1];
            let G = 0;
            for (const {
              ref: q,
              data: N
            } of X)
              G = Math.max(G, F), O.push([1, F, Math.min(q.gen, 65535)]), F += N.length, U.push(q.num, 1), A.push(N);
            if (_.set("Index", U), Array.isArray(w.fileIds) && w.fileIds.length > 0) {
              const q = x(F, w);
              _.set("ID", [w.fileIds[0], q]);
            }
            const W = [1, Math.ceil(Math.log2(G) / 8), 2], V = (W[0] + W[1] + W[2]) * O.length;
            _.set("W", W), _.set("Length", V), A.push(`${S.num} ${S.gen} obj
`), h(_, A, null), A.push(` stream
`);
            const L = A.reduce((q, N) => q + N.length, 0), Y = `
endstream
endobj
startxref
${F}
%%EOF
`, J = new Uint8Array(p.length + L + V + Y.length);
            J.set(p);
            let ie = p.length;
            for (const q of A)
              o(q, ie, J), ie += q.length;
            for (const [q, N, Z] of O)
              ie = n(q, W[0], ie, J), ie = n(N, W[1], ie, J), ie = n(Z, W[2], ie, J);
            return o(Y, ie, J), J;
          }
        },
        /* 66 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.XMLParserErrorCode = u.XMLParserBase = u.SimpleXMLParser = u.SimpleDOMNode = void 0;
          var t = P(6);
          const i = {
            NoError: 0,
            EndOfDocument: -1,
            UnterminatedCdat: -2,
            UnterminatedXmlDeclaration: -3,
            UnterminatedDoctypeDeclaration: -4,
            UnterminatedComment: -5,
            MalformedElement: -6,
            OutOfMemory: -7,
            UnterminatedAttributeValue: -8,
            UnterminatedElement: -9,
            ElementNeverBegun: -10
          };
          u.XMLParserErrorCode = i;
          function v(h, g) {
            const d = h[g];
            return d === " " || d === `
` || d === "\r" || d === "	";
          }
          function a(h) {
            for (let g = 0, d = h.length; g < d; g++)
              if (!v(h, g))
                return !1;
            return !0;
          }
          class e {
            _resolveEntities(g) {
              return g.replace(/&([^;]+);/g, (d, c) => {
                if (c.substring(0, 2) === "#x")
                  return String.fromCodePoint(parseInt(c.substring(2), 16));
                if (c.substring(0, 1) === "#")
                  return String.fromCodePoint(parseInt(c.substring(1), 10));
                switch (c) {
                  case "lt":
                    return "<";
                  case "gt":
                    return ">";
                  case "amp":
                    return "&";
                  case "quot":
                    return '"';
                  case "apos":
                    return "'";
                }
                return this.onResolveEntity(c);
              });
            }
            _parseContent(g, d) {
              const c = [];
              let n = d;
              function o() {
                for (; n < g.length && v(g, n); )
                  ++n;
              }
              for (; n < g.length && !v(g, n) && g[n] !== ">" && g[n] !== "/"; )
                ++n;
              const x = g.substring(d, n);
              for (o(); n < g.length && g[n] !== ">" && g[n] !== "/" && g[n] !== "?"; ) {
                o();
                let f = "", m = "";
                for (; n < g.length && !v(g, n) && g[n] !== "="; )
                  f += g[n], ++n;
                if (o(), g[n] !== "=")
                  return null;
                ++n, o();
                const C = g[n];
                if (C !== '"' && C !== "'")
                  return null;
                const p = g.indexOf(C, ++n);
                if (p < 0)
                  return null;
                m = g.substring(n, p), c.push({
                  name: f,
                  value: this._resolveEntities(m)
                }), n = p + 1, o();
              }
              return {
                name: x,
                attributes: c,
                parsed: n - d
              };
            }
            _parseProcessingInstruction(g, d) {
              let c = d;
              function n() {
                for (; c < g.length && v(g, c); )
                  ++c;
              }
              for (; c < g.length && !v(g, c) && g[c] !== ">" && g[c] !== "?" && g[c] !== "/"; )
                ++c;
              const o = g.substring(d, c);
              n();
              const x = c;
              for (; c < g.length && (g[c] !== "?" || g[c + 1] !== ">"); )
                ++c;
              const f = g.substring(x, c);
              return {
                name: o,
                value: f,
                parsed: c - d
              };
            }
            parseXml(g) {
              let d = 0;
              for (; d < g.length; ) {
                const c = g[d];
                let n = d;
                if (c === "<") {
                  ++n;
                  const o = g[n];
                  let x;
                  switch (o) {
                    case "/":
                      if (++n, x = g.indexOf(">", n), x < 0) {
                        this.onError(i.UnterminatedElement);
                        return;
                      }
                      this.onEndElement(g.substring(n, x)), n = x + 1;
                      break;
                    case "?":
                      ++n;
                      const f = this._parseProcessingInstruction(g, n);
                      if (g.substring(n + f.parsed, n + f.parsed + 2) !== "?>") {
                        this.onError(i.UnterminatedXmlDeclaration);
                        return;
                      }
                      this.onPi(f.name, f.value), n += f.parsed + 2;
                      break;
                    case "!":
                      if (g.substring(n + 1, n + 3) === "--") {
                        if (x = g.indexOf("-->", n + 3), x < 0) {
                          this.onError(i.UnterminatedComment);
                          return;
                        }
                        this.onComment(g.substring(n + 3, x)), n = x + 3;
                      } else if (g.substring(n + 1, n + 8) === "[CDATA[") {
                        if (x = g.indexOf("]]>", n + 8), x < 0) {
                          this.onError(i.UnterminatedCdat);
                          return;
                        }
                        this.onCdata(g.substring(n + 8, x)), n = x + 3;
                      } else if (g.substring(n + 1, n + 8) === "DOCTYPE") {
                        const p = g.indexOf("[", n + 8);
                        let w = !1;
                        if (x = g.indexOf(">", n + 8), x < 0) {
                          this.onError(i.UnterminatedDoctypeDeclaration);
                          return;
                        }
                        if (p > 0 && x > p) {
                          if (x = g.indexOf("]>", n + 8), x < 0) {
                            this.onError(i.UnterminatedDoctypeDeclaration);
                            return;
                          }
                          w = !0;
                        }
                        const X = g.substring(n + 8, x + (w ? 1 : 0));
                        this.onDoctype(X), n = x + (w ? 2 : 1);
                      } else {
                        this.onError(i.MalformedElement);
                        return;
                      }
                      break;
                    default:
                      const m = this._parseContent(g, n);
                      if (m === null) {
                        this.onError(i.MalformedElement);
                        return;
                      }
                      let C = !1;
                      if (g.substring(n + m.parsed, n + m.parsed + 2) === "/>")
                        C = !0;
                      else if (g.substring(n + m.parsed, n + m.parsed + 1) !== ">") {
                        this.onError(i.UnterminatedElement);
                        return;
                      }
                      this.onBeginElement(m.name, m.attributes, C), n += m.parsed + (C ? 2 : 1);
                      break;
                  }
                } else {
                  for (; n < g.length && g[n] !== "<"; )
                    n++;
                  const o = g.substring(d, n);
                  this.onText(this._resolveEntities(o));
                }
                d = n;
              }
            }
            onResolveEntity(g) {
              return `&${g};`;
            }
            onPi(g, d) {
            }
            onComment(g) {
            }
            onCdata(g) {
            }
            onDoctype(g) {
            }
            onText(g) {
            }
            onBeginElement(g, d, c) {
            }
            onEndElement(g) {
            }
            onError(g) {
            }
          }
          u.XMLParserBase = e;
          class y {
            constructor(g, d) {
              this.nodeName = g, this.nodeValue = d, Object.defineProperty(this, "parentNode", {
                value: null,
                writable: !0
              });
            }
            get firstChild() {
              return this.childNodes && this.childNodes[0];
            }
            get nextSibling() {
              const g = this.parentNode.childNodes;
              if (!g)
                return;
              const d = g.indexOf(this);
              if (d !== -1)
                return g[d + 1];
            }
            get textContent() {
              return this.childNodes ? this.childNodes.map(function(g) {
                return g.textContent;
              }).join("") : this.nodeValue || "";
            }
            get children() {
              return this.childNodes || [];
            }
            hasChildNodes() {
              return this.childNodes && this.childNodes.length > 0;
            }
            searchNode(g, d) {
              if (d >= g.length)
                return this;
              const c = g[d], n = [];
              let o = this;
              for (; ; ) {
                if (c.name === o.nodeName)
                  if (c.pos === 0) {
                    const x = o.searchNode(g, d + 1);
                    if (x !== null)
                      return x;
                  } else {
                    if (n.length === 0)
                      return null;
                    {
                      const [x] = n.pop();
                      let f = 0;
                      for (const m of x.childNodes)
                        if (c.name === m.nodeName) {
                          if (f === c.pos)
                            return m.searchNode(g, d + 1);
                          f++;
                        }
                      return o.searchNode(g, d + 1);
                    }
                  }
                if (o.childNodes && o.childNodes.length !== 0)
                  n.push([o, 0]), o = o.childNodes[0];
                else {
                  if (n.length === 0)
                    return null;
                  for (; n.length !== 0; ) {
                    const [x, f] = n.pop(), m = f + 1;
                    if (m < x.childNodes.length) {
                      n.push([x, m]), o = x.childNodes[m];
                      break;
                    }
                  }
                  if (n.length === 0)
                    return null;
                }
              }
            }
            dump(g) {
              if (this.nodeName === "#text") {
                g.push((0, t.encodeToXmlString)(this.nodeValue));
                return;
              }
              if (g.push(`<${this.nodeName}`), this.attributes)
                for (const d of this.attributes)
                  g.push(` ${d.name}="${(0, t.encodeToXmlString)(d.value)}"`);
              if (this.hasChildNodes()) {
                g.push(">");
                for (const d of this.childNodes)
                  d.dump(g);
                g.push(`</${this.nodeName}>`);
              } else
                this.nodeValue ? g.push(`>${(0, t.encodeToXmlString)(this.nodeValue)}</${this.nodeName}>`) : g.push("/>");
            }
          }
          u.SimpleDOMNode = y;
          class r extends e {
            constructor({
              hasAttributes: g = !1,
              lowerCaseName: d = !1
            }) {
              super(), this._currentFragment = null, this._stack = null, this._errorCode = i.NoError, this._hasAttributes = g, this._lowerCaseName = d;
            }
            parseFromString(g) {
              if (this._currentFragment = [], this._stack = [], this._errorCode = i.NoError, this.parseXml(g), this._errorCode !== i.NoError)
                return;
              const [d] = this._currentFragment;
              if (d)
                return {
                  documentElement: d
                };
            }
            onText(g) {
              if (a(g))
                return;
              const d = new y("#text", g);
              this._currentFragment.push(d);
            }
            onCdata(g) {
              const d = new y("#text", g);
              this._currentFragment.push(d);
            }
            onBeginElement(g, d, c) {
              this._lowerCaseName && (g = g.toLowerCase());
              const n = new y(g);
              n.childNodes = [], this._hasAttributes && (n.attributes = d), this._currentFragment.push(n), !c && (this._stack.push(this._currentFragment), this._currentFragment = n.childNodes);
            }
            onEndElement(g) {
              this._currentFragment = this._stack.pop() || [];
              const d = this._currentFragment.at(-1);
              if (!d)
                return null;
              for (let c = 0, n = d.childNodes.length; c < n; c++)
                d.childNodes[c].parentNode = d;
              return d;
            }
            onError(g) {
              this._errorCode = g;
            }
          }
          u.SimpleXMLParser = r;
        },
        /* 67 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.calculateSHA256 = u.calculateMD5 = u.PDF20 = u.PDF17 = u.CipherTransformFactory = u.ARCFourCipher = u.AES256Cipher = u.AES128Cipher = void 0, u.calculateSHA384 = g, u.calculateSHA512 = void 0;
          var t = P(2), i = P(5), v = P(68);
          class a {
            constructor(w) {
              this.a = 0, this.b = 0;
              const X = new Uint8Array(256), M = w.length;
              for (let j = 0; j < 256; ++j)
                X[j] = j;
              for (let j = 0, B = 0; j < 256; ++j) {
                const R = X[j];
                B = B + R + w[j % M] & 255, X[j] = X[B], X[B] = R;
              }
              this.s = X;
            }
            encryptBlock(w) {
              let X = this.a, M = this.b;
              const j = this.s, B = w.length, R = new Uint8Array(B);
              for (let D = 0; D < B; ++D) {
                X = X + 1 & 255;
                const b = j[X];
                M = M + b & 255;
                const l = j[M];
                j[X] = l, j[M] = b, R[D] = w[D] ^ j[b + l & 255];
              }
              return this.a = X, this.b = M, R;
            }
            decryptBlock(w) {
              return this.encryptBlock(w);
            }
            encrypt(w) {
              return this.encryptBlock(w);
            }
          }
          u.ARCFourCipher = a;
          const e = function() {
            const w = new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]), X = new Int32Array([-680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341, -45705983, 1770035416, -1958414417, -42063, -1990404162, 1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632, 643717713, -373897302, -701558691, 38016083, -660478335, -405537848, 568446438, -1019803690, -187363961, 1163531501, -1444681467, -51403784, 1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556, -1530992060, 1272893353, -155497632, -1094730640, 681279174, -358537222, -722521979, 76029189, -640364487, -421815835, 530742520, -995338651, -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606, -1051523, -2054922799, 1873313359, -30611744, -1560198380, 1309151649, -145523070, -1120210379, 718787259, -343485551]);
            function M(j, B, R) {
              let D = 1732584193, b = -271733879, l = -1732584194, _ = 271733878;
              const S = R + 72 & -64, A = new Uint8Array(S);
              let F, T;
              for (F = 0; F < R; ++F)
                A[F] = j[B++];
              A[F++] = 128;
              const O = S - 8;
              for (; F < O; )
                A[F++] = 0;
              A[F++] = R << 3 & 255, A[F++] = R >> 5 & 255, A[F++] = R >> 13 & 255, A[F++] = R >> 21 & 255, A[F++] = R >>> 29 & 255, A[F++] = 0, A[F++] = 0, A[F++] = 0;
              const U = new Int32Array(16);
              for (F = 0; F < S; ) {
                for (T = 0; T < 16; ++T, F += 4)
                  U[T] = A[F] | A[F + 1] << 8 | A[F + 2] << 16 | A[F + 3] << 24;
                let G = D, K = b, W = l, z = _, V, L;
                for (T = 0; T < 64; ++T) {
                  T < 16 ? (V = K & W | ~K & z, L = T) : T < 32 ? (V = z & K | ~z & W, L = 5 * T + 1 & 15) : T < 48 ? (V = K ^ W ^ z, L = 3 * T + 5 & 15) : (V = W ^ (K | ~z), L = 7 * T & 15);
                  const Y = z, J = G + V + X[T] + U[L] | 0, ie = w[T];
                  z = W, W = K, K = K + (J << ie | J >>> 32 - ie) | 0, G = Y;
                }
                D = D + G | 0, b = b + K | 0, l = l + W | 0, _ = _ + z | 0;
              }
              return new Uint8Array([D & 255, D >> 8 & 255, D >> 16 & 255, D >>> 24 & 255, b & 255, b >> 8 & 255, b >> 16 & 255, b >>> 24 & 255, l & 255, l >> 8 & 255, l >> 16 & 255, l >>> 24 & 255, _ & 255, _ >> 8 & 255, _ >> 16 & 255, _ >>> 24 & 255]);
            }
            return M;
          }();
          u.calculateMD5 = e;
          class y {
            constructor(w, X) {
              this.high = w | 0, this.low = X | 0;
            }
            and(w) {
              this.high &= w.high, this.low &= w.low;
            }
            xor(w) {
              this.high ^= w.high, this.low ^= w.low;
            }
            or(w) {
              this.high |= w.high, this.low |= w.low;
            }
            shiftRight(w) {
              w >= 32 ? (this.low = this.high >>> w - 32 | 0, this.high = 0) : (this.low = this.low >>> w | this.high << 32 - w, this.high = this.high >>> w | 0);
            }
            shiftLeft(w) {
              w >= 32 ? (this.high = this.low << w - 32, this.low = 0) : (this.high = this.high << w | this.low >>> 32 - w, this.low <<= w);
            }
            rotateRight(w) {
              let X, M;
              w & 32 ? (M = this.low, X = this.high) : (X = this.low, M = this.high), w &= 31, this.low = X >>> w | M << 32 - w, this.high = M >>> w | X << 32 - w;
            }
            not() {
              this.high = ~this.high, this.low = ~this.low;
            }
            add(w) {
              const X = (this.low >>> 0) + (w.low >>> 0);
              let M = (this.high >>> 0) + (w.high >>> 0);
              X > 4294967295 && (M += 1), this.low = X | 0, this.high = M | 0;
            }
            copyTo(w, X) {
              w[X] = this.high >>> 24 & 255, w[X + 1] = this.high >> 16 & 255, w[X + 2] = this.high >> 8 & 255, w[X + 3] = this.high & 255, w[X + 4] = this.low >>> 24 & 255, w[X + 5] = this.low >> 16 & 255, w[X + 6] = this.low >> 8 & 255, w[X + 7] = this.low & 255;
            }
            assign(w) {
              this.high = w.high, this.low = w.low;
            }
          }
          const r = function() {
            function w(_, S) {
              return _ >>> S | _ << 32 - S;
            }
            function X(_, S, A) {
              return _ & S ^ ~_ & A;
            }
            function M(_, S, A) {
              return _ & S ^ _ & A ^ S & A;
            }
            function j(_) {
              return w(_, 2) ^ w(_, 13) ^ w(_, 22);
            }
            function B(_) {
              return w(_, 6) ^ w(_, 11) ^ w(_, 25);
            }
            function R(_) {
              return w(_, 7) ^ w(_, 18) ^ _ >>> 3;
            }
            function D(_) {
              return w(_, 17) ^ w(_, 19) ^ _ >>> 10;
            }
            const b = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
            function l(_, S, A) {
              let F = 1779033703, T = 3144134277, O = 1013904242, U = 2773480762, G = 1359893119, K = 2600822924, W = 528734635, z = 1541459225;
              const V = Math.ceil((A + 9) / 64) * 64, L = new Uint8Array(V);
              let Y, J;
              for (Y = 0; Y < A; ++Y)
                L[Y] = _[S++];
              L[Y++] = 128;
              const ie = V - 8;
              for (; Y < ie; )
                L[Y++] = 0;
              L[Y++] = 0, L[Y++] = 0, L[Y++] = 0, L[Y++] = A >>> 29 & 255, L[Y++] = A >> 21 & 255, L[Y++] = A >> 13 & 255, L[Y++] = A >> 5 & 255, L[Y++] = A << 3 & 255;
              const q = new Uint32Array(64);
              for (Y = 0; Y < V; ) {
                for (J = 0; J < 16; ++J)
                  q[J] = L[Y] << 24 | L[Y + 1] << 16 | L[Y + 2] << 8 | L[Y + 3], Y += 4;
                for (J = 16; J < 64; ++J)
                  q[J] = D(q[J - 2]) + q[J - 7] + R(q[J - 15]) + q[J - 16] | 0;
                let N = F, Z = T, E = O, te = U, re = G, ee = K, $ = W, k = z, H, ne;
                for (J = 0; J < 64; ++J)
                  H = k + B(re) + X(re, ee, $) + b[J] + q[J], ne = j(N) + M(N, Z, E), k = $, $ = ee, ee = re, re = te + H | 0, te = E, E = Z, Z = N, N = H + ne | 0;
                F = F + N | 0, T = T + Z | 0, O = O + E | 0, U = U + te | 0, G = G + re | 0, K = K + ee | 0, W = W + $ | 0, z = z + k | 0;
              }
              return new Uint8Array([F >> 24 & 255, F >> 16 & 255, F >> 8 & 255, F & 255, T >> 24 & 255, T >> 16 & 255, T >> 8 & 255, T & 255, O >> 24 & 255, O >> 16 & 255, O >> 8 & 255, O & 255, U >> 24 & 255, U >> 16 & 255, U >> 8 & 255, U & 255, G >> 24 & 255, G >> 16 & 255, G >> 8 & 255, G & 255, K >> 24 & 255, K >> 16 & 255, K >> 8 & 255, K & 255, W >> 24 & 255, W >> 16 & 255, W >> 8 & 255, W & 255, z >> 24 & 255, z >> 16 & 255, z >> 8 & 255, z & 255]);
            }
            return l;
          }();
          u.calculateSHA256 = r;
          const h = function() {
            function w(l, _, S, A, F) {
              l.assign(_), l.and(S), F.assign(_), F.not(), F.and(A), l.xor(F);
            }
            function X(l, _, S, A, F) {
              l.assign(_), l.and(S), F.assign(_), F.and(A), l.xor(F), F.assign(S), F.and(A), l.xor(F);
            }
            function M(l, _, S) {
              l.assign(_), l.rotateRight(28), S.assign(_), S.rotateRight(34), l.xor(S), S.assign(_), S.rotateRight(39), l.xor(S);
            }
            function j(l, _, S) {
              l.assign(_), l.rotateRight(14), S.assign(_), S.rotateRight(18), l.xor(S), S.assign(_), S.rotateRight(41), l.xor(S);
            }
            function B(l, _, S) {
              l.assign(_), l.rotateRight(1), S.assign(_), S.rotateRight(8), l.xor(S), S.assign(_), S.shiftRight(7), l.xor(S);
            }
            function R(l, _, S) {
              l.assign(_), l.rotateRight(19), S.assign(_), S.rotateRight(61), l.xor(S), S.assign(_), S.shiftRight(6), l.xor(S);
            }
            const D = [new y(1116352408, 3609767458), new y(1899447441, 602891725), new y(3049323471, 3964484399), new y(3921009573, 2173295548), new y(961987163, 4081628472), new y(1508970993, 3053834265), new y(2453635748, 2937671579), new y(2870763221, 3664609560), new y(3624381080, 2734883394), new y(310598401, 1164996542), new y(607225278, 1323610764), new y(1426881987, 3590304994), new y(1925078388, 4068182383), new y(2162078206, 991336113), new y(2614888103, 633803317), new y(3248222580, 3479774868), new y(3835390401, 2666613458), new y(4022224774, 944711139), new y(264347078, 2341262773), new y(604807628, 2007800933), new y(770255983, 1495990901), new y(1249150122, 1856431235), new y(1555081692, 3175218132), new y(1996064986, 2198950837), new y(2554220882, 3999719339), new y(2821834349, 766784016), new y(2952996808, 2566594879), new y(3210313671, 3203337956), new y(3336571891, 1034457026), new y(3584528711, 2466948901), new y(113926993, 3758326383), new y(338241895, 168717936), new y(666307205, 1188179964), new y(773529912, 1546045734), new y(1294757372, 1522805485), new y(1396182291, 2643833823), new y(1695183700, 2343527390), new y(1986661051, 1014477480), new y(2177026350, 1206759142), new y(2456956037, 344077627), new y(2730485921, 1290863460), new y(2820302411, 3158454273), new y(3259730800, 3505952657), new y(3345764771, 106217008), new y(3516065817, 3606008344), new y(3600352804, 1432725776), new y(4094571909, 1467031594), new y(275423344, 851169720), new y(430227734, 3100823752), new y(506948616, 1363258195), new y(659060556, 3750685593), new y(883997877, 3785050280), new y(958139571, 3318307427), new y(1322822218, 3812723403), new y(1537002063, 2003034995), new y(1747873779, 3602036899), new y(1955562222, 1575990012), new y(2024104815, 1125592928), new y(2227730452, 2716904306), new y(2361852424, 442776044), new y(2428436474, 593698344), new y(2756734187, 3733110249), new y(3204031479, 2999351573), new y(3329325298, 3815920427), new y(3391569614, 3928383900), new y(3515267271, 566280711), new y(3940187606, 3454069534), new y(4118630271, 4000239992), new y(116418474, 1914138554), new y(174292421, 2731055270), new y(289380356, 3203993006), new y(460393269, 320620315), new y(685471733, 587496836), new y(852142971, 1086792851), new y(1017036298, 365543100), new y(1126000580, 2618297676), new y(1288033470, 3409855158), new y(1501505948, 4234509866), new y(1607167915, 987167468), new y(1816402316, 1246189591)];
            function b(l, _, S, A = !1) {
              let F, T, O, U, G, K, W, z;
              A ? (F = new y(3418070365, 3238371032), T = new y(1654270250, 914150663), O = new y(2438529370, 812702999), U = new y(355462360, 4144912697), G = new y(1731405415, 4290775857), K = new y(2394180231, 1750603025), W = new y(3675008525, 1694076839), z = new y(1203062813, 3204075428)) : (F = new y(1779033703, 4089235720), T = new y(3144134277, 2227873595), O = new y(1013904242, 4271175723), U = new y(2773480762, 1595750129), G = new y(1359893119, 2917565137), K = new y(2600822924, 725511199), W = new y(528734635, 4215389547), z = new y(1541459225, 327033209));
              const V = Math.ceil((S + 17) / 128) * 128, L = new Uint8Array(V);
              let Y, J;
              for (Y = 0; Y < S; ++Y)
                L[Y] = l[_++];
              L[Y++] = 128;
              const ie = V - 16;
              for (; Y < ie; )
                L[Y++] = 0;
              L[Y++] = 0, L[Y++] = 0, L[Y++] = 0, L[Y++] = 0, L[Y++] = 0, L[Y++] = 0, L[Y++] = 0, L[Y++] = 0, L[Y++] = 0, L[Y++] = 0, L[Y++] = 0, L[Y++] = S >>> 29 & 255, L[Y++] = S >> 21 & 255, L[Y++] = S >> 13 & 255, L[Y++] = S >> 5 & 255, L[Y++] = S << 3 & 255;
              const q = new Array(80);
              for (Y = 0; Y < 80; Y++)
                q[Y] = new y(0, 0);
              let N = new y(0, 0), Z = new y(0, 0), E = new y(0, 0), te = new y(0, 0), re = new y(0, 0), ee = new y(0, 0), $ = new y(0, 0), k = new y(0, 0);
              const H = new y(0, 0), ne = new y(0, 0), ae = new y(0, 0), he = new y(0, 0);
              let ue;
              for (Y = 0; Y < V; ) {
                for (J = 0; J < 16; ++J)
                  q[J].high = L[Y] << 24 | L[Y + 1] << 16 | L[Y + 2] << 8 | L[Y + 3], q[J].low = L[Y + 4] << 24 | L[Y + 5] << 16 | L[Y + 6] << 8 | L[Y + 7], Y += 8;
                for (J = 16; J < 80; ++J)
                  ue = q[J], R(ue, q[J - 2], he), ue.add(q[J - 7]), B(ae, q[J - 15], he), ue.add(ae), ue.add(q[J - 16]);
                for (N.assign(F), Z.assign(T), E.assign(O), te.assign(U), re.assign(G), ee.assign(K), $.assign(W), k.assign(z), J = 0; J < 80; ++J)
                  H.assign(k), j(ae, re, he), H.add(ae), w(ae, re, ee, $, he), H.add(ae), H.add(D[J]), H.add(q[J]), M(ne, N, he), X(ae, N, Z, E, he), ne.add(ae), ue = k, k = $, $ = ee, ee = re, te.add(H), re = te, te = E, E = Z, Z = N, ue.assign(H), ue.add(ne), N = ue;
                F.add(N), T.add(Z), O.add(E), U.add(te), G.add(re), K.add(ee), W.add($), z.add(k);
              }
              let fe;
              return A ? (fe = new Uint8Array(48), F.copyTo(fe, 0), T.copyTo(fe, 8), O.copyTo(fe, 16), U.copyTo(fe, 24), G.copyTo(fe, 32), K.copyTo(fe, 40)) : (fe = new Uint8Array(64), F.copyTo(fe, 0), T.copyTo(fe, 8), O.copyTo(fe, 16), U.copyTo(fe, 24), G.copyTo(fe, 32), K.copyTo(fe, 40), W.copyTo(fe, 48), z.copyTo(fe, 56)), fe;
            }
            return b;
          }();
          u.calculateSHA512 = h;
          function g(p, w, X) {
            return h(p, w, X, !0);
          }
          class d {
            decryptBlock(w) {
              return w;
            }
            encrypt(w) {
              return w;
            }
          }
          class c {
            constructor() {
              this.constructor === c && (0, t.unreachable)("Cannot initialize AESBaseCipher."), this._s = new Uint8Array([99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22]), this._inv_s = new Uint8Array([82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125]), this._mix = new Uint32Array([0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795]), this._mixCol = new Uint8Array(256);
              for (let w = 0; w < 256; w++)
                w < 128 ? this._mixCol[w] = w << 1 : this._mixCol[w] = w << 1 ^ 27;
              this.buffer = new Uint8Array(16), this.bufferPosition = 0;
            }
            _expandKey(w) {
              (0, t.unreachable)("Cannot call `_expandKey` on the base class");
            }
            _decrypt(w, X) {
              let M, j, B;
              const R = new Uint8Array(16);
              R.set(w);
              for (let D = 0, b = this._keySize; D < 16; ++D, ++b)
                R[D] ^= X[b];
              for (let D = this._cyclesOfRepetition - 1; D >= 1; --D) {
                M = R[13], R[13] = R[9], R[9] = R[5], R[5] = R[1], R[1] = M, M = R[14], j = R[10], R[14] = R[6], R[10] = R[2], R[6] = M, R[2] = j, M = R[15], j = R[11], B = R[7], R[15] = R[3], R[11] = M, R[7] = j, R[3] = B;
                for (let b = 0; b < 16; ++b)
                  R[b] = this._inv_s[R[b]];
                for (let b = 0, l = D * 16; b < 16; ++b, ++l)
                  R[b] ^= X[l];
                for (let b = 0; b < 16; b += 4) {
                  const l = this._mix[R[b]], _ = this._mix[R[b + 1]], S = this._mix[R[b + 2]], A = this._mix[R[b + 3]];
                  M = l ^ _ >>> 8 ^ _ << 24 ^ S >>> 16 ^ S << 16 ^ A >>> 24 ^ A << 8, R[b] = M >>> 24 & 255, R[b + 1] = M >> 16 & 255, R[b + 2] = M >> 8 & 255, R[b + 3] = M & 255;
                }
              }
              M = R[13], R[13] = R[9], R[9] = R[5], R[5] = R[1], R[1] = M, M = R[14], j = R[10], R[14] = R[6], R[10] = R[2], R[6] = M, R[2] = j, M = R[15], j = R[11], B = R[7], R[15] = R[3], R[11] = M, R[7] = j, R[3] = B;
              for (let D = 0; D < 16; ++D)
                R[D] = this._inv_s[R[D]], R[D] ^= X[D];
              return R;
            }
            _encrypt(w, X) {
              const M = this._s;
              let j, B, R;
              const D = new Uint8Array(16);
              D.set(w);
              for (let b = 0; b < 16; ++b)
                D[b] ^= X[b];
              for (let b = 1; b < this._cyclesOfRepetition; b++) {
                for (let l = 0; l < 16; ++l)
                  D[l] = M[D[l]];
                R = D[1], D[1] = D[5], D[5] = D[9], D[9] = D[13], D[13] = R, R = D[2], B = D[6], D[2] = D[10], D[6] = D[14], D[10] = R, D[14] = B, R = D[3], B = D[7], j = D[11], D[3] = D[15], D[7] = R, D[11] = B, D[15] = j;
                for (let l = 0; l < 16; l += 4) {
                  const _ = D[l + 0], S = D[l + 1], A = D[l + 2], F = D[l + 3];
                  j = _ ^ S ^ A ^ F, D[l + 0] ^= j ^ this._mixCol[_ ^ S], D[l + 1] ^= j ^ this._mixCol[S ^ A], D[l + 2] ^= j ^ this._mixCol[A ^ F], D[l + 3] ^= j ^ this._mixCol[F ^ _];
                }
                for (let l = 0, _ = b * 16; l < 16; ++l, ++_)
                  D[l] ^= X[_];
              }
              for (let b = 0; b < 16; ++b)
                D[b] = M[D[b]];
              R = D[1], D[1] = D[5], D[5] = D[9], D[9] = D[13], D[13] = R, R = D[2], B = D[6], D[2] = D[10], D[6] = D[14], D[10] = R, D[14] = B, R = D[3], B = D[7], j = D[11], D[3] = D[15], D[7] = R, D[11] = B, D[15] = j;
              for (let b = 0, l = this._keySize; b < 16; ++b, ++l)
                D[b] ^= X[l];
              return D;
            }
            _decryptBlock2(w, X) {
              const M = w.length;
              let j = this.buffer, B = this.bufferPosition;
              const R = [];
              let D = this.iv;
              for (let _ = 0; _ < M; ++_) {
                if (j[B] = w[_], ++B, B < 16)
                  continue;
                const S = this._decrypt(j, this._key);
                for (let A = 0; A < 16; ++A)
                  S[A] ^= D[A];
                D = j, R.push(S), j = new Uint8Array(16), B = 0;
              }
              if (this.buffer = j, this.bufferLength = B, this.iv = D, R.length === 0)
                return new Uint8Array(0);
              let b = 16 * R.length;
              if (X) {
                const _ = R.at(-1);
                let S = _[15];
                if (S <= 16) {
                  for (let A = 15, F = 16 - S; A >= F; --A)
                    if (_[A] !== S) {
                      S = 0;
                      break;
                    }
                  b -= S, R[R.length - 1] = _.subarray(0, 16 - S);
                }
              }
              const l = new Uint8Array(b);
              for (let _ = 0, S = 0, A = R.length; _ < A; ++_, S += 16)
                l.set(R[_], S);
              return l;
            }
            decryptBlock(w, X, M = null) {
              const j = w.length, B = this.buffer;
              let R = this.bufferPosition;
              if (M)
                this.iv = M;
              else {
                for (let D = 0; R < 16 && D < j; ++D, ++R)
                  B[R] = w[D];
                if (R < 16)
                  return this.bufferLength = R, new Uint8Array(0);
                this.iv = B, w = w.subarray(16);
              }
              return this.buffer = new Uint8Array(16), this.bufferLength = 0, this.decryptBlock = this._decryptBlock2, this.decryptBlock(w, X);
            }
            encrypt(w, X) {
              const M = w.length;
              let j = this.buffer, B = this.bufferPosition;
              const R = [];
              X || (X = new Uint8Array(16));
              for (let l = 0; l < M; ++l) {
                if (j[B] = w[l], ++B, B < 16)
                  continue;
                for (let S = 0; S < 16; ++S)
                  j[S] ^= X[S];
                const _ = this._encrypt(j, this._key);
                X = _, R.push(_), j = new Uint8Array(16), B = 0;
              }
              if (this.buffer = j, this.bufferLength = B, this.iv = X, R.length === 0)
                return new Uint8Array(0);
              const D = 16 * R.length, b = new Uint8Array(D);
              for (let l = 0, _ = 0, S = R.length; l < S; ++l, _ += 16)
                b.set(R[l], _);
              return b;
            }
          }
          class n extends c {
            constructor(w) {
              super(), this._cyclesOfRepetition = 10, this._keySize = 160, this._rcon = new Uint8Array([141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141]), this._key = this._expandKey(w);
            }
            _expandKey(w) {
              const M = this._s, j = this._rcon, B = new Uint8Array(176);
              B.set(w);
              for (let R = 16, D = 1; R < 176; ++D) {
                let b = B[R - 3], l = B[R - 2], _ = B[R - 1], S = B[R - 4];
                b = M[b], l = M[l], _ = M[_], S = M[S], b ^= j[D];
                for (let A = 0; A < 4; ++A)
                  B[R] = b ^= B[R - 16], R++, B[R] = l ^= B[R - 16], R++, B[R] = _ ^= B[R - 16], R++, B[R] = S ^= B[R - 16], R++;
              }
              return B;
            }
          }
          u.AES128Cipher = n;
          class o extends c {
            constructor(w) {
              super(), this._cyclesOfRepetition = 14, this._keySize = 224, this._key = this._expandKey(w);
            }
            _expandKey(w) {
              const M = this._s, j = new Uint8Array(240);
              j.set(w);
              let B = 1, R, D, b, l;
              for (let _ = 32, S = 1; _ < 240; ++S) {
                _ % 32 === 16 ? (R = M[R], D = M[D], b = M[b], l = M[l]) : _ % 32 === 0 && (R = j[_ - 3], D = j[_ - 2], b = j[_ - 1], l = j[_ - 4], R = M[R], D = M[D], b = M[b], l = M[l], R ^= B, (B <<= 1) >= 256 && (B = (B ^ 27) & 255));
                for (let A = 0; A < 4; ++A)
                  j[_] = R ^= j[_ - 32], _++, j[_] = D ^= j[_ - 32], _++, j[_] = b ^= j[_ - 32], _++, j[_] = l ^= j[_ - 32], _++;
              }
              return j;
            }
          }
          u.AES256Cipher = o;
          class x {
            checkOwnerPassword(w, X, M, j) {
              const B = new Uint8Array(w.length + 56);
              B.set(w, 0), B.set(X, w.length), B.set(M, w.length + X.length);
              const R = r(B, 0, B.length);
              return (0, t.isArrayEqual)(R, j);
            }
            checkUserPassword(w, X, M) {
              const j = new Uint8Array(w.length + 8);
              j.set(w, 0), j.set(X, w.length);
              const B = r(j, 0, j.length);
              return (0, t.isArrayEqual)(B, M);
            }
            getOwnerKey(w, X, M, j) {
              const B = new Uint8Array(w.length + 56);
              B.set(w, 0), B.set(X, w.length), B.set(M, w.length + X.length);
              const R = r(B, 0, B.length);
              return new o(R).decryptBlock(j, !1, new Uint8Array(16));
            }
            getUserKey(w, X, M) {
              const j = new Uint8Array(w.length + 8);
              j.set(w, 0), j.set(X, w.length);
              const B = r(j, 0, j.length);
              return new o(B).decryptBlock(M, !1, new Uint8Array(16));
            }
          }
          u.PDF17 = x;
          const f = function() {
            function w(M, j, B) {
              let R = r(j, 0, j.length).subarray(0, 32), D = [0], b = 0;
              for (; b < 64 || D.at(-1) > b - 32; ) {
                const l = M.length + R.length + B.length, _ = new Uint8Array(l);
                let S = 0;
                _.set(M, S), S += M.length, _.set(R, S), S += R.length, _.set(B, S);
                const A = new Uint8Array(l * 64);
                for (let O = 0, U = 0; O < 64; O++, U += l)
                  A.set(_, U);
                D = new n(R.subarray(0, 16)).encrypt(A, R.subarray(16, 32));
                let T = 0;
                for (let O = 0; O < 16; O++)
                  T *= 256 % 3, T %= 3, T += (D[O] >>> 0) % 3, T %= 3;
                T === 0 ? R = r(D, 0, D.length) : T === 1 ? R = g(D, 0, D.length) : T === 2 && (R = h(D, 0, D.length)), b++;
              }
              return R.subarray(0, 32);
            }
            class X {
              hash(j, B, R) {
                return w(j, B, R);
              }
              checkOwnerPassword(j, B, R, D) {
                const b = new Uint8Array(j.length + 56);
                b.set(j, 0), b.set(B, j.length), b.set(R, j.length + B.length);
                const l = w(j, b, R);
                return (0, t.isArrayEqual)(l, D);
              }
              checkUserPassword(j, B, R) {
                const D = new Uint8Array(j.length + 8);
                D.set(j, 0), D.set(B, j.length);
                const b = w(j, D, []);
                return (0, t.isArrayEqual)(b, R);
              }
              getOwnerKey(j, B, R, D) {
                const b = new Uint8Array(j.length + 56);
                b.set(j, 0), b.set(B, j.length), b.set(R, j.length + B.length);
                const l = w(j, b, R);
                return new o(l).decryptBlock(D, !1, new Uint8Array(16));
              }
              getUserKey(j, B, R) {
                const D = new Uint8Array(j.length + 8);
                D.set(j, 0), D.set(B, j.length);
                const b = w(j, D, []);
                return new o(b).decryptBlock(R, !1, new Uint8Array(16));
              }
            }
            return X;
          }();
          u.PDF20 = f;
          class m {
            constructor(w, X) {
              this.StringCipherConstructor = w, this.StreamCipherConstructor = X;
            }
            createStream(w, X) {
              const M = new this.StreamCipherConstructor();
              return new v.DecryptStream(w, X, function(B, R) {
                return M.decryptBlock(B, R);
              });
            }
            decryptString(w) {
              const X = new this.StringCipherConstructor();
              let M = (0, t.stringToBytes)(w);
              return M = X.decryptBlock(M, !0), (0, t.bytesToString)(M);
            }
            encryptString(w) {
              const X = new this.StringCipherConstructor();
              if (X instanceof c) {
                const B = 16 - w.length % 16;
                w += String.fromCharCode(B).repeat(B);
                const R = new Uint8Array(16);
                if (typeof crypto < "u")
                  crypto.getRandomValues(R);
                else
                  for (let l = 0; l < 16; l++)
                    R[l] = Math.floor(256 * Math.random());
                let D = (0, t.stringToBytes)(w);
                D = X.encrypt(D, R);
                const b = new Uint8Array(16 + D.length);
                return b.set(R), b.set(D, 16), (0, t.bytesToString)(b);
              }
              let M = (0, t.stringToBytes)(w);
              return M = X.encrypt(M), (0, t.bytesToString)(M);
            }
          }
          const C = function() {
            const w = new Uint8Array([40, 191, 78, 94, 78, 117, 138, 65, 100, 0, 78, 86, 255, 250, 1, 8, 46, 46, 0, 182, 208, 104, 62, 128, 47, 12, 169, 254, 100, 83, 105, 122]);
            function X(l, _, S, A, F, T, O, U, G, K, W, z) {
              if (_) {
                const L = Math.min(127, _.length);
                _ = _.subarray(0, L);
              } else
                _ = [];
              let V;
              return l === 6 ? V = new f() : V = new x(), V.checkUserPassword(_, U, O) ? V.getUserKey(_, G, W) : _.length && V.checkOwnerPassword(_, A, T, S) ? V.getOwnerKey(_, F, T, K) : null;
            }
            function M(l, _, S, A, F, T, O, U) {
              const G = 40 + S.length + l.length, K = new Uint8Array(G);
              let W = 0, z, V;
              if (_)
                for (V = Math.min(32, _.length); W < V; ++W)
                  K[W] = _[W];
              for (z = 0; W < 32; )
                K[W++] = w[z++];
              for (z = 0, V = S.length; z < V; ++z)
                K[W++] = S[z];
              for (K[W++] = F & 255, K[W++] = F >> 8 & 255, K[W++] = F >> 16 & 255, K[W++] = F >>> 24 & 255, z = 0, V = l.length; z < V; ++z)
                K[W++] = l[z];
              T >= 4 && !U && (K[W++] = 255, K[W++] = 255, K[W++] = 255, K[W++] = 255);
              let L = e(K, 0, W);
              const Y = O >> 3;
              if (T >= 3)
                for (z = 0; z < 50; ++z)
                  L = e(L, 0, Y);
              const J = L.subarray(0, Y);
              let ie, q;
              if (T >= 3) {
                for (W = 0; W < 32; ++W)
                  K[W] = w[W];
                for (z = 0, V = l.length; z < V; ++z)
                  K[W++] = l[z];
                ie = new a(J), q = ie.encryptBlock(e(K, 0, W)), V = J.length;
                const N = new Uint8Array(V);
                for (z = 1; z <= 19; ++z) {
                  for (let Z = 0; Z < V; ++Z)
                    N[Z] = J[Z] ^ z;
                  ie = new a(N), q = ie.encryptBlock(q);
                }
                for (z = 0, V = q.length; z < V; ++z)
                  if (A[z] !== q[z])
                    return null;
              } else
                for (ie = new a(J), q = ie.encryptBlock(w), z = 0, V = q.length; z < V; ++z)
                  if (A[z] !== q[z])
                    return null;
              return J;
            }
            function j(l, _, S, A) {
              const F = new Uint8Array(32);
              let T = 0;
              const O = Math.min(32, l.length);
              for (; T < O; ++T)
                F[T] = l[T];
              let U = 0;
              for (; T < 32; )
                F[T++] = w[U++];
              let G = e(F, 0, T);
              const K = A >> 3;
              if (S >= 3)
                for (U = 0; U < 50; ++U)
                  G = e(G, 0, G.length);
              let W, z;
              if (S >= 3) {
                z = _;
                const V = new Uint8Array(K);
                for (U = 19; U >= 0; U--) {
                  for (let L = 0; L < K; ++L)
                    V[L] = G[L] ^ U;
                  W = new a(V), z = W.encryptBlock(z);
                }
              } else
                W = new a(G.subarray(0, K)), z = W.encryptBlock(_);
              return z;
            }
            const B = i.Name.get("Identity");
            function R(l, _, S, A = !1) {
              const F = new Uint8Array(S.length + 9), T = S.length;
              let O;
              for (O = 0; O < T; ++O)
                F[O] = S[O];
              return F[O++] = l & 255, F[O++] = l >> 8 & 255, F[O++] = l >> 16 & 255, F[O++] = _ & 255, F[O++] = _ >> 8 & 255, A && (F[O++] = 115, F[O++] = 65, F[O++] = 108, F[O++] = 84), e(F, 0, O).subarray(0, Math.min(S.length + 5, 16));
            }
            function D(l, _, S, A, F) {
              if (!(_ instanceof i.Name))
                throw new t.FormatError("Invalid crypt filter name.");
              const T = l.get(_.name);
              let O;
              if (T != null && (O = T.get("CFM")), !O || O.name === "None")
                return function() {
                  return new d();
                };
              if (O.name === "V2")
                return function() {
                  return new a(R(S, A, F, !1));
                };
              if (O.name === "AESV2")
                return function() {
                  return new n(R(S, A, F, !0));
                };
              if (O.name === "AESV3")
                return function() {
                  return new o(F);
                };
              throw new t.FormatError("Unknown crypto method");
            }
            class b {
              constructor(_, S, A) {
                const F = _.get("Filter");
                if (!(0, i.isName)(F, "Standard"))
                  throw new t.FormatError("unknown encryption method");
                this.filterName = F.name, this.dict = _;
                const T = _.get("V");
                if (!Number.isInteger(T) || T !== 1 && T !== 2 && T !== 4 && T !== 5)
                  throw new t.FormatError("unsupported encryption algorithm");
                this.algorithm = T;
                let O = _.get("Length");
                if (!O)
                  if (T <= 3)
                    O = 40;
                  else {
                    const J = _.get("CF"), ie = _.get("StmF");
                    if (J instanceof i.Dict && ie instanceof i.Name) {
                      J.suppressEncryption = !0;
                      const q = J.get(ie.name);
                      O = q && q.get("Length") || 128, O < 40 && (O <<= 3);
                    }
                  }
                if (!Number.isInteger(O) || O < 40 || O % 8 !== 0)
                  throw new t.FormatError("invalid key length");
                const U = (0, t.stringToBytes)(_.get("O")).subarray(0, 32), G = (0, t.stringToBytes)(_.get("U")).subarray(0, 32), K = _.get("P"), W = _.get("R"), z = (T === 4 || T === 5) && _.get("EncryptMetadata") !== !1;
                this.encryptMetadata = z;
                const V = (0, t.stringToBytes)(S);
                let L;
                if (A) {
                  if (W === 6)
                    try {
                      A = (0, t.utf8StringToString)(A);
                    } catch {
                      (0, t.warn)("CipherTransformFactory: Unable to convert UTF8 encoded password.");
                    }
                  L = (0, t.stringToBytes)(A);
                }
                let Y;
                if (T !== 5)
                  Y = M(V, L, U, G, K, W, O, z);
                else {
                  const J = (0, t.stringToBytes)(_.get("O")).subarray(32, 40), ie = (0, t.stringToBytes)(_.get("O")).subarray(40, 48), q = (0, t.stringToBytes)(_.get("U")).subarray(0, 48), N = (0, t.stringToBytes)(_.get("U")).subarray(32, 40), Z = (0, t.stringToBytes)(_.get("U")).subarray(40, 48), E = (0, t.stringToBytes)(_.get("OE")), te = (0, t.stringToBytes)(_.get("UE"));
                  (0, t.stringToBytes)(_.get("Perms")), Y = X(W, L, U, J, ie, q, G, N, Z, E, te);
                }
                if (!Y && !A)
                  throw new t.PasswordException("No password given", t.PasswordResponses.NEED_PASSWORD);
                if (!Y && A) {
                  const J = j(L, U, W, O);
                  Y = M(V, J, U, G, K, W, O, z);
                }
                if (!Y)
                  throw new t.PasswordException("Incorrect Password", t.PasswordResponses.INCORRECT_PASSWORD);
                if (this.encryptionKey = Y, T >= 4) {
                  const J = _.get("CF");
                  J instanceof i.Dict && (J.suppressEncryption = !0), this.cf = J, this.stmf = _.get("StmF") || B, this.strf = _.get("StrF") || B, this.eff = _.get("EFF") || this.stmf;
                }
              }
              createCipherTransform(_, S) {
                if (this.algorithm === 4 || this.algorithm === 5)
                  return new m(D(this.cf, this.strf, _, S, this.encryptionKey), D(this.cf, this.stmf, _, S, this.encryptionKey));
                const A = R(_, S, this.encryptionKey, !1), F = function() {
                  return new a(A);
                };
                return new m(F, F);
              }
            }
            return b;
          }();
          u.CipherTransformFactory = C;
        },
        /* 68 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.DecryptStream = void 0;
          var t = P(19);
          const i = 512;
          class v extends t.DecodeStream {
            constructor(e, y, r) {
              super(y), this.str = e, this.dict = e.dict, this.decrypt = r, this.nextChunk = null, this.initialized = !1;
            }
            readBlock() {
              let e;
              if (this.initialized ? e = this.nextChunk : (e = this.str.getBytes(i), this.initialized = !0), !e || e.length === 0) {
                this.eof = !0;
                return;
              }
              this.nextChunk = this.str.getBytes(i);
              const y = this.nextChunk && this.nextChunk.length > 0, r = this.decrypt;
              e = r(e, !y);
              let h = this.bufferLength;
              const g = e.length, d = this.ensureBuffer(h + g);
              for (let c = 0; c < g; c++)
                d[h++] = e[c];
              this.bufferLength = h;
            }
          }
          u.DecryptStream = v;
        },
        /* 69 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.Catalog = void 0;
          var t = P(6), i = P(2), v = P(5), a = P(70), e = P(7), y = P(71), r = P(14), h = P(72), g = P(59), d = P(73), c = P(74);
          function n(x) {
            return x instanceof v.Dict && (x = x.get("D")), Array.isArray(x) ? x : null;
          }
          class o {
            constructor(f, m) {
              if (this.pdfManager = f, this.xref = m, this._catDict = m.getCatalogObj(), !(this._catDict instanceof v.Dict))
                throw new i.FormatError("Catalog object is not a dictionary.");
              this.toplevelPagesDict, this._actualNumPages = null, this.fontCache = new v.RefSetCache(), this.builtInCMapCache = /* @__PURE__ */ new Map(), this.standardFontDataCache = /* @__PURE__ */ new Map(), this.globalImageCache = new g.GlobalImageCache(), this.pageKidsCountCache = new v.RefSetCache(), this.pageIndexCache = new v.RefSetCache(), this.nonBlendModesSet = new v.RefSet();
            }
            get version() {
              const f = this._catDict.get("Version");
              return (0, i.shadow)(this, "version", f instanceof v.Name ? f.name : null);
            }
            get lang() {
              const f = this._catDict.get("Lang");
              return (0, i.shadow)(this, "lang", typeof f == "string" ? (0, i.stringToPDFString)(f) : null);
            }
            get needsRendering() {
              const f = this._catDict.get("NeedsRendering");
              return (0, i.shadow)(this, "needsRendering", typeof f == "boolean" ? f : !1);
            }
            get collection() {
              let f = null;
              try {
                const m = this._catDict.get("Collection");
                m instanceof v.Dict && m.size > 0 && (f = m);
              } catch (m) {
                if (m instanceof t.MissingDataException)
                  throw m;
                (0, i.info)("Cannot fetch Collection entry; assuming no collection is present.");
              }
              return (0, i.shadow)(this, "collection", f);
            }
            get acroForm() {
              let f = null;
              try {
                const m = this._catDict.get("AcroForm");
                m instanceof v.Dict && m.size > 0 && (f = m);
              } catch (m) {
                if (m instanceof t.MissingDataException)
                  throw m;
                (0, i.info)("Cannot fetch AcroForm entry; assuming no forms are present.");
              }
              return (0, i.shadow)(this, "acroForm", f);
            }
            get acroFormRef() {
              const f = this._catDict.getRaw("AcroForm");
              return (0, i.shadow)(this, "acroFormRef", f instanceof v.Ref ? f : null);
            }
            get metadata() {
              const f = this._catDict.getRaw("Metadata");
              if (!(f instanceof v.Ref))
                return (0, i.shadow)(this, "metadata", null);
              let m = null;
              try {
                const C = !(this.xref.encrypt && this.xref.encrypt.encryptMetadata), p = this.xref.fetch(f, C);
                if (p instanceof e.BaseStream && p.dict instanceof v.Dict) {
                  const w = p.dict.get("Type"), X = p.dict.get("Subtype");
                  if ((0, v.isName)(w, "Metadata") && (0, v.isName)(X, "XML")) {
                    const M = (0, i.stringToUTF8String)(p.getString());
                    M && (m = new d.MetadataParser(M).serializable);
                  }
                }
              } catch (C) {
                if (C instanceof t.MissingDataException)
                  throw C;
                (0, i.info)(`Skipping invalid Metadata: "${C}".`);
              }
              return (0, i.shadow)(this, "metadata", m);
            }
            get markInfo() {
              let f = null;
              try {
                f = this._readMarkInfo();
              } catch (m) {
                if (m instanceof t.MissingDataException)
                  throw m;
                (0, i.warn)("Unable to read mark info.");
              }
              return (0, i.shadow)(this, "markInfo", f);
            }
            _readMarkInfo() {
              const f = this._catDict.get("MarkInfo");
              if (!(f instanceof v.Dict))
                return null;
              const m = {
                Marked: !1,
                UserProperties: !1,
                Suspects: !1
              };
              for (const C in m) {
                const p = f.get(C);
                typeof p == "boolean" && (m[C] = p);
              }
              return m;
            }
            get structTreeRoot() {
              let f = null;
              try {
                f = this._readStructTreeRoot();
              } catch (m) {
                if (m instanceof t.MissingDataException)
                  throw m;
                (0, i.warn)("Unable read to structTreeRoot info.");
              }
              return (0, i.shadow)(this, "structTreeRoot", f);
            }
            _readStructTreeRoot() {
              const f = this._catDict.get("StructTreeRoot");
              if (!(f instanceof v.Dict))
                return null;
              const m = new c.StructTreeRoot(f);
              return m.init(), m;
            }
            get toplevelPagesDict() {
              const f = this._catDict.get("Pages");
              if (!(f instanceof v.Dict))
                throw new i.FormatError("Invalid top-level pages dictionary.");
              return (0, i.shadow)(this, "toplevelPagesDict", f);
            }
            get documentOutline() {
              let f = null;
              try {
                f = this._readDocumentOutline();
              } catch (m) {
                if (m instanceof t.MissingDataException)
                  throw m;
                (0, i.warn)("Unable to read document outline.");
              }
              return (0, i.shadow)(this, "documentOutline", f);
            }
            _readDocumentOutline() {
              let f = this._catDict.get("Outlines");
              if (!(f instanceof v.Dict) || (f = f.getRaw("First"), !(f instanceof v.Ref)))
                return null;
              const m = {
                items: []
              }, C = [{
                obj: f,
                parent: m
              }], p = new v.RefSet();
              p.put(f);
              const w = this.xref, X = new Uint8ClampedArray(3);
              for (; C.length > 0; ) {
                const M = C.shift(), j = w.fetchIfRef(M.obj);
                if (j === null)
                  continue;
                if (!j.has("Title"))
                  throw new i.FormatError("Invalid outline item encountered.");
                const B = {
                  url: null,
                  dest: null
                };
                o.parseDestDictionary({
                  destDict: j,
                  resultObj: B,
                  docBaseUrl: this.pdfManager.docBaseUrl
                });
                const R = j.get("Title"), D = j.get("F") || 0, b = j.getArray("C"), l = j.get("Count");
                let _ = X;
                Array.isArray(b) && b.length === 3 && (b[0] !== 0 || b[1] !== 0 || b[2] !== 0) && (_ = r.ColorSpace.singletons.rgb.getRgb(b, 0));
                const S = {
                  dest: B.dest,
                  url: B.url,
                  unsafeUrl: B.unsafeUrl,
                  newWindow: B.newWindow,
                  title: (0, i.stringToPDFString)(R),
                  color: _,
                  count: Number.isInteger(l) ? l : void 0,
                  bold: !!(D & 2),
                  italic: !!(D & 1),
                  items: []
                };
                M.parent.items.push(S), f = j.getRaw("First"), f instanceof v.Ref && !p.has(f) && (C.push({
                  obj: f,
                  parent: S
                }), p.put(f)), f = j.getRaw("Next"), f instanceof v.Ref && !p.has(f) && (C.push({
                  obj: f,
                  parent: M.parent
                }), p.put(f));
              }
              return m.items.length > 0 ? m.items : null;
            }
            get permissions() {
              let f = null;
              try {
                f = this._readPermissions();
              } catch (m) {
                if (m instanceof t.MissingDataException)
                  throw m;
                (0, i.warn)("Unable to read permissions.");
              }
              return (0, i.shadow)(this, "permissions", f);
            }
            _readPermissions() {
              const f = this.xref.trailer.get("Encrypt");
              if (!(f instanceof v.Dict))
                return null;
              let m = f.get("P");
              if (typeof m != "number")
                return null;
              m += 4294967296;
              const C = [];
              for (const p in i.PermissionFlag) {
                const w = i.PermissionFlag[p];
                m & w && C.push(w);
              }
              return C;
            }
            get optionalContentConfig() {
              let f = null;
              try {
                const m = this._catDict.get("OCProperties");
                if (!m)
                  return (0, i.shadow)(this, "optionalContentConfig", null);
                const C = m.get("D");
                if (!C)
                  return (0, i.shadow)(this, "optionalContentConfig", null);
                const p = m.get("OCGs");
                if (!Array.isArray(p))
                  return (0, i.shadow)(this, "optionalContentConfig", null);
                const w = [], X = [];
                for (const M of p) {
                  if (!(M instanceof v.Ref))
                    continue;
                  X.push(M);
                  const j = this.xref.fetchIfRef(M);
                  w.push({
                    id: M.toString(),
                    name: typeof j.get("Name") == "string" ? (0, i.stringToPDFString)(j.get("Name")) : null,
                    intent: typeof j.get("Intent") == "string" ? (0, i.stringToPDFString)(j.get("Intent")) : null
                  });
                }
                f = this._readOptionalContentConfig(C, X), f.groups = w;
              } catch (m) {
                if (m instanceof t.MissingDataException)
                  throw m;
                (0, i.warn)(`Unable to read optional content config: ${m}`);
              }
              return (0, i.shadow)(this, "optionalContentConfig", f);
            }
            _readOptionalContentConfig(f, m) {
              function C(B) {
                const R = [];
                if (Array.isArray(B))
                  for (const D of B)
                    D instanceof v.Ref && m.includes(D) && R.push(D.toString());
                return R;
              }
              function p(B, R = 0) {
                if (!Array.isArray(B))
                  return null;
                const D = [];
                for (const l of B) {
                  if (l instanceof v.Ref && m.includes(l)) {
                    M.put(l), D.push(l.toString());
                    continue;
                  }
                  const _ = w(l, R);
                  _ && D.push(_);
                }
                if (R > 0)
                  return D;
                const b = [];
                for (const l of m)
                  M.has(l) || b.push(l.toString());
                return b.length && D.push({
                  name: null,
                  order: b
                }), D;
              }
              function w(B, R) {
                if (++R > j)
                  return (0, i.warn)("parseNestedOrder - reached MAX_NESTED_LEVELS."), null;
                const D = X.fetchIfRef(B);
                if (!Array.isArray(D))
                  return null;
                const b = X.fetchIfRef(D[0]);
                if (typeof b != "string")
                  return null;
                const l = p(D.slice(1), R);
                return !l || !l.length ? null : {
                  name: (0, i.stringToPDFString)(b),
                  order: l
                };
              }
              const X = this.xref, M = new v.RefSet(), j = 10;
              return {
                name: typeof f.get("Name") == "string" ? (0, i.stringToPDFString)(f.get("Name")) : null,
                creator: typeof f.get("Creator") == "string" ? (0, i.stringToPDFString)(f.get("Creator")) : null,
                baseState: f.get("BaseState") instanceof v.Name ? f.get("BaseState").name : null,
                on: C(f.get("ON")),
                off: C(f.get("OFF")),
                order: p(f.get("Order")),
                groups: null
              };
            }
            setActualNumPages(f = null) {
              this._actualNumPages = f;
            }
            get hasActualNumPages() {
              return this._actualNumPages !== null;
            }
            get _pagesCount() {
              const f = this.toplevelPagesDict.get("Count");
              if (!Number.isInteger(f))
                throw new i.FormatError("Page count in top-level pages dictionary is not an integer.");
              return (0, i.shadow)(this, "_pagesCount", f);
            }
            get numPages() {
              return this.hasActualNumPages ? this._actualNumPages : this._pagesCount;
            }
            get destinations() {
              const f = this._readDests(), m = /* @__PURE__ */ Object.create(null);
              if (f instanceof a.NameTree)
                for (const [C, p] of f.getAll()) {
                  const w = n(p);
                  w && (m[(0, i.stringToPDFString)(C)] = w);
                }
              else
                f instanceof v.Dict && f.forEach(function(C, p) {
                  const w = n(p);
                  w && (m[C] = w);
                });
              return (0, i.shadow)(this, "destinations", m);
            }
            getDestination(f) {
              const m = this._readDests();
              if (m instanceof a.NameTree) {
                const C = n(m.get(f));
                if (C)
                  return C;
                const p = this.destinations[f];
                if (p)
                  return (0, i.warn)(`Found "${f}" at an incorrect position in the NameTree.`), p;
              } else if (m instanceof v.Dict) {
                const C = n(m.get(f));
                if (C)
                  return C;
              }
              return null;
            }
            _readDests() {
              const f = this._catDict.get("Names");
              if (f && f.has("Dests"))
                return new a.NameTree(f.getRaw("Dests"), this.xref);
              if (this._catDict.has("Dests"))
                return this._catDict.get("Dests");
            }
            get pageLabels() {
              let f = null;
              try {
                f = this._readPageLabels();
              } catch (m) {
                if (m instanceof t.MissingDataException)
                  throw m;
                (0, i.warn)("Unable to read page labels.");
              }
              return (0, i.shadow)(this, "pageLabels", f);
            }
            _readPageLabels() {
              const f = this._catDict.getRaw("PageLabels");
              if (!f)
                return null;
              const m = new Array(this.numPages);
              let C = null, p = "";
              const X = new a.NumberTree(f, this.xref).getAll();
              let M = "", j = 1;
              for (let B = 0, R = this.numPages; B < R; B++) {
                const D = X.get(B);
                if (D !== void 0) {
                  if (!(D instanceof v.Dict))
                    throw new i.FormatError("PageLabel is not a dictionary.");
                  if (D.has("Type") && !(0, v.isName)(D.get("Type"), "PageLabel"))
                    throw new i.FormatError("Invalid type in PageLabel dictionary.");
                  if (D.has("S")) {
                    const b = D.get("S");
                    if (!(b instanceof v.Name))
                      throw new i.FormatError("Invalid style in PageLabel dictionary.");
                    C = b.name;
                  } else
                    C = null;
                  if (D.has("P")) {
                    const b = D.get("P");
                    if (typeof b != "string")
                      throw new i.FormatError("Invalid prefix in PageLabel dictionary.");
                    p = (0, i.stringToPDFString)(b);
                  } else
                    p = "";
                  if (D.has("St")) {
                    const b = D.get("St");
                    if (!(Number.isInteger(b) && b >= 1))
                      throw new i.FormatError("Invalid start in PageLabel dictionary.");
                    j = b;
                  } else
                    j = 1;
                }
                switch (C) {
                  case "D":
                    M = j;
                    break;
                  case "R":
                  case "r":
                    M = (0, t.toRomanNumerals)(j, C === "r");
                    break;
                  case "A":
                  case "a":
                    const b = 26, S = C === "a" ? 97 : 65, A = j - 1;
                    M = String.fromCharCode(S + A % b).repeat(Math.floor(A / b) + 1);
                    break;
                  default:
                    if (C)
                      throw new i.FormatError(`Invalid style "${C}" in PageLabel dictionary.`);
                    M = "";
                }
                m[B] = p + M, j++;
              }
              return m;
            }
            get pageLayout() {
              const f = this._catDict.get("PageLayout");
              let m = "";
              if (f instanceof v.Name)
                switch (f.name) {
                  case "SinglePage":
                  case "OneColumn":
                  case "TwoColumnLeft":
                  case "TwoColumnRight":
                  case "TwoPageLeft":
                  case "TwoPageRight":
                    m = f.name;
                }
              return (0, i.shadow)(this, "pageLayout", m);
            }
            get pageMode() {
              const f = this._catDict.get("PageMode");
              let m = "UseNone";
              if (f instanceof v.Name)
                switch (f.name) {
                  case "UseNone":
                  case "UseOutlines":
                  case "UseThumbs":
                  case "FullScreen":
                  case "UseOC":
                  case "UseAttachments":
                    m = f.name;
                }
              return (0, i.shadow)(this, "pageMode", m);
            }
            get viewerPreferences() {
              const f = this._catDict.get("ViewerPreferences");
              if (!(f instanceof v.Dict))
                return (0, i.shadow)(this, "viewerPreferences", null);
              let m = null;
              for (const C of f.getKeys()) {
                const p = f.get(C);
                let w;
                switch (C) {
                  case "HideToolbar":
                  case "HideMenubar":
                  case "HideWindowUI":
                  case "FitWindow":
                  case "CenterWindow":
                  case "DisplayDocTitle":
                  case "PickTrayByPDFSize":
                    typeof p == "boolean" && (w = p);
                    break;
                  case "NonFullScreenPageMode":
                    if (p instanceof v.Name)
                      switch (p.name) {
                        case "UseNone":
                        case "UseOutlines":
                        case "UseThumbs":
                        case "UseOC":
                          w = p.name;
                          break;
                        default:
                          w = "UseNone";
                      }
                    break;
                  case "Direction":
                    if (p instanceof v.Name)
                      switch (p.name) {
                        case "L2R":
                        case "R2L":
                          w = p.name;
                          break;
                        default:
                          w = "L2R";
                      }
                    break;
                  case "ViewArea":
                  case "ViewClip":
                  case "PrintArea":
                  case "PrintClip":
                    if (p instanceof v.Name)
                      switch (p.name) {
                        case "MediaBox":
                        case "CropBox":
                        case "BleedBox":
                        case "TrimBox":
                        case "ArtBox":
                          w = p.name;
                          break;
                        default:
                          w = "CropBox";
                      }
                    break;
                  case "PrintScaling":
                    if (p instanceof v.Name)
                      switch (p.name) {
                        case "None":
                        case "AppDefault":
                          w = p.name;
                          break;
                        default:
                          w = "AppDefault";
                      }
                    break;
                  case "Duplex":
                    if (p instanceof v.Name)
                      switch (p.name) {
                        case "Simplex":
                        case "DuplexFlipShortEdge":
                        case "DuplexFlipLongEdge":
                          w = p.name;
                          break;
                        default:
                          w = "None";
                      }
                    break;
                  case "PrintPageRange":
                    Array.isArray(p) && p.length % 2 === 0 && p.every((M, j, B) => Number.isInteger(M) && M > 0 && (j === 0 || M >= B[j - 1]) && M <= this.numPages) && (w = p);
                    break;
                  case "NumCopies":
                    Number.isInteger(p) && p > 0 && (w = p);
                    break;
                  default:
                    (0, i.warn)(`Ignoring non-standard key in ViewerPreferences: ${C}.`);
                    continue;
                }
                if (w === void 0) {
                  (0, i.warn)(`Bad value, for key "${C}", in ViewerPreferences: ${p}.`);
                  continue;
                }
                m || (m = /* @__PURE__ */ Object.create(null)), m[C] = w;
              }
              return (0, i.shadow)(this, "viewerPreferences", m);
            }
            get openAction() {
              const f = this._catDict.get("OpenAction"), m = /* @__PURE__ */ Object.create(null);
              if (f instanceof v.Dict) {
                const C = new v.Dict(this.xref);
                C.set("A", f);
                const p = {
                  url: null,
                  dest: null,
                  action: null
                };
                o.parseDestDictionary({
                  destDict: C,
                  resultObj: p
                }), Array.isArray(p.dest) ? m.dest = p.dest : p.action && (m.action = p.action);
              } else
                Array.isArray(f) && (m.dest = f);
              return (0, i.shadow)(this, "openAction", (0, i.objectSize)(m) > 0 ? m : null);
            }
            get attachments() {
              const f = this._catDict.get("Names");
              let m = null;
              if (f instanceof v.Dict && f.has("EmbeddedFiles")) {
                const C = new a.NameTree(f.getRaw("EmbeddedFiles"), this.xref);
                for (const [p, w] of C.getAll()) {
                  const X = new h.FileSpec(w, this.xref);
                  m || (m = /* @__PURE__ */ Object.create(null)), m[(0, i.stringToPDFString)(p)] = X.serializable;
                }
              }
              return (0, i.shadow)(this, "attachments", m);
            }
            get xfaImages() {
              const f = this._catDict.get("Names");
              let m = null;
              if (f instanceof v.Dict && f.has("XFAImages")) {
                const C = new a.NameTree(f.getRaw("XFAImages"), this.xref);
                for (const [p, w] of C.getAll())
                  m || (m = new v.Dict(this.xref)), m.set((0, i.stringToPDFString)(p), w);
              }
              return (0, i.shadow)(this, "xfaImages", m);
            }
            _collectJavaScript() {
              const f = this._catDict.get("Names");
              let m = null;
              function C(w, X) {
                if (!(X instanceof v.Dict) || !(0, v.isName)(X.get("S"), "JavaScript"))
                  return;
                let M = X.get("JS");
                if (M instanceof e.BaseStream)
                  M = M.getString();
                else if (typeof M != "string")
                  return;
                m === null && (m = /* @__PURE__ */ new Map()), M = (0, i.stringToPDFString)(M).replace(/\u0000/g, ""), m.set(w, M);
              }
              if (f instanceof v.Dict && f.has("JavaScript")) {
                const w = new a.NameTree(f.getRaw("JavaScript"), this.xref);
                for (const [X, M] of w.getAll())
                  C((0, i.stringToPDFString)(X), M);
              }
              const p = this._catDict.get("OpenAction");
              return p && C("OpenAction", p), m;
            }
            get javaScript() {
              const f = this._collectJavaScript();
              return (0, i.shadow)(this, "javaScript", f ? [...f.values()] : null);
            }
            get jsActions() {
              const f = this._collectJavaScript();
              let m = (0, t.collectActions)(this.xref, this._catDict, i.DocumentActionEventType);
              if (f) {
                m || (m = /* @__PURE__ */ Object.create(null));
                for (const [C, p] of f)
                  C in m ? m[C].push(p) : m[C] = [p];
              }
              return (0, i.shadow)(this, "jsActions", m);
            }
            async fontFallback(f, m) {
              const C = await Promise.all(this.fontCache);
              for (const p of C)
                if (p.loadedName === f) {
                  p.fallback(m);
                  return;
                }
            }
            async cleanup(f = !1) {
              (0, y.clearGlobalCaches)(), this.globalImageCache.clear(f), this.pageKidsCountCache.clear(), this.pageIndexCache.clear(), this.nonBlendModesSet.clear();
              const m = await Promise.all(this.fontCache);
              for (const {
                dict: C
              } of m)
                delete C.cacheKey;
              this.fontCache.clear(), this.builtInCMapCache.clear(), this.standardFontDataCache.clear();
            }
            async getPageDict(f) {
              const m = [this.toplevelPagesDict], C = new v.RefSet(), p = this._catDict.getRaw("Pages");
              p instanceof v.Ref && C.put(p);
              const w = this.xref, X = this.pageKidsCountCache, M = this.pageIndexCache;
              let j = 0;
              for (; m.length; ) {
                const B = m.pop();
                if (B instanceof v.Ref) {
                  const l = X.get(B);
                  if (l >= 0 && j + l <= f) {
                    j += l;
                    continue;
                  }
                  if (C.has(B))
                    throw new i.FormatError("Pages tree contains circular reference.");
                  C.put(B);
                  const _ = await w.fetchAsync(B);
                  if (_ instanceof v.Dict) {
                    let S = _.getRaw("Type");
                    if (S instanceof v.Ref && (S = await w.fetchAsync(S)), (0, v.isName)(S, "Page") || !_.has("Kids")) {
                      if (X.has(B) || X.put(B, 1), M.has(B) || M.put(B, j), j === f)
                        return [_, B];
                      j++;
                      continue;
                    }
                  }
                  m.push(_);
                  continue;
                }
                if (!(B instanceof v.Dict))
                  throw new i.FormatError("Page dictionary kid reference points to wrong type of object.");
                const {
                  objId: R
                } = B;
                let D = B.getRaw("Count");
                if (D instanceof v.Ref && (D = await w.fetchAsync(D)), Number.isInteger(D) && D >= 0 && (R && !X.has(R) && X.put(R, D), j + D <= f)) {
                  j += D;
                  continue;
                }
                let b = B.getRaw("Kids");
                if (b instanceof v.Ref && (b = await w.fetchAsync(b)), !Array.isArray(b)) {
                  let l = B.getRaw("Type");
                  if (l instanceof v.Ref && (l = await w.fetchAsync(l)), (0, v.isName)(l, "Page") || !B.has("Kids")) {
                    if (j === f)
                      return [B, null];
                    j++;
                    continue;
                  }
                  throw new i.FormatError("Page dictionary kids object is not an array.");
                }
                for (let l = b.length - 1; l >= 0; l--)
                  m.push(b[l]);
              }
              throw new Error(`Page index ${f} not found.`);
            }
            async getAllPageDicts(f = !1) {
              const m = [{
                currentNode: this.toplevelPagesDict,
                posInKids: 0
              }], C = new v.RefSet(), p = this._catDict.getRaw("Pages");
              p instanceof v.Ref && C.put(p);
              const w = /* @__PURE__ */ new Map(), X = this.xref, M = this.pageIndexCache;
              let j = 0;
              function B(D, b) {
                b && !M.has(b) && M.put(b, j), w.set(j++, [D, b]);
              }
              function R(D) {
                if (D instanceof t.XRefEntryException && !f)
                  throw D;
                w.set(j++, [D, null]);
              }
              for (; m.length > 0; ) {
                const D = m.at(-1), {
                  currentNode: b,
                  posInKids: l
                } = D;
                let _ = b.getRaw("Kids");
                if (_ instanceof v.Ref)
                  try {
                    _ = await X.fetchAsync(_);
                  } catch (T) {
                    R(T);
                    break;
                  }
                if (!Array.isArray(_)) {
                  R(new i.FormatError("Page dictionary kids object is not an array."));
                  break;
                }
                if (l >= _.length) {
                  m.pop();
                  continue;
                }
                const S = _[l];
                let A;
                if (S instanceof v.Ref) {
                  if (C.has(S)) {
                    R(new i.FormatError("Pages tree contains circular reference."));
                    break;
                  }
                  C.put(S);
                  try {
                    A = await X.fetchAsync(S);
                  } catch (T) {
                    R(T);
                    break;
                  }
                } else
                  A = S;
                if (!(A instanceof v.Dict)) {
                  R(new i.FormatError("Page dictionary kid reference points to wrong type of object."));
                  break;
                }
                let F = A.getRaw("Type");
                if (F instanceof v.Ref)
                  try {
                    F = await X.fetchAsync(F);
                  } catch (T) {
                    R(T);
                    break;
                  }
                (0, v.isName)(F, "Page") || !A.has("Kids") ? B(A, S instanceof v.Ref ? S : null) : m.push({
                  currentNode: A,
                  posInKids: 0
                }), D.posInKids++;
              }
              return w;
            }
            getPageIndex(f) {
              const m = this.pageIndexCache.get(f);
              if (m !== void 0)
                return Promise.resolve(m);
              const C = this.xref;
              function p(M) {
                let j = 0, B;
                return C.fetchAsync(M).then(function(R) {
                  if ((0, v.isRefsEqual)(M, f) && !(0, v.isDict)(R, "Page") && !(R instanceof v.Dict && !R.has("Type") && R.has("Contents")))
                    throw new i.FormatError("The reference does not point to a /Page dictionary.");
                  if (!R)
                    return null;
                  if (!(R instanceof v.Dict))
                    throw new i.FormatError("Node must be a dictionary.");
                  return B = R.getRaw("Parent"), R.getAsync("Parent");
                }).then(function(R) {
                  if (!R)
                    return null;
                  if (!(R instanceof v.Dict))
                    throw new i.FormatError("Parent must be a dictionary.");
                  return R.getAsync("Kids");
                }).then(function(R) {
                  if (!R)
                    return null;
                  const D = [];
                  let b = !1;
                  for (let l = 0, _ = R.length; l < _; l++) {
                    const S = R[l];
                    if (!(S instanceof v.Ref))
                      throw new i.FormatError("Kid must be a reference.");
                    if ((0, v.isRefsEqual)(S, M)) {
                      b = !0;
                      break;
                    }
                    D.push(C.fetchAsync(S).then(function(A) {
                      if (!(A instanceof v.Dict))
                        throw new i.FormatError("Kid node must be a dictionary.");
                      A.has("Count") ? j += A.get("Count") : j++;
                    }));
                  }
                  if (!b)
                    throw new i.FormatError("Kid reference not found in parent's kids.");
                  return Promise.all(D).then(function() {
                    return [j, B];
                  });
                });
              }
              let w = 0;
              const X = (M) => p(M).then((j) => {
                if (!j)
                  return this.pageIndexCache.put(f, w), w;
                const [B, R] = j;
                return w += B, X(R);
              });
              return X(f);
            }
            get baseUrl() {
              const f = this._catDict.get("URI");
              if (f instanceof v.Dict) {
                const m = f.get("Base");
                if (typeof m == "string") {
                  const C = (0, i.createValidAbsoluteUrl)(m, null, {
                    tryConvertEncoding: !0
                  });
                  if (C)
                    return (0, i.shadow)(this, "baseUrl", C.href);
                }
              }
              return (0, i.shadow)(this, "baseUrl", null);
            }
            static parseDestDictionary(f) {
              const m = f.destDict;
              if (!(m instanceof v.Dict)) {
                (0, i.warn)("parseDestDictionary: `destDict` must be a dictionary.");
                return;
              }
              const C = f.resultObj;
              if (typeof C != "object") {
                (0, i.warn)("parseDestDictionary: `resultObj` must be an object.");
                return;
              }
              const p = f.docBaseUrl || null;
              let w = m.get("A"), X, M;
              if (w instanceof v.Dict || (m.has("Dest") ? w = m.get("Dest") : (w = m.get("AA"), w instanceof v.Dict && (w.has("D") ? w = w.get("D") : w.has("U") && (w = w.get("U"))))), w instanceof v.Dict) {
                const j = w.get("S");
                if (!(j instanceof v.Name)) {
                  (0, i.warn)("parseDestDictionary: Invalid type in Action dictionary.");
                  return;
                }
                const B = j.name;
                switch (B) {
                  case "ResetForm":
                    const R = w.get("Flags"), D = ((typeof R == "number" ? R : 0) & 1) === 0, b = [], l = [];
                    for (const G of w.get("Fields") || [])
                      G instanceof v.Ref ? l.push(G.toString()) : typeof G == "string" && b.push((0, i.stringToPDFString)(G));
                    C.resetForm = {
                      fields: b,
                      refs: l,
                      include: D
                    };
                    break;
                  case "URI":
                    X = w.get("URI"), X instanceof v.Name && (X = "/" + X.name);
                    break;
                  case "GoTo":
                    M = w.get("D");
                    break;
                  case "Launch":
                  case "GoToR":
                    const _ = w.get("F");
                    _ instanceof v.Dict ? X = _.get("F") || null : typeof _ == "string" && (X = _);
                    let S = w.get("D");
                    if (S && (S instanceof v.Name && (S = S.name), typeof X == "string")) {
                      const G = X.split("#")[0];
                      typeof S == "string" ? X = G + "#" + S : Array.isArray(S) && (X = G + "#" + JSON.stringify(S));
                    }
                    const A = w.get("NewWindow");
                    typeof A == "boolean" && (C.newWindow = A);
                    break;
                  case "Named":
                    const F = w.get("N");
                    F instanceof v.Name && (C.action = F.name);
                    break;
                  case "JavaScript":
                    const T = w.get("JS");
                    let O;
                    T instanceof e.BaseStream ? O = T.getString() : typeof T == "string" && (O = T);
                    const U = O && (0, t.recoverJsURL)((0, i.stringToPDFString)(O));
                    if (U) {
                      X = U.url, C.newWindow = U.newWindow;
                      break;
                    }
                  default:
                    if (B === "JavaScript" || B === "SubmitForm")
                      break;
                    (0, i.warn)(`parseDestDictionary - unsupported action: "${B}".`);
                    break;
                }
              } else
                m.has("Dest") && (M = m.get("Dest"));
              if (typeof X == "string") {
                const j = (0, i.createValidAbsoluteUrl)(X, p, {
                  addDefaultProtocol: !0,
                  tryConvertEncoding: !0
                });
                j && (C.url = j.href), C.unsafeUrl = X;
              }
              M && (M instanceof v.Name && (M = M.name), typeof M == "string" ? C.dest = (0, i.stringToPDFString)(M) : Array.isArray(M) && (C.dest = M));
            }
          }
          u.Catalog = o;
        },
        /* 70 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.NumberTree = u.NameTree = void 0;
          var t = P(5), i = P(2);
          class v {
            constructor(r, h, g) {
              this.constructor === v && (0, i.unreachable)("Cannot initialize NameOrNumberTree."), this.root = r, this.xref = h, this._type = g;
            }
            getAll() {
              const r = /* @__PURE__ */ new Map();
              if (!this.root)
                return r;
              const h = this.xref, g = new t.RefSet();
              g.put(this.root);
              const d = [this.root];
              for (; d.length > 0; ) {
                const c = h.fetchIfRef(d.shift());
                if (!(c instanceof t.Dict))
                  continue;
                if (c.has("Kids")) {
                  const o = c.get("Kids");
                  if (!Array.isArray(o))
                    continue;
                  for (const x of o) {
                    if (g.has(x))
                      throw new i.FormatError(`Duplicate entry in "${this._type}" tree.`);
                    d.push(x), g.put(x);
                  }
                  continue;
                }
                const n = c.get(this._type);
                if (Array.isArray(n))
                  for (let o = 0, x = n.length; o < x; o += 2)
                    r.set(h.fetchIfRef(n[o]), h.fetchIfRef(n[o + 1]));
              }
              return r;
            }
            get(r) {
              if (!this.root)
                return null;
              const h = this.xref;
              let g = h.fetchIfRef(this.root), d = 0;
              const c = 10;
              for (; g.has("Kids"); ) {
                if (++d > c)
                  return (0, i.warn)(`Search depth limit reached for "${this._type}" tree.`), null;
                const o = g.get("Kids");
                if (!Array.isArray(o))
                  return null;
                let x = 0, f = o.length - 1;
                for (; x <= f; ) {
                  const m = x + f >> 1, C = h.fetchIfRef(o[m]), p = C.get("Limits");
                  if (r < h.fetchIfRef(p[0]))
                    f = m - 1;
                  else if (r > h.fetchIfRef(p[1]))
                    x = m + 1;
                  else {
                    g = C;
                    break;
                  }
                }
                if (x > f)
                  return null;
              }
              const n = g.get(this._type);
              if (Array.isArray(n)) {
                let o = 0, x = n.length - 2;
                for (; o <= x; ) {
                  const f = o + x >> 1, m = f + (f & 1), C = h.fetchIfRef(n[m]);
                  if (r < C)
                    x = m - 2;
                  else if (r > C)
                    o = m + 2;
                  else
                    return h.fetchIfRef(n[m + 1]);
                }
              }
              return null;
            }
          }
          class a extends v {
            constructor(r, h) {
              super(r, h, "Names");
            }
          }
          u.NameTree = a;
          class e extends v {
            constructor(r, h) {
              super(r, h, "Nums");
            }
          }
          u.NumberTree = e;
        },
        /* 71 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.clearGlobalCaches = v;
          var t = P(5), i = P(40);
          function v() {
            (0, t.clearPrimitiveCaches)(), (0, i.clearUnicodeCaches)();
          }
        },
        /* 72 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.FileSpec = void 0;
          var t = P(2), i = P(7), v = P(5);
          function a(y) {
            return y.has("UF") ? y.get("UF") : y.has("F") ? y.get("F") : y.has("Unix") ? y.get("Unix") : y.has("Mac") ? y.get("Mac") : y.has("DOS") ? y.get("DOS") : null;
          }
          class e {
            constructor(r, h) {
              r instanceof v.Dict && (this.xref = h, this.root = r, r.has("FS") && (this.fs = r.get("FS")), this.description = r.has("Desc") ? (0, t.stringToPDFString)(r.get("Desc")) : "", r.has("RF") && (0, t.warn)("Related file specifications are not supported"), this.contentAvailable = !0, r.has("EF") || (this.contentAvailable = !1, (0, t.warn)("Non-embedded file specifications are not supported")));
            }
            get filename() {
              if (!this._filename && this.root) {
                const r = a(this.root) || "unnamed";
                this._filename = (0, t.stringToPDFString)(r).replace(/\\\\/g, "\\").replace(/\\\//g, "/").replace(/\\/g, "/");
              }
              return this._filename;
            }
            get content() {
              if (!this.contentAvailable)
                return null;
              !this.contentRef && this.root && (this.contentRef = a(this.root.get("EF")));
              let r = null;
              if (this.contentRef) {
                const h = this.xref.fetchIfRef(this.contentRef);
                h instanceof i.BaseStream ? r = h.getBytes() : (0, t.warn)("Embedded file specification points to non-existing/invalid content");
              } else
                (0, t.warn)("Embedded file specification does not have a content");
              return r;
            }
            get serializable() {
              return {
                filename: this.filename,
                content: this.content
              };
            }
          }
          u.FileSpec = e;
        },
        /* 73 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.MetadataParser = void 0;
          var t = P(66);
          class i {
            constructor(a) {
              a = this._repair(a);
              const y = new t.SimpleXMLParser({
                lowerCaseName: !0
              }).parseFromString(a);
              this._metadataMap = /* @__PURE__ */ new Map(), this._data = a, y && this._parse(y);
            }
            _repair(a) {
              return a.replace(/^[^<]+/, "").replace(/>\\376\\377([^<]+)/g, function(e, y) {
                const r = y.replace(/\\([0-3])([0-7])([0-7])/g, function(g, d, c, n) {
                  return String.fromCharCode(d * 64 + c * 8 + n * 1);
                }).replace(/&(amp|apos|gt|lt|quot);/g, function(g, d) {
                  switch (d) {
                    case "amp":
                      return "&";
                    case "apos":
                      return "'";
                    case "gt":
                      return ">";
                    case "lt":
                      return "<";
                    case "quot":
                      return '"';
                  }
                  throw new Error(`_repair: ${d} isn't defined.`);
                }), h = [];
                for (let g = 0, d = r.length; g < d; g += 2) {
                  const c = r.charCodeAt(g) * 256 + r.charCodeAt(g + 1);
                  c >= 32 && c < 127 && c !== 60 && c !== 62 && c !== 38 ? h.push(String.fromCharCode(c)) : h.push("&#x" + (65536 + c).toString(16).substring(1) + ";");
                }
                return ">" + h.join("");
              });
            }
            _getSequence(a) {
              const e = a.nodeName;
              return e !== "rdf:bag" && e !== "rdf:seq" && e !== "rdf:alt" ? null : a.childNodes.filter((y) => y.nodeName === "rdf:li");
            }
            _parseArray(a) {
              if (!a.hasChildNodes())
                return;
              const [e] = a.childNodes, y = this._getSequence(e) || [];
              this._metadataMap.set(a.nodeName, y.map((r) => r.textContent.trim()));
            }
            _parse(a) {
              let e = a.documentElement;
              if (e.nodeName !== "rdf:rdf")
                for (e = e.firstChild; e && e.nodeName !== "rdf:rdf"; )
                  e = e.nextSibling;
              if (!(!e || e.nodeName !== "rdf:rdf" || !e.hasChildNodes())) {
                for (const y of e.childNodes)
                  if (y.nodeName === "rdf:description")
                    for (const r of y.childNodes) {
                      const h = r.nodeName;
                      switch (h) {
                        case "#text":
                          continue;
                        case "dc:creator":
                        case "dc:subject":
                          this._parseArray(r);
                          continue;
                      }
                      this._metadataMap.set(h, r.textContent.trim());
                    }
              }
            }
            get serializable() {
              return {
                parsedData: this._metadataMap,
                rawData: this._data
              };
            }
          }
          u.MetadataParser = i;
        },
        /* 74 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.StructTreeRoot = u.StructTreePage = void 0;
          var t = P(5), i = P(2), v = P(70);
          const a = 40, e = {
            PAGE_CONTENT: "PAGE_CONTENT",
            STREAM_CONTENT: "STREAM_CONTENT",
            OBJECT: "OBJECT",
            ELEMENT: "ELEMENT"
          };
          class y {
            constructor(c) {
              this.dict = c, this.roleMap = /* @__PURE__ */ new Map();
            }
            init() {
              this.readRoleMap();
            }
            readRoleMap() {
              const c = this.dict.get("RoleMap");
              c instanceof t.Dict && c.forEach((n, o) => {
                o instanceof t.Name && this.roleMap.set(n, o.name);
              });
            }
          }
          u.StructTreeRoot = y;
          class r {
            constructor(c, n) {
              this.tree = c, this.dict = n, this.kids = [], this.parseKids();
            }
            get role() {
              const c = this.dict.get("S"), n = c instanceof t.Name ? c.name : "", {
                root: o
              } = this.tree;
              return o.roleMap.has(n) ? o.roleMap.get(n) : n;
            }
            parseKids() {
              let c = null;
              const n = this.dict.getRaw("Pg");
              n instanceof t.Ref && (c = n.toString());
              const o = this.dict.get("K");
              if (Array.isArray(o))
                for (const x of o) {
                  const f = this.parseKid(c, x);
                  f && this.kids.push(f);
                }
              else {
                const x = this.parseKid(c, o);
                x && this.kids.push(x);
              }
            }
            parseKid(c, n) {
              if (Number.isInteger(n))
                return this.tree.pageDict.objId !== c ? null : new h({
                  type: e.PAGE_CONTENT,
                  mcid: n,
                  pageObjId: c
                });
              let o = null;
              if (n instanceof t.Ref ? o = this.dict.xref.fetch(n) : n instanceof t.Dict && (o = n), !o)
                return null;
              const x = o.getRaw("Pg");
              x instanceof t.Ref && (c = x.toString());
              const f = o.get("Type") instanceof t.Name ? o.get("Type").name : null;
              return f === "MCR" ? this.tree.pageDict.objId !== c ? null : new h({
                type: e.STREAM_CONTENT,
                refObjId: o.getRaw("Stm") instanceof t.Ref ? o.getRaw("Stm").toString() : null,
                pageObjId: c,
                mcid: o.get("MCID")
              }) : f === "OBJR" ? this.tree.pageDict.objId !== c ? null : new h({
                type: e.OBJECT,
                refObjId: o.getRaw("Obj") instanceof t.Ref ? o.getRaw("Obj").toString() : null,
                pageObjId: c
              }) : new h({
                type: e.ELEMENT,
                dict: o
              });
            }
          }
          class h {
            constructor({
              type: c,
              dict: n = null,
              mcid: o = null,
              pageObjId: x = null,
              refObjId: f = null
            }) {
              this.type = c, this.dict = n, this.mcid = o, this.pageObjId = x, this.refObjId = f, this.parentNode = null;
            }
          }
          class g {
            constructor(c, n) {
              this.root = c, this.rootDict = c ? c.dict : null, this.pageDict = n, this.nodes = [];
            }
            parse() {
              if (!this.root || !this.rootDict)
                return;
              const c = this.rootDict.get("ParentTree");
              if (!c)
                return;
              const n = this.pageDict.get("StructParents");
              if (!Number.isInteger(n))
                return;
              const x = new v.NumberTree(c, this.rootDict.xref).get(n);
              if (!Array.isArray(x))
                return;
              const f = /* @__PURE__ */ new Map();
              for (const m of x)
                m instanceof t.Ref && this.addNode(this.rootDict.xref.fetch(m), f);
            }
            addNode(c, n, o = 0) {
              if (o > a)
                return (0, i.warn)("StructTree MAX_DEPTH reached."), null;
              if (n.has(c))
                return n.get(c);
              const x = new r(this, c);
              n.set(c, x);
              const f = c.get("P");
              if (!f || (0, t.isName)(f.get("Type"), "StructTreeRoot"))
                return this.addTopLevelNode(c, x) || n.delete(c), x;
              const m = this.addNode(f, n, o + 1);
              if (!m)
                return x;
              let C = !1;
              for (const p of m.kids)
                p.type === e.ELEMENT && p.dict === c && (p.parentNode = x, C = !0);
              return C || n.delete(c), x;
            }
            addTopLevelNode(c, n) {
              const o = this.rootDict.get("K");
              if (!o)
                return !1;
              if (o instanceof t.Dict)
                return o.objId !== c.objId ? !1 : (this.nodes[0] = n, !0);
              if (!Array.isArray(o))
                return !0;
              let x = !1;
              for (let f = 0; f < o.length; f++) {
                const m = o[f];
                m && m.toString() === c.objId && (this.nodes[f] = n, x = !0);
              }
              return x;
            }
            get serializable() {
              function c(o, x, f = 0) {
                if (f > a) {
                  (0, i.warn)("StructTree too deep to be fully serialized.");
                  return;
                }
                const m = /* @__PURE__ */ Object.create(null);
                m.role = o.role, m.children = [], x.children.push(m);
                const C = o.dict.get("Alt");
                typeof C == "string" && (m.alt = (0, i.stringToPDFString)(C));
                const p = o.dict.get("Lang");
                typeof p == "string" && (m.lang = (0, i.stringToPDFString)(p));
                for (const w of o.kids) {
                  const X = w.type === e.ELEMENT ? w.parentNode : null;
                  if (X) {
                    c(X, m, f + 1);
                    continue;
                  } else
                    w.type === e.PAGE_CONTENT || w.type === e.STREAM_CONTENT ? m.children.push({
                      type: "content",
                      id: `page${w.pageObjId}_mcid${w.mcid}`
                    }) : w.type === e.OBJECT && m.children.push({
                      type: "object",
                      id: w.refObjId
                    });
                }
              }
              const n = /* @__PURE__ */ Object.create(null);
              n.children = [], n.role = "Root";
              for (const o of this.nodes)
                o && c(o, n);
              return n;
            }
          }
          u.StructTreePage = g;
        },
        /* 75 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.ObjectLoader = void 0;
          var t = P(5), i = P(7), v = P(6), a = P(2);
          function e(h) {
            return h instanceof t.Ref || h instanceof t.Dict || h instanceof i.BaseStream || Array.isArray(h);
          }
          function y(h, g) {
            if (h instanceof t.Dict)
              h = h.getRawValues();
            else if (h instanceof i.BaseStream)
              h = h.dict.getRawValues();
            else if (!Array.isArray(h))
              return;
            for (const d of h)
              e(d) && g.push(d);
          }
          class r {
            constructor(g, d, c) {
              this.dict = g, this.keys = d, this.xref = c, this.refSet = null;
            }
            async load() {
              if (this.xref.stream.isDataLoaded)
                return;
              const {
                keys: g,
                dict: d
              } = this;
              this.refSet = new t.RefSet();
              const c = [];
              for (let n = 0, o = g.length; n < o; n++) {
                const x = d.getRaw(g[n]);
                x !== void 0 && c.push(x);
              }
              return this._walk(c);
            }
            async _walk(g) {
              const d = [], c = [];
              for (; g.length; ) {
                let n = g.pop();
                if (n instanceof t.Ref) {
                  if (this.refSet.has(n))
                    continue;
                  try {
                    this.refSet.put(n), n = this.xref.fetch(n);
                  } catch (o) {
                    if (!(o instanceof v.MissingDataException)) {
                      (0, a.warn)(`ObjectLoader._walk - requesting all data: "${o}".`), this.refSet = null;
                      const {
                        manager: x
                      } = this.xref.stream;
                      return x.requestAllChunks();
                    }
                    d.push(n), c.push({
                      begin: o.begin,
                      end: o.end
                    });
                  }
                }
                if (n instanceof i.BaseStream) {
                  const o = n.getBaseStreams();
                  if (o) {
                    let x = !1;
                    for (const f of o)
                      f.isDataLoaded || (x = !0, c.push({
                        begin: f.start,
                        end: f.end
                      }));
                    x && d.push(n);
                  }
                }
                y(n, g);
              }
              if (c.length) {
                await this.xref.stream.manager.requestRanges(c);
                for (const n of d)
                  n instanceof t.Ref && this.refSet.remove(n);
                return this._walk(d);
              }
              this.refSet = null;
            }
          }
          u.ObjectLoader = r;
        },
        /* 76 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.XFAFactory = void 0;
          var t = P(77), i = P(81), v = P(87), a = P(85), e = P(78), y = P(2), r = P(88), h = P(98);
          class g {
            constructor(c) {
              try {
                this.root = new r.XFAParser().parse(g._createDocument(c));
                const n = new i.Binder(this.root);
                this.form = n.bind(), this.dataHandler = new v.DataHandler(this.root, n.getData()), this.form[t.$globalData].template = this.form;
              } catch (n) {
                (0, y.warn)(`XFA - an error occurred during parsing and binding: ${n}`);
              }
            }
            isValid() {
              return this.root && this.form;
            }
            _createPagesHelper() {
              const c = this.form[t.$toPages]();
              return new Promise((n, o) => {
                const x = () => {
                  try {
                    const f = c.next();
                    f.done ? n(f.value) : setTimeout(x, 0);
                  } catch (f) {
                    o(f);
                  }
                };
                setTimeout(x, 0);
              });
            }
            async _createPages() {
              try {
                this.pages = await this._createPagesHelper(), this.dims = this.pages.children.map((c) => {
                  const {
                    width: n,
                    height: o
                  } = c.attributes.style;
                  return [0, 0, parseInt(n), parseInt(o)];
                });
              } catch (c) {
                (0, y.warn)(`XFA - an error occurred during layout: ${c}`);
              }
            }
            getBoundingBox(c) {
              return this.dims[c];
            }
            async getNumPages() {
              return this.pages || await this._createPages(), this.dims.length;
            }
            setImages(c) {
              this.form[t.$globalData].images = c;
            }
            setFonts(c) {
              this.form[t.$globalData].fontFinder = new a.FontFinder(c);
              const n = [];
              for (let o of this.form[t.$globalData].usedTypefaces)
                o = (0, e.stripQuotes)(o), this.form[t.$globalData].fontFinder.find(o) || n.push(o);
              return n.length > 0 ? n : null;
            }
            appendFonts(c, n) {
              this.form[t.$globalData].fontFinder.add(c, n);
            }
            async getPages() {
              this.pages || await this._createPages();
              const c = this.pages;
              return this.pages = null, c;
            }
            serializeData(c) {
              return this.dataHandler.serialize(c);
            }
            static _createDocument(c) {
              return c["/xdp:xdp"] ? Object.values(c).join("") : c["xdp:xdp"];
            }
            static getRichTextAsHtml(c) {
              if (!c || typeof c != "string")
                return null;
              try {
                let n = new r.XFAParser(h.XhtmlNamespace, !0).parse(c);
                if (!["body", "xhtml"].includes(n[t.$nodeName])) {
                  const m = h.XhtmlNamespace.body({});
                  m[t.$appendChild](n), n = m;
                }
                const o = n[t.$toHTML]();
                if (!o.success)
                  return null;
                const {
                  html: x
                } = o, {
                  attributes: f
                } = x;
                return f && (f.class && (f.class = f.class.filter((m) => !m.startsWith("xfa"))), f.dir = "auto"), {
                  html: x,
                  str: n[t.$text]()
                };
              } catch (n) {
                (0, y.warn)(`XFA - an error occurred during parsing of rich text: ${n}`);
              }
              return null;
            }
          }
          u.XFAFactory = g;
        },
        /* 77 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.XmlObject = u.XFAObjectArray = u.XFAObject = u.XFAAttribute = u.StringObject = u.OptionObject = u.Option10 = u.Option01 = u.IntegerObject = u.ContentObject = u.$uid = u.$toStyle = u.$toString = u.$toPages = u.$toHTML = u.$text = u.$tabIndex = u.$setValue = u.$setSetAttributes = u.$setId = u.$searchNode = u.$root = u.$resolvePrototypes = u.$removeChild = u.$pushPara = u.$pushGlyphs = u.$popPara = u.$onText = u.$onChildCheck = u.$onChild = u.$nsAttributes = u.$nodeName = u.$namespaceId = u.$isUsable = u.$isTransparent = u.$isThereMoreWidth = u.$isSplittable = u.$isNsAgnostic = u.$isDescendent = u.$isDataValue = u.$isCDATAXml = u.$isBindable = u.$insertAt = u.$indexOf = u.$ids = u.$hasSettableValue = u.$globalData = u.$getTemplateRoot = u.$getSubformParent = u.$getRealChildrenByNameIt = u.$getParent = u.$getNextPage = u.$getExtra = u.$getDataValue = u.$getContainedChildren = u.$getChildrenByNameIt = u.$getChildrenByName = u.$getChildrenByClass = u.$getChildren = u.$getAvailableSpace = u.$getAttributes = u.$getAttributeIt = u.$flushHTML = u.$finalize = u.$extra = u.$dump = u.$data = u.$content = u.$consumed = u.$clone = u.$cleanup = u.$cleanPage = u.$clean = u.$childrenToHTML = u.$appendChild = u.$addHTML = u.$acceptWhitespace = void 0;
          var t = P(78), i = P(2), v = P(6), a = P(79), e = P(80);
          const y = Symbol();
          u.$acceptWhitespace = y;
          const r = Symbol();
          u.$addHTML = r;
          const h = Symbol();
          u.$appendChild = h;
          const g = Symbol();
          u.$childrenToHTML = g;
          const d = Symbol();
          u.$clean = d;
          const c = Symbol();
          u.$cleanPage = c;
          const n = Symbol();
          u.$cleanup = n;
          const o = Symbol();
          u.$clone = o;
          const x = Symbol();
          u.$consumed = x;
          const f = Symbol("content");
          u.$content = f;
          const m = Symbol("data");
          u.$data = m;
          const C = Symbol();
          u.$dump = C;
          const p = Symbol("extra");
          u.$extra = p;
          const w = Symbol();
          u.$finalize = w;
          const X = Symbol();
          u.$flushHTML = X;
          const M = Symbol();
          u.$getAttributeIt = M;
          const j = Symbol();
          u.$getAttributes = j;
          const B = Symbol();
          u.$getAvailableSpace = B;
          const R = Symbol();
          u.$getChildrenByClass = R;
          const D = Symbol();
          u.$getChildrenByName = D;
          const b = Symbol();
          u.$getChildrenByNameIt = b;
          const l = Symbol();
          u.$getDataValue = l;
          const _ = Symbol();
          u.$getExtra = _;
          const S = Symbol();
          u.$getRealChildrenByNameIt = S;
          const A = Symbol();
          u.$getChildren = A;
          const F = Symbol();
          u.$getContainedChildren = F;
          const T = Symbol();
          u.$getNextPage = T;
          const O = Symbol();
          u.$getSubformParent = O;
          const U = Symbol();
          u.$getParent = U;
          const G = Symbol();
          u.$getTemplateRoot = G;
          const K = Symbol();
          u.$globalData = K;
          const W = Symbol();
          u.$hasSettableValue = W;
          const z = Symbol();
          u.$ids = z;
          const V = Symbol();
          u.$indexOf = V;
          const L = Symbol();
          u.$insertAt = L;
          const Y = Symbol();
          u.$isCDATAXml = Y;
          const J = Symbol();
          u.$isBindable = J;
          const ie = Symbol();
          u.$isDataValue = ie;
          const q = Symbol();
          u.$isDescendent = q;
          const N = Symbol();
          u.$isNsAgnostic = N;
          const Z = Symbol();
          u.$isSplittable = Z;
          const E = Symbol();
          u.$isThereMoreWidth = E;
          const te = Symbol();
          u.$isTransparent = te;
          const re = Symbol();
          u.$isUsable = re;
          const ee = Symbol(), $ = Symbol("namespaceId");
          u.$namespaceId = $;
          const k = Symbol("nodeName");
          u.$nodeName = k;
          const H = Symbol();
          u.$nsAttributes = H;
          const ne = Symbol();
          u.$onChild = ne;
          const ae = Symbol();
          u.$onChildCheck = ae;
          const he = Symbol();
          u.$onText = he;
          const ue = Symbol();
          u.$pushGlyphs = ue;
          const fe = Symbol();
          u.$popPara = fe;
          const me = Symbol();
          u.$pushPara = me;
          const Fe = Symbol();
          u.$removeChild = Fe;
          const we = Symbol("root");
          u.$root = we;
          const Ae = Symbol();
          u.$resolvePrototypes = Ae;
          const De = Symbol();
          u.$searchNode = De;
          const xe = Symbol();
          u.$setId = xe;
          const Te = Symbol();
          u.$setSetAttributes = Te;
          const ve = Symbol();
          u.$setValue = ve;
          const Se = Symbol();
          u.$tabIndex = Se;
          const be = Symbol();
          u.$text = be;
          const Le = Symbol();
          u.$toPages = Le;
          const ze = Symbol();
          u.$toHTML = ze;
          const nt = Symbol();
          u.$toString = nt;
          const Ue = Symbol();
          u.$toStyle = Ue;
          const Oe = Symbol("uid");
          u.$uid = Oe;
          const _e = Symbol(), at = Symbol(), Je = Symbol(), ot = Symbol("_children"), mt = Symbol(), Ze = Symbol(), pt = Symbol(), Ft = Symbol(), $e = Symbol(), St = Symbol(), xt = Symbol(), Ie = Symbol(), Ve = Symbol(), st = Symbol("parent"), ct = Symbol(), Rt = Symbol(), Lt = Symbol();
          let Ge = 0;
          const Ne = a.NamespaceIds.datasets.id;
          class rt {
            constructor(Re, We, it = !1) {
              this[$] = Re, this[k] = We, this[xt] = it, this[st] = null, this[ot] = [], this[Oe] = `${We}${Ge++}`, this[K] = null;
            }
            [ne](Re) {
              if (!this[xt] || !this[ae](Re))
                return !1;
              const We = Re[k], it = this[We];
              if (it instanceof tt) {
                if (it.push(Re))
                  return this[h](Re), !0;
              } else
                return it !== null && this[Fe](it), this[We] = Re, this[h](Re), !0;
              let et = "";
              return this.id ? et = ` (id: ${this.id})` : this.name && (et = ` (name: ${this.name} ${this.h.value})`), (0, i.warn)(`XFA - node "${this[k]}"${et} has already enough "${We}"!`), !1;
            }
            [ae](Re) {
              return this.hasOwnProperty(Re[k]) && Re[$] === this[$];
            }
            [N]() {
              return !1;
            }
            [y]() {
              return !1;
            }
            [Y]() {
              return !1;
            }
            [J]() {
              return !1;
            }
            [fe]() {
              this.para && this[G]()[p].paraStack.pop();
            }
            [me]() {
              this[G]()[p].paraStack.push(this.para);
            }
            [xe](Re) {
              this.id && this[$] === a.NamespaceIds.template.id && Re.set(this.id, this);
            }
            [G]() {
              return this[K].template;
            }
            [Z]() {
              return !1;
            }
            [E]() {
              return !1;
            }
            [h](Re) {
              Re[st] = this, this[ot].push(Re), !Re[K] && this[K] && (Re[K] = this[K]);
            }
            [Fe](Re) {
              const We = this[ot].indexOf(Re);
              this[ot].splice(We, 1);
            }
            [W]() {
              return this.hasOwnProperty("value");
            }
            [ve](Re) {
            }
            [he](Re) {
            }
            [w]() {
            }
            [d](Re) {
              delete this[xt], this[n] && (Re.clean(this[n]), delete this[n]);
            }
            [V](Re) {
              return this[ot].indexOf(Re);
            }
            [L](Re, We) {
              We[st] = this, this[ot].splice(Re, 0, We), !We[K] && this[K] && (We[K] = this[K]);
            }
            [te]() {
              return !this.name;
            }
            [ee]() {
              return "";
            }
            [be]() {
              return this[ot].length === 0 ? this[f] : this[ot].map((Re) => Re[be]()).join("");
            }
            get [Je]() {
              const Re = Object.getPrototypeOf(this);
              if (!Re._attributes) {
                const We = Re._attributes = /* @__PURE__ */ new Set();
                for (const it of Object.getOwnPropertyNames(this)) {
                  if (this[it] === null || this[it] instanceof rt || this[it] instanceof tt)
                    break;
                  We.add(it);
                }
              }
              return (0, i.shadow)(this, Je, Re._attributes);
            }
            [q](Re) {
              let We = this;
              for (; We; ) {
                if (We === Re)
                  return !0;
                We = We[U]();
              }
              return !1;
            }
            [U]() {
              return this[st];
            }
            [O]() {
              return this[U]();
            }
            [A](Re = null) {
              return Re ? this[Re] : this[ot];
            }
            [C]() {
              const Re = /* @__PURE__ */ Object.create(null);
              this[f] && (Re.$content = this[f]);
              for (const We of Object.getOwnPropertyNames(this)) {
                const it = this[We];
                it !== null && (it instanceof rt ? Re[We] = it[C]() : it instanceof tt ? it.isEmpty() || (Re[We] = it.dump()) : Re[We] = it);
              }
              return Re;
            }
            [Ue]() {
              return null;
            }
            [ze]() {
              return t.HTMLResult.EMPTY;
            }
            *[F]() {
              for (const Re of this[A]())
                yield Re;
            }
            *[Ft](Re, We) {
              for (const it of this[F]())
                if (!Re || We === Re.has(it[k])) {
                  const et = this[B](), At = it[ze](et);
                  At.success || (this[p].failingNode = it), yield At;
                }
            }
            [X]() {
              return null;
            }
            [r](Re, We) {
              this[p].children.push(Re);
            }
            [B]() {
            }
            [g]({
              filter: Re = null,
              include: We = !0
            }) {
              if (!this[p].generator)
                this[p].generator = this[Ft](Re, We);
              else {
                const it = this[B](), et = this[p].failingNode[ze](it);
                if (!et.success)
                  return et;
                et.html && this[r](et.html, et.bbox), delete this[p].failingNode;
              }
              for (; ; ) {
                const it = this[p].generator.next();
                if (it.done)
                  break;
                const et = it.value;
                if (!et.success)
                  return et;
                et.html && this[r](et.html, et.bbox);
              }
              return this[p].generator = null, t.HTMLResult.EMPTY;
            }
            [Te](Re) {
              this[Rt] = new Set(Object.keys(Re));
            }
            [St](Re) {
              const We = this[Je], it = this[Rt];
              return [...Re].filter((et) => We.has(et) && !it.has(et));
            }
            [Ae](Re, We = /* @__PURE__ */ new Set()) {
              for (const it of this[ot])
                it[ct](Re, We);
            }
            [ct](Re, We) {
              const it = this[$e](Re, We);
              it ? this[_e](it, Re, We) : this[Ae](Re, We);
            }
            [$e](Re, We) {
              const {
                use: it,
                usehref: et
              } = this;
              if (!it && !et)
                return null;
              let At = null, It = null, Vt = null, Ut = it;
              if (et ? (Ut = et, et.startsWith("#som(") && et.endsWith(")") ? It = et.slice(5, et.length - 1) : et.startsWith(".#som(") && et.endsWith(")") ? It = et.slice(6, et.length - 1) : et.startsWith("#") ? Vt = et.slice(1) : et.startsWith(".#") && (Vt = et.slice(2))) : it.startsWith("#") ? Vt = it.slice(1) : It = it, this.use = this.usehref = "", Vt ? At = Re.get(Vt) : (At = (0, e.searchNode)(Re.get(we), this, It, !0, !1), At && (At = At[0])), !At)
                return (0, i.warn)(`XFA - Invalid prototype reference: ${Ut}.`), null;
              if (At[k] !== this[k])
                return (0, i.warn)(`XFA - Incompatible prototype: ${At[k]} !== ${this[k]}.`), null;
              if (We.has(At))
                return (0, i.warn)("XFA - Cycle detected in prototypes use."), null;
              We.add(At);
              const Wt = At[$e](Re, We);
              return Wt && At[_e](Wt, Re, We), At[Ae](Re, We), We.delete(At), At;
            }
            [_e](Re, We, it) {
              if (it.has(Re)) {
                (0, i.warn)("XFA - Cycle detected in prototypes use.");
                return;
              }
              !this[f] && Re[f] && (this[f] = Re[f]), new Set(it).add(Re);
              for (const At of this[St](Re[Rt]))
                this[At] = Re[At], this[Rt] && this[Rt].add(At);
              for (const At of Object.getOwnPropertyNames(this)) {
                if (this[Je].has(At))
                  continue;
                const It = this[At], Vt = Re[At];
                if (It instanceof tt) {
                  for (const Ut of It[ot])
                    Ut[ct](We, it);
                  for (let Ut = It[ot].length, Wt = Vt[ot].length; Ut < Wt; Ut++) {
                    const Kt = Re[ot][Ut][o]();
                    if (It.push(Kt))
                      Kt[st] = this, this[ot].push(Kt), Kt[ct](We, it);
                    else
                      break;
                  }
                  continue;
                }
                if (It !== null) {
                  It[Ae](We, it), Vt && It[_e](Vt, We, it);
                  continue;
                }
                if (Vt !== null) {
                  const Ut = Vt[o]();
                  Ut[st] = this, this[At] = Ut, this[ot].push(Ut), Ut[ct](We, it);
                }
              }
            }
            static [mt](Re) {
              return Array.isArray(Re) ? Re.map((We) => rt[mt](We)) : typeof Re == "object" && Re !== null ? Object.assign({}, Re) : Re;
            }
            [o]() {
              const Re = Object.create(Object.getPrototypeOf(this));
              for (const We of Object.getOwnPropertySymbols(this))
                try {
                  Re[We] = this[We];
                } catch {
                  (0, i.shadow)(Re, We, this[We]);
                }
              Re[Oe] = `${Re[k]}${Ge++}`, Re[ot] = [];
              for (const We of Object.getOwnPropertyNames(this)) {
                if (this[Je].has(We)) {
                  Re[We] = rt[mt](this[We]);
                  continue;
                }
                const it = this[We];
                it instanceof tt ? Re[We] = new tt(it[Ie]) : Re[We] = null;
              }
              for (const We of this[ot]) {
                const it = We[k], et = We[o]();
                Re[ot].push(et), et[st] = Re, Re[it] === null ? Re[it] = et : Re[it][ot].push(et);
              }
              return Re;
            }
            [A](Re = null) {
              return Re ? this[ot].filter((We) => We[k] === Re) : this[ot];
            }
            [R](Re) {
              return this[Re];
            }
            [D](Re, We, it = !0) {
              return Array.from(this[b](Re, We, it));
            }
            *[b](Re, We, it = !0) {
              if (Re === "parent") {
                yield this[st];
                return;
              }
              for (const et of this[ot])
                et[k] === Re && (yield et), et.name === Re && (yield et), (We || et[te]()) && (yield* et[b](Re, We, !1));
              it && this[Je].has(Re) && (yield new dt(this, Re, this[Re]));
            }
          }
          u.XFAObject = rt;
          class tt {
            constructor(Re = 1 / 0) {
              this[Ie] = Re, this[ot] = [];
            }
            push(Re) {
              return this[ot].length <= this[Ie] ? (this[ot].push(Re), !0) : ((0, i.warn)(`XFA - node "${Re[k]}" accepts no more than ${this[Ie]} children`), !1);
            }
            isEmpty() {
              return this[ot].length === 0;
            }
            dump() {
              return this[ot].length === 1 ? this[ot][0][C]() : this[ot].map((Re) => Re[C]());
            }
            [o]() {
              const Re = new tt(this[Ie]);
              return Re[ot] = this[ot].map((We) => We[o]()), Re;
            }
            get children() {
              return this[ot];
            }
            clear() {
              this[ot].length = 0;
            }
          }
          u.XFAObjectArray = tt;
          class dt {
            constructor(Re, We, it) {
              this[st] = Re, this[k] = We, this[f] = it, this[x] = !1, this[Oe] = `attribute${Ge++}`;
            }
            [U]() {
              return this[st];
            }
            [ie]() {
              return !0;
            }
            [l]() {
              return this[f].trim();
            }
            [ve](Re) {
              Re = Re.value || "", this[f] = Re.toString();
            }
            [be]() {
              return this[f];
            }
            [q](Re) {
              return this[st] === Re || this[st][q](Re);
            }
          }
          u.XFAAttribute = dt;
          class Ct extends rt {
            constructor(Re, We, it = {}) {
              if (super(Re, We), this[f] = "", this[Ze] = null, We !== "#text") {
                const et = /* @__PURE__ */ new Map();
                this[at] = et;
                for (const [At, It] of Object.entries(it))
                  et.set(At, new dt(this, At, It));
                if (it.hasOwnProperty(H)) {
                  const At = it[H].xfa.dataNode;
                  At !== void 0 && (At === "dataGroup" ? this[Ze] = !1 : At === "dataValue" && (this[Ze] = !0));
                }
              }
              this[x] = !1;
            }
            [nt](Re) {
              const We = this[k];
              if (We === "#text") {
                Re.push((0, v.encodeToXmlString)(this[f]));
                return;
              }
              const it = (0, i.utf8StringToString)(We), et = this[$] === Ne ? "xfa:" : "";
              Re.push(`<${et}${it}`);
              for (const [At, It] of this[at].entries()) {
                const Vt = (0, i.utf8StringToString)(At);
                Re.push(` ${Vt}="${(0, v.encodeToXmlString)(It[f])}"`);
              }
              if (this[Ze] !== null && (this[Ze] ? Re.push(' xfa:dataNode="dataValue"') : Re.push(' xfa:dataNode="dataGroup"')), !this[f] && this[ot].length === 0) {
                Re.push("/>");
                return;
              }
              if (Re.push(">"), this[f])
                typeof this[f] == "string" ? Re.push((0, v.encodeToXmlString)(this[f])) : this[f][nt](Re);
              else
                for (const At of this[ot])
                  At[nt](Re);
              Re.push(`</${et}${it}>`);
            }
            [ne](Re) {
              if (this[f]) {
                const We = new Ct(this[$], "#text");
                this[h](We), We[f] = this[f], this[f] = "";
              }
              return this[h](Re), !0;
            }
            [he](Re) {
              this[f] += Re;
            }
            [w]() {
              if (this[f] && this[ot].length > 0) {
                const Re = new Ct(this[$], "#text");
                this[h](Re), Re[f] = this[f], delete this[f];
              }
            }
            [ze]() {
              return this[k] === "#text" ? t.HTMLResult.success({
                name: "#text",
                value: this[f]
              }) : t.HTMLResult.EMPTY;
            }
            [A](Re = null) {
              return Re ? this[ot].filter((We) => We[k] === Re) : this[ot];
            }
            [j]() {
              return this[at];
            }
            [R](Re) {
              const We = this[at].get(Re);
              return We !== void 0 ? We : this[A](Re);
            }
            *[b](Re, We) {
              const it = this[at].get(Re);
              it && (yield it);
              for (const et of this[ot])
                et[k] === Re && (yield et), We && (yield* et[b](Re, We));
            }
            *[M](Re, We) {
              const it = this[at].get(Re);
              it && (!We || !it[x]) && (yield it);
              for (const et of this[ot])
                yield* et[M](Re, We);
            }
            *[S](Re, We, it) {
              for (const et of this[ot])
                et[k] === Re && (!it || !et[x]) && (yield et), We && (yield* et[S](Re, We, it));
            }
            [ie]() {
              return this[Ze] === null ? this[ot].length === 0 || this[ot][0][$] === a.NamespaceIds.xhtml.id : this[Ze];
            }
            [l]() {
              return this[Ze] === null ? this[ot].length === 0 ? this[f].trim() : this[ot][0][$] === a.NamespaceIds.xhtml.id ? this[ot][0][be]().trim() : null : this[f].trim();
            }
            [ve](Re) {
              Re = Re.value || "", this[f] = Re.toString();
            }
            [C](Re = !1) {
              const We = /* @__PURE__ */ Object.create(null);
              Re && (We.$ns = this[$]), this[f] && (We.$content = this[f]), We.$name = this[k], We.children = [];
              for (const it of this[ot])
                We.children.push(it[C](Re));
              We.attributes = /* @__PURE__ */ Object.create(null);
              for (const [it, et] of this[at])
                We.attributes[it] = et[f];
              return We;
            }
          }
          u.XmlObject = Ct;
          class bt extends rt {
            constructor(Re, We) {
              super(Re, We), this[f] = "";
            }
            [he](Re) {
              this[f] += Re;
            }
            [w]() {
            }
          }
          u.ContentObject = bt;
          class ht extends bt {
            constructor(Re, We, it) {
              super(Re, We), this[Ve] = it;
            }
            [w]() {
              this[f] = (0, t.getKeyword)({
                data: this[f],
                defaultValue: this[Ve][0],
                validate: (Re) => this[Ve].includes(Re)
              });
            }
            [d](Re) {
              super[d](Re), delete this[Ve];
            }
          }
          u.OptionObject = ht;
          class vt extends bt {
            [w]() {
              this[f] = this[f].trim();
            }
          }
          u.StringObject = vt;
          class _t extends bt {
            constructor(Re, We, it, et) {
              super(Re, We), this[pt] = it, this[Lt] = et;
            }
            [w]() {
              this[f] = (0, t.getInteger)({
                data: this[f],
                defaultValue: this[pt],
                validate: this[Lt]
              });
            }
            [d](Re) {
              super[d](Re), delete this[pt], delete this[Lt];
            }
          }
          u.IntegerObject = _t;
          class Nt extends _t {
            constructor(Re, We) {
              super(Re, We, 0, (it) => it === 1);
            }
          }
          u.Option01 = Nt;
          class Mt extends _t {
            constructor(Re, We) {
              super(Re, We, 1, (it) => it === 0);
            }
          }
          u.Option10 = Mt;
        },
        /* 78 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.HTMLResult = void 0, u.getBBox = o, u.getColor = n, u.getFloat = y, u.getInteger = e, u.getKeyword = r, u.getMeasurement = g, u.getRatio = d, u.getRelevant = c, u.getStringOption = h, u.stripQuotes = a;
          var t = P(2);
          const i = {
            pt: (f) => f,
            cm: (f) => f / 2.54 * 72,
            mm: (f) => f / (10 * 2.54) * 72,
            in: (f) => f * 72,
            px: (f) => f
          }, v = /([+-]?\d+\.?\d*)(.*)/;
          function a(f) {
            return f.startsWith("'") || f.startsWith('"') ? f.slice(1, f.length - 1) : f;
          }
          function e({
            data: f,
            defaultValue: m,
            validate: C
          }) {
            if (!f)
              return m;
            f = f.trim();
            const p = parseInt(f, 10);
            return !isNaN(p) && C(p) ? p : m;
          }
          function y({
            data: f,
            defaultValue: m,
            validate: C
          }) {
            if (!f)
              return m;
            f = f.trim();
            const p = parseFloat(f);
            return !isNaN(p) && C(p) ? p : m;
          }
          function r({
            data: f,
            defaultValue: m,
            validate: C
          }) {
            return f ? (f = f.trim(), C(f) ? f : m) : m;
          }
          function h(f, m) {
            return r({
              data: f,
              defaultValue: m[0],
              validate: (C) => m.includes(C)
            });
          }
          function g(f, m = "0") {
            if (m = m || "0", !f)
              return g(m);
            const C = f.trim().match(v);
            if (!C)
              return g(m);
            const [, p, w] = C, X = parseFloat(p);
            if (isNaN(X))
              return g(m);
            if (X === 0)
              return 0;
            const M = i[w];
            return M ? M(X) : X;
          }
          function d(f) {
            if (!f)
              return {
                num: 1,
                den: 1
              };
            const m = f.trim().split(/\s*:\s*/).map((w) => parseFloat(w)).filter((w) => !isNaN(w));
            if (m.length === 1 && m.push(1), m.length === 0)
              return {
                num: 1,
                den: 1
              };
            const [C, p] = m;
            return {
              num: C,
              den: p
            };
          }
          function c(f) {
            return f ? f.trim().split(/\s+/).map((m) => ({
              excluded: m[0] === "-",
              viewname: m.substring(1)
            })) : [];
          }
          function n(f, m = [0, 0, 0]) {
            let [C, p, w] = m;
            if (!f)
              return {
                r: C,
                g: p,
                b: w
              };
            const X = f.trim().split(/\s*,\s*/).map((M) => Math.min(Math.max(0, parseInt(M.trim(), 10)), 255)).map((M) => isNaN(M) ? 0 : M);
            return X.length < 3 ? {
              r: C,
              g: p,
              b: w
            } : ([C, p, w] = X, {
              r: C,
              g: p,
              b: w
            });
          }
          function o(f) {
            if (!f)
              return {
                x: -1,
                y: -1,
                width: -1,
                height: -1
              };
            const C = f.trim().split(/\s*,\s*/).map((j) => g(j, "-1"));
            if (C.length < 4 || C[2] < 0 || C[3] < 0)
              return {
                x: -1,
                y: -1,
                width: -1,
                height: -1
              };
            const [p, w, X, M] = C;
            return {
              x: p,
              y: w,
              width: X,
              height: M
            };
          }
          class x {
            static get FAILURE() {
              return (0, t.shadow)(this, "FAILURE", new x(!1, null, null, null));
            }
            static get EMPTY() {
              return (0, t.shadow)(this, "EMPTY", new x(!0, null, null, null));
            }
            constructor(m, C, p, w) {
              this.success = m, this.html = C, this.bbox = p, this.breakNode = w;
            }
            isBreak() {
              return !!this.breakNode;
            }
            static breakNode(m) {
              return new x(!1, null, null, m);
            }
            static success(m, C = null) {
              return new x(!0, m, C, null);
            }
          }
          u.HTMLResult = x;
        },
        /* 79 */
        /***/
        (Q, u) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.NamespaceIds = u.$buildXFAObject = void 0;
          const P = Symbol();
          u.$buildXFAObject = P;
          const t = {
            config: {
              id: 0,
              check: (i) => i.startsWith("http://www.xfa.org/schema/xci/")
            },
            connectionSet: {
              id: 1,
              check: (i) => i.startsWith("http://www.xfa.org/schema/xfa-connection-set/")
            },
            datasets: {
              id: 2,
              check: (i) => i.startsWith("http://www.xfa.org/schema/xfa-data/")
            },
            form: {
              id: 3,
              check: (i) => i.startsWith("http://www.xfa.org/schema/xfa-form/")
            },
            localeSet: {
              id: 4,
              check: (i) => i.startsWith("http://www.xfa.org/schema/xfa-locale-set/")
            },
            pdf: {
              id: 5,
              check: (i) => i === "http://ns.adobe.com/xdp/pdf/"
            },
            signature: {
              id: 6,
              check: (i) => i === "http://www.w3.org/2000/09/xmldsig#"
            },
            sourceSet: {
              id: 7,
              check: (i) => i.startsWith("http://www.xfa.org/schema/xfa-source-set/")
            },
            stylesheet: {
              id: 8,
              check: (i) => i === "http://www.w3.org/1999/XSL/Transform"
            },
            template: {
              id: 9,
              check: (i) => i.startsWith("http://www.xfa.org/schema/xfa-template/")
            },
            xdc: {
              id: 10,
              check: (i) => i.startsWith("http://www.xfa.org/schema/xdc/")
            },
            xdp: {
              id: 11,
              check: (i) => i === "http://ns.adobe.com/xdp/"
            },
            xfdf: {
              id: 12,
              check: (i) => i === "http://ns.adobe.com/xfdf/"
            },
            xhtml: {
              id: 13,
              check: (i) => i === "http://www.w3.org/1999/xhtml"
            },
            xmpmeta: {
              id: 14,
              check: (i) => i === "http://ns.adobe.com/xmpmeta/"
            }
          };
          u.NamespaceIds = t;
        },
        /* 80 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.createDataNode = x, u.searchNode = n;
          var t = P(77), i = P(79), v = P(2);
          const a = /^[^.[]+/, e = /^[^\]]+/, y = {
            dot: 0,
            dotDot: 1,
            dotHash: 2,
            dotBracket: 3,
            dotParen: 4
          }, r = /* @__PURE__ */ new Map([["$data", (f, m) => f.datasets ? f.datasets.data : f], ["$record", (f, m) => (f.datasets ? f.datasets.data : f)[t.$getChildren]()[0]], ["$template", (f, m) => f.template], ["$connectionSet", (f, m) => f.connectionSet], ["$form", (f, m) => f.form], ["$layout", (f, m) => f.layout], ["$host", (f, m) => f.host], ["$dataWindow", (f, m) => f.dataWindow], ["$event", (f, m) => f.event], ["!", (f, m) => f.datasets], ["$xfa", (f, m) => f], ["xfa", (f, m) => f], ["$", (f, m) => m]]), h = /* @__PURE__ */ new WeakMap(), g = i.NamespaceIds.datasets.id;
          function d(f) {
            return f = f.trim(), f === "*" ? 1 / 0 : parseInt(f, 10) || 0;
          }
          function c(f, m, C = !0) {
            let p = f.match(a);
            if (!p)
              return null;
            let [w] = p;
            const X = [{
              name: w,
              cacheName: "." + w,
              index: 0,
              js: null,
              formCalc: null,
              operator: y.dot
            }];
            let M = w.length;
            for (; M < f.length; ) {
              const j = M;
              if (f.charAt(M++) === "[") {
                if (p = f.slice(M).match(e), !p)
                  return (0, v.warn)("XFA - Invalid index in SOM expression"), null;
                X.at(-1).index = d(p[0]), M += p[0].length + 1;
                continue;
              }
              let R;
              switch (f.charAt(M)) {
                case ".":
                  if (!m)
                    return null;
                  M++, R = y.dotDot;
                  break;
                case "#":
                  M++, R = y.dotHash;
                  break;
                case "[":
                  if (C)
                    return (0, v.warn)("XFA - SOM expression contains a FormCalc subexpression which is not supported for now."), null;
                  R = y.dotBracket;
                  break;
                case "(":
                  if (C)
                    return (0, v.warn)("XFA - SOM expression contains a JavaScript subexpression which is not supported for now."), null;
                  R = y.dotParen;
                  break;
                default:
                  R = y.dot;
                  break;
              }
              if (p = f.slice(M).match(a), !p)
                break;
              [w] = p, M += w.length, X.push({
                name: w,
                cacheName: f.slice(j, M),
                operator: R,
                index: 0,
                js: null,
                formCalc: null
              });
            }
            return X;
          }
          function n(f, m, C, p = !0, w = !0) {
            const X = c(C, p);
            if (!X)
              return null;
            const M = r.get(X[0].name);
            let j = 0, B;
            M ? (B = !0, f = [M(f, m)], j = 1) : (B = m === null, f = [m || f]);
            for (let R = X.length; j < R; j++) {
              const {
                name: D,
                cacheName: b,
                operator: l,
                index: _
              } = X[j], S = [];
              for (const A of f) {
                if (!(A instanceof t.XFAObject))
                  continue;
                let F, T;
                if (w && (T = h.get(A), T || (T = /* @__PURE__ */ new Map(), h.set(A, T)), F = T.get(b)), !F) {
                  switch (l) {
                    case y.dot:
                      F = A[t.$getChildrenByName](D, !1);
                      break;
                    case y.dotDot:
                      F = A[t.$getChildrenByName](D, !0);
                      break;
                    case y.dotHash:
                      F = A[t.$getChildrenByClass](D), F instanceof t.XFAObjectArray ? F = F.children : F = [F];
                      break;
                  }
                  w && T.set(b, F);
                }
                F.length > 0 && S.push(F);
              }
              if (S.length === 0 && !B && j === 0) {
                if (m = m[t.$getParent](), !m)
                  return null;
                j = -1, f = [m];
                continue;
              }
              isFinite(_) ? f = S.filter((A) => _ < A.length).map((A) => A[_]) : f = S.flat();
            }
            return f.length === 0 ? null : f;
          }
          function o(f, m) {
            let C = null;
            for (const {
              name: p,
              index: w
            } of m) {
              for (let X = 0, M = isFinite(w) ? w : 0; X <= M; X++) {
                const j = f[t.$namespaceId] === g ? -1 : f[t.$namespaceId];
                C = new t.XmlObject(j, p), f[t.$appendChild](C);
              }
              f = C;
            }
            return C;
          }
          function x(f, m, C) {
            const p = c(C);
            if (!p || p.some((M) => M.operator === y.dotDot))
              return null;
            const w = r.get(p[0].name);
            let X = 0;
            w ? (f = w(f, m), X = 1) : f = m || f;
            for (let M = p.length; X < M; X++) {
              const {
                name: j,
                operator: B,
                index: R
              } = p[X];
              if (!isFinite(R))
                return p[X].index = 0, o(f, p.slice(X));
              let D;
              switch (B) {
                case y.dot:
                  D = f[t.$getChildrenByName](j, !1);
                  break;
                case y.dotDot:
                  D = f[t.$getChildrenByName](j, !0);
                  break;
                case y.dotHash:
                  D = f[t.$getChildrenByClass](j), D instanceof t.XFAObjectArray ? D = D.children : D = [D];
                  break;
              }
              if (D.length === 0)
                return o(f, p.slice(X));
              if (R < D.length) {
                const b = D[R];
                if (!(b instanceof t.XFAObject))
                  return (0, v.warn)("XFA - Cannot create a node."), null;
                f = b;
              } else
                return p[X].index = R - D.length, o(f, p.slice(X));
            }
            return null;
          }
        },
        /* 81 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.Binder = void 0;
          var t = P(77), i = P(82), v = P(80), a = P(79), e = P(2);
          const y = a.NamespaceIds.datasets.id;
          function r(g) {
            const d = new i.Text({});
            return d[t.$content] = g, d;
          }
          class h {
            constructor(d) {
              this.root = d, this.datasets = d.datasets, d.datasets && d.datasets.data ? this.data = d.datasets.data : this.data = new t.XmlObject(a.NamespaceIds.datasets.id, "data"), this.emptyMerge = this.data[t.$getChildren]().length === 0, this.root.form = this.form = d.template[t.$clone]();
            }
            _isConsumeData() {
              return !this.emptyMerge && this._mergeMode;
            }
            _isMatchTemplate() {
              return !this._isConsumeData();
            }
            bind() {
              return this._bindElement(this.form, this.data), this.form;
            }
            getData() {
              return this.data;
            }
            _bindValue(d, c, n) {
              if (d[t.$data] = c, d[t.$hasSettableValue]())
                if (c[t.$isDataValue]()) {
                  const o = c[t.$getDataValue]();
                  d[t.$setValue](r(o));
                } else if (d instanceof i.Field && d.ui && d.ui.choiceList && d.ui.choiceList.open === "multiSelect") {
                  const o = c[t.$getChildren]().map((x) => x[t.$content].trim()).join(`
`);
                  d[t.$setValue](r(o));
                } else
                  this._isConsumeData() && (0, e.warn)("XFA - Nodes haven't the same type.");
              else
                !c[t.$isDataValue]() || this._isMatchTemplate() ? this._bindElement(d, c) : (0, e.warn)("XFA - Nodes haven't the same type.");
            }
            _findDataByNameToConsume(d, c, n, o) {
              if (!d)
                return null;
              let x, f;
              for (let m = 0; m < 3; m++) {
                for (x = n[t.$getRealChildrenByNameIt](d, !1, !0); f = x.next().value, !!f; )
                  if (c === f[t.$isDataValue]())
                    return f;
                if (n[t.$namespaceId] === a.NamespaceIds.datasets.id && n[t.$nodeName] === "data")
                  break;
                n = n[t.$getParent]();
              }
              return o ? (x = this.data[t.$getRealChildrenByNameIt](d, !0, !1), f = x.next().value, f || (x = this.data[t.$getAttributeIt](d, !0), f = x.next().value, f && f[t.$isDataValue]()) ? f : null) : null;
            }
            _setProperties(d, c) {
              if (d.hasOwnProperty("setProperty"))
                for (const {
                  ref: n,
                  target: o,
                  connection: x
                } of d.setProperty.children) {
                  if (x || !n)
                    continue;
                  const f = (0, v.searchNode)(this.root, c, n, !1, !1);
                  if (!f) {
                    (0, e.warn)(`XFA - Invalid reference: ${n}.`);
                    continue;
                  }
                  const [m] = f;
                  if (!m[t.$isDescendent](this.data)) {
                    (0, e.warn)("XFA - Invalid node: must be a data node.");
                    continue;
                  }
                  const C = (0, v.searchNode)(this.root, d, o, !1, !1);
                  if (!C) {
                    (0, e.warn)(`XFA - Invalid target: ${o}.`);
                    continue;
                  }
                  const [p] = C;
                  if (!p[t.$isDescendent](d)) {
                    (0, e.warn)("XFA - Invalid target: must be a property or subproperty.");
                    continue;
                  }
                  const w = p[t.$getParent]();
                  if (p instanceof i.SetProperty || w instanceof i.SetProperty) {
                    (0, e.warn)("XFA - Invalid target: cannot be a setProperty or one of its properties.");
                    continue;
                  }
                  if (p instanceof i.BindItems || w instanceof i.BindItems) {
                    (0, e.warn)("XFA - Invalid target: cannot be a bindItems or one of its properties.");
                    continue;
                  }
                  const X = m[t.$text](), M = p[t.$nodeName];
                  if (p instanceof t.XFAAttribute) {
                    const j = /* @__PURE__ */ Object.create(null);
                    j[M] = X;
                    const B = Reflect.construct(Object.getPrototypeOf(w).constructor, [j]);
                    w[M] = B[M];
                    continue;
                  }
                  if (!p.hasOwnProperty(t.$content)) {
                    (0, e.warn)("XFA - Invalid node to use in setProperty");
                    continue;
                  }
                  p[t.$data] = m, p[t.$content] = X, p[t.$finalize]();
                }
            }
            _bindItems(d, c) {
              if (!d.hasOwnProperty("items") || !d.hasOwnProperty("bindItems") || d.bindItems.isEmpty())
                return;
              for (const x of d.items.children)
                d[t.$removeChild](x);
              d.items.clear();
              const n = new i.Items({}), o = new i.Items({});
              d[t.$appendChild](n), d.items.push(n), d[t.$appendChild](o), d.items.push(o);
              for (const {
                ref: x,
                labelRef: f,
                valueRef: m,
                connection: C
              } of d.bindItems.children) {
                if (C || !x)
                  continue;
                const p = (0, v.searchNode)(this.root, c, x, !1, !1);
                if (!p) {
                  (0, e.warn)(`XFA - Invalid reference: ${x}.`);
                  continue;
                }
                for (const w of p) {
                  if (!w[t.$isDescendent](this.datasets)) {
                    (0, e.warn)(`XFA - Invalid ref (${x}): must be a datasets child.`);
                    continue;
                  }
                  const X = (0, v.searchNode)(this.root, w, f, !0, !1);
                  if (!X) {
                    (0, e.warn)(`XFA - Invalid label: ${f}.`);
                    continue;
                  }
                  const [M] = X;
                  if (!M[t.$isDescendent](this.datasets)) {
                    (0, e.warn)("XFA - Invalid label: must be a datasets child.");
                    continue;
                  }
                  const j = (0, v.searchNode)(this.root, w, m, !0, !1);
                  if (!j) {
                    (0, e.warn)(`XFA - Invalid value: ${m}.`);
                    continue;
                  }
                  const [B] = j;
                  if (!B[t.$isDescendent](this.datasets)) {
                    (0, e.warn)("XFA - Invalid value: must be a datasets child.");
                    continue;
                  }
                  const R = r(M[t.$text]()), D = r(B[t.$text]());
                  n[t.$appendChild](R), n.text.push(R), o[t.$appendChild](D), o.text.push(D);
                }
              }
            }
            _bindOccurrences(d, c, n) {
              let o;
              if (c.length > 1 && (o = d[t.$clone](), o[t.$removeChild](o.occur), o.occur = null), this._bindValue(d, c[0], n), this._setProperties(d, c[0]), this._bindItems(d, c[0]), c.length === 1)
                return;
              const x = d[t.$getParent](), f = d[t.$nodeName], m = x[t.$indexOf](d);
              for (let C = 1, p = c.length; C < p; C++) {
                const w = c[C], X = o[t.$clone]();
                x[f].push(X), x[t.$insertAt](m + C, X), this._bindValue(X, w, n), this._setProperties(X, w), this._bindItems(X, w);
              }
            }
            _createOccurrences(d) {
              if (!this.emptyMerge)
                return;
              const {
                occur: c
              } = d;
              if (!c || c.initial <= 1)
                return;
              const n = d[t.$getParent](), o = d[t.$nodeName];
              if (!(n[o] instanceof t.XFAObjectArray))
                return;
              let x;
              d.name ? x = n[o].children.filter((C) => C.name === d.name).length : x = n[o].children.length;
              const f = n[t.$indexOf](d) + 1, m = c.initial - x;
              if (m) {
                const C = d[t.$clone]();
                C[t.$removeChild](C.occur), C.occur = null, n[o].push(C), n[t.$insertAt](f, C);
                for (let p = 1; p < m; p++) {
                  const w = C[t.$clone]();
                  n[o].push(w), n[t.$insertAt](f + p, w);
                }
              }
            }
            _getOccurInfo(d) {
              const {
                name: c,
                occur: n
              } = d;
              if (!n || !c)
                return [1, 1];
              const o = n.max === -1 ? 1 / 0 : n.max;
              return [n.min, o];
            }
            _setAndBind(d, c) {
              this._setProperties(d, c), this._bindItems(d, c), this._bindElement(d, c);
            }
            _bindElement(d, c) {
              const n = [];
              this._createOccurrences(d);
              for (const o of d[t.$getChildren]()) {
                if (o[t.$data])
                  continue;
                if (this._mergeMode === void 0 && o[t.$nodeName] === "subform") {
                  this._mergeMode = o.mergeMode === "consumeData";
                  const X = c[t.$getChildren]();
                  if (X.length > 0)
                    this._bindOccurrences(o, [X[0]], null);
                  else if (this.emptyMerge) {
                    const M = c[t.$namespaceId] === y ? -1 : c[t.$namespaceId], j = o[t.$data] = new t.XmlObject(M, o.name || "root");
                    c[t.$appendChild](j), this._bindElement(o, j);
                  }
                  continue;
                }
                if (!o[t.$isBindable]())
                  continue;
                let x = !1, f = null, m = null, C = null;
                if (o.bind) {
                  switch (o.bind.match) {
                    case "none":
                      this._setAndBind(o, c);
                      continue;
                    case "global":
                      x = !0;
                      break;
                    case "dataRef":
                      if (!o.bind.ref) {
                        (0, e.warn)(`XFA - ref is empty in node ${o[t.$nodeName]}.`), this._setAndBind(o, c);
                        continue;
                      }
                      m = o.bind.ref;
                      break;
                  }
                  o.bind.picture && (f = o.bind.picture[t.$content]);
                }
                const [p, w] = this._getOccurInfo(o);
                if (m)
                  if (C = (0, v.searchNode)(this.root, c, m, !0, !1), C === null) {
                    if (C = (0, v.createDataNode)(this.data, c, m), !C)
                      continue;
                    this._isConsumeData() && (C[t.$consumed] = !0), this._setAndBind(o, C);
                    continue;
                  } else
                    this._isConsumeData() && (C = C.filter((X) => !X[t.$consumed])), C.length > w ? C = C.slice(0, w) : C.length === 0 && (C = null), C && this._isConsumeData() && C.forEach((X) => {
                      X[t.$consumed] = !0;
                    });
                else {
                  if (!o.name) {
                    this._setAndBind(o, c);
                    continue;
                  }
                  if (this._isConsumeData()) {
                    const X = [];
                    for (; X.length < w; ) {
                      const M = this._findDataByNameToConsume(o.name, o[t.$hasSettableValue](), c, x);
                      if (!M)
                        break;
                      M[t.$consumed] = !0, X.push(M);
                    }
                    C = X.length > 0 ? X : null;
                  } else {
                    if (C = c[t.$getRealChildrenByNameIt](o.name, !1, this.emptyMerge).next().value, !C) {
                      if (p === 0) {
                        n.push(o);
                        continue;
                      }
                      const X = c[t.$namespaceId] === y ? -1 : c[t.$namespaceId];
                      C = o[t.$data] = new t.XmlObject(X, o.name), this.emptyMerge && (C[t.$consumed] = !0), c[t.$appendChild](C), this._setAndBind(o, C);
                      continue;
                    }
                    this.emptyMerge && (C[t.$consumed] = !0), C = [C];
                  }
                }
                C ? this._bindOccurrences(o, C, f) : p > 0 ? this._setAndBind(o, c) : n.push(o);
              }
              n.forEach((o) => o[t.$getParent]()[t.$removeChild](o));
            }
          }
          u.Binder = h;
        },
        /* 82 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.Value = u.Text = u.TemplateNamespace = u.Template = u.SetProperty = u.Items = u.Field = u.BindItems = void 0;
          var t = P(77), i = P(79), v = P(83), a = P(84), e = P(78), y = P(2), r = P(85), h = P(6), g = P(80);
          const d = i.NamespaceIds.template.id, c = "http://www.w3.org/2000/svg", n = 2, o = 3, x = 5e3, f = /^H(\d+)$/, m = /* @__PURE__ */ new Set(["image/gif", "image/jpeg", "image/jpg", "image/pjpeg", "image/png", "image/apng", "image/x-png", "image/bmp", "image/x-ms-bmp", "image/tiff", "image/tif", "application/octet-stream"]), C = [[[66, 77], "image/bmp"], [[255, 216, 255], "image/jpeg"], [[73, 73, 42, 0], "image/tiff"], [[77, 77, 0, 42], "image/tiff"], [[71, 73, 70, 56, 57, 97], "image/gif"], [[137, 80, 78, 71, 13, 10, 26, 10], "image/png"]];
          function p(Xe) {
            if (!Xe || !Xe.border)
              return {
                w: 0,
                h: 0
              };
            const I = Xe.border[t.$getExtra]();
            return I ? {
              w: I.widths[0] + I.widths[2] + I.insets[0] + I.insets[2],
              h: I.widths[1] + I.widths[3] + I.insets[1] + I.insets[3]
            } : {
              w: 0,
              h: 0
            };
          }
          function w(Xe) {
            return Xe.margin && (Xe.margin.topInset || Xe.margin.rightInset || Xe.margin.bottomInset || Xe.margin.leftInset);
          }
          function X(Xe, I) {
            if (!Xe.value) {
              const ce = new xn({});
              Xe[t.$appendChild](ce), Xe.value = ce;
            }
            Xe.value[t.$setValue](I);
          }
          function* M(Xe) {
            for (const I of Xe[t.$getChildren]()) {
              if (I instanceof hn) {
                yield* I[t.$getContainedChildren]();
                continue;
              }
              yield I;
            }
          }
          function j(Xe) {
            return Xe.validate && Xe.validate.nullTest === "error";
          }
          function B(Xe) {
            for (; Xe; ) {
              if (!Xe.traversal) {
                Xe[t.$tabIndex] = Xe[t.$getParent]()[t.$tabIndex];
                return;
              }
              if (Xe[t.$tabIndex])
                return;
              let I = null;
              for (const Ke of Xe.traversal[t.$getChildren]())
                if (Ke.operation === "next") {
                  I = Ke;
                  break;
                }
              if (!I || !I.ref) {
                Xe[t.$tabIndex] = Xe[t.$getParent]()[t.$tabIndex];
                return;
              }
              const ce = Xe[t.$getTemplateRoot]();
              Xe[t.$tabIndex] = ++ce[t.$tabIndex];
              const je = ce[t.$searchNode](I.ref, Xe);
              if (!je)
                return;
              Xe = je[0];
            }
          }
          function R(Xe, I) {
            const ce = Xe.assist;
            if (ce) {
              const je = ce[t.$toHTML]();
              je && (I.title = je);
              const ut = ce.role.match(f);
              if (ut) {
                const Ot = "heading", Dt = ut[1];
                I.role = Ot, I["aria-level"] = Dt;
              }
            }
            if (Xe.layout === "table")
              I.role = "table";
            else if (Xe.layout === "row")
              I.role = "row";
            else {
              const je = Xe[t.$getParent]();
              je.layout === "row" && (je.assist && je.assist.role === "TH" ? I.role = "columnheader" : I.role = "cell");
            }
          }
          function D(Xe) {
            if (!Xe.assist)
              return null;
            const I = Xe.assist;
            return I.speak && I.speak[t.$content] !== "" ? I.speak[t.$content] : I.toolTip ? I.toolTip[t.$content] : null;
          }
          function b(Xe) {
            return e.HTMLResult.success({
              name: "div",
              attributes: {
                class: ["xfaRich"],
                style: /* @__PURE__ */ Object.create(null)
              },
              children: [{
                name: "span",
                attributes: {
                  style: /* @__PURE__ */ Object.create(null)
                },
                value: Xe
              }]
            });
          }
          function l(Xe) {
            const I = Xe[t.$getTemplateRoot]();
            I[t.$extra].firstUnsplittable === null && (I[t.$extra].firstUnsplittable = Xe, I[t.$extra].noLayoutFailure = !0);
          }
          function _(Xe) {
            const I = Xe[t.$getTemplateRoot]();
            I[t.$extra].firstUnsplittable === Xe && (I[t.$extra].noLayoutFailure = !1);
          }
          function S(Xe) {
            if (Xe[t.$extra] || (Xe[t.$extra] = /* @__PURE__ */ Object.create(null), Xe.targetType === "auto"))
              return !1;
            const I = Xe[t.$getTemplateRoot]();
            let ce = null;
            if (Xe.target) {
              if (ce = I[t.$searchNode](Xe.target, Xe[t.$getParent]()), !ce)
                return !1;
              ce = ce[0];
            }
            const {
              currentPageArea: je,
              currentContentArea: Ke
            } = I[t.$extra];
            if (Xe.targetType === "pageArea")
              return ce instanceof et || (ce = null), Xe.startNew ? (Xe[t.$extra].target = ce || je, !0) : ce && ce !== je ? (Xe[t.$extra].target = ce, !0) : !1;
            ce instanceof ne || (ce = null);
            const ut = ce && ce[t.$getParent]();
            let Ot, Dt = ut;
            if (Xe.startNew)
              if (ce) {
                const Pt = ut.contentArea.children, jt = Pt.indexOf(Ke), Xt = Pt.indexOf(ce);
                jt !== -1 && jt < Xt && (Dt = null), Ot = Xt - 1;
              } else
                Ot = je.contentArea.children.indexOf(Ke);
            else if (ce && ce !== Ke)
              Ot = ut.contentArea.children.indexOf(ce) - 1, Dt = ut === je ? null : ut;
            else
              return !1;
            return Xe[t.$extra].target = Dt, Xe[t.$extra].index = Ot, !0;
          }
          function A(Xe, I, ce) {
            const je = Xe[t.$getTemplateRoot](), Ke = je[t.$extra].noLayoutFailure, ut = I[t.$getSubformParent];
            I[t.$getSubformParent] = () => Xe, je[t.$extra].noLayoutFailure = !0;
            const Ot = I[t.$toHTML](ce);
            Xe[t.$addHTML](Ot.html, Ot.bbox), je[t.$extra].noLayoutFailure = Ke, I[t.$getSubformParent] = ut;
          }
          class F extends t.StringObject {
            constructor(I) {
              super(d, "appearanceFilter"), this.id = I.id || "", this.type = (0, e.getStringOption)(I.type, ["optional", "required"]), this.use = I.use || "", this.usehref = I.usehref || "";
            }
          }
          class T extends t.XFAObject {
            constructor(I) {
              super(d, "arc", !0), this.circular = (0, e.getInteger)({
                data: I.circular,
                defaultValue: 0,
                validate: (ce) => ce === 1
              }), this.hand = (0, e.getStringOption)(I.hand, ["even", "left", "right"]), this.id = I.id || "", this.startAngle = (0, e.getFloat)({
                data: I.startAngle,
                defaultValue: 0,
                validate: (ce) => !0
              }), this.sweepAngle = (0, e.getFloat)({
                data: I.sweepAngle,
                defaultValue: 360,
                validate: (ce) => !0
              }), this.use = I.use || "", this.usehref = I.usehref || "", this.edge = null, this.fill = null;
            }
            [t.$toHTML]() {
              const I = this.edge || new Te({}), ce = I[t.$toStyle](), je = /* @__PURE__ */ Object.create(null);
              this.fill && this.fill.presence === "visible" ? Object.assign(je, this.fill[t.$toStyle]()) : je.fill = "transparent", je.strokeWidth = (0, a.measureToString)(I.presence === "visible" ? I.thickness : 0), je.stroke = ce.color;
              let Ke;
              const ut = {
                xmlns: c,
                style: {
                  width: "100%",
                  height: "100%",
                  overflow: "visible"
                }
              };
              if (this.sweepAngle === 360)
                Ke = {
                  name: "ellipse",
                  attributes: {
                    xmlns: c,
                    cx: "50%",
                    cy: "50%",
                    rx: "50%",
                    ry: "50%",
                    style: je
                  }
                };
              else {
                const Pt = this.startAngle * Math.PI / 180, jt = this.sweepAngle * Math.PI / 180, Xt = this.sweepAngle > 180 ? 1 : 0, [Zt, Yt, en, ye] = [50 * (1 + Math.cos(Pt)), 50 * (1 - Math.sin(Pt)), 50 * (1 + Math.cos(Pt + jt)), 50 * (1 - Math.sin(Pt + jt))];
                Ke = {
                  name: "path",
                  attributes: {
                    xmlns: c,
                    d: `M ${Zt} ${Yt} A 50 50 0 ${Xt} 0 ${en} ${ye}`,
                    vectorEffect: "non-scaling-stroke",
                    style: je
                  }
                }, Object.assign(ut, {
                  viewBox: "0 0 100 100",
                  preserveAspectRatio: "none"
                });
              }
              const Ot = {
                name: "svg",
                children: [Ke],
                attributes: ut
              }, Dt = this[t.$getParent]()[t.$getParent]();
              return w(Dt) ? e.HTMLResult.success({
                name: "div",
                attributes: {
                  style: {
                    display: "inline",
                    width: "100%",
                    height: "100%"
                  }
                },
                children: [Ot]
              }) : (Ot.attributes.style.position = "absolute", e.HTMLResult.success(Ot));
            }
          }
          class O extends t.XFAObject {
            constructor(I) {
              super(d, "area", !0), this.colSpan = (0, e.getInteger)({
                data: I.colSpan,
                defaultValue: 1,
                validate: (ce) => ce >= 1 || ce === -1
              }), this.id = I.id || "", this.name = I.name || "", this.relevant = (0, e.getRelevant)(I.relevant), this.use = I.use || "", this.usehref = I.usehref || "", this.x = (0, e.getMeasurement)(I.x, "0pt"), this.y = (0, e.getMeasurement)(I.y, "0pt"), this.desc = null, this.extras = null, this.area = new t.XFAObjectArray(), this.draw = new t.XFAObjectArray(), this.exObject = new t.XFAObjectArray(), this.exclGroup = new t.XFAObjectArray(), this.field = new t.XFAObjectArray(), this.subform = new t.XFAObjectArray(), this.subformSet = new t.XFAObjectArray();
            }
            *[t.$getContainedChildren]() {
              yield* M(this);
            }
            [t.$isTransparent]() {
              return !0;
            }
            [t.$isBindable]() {
              return !0;
            }
            [t.$addHTML](I, ce) {
              const [je, Ke, ut, Ot] = ce;
              this[t.$extra].width = Math.max(this[t.$extra].width, je + ut), this[t.$extra].height = Math.max(this[t.$extra].height, Ke + Ot), this[t.$extra].children.push(I);
            }
            [t.$getAvailableSpace]() {
              return this[t.$extra].availableSpace;
            }
            [t.$toHTML](I) {
              const ce = (0, a.toStyle)(this, "position"), je = {
                style: ce,
                id: this[t.$uid],
                class: ["xfaArea"]
              };
              (0, a.isPrintOnly)(this) && je.class.push("xfaPrintOnly"), this.name && (je.xfaName = this.name);
              const Ke = [];
              this[t.$extra] = {
                children: Ke,
                width: 0,
                height: 0,
                availableSpace: I
              };
              const ut = this[t.$childrenToHTML]({
                filter: /* @__PURE__ */ new Set(["area", "draw", "field", "exclGroup", "subform", "subformSet"]),
                include: !0
              });
              if (!ut.success)
                return ut.isBreak() ? ut : (delete this[t.$extra], e.HTMLResult.FAILURE);
              ce.width = (0, a.measureToString)(this[t.$extra].width), ce.height = (0, a.measureToString)(this[t.$extra].height);
              const Ot = {
                name: "div",
                attributes: je,
                children: Ke
              }, Dt = [this.x, this.y, this[t.$extra].width, this[t.$extra].height];
              return delete this[t.$extra], e.HTMLResult.success(Ot, Dt);
            }
          }
          class U extends t.XFAObject {
            constructor(I) {
              super(d, "assist", !0), this.id = I.id || "", this.role = I.role || "", this.use = I.use || "", this.usehref = I.usehref || "", this.speak = null, this.toolTip = null;
            }
            [t.$toHTML]() {
              return this.toolTip && this.toolTip[t.$content] ? this.toolTip[t.$content] : null;
            }
          }
          class G extends t.XFAObject {
            constructor(I) {
              super(d, "barcode", !0), this.charEncoding = (0, e.getKeyword)({
                data: I.charEncoding ? I.charEncoding.toLowerCase() : "",
                defaultValue: "",
                validate: (ce) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(ce) || ce.match(/iso-8859-\d{2}/)
              }), this.checksum = (0, e.getStringOption)(I.checksum, ["none", "1mod10", "1mod10_1mod11", "2mod10", "auto"]), this.dataColumnCount = (0, e.getInteger)({
                data: I.dataColumnCount,
                defaultValue: -1,
                validate: (ce) => ce >= 0
              }), this.dataLength = (0, e.getInteger)({
                data: I.dataLength,
                defaultValue: -1,
                validate: (ce) => ce >= 0
              }), this.dataPrep = (0, e.getStringOption)(I.dataPrep, ["none", "flateCompress"]), this.dataRowCount = (0, e.getInteger)({
                data: I.dataRowCount,
                defaultValue: -1,
                validate: (ce) => ce >= 0
              }), this.endChar = I.endChar || "", this.errorCorrectionLevel = (0, e.getInteger)({
                data: I.errorCorrectionLevel,
                defaultValue: -1,
                validate: (ce) => ce >= 0 && ce <= 8
              }), this.id = I.id || "", this.moduleHeight = (0, e.getMeasurement)(I.moduleHeight, "5mm"), this.moduleWidth = (0, e.getMeasurement)(I.moduleWidth, "0.25mm"), this.printCheckDigit = (0, e.getInteger)({
                data: I.printCheckDigit,
                defaultValue: 0,
                validate: (ce) => ce === 1
              }), this.rowColumnRatio = (0, e.getRatio)(I.rowColumnRatio), this.startChar = I.startChar || "", this.textLocation = (0, e.getStringOption)(I.textLocation, ["below", "above", "aboveEmbedded", "belowEmbedded", "none"]), this.truncate = (0, e.getInteger)({
                data: I.truncate,
                defaultValue: 0,
                validate: (ce) => ce === 1
              }), this.type = (0, e.getStringOption)(I.type ? I.type.toLowerCase() : "", ["aztec", "codabar", "code2of5industrial", "code2of5interleaved", "code2of5matrix", "code2of5standard", "code3of9", "code3of9extended", "code11", "code49", "code93", "code128", "code128a", "code128b", "code128c", "code128sscc", "datamatrix", "ean8", "ean8add2", "ean8add5", "ean13", "ean13add2", "ean13add5", "ean13pwcd", "fim", "logmars", "maxicode", "msi", "pdf417", "pdf417macro", "plessey", "postauscust2", "postauscust3", "postausreplypaid", "postausstandard", "postukrm4scc", "postusdpbc", "postusimb", "postusstandard", "postus5zip", "qrcode", "rfid", "rss14", "rss14expanded", "rss14limited", "rss14stacked", "rss14stackedomni", "rss14truncated", "telepen", "ucc128", "ucc128random", "ucc128sscc", "upca", "upcaadd2", "upcaadd5", "upcapwcd", "upce", "upceadd2", "upceadd5", "upcean2", "upcean5", "upsmaxicode"]), this.upsMode = (0, e.getStringOption)(I.upsMode, ["usCarrier", "internationalCarrier", "secureSymbol", "standardSymbol"]), this.use = I.use || "", this.usehref = I.usehref || "", this.wideNarrowRatio = (0, e.getRatio)(I.wideNarrowRatio), this.encrypt = null, this.extras = null;
            }
          }
          class K extends t.XFAObject {
            constructor(I) {
              super(d, "bind", !0), this.match = (0, e.getStringOption)(I.match, ["once", "dataRef", "global", "none"]), this.ref = I.ref || "", this.picture = null;
            }
          }
          class W extends t.XFAObject {
            constructor(I) {
              super(d, "bindItems"), this.connection = I.connection || "", this.labelRef = I.labelRef || "", this.ref = I.ref || "", this.valueRef = I.valueRef || "";
            }
          }
          u.BindItems = W;
          class z extends t.XFAObject {
            constructor(I) {
              super(d, "bookend"), this.id = I.id || "", this.leader = I.leader || "", this.trailer = I.trailer || "", this.use = I.use || "", this.usehref = I.usehref || "";
            }
          }
          class V extends t.Option01 {
            constructor(I) {
              super(d, "boolean"), this.id = I.id || "", this.name = I.name || "", this.use = I.use || "", this.usehref = I.usehref || "";
            }
            [t.$toHTML](I) {
              return b(this[t.$content] === 1 ? "1" : "0");
            }
          }
          class L extends t.XFAObject {
            constructor(I) {
              super(d, "border", !0), this.break = (0, e.getStringOption)(I.break, ["close", "open"]), this.hand = (0, e.getStringOption)(I.hand, ["even", "left", "right"]), this.id = I.id || "", this.presence = (0, e.getStringOption)(I.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = (0, e.getRelevant)(I.relevant), this.use = I.use || "", this.usehref = I.usehref || "", this.corner = new t.XFAObjectArray(4), this.edge = new t.XFAObjectArray(4), this.extras = null, this.fill = null, this.margin = null;
            }
            [t.$getExtra]() {
              if (!this[t.$extra]) {
                const I = this.edge.children.slice();
                if (I.length < 4) {
                  const Ke = I.at(-1) || new Te({});
                  for (let ut = I.length; ut < 4; ut++)
                    I.push(Ke);
                }
                const ce = I.map((Ke) => Ke.thickness), je = [0, 0, 0, 0];
                this.margin && (je[0] = this.margin.topInset, je[1] = this.margin.rightInset, je[2] = this.margin.bottomInset, je[3] = this.margin.leftInset), this[t.$extra] = {
                  widths: ce,
                  insets: je,
                  edges: I
                };
              }
              return this[t.$extra];
            }
            [t.$toStyle]() {
              const {
                edges: I
              } = this[t.$getExtra](), ce = I.map((Ke) => {
                const ut = Ke[t.$toStyle]();
                return ut.color = ut.color || "#000000", ut;
              }), je = /* @__PURE__ */ Object.create(null);
              if (this.margin && Object.assign(je, this.margin[t.$toStyle]()), this.fill && this.fill.presence === "visible" && Object.assign(je, this.fill[t.$toStyle]()), this.corner.children.some((Ke) => Ke.radius !== 0)) {
                const Ke = this.corner.children.map((ut) => ut[t.$toStyle]());
                if (Ke.length === 2 || Ke.length === 3) {
                  const ut = Ke.at(-1);
                  for (let Ot = Ke.length; Ot < 4; Ot++)
                    Ke.push(ut);
                }
                je.borderRadius = Ke.map((ut) => ut.radius).join(" ");
              }
              switch (this.presence) {
                case "invisible":
                case "hidden":
                  je.borderStyle = "";
                  break;
                case "inactive":
                  je.borderStyle = "none";
                  break;
                default:
                  je.borderStyle = ce.map((Ke) => Ke.style).join(" ");
                  break;
              }
              return je.borderWidth = ce.map((Ke) => Ke.width).join(" "), je.borderColor = ce.map((Ke) => Ke.color).join(" "), je;
            }
          }
          class Y extends t.XFAObject {
            constructor(I) {
              super(d, "break", !0), this.after = (0, e.getStringOption)(I.after, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]), this.afterTarget = I.afterTarget || "", this.before = (0, e.getStringOption)(I.before, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]), this.beforeTarget = I.beforeTarget || "", this.bookendLeader = I.bookendLeader || "", this.bookendTrailer = I.bookendTrailer || "", this.id = I.id || "", this.overflowLeader = I.overflowLeader || "", this.overflowTarget = I.overflowTarget || "", this.overflowTrailer = I.overflowTrailer || "", this.startNew = (0, e.getInteger)({
                data: I.startNew,
                defaultValue: 0,
                validate: (ce) => ce === 1
              }), this.use = I.use || "", this.usehref = I.usehref || "", this.extras = null;
            }
          }
          class J extends t.XFAObject {
            constructor(I) {
              super(d, "breakAfter", !0), this.id = I.id || "", this.leader = I.leader || "", this.startNew = (0, e.getInteger)({
                data: I.startNew,
                defaultValue: 0,
                validate: (ce) => ce === 1
              }), this.target = I.target || "", this.targetType = (0, e.getStringOption)(I.targetType, ["auto", "contentArea", "pageArea"]), this.trailer = I.trailer || "", this.use = I.use || "", this.usehref = I.usehref || "", this.script = null;
            }
          }
          class ie extends t.XFAObject {
            constructor(I) {
              super(d, "breakBefore", !0), this.id = I.id || "", this.leader = I.leader || "", this.startNew = (0, e.getInteger)({
                data: I.startNew,
                defaultValue: 0,
                validate: (ce) => ce === 1
              }), this.target = I.target || "", this.targetType = (0, e.getStringOption)(I.targetType, ["auto", "contentArea", "pageArea"]), this.trailer = I.trailer || "", this.use = I.use || "", this.usehref = I.usehref || "", this.script = null;
            }
            [t.$toHTML](I) {
              return this[t.$extra] = {}, e.HTMLResult.FAILURE;
            }
          }
          class q extends t.XFAObject {
            constructor(I) {
              super(d, "button", !0), this.highlight = (0, e.getStringOption)(I.highlight, ["inverted", "none", "outline", "push"]), this.id = I.id || "", this.use = I.use || "", this.usehref = I.usehref || "", this.extras = null;
            }
            [t.$toHTML](I) {
              const je = this[t.$getParent]()[t.$getParent](), Ke = {
                name: "button",
                attributes: {
                  id: this[t.$uid],
                  class: ["xfaButton"],
                  style: {}
                },
                children: []
              };
              for (const ut of je.event.children) {
                if (ut.activity !== "click" || !ut.script)
                  continue;
                const Ot = (0, h.recoverJsURL)(ut.script[t.$content]);
                if (!Ot)
                  continue;
                const Dt = (0, a.fixURL)(Ot.url);
                Dt && Ke.children.push({
                  name: "a",
                  attributes: {
                    id: "link" + this[t.$uid],
                    href: Dt,
                    newWindow: Ot.newWindow,
                    class: ["xfaLink"],
                    style: {}
                  },
                  children: []
                });
              }
              return e.HTMLResult.success(Ke);
            }
          }
          class N extends t.XFAObject {
            constructor(I) {
              super(d, "calculate", !0), this.id = I.id || "", this.override = (0, e.getStringOption)(I.override, ["disabled", "error", "ignore", "warning"]), this.use = I.use || "", this.usehref = I.usehref || "", this.extras = null, this.message = null, this.script = null;
            }
          }
          class Z extends t.XFAObject {
            constructor(I) {
              super(d, "caption", !0), this.id = I.id || "", this.placement = (0, e.getStringOption)(I.placement, ["left", "bottom", "inline", "right", "top"]), this.presence = (0, e.getStringOption)(I.presence, ["visible", "hidden", "inactive", "invisible"]), this.reserve = Math.ceil((0, e.getMeasurement)(I.reserve)), this.use = I.use || "", this.usehref = I.usehref || "", this.extras = null, this.font = null, this.margin = null, this.para = null, this.value = null;
            }
            [t.$setValue](I) {
              X(this, I);
            }
            [t.$getExtra](I) {
              if (!this[t.$extra]) {
                let {
                  width: ce,
                  height: je
                } = I;
                switch (this.placement) {
                  case "left":
                  case "right":
                  case "inline":
                    ce = this.reserve <= 0 ? ce : this.reserve;
                    break;
                  case "top":
                  case "bottom":
                    je = this.reserve <= 0 ? je : this.reserve;
                    break;
                }
                this[t.$extra] = (0, a.layoutNode)(this, {
                  width: ce,
                  height: je
                });
              }
              return this[t.$extra];
            }
            [t.$toHTML](I) {
              if (!this.value)
                return e.HTMLResult.EMPTY;
              this[t.$pushPara]();
              const ce = this.value[t.$toHTML](I).html;
              if (!ce)
                return this[t.$popPara](), e.HTMLResult.EMPTY;
              const je = this.reserve;
              if (this.reserve <= 0) {
                const {
                  w: Ot,
                  h: Dt
                } = this[t.$getExtra](I);
                switch (this.placement) {
                  case "left":
                  case "right":
                  case "inline":
                    this.reserve = Ot;
                    break;
                  case "top":
                  case "bottom":
                    this.reserve = Dt;
                    break;
                }
              }
              const Ke = [];
              typeof ce == "string" ? Ke.push({
                name: "#text",
                value: ce
              }) : Ke.push(ce);
              const ut = (0, a.toStyle)(this, "font", "margin", "visibility");
              switch (this.placement) {
                case "left":
                case "right":
                  this.reserve > 0 && (ut.width = (0, a.measureToString)(this.reserve));
                  break;
                case "top":
                case "bottom":
                  this.reserve > 0 && (ut.height = (0, a.measureToString)(this.reserve));
                  break;
              }
              return (0, a.setPara)(this, null, ce), this[t.$popPara](), this.reserve = je, e.HTMLResult.success({
                name: "div",
                attributes: {
                  style: ut,
                  class: ["xfaCaption"]
                },
                children: Ke
              });
            }
          }
          class E extends t.StringObject {
            constructor(I) {
              super(d, "certificate"), this.id = I.id || "", this.name = I.name || "", this.use = I.use || "", this.usehref = I.usehref || "";
            }
          }
          class te extends t.XFAObject {
            constructor(I) {
              super(d, "certificates", !0), this.credentialServerPolicy = (0, e.getStringOption)(I.credentialServerPolicy, ["optional", "required"]), this.id = I.id || "", this.url = I.url || "", this.urlPolicy = I.urlPolicy || "", this.use = I.use || "", this.usehref = I.usehref || "", this.encryption = null, this.issuers = null, this.keyUsage = null, this.oids = null, this.signing = null, this.subjectDNs = null;
            }
          }
          class re extends t.XFAObject {
            constructor(I) {
              super(d, "checkButton", !0), this.id = I.id || "", this.mark = (0, e.getStringOption)(I.mark, ["default", "check", "circle", "cross", "diamond", "square", "star"]), this.shape = (0, e.getStringOption)(I.shape, ["square", "round"]), this.size = (0, e.getMeasurement)(I.size, "10pt"), this.use = I.use || "", this.usehref = I.usehref || "", this.border = null, this.extras = null, this.margin = null;
            }
            [t.$toHTML](I) {
              const ce = (0, a.toStyle)("margin"), je = (0, a.measureToString)(this.size);
              ce.width = ce.height = je;
              let Ke, ut, Ot;
              const Dt = this[t.$getParent]()[t.$getParent](), Pt = Dt.items.children.length && Dt.items.children[0][t.$toHTML]().html || [], jt = {
                on: (Pt[0] !== void 0 ? Pt[0] : "on").toString(),
                off: (Pt[1] !== void 0 ? Pt[1] : "off").toString()
              }, Zt = (Dt.value && Dt.value[t.$text]() || "off") === jt.on || void 0, Yt = Dt[t.$getSubformParent](), en = Dt[t.$uid];
              let ye;
              Yt instanceof Je ? (Ot = Yt[t.$uid], Ke = "radio", ut = "xfaRadio", ye = Yt[t.$data] && Yt[t.$data][t.$uid] || Yt[t.$uid]) : (Ke = "checkbox", ut = "xfaCheckbox", ye = Dt[t.$data] && Dt[t.$data][t.$uid] || Dt[t.$uid]);
              const Pe = {
                name: "input",
                attributes: {
                  class: [ut],
                  style: ce,
                  fieldId: en,
                  dataId: ye,
                  type: Ke,
                  checked: Zt,
                  xfaOn: jt.on,
                  xfaOff: jt.off,
                  "aria-label": D(Dt),
                  "aria-required": !1
                }
              };
              return Ot && (Pe.attributes.name = Ot), j(Dt) && (Pe.attributes["aria-required"] = !0, Pe.attributes.required = !0), e.HTMLResult.success({
                name: "label",
                attributes: {
                  class: ["xfaLabel"]
                },
                children: [Pe]
              });
            }
          }
          class ee extends t.XFAObject {
            constructor(I) {
              super(d, "choiceList", !0), this.commitOn = (0, e.getStringOption)(I.commitOn, ["select", "exit"]), this.id = I.id || "", this.open = (0, e.getStringOption)(I.open, ["userControl", "always", "multiSelect", "onEntry"]), this.textEntry = (0, e.getInteger)({
                data: I.textEntry,
                defaultValue: 0,
                validate: (ce) => ce === 1
              }), this.use = I.use || "", this.usehref = I.usehref || "", this.border = null, this.extras = null, this.margin = null;
            }
            [t.$toHTML](I) {
              const ce = (0, a.toStyle)(this, "border", "margin"), Ke = this[t.$getParent]()[t.$getParent](), Ot = {
                fontSize: `calc(${Ke.font && Ke.font.size || 10}px * var(--scale-factor))`
              }, Dt = [];
              if (Ke.items.children.length > 0) {
                const jt = Ke.items;
                let Xt = 0, Zt = 0;
                jt.children.length === 2 && (Xt = jt.children[0].save, Zt = 1 - Xt);
                const Yt = jt.children[Xt][t.$toHTML]().html, en = jt.children[Zt][t.$toHTML]().html;
                let ye = !1;
                const Pe = Ke.value && Ke.value[t.$text]() || "";
                for (let Qe = 0, Ye = Yt.length; Qe < Ye; Qe++) {
                  const lt = {
                    name: "option",
                    attributes: {
                      value: en[Qe] || Yt[Qe],
                      style: Ot
                    },
                    value: Yt[Qe]
                  };
                  en[Qe] === Pe && (lt.attributes.selected = ye = !0), Dt.push(lt);
                }
                ye || Dt.splice(0, 0, {
                  name: "option",
                  attributes: {
                    hidden: !0,
                    selected: !0
                  },
                  value: " "
                });
              }
              const Pt = {
                class: ["xfaSelect"],
                fieldId: Ke[t.$uid],
                dataId: Ke[t.$data] && Ke[t.$data][t.$uid] || Ke[t.$uid],
                style: ce,
                "aria-label": D(Ke),
                "aria-required": !1
              };
              return j(Ke) && (Pt["aria-required"] = !0, Pt.required = !0), this.open === "multiSelect" && (Pt.multiple = !0), e.HTMLResult.success({
                name: "label",
                attributes: {
                  class: ["xfaLabel"]
                },
                children: [{
                  name: "select",
                  children: Dt,
                  attributes: Pt
                }]
              });
            }
          }
          class $ extends t.XFAObject {
            constructor(I) {
              super(d, "color", !0), this.cSpace = (0, e.getStringOption)(I.cSpace, ["SRGB"]), this.id = I.id || "", this.use = I.use || "", this.usehref = I.usehref || "", this.value = I.value ? (0, e.getColor)(I.value) : "", this.extras = null;
            }
            [t.$hasSettableValue]() {
              return !1;
            }
            [t.$toStyle]() {
              return this.value ? y.Util.makeHexColor(this.value.r, this.value.g, this.value.b) : null;
            }
          }
          class k extends t.XFAObject {
            constructor(I) {
              super(d, "comb"), this.id = I.id || "", this.numberOfCells = (0, e.getInteger)({
                data: I.numberOfCells,
                defaultValue: 0,
                validate: (ce) => ce >= 0
              }), this.use = I.use || "", this.usehref = I.usehref || "";
            }
          }
          class H extends t.XFAObject {
            constructor(I) {
              super(d, "connect", !0), this.connection = I.connection || "", this.id = I.id || "", this.ref = I.ref || "", this.usage = (0, e.getStringOption)(I.usage, ["exportAndImport", "exportOnly", "importOnly"]), this.use = I.use || "", this.usehref = I.usehref || "", this.picture = null;
            }
          }
          class ne extends t.XFAObject {
            constructor(I) {
              super(d, "contentArea", !0), this.h = (0, e.getMeasurement)(I.h), this.id = I.id || "", this.name = I.name || "", this.relevant = (0, e.getRelevant)(I.relevant), this.use = I.use || "", this.usehref = I.usehref || "", this.w = (0, e.getMeasurement)(I.w), this.x = (0, e.getMeasurement)(I.x, "0pt"), this.y = (0, e.getMeasurement)(I.y, "0pt"), this.desc = null, this.extras = null;
            }
            [t.$toHTML](I) {
              const ce = (0, a.measureToString)(this.x), je = (0, a.measureToString)(this.y), Ke = {
                left: ce,
                top: je,
                width: (0, a.measureToString)(this.w),
                height: (0, a.measureToString)(this.h)
              }, ut = ["xfaContentarea"];
              return (0, a.isPrintOnly)(this) && ut.push("xfaPrintOnly"), e.HTMLResult.success({
                name: "div",
                children: [],
                attributes: {
                  style: Ke,
                  class: ut,
                  id: this[t.$uid]
                }
              });
            }
          }
          class ae extends t.XFAObject {
            constructor(I) {
              super(d, "corner", !0), this.id = I.id || "", this.inverted = (0, e.getInteger)({
                data: I.inverted,
                defaultValue: 0,
                validate: (ce) => ce === 1
              }), this.join = (0, e.getStringOption)(I.join, ["square", "round"]), this.presence = (0, e.getStringOption)(I.presence, ["visible", "hidden", "inactive", "invisible"]), this.radius = (0, e.getMeasurement)(I.radius), this.stroke = (0, e.getStringOption)(I.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]), this.thickness = (0, e.getMeasurement)(I.thickness, "0.5pt"), this.use = I.use || "", this.usehref = I.usehref || "", this.color = null, this.extras = null;
            }
            [t.$toStyle]() {
              const I = (0, a.toStyle)(this, "visibility");
              return I.radius = (0, a.measureToString)(this.join === "square" ? 0 : this.radius), I;
            }
          }
          class he extends t.ContentObject {
            constructor(I) {
              super(d, "date"), this.id = I.id || "", this.name = I.name || "", this.use = I.use || "", this.usehref = I.usehref || "";
            }
            [t.$finalize]() {
              const I = this[t.$content].trim();
              this[t.$content] = I ? new Date(I) : null;
            }
            [t.$toHTML](I) {
              return b(this[t.$content] ? this[t.$content].toString() : "");
            }
          }
          class ue extends t.ContentObject {
            constructor(I) {
              super(d, "dateTime"), this.id = I.id || "", this.name = I.name || "", this.use = I.use || "", this.usehref = I.usehref || "";
            }
            [t.$finalize]() {
              const I = this[t.$content].trim();
              this[t.$content] = I ? new Date(I) : null;
            }
            [t.$toHTML](I) {
              return b(this[t.$content] ? this[t.$content].toString() : "");
            }
          }
          class fe extends t.XFAObject {
            constructor(I) {
              super(d, "dateTimeEdit", !0), this.hScrollPolicy = (0, e.getStringOption)(I.hScrollPolicy, ["auto", "off", "on"]), this.id = I.id || "", this.picker = (0, e.getStringOption)(I.picker, ["host", "none"]), this.use = I.use || "", this.usehref = I.usehref || "", this.border = null, this.comb = null, this.extras = null, this.margin = null;
            }
            [t.$toHTML](I) {
              const ce = (0, a.toStyle)(this, "border", "font", "margin"), je = this[t.$getParent]()[t.$getParent](), Ke = {
                name: "input",
                attributes: {
                  type: "text",
                  fieldId: je[t.$uid],
                  dataId: je[t.$data] && je[t.$data][t.$uid] || je[t.$uid],
                  class: ["xfaTextfield"],
                  style: ce,
                  "aria-label": D(je),
                  "aria-required": !1
                }
              };
              return j(je) && (Ke.attributes["aria-required"] = !0, Ke.attributes.required = !0), e.HTMLResult.success({
                name: "label",
                attributes: {
                  class: ["xfaLabel"]
                },
                children: [Ke]
              });
            }
          }
          class me extends t.ContentObject {
            constructor(I) {
              super(d, "decimal"), this.fracDigits = (0, e.getInteger)({
                data: I.fracDigits,
                defaultValue: 2,
                validate: (ce) => !0
              }), this.id = I.id || "", this.leadDigits = (0, e.getInteger)({
                data: I.leadDigits,
                defaultValue: -1,
                validate: (ce) => !0
              }), this.name = I.name || "", this.use = I.use || "", this.usehref = I.usehref || "";
            }
            [t.$finalize]() {
              const I = parseFloat(this[t.$content].trim());
              this[t.$content] = isNaN(I) ? null : I;
            }
            [t.$toHTML](I) {
              return b(this[t.$content] !== null ? this[t.$content].toString() : "");
            }
          }
          class Fe extends t.XFAObject {
            constructor(I) {
              super(d, "defaultUi", !0), this.id = I.id || "", this.use = I.use || "", this.usehref = I.usehref || "", this.extras = null;
            }
          }
          class we extends t.XFAObject {
            constructor(I) {
              super(d, "desc", !0), this.id = I.id || "", this.use = I.use || "", this.usehref = I.usehref || "", this.boolean = new t.XFAObjectArray(), this.date = new t.XFAObjectArray(), this.dateTime = new t.XFAObjectArray(), this.decimal = new t.XFAObjectArray(), this.exData = new t.XFAObjectArray(), this.float = new t.XFAObjectArray(), this.image = new t.XFAObjectArray(), this.integer = new t.XFAObjectArray(), this.text = new t.XFAObjectArray(), this.time = new t.XFAObjectArray();
            }
          }
          class Ae extends t.OptionObject {
            constructor(I) {
              super(d, "digestMethod", ["", "SHA1", "SHA256", "SHA512", "RIPEMD160"]), this.id = I.id || "", this.use = I.use || "", this.usehref = I.usehref || "";
            }
          }
          class De extends t.XFAObject {
            constructor(I) {
              super(d, "digestMethods", !0), this.id = I.id || "", this.type = (0, e.getStringOption)(I.type, ["optional", "required"]), this.use = I.use || "", this.usehref = I.usehref || "", this.digestMethod = new t.XFAObjectArray();
            }
          }
          class xe extends t.XFAObject {
            constructor(I) {
              super(d, "draw", !0), this.anchorType = (0, e.getStringOption)(I.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = (0, e.getInteger)({
                data: I.colSpan,
                defaultValue: 1,
                validate: (ce) => ce >= 1 || ce === -1
              }), this.h = I.h ? (0, e.getMeasurement)(I.h) : "", this.hAlign = (0, e.getStringOption)(I.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = I.id || "", this.locale = I.locale || "", this.maxH = (0, e.getMeasurement)(I.maxH, "0pt"), this.maxW = (0, e.getMeasurement)(I.maxW, "0pt"), this.minH = (0, e.getMeasurement)(I.minH, "0pt"), this.minW = (0, e.getMeasurement)(I.minW, "0pt"), this.name = I.name || "", this.presence = (0, e.getStringOption)(I.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = (0, e.getRelevant)(I.relevant), this.rotate = (0, e.getInteger)({
                data: I.rotate,
                defaultValue: 0,
                validate: (ce) => ce % 90 === 0
              }), this.use = I.use || "", this.usehref = I.usehref || "", this.w = I.w ? (0, e.getMeasurement)(I.w) : "", this.x = (0, e.getMeasurement)(I.x, "0pt"), this.y = (0, e.getMeasurement)(I.y, "0pt"), this.assist = null, this.border = null, this.caption = null, this.desc = null, this.extras = null, this.font = null, this.keep = null, this.margin = null, this.para = null, this.traversal = null, this.ui = null, this.value = null, this.setProperty = new t.XFAObjectArray();
            }
            [t.$setValue](I) {
              X(this, I);
            }
            [t.$toHTML](I) {
              if (B(this), this.presence === "hidden" || this.presence === "inactive")
                return e.HTMLResult.EMPTY;
              (0, a.fixDimensions)(this), this[t.$pushPara]();
              const ce = this.w, je = this.h, {
                w: Ke,
                h: ut,
                isBroken: Ot
              } = (0, a.layoutNode)(this, I);
              if (Ke && this.w === "") {
                if (Ot && this[t.$getSubformParent]()[t.$isThereMoreWidth]())
                  return this[t.$popPara](), e.HTMLResult.FAILURE;
                this.w = Ke;
              }
              if (ut && this.h === "" && (this.h = ut), l(this), !(0, v.checkDimensions)(this, I))
                return this.w = ce, this.h = je, this[t.$popPara](), e.HTMLResult.FAILURE;
              _(this);
              const Dt = (0, a.toStyle)(this, "font", "hAlign", "dimensions", "position", "presence", "rotate", "anchorType", "border", "margin");
              (0, a.setMinMaxDimensions)(this, Dt), Dt.margin && (Dt.padding = Dt.margin, delete Dt.margin);
              const Pt = ["xfaDraw"];
              this.font && Pt.push("xfaFont"), (0, a.isPrintOnly)(this) && Pt.push("xfaPrintOnly");
              const jt = {
                style: Dt,
                id: this[t.$uid],
                class: Pt
              };
              this.name && (jt.xfaName = this.name);
              const Xt = {
                name: "div",
                attributes: jt,
                children: []
              };
              R(this, jt);
              const Zt = (0, a.computeBbox)(this, Xt, I), Yt = this.value ? this.value[t.$toHTML](I).html : null;
              return Yt === null ? (this.w = ce, this.h = je, this[t.$popPara](), e.HTMLResult.success((0, a.createWrapper)(this, Xt), Zt)) : (Xt.children.push(Yt), (0, a.setPara)(this, Dt, Yt), this.w = ce, this.h = je, this[t.$popPara](), e.HTMLResult.success((0, a.createWrapper)(this, Xt), Zt));
            }
          }
          class Te extends t.XFAObject {
            constructor(I) {
              super(d, "edge", !0), this.cap = (0, e.getStringOption)(I.cap, ["square", "butt", "round"]), this.id = I.id || "", this.presence = (0, e.getStringOption)(I.presence, ["visible", "hidden", "inactive", "invisible"]), this.stroke = (0, e.getStringOption)(I.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]), this.thickness = (0, e.getMeasurement)(I.thickness, "0.5pt"), this.use = I.use || "", this.usehref = I.usehref || "", this.color = null, this.extras = null;
            }
            [t.$toStyle]() {
              const I = (0, a.toStyle)(this, "visibility");
              if (Object.assign(I, {
                linecap: this.cap,
                width: (0, a.measureToString)(this.thickness),
                color: this.color ? this.color[t.$toStyle]() : "#000000",
                style: ""
              }), this.presence !== "visible")
                I.style = "none";
              else
                switch (this.stroke) {
                  case "solid":
                    I.style = "solid";
                    break;
                  case "dashDot":
                    I.style = "dashed";
                    break;
                  case "dashDotDot":
                    I.style = "dashed";
                    break;
                  case "dashed":
                    I.style = "dashed";
                    break;
                  case "dotted":
                    I.style = "dotted";
                    break;
                  case "embossed":
                    I.style = "ridge";
                    break;
                  case "etched":
                    I.style = "groove";
                    break;
                  case "lowered":
                    I.style = "inset";
                    break;
                  case "raised":
                    I.style = "outset";
                    break;
                }
              return I;
            }
          }
          class ve extends t.OptionObject {
            constructor(I) {
              super(d, "encoding", ["adbe.x509.rsa_sha1", "adbe.pkcs7.detached", "adbe.pkcs7.sha1"]), this.id = I.id || "", this.use = I.use || "", this.usehref = I.usehref || "";
            }
          }
          class Se extends t.XFAObject {
            constructor(I) {
              super(d, "encodings", !0), this.id = I.id || "", this.type = (0, e.getStringOption)(I.type, ["optional", "required"]), this.use = I.use || "", this.usehref = I.usehref || "", this.encoding = new t.XFAObjectArray();
            }
          }
          class be extends t.XFAObject {
            constructor(I) {
              super(d, "encrypt", !0), this.id = I.id || "", this.use = I.use || "", this.usehref = I.usehref || "", this.certificate = null;
            }
          }
          class Le extends t.XFAObject {
            constructor(I) {
              super(d, "encryptData", !0), this.id = I.id || "", this.operation = (0, e.getStringOption)(I.operation, ["encrypt", "decrypt"]), this.target = I.target || "", this.use = I.use || "", this.usehref = I.usehref || "", this.filter = null, this.manifest = null;
            }
          }
          class ze extends t.XFAObject {
            constructor(I) {
              super(d, "encryption", !0), this.id = I.id || "", this.type = (0, e.getStringOption)(I.type, ["optional", "required"]), this.use = I.use || "", this.usehref = I.usehref || "", this.certificate = new t.XFAObjectArray();
            }
          }
          class nt extends t.OptionObject {
            constructor(I) {
              super(d, "encryptionMethod", ["", "AES256-CBC", "TRIPLEDES-CBC", "AES128-CBC", "AES192-CBC"]), this.id = I.id || "", this.use = I.use || "", this.usehref = I.usehref || "";
            }
          }
          class Ue extends t.XFAObject {
            constructor(I) {
              super(d, "encryptionMethods", !0), this.id = I.id || "", this.type = (0, e.getStringOption)(I.type, ["optional", "required"]), this.use = I.use || "", this.usehref = I.usehref || "", this.encryptionMethod = new t.XFAObjectArray();
            }
          }
          class Oe extends t.XFAObject {
            constructor(I) {
              super(d, "event", !0), this.activity = (0, e.getStringOption)(I.activity, ["click", "change", "docClose", "docReady", "enter", "exit", "full", "indexChange", "initialize", "mouseDown", "mouseEnter", "mouseExit", "mouseUp", "postExecute", "postOpen", "postPrint", "postSave", "postSign", "postSubmit", "preExecute", "preOpen", "prePrint", "preSave", "preSign", "preSubmit", "ready", "validationState"]), this.id = I.id || "", this.listen = (0, e.getStringOption)(I.listen, ["refOnly", "refAndDescendents"]), this.name = I.name || "", this.ref = I.ref || "", this.use = I.use || "", this.usehref = I.usehref || "", this.extras = null, this.encryptData = null, this.execute = null, this.script = null, this.signData = null, this.submit = null;
            }
          }
          class _e extends t.ContentObject {
            constructor(I) {
              super(d, "exData"), this.contentType = I.contentType || "", this.href = I.href || "", this.id = I.id || "", this.maxLength = (0, e.getInteger)({
                data: I.maxLength,
                defaultValue: -1,
                validate: (ce) => ce >= -1
              }), this.name = I.name || "", this.rid = I.rid || "", this.transferEncoding = (0, e.getStringOption)(I.transferEncoding, ["none", "base64", "package"]), this.use = I.use || "", this.usehref = I.usehref || "";
            }
            [t.$isCDATAXml]() {
              return this.contentType === "text/html";
            }
            [t.$onChild](I) {
              return this.contentType === "text/html" && I[t.$namespaceId] === i.NamespaceIds.xhtml.id ? (this[t.$content] = I, !0) : this.contentType === "text/xml" ? (this[t.$content] = I, !0) : !1;
            }
            [t.$toHTML](I) {
              return this.contentType !== "text/html" || !this[t.$content] ? e.HTMLResult.EMPTY : this[t.$content][t.$toHTML](I);
            }
          }
          class at extends t.XFAObject {
            constructor(I) {
              super(d, "exObject", !0), this.archive = I.archive || "", this.classId = I.classId || "", this.codeBase = I.codeBase || "", this.codeType = I.codeType || "", this.id = I.id || "", this.name = I.name || "", this.use = I.use || "", this.usehref = I.usehref || "", this.extras = null, this.boolean = new t.XFAObjectArray(), this.date = new t.XFAObjectArray(), this.dateTime = new t.XFAObjectArray(), this.decimal = new t.XFAObjectArray(), this.exData = new t.XFAObjectArray(), this.exObject = new t.XFAObjectArray(), this.float = new t.XFAObjectArray(), this.image = new t.XFAObjectArray(), this.integer = new t.XFAObjectArray(), this.text = new t.XFAObjectArray(), this.time = new t.XFAObjectArray();
            }
          }
          class Je extends t.XFAObject {
            constructor(I) {
              super(d, "exclGroup", !0), this.access = (0, e.getStringOption)(I.access, ["open", "nonInteractive", "protected", "readOnly"]), this.accessKey = I.accessKey || "", this.anchorType = (0, e.getStringOption)(I.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = (0, e.getInteger)({
                data: I.colSpan,
                defaultValue: 1,
                validate: (ce) => ce >= 1 || ce === -1
              }), this.h = I.h ? (0, e.getMeasurement)(I.h) : "", this.hAlign = (0, e.getStringOption)(I.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = I.id || "", this.layout = (0, e.getStringOption)(I.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]), this.maxH = (0, e.getMeasurement)(I.maxH, "0pt"), this.maxW = (0, e.getMeasurement)(I.maxW, "0pt"), this.minH = (0, e.getMeasurement)(I.minH, "0pt"), this.minW = (0, e.getMeasurement)(I.minW, "0pt"), this.name = I.name || "", this.presence = (0, e.getStringOption)(I.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = (0, e.getRelevant)(I.relevant), this.use = I.use || "", this.usehref = I.usehref || "", this.w = I.w ? (0, e.getMeasurement)(I.w) : "", this.x = (0, e.getMeasurement)(I.x, "0pt"), this.y = (0, e.getMeasurement)(I.y, "0pt"), this.assist = null, this.bind = null, this.border = null, this.calculate = null, this.caption = null, this.desc = null, this.extras = null, this.margin = null, this.para = null, this.traversal = null, this.validate = null, this.connect = new t.XFAObjectArray(), this.event = new t.XFAObjectArray(), this.field = new t.XFAObjectArray(), this.setProperty = new t.XFAObjectArray();
            }
            [t.$isBindable]() {
              return !0;
            }
            [t.$hasSettableValue]() {
              return !0;
            }
            [t.$setValue](I) {
              for (const ce of this.field.children) {
                if (!ce.value) {
                  const je = new xn({});
                  ce[t.$appendChild](je), ce.value = je;
                }
                ce.value[t.$setValue](I);
              }
            }
            [t.$isThereMoreWidth]() {
              return this.layout.endsWith("-tb") && this[t.$extra].attempt === 0 && this[t.$extra].numberInLine > 0 || this[t.$getParent]()[t.$isThereMoreWidth]();
            }
            [t.$isSplittable]() {
              const I = this[t.$getSubformParent]();
              return I[t.$isSplittable]() ? this[t.$extra]._isSplittable !== void 0 ? this[t.$extra]._isSplittable : this.layout === "position" || this.layout.includes("row") ? (this[t.$extra]._isSplittable = !1, !1) : I.layout && I.layout.endsWith("-tb") && I[t.$extra].numberInLine !== 0 ? !1 : (this[t.$extra]._isSplittable = !0, !0) : !1;
            }
            [t.$flushHTML]() {
              return (0, v.flushHTML)(this);
            }
            [t.$addHTML](I, ce) {
              (0, v.addHTML)(this, I, ce);
            }
            [t.$getAvailableSpace]() {
              return (0, v.getAvailableSpace)(this);
            }
            [t.$toHTML](I) {
              if (B(this), this.presence === "hidden" || this.presence === "inactive" || this.h === 0 || this.w === 0)
                return e.HTMLResult.EMPTY;
              (0, a.fixDimensions)(this);
              const ce = [], je = {
                id: this[t.$uid],
                class: []
              };
              (0, a.setAccess)(this, je.class), this[t.$extra] || (this[t.$extra] = /* @__PURE__ */ Object.create(null)), Object.assign(this[t.$extra], {
                children: ce,
                attributes: je,
                attempt: 0,
                line: null,
                numberInLine: 0,
                availableSpace: {
                  width: Math.min(this.w || 1 / 0, I.width),
                  height: Math.min(this.h || 1 / 0, I.height)
                },
                width: 0,
                height: 0,
                prevHeight: 0,
                currentWidth: 0
              });
              const Ke = this[t.$isSplittable]();
              if (Ke || l(this), !(0, v.checkDimensions)(this, I))
                return e.HTMLResult.FAILURE;
              const ut = /* @__PURE__ */ new Set(["field"]);
              if (this.layout.includes("row")) {
                const Ye = this[t.$getSubformParent]().columnWidths;
                Array.isArray(Ye) && Ye.length > 0 && (this[t.$extra].columnWidths = Ye, this[t.$extra].currentColumn = 0);
              }
              const Ot = (0, a.toStyle)(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), Dt = ["xfaExclgroup"], Pt = (0, a.layoutClass)(this);
              Pt && Dt.push(Pt), (0, a.isPrintOnly)(this) && Dt.push("xfaPrintOnly"), je.style = Ot, je.class = Dt, this.name && (je.xfaName = this.name), this[t.$pushPara]();
              const jt = this.layout === "lr-tb" || this.layout === "rl-tb", Xt = jt ? n : 1;
              for (; this[t.$extra].attempt < Xt; this[t.$extra].attempt++) {
                jt && this[t.$extra].attempt === n - 1 && (this[t.$extra].numberInLine = 0);
                const Ye = this[t.$childrenToHTML]({
                  filter: ut,
                  include: !0
                });
                if (Ye.success)
                  break;
                if (Ye.isBreak())
                  return this[t.$popPara](), Ye;
                if (jt && this[t.$extra].attempt === 0 && this[t.$extra].numberInLine === 0 && !this[t.$getTemplateRoot]()[t.$extra].noLayoutFailure) {
                  this[t.$extra].attempt = Xt;
                  break;
                }
              }
              if (this[t.$popPara](), Ke || _(this), this[t.$extra].attempt === Xt)
                return Ke || delete this[t.$extra], e.HTMLResult.FAILURE;
              let Zt = 0, Yt = 0;
              this.margin && (Zt = this.margin.leftInset + this.margin.rightInset, Yt = this.margin.topInset + this.margin.bottomInset);
              const en = Math.max(this[t.$extra].width + Zt, this.w || 0), ye = Math.max(this[t.$extra].height + Yt, this.h || 0), Pe = [this.x, this.y, en, ye];
              this.w === "" && (Ot.width = (0, a.measureToString)(en)), this.h === "" && (Ot.height = (0, a.measureToString)(ye));
              const Qe = {
                name: "div",
                attributes: je,
                children: ce
              };
              return R(this, je), delete this[t.$extra], e.HTMLResult.success((0, a.createWrapper)(this, Qe), Pe);
            }
          }
          class ot extends t.XFAObject {
            constructor(I) {
              super(d, "execute"), this.connection = I.connection || "", this.executeType = (0, e.getStringOption)(I.executeType, ["import", "remerge"]), this.id = I.id || "", this.runAt = (0, e.getStringOption)(I.runAt, ["client", "both", "server"]), this.use = I.use || "", this.usehref = I.usehref || "";
            }
          }
          class mt extends t.XFAObject {
            constructor(I) {
              super(d, "extras", !0), this.id = I.id || "", this.name = I.name || "", this.use = I.use || "", this.usehref = I.usehref || "", this.boolean = new t.XFAObjectArray(), this.date = new t.XFAObjectArray(), this.dateTime = new t.XFAObjectArray(), this.decimal = new t.XFAObjectArray(), this.exData = new t.XFAObjectArray(), this.extras = new t.XFAObjectArray(), this.float = new t.XFAObjectArray(), this.image = new t.XFAObjectArray(), this.integer = new t.XFAObjectArray(), this.text = new t.XFAObjectArray(), this.time = new t.XFAObjectArray();
            }
          }
          class Ze extends t.XFAObject {
            constructor(I) {
              super(d, "field", !0), this.access = (0, e.getStringOption)(I.access, ["open", "nonInteractive", "protected", "readOnly"]), this.accessKey = I.accessKey || "", this.anchorType = (0, e.getStringOption)(I.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = (0, e.getInteger)({
                data: I.colSpan,
                defaultValue: 1,
                validate: (ce) => ce >= 1 || ce === -1
              }), this.h = I.h ? (0, e.getMeasurement)(I.h) : "", this.hAlign = (0, e.getStringOption)(I.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = I.id || "", this.locale = I.locale || "", this.maxH = (0, e.getMeasurement)(I.maxH, "0pt"), this.maxW = (0, e.getMeasurement)(I.maxW, "0pt"), this.minH = (0, e.getMeasurement)(I.minH, "0pt"), this.minW = (0, e.getMeasurement)(I.minW, "0pt"), this.name = I.name || "", this.presence = (0, e.getStringOption)(I.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = (0, e.getRelevant)(I.relevant), this.rotate = (0, e.getInteger)({
                data: I.rotate,
                defaultValue: 0,
                validate: (ce) => ce % 90 === 0
              }), this.use = I.use || "", this.usehref = I.usehref || "", this.w = I.w ? (0, e.getMeasurement)(I.w) : "", this.x = (0, e.getMeasurement)(I.x, "0pt"), this.y = (0, e.getMeasurement)(I.y, "0pt"), this.assist = null, this.bind = null, this.border = null, this.calculate = null, this.caption = null, this.desc = null, this.extras = null, this.font = null, this.format = null, this.items = new t.XFAObjectArray(2), this.keep = null, this.margin = null, this.para = null, this.traversal = null, this.ui = null, this.validate = null, this.value = null, this.bindItems = new t.XFAObjectArray(), this.connect = new t.XFAObjectArray(), this.event = new t.XFAObjectArray(), this.setProperty = new t.XFAObjectArray();
            }
            [t.$isBindable]() {
              return !0;
            }
            [t.$setValue](I) {
              X(this, I);
            }
            [t.$toHTML](I) {
              if (B(this), !this.ui) {
                this.ui = new An({}), this.ui[t.$globalData] = this[t.$globalData], this[t.$appendChild](this.ui);
                let Ye;
                switch (this.items.children.length) {
                  case 0:
                    Ye = new wn({}), this.ui.textEdit = Ye;
                    break;
                  case 1:
                    Ye = new re({}), this.ui.checkButton = Ye;
                    break;
                  case 2:
                    Ye = new ee({}), this.ui.choiceList = Ye;
                    break;
                }
                this.ui[t.$appendChild](Ye);
              }
              if (!this.ui || this.presence === "hidden" || this.presence === "inactive" || this.h === 0 || this.w === 0)
                return e.HTMLResult.EMPTY;
              this.caption && delete this.caption[t.$extra], this[t.$pushPara]();
              const ce = this.caption ? this.caption[t.$toHTML](I).html : null, je = this.w, Ke = this.h;
              let ut = 0, Ot = 0;
              this.margin && (ut = this.margin.leftInset + this.margin.rightInset, Ot = this.margin.topInset + this.margin.bottomInset);
              let Dt = null;
              if (this.w === "" || this.h === "") {
                let Ye = null, lt = null, Bt = 0, yt = 0;
                if (this.ui.checkButton)
                  Bt = yt = this.ui.checkButton.size;
                else {
                  const {
                    w: $t,
                    h: Ht
                  } = (0, a.layoutNode)(this, I);
                  $t !== null ? (Bt = $t, yt = Ht) : yt = (0, r.getMetrics)(this.font, !0).lineNoGap;
                }
                if (Dt = p(this.ui[t.$getExtra]()), Bt += Dt.w, yt += Dt.h, this.caption) {
                  const {
                    w: $t,
                    h: Ht,
                    isBroken: zt
                  } = this.caption[t.$getExtra](I);
                  if (zt && this[t.$getSubformParent]()[t.$isThereMoreWidth]())
                    return this[t.$popPara](), e.HTMLResult.FAILURE;
                  switch (Ye = $t, lt = Ht, this.caption.placement) {
                    case "left":
                    case "right":
                    case "inline":
                      Ye += Bt;
                      break;
                    case "top":
                    case "bottom":
                      lt += yt;
                      break;
                  }
                } else
                  Ye = Bt, lt = yt;
                Ye && this.w === "" && (Ye += ut, this.w = Math.min(this.maxW <= 0 ? 1 / 0 : this.maxW, this.minW + 1 < Ye ? Ye : this.minW)), lt && this.h === "" && (lt += Ot, this.h = Math.min(this.maxH <= 0 ? 1 / 0 : this.maxH, this.minH + 1 < lt ? lt : this.minH));
              }
              if (this[t.$popPara](), (0, a.fixDimensions)(this), l(this), !(0, v.checkDimensions)(this, I))
                return this.w = je, this.h = Ke, this[t.$popPara](), e.HTMLResult.FAILURE;
              _(this);
              const Pt = (0, a.toStyle)(this, "font", "dimensions", "position", "rotate", "anchorType", "presence", "margin", "hAlign");
              (0, a.setMinMaxDimensions)(this, Pt);
              const jt = ["xfaField"];
              this.font && jt.push("xfaFont"), (0, a.isPrintOnly)(this) && jt.push("xfaPrintOnly");
              const Xt = {
                style: Pt,
                id: this[t.$uid],
                class: jt
              };
              Pt.margin && (Pt.padding = Pt.margin, delete Pt.margin), (0, a.setAccess)(this, jt), this.name && (Xt.xfaName = this.name);
              const Zt = [], Yt = {
                name: "div",
                attributes: Xt,
                children: Zt
              };
              R(this, Xt);
              const en = this.border ? this.border[t.$toStyle]() : null, ye = (0, a.computeBbox)(this, Yt, I), Pe = this.ui[t.$toHTML]().html;
              if (!Pe)
                return Object.assign(Pt, en), e.HTMLResult.success((0, a.createWrapper)(this, Yt), ye);
              this[t.$tabIndex] && (Pe.children && Pe.children[0] ? Pe.children[0].attributes.tabindex = this[t.$tabIndex] : Pe.attributes.tabindex = this[t.$tabIndex]), Pe.attributes.style || (Pe.attributes.style = /* @__PURE__ */ Object.create(null));
              let Qe = null;
              if (this.ui.button ? (Pe.children.length === 1 && ([Qe] = Pe.children.splice(0, 1)), Object.assign(Pe.attributes.style, en)) : Object.assign(Pt, en), Zt.push(Pe), this.value) {
                if (this.ui.imageEdit)
                  Pe.children.push(this.value[t.$toHTML]().html);
                else if (!this.ui.button) {
                  let Ye = "";
                  if (this.value.exData)
                    Ye = this.value.exData[t.$text]();
                  else if (this.value.text)
                    Ye = this.value.text[t.$getExtra]();
                  else {
                    const lt = this.value[t.$toHTML]().html;
                    lt !== null && (Ye = lt.children[0].value);
                  }
                  this.ui.textEdit && this.value.text && this.value.text.maxChars && (Pe.children[0].attributes.maxLength = this.value.text.maxChars), Ye && (this.ui.numericEdit && (Ye = parseFloat(Ye), Ye = isNaN(Ye) ? "" : Ye.toString()), Pe.children[0].name === "textarea" ? Pe.children[0].attributes.textContent = Ye : Pe.children[0].attributes.value = Ye);
                }
              }
              if (!this.ui.imageEdit && Pe.children && Pe.children[0] && this.h) {
                Dt = Dt || p(this.ui[t.$getExtra]());
                let Ye = 0;
                if (this.caption && ["top", "bottom"].includes(this.caption.placement)) {
                  Ye = this.caption.reserve, Ye <= 0 && (Ye = this.caption[t.$getExtra](I).h);
                  const lt = this.h - Ye - Ot - Dt.h;
                  Pe.children[0].attributes.style.height = (0, a.measureToString)(lt);
                } else
                  Pe.children[0].attributes.style.height = "100%";
              }
              if (Qe && Pe.children.push(Qe), !ce)
                return Pe.attributes.class && Pe.attributes.class.push("xfaLeft"), this.w = je, this.h = Ke, e.HTMLResult.success((0, a.createWrapper)(this, Yt), ye);
              if (this.ui.button)
                return Pt.padding && delete Pt.padding, ce.name === "div" && (ce.name = "span"), Pe.children.push(ce), e.HTMLResult.success(Yt, ye);
              switch (this.ui.checkButton && (ce.attributes.class[0] = "xfaCaptionForCheckButton"), Pe.attributes.class || (Pe.attributes.class = []), Pe.children.splice(0, 0, ce), this.caption.placement) {
                case "left":
                  Pe.attributes.class.push("xfaLeft");
                  break;
                case "right":
                  Pe.attributes.class.push("xfaRight");
                  break;
                case "top":
                  Pe.attributes.class.push("xfaTop");
                  break;
                case "bottom":
                  Pe.attributes.class.push("xfaBottom");
                  break;
                case "inline":
                  Pe.attributes.class.push("xfaLeft");
                  break;
              }
              return this.w = je, this.h = Ke, e.HTMLResult.success((0, a.createWrapper)(this, Yt), ye);
            }
          }
          u.Field = Ze;
          class pt extends t.XFAObject {
            constructor(I) {
              super(d, "fill", !0), this.id = I.id || "", this.presence = (0, e.getStringOption)(I.presence, ["visible", "hidden", "inactive", "invisible"]), this.use = I.use || "", this.usehref = I.usehref || "", this.color = null, this.extras = null, this.linear = null, this.pattern = null, this.radial = null, this.solid = null, this.stipple = null;
            }
            [t.$toStyle]() {
              const I = this[t.$getParent](), je = I[t.$getParent]()[t.$getParent](), Ke = /* @__PURE__ */ Object.create(null);
              let ut = "color", Ot = ut;
              I instanceof L && (ut = "background-color", Ot = "background", je instanceof An && (Ke.backgroundColor = "white")), (I instanceof fn || I instanceof T) && (ut = Ot = "fill", Ke.fill = "white");
              for (const Dt of Object.getOwnPropertyNames(this)) {
                if (Dt === "extras" || Dt === "color")
                  continue;
                const Pt = this[Dt];
                if (!(Pt instanceof t.XFAObject))
                  continue;
                const jt = Pt[t.$toStyle](this.color);
                return jt && (Ke[jt.startsWith("#") ? ut : Ot] = jt), Ke;
              }
              if (this.color && this.color.value) {
                const Dt = this.color[t.$toStyle]();
                Ke[Dt.startsWith("#") ? ut : Ot] = Dt;
              }
              return Ke;
            }
          }
          class Ft extends t.XFAObject {
            constructor(I) {
              super(d, "filter", !0), this.addRevocationInfo = (0, e.getStringOption)(I.addRevocationInfo, ["", "required", "optional", "none"]), this.id = I.id || "", this.name = I.name || "", this.use = I.use || "", this.usehref = I.usehref || "", this.version = (0, e.getInteger)({
                data: this.version,
                defaultValue: 5,
                validate: (ce) => ce >= 1 && ce <= 5
              }), this.appearanceFilter = null, this.certificates = null, this.digestMethods = null, this.encodings = null, this.encryptionMethods = null, this.handler = null, this.lockDocument = null, this.mdp = null, this.reasons = null, this.timeStamp = null;
            }
          }
          class $e extends t.ContentObject {
            constructor(I) {
              super(d, "float"), this.id = I.id || "", this.name = I.name || "", this.use = I.use || "", this.usehref = I.usehref || "";
            }
            [t.$finalize]() {
              const I = parseFloat(this[t.$content].trim());
              this[t.$content] = isNaN(I) ? null : I;
            }
            [t.$toHTML](I) {
              return b(this[t.$content] !== null ? this[t.$content].toString() : "");
            }
          }
          class St extends t.XFAObject {
            constructor(I) {
              super(d, "font", !0), this.baselineShift = (0, e.getMeasurement)(I.baselineShift), this.fontHorizontalScale = (0, e.getFloat)({
                data: I.fontHorizontalScale,
                defaultValue: 100,
                validate: (ce) => ce >= 0
              }), this.fontVerticalScale = (0, e.getFloat)({
                data: I.fontVerticalScale,
                defaultValue: 100,
                validate: (ce) => ce >= 0
              }), this.id = I.id || "", this.kerningMode = (0, e.getStringOption)(I.kerningMode, ["none", "pair"]), this.letterSpacing = (0, e.getMeasurement)(I.letterSpacing, "0"), this.lineThrough = (0, e.getInteger)({
                data: I.lineThrough,
                defaultValue: 0,
                validate: (ce) => ce === 1 || ce === 2
              }), this.lineThroughPeriod = (0, e.getStringOption)(I.lineThroughPeriod, ["all", "word"]), this.overline = (0, e.getInteger)({
                data: I.overline,
                defaultValue: 0,
                validate: (ce) => ce === 1 || ce === 2
              }), this.overlinePeriod = (0, e.getStringOption)(I.overlinePeriod, ["all", "word"]), this.posture = (0, e.getStringOption)(I.posture, ["normal", "italic"]), this.size = (0, e.getMeasurement)(I.size, "10pt"), this.typeface = I.typeface || "Courier", this.underline = (0, e.getInteger)({
                data: I.underline,
                defaultValue: 0,
                validate: (ce) => ce === 1 || ce === 2
              }), this.underlinePeriod = (0, e.getStringOption)(I.underlinePeriod, ["all", "word"]), this.use = I.use || "", this.usehref = I.usehref || "", this.weight = (0, e.getStringOption)(I.weight, ["normal", "bold"]), this.extras = null, this.fill = null;
            }
            [t.$clean](I) {
              super[t.$clean](I), this[t.$globalData].usedTypefaces.add(this.typeface);
            }
            [t.$toStyle]() {
              const I = (0, a.toStyle)(this, "fill"), ce = I.color;
              return ce && (ce === "#000000" ? delete I.color : ce.startsWith("#") || (I.background = ce, I.backgroundClip = "text", I.color = "transparent")), this.baselineShift && (I.verticalAlign = (0, a.measureToString)(this.baselineShift)), I.fontKerning = this.kerningMode === "none" ? "none" : "normal", I.letterSpacing = (0, a.measureToString)(this.letterSpacing), this.lineThrough !== 0 && (I.textDecoration = "line-through", this.lineThrough === 2 && (I.textDecorationStyle = "double")), this.overline !== 0 && (I.textDecoration = "overline", this.overline === 2 && (I.textDecorationStyle = "double")), I.fontStyle = this.posture, I.fontSize = (0, a.measureToString)(0.99 * this.size), (0, a.setFontFamily)(this, this, this[t.$globalData].fontFinder, I), this.underline !== 0 && (I.textDecoration = "underline", this.underline === 2 && (I.textDecorationStyle = "double")), I.fontWeight = this.weight, I;
            }
          }
          class xt extends t.XFAObject {
            constructor(I) {
              super(d, "format", !0), this.id = I.id || "", this.use = I.use || "", this.usehref = I.usehref || "", this.extras = null, this.picture = null;
            }
          }
          class Ie extends t.StringObject {
            constructor(I) {
              super(d, "handler"), this.id = I.id || "", this.type = (0, e.getStringOption)(I.type, ["optional", "required"]), this.use = I.use || "", this.usehref = I.usehref || "";
            }
          }
          class Ve extends t.XFAObject {
            constructor(I) {
              super(d, "hyphenation"), this.excludeAllCaps = (0, e.getInteger)({
                data: I.excludeAllCaps,
                defaultValue: 0,
                validate: (ce) => ce === 1
              }), this.excludeInitialCap = (0, e.getInteger)({
                data: I.excludeInitialCap,
                defaultValue: 0,
                validate: (ce) => ce === 1
              }), this.hyphenate = (0, e.getInteger)({
                data: I.hyphenate,
                defaultValue: 0,
                validate: (ce) => ce === 1
              }), this.id = I.id || "", this.pushCharacterCount = (0, e.getInteger)({
                data: I.pushCharacterCount,
                defaultValue: 3,
                validate: (ce) => ce >= 0
              }), this.remainCharacterCount = (0, e.getInteger)({
                data: I.remainCharacterCount,
                defaultValue: 3,
                validate: (ce) => ce >= 0
              }), this.use = I.use || "", this.usehref = I.usehref || "", this.wordCharacterCount = (0, e.getInteger)({
                data: I.wordCharacterCount,
                defaultValue: 7,
                validate: (ce) => ce >= 0
              });
            }
          }
          class st extends t.StringObject {
            constructor(I) {
              super(d, "image"), this.aspect = (0, e.getStringOption)(I.aspect, ["fit", "actual", "height", "none", "width"]), this.contentType = I.contentType || "", this.href = I.href || "", this.id = I.id || "", this.name = I.name || "", this.transferEncoding = (0, e.getStringOption)(I.transferEncoding, ["base64", "none", "package"]), this.use = I.use || "", this.usehref = I.usehref || "";
            }
            [t.$toHTML]() {
              if (this.contentType && !m.has(this.contentType.toLowerCase()))
                return e.HTMLResult.EMPTY;
              let I = this[t.$globalData].images && this[t.$globalData].images.get(this.href);
              if (!I && (this.href || !this[t.$content]) || (!I && this.transferEncoding === "base64" && (I = (0, y.stringToBytes)(atob(this[t.$content]))), !I))
                return e.HTMLResult.EMPTY;
              if (!this.contentType) {
                for (const [ut, Ot] of C)
                  if (I.length > ut.length && ut.every((Dt, Pt) => Dt === I[Pt])) {
                    this.contentType = Ot;
                    break;
                  }
                if (!this.contentType)
                  return e.HTMLResult.EMPTY;
              }
              const ce = new Blob([I], {
                type: this.contentType
              });
              let je;
              switch (this.aspect) {
                case "fit":
                case "actual":
                  break;
                case "height":
                  je = {
                    height: "100%",
                    objectFit: "fill"
                  };
                  break;
                case "none":
                  je = {
                    width: "100%",
                    height: "100%",
                    objectFit: "fill"
                  };
                  break;
                case "width":
                  je = {
                    width: "100%",
                    objectFit: "fill"
                  };
                  break;
              }
              const Ke = this[t.$getParent]();
              return e.HTMLResult.success({
                name: "img",
                attributes: {
                  class: ["xfaImage"],
                  style: je,
                  src: URL.createObjectURL(ce),
                  alt: Ke ? D(Ke[t.$getParent]()) : null
                }
              });
            }
          }
          class ct extends t.XFAObject {
            constructor(I) {
              super(d, "imageEdit", !0), this.data = (0, e.getStringOption)(I.data, ["link", "embed"]), this.id = I.id || "", this.use = I.use || "", this.usehref = I.usehref || "", this.border = null, this.extras = null, this.margin = null;
            }
            [t.$toHTML](I) {
              return this.data === "embed" ? e.HTMLResult.success({
                name: "div",
                children: [],
                attributes: {}
              }) : e.HTMLResult.EMPTY;
            }
          }
          class Rt extends t.ContentObject {
            constructor(I) {
              super(d, "integer"), this.id = I.id || "", this.name = I.name || "", this.use = I.use || "", this.usehref = I.usehref || "";
            }
            [t.$finalize]() {
              const I = parseInt(this[t.$content].trim(), 10);
              this[t.$content] = isNaN(I) ? null : I;
            }
            [t.$toHTML](I) {
              return b(this[t.$content] !== null ? this[t.$content].toString() : "");
            }
          }
          class Lt extends t.XFAObject {
            constructor(I) {
              super(d, "issuers", !0), this.id = I.id || "", this.type = (0, e.getStringOption)(I.type, ["optional", "required"]), this.use = I.use || "", this.usehref = I.usehref || "", this.certificate = new t.XFAObjectArray();
            }
          }
          class Ge extends t.XFAObject {
            constructor(I) {
              super(d, "items", !0), this.id = I.id || "", this.name = I.name || "", this.presence = (0, e.getStringOption)(I.presence, ["visible", "hidden", "inactive", "invisible"]), this.ref = I.ref || "", this.save = (0, e.getInteger)({
                data: I.save,
                defaultValue: 0,
                validate: (ce) => ce === 1
              }), this.use = I.use || "", this.usehref = I.usehref || "", this.boolean = new t.XFAObjectArray(), this.date = new t.XFAObjectArray(), this.dateTime = new t.XFAObjectArray(), this.decimal = new t.XFAObjectArray(), this.exData = new t.XFAObjectArray(), this.float = new t.XFAObjectArray(), this.image = new t.XFAObjectArray(), this.integer = new t.XFAObjectArray(), this.text = new t.XFAObjectArray(), this.time = new t.XFAObjectArray();
            }
            [t.$toHTML]() {
              const I = [];
              for (const ce of this[t.$getChildren]())
                I.push(ce[t.$text]());
              return e.HTMLResult.success(I);
            }
          }
          u.Items = Ge;
          class Ne extends t.XFAObject {
            constructor(I) {
              super(d, "keep", !0), this.id = I.id || "";
              const ce = ["none", "contentArea", "pageArea"];
              this.intact = (0, e.getStringOption)(I.intact, ce), this.next = (0, e.getStringOption)(I.next, ce), this.previous = (0, e.getStringOption)(I.previous, ce), this.use = I.use || "", this.usehref = I.usehref || "", this.extras = null;
            }
          }
          class rt extends t.XFAObject {
            constructor(I) {
              super(d, "keyUsage");
              const ce = ["", "yes", "no"];
              this.crlSign = (0, e.getStringOption)(I.crlSign, ce), this.dataEncipherment = (0, e.getStringOption)(I.dataEncipherment, ce), this.decipherOnly = (0, e.getStringOption)(I.decipherOnly, ce), this.digitalSignature = (0, e.getStringOption)(I.digitalSignature, ce), this.encipherOnly = (0, e.getStringOption)(I.encipherOnly, ce), this.id = I.id || "", this.keyAgreement = (0, e.getStringOption)(I.keyAgreement, ce), this.keyCertSign = (0, e.getStringOption)(I.keyCertSign, ce), this.keyEncipherment = (0, e.getStringOption)(I.keyEncipherment, ce), this.nonRepudiation = (0, e.getStringOption)(I.nonRepudiation, ce), this.type = (0, e.getStringOption)(I.type, ["optional", "required"]), this.use = I.use || "", this.usehref = I.usehref || "";
            }
          }
          class tt extends t.XFAObject {
            constructor(I) {
              super(d, "line", !0), this.hand = (0, e.getStringOption)(I.hand, ["even", "left", "right"]), this.id = I.id || "", this.slope = (0, e.getStringOption)(I.slope, ["\\", "/"]), this.use = I.use || "", this.usehref = I.usehref || "", this.edge = null;
            }
            [t.$toHTML]() {
              const I = this[t.$getParent]()[t.$getParent](), ce = this.edge || new Te({}), je = ce[t.$toStyle](), Ke = /* @__PURE__ */ Object.create(null), ut = ce.presence === "visible" ? ce.thickness : 0;
              Ke.strokeWidth = (0, a.measureToString)(ut), Ke.stroke = je.color;
              let Ot, Dt, Pt, jt, Xt = "100%", Zt = "100%";
              I.w <= ut ? ([Ot, Dt, Pt, jt] = ["50%", 0, "50%", "100%"], Xt = Ke.strokeWidth) : I.h <= ut ? ([Ot, Dt, Pt, jt] = [0, "50%", "100%", "50%"], Zt = Ke.strokeWidth) : this.slope === "\\" ? [Ot, Dt, Pt, jt] = [0, 0, "100%", "100%"] : [Ot, Dt, Pt, jt] = [0, "100%", "100%", 0];
              const en = {
                name: "svg",
                children: [{
                  name: "line",
                  attributes: {
                    xmlns: c,
                    x1: Ot,
                    y1: Dt,
                    x2: Pt,
                    y2: jt,
                    style: Ke
                  }
                }],
                attributes: {
                  xmlns: c,
                  width: Xt,
                  height: Zt,
                  style: {
                    overflow: "visible"
                  }
                }
              };
              return w(I) ? e.HTMLResult.success({
                name: "div",
                attributes: {
                  style: {
                    display: "inline",
                    width: "100%",
                    height: "100%"
                  }
                },
                children: [en]
              }) : (en.attributes.style.position = "absolute", e.HTMLResult.success(en));
            }
          }
          class dt extends t.XFAObject {
            constructor(I) {
              super(d, "linear", !0), this.id = I.id || "", this.type = (0, e.getStringOption)(I.type, ["toRight", "toBottom", "toLeft", "toTop"]), this.use = I.use || "", this.usehref = I.usehref || "", this.color = null, this.extras = null;
            }
            [t.$toStyle](I) {
              I = I ? I[t.$toStyle]() : "#FFFFFF";
              const ce = this.type.replace(/([RBLT])/, " $1").toLowerCase(), je = this.color ? this.color[t.$toStyle]() : "#000000";
              return `linear-gradient(${ce}, ${I}, ${je})`;
            }
          }
          class Ct extends t.ContentObject {
            constructor(I) {
              super(d, "lockDocument"), this.id = I.id || "", this.type = (0, e.getStringOption)(I.type, ["optional", "required"]), this.use = I.use || "", this.usehref = I.usehref || "";
            }
            [t.$finalize]() {
              this[t.$content] = (0, e.getStringOption)(this[t.$content], ["auto", "0", "1"]);
            }
          }
          class bt extends t.XFAObject {
            constructor(I) {
              super(d, "manifest", !0), this.action = (0, e.getStringOption)(I.action, ["include", "all", "exclude"]), this.id = I.id || "", this.name = I.name || "", this.use = I.use || "", this.usehref = I.usehref || "", this.extras = null, this.ref = new t.XFAObjectArray();
            }
          }
          class ht extends t.XFAObject {
            constructor(I) {
              super(d, "margin", !0), this.bottomInset = (0, e.getMeasurement)(I.bottomInset, "0"), this.id = I.id || "", this.leftInset = (0, e.getMeasurement)(I.leftInset, "0"), this.rightInset = (0, e.getMeasurement)(I.rightInset, "0"), this.topInset = (0, e.getMeasurement)(I.topInset, "0"), this.use = I.use || "", this.usehref = I.usehref || "", this.extras = null;
            }
            [t.$toStyle]() {
              return {
                margin: (0, a.measureToString)(this.topInset) + " " + (0, a.measureToString)(this.rightInset) + " " + (0, a.measureToString)(this.bottomInset) + " " + (0, a.measureToString)(this.leftInset)
              };
            }
          }
          class vt extends t.XFAObject {
            constructor(I) {
              super(d, "mdp"), this.id = I.id || "", this.permissions = (0, e.getInteger)({
                data: I.permissions,
                defaultValue: 2,
                validate: (ce) => ce === 1 || ce === 3
              }), this.signatureType = (0, e.getStringOption)(I.signatureType, ["filler", "author"]), this.use = I.use || "", this.usehref = I.usehref || "";
            }
          }
          class _t extends t.XFAObject {
            constructor(I) {
              super(d, "medium"), this.id = I.id || "", this.imagingBBox = (0, e.getBBox)(I.imagingBBox), this.long = (0, e.getMeasurement)(I.long), this.orientation = (0, e.getStringOption)(I.orientation, ["portrait", "landscape"]), this.short = (0, e.getMeasurement)(I.short), this.stock = I.stock || "", this.trayIn = (0, e.getStringOption)(I.trayIn, ["auto", "delegate", "pageFront"]), this.trayOut = (0, e.getStringOption)(I.trayOut, ["auto", "delegate"]), this.use = I.use || "", this.usehref = I.usehref || "";
            }
          }
          class Nt extends t.XFAObject {
            constructor(I) {
              super(d, "message", !0), this.id = I.id || "", this.use = I.use || "", this.usehref = I.usehref || "", this.text = new t.XFAObjectArray();
            }
          }
          class Mt extends t.XFAObject {
            constructor(I) {
              super(d, "numericEdit", !0), this.hScrollPolicy = (0, e.getStringOption)(I.hScrollPolicy, ["auto", "off", "on"]), this.id = I.id || "", this.use = I.use || "", this.usehref = I.usehref || "", this.border = null, this.comb = null, this.extras = null, this.margin = null;
            }
            [t.$toHTML](I) {
              const ce = (0, a.toStyle)(this, "border", "font", "margin"), je = this[t.$getParent]()[t.$getParent](), Ke = {
                name: "input",
                attributes: {
                  type: "text",
                  fieldId: je[t.$uid],
                  dataId: je[t.$data] && je[t.$data][t.$uid] || je[t.$uid],
                  class: ["xfaTextfield"],
                  style: ce,
                  "aria-label": D(je),
                  "aria-required": !1
                }
              };
              return j(je) && (Ke.attributes["aria-required"] = !0, Ke.attributes.required = !0), e.HTMLResult.success({
                name: "label",
                attributes: {
                  class: ["xfaLabel"]
                },
                children: [Ke]
              });
            }
          }
          class Et extends t.XFAObject {
            constructor(I) {
              super(d, "occur", !0), this.id = I.id || "", this.initial = I.initial !== "" ? (0, e.getInteger)({
                data: I.initial,
                defaultValue: "",
                validate: (ce) => !0
              }) : "", this.max = I.max !== "" ? (0, e.getInteger)({
                data: I.max,
                defaultValue: 1,
                validate: (ce) => !0
              }) : "", this.min = I.min !== "" ? (0, e.getInteger)({
                data: I.min,
                defaultValue: 1,
                validate: (ce) => !0
              }) : "", this.use = I.use || "", this.usehref = I.usehref || "", this.extras = null;
            }
            [t.$clean]() {
              const I = this[t.$getParent](), ce = this.min;
              this.min === "" && (this.min = I instanceof et || I instanceof At ? 0 : 1), this.max === "" && (ce === "" ? this.max = I instanceof et || I instanceof At ? -1 : 1 : this.max = this.min), this.max !== -1 && this.max < this.min && (this.max = this.min), this.initial === "" && (this.initial = I instanceof Tn ? 1 : this.min);
            }
          }
          class Re extends t.StringObject {
            constructor(I) {
              super(d, "oid"), this.id = I.id || "", this.name = I.name || "", this.use = I.use || "", this.usehref = I.usehref || "";
            }
          }
          class We extends t.XFAObject {
            constructor(I) {
              super(d, "oids", !0), this.id = I.id || "", this.type = (0, e.getStringOption)(I.type, ["optional", "required"]), this.use = I.use || "", this.usehref = I.usehref || "", this.oid = new t.XFAObjectArray();
            }
          }
          class it extends t.XFAObject {
            constructor(I) {
              super(d, "overflow"), this.id = I.id || "", this.leader = I.leader || "", this.target = I.target || "", this.trailer = I.trailer || "", this.use = I.use || "", this.usehref = I.usehref || "";
            }
            [t.$getExtra]() {
              if (!this[t.$extra]) {
                const I = this[t.$getParent](), ce = this[t.$getTemplateRoot](), je = ce[t.$searchNode](this.target, I), Ke = ce[t.$searchNode](this.leader, I), ut = ce[t.$searchNode](this.trailer, I);
                this[t.$extra] = {
                  target: je && je[0] || null,
                  leader: Ke && Ke[0] || null,
                  trailer: ut && ut[0] || null,
                  addLeader: !1,
                  addTrailer: !1
                };
              }
              return this[t.$extra];
            }
          }
          class et extends t.XFAObject {
            constructor(I) {
              super(d, "pageArea", !0), this.blankOrNotBlank = (0, e.getStringOption)(I.blankOrNotBlank, ["any", "blank", "notBlank"]), this.id = I.id || "", this.initialNumber = (0, e.getInteger)({
                data: I.initialNumber,
                defaultValue: 1,
                validate: (ce) => !0
              }), this.name = I.name || "", this.numbered = (0, e.getInteger)({
                data: I.numbered,
                defaultValue: 1,
                validate: (ce) => !0
              }), this.oddOrEven = (0, e.getStringOption)(I.oddOrEven, ["any", "even", "odd"]), this.pagePosition = (0, e.getStringOption)(I.pagePosition, ["any", "first", "last", "only", "rest"]), this.relevant = (0, e.getRelevant)(I.relevant), this.use = I.use || "", this.usehref = I.usehref || "", this.desc = null, this.extras = null, this.medium = null, this.occur = null, this.area = new t.XFAObjectArray(), this.contentArea = new t.XFAObjectArray(), this.draw = new t.XFAObjectArray(), this.exclGroup = new t.XFAObjectArray(), this.field = new t.XFAObjectArray(), this.subform = new t.XFAObjectArray();
            }
            [t.$isUsable]() {
              return this[t.$extra] ? !this.occur || this.occur.max === -1 || this[t.$extra].numberOfUse < this.occur.max : (this[t.$extra] = {
                numberOfUse: 0
              }, !0);
            }
            [t.$cleanPage]() {
              delete this[t.$extra];
            }
            [t.$getNextPage]() {
              this[t.$extra] || (this[t.$extra] = {
                numberOfUse: 0
              });
              const I = this[t.$getParent]();
              return I.relation === "orderedOccurrence" && this[t.$isUsable]() ? (this[t.$extra].numberOfUse += 1, this) : I[t.$getNextPage]();
            }
            [t.$getAvailableSpace]() {
              return this[t.$extra].space || {
                width: 0,
                height: 0
              };
            }
            [t.$toHTML]() {
              this[t.$extra] || (this[t.$extra] = {
                numberOfUse: 1
              });
              const I = [];
              this[t.$extra].children = I;
              const ce = /* @__PURE__ */ Object.create(null);
              if (this.medium && this.medium.short && this.medium.long) {
                if (ce.width = (0, a.measureToString)(this.medium.short), ce.height = (0, a.measureToString)(this.medium.long), this[t.$extra].space = {
                  width: this.medium.short,
                  height: this.medium.long
                }, this.medium.orientation === "landscape") {
                  const je = ce.width;
                  ce.width = ce.height, ce.height = je, this[t.$extra].space = {
                    width: this.medium.long,
                    height: this.medium.short
                  };
                }
              } else
                (0, y.warn)("XFA - No medium specified in pageArea: please file a bug.");
              return this[t.$childrenToHTML]({
                filter: /* @__PURE__ */ new Set(["area", "draw", "field", "subform"]),
                include: !0
              }), this[t.$childrenToHTML]({
                filter: /* @__PURE__ */ new Set(["contentArea"]),
                include: !0
              }), e.HTMLResult.success({
                name: "div",
                children: I,
                attributes: {
                  class: ["xfaPage"],
                  id: this[t.$uid],
                  style: ce,
                  xfaName: this.name
                }
              });
            }
          }
          class At extends t.XFAObject {
            constructor(I) {
              super(d, "pageSet", !0), this.duplexImposition = (0, e.getStringOption)(I.duplexImposition, ["longEdge", "shortEdge"]), this.id = I.id || "", this.name = I.name || "", this.relation = (0, e.getStringOption)(I.relation, ["orderedOccurrence", "duplexPaginated", "simplexPaginated"]), this.relevant = (0, e.getRelevant)(I.relevant), this.use = I.use || "", this.usehref = I.usehref || "", this.extras = null, this.occur = null, this.pageArea = new t.XFAObjectArray(), this.pageSet = new t.XFAObjectArray();
            }
            [t.$cleanPage]() {
              for (const I of this.pageArea.children)
                I[t.$cleanPage]();
              for (const I of this.pageSet.children)
                I[t.$cleanPage]();
            }
            [t.$isUsable]() {
              return !this.occur || this.occur.max === -1 || this[t.$extra].numberOfUse < this.occur.max;
            }
            [t.$getNextPage]() {
              if (this[t.$extra] || (this[t.$extra] = {
                numberOfUse: 1,
                pageIndex: -1,
                pageSetIndex: -1
              }), this.relation === "orderedOccurrence") {
                if (this[t.$extra].pageIndex + 1 < this.pageArea.children.length)
                  return this[t.$extra].pageIndex += 1, this.pageArea.children[this[t.$extra].pageIndex][t.$getNextPage]();
                if (this[t.$extra].pageSetIndex + 1 < this.pageSet.children.length)
                  return this[t.$extra].pageSetIndex += 1, this.pageSet.children[this[t.$extra].pageSetIndex][t.$getNextPage]();
                if (this[t.$isUsable]())
                  return this[t.$extra].numberOfUse += 1, this[t.$extra].pageIndex = -1, this[t.$extra].pageSetIndex = -1, this[t.$getNextPage]();
                const ut = this[t.$getParent]();
                return ut instanceof At ? ut[t.$getNextPage]() : (this[t.$cleanPage](), this[t.$getNextPage]());
              }
              const I = this[t.$getTemplateRoot]()[t.$extra].pageNumber, ce = I % 2 === 0 ? "even" : "odd", je = I === 0 ? "first" : "rest";
              let Ke = this.pageArea.children.find((ut) => ut.oddOrEven === ce && ut.pagePosition === je);
              return Ke || (Ke = this.pageArea.children.find((ut) => ut.oddOrEven === "any" && ut.pagePosition === je), Ke) || (Ke = this.pageArea.children.find((ut) => ut.oddOrEven === "any" && ut.pagePosition === "any"), Ke) ? Ke : this.pageArea.children[0];
            }
          }
          class It extends t.XFAObject {
            constructor(I) {
              super(d, "para", !0), this.hAlign = (0, e.getStringOption)(I.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = I.id || "", this.lineHeight = I.lineHeight ? (0, e.getMeasurement)(I.lineHeight, "0pt") : "", this.marginLeft = I.marginLeft ? (0, e.getMeasurement)(I.marginLeft, "0pt") : "", this.marginRight = I.marginRight ? (0, e.getMeasurement)(I.marginRight, "0pt") : "", this.orphans = (0, e.getInteger)({
                data: I.orphans,
                defaultValue: 0,
                validate: (ce) => ce >= 0
              }), this.preserve = I.preserve || "", this.radixOffset = I.radixOffset ? (0, e.getMeasurement)(I.radixOffset, "0pt") : "", this.spaceAbove = I.spaceAbove ? (0, e.getMeasurement)(I.spaceAbove, "0pt") : "", this.spaceBelow = I.spaceBelow ? (0, e.getMeasurement)(I.spaceBelow, "0pt") : "", this.tabDefault = I.tabDefault ? (0, e.getMeasurement)(this.tabDefault) : "", this.tabStops = (I.tabStops || "").trim().split(/\s+/).map((ce, je) => je % 2 === 1 ? (0, e.getMeasurement)(ce) : ce), this.textIndent = I.textIndent ? (0, e.getMeasurement)(I.textIndent, "0pt") : "", this.use = I.use || "", this.usehref = I.usehref || "", this.vAlign = (0, e.getStringOption)(I.vAlign, ["top", "bottom", "middle"]), this.widows = (0, e.getInteger)({
                data: I.widows,
                defaultValue: 0,
                validate: (ce) => ce >= 0
              }), this.hyphenation = null;
            }
            [t.$toStyle]() {
              const I = (0, a.toStyle)(this, "hAlign");
              return this.marginLeft !== "" && (I.paddingLeft = (0, a.measureToString)(this.marginLeft)), this.marginRight !== "" && (I.paddingight = (0, a.measureToString)(this.marginRight)), this.spaceAbove !== "" && (I.paddingTop = (0, a.measureToString)(this.spaceAbove)), this.spaceBelow !== "" && (I.paddingBottom = (0, a.measureToString)(this.spaceBelow)), this.textIndent !== "" && (I.textIndent = (0, a.measureToString)(this.textIndent), (0, a.fixTextIndent)(I)), this.lineHeight > 0 && (I.lineHeight = (0, a.measureToString)(this.lineHeight)), this.tabDefault !== "" && (I.tabSize = (0, a.measureToString)(this.tabDefault)), this.tabStops.length > 0, this.hyphenatation && Object.assign(I, this.hyphenatation[t.$toStyle]()), I;
            }
          }
          class Vt extends t.XFAObject {
            constructor(I) {
              super(d, "passwordEdit", !0), this.hScrollPolicy = (0, e.getStringOption)(I.hScrollPolicy, ["auto", "off", "on"]), this.id = I.id || "", this.passwordChar = I.passwordChar || "*", this.use = I.use || "", this.usehref = I.usehref || "", this.border = null, this.extras = null, this.margin = null;
            }
          }
          class Ut extends t.XFAObject {
            constructor(I) {
              super(d, "pattern", !0), this.id = I.id || "", this.type = (0, e.getStringOption)(I.type, ["crossHatch", "crossDiagonal", "diagonalLeft", "diagonalRight", "horizontal", "vertical"]), this.use = I.use || "", this.usehref = I.usehref || "", this.color = null, this.extras = null;
            }
            [t.$toStyle](I) {
              I = I ? I[t.$toStyle]() : "#FFFFFF";
              const ce = this.color ? this.color[t.$toStyle]() : "#000000", je = 5, Ke = "repeating-linear-gradient", ut = `${I},${I} ${je}px,${ce} ${je}px,${ce} ${2 * je}px`;
              switch (this.type) {
                case "crossHatch":
                  return `${Ke}(to top,${ut}) ${Ke}(to right,${ut})`;
                case "crossDiagonal":
                  return `${Ke}(45deg,${ut}) ${Ke}(-45deg,${ut})`;
                case "diagonalLeft":
                  return `${Ke}(45deg,${ut})`;
                case "diagonalRight":
                  return `${Ke}(-45deg,${ut})`;
                case "horizontal":
                  return `${Ke}(to top,${ut})`;
                case "vertical":
                  return `${Ke}(to right,${ut})`;
              }
              return "";
            }
          }
          class Wt extends t.StringObject {
            constructor(I) {
              super(d, "picture"), this.id = I.id || "", this.use = I.use || "", this.usehref = I.usehref || "";
            }
          }
          class Kt extends t.XFAObject {
            constructor(I) {
              super(d, "proto", !0), this.appearanceFilter = new t.XFAObjectArray(), this.arc = new t.XFAObjectArray(), this.area = new t.XFAObjectArray(), this.assist = new t.XFAObjectArray(), this.barcode = new t.XFAObjectArray(), this.bindItems = new t.XFAObjectArray(), this.bookend = new t.XFAObjectArray(), this.boolean = new t.XFAObjectArray(), this.border = new t.XFAObjectArray(), this.break = new t.XFAObjectArray(), this.breakAfter = new t.XFAObjectArray(), this.breakBefore = new t.XFAObjectArray(), this.button = new t.XFAObjectArray(), this.calculate = new t.XFAObjectArray(), this.caption = new t.XFAObjectArray(), this.certificate = new t.XFAObjectArray(), this.certificates = new t.XFAObjectArray(), this.checkButton = new t.XFAObjectArray(), this.choiceList = new t.XFAObjectArray(), this.color = new t.XFAObjectArray(), this.comb = new t.XFAObjectArray(), this.connect = new t.XFAObjectArray(), this.contentArea = new t.XFAObjectArray(), this.corner = new t.XFAObjectArray(), this.date = new t.XFAObjectArray(), this.dateTime = new t.XFAObjectArray(), this.dateTimeEdit = new t.XFAObjectArray(), this.decimal = new t.XFAObjectArray(), this.defaultUi = new t.XFAObjectArray(), this.desc = new t.XFAObjectArray(), this.digestMethod = new t.XFAObjectArray(), this.digestMethods = new t.XFAObjectArray(), this.draw = new t.XFAObjectArray(), this.edge = new t.XFAObjectArray(), this.encoding = new t.XFAObjectArray(), this.encodings = new t.XFAObjectArray(), this.encrypt = new t.XFAObjectArray(), this.encryptData = new t.XFAObjectArray(), this.encryption = new t.XFAObjectArray(), this.encryptionMethod = new t.XFAObjectArray(), this.encryptionMethods = new t.XFAObjectArray(), this.event = new t.XFAObjectArray(), this.exData = new t.XFAObjectArray(), this.exObject = new t.XFAObjectArray(), this.exclGroup = new t.XFAObjectArray(), this.execute = new t.XFAObjectArray(), this.extras = new t.XFAObjectArray(), this.field = new t.XFAObjectArray(), this.fill = new t.XFAObjectArray(), this.filter = new t.XFAObjectArray(), this.float = new t.XFAObjectArray(), this.font = new t.XFAObjectArray(), this.format = new t.XFAObjectArray(), this.handler = new t.XFAObjectArray(), this.hyphenation = new t.XFAObjectArray(), this.image = new t.XFAObjectArray(), this.imageEdit = new t.XFAObjectArray(), this.integer = new t.XFAObjectArray(), this.issuers = new t.XFAObjectArray(), this.items = new t.XFAObjectArray(), this.keep = new t.XFAObjectArray(), this.keyUsage = new t.XFAObjectArray(), this.line = new t.XFAObjectArray(), this.linear = new t.XFAObjectArray(), this.lockDocument = new t.XFAObjectArray(), this.manifest = new t.XFAObjectArray(), this.margin = new t.XFAObjectArray(), this.mdp = new t.XFAObjectArray(), this.medium = new t.XFAObjectArray(), this.message = new t.XFAObjectArray(), this.numericEdit = new t.XFAObjectArray(), this.occur = new t.XFAObjectArray(), this.oid = new t.XFAObjectArray(), this.oids = new t.XFAObjectArray(), this.overflow = new t.XFAObjectArray(), this.pageArea = new t.XFAObjectArray(), this.pageSet = new t.XFAObjectArray(), this.para = new t.XFAObjectArray(), this.passwordEdit = new t.XFAObjectArray(), this.pattern = new t.XFAObjectArray(), this.picture = new t.XFAObjectArray(), this.radial = new t.XFAObjectArray(), this.reason = new t.XFAObjectArray(), this.reasons = new t.XFAObjectArray(), this.rectangle = new t.XFAObjectArray(), this.ref = new t.XFAObjectArray(), this.script = new t.XFAObjectArray(), this.setProperty = new t.XFAObjectArray(), this.signData = new t.XFAObjectArray(), this.signature = new t.XFAObjectArray(), this.signing = new t.XFAObjectArray(), this.solid = new t.XFAObjectArray(), this.speak = new t.XFAObjectArray(), this.stipple = new t.XFAObjectArray(), this.subform = new t.XFAObjectArray(), this.subformSet = new t.XFAObjectArray(), this.subjectDN = new t.XFAObjectArray(), this.subjectDNs = new t.XFAObjectArray(), this.submit = new t.XFAObjectArray(), this.text = new t.XFAObjectArray(), this.textEdit = new t.XFAObjectArray(), this.time = new t.XFAObjectArray(), this.timeStamp = new t.XFAObjectArray(), this.toolTip = new t.XFAObjectArray(), this.traversal = new t.XFAObjectArray(), this.traverse = new t.XFAObjectArray(), this.ui = new t.XFAObjectArray(), this.validate = new t.XFAObjectArray(), this.value = new t.XFAObjectArray(), this.variables = new t.XFAObjectArray();
            }
          }
          class rn extends t.XFAObject {
            constructor(I) {
              super(d, "radial", !0), this.id = I.id || "", this.type = (0, e.getStringOption)(I.type, ["toEdge", "toCenter"]), this.use = I.use || "", this.usehref = I.usehref || "", this.color = null, this.extras = null;
            }
            [t.$toStyle](I) {
              I = I ? I[t.$toStyle]() : "#FFFFFF";
              const ce = this.color ? this.color[t.$toStyle]() : "#000000";
              return `radial-gradient(circle at center, ${this.type === "toEdge" ? `${I},${ce}` : `${ce},${I}`})`;
            }
          }
          class ln extends t.StringObject {
            constructor(I) {
              super(d, "reason"), this.id = I.id || "", this.name = I.name || "", this.use = I.use || "", this.usehref = I.usehref || "";
            }
          }
          class Cn extends t.XFAObject {
            constructor(I) {
              super(d, "reasons", !0), this.id = I.id || "", this.type = (0, e.getStringOption)(I.type, ["optional", "required"]), this.use = I.use || "", this.usehref = I.usehref || "", this.reason = new t.XFAObjectArray();
            }
          }
          class fn extends t.XFAObject {
            constructor(I) {
              super(d, "rectangle", !0), this.hand = (0, e.getStringOption)(I.hand, ["even", "left", "right"]), this.id = I.id || "", this.use = I.use || "", this.usehref = I.usehref || "", this.corner = new t.XFAObjectArray(4), this.edge = new t.XFAObjectArray(4), this.fill = null;
            }
            [t.$toHTML]() {
              const I = this.edge.children.length ? this.edge.children[0] : new Te({}), ce = I[t.$toStyle](), je = /* @__PURE__ */ Object.create(null);
              this.fill && this.fill.presence === "visible" ? Object.assign(je, this.fill[t.$toStyle]()) : je.fill = "transparent", je.strokeWidth = (0, a.measureToString)(I.presence === "visible" ? I.thickness : 0), je.stroke = ce.color;
              const ut = (this.corner.children.length ? this.corner.children[0] : new ae({}))[t.$toStyle](), Dt = {
                name: "svg",
                children: [{
                  name: "rect",
                  attributes: {
                    xmlns: c,
                    width: "100%",
                    height: "100%",
                    x: 0,
                    y: 0,
                    rx: ut.radius,
                    ry: ut.radius,
                    style: je
                  }
                }],
                attributes: {
                  xmlns: c,
                  style: {
                    overflow: "visible"
                  },
                  width: "100%",
                  height: "100%"
                }
              }, Pt = this[t.$getParent]()[t.$getParent]();
              return w(Pt) ? e.HTMLResult.success({
                name: "div",
                attributes: {
                  style: {
                    display: "inline",
                    width: "100%",
                    height: "100%"
                  }
                },
                children: [Dt]
              }) : (Dt.attributes.style.position = "absolute", e.HTMLResult.success(Dt));
            }
          }
          class Fn extends t.StringObject {
            constructor(I) {
              super(d, "ref"), this.id = I.id || "", this.use = I.use || "", this.usehref = I.usehref || "";
            }
          }
          class yn extends t.StringObject {
            constructor(I) {
              super(d, "script"), this.binding = I.binding || "", this.contentType = I.contentType || "", this.id = I.id || "", this.name = I.name || "", this.runAt = (0, e.getStringOption)(I.runAt, ["client", "both", "server"]), this.use = I.use || "", this.usehref = I.usehref || "";
            }
          }
          class Dn extends t.XFAObject {
            constructor(I) {
              super(d, "setProperty"), this.connection = I.connection || "", this.ref = I.ref || "", this.target = I.target || "";
            }
          }
          u.SetProperty = Dn;
          class En extends t.XFAObject {
            constructor(I) {
              super(d, "signData", !0), this.id = I.id || "", this.operation = (0, e.getStringOption)(I.operation, ["sign", "clear", "verify"]), this.ref = I.ref || "", this.target = I.target || "", this.use = I.use || "", this.usehref = I.usehref || "", this.filter = null, this.manifest = null;
            }
          }
          class Bn extends t.XFAObject {
            constructor(I) {
              super(d, "signature", !0), this.id = I.id || "", this.type = (0, e.getStringOption)(I.type, ["PDF1.3", "PDF1.6"]), this.use = I.use || "", this.usehref = I.usehref || "", this.border = null, this.extras = null, this.filter = null, this.manifest = null, this.margin = null;
            }
          }
          class Ln extends t.XFAObject {
            constructor(I) {
              super(d, "signing", !0), this.id = I.id || "", this.type = (0, e.getStringOption)(I.type, ["optional", "required"]), this.use = I.use || "", this.usehref = I.usehref || "", this.certificate = new t.XFAObjectArray();
            }
          }
          class vn extends t.XFAObject {
            constructor(I) {
              super(d, "solid", !0), this.id = I.id || "", this.use = I.use || "", this.usehref = I.usehref || "", this.extras = null;
            }
            [t.$toStyle](I) {
              return I ? I[t.$toStyle]() : "#FFFFFF";
            }
          }
          class kn extends t.StringObject {
            constructor(I) {
              super(d, "speak"), this.disable = (0, e.getInteger)({
                data: I.disable,
                defaultValue: 0,
                validate: (ce) => ce === 1
              }), this.id = I.id || "", this.priority = (0, e.getStringOption)(I.priority, ["custom", "caption", "name", "toolTip"]), this.rid = I.rid || "", this.use = I.use || "", this.usehref = I.usehref || "";
            }
          }
          class On extends t.XFAObject {
            constructor(I) {
              super(d, "stipple", !0), this.id = I.id || "", this.rate = (0, e.getInteger)({
                data: I.rate,
                defaultValue: 50,
                validate: (ce) => ce >= 0 && ce <= 100
              }), this.use = I.use || "", this.usehref = I.usehref || "", this.color = null, this.extras = null;
            }
            [t.$toStyle](I) {
              const ce = this.rate / 100;
              return y.Util.makeHexColor(Math.round(I.value.r * (1 - ce) + this.value.r * ce), Math.round(I.value.g * (1 - ce) + this.value.g * ce), Math.round(I.value.b * (1 - ce) + this.value.b * ce));
            }
          }
          class mn extends t.XFAObject {
            constructor(I) {
              super(d, "subform", !0), this.access = (0, e.getStringOption)(I.access, ["open", "nonInteractive", "protected", "readOnly"]), this.allowMacro = (0, e.getInteger)({
                data: I.allowMacro,
                defaultValue: 0,
                validate: (ce) => ce === 1
              }), this.anchorType = (0, e.getStringOption)(I.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = (0, e.getInteger)({
                data: I.colSpan,
                defaultValue: 1,
                validate: (ce) => ce >= 1 || ce === -1
              }), this.columnWidths = (I.columnWidths || "").trim().split(/\s+/).map((ce) => ce === "-1" ? -1 : (0, e.getMeasurement)(ce)), this.h = I.h ? (0, e.getMeasurement)(I.h) : "", this.hAlign = (0, e.getStringOption)(I.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = I.id || "", this.layout = (0, e.getStringOption)(I.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]), this.locale = I.locale || "", this.maxH = (0, e.getMeasurement)(I.maxH, "0pt"), this.maxW = (0, e.getMeasurement)(I.maxW, "0pt"), this.mergeMode = (0, e.getStringOption)(I.mergeMode, ["consumeData", "matchTemplate"]), this.minH = (0, e.getMeasurement)(I.minH, "0pt"), this.minW = (0, e.getMeasurement)(I.minW, "0pt"), this.name = I.name || "", this.presence = (0, e.getStringOption)(I.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = (0, e.getRelevant)(I.relevant), this.restoreState = (0, e.getStringOption)(I.restoreState, ["manual", "auto"]), this.scope = (0, e.getStringOption)(I.scope, ["name", "none"]), this.use = I.use || "", this.usehref = I.usehref || "", this.w = I.w ? (0, e.getMeasurement)(I.w) : "", this.x = (0, e.getMeasurement)(I.x, "0pt"), this.y = (0, e.getMeasurement)(I.y, "0pt"), this.assist = null, this.bind = null, this.bookend = null, this.border = null, this.break = null, this.calculate = null, this.desc = null, this.extras = null, this.keep = null, this.margin = null, this.occur = null, this.overflow = null, this.pageSet = null, this.para = null, this.traversal = null, this.validate = null, this.variables = null, this.area = new t.XFAObjectArray(), this.breakAfter = new t.XFAObjectArray(), this.breakBefore = new t.XFAObjectArray(), this.connect = new t.XFAObjectArray(), this.draw = new t.XFAObjectArray(), this.event = new t.XFAObjectArray(), this.exObject = new t.XFAObjectArray(), this.exclGroup = new t.XFAObjectArray(), this.field = new t.XFAObjectArray(), this.proto = new t.XFAObjectArray(), this.setProperty = new t.XFAObjectArray(), this.subform = new t.XFAObjectArray(), this.subformSet = new t.XFAObjectArray();
            }
            [t.$getSubformParent]() {
              const I = this[t.$getParent]();
              return I instanceof hn ? I[t.$getSubformParent]() : I;
            }
            [t.$isBindable]() {
              return !0;
            }
            [t.$isThereMoreWidth]() {
              return this.layout.endsWith("-tb") && this[t.$extra].attempt === 0 && this[t.$extra].numberInLine > 0 || this[t.$getParent]()[t.$isThereMoreWidth]();
            }
            *[t.$getContainedChildren]() {
              yield* M(this);
            }
            [t.$flushHTML]() {
              return (0, v.flushHTML)(this);
            }
            [t.$addHTML](I, ce) {
              (0, v.addHTML)(this, I, ce);
            }
            [t.$getAvailableSpace]() {
              return (0, v.getAvailableSpace)(this);
            }
            [t.$isSplittable]() {
              const I = this[t.$getSubformParent]();
              return I[t.$isSplittable]() ? this[t.$extra]._isSplittable !== void 0 ? this[t.$extra]._isSplittable : this.layout === "position" || this.layout.includes("row") ? (this[t.$extra]._isSplittable = !1, !1) : this.keep && this.keep.intact !== "none" ? (this[t.$extra]._isSplittable = !1, !1) : I.layout && I.layout.endsWith("-tb") && I[t.$extra].numberInLine !== 0 ? !1 : (this[t.$extra]._isSplittable = !0, !0) : !1;
            }
            [t.$toHTML](I) {
              if (B(this), this.break) {
                if (this.break.after !== "auto" || this.break.afterTarget !== "") {
                  const yt = new J({
                    targetType: this.break.after,
                    target: this.break.afterTarget,
                    startNew: this.break.startNew.toString()
                  });
                  yt[t.$globalData] = this[t.$globalData], this[t.$appendChild](yt), this.breakAfter.push(yt);
                }
                if (this.break.before !== "auto" || this.break.beforeTarget !== "") {
                  const yt = new ie({
                    targetType: this.break.before,
                    target: this.break.beforeTarget,
                    startNew: this.break.startNew.toString()
                  });
                  yt[t.$globalData] = this[t.$globalData], this[t.$appendChild](yt), this.breakBefore.push(yt);
                }
                if (this.break.overflowTarget !== "") {
                  const yt = new it({
                    target: this.break.overflowTarget,
                    leader: this.break.overflowLeader,
                    trailer: this.break.overflowTrailer
                  });
                  yt[t.$globalData] = this[t.$globalData], this[t.$appendChild](yt), this.overflow.push(yt);
                }
                this[t.$removeChild](this.break), this.break = null;
              }
              if (this.presence === "hidden" || this.presence === "inactive")
                return e.HTMLResult.EMPTY;
              if ((this.breakBefore.children.length > 1 || this.breakAfter.children.length > 1) && (0, y.warn)("XFA - Several breakBefore or breakAfter in subforms: please file a bug."), this.breakBefore.children.length >= 1) {
                const yt = this.breakBefore.children[0];
                if (S(yt))
                  return e.HTMLResult.breakNode(yt);
              }
              if (this[t.$extra] && this[t.$extra].afterBreakAfter)
                return e.HTMLResult.EMPTY;
              (0, a.fixDimensions)(this);
              const ce = [], je = {
                id: this[t.$uid],
                class: []
              };
              (0, a.setAccess)(this, je.class), this[t.$extra] || (this[t.$extra] = /* @__PURE__ */ Object.create(null)), Object.assign(this[t.$extra], {
                children: ce,
                line: null,
                attributes: je,
                attempt: 0,
                numberInLine: 0,
                availableSpace: {
                  width: Math.min(this.w || 1 / 0, I.width),
                  height: Math.min(this.h || 1 / 0, I.height)
                },
                width: 0,
                height: 0,
                prevHeight: 0,
                currentWidth: 0
              });
              const Ke = this[t.$getTemplateRoot](), ut = Ke[t.$extra].noLayoutFailure, Ot = this[t.$isSplittable]();
              if (Ot || l(this), !(0, v.checkDimensions)(this, I))
                return e.HTMLResult.FAILURE;
              const Dt = /* @__PURE__ */ new Set(["area", "draw", "exclGroup", "field", "subform", "subformSet"]);
              if (this.layout.includes("row")) {
                const yt = this[t.$getSubformParent]().columnWidths;
                Array.isArray(yt) && yt.length > 0 && (this[t.$extra].columnWidths = yt, this[t.$extra].currentColumn = 0);
              }
              const Pt = (0, a.toStyle)(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), jt = ["xfaSubform"], Xt = (0, a.layoutClass)(this);
              if (Xt && jt.push(Xt), je.style = Pt, je.class = jt, this.name && (je.xfaName = this.name), this.overflow) {
                const yt = this.overflow[t.$getExtra]();
                yt.addLeader && (yt.addLeader = !1, A(this, yt.leader, I));
              }
              this[t.$pushPara]();
              const Zt = this.layout === "lr-tb" || this.layout === "rl-tb", Yt = Zt ? n : 1;
              for (; this[t.$extra].attempt < Yt; this[t.$extra].attempt++) {
                Zt && this[t.$extra].attempt === n - 1 && (this[t.$extra].numberInLine = 0);
                const yt = this[t.$childrenToHTML]({
                  filter: Dt,
                  include: !0
                });
                if (yt.success)
                  break;
                if (yt.isBreak())
                  return this[t.$popPara](), yt;
                if (Zt && this[t.$extra].attempt === 0 && this[t.$extra].numberInLine === 0 && !Ke[t.$extra].noLayoutFailure) {
                  this[t.$extra].attempt = Yt;
                  break;
                }
              }
              if (this[t.$popPara](), Ot || _(this), Ke[t.$extra].noLayoutFailure = ut, this[t.$extra].attempt === Yt)
                return this.overflow && (this[t.$getTemplateRoot]()[t.$extra].overflowNode = this.overflow), Ot || delete this[t.$extra], e.HTMLResult.FAILURE;
              if (this.overflow) {
                const yt = this.overflow[t.$getExtra]();
                yt.addTrailer && (yt.addTrailer = !1, A(this, yt.trailer, I));
              }
              let en = 0, ye = 0;
              this.margin && (en = this.margin.leftInset + this.margin.rightInset, ye = this.margin.topInset + this.margin.bottomInset);
              const Pe = Math.max(this[t.$extra].width + en, this.w || 0), Qe = Math.max(this[t.$extra].height + ye, this.h || 0), Ye = [this.x, this.y, Pe, Qe];
              if (this.w === "" && (Pt.width = (0, a.measureToString)(Pe)), this.h === "" && (Pt.height = (0, a.measureToString)(Qe)), (Pt.width === "0px" || Pt.height === "0px") && ce.length === 0)
                return e.HTMLResult.EMPTY;
              const lt = {
                name: "div",
                attributes: je,
                children: ce
              };
              R(this, je);
              const Bt = e.HTMLResult.success((0, a.createWrapper)(this, lt), Ye);
              if (this.breakAfter.children.length >= 1) {
                const yt = this.breakAfter.children[0];
                if (S(yt))
                  return this[t.$extra].afterBreakAfter = Bt, e.HTMLResult.breakNode(yt);
              }
              return delete this[t.$extra], Bt;
            }
          }
          class hn extends t.XFAObject {
            constructor(I) {
              super(d, "subformSet", !0), this.id = I.id || "", this.name = I.name || "", this.relation = (0, e.getStringOption)(I.relation, ["ordered", "choice", "unordered"]), this.relevant = (0, e.getRelevant)(I.relevant), this.use = I.use || "", this.usehref = I.usehref || "", this.bookend = null, this.break = null, this.desc = null, this.extras = null, this.occur = null, this.overflow = null, this.breakAfter = new t.XFAObjectArray(), this.breakBefore = new t.XFAObjectArray(), this.subform = new t.XFAObjectArray(), this.subformSet = new t.XFAObjectArray();
            }
            *[t.$getContainedChildren]() {
              yield* M(this);
            }
            [t.$getSubformParent]() {
              let I = this[t.$getParent]();
              for (; !(I instanceof mn); )
                I = I[t.$getParent]();
              return I;
            }
            [t.$isBindable]() {
              return !0;
            }
          }
          class gn extends t.ContentObject {
            constructor(I) {
              super(d, "subjectDN"), this.delimiter = I.delimiter || ",", this.id = I.id || "", this.name = I.name || "", this.use = I.use || "", this.usehref = I.usehref || "";
            }
            [t.$finalize]() {
              this[t.$content] = new Map(this[t.$content].split(this.delimiter).map((I) => (I = I.split("=", 2), I[0] = I[0].trim(), I)));
            }
          }
          class an extends t.XFAObject {
            constructor(I) {
              super(d, "subjectDNs", !0), this.id = I.id || "", this.type = (0, e.getStringOption)(I.type, ["optional", "required"]), this.use = I.use || "", this.usehref = I.usehref || "", this.subjectDN = new t.XFAObjectArray();
            }
          }
          class dn extends t.XFAObject {
            constructor(I) {
              super(d, "submit", !0), this.embedPDF = (0, e.getInteger)({
                data: I.embedPDF,
                defaultValue: 0,
                validate: (ce) => ce === 1
              }), this.format = (0, e.getStringOption)(I.format, ["xdp", "formdata", "pdf", "urlencoded", "xfd", "xml"]), this.id = I.id || "", this.target = I.target || "", this.textEncoding = (0, e.getKeyword)({
                data: I.textEncoding ? I.textEncoding.toLowerCase() : "",
                defaultValue: "",
                validate: (ce) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(ce) || ce.match(/iso-8859-\d{2}/)
              }), this.use = I.use || "", this.usehref = I.usehref || "", this.xdpContent = I.xdpContent || "", this.encrypt = null, this.encryptData = new t.XFAObjectArray(), this.signData = new t.XFAObjectArray();
            }
          }
          class Tn extends t.XFAObject {
            constructor(I) {
              super(d, "template", !0), this.baseProfile = (0, e.getStringOption)(I.baseProfile, ["full", "interactiveForms"]), this.extras = null, this.subform = new t.XFAObjectArray();
            }
            [t.$finalize]() {
              this.subform.children.length === 0 && (0, y.warn)("XFA - No subforms in template node."), this.subform.children.length >= 2 && (0, y.warn)("XFA - Several subforms in template node: please file a bug."), this[t.$tabIndex] = x;
            }
            [t.$isSplittable]() {
              return !0;
            }
            [t.$searchNode](I, ce) {
              return I.startsWith("#") ? [this[t.$ids].get(I.slice(1))] : (0, g.searchNode)(this, ce, I, !0, !0);
            }
            *[t.$toPages]() {
              if (!this.subform.children.length)
                return e.HTMLResult.success({
                  name: "div",
                  children: []
                });
              this[t.$extra] = {
                overflowNode: null,
                firstUnsplittable: null,
                currentContentArea: null,
                currentPageArea: null,
                noLayoutFailure: !1,
                pageNumber: 1,
                pagePosition: "first",
                oddOrEven: "odd",
                blankOrNotBlank: "nonBlank",
                paraStack: []
              };
              const I = this.subform.children[0];
              I.pageSet[t.$cleanPage]();
              const ce = I.pageSet.pageArea.children, je = {
                name: "div",
                children: []
              };
              let Ke = null, ut = null, Ot = null;
              if (I.breakBefore.children.length >= 1 ? (ut = I.breakBefore.children[0], Ot = ut.target) : I.subform.children.length >= 1 && I.subform.children[0].breakBefore.children.length >= 1 ? (ut = I.subform.children[0].breakBefore.children[0], Ot = ut.target) : I.break && I.break.beforeTarget ? (ut = I.break, Ot = ut.beforeTarget) : I.subform.children.length >= 1 && I.subform.children[0].break && I.subform.children[0].break.beforeTarget && (ut = I.subform.children[0].break, Ot = ut.beforeTarget), ut) {
                const ye = this[t.$searchNode](Ot, ut[t.$getParent]());
                ye instanceof et && (Ke = ye, ut[t.$extra] = {});
              }
              Ke || (Ke = ce[0]), Ke[t.$extra] = {
                numberOfUse: 1
              };
              const Dt = Ke[t.$getParent]();
              Dt[t.$extra] = {
                numberOfUse: 1,
                pageIndex: Dt.pageArea.children.indexOf(Ke),
                pageSetIndex: 0
              };
              let Pt, jt = null, Xt = null, Zt = !0, Yt = 0, en = 0;
              for (; ; ) {
                if (Zt)
                  Yt = 0;
                else if (je.children.pop(), ++Yt === o)
                  return (0, y.warn)("XFA - Something goes wrong: please file a bug."), je;
                Pt = null, this[t.$extra].currentPageArea = Ke;
                const ye = Ke[t.$toHTML]().html;
                je.children.push(ye), jt && (this[t.$extra].noLayoutFailure = !0, ye.children.push(jt[t.$toHTML](Ke[t.$extra].space).html), jt = null), Xt && (this[t.$extra].noLayoutFailure = !0, ye.children.push(Xt[t.$toHTML](Ke[t.$extra].space).html), Xt = null);
                const Pe = Ke.contentArea.children, Qe = ye.children.filter((lt) => lt.attributes.class.includes("xfaContentarea"));
                Zt = !1, this[t.$extra].firstUnsplittable = null, this[t.$extra].noLayoutFailure = !1;
                const Ye = (lt) => {
                  const Bt = I[t.$flushHTML]();
                  Bt && (Zt = Zt || Bt.children && Bt.children.length !== 0, Qe[lt].children.push(Bt));
                };
                for (let lt = en, Bt = Pe.length; lt < Bt; lt++) {
                  const yt = this[t.$extra].currentContentArea = Pe[lt], $t = {
                    width: yt.w,
                    height: yt.h
                  };
                  en = 0, jt && (Qe[lt].children.push(jt[t.$toHTML]($t).html), jt = null), Xt && (Qe[lt].children.push(Xt[t.$toHTML]($t).html), Xt = null);
                  const Ht = I[t.$toHTML]($t);
                  if (Ht.success)
                    return Ht.html ? (Zt = Zt || Ht.html.children && Ht.html.children.length !== 0, Qe[lt].children.push(Ht.html)) : !Zt && je.children.length > 1 && je.children.pop(), je;
                  if (Ht.isBreak()) {
                    const zt = Ht.breakNode;
                    if (Ye(lt), zt.targetType === "auto")
                      continue;
                    zt.leader && (jt = this[t.$searchNode](zt.leader, zt[t.$getParent]()), jt = jt ? jt[0] : null), zt.trailer && (Xt = this[t.$searchNode](zt.trailer, zt[t.$getParent]()), Xt = Xt ? Xt[0] : null), zt.targetType === "pageArea" ? (Pt = zt[t.$extra].target, lt = 1 / 0) : zt[t.$extra].target ? (Pt = zt[t.$extra].target, en = zt[t.$extra].index + 1, lt = 1 / 0) : lt = zt[t.$extra].index;
                    continue;
                  }
                  if (this[t.$extra].overflowNode) {
                    const zt = this[t.$extra].overflowNode;
                    this[t.$extra].overflowNode = null;
                    const Jt = zt[t.$getExtra](), Qt = Jt.target;
                    Jt.addLeader = Jt.leader !== null, Jt.addTrailer = Jt.trailer !== null, Ye(lt);
                    const nn = lt;
                    if (lt = 1 / 0, Qt instanceof et)
                      Pt = Qt;
                    else if (Qt instanceof ne) {
                      const tn = Pe.indexOf(Qt);
                      tn !== -1 ? tn > nn ? lt = tn - 1 : en = tn : (Pt = Qt[t.$getParent](), en = Pt.contentArea.children.indexOf(Qt));
                    }
                    continue;
                  }
                  Ye(lt);
                }
                this[t.$extra].pageNumber += 1, Pt && (Pt[t.$isUsable]() ? Pt[t.$extra].numberOfUse += 1 : Pt = null), Ke = Pt || Ke[t.$getNextPage](), yield null;
              }
            }
          }
          u.Template = Tn;
          class In extends t.ContentObject {
            constructor(I) {
              super(d, "text"), this.id = I.id || "", this.maxChars = (0, e.getInteger)({
                data: I.maxChars,
                defaultValue: 0,
                validate: (ce) => ce >= 0
              }), this.name = I.name || "", this.rid = I.rid || "", this.use = I.use || "", this.usehref = I.usehref || "";
            }
            [t.$acceptWhitespace]() {
              return !0;
            }
            [t.$onChild](I) {
              return I[t.$namespaceId] === i.NamespaceIds.xhtml.id ? (this[t.$content] = I, !0) : ((0, y.warn)(`XFA - Invalid content in Text: ${I[t.$nodeName]}.`), !1);
            }
            [t.$onText](I) {
              this[t.$content] instanceof t.XFAObject || super[t.$onText](I);
            }
            [t.$finalize]() {
              typeof this[t.$content] == "string" && (this[t.$content] = this[t.$content].replace(/\r\n/g, `
`));
            }
            [t.$getExtra]() {
              return typeof this[t.$content] == "string" ? this[t.$content].split(/[\u2029\u2028\n]/).reduce((I, ce) => (ce && I.push(ce), I), []).join(`
`) : this[t.$content][t.$text]();
            }
            [t.$toHTML](I) {
              if (typeof this[t.$content] == "string") {
                const ce = b(this[t.$content]).html;
                return this[t.$content].includes("\u2029") ? (ce.name = "div", ce.children = [], this[t.$content].split("\u2029").map((je) => je.split(/[\u2028\n]/).reduce((Ke, ut) => (Ke.push({
                  name: "span",
                  value: ut
                }, {
                  name: "br"
                }), Ke), [])).forEach((je) => {
                  ce.children.push({
                    name: "p",
                    children: je
                  });
                })) : /[\u2028\n]/.test(this[t.$content]) && (ce.name = "div", ce.children = [], this[t.$content].split(/[\u2028\n]/).forEach((je) => {
                  ce.children.push({
                    name: "span",
                    value: je
                  }, {
                    name: "br"
                  });
                })), e.HTMLResult.success(ce);
              }
              return this[t.$content][t.$toHTML](I);
            }
          }
          u.Text = In;
          class wn extends t.XFAObject {
            constructor(I) {
              super(d, "textEdit", !0), this.allowRichText = (0, e.getInteger)({
                data: I.allowRichText,
                defaultValue: 0,
                validate: (ce) => ce === 1
              }), this.hScrollPolicy = (0, e.getStringOption)(I.hScrollPolicy, ["auto", "off", "on"]), this.id = I.id || "", this.multiLine = (0, e.getInteger)({
                data: I.multiLine,
                defaultValue: "",
                validate: (ce) => ce === 0 || ce === 1
              }), this.use = I.use || "", this.usehref = I.usehref || "", this.vScrollPolicy = (0, e.getStringOption)(I.vScrollPolicy, ["auto", "off", "on"]), this.border = null, this.comb = null, this.extras = null, this.margin = null;
            }
            [t.$toHTML](I) {
              const ce = (0, a.toStyle)(this, "border", "font", "margin");
              let je;
              const Ke = this[t.$getParent]()[t.$getParent]();
              return this.multiLine === "" && (this.multiLine = Ke instanceof xe ? 1 : 0), this.multiLine === 1 ? je = {
                name: "textarea",
                attributes: {
                  dataId: Ke[t.$data] && Ke[t.$data][t.$uid] || Ke[t.$uid],
                  fieldId: Ke[t.$uid],
                  class: ["xfaTextfield"],
                  style: ce,
                  "aria-label": D(Ke),
                  "aria-required": !1
                }
              } : je = {
                name: "input",
                attributes: {
                  type: "text",
                  dataId: Ke[t.$data] && Ke[t.$data][t.$uid] || Ke[t.$uid],
                  fieldId: Ke[t.$uid],
                  class: ["xfaTextfield"],
                  style: ce,
                  "aria-label": D(Ke),
                  "aria-required": !1
                }
              }, j(Ke) && (je.attributes["aria-required"] = !0, je.attributes.required = !0), e.HTMLResult.success({
                name: "label",
                attributes: {
                  class: ["xfaLabel"]
                },
                children: [je]
              });
            }
          }
          class Nn extends t.StringObject {
            constructor(I) {
              super(d, "time"), this.id = I.id || "", this.name = I.name || "", this.use = I.use || "", this.usehref = I.usehref || "";
            }
            [t.$finalize]() {
              const I = this[t.$content].trim();
              this[t.$content] = I ? new Date(I) : null;
            }
            [t.$toHTML](I) {
              return b(this[t.$content] ? this[t.$content].toString() : "");
            }
          }
          class Pn extends t.XFAObject {
            constructor(I) {
              super(d, "timeStamp"), this.id = I.id || "", this.server = I.server || "", this.type = (0, e.getStringOption)(I.type, ["optional", "required"]), this.use = I.use || "", this.usehref = I.usehref || "";
            }
          }
          class Rn extends t.StringObject {
            constructor(I) {
              super(d, "toolTip"), this.id = I.id || "", this.rid = I.rid || "", this.use = I.use || "", this.usehref = I.usehref || "";
            }
          }
          class Un extends t.XFAObject {
            constructor(I) {
              super(d, "traversal", !0), this.id = I.id || "", this.use = I.use || "", this.usehref = I.usehref || "", this.extras = null, this.traverse = new t.XFAObjectArray();
            }
          }
          class _n extends t.XFAObject {
            constructor(I) {
              super(d, "traverse", !0), this.id = I.id || "", this.operation = (0, e.getStringOption)(I.operation, ["next", "back", "down", "first", "left", "right", "up"]), this.ref = I.ref || "", this.use = I.use || "", this.usehref = I.usehref || "", this.extras = null, this.script = null;
            }
            get name() {
              return this.operation;
            }
            [t.$isTransparent]() {
              return !1;
            }
          }
          class An extends t.XFAObject {
            constructor(I) {
              super(d, "ui", !0), this.id = I.id || "", this.use = I.use || "", this.usehref = I.usehref || "", this.extras = null, this.picture = null, this.barcode = null, this.button = null, this.checkButton = null, this.choiceList = null, this.dateTimeEdit = null, this.defaultUi = null, this.imageEdit = null, this.numericEdit = null, this.passwordEdit = null, this.signature = null, this.textEdit = null;
            }
            [t.$getExtra]() {
              if (this[t.$extra] === void 0) {
                for (const I of Object.getOwnPropertyNames(this)) {
                  if (I === "extras" || I === "picture")
                    continue;
                  const ce = this[I];
                  if (ce instanceof t.XFAObject)
                    return this[t.$extra] = ce, ce;
                }
                this[t.$extra] = null;
              }
              return this[t.$extra];
            }
            [t.$toHTML](I) {
              const ce = this[t.$getExtra]();
              return ce ? ce[t.$toHTML](I) : e.HTMLResult.EMPTY;
            }
          }
          class Mn extends t.XFAObject {
            constructor(I) {
              super(d, "validate", !0), this.formatTest = (0, e.getStringOption)(I.formatTest, ["warning", "disabled", "error"]), this.id = I.id || "", this.nullTest = (0, e.getStringOption)(I.nullTest, ["disabled", "error", "warning"]), this.scriptTest = (0, e.getStringOption)(I.scriptTest, ["error", "disabled", "warning"]), this.use = I.use || "", this.usehref = I.usehref || "", this.extras = null, this.message = null, this.picture = null, this.script = null;
            }
          }
          class xn extends t.XFAObject {
            constructor(I) {
              super(d, "value", !0), this.id = I.id || "", this.override = (0, e.getInteger)({
                data: I.override,
                defaultValue: 0,
                validate: (ce) => ce === 1
              }), this.relevant = (0, e.getRelevant)(I.relevant), this.use = I.use || "", this.usehref = I.usehref || "", this.arc = null, this.boolean = null, this.date = null, this.dateTime = null, this.decimal = null, this.exData = null, this.float = null, this.image = null, this.integer = null, this.line = null, this.rectangle = null, this.text = null, this.time = null;
            }
            [t.$setValue](I) {
              const ce = this[t.$getParent]();
              if (ce instanceof Ze && ce.ui && ce.ui.imageEdit) {
                this.image || (this.image = new st({}), this[t.$appendChild](this.image)), this.image[t.$content] = I[t.$content];
                return;
              }
              const je = I[t.$nodeName];
              if (this[je] !== null) {
                this[je][t.$content] = I[t.$content];
                return;
              }
              for (const Ke of Object.getOwnPropertyNames(this)) {
                const ut = this[Ke];
                ut instanceof t.XFAObject && (this[Ke] = null, this[t.$removeChild](ut));
              }
              this[I[t.$nodeName]] = I, this[t.$appendChild](I);
            }
            [t.$text]() {
              if (this.exData)
                return typeof this.exData[t.$content] == "string" ? this.exData[t.$content].trim() : this.exData[t.$content][t.$text]().trim();
              for (const I of Object.getOwnPropertyNames(this)) {
                if (I === "image")
                  continue;
                const ce = this[I];
                if (ce instanceof t.XFAObject)
                  return (ce[t.$content] || "").toString().trim();
              }
              return null;
            }
            [t.$toHTML](I) {
              for (const ce of Object.getOwnPropertyNames(this)) {
                const je = this[ce];
                if (je instanceof t.XFAObject)
                  return je[t.$toHTML](I);
              }
              return e.HTMLResult.EMPTY;
            }
          }
          u.Value = xn;
          class jn extends t.XFAObject {
            constructor(I) {
              super(d, "variables", !0), this.id = I.id || "", this.use = I.use || "", this.usehref = I.usehref || "", this.boolean = new t.XFAObjectArray(), this.date = new t.XFAObjectArray(), this.dateTime = new t.XFAObjectArray(), this.decimal = new t.XFAObjectArray(), this.exData = new t.XFAObjectArray(), this.float = new t.XFAObjectArray(), this.image = new t.XFAObjectArray(), this.integer = new t.XFAObjectArray(), this.manifest = new t.XFAObjectArray(), this.script = new t.XFAObjectArray(), this.text = new t.XFAObjectArray(), this.time = new t.XFAObjectArray();
            }
            [t.$isTransparent]() {
              return !0;
            }
          }
          class bn {
            static [i.$buildXFAObject](I, ce) {
              if (bn.hasOwnProperty(I)) {
                const je = bn[I](ce);
                return je[t.$setSetAttributes](ce), je;
              }
            }
            static appearanceFilter(I) {
              return new F(I);
            }
            static arc(I) {
              return new T(I);
            }
            static area(I) {
              return new O(I);
            }
            static assist(I) {
              return new U(I);
            }
            static barcode(I) {
              return new G(I);
            }
            static bind(I) {
              return new K(I);
            }
            static bindItems(I) {
              return new W(I);
            }
            static bookend(I) {
              return new z(I);
            }
            static boolean(I) {
              return new V(I);
            }
            static border(I) {
              return new L(I);
            }
            static break(I) {
              return new Y(I);
            }
            static breakAfter(I) {
              return new J(I);
            }
            static breakBefore(I) {
              return new ie(I);
            }
            static button(I) {
              return new q(I);
            }
            static calculate(I) {
              return new N(I);
            }
            static caption(I) {
              return new Z(I);
            }
            static certificate(I) {
              return new E(I);
            }
            static certificates(I) {
              return new te(I);
            }
            static checkButton(I) {
              return new re(I);
            }
            static choiceList(I) {
              return new ee(I);
            }
            static color(I) {
              return new $(I);
            }
            static comb(I) {
              return new k(I);
            }
            static connect(I) {
              return new H(I);
            }
            static contentArea(I) {
              return new ne(I);
            }
            static corner(I) {
              return new ae(I);
            }
            static date(I) {
              return new he(I);
            }
            static dateTime(I) {
              return new ue(I);
            }
            static dateTimeEdit(I) {
              return new fe(I);
            }
            static decimal(I) {
              return new me(I);
            }
            static defaultUi(I) {
              return new Fe(I);
            }
            static desc(I) {
              return new we(I);
            }
            static digestMethod(I) {
              return new Ae(I);
            }
            static digestMethods(I) {
              return new De(I);
            }
            static draw(I) {
              return new xe(I);
            }
            static edge(I) {
              return new Te(I);
            }
            static encoding(I) {
              return new ve(I);
            }
            static encodings(I) {
              return new Se(I);
            }
            static encrypt(I) {
              return new be(I);
            }
            static encryptData(I) {
              return new Le(I);
            }
            static encryption(I) {
              return new ze(I);
            }
            static encryptionMethod(I) {
              return new nt(I);
            }
            static encryptionMethods(I) {
              return new Ue(I);
            }
            static event(I) {
              return new Oe(I);
            }
            static exData(I) {
              return new _e(I);
            }
            static exObject(I) {
              return new at(I);
            }
            static exclGroup(I) {
              return new Je(I);
            }
            static execute(I) {
              return new ot(I);
            }
            static extras(I) {
              return new mt(I);
            }
            static field(I) {
              return new Ze(I);
            }
            static fill(I) {
              return new pt(I);
            }
            static filter(I) {
              return new Ft(I);
            }
            static float(I) {
              return new $e(I);
            }
            static font(I) {
              return new St(I);
            }
            static format(I) {
              return new xt(I);
            }
            static handler(I) {
              return new Ie(I);
            }
            static hyphenation(I) {
              return new Ve(I);
            }
            static image(I) {
              return new st(I);
            }
            static imageEdit(I) {
              return new ct(I);
            }
            static integer(I) {
              return new Rt(I);
            }
            static issuers(I) {
              return new Lt(I);
            }
            static items(I) {
              return new Ge(I);
            }
            static keep(I) {
              return new Ne(I);
            }
            static keyUsage(I) {
              return new rt(I);
            }
            static line(I) {
              return new tt(I);
            }
            static linear(I) {
              return new dt(I);
            }
            static lockDocument(I) {
              return new Ct(I);
            }
            static manifest(I) {
              return new bt(I);
            }
            static margin(I) {
              return new ht(I);
            }
            static mdp(I) {
              return new vt(I);
            }
            static medium(I) {
              return new _t(I);
            }
            static message(I) {
              return new Nt(I);
            }
            static numericEdit(I) {
              return new Mt(I);
            }
            static occur(I) {
              return new Et(I);
            }
            static oid(I) {
              return new Re(I);
            }
            static oids(I) {
              return new We(I);
            }
            static overflow(I) {
              return new it(I);
            }
            static pageArea(I) {
              return new et(I);
            }
            static pageSet(I) {
              return new At(I);
            }
            static para(I) {
              return new It(I);
            }
            static passwordEdit(I) {
              return new Vt(I);
            }
            static pattern(I) {
              return new Ut(I);
            }
            static picture(I) {
              return new Wt(I);
            }
            static proto(I) {
              return new Kt(I);
            }
            static radial(I) {
              return new rn(I);
            }
            static reason(I) {
              return new ln(I);
            }
            static reasons(I) {
              return new Cn(I);
            }
            static rectangle(I) {
              return new fn(I);
            }
            static ref(I) {
              return new Fn(I);
            }
            static script(I) {
              return new yn(I);
            }
            static setProperty(I) {
              return new Dn(I);
            }
            static signData(I) {
              return new En(I);
            }
            static signature(I) {
              return new Bn(I);
            }
            static signing(I) {
              return new Ln(I);
            }
            static solid(I) {
              return new vn(I);
            }
            static speak(I) {
              return new kn(I);
            }
            static stipple(I) {
              return new On(I);
            }
            static subform(I) {
              return new mn(I);
            }
            static subformSet(I) {
              return new hn(I);
            }
            static subjectDN(I) {
              return new gn(I);
            }
            static subjectDNs(I) {
              return new an(I);
            }
            static submit(I) {
              return new dn(I);
            }
            static template(I) {
              return new Tn(I);
            }
            static text(I) {
              return new In(I);
            }
            static textEdit(I) {
              return new wn(I);
            }
            static time(I) {
              return new Nn(I);
            }
            static timeStamp(I) {
              return new Pn(I);
            }
            static toolTip(I) {
              return new Rn(I);
            }
            static traversal(I) {
              return new Un(I);
            }
            static traverse(I) {
              return new _n(I);
            }
            static ui(I) {
              return new An(I);
            }
            static validate(I) {
              return new Mn(I);
            }
            static value(I) {
              return new xn(I);
            }
            static variables(I) {
              return new jn(I);
            }
          }
          u.TemplateNamespace = bn;
        },
        /* 83 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.addHTML = e, u.checkDimensions = h, u.flushHTML = a, u.getAvailableSpace = y;
          var t = P(77), i = P(84);
          function v(g, d) {
            return {
              name: "div",
              attributes: {
                class: [g.layout === "lr-tb" ? "xfaLr" : "xfaRl"]
              },
              children: d
            };
          }
          function a(g) {
            if (!g[t.$extra])
              return null;
            const c = {
              name: "div",
              attributes: g[t.$extra].attributes,
              children: g[t.$extra].children
            };
            if (g[t.$extra].failingNode) {
              const n = g[t.$extra].failingNode[t.$flushHTML]();
              n && (g.layout.endsWith("-tb") ? c.children.push(v(g, [n])) : c.children.push(n));
            }
            return c.children.length === 0 ? null : c;
          }
          function e(g, d, c) {
            const n = g[t.$extra], o = n.availableSpace, [x, f, m, C] = c;
            switch (g.layout) {
              case "position": {
                n.width = Math.max(n.width, x + m), n.height = Math.max(n.height, f + C), n.children.push(d);
                break;
              }
              case "lr-tb":
              case "rl-tb":
                (!n.line || n.attempt === 1) && (n.line = v(g, []), n.children.push(n.line), n.numberInLine = 0), n.numberInLine += 1, n.line.children.push(d), n.attempt === 0 ? (n.currentWidth += m, n.height = Math.max(n.height, n.prevHeight + C)) : (n.currentWidth = m, n.prevHeight = n.height, n.height += C, n.attempt = 0), n.width = Math.max(n.width, n.currentWidth);
                break;
              case "rl-row":
              case "row": {
                n.children.push(d), n.width += m, n.height = Math.max(n.height, C);
                const p = (0, i.measureToString)(n.height);
                for (const w of n.children)
                  w.attributes.style.height = p;
                break;
              }
              case "table": {
                n.width = Math.min(o.width, Math.max(n.width, m)), n.height += C, n.children.push(d);
                break;
              }
              case "tb": {
                n.width = Math.min(o.width, Math.max(n.width, m)), n.height += C, n.children.push(d);
                break;
              }
            }
          }
          function y(g) {
            const d = g[t.$extra].availableSpace, c = g.margin ? g.margin.topInset + g.margin.bottomInset : 0, n = g.margin ? g.margin.leftInset + g.margin.rightInset : 0;
            switch (g.layout) {
              case "lr-tb":
              case "rl-tb":
                return g[t.$extra].attempt === 0 ? {
                  width: d.width - n - g[t.$extra].currentWidth,
                  height: d.height - c - g[t.$extra].prevHeight
                } : {
                  width: d.width - n,
                  height: d.height - c - g[t.$extra].height
                };
              case "rl-row":
              case "row":
                return {
                  width: g[t.$extra].columnWidths.slice(g[t.$extra].currentColumn).reduce((x, f) => x + f),
                  height: d.height - n
                };
              case "table":
              case "tb":
                return {
                  width: d.width - n,
                  height: d.height - c - g[t.$extra].height
                };
              case "position":
              default:
                return d;
            }
          }
          function r(g) {
            let d = g.w === "" ? NaN : g.w, c = g.h === "" ? NaN : g.h, [n, o] = [0, 0];
            switch (g.anchorType || "") {
              case "bottomCenter":
                [n, o] = [d / 2, c];
                break;
              case "bottomLeft":
                [n, o] = [0, c];
                break;
              case "bottomRight":
                [n, o] = [d, c];
                break;
              case "middleCenter":
                [n, o] = [d / 2, c / 2];
                break;
              case "middleLeft":
                [n, o] = [0, c / 2];
                break;
              case "middleRight":
                [n, o] = [d, c / 2];
                break;
              case "topCenter":
                [n, o] = [d / 2, 0];
                break;
              case "topRight":
                [n, o] = [d, 0];
                break;
            }
            let x, f;
            switch (g.rotate || 0) {
              case 0:
                [x, f] = [-n, -o];
                break;
              case 90:
                [x, f] = [-o, n], [d, c] = [c, -d];
                break;
              case 180:
                [x, f] = [n, o], [d, c] = [-d, -c];
                break;
              case 270:
                [x, f] = [o, -n], [d, c] = [-c, d];
                break;
            }
            return [g.x + x + Math.min(0, d), g.y + f + Math.min(0, c), Math.abs(d), Math.abs(c)];
          }
          function h(g, d) {
            if (g[t.$getTemplateRoot]()[t.$extra].firstUnsplittable === null || g.w === 0 || g.h === 0)
              return !0;
            const c = 2, n = g[t.$getSubformParent](), o = n[t.$extra] && n[t.$extra].attempt || 0, [, x, f, m] = r(g);
            switch (n.layout) {
              case "lr-tb":
              case "rl-tb":
                return o === 0 ? g[t.$getTemplateRoot]()[t.$extra].noLayoutFailure ? g.w !== "" ? Math.round(f - d.width) <= c : d.width > c : g.h !== "" && Math.round(m - d.height) > c ? !1 : g.w !== "" ? Math.round(f - d.width) <= c ? !0 : n[t.$extra].numberInLine === 0 ? d.height > c : !1 : d.width > c : g[t.$getTemplateRoot]()[t.$extra].noLayoutFailure ? !0 : g.h !== "" && Math.round(m - d.height) > c ? !1 : g.w === "" || Math.round(f - d.width) <= c ? d.height > c : n[t.$isThereMoreWidth]() ? !1 : d.height > c;
              case "table":
              case "tb":
                return g[t.$getTemplateRoot]()[t.$extra].noLayoutFailure ? !0 : g.h !== "" && !g[t.$isSplittable]() ? Math.round(m - d.height) <= c : g.w === "" || Math.round(f - d.width) <= c ? d.height > c : n[t.$isThereMoreWidth]() ? !1 : d.height > c;
              case "position":
                if (g[t.$getTemplateRoot]()[t.$extra].noLayoutFailure || g.h === "" || Math.round(m + x - d.height) <= c)
                  return !0;
                const C = g[t.$getTemplateRoot]()[t.$extra].currentContentArea;
                return m + x > C.h;
              case "rl-row":
              case "row":
                return g[t.$getTemplateRoot]()[t.$extra].noLayoutFailure ? !0 : g.h !== "" ? Math.round(m - d.height) <= c : !0;
              default:
                return !0;
            }
          }
        },
        /* 84 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.computeBbox = c, u.createWrapper = f, u.fixDimensions = n, u.fixTextIndent = m, u.fixURL = j, u.isPrintOnly = p, u.layoutClass = o, u.layoutNode = d, u.measureToString = y, u.setAccess = C, u.setFontFamily = M, u.setMinMaxDimensions = h, u.setPara = X, u.toStyle = x;
          var t = P(77), i = P(2), v = P(78), a = P(85), e = P(86);
          function y(B) {
            return typeof B == "string" ? "0px" : Number.isInteger(B) ? `${B}px` : `${B.toFixed(2)}px`;
          }
          const r = {
            anchorType(B, R) {
              const D = B[t.$getSubformParent]();
              if (!(!D || D.layout && D.layout !== "position"))
                switch ("transform" in R || (R.transform = ""), B.anchorType) {
                  case "bottomCenter":
                    R.transform += "translate(-50%, -100%)";
                    break;
                  case "bottomLeft":
                    R.transform += "translate(0,-100%)";
                    break;
                  case "bottomRight":
                    R.transform += "translate(-100%,-100%)";
                    break;
                  case "middleCenter":
                    R.transform += "translate(-50%,-50%)";
                    break;
                  case "middleLeft":
                    R.transform += "translate(0,-50%)";
                    break;
                  case "middleRight":
                    R.transform += "translate(-100%,-50%)";
                    break;
                  case "topCenter":
                    R.transform += "translate(-50%,0)";
                    break;
                  case "topRight":
                    R.transform += "translate(-100%,0)";
                    break;
                }
            },
            dimensions(B, R) {
              const D = B[t.$getSubformParent]();
              let b = B.w;
              const l = B.h;
              if (D.layout && D.layout.includes("row")) {
                const _ = D[t.$extra], S = B.colSpan;
                let A;
                S === -1 ? (A = _.columnWidths.slice(_.currentColumn).reduce((F, T) => F + T, 0), _.currentColumn = 0) : (A = _.columnWidths.slice(_.currentColumn, _.currentColumn + S).reduce((F, T) => F + T, 0), _.currentColumn = (_.currentColumn + B.colSpan) % _.columnWidths.length), isNaN(A) || (b = B.w = A);
              }
              b !== "" ? R.width = y(b) : R.width = "auto", l !== "" ? R.height = y(l) : R.height = "auto";
            },
            position(B, R) {
              const D = B[t.$getSubformParent]();
              D && D.layout && D.layout !== "position" || (R.position = "absolute", R.left = y(B.x), R.top = y(B.y));
            },
            rotate(B, R) {
              B.rotate && ("transform" in R || (R.transform = ""), R.transform += `rotate(-${B.rotate}deg)`, R.transformOrigin = "top left");
            },
            presence(B, R) {
              switch (B.presence) {
                case "invisible":
                  R.visibility = "hidden";
                  break;
                case "hidden":
                case "inactive":
                  R.display = "none";
                  break;
              }
            },
            hAlign(B, R) {
              if (B[t.$nodeName] === "para")
                switch (B.hAlign) {
                  case "justifyAll":
                    R.textAlign = "justify-all";
                    break;
                  case "radix":
                    R.textAlign = "left";
                    break;
                  default:
                    R.textAlign = B.hAlign;
                }
              else
                switch (B.hAlign) {
                  case "left":
                    R.alignSelf = "start";
                    break;
                  case "center":
                    R.alignSelf = "center";
                    break;
                  case "right":
                    R.alignSelf = "end";
                    break;
                }
            },
            margin(B, R) {
              B.margin && (R.margin = B.margin[t.$toStyle]().margin);
            }
          };
          function h(B, R) {
            B[t.$getSubformParent]().layout === "position" && (B.minW > 0 && (R.minWidth = y(B.minW)), B.maxW > 0 && (R.maxWidth = y(B.maxW)), B.minH > 0 && (R.minHeight = y(B.minH)), B.maxH > 0 && (R.maxHeight = y(B.maxH)));
          }
          function g(B, R, D, b, l, _) {
            const S = new e.TextMeasure(R, D, b, l);
            return typeof B == "string" ? S.addString(B) : B[t.$pushGlyphs](S), S.compute(_);
          }
          function d(B, R) {
            let D = null, b = null, l = !1;
            if ((!B.w || !B.h) && B.value) {
              let _ = 0, S = 0;
              B.margin && (_ = B.margin.leftInset + B.margin.rightInset, S = B.margin.topInset + B.margin.bottomInset);
              let A = null, F = null;
              B.para && (F = /* @__PURE__ */ Object.create(null), A = B.para.lineHeight === "" ? null : B.para.lineHeight, F.top = B.para.spaceAbove === "" ? 0 : B.para.spaceAbove, F.bottom = B.para.spaceBelow === "" ? 0 : B.para.spaceBelow, F.left = B.para.marginLeft === "" ? 0 : B.para.marginLeft, F.right = B.para.marginRight === "" ? 0 : B.para.marginRight);
              let T = B.font;
              if (!T) {
                const G = B[t.$getTemplateRoot]();
                let K = B[t.$getParent]();
                for (; K && K !== G; ) {
                  if (K.font) {
                    T = K.font;
                    break;
                  }
                  K = K[t.$getParent]();
                }
              }
              const O = (B.w || R.width) - _, U = B[t.$globalData].fontFinder;
              if (B.value.exData && B.value.exData[t.$content] && B.value.exData.contentType === "text/html") {
                const G = g(B.value.exData[t.$content], T, F, A, U, O);
                b = G.width, D = G.height, l = G.isBroken;
              } else {
                const G = B.value[t.$text]();
                if (G) {
                  const K = g(G, T, F, A, U, O);
                  b = K.width, D = K.height, l = K.isBroken;
                }
              }
              b !== null && !B.w && (b += _), D !== null && !B.h && (D += S);
            }
            return {
              w: b,
              h: D,
              isBroken: l
            };
          }
          function c(B, R, D) {
            let b;
            if (B.w !== "" && B.h !== "")
              b = [B.x, B.y, B.w, B.h];
            else {
              if (!D)
                return null;
              let l = B.w;
              if (l === "") {
                if (B.maxW === 0) {
                  const S = B[t.$getSubformParent]();
                  S.layout === "position" && S.w !== "" ? l = 0 : l = B.minW;
                } else
                  l = Math.min(B.maxW, D.width);
                R.attributes.style.width = y(l);
              }
              let _ = B.h;
              if (_ === "") {
                if (B.maxH === 0) {
                  const S = B[t.$getSubformParent]();
                  S.layout === "position" && S.h !== "" ? _ = 0 : _ = B.minH;
                } else
                  _ = Math.min(B.maxH, D.height);
                R.attributes.style.height = y(_);
              }
              b = [B.x, B.y, l, _];
            }
            return b;
          }
          function n(B) {
            const R = B[t.$getSubformParent]();
            if (R.layout && R.layout.includes("row")) {
              const D = R[t.$extra], b = B.colSpan;
              let l;
              b === -1 ? l = D.columnWidths.slice(D.currentColumn).reduce((_, S) => _ + S, 0) : l = D.columnWidths.slice(D.currentColumn, D.currentColumn + b).reduce((_, S) => _ + S, 0), isNaN(l) || (B.w = l);
            }
            R.layout && R.layout !== "position" && (B.x = B.y = 0), B.layout === "table" && B.w === "" && Array.isArray(B.columnWidths) && (B.w = B.columnWidths.reduce((D, b) => D + b, 0));
          }
          function o(B) {
            switch (B.layout) {
              case "position":
                return "xfaPosition";
              case "lr-tb":
                return "xfaLrTb";
              case "rl-row":
                return "xfaRlRow";
              case "rl-tb":
                return "xfaRlTb";
              case "row":
                return "xfaRow";
              case "table":
                return "xfaTable";
              case "tb":
                return "xfaTb";
              default:
                return "xfaPosition";
            }
          }
          function x(B, ...R) {
            const D = /* @__PURE__ */ Object.create(null);
            for (const b of R) {
              const l = B[b];
              if (l !== null) {
                if (r.hasOwnProperty(b)) {
                  r[b](B, D);
                  continue;
                }
                if (l instanceof t.XFAObject) {
                  const _ = l[t.$toStyle]();
                  _ ? Object.assign(D, _) : (0, i.warn)(`(DEBUG) - XFA - style for ${b} not implemented yet`);
                }
              }
            }
            return D;
          }
          function f(B, R) {
            const {
              attributes: D
            } = R, {
              style: b
            } = D, l = {
              name: "div",
              attributes: {
                class: ["xfaWrapper"],
                style: /* @__PURE__ */ Object.create(null)
              },
              children: []
            };
            if (D.class.push("xfaWrapped"), B.border) {
              const {
                widths: _,
                insets: S
              } = B.border[t.$extra];
              let A, F, T = S[0], O = S[3];
              const U = S[0] + S[2], G = S[1] + S[3];
              switch (B.border.hand) {
                case "even":
                  T -= _[0] / 2, O -= _[3] / 2, A = `calc(100% + ${(_[1] + _[3]) / 2 - G}px)`, F = `calc(100% + ${(_[0] + _[2]) / 2 - U}px)`;
                  break;
                case "left":
                  T -= _[0], O -= _[3], A = `calc(100% + ${_[1] + _[3] - G}px)`, F = `calc(100% + ${_[0] + _[2] - U}px)`;
                  break;
                case "right":
                  A = G ? `calc(100% - ${G}px)` : "100%", F = U ? `calc(100% - ${U}px)` : "100%";
                  break;
              }
              const K = ["xfaBorder"];
              p(B.border) && K.push("xfaPrintOnly");
              const W = {
                name: "div",
                attributes: {
                  class: K,
                  style: {
                    top: `${T}px`,
                    left: `${O}px`,
                    width: A,
                    height: F
                  }
                },
                children: []
              };
              for (const z of ["border", "borderWidth", "borderColor", "borderRadius", "borderStyle"])
                b[z] !== void 0 && (W.attributes.style[z] = b[z], delete b[z]);
              l.children.push(W, R);
            } else
              l.children.push(R);
            for (const _ of ["background", "backgroundClip", "top", "left", "width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "transform", "transformOrigin", "visibility"])
              b[_] !== void 0 && (l.attributes.style[_] = b[_], delete b[_]);
            return b.position === "absolute" ? l.attributes.style.position = "absolute" : l.attributes.style.position = "relative", delete b.position, b.alignSelf && (l.attributes.style.alignSelf = b.alignSelf, delete b.alignSelf), l;
          }
          function m(B) {
            const R = (0, v.getMeasurement)(B.textIndent, "0px");
            if (R >= 0)
              return;
            const b = "padding" + ((B.textAlign === "right" ? "right" : "left") === "left" ? "Left" : "Right"), l = (0, v.getMeasurement)(B[b], "0px");
            B[b] = `${l - R}px`;
          }
          function C(B, R) {
            switch (B.access) {
              case "nonInteractive":
                R.push("xfaNonInteractive");
                break;
              case "readOnly":
                R.push("xfaReadOnly");
                break;
              case "protected":
                R.push("xfaDisabled");
                break;
            }
          }
          function p(B) {
            return B.relevant.length > 0 && !B.relevant[0].excluded && B.relevant[0].viewname === "print";
          }
          function w(B) {
            const R = B[t.$getTemplateRoot]()[t.$extra].paraStack;
            return R.length ? R.at(-1) : null;
          }
          function X(B, R, D) {
            if (D.attributes.class && D.attributes.class.includes("xfaRich")) {
              R && (B.h === "" && (R.height = "auto"), B.w === "" && (R.width = "auto"));
              const b = w(B);
              if (b) {
                const l = D.attributes.style;
                switch (l.display = "flex", l.flexDirection = "column", b.vAlign) {
                  case "top":
                    l.justifyContent = "start";
                    break;
                  case "bottom":
                    l.justifyContent = "end";
                    break;
                  case "middle":
                    l.justifyContent = "center";
                    break;
                }
                const _ = b[t.$toStyle]();
                for (const [S, A] of Object.entries(_))
                  S in l || (l[S] = A);
              }
            }
          }
          function M(B, R, D, b) {
            if (!D) {
              delete b.fontFamily;
              return;
            }
            const l = (0, v.stripQuotes)(B.typeface);
            b.fontFamily = `"${l}"`;
            const _ = D.find(l);
            if (_) {
              const {
                fontFamily: S
              } = _.regular.cssFontInfo;
              S !== l && (b.fontFamily = `"${S}"`);
              const A = w(R);
              if (A && A.lineHeight !== "" || b.lineHeight)
                return;
              const F = (0, a.selectFont)(B, _);
              F && (b.lineHeight = Math.max(1.2, F.lineHeight));
            }
          }
          function j(B) {
            const R = (0, i.createValidAbsoluteUrl)(B, null, {
              addDefaultProtocol: !0,
              tryConvertEncoding: !0
            });
            return R ? R.href : null;
          }
        },
        /* 85 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.FontFinder = void 0, u.getMetrics = y, u.selectFont = e;
          var t = P(77), i = P(78), v = P(2);
          class a {
            constructor(h) {
              this.fonts = /* @__PURE__ */ new Map(), this.cache = /* @__PURE__ */ new Map(), this.warned = /* @__PURE__ */ new Set(), this.defaultFont = null, this.add(h);
            }
            add(h, g = null) {
              for (const c of h)
                this.addPdfFont(c);
              for (const c of this.fonts.values())
                c.regular || (c.regular = c.italic || c.bold || c.bolditalic);
              if (!g || g.size === 0)
                return;
              const d = this.fonts.get("PdfJS-Fallback-PdfJS-XFA");
              for (const c of g)
                this.fonts.set(c, d);
            }
            addPdfFont(h) {
              const g = h.cssFontInfo, d = g.fontFamily;
              let c = this.fonts.get(d);
              c || (c = /* @__PURE__ */ Object.create(null), this.fonts.set(d, c), this.defaultFont || (this.defaultFont = c));
              let n = "";
              const o = parseFloat(g.fontWeight);
              parseFloat(g.italicAngle) !== 0 ? n = o >= 700 ? "bolditalic" : "italic" : o >= 700 && (n = "bold"), n || ((h.name.includes("Bold") || h.psName && h.psName.includes("Bold")) && (n = "bold"), (h.name.includes("Italic") || h.name.endsWith("It") || h.psName && (h.psName.includes("Italic") || h.psName.endsWith("It"))) && (n += "italic")), n || (n = "regular"), c[n] = h;
            }
            getDefault() {
              return this.defaultFont;
            }
            find(h, g = !0) {
              let d = this.fonts.get(h) || this.cache.get(h);
              if (d)
                return d;
              const c = /,|-|_| |bolditalic|bold|italic|regular|it/gi;
              let n = h.replace(c, "");
              if (d = this.fonts.get(n), d)
                return this.cache.set(h, d), d;
              n = n.toLowerCase();
              const o = [];
              for (const [x, f] of this.fonts.entries())
                x.replace(c, "").toLowerCase().startsWith(n) && o.push(f);
              if (o.length === 0)
                for (const [, x] of this.fonts.entries())
                  x.regular.name && x.regular.name.replace(c, "").toLowerCase().startsWith(n) && o.push(x);
              if (o.length === 0) {
                n = n.replace(/psmt|mt/gi, "");
                for (const [x, f] of this.fonts.entries())
                  x.replace(c, "").toLowerCase().startsWith(n) && o.push(f);
              }
              if (o.length === 0)
                for (const x of this.fonts.values())
                  x.regular.name && x.regular.name.replace(c, "").toLowerCase().startsWith(n) && o.push(x);
              return o.length >= 1 ? (o.length !== 1 && g && (0, v.warn)(`XFA - Too many choices to guess the correct font: ${h}`), this.cache.set(h, o[0]), o[0]) : (g && !this.warned.has(h) && (this.warned.add(h), (0, v.warn)(`XFA - Cannot find the font: ${h}`)), null);
            }
          }
          u.FontFinder = a;
          function e(r, h) {
            return r.posture === "italic" ? r.weight === "bold" ? h.bolditalic : h.italic : r.weight === "bold" ? h.bold : h.regular;
          }
          function y(r, h = !1) {
            let g = null;
            if (r) {
              const o = (0, i.stripQuotes)(r.typeface), x = r[t.$globalData].fontFinder.find(o);
              g = e(r, x);
            }
            if (!g)
              return {
                lineHeight: 12,
                lineGap: 2,
                lineNoGap: 10
              };
            const d = r.size || 10, c = g.lineHeight ? Math.max(h ? 0 : 1.2, g.lineHeight) : 1.2, n = g.lineGap === void 0 ? 0.2 : g.lineGap;
            return {
              lineHeight: c * d,
              lineGap: n * d,
              lineNoGap: Math.max(1, c - n) * d
            };
          }
        },
        /* 86 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.TextMeasure = void 0;
          var t = P(85);
          const i = 1.02;
          class v {
            constructor(r, h, g, d) {
              if (this.lineHeight = g, this.paraMargin = h || {
                top: 0,
                bottom: 0,
                left: 0,
                right: 0
              }, !r) {
                [this.pdfFont, this.xfaFont] = this.defaultFont(d);
                return;
              }
              this.xfaFont = {
                typeface: r.typeface,
                posture: r.posture,
                weight: r.weight,
                size: r.size,
                letterSpacing: r.letterSpacing
              };
              const c = d.find(r.typeface);
              if (!c) {
                [this.pdfFont, this.xfaFont] = this.defaultFont(d);
                return;
              }
              this.pdfFont = (0, t.selectFont)(r, c), this.pdfFont || ([this.pdfFont, this.xfaFont] = this.defaultFont(d));
            }
            defaultFont(r) {
              const h = r.find("Helvetica", !1) || r.find("Myriad Pro", !1) || r.find("Arial", !1) || r.getDefault();
              if (h && h.regular) {
                const d = h.regular, n = {
                  typeface: d.cssFontInfo.fontFamily,
                  posture: "normal",
                  weight: "normal",
                  size: 10,
                  letterSpacing: 0
                };
                return [d, n];
              }
              return [null, {
                typeface: "Courier",
                posture: "normal",
                weight: "normal",
                size: 10,
                letterSpacing: 0
              }];
            }
          }
          class a {
            constructor(r, h, g, d) {
              this.fontFinder = d, this.stack = [new v(r, h, g, d)];
            }
            pushData(r, h, g) {
              const d = this.stack.at(-1);
              for (const n of ["typeface", "posture", "weight", "size", "letterSpacing"])
                r[n] || (r[n] = d.xfaFont[n]);
              for (const n of ["top", "bottom", "left", "right"])
                isNaN(h[n]) && (h[n] = d.paraMargin[n]);
              const c = new v(r, h, g || d.lineHeight, this.fontFinder);
              c.pdfFont || (c.pdfFont = d.pdfFont), this.stack.push(c);
            }
            popFont() {
              this.stack.pop();
            }
            topFont() {
              return this.stack.at(-1);
            }
          }
          class e {
            constructor(r, h, g, d) {
              this.glyphs = [], this.fontSelector = new a(r, h, g, d), this.extraHeight = 0;
            }
            pushData(r, h, g) {
              this.fontSelector.pushData(r, h, g);
            }
            popFont(r) {
              return this.fontSelector.popFont();
            }
            addPara() {
              const r = this.fontSelector.topFont();
              this.extraHeight += r.paraMargin.top + r.paraMargin.bottom;
            }
            addString(r) {
              if (!r)
                return;
              const h = this.fontSelector.topFont(), g = h.xfaFont.size;
              if (h.pdfFont) {
                const d = h.xfaFont.letterSpacing, c = h.pdfFont, n = c.lineHeight || 1.2, o = h.lineHeight || Math.max(1.2, n) * g, x = c.lineGap === void 0 ? 0.2 : c.lineGap, f = n - x, m = Math.max(1, f) * g, C = g / 1e3, p = c.defaultWidth || c.charsToGlyphs(" ")[0].width;
                for (const w of r.split(/[\u2029\n]/)) {
                  const X = c.encodeString(w).join(""), M = c.charsToGlyphs(X);
                  for (const j of M) {
                    const B = j.width || p;
                    this.glyphs.push([B * C + d, o, m, j.unicode, !1]);
                  }
                  this.glyphs.push([0, 0, 0, `
`, !0]);
                }
                this.glyphs.pop();
                return;
              }
              for (const d of r.split(/[\u2029\n]/)) {
                for (const c of d.split(""))
                  this.glyphs.push([g, 1.2 * g, g, c, !1]);
                this.glyphs.push([0, 0, 0, `
`, !0]);
              }
              this.glyphs.pop();
            }
            compute(r) {
              let h = -1, g = 0, d = 0, c = 0, n = 0, o = 0, x = !1, f = !0;
              for (let m = 0, C = this.glyphs.length; m < C; m++) {
                const [p, w, X, M, j] = this.glyphs[m], B = M === " ", R = f ? X : w;
                if (j) {
                  d = Math.max(d, n), n = 0, c += o, o = R, h = -1, g = 0, f = !1;
                  continue;
                }
                if (B) {
                  n + p > r ? (d = Math.max(d, n), n = 0, c += o, o = R, h = -1, g = 0, x = !0, f = !1) : (o = Math.max(R, o), g = n, n += p, h = m);
                  continue;
                }
                if (n + p > r) {
                  c += o, o = R, h !== -1 ? (m = h, d = Math.max(d, g), n = 0, h = -1, g = 0) : (d = Math.max(d, n), n = p), x = !0, f = !1;
                  continue;
                }
                n += p, o = Math.max(R, o);
              }
              return d = Math.max(d, n), c += o + this.extraHeight, {
                width: i * d,
                height: c,
                isBroken: x
              };
            }
          }
          u.TextMeasure = e;
        },
        /* 87 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.DataHandler = void 0;
          var t = P(77);
          class i {
            constructor(a, e) {
              this.data = e, this.dataset = a.datasets || null;
            }
            serialize(a) {
              const e = [[-1, this.data[t.$getChildren]()]];
              for (; e.length > 0; ) {
                const r = e.at(-1), [h, g] = r;
                if (h + 1 === g.length) {
                  e.pop();
                  continue;
                }
                const d = g[++r[0]], c = a.get(d[t.$uid]);
                if (c)
                  d[t.$setValue](c);
                else {
                  const o = d[t.$getAttributes]();
                  for (const x of o.values()) {
                    const f = a.get(x[t.$uid]);
                    if (f) {
                      x[t.$setValue](f);
                      break;
                    }
                  }
                }
                const n = d[t.$getChildren]();
                n.length > 0 && e.push([-1, n]);
              }
              const y = ['<xfa:datasets xmlns:xfa="http://www.xfa.org/schema/xfa-data/1.0/">'];
              if (this.dataset)
                for (const r of this.dataset[t.$getChildren]())
                  r[t.$nodeName] !== "data" && r[t.$toString](y);
              return this.data[t.$toString](y), y.push("</xfa:datasets>"), y.join("");
            }
          }
          u.DataHandler = i;
        },
        /* 88 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.XFAParser = void 0;
          var t = P(77), i = P(66), v = P(89), a = P(2);
          class e extends i.XMLParserBase {
            constructor(r = null, h = !1) {
              super(), this._builder = new v.Builder(r), this._stack = [], this._globalData = {
                usedTypefaces: /* @__PURE__ */ new Set()
              }, this._ids = /* @__PURE__ */ new Map(), this._current = this._builder.buildRoot(this._ids), this._errorCode = i.XMLParserErrorCode.NoError, this._whiteRegex = /^\s+$/, this._nbsps = /\xa0+/g, this._richText = h;
            }
            parse(r) {
              if (this.parseXml(r), this._errorCode === i.XMLParserErrorCode.NoError)
                return this._current[t.$finalize](), this._current.element;
            }
            onText(r) {
              if (r = r.replace(this._nbsps, (h) => h.slice(1) + " "), this._richText || this._current[t.$acceptWhitespace]()) {
                this._current[t.$onText](r, this._richText);
                return;
              }
              this._whiteRegex.test(r) || this._current[t.$onText](r.trim());
            }
            onCdata(r) {
              this._current[t.$onText](r);
            }
            _mkAttributes(r, h) {
              let g = null, d = null;
              const c = /* @__PURE__ */ Object.create({});
              for (const {
                name: n,
                value: o
              } of r)
                if (n === "xmlns")
                  g ? (0, a.warn)(`XFA - multiple namespace definition in <${h}>`) : g = o;
                else if (n.startsWith("xmlns:")) {
                  const x = n.substring(6);
                  d || (d = []), d.push({
                    prefix: x,
                    value: o
                  });
                } else {
                  const x = n.indexOf(":");
                  if (x === -1)
                    c[n] = o;
                  else {
                    let f = c[t.$nsAttributes];
                    f || (f = c[t.$nsAttributes] = /* @__PURE__ */ Object.create(null));
                    const [m, C] = [n.slice(0, x), n.slice(x + 1)];
                    let p = f[m];
                    p || (p = f[m] = /* @__PURE__ */ Object.create(null)), p[C] = o;
                  }
                }
              return [g, d, c];
            }
            _getNameAndPrefix(r, h) {
              const g = r.indexOf(":");
              return g === -1 ? [r, null] : [r.substring(g + 1), h ? "" : r.substring(0, g)];
            }
            onBeginElement(r, h, g) {
              const [d, c, n] = this._mkAttributes(h, r), [o, x] = this._getNameAndPrefix(r, this._builder.isNsAgnostic()), f = this._builder.build({
                nsPrefix: x,
                name: o,
                attributes: n,
                namespace: d,
                prefixes: c
              });
              if (f[t.$globalData] = this._globalData, g) {
                f[t.$finalize](), this._current[t.$onChild](f) && f[t.$setId](this._ids), f[t.$clean](this._builder);
                return;
              }
              this._stack.push(this._current), this._current = f;
            }
            onEndElement(r) {
              const h = this._current;
              if (h[t.$isCDATAXml]() && typeof h[t.$content] == "string") {
                const g = new e();
                g._globalData = this._globalData;
                const d = g.parse(h[t.$content]);
                h[t.$content] = null, h[t.$onChild](d);
              }
              h[t.$finalize](), this._current = this._stack.pop(), this._current[t.$onChild](h) && h[t.$setId](this._ids), h[t.$clean](this._builder);
            }
            onError(r) {
              this._errorCode = r;
            }
          }
          u.XFAParser = e;
        },
        /* 89 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.Builder = void 0;
          var t = P(79), i = P(77), v = P(90), a = P(82), e = P(99), y = P(2);
          class r extends i.XFAObject {
            constructor(c) {
              super(-1, "root", /* @__PURE__ */ Object.create(null)), this.element = null, this[i.$ids] = c;
            }
            [i.$onChild](c) {
              return this.element = c, !0;
            }
            [i.$finalize]() {
              super[i.$finalize](), this.element.template instanceof a.Template && (this[i.$ids].set(i.$root, this.element), this.element.template[i.$resolvePrototypes](this[i.$ids]), this.element.template[i.$ids] = this[i.$ids]);
            }
          }
          class h extends i.XFAObject {
            constructor() {
              super(-1, "", /* @__PURE__ */ Object.create(null));
            }
            [i.$onChild](c) {
              return !1;
            }
          }
          class g {
            constructor(c = null) {
              this._namespaceStack = [], this._nsAgnosticLevel = 0, this._namespacePrefixes = /* @__PURE__ */ new Map(), this._namespaces = /* @__PURE__ */ new Map(), this._nextNsId = Math.max(...Object.values(t.NamespaceIds).map(({
                id: n
              }) => n)), this._currentNamespace = c || new e.UnknownNamespace(++this._nextNsId);
            }
            buildRoot(c) {
              return new r(c);
            }
            build({
              nsPrefix: c,
              name: n,
              attributes: o,
              namespace: x,
              prefixes: f
            }) {
              const m = x !== null;
              if (m && (this._namespaceStack.push(this._currentNamespace), this._currentNamespace = this._searchNamespace(x)), f && this._addNamespacePrefix(f), o.hasOwnProperty(i.$nsAttributes)) {
                const w = v.NamespaceSetUp.datasets, X = o[i.$nsAttributes];
                let M = null;
                for (const [j, B] of Object.entries(X))
                  if (this._getNamespaceToUse(j) === w) {
                    M = {
                      xfa: B
                    };
                    break;
                  }
                M ? o[i.$nsAttributes] = M : delete o[i.$nsAttributes];
              }
              const C = this._getNamespaceToUse(c), p = C && C[t.$buildXFAObject](n, o) || new h();
              return p[i.$isNsAgnostic]() && this._nsAgnosticLevel++, (m || f || p[i.$isNsAgnostic]()) && (p[i.$cleanup] = {
                hasNamespace: m,
                prefixes: f,
                nsAgnostic: p[i.$isNsAgnostic]()
              }), p;
            }
            isNsAgnostic() {
              return this._nsAgnosticLevel > 0;
            }
            _searchNamespace(c) {
              let n = this._namespaces.get(c);
              if (n)
                return n;
              for (const [o, {
                check: x
              }] of Object.entries(t.NamespaceIds))
                if (x(c)) {
                  if (n = v.NamespaceSetUp[o], n)
                    return this._namespaces.set(c, n), n;
                  break;
                }
              return n = new e.UnknownNamespace(++this._nextNsId), this._namespaces.set(c, n), n;
            }
            _addNamespacePrefix(c) {
              for (const {
                prefix: n,
                value: o
              } of c) {
                const x = this._searchNamespace(o);
                let f = this._namespacePrefixes.get(n);
                f || (f = [], this._namespacePrefixes.set(n, f)), f.push(x);
              }
            }
            _getNamespaceToUse(c) {
              if (!c)
                return this._currentNamespace;
              const n = this._namespacePrefixes.get(c);
              return n && n.length > 0 ? n.at(-1) : ((0, y.warn)(`Unknown namespace prefix: ${c}.`), null);
            }
            clean(c) {
              const {
                hasNamespace: n,
                prefixes: o,
                nsAgnostic: x
              } = c;
              n && (this._currentNamespace = this._namespaceStack.pop()), o && o.forEach(({
                prefix: f
              }) => {
                this._namespacePrefixes.get(f).pop();
              }), x && this._nsAgnosticLevel--;
            }
          }
          u.Builder = g;
        },
        /* 90 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.NamespaceSetUp = void 0;
          var t = P(91), i = P(92), v = P(93), a = P(94), e = P(95), y = P(96), r = P(82), h = P(97), g = P(98);
          const d = {
            config: t.ConfigNamespace,
            connection: i.ConnectionSetNamespace,
            datasets: v.DatasetsNamespace,
            localeSet: a.LocaleSetNamespace,
            signature: e.SignatureNamespace,
            stylesheet: y.StylesheetNamespace,
            template: r.TemplateNamespace,
            xdp: h.XdpNamespace,
            xhtml: g.XhtmlNamespace
          };
          u.NamespaceSetUp = d;
        },
        /* 91 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.ConfigNamespace = void 0;
          var t = P(79), i = P(77), v = P(78), a = P(2);
          const e = t.NamespaceIds.config.id;
          class y extends i.XFAObject {
            constructor(ce) {
              super(e, "acrobat", !0), this.acrobat7 = null, this.autoSave = null, this.common = null, this.validate = null, this.validateApprovalSignatures = null, this.submitUrl = new i.XFAObjectArray();
            }
          }
          class r extends i.XFAObject {
            constructor(ce) {
              super(e, "acrobat7", !0), this.dynamicRender = null;
            }
          }
          class h extends i.OptionObject {
            constructor(ce) {
              super(e, "ADBE_JSConsole", ["delegate", "Enable", "Disable"]);
            }
          }
          class g extends i.OptionObject {
            constructor(ce) {
              super(e, "ADBE_JSDebugger", ["delegate", "Enable", "Disable"]);
            }
          }
          class d extends i.Option01 {
            constructor(ce) {
              super(e, "addSilentPrint");
            }
          }
          class c extends i.Option01 {
            constructor(ce) {
              super(e, "addViewerPreferences");
            }
          }
          class n extends i.Option10 {
            constructor(ce) {
              super(e, "adjustData");
            }
          }
          class o extends i.IntegerObject {
            constructor(ce) {
              super(e, "adobeExtensionLevel", 0, (je) => je >= 1 && je <= 8);
            }
          }
          class x extends i.XFAObject {
            constructor(ce) {
              super(e, "agent", !0), this.name = ce.name ? ce.name.trim() : "", this.common = new i.XFAObjectArray();
            }
          }
          class f extends i.ContentObject {
            constructor(ce) {
              super(e, "alwaysEmbed");
            }
          }
          class m extends i.StringObject {
            constructor(ce) {
              super(e, "amd");
            }
          }
          class C extends i.XFAObject {
            constructor(ce) {
              super(e, "area"), this.level = (0, v.getInteger)({
                data: ce.level,
                defaultValue: 0,
                validate: (je) => je >= 1 && je <= 3
              }), this.name = (0, v.getStringOption)(ce.name, ["", "barcode", "coreinit", "deviceDriver", "font", "general", "layout", "merge", "script", "signature", "sourceSet", "templateCache"]);
            }
          }
          class p extends i.OptionObject {
            constructor(ce) {
              super(e, "attributes", ["preserve", "delegate", "ignore"]);
            }
          }
          class w extends i.OptionObject {
            constructor(ce) {
              super(e, "autoSave", ["disabled", "enabled"]);
            }
          }
          class X extends i.StringObject {
            constructor(ce) {
              super(e, "base");
            }
          }
          class M extends i.XFAObject {
            constructor(ce) {
              super(e, "batchOutput"), this.format = (0, v.getStringOption)(ce.format, ["none", "concat", "zip", "zipCompress"]);
            }
          }
          class j extends i.ContentObject {
            constructor(ce) {
              super(e, "behaviorOverride");
            }
            [i.$finalize]() {
              this[i.$content] = new Map(this[i.$content].trim().split(/\s+/).filter((ce) => ce.includes(":")).map((ce) => ce.split(":", 2)));
            }
          }
          class B extends i.XFAObject {
            constructor(ce) {
              super(e, "cache", !0), this.templateCache = null;
            }
          }
          class R extends i.Option01 {
            constructor(ce) {
              super(e, "change");
            }
          }
          class D extends i.XFAObject {
            constructor(ce) {
              super(e, "common", !0), this.data = null, this.locale = null, this.localeSet = null, this.messaging = null, this.suppressBanner = null, this.template = null, this.validationMessaging = null, this.versionControl = null, this.log = new i.XFAObjectArray();
            }
          }
          class b extends i.XFAObject {
            constructor(ce) {
              super(e, "compress"), this.scope = (0, v.getStringOption)(ce.scope, ["imageOnly", "document"]);
            }
          }
          class l extends i.Option01 {
            constructor(ce) {
              super(e, "compressLogicalStructure");
            }
          }
          class _ extends i.Option10 {
            constructor(ce) {
              super(e, "compressObjectStream");
            }
          }
          class S extends i.XFAObject {
            constructor(ce) {
              super(e, "compression", !0), this.compressLogicalStructure = null, this.compressObjectStream = null, this.level = null, this.type = null;
            }
          }
          class A extends i.XFAObject {
            constructor(ce) {
              super(e, "config", !0), this.acrobat = null, this.present = null, this.trace = null, this.agent = new i.XFAObjectArray();
            }
          }
          class F extends i.OptionObject {
            constructor(ce) {
              super(e, "conformance", ["A", "B"]);
            }
          }
          class T extends i.Option01 {
            constructor(ce) {
              super(e, "contentCopy");
            }
          }
          class O extends i.IntegerObject {
            constructor(ce) {
              super(e, "copies", 1, (je) => je >= 1);
            }
          }
          class U extends i.StringObject {
            constructor(ce) {
              super(e, "creator");
            }
          }
          class G extends i.IntegerObject {
            constructor(ce) {
              super(e, "currentPage", 0, (je) => je >= 0);
            }
          }
          class K extends i.XFAObject {
            constructor(ce) {
              super(e, "data", !0), this.adjustData = null, this.attributes = null, this.incrementalLoad = null, this.outputXSL = null, this.range = null, this.record = null, this.startNode = null, this.uri = null, this.window = null, this.xsl = null, this.excludeNS = new i.XFAObjectArray(), this.transform = new i.XFAObjectArray();
            }
          }
          class W extends i.XFAObject {
            constructor(ce) {
              super(e, "debug", !0), this.uri = null;
            }
          }
          class z extends i.ContentObject {
            constructor(ce) {
              super(e, "defaultTypeface"), this.writingScript = (0, v.getStringOption)(ce.writingScript, ["*", "Arabic", "Cyrillic", "EastEuropeanRoman", "Greek", "Hebrew", "Japanese", "Korean", "Roman", "SimplifiedChinese", "Thai", "TraditionalChinese", "Vietnamese"]);
            }
          }
          class V extends i.OptionObject {
            constructor(ce) {
              super(e, "destination", ["pdf", "pcl", "ps", "webClient", "zpl"]);
            }
          }
          class L extends i.Option01 {
            constructor(ce) {
              super(e, "documentAssembly");
            }
          }
          class Y extends i.XFAObject {
            constructor(ce) {
              super(e, "driver", !0), this.name = ce.name ? ce.name.trim() : "", this.fontInfo = null, this.xdc = null;
            }
          }
          class J extends i.OptionObject {
            constructor(ce) {
              super(e, "duplexOption", ["simplex", "duplexFlipLongEdge", "duplexFlipShortEdge"]);
            }
          }
          class ie extends i.OptionObject {
            constructor(ce) {
              super(e, "dynamicRender", ["forbidden", "required"]);
            }
          }
          class q extends i.Option01 {
            constructor(ce) {
              super(e, "embed");
            }
          }
          class N extends i.Option01 {
            constructor(ce) {
              super(e, "encrypt");
            }
          }
          class Z extends i.XFAObject {
            constructor(ce) {
              super(e, "encryption", !0), this.encrypt = null, this.encryptionLevel = null, this.permissions = null;
            }
          }
          class E extends i.OptionObject {
            constructor(ce) {
              super(e, "encryptionLevel", ["40bit", "128bit"]);
            }
          }
          class te extends i.StringObject {
            constructor(ce) {
              super(e, "enforce");
            }
          }
          class re extends i.XFAObject {
            constructor(ce) {
              super(e, "equate"), this.force = (0, v.getInteger)({
                data: ce.force,
                defaultValue: 1,
                validate: (je) => je === 0
              }), this.from = ce.from || "", this.to = ce.to || "";
            }
          }
          class ee extends i.XFAObject {
            constructor(ce) {
              super(e, "equateRange"), this.from = ce.from || "", this.to = ce.to || "", this._unicodeRange = ce.unicodeRange || "";
            }
            get unicodeRange() {
              const ce = [], je = /U\+([0-9a-fA-F]+)/, Ke = this._unicodeRange;
              for (let ut of Ke.split(",").map((Ot) => Ot.trim()).filter((Ot) => !!Ot))
                ut = ut.split("-", 2).map((Ot) => {
                  const Dt = Ot.match(je);
                  return Dt ? parseInt(Dt[1], 16) : 0;
                }), ut.length === 1 && ut.push(ut[0]), ce.push(ut);
              return (0, a.shadow)(this, "unicodeRange", ce);
            }
          }
          class $ extends i.ContentObject {
            constructor(ce) {
              super(e, "exclude");
            }
            [i.$finalize]() {
              this[i.$content] = this[i.$content].trim().split(/\s+/).filter((ce) => ce && ["calculate", "close", "enter", "exit", "initialize", "ready", "validate"].includes(ce));
            }
          }
          class k extends i.StringObject {
            constructor(ce) {
              super(e, "excludeNS");
            }
          }
          class H extends i.OptionObject {
            constructor(ce) {
              super(e, "flipLabel", ["usePrinterSetting", "on", "off"]);
            }
          }
          class ne extends i.XFAObject {
            constructor(ce) {
              super(e, "fontInfo", !0), this.embed = null, this.map = null, this.subsetBelow = null, this.alwaysEmbed = new i.XFAObjectArray(), this.defaultTypeface = new i.XFAObjectArray(), this.neverEmbed = new i.XFAObjectArray();
            }
          }
          class ae extends i.Option01 {
            constructor(ce) {
              super(e, "formFieldFilling");
            }
          }
          class he extends i.StringObject {
            constructor(ce) {
              super(e, "groupParent");
            }
          }
          class ue extends i.OptionObject {
            constructor(ce) {
              super(e, "ifEmpty", ["dataValue", "dataGroup", "ignore", "remove"]);
            }
          }
          class fe extends i.StringObject {
            constructor(ce) {
              super(e, "includeXDPContent");
            }
          }
          class me extends i.OptionObject {
            constructor(ce) {
              super(e, "incrementalLoad", ["none", "forwardOnly"]);
            }
          }
          class Fe extends i.Option01 {
            constructor(ce) {
              super(e, "incrementalMerge");
            }
          }
          class we extends i.Option01 {
            constructor(ce) {
              super(e, "interactive");
            }
          }
          class Ae extends i.OptionObject {
            constructor(ce) {
              super(e, "jog", ["usePrinterSetting", "none", "pageSet"]);
            }
          }
          class De extends i.XFAObject {
            constructor(ce) {
              super(e, "labelPrinter", !0), this.name = (0, v.getStringOption)(ce.name, ["zpl", "dpl", "ipl", "tcpl"]), this.batchOutput = null, this.flipLabel = null, this.fontInfo = null, this.xdc = null;
            }
          }
          class xe extends i.OptionObject {
            constructor(ce) {
              super(e, "layout", ["paginate", "panel"]);
            }
          }
          class Te extends i.IntegerObject {
            constructor(ce) {
              super(e, "level", 0, (je) => je > 0);
            }
          }
          class ve extends i.Option01 {
            constructor(ce) {
              super(e, "linearized");
            }
          }
          class Se extends i.StringObject {
            constructor(ce) {
              super(e, "locale");
            }
          }
          class be extends i.StringObject {
            constructor(ce) {
              super(e, "localeSet");
            }
          }
          class Le extends i.XFAObject {
            constructor(ce) {
              super(e, "log", !0), this.mode = null, this.threshold = null, this.to = null, this.uri = null;
            }
          }
          class ze extends i.XFAObject {
            constructor(ce) {
              super(e, "map", !0), this.equate = new i.XFAObjectArray(), this.equateRange = new i.XFAObjectArray();
            }
          }
          class nt extends i.XFAObject {
            constructor(ce) {
              super(e, "mediumInfo", !0), this.map = null;
            }
          }
          class Ue extends i.XFAObject {
            constructor(ce) {
              super(e, "message", !0), this.msgId = null, this.severity = null;
            }
          }
          class Oe extends i.XFAObject {
            constructor(ce) {
              super(e, "messaging", !0), this.message = new i.XFAObjectArray();
            }
          }
          class _e extends i.OptionObject {
            constructor(ce) {
              super(e, "mode", ["append", "overwrite"]);
            }
          }
          class at extends i.Option01 {
            constructor(ce) {
              super(e, "modifyAnnots");
            }
          }
          class Je extends i.IntegerObject {
            constructor(ce) {
              super(e, "msgId", 1, (je) => je >= 1);
            }
          }
          class ot extends i.StringObject {
            constructor(ce) {
              super(e, "nameAttr");
            }
          }
          class mt extends i.ContentObject {
            constructor(ce) {
              super(e, "neverEmbed");
            }
          }
          class Ze extends i.IntegerObject {
            constructor(ce) {
              super(e, "numberOfCopies", null, (je) => je >= 2 && je <= 5);
            }
          }
          class pt extends i.XFAObject {
            constructor(ce) {
              super(e, "openAction", !0), this.destination = null;
            }
          }
          class Ft extends i.XFAObject {
            constructor(ce) {
              super(e, "output", !0), this.to = null, this.type = null, this.uri = null;
            }
          }
          class $e extends i.StringObject {
            constructor(ce) {
              super(e, "outputBin");
            }
          }
          class St extends i.XFAObject {
            constructor(ce) {
              super(e, "outputXSL", !0), this.uri = null;
            }
          }
          class xt extends i.OptionObject {
            constructor(ce) {
              super(e, "overprint", ["none", "both", "draw", "field"]);
            }
          }
          class Ie extends i.StringObject {
            constructor(ce) {
              super(e, "packets");
            }
            [i.$finalize]() {
              this[i.$content] !== "*" && (this[i.$content] = this[i.$content].trim().split(/\s+/).filter((ce) => ["config", "datasets", "template", "xfdf", "xslt"].includes(ce)));
            }
          }
          class Ve extends i.XFAObject {
            constructor(ce) {
              super(e, "pageOffset"), this.x = (0, v.getInteger)({
                data: ce.x,
                defaultValue: "useXDCSetting",
                validate: (je) => !0
              }), this.y = (0, v.getInteger)({
                data: ce.y,
                defaultValue: "useXDCSetting",
                validate: (je) => !0
              });
            }
          }
          class st extends i.StringObject {
            constructor(ce) {
              super(e, "pageRange");
            }
            [i.$finalize]() {
              const ce = this[i.$content].trim().split(/\s+/).map((Ke) => parseInt(Ke, 10)), je = [];
              for (let Ke = 0, ut = ce.length; Ke < ut; Ke += 2)
                je.push(ce.slice(Ke, Ke + 2));
              this[i.$content] = je;
            }
          }
          class ct extends i.OptionObject {
            constructor(ce) {
              super(e, "pagination", ["simplex", "duplexShortEdge", "duplexLongEdge"]);
            }
          }
          class Rt extends i.OptionObject {
            constructor(ce) {
              super(e, "paginationOverride", ["none", "forceDuplex", "forceDuplexLongEdge", "forceDuplexShortEdge", "forceSimplex"]);
            }
          }
          class Lt extends i.IntegerObject {
            constructor(ce) {
              super(e, "part", 1, (je) => !1);
            }
          }
          class Ge extends i.XFAObject {
            constructor(ce) {
              super(e, "pcl", !0), this.name = ce.name || "", this.batchOutput = null, this.fontInfo = null, this.jog = null, this.mediumInfo = null, this.outputBin = null, this.pageOffset = null, this.staple = null, this.xdc = null;
            }
          }
          class Ne extends i.XFAObject {
            constructor(ce) {
              super(e, "pdf", !0), this.name = ce.name || "", this.adobeExtensionLevel = null, this.batchOutput = null, this.compression = null, this.creator = null, this.encryption = null, this.fontInfo = null, this.interactive = null, this.linearized = null, this.openAction = null, this.pdfa = null, this.producer = null, this.renderPolicy = null, this.scriptModel = null, this.silentPrint = null, this.submitFormat = null, this.tagged = null, this.version = null, this.viewerPreferences = null, this.xdc = null;
            }
          }
          class rt extends i.XFAObject {
            constructor(ce) {
              super(e, "pdfa", !0), this.amd = null, this.conformance = null, this.includeXDPContent = null, this.part = null;
            }
          }
          class tt extends i.XFAObject {
            constructor(ce) {
              super(e, "permissions", !0), this.accessibleContent = null, this.change = null, this.contentCopy = null, this.documentAssembly = null, this.formFieldFilling = null, this.modifyAnnots = null, this.plaintextMetadata = null, this.print = null, this.printHighQuality = null;
            }
          }
          class dt extends i.Option01 {
            constructor(ce) {
              super(e, "pickTrayByPDFSize");
            }
          }
          class Ct extends i.StringObject {
            constructor(ce) {
              super(e, "picture");
            }
          }
          class bt extends i.Option01 {
            constructor(ce) {
              super(e, "plaintextMetadata");
            }
          }
          class ht extends i.OptionObject {
            constructor(ce) {
              super(e, "presence", ["preserve", "dissolve", "dissolveStructure", "ignore", "remove"]);
            }
          }
          class vt extends i.XFAObject {
            constructor(ce) {
              super(e, "present", !0), this.behaviorOverride = null, this.cache = null, this.common = null, this.copies = null, this.destination = null, this.incrementalMerge = null, this.layout = null, this.output = null, this.overprint = null, this.pagination = null, this.paginationOverride = null, this.script = null, this.validate = null, this.xdp = null, this.driver = new i.XFAObjectArray(), this.labelPrinter = new i.XFAObjectArray(), this.pcl = new i.XFAObjectArray(), this.pdf = new i.XFAObjectArray(), this.ps = new i.XFAObjectArray(), this.submitUrl = new i.XFAObjectArray(), this.webClient = new i.XFAObjectArray(), this.zpl = new i.XFAObjectArray();
            }
          }
          class _t extends i.Option01 {
            constructor(ce) {
              super(e, "print");
            }
          }
          class Nt extends i.Option01 {
            constructor(ce) {
              super(e, "printHighQuality");
            }
          }
          class Mt extends i.OptionObject {
            constructor(ce) {
              super(e, "printScaling", ["appdefault", "noScaling"]);
            }
          }
          class Et extends i.StringObject {
            constructor(ce) {
              super(e, "printerName");
            }
          }
          class Re extends i.StringObject {
            constructor(ce) {
              super(e, "producer");
            }
          }
          class We extends i.XFAObject {
            constructor(ce) {
              super(e, "ps", !0), this.name = ce.name || "", this.batchOutput = null, this.fontInfo = null, this.jog = null, this.mediumInfo = null, this.outputBin = null, this.staple = null, this.xdc = null;
            }
          }
          class it extends i.ContentObject {
            constructor(ce) {
              super(e, "range");
            }
            [i.$finalize]() {
              this[i.$content] = this[i.$content].trim().split(/\s*,\s*/, 2).map((ce) => ce.split("-").map((je) => parseInt(je.trim(), 10))).filter((ce) => ce.every((je) => !isNaN(je))).map((ce) => (ce.length === 1 && ce.push(ce[0]), ce));
            }
          }
          class et extends i.ContentObject {
            constructor(ce) {
              super(e, "record");
            }
            [i.$finalize]() {
              this[i.$content] = this[i.$content].trim();
              const ce = parseInt(this[i.$content], 10);
              !isNaN(ce) && ce >= 0 && (this[i.$content] = ce);
            }
          }
          class At extends i.ContentObject {
            constructor(ce) {
              super(e, "relevant");
            }
            [i.$finalize]() {
              this[i.$content] = this[i.$content].trim().split(/\s+/);
            }
          }
          class It extends i.ContentObject {
            constructor(ce) {
              super(e, "rename");
            }
            [i.$finalize]() {
              this[i.$content] = this[i.$content].trim(), (this[i.$content].toLowerCase().startsWith("xml") || this[i.$content].match(new RegExp("[\\p{L}_][\\p{L}\\d._\\p{M}-]*", "u"))) && (0, a.warn)("XFA - Rename: invalid XFA name");
            }
          }
          class Vt extends i.OptionObject {
            constructor(ce) {
              super(e, "renderPolicy", ["server", "client"]);
            }
          }
          class Ut extends i.OptionObject {
            constructor(ce) {
              super(e, "runScripts", ["both", "client", "none", "server"]);
            }
          }
          class Wt extends i.XFAObject {
            constructor(ce) {
              super(e, "script", !0), this.currentPage = null, this.exclude = null, this.runScripts = null;
            }
          }
          class Kt extends i.OptionObject {
            constructor(ce) {
              super(e, "scriptModel", ["XFA", "none"]);
            }
          }
          class rn extends i.OptionObject {
            constructor(ce) {
              super(e, "severity", ["ignore", "error", "information", "trace", "warning"]);
            }
          }
          class ln extends i.XFAObject {
            constructor(ce) {
              super(e, "silentPrint", !0), this.addSilentPrint = null, this.printerName = null;
            }
          }
          class Cn extends i.XFAObject {
            constructor(ce) {
              super(e, "staple"), this.mode = (0, v.getStringOption)(ce.mode, ["usePrinterSetting", "on", "off"]);
            }
          }
          class fn extends i.StringObject {
            constructor(ce) {
              super(e, "startNode");
            }
          }
          class Fn extends i.IntegerObject {
            constructor(ce) {
              super(e, "startPage", 0, (je) => !0);
            }
          }
          class yn extends i.OptionObject {
            constructor(ce) {
              super(e, "submitFormat", ["html", "delegate", "fdf", "xml", "pdf"]);
            }
          }
          class Dn extends i.StringObject {
            constructor(ce) {
              super(e, "submitUrl");
            }
          }
          class En extends i.IntegerObject {
            constructor(ce) {
              super(e, "subsetBelow", 100, (je) => je >= 0 && je <= 100);
            }
          }
          class Bn extends i.Option01 {
            constructor(ce) {
              super(e, "suppressBanner");
            }
          }
          class Ln extends i.Option01 {
            constructor(ce) {
              super(e, "tagged");
            }
          }
          class vn extends i.XFAObject {
            constructor(ce) {
              super(e, "template", !0), this.base = null, this.relevant = null, this.startPage = null, this.uri = null, this.xsl = null;
            }
          }
          class kn extends i.OptionObject {
            constructor(ce) {
              super(e, "threshold", ["trace", "error", "information", "warning"]);
            }
          }
          class On extends i.OptionObject {
            constructor(ce) {
              super(e, "to", ["null", "memory", "stderr", "stdout", "system", "uri"]);
            }
          }
          class mn extends i.XFAObject {
            constructor(ce) {
              super(e, "templateCache"), this.maxEntries = (0, v.getInteger)({
                data: ce.maxEntries,
                defaultValue: 5,
                validate: (je) => je >= 0
              });
            }
          }
          class hn extends i.XFAObject {
            constructor(ce) {
              super(e, "trace", !0), this.area = new i.XFAObjectArray();
            }
          }
          class gn extends i.XFAObject {
            constructor(ce) {
              super(e, "transform", !0), this.groupParent = null, this.ifEmpty = null, this.nameAttr = null, this.picture = null, this.presence = null, this.rename = null, this.whitespace = null;
            }
          }
          class an extends i.OptionObject {
            constructor(ce) {
              super(e, "type", ["none", "ascii85", "asciiHex", "ccittfax", "flate", "lzw", "runLength", "native", "xdp", "mergedXDP"]);
            }
          }
          class dn extends i.StringObject {
            constructor(ce) {
              super(e, "uri");
            }
          }
          class Tn extends i.OptionObject {
            constructor(ce) {
              super(e, "validate", ["preSubmit", "prePrint", "preExecute", "preSave"]);
            }
          }
          class In extends i.ContentObject {
            constructor(ce) {
              super(e, "validateApprovalSignatures");
            }
            [i.$finalize]() {
              this[i.$content] = this[i.$content].trim().split(/\s+/).filter((ce) => ["docReady", "postSign"].includes(ce));
            }
          }
          class wn extends i.OptionObject {
            constructor(ce) {
              super(e, "validationMessaging", ["allMessagesIndividually", "allMessagesTogether", "firstMessageOnly", "noMessages"]);
            }
          }
          class Nn extends i.OptionObject {
            constructor(ce) {
              super(e, "version", ["1.7", "1.6", "1.5", "1.4", "1.3", "1.2"]);
            }
          }
          class Pn extends i.XFAObject {
            constructor(ce) {
              super(e, "VersionControl"), this.outputBelow = (0, v.getStringOption)(ce.outputBelow, ["warn", "error", "update"]), this.sourceAbove = (0, v.getStringOption)(ce.sourceAbove, ["warn", "error"]), this.sourceBelow = (0, v.getStringOption)(ce.sourceBelow, ["update", "maintain"]);
            }
          }
          class Rn extends i.XFAObject {
            constructor(ce) {
              super(e, "viewerPreferences", !0), this.ADBE_JSConsole = null, this.ADBE_JSDebugger = null, this.addViewerPreferences = null, this.duplexOption = null, this.enforce = null, this.numberOfCopies = null, this.pageRange = null, this.pickTrayByPDFSize = null, this.printScaling = null;
            }
          }
          class Un extends i.XFAObject {
            constructor(ce) {
              super(e, "webClient", !0), this.name = ce.name ? ce.name.trim() : "", this.fontInfo = null, this.xdc = null;
            }
          }
          class _n extends i.OptionObject {
            constructor(ce) {
              super(e, "whitespace", ["preserve", "ltrim", "normalize", "rtrim", "trim"]);
            }
          }
          class An extends i.ContentObject {
            constructor(ce) {
              super(e, "window");
            }
            [i.$finalize]() {
              const ce = this[i.$content].trim().split(/\s*,\s*/, 2).map((je) => parseInt(je, 10));
              if (ce.some((je) => isNaN(je))) {
                this[i.$content] = [0, 0];
                return;
              }
              ce.length === 1 && ce.push(ce[0]), this[i.$content] = ce;
            }
          }
          class Mn extends i.XFAObject {
            constructor(ce) {
              super(e, "xdc", !0), this.uri = new i.XFAObjectArray(), this.xsl = new i.XFAObjectArray();
            }
          }
          class xn extends i.XFAObject {
            constructor(ce) {
              super(e, "xdp", !0), this.packets = null;
            }
          }
          class jn extends i.XFAObject {
            constructor(ce) {
              super(e, "xsl", !0), this.debug = null, this.uri = null;
            }
          }
          class bn extends i.XFAObject {
            constructor(ce) {
              super(e, "zpl", !0), this.name = ce.name ? ce.name.trim() : "", this.batchOutput = null, this.flipLabel = null, this.fontInfo = null, this.xdc = null;
            }
          }
          class Xe {
            static [t.$buildXFAObject](ce, je) {
              if (Xe.hasOwnProperty(ce))
                return Xe[ce](je);
            }
            static acrobat(ce) {
              return new y(ce);
            }
            static acrobat7(ce) {
              return new r(ce);
            }
            static ADBE_JSConsole(ce) {
              return new h(ce);
            }
            static ADBE_JSDebugger(ce) {
              return new g(ce);
            }
            static addSilentPrint(ce) {
              return new d(ce);
            }
            static addViewerPreferences(ce) {
              return new c(ce);
            }
            static adjustData(ce) {
              return new n(ce);
            }
            static adobeExtensionLevel(ce) {
              return new o(ce);
            }
            static agent(ce) {
              return new x(ce);
            }
            static alwaysEmbed(ce) {
              return new f(ce);
            }
            static amd(ce) {
              return new m(ce);
            }
            static area(ce) {
              return new C(ce);
            }
            static attributes(ce) {
              return new p(ce);
            }
            static autoSave(ce) {
              return new w(ce);
            }
            static base(ce) {
              return new X(ce);
            }
            static batchOutput(ce) {
              return new M(ce);
            }
            static behaviorOverride(ce) {
              return new j(ce);
            }
            static cache(ce) {
              return new B(ce);
            }
            static change(ce) {
              return new R(ce);
            }
            static common(ce) {
              return new D(ce);
            }
            static compress(ce) {
              return new b(ce);
            }
            static compressLogicalStructure(ce) {
              return new l(ce);
            }
            static compressObjectStream(ce) {
              return new _(ce);
            }
            static compression(ce) {
              return new S(ce);
            }
            static config(ce) {
              return new A(ce);
            }
            static conformance(ce) {
              return new F(ce);
            }
            static contentCopy(ce) {
              return new T(ce);
            }
            static copies(ce) {
              return new O(ce);
            }
            static creator(ce) {
              return new U(ce);
            }
            static currentPage(ce) {
              return new G(ce);
            }
            static data(ce) {
              return new K(ce);
            }
            static debug(ce) {
              return new W(ce);
            }
            static defaultTypeface(ce) {
              return new z(ce);
            }
            static destination(ce) {
              return new V(ce);
            }
            static documentAssembly(ce) {
              return new L(ce);
            }
            static driver(ce) {
              return new Y(ce);
            }
            static duplexOption(ce) {
              return new J(ce);
            }
            static dynamicRender(ce) {
              return new ie(ce);
            }
            static embed(ce) {
              return new q(ce);
            }
            static encrypt(ce) {
              return new N(ce);
            }
            static encryption(ce) {
              return new Z(ce);
            }
            static encryptionLevel(ce) {
              return new E(ce);
            }
            static enforce(ce) {
              return new te(ce);
            }
            static equate(ce) {
              return new re(ce);
            }
            static equateRange(ce) {
              return new ee(ce);
            }
            static exclude(ce) {
              return new $(ce);
            }
            static excludeNS(ce) {
              return new k(ce);
            }
            static flipLabel(ce) {
              return new H(ce);
            }
            static fontInfo(ce) {
              return new ne(ce);
            }
            static formFieldFilling(ce) {
              return new ae(ce);
            }
            static groupParent(ce) {
              return new he(ce);
            }
            static ifEmpty(ce) {
              return new ue(ce);
            }
            static includeXDPContent(ce) {
              return new fe(ce);
            }
            static incrementalLoad(ce) {
              return new me(ce);
            }
            static incrementalMerge(ce) {
              return new Fe(ce);
            }
            static interactive(ce) {
              return new we(ce);
            }
            static jog(ce) {
              return new Ae(ce);
            }
            static labelPrinter(ce) {
              return new De(ce);
            }
            static layout(ce) {
              return new xe(ce);
            }
            static level(ce) {
              return new Te(ce);
            }
            static linearized(ce) {
              return new ve(ce);
            }
            static locale(ce) {
              return new Se(ce);
            }
            static localeSet(ce) {
              return new be(ce);
            }
            static log(ce) {
              return new Le(ce);
            }
            static map(ce) {
              return new ze(ce);
            }
            static mediumInfo(ce) {
              return new nt(ce);
            }
            static message(ce) {
              return new Ue(ce);
            }
            static messaging(ce) {
              return new Oe(ce);
            }
            static mode(ce) {
              return new _e(ce);
            }
            static modifyAnnots(ce) {
              return new at(ce);
            }
            static msgId(ce) {
              return new Je(ce);
            }
            static nameAttr(ce) {
              return new ot(ce);
            }
            static neverEmbed(ce) {
              return new mt(ce);
            }
            static numberOfCopies(ce) {
              return new Ze(ce);
            }
            static openAction(ce) {
              return new pt(ce);
            }
            static output(ce) {
              return new Ft(ce);
            }
            static outputBin(ce) {
              return new $e(ce);
            }
            static outputXSL(ce) {
              return new St(ce);
            }
            static overprint(ce) {
              return new xt(ce);
            }
            static packets(ce) {
              return new Ie(ce);
            }
            static pageOffset(ce) {
              return new Ve(ce);
            }
            static pageRange(ce) {
              return new st(ce);
            }
            static pagination(ce) {
              return new ct(ce);
            }
            static paginationOverride(ce) {
              return new Rt(ce);
            }
            static part(ce) {
              return new Lt(ce);
            }
            static pcl(ce) {
              return new Ge(ce);
            }
            static pdf(ce) {
              return new Ne(ce);
            }
            static pdfa(ce) {
              return new rt(ce);
            }
            static permissions(ce) {
              return new tt(ce);
            }
            static pickTrayByPDFSize(ce) {
              return new dt(ce);
            }
            static picture(ce) {
              return new Ct(ce);
            }
            static plaintextMetadata(ce) {
              return new bt(ce);
            }
            static presence(ce) {
              return new ht(ce);
            }
            static present(ce) {
              return new vt(ce);
            }
            static print(ce) {
              return new _t(ce);
            }
            static printHighQuality(ce) {
              return new Nt(ce);
            }
            static printScaling(ce) {
              return new Mt(ce);
            }
            static printerName(ce) {
              return new Et(ce);
            }
            static producer(ce) {
              return new Re(ce);
            }
            static ps(ce) {
              return new We(ce);
            }
            static range(ce) {
              return new it(ce);
            }
            static record(ce) {
              return new et(ce);
            }
            static relevant(ce) {
              return new At(ce);
            }
            static rename(ce) {
              return new It(ce);
            }
            static renderPolicy(ce) {
              return new Vt(ce);
            }
            static runScripts(ce) {
              return new Ut(ce);
            }
            static script(ce) {
              return new Wt(ce);
            }
            static scriptModel(ce) {
              return new Kt(ce);
            }
            static severity(ce) {
              return new rn(ce);
            }
            static silentPrint(ce) {
              return new ln(ce);
            }
            static staple(ce) {
              return new Cn(ce);
            }
            static startNode(ce) {
              return new fn(ce);
            }
            static startPage(ce) {
              return new Fn(ce);
            }
            static submitFormat(ce) {
              return new yn(ce);
            }
            static submitUrl(ce) {
              return new Dn(ce);
            }
            static subsetBelow(ce) {
              return new En(ce);
            }
            static suppressBanner(ce) {
              return new Bn(ce);
            }
            static tagged(ce) {
              return new Ln(ce);
            }
            static template(ce) {
              return new vn(ce);
            }
            static templateCache(ce) {
              return new mn(ce);
            }
            static threshold(ce) {
              return new kn(ce);
            }
            static to(ce) {
              return new On(ce);
            }
            static trace(ce) {
              return new hn(ce);
            }
            static transform(ce) {
              return new gn(ce);
            }
            static type(ce) {
              return new an(ce);
            }
            static uri(ce) {
              return new dn(ce);
            }
            static validate(ce) {
              return new Tn(ce);
            }
            static validateApprovalSignatures(ce) {
              return new In(ce);
            }
            static validationMessaging(ce) {
              return new wn(ce);
            }
            static version(ce) {
              return new Nn(ce);
            }
            static versionControl(ce) {
              return new Pn(ce);
            }
            static viewerPreferences(ce) {
              return new Rn(ce);
            }
            static webClient(ce) {
              return new Un(ce);
            }
            static whitespace(ce) {
              return new _n(ce);
            }
            static window(ce) {
              return new An(ce);
            }
            static xdc(ce) {
              return new Mn(ce);
            }
            static xdp(ce) {
              return new xn(ce);
            }
            static xsl(ce) {
              return new jn(ce);
            }
            static zpl(ce) {
              return new bn(ce);
            }
          }
          u.ConfigNamespace = Xe;
        },
        /* 92 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.ConnectionSetNamespace = void 0;
          var t = P(79), i = P(77);
          const v = t.NamespaceIds.connectionSet.id;
          class a extends i.XFAObject {
            constructor(p) {
              super(v, "connectionSet", !0), this.wsdlConnection = new i.XFAObjectArray(), this.xmlConnection = new i.XFAObjectArray(), this.xsdConnection = new i.XFAObjectArray();
            }
          }
          class e extends i.XFAObject {
            constructor(p) {
              super(v, "effectiveInputPolicy"), this.id = p.id || "", this.name = p.name || "", this.use = p.use || "", this.usehref = p.usehref || "";
            }
          }
          class y extends i.XFAObject {
            constructor(p) {
              super(v, "effectiveOutputPolicy"), this.id = p.id || "", this.name = p.name || "", this.use = p.use || "", this.usehref = p.usehref || "";
            }
          }
          class r extends i.StringObject {
            constructor(p) {
              super(v, "operation"), this.id = p.id || "", this.input = p.input || "", this.name = p.name || "", this.output = p.output || "", this.use = p.use || "", this.usehref = p.usehref || "";
            }
          }
          class h extends i.StringObject {
            constructor(p) {
              super(v, "rootElement"), this.id = p.id || "", this.name = p.name || "", this.use = p.use || "", this.usehref = p.usehref || "";
            }
          }
          class g extends i.StringObject {
            constructor(p) {
              super(v, "soapAction"), this.id = p.id || "", this.name = p.name || "", this.use = p.use || "", this.usehref = p.usehref || "";
            }
          }
          class d extends i.StringObject {
            constructor(p) {
              super(v, "soapAddress"), this.id = p.id || "", this.name = p.name || "", this.use = p.use || "", this.usehref = p.usehref || "";
            }
          }
          class c extends i.StringObject {
            constructor(p) {
              super(v, "uri"), this.id = p.id || "", this.name = p.name || "", this.use = p.use || "", this.usehref = p.usehref || "";
            }
          }
          class n extends i.StringObject {
            constructor(p) {
              super(v, "wsdlAddress"), this.id = p.id || "", this.name = p.name || "", this.use = p.use || "", this.usehref = p.usehref || "";
            }
          }
          class o extends i.XFAObject {
            constructor(p) {
              super(v, "wsdlConnection", !0), this.dataDescription = p.dataDescription || "", this.name = p.name || "", this.effectiveInputPolicy = null, this.effectiveOutputPolicy = null, this.operation = null, this.soapAction = null, this.soapAddress = null, this.wsdlAddress = null;
            }
          }
          class x extends i.XFAObject {
            constructor(p) {
              super(v, "xmlConnection", !0), this.dataDescription = p.dataDescription || "", this.name = p.name || "", this.uri = null;
            }
          }
          class f extends i.XFAObject {
            constructor(p) {
              super(v, "xsdConnection", !0), this.dataDescription = p.dataDescription || "", this.name = p.name || "", this.rootElement = null, this.uri = null;
            }
          }
          class m {
            static [t.$buildXFAObject](p, w) {
              if (m.hasOwnProperty(p))
                return m[p](w);
            }
            static connectionSet(p) {
              return new a(p);
            }
            static effectiveInputPolicy(p) {
              return new e(p);
            }
            static effectiveOutputPolicy(p) {
              return new y(p);
            }
            static operation(p) {
              return new r(p);
            }
            static rootElement(p) {
              return new h(p);
            }
            static soapAction(p) {
              return new g(p);
            }
            static soapAddress(p) {
              return new d(p);
            }
            static uri(p) {
              return new c(p);
            }
            static wsdlAddress(p) {
              return new n(p);
            }
            static wsdlConnection(p) {
              return new o(p);
            }
            static xmlConnection(p) {
              return new x(p);
            }
            static xsdConnection(p) {
              return new f(p);
            }
          }
          u.ConnectionSetNamespace = m;
        },
        /* 93 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.DatasetsNamespace = void 0;
          var t = P(77), i = P(79);
          const v = i.NamespaceIds.datasets.id;
          class a extends t.XmlObject {
            constructor(h) {
              super(v, "data", h);
            }
            [t.$isNsAgnostic]() {
              return !0;
            }
          }
          class e extends t.XFAObject {
            constructor(h) {
              super(v, "datasets", !0), this.data = null, this.Signature = null;
            }
            [t.$onChild](h) {
              const g = h[t.$nodeName];
              (g === "data" && h[t.$namespaceId] === v || g === "Signature" && h[t.$namespaceId] === i.NamespaceIds.signature.id) && (this[g] = h), this[t.$appendChild](h);
            }
          }
          class y {
            static [i.$buildXFAObject](h, g) {
              if (y.hasOwnProperty(h))
                return y[h](g);
            }
            static datasets(h) {
              return new e(h);
            }
            static data(h) {
              return new a(h);
            }
          }
          u.DatasetsNamespace = y;
        },
        /* 94 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.LocaleSetNamespace = void 0;
          var t = P(79), i = P(77), v = P(78);
          const a = t.NamespaceIds.localeSet.id;
          class e extends i.XFAObject {
            constructor(F) {
              super(a, "calendarSymbols", !0), this.name = "gregorian", this.dayNames = new i.XFAObjectArray(2), this.eraNames = null, this.meridiemNames = null, this.monthNames = new i.XFAObjectArray(2);
            }
          }
          class y extends i.StringObject {
            constructor(F) {
              super(a, "currencySymbol"), this.name = (0, v.getStringOption)(F.name, ["symbol", "isoname", "decimal"]);
            }
          }
          class r extends i.XFAObject {
            constructor(F) {
              super(a, "currencySymbols", !0), this.currencySymbol = new i.XFAObjectArray(3);
            }
          }
          class h extends i.StringObject {
            constructor(F) {
              super(a, "datePattern"), this.name = (0, v.getStringOption)(F.name, ["full", "long", "med", "short"]);
            }
          }
          class g extends i.XFAObject {
            constructor(F) {
              super(a, "datePatterns", !0), this.datePattern = new i.XFAObjectArray(4);
            }
          }
          class d extends i.ContentObject {
            constructor(F) {
              super(a, "dateTimeSymbols");
            }
          }
          class c extends i.StringObject {
            constructor(F) {
              super(a, "day");
            }
          }
          class n extends i.XFAObject {
            constructor(F) {
              super(a, "dayNames", !0), this.abbr = (0, v.getInteger)({
                data: F.abbr,
                defaultValue: 0,
                validate: (T) => T === 1
              }), this.day = new i.XFAObjectArray(7);
            }
          }
          class o extends i.StringObject {
            constructor(F) {
              super(a, "era");
            }
          }
          class x extends i.XFAObject {
            constructor(F) {
              super(a, "eraNames", !0), this.era = new i.XFAObjectArray(2);
            }
          }
          class f extends i.XFAObject {
            constructor(F) {
              super(a, "locale", !0), this.desc = F.desc || "", this.name = "isoname", this.calendarSymbols = null, this.currencySymbols = null, this.datePatterns = null, this.dateTimeSymbols = null, this.numberPatterns = null, this.numberSymbols = null, this.timePatterns = null, this.typeFaces = null;
            }
          }
          class m extends i.XFAObject {
            constructor(F) {
              super(a, "localeSet", !0), this.locale = new i.XFAObjectArray();
            }
          }
          class C extends i.StringObject {
            constructor(F) {
              super(a, "meridiem");
            }
          }
          class p extends i.XFAObject {
            constructor(F) {
              super(a, "meridiemNames", !0), this.meridiem = new i.XFAObjectArray(2);
            }
          }
          class w extends i.StringObject {
            constructor(F) {
              super(a, "month");
            }
          }
          class X extends i.XFAObject {
            constructor(F) {
              super(a, "monthNames", !0), this.abbr = (0, v.getInteger)({
                data: F.abbr,
                defaultValue: 0,
                validate: (T) => T === 1
              }), this.month = new i.XFAObjectArray(12);
            }
          }
          class M extends i.StringObject {
            constructor(F) {
              super(a, "numberPattern"), this.name = (0, v.getStringOption)(F.name, ["full", "long", "med", "short"]);
            }
          }
          class j extends i.XFAObject {
            constructor(F) {
              super(a, "numberPatterns", !0), this.numberPattern = new i.XFAObjectArray(4);
            }
          }
          class B extends i.StringObject {
            constructor(F) {
              super(a, "numberSymbol"), this.name = (0, v.getStringOption)(F.name, ["decimal", "grouping", "percent", "minus", "zero"]);
            }
          }
          class R extends i.XFAObject {
            constructor(F) {
              super(a, "numberSymbols", !0), this.numberSymbol = new i.XFAObjectArray(5);
            }
          }
          class D extends i.StringObject {
            constructor(F) {
              super(a, "timePattern"), this.name = (0, v.getStringOption)(F.name, ["full", "long", "med", "short"]);
            }
          }
          class b extends i.XFAObject {
            constructor(F) {
              super(a, "timePatterns", !0), this.timePattern = new i.XFAObjectArray(4);
            }
          }
          class l extends i.XFAObject {
            constructor(F) {
              super(a, "typeFace", !0), this.name = F.name | "";
            }
          }
          class _ extends i.XFAObject {
            constructor(F) {
              super(a, "typeFaces", !0), this.typeFace = new i.XFAObjectArray();
            }
          }
          class S {
            static [t.$buildXFAObject](F, T) {
              if (S.hasOwnProperty(F))
                return S[F](T);
            }
            static calendarSymbols(F) {
              return new e(F);
            }
            static currencySymbol(F) {
              return new y(F);
            }
            static currencySymbols(F) {
              return new r(F);
            }
            static datePattern(F) {
              return new h(F);
            }
            static datePatterns(F) {
              return new g(F);
            }
            static dateTimeSymbols(F) {
              return new d(F);
            }
            static day(F) {
              return new c(F);
            }
            static dayNames(F) {
              return new n(F);
            }
            static era(F) {
              return new o(F);
            }
            static eraNames(F) {
              return new x(F);
            }
            static locale(F) {
              return new f(F);
            }
            static localeSet(F) {
              return new m(F);
            }
            static meridiem(F) {
              return new C(F);
            }
            static meridiemNames(F) {
              return new p(F);
            }
            static month(F) {
              return new w(F);
            }
            static monthNames(F) {
              return new X(F);
            }
            static numberPattern(F) {
              return new M(F);
            }
            static numberPatterns(F) {
              return new j(F);
            }
            static numberSymbol(F) {
              return new B(F);
            }
            static numberSymbols(F) {
              return new R(F);
            }
            static timePattern(F) {
              return new D(F);
            }
            static timePatterns(F) {
              return new b(F);
            }
            static typeFace(F) {
              return new l(F);
            }
            static typeFaces(F) {
              return new _(F);
            }
          }
          u.LocaleSetNamespace = S;
        },
        /* 95 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.SignatureNamespace = void 0;
          var t = P(79), i = P(77);
          const v = t.NamespaceIds.signature.id;
          class a extends i.XFAObject {
            constructor(r) {
              super(v, "signature", !0);
            }
          }
          class e {
            static [t.$buildXFAObject](r, h) {
              if (e.hasOwnProperty(r))
                return e[r](h);
            }
            static signature(r) {
              return new a(r);
            }
          }
          u.SignatureNamespace = e;
        },
        /* 96 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.StylesheetNamespace = void 0;
          var t = P(79), i = P(77);
          const v = t.NamespaceIds.stylesheet.id;
          class a extends i.XFAObject {
            constructor(r) {
              super(v, "stylesheet", !0);
            }
          }
          class e {
            static [t.$buildXFAObject](r, h) {
              if (e.hasOwnProperty(r))
                return e[r](h);
            }
            static stylesheet(r) {
              return new a(r);
            }
          }
          u.StylesheetNamespace = e;
        },
        /* 97 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.XdpNamespace = void 0;
          var t = P(79), i = P(77);
          const v = t.NamespaceIds.xdp.id;
          class a extends i.XFAObject {
            constructor(r) {
              super(v, "xdp", !0), this.uuid = r.uuid || "", this.timeStamp = r.timeStamp || "", this.config = null, this.connectionSet = null, this.datasets = null, this.localeSet = null, this.stylesheet = new i.XFAObjectArray(), this.template = null;
            }
            [i.$onChildCheck](r) {
              const h = t.NamespaceIds[r[i.$nodeName]];
              return h && r[i.$namespaceId] === h.id;
            }
          }
          class e {
            static [t.$buildXFAObject](r, h) {
              if (e.hasOwnProperty(r))
                return e[r](h);
            }
            static xdp(r) {
              return new a(r);
            }
          }
          u.XdpNamespace = e;
        },
        /* 98 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.XhtmlNamespace = void 0;
          var t = P(77), i = P(79), v = P(84), a = P(78);
          const e = i.NamespaceIds.xhtml.id, y = Symbol(), r = /* @__PURE__ */ new Set(["color", "font", "font-family", "font-size", "font-stretch", "font-style", "font-weight", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "letter-spacing", "line-height", "orphans", "page-break-after", "page-break-before", "page-break-inside", "tab-interval", "tab-stop", "text-align", "text-decoration", "text-indent", "vertical-align", "widows", "kerning-mode", "xfa-font-horizontal-scale", "xfa-font-vertical-scale", "xfa-spacerun", "xfa-tab-stops"]), h = /* @__PURE__ */ new Map([["page-break-after", "breakAfter"], ["page-break-before", "breakBefore"], ["page-break-inside", "breakInside"], ["kerning-mode", (A) => A === "none" ? "none" : "normal"], ["xfa-font-horizontal-scale", (A) => `scaleX(${Math.max(0, Math.min(parseInt(A) / 100)).toFixed(2)})`], ["xfa-font-vertical-scale", (A) => `scaleY(${Math.max(0, Math.min(parseInt(A) / 100)).toFixed(2)})`], ["xfa-spacerun", ""], ["xfa-tab-stops", ""], ["font-size", (A, F) => (A = F.fontSize = (0, a.getMeasurement)(A), (0, v.measureToString)(0.99 * A))], ["letter-spacing", (A) => (0, v.measureToString)((0, a.getMeasurement)(A))], ["line-height", (A) => (0, v.measureToString)((0, a.getMeasurement)(A))], ["margin", (A) => (0, v.measureToString)((0, a.getMeasurement)(A))], ["margin-bottom", (A) => (0, v.measureToString)((0, a.getMeasurement)(A))], ["margin-left", (A) => (0, v.measureToString)((0, a.getMeasurement)(A))], ["margin-right", (A) => (0, v.measureToString)((0, a.getMeasurement)(A))], ["margin-top", (A) => (0, v.measureToString)((0, a.getMeasurement)(A))], ["text-indent", (A) => (0, v.measureToString)((0, a.getMeasurement)(A))], ["font-family", (A) => A], ["vertical-align", (A) => (0, v.measureToString)((0, a.getMeasurement)(A))]]), g = /\s+/g, d = /[\r\n]+/g, c = /\r\n?/g;
          function n(A, F, T) {
            const O = /* @__PURE__ */ Object.create(null);
            if (!A)
              return O;
            const U = /* @__PURE__ */ Object.create(null);
            for (const [G, K] of A.split(";").map((W) => W.split(":", 2))) {
              const W = h.get(G);
              if (W === "")
                continue;
              let z = K;
              W && (typeof W == "string" ? z = W : z = W(K, U)), G.endsWith("scale") ? O.transform ? O.transform = `${O[G]} ${z}` : O.transform = z : O[G.replaceAll(/-([a-zA-Z])/g, (V, L) => L.toUpperCase())] = z;
            }
            if (O.fontFamily && (0, v.setFontFamily)({
              typeface: O.fontFamily,
              weight: O.fontWeight || "normal",
              posture: O.fontStyle || "normal",
              size: U.fontSize || 0
            }, F, F[t.$globalData].fontFinder, O), T && O.verticalAlign && O.verticalAlign !== "0px" && O.fontSize) {
              const W = (0, a.getMeasurement)(O.fontSize);
              O.fontSize = (0, v.measureToString)(W * 0.583), O.verticalAlign = (0, v.measureToString)(Math.sign((0, a.getMeasurement)(O.verticalAlign)) * W * 0.333);
            }
            return T && O.fontSize && (O.fontSize = `calc(${O.fontSize} * var(--scale-factor))`), (0, v.fixTextIndent)(O), O;
          }
          function o(A) {
            return A.style ? A.style.trim().split(/\s*;\s*/).filter((F) => !!F).map((F) => F.split(/\s*:\s*/, 2)).filter(([F, T]) => (F === "font-family" && A[t.$globalData].usedTypefaces.add(T), r.has(F))).map((F) => F.join(":")).join(";") : "";
          }
          const x = /* @__PURE__ */ new Set(["body", "html"]);
          class f extends t.XmlObject {
            constructor(F, T) {
              super(e, T), this[y] = !1, this.style = F.style || "";
            }
            [t.$clean](F) {
              super[t.$clean](F), this.style = o(this);
            }
            [t.$acceptWhitespace]() {
              return !x.has(this[t.$nodeName]);
            }
            [t.$onText](F, T = !1) {
              T ? this[y] = !0 : (F = F.replace(d, ""), this.style.includes("xfa-spacerun:yes") || (F = F.replace(g, " "))), F && (this[t.$content] += F);
            }
            [t.$pushGlyphs](F, T = !0) {
              const O = /* @__PURE__ */ Object.create(null), U = {
                top: NaN,
                bottom: NaN,
                left: NaN,
                right: NaN
              };
              let G = null;
              for (const [K, W] of this.style.split(";").map((z) => z.split(":", 2)))
                switch (K) {
                  case "font-family":
                    O.typeface = (0, a.stripQuotes)(W);
                    break;
                  case "font-size":
                    O.size = (0, a.getMeasurement)(W);
                    break;
                  case "font-weight":
                    O.weight = W;
                    break;
                  case "font-style":
                    O.posture = W;
                    break;
                  case "letter-spacing":
                    O.letterSpacing = (0, a.getMeasurement)(W);
                    break;
                  case "margin":
                    const z = W.split(/ \t/).map((V) => (0, a.getMeasurement)(V));
                    switch (z.length) {
                      case 1:
                        U.top = U.bottom = U.left = U.right = z[0];
                        break;
                      case 2:
                        U.top = U.bottom = z[0], U.left = U.right = z[1];
                        break;
                      case 3:
                        U.top = z[0], U.bottom = z[2], U.left = U.right = z[1];
                        break;
                      case 4:
                        U.top = z[0], U.left = z[1], U.bottom = z[2], U.right = z[3];
                        break;
                    }
                    break;
                  case "margin-top":
                    U.top = (0, a.getMeasurement)(W);
                    break;
                  case "margin-bottom":
                    U.bottom = (0, a.getMeasurement)(W);
                    break;
                  case "margin-left":
                    U.left = (0, a.getMeasurement)(W);
                    break;
                  case "margin-right":
                    U.right = (0, a.getMeasurement)(W);
                    break;
                  case "line-height":
                    G = (0, a.getMeasurement)(W);
                    break;
                }
              if (F.pushData(O, U, G), this[t.$content])
                F.addString(this[t.$content]);
              else
                for (const K of this[t.$getChildren]()) {
                  if (K[t.$nodeName] === "#text") {
                    F.addString(K[t.$content]);
                    continue;
                  }
                  K[t.$pushGlyphs](F);
                }
              T && F.popFont();
            }
            [t.$toHTML](F) {
              const T = [];
              if (this[t.$extra] = {
                children: T
              }, this[t.$childrenToHTML]({}), T.length === 0 && !this[t.$content])
                return a.HTMLResult.EMPTY;
              let O;
              return this[y] ? O = this[t.$content] ? this[t.$content].replace(c, `
`) : void 0 : O = this[t.$content] || void 0, a.HTMLResult.success({
                name: this[t.$nodeName],
                attributes: {
                  href: this.href,
                  style: n(this.style, this, this[y])
                },
                children: T,
                value: O
              });
            }
          }
          class m extends f {
            constructor(F) {
              super(F, "a"), this.href = (0, v.fixURL)(F.href) || "";
            }
          }
          class C extends f {
            constructor(F) {
              super(F, "b");
            }
            [t.$pushGlyphs](F) {
              F.pushFont({
                weight: "bold"
              }), super[t.$pushGlyphs](F), F.popFont();
            }
          }
          class p extends f {
            constructor(F) {
              super(F, "body");
            }
            [t.$toHTML](F) {
              const T = super[t.$toHTML](F), {
                html: O
              } = T;
              return O ? (O.name = "div", O.attributes.class = ["xfaRich"], T) : a.HTMLResult.EMPTY;
            }
          }
          class w extends f {
            constructor(F) {
              super(F, "br");
            }
            [t.$text]() {
              return `
`;
            }
            [t.$pushGlyphs](F) {
              F.addString(`
`);
            }
            [t.$toHTML](F) {
              return a.HTMLResult.success({
                name: "br"
              });
            }
          }
          class X extends f {
            constructor(F) {
              super(F, "html");
            }
            [t.$toHTML](F) {
              const T = [];
              if (this[t.$extra] = {
                children: T
              }, this[t.$childrenToHTML]({}), T.length === 0)
                return a.HTMLResult.success({
                  name: "div",
                  attributes: {
                    class: ["xfaRich"],
                    style: {}
                  },
                  value: this[t.$content] || ""
                });
              if (T.length === 1) {
                const O = T[0];
                if (O.attributes && O.attributes.class.includes("xfaRich"))
                  return a.HTMLResult.success(O);
              }
              return a.HTMLResult.success({
                name: "div",
                attributes: {
                  class: ["xfaRich"],
                  style: {}
                },
                children: T
              });
            }
          }
          class M extends f {
            constructor(F) {
              super(F, "i");
            }
            [t.$pushGlyphs](F) {
              F.pushFont({
                posture: "italic"
              }), super[t.$pushGlyphs](F), F.popFont();
            }
          }
          class j extends f {
            constructor(F) {
              super(F, "li");
            }
          }
          class B extends f {
            constructor(F) {
              super(F, "ol");
            }
          }
          class R extends f {
            constructor(F) {
              super(F, "p");
            }
            [t.$pushGlyphs](F) {
              super[t.$pushGlyphs](F, !1), F.addString(`
`), F.addPara(), F.popFont();
            }
            [t.$text]() {
              return this[t.$getParent]()[t.$getChildren]().at(-1) === this ? super[t.$text]() : super[t.$text]() + `
`;
            }
          }
          class D extends f {
            constructor(F) {
              super(F, "span");
            }
          }
          class b extends f {
            constructor(F) {
              super(F, "sub");
            }
          }
          class l extends f {
            constructor(F) {
              super(F, "sup");
            }
          }
          class _ extends f {
            constructor(F) {
              super(F, "ul");
            }
          }
          class S {
            static [i.$buildXFAObject](F, T) {
              if (S.hasOwnProperty(F))
                return S[F](T);
            }
            static a(F) {
              return new m(F);
            }
            static b(F) {
              return new C(F);
            }
            static body(F) {
              return new p(F);
            }
            static br(F) {
              return new w(F);
            }
            static html(F) {
              return new X(F);
            }
            static i(F) {
              return new M(F);
            }
            static li(F) {
              return new j(F);
            }
            static ol(F) {
              return new B(F);
            }
            static p(F) {
              return new R(F);
            }
            static span(F) {
              return new D(F);
            }
            static sub(F) {
              return new b(F);
            }
            static sup(F) {
              return new l(F);
            }
            static ul(F) {
              return new _(F);
            }
          }
          u.XhtmlNamespace = S;
        },
        /* 99 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.UnknownNamespace = void 0;
          var t = P(79), i = P(77);
          class v {
            constructor(e) {
              this.namespaceId = e;
            }
            [t.$buildXFAObject](e, y) {
              return new i.XmlObject(this.namespaceId, e, y);
            }
          }
          u.UnknownNamespace = v;
        },
        /* 100 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.DatasetReader = void 0;
          var t = P(2), i = P(6), v = P(66);
          function a(r) {
            try {
              return (0, t.stringToUTF8String)(r);
            } catch (h) {
              return (0, t.warn)(`UTF-8 decoding failed: "${h}".`), r;
            }
          }
          class e extends v.SimpleXMLParser {
            constructor(h) {
              super(h), this.node = null;
            }
            onEndElement(h) {
              const g = super.onEndElement(h);
              if (g && h === "xfa:datasets")
                throw this.node = g, new Error("Aborting DatasetXMLParser.");
            }
          }
          class y {
            constructor(h) {
              if (h.datasets)
                this.node = new v.SimpleXMLParser({
                  hasAttributes: !0
                }).parseFromString(h.datasets).documentElement;
              else {
                const g = new e({
                  hasAttributes: !0
                });
                try {
                  g.parseFromString(h["xdp:xdp"]);
                } catch {
                }
                this.node = g.node;
              }
            }
            getValue(h) {
              if (!this.node || !h)
                return "";
              const g = this.node.searchNode((0, i.parseXFAPath)(h), 0);
              if (!g)
                return "";
              const d = g.firstChild;
              return d && d.nodeName === "value" ? g.children.map((c) => a(c.textContent)) : a(g.textContent);
            }
          }
          u.DatasetReader = y;
        },
        /* 101 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.XRef = void 0;
          var t = P(2), i = P(5), v = P(6), a = P(17), e = P(7), y = P(67);
          class r {
            constructor(g, d) {
              this.stream = g, this.pdfManager = d, this.entries = [], this.xrefstms = /* @__PURE__ */ Object.create(null), this._cacheMap = /* @__PURE__ */ new Map(), this._pendingRefs = new i.RefSet(), this.stats = new v.DocStats(d.msgHandler), this._newRefNum = null;
            }
            getNewRef() {
              return this._newRefNum === null && (this._newRefNum = this.entries.length || 1), i.Ref.get(this._newRefNum++, 0);
            }
            resetNewRef() {
              this._newRefNum = null;
            }
            setStartXRef(g) {
              this.startXRefQueue = [g];
            }
            parse(g = !1) {
              let d;
              g ? ((0, t.warn)("Indexing all PDF objects"), d = this.indexObjects()) : d = this.readXRef(), d.assignXref(this), this.trailer = d;
              let c;
              try {
                c = d.get("Encrypt");
              } catch (o) {
                if (o instanceof v.MissingDataException)
                  throw o;
                (0, t.warn)(`XRef.parse - Invalid "Encrypt" reference: "${o}".`);
              }
              if (c instanceof i.Dict) {
                const o = d.get("ID"), x = o && o.length ? o[0] : "";
                c.suppressEncryption = !0, this.encrypt = new y.CipherTransformFactory(c, x, this.pdfManager.password);
              }
              let n;
              try {
                n = d.get("Root");
              } catch (o) {
                if (o instanceof v.MissingDataException)
                  throw o;
                (0, t.warn)(`XRef.parse - Invalid "Root" reference: "${o}".`);
              }
              if (n instanceof i.Dict)
                try {
                  if (n.get("Pages") instanceof i.Dict) {
                    this.root = n;
                    return;
                  }
                } catch (o) {
                  if (o instanceof v.MissingDataException)
                    throw o;
                  (0, t.warn)(`XRef.parse - Invalid "Pages" reference: "${o}".`);
                }
              throw g ? new t.InvalidPDFException("Invalid Root reference.") : new v.XRefParseException();
            }
            processXRefTable(g) {
              "tableState" in this || (this.tableState = {
                entryNum: 0,
                streamPos: g.lexer.stream.pos,
                parserBuf1: g.buf1,
                parserBuf2: g.buf2
              });
              const d = this.readXRefTable(g);
              if (!(0, i.isCmd)(d, "trailer"))
                throw new t.FormatError("Invalid XRef table: could not find trailer dictionary");
              let c = g.getObj();
              if (!(c instanceof i.Dict) && c.dict && (c = c.dict), !(c instanceof i.Dict))
                throw new t.FormatError("Invalid XRef table: could not parse trailer dictionary");
              return delete this.tableState, c;
            }
            readXRefTable(g) {
              const d = g.lexer.stream, c = this.tableState;
              d.pos = c.streamPos, g.buf1 = c.parserBuf1, g.buf2 = c.parserBuf2;
              let n;
              for (; ; ) {
                if (!("firstEntryNum" in c) || !("entryCount" in c)) {
                  if ((0, i.isCmd)(n = g.getObj(), "trailer"))
                    break;
                  c.firstEntryNum = n, c.entryCount = g.getObj();
                }
                let o = c.firstEntryNum;
                const x = c.entryCount;
                if (!Number.isInteger(o) || !Number.isInteger(x))
                  throw new t.FormatError("Invalid XRef table: wrong types in subsection header");
                for (let f = c.entryNum; f < x; f++) {
                  c.streamPos = d.pos, c.entryNum = f, c.parserBuf1 = g.buf1, c.parserBuf2 = g.buf2;
                  const m = {};
                  m.offset = g.getObj(), m.gen = g.getObj();
                  const C = g.getObj();
                  if (C instanceof i.Cmd)
                    switch (C.cmd) {
                      case "f":
                        m.free = !0;
                        break;
                      case "n":
                        m.uncompressed = !0;
                        break;
                    }
                  if (!Number.isInteger(m.offset) || !Number.isInteger(m.gen) || !(m.free || m.uncompressed))
                    throw new t.FormatError(`Invalid entry in XRef subsection: ${o}, ${x}`);
                  f === 0 && m.free && o === 1 && (o = 0), this.entries[f + o] || (this.entries[f + o] = m);
                }
                c.entryNum = 0, c.streamPos = d.pos, c.parserBuf1 = g.buf1, c.parserBuf2 = g.buf2, delete c.firstEntryNum, delete c.entryCount;
              }
              if (this.entries[0] && !this.entries[0].free)
                throw new t.FormatError("Invalid XRef table: unexpected first object");
              return n;
            }
            processXRefStream(g) {
              if (!("streamState" in this)) {
                const d = g.dict, c = d.get("W");
                let n = d.get("Index");
                n || (n = [0, d.get("Size")]), this.streamState = {
                  entryRanges: n,
                  byteWidths: c,
                  entryNum: 0,
                  streamPos: g.pos
                };
              }
              return this.readXRefStream(g), delete this.streamState, g.dict;
            }
            readXRefStream(g) {
              const d = this.streamState;
              g.pos = d.streamPos;
              const [c, n, o] = d.byteWidths, x = d.entryRanges;
              for (; x.length > 0; ) {
                const [f, m] = x;
                if (!Number.isInteger(f) || !Number.isInteger(m))
                  throw new t.FormatError(`Invalid XRef range fields: ${f}, ${m}`);
                if (!Number.isInteger(c) || !Number.isInteger(n) || !Number.isInteger(o))
                  throw new t.FormatError(`Invalid XRef entry fields length: ${f}, ${m}`);
                for (let C = d.entryNum; C < m; ++C) {
                  d.entryNum = C, d.streamPos = g.pos;
                  let p = 0, w = 0, X = 0;
                  for (let j = 0; j < c; ++j) {
                    const B = g.getByte();
                    if (B === -1)
                      throw new t.FormatError("Invalid XRef byteWidths 'type'.");
                    p = p << 8 | B;
                  }
                  c === 0 && (p = 1);
                  for (let j = 0; j < n; ++j) {
                    const B = g.getByte();
                    if (B === -1)
                      throw new t.FormatError("Invalid XRef byteWidths 'offset'.");
                    w = w << 8 | B;
                  }
                  for (let j = 0; j < o; ++j) {
                    const B = g.getByte();
                    if (B === -1)
                      throw new t.FormatError("Invalid XRef byteWidths 'generation'.");
                    X = X << 8 | B;
                  }
                  const M = {};
                  switch (M.offset = w, M.gen = X, p) {
                    case 0:
                      M.free = !0;
                      break;
                    case 1:
                      M.uncompressed = !0;
                      break;
                    case 2:
                      break;
                    default:
                      throw new t.FormatError(`Invalid XRef entry type: ${p}`);
                  }
                  this.entries[f + C] || (this.entries[f + C] = M);
                }
                d.entryNum = 0, d.streamPos = g.pos, x.splice(0, 2);
              }
            }
            indexObjects() {
              function f(T, O) {
                let U = "", G = T[O];
                for (; G !== 10 && G !== 13 && G !== 60 && !(++O >= T.length); )
                  U += String.fromCharCode(G), G = T[O];
                return U;
              }
              function m(T, O, U) {
                const G = U.length, K = T.length;
                let W = 0;
                for (; O < K; ) {
                  let z = 0;
                  for (; z < G && T[O + z] === U[z]; )
                    ++z;
                  if (z >= G)
                    break;
                  O++, W++;
                }
                return W;
              }
              const C = /^(\d+)\s+(\d+)\s+obj\b/, p = /\bendobj[\b\s]$/, w = /\s+(\d+\s+\d+\s+obj[\b\s<])$/, X = 25, M = new Uint8Array([116, 114, 97, 105, 108, 101, 114]), j = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]), B = new Uint8Array([111, 98, 106]), R = new Uint8Array([47, 88, 82, 101, 102]);
              this.entries.length = 0, this._cacheMap.clear();
              const D = this.stream;
              D.pos = 0;
              const b = D.getBytes(), l = b.length;
              let _ = D.start;
              const S = [], A = [];
              for (; _ < l; ) {
                let T = b[_];
                if (T === 9 || T === 10 || T === 13 || T === 32) {
                  ++_;
                  continue;
                }
                if (T === 37) {
                  do {
                    if (++_, _ >= l)
                      break;
                    T = b[_];
                  } while (T !== 10 && T !== 13);
                  continue;
                }
                const O = f(b, _);
                let U;
                if (O.startsWith("xref") && (O.length === 4 || /\s/.test(O[4])))
                  _ += m(b, _, M), S.push(_), _ += m(b, _, j);
                else if (U = C.exec(O)) {
                  const G = U[1] | 0, K = U[2] | 0;
                  let W, z = _ + O.length, V = !1;
                  if (!this.entries[G])
                    V = !0;
                  else if (this.entries[G].gen === K)
                    try {
                      new a.Parser({
                        lexer: new a.Lexer(D.makeSubStream(z))
                      }).getObj(), V = !0;
                    } catch (J) {
                      J instanceof v.ParserEOFException ? (0, t.warn)(`indexObjects -- checking object (${O}): "${J}".`) : V = !0;
                    }
                  for (V && (this.entries[G] = {
                    offset: _ - D.start,
                    gen: K,
                    uncompressed: !0
                  }); z < b.length; ) {
                    const J = z + m(b, z, B) + 4;
                    W = J - _;
                    const ie = Math.max(J - X, z), q = (0, t.bytesToString)(b.subarray(ie, J));
                    if (p.test(q))
                      break;
                    {
                      const N = w.exec(q);
                      if (N && N[1]) {
                        (0, t.warn)('indexObjects: Found new "obj" inside of another "obj", caused by missing "endobj" -- trying to recover.'), W -= N[1].length;
                        break;
                      }
                    }
                    z = J;
                  }
                  const L = b.subarray(_, _ + W), Y = m(L, 0, R);
                  Y < W && L[Y + 5] < 64 && (A.push(_ - D.start), this.xrefstms[_ - D.start] = 1), _ += W;
                } else
                  O.startsWith("trailer") && (O.length === 7 || /\s/.test(O[7])) ? (S.push(_), _ += m(b, _, j)) : _ += O.length + 1;
              }
              for (let T = 0, O = A.length; T < O; ++T)
                this.startXRefQueue.push(A[T]), this.readXRef(!0);
              let F;
              for (let T = 0, O = S.length; T < O; ++T) {
                D.pos = S[T];
                const U = new a.Parser({
                  lexer: new a.Lexer(D),
                  xref: this,
                  allowStreams: !0,
                  recoveryMode: !0
                }), G = U.getObj();
                if (!(0, i.isCmd)(G, "trailer"))
                  continue;
                const K = U.getObj();
                if (K instanceof i.Dict) {
                  try {
                    const W = K.get("Root");
                    if (!(W instanceof i.Dict))
                      continue;
                    const z = W.get("Pages");
                    if (!(z instanceof i.Dict))
                      continue;
                    const V = z.get("Count");
                    if (!Number.isInteger(V))
                      continue;
                  } catch {
                    continue;
                  }
                  if (K.has("ID"))
                    return K;
                  F = K;
                }
              }
              if (F)
                return F;
              if (this.topDict)
                return this.topDict;
              throw new t.InvalidPDFException("Invalid PDF structure.");
            }
            readXRef(g = !1) {
              const d = this.stream, c = /* @__PURE__ */ new Set();
              try {
                for (; this.startXRefQueue.length; ) {
                  const n = this.startXRefQueue[0];
                  if (c.has(n)) {
                    (0, t.warn)("readXRef - skipping XRef table since it was already parsed."), this.startXRefQueue.shift();
                    continue;
                  }
                  c.add(n), d.pos = n + d.start;
                  const o = new a.Parser({
                    lexer: new a.Lexer(d),
                    xref: this,
                    allowStreams: !0
                  });
                  let x = o.getObj(), f;
                  if ((0, i.isCmd)(x, "xref")) {
                    if (f = this.processXRefTable(o), this.topDict || (this.topDict = f), x = f.get("XRefStm"), Number.isInteger(x)) {
                      const m = x;
                      m in this.xrefstms || (this.xrefstms[m] = 1, this.startXRefQueue.push(m));
                    }
                  } else if (Number.isInteger(x)) {
                    if (!Number.isInteger(o.getObj()) || !(0, i.isCmd)(o.getObj(), "obj") || !((x = o.getObj()) instanceof e.BaseStream))
                      throw new t.FormatError("Invalid XRef stream");
                    if (f = this.processXRefStream(x), this.topDict || (this.topDict = f), !f)
                      throw new t.FormatError("Failed to read XRef stream");
                  } else
                    throw new t.FormatError("Invalid XRef stream header");
                  x = f.get("Prev"), Number.isInteger(x) ? this.startXRefQueue.push(x) : x instanceof i.Ref && this.startXRefQueue.push(x.num), this.startXRefQueue.shift();
                }
                return this.topDict;
              } catch (n) {
                if (n instanceof v.MissingDataException)
                  throw n;
                (0, t.info)("(while reading XRef): " + n), this.startXRefQueue.shift();
              }
              if (!g)
                throw new v.XRefParseException();
            }
            getEntry(g) {
              const d = this.entries[g];
              return d && !d.free && d.offset ? d : null;
            }
            fetchIfRef(g, d = !1) {
              return g instanceof i.Ref ? this.fetch(g, d) : g;
            }
            fetch(g, d = !1) {
              if (!(g instanceof i.Ref))
                throw new Error("ref object is not a reference");
              const c = g.num, n = this._cacheMap.get(c);
              if (n !== void 0)
                return n instanceof i.Dict && !n.objId && (n.objId = g.toString()), n;
              let o = this.getEntry(c);
              if (o === null)
                return this._cacheMap.set(c, o), o;
              if (this._pendingRefs.has(g))
                return this._pendingRefs.remove(g), (0, t.warn)(`Ignoring circular reference: ${g}.`), i.CIRCULAR_REF;
              this._pendingRefs.put(g);
              try {
                o.uncompressed ? o = this.fetchUncompressed(g, o, d) : o = this.fetchCompressed(g, o, d), this._pendingRefs.remove(g);
              } catch (x) {
                throw this._pendingRefs.remove(g), x;
              }
              return o instanceof i.Dict ? o.objId = g.toString() : o instanceof e.BaseStream && (o.dict.objId = g.toString()), o;
            }
            fetchUncompressed(g, d, c = !1) {
              const n = g.gen;
              let o = g.num;
              if (d.gen !== n)
                throw new v.XRefEntryException(`Inconsistent generation in XRef: ${g}`);
              const x = this.stream.makeSubStream(d.offset + this.stream.start), f = new a.Parser({
                lexer: new a.Lexer(x),
                xref: this,
                allowStreams: !0
              }), m = f.getObj(), C = f.getObj(), p = f.getObj();
              if (m !== o || C !== n || !(p instanceof i.Cmd))
                throw new v.XRefEntryException(`Bad (uncompressed) XRef entry: ${g}`);
              if (p.cmd !== "obj") {
                if (p.cmd.startsWith("obj") && (o = parseInt(p.cmd.substring(3), 10), !Number.isNaN(o)))
                  return o;
                throw new v.XRefEntryException(`Bad (uncompressed) XRef entry: ${g}`);
              }
              return this.encrypt && !c ? d = f.getObj(this.encrypt.createCipherTransform(o, n)) : d = f.getObj(), d instanceof e.BaseStream || this._cacheMap.set(o, d), d;
            }
            fetchCompressed(g, d, c = !1) {
              const n = d.offset, o = this.fetch(i.Ref.get(n, 0));
              if (!(o instanceof e.BaseStream))
                throw new t.FormatError("bad ObjStm stream");
              const x = o.dict.get("First"), f = o.dict.get("N");
              if (!Number.isInteger(x) || !Number.isInteger(f))
                throw new t.FormatError("invalid first and n parameters for ObjStm stream");
              let m = new a.Parser({
                lexer: new a.Lexer(o),
                xref: this,
                allowStreams: !0
              });
              const C = new Array(f), p = new Array(f);
              for (let M = 0; M < f; ++M) {
                const j = m.getObj();
                if (!Number.isInteger(j))
                  throw new t.FormatError(`invalid object number in the ObjStm stream: ${j}`);
                const B = m.getObj();
                if (!Number.isInteger(B))
                  throw new t.FormatError(`invalid object offset in the ObjStm stream: ${B}`);
                C[M] = j, p[M] = B;
              }
              const w = (o.start || 0) + x, X = new Array(f);
              for (let M = 0; M < f; ++M) {
                const j = M < f - 1 ? p[M + 1] - p[M] : void 0;
                if (j < 0)
                  throw new t.FormatError("Invalid offset in the ObjStm stream.");
                m = new a.Parser({
                  lexer: new a.Lexer(o.makeSubStream(w + p[M], j, o.dict)),
                  xref: this,
                  allowStreams: !0
                });
                const B = m.getObj();
                if (X[M] = B, B instanceof e.BaseStream)
                  continue;
                const R = C[M], D = this.entries[R];
                D && D.offset === n && D.gen === M && this._cacheMap.set(R, B);
              }
              if (d = X[d.gen], d === void 0)
                throw new v.XRefEntryException(`Bad (compressed) XRef entry: ${g}`);
              return d;
            }
            async fetchIfRefAsync(g, d) {
              return g instanceof i.Ref ? this.fetchAsync(g, d) : g;
            }
            async fetchAsync(g, d) {
              try {
                return this.fetch(g, d);
              } catch (c) {
                if (!(c instanceof v.MissingDataException))
                  throw c;
                return await this.pdfManager.requestRange(c.begin, c.end), this.fetchAsync(g, d);
              }
            }
            getCatalogObj() {
              return this.root;
            }
          }
          u.XRef = r;
        },
        /* 102 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.MessageHandler = void 0;
          var t = P(2);
          const i = {
            UNKNOWN: 0,
            DATA: 1,
            ERROR: 2
          }, v = {
            UNKNOWN: 0,
            CANCEL: 1,
            CANCEL_COMPLETE: 2,
            CLOSE: 3,
            ENQUEUE: 4,
            ERROR: 5,
            PULL: 6,
            PULL_COMPLETE: 7,
            START_COMPLETE: 8
          };
          function a(y) {
            switch (y instanceof Error || typeof y == "object" && y !== null || (0, t.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), y.name) {
              case "AbortException":
                return new t.AbortException(y.message);
              case "MissingPDFException":
                return new t.MissingPDFException(y.message);
              case "PasswordException":
                return new t.PasswordException(y.message, y.code);
              case "UnexpectedResponseException":
                return new t.UnexpectedResponseException(y.message, y.status);
              case "UnknownErrorException":
                return new t.UnknownErrorException(y.message, y.details);
              default:
                return new t.UnknownErrorException(y.message, y.toString());
            }
          }
          class e {
            constructor(r, h, g) {
              this.sourceName = r, this.targetName = h, this.comObj = g, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), this._onComObjOnMessage = (d) => {
                const c = d.data;
                if (c.targetName !== this.sourceName)
                  return;
                if (c.stream) {
                  this._processStreamMessage(c);
                  return;
                }
                if (c.callback) {
                  const o = c.callbackId, x = this.callbackCapabilities[o];
                  if (!x)
                    throw new Error(`Cannot resolve callback ${o}`);
                  if (delete this.callbackCapabilities[o], c.callback === i.DATA)
                    x.resolve(c.data);
                  else if (c.callback === i.ERROR)
                    x.reject(a(c.reason));
                  else
                    throw new Error("Unexpected callback case");
                  return;
                }
                const n = this.actionHandler[c.action];
                if (!n)
                  throw new Error(`Unknown action from worker: ${c.action}`);
                if (c.callbackId) {
                  const o = this.sourceName, x = c.sourceName;
                  new Promise(function(f) {
                    f(n(c.data));
                  }).then(function(f) {
                    g.postMessage({
                      sourceName: o,
                      targetName: x,
                      callback: i.DATA,
                      callbackId: c.callbackId,
                      data: f
                    });
                  }, function(f) {
                    g.postMessage({
                      sourceName: o,
                      targetName: x,
                      callback: i.ERROR,
                      callbackId: c.callbackId,
                      reason: a(f)
                    });
                  });
                  return;
                }
                if (c.streamId) {
                  this._createStreamSink(c);
                  return;
                }
                n(c.data);
              }, g.addEventListener("message", this._onComObjOnMessage);
            }
            on(r, h) {
              const g = this.actionHandler;
              if (g[r])
                throw new Error(`There is already an actionName called "${r}"`);
              g[r] = h;
            }
            send(r, h, g) {
              this.comObj.postMessage({
                sourceName: this.sourceName,
                targetName: this.targetName,
                action: r,
                data: h
              }, g);
            }
            sendWithPromise(r, h, g) {
              const d = this.callbackId++, c = (0, t.createPromiseCapability)();
              this.callbackCapabilities[d] = c;
              try {
                this.comObj.postMessage({
                  sourceName: this.sourceName,
                  targetName: this.targetName,
                  action: r,
                  callbackId: d,
                  data: h
                }, g);
              } catch (n) {
                c.reject(n);
              }
              return c.promise;
            }
            sendWithStream(r, h, g, d) {
              const c = this.streamId++, n = this.sourceName, o = this.targetName, x = this.comObj;
              return new ReadableStream({
                start: (f) => {
                  const m = (0, t.createPromiseCapability)();
                  return this.streamControllers[c] = {
                    controller: f,
                    startCall: m,
                    pullCall: null,
                    cancelCall: null,
                    isClosed: !1
                  }, x.postMessage({
                    sourceName: n,
                    targetName: o,
                    action: r,
                    streamId: c,
                    data: h,
                    desiredSize: f.desiredSize
                  }, d), m.promise;
                },
                pull: (f) => {
                  const m = (0, t.createPromiseCapability)();
                  return this.streamControllers[c].pullCall = m, x.postMessage({
                    sourceName: n,
                    targetName: o,
                    stream: v.PULL,
                    streamId: c,
                    desiredSize: f.desiredSize
                  }), m.promise;
                },
                cancel: (f) => {
                  (0, t.assert)(f instanceof Error, "cancel must have a valid reason");
                  const m = (0, t.createPromiseCapability)();
                  return this.streamControllers[c].cancelCall = m, this.streamControllers[c].isClosed = !0, x.postMessage({
                    sourceName: n,
                    targetName: o,
                    stream: v.CANCEL,
                    streamId: c,
                    reason: a(f)
                  }), m.promise;
                }
              }, g);
            }
            _createStreamSink(r) {
              const h = r.streamId, g = this.sourceName, d = r.sourceName, c = this.comObj, n = this, o = this.actionHandler[r.action], x = {
                enqueue(f, m = 1, C) {
                  if (this.isCancelled)
                    return;
                  const p = this.desiredSize;
                  this.desiredSize -= m, p > 0 && this.desiredSize <= 0 && (this.sinkCapability = (0, t.createPromiseCapability)(), this.ready = this.sinkCapability.promise), c.postMessage({
                    sourceName: g,
                    targetName: d,
                    stream: v.ENQUEUE,
                    streamId: h,
                    chunk: f
                  }, C);
                },
                close() {
                  this.isCancelled || (this.isCancelled = !0, c.postMessage({
                    sourceName: g,
                    targetName: d,
                    stream: v.CLOSE,
                    streamId: h
                  }), delete n.streamSinks[h]);
                },
                error(f) {
                  (0, t.assert)(f instanceof Error, "error must have a valid reason"), !this.isCancelled && (this.isCancelled = !0, c.postMessage({
                    sourceName: g,
                    targetName: d,
                    stream: v.ERROR,
                    streamId: h,
                    reason: a(f)
                  }));
                },
                sinkCapability: (0, t.createPromiseCapability)(),
                onPull: null,
                onCancel: null,
                isCancelled: !1,
                desiredSize: r.desiredSize,
                ready: null
              };
              x.sinkCapability.resolve(), x.ready = x.sinkCapability.promise, this.streamSinks[h] = x, new Promise(function(f) {
                f(o(r.data, x));
              }).then(function() {
                c.postMessage({
                  sourceName: g,
                  targetName: d,
                  stream: v.START_COMPLETE,
                  streamId: h,
                  success: !0
                });
              }, function(f) {
                c.postMessage({
                  sourceName: g,
                  targetName: d,
                  stream: v.START_COMPLETE,
                  streamId: h,
                  reason: a(f)
                });
              });
            }
            _processStreamMessage(r) {
              const h = r.streamId, g = this.sourceName, d = r.sourceName, c = this.comObj, n = this.streamControllers[h], o = this.streamSinks[h];
              switch (r.stream) {
                case v.START_COMPLETE:
                  r.success ? n.startCall.resolve() : n.startCall.reject(a(r.reason));
                  break;
                case v.PULL_COMPLETE:
                  r.success ? n.pullCall.resolve() : n.pullCall.reject(a(r.reason));
                  break;
                case v.PULL:
                  if (!o) {
                    c.postMessage({
                      sourceName: g,
                      targetName: d,
                      stream: v.PULL_COMPLETE,
                      streamId: h,
                      success: !0
                    });
                    break;
                  }
                  o.desiredSize <= 0 && r.desiredSize > 0 && o.sinkCapability.resolve(), o.desiredSize = r.desiredSize, new Promise(function(x) {
                    x(o.onPull && o.onPull());
                  }).then(function() {
                    c.postMessage({
                      sourceName: g,
                      targetName: d,
                      stream: v.PULL_COMPLETE,
                      streamId: h,
                      success: !0
                    });
                  }, function(x) {
                    c.postMessage({
                      sourceName: g,
                      targetName: d,
                      stream: v.PULL_COMPLETE,
                      streamId: h,
                      reason: a(x)
                    });
                  });
                  break;
                case v.ENQUEUE:
                  if ((0, t.assert)(n, "enqueue should have stream controller"), n.isClosed)
                    break;
                  n.controller.enqueue(r.chunk);
                  break;
                case v.CLOSE:
                  if ((0, t.assert)(n, "close should have stream controller"), n.isClosed)
                    break;
                  n.isClosed = !0, n.controller.close(), this._deleteStreamController(n, h);
                  break;
                case v.ERROR:
                  (0, t.assert)(n, "error should have stream controller"), n.controller.error(a(r.reason)), this._deleteStreamController(n, h);
                  break;
                case v.CANCEL_COMPLETE:
                  r.success ? n.cancelCall.resolve() : n.cancelCall.reject(a(r.reason)), this._deleteStreamController(n, h);
                  break;
                case v.CANCEL:
                  if (!o)
                    break;
                  new Promise(function(x) {
                    x(o.onCancel && o.onCancel(a(r.reason)));
                  }).then(function() {
                    c.postMessage({
                      sourceName: g,
                      targetName: d,
                      stream: v.CANCEL_COMPLETE,
                      streamId: h,
                      success: !0
                    });
                  }, function(x) {
                    c.postMessage({
                      sourceName: g,
                      targetName: d,
                      stream: v.CANCEL_COMPLETE,
                      streamId: h,
                      reason: a(x)
                    });
                  }), o.sinkCapability.reject(a(r.reason)), o.isCancelled = !0, delete this.streamSinks[h];
                  break;
                default:
                  throw new Error("Unexpected stream case");
              }
            }
            async _deleteStreamController(r, h) {
              await Promise.allSettled([r.startCall && r.startCall.promise, r.pullCall && r.pullCall.promise, r.cancelCall && r.cancelCall.promise]), delete this.streamControllers[h];
            }
            destroy() {
              this.comObj.removeEventListener("message", this._onComObjOnMessage);
            }
          }
          u.MessageHandler = e;
        },
        /* 103 */
        /***/
        (Q, u, P) => {
          Object.defineProperty(u, "__esModule", {
            value: !0
          }), u.PDFWorkerStream = void 0;
          var t = P(2);
          class i {
            constructor(y) {
              this._msgHandler = y, this._contentLength = null, this._fullRequestReader = null, this._rangeRequestReaders = [];
            }
            getFullReader() {
              return (0, t.assert)(!this._fullRequestReader, "PDFWorkerStream.getFullReader can only be called once."), this._fullRequestReader = new v(this._msgHandler), this._fullRequestReader;
            }
            getRangeReader(y, r) {
              const h = new a(y, r, this._msgHandler);
              return this._rangeRequestReaders.push(h), h;
            }
            cancelAllRequests(y) {
              this._fullRequestReader && this._fullRequestReader.cancel(y);
              for (const r of this._rangeRequestReaders.slice(0))
                r.cancel(y);
            }
          }
          u.PDFWorkerStream = i;
          class v {
            constructor(y) {
              this._msgHandler = y, this.onProgress = null, this._contentLength = null, this._isRangeSupported = !1, this._isStreamingSupported = !1;
              const r = this._msgHandler.sendWithStream("GetReader");
              this._reader = r.getReader(), this._headersReady = this._msgHandler.sendWithPromise("ReaderHeadersReady").then((h) => {
                this._isStreamingSupported = h.isStreamingSupported, this._isRangeSupported = h.isRangeSupported, this._contentLength = h.contentLength;
              });
            }
            get headersReady() {
              return this._headersReady;
            }
            get contentLength() {
              return this._contentLength;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            get isRangeSupported() {
              return this._isRangeSupported;
            }
            async read() {
              const {
                value: y,
                done: r
              } = await this._reader.read();
              return r ? {
                value: void 0,
                done: !0
              } : {
                value: y.buffer,
                done: !1
              };
            }
            cancel(y) {
              this._reader.cancel(y);
            }
          }
          class a {
            constructor(y, r, h) {
              this._msgHandler = h, this.onProgress = null;
              const g = this._msgHandler.sendWithStream("GetRangeReader", {
                begin: y,
                end: r
              });
              this._reader = g.getReader();
            }
            get isStreamingSupported() {
              return !1;
            }
            async read() {
              const {
                value: y,
                done: r
              } = await this._reader.read();
              return r ? {
                value: void 0,
                done: !0
              } : {
                value: y.buffer,
                done: !1
              };
            }
            cancel(y) {
              this._reader.cancel(y);
            }
          }
        }
        /******/
      ], de = {};
      function oe(Q) {
        var u = de[Q];
        if (u !== void 0)
          return u.exports;
        var P = de[Q] = {
          /******/
          // no module.id needed
          /******/
          // no module.loaded needed
          /******/
          exports: {}
          /******/
        };
        return le[Q](P, P.exports, oe), P.exports;
      }
      oe.d = (Q, u) => {
        for (var P in u)
          oe.o(u, P) && !oe.o(Q, P) && Object.defineProperty(Q, P, { enumerable: !0, get: u[P] });
      }, oe.o = (Q, u) => Object.prototype.hasOwnProperty.call(Q, u), oe.r = (Q) => {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(Q, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(Q, "__esModule", { value: !0 });
      };
      var se = {};
      return (() => {
        var Q = se;
        Object.defineProperty(Q, "__esModule", {
          value: !0
        }), Object.defineProperty(Q, "WorkerMessageHandler", {
          enumerable: !0,
          get: function() {
            return u.WorkerMessageHandler;
          }
        });
        var u = oe(1);
      })(), se;
    })()
  ));
})(pdf_worker);
(typeof window < "u" ? window : {}).pdfjsWorker = pdf_workerExports;
const wrapper$3 = "_wrapper_118zq_1", header = "_header_118zq_6", document$1 = "_document_118zq_10", button = "_button_118zq_16", thumbnail$1 = "_thumbnail_118zq_33", s$3 = {
  wrapper: wrapper$3,
  header,
  document: document$1,
  button,
  thumbnail: thumbnail$1
};
pdfExports.GlobalWorkerOptions.workerSrc = pdf_worker_entry.workerSrc;
var mammoth_browserExports = {}, mammoth_browser = {
  get exports() {
    return mammoth_browserExports;
  },
  set exports(Ee) {
    mammoth_browserExports = Ee;
  }
};
(function(Ee, ge) {
  (function(le) {
    Ee.exports = le();
  })(function() {
    return function le(de, oe, se) {
      function Q(t, i) {
        if (!oe[t]) {
          if (!de[t]) {
            var v = typeof commonjsRequire == "function" && commonjsRequire;
            if (!i && v)
              return v(t, !0);
            if (u)
              return u(t, !0);
            var a = new Error("Cannot find module '" + t + "'");
            throw a.code = "MODULE_NOT_FOUND", a;
          }
          var e = oe[t] = { exports: {} };
          de[t][0].call(e.exports, function(y) {
            var r = de[t][1][y];
            return Q(r || y);
          }, e, e.exports, le, de, oe, se);
        }
        return oe[t].exports;
      }
      for (var u = typeof commonjsRequire == "function" && commonjsRequire, P = 0; P < se.length; P++)
        Q(se[P]);
      return Q;
    }({ 1: [function(le, de, oe) {
      var se = le("../../lib/promises");
      oe.Files = Q;
      function Q() {
        function u(P) {
          return se.reject(new Error("could not open external image: '" + P + `'
cannot open linked files from a web browser`));
        }
        return {
          read: u
        };
      }
    }, { "../../lib/promises": 23 }], 2: [function(le, de, oe) {
      var se = le("../lib/promises"), Q = le("../lib/zipfile");
      oe.openZip = u;
      function u(P) {
        return P.arrayBuffer ? se.resolve(Q.openArrayBuffer(P.arrayBuffer)) : se.reject(new Error("Could not find file in options"));
      }
    }, { "../lib/promises": 23, "../lib/zipfile": 39 }], 3: [function(le, de, oe) {
      var se = le("underscore"), Q = le("./promises"), u = le("./documents"), P = le("./styles/html-paths"), t = le("./results"), i = le("./images"), v = le("./html"), a = le("./writers");
      oe.DocumentConverter = e;
      function e(o) {
        return {
          convertToHtml: function(x) {
            var f = se.indexBy(
              x.type === u.types.document ? x.comments : [],
              "commentId"
            ), m = new y(o, f);
            return m.convertToHtml(x);
          }
        };
      }
      function y(o, x) {
        var f = 1, m = [], C = [];
        o = se.extend({ ignoreEmptyParagraphs: !0 }, o);
        var p = o.idPrefix === void 0 ? "" : o.idPrefix, w = o.ignoreEmptyParagraphs, X = P.topLevelElement("p"), M = o.styleMap || [];
        function j(E) {
          var te = [], re = R(E, te, {}), ee = [];
          c(re, function(k) {
            k.type === "deferred" && ee.push(k);
          });
          var $ = {};
          return Q.mapSeries(ee, function(k) {
            return k.value().then(function(H) {
              $[k.id] = H;
            });
          }).then(function() {
            function k(ne) {
              return d(ne, function(ae) {
                return ae.type === "deferred" ? $[ae.id] : ae.children ? [
                  se.extend({}, ae, {
                    children: k(ae.children)
                  })
                ] : [ae];
              });
            }
            var H = a.writer({
              prettyPrint: o.prettyPrint,
              outputFormat: o.outputFormat
            });
            return v.write(H, v.simplify(k(re))), new t.Result(H.asString(), te);
          });
        }
        function B(E, te, re) {
          return d(E, function(ee) {
            return R(ee, te, re);
          });
        }
        function R(E, te, re) {
          if (!re)
            throw new Error("options not set");
          var ee = Z[E.type];
          return ee ? ee(E, te, re) : [];
        }
        function D(E, te, re) {
          return b(E, te).wrap(function() {
            var ee = B(E.children, te, re);
            return w ? ee : [v.forceWrite].concat(ee);
          });
        }
        function b(E, te) {
          var re = A(E);
          return re ? re.to : (E.styleId && te.push(g("paragraph", E)), X);
        }
        function l(E, te, re) {
          var ee = function() {
            return B(E.children, te, re);
          }, $ = [];
          E.isSmallCaps && $.push(_("smallCaps")), E.isAllCaps && $.push(_("allCaps")), E.isStrikethrough && $.push(_("strikethrough", "s")), E.isUnderline && $.push(_("underline")), E.verticalAlignment === u.verticalAlignment.subscript && $.push(P.element("sub", {}, { fresh: !1 })), E.verticalAlignment === u.verticalAlignment.superscript && $.push(P.element("sup", {}, { fresh: !1 })), E.isItalic && $.push(_("italic", "em")), E.isBold && $.push(_("bold", "strong"));
          var k = P.empty, H = A(E);
          return H ? k = H.to : E.styleId && te.push(g("run", E)), $.push(k), $.forEach(function(ne) {
            ee = ne.wrap.bind(ne, ee);
          }), ee();
        }
        function _(E, te) {
          var re = S({ type: E });
          return re || (te ? P.element(te, {}, { fresh: !1 }) : P.empty);
        }
        function S(E, te) {
          var re = A(E);
          return re ? re.to : te;
        }
        function A(E) {
          for (var te = 0; te < M.length; te++)
            if (M[te].from.matches(E))
              return M[te];
        }
        function F(E) {
          return function(te, re) {
            return Q.attempt(function() {
              return E(te, re);
            }).caught(function(ee) {
              return re.push(t.error(ee)), [];
            });
          };
        }
        function T(E) {
          return U(E.noteType, E.noteId);
        }
        function O(E) {
          return G(E.noteType, E.noteId);
        }
        function U(E, te) {
          return K(E + "-" + te);
        }
        function G(E, te) {
          return K(E + "-ref-" + te);
        }
        function K(E) {
          return p + E;
        }
        var W = P.elements([
          P.element("table", {}, { fresh: !0 })
        ]);
        function z(E, te, re) {
          return S(E, W).wrap(function() {
            return V(E, te, re);
          });
        }
        function V(E, te, re) {
          var ee = se.findIndex(E.children, function(ne) {
            return !ne.type === u.types.tableRow || !ne.isHeader;
          });
          ee === -1 && (ee = E.children.length);
          var $;
          if (ee === 0)
            $ = B(
              E.children,
              te,
              se.extend({}, re, { isTableHeader: !1 })
            );
          else {
            var k = B(
              E.children.slice(0, ee),
              te,
              se.extend({}, re, { isTableHeader: !0 })
            ), H = B(
              E.children.slice(ee),
              te,
              se.extend({}, re, { isTableHeader: !1 })
            );
            $ = [
              v.freshElement("thead", {}, k),
              v.freshElement("tbody", {}, H)
            ];
          }
          return [v.forceWrite].concat($);
        }
        function L(E, te, re) {
          var ee = B(E.children, te, re);
          return [
            v.freshElement("tr", {}, [v.forceWrite].concat(ee))
          ];
        }
        function Y(E, te, re) {
          var ee = re.isTableHeader ? "th" : "td", $ = B(E.children, te, re), k = {};
          return E.colSpan !== 1 && (k.colspan = E.colSpan.toString()), E.rowSpan !== 1 && (k.rowspan = E.rowSpan.toString()), [
            v.freshElement(ee, k, [v.forceWrite].concat($))
          ];
        }
        function J(E, te, re) {
          return S(E, P.ignore).wrap(function() {
            var ee = x[E.commentId], $ = C.length + 1, k = "[" + n(ee) + $ + "]";
            return C.push({ label: k, comment: ee }), [
              v.freshElement("a", {
                href: "#" + U("comment", E.commentId),
                id: G("comment", E.commentId)
              }, [v.text(k)])
            ];
          });
        }
        function ie(E, te, re) {
          var ee = E.label, $ = E.comment, k = B($.body, te, re).concat([
            v.nonFreshElement("p", {}, [
              v.text(" "),
              v.freshElement("a", { href: "#" + G("comment", $.commentId) }, [
                v.text("↑")
              ])
            ])
          ]);
          return [
            v.freshElement(
              "dt",
              { id: U("comment", $.commentId) },
              [v.text("Comment " + ee)]
            ),
            v.freshElement("dd", {}, k)
          ];
        }
        function q(E, te, re) {
          return N(E).wrap(function() {
            return [];
          });
        }
        function N(E) {
          var te = A(E);
          return te ? te.to : E.breakType === "line" ? P.topLevelElement("br") : P.empty;
        }
        var Z = {
          document: function(E, te, re) {
            var ee = B(E.children, te, re), $ = m.map(function(H) {
              return E.notes.resolve(H);
            }), k = B($, te, re);
            return ee.concat([
              v.freshElement("ol", {}, k),
              v.freshElement("dl", {}, d(C, function(H) {
                return ie(H, te, re);
              }))
            ]);
          },
          paragraph: D,
          run: l,
          text: function(E, te, re) {
            return [v.text(E.value)];
          },
          tab: function(E, te, re) {
            return [v.text("	")];
          },
          hyperlink: function(E, te, re) {
            var ee = E.anchor ? "#" + K(E.anchor) : E.href, $ = { href: ee };
            E.targetFrame != null && ($.target = E.targetFrame);
            var k = B(E.children, te, re);
            return [v.nonFreshElement("a", $, k)];
          },
          bookmarkStart: function(E, te, re) {
            var ee = v.freshElement("a", {
              id: K(E.name)
            }, [v.forceWrite]);
            return [ee];
          },
          noteReference: function(E, te, re) {
            m.push(E);
            var ee = v.freshElement("a", {
              href: "#" + T(E),
              id: O(E)
            }, [v.text("[" + f++ + "]")]);
            return [v.freshElement("sup", {}, [ee])];
          },
          note: function(E, te, re) {
            var ee = B(E.body, te, re), $ = v.elementWithTag(P.element("p", {}, { fresh: !1 }), [
              v.text(" "),
              v.freshElement("a", { href: "#" + O(E) }, [v.text("↑")])
            ]), k = ee.concat([$]);
            return v.freshElement("li", { id: T(E) }, k);
          },
          commentReference: J,
          comment: ie,
          image: h(F(o.convertImage || i.dataUri)),
          table: z,
          tableRow: L,
          tableCell: Y,
          break: q
        };
        return {
          convertToHtml: j
        };
      }
      var r = 1;
      function h(o) {
        return function(x, f, m) {
          return [
            {
              type: "deferred",
              id: r++,
              value: function() {
                return o(x, f, m);
              }
            }
          ];
        };
      }
      function g(o, x) {
        return t.warning(
          "Unrecognised " + o + " style: '" + x.styleName + "' (Style ID: " + x.styleId + ")"
        );
      }
      function d(o, x) {
        return se.flatten(o.map(x), !0);
      }
      function c(o, x) {
        o.forEach(function(f) {
          x(f), f.children && c(f.children, x);
        });
      }
      var n = oe.commentAuthorLabel = function(x) {
        return x.authorInitials || "";
      };
    }, { "./documents": 4, "./html": 18, "./images": 20, "./promises": 23, "./results": 25, "./styles/html-paths": 28, "./writers": 33, underscore: 117 }], 4: [function(le, de, oe) {
      var se = le("underscore"), Q = oe.types = {
        document: "document",
        paragraph: "paragraph",
        run: "run",
        text: "text",
        tab: "tab",
        hyperlink: "hyperlink",
        noteReference: "noteReference",
        image: "image",
        note: "note",
        commentReference: "commentReference",
        comment: "comment",
        table: "table",
        tableRow: "tableRow",
        tableCell: "tableCell",
        break: "break",
        bookmarkStart: "bookmarkStart"
      };
      function u(p, w) {
        return w = w || {}, {
          type: Q.document,
          children: p,
          notes: w.notes || new r({}),
          comments: w.comments || []
        };
      }
      function P(p, w) {
        w = w || {};
        var X = w.indent || {};
        return {
          type: Q.paragraph,
          children: p,
          styleId: w.styleId || null,
          styleName: w.styleName || null,
          numbering: w.numbering || null,
          alignment: w.alignment || null,
          indent: {
            start: X.start || null,
            end: X.end || null,
            firstLine: X.firstLine || null,
            hanging: X.hanging || null
          }
        };
      }
      function t(p, w) {
        return w = w || {}, {
          type: Q.run,
          children: p,
          styleId: w.styleId || null,
          styleName: w.styleName || null,
          isBold: w.isBold,
          isUnderline: w.isUnderline,
          isItalic: w.isItalic,
          isStrikethrough: w.isStrikethrough,
          isAllCaps: w.isAllCaps,
          isSmallCaps: w.isSmallCaps,
          verticalAlignment: w.verticalAlignment || i.baseline,
          font: w.font || null,
          fontSize: w.fontSize || null
        };
      }
      var i = {
        baseline: "baseline",
        superscript: "superscript",
        subscript: "subscript"
      };
      function v(p) {
        return {
          type: Q.text,
          value: p
        };
      }
      function a() {
        return {
          type: Q.tab
        };
      }
      function e(p, w) {
        return {
          type: Q.hyperlink,
          children: p,
          href: w.href,
          anchor: w.anchor,
          targetFrame: w.targetFrame
        };
      }
      function y(p) {
        return {
          type: Q.noteReference,
          noteType: p.noteType,
          noteId: p.noteId
        };
      }
      function r(p) {
        this._notes = se.indexBy(p, function(w) {
          return c(w.noteType, w.noteId);
        });
      }
      r.prototype.resolve = function(p) {
        return this.findNoteByKey(c(p.noteType, p.noteId));
      }, r.prototype.findNoteByKey = function(p) {
        return this._notes[p] || null;
      };
      function h(p) {
        return {
          type: Q.note,
          noteType: p.noteType,
          noteId: p.noteId,
          body: p.body
        };
      }
      function g(p) {
        return {
          type: Q.commentReference,
          commentId: p.commentId
        };
      }
      function d(p) {
        return {
          type: Q.comment,
          commentId: p.commentId,
          body: p.body,
          authorName: p.authorName,
          authorInitials: p.authorInitials
        };
      }
      function c(p, w) {
        return p + "-" + w;
      }
      function n(p) {
        return {
          type: Q.image,
          read: p.readImage,
          altText: p.altText,
          contentType: p.contentType
        };
      }
      function o(p, w) {
        return w = w || {}, {
          type: Q.table,
          children: p,
          styleId: w.styleId || null,
          styleName: w.styleName || null
        };
      }
      function x(p, w) {
        return w = w || {}, {
          type: Q.tableRow,
          children: p,
          isHeader: w.isHeader || !1
        };
      }
      function f(p, w) {
        return w = w || {}, {
          type: Q.tableCell,
          children: p,
          colSpan: w.colSpan == null ? 1 : w.colSpan,
          rowSpan: w.rowSpan == null ? 1 : w.rowSpan
        };
      }
      function m(p) {
        return {
          type: Q.break,
          breakType: p
        };
      }
      function C(p) {
        return {
          type: Q.bookmarkStart,
          name: p.name
        };
      }
      oe.document = oe.Document = u, oe.paragraph = oe.Paragraph = P, oe.run = oe.Run = t, oe.Text = v, oe.tab = oe.Tab = a, oe.Hyperlink = e, oe.noteReference = oe.NoteReference = y, oe.Notes = r, oe.Note = h, oe.commentReference = g, oe.comment = d, oe.Image = n, oe.Table = o, oe.TableRow = x, oe.TableCell = f, oe.lineBreak = m("line"), oe.pageBreak = m("page"), oe.columnBreak = m("column"), oe.BookmarkStart = C, oe.verticalAlignment = i;
    }, { underscore: 117 }], 5: [function(le, de, oe) {
      oe.createBodyReader = v, oe._readNumberingProperties = e;
      var se = le("dingbat-to-unicode"), Q = le("underscore"), u = le("../documents"), P = le("../results").Result, t = le("../results").warning, i = le("./uris");
      function v(w) {
        return {
          readXmlElement: function(X) {
            return new a(w).readXmlElement(X);
          },
          readXmlElements: function(X) {
            return new a(w).readXmlElements(X);
          }
        };
      }
      function a(w) {
        var X = [], M = [], j = w.relationships, B = w.contentTypes, R = w.docxFile, D = w.files, b = w.numbering, l = w.styles;
        function _(Ae) {
          var De = Ae.map(S);
          return m(De);
        }
        function S(Ae) {
          if (Ae.type === "element") {
            var De = E[Ae.name];
            if (De)
              return De(Ae);
            if (!Object.prototype.hasOwnProperty.call(r, Ae.name)) {
              var xe = t("An unrecognised element was ignored: " + Ae.name);
              return c([xe]);
            }
          }
          return n();
        }
        function A(Ae) {
          return {
            start: Ae.attributes["w:start"] || Ae.attributes["w:left"],
            end: Ae.attributes["w:end"] || Ae.attributes["w:right"],
            firstLine: Ae.attributes["w:firstLine"],
            hanging: Ae.attributes["w:hanging"]
          };
        }
        function F(Ae) {
          return G(Ae).map(function(De) {
            var xe = Ae.firstOrEmpty("w:sz").attributes["w:val"], Te = /^[0-9]+$/.test(xe) ? parseInt(xe, 10) / 2 : null;
            return {
              type: "runProperties",
              styleId: De.styleId,
              styleName: De.name,
              verticalAlignment: Ae.firstOrEmpty("w:vertAlign").attributes["w:val"],
              font: Ae.firstOrEmpty("w:rFonts").attributes["w:ascii"],
              fontSize: Te,
              isBold: O(Ae.first("w:b")),
              isUnderline: T(Ae.first("w:u")),
              isItalic: O(Ae.first("w:i")),
              isStrikethrough: O(Ae.first("w:strike")),
              isAllCaps: O(Ae.first("w:caps")),
              isSmallCaps: O(Ae.first("w:smallCaps"))
            };
          });
        }
        function T(Ae) {
          if (Ae) {
            var De = Ae.attributes["w:val"];
            return De !== void 0 && De !== "false" && De !== "0" && De !== "none";
          } else
            return !1;
        }
        function O(Ae) {
          if (Ae) {
            var De = Ae.attributes["w:val"];
            return De !== "false" && De !== "0";
          } else
            return !1;
        }
        function U(Ae) {
          return W(Ae, "w:pStyle", "Paragraph", l.findParagraphStyleById);
        }
        function G(Ae) {
          return W(Ae, "w:rStyle", "Run", l.findCharacterStyleById);
        }
        function K(Ae) {
          return W(Ae, "w:tblStyle", "Table", l.findTableStyleById);
        }
        function W(Ae, De, xe, Te) {
          var ve = [], Se = Ae.first(De), be = null, Le = null;
          if (Se && (be = Se.attributes["w:val"], be)) {
            var ze = Te(be);
            ze ? Le = ze.name : ve.push(we(xe, be));
          }
          return x({ styleId: be, name: Le }, ve);
        }
        var z = { type: "unknown" };
        function V(Ae) {
          var De = Ae.attributes["w:fldCharType"];
          if (De === "begin")
            X.push(z), M = [];
          else if (De === "end")
            X.pop();
          else if (De === "separate") {
            var xe = Y(M.join("")), Te = xe === null ? z : { type: "hyperlink", options: xe };
            X.pop(), X.push(Te);
          }
          return n();
        }
        function L() {
          var Ae = Q.last(X.filter(function(De) {
            return De.type === "hyperlink";
          }));
          return Ae ? Ae.options : null;
        }
        function Y(Ae) {
          var De = /\s*HYPERLINK "(.*)"/.exec(Ae);
          if (De)
            return { href: De[1] };
          var xe = /\s*HYPERLINK\s+\\l\s+"(.*)"/.exec(Ae);
          return xe ? { anchor: xe[1] } : null;
        }
        function J(Ae) {
          return M.push(Ae.text()), n();
        }
        function ie(Ae) {
          var De = Ae.attributes["w:font"], xe = Ae.attributes["w:char"], Te = se.hex(De, xe);
          return Te == null && /^F0..$/.test(xe) && (Te = se.hex(De, xe.substring(2))), Te == null ? c([t(
            "A w:sym element with an unsupported character was ignored: char " + xe + " in font " + De
          )]) : o(new u.Text(Te.string));
        }
        function q(Ae) {
          return function(De) {
            var xe = De.attributes["w:id"];
            return o(new u.NoteReference({
              noteType: Ae,
              noteId: xe
            }));
          };
        }
        function N(Ae) {
          return o(u.commentReference({
            commentId: Ae.attributes["w:id"]
          }));
        }
        function Z(Ae) {
          return _(Ae.children);
        }
        var E = {
          "w:p": function(Ae) {
            return _(Ae.children).map(function(De) {
              var xe = Q.find(De, h);
              return new u.Paragraph(
                De.filter(d(h)),
                xe
              );
            }).insertExtra();
          },
          "w:pPr": function(Ae) {
            return U(Ae).map(function(De) {
              return {
                type: "paragraphProperties",
                styleId: De.styleId,
                styleName: De.name,
                alignment: Ae.firstOrEmpty("w:jc").attributes["w:val"],
                numbering: e(De.styleId, Ae.firstOrEmpty("w:numPr"), b),
                indent: A(Ae.firstOrEmpty("w:ind"))
              };
            });
          },
          "w:r": function(Ae) {
            return _(Ae.children).map(function(De) {
              var xe = Q.find(De, g);
              De = De.filter(d(g));
              var Te = L();
              return Te !== null && (De = [new u.Hyperlink(De, Te)]), new u.Run(De, xe);
            });
          },
          "w:rPr": F,
          "w:fldChar": V,
          "w:instrText": J,
          "w:t": function(Ae) {
            return o(new u.Text(Ae.text()));
          },
          "w:tab": function(Ae) {
            return o(new u.Tab());
          },
          "w:noBreakHyphen": function() {
            return o(new u.Text("‑"));
          },
          "w:softHyphen": function(Ae) {
            return o(new u.Text("­"));
          },
          "w:sym": ie,
          "w:hyperlink": function(Ae) {
            var De = Ae.attributes["r:id"], xe = Ae.attributes["w:anchor"];
            return _(Ae.children).map(function(Te) {
              function ve(be) {
                var Le = Ae.attributes["w:tgtFrame"] || null;
                return new u.Hyperlink(
                  Te,
                  Q.extend({ targetFrame: Le }, be)
                );
              }
              if (De) {
                var Se = j.findTargetByRelationshipId(De);
                return xe && (Se = i.replaceFragment(Se, xe)), ve({ href: Se });
              } else
                return xe ? ve({ anchor: xe }) : Te;
            });
          },
          "w:tbl": te,
          "w:tr": ee,
          "w:tc": $,
          "w:footnoteReference": q("footnote"),
          "w:endnoteReference": q("endnote"),
          "w:commentReference": N,
          "w:br": function(Ae) {
            var De = Ae.attributes["w:type"];
            return De == null || De === "textWrapping" ? o(u.lineBreak) : De === "page" ? o(u.pageBreak) : De === "column" ? o(u.columnBreak) : c([t("Unsupported break type: " + De)]);
          },
          "w:bookmarkStart": function(Ae) {
            var De = Ae.attributes["w:name"];
            return De === "_GoBack" ? n() : o(new u.BookmarkStart({ name: De }));
          },
          "mc:AlternateContent": function(Ae) {
            return Z(Ae.first("mc:Fallback"));
          },
          "w:sdt": function(Ae) {
            return _(Ae.firstOrEmpty("w:sdtContent").children);
          },
          "w:ins": Z,
          "w:object": Z,
          "w:smartTag": Z,
          "w:drawing": Z,
          "w:pict": function(Ae) {
            return Z(Ae).toExtra();
          },
          "v:roundrect": Z,
          "v:shape": Z,
          "v:textbox": Z,
          "w:txbxContent": Z,
          "wp:inline": ne,
          "wp:anchor": ne,
          "v:imagedata": fe,
          "v:group": Z,
          "v:rect": Z
        };
        return {
          readXmlElement: S,
          readXmlElements: _
        };
        function te(Ae) {
          var De = re(Ae.firstOrEmpty("w:tblPr"));
          return _(Ae.children).flatMap(H).flatMap(function(xe) {
            return De.map(function(Te) {
              return u.Table(xe, Te);
            });
          });
        }
        function re(Ae) {
          return K(Ae).map(function(De) {
            return {
              styleId: De.styleId,
              styleName: De.name
            };
          });
        }
        function ee(Ae) {
          var De = Ae.firstOrEmpty("w:trPr"), xe = !!De.first("w:tblHeader");
          return _(Ae.children).map(function(Te) {
            return u.TableRow(Te, { isHeader: xe });
          });
        }
        function $(Ae) {
          return _(Ae.children).map(function(De) {
            var xe = Ae.firstOrEmpty("w:tcPr"), Te = xe.firstOrEmpty("w:gridSpan").attributes["w:val"], ve = Te ? parseInt(Te, 10) : 1, Se = u.TableCell(De, { colSpan: ve });
            return Se._vMerge = k(xe), Se;
          });
        }
        function k(Ae) {
          var De = Ae.first("w:vMerge");
          if (De) {
            var xe = De.attributes["w:val"];
            return xe === "continue" || !xe;
          } else
            return null;
        }
        function H(Ae) {
          var De = Q.any(Ae, function(ve) {
            return ve.type !== u.types.tableRow;
          });
          if (De)
            return x(Ae, [t(
              "unexpected non-row element in table, cell merging may be incorrect"
            )]);
          var xe = Q.any(Ae, function(ve) {
            return Q.any(ve.children, function(Se) {
              return Se.type !== u.types.tableCell;
            });
          });
          if (xe)
            return x(Ae, [t(
              "unexpected non-cell element in table row, cell merging may be incorrect"
            )]);
          var Te = {};
          return Ae.forEach(function(ve) {
            var Se = 0;
            ve.children.forEach(function(be) {
              be._vMerge && Te[Se] ? Te[Se].rowSpan++ : (Te[Se] = be, be._vMerge = !1), Se += be.colSpan;
            });
          }), Ae.forEach(function(ve) {
            ve.children = ve.children.filter(function(Se) {
              return !Se._vMerge;
            }), ve.children.forEach(function(Se) {
              delete Se._vMerge;
            });
          }), o(Ae);
        }
        function ne(Ae) {
          var De = Ae.getElementsByTagName("a:graphic").getElementsByTagName("a:graphicData").getElementsByTagName("pic:pic").getElementsByTagName("pic:blipFill").getElementsByTagName("a:blip");
          return m(De.map(ae.bind(null, Ae)));
        }
        function ae(Ae, De) {
          var xe = Ae.first("wp:docPr").attributes, Te = he(xe.descr) ? xe.title : xe.descr, ve = ue(De);
          return ve === null ? c([t("Could not find image file for a:blip element")]) : Fe(ve, Te);
        }
        function he(Ae) {
          return Ae == null || /^\s*$/.test(Ae);
        }
        function ue(Ae) {
          var De = Ae.attributes["r:embed"], xe = Ae.attributes["r:link"];
          if (De)
            return me(De);
          if (xe) {
            var Te = j.findTargetByRelationshipId(xe);
            return {
              path: Te,
              read: D.read.bind(D, Te)
            };
          } else
            return null;
        }
        function fe(Ae) {
          var De = Ae.attributes["r:id"];
          return De ? Fe(
            me(De),
            Ae.attributes["o:title"]
          ) : c([t("A v:imagedata element without a relationship ID was ignored")]);
        }
        function me(Ae) {
          var De = i.uriToZipEntryName("word", j.findTargetByRelationshipId(Ae));
          return {
            path: De,
            read: R.read.bind(R, De)
          };
        }
        function Fe(Ae, De) {
          var xe = B.findContentType(Ae.path), Te = u.Image({
            readImage: Ae.read,
            altText: De,
            contentType: xe
          }), ve = y[xe] ? [] : t("Image of type " + xe + " is unlikely to display in web browsers");
          return x(Te, ve);
        }
        function we(Ae, De) {
          return t(
            Ae + " style with ID " + De + " was referenced but not defined in the document"
          );
        }
      }
      function e(w, X, M) {
        if (w != null) {
          var j = M.findLevelByParagraphStyleId(w);
          if (j != null)
            return j;
        }
        var B = X.firstOrEmpty("w:ilvl").attributes["w:val"], R = X.firstOrEmpty("w:numId").attributes["w:val"];
        return B === void 0 || R === void 0 ? null : M.findLevel(R, B);
      }
      var y = {
        "image/png": !0,
        "image/gif": !0,
        "image/jpeg": !0,
        "image/svg+xml": !0,
        "image/tiff": !0
      }, r = {
        "office-word:wrap": !0,
        "v:shadow": !0,
        "v:shapetype": !0,
        "w:annotationRef": !0,
        "w:bookmarkEnd": !0,
        "w:sectPr": !0,
        "w:proofErr": !0,
        "w:lastRenderedPageBreak": !0,
        "w:commentRangeStart": !0,
        "w:commentRangeEnd": !0,
        "w:del": !0,
        "w:footnoteRef": !0,
        "w:endnoteRef": !0,
        "w:tblPr": !0,
        "w:tblGrid": !0,
        "w:trPr": !0,
        "w:tcPr": !0
      };
      function h(w) {
        return w.type === "paragraphProperties";
      }
      function g(w) {
        return w.type === "runProperties";
      }
      function d(w) {
        return function(X) {
          return !w(X);
        };
      }
      function c(w) {
        return new f(null, null, w);
      }
      function n() {
        return new f(null);
      }
      function o(w) {
        return new f(w);
      }
      function x(w, X) {
        return new f(w, null, X);
      }
      function f(w, X, M) {
        this.value = w || [], this.extra = X, this._result = new P({
          element: this.value,
          extra: X
        }, M), this.messages = this._result.messages;
      }
      f.prototype.toExtra = function() {
        return new f(null, C(this.extra, this.value), this.messages);
      }, f.prototype.insertExtra = function() {
        var w = this.extra;
        return w && w.length ? new f(C(this.value, w), null, this.messages) : this;
      }, f.prototype.map = function(w) {
        var X = this._result.map(function(M) {
          return w(M.element);
        });
        return new f(X.value, this.extra, X.messages);
      }, f.prototype.flatMap = function(w) {
        var X = this._result.flatMap(function(M) {
          return w(M.element)._result;
        });
        return new f(X.value.element, C(this.extra, X.value.extra), X.messages);
      };
      function m(w) {
        var X = P.combine(Q.pluck(w, "_result"));
        return new f(
          Q.flatten(Q.pluck(X.value, "element")),
          Q.filter(Q.flatten(Q.pluck(X.value, "extra")), p),
          X.messages
        );
      }
      function C(w, X) {
        return Q.flatten([w, X]);
      }
      function p(w) {
        return w;
      }
    }, { "../documents": 4, "../results": 25, "./uris": 16, "dingbat-to-unicode": 81, underscore: 117 }], 6: [function(le, de, oe) {
      var se = le("../documents"), Q = le("../results").Result;
      function u(P) {
        function t(v) {
          return Q.combine(v.getElementsByTagName("w:comment").map(i));
        }
        function i(v) {
          var a = v.attributes["w:id"];
          function e(y) {
            return (v.attributes[y] || "").trim() || null;
          }
          return P.readXmlElements(v.children).map(function(y) {
            return se.comment({
              commentId: a,
              body: y,
              authorName: e("w:author"),
              authorInitials: e("w:initials")
            });
          });
        }
        return t;
      }
      oe.createCommentsReader = u;
    }, { "../documents": 4, "../results": 25 }], 7: [function(le, de, oe) {
      oe.readContentTypesFromXml = Q;
      var se = {
        png: "png",
        gif: "gif",
        jpeg: "jpeg",
        jpg: "jpeg",
        tif: "tiff",
        tiff: "tiff",
        bmp: "bmp"
      };
      oe.defaultContentTypes = u({}, {});
      function Q(P) {
        var t = {}, i = {};
        return P.children.forEach(function(v) {
          if (v.name === "content-types:Default" && (t[v.attributes.Extension] = v.attributes.ContentType), v.name === "content-types:Override") {
            var a = v.attributes.PartName;
            a.charAt(0) === "/" && (a = a.substring(1)), i[a] = v.attributes.ContentType;
          }
        }), u(i, t);
      }
      function u(P, t) {
        return {
          findContentType: function(i) {
            var v = P[i];
            if (v)
              return v;
            var a = i.split("."), e = a[a.length - 1];
            if (t.hasOwnProperty(e))
              return t[e];
            var y = se[e.toLowerCase()];
            return y ? "image/" + y : null;
          }
        };
      }
    }, {}], 8: [function(le, de, oe) {
      oe.DocumentXmlReader = u;
      var se = le("../documents"), Q = le("../results").Result;
      function u(P) {
        var t = P.bodyReader;
        function i(v) {
          var a = v.first("w:body"), e = t.readXmlElements(a.children).map(function(y) {
            return new se.Document(y, {
              notes: P.notes,
              comments: P.comments
            });
          });
          return new Q(e.value, e.messages);
        }
        return {
          convertXmlToDocument: i
        };
      }
    }, { "../documents": 4, "../results": 25 }], 9: [function(le, de, oe) {
      oe.read = n, oe._findPartPaths = o;
      var se = le("path"), Q = le("../promises"), u = le("../documents"), P = le("../results").Result, t = le("../zipfile"), i = le("./office-xml-reader").readXmlFromZipFile, v = le("./body-reader").createBodyReader, a = le("./document-xml-reader").DocumentXmlReader, e = le("./relationships-reader"), y = le("./content-types-reader"), r = le("./numbering-xml"), h = le("./styles-reader"), g = le("./notes-reader"), d = le("./comments-reader"), c = le("./files").Files;
      function n(B, R) {
        return R = R || {}, Q.props({
          contentTypes: w(B),
          partPaths: o(B),
          docxFile: B,
          files: new c(R.path ? se.dirname(R.path) : null)
        }).also(function(D) {
          return {
            styles: M(B, D.partPaths.styles)
          };
        }).also(function(D) {
          return {
            numbering: X(B, D.partPaths.numbering, D.styles)
          };
        }).also(function(D) {
          return {
            footnotes: C(D.partPaths.footnotes, D, function(b, l) {
              return l ? g.createFootnotesReader(b)(l) : new P([]);
            }),
            endnotes: C(D.partPaths.endnotes, D, function(b, l) {
              return l ? g.createEndnotesReader(b)(l) : new P([]);
            }),
            comments: C(D.partPaths.comments, D, function(b, l) {
              return l ? d.createCommentsReader(b)(l) : new P([]);
            })
          };
        }).also(function(D) {
          return {
            notes: D.footnotes.flatMap(function(b) {
              return D.endnotes.map(function(l) {
                return new u.Notes(b.concat(l));
              });
            })
          };
        }).then(function(D) {
          return C(D.partPaths.mainDocument, D, function(b, l) {
            return D.notes.flatMap(function(_) {
              return D.comments.flatMap(function(S) {
                var A = new a({
                  bodyReader: b,
                  notes: _,
                  comments: S
                });
                return A.convertXmlToDocument(l);
              });
            });
          });
        });
      }
      function o(B) {
        return j(B).then(function(R) {
          var D = x({
            docxFile: B,
            relationships: R,
            relationshipType: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
            basePath: "",
            fallbackPath: "word/document.xml"
          });
          if (!B.exists(D))
            throw new Error("Could not find main document part. Are you sure this is a valid .docx file?");
          return m({
            filename: p(D),
            readElement: e.readRelationships,
            defaultValue: e.defaultValue
          })(B).then(function(b) {
            function l(_) {
              return x({
                docxFile: B,
                relationships: b,
                relationshipType: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/" + _,
                basePath: t.splitPath(D).dirname,
                fallbackPath: "word/" + _ + ".xml"
              });
            }
            return {
              mainDocument: D,
              comments: l("comments"),
              endnotes: l("endnotes"),
              footnotes: l("footnotes"),
              numbering: l("numbering"),
              styles: l("styles")
            };
          });
        });
      }
      function x(B) {
        var R = B.docxFile, D = B.relationships, b = B.relationshipType, l = B.basePath, _ = B.fallbackPath, S = D.findTargetsByType(b), A = S.map(function(T) {
          return f(t.joinPath(l, T), "/");
        }), F = A.filter(function(T) {
          return R.exists(T);
        });
        return F.length === 0 ? _ : F[0];
      }
      function f(B, R) {
        return B.substring(0, R.length) === R ? B.substring(R.length) : B;
      }
      function m(B) {
        return function(R) {
          return i(R, B.filename).then(function(D) {
            return D ? B.readElement(D) : B.defaultValue;
          });
        };
      }
      function C(B, R, D) {
        var b = m({
          filename: p(B),
          readElement: e.readRelationships,
          defaultValue: e.defaultValue
        });
        return b(R.docxFile).then(function(l) {
          var _ = new v({
            relationships: l,
            contentTypes: R.contentTypes,
            docxFile: R.docxFile,
            numbering: R.numbering,
            styles: R.styles,
            files: R.files
          });
          return i(R.docxFile, B).then(function(S) {
            return D(_, S);
          });
        });
      }
      function p(B) {
        var R = t.splitPath(B);
        return t.joinPath(R.dirname, "_rels", R.basename + ".rels");
      }
      var w = m({
        filename: "[Content_Types].xml",
        readElement: y.readContentTypesFromXml,
        defaultValue: y.defaultContentTypes
      });
      function X(B, R, D) {
        return m({
          filename: R,
          readElement: function(b) {
            return r.readNumberingXml(b, { styles: D });
          },
          defaultValue: r.defaultNumbering
        })(B);
      }
      function M(B, R) {
        return m({
          filename: R,
          readElement: h.readStylesXml,
          defaultValue: h.defaultStyles
        })(B);
      }
      var j = m({
        filename: "_rels/.rels",
        readElement: e.readRelationships,
        defaultValue: e.defaultValue
      });
    }, { "../documents": 4, "../promises": 23, "../results": 25, "../zipfile": 39, "./body-reader": 5, "./comments-reader": 6, "./content-types-reader": 7, "./document-xml-reader": 8, "./files": 1, "./notes-reader": 10, "./numbering-xml": 11, "./office-xml-reader": 12, "./relationships-reader": 13, "./styles-reader": 15, path: 100 }], 10: [function(le, de, oe) {
      var se = le("../documents"), Q = le("../results").Result;
      oe.createFootnotesReader = u.bind(this, "footnote"), oe.createEndnotesReader = u.bind(this, "endnote");
      function u(P, t) {
        function i(e) {
          return Q.combine(e.getElementsByTagName("w:" + P).filter(v).map(a));
        }
        function v(e) {
          var y = e.attributes["w:type"];
          return y !== "continuationSeparator" && y !== "separator";
        }
        function a(e) {
          var y = e.attributes["w:id"];
          return t.readXmlElements(e.children).map(function(r) {
            return se.Note({ noteType: P, noteId: y, body: r });
          });
        }
        return i;
      }
    }, { "../documents": 4, "../results": 25 }], 11: [function(le, de, oe) {
      var se = le("underscore");
      oe.readNumberingXml = u, oe.Numbering = Q, oe.defaultNumbering = new Q({}, {});
      function Q(v, a, e) {
        var y = se.flatten(se.values(a).map(function(d) {
          return se.values(d.levels);
        })), r = se.indexBy(
          y.filter(function(d) {
            return d.paragraphStyleId != null;
          }),
          "paragraphStyleId"
        );
        function h(d, c) {
          var n = v[d];
          if (n) {
            var o = a[n.abstractNumId];
            if (o) {
              if (o.numStyleLink == null)
                return a[n.abstractNumId].levels[c];
              var x = e.findNumberingStyleById(o.numStyleLink);
              return h(x.numId, c);
            } else
              return null;
          } else
            return null;
        }
        function g(d) {
          return r[d] || null;
        }
        return {
          findLevel: h,
          findLevelByParagraphStyleId: g
        };
      }
      function u(v, a) {
        if (!a || !a.styles)
          throw new Error("styles is missing");
        var e = P(v), y = i(v);
        return new Q(y, e, a.styles);
      }
      function P(v) {
        var a = {};
        return v.getElementsByTagName("w:abstractNum").forEach(function(e) {
          var y = e.attributes["w:abstractNumId"];
          a[y] = t(e);
        }), a;
      }
      function t(v) {
        var a = {};
        v.getElementsByTagName("w:lvl").forEach(function(y) {
          var r = y.attributes["w:ilvl"], h = y.first("w:numFmt").attributes["w:val"], g = y.firstOrEmpty("w:pStyle").attributes["w:val"];
          a[r] = {
            isOrdered: h !== "bullet",
            level: r,
            paragraphStyleId: g
          };
        });
        var e = v.firstOrEmpty("w:numStyleLink").attributes["w:val"];
        return { levels: a, numStyleLink: e };
      }
      function i(v) {
        var a = {};
        return v.getElementsByTagName("w:num").forEach(function(e) {
          var y = e.attributes["w:numId"], r = e.first("w:abstractNumId").attributes["w:val"];
          a[y] = { abstractNumId: r };
        }), a;
      }
    }, { underscore: 117 }], 12: [function(le, de, oe) {
      var se = le("underscore"), Q = le("../promises"), u = le("../xml");
      oe.read = t, oe.readXmlFromZipFile = i;
      var P = {
        "http://schemas.openxmlformats.org/wordprocessingml/2006/main": "w",
        "http://schemas.openxmlformats.org/officeDocument/2006/relationships": "r",
        "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing": "wp",
        "http://schemas.openxmlformats.org/drawingml/2006/main": "a",
        "http://schemas.openxmlformats.org/drawingml/2006/picture": "pic",
        "http://schemas.openxmlformats.org/package/2006/content-types": "content-types",
        "urn:schemas-microsoft-com:vml": "v",
        "http://schemas.openxmlformats.org/markup-compatibility/2006": "mc",
        "urn:schemas-microsoft-com:office:word": "office-word"
      };
      function t(e) {
        return u.readString(e, P).then(function(y) {
          return a(y)[0];
        });
      }
      function i(e, y) {
        return e.exists(y) ? e.read(y, "utf-8").then(v).then(t) : Q.resolve(null);
      }
      function v(e) {
        return e.replace(/^\uFEFF/g, "");
      }
      function a(e) {
        return e.type === "element" ? e.name === "mc:AlternateContent" ? e.first("mc:Fallback").children : (e.children = se.flatten(e.children.map(a, !0)), [e]) : [e];
      }
    }, { "../promises": 23, "../xml": 35, underscore: 117 }], 13: [function(le, de, oe) {
      oe.readRelationships = se, oe.defaultValue = new Q([]), oe.Relationships = Q;
      function se(u) {
        var P = [];
        return u.children.forEach(function(t) {
          if (t.name === "{http://schemas.openxmlformats.org/package/2006/relationships}Relationship") {
            var i = {
              relationshipId: t.attributes.Id,
              target: t.attributes.Target,
              type: t.attributes.Type
            };
            P.push(i);
          }
        }), new Q(P);
      }
      function Q(u) {
        var P = {};
        u.forEach(function(i) {
          P[i.relationshipId] = i.target;
        });
        var t = {};
        return u.forEach(function(i) {
          t[i.type] || (t[i.type] = []), t[i.type].push(i.target);
        }), {
          findTargetByRelationshipId: function(i) {
            return P[i];
          },
          findTargetsByType: function(i) {
            return t[i] || [];
          }
        };
      }
    }, {}], 14: [function(le, de, oe) {
      var se = le("underscore"), Q = le("../promises"), u = le("../xml");
      oe.writeStyleMap = v, oe.readStyleMap = r;
      var P = "http://schemas.zwobble.org/mammoth/style-map", t = "mammoth/style-map", i = "/" + t;
      function v(h, g) {
        return h.write(t, g), a(h).then(function() {
          return e(h);
        });
      }
      function a(h) {
        var g = "word/_rels/document.xml.rels", d = "http://schemas.openxmlformats.org/package/2006/relationships", c = "{" + d + "}Relationship";
        return h.read(g, "utf8").then(u.readString).then(function(n) {
          var o = n.children;
          y(o, c, "Id", {
            Id: "rMammothStyleMap",
            Type: P,
            Target: i
          });
          var x = { "": d };
          return h.write(g, u.writeString(n, x));
        });
      }
      function e(h) {
        var g = "[Content_Types].xml", d = "http://schemas.openxmlformats.org/package/2006/content-types", c = "{" + d + "}Override";
        return h.read(g, "utf8").then(u.readString).then(function(n) {
          var o = n.children;
          y(o, c, "PartName", {
            PartName: i,
            ContentType: "text/prs.mammoth.style-map"
          });
          var x = { "": d };
          return h.write(g, u.writeString(n, x));
        });
      }
      function y(h, g, d, c) {
        var n = se.find(h, function(o) {
          return o.name === g && o.attributes[d] === c[d];
        });
        n ? n.attributes = c : h.push(u.element(g, c));
      }
      function r(h) {
        return h.exists(t) ? h.read(t, "utf8") : Q.resolve(null);
      }
    }, { "../promises": 23, "../xml": 35, underscore: 117 }], 15: [function(le, de, oe) {
      oe.readStylesXml = Q, oe.Styles = se, oe.defaultStyles = new se({}, {});
      function se(i, v, a, e) {
        return {
          findParagraphStyleById: function(y) {
            return i[y];
          },
          findCharacterStyleById: function(y) {
            return v[y];
          },
          findTableStyleById: function(y) {
            return a[y];
          },
          findNumberingStyleById: function(y) {
            return e[y];
          }
        };
      }
      se.EMPTY = new se({}, {}, {}, {});
      function Q(i) {
        var v = {}, a = {}, e = {}, y = {}, r = {
          paragraph: v,
          character: a,
          table: e
        };
        return i.getElementsByTagName("w:style").forEach(function(h) {
          var g = u(h);
          if (g.type === "numbering")
            y[g.styleId] = t(h);
          else {
            var d = r[g.type];
            d && (d[g.styleId] = g);
          }
        }), new se(v, a, e, y);
      }
      function u(i) {
        var v = i.attributes["w:type"], a = i.attributes["w:styleId"], e = P(i);
        return { type: v, styleId: a, name: e };
      }
      function P(i) {
        var v = i.first("w:name");
        return v ? v.attributes["w:val"] : null;
      }
      function t(i) {
        var v = i.firstOrEmpty("w:pPr").firstOrEmpty("w:numPr").firstOrEmpty("w:numId").attributes["w:val"];
        return { numId: v };
      }
    }, {}], 16: [function(le, de, oe) {
      oe.uriToZipEntryName = se, oe.replaceFragment = Q;
      function se(u, P) {
        return P.charAt(0) === "/" ? P.substr(1) : u + "/" + P;
      }
      function Q(u, P) {
        var t = u.indexOf("#");
        return t !== -1 && (u = u.substring(0, t)), u + "#" + P;
      }
    }, {}], 17: [function(le, de, oe) {
      var se = le("../styles/html-paths");
      function Q(e, y, r) {
        return P(
          se.element(e, y, { fresh: !1 }),
          r
        );
      }
      function u(e, y, r) {
        var h = se.element(e, y, { fresh: !0 });
        return P(h, r);
      }
      function P(e, y) {
        return {
          type: "element",
          tag: e,
          children: y || []
        };
      }
      function t(e) {
        return {
          type: "text",
          value: e
        };
      }
      var i = {
        type: "forceWrite"
      };
      oe.freshElement = u, oe.nonFreshElement = Q, oe.elementWithTag = P, oe.text = t, oe.forceWrite = i;
      var v = {
        br: !0,
        hr: !0,
        img: !0
      };
      function a(e) {
        return e.children.length === 0 && v[e.tag.tagName];
      }
      oe.isVoidElement = a;
    }, { "../styles/html-paths": 28 }], 18: [function(le, de, oe) {
      var se = le("./ast");
      oe.freshElement = se.freshElement, oe.nonFreshElement = se.nonFreshElement, oe.elementWithTag = se.elementWithTag, oe.text = se.text, oe.forceWrite = se.forceWrite, oe.simplify = le("./simplify");
      function Q(v, a) {
        a.forEach(function(e) {
          u(v, e);
        });
      }
      function u(v, a) {
        P[a.type](v, a);
      }
      var P = {
        element: t,
        text: i,
        forceWrite: function() {
        }
      };
      function t(v, a) {
        se.isVoidElement(a) ? v.selfClosing(a.tag.tagName, a.tag.attributes) : (v.open(a.tag.tagName, a.tag.attributes), Q(v, a.children), v.close(a.tag.tagName));
      }
      function i(v, a) {
        v.text(a.value);
      }
      oe.write = Q;
    }, { "./ast": 17, "./simplify": 19 }], 19: [function(le, de, oe) {
      var se = le("underscore"), Q = le("./ast");
      function u(n) {
        return P(y(n));
      }
      function P(n) {
        var o = [];
        return n.map(t).forEach(function(x) {
          e(o, x);
        }), o;
      }
      function t(n) {
        return i[n.type](n);
      }
      var i = {
        element: v,
        text: a,
        forceWrite: a
      };
      function v(n) {
        return Q.elementWithTag(n.tag, P(n.children));
      }
      function a(n) {
        return n;
      }
      function e(n, o) {
        var x = n[n.length - 1];
        o.type === "element" && !o.tag.fresh && x && x.type === "element" && o.tag.matchesElement(x.tag) ? (o.tag.separator && e(x.children, Q.text(o.tag.separator)), o.children.forEach(function(f) {
          e(x.children, f);
        })) : n.push(o);
      }
      function y(n) {
        return r(n, function(o) {
          return h[o.type](o);
        });
      }
      function r(n, o) {
        return se.flatten(se.map(n, o), !0);
      }
      var h = {
        element: d,
        text: c,
        forceWrite: g
      };
      function g(n) {
        return [n];
      }
      function d(n) {
        var o = y(n.children);
        return o.length === 0 && !Q.isVoidElement(n) ? [] : [Q.elementWithTag(n.tag, o)];
      }
      function c(n) {
        return n.value.length === 0 ? [] : [n];
      }
      de.exports = u;
    }, { "./ast": 17, underscore: 117 }], 20: [function(le, de, oe) {
      var se = le("underscore"), Q = le("./promises"), u = le("./html");
      oe.imgElement = P;
      function P(t) {
        return function(i, v) {
          return Q.when(t(i)).then(function(a) {
            var e = {};
            return i.altText && (e.alt = i.altText), se.extend(e, a), [u.freshElement("img", e)];
          });
        };
      }
      oe.inline = oe.imgElement, oe.dataUri = P(function(t) {
        return t.read("base64").then(function(i) {
          return {
            src: "data:" + t.contentType + ";base64," + i
          };
        });
      });
    }, { "./html": 18, "./promises": 23, underscore: 117 }], 21: [function(le, de, oe) {
      var se = le("underscore"), Q = le("./docx/docx-reader"), u = le("./docx/style-map"), P = le("./document-to-html").DocumentConverter, t = le("./raw-text").convertElementToRawText, i = le("./style-reader").readStyle, v = le("./options-reader").readOptions, a = le("./unzip"), e = le("./results").Result;
      oe.convertToHtml = y, oe.convertToMarkdown = r, oe.convert = h, oe.extractRawText = n, oe.images = le("./images"), oe.transforms = le("./transforms"), oe.underline = le("./underline"), oe.embedStyleMap = o, oe.readEmbeddedStyleMap = g;
      function y(x, f) {
        return h(x, f);
      }
      function r(x, f) {
        var m = Object.create(f || {});
        return m.outputFormat = "markdown", h(x, m);
      }
      function h(x, f) {
        return f = v(f), a.openZip(x).tap(function(m) {
          return u.readStyleMap(m).then(function(C) {
            f.embeddedStyleMap = C;
          });
        }).then(function(m) {
          return Q.read(m, x).then(function(C) {
            return C.map(f.transformDocument);
          }).then(function(C) {
            return d(C, f);
          });
        });
      }
      function g(x) {
        return a.openZip(x).then(u.readStyleMap);
      }
      function d(x, f) {
        var m = c(f.readStyleMap()), C = se.extend({}, f, {
          styleMap: m.value
        }), p = new P(C);
        return x.flatMapThen(function(w) {
          return m.flatMapThen(function(X) {
            return p.convertToHtml(w);
          });
        });
      }
      function c(x) {
        return e.combine((x || []).map(i)).map(function(f) {
          return f.filter(function(m) {
            return !!m;
          });
        });
      }
      function n(x) {
        return a.openZip(x).then(Q.read).then(function(f) {
          return f.map(t);
        });
      }
      function o(x, f) {
        return a.openZip(x).tap(function(m) {
          return u.writeStyleMap(m, f);
        }).then(function(m) {
          return m.toBuffer();
        }).then(function(m) {
          return {
            toBuffer: function() {
              return m;
            }
          };
        });
      }
      oe.styleMapping = function() {
        throw new Error(`Use a raw string instead of mammoth.styleMapping e.g. "p[style-name='Title'] => h1" instead of mammoth.styleMapping("p[style-name='Title'] => h1")`);
      };
    }, { "./document-to-html": 3, "./docx/docx-reader": 9, "./docx/style-map": 14, "./images": 20, "./options-reader": 22, "./raw-text": 24, "./results": 25, "./style-reader": 26, "./transforms": 30, "./underline": 31, "./unzip": 2, underscore: 117 }], 22: [function(le, de, oe) {
      oe.readOptions = P;
      var se = le("underscore"), Q = oe._defaultStyleMap = [
        "p.Heading1 => h1:fresh",
        "p.Heading2 => h2:fresh",
        "p.Heading3 => h3:fresh",
        "p.Heading4 => h4:fresh",
        "p.Heading5 => h5:fresh",
        "p.Heading6 => h6:fresh",
        "p[style-name='Heading 1'] => h1:fresh",
        "p[style-name='Heading 2'] => h2:fresh",
        "p[style-name='Heading 3'] => h3:fresh",
        "p[style-name='Heading 4'] => h4:fresh",
        "p[style-name='Heading 5'] => h5:fresh",
        "p[style-name='Heading 6'] => h6:fresh",
        "p[style-name='heading 1'] => h1:fresh",
        "p[style-name='heading 2'] => h2:fresh",
        "p[style-name='heading 3'] => h3:fresh",
        "p[style-name='heading 4'] => h4:fresh",
        "p[style-name='heading 5'] => h5:fresh",
        "p[style-name='heading 6'] => h6:fresh",
        "r[style-name='Strong'] => strong",
        "p[style-name='footnote text'] => p:fresh",
        "r[style-name='footnote reference'] =>",
        "p[style-name='endnote text'] => p:fresh",
        "r[style-name='endnote reference'] =>",
        "p[style-name='annotation text'] => p:fresh",
        "r[style-name='annotation reference'] =>",
        // LibreOffice
        "p[style-name='Footnote'] => p:fresh",
        "r[style-name='Footnote anchor'] =>",
        "p[style-name='Endnote'] => p:fresh",
        "r[style-name='Endnote anchor'] =>",
        "p:unordered-list(1) => ul > li:fresh",
        "p:unordered-list(2) => ul|ol > li > ul > li:fresh",
        "p:unordered-list(3) => ul|ol > li > ul|ol > li > ul > li:fresh",
        "p:unordered-list(4) => ul|ol > li > ul|ol > li > ul|ol > li > ul > li:fresh",
        "p:unordered-list(5) => ul|ol > li > ul|ol > li > ul|ol > li > ul|ol > li > ul > li:fresh",
        "p:ordered-list(1) => ol > li:fresh",
        "p:ordered-list(2) => ul|ol > li > ol > li:fresh",
        "p:ordered-list(3) => ul|ol > li > ul|ol > li > ol > li:fresh",
        "p:ordered-list(4) => ul|ol > li > ul|ol > li > ul|ol > li > ol > li:fresh",
        "p:ordered-list(5) => ul|ol > li > ul|ol > li > ul|ol > li > ul|ol > li > ol > li:fresh",
        "r[style-name='Hyperlink'] =>",
        "p[style-name='Normal'] => p:fresh"
      ], u = oe._standardOptions = {
        transformDocument: i,
        includeDefaultStyleMap: !0,
        includeEmbeddedStyleMap: !0
      };
      function P(v) {
        return v = v || {}, se.extend({}, u, v, {
          customStyleMap: t(v.styleMap),
          readStyleMap: function() {
            var a = this.customStyleMap;
            return this.includeEmbeddedStyleMap && (a = a.concat(t(this.embeddedStyleMap))), this.includeDefaultStyleMap && (a = a.concat(Q)), a;
          }
        });
      }
      function t(v) {
        return v ? se.isString(v) ? v.split(`
`).map(function(a) {
          return a.trim();
        }).filter(function(a) {
          return a !== "" && a.charAt(0) !== "#";
        }) : v : [];
      }
      function i(v) {
        return v;
      }
    }, { underscore: 117 }], 23: [function(le, de, oe) {
      var se = le("underscore"), Q = le("bluebird/js/release/promise")();
      oe.defer = u, oe.when = Q.resolve, oe.resolve = Q.resolve, oe.all = Q.all, oe.props = Q.props, oe.reject = Q.reject, oe.promisify = Q.promisify, oe.mapSeries = Q.mapSeries, oe.attempt = Q.attempt, oe.nfcall = function(P) {
        var t = Array.prototype.slice.call(arguments, 1), i = Q.promisify(P);
        return i.apply(null, t);
      }, Q.prototype.fail = Q.prototype.caught, Q.prototype.also = function(P) {
        return this.then(function(t) {
          var i = se.extend({}, t, P(t));
          return Q.props(i);
        });
      };
      function u() {
        var P, t, i = new Q.Promise(function(v, a) {
          P = v, t = a;
        });
        return {
          resolve: P,
          reject: t,
          promise: i
        };
      }
    }, { "bluebird/js/release/promise": 61, underscore: 117 }], 24: [function(le, de, oe) {
      var se = le("./documents");
      function Q(u) {
        if (u.type === "text")
          return u.value;
        if (u.type === se.types.tab)
          return "	";
        var P = u.type === "paragraph" ? `

` : "";
        return (u.children || []).map(Q).join("") + P;
      }
      oe.convertElementToRawText = Q;
    }, { "./documents": 4 }], 25: [function(le, de, oe) {
      var se = le("underscore");
      oe.Result = Q, oe.success = u, oe.warning = P, oe.error = t;
      function Q(e, y) {
        this.value = e, this.messages = y || [];
      }
      Q.prototype.map = function(e) {
        return new Q(e(this.value), this.messages);
      }, Q.prototype.flatMap = function(e) {
        var y = e(this.value);
        return new Q(y.value, i([this, y]));
      }, Q.prototype.flatMapThen = function(e) {
        var y = this;
        return e(this.value).then(function(r) {
          return new Q(r.value, i([y, r]));
        });
      }, Q.combine = function(e) {
        var y = se.flatten(se.pluck(e, "value")), r = i(e);
        return new Q(y, r);
      };
      function u(e) {
        return new Q(e, []);
      }
      function P(e) {
        return {
          type: "warning",
          message: e
        };
      }
      function t(e) {
        return {
          type: "error",
          message: e.message,
          error: e
        };
      }
      function i(e) {
        var y = [];
        return se.flatten(se.pluck(e, "messages"), !0).forEach(function(r) {
          v(y, r) || y.push(r);
        }), y;
      }
      function v(e, y) {
        return se.find(e, a.bind(null, y)) !== void 0;
      }
      function a(e, y) {
        return e.type === y.type && e.message === y.message;
      }
    }, { underscore: 117 }], 26: [function(le, de, oe) {
      var se = le("underscore"), Q = le("lop"), u = le("./styles/document-matchers"), P = le("./styles/html-paths"), t = le("./styles/parser/tokeniser").tokenise, i = le("./results");
      oe.readHtmlPath = r, oe.readDocumentMatcher = e, oe.readStyle = v;
      function v(w) {
        return f(p, w);
      }
      function a() {
        return Q.rules.sequence(
          Q.rules.sequence.capture(y()),
          Q.rules.tokenOfType("whitespace"),
          Q.rules.tokenOfType("arrow"),
          Q.rules.sequence.capture(Q.rules.optional(Q.rules.sequence(
            Q.rules.tokenOfType("whitespace"),
            Q.rules.sequence.capture(h())
          ).head())),
          Q.rules.tokenOfType("end")
        ).map(function(w, X) {
          return {
            from: w,
            to: X.valueOrElse(P.empty)
          };
        });
      }
      function e(w) {
        return f(y(), w);
      }
      function y() {
        var w = Q.rules.sequence, X = function(L, Y) {
          return Q.rules.then(
            Q.rules.token("identifier", L),
            function() {
              return Y;
            }
          );
        }, M = X("p", u.paragraph), j = X("r", u.run), B = Q.rules.firstOf(
          "p or r or table",
          M,
          j
        ), R = Q.rules.then(
          x,
          function(L) {
            return { styleId: L };
          }
        ), D = Q.rules.firstOf(
          "style name matcher",
          Q.rules.then(
            Q.rules.sequence(
              Q.rules.tokenOfType("equals"),
              Q.rules.sequence.cut(),
              Q.rules.sequence.capture(c)
            ).head(),
            function(L) {
              return { styleName: u.equalTo(L) };
            }
          ),
          Q.rules.then(
            Q.rules.sequence(
              Q.rules.tokenOfType("startsWith"),
              Q.rules.sequence.cut(),
              Q.rules.sequence.capture(c)
            ).head(),
            function(L) {
              return { styleName: u.startsWith(L) };
            }
          )
        ), b = Q.rules.sequence(
          Q.rules.tokenOfType("open-square-bracket"),
          Q.rules.sequence.cut(),
          Q.rules.token("identifier", "style-name"),
          Q.rules.sequence.capture(D),
          Q.rules.tokenOfType("close-square-bracket")
        ).head(), l = Q.rules.firstOf(
          "list type",
          X("ordered-list", { isOrdered: !0 }),
          X("unordered-list", { isOrdered: !1 })
        ), _ = w(
          Q.rules.tokenOfType("colon"),
          w.capture(l),
          w.cut(),
          Q.rules.tokenOfType("open-paren"),
          w.capture(d),
          Q.rules.tokenOfType("close-paren")
        ).map(function(L, Y) {
          return {
            list: {
              isOrdered: L.isOrdered,
              levelIndex: Y - 1
            }
          };
        });
        function S(L) {
          var Y = Q.rules.firstOf.apply(
            Q.rules.firstOf,
            ["matcher suffix"].concat(L)
          ), J = Q.rules.zeroOrMore(Y);
          return Q.rules.then(J, function(ie) {
            var q = {};
            return ie.forEach(function(N) {
              se.extend(q, N);
            }), q;
          });
        }
        var A = w(
          w.capture(B),
          w.capture(S([
            R,
            b,
            _
          ]))
        ).map(function(L, Y) {
          return L(Y);
        }), F = w(
          Q.rules.token("identifier", "table"),
          w.capture(S([
            R,
            b
          ]))
        ).map(function(L) {
          return u.table(L);
        }), T = X("b", u.bold), O = X("i", u.italic), U = X("u", u.underline), G = X("strike", u.strikethrough), K = X("all-caps", u.allCaps), W = X("small-caps", u.smallCaps), z = X("comment-reference", u.commentReference), V = w(
          Q.rules.token("identifier", "br"),
          w.cut(),
          Q.rules.tokenOfType("open-square-bracket"),
          Q.rules.token("identifier", "type"),
          Q.rules.tokenOfType("equals"),
          w.capture(c),
          Q.rules.tokenOfType("close-square-bracket")
        ).map(function(L) {
          switch (L) {
            case "line":
              return u.lineBreak;
            case "page":
              return u.pageBreak;
            case "column":
              return u.columnBreak;
          }
        });
        return Q.rules.firstOf(
          "element type",
          A,
          F,
          T,
          O,
          U,
          G,
          K,
          W,
          z,
          V
        );
      }
      function r(w) {
        return f(h(), w);
      }
      function h() {
        var w = Q.rules.sequence.capture, X = Q.rules.tokenOfType("whitespace"), M = Q.rules.then(
          Q.rules.optional(Q.rules.sequence(
            Q.rules.tokenOfType("colon"),
            Q.rules.token("identifier", "fresh")
          )),
          function(D) {
            return D.map(function() {
              return !0;
            }).valueOrElse(!1);
          }
        ), j = Q.rules.then(
          Q.rules.optional(Q.rules.sequence(
            Q.rules.tokenOfType("colon"),
            Q.rules.token("identifier", "separator"),
            Q.rules.tokenOfType("open-paren"),
            w(c),
            Q.rules.tokenOfType("close-paren")
          ).head()),
          function(D) {
            return D.valueOrElse("");
          }
        ), B = Q.rules.oneOrMoreWithSeparator(
          g,
          Q.rules.tokenOfType("choice")
        ), R = Q.rules.sequence(
          w(B),
          w(Q.rules.zeroOrMore(x)),
          w(M),
          w(j)
        ).map(function(D, b, l, _) {
          var S = {}, A = {};
          return b.length > 0 && (S.class = b.join(" ")), l && (A.fresh = !0), _ && (A.separator = _), P.element(D, S, A);
        });
        return Q.rules.firstOf(
          "html path",
          Q.rules.then(Q.rules.tokenOfType("bang"), function() {
            return P.ignore;
          }),
          Q.rules.then(
            Q.rules.zeroOrMoreWithSeparator(
              R,
              Q.rules.sequence(
                X,
                Q.rules.tokenOfType("gt"),
                X
              )
            ),
            P.elements
          )
        );
      }
      var g = Q.rules.then(
        Q.rules.tokenOfType("identifier"),
        o
      ), d = Q.rules.tokenOfType("integer"), c = Q.rules.then(
        Q.rules.tokenOfType("string"),
        o
      ), n = {
        n: `
`,
        r: "\r",
        t: "	"
      };
      function o(w) {
        return w.replace(/\\(.)/g, function(X, M) {
          return n[M] || M;
        });
      }
      var x = Q.rules.sequence(
        Q.rules.tokenOfType("dot"),
        Q.rules.sequence.cut(),
        Q.rules.sequence.capture(g)
      ).head();
      function f(w, X) {
        var M = t(X), j = Q.Parser(), B = j.parseTokens(w, M);
        return B.isSuccess() ? i.success(B.value()) : new i.Result(null, [i.warning(m(X, B))]);
      }
      function m(w, X) {
        return "Did not understand this style mapping, so ignored it: " + w + `
` + X.errors().map(C).join(`
`);
      }
      function C(w) {
        return "Error was at character number " + w.characterNumber() + ": Expected " + w.expected + " but got " + w.actual;
      }
      var p = a();
    }, { "./results": 25, "./styles/document-matchers": 27, "./styles/html-paths": 28, "./styles/parser/tokeniser": 29, lop: 88, underscore: 117 }], 27: [function(le, de, oe) {
      oe.paragraph = se, oe.run = Q, oe.table = u, oe.bold = new P("bold"), oe.italic = new P("italic"), oe.underline = new P("underline"), oe.strikethrough = new P("strikethrough"), oe.allCaps = new P("allCaps"), oe.smallCaps = new P("smallCaps"), oe.commentReference = new P("commentReference"), oe.lineBreak = new P("break", { breakType: "line" }), oe.pageBreak = new P("break", { breakType: "page" }), oe.columnBreak = new P("break", { breakType: "column" }), oe.equalTo = i, oe.startsWith = v;
      function se(y) {
        return new P("paragraph", y);
      }
      function Q(y) {
        return new P("run", y);
      }
      function u(y) {
        return new P("table", y);
      }
      function P(y, r) {
        r = r || {}, this._elementType = y, this._styleId = r.styleId, this._styleName = r.styleName, r.list && (this._listIndex = r.list.levelIndex, this._listIsOrdered = r.list.isOrdered);
      }
      P.prototype.matches = function(y) {
        return y.type === this._elementType && (this._styleId === void 0 || y.styleId === this._styleId) && (this._styleName === void 0 || y.styleName && this._styleName.operator(this._styleName.operand, y.styleName)) && (this._listIndex === void 0 || t(y, this._listIndex, this._listIsOrdered)) && (this._breakType === void 0 || this._breakType === y.breakType);
      };
      function t(y, r, h) {
        return y.numbering && y.numbering.level == r && y.numbering.isOrdered == h;
      }
      function i(y) {
        return {
          operator: a,
          operand: y
        };
      }
      function v(y) {
        return {
          operator: e,
          operand: y
        };
      }
      function a(y, r) {
        return y.toUpperCase() === r.toUpperCase();
      }
      function e(y, r) {
        return r.toUpperCase().indexOf(y.toUpperCase()) === 0;
      }
    }, {}], 28: [function(le, de, oe) {
      var se = le("underscore"), Q = le("../html");
      oe.topLevelElement = u, oe.elements = P, oe.element = i;
      function u(a, e) {
        return P([i(a, e, { fresh: !0 })]);
      }
      function P(a) {
        return new t(a.map(function(e) {
          return se.isString(e) ? i(e) : e;
        }));
      }
      function t(a) {
        this._elements = a;
      }
      t.prototype.wrap = function(e) {
        for (var y = e(), r = this._elements.length - 1; r >= 0; r--)
          y = this._elements[r].wrapNodes(y);
        return y;
      };
      function i(a, e, y) {
        return y = y || {}, new v(a, e, y);
      }
      function v(a, e, y) {
        var r = {};
        se.isArray(a) ? (a.forEach(function(h) {
          r[h] = !0;
        }), a = a[0]) : r[a] = !0, this.tagName = a, this.tagNames = r, this.attributes = e || {}, this.fresh = y.fresh, this.separator = y.separator;
      }
      v.prototype.matchesElement = function(a) {
        return this.tagNames[a.tagName] && se.isEqual(this.attributes || {}, a.attributes || {});
      }, v.prototype.wrap = function(e) {
        return this.wrapNodes(e());
      }, v.prototype.wrapNodes = function(e) {
        return [Q.elementWithTag(this, e)];
      }, oe.empty = P([]), oe.ignore = {
        wrap: function() {
          return [];
        }
      };
    }, { "../html": 18, underscore: 117 }], 29: [function(le, de, oe) {
      var se = le("lop"), Q = se.RegexTokeniser;
      oe.tokenise = P;
      var u = "'((?:\\\\.|[^'])*)";
      function P(t) {
        var i = "(?:[a-zA-Z\\-_]|\\\\.)", v = new Q([
          { name: "identifier", regex: new RegExp("(" + i + "(?:" + i + "|[0-9])*)") },
          { name: "dot", regex: /\./ },
          { name: "colon", regex: /:/ },
          { name: "gt", regex: />/ },
          { name: "whitespace", regex: /\s+/ },
          { name: "arrow", regex: /=>/ },
          { name: "equals", regex: /=/ },
          { name: "startsWith", regex: /\^=/ },
          { name: "open-paren", regex: /\(/ },
          { name: "close-paren", regex: /\)/ },
          { name: "open-square-bracket", regex: /\[/ },
          { name: "close-square-bracket", regex: /\]/ },
          { name: "string", regex: new RegExp(u + "'") },
          { name: "unterminated-string", regex: new RegExp(u) },
          { name: "integer", regex: /([0-9]+)/ },
          { name: "choice", regex: /\|/ },
          { name: "bang", regex: /(!)/ }
        ]);
        return v.tokenise(t);
      }
    }, { lop: 88 }], 30: [function(le, de, oe) {
      var se = le("underscore");
      oe.paragraph = Q, oe.run = u, oe._elements = t, oe.getDescendantsOfType = i, oe.getDescendants = v;
      function Q(e) {
        return P("paragraph", e);
      }
      function u(e) {
        return P("run", e);
      }
      function P(e, y) {
        return t(function(r) {
          return r.type === e ? y(r) : r;
        });
      }
      function t(e) {
        return function y(r) {
          if (r.children) {
            var h = se.map(r.children, y);
            r = se.extend(r, { children: h });
          }
          return e(r);
        };
      }
      function i(e, y) {
        return v(e).filter(function(r) {
          return r.type === y;
        });
      }
      function v(e) {
        var y = [];
        return a(e, function(r) {
          y.push(r);
        }), y;
      }
      function a(e, y) {
        e.children && e.children.forEach(function(r) {
          a(r, y), y(r);
        });
      }
    }, { underscore: 117 }], 31: [function(le, de, oe) {
      var se = le("./styles/html-paths"), Q = le("./html");
      oe.element = u;
      function u(P) {
        return function(t) {
          return Q.elementWithTag(se.element(P), [t]);
        };
      }
    }, { "./html": 18, "./styles/html-paths": 28 }], 32: [function(le, de, oe) {
      var se = le("util"), Q = le("underscore");
      oe.writer = u;
      function u(e) {
        return e = e || {}, e.prettyPrint ? t() : i();
      }
      var P = {
        div: !0,
        p: !0,
        ul: !0,
        li: !0
      };
      function t() {
        var e = 0, y = "  ", r = [], h = !0, g = !1, d = i();
        function c(w, X) {
          P[w] && C(), r.push(w), d.open(w, X), P[w] && e++, h = !1;
        }
        function n(w) {
          P[w] && (e--, C()), r.pop(), d.close(w);
        }
        function o(w) {
          m();
          var X = p() ? w : w.replace(`
`, `
` + y);
          d.text(X);
        }
        function x(w, X) {
          C(), d.selfClosing(w, X);
        }
        function f() {
          return r.length === 0 || P[r[r.length - 1]];
        }
        function m() {
          g || (C(), g = !0);
        }
        function C() {
          if (g = !1, !h && f() && !p()) {
            d._append(`
`);
            for (var w = 0; w < e; w++)
              d._append(y);
          }
        }
        function p() {
          return Q.some(r, function(w) {
            return w === "pre";
          });
        }
        return {
          asString: d.asString,
          open: c,
          close: n,
          text: o,
          selfClosing: x
        };
      }
      function i() {
        var e = [];
        function y(o, x) {
          var f = g(x);
          e.push(se.format("<%s%s>", o, f));
        }
        function r(o) {
          e.push(se.format("</%s>", o));
        }
        function h(o, x) {
          var f = g(x);
          e.push(se.format("<%s%s />", o, f));
        }
        function g(o) {
          return Q.map(o, function(x, f) {
            return se.format(' %s="%s"', f, a(x));
          }).join("");
        }
        function d(o) {
          e.push(v(o));
        }
        function c(o) {
          e.push(o);
        }
        function n() {
          return e.join("");
        }
        return {
          asString: n,
          open: y,
          close: r,
          text: d,
          selfClosing: h,
          _append: c
        };
      }
      function v(e) {
        return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
      }
      function a(e) {
        return e.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
      }
    }, { underscore: 117, util: 121 }], 33: [function(le, de, oe) {
      var se = le("./html-writer"), Q = le("./markdown-writer");
      oe.writer = u;
      function u(P) {
        return P = P || {}, P.outputFormat === "markdown" ? Q.writer() : se.writer(P);
      }
    }, { "./html-writer": 32, "./markdown-writer": 34 }], 34: [function(le, de, oe) {
      var se = le("underscore");
      function Q(h) {
        return u(h, h);
      }
      function u(h, g) {
        return function() {
          return { start: h, end: g };
        };
      }
      function P(h) {
        var g = h.href || "";
        return g ? {
          start: "[",
          end: "](" + g + ")",
          anchorPosition: "before"
        } : {};
      }
      function t(h) {
        var g = h.src || "", d = h.alt || "";
        return g || d ? { start: "![" + d + "](" + g + ")" } : {};
      }
      function i(h) {
        return function(g, d) {
          return {
            start: d ? `
` : "",
            end: d ? "" : `
`,
            list: {
              isOrdered: h.isOrdered,
              indent: d ? d.indent + 1 : 0,
              count: 0
            }
          };
        };
      }
      function v(h, g, d) {
        g = g || { indent: 0, isOrdered: !1, count: 0 }, g.count++, d.hasClosed = !1;
        var c = g.isOrdered ? g.count + "." : "-", n = e("	", g.indent) + c + " ";
        return {
          start: n,
          end: function() {
            if (!d.hasClosed)
              return d.hasClosed = !0, `
`;
          }
        };
      }
      var a = {
        p: u("", `

`),
        br: u("", `  
`),
        ul: i({ isOrdered: !1 }),
        ol: i({ isOrdered: !0 }),
        li: v,
        strong: Q("__"),
        em: Q("*"),
        a: P,
        img: t
      };
      (function() {
        for (var h = 1; h <= 6; h++)
          a["h" + h] = u(e("#", h) + " ", `

`);
      })();
      function e(h, g) {
        return new Array(g + 1).join(h);
      }
      function y() {
        var h = [], g = [], d = null, c = {};
        function n(p, w) {
          w = w || {};
          var X = a[p] || function() {
            return {};
          }, M = X(w, d, c);
          g.push({ end: M.end, list: d }), M.list && (d = M.list);
          var j = M.anchorPosition === "before";
          j && o(w), h.push(M.start || ""), j || o(w);
        }
        function o(p) {
          p.id && h.push('<a id="' + p.id + '"></a>');
        }
        function x(p) {
          var w = g.pop();
          d = w.list;
          var X = se.isFunction(w.end) ? w.end() : w.end;
          h.push(X || "");
        }
        function f(p, w) {
          n(p, w), x();
        }
        function m(p) {
          h.push(r(p));
        }
        function C() {
          return h.join("");
        }
        return {
          asString: C,
          open: n,
          close: x,
          text: m,
          selfClosing: f
        };
      }
      oe.writer = y;
      function r(h) {
        return h.replace(/\\/g, "\\\\").replace(/([\`\*_\{\}\[\]\(\)\#\+\-\.\!])/g, "\\$1");
      }
    }, { underscore: 117 }], 35: [function(le, de, oe) {
      var se = le("./nodes");
      oe.Element = se.Element, oe.element = se.element, oe.text = se.text, oe.readString = le("./reader").readString, oe.writeString = le("./writer").writeString;
    }, { "./nodes": 36, "./reader": 37, "./writer": 38 }], 36: [function(le, de, oe) {
      var se = le("underscore");
      oe.Element = u, oe.element = function(i, v, a) {
        return new u(i, v, a);
      }, oe.text = function(i) {
        return {
          type: "text",
          value: i
        };
      };
      var Q = {
        first: function() {
          return null;
        },
        firstOrEmpty: function() {
          return Q;
        },
        attributes: {}
      };
      function u(i, v, a) {
        this.type = "element", this.name = i, this.attributes = v || {}, this.children = a || [];
      }
      u.prototype.first = function(i) {
        return se.find(this.children, function(v) {
          return v.name === i;
        });
      }, u.prototype.firstOrEmpty = function(i) {
        return this.first(i) || Q;
      }, u.prototype.getElementsByTagName = function(i) {
        var v = se.filter(this.children, function(a) {
          return a.name === i;
        });
        return t(v);
      }, u.prototype.text = function() {
        if (this.children.length === 0)
          return "";
        if (this.children.length !== 1 || this.children[0].type !== "text")
          throw new Error("Not implemented");
        return this.children[0].value;
      };
      var P = {
        getElementsByTagName: function(i) {
          return t(se.flatten(this.map(function(v) {
            return v.getElementsByTagName(i);
          }, !0)));
        }
      };
      function t(i) {
        return se.extend(i, P);
      }
    }, { underscore: 117 }], 37: [function(le, de, oe) {
      var se = le("../promises"), Q = le("sax"), u = le("underscore"), P = le("./nodes"), t = P.Element;
      oe.readString = i;
      function i(a, e) {
        e = e || {};
        var y = !1, r = Q.parser(!0, { xmlns: !0, position: !1 }), h = { children: [] }, g = h, d = [], c = se.defer();
        r.onopentag = function(o) {
          var x = v(o.attributes, function(m) {
            return m.value;
          }, n), f = new t(n(o), x);
          g.children.push(f), d.push(g), g = f;
        };
        function n(o) {
          if (o.uri) {
            var x = e[o.uri], f;
            return x ? f = x + ":" : f = "{" + o.uri + "}", f + o.local;
          } else
            return o.local;
        }
        return r.onclosetag = function(o) {
          g = d.pop();
        }, r.ontext = function(o) {
          g !== h && g.children.push(P.text(o));
        }, r.onend = function() {
          y || (y = !0, c.resolve(h.children[0]));
        }, r.onerror = function(o) {
          y || (y = !0, c.reject(o));
        }, r.write(a).close(), c.promise;
      }
      function v(a, e, y) {
        return u.reduce(a, function(r, h, g) {
          var d = y(h, g, a);
          return r[d] = e(h, g, a), r;
        }, {});
      }
    }, { "../promises": 23, "./nodes": 36, sax: 114, underscore: 117 }], 38: [function(le, de, oe) {
      var se = le("underscore"), Q = le("xmlbuilder");
      oe.writeString = u;
      function u(t, i) {
        var v = se.invert(i), a = {
          element: y,
          text: P
        };
        function e(g, d) {
          return a[d.type](g, d);
        }
        function y(g, d) {
          var c = g.element(r(d.name), d.attributes);
          d.children.forEach(function(n) {
            e(c, n);
          });
        }
        function r(g) {
          var d = /^\{(.*)\}(.*)$/.exec(g);
          if (d) {
            var c = v[d[1]];
            return c + (c === "" ? "" : ":") + d[2];
          } else
            return g;
        }
        function h(g) {
          var d = Q.create(r(g.name), {
            version: "1.0",
            encoding: "UTF-8",
            standalone: !0
          });
          return se.forEach(i, function(c, n) {
            var o = "xmlns" + (n === "" ? "" : ":" + n);
            d.attribute(o, c);
          }), g.children.forEach(function(c) {
            e(d, c);
          }), d.end();
        }
        return h(t);
      }
      function P(t, i) {
        t.text(i.value);
      }
    }, { underscore: 117, xmlbuilder: 143 }], 39: [function(le, de, oe) {
      (function(se) {
        var Q = le("jszip");
        oe.openArrayBuffer = u, oe.splitPath = t, oe.joinPath = i;
        function u(v) {
          return Q.loadAsync(v).then(function(a) {
            function e(g) {
              return a.file(g) !== null;
            }
            function y(g, d) {
              return a.file(g).async("uint8array").then(function(c) {
                var n = P(c);
                return d ? n.toString(d) : n;
              });
            }
            function r(g, d) {
              a.file(g, d);
            }
            function h() {
              return a.generateAsync({ type: "nodebuffer" });
            }
            return {
              exists: e,
              read: y,
              write: r,
              toBuffer: h
            };
          });
        }
        function P(v) {
          return se.from && se.from !== Uint8Array.from ? se.from(v) : new se(v);
        }
        function t(v) {
          var a = v.lastIndexOf("/");
          return a === -1 ? { dirname: "", basename: v } : {
            dirname: v.substring(0, a),
            basename: v.substring(a + 1)
          };
        }
        function i() {
          var v = Array.prototype.filter.call(arguments, function(e) {
            return e;
          }), a = [];
          return v.forEach(function(e) {
            /^\//.test(e) ? a = [e] : a.push(e);
          }), a.join("/");
        }
      }).call(this, le("buffer").Buffer);
    }, { buffer: 78, jszip: 87 }], 40: [function(le, de, oe) {
      oe.byteLength = a, oe.toByteArray = e, oe.fromByteArray = h;
      for (var se = [], Q = [], u = typeof Uint8Array < "u" ? Uint8Array : Array, P = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t = 0, i = P.length; t < i; ++t)
        se[t] = P[t], Q[P.charCodeAt(t)] = t;
      Q["-".charCodeAt(0)] = 62, Q["_".charCodeAt(0)] = 63;
      function v(g) {
        var d = g.length;
        if (d % 4 > 0)
          throw new Error("Invalid string. Length must be a multiple of 4");
        return g[d - 2] === "=" ? 2 : g[d - 1] === "=" ? 1 : 0;
      }
      function a(g) {
        return g.length * 3 / 4 - v(g);
      }
      function e(g) {
        var d, c, n, o, x, f, m = g.length;
        x = v(g), f = new u(m * 3 / 4 - x), n = x > 0 ? m - 4 : m;
        var C = 0;
        for (d = 0, c = 0; d < n; d += 4, c += 3)
          o = Q[g.charCodeAt(d)] << 18 | Q[g.charCodeAt(d + 1)] << 12 | Q[g.charCodeAt(d + 2)] << 6 | Q[g.charCodeAt(d + 3)], f[C++] = o >> 16 & 255, f[C++] = o >> 8 & 255, f[C++] = o & 255;
        return x === 2 ? (o = Q[g.charCodeAt(d)] << 2 | Q[g.charCodeAt(d + 1)] >> 4, f[C++] = o & 255) : x === 1 && (o = Q[g.charCodeAt(d)] << 10 | Q[g.charCodeAt(d + 1)] << 4 | Q[g.charCodeAt(d + 2)] >> 2, f[C++] = o >> 8 & 255, f[C++] = o & 255), f;
      }
      function y(g) {
        return se[g >> 18 & 63] + se[g >> 12 & 63] + se[g >> 6 & 63] + se[g & 63];
      }
      function r(g, d, c) {
        for (var n, o = [], x = d; x < c; x += 3)
          n = (g[x] << 16) + (g[x + 1] << 8) + g[x + 2], o.push(y(n));
        return o.join("");
      }
      function h(g) {
        for (var d, c = g.length, n = c % 3, o = "", x = [], f = 16383, m = 0, C = c - n; m < C; m += f)
          x.push(r(g, m, m + f > C ? C : m + f));
        return n === 1 ? (d = g[c - 1], o += se[d >> 2], o += se[d << 4 & 63], o += "==") : n === 2 && (d = (g[c - 2] << 8) + g[c - 1], o += se[d >> 10], o += se[d >> 4 & 63], o += se[d << 2 & 63], o += "="), x.push(o), x.join("");
      }
    }, {}], 41: [function(le, de, oe) {
      de.exports = function(se) {
        var Q = se._SomePromiseArray;
        function u(P) {
          var t = new Q(P), i = t.promise();
          return t.setHowMany(1), t.setUnwrap(), t.init(), i;
        }
        se.any = function(P) {
          return u(P);
        }, se.prototype.any = function() {
          return u(this);
        };
      };
    }, {}], 42: [function(le, de, oe) {
      (function(se) {
        var Q;
        try {
          throw new Error();
        } catch (y) {
          Q = y;
        }
        var u = le("./schedule"), P = le("./queue"), t = le("./util");
        function i() {
          this._customScheduler = !1, this._isTickUsed = !1, this._lateQueue = new P(16), this._normalQueue = new P(16), this._haveDrainedQueues = !1, this._trampolineEnabled = !0;
          var y = this;
          this.drainQueues = function() {
            y._drainQueues();
          }, this._schedule = u;
        }
        i.prototype.setScheduler = function(y) {
          var r = this._schedule;
          return this._schedule = y, this._customScheduler = !0, r;
        }, i.prototype.hasCustomScheduler = function() {
          return this._customScheduler;
        }, i.prototype.enableTrampoline = function() {
          this._trampolineEnabled = !0;
        }, i.prototype.disableTrampolineIfNecessary = function() {
          t.hasDevTools && (this._trampolineEnabled = !1);
        }, i.prototype.haveItemsQueued = function() {
          return this._isTickUsed || this._haveDrainedQueues;
        }, i.prototype.fatalError = function(y, r) {
          r ? (se.stderr.write("Fatal " + (y instanceof Error ? y.stack : y) + `
`), se.exit(2)) : this.throwLater(y);
        }, i.prototype.throwLater = function(y, r) {
          if (arguments.length === 1 && (r = y, y = function() {
            throw r;
          }), typeof setTimeout < "u")
            setTimeout(function() {
              y(r);
            }, 0);
          else
            try {
              this._schedule(function() {
                y(r);
              });
            } catch {
              throw new Error(`No async scheduler available

    See http://goo.gl/MqrFmX
`);
            }
        };
        function v(y, r, h) {
          this._lateQueue.push(y, r, h), this._queueTick();
        }
        function a(y, r, h) {
          this._normalQueue.push(y, r, h), this._queueTick();
        }
        function e(y) {
          this._normalQueue._pushOne(y), this._queueTick();
        }
        t.hasDevTools ? (i.prototype.invokeLater = function(y, r, h) {
          this._trampolineEnabled ? v.call(this, y, r, h) : this._schedule(function() {
            setTimeout(function() {
              y.call(r, h);
            }, 100);
          });
        }, i.prototype.invoke = function(y, r, h) {
          this._trampolineEnabled ? a.call(this, y, r, h) : this._schedule(function() {
            y.call(r, h);
          });
        }, i.prototype.settlePromises = function(y) {
          this._trampolineEnabled ? e.call(this, y) : this._schedule(function() {
            y._settlePromises();
          });
        }) : (i.prototype.invokeLater = v, i.prototype.invoke = a, i.prototype.settlePromises = e), i.prototype._drainQueue = function(y) {
          for (; y.length() > 0; ) {
            var r = y.shift();
            if (typeof r != "function") {
              r._settlePromises();
              continue;
            }
            var h = y.shift(), g = y.shift();
            r.call(h, g);
          }
        }, i.prototype._drainQueues = function() {
          this._drainQueue(this._normalQueue), this._reset(), this._haveDrainedQueues = !0, this._drainQueue(this._lateQueue);
        }, i.prototype._queueTick = function() {
          this._isTickUsed || (this._isTickUsed = !0, this._schedule(this.drainQueues));
        }, i.prototype._reset = function() {
          this._isTickUsed = !1;
        }, de.exports = i, de.exports.firstLineError = Q;
      }).call(this, le("_process"));
    }, { "./queue": 65, "./schedule": 68, "./util": 75, _process: 102 }], 43: [function(le, de, oe) {
      de.exports = function(se, Q, u, P) {
        var t = !1, i = function(y, r) {
          this._reject(r);
        }, v = function(y, r) {
          r.promiseRejectionQueued = !0, r.bindingPromise._then(i, i, null, this, y);
        }, a = function(y, r) {
          this._bitField & 50397184 || this._resolveCallback(r.target);
        }, e = function(y, r) {
          r.promiseRejectionQueued || this._reject(y);
        };
        se.prototype.bind = function(y) {
          t || (t = !0, se.prototype._propagateFrom = P.propagateFromFunction(), se.prototype._boundValue = P.boundValueFunction());
          var r = u(y), h = new se(Q);
          h._propagateFrom(this, 1);
          var g = this._target();
          if (h._setBoundTo(r), r instanceof se) {
            var d = {
              promiseRejectionQueued: !1,
              promise: h,
              target: g,
              bindingPromise: r
            };
            g._then(Q, v, void 0, h, d), r._then(
              a,
              e,
              void 0,
              h,
              d
            ), h._setOnCancel(r);
          } else
            h._resolveCallback(g);
          return h;
        }, se.prototype._setBoundTo = function(y) {
          y !== void 0 ? (this._bitField = this._bitField | 2097152, this._boundTo = y) : this._bitField = this._bitField & -2097153;
        }, se.prototype._isBound = function() {
          return (this._bitField & 2097152) === 2097152;
        }, se.bind = function(y, r) {
          return se.resolve(r).bind(y);
        };
      };
    }, {}], 44: [function(le, de, oe) {
      var se = Object.create;
      if (se) {
        var Q = se(null), u = se(null);
        Q[" size"] = u[" size"] = 0;
      }
      de.exports = function(P) {
        var t = le("./util"), i = t.canEvaluate, v = t.isIdentifier, a, e;
        {
          var y = function(o) {
            return new Function("ensureMethod", `                                    
	        return function(obj) {                                               
	            'use strict'                                                     
	            var len = this.length;                                           
	            ensureMethod(obj, 'methodName');                                 
	            switch(len) {                                                    
	                case 1: return obj.methodName(this[0]);                      
	                case 2: return obj.methodName(this[0], this[1]);             
	                case 3: return obj.methodName(this[0], this[1], this[2]);    
	                case 0: return obj.methodName();                             
	                default:                                                     
	                    return obj.methodName.apply(obj, this);                  
	            }                                                                
	        };                                                                   
	        `.replace(/methodName/g, o))(g);
          }, r = function(o) {
            return new Function("obj", `                                             
	        'use strict';                                                        
	        return obj.propertyName;                                             
	        `.replace("propertyName", o));
          }, h = function(o, x, f) {
            var m = f[o];
            if (typeof m != "function") {
              if (!v(o))
                return null;
              if (m = x(o), f[o] = m, f[" size"]++, f[" size"] > 512) {
                for (var C = Object.keys(f), p = 0; p < 256; ++p)
                  delete f[C[p]];
                f[" size"] = C.length - 256;
              }
            }
            return m;
          };
          a = function(o) {
            return h(o, y, Q);
          }, e = function(o) {
            return h(o, r, u);
          };
        }
        function g(o, x) {
          var f;
          if (o != null && (f = o[x]), typeof f != "function") {
            var m = "Object " + t.classString(o) + " has no method '" + t.toString(x) + "'";
            throw new P.TypeError(m);
          }
          return f;
        }
        function d(o) {
          var x = this.pop(), f = g(o, x);
          return f.apply(o, this);
        }
        P.prototype.call = function(o) {
          for (var x = arguments.length, f = new Array(Math.max(x - 1, 0)), m = 1; m < x; ++m)
            f[m - 1] = arguments[m];
          if (i) {
            var C = a(o);
            if (C !== null)
              return this._then(
                C,
                void 0,
                void 0,
                f,
                void 0
              );
          }
          return f.push(o), this._then(d, void 0, void 0, f, void 0);
        };
        function c(o) {
          return o[this];
        }
        function n(o) {
          var x = +this;
          return x < 0 && (x = Math.max(0, x + o.length)), o[x];
        }
        P.prototype.get = function(o) {
          var x = typeof o == "number", f;
          if (x)
            f = n;
          else if (i) {
            var m = e(o);
            f = m !== null ? m : c;
          } else
            f = c;
          return this._then(f, void 0, void 0, o, void 0);
        };
      };
    }, { "./util": 75 }], 45: [function(le, de, oe) {
      de.exports = function(se, Q, u, P) {
        var t = le("./util"), i = t.tryCatch, v = t.errorObj, a = se._async;
        se.prototype.break = se.prototype.cancel = function() {
          if (!P.cancellation())
            return this._warn("cancellation is disabled");
          for (var e = this, y = e; e._isCancellable(); ) {
            if (!e._cancelBy(y)) {
              y._isFollowing() ? y._followee().cancel() : y._cancelBranched();
              break;
            }
            var r = e._cancellationParent;
            if (r == null || !r._isCancellable()) {
              e._isFollowing() ? e._followee().cancel() : e._cancelBranched();
              break;
            } else
              e._isFollowing() && e._followee().cancel(), e._setWillBeCancelled(), y = e, e = r;
          }
        }, se.prototype._branchHasCancelled = function() {
          this._branchesRemainingToCancel--;
        }, se.prototype._enoughBranchesHaveCancelled = function() {
          return this._branchesRemainingToCancel === void 0 || this._branchesRemainingToCancel <= 0;
        }, se.prototype._cancelBy = function(e) {
          return e === this ? (this._branchesRemainingToCancel = 0, this._invokeOnCancel(), !0) : (this._branchHasCancelled(), this._enoughBranchesHaveCancelled() ? (this._invokeOnCancel(), !0) : !1);
        }, se.prototype._cancelBranched = function() {
          this._enoughBranchesHaveCancelled() && this._cancel();
        }, se.prototype._cancel = function() {
          this._isCancellable() && (this._setCancelled(), a.invoke(this._cancelPromises, this, void 0));
        }, se.prototype._cancelPromises = function() {
          this._length() > 0 && this._settlePromises();
        }, se.prototype._unsetOnCancel = function() {
          this._onCancelField = void 0;
        }, se.prototype._isCancellable = function() {
          return this.isPending() && !this._isCancelled();
        }, se.prototype.isCancellable = function() {
          return this.isPending() && !this.isCancelled();
        }, se.prototype._doInvokeOnCancel = function(e, y) {
          if (t.isArray(e))
            for (var r = 0; r < e.length; ++r)
              this._doInvokeOnCancel(e[r], y);
          else if (e !== void 0)
            if (typeof e == "function") {
              if (!y) {
                var h = i(e).call(this._boundValue());
                h === v && (this._attachExtraTrace(h.e), a.throwLater(h.e));
              }
            } else
              e._resultCancelled(this);
        }, se.prototype._invokeOnCancel = function() {
          var e = this._onCancel();
          this._unsetOnCancel(), a.invoke(this._doInvokeOnCancel, this, e);
        }, se.prototype._invokeInternalOnCancel = function() {
          this._isCancellable() && (this._doInvokeOnCancel(this._onCancel(), !0), this._unsetOnCancel());
        }, se.prototype._resultCancelled = function() {
          this.cancel();
        };
      };
    }, { "./util": 75 }], 46: [function(le, de, oe) {
      de.exports = function(se) {
        var Q = le("./util"), u = le("./es5").keys, P = Q.tryCatch, t = Q.errorObj;
        function i(v, a, e) {
          return function(y) {
            var r = e._boundValue();
            e:
              for (var h = 0; h < v.length; ++h) {
                var g = v[h];
                if (g === Error || g != null && g.prototype instanceof Error) {
                  if (y instanceof g)
                    return P(a).call(r, y);
                } else if (typeof g == "function") {
                  var d = P(g).call(r, y);
                  if (d === t)
                    return d;
                  if (d)
                    return P(a).call(r, y);
                } else if (Q.isObject(y)) {
                  for (var c = u(g), n = 0; n < c.length; ++n) {
                    var o = c[n];
                    if (g[o] != y[o])
                      continue e;
                  }
                  return P(a).call(r, y);
                }
              }
            return se;
          };
        }
        return i;
      };
    }, { "./es5": 52, "./util": 75 }], 47: [function(le, de, oe) {
      de.exports = function(se) {
        var Q = !1, u = [];
        se.prototype._promiseCreated = function() {
        }, se.prototype._pushContext = function() {
        }, se.prototype._popContext = function() {
          return null;
        }, se._peekContext = se.prototype._peekContext = function() {
        };
        function P() {
          this._trace = new P.CapturedTrace(i());
        }
        P.prototype._pushContext = function() {
          this._trace !== void 0 && (this._trace._promiseCreated = null, u.push(this._trace));
        }, P.prototype._popContext = function() {
          if (this._trace !== void 0) {
            var v = u.pop(), a = v._promiseCreated;
            return v._promiseCreated = null, a;
          }
          return null;
        };
        function t() {
          if (Q)
            return new P();
        }
        function i() {
          var v = u.length - 1;
          if (v >= 0)
            return u[v];
        }
        return P.CapturedTrace = null, P.create = t, P.deactivateLongStackTraces = function() {
        }, P.activateLongStackTraces = function() {
          var v = se.prototype._pushContext, a = se.prototype._popContext, e = se._peekContext, y = se.prototype._peekContext, r = se.prototype._promiseCreated;
          P.deactivateLongStackTraces = function() {
            se.prototype._pushContext = v, se.prototype._popContext = a, se._peekContext = e, se.prototype._peekContext = y, se.prototype._promiseCreated = r, Q = !1;
          }, Q = !0, se.prototype._pushContext = P.prototype._pushContext, se.prototype._popContext = P.prototype._popContext, se._peekContext = se.prototype._peekContext = i, se.prototype._promiseCreated = function() {
            var h = this._peekContext();
            h && h._promiseCreated == null && (h._promiseCreated = this);
          };
        }, P;
      };
    }, {}], 48: [function(le, de, oe) {
      (function(se) {
        de.exports = function(Q, u) {
          var P = Q._getDomain, t = Q._async, i = le("./errors").Warning, v = le("./util"), a = v.canAttachTrace, e, y, r = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/, h = /\((?:timers\.js):\d+:\d+\)/, g = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/, d = null, c = null, n = !1, o, x = !!(v.env("BLUEBIRD_DEBUG") != 0 && (v.env("BLUEBIRD_DEBUG") || v.env("NODE_ENV") === "development")), f = !!(v.env("BLUEBIRD_WARNINGS") != 0 && (x || v.env("BLUEBIRD_WARNINGS"))), m = !!(v.env("BLUEBIRD_LONG_STACK_TRACES") != 0 && (x || v.env("BLUEBIRD_LONG_STACK_TRACES"))), C = v.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (f || !!v.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
          Q.prototype.suppressUnhandledRejections = function() {
            var ue = this._target();
            ue._bitField = ue._bitField & -1048577 | 524288;
          }, Q.prototype._ensurePossibleRejectionHandled = function() {
            this._bitField & 524288 || (this._setRejectionIsUnhandled(), t.invokeLater(this._notifyUnhandledRejection, this, void 0));
          }, Q.prototype._notifyUnhandledRejectionIsHandled = function() {
            Z(
              "rejectionHandled",
              e,
              void 0,
              this
            );
          }, Q.prototype._setReturnedNonUndefined = function() {
            this._bitField = this._bitField | 268435456;
          }, Q.prototype._returnedNonUndefined = function() {
            return (this._bitField & 268435456) !== 0;
          }, Q.prototype._notifyUnhandledRejection = function() {
            if (this._isRejectionUnhandled()) {
              var ue = this._settledValue();
              this._setUnhandledRejectionIsNotified(), Z(
                "unhandledRejection",
                y,
                ue,
                this
              );
            }
          }, Q.prototype._setUnhandledRejectionIsNotified = function() {
            this._bitField = this._bitField | 262144;
          }, Q.prototype._unsetUnhandledRejectionIsNotified = function() {
            this._bitField = this._bitField & -262145;
          }, Q.prototype._isUnhandledRejectionNotified = function() {
            return (this._bitField & 262144) > 0;
          }, Q.prototype._setRejectionIsUnhandled = function() {
            this._bitField = this._bitField | 1048576;
          }, Q.prototype._unsetRejectionIsUnhandled = function() {
            this._bitField = this._bitField & -1048577, this._isUnhandledRejectionNotified() && (this._unsetUnhandledRejectionIsNotified(), this._notifyUnhandledRejectionIsHandled());
          }, Q.prototype._isRejectionUnhandled = function() {
            return (this._bitField & 1048576) > 0;
          }, Q.prototype._warn = function(ue, fe, me) {
            return z(ue, fe, me || this);
          }, Q.onPossiblyUnhandledRejection = function(ue) {
            var fe = P();
            y = typeof ue == "function" ? fe === null ? ue : v.domainBind(fe, ue) : void 0;
          }, Q.onUnhandledRejectionHandled = function(ue) {
            var fe = P();
            e = typeof ue == "function" ? fe === null ? ue : v.domainBind(fe, ue) : void 0;
          };
          var p = function() {
          };
          Q.longStackTraces = function() {
            if (t.haveItemsQueued() && !he.longStackTraces)
              throw new Error(`cannot enable long stack traces after promises have been created

    See http://goo.gl/MqrFmX
`);
            if (!he.longStackTraces && re()) {
              var ue = Q.prototype._captureStackTrace, fe = Q.prototype._attachExtraTrace;
              he.longStackTraces = !0, p = function() {
                if (t.haveItemsQueued() && !he.longStackTraces)
                  throw new Error(`cannot enable long stack traces after promises have been created

    See http://goo.gl/MqrFmX
`);
                Q.prototype._captureStackTrace = ue, Q.prototype._attachExtraTrace = fe, u.deactivateLongStackTraces(), t.enableTrampoline(), he.longStackTraces = !1;
              }, Q.prototype._captureStackTrace = U, Q.prototype._attachExtraTrace = G, u.activateLongStackTraces(), t.disableTrampolineIfNecessary();
            }
          }, Q.hasLongStackTraces = function() {
            return he.longStackTraces && re();
          };
          var w = function() {
            try {
              if (typeof CustomEvent == "function") {
                var ue = new CustomEvent("CustomEvent");
                return v.global.dispatchEvent(ue), function(fe, me) {
                  var Fe = new CustomEvent(fe.toLowerCase(), {
                    detail: me,
                    cancelable: !0
                  });
                  return !v.global.dispatchEvent(Fe);
                };
              } else if (typeof Event == "function") {
                var ue = new Event("CustomEvent");
                return v.global.dispatchEvent(ue), function(me, Fe) {
                  var we = new Event(me.toLowerCase(), {
                    cancelable: !0
                  });
                  return we.detail = Fe, !v.global.dispatchEvent(we);
                };
              } else {
                var ue = document.createEvent("CustomEvent");
                return ue.initCustomEvent("testingtheevent", !1, !0, {}), v.global.dispatchEvent(ue), function(me, Fe) {
                  var we = document.createEvent("CustomEvent");
                  return we.initCustomEvent(
                    me.toLowerCase(),
                    !1,
                    !0,
                    Fe
                  ), !v.global.dispatchEvent(we);
                };
              }
            } catch {
            }
            return function() {
              return !1;
            };
          }(), X = function() {
            return v.isNode ? function() {
              return se.emit.apply(se, arguments);
            } : v.global ? function(ue) {
              var fe = "on" + ue.toLowerCase(), me = v.global[fe];
              return me ? (me.apply(v.global, [].slice.call(arguments, 1)), !0) : !1;
            } : function() {
              return !1;
            };
          }();
          function M(ue, fe) {
            return { promise: fe };
          }
          var j = {
            promiseCreated: M,
            promiseFulfilled: M,
            promiseRejected: M,
            promiseResolved: M,
            promiseCancelled: M,
            promiseChained: function(ue, fe, me) {
              return { promise: fe, child: me };
            },
            warning: function(ue, fe) {
              return { warning: fe };
            },
            unhandledRejection: function(ue, fe, me) {
              return { reason: fe, promise: me };
            },
            rejectionHandled: M
          }, B = function(ue) {
            var fe = !1;
            try {
              fe = X.apply(null, arguments);
            } catch (Fe) {
              t.throwLater(Fe), fe = !0;
            }
            var me = !1;
            try {
              me = w(
                ue,
                j[ue].apply(null, arguments)
              );
            } catch (Fe) {
              t.throwLater(Fe), me = !0;
            }
            return me || fe;
          };
          Q.config = function(ue) {
            if (ue = Object(ue), "longStackTraces" in ue && (ue.longStackTraces ? Q.longStackTraces() : !ue.longStackTraces && Q.hasLongStackTraces() && p()), "warnings" in ue) {
              var fe = ue.warnings;
              he.warnings = !!fe, C = he.warnings, v.isObject(fe) && "wForgottenReturn" in fe && (C = !!fe.wForgottenReturn);
            }
            if ("cancellation" in ue && ue.cancellation && !he.cancellation) {
              if (t.haveItemsQueued())
                throw new Error(
                  "cannot enable cancellation after promises are in use"
                );
              Q.prototype._clearCancellationData = S, Q.prototype._propagateFrom = A, Q.prototype._onCancel = l, Q.prototype._setOnCancel = _, Q.prototype._attachCancellationCallback = b, Q.prototype._execute = D, T = A, he.cancellation = !0;
            }
            return "monitoring" in ue && (ue.monitoring && !he.monitoring ? (he.monitoring = !0, Q.prototype._fireEvent = B) : !ue.monitoring && he.monitoring && (he.monitoring = !1, Q.prototype._fireEvent = R)), Q;
          };
          function R() {
            return !1;
          }
          Q.prototype._fireEvent = R, Q.prototype._execute = function(ue, fe, me) {
            try {
              ue(fe, me);
            } catch (Fe) {
              return Fe;
            }
          }, Q.prototype._onCancel = function() {
          }, Q.prototype._setOnCancel = function(ue) {
          }, Q.prototype._attachCancellationCallback = function(ue) {
          }, Q.prototype._captureStackTrace = function() {
          }, Q.prototype._attachExtraTrace = function() {
          }, Q.prototype._clearCancellationData = function() {
          }, Q.prototype._propagateFrom = function(ue, fe) {
          };
          function D(ue, fe, me) {
            var Fe = this;
            try {
              ue(fe, me, function(we) {
                if (typeof we != "function")
                  throw new TypeError("onCancel must be a function, got: " + v.toString(we));
                Fe._attachCancellationCallback(we);
              });
            } catch (we) {
              return we;
            }
          }
          function b(ue) {
            if (!this._isCancellable())
              return this;
            var fe = this._onCancel();
            fe !== void 0 ? v.isArray(fe) ? fe.push(ue) : this._setOnCancel([fe, ue]) : this._setOnCancel(ue);
          }
          function l() {
            return this._onCancelField;
          }
          function _(ue) {
            this._onCancelField = ue;
          }
          function S() {
            this._cancellationParent = void 0, this._onCancelField = void 0;
          }
          function A(ue, fe) {
            if (fe & 1) {
              this._cancellationParent = ue;
              var me = ue._branchesRemainingToCancel;
              me === void 0 && (me = 0), ue._branchesRemainingToCancel = me + 1;
            }
            fe & 2 && ue._isBound() && this._setBoundTo(ue._boundTo);
          }
          function F(ue, fe) {
            fe & 2 && ue._isBound() && this._setBoundTo(ue._boundTo);
          }
          var T = F;
          function O() {
            var ue = this._boundTo;
            return ue !== void 0 && ue instanceof Q ? ue.isFulfilled() ? ue.value() : void 0 : ue;
          }
          function U() {
            this._trace = new ne(this._peekContext());
          }
          function G(ue, fe) {
            if (a(ue)) {
              var me = this._trace;
              if (me !== void 0 && fe && (me = me._parent), me !== void 0)
                me.attachExtraTrace(ue);
              else if (!ue.__stackCleaned__) {
                var Fe = q(ue);
                v.notEnumerableProp(
                  ue,
                  "stack",
                  Fe.message + `
` + Fe.stack.join(`
`)
                ), v.notEnumerableProp(ue, "__stackCleaned__", !0);
              }
            }
          }
          function K(ue, fe, me, Fe, we) {
            if (ue === void 0 && fe !== null && C) {
              if (we !== void 0 && we._returnedNonUndefined() || !(Fe._bitField & 65535))
                return;
              me && (me = me + " ");
              var Ae = "", De = "";
              if (fe._trace) {
                for (var xe = fe._trace.stack.split(`
`), Te = J(xe), ve = Te.length - 1; ve >= 0; --ve) {
                  var Se = Te[ve];
                  if (!h.test(Se)) {
                    var be = Se.match(g);
                    be && (Ae = "at " + be[1] + ":" + be[2] + ":" + be[3] + " ");
                    break;
                  }
                }
                if (Te.length > 0) {
                  for (var Le = Te[0], ve = 0; ve < xe.length; ++ve)
                    if (xe[ve] === Le) {
                      ve > 0 && (De = `
` + xe[ve - 1]);
                      break;
                    }
                }
              }
              var ze = "a promise was created in a " + me + "handler " + Ae + "but was not returned from it, see http://goo.gl/rRqMUw" + De;
              Fe._warn(ze, !0, fe);
            }
          }
          function W(ue, fe) {
            var me = ue + " is deprecated and will be removed in a future version.";
            return fe && (me += " Use " + fe + " instead."), z(me);
          }
          function z(ue, fe, me) {
            if (he.warnings) {
              var Fe = new i(ue), we;
              if (fe)
                me._attachExtraTrace(Fe);
              else if (he.longStackTraces && (we = Q._peekContext()))
                we.attachExtraTrace(Fe);
              else {
                var Ae = q(Fe);
                Fe.stack = Ae.message + `
` + Ae.stack.join(`
`);
              }
              B("warning", Fe) || N(Fe, "", !0);
            }
          }
          function V(ue, fe) {
            for (var me = 0; me < fe.length - 1; ++me)
              fe[me].push("From previous event:"), fe[me] = fe[me].join(`
`);
            return me < fe.length && (fe[me] = fe[me].join(`
`)), ue + `
` + fe.join(`
`);
          }
          function L(ue) {
            for (var fe = 0; fe < ue.length; ++fe)
              (ue[fe].length === 0 || fe + 1 < ue.length && ue[fe][0] === ue[fe + 1][0]) && (ue.splice(fe, 1), fe--);
          }
          function Y(ue) {
            for (var fe = ue[0], me = 1; me < ue.length; ++me) {
              for (var Fe = ue[me], we = fe.length - 1, Ae = fe[we], De = -1, xe = Fe.length - 1; xe >= 0; --xe)
                if (Fe[xe] === Ae) {
                  De = xe;
                  break;
                }
              for (var xe = De; xe >= 0; --xe) {
                var Te = Fe[xe];
                if (fe[we] === Te)
                  fe.pop(), we--;
                else
                  break;
              }
              fe = Fe;
            }
          }
          function J(ue) {
            for (var fe = [], me = 0; me < ue.length; ++me) {
              var Fe = ue[me], we = Fe === "    (No stack trace)" || d.test(Fe), Ae = we && ee(Fe);
              we && !Ae && (n && Fe.charAt(0) !== " " && (Fe = "    " + Fe), fe.push(Fe));
            }
            return fe;
          }
          function ie(ue) {
            for (var fe = ue.stack.replace(/\s+$/g, "").split(`
`), me = 0; me < fe.length; ++me) {
              var Fe = fe[me];
              if (Fe === "    (No stack trace)" || d.test(Fe))
                break;
            }
            return me > 0 && ue.name != "SyntaxError" && (fe = fe.slice(me)), fe;
          }
          function q(ue) {
            var fe = ue.stack, me = ue.toString();
            return fe = typeof fe == "string" && fe.length > 0 ? ie(ue) : ["    (No stack trace)"], {
              message: me,
              stack: ue.name == "SyntaxError" ? fe : J(fe)
            };
          }
          function N(ue, fe, me) {
            if (typeof console < "u") {
              var Fe;
              if (v.isObject(ue)) {
                var we = ue.stack;
                Fe = fe + c(we, ue);
              } else
                Fe = fe + String(ue);
              typeof o == "function" ? o(Fe, me) : (typeof console.log == "function" || typeof console.log == "object") && console.log(Fe);
            }
          }
          function Z(ue, fe, me, Fe) {
            var we = !1;
            try {
              typeof fe == "function" && (we = !0, ue === "rejectionHandled" ? fe(Fe) : fe(me, Fe));
            } catch (Ae) {
              t.throwLater(Ae);
            }
            ue === "unhandledRejection" ? !B(ue, me, Fe) && !we && N(me, "Unhandled rejection ") : B(ue, Fe);
          }
          function E(ue) {
            var fe;
            if (typeof ue == "function")
              fe = "[function " + (ue.name || "anonymous") + "]";
            else {
              fe = ue && typeof ue.toString == "function" ? ue.toString() : v.toString(ue);
              var me = /\[object [a-zA-Z0-9$_]+\]/;
              if (me.test(fe))
                try {
                  var Fe = JSON.stringify(ue);
                  fe = Fe;
                } catch {
                }
              fe.length === 0 && (fe = "(empty array)");
            }
            return "(<" + te(fe) + ">, no stack trace)";
          }
          function te(ue) {
            var fe = 41;
            return ue.length < fe ? ue : ue.substr(0, fe - 3) + "...";
          }
          function re() {
            return typeof ae == "function";
          }
          var ee = function() {
            return !1;
          }, $ = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
          function k(ue) {
            var fe = ue.match($);
            if (fe)
              return {
                fileName: fe[1],
                line: parseInt(fe[2], 10)
              };
          }
          function H(ue, fe) {
            if (re()) {
              for (var me = ue.stack.split(`
`), Fe = fe.stack.split(`
`), we = -1, Ae = -1, De, xe, Te = 0; Te < me.length; ++Te) {
                var ve = k(me[Te]);
                if (ve) {
                  De = ve.fileName, we = ve.line;
                  break;
                }
              }
              for (var Te = 0; Te < Fe.length; ++Te) {
                var ve = k(Fe[Te]);
                if (ve) {
                  xe = ve.fileName, Ae = ve.line;
                  break;
                }
              }
              we < 0 || Ae < 0 || !De || !xe || De !== xe || we >= Ae || (ee = function(Se) {
                if (r.test(Se))
                  return !0;
                var be = k(Se);
                return !!(be && be.fileName === De && we <= be.line && be.line <= Ae);
              });
            }
          }
          function ne(ue) {
            this._parent = ue, this._promisesCreated = 0;
            var fe = this._length = 1 + (ue === void 0 ? 0 : ue._length);
            ae(this, ne), fe > 32 && this.uncycle();
          }
          v.inherits(ne, Error), u.CapturedTrace = ne, ne.prototype.uncycle = function() {
            var ue = this._length;
            if (!(ue < 2)) {
              for (var fe = [], me = {}, Fe = 0, we = this; we !== void 0; ++Fe)
                fe.push(we), we = we._parent;
              ue = this._length = Fe;
              for (var Fe = ue - 1; Fe >= 0; --Fe) {
                var Ae = fe[Fe].stack;
                me[Ae] === void 0 && (me[Ae] = Fe);
              }
              for (var Fe = 0; Fe < ue; ++Fe) {
                var De = fe[Fe].stack, xe = me[De];
                if (xe !== void 0 && xe !== Fe) {
                  xe > 0 && (fe[xe - 1]._parent = void 0, fe[xe - 1]._length = 1), fe[Fe]._parent = void 0, fe[Fe]._length = 1;
                  var Te = Fe > 0 ? fe[Fe - 1] : this;
                  xe < ue - 1 ? (Te._parent = fe[xe + 1], Te._parent.uncycle(), Te._length = Te._parent._length + 1) : (Te._parent = void 0, Te._length = 1);
                  for (var ve = Te._length + 1, Se = Fe - 2; Se >= 0; --Se)
                    fe[Se]._length = ve, ve++;
                  return;
                }
              }
            }
          }, ne.prototype.attachExtraTrace = function(ue) {
            if (!ue.__stackCleaned__) {
              this.uncycle();
              for (var fe = q(ue), me = fe.message, Fe = [fe.stack], we = this; we !== void 0; )
                Fe.push(J(we.stack.split(`
`))), we = we._parent;
              Y(Fe), L(Fe), v.notEnumerableProp(ue, "stack", V(me, Fe)), v.notEnumerableProp(ue, "__stackCleaned__", !0);
            }
          };
          var ae = function() {
            var fe = /^\s*at\s*/, me = function(De, xe) {
              return typeof De == "string" ? De : xe.name !== void 0 && xe.message !== void 0 ? xe.toString() : E(xe);
            };
            if (typeof Error.stackTraceLimit == "number" && typeof Error.captureStackTrace == "function") {
              Error.stackTraceLimit += 6, d = fe, c = me;
              var Fe = Error.captureStackTrace;
              return ee = function(De) {
                return r.test(De);
              }, function(De, xe) {
                Error.stackTraceLimit += 6, Fe(De, xe), Error.stackTraceLimit -= 6;
              };
            }
            var we = new Error();
            if (typeof we.stack == "string" && we.stack.split(`
`)[0].indexOf("stackDetection@") >= 0)
              return d = /@/, c = me, n = !0, function(xe) {
                xe.stack = new Error().stack;
              };
            var Ae;
            try {
              throw new Error();
            } catch (De) {
              Ae = "stack" in De;
            }
            return !("stack" in we) && Ae && typeof Error.stackTraceLimit == "number" ? (d = fe, c = me, function(xe) {
              Error.stackTraceLimit += 6;
              try {
                throw new Error();
              } catch (Te) {
                xe.stack = Te.stack;
              }
              Error.stackTraceLimit -= 6;
            }) : (c = function(De, xe) {
              return typeof De == "string" ? De : (typeof xe == "object" || typeof xe == "function") && xe.name !== void 0 && xe.message !== void 0 ? xe.toString() : E(xe);
            }, null);
          }();
          typeof console < "u" && typeof console.warn < "u" && (o = function(ue) {
            console.warn(ue);
          }, v.isNode && se.stderr.isTTY ? o = function(ue, fe) {
            var me = fe ? "\x1B[33m" : "\x1B[31m";
            console.warn(me + ue + `\x1B[0m
`);
          } : !v.isNode && typeof new Error().stack == "string" && (o = function(ue, fe) {
            console.warn(
              "%c" + ue,
              fe ? "color: darkorange" : "color: red"
            );
          }));
          var he = {
            warnings: f,
            longStackTraces: !1,
            cancellation: !1,
            monitoring: !1
          };
          return m && Q.longStackTraces(), {
            longStackTraces: function() {
              return he.longStackTraces;
            },
            warnings: function() {
              return he.warnings;
            },
            cancellation: function() {
              return he.cancellation;
            },
            monitoring: function() {
              return he.monitoring;
            },
            propagateFromFunction: function() {
              return T;
            },
            boundValueFunction: function() {
              return O;
            },
            checkForgottenReturns: K,
            setBounds: H,
            warn: z,
            deprecated: W,
            CapturedTrace: ne,
            fireDomEvent: w,
            fireGlobalEvent: X
          };
        };
      }).call(this, le("_process"));
    }, { "./errors": 51, "./util": 75, _process: 102 }], 49: [function(le, de, oe) {
      de.exports = function(se) {
        function Q() {
          return this.value;
        }
        function u() {
          throw this.reason;
        }
        se.prototype.return = se.prototype.thenReturn = function(P) {
          return P instanceof se && P.suppressUnhandledRejections(), this._then(
            Q,
            void 0,
            void 0,
            { value: P },
            void 0
          );
        }, se.prototype.throw = se.prototype.thenThrow = function(P) {
          return this._then(
            u,
            void 0,
            void 0,
            { reason: P },
            void 0
          );
        }, se.prototype.catchThrow = function(P) {
          if (arguments.length <= 1)
            return this._then(
              void 0,
              u,
              void 0,
              { reason: P },
              void 0
            );
          var t = arguments[1], i = function() {
            throw t;
          };
          return this.caught(P, i);
        }, se.prototype.catchReturn = function(P) {
          if (arguments.length <= 1)
            return P instanceof se && P.suppressUnhandledRejections(), this._then(
              void 0,
              Q,
              void 0,
              { value: P },
              void 0
            );
          var t = arguments[1];
          t instanceof se && t.suppressUnhandledRejections();
          var i = function() {
            return t;
          };
          return this.caught(P, i);
        };
      };
    }, {}], 50: [function(le, de, oe) {
      de.exports = function(se, Q) {
        var u = se.reduce, P = se.all;
        function t() {
          return P(this);
        }
        function i(v, a) {
          return u(v, a, Q, Q);
        }
        se.prototype.each = function(v) {
          return u(this, v, Q, 0)._then(t, void 0, void 0, this, void 0);
        }, se.prototype.mapSeries = function(v) {
          return u(this, v, Q, Q);
        }, se.each = function(v, a) {
          return u(v, a, Q, 0)._then(t, void 0, void 0, v, void 0);
        }, se.mapSeries = i;
      };
    }, {}], 51: [function(le, de, oe) {
      var se = le("./es5"), Q = se.freeze, u = le("./util"), P = u.inherits, t = u.notEnumerableProp;
      function i(x, f) {
        function m(C) {
          if (!(this instanceof m))
            return new m(C);
          t(
            this,
            "message",
            typeof C == "string" ? C : f
          ), t(this, "name", x), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : Error.call(this);
        }
        return P(m, Error), m;
      }
      var v, a, e = i("Warning", "warning"), y = i("CancellationError", "cancellation error"), r = i("TimeoutError", "timeout error"), h = i("AggregateError", "aggregate error");
      try {
        v = TypeError, a = RangeError;
      } catch {
        v = i("TypeError", "type error"), a = i("RangeError", "range error");
      }
      for (var g = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" "), d = 0; d < g.length; ++d)
        typeof Array.prototype[g[d]] == "function" && (h.prototype[g[d]] = Array.prototype[g[d]]);
      se.defineProperty(h.prototype, "length", {
        value: 0,
        configurable: !1,
        writable: !0,
        enumerable: !0
      }), h.prototype.isOperational = !0;
      var c = 0;
      h.prototype.toString = function() {
        var x = Array(c * 4 + 1).join(" "), f = `
` + x + `AggregateError of:
`;
        c++, x = Array(c * 4 + 1).join(" ");
        for (var m = 0; m < this.length; ++m) {
          for (var C = this[m] === this ? "[Circular AggregateError]" : this[m] + "", p = C.split(`
`), w = 0; w < p.length; ++w)
            p[w] = x + p[w];
          C = p.join(`
`), f += C + `
`;
        }
        return c--, f;
      };
      function n(x) {
        if (!(this instanceof n))
          return new n(x);
        t(this, "name", "OperationalError"), t(this, "message", x), this.cause = x, this.isOperational = !0, x instanceof Error ? (t(this, "message", x.message), t(this, "stack", x.stack)) : Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
      }
      P(n, Error);
      var o = Error.__BluebirdErrorTypes__;
      o || (o = Q({
        CancellationError: y,
        TimeoutError: r,
        OperationalError: n,
        RejectionError: n,
        AggregateError: h
      }), se.defineProperty(Error, "__BluebirdErrorTypes__", {
        value: o,
        writable: !1,
        enumerable: !1,
        configurable: !1
      })), de.exports = {
        Error,
        TypeError: v,
        RangeError: a,
        CancellationError: o.CancellationError,
        OperationalError: o.OperationalError,
        TimeoutError: o.TimeoutError,
        AggregateError: o.AggregateError,
        Warning: e
      };
    }, { "./es5": 52, "./util": 75 }], 52: [function(le, de, oe) {
      var se = function() {
        return this === void 0;
      }();
      if (se)
        de.exports = {
          freeze: Object.freeze,
          defineProperty: Object.defineProperty,
          getDescriptor: Object.getOwnPropertyDescriptor,
          keys: Object.keys,
          names: Object.getOwnPropertyNames,
          getPrototypeOf: Object.getPrototypeOf,
          isArray: Array.isArray,
          isES5: se,
          propertyIsWritable: function(r, h) {
            var g = Object.getOwnPropertyDescriptor(r, h);
            return !!(!g || g.writable || g.set);
          }
        };
      else {
        var Q = {}.hasOwnProperty, u = {}.toString, P = {}.constructor.prototype, t = function(r) {
          var h = [];
          for (var g in r)
            Q.call(r, g) && h.push(g);
          return h;
        }, i = function(r, h) {
          return { value: r[h] };
        }, v = function(r, h, g) {
          return r[h] = g.value, r;
        }, a = function(r) {
          return r;
        }, e = function(r) {
          try {
            return Object(r).constructor.prototype;
          } catch {
            return P;
          }
        }, y = function(r) {
          try {
            return u.call(r) === "[object Array]";
          } catch {
            return !1;
          }
        };
        de.exports = {
          isArray: y,
          keys: t,
          names: t,
          defineProperty: v,
          getDescriptor: i,
          freeze: a,
          getPrototypeOf: e,
          isES5: se,
          propertyIsWritable: function() {
            return !0;
          }
        };
      }
    }, {}], 53: [function(le, de, oe) {
      de.exports = function(se, Q) {
        var u = se.map;
        se.prototype.filter = function(P, t) {
          return u(this, P, t, Q);
        }, se.filter = function(P, t, i) {
          return u(P, t, i, Q);
        };
      };
    }, {}], 54: [function(le, de, oe) {
      de.exports = function(se, Q) {
        var u = le("./util"), P = se.CancellationError, t = u.errorObj;
        function i(h, g, d) {
          this.promise = h, this.type = g, this.handler = d, this.called = !1, this.cancelPromise = null;
        }
        i.prototype.isFinallyHandler = function() {
          return this.type === 0;
        };
        function v(h) {
          this.finallyHandler = h;
        }
        v.prototype._resultCancelled = function() {
          a(this.finallyHandler);
        };
        function a(h, g) {
          return h.cancelPromise != null ? (arguments.length > 1 ? h.cancelPromise._reject(g) : h.cancelPromise._cancel(), h.cancelPromise = null, !0) : !1;
        }
        function e() {
          return r.call(this, this.promise._target()._settledValue());
        }
        function y(h) {
          if (!a(this, h))
            return t.e = h, t;
        }
        function r(h) {
          var g = this.promise, d = this.handler;
          if (!this.called) {
            this.called = !0;
            var c = this.isFinallyHandler() ? d.call(g._boundValue()) : d.call(g._boundValue(), h);
            if (c !== void 0) {
              g._setReturnedNonUndefined();
              var n = Q(c, g);
              if (n instanceof se) {
                if (this.cancelPromise != null)
                  if (n._isCancelled()) {
                    var o = new P("late cancellation observer");
                    return g._attachExtraTrace(o), t.e = o, t;
                  } else
                    n.isPending() && n._attachCancellationCallback(
                      new v(this)
                    );
                return n._then(
                  e,
                  y,
                  void 0,
                  this,
                  void 0
                );
              }
            }
          }
          return g.isRejected() ? (a(this), t.e = h, t) : (a(this), h);
        }
        return se.prototype._passThrough = function(h, g, d, c) {
          return typeof h != "function" ? this.then() : this._then(
            d,
            c,
            void 0,
            new i(this, g, h),
            void 0
          );
        }, se.prototype.lastly = se.prototype.finally = function(h) {
          return this._passThrough(
            h,
            0,
            r,
            r
          );
        }, se.prototype.tap = function(h) {
          return this._passThrough(h, 1, r);
        }, i;
      };
    }, { "./util": 75 }], 55: [function(le, de, oe) {
      de.exports = function(se, Q, u, P, t, i) {
        var v = le("./errors"), a = v.TypeError, e = le("./util"), y = e.errorObj, r = e.tryCatch, h = [];
        function g(c, n, o) {
          for (var x = 0; x < n.length; ++x) {
            o._pushContext();
            var f = r(n[x])(c);
            if (o._popContext(), f === y) {
              o._pushContext();
              var m = se.reject(y.e);
              return o._popContext(), m;
            }
            var C = P(f, o);
            if (C instanceof se)
              return C;
          }
          return null;
        }
        function d(c, n, o, x) {
          if (i.cancellation()) {
            var f = new se(u), m = this._finallyPromise = new se(u);
            this._promise = f.lastly(function() {
              return m;
            }), f._captureStackTrace(), f._setOnCancel(this);
          } else {
            var C = this._promise = new se(u);
            C._captureStackTrace();
          }
          this._stack = x, this._generatorFunction = c, this._receiver = n, this._generator = void 0, this._yieldHandlers = typeof o == "function" ? [o].concat(h) : h, this._yieldedPromise = null, this._cancellationPhase = !1;
        }
        e.inherits(d, t), d.prototype._isResolved = function() {
          return this._promise === null;
        }, d.prototype._cleanup = function() {
          this._promise = this._generator = null, i.cancellation() && this._finallyPromise !== null && (this._finallyPromise._fulfill(), this._finallyPromise = null);
        }, d.prototype._promiseCancelled = function() {
          if (!this._isResolved()) {
            var c = typeof this._generator.return < "u", n;
            if (c)
              this._promise._pushContext(), n = r(this._generator.return).call(
                this._generator,
                void 0
              ), this._promise._popContext();
            else {
              var o = new se.CancellationError(
                "generator .return() sentinel"
              );
              se.coroutine.returnSentinel = o, this._promise._attachExtraTrace(o), this._promise._pushContext(), n = r(this._generator.throw).call(
                this._generator,
                o
              ), this._promise._popContext();
            }
            this._cancellationPhase = !0, this._yieldedPromise = null, this._continue(n);
          }
        }, d.prototype._promiseFulfilled = function(c) {
          this._yieldedPromise = null, this._promise._pushContext();
          var n = r(this._generator.next).call(this._generator, c);
          this._promise._popContext(), this._continue(n);
        }, d.prototype._promiseRejected = function(c) {
          this._yieldedPromise = null, this._promise._attachExtraTrace(c), this._promise._pushContext();
          var n = r(this._generator.throw).call(this._generator, c);
          this._promise._popContext(), this._continue(n);
        }, d.prototype._resultCancelled = function() {
          if (this._yieldedPromise instanceof se) {
            var c = this._yieldedPromise;
            this._yieldedPromise = null, c.cancel();
          }
        }, d.prototype.promise = function() {
          return this._promise;
        }, d.prototype._run = function() {
          this._generator = this._generatorFunction.call(this._receiver), this._receiver = this._generatorFunction = void 0, this._promiseFulfilled(void 0);
        }, d.prototype._continue = function(c) {
          var n = this._promise;
          if (c === y)
            return this._cleanup(), this._cancellationPhase ? n.cancel() : n._rejectCallback(c.e, !1);
          var o = c.value;
          if (c.done === !0)
            return this._cleanup(), this._cancellationPhase ? n.cancel() : n._resolveCallback(o);
          var x = P(o, this._promise);
          if (!(x instanceof se) && (x = g(
            x,
            this._yieldHandlers,
            this._promise
          ), x === null)) {
            this._promiseRejected(
              new a(
                `A value %s was yielded that could not be treated as a promise

    See http://goo.gl/MqrFmX

`.replace("%s", o) + `From coroutine:
` + this._stack.split(`
`).slice(1, -7).join(`
`)
              )
            );
            return;
          }
          x = x._target();
          var f = x._bitField;
          f & 50397184 ? f & 33554432 ? se._async.invoke(
            this._promiseFulfilled,
            this,
            x._value()
          ) : f & 16777216 ? se._async.invoke(
            this._promiseRejected,
            this,
            x._reason()
          ) : this._promiseCancelled() : (this._yieldedPromise = x, x._proxy(this, null));
        }, se.coroutine = function(c, n) {
          if (typeof c != "function")
            throw new a(`generatorFunction must be a function

    See http://goo.gl/MqrFmX
`);
          var o = Object(n).yieldHandler, x = d, f = new Error().stack;
          return function() {
            var m = c.apply(this, arguments), C = new x(
              void 0,
              void 0,
              o,
              f
            ), p = C.promise();
            return C._generator = m, C._promiseFulfilled(void 0), p;
          };
        }, se.coroutine.addYieldHandler = function(c) {
          if (typeof c != "function")
            throw new a("expecting a function but got " + e.classString(c));
          h.push(c);
        }, se.spawn = function(c) {
          if (i.deprecated("Promise.spawn()", "Promise.coroutine()"), typeof c != "function")
            return Q(`generatorFunction must be a function

    See http://goo.gl/MqrFmX
`);
          var n = new d(c, this), o = n.promise();
          return n._run(se.spawn), o;
        };
      };
    }, { "./errors": 51, "./util": 75 }], 56: [function(le, de, oe) {
      de.exports = function(se, Q, u, P, t, i) {
        var v = le("./util"), a = v.canEvaluate, e = v.tryCatch, y = v.errorObj, r;
        if (a) {
          for (var h = function(f) {
            return new Function("value", "holder", `                             
	            'use strict';                                                    
	            holder.pIndex = value;                                           
	            holder.checkFulfillment(this);                                   
	            `.replace(/Index/g, f));
          }, g = function(f) {
            return new Function("promise", "holder", `                           
	            'use strict';                                                    
	            holder.pIndex = promise;                                         
	            `.replace(/Index/g, f));
          }, d = function(f) {
            for (var m = new Array(f), C = 0; C < m.length; ++C)
              m[C] = "this.p" + (C + 1);
            var p = m.join(" = ") + " = null;", w = `var promise;
` + m.map(function(B) {
              return `                                                         
	                promise = ` + B + `;                                      
	                if (promise instanceof Promise) {                            
	                    promise.cancel();                                        
	                }                                                            
	            `;
            }).join(`
`), X = m.join(", "), M = "Holder$" + f, j = `return function(tryCatch, errorObj, Promise, async) {    
	            'use strict';                                                    
	            function [TheName](fn) {                                         
	                [TheProperties]                                              
	                this.fn = fn;                                                
	                this.asyncNeeded = true;                                     
	                this.now = 0;                                                
	            }                                                                
	                                                                             
	            [TheName].prototype._callFunction = function(promise) {          
	                promise._pushContext();                                      
	                var ret = tryCatch(this.fn)([ThePassedArguments]);           
	                promise._popContext();                                       
	                if (ret === errorObj) {                                      
	                    promise._rejectCallback(ret.e, false);                   
	                } else {                                                     
	                    promise._resolveCallback(ret);                           
	                }                                                            
	            };                                                               
	                                                                             
	            [TheName].prototype.checkFulfillment = function(promise) {       
	                var now = ++this.now;                                        
	                if (now === [TheTotal]) {                                    
	                    if (this.asyncNeeded) {                                  
	                        async.invoke(this._callFunction, this, promise);     
	                    } else {                                                 
	                        this._callFunction(promise);                         
	                    }                                                        
	                                                                             
	                }                                                            
	            };                                                               
	                                                                             
	            [TheName].prototype._resultCancelled = function() {              
	                [CancellationCode]                                           
	            };                                                               
	                                                                             
	            return [TheName];                                                
	        }(tryCatch, errorObj, Promise, async);                               
	        `;
            return j = j.replace(/\[TheName\]/g, M).replace(/\[TheTotal\]/g, f).replace(/\[ThePassedArguments\]/g, X).replace(/\[TheProperties\]/g, p).replace(/\[CancellationCode\]/g, w), new Function("tryCatch", "errorObj", "Promise", "async", j)(e, y, se, t);
          }, c = [], n = [], o = [], x = 0; x < 8; ++x)
            c.push(d(x + 1)), n.push(h(x + 1)), o.push(g(x + 1));
          r = function(f) {
            this._reject(f);
          };
        }
        se.join = function() {
          var f = arguments.length - 1, m;
          if (f > 0 && typeof arguments[f] == "function" && (m = arguments[f], f <= 8 && a)) {
            var l = new se(P);
            l._captureStackTrace();
            for (var C = c[f - 1], p = new C(m), w = n, X = 0; X < f; ++X) {
              var M = u(arguments[X], l);
              if (M instanceof se) {
                M = M._target();
                var j = M._bitField;
                j & 50397184 ? j & 33554432 ? w[X].call(
                  l,
                  M._value(),
                  p
                ) : j & 16777216 ? l._reject(M._reason()) : l._cancel() : (M._then(
                  w[X],
                  r,
                  void 0,
                  l,
                  p
                ), o[X](M, p), p.asyncNeeded = !1);
              } else
                w[X].call(l, M, p);
            }
            if (!l._isFateSealed()) {
              if (p.asyncNeeded) {
                var B = i();
                B !== null && (p.fn = v.domainBind(B, p.fn));
              }
              l._setAsyncGuaranteed(), l._setOnCancel(p);
            }
            return l;
          }
          for (var R = arguments.length, D = new Array(R), b = 0; b < R; ++b)
            D[b] = arguments[b];
          m && D.pop();
          var l = new Q(D).promise();
          return m !== void 0 ? l.spread(m) : l;
        };
      };
    }, { "./util": 75 }], 57: [function(le, de, oe) {
      de.exports = function(se, Q, u, P, t, i) {
        var v = se._getDomain, a = le("./util"), e = a.tryCatch, y = a.errorObj, r = se._async;
        function h(d, c, n, o) {
          this.constructor$(d), this._promise._captureStackTrace();
          var x = v();
          this._callback = x === null ? c : a.domainBind(x, c), this._preservedValues = o === t ? new Array(this.length()) : null, this._limit = n, this._inFlight = 0, this._queue = [], r.invoke(this._asyncInit, this, void 0);
        }
        a.inherits(h, Q), h.prototype._asyncInit = function() {
          this._init$(void 0, -2);
        }, h.prototype._init = function() {
        }, h.prototype._promiseFulfilled = function(d, c) {
          var n = this._values, o = this.length(), x = this._preservedValues, f = this._limit;
          if (c < 0) {
            if (c = c * -1 - 1, n[c] = d, f >= 1 && (this._inFlight--, this._drainQueue(), this._isResolved()))
              return !0;
          } else {
            if (f >= 1 && this._inFlight >= f)
              return n[c] = d, this._queue.push(c), !1;
            x !== null && (x[c] = d);
            var m = this._promise, C = this._callback, p = m._boundValue();
            m._pushContext();
            var w = e(C).call(p, d, c, o), X = m._popContext();
            if (i.checkForgottenReturns(
              w,
              X,
              x !== null ? "Promise.filter" : "Promise.map",
              m
            ), w === y)
              return this._reject(w.e), !0;
            var M = P(w, this._promise);
            if (M instanceof se) {
              M = M._target();
              var j = M._bitField;
              if (j & 50397184)
                if (j & 33554432)
                  w = M._value();
                else
                  return j & 16777216 ? (this._reject(M._reason()), !0) : (this._cancel(), !0);
              else
                return f >= 1 && this._inFlight++, n[c] = M, M._proxy(this, (c + 1) * -1), !1;
            }
            n[c] = w;
          }
          var B = ++this._totalResolved;
          return B >= o ? (x !== null ? this._filter(n, x) : this._resolve(n), !0) : !1;
        }, h.prototype._drainQueue = function() {
          for (var d = this._queue, c = this._limit, n = this._values; d.length > 0 && this._inFlight < c; ) {
            if (this._isResolved())
              return;
            var o = d.pop();
            this._promiseFulfilled(n[o], o);
          }
        }, h.prototype._filter = function(d, c) {
          for (var n = c.length, o = new Array(n), x = 0, f = 0; f < n; ++f)
            d[f] && (o[x++] = c[f]);
          o.length = x, this._resolve(o);
        }, h.prototype.preservedValues = function() {
          return this._preservedValues;
        };
        function g(d, c, n, o) {
          if (typeof c != "function")
            return u("expecting a function but got " + a.classString(c));
          var x = 0;
          if (n !== void 0)
            if (typeof n == "object" && n !== null) {
              if (typeof n.concurrency != "number")
                return se.reject(
                  new TypeError("'concurrency' must be a number but it is " + a.classString(n.concurrency))
                );
              x = n.concurrency;
            } else
              return se.reject(new TypeError(
                "options argument must be an object but it is " + a.classString(n)
              ));
          return x = typeof x == "number" && isFinite(x) && x >= 1 ? x : 0, new h(d, c, x, o).promise();
        }
        se.prototype.map = function(d, c) {
          return g(this, d, c, null);
        }, se.map = function(d, c, n, o) {
          return g(d, c, n, o);
        };
      };
    }, { "./util": 75 }], 58: [function(le, de, oe) {
      de.exports = function(se, Q, u, P, t) {
        var i = le("./util"), v = i.tryCatch;
        se.method = function(a) {
          if (typeof a != "function")
            throw new se.TypeError("expecting a function but got " + i.classString(a));
          return function() {
            var e = new se(Q);
            e._captureStackTrace(), e._pushContext();
            var y = v(a).apply(this, arguments), r = e._popContext();
            return t.checkForgottenReturns(
              y,
              r,
              "Promise.method",
              e
            ), e._resolveFromSyncValue(y), e;
          };
        }, se.attempt = se.try = function(a) {
          if (typeof a != "function")
            return P("expecting a function but got " + i.classString(a));
          var e = new se(Q);
          e._captureStackTrace(), e._pushContext();
          var y;
          if (arguments.length > 1) {
            t.deprecated("calling Promise.try with more than 1 argument");
            var r = arguments[1], h = arguments[2];
            y = i.isArray(r) ? v(a).apply(h, r) : v(a).call(h, r);
          } else
            y = v(a)();
          var g = e._popContext();
          return t.checkForgottenReturns(
            y,
            g,
            "Promise.try",
            e
          ), e._resolveFromSyncValue(y), e;
        }, se.prototype._resolveFromSyncValue = function(a) {
          a === i.errorObj ? this._rejectCallback(a.e, !1) : this._resolveCallback(a, !0);
        };
      };
    }, { "./util": 75 }], 59: [function(le, de, oe) {
      var se = le("./util"), Q = se.maybeWrapAsError, u = le("./errors"), P = u.OperationalError, t = le("./es5");
      function i(y) {
        return y instanceof Error && t.getPrototypeOf(y) === Error.prototype;
      }
      var v = /^(?:name|message|stack|cause)$/;
      function a(y) {
        var r;
        if (i(y)) {
          r = new P(y), r.name = y.name, r.message = y.message, r.stack = y.stack;
          for (var h = t.keys(y), g = 0; g < h.length; ++g) {
            var d = h[g];
            v.test(d) || (r[d] = y[d]);
          }
          return r;
        }
        return se.markAsOriginatingFromRejection(y), y;
      }
      function e(y, r) {
        return function(h, g) {
          if (y !== null) {
            if (h) {
              var d = a(Q(h));
              y._attachExtraTrace(d), y._reject(d);
            } else if (!r)
              y._fulfill(g);
            else {
              for (var c = arguments.length, n = new Array(Math.max(c - 1, 0)), o = 1; o < c; ++o)
                n[o - 1] = arguments[o];
              y._fulfill(n);
            }
            y = null;
          }
        };
      }
      de.exports = e;
    }, { "./errors": 51, "./es5": 52, "./util": 75 }], 60: [function(le, de, oe) {
      de.exports = function(se) {
        var Q = le("./util"), u = se._async, P = Q.tryCatch, t = Q.errorObj;
        function i(e, y) {
          var r = this;
          if (!Q.isArray(e))
            return v.call(r, e, y);
          var h = P(y).apply(r._boundValue(), [null].concat(e));
          h === t && u.throwLater(h.e);
        }
        function v(e, y) {
          var r = this, h = r._boundValue(), g = e === void 0 ? P(y).call(h, null) : P(y).call(h, null, e);
          g === t && u.throwLater(g.e);
        }
        function a(e, y) {
          var r = this;
          if (!e) {
            var h = new Error(e + "");
            h.cause = e, e = h;
          }
          var g = P(y).call(r._boundValue(), e);
          g === t && u.throwLater(g.e);
        }
        se.prototype.asCallback = se.prototype.nodeify = function(e, y) {
          if (typeof e == "function") {
            var r = v;
            y !== void 0 && Object(y).spread && (r = i), this._then(
              r,
              a,
              void 0,
              this,
              e
            );
          }
          return this;
        };
      };
    }, { "./util": 75 }], 61: [function(le, de, oe) {
      (function(se) {
        de.exports = function() {
          var Q = function() {
            return new g(`circular promise resolution chain

    See http://goo.gl/MqrFmX
`);
          }, u = function() {
            return new D.PromiseInspection(this._target());
          }, P = function(S) {
            return D.reject(new g(S));
          };
          function t() {
          }
          var i = {}, v = le("./util"), a;
          v.isNode ? a = function() {
            var S = se.domain;
            return S === void 0 && (S = null), S;
          } : a = function() {
            return null;
          }, v.notEnumerableProp(D, "_getDomain", a);
          var e = le("./es5"), y = le("./async"), r = new y();
          e.defineProperty(D, "_async", { value: r });
          var h = le("./errors"), g = D.TypeError = h.TypeError;
          D.RangeError = h.RangeError;
          var d = D.CancellationError = h.CancellationError;
          D.TimeoutError = h.TimeoutError, D.OperationalError = h.OperationalError, D.RejectionError = h.OperationalError, D.AggregateError = h.AggregateError;
          var c = function() {
          }, n = {}, o = {}, x = le("./thenables")(D, c), f = le("./promise_array")(
            D,
            c,
            x,
            P,
            t
          ), m = le("./context")(D), C = m.create, p = le("./debuggability")(D, m);
          p.CapturedTrace;
          var w = le("./finally")(D, x), X = le("./catch_filter")(o), M = le("./nodeback"), j = v.errorObj, B = v.tryCatch;
          function R(S, A) {
            if (typeof A != "function")
              throw new g("expecting a function but got " + v.classString(A));
            if (S.constructor !== D)
              throw new g(`the promise constructor cannot be invoked directly

    See http://goo.gl/MqrFmX
`);
          }
          function D(S) {
            this._bitField = 0, this._fulfillmentHandler0 = void 0, this._rejectionHandler0 = void 0, this._promise0 = void 0, this._receiver0 = void 0, S !== c && (R(this, S), this._resolveFromExecutor(S)), this._promiseCreated(), this._fireEvent("promiseCreated", this);
          }
          D.prototype.toString = function() {
            return "[object Promise]";
          }, D.prototype.caught = D.prototype.catch = function(S) {
            var A = arguments.length;
            if (A > 1) {
              var F = new Array(A - 1), T = 0, O;
              for (O = 0; O < A - 1; ++O) {
                var U = arguments[O];
                if (v.isObject(U))
                  F[T++] = U;
                else
                  return P("expecting an object but got A catch statement predicate " + v.classString(U));
              }
              return F.length = T, S = arguments[O], this.then(void 0, X(F, S, this));
            }
            return this.then(void 0, S);
          }, D.prototype.reflect = function() {
            return this._then(
              u,
              u,
              void 0,
              this,
              void 0
            );
          }, D.prototype.then = function(S, A) {
            if (p.warnings() && arguments.length > 0 && typeof S != "function" && typeof A != "function") {
              var F = ".then() only accepts functions but was passed: " + v.classString(S);
              arguments.length > 1 && (F += ", " + v.classString(A)), this._warn(F);
            }
            return this._then(S, A, void 0, void 0, void 0);
          }, D.prototype.done = function(S, A) {
            var F = this._then(S, A, void 0, void 0, void 0);
            F._setIsFinal();
          }, D.prototype.spread = function(S) {
            return typeof S != "function" ? P("expecting a function but got " + v.classString(S)) : this.all()._then(S, void 0, void 0, n, void 0);
          }, D.prototype.toJSON = function() {
            var S = {
              isFulfilled: !1,
              isRejected: !1,
              fulfillmentValue: void 0,
              rejectionReason: void 0
            };
            return this.isFulfilled() ? (S.fulfillmentValue = this.value(), S.isFulfilled = !0) : this.isRejected() && (S.rejectionReason = this.reason(), S.isRejected = !0), S;
          }, D.prototype.all = function() {
            return arguments.length > 0 && this._warn(".all() was passed arguments but it does not take any"), new f(this).promise();
          }, D.prototype.error = function(S) {
            return this.caught(v.originatesFromRejection, S);
          }, D.getNewLibraryCopy = de.exports, D.is = function(S) {
            return S instanceof D;
          }, D.fromNode = D.fromCallback = function(S) {
            var A = new D(c);
            A._captureStackTrace();
            var F = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : !1, T = B(S)(M(A, F));
            return T === j && A._rejectCallback(T.e, !0), A._isFateSealed() || A._setAsyncGuaranteed(), A;
          }, D.all = function(S) {
            return new f(S).promise();
          }, D.cast = function(S) {
            var A = x(S);
            return A instanceof D || (A = new D(c), A._captureStackTrace(), A._setFulfilled(), A._rejectionHandler0 = S), A;
          }, D.resolve = D.fulfilled = D.cast, D.reject = D.rejected = function(S) {
            var A = new D(c);
            return A._captureStackTrace(), A._rejectCallback(S, !0), A;
          }, D.setScheduler = function(S) {
            if (typeof S != "function")
              throw new g("expecting a function but got " + v.classString(S));
            return r.setScheduler(S);
          }, D.prototype._then = function(S, A, F, T, O) {
            var U = O !== void 0, G = U ? O : new D(c), K = this._target(), W = K._bitField;
            U || (G._propagateFrom(this, 3), G._captureStackTrace(), T === void 0 && this._bitField & 2097152 && (W & 50397184 ? T = this._boundValue() : T = K === this ? void 0 : this._boundTo), this._fireEvent("promiseChained", this, G));
            var z = a();
            if (W & 50397184) {
              var V, L, Y = K._settlePromiseCtx;
              W & 33554432 ? (L = K._rejectionHandler0, V = S) : W & 16777216 ? (L = K._fulfillmentHandler0, V = A, K._unsetRejectionIsUnhandled()) : (Y = K._settlePromiseLateCancellationObserver, L = new d("late cancellation observer"), K._attachExtraTrace(L), V = A), r.invoke(Y, K, {
                handler: z === null ? V : typeof V == "function" && v.domainBind(z, V),
                promise: G,
                receiver: T,
                value: L
              });
            } else
              K._addCallbacks(S, A, G, T, z);
            return G;
          }, D.prototype._length = function() {
            return this._bitField & 65535;
          }, D.prototype._isFateSealed = function() {
            return (this._bitField & 117506048) !== 0;
          }, D.prototype._isFollowing = function() {
            return (this._bitField & 67108864) === 67108864;
          }, D.prototype._setLength = function(S) {
            this._bitField = this._bitField & -65536 | S & 65535;
          }, D.prototype._setFulfilled = function() {
            this._bitField = this._bitField | 33554432, this._fireEvent("promiseFulfilled", this);
          }, D.prototype._setRejected = function() {
            this._bitField = this._bitField | 16777216, this._fireEvent("promiseRejected", this);
          }, D.prototype._setFollowing = function() {
            this._bitField = this._bitField | 67108864, this._fireEvent("promiseResolved", this);
          }, D.prototype._setIsFinal = function() {
            this._bitField = this._bitField | 4194304;
          }, D.prototype._isFinal = function() {
            return (this._bitField & 4194304) > 0;
          }, D.prototype._unsetCancelled = function() {
            this._bitField = this._bitField & -65537;
          }, D.prototype._setCancelled = function() {
            this._bitField = this._bitField | 65536, this._fireEvent("promiseCancelled", this);
          }, D.prototype._setWillBeCancelled = function() {
            this._bitField = this._bitField | 8388608;
          }, D.prototype._setAsyncGuaranteed = function() {
            r.hasCustomScheduler() || (this._bitField = this._bitField | 134217728);
          }, D.prototype._receiverAt = function(S) {
            var A = S === 0 ? this._receiver0 : this[S * 4 - 4 + 3];
            if (A !== i)
              return A === void 0 && this._isBound() ? this._boundValue() : A;
          }, D.prototype._promiseAt = function(S) {
            return this[S * 4 - 4 + 2];
          }, D.prototype._fulfillmentHandlerAt = function(S) {
            return this[S * 4 - 4 + 0];
          }, D.prototype._rejectionHandlerAt = function(S) {
            return this[S * 4 - 4 + 1];
          }, D.prototype._boundValue = function() {
          }, D.prototype._migrateCallback0 = function(S) {
            S._bitField;
            var A = S._fulfillmentHandler0, F = S._rejectionHandler0, T = S._promise0, O = S._receiverAt(0);
            O === void 0 && (O = i), this._addCallbacks(A, F, T, O, null);
          }, D.prototype._migrateCallbackAt = function(S, A) {
            var F = S._fulfillmentHandlerAt(A), T = S._rejectionHandlerAt(A), O = S._promiseAt(A), U = S._receiverAt(A);
            U === void 0 && (U = i), this._addCallbacks(F, T, O, U, null);
          }, D.prototype._addCallbacks = function(S, A, F, T, O) {
            var U = this._length();
            if (U >= 65535 - 4 && (U = 0, this._setLength(0)), U === 0)
              this._promise0 = F, this._receiver0 = T, typeof S == "function" && (this._fulfillmentHandler0 = O === null ? S : v.domainBind(O, S)), typeof A == "function" && (this._rejectionHandler0 = O === null ? A : v.domainBind(O, A));
            else {
              var G = U * 4 - 4;
              this[G + 2] = F, this[G + 3] = T, typeof S == "function" && (this[G + 0] = O === null ? S : v.domainBind(O, S)), typeof A == "function" && (this[G + 1] = O === null ? A : v.domainBind(O, A));
            }
            return this._setLength(U + 1), U;
          }, D.prototype._proxy = function(S, A) {
            this._addCallbacks(void 0, void 0, A, S, null);
          }, D.prototype._resolveCallback = function(S, A) {
            if (!(this._bitField & 117506048)) {
              if (S === this)
                return this._rejectCallback(Q(), !1);
              var F = x(S, this);
              if (!(F instanceof D))
                return this._fulfill(S);
              A && this._propagateFrom(F, 2);
              var T = F._target();
              if (T === this) {
                this._reject(Q());
                return;
              }
              var O = T._bitField;
              if (O & 50397184)
                if (O & 33554432)
                  this._fulfill(T._value());
                else if (O & 16777216)
                  this._reject(T._reason());
                else {
                  var K = new d("late cancellation observer");
                  T._attachExtraTrace(K), this._reject(K);
                }
              else {
                var U = this._length();
                U > 0 && T._migrateCallback0(this);
                for (var G = 1; G < U; ++G)
                  T._migrateCallbackAt(this, G);
                this._setFollowing(), this._setLength(0), this._setFollowee(T);
              }
            }
          }, D.prototype._rejectCallback = function(S, A, F) {
            var T = v.ensureErrorObject(S), O = T === S;
            if (!O && !F && p.warnings()) {
              var U = "a promise was rejected with a non-error: " + v.classString(S);
              this._warn(U, !0);
            }
            this._attachExtraTrace(T, A ? O : !1), this._reject(S);
          }, D.prototype._resolveFromExecutor = function(S) {
            var A = this;
            this._captureStackTrace(), this._pushContext();
            var F = !0, T = this._execute(S, function(O) {
              A._resolveCallback(O);
            }, function(O) {
              A._rejectCallback(O, F);
            });
            F = !1, this._popContext(), T !== void 0 && A._rejectCallback(T, !0);
          }, D.prototype._settlePromiseFromHandler = function(S, A, F, T) {
            var O = T._bitField;
            if (!(O & 65536)) {
              T._pushContext();
              var U;
              A === n ? !F || typeof F.length != "number" ? (U = j, U.e = new g("cannot .spread() a non-array: " + v.classString(F))) : U = B(S).apply(this._boundValue(), F) : U = B(S).call(A, F);
              var G = T._popContext();
              O = T._bitField, !(O & 65536) && (U === o ? T._reject(F) : U === j ? T._rejectCallback(U.e, !1) : (p.checkForgottenReturns(U, G, "", T, this), T._resolveCallback(U)));
            }
          }, D.prototype._target = function() {
            for (var S = this; S._isFollowing(); )
              S = S._followee();
            return S;
          }, D.prototype._followee = function() {
            return this._rejectionHandler0;
          }, D.prototype._setFollowee = function(S) {
            this._rejectionHandler0 = S;
          }, D.prototype._settlePromise = function(S, A, F, T) {
            var O = S instanceof D, U = this._bitField, G = (U & 134217728) !== 0;
            U & 65536 ? (O && S._invokeInternalOnCancel(), F instanceof w && F.isFinallyHandler() ? (F.cancelPromise = S, B(A).call(F, T) === j && S._reject(j.e)) : A === u ? S._fulfill(u.call(F)) : F instanceof t ? F._promiseCancelled(S) : O || S instanceof f ? S._cancel() : F.cancel()) : typeof A == "function" ? O ? (G && S._setAsyncGuaranteed(), this._settlePromiseFromHandler(A, F, T, S)) : A.call(F, T, S) : F instanceof t ? F._isResolved() || (U & 33554432 ? F._promiseFulfilled(T, S) : F._promiseRejected(T, S)) : O && (G && S._setAsyncGuaranteed(), U & 33554432 ? S._fulfill(T) : S._reject(T));
          }, D.prototype._settlePromiseLateCancellationObserver = function(S) {
            var A = S.handler, F = S.promise, T = S.receiver, O = S.value;
            typeof A == "function" ? F instanceof D ? this._settlePromiseFromHandler(A, T, O, F) : A.call(T, O, F) : F instanceof D && F._reject(O);
          }, D.prototype._settlePromiseCtx = function(S) {
            this._settlePromise(S.promise, S.handler, S.receiver, S.value);
          }, D.prototype._settlePromise0 = function(S, A, F) {
            var T = this._promise0, O = this._receiverAt(0);
            this._promise0 = void 0, this._receiver0 = void 0, this._settlePromise(T, S, O, A);
          }, D.prototype._clearCallbackDataAtIndex = function(S) {
            var A = S * 4 - 4;
            this[A + 2] = this[A + 3] = this[A + 0] = this[A + 1] = void 0;
          }, D.prototype._fulfill = function(S) {
            var A = this._bitField;
            if (!((A & 117506048) >>> 16)) {
              if (S === this) {
                var F = Q();
                return this._attachExtraTrace(F), this._reject(F);
              }
              this._setFulfilled(), this._rejectionHandler0 = S, (A & 65535) > 0 && (A & 134217728 ? this._settlePromises() : r.settlePromises(this));
            }
          }, D.prototype._reject = function(S) {
            var A = this._bitField;
            if (!((A & 117506048) >>> 16)) {
              if (this._setRejected(), this._fulfillmentHandler0 = S, this._isFinal())
                return r.fatalError(S, v.isNode);
              (A & 65535) > 0 ? r.settlePromises(this) : this._ensurePossibleRejectionHandled();
            }
          }, D.prototype._fulfillPromises = function(S, A) {
            for (var F = 1; F < S; F++) {
              var T = this._fulfillmentHandlerAt(F), O = this._promiseAt(F), U = this._receiverAt(F);
              this._clearCallbackDataAtIndex(F), this._settlePromise(O, T, U, A);
            }
          }, D.prototype._rejectPromises = function(S, A) {
            for (var F = 1; F < S; F++) {
              var T = this._rejectionHandlerAt(F), O = this._promiseAt(F), U = this._receiverAt(F);
              this._clearCallbackDataAtIndex(F), this._settlePromise(O, T, U, A);
            }
          }, D.prototype._settlePromises = function() {
            var S = this._bitField, A = S & 65535;
            if (A > 0) {
              if (S & 16842752) {
                var F = this._fulfillmentHandler0;
                this._settlePromise0(this._rejectionHandler0, F, S), this._rejectPromises(A, F);
              } else {
                var T = this._rejectionHandler0;
                this._settlePromise0(this._fulfillmentHandler0, T, S), this._fulfillPromises(A, T);
              }
              this._setLength(0);
            }
            this._clearCancellationData();
          }, D.prototype._settledValue = function() {
            var S = this._bitField;
            if (S & 33554432)
              return this._rejectionHandler0;
            if (S & 16777216)
              return this._fulfillmentHandler0;
          };
          function b(S) {
            this.promise._resolveCallback(S);
          }
          function l(S) {
            this.promise._rejectCallback(S, !1);
          }
          D.defer = D.pending = function() {
            p.deprecated("Promise.defer", "new Promise");
            var S = new D(c);
            return {
              promise: S,
              resolve: b,
              reject: l
            };
          }, v.notEnumerableProp(
            D,
            "_makeSelfResolutionError",
            Q
          ), le("./method")(
            D,
            c,
            x,
            P,
            p
          ), le("./bind")(D, c, x, p), le("./cancel")(D, f, P, p), le("./direct_resolve")(D), le("./synchronous_inspection")(D), le("./join")(
            D,
            f,
            x,
            c,
            r,
            a
          ), D.Promise = D, D.version = "3.4.7", le("./map.js")(D, f, P, x, c, p), le("./call_get.js")(D), le("./using.js")(D, P, x, C, c, p), le("./timers.js")(D, c, p), le("./generators.js")(D, P, c, x, t, p), le("./nodeify.js")(D), le("./promisify.js")(D, c), le("./props.js")(D, f, x, P), le("./race.js")(D, c, x, P), le("./reduce.js")(D, f, P, x, c, p), le("./settle.js")(D, f, p), le("./some.js")(D, f, P), le("./filter.js")(D, c), le("./each.js")(D, c), le("./any.js")(D), v.toFastProperties(D), v.toFastProperties(D.prototype);
          function _(S) {
            var A = new D(c);
            A._fulfillmentHandler0 = S, A._rejectionHandler0 = S, A._promise0 = S, A._receiver0 = S;
          }
          return _({ a: 1 }), _({ b: 2 }), _({ c: 3 }), _(1), _(function() {
          }), _(void 0), _(!1), _(new D(c)), p.setBounds(y.firstLineError, v.lastLineError), D;
        };
      }).call(this, le("_process"));
    }, { "./any.js": 41, "./async": 42, "./bind": 43, "./call_get.js": 44, "./cancel": 45, "./catch_filter": 46, "./context": 47, "./debuggability": 48, "./direct_resolve": 49, "./each.js": 50, "./errors": 51, "./es5": 52, "./filter.js": 53, "./finally": 54, "./generators.js": 55, "./join": 56, "./map.js": 57, "./method": 58, "./nodeback": 59, "./nodeify.js": 60, "./promise_array": 62, "./promisify.js": 63, "./props.js": 64, "./race.js": 66, "./reduce.js": 67, "./settle.js": 69, "./some.js": 70, "./synchronous_inspection": 71, "./thenables": 72, "./timers.js": 73, "./using.js": 74, "./util": 75, _process: 102 }], 62: [function(le, de, oe) {
      de.exports = function(se, Q, u, P, t) {
        var i = le("./util");
        i.isArray;
        function v(e) {
          switch (e) {
            case -2:
              return [];
            case -3:
              return {};
          }
        }
        function a(e) {
          var y = this._promise = new se(Q);
          e instanceof se && y._propagateFrom(e, 3), y._setOnCancel(this), this._values = e, this._length = 0, this._totalResolved = 0, this._init(void 0, -2);
        }
        return i.inherits(a, t), a.prototype.length = function() {
          return this._length;
        }, a.prototype.promise = function() {
          return this._promise;
        }, a.prototype._init = function e(y, r) {
          var h = u(this._values, this._promise);
          if (h instanceof se) {
            h = h._target();
            var g = h._bitField;
            if (this._values = h, g & 50397184)
              if (g & 33554432)
                h = h._value();
              else
                return g & 16777216 ? this._reject(h._reason()) : this._cancel();
            else
              return this._promise._setAsyncGuaranteed(), h._then(
                e,
                this._reject,
                void 0,
                this,
                r
              );
          }
          if (h = i.asArray(h), h === null) {
            var d = P(
              "expecting an array or an iterable object but got " + i.classString(h)
            ).reason();
            this._promise._rejectCallback(d, !1);
            return;
          }
          if (h.length === 0) {
            r === -5 ? this._resolveEmptyArray() : this._resolve(v(r));
            return;
          }
          this._iterate(h);
        }, a.prototype._iterate = function(e) {
          var y = this.getActualLength(e.length);
          this._length = y, this._values = this.shouldCopyValues() ? new Array(y) : this._values;
          for (var r = this._promise, h = !1, g = null, d = 0; d < y; ++d) {
            var c = u(e[d], r);
            c instanceof se ? (c = c._target(), g = c._bitField) : g = null, h ? g !== null && c.suppressUnhandledRejections() : g !== null ? g & 50397184 ? g & 33554432 ? h = this._promiseFulfilled(c._value(), d) : g & 16777216 ? h = this._promiseRejected(c._reason(), d) : h = this._promiseCancelled(d) : (c._proxy(this, d), this._values[d] = c) : h = this._promiseFulfilled(c, d);
          }
          h || r._setAsyncGuaranteed();
        }, a.prototype._isResolved = function() {
          return this._values === null;
        }, a.prototype._resolve = function(e) {
          this._values = null, this._promise._fulfill(e);
        }, a.prototype._cancel = function() {
          this._isResolved() || !this._promise._isCancellable() || (this._values = null, this._promise._cancel());
        }, a.prototype._reject = function(e) {
          this._values = null, this._promise._rejectCallback(e, !1);
        }, a.prototype._promiseFulfilled = function(e, y) {
          this._values[y] = e;
          var r = ++this._totalResolved;
          return r >= this._length ? (this._resolve(this._values), !0) : !1;
        }, a.prototype._promiseCancelled = function() {
          return this._cancel(), !0;
        }, a.prototype._promiseRejected = function(e) {
          return this._totalResolved++, this._reject(e), !0;
        }, a.prototype._resultCancelled = function() {
          if (!this._isResolved()) {
            var e = this._values;
            if (this._cancel(), e instanceof se)
              e.cancel();
            else
              for (var y = 0; y < e.length; ++y)
                e[y] instanceof se && e[y].cancel();
          }
        }, a.prototype.shouldCopyValues = function() {
          return !0;
        }, a.prototype.getActualLength = function(e) {
          return e;
        }, a;
      };
    }, { "./util": 75 }], 63: [function(le, de, oe) {
      de.exports = function(se, Q) {
        var u = {}, P = le("./util"), t = le("./nodeback"), i = P.withAppended, v = P.maybeWrapAsError, a = P.canEvaluate, e = le("./errors").TypeError, y = "Async", r = { __isPromisified__: !0 }, h = [
          "arity",
          "length",
          "name",
          "arguments",
          "caller",
          "callee",
          "prototype",
          "__isPromisified__"
        ], g = new RegExp("^(?:" + h.join("|") + ")$"), d = function(b) {
          return P.isIdentifier(b) && b.charAt(0) !== "_" && b !== "constructor";
        };
        function c(b) {
          return !g.test(b);
        }
        function n(b) {
          try {
            return b.__isPromisified__ === !0;
          } catch {
            return !1;
          }
        }
        function o(b, l, _) {
          var S = P.getDataPropertyOrDefault(
            b,
            l + _,
            r
          );
          return S ? n(S) : !1;
        }
        function x(b, l, _) {
          for (var S = 0; S < b.length; S += 2) {
            var A = b[S];
            if (_.test(A)) {
              for (var F = A.replace(_, ""), T = 0; T < b.length; T += 2)
                if (b[T] === F)
                  throw new e(`Cannot promisify an API that has normal methods with '%s'-suffix

    See http://goo.gl/MqrFmX
`.replace("%s", l));
            }
          }
        }
        function f(b, l, _, S) {
          for (var A = P.inheritedDataKeys(b), F = [], T = 0; T < A.length; ++T) {
            var O = A[T], U = b[O], G = S === d ? !0 : d(O);
            typeof U == "function" && !n(U) && !o(b, O, l) && S(O, U, b, G) && F.push(O, U);
          }
          return x(F, l, _), F;
        }
        var m = function(b) {
          return b.replace(/([$])/, "\\$");
        }, C;
        {
          var p = function(b) {
            for (var l = [b], _ = Math.max(0, b - 1 - 3), S = b - 1; S >= _; --S)
              l.push(S);
            for (var S = b + 1; S <= 3; ++S)
              l.push(S);
            return l;
          }, w = function(b) {
            return P.filledRange(b, "_arg", "");
          }, X = function(b) {
            return P.filledRange(
              Math.max(b, 3),
              "_arg",
              ""
            );
          }, M = function(b) {
            return typeof b.length == "number" ? Math.max(Math.min(b.length, 1024), 0) : 0;
          };
          C = function(b, l, _, S, A, F) {
            var T = Math.max(0, M(S) - 1), O = p(T), U = typeof b == "string" || l === u;
            function G(V) {
              var L = w(V).join(", "), Y = V > 0 ? ", " : "", J;
              return U ? J = `ret = callback.call(this, {{args}}, nodeback); break;
` : J = l === void 0 ? `ret = callback({{args}}, nodeback); break;
` : `ret = callback.call(receiver, {{args}}, nodeback); break;
`, J.replace("{{args}}", L).replace(", ", Y);
            }
            function K() {
              for (var V = "", L = 0; L < O.length; ++L)
                V += "case " + O[L] + ":" + G(O[L]);
              return V += `                                                             
	        default:                                                             
	            var args = new Array(len + 1);                                   
	            var i = 0;                                                       
	            for (var i = 0; i < len; ++i) {                                  
	               args[i] = arguments[i];                                       
	            }                                                                
	            args[i] = nodeback;                                              
	            [CodeForCall]                                                    
	            break;                                                           
	        `.replace("[CodeForCall]", U ? `ret = callback.apply(this, args);
` : `ret = callback.apply(receiver, args);
`), V;
            }
            var W = typeof b == "string" ? "this != null ? this['" + b + "'] : fn" : "fn", z = `'use strict';                                                
	        var ret = function (Parameters) {                                    
	            'use strict';                                                    
	            var len = arguments.length;                                      
	            var promise = new Promise(INTERNAL);                             
	            promise._captureStackTrace();                                    
	            var nodeback = nodebackForPromise(promise, ` + F + `);   
	            var ret;                                                         
	            var callback = tryCatch([GetFunctionCode]);                      
	            switch(len) {                                                    
	                [CodeForSwitchCase]                                          
	            }                                                                
	            if (ret === errorObj) {                                          
	                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
	            }                                                                
	            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     
	            return promise;                                                  
	        };                                                                   
	        notEnumerableProp(ret, '__isPromisified__', true);                   
	        return ret;                                                          
	    `.replace("[CodeForSwitchCase]", K()).replace("[GetFunctionCode]", W);
            return z = z.replace("Parameters", X(T)), new Function(
              "Promise",
              "fn",
              "receiver",
              "withAppended",
              "maybeWrapAsError",
              "nodebackForPromise",
              "tryCatch",
              "errorObj",
              "notEnumerableProp",
              "INTERNAL",
              z
            )(
              se,
              S,
              l,
              i,
              v,
              t,
              P.tryCatch,
              P.errorObj,
              P.notEnumerableProp,
              Q
            );
          };
        }
        function j(b, l, _, S, A, F) {
          var T = function() {
            return this;
          }(), O = b;
          typeof O == "string" && (b = S);
          function U() {
            var G = l;
            l === u && (G = this);
            var K = new se(Q);
            K._captureStackTrace();
            var W = typeof O == "string" && this !== T ? this[O] : b, z = t(K, F);
            try {
              W.apply(G, i(arguments, z));
            } catch (V) {
              K._rejectCallback(v(V), !0, !0);
            }
            return K._isFateSealed() || K._setAsyncGuaranteed(), K;
          }
          return P.notEnumerableProp(U, "__isPromisified__", !0), U;
        }
        var B = a ? C : j;
        function R(b, l, _, S, A) {
          for (var F = new RegExp(m(l) + "$"), T = f(b, l, F, _), O = 0, U = T.length; O < U; O += 2) {
            var G = T[O], K = T[O + 1], W = G + l;
            if (S === B)
              b[W] = B(G, u, G, K, l, A);
            else {
              var z = S(K, function() {
                return B(
                  G,
                  u,
                  G,
                  K,
                  l,
                  A
                );
              });
              P.notEnumerableProp(z, "__isPromisified__", !0), b[W] = z;
            }
          }
          return P.toFastProperties(b), b;
        }
        function D(b, l, _) {
          return B(
            b,
            l,
            void 0,
            b,
            null,
            _
          );
        }
        se.promisify = function(b, l) {
          if (typeof b != "function")
            throw new e("expecting a function but got " + P.classString(b));
          if (n(b))
            return b;
          l = Object(l);
          var _ = l.context === void 0 ? u : l.context, S = !!l.multiArgs, A = D(b, _, S);
          return P.copyDescriptors(b, A, c), A;
        }, se.promisifyAll = function(b, l) {
          if (typeof b != "function" && typeof b != "object")
            throw new e(`the target of promisifyAll must be an object or a function

    See http://goo.gl/MqrFmX
`);
          l = Object(l);
          var _ = !!l.multiArgs, S = l.suffix;
          typeof S != "string" && (S = y);
          var A = l.filter;
          typeof A != "function" && (A = d);
          var F = l.promisifier;
          if (typeof F != "function" && (F = B), !P.isIdentifier(S))
            throw new RangeError(`suffix must be a valid identifier

    See http://goo.gl/MqrFmX
`);
          for (var T = P.inheritedDataKeys(b), O = 0; O < T.length; ++O) {
            var U = b[T[O]];
            T[O] !== "constructor" && P.isClass(U) && (R(
              U.prototype,
              S,
              A,
              F,
              _
            ), R(U, S, A, F, _));
          }
          return R(b, S, A, F, _);
        };
      };
    }, { "./errors": 51, "./nodeback": 59, "./util": 75 }], 64: [function(le, de, oe) {
      de.exports = function(se, Q, u, P) {
        var t = le("./util"), i = t.isObject, v = le("./es5"), a;
        typeof Map == "function" && (a = Map);
        var e = function() {
          var g = 0, d = 0;
          function c(n, o) {
            this[g] = n, this[g + d] = o, g++;
          }
          return function(o) {
            d = o.size, g = 0;
            var x = new Array(o.size * 2);
            return o.forEach(c, x), x;
          };
        }(), y = function(g) {
          for (var d = new a(), c = g.length / 2 | 0, n = 0; n < c; ++n) {
            var o = g[c + n], x = g[n];
            d.set(o, x);
          }
          return d;
        };
        function r(g) {
          var d = !1, c;
          if (a !== void 0 && g instanceof a)
            c = e(g), d = !0;
          else {
            var n = v.keys(g), o = n.length;
            c = new Array(o * 2);
            for (var x = 0; x < o; ++x) {
              var f = n[x];
              c[x] = g[f], c[x + o] = f;
            }
          }
          this.constructor$(c), this._isMap = d, this._init$(void 0, -3);
        }
        t.inherits(r, Q), r.prototype._init = function() {
        }, r.prototype._promiseFulfilled = function(g, d) {
          this._values[d] = g;
          var c = ++this._totalResolved;
          if (c >= this._length) {
            var n;
            if (this._isMap)
              n = y(this._values);
            else {
              n = {};
              for (var o = this.length(), x = 0, f = this.length(); x < f; ++x)
                n[this._values[x + o]] = this._values[x];
            }
            return this._resolve(n), !0;
          }
          return !1;
        }, r.prototype.shouldCopyValues = function() {
          return !1;
        }, r.prototype.getActualLength = function(g) {
          return g >> 1;
        };
        function h(g) {
          var d, c = u(g);
          if (i(c))
            c instanceof se ? d = c._then(
              se.props,
              void 0,
              void 0,
              void 0,
              void 0
            ) : d = new r(c).promise();
          else
            return P(`cannot await properties of a non-object

    See http://goo.gl/MqrFmX
`);
          return c instanceof se && d._propagateFrom(c, 2), d;
        }
        se.prototype.props = function() {
          return h(this);
        }, se.props = function(g) {
          return h(g);
        };
      };
    }, { "./es5": 52, "./util": 75 }], 65: [function(le, de, oe) {
      function se(u, P, t, i, v) {
        for (var a = 0; a < v; ++a)
          t[a + i] = u[a + P], u[a + P] = void 0;
      }
      function Q(u) {
        this._capacity = u, this._length = 0, this._front = 0;
      }
      Q.prototype._willBeOverCapacity = function(u) {
        return this._capacity < u;
      }, Q.prototype._pushOne = function(u) {
        var P = this.length();
        this._checkCapacity(P + 1);
        var t = this._front + P & this._capacity - 1;
        this[t] = u, this._length = P + 1;
      }, Q.prototype.push = function(u, P, t) {
        var i = this.length() + 3;
        if (this._willBeOverCapacity(i)) {
          this._pushOne(u), this._pushOne(P), this._pushOne(t);
          return;
        }
        var v = this._front + i - 3;
        this._checkCapacity(i);
        var a = this._capacity - 1;
        this[v + 0 & a] = u, this[v + 1 & a] = P, this[v + 2 & a] = t, this._length = i;
      }, Q.prototype.shift = function() {
        var u = this._front, P = this[u];
        return this[u] = void 0, this._front = u + 1 & this._capacity - 1, this._length--, P;
      }, Q.prototype.length = function() {
        return this._length;
      }, Q.prototype._checkCapacity = function(u) {
        this._capacity < u && this._resizeTo(this._capacity << 1);
      }, Q.prototype._resizeTo = function(u) {
        var P = this._capacity;
        this._capacity = u;
        var t = this._front, i = this._length, v = t + i & P - 1;
        se(this, 0, this, P, v);
      }, de.exports = Q;
    }, {}], 66: [function(le, de, oe) {
      de.exports = function(se, Q, u, P) {
        var t = le("./util"), i = function(a) {
          return a.then(function(e) {
            return v(e, a);
          });
        };
        function v(a, e) {
          var y = u(a);
          if (y instanceof se)
            return i(y);
          if (a = t.asArray(a), a === null)
            return P("expecting an array or an iterable object but got " + t.classString(a));
          var r = new se(Q);
          e !== void 0 && r._propagateFrom(e, 3);
          for (var h = r._fulfill, g = r._reject, d = 0, c = a.length; d < c; ++d) {
            var n = a[d];
            n === void 0 && !(d in a) || se.cast(n)._then(h, g, void 0, r, null);
          }
          return r;
        }
        se.race = function(a) {
          return v(a, void 0);
        }, se.prototype.race = function() {
          return v(this, void 0);
        };
      };
    }, { "./util": 75 }], 67: [function(le, de, oe) {
      de.exports = function(se, Q, u, P, t, i) {
        var v = se._getDomain, a = le("./util"), e = a.tryCatch;
        function y(c, n, o, x) {
          this.constructor$(c);
          var f = v();
          this._fn = f === null ? n : a.domainBind(f, n), o !== void 0 && (o = se.resolve(o), o._attachCancellationCallback(this)), this._initialValue = o, this._currentCancellable = null, x === t ? this._eachValues = Array(this._length) : x === 0 ? this._eachValues = null : this._eachValues = void 0, this._promise._captureStackTrace(), this._init$(void 0, -5);
        }
        a.inherits(y, Q), y.prototype._gotAccum = function(c) {
          this._eachValues !== void 0 && this._eachValues !== null && c !== t && this._eachValues.push(c);
        }, y.prototype._eachComplete = function(c) {
          return this._eachValues !== null && this._eachValues.push(c), this._eachValues;
        }, y.prototype._init = function() {
        }, y.prototype._resolveEmptyArray = function() {
          this._resolve(this._eachValues !== void 0 ? this._eachValues : this._initialValue);
        }, y.prototype.shouldCopyValues = function() {
          return !1;
        }, y.prototype._resolve = function(c) {
          this._promise._resolveCallback(c), this._values = null;
        }, y.prototype._resultCancelled = function(c) {
          if (c === this._initialValue)
            return this._cancel();
          this._isResolved() || (this._resultCancelled$(), this._currentCancellable instanceof se && this._currentCancellable.cancel(), this._initialValue instanceof se && this._initialValue.cancel());
        }, y.prototype._iterate = function(c) {
          this._values = c;
          var n, o, x = c.length;
          if (this._initialValue !== void 0 ? (n = this._initialValue, o = 0) : (n = se.resolve(c[0]), o = 1), this._currentCancellable = n, !n.isRejected())
            for (; o < x; ++o) {
              var f = {
                accum: null,
                value: c[o],
                index: o,
                length: x,
                array: this
              };
              n = n._then(g, void 0, void 0, f, void 0);
            }
          this._eachValues !== void 0 && (n = n._then(this._eachComplete, void 0, void 0, this, void 0)), n._then(r, r, void 0, n, this);
        }, se.prototype.reduce = function(c, n) {
          return h(this, c, n, null);
        }, se.reduce = function(c, n, o, x) {
          return h(c, n, o, x);
        };
        function r(c, n) {
          this.isFulfilled() ? n._resolve(c) : n._reject(c);
        }
        function h(c, n, o, x) {
          if (typeof n != "function")
            return u("expecting a function but got " + a.classString(n));
          var f = new y(c, n, o, x);
          return f.promise();
        }
        function g(c) {
          this.accum = c, this.array._gotAccum(c);
          var n = P(this.value, this.array._promise);
          return n instanceof se ? (this.array._currentCancellable = n, n._then(d, void 0, void 0, this, void 0)) : d.call(this, n);
        }
        function d(c) {
          var n = this.array, o = n._promise, x = e(n._fn);
          o._pushContext();
          var f;
          n._eachValues !== void 0 ? f = x.call(o._boundValue(), c, this.index, this.length) : f = x.call(
            o._boundValue(),
            this.accum,
            c,
            this.index,
            this.length
          ), f instanceof se && (n._currentCancellable = f);
          var m = o._popContext();
          return i.checkForgottenReturns(
            f,
            m,
            n._eachValues !== void 0 ? "Promise.each" : "Promise.reduce",
            o
          ), f;
        }
      };
    }, { "./util": 75 }], 68: [function(le, de, oe) {
      (function(se, Q) {
        var u = le("./util"), P, t = function() {
          throw new Error(`No async scheduler available

    See http://goo.gl/MqrFmX
`);
        }, i = u.getNativePromise();
        if (u.isNode && typeof MutationObserver > "u") {
          var v = Q.setImmediate, a = se.nextTick;
          P = u.isRecentNode ? function(y) {
            v.call(Q, y);
          } : function(y) {
            a.call(se, y);
          };
        } else if (typeof i == "function" && typeof i.resolve == "function") {
          var e = i.resolve();
          P = function(y) {
            e.then(y);
          };
        } else
          typeof MutationObserver < "u" && !(typeof window < "u" && window.navigator && (window.navigator.standalone || window.cordova)) ? P = function() {
            var y = document.createElement("div"), r = { attributes: !0 }, h = !1, g = document.createElement("div"), d = new MutationObserver(function() {
              y.classList.toggle("foo"), h = !1;
            });
            d.observe(g, r);
            var c = function() {
              h || (h = !0, g.classList.toggle("foo"));
            };
            return function(o) {
              var x = new MutationObserver(function() {
                x.disconnect(), o();
              });
              x.observe(y, r), c();
            };
          }() : typeof setImmediate < "u" ? P = function(y) {
            setImmediate(y);
          } : typeof setTimeout < "u" ? P = function(y) {
            setTimeout(y, 0);
          } : P = t;
        de.exports = P;
      }).call(this, le("_process"), typeof commonjsGlobal < "u" ? commonjsGlobal : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "./util": 75, _process: 102 }], 69: [function(le, de, oe) {
      de.exports = function(se, Q, u) {
        var P = se.PromiseInspection, t = le("./util");
        function i(v) {
          this.constructor$(v);
        }
        t.inherits(i, Q), i.prototype._promiseResolved = function(v, a) {
          this._values[v] = a;
          var e = ++this._totalResolved;
          return e >= this._length ? (this._resolve(this._values), !0) : !1;
        }, i.prototype._promiseFulfilled = function(v, a) {
          var e = new P();
          return e._bitField = 33554432, e._settledValueField = v, this._promiseResolved(a, e);
        }, i.prototype._promiseRejected = function(v, a) {
          var e = new P();
          return e._bitField = 16777216, e._settledValueField = v, this._promiseResolved(a, e);
        }, se.settle = function(v) {
          return u.deprecated(".settle()", ".reflect()"), new i(v).promise();
        }, se.prototype.settle = function() {
          return se.settle(this);
        };
      };
    }, { "./util": 75 }], 70: [function(le, de, oe) {
      de.exports = function(se, Q, u) {
        var P = le("./util"), t = le("./errors").RangeError, i = le("./errors").AggregateError, v = P.isArray, a = {};
        function e(r) {
          this.constructor$(r), this._howMany = 0, this._unwrap = !1, this._initialized = !1;
        }
        P.inherits(e, Q), e.prototype._init = function() {
          if (this._initialized) {
            if (this._howMany === 0) {
              this._resolve([]);
              return;
            }
            this._init$(void 0, -5);
            var r = v(this._values);
            !this._isResolved() && r && this._howMany > this._canPossiblyFulfill() && this._reject(this._getRangeError(this.length()));
          }
        }, e.prototype.init = function() {
          this._initialized = !0, this._init();
        }, e.prototype.setUnwrap = function() {
          this._unwrap = !0;
        }, e.prototype.howMany = function() {
          return this._howMany;
        }, e.prototype.setHowMany = function(r) {
          this._howMany = r;
        }, e.prototype._promiseFulfilled = function(r) {
          return this._addFulfilled(r), this._fulfilled() === this.howMany() ? (this._values.length = this.howMany(), this.howMany() === 1 && this._unwrap ? this._resolve(this._values[0]) : this._resolve(this._values), !0) : !1;
        }, e.prototype._promiseRejected = function(r) {
          return this._addRejected(r), this._checkOutcome();
        }, e.prototype._promiseCancelled = function() {
          return this._values instanceof se || this._values == null ? this._cancel() : (this._addRejected(a), this._checkOutcome());
        }, e.prototype._checkOutcome = function() {
          if (this.howMany() > this._canPossiblyFulfill()) {
            for (var r = new i(), h = this.length(); h < this._values.length; ++h)
              this._values[h] !== a && r.push(this._values[h]);
            return r.length > 0 ? this._reject(r) : this._cancel(), !0;
          }
          return !1;
        }, e.prototype._fulfilled = function() {
          return this._totalResolved;
        }, e.prototype._rejected = function() {
          return this._values.length - this.length();
        }, e.prototype._addRejected = function(r) {
          this._values.push(r);
        }, e.prototype._addFulfilled = function(r) {
          this._values[this._totalResolved++] = r;
        }, e.prototype._canPossiblyFulfill = function() {
          return this.length() - this._rejected();
        }, e.prototype._getRangeError = function(r) {
          var h = "Input array must contain at least " + this._howMany + " items but contains only " + r + " items";
          return new t(h);
        }, e.prototype._resolveEmptyArray = function() {
          this._reject(this._getRangeError(0));
        };
        function y(r, h) {
          if ((h | 0) !== h || h < 0)
            return u(`expecting a positive integer

    See http://goo.gl/MqrFmX
`);
          var g = new e(r), d = g.promise();
          return g.setHowMany(h), g.init(), d;
        }
        se.some = function(r, h) {
          return y(r, h);
        }, se.prototype.some = function(r) {
          return y(this, r);
        }, se._SomePromiseArray = e;
      };
    }, { "./errors": 51, "./util": 75 }], 71: [function(le, de, oe) {
      de.exports = function(se) {
        function Q(e) {
          e !== void 0 ? (e = e._target(), this._bitField = e._bitField, this._settledValueField = e._isFateSealed() ? e._settledValue() : void 0) : (this._bitField = 0, this._settledValueField = void 0);
        }
        Q.prototype._settledValue = function() {
          return this._settledValueField;
        };
        var u = Q.prototype.value = function() {
          if (!this.isFulfilled())
            throw new TypeError(`cannot get fulfillment value of a non-fulfilled promise

    See http://goo.gl/MqrFmX
`);
          return this._settledValue();
        }, P = Q.prototype.error = Q.prototype.reason = function() {
          if (!this.isRejected())
            throw new TypeError(`cannot get rejection reason of a non-rejected promise

    See http://goo.gl/MqrFmX
`);
          return this._settledValue();
        }, t = Q.prototype.isFulfilled = function() {
          return (this._bitField & 33554432) !== 0;
        }, i = Q.prototype.isRejected = function() {
          return (this._bitField & 16777216) !== 0;
        }, v = Q.prototype.isPending = function() {
          return (this._bitField & 50397184) === 0;
        }, a = Q.prototype.isResolved = function() {
          return (this._bitField & 50331648) !== 0;
        };
        Q.prototype.isCancelled = function() {
          return (this._bitField & 8454144) !== 0;
        }, se.prototype.__isCancelled = function() {
          return (this._bitField & 65536) === 65536;
        }, se.prototype._isCancelled = function() {
          return this._target().__isCancelled();
        }, se.prototype.isCancelled = function() {
          return (this._target()._bitField & 8454144) !== 0;
        }, se.prototype.isPending = function() {
          return v.call(this._target());
        }, se.prototype.isRejected = function() {
          return i.call(this._target());
        }, se.prototype.isFulfilled = function() {
          return t.call(this._target());
        }, se.prototype.isResolved = function() {
          return a.call(this._target());
        }, se.prototype.value = function() {
          return u.call(this._target());
        }, se.prototype.reason = function() {
          var e = this._target();
          return e._unsetRejectionIsUnhandled(), P.call(e);
        }, se.prototype._value = function() {
          return this._settledValue();
        }, se.prototype._reason = function() {
          return this._unsetRejectionIsUnhandled(), this._settledValue();
        }, se.PromiseInspection = Q;
      };
    }, {}], 72: [function(le, de, oe) {
      de.exports = function(se, Q) {
        var u = le("./util"), P = u.errorObj, t = u.isObject;
        function i(h, g) {
          if (t(h)) {
            if (h instanceof se)
              return h;
            var d = a(h);
            if (d === P) {
              g && g._pushContext();
              var c = se.reject(d.e);
              return g && g._popContext(), c;
            } else if (typeof d == "function") {
              if (y(h)) {
                var c = new se(Q);
                return h._then(
                  c._fulfill,
                  c._reject,
                  void 0,
                  c,
                  null
                ), c;
              }
              return r(h, d, g);
            }
          }
          return h;
        }
        function v(h) {
          return h.then;
        }
        function a(h) {
          try {
            return v(h);
          } catch (g) {
            return P.e = g, P;
          }
        }
        var e = {}.hasOwnProperty;
        function y(h) {
          try {
            return e.call(h, "_promise0");
          } catch {
            return !1;
          }
        }
        function r(h, g, d) {
          var c = new se(Q), n = c;
          d && d._pushContext(), c._captureStackTrace(), d && d._popContext();
          var o = !0, x = u.tryCatch(g).call(h, f, m);
          o = !1, c && x === P && (c._rejectCallback(x.e, !0, !0), c = null);
          function f(C) {
            c && (c._resolveCallback(C), c = null);
          }
          function m(C) {
            c && (c._rejectCallback(C, o, !0), c = null);
          }
          return n;
        }
        return i;
      };
    }, { "./util": 75 }], 73: [function(le, de, oe) {
      de.exports = function(se, Q, u) {
        var P = le("./util"), t = se.TimeoutError;
        function i(h) {
          this.handle = h;
        }
        i.prototype._resultCancelled = function() {
          clearTimeout(this.handle);
        };
        var v = function(h) {
          return a(+this).thenReturn(h);
        }, a = se.delay = function(h, g) {
          var d, c;
          return g !== void 0 ? (d = se.resolve(g)._then(v, null, null, h, void 0), u.cancellation() && g instanceof se && d._setOnCancel(g)) : (d = new se(Q), c = setTimeout(function() {
            d._fulfill();
          }, +h), u.cancellation() && d._setOnCancel(new i(c)), d._captureStackTrace()), d._setAsyncGuaranteed(), d;
        };
        se.prototype.delay = function(h) {
          return a(h, this);
        };
        var e = function(h, g, d) {
          var c;
          typeof g != "string" ? g instanceof Error ? c = g : c = new t("operation timed out") : c = new t(g), P.markAsOriginatingFromRejection(c), h._attachExtraTrace(c), h._reject(c), d != null && d.cancel();
        };
        function y(h) {
          return clearTimeout(this.handle), h;
        }
        function r(h) {
          throw clearTimeout(this.handle), h;
        }
        se.prototype.timeout = function(h, g) {
          h = +h;
          var d, c, n = new i(setTimeout(function() {
            d.isPending() && e(d, g, c);
          }, h));
          return u.cancellation() ? (c = this.then(), d = c._then(
            y,
            r,
            void 0,
            n,
            void 0
          ), d._setOnCancel(n)) : d = this._then(
            y,
            r,
            void 0,
            n,
            void 0
          ), d;
        };
      };
    }, { "./util": 75 }], 74: [function(le, de, oe) {
      de.exports = function(se, Q, u, P, t, i) {
        var v = le("./util"), a = le("./errors").TypeError, e = le("./util").inherits, y = v.errorObj, r = v.tryCatch, h = {};
        function g(m) {
          setTimeout(function() {
            throw m;
          }, 0);
        }
        function d(m) {
          var C = u(m);
          return C !== m && typeof m._isDisposable == "function" && typeof m._getDisposer == "function" && m._isDisposable() && C._setDisposable(m._getDisposer()), C;
        }
        function c(m, C) {
          var p = 0, w = m.length, X = new se(t);
          function M() {
            if (p >= w)
              return X._fulfill();
            var j = d(m[p++]);
            if (j instanceof se && j._isDisposable()) {
              try {
                j = u(
                  j._getDisposer().tryDispose(C),
                  m.promise
                );
              } catch (B) {
                return g(B);
              }
              if (j instanceof se)
                return j._then(
                  M,
                  g,
                  null,
                  null,
                  null
                );
            }
            M();
          }
          return M(), X;
        }
        function n(m, C, p) {
          this._data = m, this._promise = C, this._context = p;
        }
        n.prototype.data = function() {
          return this._data;
        }, n.prototype.promise = function() {
          return this._promise;
        }, n.prototype.resource = function() {
          return this.promise().isFulfilled() ? this.promise().value() : h;
        }, n.prototype.tryDispose = function(m) {
          var C = this.resource(), p = this._context;
          p !== void 0 && p._pushContext();
          var w = C !== h ? this.doDispose(C, m) : null;
          return p !== void 0 && p._popContext(), this._promise._unsetDisposable(), this._data = null, w;
        }, n.isDisposer = function(m) {
          return m != null && typeof m.resource == "function" && typeof m.tryDispose == "function";
        };
        function o(m, C, p) {
          this.constructor$(m, C, p);
        }
        e(o, n), o.prototype.doDispose = function(m, C) {
          var p = this.data();
          return p.call(m, m, C);
        };
        function x(m) {
          return n.isDisposer(m) ? (this.resources[this.index]._setDisposable(m), m.promise()) : m;
        }
        function f(m) {
          this.length = m, this.promise = null, this[m - 1] = null;
        }
        f.prototype._resultCancelled = function() {
          for (var m = this.length, C = 0; C < m; ++C) {
            var p = this[C];
            p instanceof se && p.cancel();
          }
        }, se.using = function() {
          var m = arguments.length;
          if (m < 2)
            return Q(
              "you must pass at least 2 arguments to Promise.using"
            );
          var C = arguments[m - 1];
          if (typeof C != "function")
            return Q("expecting a function but got " + v.classString(C));
          var p, w = !0;
          m === 2 && Array.isArray(arguments[0]) ? (p = arguments[0], m = p.length, w = !1) : (p = arguments, m--);
          for (var X = new f(m), M = 0; M < m; ++M) {
            var j = p[M];
            if (n.isDisposer(j)) {
              var B = j;
              j = j.promise(), j._setDisposable(B);
            } else {
              var R = u(j);
              R instanceof se && (j = R._then(x, null, null, {
                resources: X,
                index: M
              }, void 0));
            }
            X[M] = j;
          }
          for (var D = new Array(X.length), M = 0; M < D.length; ++M)
            D[M] = se.resolve(X[M]).reflect();
          var b = se.all(D).then(function(_) {
            for (var S = 0; S < _.length; ++S) {
              var A = _[S];
              if (A.isRejected())
                return y.e = A.error(), y;
              if (!A.isFulfilled()) {
                b.cancel();
                return;
              }
              _[S] = A.value();
            }
            l._pushContext(), C = r(C);
            var F = w ? C.apply(void 0, _) : C(_), T = l._popContext();
            return i.checkForgottenReturns(
              F,
              T,
              "Promise.using",
              l
            ), F;
          }), l = b.lastly(function() {
            var _ = new se.PromiseInspection(b);
            return c(X, _);
          });
          return X.promise = l, l._setOnCancel(X), l;
        }, se.prototype._setDisposable = function(m) {
          this._bitField = this._bitField | 131072, this._disposer = m;
        }, se.prototype._isDisposable = function() {
          return (this._bitField & 131072) > 0;
        }, se.prototype._getDisposer = function() {
          return this._disposer;
        }, se.prototype._unsetDisposable = function() {
          this._bitField = this._bitField & -131073, this._disposer = void 0;
        }, se.prototype.disposer = function(m) {
          if (typeof m == "function")
            return new o(m, this, P());
          throw new a();
        };
      };
    }, { "./errors": 51, "./util": 75 }], 75: [function(le, de, oe) {
      (function(se, Q) {
        var u = le("./es5"), P = typeof navigator > "u", t = { e: {} }, i, v = typeof self < "u" ? self : typeof window < "u" ? window : typeof Q < "u" ? Q : this !== void 0 ? this : null;
        function a() {
          try {
            var W = i;
            return i = null, W.apply(this, arguments);
          } catch (z) {
            return t.e = z, t;
          }
        }
        function e(W) {
          return i = W, a;
        }
        var y = function(W, z) {
          var V = {}.hasOwnProperty;
          function L() {
            this.constructor = W, this.constructor$ = z;
            for (var Y in z.prototype)
              V.call(z.prototype, Y) && Y.charAt(Y.length - 1) !== "$" && (this[Y + "$"] = z.prototype[Y]);
          }
          return L.prototype = z.prototype, W.prototype = new L(), W.prototype;
        };
        function r(W) {
          return W == null || W === !0 || W === !1 || typeof W == "string" || typeof W == "number";
        }
        function h(W) {
          return typeof W == "function" || typeof W == "object" && W !== null;
        }
        function g(W) {
          return r(W) ? new Error(M(W)) : W;
        }
        function d(W, z) {
          var V = W.length, L = new Array(V + 1), Y;
          for (Y = 0; Y < V; ++Y)
            L[Y] = W[Y];
          return L[Y] = z, L;
        }
        function c(W, z, V) {
          if (u.isES5) {
            var L = Object.getOwnPropertyDescriptor(W, z);
            if (L != null)
              return L.get == null && L.set == null ? L.value : V;
          } else
            return {}.hasOwnProperty.call(W, z) ? W[z] : void 0;
        }
        function n(W, z, V) {
          if (r(W))
            return W;
          var L = {
            value: V,
            configurable: !0,
            enumerable: !1,
            writable: !0
          };
          return u.defineProperty(W, z, L), W;
        }
        function o(W) {
          throw W;
        }
        var x = function() {
          var W = [
            Array.prototype,
            Object.prototype,
            Function.prototype
          ], z = function(Y) {
            for (var J = 0; J < W.length; ++J)
              if (W[J] === Y)
                return !0;
            return !1;
          };
          if (u.isES5) {
            var V = Object.getOwnPropertyNames;
            return function(Y) {
              for (var J = [], ie = /* @__PURE__ */ Object.create(null); Y != null && !z(Y); ) {
                var q;
                try {
                  q = V(Y);
                } catch {
                  return J;
                }
                for (var N = 0; N < q.length; ++N) {
                  var Z = q[N];
                  if (!ie[Z]) {
                    ie[Z] = !0;
                    var E = Object.getOwnPropertyDescriptor(Y, Z);
                    E != null && E.get == null && E.set == null && J.push(Z);
                  }
                }
                Y = u.getPrototypeOf(Y);
              }
              return J;
            };
          } else {
            var L = {}.hasOwnProperty;
            return function(Y) {
              if (z(Y))
                return [];
              var J = [];
              e:
                for (var ie in Y)
                  if (L.call(Y, ie))
                    J.push(ie);
                  else {
                    for (var q = 0; q < W.length; ++q)
                      if (L.call(W[q], ie))
                        continue e;
                    J.push(ie);
                  }
              return J;
            };
          }
        }(), f = /this\s*\.\s*\S+\s*=/;
        function m(W) {
          try {
            if (typeof W == "function") {
              var z = u.names(W.prototype), V = u.isES5 && z.length > 1, L = z.length > 0 && !(z.length === 1 && z[0] === "constructor"), Y = f.test(W + "") && u.names(W).length > 0;
              if (V || L || Y)
                return !0;
            }
            return !1;
          } catch {
            return !1;
          }
        }
        function C(W) {
          return W;
        }
        var p = /^[a-z$_][a-z$_0-9]*$/i;
        function w(W) {
          return p.test(W);
        }
        function X(W, z, V) {
          for (var L = new Array(W), Y = 0; Y < W; ++Y)
            L[Y] = z + Y + V;
          return L;
        }
        function M(W) {
          try {
            return W + "";
          } catch {
            return "[no string representation]";
          }
        }
        function j(W) {
          return W !== null && typeof W == "object" && typeof W.message == "string" && typeof W.name == "string";
        }
        function B(W) {
          try {
            n(W, "isOperational", !0);
          } catch {
          }
        }
        function R(W) {
          return W == null ? !1 : W instanceof Error.__BluebirdErrorTypes__.OperationalError || W.isOperational === !0;
        }
        function D(W) {
          return j(W) && u.propertyIsWritable(W, "stack");
        }
        var b = function() {
          return "stack" in new Error() ? function(W) {
            return D(W) ? W : new Error(M(W));
          } : function(W) {
            if (D(W))
              return W;
            try {
              throw new Error(M(W));
            } catch (z) {
              return z;
            }
          };
        }();
        function l(W) {
          return {}.toString.call(W);
        }
        function _(W, z, V) {
          for (var L = u.names(W), Y = 0; Y < L.length; ++Y) {
            var J = L[Y];
            if (V(J))
              try {
                u.defineProperty(z, J, u.getDescriptor(W, J));
              } catch {
              }
          }
        }
        var S = function(W) {
          return u.isArray(W) ? W : null;
        };
        if (typeof Symbol < "u" && Symbol.iterator) {
          var A = typeof Array.from == "function" ? function(W) {
            return Array.from(W);
          } : function(W) {
            for (var z = [], V = W[Symbol.iterator](), L; !(L = V.next()).done; )
              z.push(L.value);
            return z;
          };
          S = function(W) {
            return u.isArray(W) ? W : W != null && typeof W[Symbol.iterator] == "function" ? A(W) : null;
          };
        }
        var F = typeof se < "u" && l(se).toLowerCase() === "[object process]", T = typeof se < "u" && typeof se.env < "u";
        function O(W) {
          return T ? se.env[W] : void 0;
        }
        function U() {
          if (typeof Promise == "function")
            try {
              var W = new Promise(function() {
              });
              if ({}.toString.call(W) === "[object Promise]")
                return Promise;
            } catch {
            }
        }
        function G(W, z) {
          return W.bind(z);
        }
        var K = {
          isClass: m,
          isIdentifier: w,
          inheritedDataKeys: x,
          getDataPropertyOrDefault: c,
          thrower: o,
          isArray: u.isArray,
          asArray: S,
          notEnumerableProp: n,
          isPrimitive: r,
          isObject: h,
          isError: j,
          canEvaluate: P,
          errorObj: t,
          tryCatch: e,
          inherits: y,
          withAppended: d,
          maybeWrapAsError: g,
          toFastProperties: C,
          filledRange: X,
          toString: M,
          canAttachTrace: D,
          ensureErrorObject: b,
          originatesFromRejection: R,
          markAsOriginatingFromRejection: B,
          classString: l,
          copyDescriptors: _,
          hasDevTools: typeof chrome < "u" && chrome && typeof chrome.loadTimes == "function",
          isNode: F,
          hasEnvVariables: T,
          env: O,
          global: v,
          getNativePromise: U,
          domainBind: G
        };
        K.isRecentNode = K.isNode && function() {
          var W = se.versions.node.split(".").map(Number);
          return W[0] === 0 && W[1] > 10 || W[0] > 0;
        }(), K.isNode && K.toFastProperties(se);
        try {
          throw new Error();
        } catch (W) {
          K.lastLineError = W;
        }
        de.exports = K;
      }).call(this, le("_process"), typeof commonjsGlobal < "u" ? commonjsGlobal : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "./es5": 52, _process: 102 }], 76: [function(le, de, oe) {
    }, {}], 77: [function(le, de, oe) {
      (function(se) {
        var Q = le("buffer"), u = Q.Buffer, P = Q.SlowBuffer, t = Q.kMaxLength || 2147483647;
        oe.alloc = function(v, a, e) {
          if (typeof u.alloc == "function")
            return u.alloc(v, a, e);
          if (typeof e == "number")
            throw new TypeError("encoding must not be number");
          if (typeof v != "number")
            throw new TypeError("size must be a number");
          if (v > t)
            throw new RangeError("size is too large");
          var y = e, r = a;
          r === void 0 && (y = void 0, r = 0);
          var h = new u(v);
          if (typeof r == "string")
            for (var g = new u(r, y), d = g.length, c = -1; ++c < v; )
              h[c] = g[c % d];
          else
            h.fill(r);
          return h;
        }, oe.allocUnsafe = function(v) {
          if (typeof u.allocUnsafe == "function")
            return u.allocUnsafe(v);
          if (typeof v != "number")
            throw new TypeError("size must be a number");
          if (v > t)
            throw new RangeError("size is too large");
          return new u(v);
        }, oe.from = function(v, a, e) {
          if (typeof u.from == "function" && (!se.Uint8Array || Uint8Array.from !== u.from))
            return u.from(v, a, e);
          if (typeof v == "number")
            throw new TypeError('"value" argument must not be a number');
          if (typeof v == "string")
            return new u(v, a);
          if (typeof ArrayBuffer < "u" && v instanceof ArrayBuffer) {
            var y = a;
            if (arguments.length === 1)
              return new u(v);
            typeof y > "u" && (y = 0);
            var r = e;
            if (typeof r > "u" && (r = v.byteLength - y), y >= v.byteLength)
              throw new RangeError("'offset' is out of bounds");
            if (r > v.byteLength - y)
              throw new RangeError("'length' is out of bounds");
            return new u(v.slice(y, y + r));
          }
          if (u.isBuffer(v)) {
            var h = new u(v.length);
            return v.copy(h, 0, 0, v.length), h;
          }
          if (v) {
            if (Array.isArray(v) || typeof ArrayBuffer < "u" && v.buffer instanceof ArrayBuffer || "length" in v)
              return new u(v);
            if (v.type === "Buffer" && Array.isArray(v.data))
              return new u(v.data);
          }
          throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
        }, oe.allocUnsafeSlow = function(v) {
          if (typeof u.allocUnsafeSlow == "function")
            return u.allocUnsafeSlow(v);
          if (typeof v != "number")
            throw new TypeError("size must be a number");
          if (v >= t)
            throw new RangeError("size is too large");
          return new P(v);
        };
      }).call(this, typeof commonjsGlobal < "u" ? commonjsGlobal : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { buffer: 78 }], 78: [function(le, de, oe) {
      (function(se) {
        var Q = le("base64-js"), u = le("ieee754"), P = le("isarray");
        oe.Buffer = a, oe.SlowBuffer = x, oe.INSPECT_MAX_BYTES = 50, a.TYPED_ARRAY_SUPPORT = se.TYPED_ARRAY_SUPPORT !== void 0 ? se.TYPED_ARRAY_SUPPORT : t(), oe.kMaxLength = i();
        function t() {
          try {
            var $ = new Uint8Array(1);
            return $.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
              return 42;
            } }, $.foo() === 42 && // typed array instances can be augmented
            typeof $.subarray == "function" && // chrome 9-10 lack `subarray`
            $.subarray(1, 1).byteLength === 0;
          } catch {
            return !1;
          }
        }
        function i() {
          return a.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
        }
        function v($, k) {
          if (i() < k)
            throw new RangeError("Invalid typed array length");
          return a.TYPED_ARRAY_SUPPORT ? ($ = new Uint8Array(k), $.__proto__ = a.prototype) : ($ === null && ($ = new a(k)), $.length = k), $;
        }
        function a($, k, H) {
          if (!a.TYPED_ARRAY_SUPPORT && !(this instanceof a))
            return new a($, k, H);
          if (typeof $ == "number") {
            if (typeof k == "string")
              throw new Error(
                "If encoding is specified then the first argument must be a string"
              );
            return h(this, $);
          }
          return e(this, $, k, H);
        }
        a.poolSize = 8192, a._augment = function($) {
          return $.__proto__ = a.prototype, $;
        };
        function e($, k, H, ne) {
          if (typeof k == "number")
            throw new TypeError('"value" argument must not be a number');
          return typeof ArrayBuffer < "u" && k instanceof ArrayBuffer ? c($, k, H, ne) : typeof k == "string" ? g($, k, H) : n($, k);
        }
        a.from = function($, k, H) {
          return e(null, $, k, H);
        }, a.TYPED_ARRAY_SUPPORT && (a.prototype.__proto__ = Uint8Array.prototype, a.__proto__ = Uint8Array, typeof Symbol < "u" && Symbol.species && a[Symbol.species] === a && Object.defineProperty(a, Symbol.species, {
          value: null,
          configurable: !0
        }));
        function y($) {
          if (typeof $ != "number")
            throw new TypeError('"size" argument must be a number');
          if ($ < 0)
            throw new RangeError('"size" argument must not be negative');
        }
        function r($, k, H, ne) {
          return y(k), k <= 0 ? v($, k) : H !== void 0 ? typeof ne == "string" ? v($, k).fill(H, ne) : v($, k).fill(H) : v($, k);
        }
        a.alloc = function($, k, H) {
          return r(null, $, k, H);
        };
        function h($, k) {
          if (y(k), $ = v($, k < 0 ? 0 : o(k) | 0), !a.TYPED_ARRAY_SUPPORT)
            for (var H = 0; H < k; ++H)
              $[H] = 0;
          return $;
        }
        a.allocUnsafe = function($) {
          return h(null, $);
        }, a.allocUnsafeSlow = function($) {
          return h(null, $);
        };
        function g($, k, H) {
          if ((typeof H != "string" || H === "") && (H = "utf8"), !a.isEncoding(H))
            throw new TypeError('"encoding" must be a valid string encoding');
          var ne = f(k, H) | 0;
          $ = v($, ne);
          var ae = $.write(k, H);
          return ae !== ne && ($ = $.slice(0, ae)), $;
        }
        function d($, k) {
          var H = k.length < 0 ? 0 : o(k.length) | 0;
          $ = v($, H);
          for (var ne = 0; ne < H; ne += 1)
            $[ne] = k[ne] & 255;
          return $;
        }
        function c($, k, H, ne) {
          if (k.byteLength, H < 0 || k.byteLength < H)
            throw new RangeError("'offset' is out of bounds");
          if (k.byteLength < H + (ne || 0))
            throw new RangeError("'length' is out of bounds");
          return H === void 0 && ne === void 0 ? k = new Uint8Array(k) : ne === void 0 ? k = new Uint8Array(k, H) : k = new Uint8Array(k, H, ne), a.TYPED_ARRAY_SUPPORT ? ($ = k, $.__proto__ = a.prototype) : $ = d($, k), $;
        }
        function n($, k) {
          if (a.isBuffer(k)) {
            var H = o(k.length) | 0;
            return $ = v($, H), $.length === 0 || k.copy($, 0, 0, H), $;
          }
          if (k) {
            if (typeof ArrayBuffer < "u" && k.buffer instanceof ArrayBuffer || "length" in k)
              return typeof k.length != "number" || ee(k.length) ? v($, 0) : d($, k);
            if (k.type === "Buffer" && P(k.data))
              return d($, k.data);
          }
          throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
        }
        function o($) {
          if ($ >= i())
            throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i().toString(16) + " bytes");
          return $ | 0;
        }
        function x($) {
          return +$ != $ && ($ = 0), a.alloc(+$);
        }
        a.isBuffer = function(k) {
          return !!(k != null && k._isBuffer);
        }, a.compare = function(k, H) {
          if (!a.isBuffer(k) || !a.isBuffer(H))
            throw new TypeError("Arguments must be Buffers");
          if (k === H)
            return 0;
          for (var ne = k.length, ae = H.length, he = 0, ue = Math.min(ne, ae); he < ue; ++he)
            if (k[he] !== H[he]) {
              ne = k[he], ae = H[he];
              break;
            }
          return ne < ae ? -1 : ae < ne ? 1 : 0;
        }, a.isEncoding = function(k) {
          switch (String(k).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return !0;
            default:
              return !1;
          }
        }, a.concat = function(k, H) {
          if (!P(k))
            throw new TypeError('"list" argument must be an Array of Buffers');
          if (k.length === 0)
            return a.alloc(0);
          var ne;
          if (H === void 0)
            for (H = 0, ne = 0; ne < k.length; ++ne)
              H += k[ne].length;
          var ae = a.allocUnsafe(H), he = 0;
          for (ne = 0; ne < k.length; ++ne) {
            var ue = k[ne];
            if (!a.isBuffer(ue))
              throw new TypeError('"list" argument must be an Array of Buffers');
            ue.copy(ae, he), he += ue.length;
          }
          return ae;
        };
        function f($, k) {
          if (a.isBuffer($))
            return $.length;
          if (typeof ArrayBuffer < "u" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView($) || $ instanceof ArrayBuffer))
            return $.byteLength;
          typeof $ != "string" && ($ = "" + $);
          var H = $.length;
          if (H === 0)
            return 0;
          for (var ne = !1; ; )
            switch (k) {
              case "ascii":
              case "latin1":
              case "binary":
                return H;
              case "utf8":
              case "utf-8":
              case void 0:
                return N($).length;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return H * 2;
              case "hex":
                return H >>> 1;
              case "base64":
                return te($).length;
              default:
                if (ne)
                  return N($).length;
                k = ("" + k).toLowerCase(), ne = !0;
            }
        }
        a.byteLength = f;
        function m($, k, H) {
          var ne = !1;
          if ((k === void 0 || k < 0) && (k = 0), k > this.length || ((H === void 0 || H > this.length) && (H = this.length), H <= 0) || (H >>>= 0, k >>>= 0, H <= k))
            return "";
          for ($ || ($ = "utf8"); ; )
            switch ($) {
              case "hex":
                return T(this, k, H);
              case "utf8":
              case "utf-8":
                return l(this, k, H);
              case "ascii":
                return A(this, k, H);
              case "latin1":
              case "binary":
                return F(this, k, H);
              case "base64":
                return b(this, k, H);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return O(this, k, H);
              default:
                if (ne)
                  throw new TypeError("Unknown encoding: " + $);
                $ = ($ + "").toLowerCase(), ne = !0;
            }
        }
        a.prototype._isBuffer = !0;
        function C($, k, H) {
          var ne = $[k];
          $[k] = $[H], $[H] = ne;
        }
        a.prototype.swap16 = function() {
          var k = this.length;
          if (k % 2 !== 0)
            throw new RangeError("Buffer size must be a multiple of 16-bits");
          for (var H = 0; H < k; H += 2)
            C(this, H, H + 1);
          return this;
        }, a.prototype.swap32 = function() {
          var k = this.length;
          if (k % 4 !== 0)
            throw new RangeError("Buffer size must be a multiple of 32-bits");
          for (var H = 0; H < k; H += 4)
            C(this, H, H + 3), C(this, H + 1, H + 2);
          return this;
        }, a.prototype.swap64 = function() {
          var k = this.length;
          if (k % 8 !== 0)
            throw new RangeError("Buffer size must be a multiple of 64-bits");
          for (var H = 0; H < k; H += 8)
            C(this, H, H + 7), C(this, H + 1, H + 6), C(this, H + 2, H + 5), C(this, H + 3, H + 4);
          return this;
        }, a.prototype.toString = function() {
          var k = this.length | 0;
          return k === 0 ? "" : arguments.length === 0 ? l(this, 0, k) : m.apply(this, arguments);
        }, a.prototype.equals = function(k) {
          if (!a.isBuffer(k))
            throw new TypeError("Argument must be a Buffer");
          return this === k ? !0 : a.compare(this, k) === 0;
        }, a.prototype.inspect = function() {
          var k = "", H = oe.INSPECT_MAX_BYTES;
          return this.length > 0 && (k = this.toString("hex", 0, H).match(/.{2}/g).join(" "), this.length > H && (k += " ... ")), "<Buffer " + k + ">";
        }, a.prototype.compare = function(k, H, ne, ae, he) {
          if (!a.isBuffer(k))
            throw new TypeError("Argument must be a Buffer");
          if (H === void 0 && (H = 0), ne === void 0 && (ne = k ? k.length : 0), ae === void 0 && (ae = 0), he === void 0 && (he = this.length), H < 0 || ne > k.length || ae < 0 || he > this.length)
            throw new RangeError("out of range index");
          if (ae >= he && H >= ne)
            return 0;
          if (ae >= he)
            return -1;
          if (H >= ne)
            return 1;
          if (H >>>= 0, ne >>>= 0, ae >>>= 0, he >>>= 0, this === k)
            return 0;
          for (var ue = he - ae, fe = ne - H, me = Math.min(ue, fe), Fe = this.slice(ae, he), we = k.slice(H, ne), Ae = 0; Ae < me; ++Ae)
            if (Fe[Ae] !== we[Ae]) {
              ue = Fe[Ae], fe = we[Ae];
              break;
            }
          return ue < fe ? -1 : fe < ue ? 1 : 0;
        };
        function p($, k, H, ne, ae) {
          if ($.length === 0)
            return -1;
          if (typeof H == "string" ? (ne = H, H = 0) : H > 2147483647 ? H = 2147483647 : H < -2147483648 && (H = -2147483648), H = +H, isNaN(H) && (H = ae ? 0 : $.length - 1), H < 0 && (H = $.length + H), H >= $.length) {
            if (ae)
              return -1;
            H = $.length - 1;
          } else if (H < 0)
            if (ae)
              H = 0;
            else
              return -1;
          if (typeof k == "string" && (k = a.from(k, ne)), a.isBuffer(k))
            return k.length === 0 ? -1 : w($, k, H, ne, ae);
          if (typeof k == "number")
            return k = k & 255, a.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? ae ? Uint8Array.prototype.indexOf.call($, k, H) : Uint8Array.prototype.lastIndexOf.call($, k, H) : w($, [k], H, ne, ae);
          throw new TypeError("val must be string, number or Buffer");
        }
        function w($, k, H, ne, ae) {
          var he = 1, ue = $.length, fe = k.length;
          if (ne !== void 0 && (ne = String(ne).toLowerCase(), ne === "ucs2" || ne === "ucs-2" || ne === "utf16le" || ne === "utf-16le")) {
            if ($.length < 2 || k.length < 2)
              return -1;
            he = 2, ue /= 2, fe /= 2, H /= 2;
          }
          function me(xe, Te) {
            return he === 1 ? xe[Te] : xe.readUInt16BE(Te * he);
          }
          var Fe;
          if (ae) {
            var we = -1;
            for (Fe = H; Fe < ue; Fe++)
              if (me($, Fe) === me(k, we === -1 ? 0 : Fe - we)) {
                if (we === -1 && (we = Fe), Fe - we + 1 === fe)
                  return we * he;
              } else
                we !== -1 && (Fe -= Fe - we), we = -1;
          } else
            for (H + fe > ue && (H = ue - fe), Fe = H; Fe >= 0; Fe--) {
              for (var Ae = !0, De = 0; De < fe; De++)
                if (me($, Fe + De) !== me(k, De)) {
                  Ae = !1;
                  break;
                }
              if (Ae)
                return Fe;
            }
          return -1;
        }
        a.prototype.includes = function(k, H, ne) {
          return this.indexOf(k, H, ne) !== -1;
        }, a.prototype.indexOf = function(k, H, ne) {
          return p(this, k, H, ne, !0);
        }, a.prototype.lastIndexOf = function(k, H, ne) {
          return p(this, k, H, ne, !1);
        };
        function X($, k, H, ne) {
          H = Number(H) || 0;
          var ae = $.length - H;
          ne ? (ne = Number(ne), ne > ae && (ne = ae)) : ne = ae;
          var he = k.length;
          if (he % 2 !== 0)
            throw new TypeError("Invalid hex string");
          ne > he / 2 && (ne = he / 2);
          for (var ue = 0; ue < ne; ++ue) {
            var fe = parseInt(k.substr(ue * 2, 2), 16);
            if (isNaN(fe))
              return ue;
            $[H + ue] = fe;
          }
          return ue;
        }
        function M($, k, H, ne) {
          return re(N(k, $.length - H), $, H, ne);
        }
        function j($, k, H, ne) {
          return re(Z(k), $, H, ne);
        }
        function B($, k, H, ne) {
          return j($, k, H, ne);
        }
        function R($, k, H, ne) {
          return re(te(k), $, H, ne);
        }
        function D($, k, H, ne) {
          return re(E(k, $.length - H), $, H, ne);
        }
        a.prototype.write = function(k, H, ne, ae) {
          if (H === void 0)
            ae = "utf8", ne = this.length, H = 0;
          else if (ne === void 0 && typeof H == "string")
            ae = H, ne = this.length, H = 0;
          else if (isFinite(H))
            H = H | 0, isFinite(ne) ? (ne = ne | 0, ae === void 0 && (ae = "utf8")) : (ae = ne, ne = void 0);
          else
            throw new Error(
              "Buffer.write(string, encoding, offset[, length]) is no longer supported"
            );
          var he = this.length - H;
          if ((ne === void 0 || ne > he) && (ne = he), k.length > 0 && (ne < 0 || H < 0) || H > this.length)
            throw new RangeError("Attempt to write outside buffer bounds");
          ae || (ae = "utf8");
          for (var ue = !1; ; )
            switch (ae) {
              case "hex":
                return X(this, k, H, ne);
              case "utf8":
              case "utf-8":
                return M(this, k, H, ne);
              case "ascii":
                return j(this, k, H, ne);
              case "latin1":
              case "binary":
                return B(this, k, H, ne);
              case "base64":
                return R(this, k, H, ne);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return D(this, k, H, ne);
              default:
                if (ue)
                  throw new TypeError("Unknown encoding: " + ae);
                ae = ("" + ae).toLowerCase(), ue = !0;
            }
        }, a.prototype.toJSON = function() {
          return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
          };
        };
        function b($, k, H) {
          return k === 0 && H === $.length ? Q.fromByteArray($) : Q.fromByteArray($.slice(k, H));
        }
        function l($, k, H) {
          H = Math.min($.length, H);
          for (var ne = [], ae = k; ae < H; ) {
            var he = $[ae], ue = null, fe = he > 239 ? 4 : he > 223 ? 3 : he > 191 ? 2 : 1;
            if (ae + fe <= H) {
              var me, Fe, we, Ae;
              switch (fe) {
                case 1:
                  he < 128 && (ue = he);
                  break;
                case 2:
                  me = $[ae + 1], (me & 192) === 128 && (Ae = (he & 31) << 6 | me & 63, Ae > 127 && (ue = Ae));
                  break;
                case 3:
                  me = $[ae + 1], Fe = $[ae + 2], (me & 192) === 128 && (Fe & 192) === 128 && (Ae = (he & 15) << 12 | (me & 63) << 6 | Fe & 63, Ae > 2047 && (Ae < 55296 || Ae > 57343) && (ue = Ae));
                  break;
                case 4:
                  me = $[ae + 1], Fe = $[ae + 2], we = $[ae + 3], (me & 192) === 128 && (Fe & 192) === 128 && (we & 192) === 128 && (Ae = (he & 15) << 18 | (me & 63) << 12 | (Fe & 63) << 6 | we & 63, Ae > 65535 && Ae < 1114112 && (ue = Ae));
              }
            }
            ue === null ? (ue = 65533, fe = 1) : ue > 65535 && (ue -= 65536, ne.push(ue >>> 10 & 1023 | 55296), ue = 56320 | ue & 1023), ne.push(ue), ae += fe;
          }
          return S(ne);
        }
        var _ = 4096;
        function S($) {
          var k = $.length;
          if (k <= _)
            return String.fromCharCode.apply(String, $);
          for (var H = "", ne = 0; ne < k; )
            H += String.fromCharCode.apply(
              String,
              $.slice(ne, ne += _)
            );
          return H;
        }
        function A($, k, H) {
          var ne = "";
          H = Math.min($.length, H);
          for (var ae = k; ae < H; ++ae)
            ne += String.fromCharCode($[ae] & 127);
          return ne;
        }
        function F($, k, H) {
          var ne = "";
          H = Math.min($.length, H);
          for (var ae = k; ae < H; ++ae)
            ne += String.fromCharCode($[ae]);
          return ne;
        }
        function T($, k, H) {
          var ne = $.length;
          (!k || k < 0) && (k = 0), (!H || H < 0 || H > ne) && (H = ne);
          for (var ae = "", he = k; he < H; ++he)
            ae += q($[he]);
          return ae;
        }
        function O($, k, H) {
          for (var ne = $.slice(k, H), ae = "", he = 0; he < ne.length; he += 2)
            ae += String.fromCharCode(ne[he] + ne[he + 1] * 256);
          return ae;
        }
        a.prototype.slice = function(k, H) {
          var ne = this.length;
          k = ~~k, H = H === void 0 ? ne : ~~H, k < 0 ? (k += ne, k < 0 && (k = 0)) : k > ne && (k = ne), H < 0 ? (H += ne, H < 0 && (H = 0)) : H > ne && (H = ne), H < k && (H = k);
          var ae;
          if (a.TYPED_ARRAY_SUPPORT)
            ae = this.subarray(k, H), ae.__proto__ = a.prototype;
          else {
            var he = H - k;
            ae = new a(he, void 0);
            for (var ue = 0; ue < he; ++ue)
              ae[ue] = this[ue + k];
          }
          return ae;
        };
        function U($, k, H) {
          if ($ % 1 !== 0 || $ < 0)
            throw new RangeError("offset is not uint");
          if ($ + k > H)
            throw new RangeError("Trying to access beyond buffer length");
        }
        a.prototype.readUIntLE = function(k, H, ne) {
          k = k | 0, H = H | 0, ne || U(k, H, this.length);
          for (var ae = this[k], he = 1, ue = 0; ++ue < H && (he *= 256); )
            ae += this[k + ue] * he;
          return ae;
        }, a.prototype.readUIntBE = function(k, H, ne) {
          k = k | 0, H = H | 0, ne || U(k, H, this.length);
          for (var ae = this[k + --H], he = 1; H > 0 && (he *= 256); )
            ae += this[k + --H] * he;
          return ae;
        }, a.prototype.readUInt8 = function(k, H) {
          return H || U(k, 1, this.length), this[k];
        }, a.prototype.readUInt16LE = function(k, H) {
          return H || U(k, 2, this.length), this[k] | this[k + 1] << 8;
        }, a.prototype.readUInt16BE = function(k, H) {
          return H || U(k, 2, this.length), this[k] << 8 | this[k + 1];
        }, a.prototype.readUInt32LE = function(k, H) {
          return H || U(k, 4, this.length), (this[k] | this[k + 1] << 8 | this[k + 2] << 16) + this[k + 3] * 16777216;
        }, a.prototype.readUInt32BE = function(k, H) {
          return H || U(k, 4, this.length), this[k] * 16777216 + (this[k + 1] << 16 | this[k + 2] << 8 | this[k + 3]);
        }, a.prototype.readIntLE = function(k, H, ne) {
          k = k | 0, H = H | 0, ne || U(k, H, this.length);
          for (var ae = this[k], he = 1, ue = 0; ++ue < H && (he *= 256); )
            ae += this[k + ue] * he;
          return he *= 128, ae >= he && (ae -= Math.pow(2, 8 * H)), ae;
        }, a.prototype.readIntBE = function(k, H, ne) {
          k = k | 0, H = H | 0, ne || U(k, H, this.length);
          for (var ae = H, he = 1, ue = this[k + --ae]; ae > 0 && (he *= 256); )
            ue += this[k + --ae] * he;
          return he *= 128, ue >= he && (ue -= Math.pow(2, 8 * H)), ue;
        }, a.prototype.readInt8 = function(k, H) {
          return H || U(k, 1, this.length), this[k] & 128 ? (255 - this[k] + 1) * -1 : this[k];
        }, a.prototype.readInt16LE = function(k, H) {
          H || U(k, 2, this.length);
          var ne = this[k] | this[k + 1] << 8;
          return ne & 32768 ? ne | 4294901760 : ne;
        }, a.prototype.readInt16BE = function(k, H) {
          H || U(k, 2, this.length);
          var ne = this[k + 1] | this[k] << 8;
          return ne & 32768 ? ne | 4294901760 : ne;
        }, a.prototype.readInt32LE = function(k, H) {
          return H || U(k, 4, this.length), this[k] | this[k + 1] << 8 | this[k + 2] << 16 | this[k + 3] << 24;
        }, a.prototype.readInt32BE = function(k, H) {
          return H || U(k, 4, this.length), this[k] << 24 | this[k + 1] << 16 | this[k + 2] << 8 | this[k + 3];
        }, a.prototype.readFloatLE = function(k, H) {
          return H || U(k, 4, this.length), u.read(this, k, !0, 23, 4);
        }, a.prototype.readFloatBE = function(k, H) {
          return H || U(k, 4, this.length), u.read(this, k, !1, 23, 4);
        }, a.prototype.readDoubleLE = function(k, H) {
          return H || U(k, 8, this.length), u.read(this, k, !0, 52, 8);
        }, a.prototype.readDoubleBE = function(k, H) {
          return H || U(k, 8, this.length), u.read(this, k, !1, 52, 8);
        };
        function G($, k, H, ne, ae, he) {
          if (!a.isBuffer($))
            throw new TypeError('"buffer" argument must be a Buffer instance');
          if (k > ae || k < he)
            throw new RangeError('"value" argument is out of bounds');
          if (H + ne > $.length)
            throw new RangeError("Index out of range");
        }
        a.prototype.writeUIntLE = function(k, H, ne, ae) {
          if (k = +k, H = H | 0, ne = ne | 0, !ae) {
            var he = Math.pow(2, 8 * ne) - 1;
            G(this, k, H, ne, he, 0);
          }
          var ue = 1, fe = 0;
          for (this[H] = k & 255; ++fe < ne && (ue *= 256); )
            this[H + fe] = k / ue & 255;
          return H + ne;
        }, a.prototype.writeUIntBE = function(k, H, ne, ae) {
          if (k = +k, H = H | 0, ne = ne | 0, !ae) {
            var he = Math.pow(2, 8 * ne) - 1;
            G(this, k, H, ne, he, 0);
          }
          var ue = ne - 1, fe = 1;
          for (this[H + ue] = k & 255; --ue >= 0 && (fe *= 256); )
            this[H + ue] = k / fe & 255;
          return H + ne;
        }, a.prototype.writeUInt8 = function(k, H, ne) {
          return k = +k, H = H | 0, ne || G(this, k, H, 1, 255, 0), a.TYPED_ARRAY_SUPPORT || (k = Math.floor(k)), this[H] = k & 255, H + 1;
        };
        function K($, k, H, ne) {
          k < 0 && (k = 65535 + k + 1);
          for (var ae = 0, he = Math.min($.length - H, 2); ae < he; ++ae)
            $[H + ae] = (k & 255 << 8 * (ne ? ae : 1 - ae)) >>> (ne ? ae : 1 - ae) * 8;
        }
        a.prototype.writeUInt16LE = function(k, H, ne) {
          return k = +k, H = H | 0, ne || G(this, k, H, 2, 65535, 0), a.TYPED_ARRAY_SUPPORT ? (this[H] = k & 255, this[H + 1] = k >>> 8) : K(this, k, H, !0), H + 2;
        }, a.prototype.writeUInt16BE = function(k, H, ne) {
          return k = +k, H = H | 0, ne || G(this, k, H, 2, 65535, 0), a.TYPED_ARRAY_SUPPORT ? (this[H] = k >>> 8, this[H + 1] = k & 255) : K(this, k, H, !1), H + 2;
        };
        function W($, k, H, ne) {
          k < 0 && (k = 4294967295 + k + 1);
          for (var ae = 0, he = Math.min($.length - H, 4); ae < he; ++ae)
            $[H + ae] = k >>> (ne ? ae : 3 - ae) * 8 & 255;
        }
        a.prototype.writeUInt32LE = function(k, H, ne) {
          return k = +k, H = H | 0, ne || G(this, k, H, 4, 4294967295, 0), a.TYPED_ARRAY_SUPPORT ? (this[H + 3] = k >>> 24, this[H + 2] = k >>> 16, this[H + 1] = k >>> 8, this[H] = k & 255) : W(this, k, H, !0), H + 4;
        }, a.prototype.writeUInt32BE = function(k, H, ne) {
          return k = +k, H = H | 0, ne || G(this, k, H, 4, 4294967295, 0), a.TYPED_ARRAY_SUPPORT ? (this[H] = k >>> 24, this[H + 1] = k >>> 16, this[H + 2] = k >>> 8, this[H + 3] = k & 255) : W(this, k, H, !1), H + 4;
        }, a.prototype.writeIntLE = function(k, H, ne, ae) {
          if (k = +k, H = H | 0, !ae) {
            var he = Math.pow(2, 8 * ne - 1);
            G(this, k, H, ne, he - 1, -he);
          }
          var ue = 0, fe = 1, me = 0;
          for (this[H] = k & 255; ++ue < ne && (fe *= 256); )
            k < 0 && me === 0 && this[H + ue - 1] !== 0 && (me = 1), this[H + ue] = (k / fe >> 0) - me & 255;
          return H + ne;
        }, a.prototype.writeIntBE = function(k, H, ne, ae) {
          if (k = +k, H = H | 0, !ae) {
            var he = Math.pow(2, 8 * ne - 1);
            G(this, k, H, ne, he - 1, -he);
          }
          var ue = ne - 1, fe = 1, me = 0;
          for (this[H + ue] = k & 255; --ue >= 0 && (fe *= 256); )
            k < 0 && me === 0 && this[H + ue + 1] !== 0 && (me = 1), this[H + ue] = (k / fe >> 0) - me & 255;
          return H + ne;
        }, a.prototype.writeInt8 = function(k, H, ne) {
          return k = +k, H = H | 0, ne || G(this, k, H, 1, 127, -128), a.TYPED_ARRAY_SUPPORT || (k = Math.floor(k)), k < 0 && (k = 255 + k + 1), this[H] = k & 255, H + 1;
        }, a.prototype.writeInt16LE = function(k, H, ne) {
          return k = +k, H = H | 0, ne || G(this, k, H, 2, 32767, -32768), a.TYPED_ARRAY_SUPPORT ? (this[H] = k & 255, this[H + 1] = k >>> 8) : K(this, k, H, !0), H + 2;
        }, a.prototype.writeInt16BE = function(k, H, ne) {
          return k = +k, H = H | 0, ne || G(this, k, H, 2, 32767, -32768), a.TYPED_ARRAY_SUPPORT ? (this[H] = k >>> 8, this[H + 1] = k & 255) : K(this, k, H, !1), H + 2;
        }, a.prototype.writeInt32LE = function(k, H, ne) {
          return k = +k, H = H | 0, ne || G(this, k, H, 4, 2147483647, -2147483648), a.TYPED_ARRAY_SUPPORT ? (this[H] = k & 255, this[H + 1] = k >>> 8, this[H + 2] = k >>> 16, this[H + 3] = k >>> 24) : W(this, k, H, !0), H + 4;
        }, a.prototype.writeInt32BE = function(k, H, ne) {
          return k = +k, H = H | 0, ne || G(this, k, H, 4, 2147483647, -2147483648), k < 0 && (k = 4294967295 + k + 1), a.TYPED_ARRAY_SUPPORT ? (this[H] = k >>> 24, this[H + 1] = k >>> 16, this[H + 2] = k >>> 8, this[H + 3] = k & 255) : W(this, k, H, !1), H + 4;
        };
        function z($, k, H, ne, ae, he) {
          if (H + ne > $.length)
            throw new RangeError("Index out of range");
          if (H < 0)
            throw new RangeError("Index out of range");
        }
        function V($, k, H, ne, ae) {
          return ae || z($, k, H, 4), u.write($, k, H, ne, 23, 4), H + 4;
        }
        a.prototype.writeFloatLE = function(k, H, ne) {
          return V(this, k, H, !0, ne);
        }, a.prototype.writeFloatBE = function(k, H, ne) {
          return V(this, k, H, !1, ne);
        };
        function L($, k, H, ne, ae) {
          return ae || z($, k, H, 8), u.write($, k, H, ne, 52, 8), H + 8;
        }
        a.prototype.writeDoubleLE = function(k, H, ne) {
          return L(this, k, H, !0, ne);
        }, a.prototype.writeDoubleBE = function(k, H, ne) {
          return L(this, k, H, !1, ne);
        }, a.prototype.copy = function(k, H, ne, ae) {
          if (ne || (ne = 0), !ae && ae !== 0 && (ae = this.length), H >= k.length && (H = k.length), H || (H = 0), ae > 0 && ae < ne && (ae = ne), ae === ne || k.length === 0 || this.length === 0)
            return 0;
          if (H < 0)
            throw new RangeError("targetStart out of bounds");
          if (ne < 0 || ne >= this.length)
            throw new RangeError("sourceStart out of bounds");
          if (ae < 0)
            throw new RangeError("sourceEnd out of bounds");
          ae > this.length && (ae = this.length), k.length - H < ae - ne && (ae = k.length - H + ne);
          var he = ae - ne, ue;
          if (this === k && ne < H && H < ae)
            for (ue = he - 1; ue >= 0; --ue)
              k[ue + H] = this[ue + ne];
          else if (he < 1e3 || !a.TYPED_ARRAY_SUPPORT)
            for (ue = 0; ue < he; ++ue)
              k[ue + H] = this[ue + ne];
          else
            Uint8Array.prototype.set.call(
              k,
              this.subarray(ne, ne + he),
              H
            );
          return he;
        }, a.prototype.fill = function(k, H, ne, ae) {
          if (typeof k == "string") {
            if (typeof H == "string" ? (ae = H, H = 0, ne = this.length) : typeof ne == "string" && (ae = ne, ne = this.length), k.length === 1) {
              var he = k.charCodeAt(0);
              he < 256 && (k = he);
            }
            if (ae !== void 0 && typeof ae != "string")
              throw new TypeError("encoding must be a string");
            if (typeof ae == "string" && !a.isEncoding(ae))
              throw new TypeError("Unknown encoding: " + ae);
          } else
            typeof k == "number" && (k = k & 255);
          if (H < 0 || this.length < H || this.length < ne)
            throw new RangeError("Out of range index");
          if (ne <= H)
            return this;
          H = H >>> 0, ne = ne === void 0 ? this.length : ne >>> 0, k || (k = 0);
          var ue;
          if (typeof k == "number")
            for (ue = H; ue < ne; ++ue)
              this[ue] = k;
          else {
            var fe = a.isBuffer(k) ? k : N(new a(k, ae).toString()), me = fe.length;
            for (ue = 0; ue < ne - H; ++ue)
              this[ue + H] = fe[ue % me];
          }
          return this;
        };
        var Y = /[^+\/0-9A-Za-z-_]/g;
        function J($) {
          if ($ = ie($).replace(Y, ""), $.length < 2)
            return "";
          for (; $.length % 4 !== 0; )
            $ = $ + "=";
          return $;
        }
        function ie($) {
          return $.trim ? $.trim() : $.replace(/^\s+|\s+$/g, "");
        }
        function q($) {
          return $ < 16 ? "0" + $.toString(16) : $.toString(16);
        }
        function N($, k) {
          k = k || 1 / 0;
          for (var H, ne = $.length, ae = null, he = [], ue = 0; ue < ne; ++ue) {
            if (H = $.charCodeAt(ue), H > 55295 && H < 57344) {
              if (!ae) {
                if (H > 56319) {
                  (k -= 3) > -1 && he.push(239, 191, 189);
                  continue;
                } else if (ue + 1 === ne) {
                  (k -= 3) > -1 && he.push(239, 191, 189);
                  continue;
                }
                ae = H;
                continue;
              }
              if (H < 56320) {
                (k -= 3) > -1 && he.push(239, 191, 189), ae = H;
                continue;
              }
              H = (ae - 55296 << 10 | H - 56320) + 65536;
            } else
              ae && (k -= 3) > -1 && he.push(239, 191, 189);
            if (ae = null, H < 128) {
              if ((k -= 1) < 0)
                break;
              he.push(H);
            } else if (H < 2048) {
              if ((k -= 2) < 0)
                break;
              he.push(
                H >> 6 | 192,
                H & 63 | 128
              );
            } else if (H < 65536) {
              if ((k -= 3) < 0)
                break;
              he.push(
                H >> 12 | 224,
                H >> 6 & 63 | 128,
                H & 63 | 128
              );
            } else if (H < 1114112) {
              if ((k -= 4) < 0)
                break;
              he.push(
                H >> 18 | 240,
                H >> 12 & 63 | 128,
                H >> 6 & 63 | 128,
                H & 63 | 128
              );
            } else
              throw new Error("Invalid code point");
          }
          return he;
        }
        function Z($) {
          for (var k = [], H = 0; H < $.length; ++H)
            k.push($.charCodeAt(H) & 255);
          return k;
        }
        function E($, k) {
          for (var H, ne, ae, he = [], ue = 0; ue < $.length && !((k -= 2) < 0); ++ue)
            H = $.charCodeAt(ue), ne = H >> 8, ae = H % 256, he.push(ae), he.push(ne);
          return he;
        }
        function te($) {
          return Q.toByteArray(J($));
        }
        function re($, k, H, ne) {
          for (var ae = 0; ae < ne && !(ae + H >= k.length || ae >= $.length); ++ae)
            k[ae + H] = $[ae];
          return ae;
        }
        function ee($) {
          return $ !== $;
        }
      }).call(this, typeof commonjsGlobal < "u" ? commonjsGlobal : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "base64-js": 40, ieee754: 83, isarray: 86 }], 79: [function(le, de, oe) {
      (function(se) {
        function Q(o) {
          return Array.isArray ? Array.isArray(o) : n(o) === "[object Array]";
        }
        oe.isArray = Q;
        function u(o) {
          return typeof o == "boolean";
        }
        oe.isBoolean = u;
        function P(o) {
          return o === null;
        }
        oe.isNull = P;
        function t(o) {
          return o == null;
        }
        oe.isNullOrUndefined = t;
        function i(o) {
          return typeof o == "number";
        }
        oe.isNumber = i;
        function v(o) {
          return typeof o == "string";
        }
        oe.isString = v;
        function a(o) {
          return typeof o == "symbol";
        }
        oe.isSymbol = a;
        function e(o) {
          return o === void 0;
        }
        oe.isUndefined = e;
        function y(o) {
          return n(o) === "[object RegExp]";
        }
        oe.isRegExp = y;
        function r(o) {
          return typeof o == "object" && o !== null;
        }
        oe.isObject = r;
        function h(o) {
          return n(o) === "[object Date]";
        }
        oe.isDate = h;
        function g(o) {
          return n(o) === "[object Error]" || o instanceof Error;
        }
        oe.isError = g;
        function d(o) {
          return typeof o == "function";
        }
        oe.isFunction = d;
        function c(o) {
          return o === null || typeof o == "boolean" || typeof o == "number" || typeof o == "string" || typeof o == "symbol" || // ES6 symbol
          typeof o > "u";
        }
        oe.isPrimitive = c, oe.isBuffer = se.isBuffer;
        function n(o) {
          return Object.prototype.toString.call(o);
        }
      }).call(this, { isBuffer: le("../../is-buffer/index.js") });
    }, { "../../is-buffer/index.js": 85 }], 80: [function(le, de, oe) {
      Object.defineProperty(oe, "__esModule", { value: !0 });
      var se = [
        { "Typeface name": "Symbol", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
        { "Typeface name": "Symbol", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "33", "Unicode hex": "21" },
        { "Typeface name": "Symbol", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "8704", "Unicode hex": "2200" },
        { "Typeface name": "Symbol", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "35", "Unicode hex": "23" },
        { "Typeface name": "Symbol", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "8707", "Unicode hex": "2203" },
        { "Typeface name": "Symbol", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "37", "Unicode hex": "25" },
        { "Typeface name": "Symbol", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "38", "Unicode hex": "26" },
        { "Typeface name": "Symbol", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "8717", "Unicode hex": "220D" },
        { "Typeface name": "Symbol", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "40", "Unicode hex": "28" },
        { "Typeface name": "Symbol", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "41", "Unicode hex": "29" },
        { "Typeface name": "Symbol", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "42", "Unicode hex": "2A" },
        { "Typeface name": "Symbol", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "43", "Unicode hex": "2B" },
        { "Typeface name": "Symbol", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "44", "Unicode hex": "2C" },
        { "Typeface name": "Symbol", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "8722", "Unicode hex": "2212" },
        { "Typeface name": "Symbol", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "46", "Unicode hex": "2E" },
        { "Typeface name": "Symbol", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "47", "Unicode hex": "2F" },
        { "Typeface name": "Symbol", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "48", "Unicode hex": "30" },
        { "Typeface name": "Symbol", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "49", "Unicode hex": "31" },
        { "Typeface name": "Symbol", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "50", "Unicode hex": "32" },
        { "Typeface name": "Symbol", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "51", "Unicode hex": "33" },
        { "Typeface name": "Symbol", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "52", "Unicode hex": "34" },
        { "Typeface name": "Symbol", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "53", "Unicode hex": "35" },
        { "Typeface name": "Symbol", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "54", "Unicode hex": "36" },
        { "Typeface name": "Symbol", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "55", "Unicode hex": "37" },
        { "Typeface name": "Symbol", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "56", "Unicode hex": "38" },
        { "Typeface name": "Symbol", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "57", "Unicode hex": "39" },
        { "Typeface name": "Symbol", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "58", "Unicode hex": "3A" },
        { "Typeface name": "Symbol", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "59", "Unicode hex": "3B" },
        { "Typeface name": "Symbol", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "60", "Unicode hex": "3C" },
        { "Typeface name": "Symbol", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "61", "Unicode hex": "3D" },
        { "Typeface name": "Symbol", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "62", "Unicode hex": "3E" },
        { "Typeface name": "Symbol", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "63", "Unicode hex": "3F" },
        { "Typeface name": "Symbol", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "8773", "Unicode hex": "2245" },
        { "Typeface name": "Symbol", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "913", "Unicode hex": "391" },
        { "Typeface name": "Symbol", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "914", "Unicode hex": "392" },
        { "Typeface name": "Symbol", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "935", "Unicode hex": "3A7" },
        { "Typeface name": "Symbol", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "916", "Unicode hex": "394" },
        { "Typeface name": "Symbol", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "917", "Unicode hex": "395" },
        { "Typeface name": "Symbol", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "934", "Unicode hex": "3A6" },
        { "Typeface name": "Symbol", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "915", "Unicode hex": "393" },
        { "Typeface name": "Symbol", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "919", "Unicode hex": "397" },
        { "Typeface name": "Symbol", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "921", "Unicode hex": "399" },
        { "Typeface name": "Symbol", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "977", "Unicode hex": "3D1" },
        { "Typeface name": "Symbol", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "922", "Unicode hex": "39A" },
        { "Typeface name": "Symbol", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "923", "Unicode hex": "39B" },
        { "Typeface name": "Symbol", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "924", "Unicode hex": "39C" },
        { "Typeface name": "Symbol", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "925", "Unicode hex": "39D" },
        { "Typeface name": "Symbol", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "927", "Unicode hex": "39F" },
        { "Typeface name": "Symbol", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "928", "Unicode hex": "3A0" },
        { "Typeface name": "Symbol", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "920", "Unicode hex": "398" },
        { "Typeface name": "Symbol", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "929", "Unicode hex": "3A1" },
        { "Typeface name": "Symbol", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "931", "Unicode hex": "3A3" },
        { "Typeface name": "Symbol", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "932", "Unicode hex": "3A4" },
        { "Typeface name": "Symbol", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "933", "Unicode hex": "3A5" },
        { "Typeface name": "Symbol", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "962", "Unicode hex": "3C2" },
        { "Typeface name": "Symbol", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "937", "Unicode hex": "3A9" },
        { "Typeface name": "Symbol", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "926", "Unicode hex": "39E" },
        { "Typeface name": "Symbol", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "936", "Unicode hex": "3A8" },
        { "Typeface name": "Symbol", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "918", "Unicode hex": "396" },
        { "Typeface name": "Symbol", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "91", "Unicode hex": "5B" },
        { "Typeface name": "Symbol", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "8756", "Unicode hex": "2234" },
        { "Typeface name": "Symbol", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "93", "Unicode hex": "5D" },
        { "Typeface name": "Symbol", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "8869", "Unicode hex": "22A5" },
        { "Typeface name": "Symbol", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "95", "Unicode hex": "5F" },
        { "Typeface name": "Symbol", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "8254", "Unicode hex": "203E" },
        { "Typeface name": "Symbol", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "945", "Unicode hex": "3B1" },
        { "Typeface name": "Symbol", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "946", "Unicode hex": "3B2" },
        { "Typeface name": "Symbol", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "967", "Unicode hex": "3C7" },
        { "Typeface name": "Symbol", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "948", "Unicode hex": "3B4" },
        { "Typeface name": "Symbol", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "949", "Unicode hex": "3B5" },
        { "Typeface name": "Symbol", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "966", "Unicode hex": "3C6" },
        { "Typeface name": "Symbol", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "947", "Unicode hex": "3B3" },
        { "Typeface name": "Symbol", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "951", "Unicode hex": "3B7" },
        { "Typeface name": "Symbol", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "953", "Unicode hex": "3B9" },
        { "Typeface name": "Symbol", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "981", "Unicode hex": "3D5" },
        { "Typeface name": "Symbol", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "954", "Unicode hex": "3BA" },
        { "Typeface name": "Symbol", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "955", "Unicode hex": "3BB" },
        { "Typeface name": "Symbol", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "956", "Unicode hex": "3BC" },
        { "Typeface name": "Symbol", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "957", "Unicode hex": "3BD" },
        { "Typeface name": "Symbol", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "959", "Unicode hex": "3BF" },
        { "Typeface name": "Symbol", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "960", "Unicode hex": "3C0" },
        { "Typeface name": "Symbol", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "952", "Unicode hex": "3B8" },
        { "Typeface name": "Symbol", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "961", "Unicode hex": "3C1" },
        { "Typeface name": "Symbol", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "963", "Unicode hex": "3C3" },
        { "Typeface name": "Symbol", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "964", "Unicode hex": "3C4" },
        { "Typeface name": "Symbol", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "965", "Unicode hex": "3C5" },
        { "Typeface name": "Symbol", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "982", "Unicode hex": "3D6" },
        { "Typeface name": "Symbol", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "969", "Unicode hex": "3C9" },
        { "Typeface name": "Symbol", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "958", "Unicode hex": "3BE" },
        { "Typeface name": "Symbol", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "968", "Unicode hex": "3C8" },
        { "Typeface name": "Symbol", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "950", "Unicode hex": "3B6" },
        { "Typeface name": "Symbol", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "123", "Unicode hex": "7B" },
        { "Typeface name": "Symbol", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "124", "Unicode hex": "7C" },
        { "Typeface name": "Symbol", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "125", "Unicode hex": "7D" },
        { "Typeface name": "Symbol", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "126", "Unicode hex": "7E" },
        { "Typeface name": "Symbol", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "8364", "Unicode hex": "20AC" },
        { "Typeface name": "Symbol", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "978", "Unicode hex": "3D2" },
        { "Typeface name": "Symbol", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "8242", "Unicode hex": "2032" },
        { "Typeface name": "Symbol", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "8804", "Unicode hex": "2264" },
        { "Typeface name": "Symbol", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "8260", "Unicode hex": "2044" },
        { "Typeface name": "Symbol", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "8734", "Unicode hex": "221E" },
        { "Typeface name": "Symbol", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "402", "Unicode hex": "192" },
        { "Typeface name": "Symbol", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "9827", "Unicode hex": "2663" },
        { "Typeface name": "Symbol", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "9830", "Unicode hex": "2666" },
        { "Typeface name": "Symbol", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "9829", "Unicode hex": "2665" },
        { "Typeface name": "Symbol", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "9824", "Unicode hex": "2660" },
        { "Typeface name": "Symbol", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "8596", "Unicode hex": "2194" },
        { "Typeface name": "Symbol", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "8592", "Unicode hex": "2190" },
        { "Typeface name": "Symbol", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "8593", "Unicode hex": "2191" },
        { "Typeface name": "Symbol", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "8594", "Unicode hex": "2192" },
        { "Typeface name": "Symbol", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "8595", "Unicode hex": "2193" },
        { "Typeface name": "Symbol", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "176", "Unicode hex": "B0" },
        { "Typeface name": "Symbol", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "177", "Unicode hex": "B1" },
        { "Typeface name": "Symbol", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "8243", "Unicode hex": "2033" },
        { "Typeface name": "Symbol", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "8805", "Unicode hex": "2265" },
        { "Typeface name": "Symbol", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "215", "Unicode hex": "D7" },
        { "Typeface name": "Symbol", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "8733", "Unicode hex": "221D" },
        { "Typeface name": "Symbol", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "8706", "Unicode hex": "2202" },
        { "Typeface name": "Symbol", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "8226", "Unicode hex": "2022" },
        { "Typeface name": "Symbol", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "247", "Unicode hex": "F7" },
        { "Typeface name": "Symbol", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "8800", "Unicode hex": "2260" },
        { "Typeface name": "Symbol", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "8801", "Unicode hex": "2261" },
        { "Typeface name": "Symbol", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "8776", "Unicode hex": "2248" },
        { "Typeface name": "Symbol", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "8230", "Unicode hex": "2026" },
        { "Typeface name": "Symbol", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "9168", "Unicode hex": "23D0" },
        { "Typeface name": "Symbol", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "9135", "Unicode hex": "23AF" },
        { "Typeface name": "Symbol", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "8629", "Unicode hex": "21B5" },
        { "Typeface name": "Symbol", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "8501", "Unicode hex": "2135" },
        { "Typeface name": "Symbol", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "8465", "Unicode hex": "2111" },
        { "Typeface name": "Symbol", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "8476", "Unicode hex": "211C" },
        { "Typeface name": "Symbol", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "8472", "Unicode hex": "2118" },
        { "Typeface name": "Symbol", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "8855", "Unicode hex": "2297" },
        { "Typeface name": "Symbol", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "8853", "Unicode hex": "2295" },
        { "Typeface name": "Symbol", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "8709", "Unicode hex": "2205" },
        { "Typeface name": "Symbol", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "8745", "Unicode hex": "2229" },
        { "Typeface name": "Symbol", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "8746", "Unicode hex": "222A" },
        { "Typeface name": "Symbol", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "8835", "Unicode hex": "2283" },
        { "Typeface name": "Symbol", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "8839", "Unicode hex": "2287" },
        { "Typeface name": "Symbol", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "8836", "Unicode hex": "2284" },
        { "Typeface name": "Symbol", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "8834", "Unicode hex": "2282" },
        { "Typeface name": "Symbol", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "8838", "Unicode hex": "2286" },
        { "Typeface name": "Symbol", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "8712", "Unicode hex": "2208" },
        { "Typeface name": "Symbol", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "8713", "Unicode hex": "2209" },
        { "Typeface name": "Symbol", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "8736", "Unicode hex": "2220" },
        { "Typeface name": "Symbol", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "8711", "Unicode hex": "2207" },
        { "Typeface name": "Symbol", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "174", "Unicode hex": "AE" },
        { "Typeface name": "Symbol", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "169", "Unicode hex": "A9" },
        { "Typeface name": "Symbol", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "8482", "Unicode hex": "2122" },
        { "Typeface name": "Symbol", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "8719", "Unicode hex": "220F" },
        { "Typeface name": "Symbol", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "8730", "Unicode hex": "221A" },
        { "Typeface name": "Symbol", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "8901", "Unicode hex": "22C5" },
        { "Typeface name": "Symbol", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "172", "Unicode hex": "AC" },
        { "Typeface name": "Symbol", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "8743", "Unicode hex": "2227" },
        { "Typeface name": "Symbol", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "8744", "Unicode hex": "2228" },
        { "Typeface name": "Symbol", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "8660", "Unicode hex": "21D4" },
        { "Typeface name": "Symbol", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "8656", "Unicode hex": "21D0" },
        { "Typeface name": "Symbol", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "8657", "Unicode hex": "21D1" },
        { "Typeface name": "Symbol", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "8658", "Unicode hex": "21D2" },
        { "Typeface name": "Symbol", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "8659", "Unicode hex": "21D3" },
        { "Typeface name": "Symbol", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "9674", "Unicode hex": "25CA" },
        { "Typeface name": "Symbol", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "12296", "Unicode hex": "3008" },
        { "Typeface name": "Symbol", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "174", "Unicode hex": "AE" },
        { "Typeface name": "Symbol", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "169", "Unicode hex": "A9" },
        { "Typeface name": "Symbol", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "8482", "Unicode hex": "2122" },
        { "Typeface name": "Symbol", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "8721", "Unicode hex": "2211" },
        { "Typeface name": "Symbol", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "9115", "Unicode hex": "239B" },
        { "Typeface name": "Symbol", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "9116", "Unicode hex": "239C" },
        { "Typeface name": "Symbol", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "9117", "Unicode hex": "239D" },
        { "Typeface name": "Symbol", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "9121", "Unicode hex": "23A1" },
        { "Typeface name": "Symbol", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "9122", "Unicode hex": "23A2" },
        { "Typeface name": "Symbol", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "9123", "Unicode hex": "23A3" },
        { "Typeface name": "Symbol", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "9127", "Unicode hex": "23A7" },
        { "Typeface name": "Symbol", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "9128", "Unicode hex": "23A8" },
        { "Typeface name": "Symbol", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "9129", "Unicode hex": "23A9" },
        { "Typeface name": "Symbol", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "9130", "Unicode hex": "23AA" },
        { "Typeface name": "Symbol", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "63743", "Unicode hex": "F8FF" },
        { "Typeface name": "Symbol", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "12297", "Unicode hex": "3009" },
        { "Typeface name": "Symbol", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "8747", "Unicode hex": "222B" },
        { "Typeface name": "Symbol", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "8992", "Unicode hex": "2320" },
        { "Typeface name": "Symbol", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "9134", "Unicode hex": "23AE" },
        { "Typeface name": "Symbol", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "8993", "Unicode hex": "2321" },
        { "Typeface name": "Symbol", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "9118", "Unicode hex": "239E" },
        { "Typeface name": "Symbol", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "9119", "Unicode hex": "239F" },
        { "Typeface name": "Symbol", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "9120", "Unicode hex": "23A0" },
        { "Typeface name": "Symbol", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "9124", "Unicode hex": "23A4" },
        { "Typeface name": "Symbol", "Dingbat dec": "250", "Dingbat hex": "FA", "Unicode dec": "9125", "Unicode hex": "23A5" },
        { "Typeface name": "Symbol", "Dingbat dec": "251", "Dingbat hex": "FB", "Unicode dec": "9126", "Unicode hex": "23A6" },
        { "Typeface name": "Symbol", "Dingbat dec": "252", "Dingbat hex": "FC", "Unicode dec": "9131", "Unicode hex": "23AB" },
        { "Typeface name": "Symbol", "Dingbat dec": "253", "Dingbat hex": "FD", "Unicode dec": "9132", "Unicode hex": "23AC" },
        { "Typeface name": "Symbol", "Dingbat dec": "254", "Dingbat hex": "FE", "Unicode dec": "9133", "Unicode hex": "23AD" },
        { "Typeface name": "Webdings", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
        { "Typeface name": "Webdings", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "128375", "Unicode hex": "1F577" },
        { "Typeface name": "Webdings", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "128376", "Unicode hex": "1F578" },
        { "Typeface name": "Webdings", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "128370", "Unicode hex": "1F572" },
        { "Typeface name": "Webdings", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "128374", "Unicode hex": "1F576" },
        { "Typeface name": "Webdings", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "127942", "Unicode hex": "1F3C6" },
        { "Typeface name": "Webdings", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "127894", "Unicode hex": "1F396" },
        { "Typeface name": "Webdings", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "128391", "Unicode hex": "1F587" },
        { "Typeface name": "Webdings", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "128488", "Unicode hex": "1F5E8" },
        { "Typeface name": "Webdings", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "128489", "Unicode hex": "1F5E9" },
        { "Typeface name": "Webdings", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "128496", "Unicode hex": "1F5F0" },
        { "Typeface name": "Webdings", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "128497", "Unicode hex": "1F5F1" },
        { "Typeface name": "Webdings", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "127798", "Unicode hex": "1F336" },
        { "Typeface name": "Webdings", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "127895", "Unicode hex": "1F397" },
        { "Typeface name": "Webdings", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "128638", "Unicode hex": "1F67E" },
        { "Typeface name": "Webdings", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "128636", "Unicode hex": "1F67C" },
        { "Typeface name": "Webdings", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "128469", "Unicode hex": "1F5D5" },
        { "Typeface name": "Webdings", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "128470", "Unicode hex": "1F5D6" },
        { "Typeface name": "Webdings", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "128471", "Unicode hex": "1F5D7" },
        { "Typeface name": "Webdings", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "9204", "Unicode hex": "23F4" },
        { "Typeface name": "Webdings", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "9205", "Unicode hex": "23F5" },
        { "Typeface name": "Webdings", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "9206", "Unicode hex": "23F6" },
        { "Typeface name": "Webdings", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "9207", "Unicode hex": "23F7" },
        { "Typeface name": "Webdings", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "9194", "Unicode hex": "23EA" },
        { "Typeface name": "Webdings", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "9193", "Unicode hex": "23E9" },
        { "Typeface name": "Webdings", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "9198", "Unicode hex": "23EE" },
        { "Typeface name": "Webdings", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "9197", "Unicode hex": "23ED" },
        { "Typeface name": "Webdings", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "9208", "Unicode hex": "23F8" },
        { "Typeface name": "Webdings", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "9209", "Unicode hex": "23F9" },
        { "Typeface name": "Webdings", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "9210", "Unicode hex": "23FA" },
        { "Typeface name": "Webdings", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "128474", "Unicode hex": "1F5DA" },
        { "Typeface name": "Webdings", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "128499", "Unicode hex": "1F5F3" },
        { "Typeface name": "Webdings", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "128736", "Unicode hex": "1F6E0" },
        { "Typeface name": "Webdings", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "127959", "Unicode hex": "1F3D7" },
        { "Typeface name": "Webdings", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "127960", "Unicode hex": "1F3D8" },
        { "Typeface name": "Webdings", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "127961", "Unicode hex": "1F3D9" },
        { "Typeface name": "Webdings", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "127962", "Unicode hex": "1F3DA" },
        { "Typeface name": "Webdings", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "127964", "Unicode hex": "1F3DC" },
        { "Typeface name": "Webdings", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "127981", "Unicode hex": "1F3ED" },
        { "Typeface name": "Webdings", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "127963", "Unicode hex": "1F3DB" },
        { "Typeface name": "Webdings", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "127968", "Unicode hex": "1F3E0" },
        { "Typeface name": "Webdings", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "127958", "Unicode hex": "1F3D6" },
        { "Typeface name": "Webdings", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "127965", "Unicode hex": "1F3DD" },
        { "Typeface name": "Webdings", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "128739", "Unicode hex": "1F6E3" },
        { "Typeface name": "Webdings", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "128269", "Unicode hex": "1F50D" },
        { "Typeface name": "Webdings", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "127956", "Unicode hex": "1F3D4" },
        { "Typeface name": "Webdings", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "128065", "Unicode hex": "1F441" },
        { "Typeface name": "Webdings", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "128066", "Unicode hex": "1F442" },
        { "Typeface name": "Webdings", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "127966", "Unicode hex": "1F3DE" },
        { "Typeface name": "Webdings", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "127957", "Unicode hex": "1F3D5" },
        { "Typeface name": "Webdings", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "128740", "Unicode hex": "1F6E4" },
        { "Typeface name": "Webdings", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "127967", "Unicode hex": "1F3DF" },
        { "Typeface name": "Webdings", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "128755", "Unicode hex": "1F6F3" },
        { "Typeface name": "Webdings", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "128364", "Unicode hex": "1F56C" },
        { "Typeface name": "Webdings", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "128363", "Unicode hex": "1F56B" },
        { "Typeface name": "Webdings", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "128360", "Unicode hex": "1F568" },
        { "Typeface name": "Webdings", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "128264", "Unicode hex": "1F508" },
        { "Typeface name": "Webdings", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "127892", "Unicode hex": "1F394" },
        { "Typeface name": "Webdings", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "127893", "Unicode hex": "1F395" },
        { "Typeface name": "Webdings", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "128492", "Unicode hex": "1F5EC" },
        { "Typeface name": "Webdings", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "128637", "Unicode hex": "1F67D" },
        { "Typeface name": "Webdings", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "128493", "Unicode hex": "1F5ED" },
        { "Typeface name": "Webdings", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "128490", "Unicode hex": "1F5EA" },
        { "Typeface name": "Webdings", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "128491", "Unicode hex": "1F5EB" },
        { "Typeface name": "Webdings", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "11156", "Unicode hex": "2B94" },
        { "Typeface name": "Webdings", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "10004", "Unicode hex": "2714" },
        { "Typeface name": "Webdings", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "128690", "Unicode hex": "1F6B2" },
        { "Typeface name": "Webdings", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "11036", "Unicode hex": "2B1C" },
        { "Typeface name": "Webdings", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "128737", "Unicode hex": "1F6E1" },
        { "Typeface name": "Webdings", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "128230", "Unicode hex": "1F4E6" },
        { "Typeface name": "Webdings", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "128753", "Unicode hex": "1F6F1" },
        { "Typeface name": "Webdings", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "11035", "Unicode hex": "2B1B" },
        { "Typeface name": "Webdings", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "128657", "Unicode hex": "1F691" },
        { "Typeface name": "Webdings", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "128712", "Unicode hex": "1F6C8" },
        { "Typeface name": "Webdings", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "128745", "Unicode hex": "1F6E9" },
        { "Typeface name": "Webdings", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "128752", "Unicode hex": "1F6F0" },
        { "Typeface name": "Webdings", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "128968", "Unicode hex": "1F7C8" },
        { "Typeface name": "Webdings", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "128372", "Unicode hex": "1F574" },
        { "Typeface name": "Webdings", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "11044", "Unicode hex": "2B24" },
        { "Typeface name": "Webdings", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "128741", "Unicode hex": "1F6E5" },
        { "Typeface name": "Webdings", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "128660", "Unicode hex": "1F694" },
        { "Typeface name": "Webdings", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "128472", "Unicode hex": "1F5D8" },
        { "Typeface name": "Webdings", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "128473", "Unicode hex": "1F5D9" },
        { "Typeface name": "Webdings", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "10067", "Unicode hex": "2753" },
        { "Typeface name": "Webdings", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "128754", "Unicode hex": "1F6F2" },
        { "Typeface name": "Webdings", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "128647", "Unicode hex": "1F687" },
        { "Typeface name": "Webdings", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "128653", "Unicode hex": "1F68D" },
        { "Typeface name": "Webdings", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "9971", "Unicode hex": "26F3" },
        { "Typeface name": "Webdings", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "10680", "Unicode hex": "29B8" },
        { "Typeface name": "Webdings", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "8854", "Unicode hex": "2296" },
        { "Typeface name": "Webdings", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "128685", "Unicode hex": "1F6AD" },
        { "Typeface name": "Webdings", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "128494", "Unicode hex": "1F5EE" },
        { "Typeface name": "Webdings", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "9168", "Unicode hex": "23D0" },
        { "Typeface name": "Webdings", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "128495", "Unicode hex": "1F5EF" },
        { "Typeface name": "Webdings", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "128498", "Unicode hex": "1F5F2" },
        { "Typeface name": "Webdings", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "128697", "Unicode hex": "1F6B9" },
        { "Typeface name": "Webdings", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "128698", "Unicode hex": "1F6BA" },
        { "Typeface name": "Webdings", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "128713", "Unicode hex": "1F6C9" },
        { "Typeface name": "Webdings", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "128714", "Unicode hex": "1F6CA" },
        { "Typeface name": "Webdings", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "128700", "Unicode hex": "1F6BC" },
        { "Typeface name": "Webdings", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "128125", "Unicode hex": "1F47D" },
        { "Typeface name": "Webdings", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "127947", "Unicode hex": "1F3CB" },
        { "Typeface name": "Webdings", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "9975", "Unicode hex": "26F7" },
        { "Typeface name": "Webdings", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "127938", "Unicode hex": "1F3C2" },
        { "Typeface name": "Webdings", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "127948", "Unicode hex": "1F3CC" },
        { "Typeface name": "Webdings", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "127946", "Unicode hex": "1F3CA" },
        { "Typeface name": "Webdings", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "127940", "Unicode hex": "1F3C4" },
        { "Typeface name": "Webdings", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "127949", "Unicode hex": "1F3CD" },
        { "Typeface name": "Webdings", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "127950", "Unicode hex": "1F3CE" },
        { "Typeface name": "Webdings", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "128664", "Unicode hex": "1F698" },
        { "Typeface name": "Webdings", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "128480", "Unicode hex": "1F5E0" },
        { "Typeface name": "Webdings", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "128738", "Unicode hex": "1F6E2" },
        { "Typeface name": "Webdings", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "128176", "Unicode hex": "1F4B0" },
        { "Typeface name": "Webdings", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "127991", "Unicode hex": "1F3F7" },
        { "Typeface name": "Webdings", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "128179", "Unicode hex": "1F4B3" },
        { "Typeface name": "Webdings", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "128106", "Unicode hex": "1F46A" },
        { "Typeface name": "Webdings", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "128481", "Unicode hex": "1F5E1" },
        { "Typeface name": "Webdings", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "128482", "Unicode hex": "1F5E2" },
        { "Typeface name": "Webdings", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "128483", "Unicode hex": "1F5E3" },
        { "Typeface name": "Webdings", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "10031", "Unicode hex": "272F" },
        { "Typeface name": "Webdings", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "128388", "Unicode hex": "1F584" },
        { "Typeface name": "Webdings", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "128389", "Unicode hex": "1F585" },
        { "Typeface name": "Webdings", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "128387", "Unicode hex": "1F583" },
        { "Typeface name": "Webdings", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "128390", "Unicode hex": "1F586" },
        { "Typeface name": "Webdings", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "128441", "Unicode hex": "1F5B9" },
        { "Typeface name": "Webdings", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "128442", "Unicode hex": "1F5BA" },
        { "Typeface name": "Webdings", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "128443", "Unicode hex": "1F5BB" },
        { "Typeface name": "Webdings", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "128373", "Unicode hex": "1F575" },
        { "Typeface name": "Webdings", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "128368", "Unicode hex": "1F570" },
        { "Typeface name": "Webdings", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "128445", "Unicode hex": "1F5BD" },
        { "Typeface name": "Webdings", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "128446", "Unicode hex": "1F5BE" },
        { "Typeface name": "Webdings", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "128203", "Unicode hex": "1F4CB" },
        { "Typeface name": "Webdings", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "128466", "Unicode hex": "1F5D2" },
        { "Typeface name": "Webdings", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "128467", "Unicode hex": "1F5D3" },
        { "Typeface name": "Webdings", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "128366", "Unicode hex": "1F56E" },
        { "Typeface name": "Webdings", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "128218", "Unicode hex": "1F4DA" },
        { "Typeface name": "Webdings", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "128478", "Unicode hex": "1F5DE" },
        { "Typeface name": "Webdings", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "128479", "Unicode hex": "1F5DF" },
        { "Typeface name": "Webdings", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "128451", "Unicode hex": "1F5C3" },
        { "Typeface name": "Webdings", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "128450", "Unicode hex": "1F5C2" },
        { "Typeface name": "Webdings", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "128444", "Unicode hex": "1F5BC" },
        { "Typeface name": "Webdings", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "127917", "Unicode hex": "1F3AD" },
        { "Typeface name": "Webdings", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "127900", "Unicode hex": "1F39C" },
        { "Typeface name": "Webdings", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "127896", "Unicode hex": "1F398" },
        { "Typeface name": "Webdings", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "127897", "Unicode hex": "1F399" },
        { "Typeface name": "Webdings", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "127911", "Unicode hex": "1F3A7" },
        { "Typeface name": "Webdings", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "128191", "Unicode hex": "1F4BF" },
        { "Typeface name": "Webdings", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "127902", "Unicode hex": "1F39E" },
        { "Typeface name": "Webdings", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "128247", "Unicode hex": "1F4F7" },
        { "Typeface name": "Webdings", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "127903", "Unicode hex": "1F39F" },
        { "Typeface name": "Webdings", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "127916", "Unicode hex": "1F3AC" },
        { "Typeface name": "Webdings", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "128253", "Unicode hex": "1F4FD" },
        { "Typeface name": "Webdings", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "128249", "Unicode hex": "1F4F9" },
        { "Typeface name": "Webdings", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "128254", "Unicode hex": "1F4FE" },
        { "Typeface name": "Webdings", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "128251", "Unicode hex": "1F4FB" },
        { "Typeface name": "Webdings", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "127898", "Unicode hex": "1F39A" },
        { "Typeface name": "Webdings", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "127899", "Unicode hex": "1F39B" },
        { "Typeface name": "Webdings", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "128250", "Unicode hex": "1F4FA" },
        { "Typeface name": "Webdings", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "128187", "Unicode hex": "1F4BB" },
        { "Typeface name": "Webdings", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "128421", "Unicode hex": "1F5A5" },
        { "Typeface name": "Webdings", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "128422", "Unicode hex": "1F5A6" },
        { "Typeface name": "Webdings", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "128423", "Unicode hex": "1F5A7" },
        { "Typeface name": "Webdings", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "128377", "Unicode hex": "1F579" },
        { "Typeface name": "Webdings", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "127918", "Unicode hex": "1F3AE" },
        { "Typeface name": "Webdings", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "128379", "Unicode hex": "1F57B" },
        { "Typeface name": "Webdings", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "128380", "Unicode hex": "1F57C" },
        { "Typeface name": "Webdings", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "128223", "Unicode hex": "1F4DF" },
        { "Typeface name": "Webdings", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "128385", "Unicode hex": "1F581" },
        { "Typeface name": "Webdings", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "128384", "Unicode hex": "1F580" },
        { "Typeface name": "Webdings", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "128424", "Unicode hex": "1F5A8" },
        { "Typeface name": "Webdings", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "128425", "Unicode hex": "1F5A9" },
        { "Typeface name": "Webdings", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "128447", "Unicode hex": "1F5BF" },
        { "Typeface name": "Webdings", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "128426", "Unicode hex": "1F5AA" },
        { "Typeface name": "Webdings", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "128476", "Unicode hex": "1F5DC" },
        { "Typeface name": "Webdings", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "128274", "Unicode hex": "1F512" },
        { "Typeface name": "Webdings", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "128275", "Unicode hex": "1F513" },
        { "Typeface name": "Webdings", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "128477", "Unicode hex": "1F5DD" },
        { "Typeface name": "Webdings", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "128229", "Unicode hex": "1F4E5" },
        { "Typeface name": "Webdings", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "128228", "Unicode hex": "1F4E4" },
        { "Typeface name": "Webdings", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "128371", "Unicode hex": "1F573" },
        { "Typeface name": "Webdings", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "127779", "Unicode hex": "1F323" },
        { "Typeface name": "Webdings", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "127780", "Unicode hex": "1F324" },
        { "Typeface name": "Webdings", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "127781", "Unicode hex": "1F325" },
        { "Typeface name": "Webdings", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "127782", "Unicode hex": "1F326" },
        { "Typeface name": "Webdings", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "9729", "Unicode hex": "2601" },
        { "Typeface name": "Webdings", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "127784", "Unicode hex": "1F328" },
        { "Typeface name": "Webdings", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "127783", "Unicode hex": "1F327" },
        { "Typeface name": "Webdings", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "127785", "Unicode hex": "1F329" },
        { "Typeface name": "Webdings", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "127786", "Unicode hex": "1F32A" },
        { "Typeface name": "Webdings", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "127788", "Unicode hex": "1F32C" },
        { "Typeface name": "Webdings", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "127787", "Unicode hex": "1F32B" },
        { "Typeface name": "Webdings", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "127772", "Unicode hex": "1F31C" },
        { "Typeface name": "Webdings", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "127777", "Unicode hex": "1F321" },
        { "Typeface name": "Webdings", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "128715", "Unicode hex": "1F6CB" },
        { "Typeface name": "Webdings", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "128719", "Unicode hex": "1F6CF" },
        { "Typeface name": "Webdings", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "127869", "Unicode hex": "1F37D" },
        { "Typeface name": "Webdings", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "127864", "Unicode hex": "1F378" },
        { "Typeface name": "Webdings", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "128718", "Unicode hex": "1F6CE" },
        { "Typeface name": "Webdings", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "128717", "Unicode hex": "1F6CD" },
        { "Typeface name": "Webdings", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "9413", "Unicode hex": "24C5" },
        { "Typeface name": "Webdings", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "9855", "Unicode hex": "267F" },
        { "Typeface name": "Webdings", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "128710", "Unicode hex": "1F6C6" },
        { "Typeface name": "Webdings", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "128392", "Unicode hex": "1F588" },
        { "Typeface name": "Webdings", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "127891", "Unicode hex": "1F393" },
        { "Typeface name": "Webdings", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "128484", "Unicode hex": "1F5E4" },
        { "Typeface name": "Webdings", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "128485", "Unicode hex": "1F5E5" },
        { "Typeface name": "Webdings", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "128486", "Unicode hex": "1F5E6" },
        { "Typeface name": "Webdings", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "128487", "Unicode hex": "1F5E7" },
        { "Typeface name": "Webdings", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "128746", "Unicode hex": "1F6EA" },
        { "Typeface name": "Webdings", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "128063", "Unicode hex": "1F43F" },
        { "Typeface name": "Webdings", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "128038", "Unicode hex": "1F426" },
        { "Typeface name": "Webdings", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "128031", "Unicode hex": "1F41F" },
        { "Typeface name": "Webdings", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "128021", "Unicode hex": "1F415" },
        { "Typeface name": "Webdings", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "128008", "Unicode hex": "1F408" },
        { "Typeface name": "Webdings", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "128620", "Unicode hex": "1F66C" },
        { "Typeface name": "Webdings", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "128622", "Unicode hex": "1F66E" },
        { "Typeface name": "Webdings", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "128621", "Unicode hex": "1F66D" },
        { "Typeface name": "Webdings", "Dingbat dec": "250", "Dingbat hex": "FA", "Unicode dec": "128623", "Unicode hex": "1F66F" },
        { "Typeface name": "Webdings", "Dingbat dec": "251", "Dingbat hex": "FB", "Unicode dec": "128506", "Unicode hex": "1F5FA" },
        { "Typeface name": "Webdings", "Dingbat dec": "252", "Dingbat hex": "FC", "Unicode dec": "127757", "Unicode hex": "1F30D" },
        { "Typeface name": "Webdings", "Dingbat dec": "253", "Dingbat hex": "FD", "Unicode dec": "127759", "Unicode hex": "1F30F" },
        { "Typeface name": "Webdings", "Dingbat dec": "254", "Dingbat hex": "FE", "Unicode dec": "127758", "Unicode hex": "1F30E" },
        { "Typeface name": "Webdings", "Dingbat dec": "255", "Dingbat hex": "FF", "Unicode dec": "128330", "Unicode hex": "1F54A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
        { "Typeface name": "Wingdings", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "128393", "Unicode hex": "1F589" },
        { "Typeface name": "Wingdings", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "9986", "Unicode hex": "2702" },
        { "Typeface name": "Wingdings", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "9985", "Unicode hex": "2701" },
        { "Typeface name": "Wingdings", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "128083", "Unicode hex": "1F453" },
        { "Typeface name": "Wingdings", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "128365", "Unicode hex": "1F56D" },
        { "Typeface name": "Wingdings", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "128366", "Unicode hex": "1F56E" },
        { "Typeface name": "Wingdings", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "128367", "Unicode hex": "1F56F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "128383", "Unicode hex": "1F57F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "9990", "Unicode hex": "2706" },
        { "Typeface name": "Wingdings", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "128386", "Unicode hex": "1F582" },
        { "Typeface name": "Wingdings", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "128387", "Unicode hex": "1F583" },
        { "Typeface name": "Wingdings", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "128234", "Unicode hex": "1F4EA" },
        { "Typeface name": "Wingdings", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "128235", "Unicode hex": "1F4EB" },
        { "Typeface name": "Wingdings", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "128236", "Unicode hex": "1F4EC" },
        { "Typeface name": "Wingdings", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "128237", "Unicode hex": "1F4ED" },
        { "Typeface name": "Wingdings", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "128448", "Unicode hex": "1F5C0" },
        { "Typeface name": "Wingdings", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "128449", "Unicode hex": "1F5C1" },
        { "Typeface name": "Wingdings", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "128462", "Unicode hex": "1F5CE" },
        { "Typeface name": "Wingdings", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "128463", "Unicode hex": "1F5CF" },
        { "Typeface name": "Wingdings", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "128464", "Unicode hex": "1F5D0" },
        { "Typeface name": "Wingdings", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "128452", "Unicode hex": "1F5C4" },
        { "Typeface name": "Wingdings", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "8987", "Unicode hex": "231B" },
        { "Typeface name": "Wingdings", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "128430", "Unicode hex": "1F5AE" },
        { "Typeface name": "Wingdings", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "128432", "Unicode hex": "1F5B0" },
        { "Typeface name": "Wingdings", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "128434", "Unicode hex": "1F5B2" },
        { "Typeface name": "Wingdings", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "128435", "Unicode hex": "1F5B3" },
        { "Typeface name": "Wingdings", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "128436", "Unicode hex": "1F5B4" },
        { "Typeface name": "Wingdings", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "128427", "Unicode hex": "1F5AB" },
        { "Typeface name": "Wingdings", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "128428", "Unicode hex": "1F5AC" },
        { "Typeface name": "Wingdings", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "9991", "Unicode hex": "2707" },
        { "Typeface name": "Wingdings", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "9997", "Unicode hex": "270D" },
        { "Typeface name": "Wingdings", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "128398", "Unicode hex": "1F58E" },
        { "Typeface name": "Wingdings", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "9996", "Unicode hex": "270C" },
        { "Typeface name": "Wingdings", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "128399", "Unicode hex": "1F58F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "128077", "Unicode hex": "1F44D" },
        { "Typeface name": "Wingdings", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "128078", "Unicode hex": "1F44E" },
        { "Typeface name": "Wingdings", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "9756", "Unicode hex": "261C" },
        { "Typeface name": "Wingdings", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "9758", "Unicode hex": "261E" },
        { "Typeface name": "Wingdings", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "9757", "Unicode hex": "261D" },
        { "Typeface name": "Wingdings", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "9759", "Unicode hex": "261F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "128400", "Unicode hex": "1F590" },
        { "Typeface name": "Wingdings", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "9786", "Unicode hex": "263A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "128528", "Unicode hex": "1F610" },
        { "Typeface name": "Wingdings", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "9785", "Unicode hex": "2639" },
        { "Typeface name": "Wingdings", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "128163", "Unicode hex": "1F4A3" },
        { "Typeface name": "Wingdings", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "128369", "Unicode hex": "1F571" },
        { "Typeface name": "Wingdings", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "127987", "Unicode hex": "1F3F3" },
        { "Typeface name": "Wingdings", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "127985", "Unicode hex": "1F3F1" },
        { "Typeface name": "Wingdings", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "9992", "Unicode hex": "2708" },
        { "Typeface name": "Wingdings", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "9788", "Unicode hex": "263C" },
        { "Typeface name": "Wingdings", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "127778", "Unicode hex": "1F322" },
        { "Typeface name": "Wingdings", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "10052", "Unicode hex": "2744" },
        { "Typeface name": "Wingdings", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "128326", "Unicode hex": "1F546" },
        { "Typeface name": "Wingdings", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "10014", "Unicode hex": "271E" },
        { "Typeface name": "Wingdings", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "128328", "Unicode hex": "1F548" },
        { "Typeface name": "Wingdings", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "10016", "Unicode hex": "2720" },
        { "Typeface name": "Wingdings", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "10017", "Unicode hex": "2721" },
        { "Typeface name": "Wingdings", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "9770", "Unicode hex": "262A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "9775", "Unicode hex": "262F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "128329", "Unicode hex": "1F549" },
        { "Typeface name": "Wingdings", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "9784", "Unicode hex": "2638" },
        { "Typeface name": "Wingdings", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "9800", "Unicode hex": "2648" },
        { "Typeface name": "Wingdings", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "9801", "Unicode hex": "2649" },
        { "Typeface name": "Wingdings", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "9802", "Unicode hex": "264A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "9803", "Unicode hex": "264B" },
        { "Typeface name": "Wingdings", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "9804", "Unicode hex": "264C" },
        { "Typeface name": "Wingdings", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "9805", "Unicode hex": "264D" },
        { "Typeface name": "Wingdings", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "9806", "Unicode hex": "264E" },
        { "Typeface name": "Wingdings", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "9807", "Unicode hex": "264F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "9808", "Unicode hex": "2650" },
        { "Typeface name": "Wingdings", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "9809", "Unicode hex": "2651" },
        { "Typeface name": "Wingdings", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "9810", "Unicode hex": "2652" },
        { "Typeface name": "Wingdings", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "9811", "Unicode hex": "2653" },
        { "Typeface name": "Wingdings", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "128624", "Unicode hex": "1F670" },
        { "Typeface name": "Wingdings", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "128629", "Unicode hex": "1F675" },
        { "Typeface name": "Wingdings", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "9899", "Unicode hex": "26AB" },
        { "Typeface name": "Wingdings", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "128318", "Unicode hex": "1F53E" },
        { "Typeface name": "Wingdings", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "9724", "Unicode hex": "25FC" },
        { "Typeface name": "Wingdings", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "128911", "Unicode hex": "1F78F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "128912", "Unicode hex": "1F790" },
        { "Typeface name": "Wingdings", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "10065", "Unicode hex": "2751" },
        { "Typeface name": "Wingdings", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "10066", "Unicode hex": "2752" },
        { "Typeface name": "Wingdings", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "128927", "Unicode hex": "1F79F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "10731", "Unicode hex": "29EB" },
        { "Typeface name": "Wingdings", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "9670", "Unicode hex": "25C6" },
        { "Typeface name": "Wingdings", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "10070", "Unicode hex": "2756" },
        { "Typeface name": "Wingdings", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "11049", "Unicode hex": "2B29" },
        { "Typeface name": "Wingdings", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "8999", "Unicode hex": "2327" },
        { "Typeface name": "Wingdings", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "11193", "Unicode hex": "2BB9" },
        { "Typeface name": "Wingdings", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "8984", "Unicode hex": "2318" },
        { "Typeface name": "Wingdings", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "127989", "Unicode hex": "1F3F5" },
        { "Typeface name": "Wingdings", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "127990", "Unicode hex": "1F3F6" },
        { "Typeface name": "Wingdings", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "128630", "Unicode hex": "1F676" },
        { "Typeface name": "Wingdings", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "128631", "Unicode hex": "1F677" },
        { "Typeface name": "Wingdings", "Dingbat dec": "127", "Dingbat hex": "7F", "Unicode dec": "9647", "Unicode hex": "25AF" },
        { "Typeface name": "Wingdings", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "127243", "Unicode hex": "1F10B" },
        { "Typeface name": "Wingdings", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "10112", "Unicode hex": "2780" },
        { "Typeface name": "Wingdings", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "10113", "Unicode hex": "2781" },
        { "Typeface name": "Wingdings", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "10114", "Unicode hex": "2782" },
        { "Typeface name": "Wingdings", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "10115", "Unicode hex": "2783" },
        { "Typeface name": "Wingdings", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "10116", "Unicode hex": "2784" },
        { "Typeface name": "Wingdings", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "10117", "Unicode hex": "2785" },
        { "Typeface name": "Wingdings", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "10118", "Unicode hex": "2786" },
        { "Typeface name": "Wingdings", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "10119", "Unicode hex": "2787" },
        { "Typeface name": "Wingdings", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "10120", "Unicode hex": "2788" },
        { "Typeface name": "Wingdings", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "10121", "Unicode hex": "2789" },
        { "Typeface name": "Wingdings", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "127244", "Unicode hex": "1F10C" },
        { "Typeface name": "Wingdings", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "10122", "Unicode hex": "278A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "10123", "Unicode hex": "278B" },
        { "Typeface name": "Wingdings", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "10124", "Unicode hex": "278C" },
        { "Typeface name": "Wingdings", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "10125", "Unicode hex": "278D" },
        { "Typeface name": "Wingdings", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "10126", "Unicode hex": "278E" },
        { "Typeface name": "Wingdings", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "10127", "Unicode hex": "278F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "10128", "Unicode hex": "2790" },
        { "Typeface name": "Wingdings", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "10129", "Unicode hex": "2791" },
        { "Typeface name": "Wingdings", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "10130", "Unicode hex": "2792" },
        { "Typeface name": "Wingdings", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "10131", "Unicode hex": "2793" },
        { "Typeface name": "Wingdings", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "128610", "Unicode hex": "1F662" },
        { "Typeface name": "Wingdings", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "128608", "Unicode hex": "1F660" },
        { "Typeface name": "Wingdings", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "128609", "Unicode hex": "1F661" },
        { "Typeface name": "Wingdings", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "128611", "Unicode hex": "1F663" },
        { "Typeface name": "Wingdings", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "128606", "Unicode hex": "1F65E" },
        { "Typeface name": "Wingdings", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "128604", "Unicode hex": "1F65C" },
        { "Typeface name": "Wingdings", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "128605", "Unicode hex": "1F65D" },
        { "Typeface name": "Wingdings", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "128607", "Unicode hex": "1F65F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "8729", "Unicode hex": "2219" },
        { "Typeface name": "Wingdings", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "8226", "Unicode hex": "2022" },
        { "Typeface name": "Wingdings", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "11037", "Unicode hex": "2B1D" },
        { "Typeface name": "Wingdings", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "11096", "Unicode hex": "2B58" },
        { "Typeface name": "Wingdings", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "128902", "Unicode hex": "1F786" },
        { "Typeface name": "Wingdings", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "128904", "Unicode hex": "1F788" },
        { "Typeface name": "Wingdings", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "128906", "Unicode hex": "1F78A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "128907", "Unicode hex": "1F78B" },
        { "Typeface name": "Wingdings", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "128319", "Unicode hex": "1F53F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "9642", "Unicode hex": "25AA" },
        { "Typeface name": "Wingdings", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "128910", "Unicode hex": "1F78E" },
        { "Typeface name": "Wingdings", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "128961", "Unicode hex": "1F7C1" },
        { "Typeface name": "Wingdings", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "128965", "Unicode hex": "1F7C5" },
        { "Typeface name": "Wingdings", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "9733", "Unicode hex": "2605" },
        { "Typeface name": "Wingdings", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "128971", "Unicode hex": "1F7CB" },
        { "Typeface name": "Wingdings", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "128975", "Unicode hex": "1F7CF" },
        { "Typeface name": "Wingdings", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "128979", "Unicode hex": "1F7D3" },
        { "Typeface name": "Wingdings", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "128977", "Unicode hex": "1F7D1" },
        { "Typeface name": "Wingdings", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "11216", "Unicode hex": "2BD0" },
        { "Typeface name": "Wingdings", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "8982", "Unicode hex": "2316" },
        { "Typeface name": "Wingdings", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "11214", "Unicode hex": "2BCE" },
        { "Typeface name": "Wingdings", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "11215", "Unicode hex": "2BCF" },
        { "Typeface name": "Wingdings", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "11217", "Unicode hex": "2BD1" },
        { "Typeface name": "Wingdings", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "10026", "Unicode hex": "272A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "10032", "Unicode hex": "2730" },
        { "Typeface name": "Wingdings", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "128336", "Unicode hex": "1F550" },
        { "Typeface name": "Wingdings", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "128337", "Unicode hex": "1F551" },
        { "Typeface name": "Wingdings", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "128338", "Unicode hex": "1F552" },
        { "Typeface name": "Wingdings", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "128339", "Unicode hex": "1F553" },
        { "Typeface name": "Wingdings", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "128340", "Unicode hex": "1F554" },
        { "Typeface name": "Wingdings", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "128341", "Unicode hex": "1F555" },
        { "Typeface name": "Wingdings", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "128342", "Unicode hex": "1F556" },
        { "Typeface name": "Wingdings", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "128343", "Unicode hex": "1F557" },
        { "Typeface name": "Wingdings", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "128344", "Unicode hex": "1F558" },
        { "Typeface name": "Wingdings", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "128345", "Unicode hex": "1F559" },
        { "Typeface name": "Wingdings", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "128346", "Unicode hex": "1F55A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "128347", "Unicode hex": "1F55B" },
        { "Typeface name": "Wingdings", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "11184", "Unicode hex": "2BB0" },
        { "Typeface name": "Wingdings", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "11185", "Unicode hex": "2BB1" },
        { "Typeface name": "Wingdings", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "11186", "Unicode hex": "2BB2" },
        { "Typeface name": "Wingdings", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "11187", "Unicode hex": "2BB3" },
        { "Typeface name": "Wingdings", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "11188", "Unicode hex": "2BB4" },
        { "Typeface name": "Wingdings", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "11189", "Unicode hex": "2BB5" },
        { "Typeface name": "Wingdings", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "11190", "Unicode hex": "2BB6" },
        { "Typeface name": "Wingdings", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "11191", "Unicode hex": "2BB7" },
        { "Typeface name": "Wingdings", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "128618", "Unicode hex": "1F66A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "128619", "Unicode hex": "1F66B" },
        { "Typeface name": "Wingdings", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "128597", "Unicode hex": "1F655" },
        { "Typeface name": "Wingdings", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "128596", "Unicode hex": "1F654" },
        { "Typeface name": "Wingdings", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "128599", "Unicode hex": "1F657" },
        { "Typeface name": "Wingdings", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "128598", "Unicode hex": "1F656" },
        { "Typeface name": "Wingdings", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "128592", "Unicode hex": "1F650" },
        { "Typeface name": "Wingdings", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "128593", "Unicode hex": "1F651" },
        { "Typeface name": "Wingdings", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "128594", "Unicode hex": "1F652" },
        { "Typeface name": "Wingdings", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "128595", "Unicode hex": "1F653" },
        { "Typeface name": "Wingdings", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "9003", "Unicode hex": "232B" },
        { "Typeface name": "Wingdings", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "8998", "Unicode hex": "2326" },
        { "Typeface name": "Wingdings", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "11160", "Unicode hex": "2B98" },
        { "Typeface name": "Wingdings", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "11162", "Unicode hex": "2B9A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "11161", "Unicode hex": "2B99" },
        { "Typeface name": "Wingdings", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "11163", "Unicode hex": "2B9B" },
        { "Typeface name": "Wingdings", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "11144", "Unicode hex": "2B88" },
        { "Typeface name": "Wingdings", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "11146", "Unicode hex": "2B8A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "11145", "Unicode hex": "2B89" },
        { "Typeface name": "Wingdings", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "11147", "Unicode hex": "2B8B" },
        { "Typeface name": "Wingdings", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "129128", "Unicode hex": "1F868" },
        { "Typeface name": "Wingdings", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "129130", "Unicode hex": "1F86A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "129129", "Unicode hex": "1F869" },
        { "Typeface name": "Wingdings", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "129131", "Unicode hex": "1F86B" },
        { "Typeface name": "Wingdings", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "129132", "Unicode hex": "1F86C" },
        { "Typeface name": "Wingdings", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "129133", "Unicode hex": "1F86D" },
        { "Typeface name": "Wingdings", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "129135", "Unicode hex": "1F86F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "129134", "Unicode hex": "1F86E" },
        { "Typeface name": "Wingdings", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "129144", "Unicode hex": "1F878" },
        { "Typeface name": "Wingdings", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "129146", "Unicode hex": "1F87A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "129145", "Unicode hex": "1F879" },
        { "Typeface name": "Wingdings", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "129147", "Unicode hex": "1F87B" },
        { "Typeface name": "Wingdings", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "129148", "Unicode hex": "1F87C" },
        { "Typeface name": "Wingdings", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "129149", "Unicode hex": "1F87D" },
        { "Typeface name": "Wingdings", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "129151", "Unicode hex": "1F87F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "129150", "Unicode hex": "1F87E" },
        { "Typeface name": "Wingdings", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "8678", "Unicode hex": "21E6" },
        { "Typeface name": "Wingdings", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "8680", "Unicode hex": "21E8" },
        { "Typeface name": "Wingdings", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "8679", "Unicode hex": "21E7" },
        { "Typeface name": "Wingdings", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "8681", "Unicode hex": "21E9" },
        { "Typeface name": "Wingdings", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "11012", "Unicode hex": "2B04" },
        { "Typeface name": "Wingdings", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "8691", "Unicode hex": "21F3" },
        { "Typeface name": "Wingdings", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "11009", "Unicode hex": "2B01" },
        { "Typeface name": "Wingdings", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "11008", "Unicode hex": "2B00" },
        { "Typeface name": "Wingdings", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "11011", "Unicode hex": "2B03" },
        { "Typeface name": "Wingdings", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "11010", "Unicode hex": "2B02" },
        { "Typeface name": "Wingdings", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "129196", "Unicode hex": "1F8AC" },
        { "Typeface name": "Wingdings", "Dingbat dec": "250", "Dingbat hex": "FA", "Unicode dec": "129197", "Unicode hex": "1F8AD" },
        { "Typeface name": "Wingdings", "Dingbat dec": "251", "Dingbat hex": "FB", "Unicode dec": "128502", "Unicode hex": "1F5F6" },
        { "Typeface name": "Wingdings", "Dingbat dec": "252", "Dingbat hex": "FC", "Unicode dec": "10003", "Unicode hex": "2713" },
        { "Typeface name": "Wingdings", "Dingbat dec": "253", "Dingbat hex": "FD", "Unicode dec": "128503", "Unicode hex": "1F5F7" },
        { "Typeface name": "Wingdings", "Dingbat dec": "254", "Dingbat hex": "FE", "Unicode dec": "128505", "Unicode hex": "1F5F9" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "128394", "Unicode hex": "1F58A" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "128395", "Unicode hex": "1F58B" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "128396", "Unicode hex": "1F58C" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "128397", "Unicode hex": "1F58D" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "9988", "Unicode hex": "2704" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "9984", "Unicode hex": "2700" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "128382", "Unicode hex": "1F57E" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "128381", "Unicode hex": "1F57D" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "128453", "Unicode hex": "1F5C5" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "128454", "Unicode hex": "1F5C6" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "128455", "Unicode hex": "1F5C7" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "128456", "Unicode hex": "1F5C8" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "128457", "Unicode hex": "1F5C9" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "128458", "Unicode hex": "1F5CA" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "128459", "Unicode hex": "1F5CB" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "128460", "Unicode hex": "1F5CC" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "128461", "Unicode hex": "1F5CD" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "128203", "Unicode hex": "1F4CB" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "128465", "Unicode hex": "1F5D1" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "128468", "Unicode hex": "1F5D4" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "128437", "Unicode hex": "1F5B5" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "128438", "Unicode hex": "1F5B6" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "128439", "Unicode hex": "1F5B7" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "128440", "Unicode hex": "1F5B8" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "128429", "Unicode hex": "1F5AD" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "128431", "Unicode hex": "1F5AF" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "128433", "Unicode hex": "1F5B1" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "128402", "Unicode hex": "1F592" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "128403", "Unicode hex": "1F593" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "128408", "Unicode hex": "1F598" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "128409", "Unicode hex": "1F599" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "128410", "Unicode hex": "1F59A" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "128411", "Unicode hex": "1F59B" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "128072", "Unicode hex": "1F448" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "128073", "Unicode hex": "1F449" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "128412", "Unicode hex": "1F59C" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "128413", "Unicode hex": "1F59D" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "128414", "Unicode hex": "1F59E" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "128415", "Unicode hex": "1F59F" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "128416", "Unicode hex": "1F5A0" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "128417", "Unicode hex": "1F5A1" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "128070", "Unicode hex": "1F446" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "128071", "Unicode hex": "1F447" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "128418", "Unicode hex": "1F5A2" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "128419", "Unicode hex": "1F5A3" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "128401", "Unicode hex": "1F591" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "128500", "Unicode hex": "1F5F4" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "128504", "Unicode hex": "1F5F8" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "128501", "Unicode hex": "1F5F5" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "9745", "Unicode hex": "2611" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "11197", "Unicode hex": "2BBD" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "9746", "Unicode hex": "2612" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "11198", "Unicode hex": "2BBE" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "11199", "Unicode hex": "2BBF" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "128711", "Unicode hex": "1F6C7" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "10680", "Unicode hex": "29B8" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "128625", "Unicode hex": "1F671" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "128628", "Unicode hex": "1F674" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "128626", "Unicode hex": "1F672" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "128627", "Unicode hex": "1F673" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "8253", "Unicode hex": "203D" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "128633", "Unicode hex": "1F679" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "128634", "Unicode hex": "1F67A" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "128635", "Unicode hex": "1F67B" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "128614", "Unicode hex": "1F666" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "128612", "Unicode hex": "1F664" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "128613", "Unicode hex": "1F665" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "128615", "Unicode hex": "1F667" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "128602", "Unicode hex": "1F65A" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "128600", "Unicode hex": "1F658" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "128601", "Unicode hex": "1F659" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "128603", "Unicode hex": "1F65B" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "9450", "Unicode hex": "24EA" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "9312", "Unicode hex": "2460" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "9313", "Unicode hex": "2461" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "9314", "Unicode hex": "2462" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "9315", "Unicode hex": "2463" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "9316", "Unicode hex": "2464" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "9317", "Unicode hex": "2465" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "9318", "Unicode hex": "2466" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "9319", "Unicode hex": "2467" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "9320", "Unicode hex": "2468" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "9321", "Unicode hex": "2469" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "9471", "Unicode hex": "24FF" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "10102", "Unicode hex": "2776" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "10103", "Unicode hex": "2777" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "10104", "Unicode hex": "2778" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "10105", "Unicode hex": "2779" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "10106", "Unicode hex": "277A" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "10107", "Unicode hex": "277B" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "10108", "Unicode hex": "277C" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "10109", "Unicode hex": "277D" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "10110", "Unicode hex": "277E" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "10111", "Unicode hex": "277F" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "9737", "Unicode hex": "2609" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "127765", "Unicode hex": "1F315" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "9789", "Unicode hex": "263D" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "9790", "Unicode hex": "263E" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "11839", "Unicode hex": "2E3F" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "10013", "Unicode hex": "271D" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "128327", "Unicode hex": "1F547" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "128348", "Unicode hex": "1F55C" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "128349", "Unicode hex": "1F55D" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "128350", "Unicode hex": "1F55E" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "128351", "Unicode hex": "1F55F" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "128352", "Unicode hex": "1F560" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "128353", "Unicode hex": "1F561" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "128354", "Unicode hex": "1F562" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "128355", "Unicode hex": "1F563" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "128356", "Unicode hex": "1F564" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "128357", "Unicode hex": "1F565" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "128358", "Unicode hex": "1F566" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "128359", "Unicode hex": "1F567" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "128616", "Unicode hex": "1F668" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "128617", "Unicode hex": "1F669" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "8901", "Unicode hex": "22C5" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "128900", "Unicode hex": "1F784" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "10625", "Unicode hex": "2981" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "9679", "Unicode hex": "25CF" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "9675", "Unicode hex": "25CB" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "128901", "Unicode hex": "1F785" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "128903", "Unicode hex": "1F787" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "128905", "Unicode hex": "1F789" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "8857", "Unicode hex": "2299" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "10687", "Unicode hex": "29BF" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "128908", "Unicode hex": "1F78C" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "128909", "Unicode hex": "1F78D" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "9726", "Unicode hex": "25FE" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "9632", "Unicode hex": "25A0" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "9633", "Unicode hex": "25A1" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "128913", "Unicode hex": "1F791" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "128914", "Unicode hex": "1F792" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "128915", "Unicode hex": "1F793" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "128916", "Unicode hex": "1F794" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "9635", "Unicode hex": "25A3" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "128917", "Unicode hex": "1F795" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "128918", "Unicode hex": "1F796" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "128919", "Unicode hex": "1F797" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "128920", "Unicode hex": "1F798" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "11049", "Unicode hex": "2B29" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "11045", "Unicode hex": "2B25" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "9671", "Unicode hex": "25C7" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "128922", "Unicode hex": "1F79A" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "9672", "Unicode hex": "25C8" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "128923", "Unicode hex": "1F79B" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "128924", "Unicode hex": "1F79C" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "128925", "Unicode hex": "1F79D" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "128926", "Unicode hex": "1F79E" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "11050", "Unicode hex": "2B2A" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "11047", "Unicode hex": "2B27" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "9674", "Unicode hex": "25CA" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "128928", "Unicode hex": "1F7A0" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "9686", "Unicode hex": "25D6" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "9687", "Unicode hex": "25D7" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "11210", "Unicode hex": "2BCA" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "11211", "Unicode hex": "2BCB" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "11200", "Unicode hex": "2BC0" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "11201", "Unicode hex": "2BC1" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "11039", "Unicode hex": "2B1F" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "11202", "Unicode hex": "2BC2" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "11043", "Unicode hex": "2B23" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "11042", "Unicode hex": "2B22" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "11203", "Unicode hex": "2BC3" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "11204", "Unicode hex": "2BC4" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "128929", "Unicode hex": "1F7A1" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "128930", "Unicode hex": "1F7A2" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "128931", "Unicode hex": "1F7A3" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "128932", "Unicode hex": "1F7A4" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "128933", "Unicode hex": "1F7A5" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "128934", "Unicode hex": "1F7A6" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "128935", "Unicode hex": "1F7A7" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "128936", "Unicode hex": "1F7A8" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "128937", "Unicode hex": "1F7A9" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "128938", "Unicode hex": "1F7AA" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "128939", "Unicode hex": "1F7AB" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "128940", "Unicode hex": "1F7AC" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "128941", "Unicode hex": "1F7AD" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "128942", "Unicode hex": "1F7AE" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "128943", "Unicode hex": "1F7AF" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "128944", "Unicode hex": "1F7B0" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "128945", "Unicode hex": "1F7B1" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "128946", "Unicode hex": "1F7B2" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "128947", "Unicode hex": "1F7B3" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "128948", "Unicode hex": "1F7B4" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "128949", "Unicode hex": "1F7B5" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "128950", "Unicode hex": "1F7B6" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "128951", "Unicode hex": "1F7B7" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "128952", "Unicode hex": "1F7B8" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "128953", "Unicode hex": "1F7B9" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "128954", "Unicode hex": "1F7BA" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "128955", "Unicode hex": "1F7BB" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "128956", "Unicode hex": "1F7BC" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "128957", "Unicode hex": "1F7BD" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "128958", "Unicode hex": "1F7BE" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "128959", "Unicode hex": "1F7BF" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "128960", "Unicode hex": "1F7C0" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "128962", "Unicode hex": "1F7C2" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "128964", "Unicode hex": "1F7C4" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "128966", "Unicode hex": "1F7C6" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "128969", "Unicode hex": "1F7C9" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "128970", "Unicode hex": "1F7CA" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "10038", "Unicode hex": "2736" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "128972", "Unicode hex": "1F7CC" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "128974", "Unicode hex": "1F7CE" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "128976", "Unicode hex": "1F7D0" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "128978", "Unicode hex": "1F7D2" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "10041", "Unicode hex": "2739" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "128963", "Unicode hex": "1F7C3" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "128967", "Unicode hex": "1F7C7" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "10031", "Unicode hex": "272F" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "128973", "Unicode hex": "1F7CD" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "128980", "Unicode hex": "1F7D4" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "11212", "Unicode hex": "2BCC" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "11213", "Unicode hex": "2BCD" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "8251", "Unicode hex": "203B" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "8258", "Unicode hex": "2042" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "11104", "Unicode hex": "2B60" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "11106", "Unicode hex": "2B62" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "11105", "Unicode hex": "2B61" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "11107", "Unicode hex": "2B63" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "11110", "Unicode hex": "2B66" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "11111", "Unicode hex": "2B67" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "11113", "Unicode hex": "2B69" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "11112", "Unicode hex": "2B68" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "11120", "Unicode hex": "2B70" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "11122", "Unicode hex": "2B72" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "11121", "Unicode hex": "2B71" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "11123", "Unicode hex": "2B73" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "11126", "Unicode hex": "2B76" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "11128", "Unicode hex": "2B78" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "11131", "Unicode hex": "2B7B" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "11133", "Unicode hex": "2B7D" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "11108", "Unicode hex": "2B64" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "11109", "Unicode hex": "2B65" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "11114", "Unicode hex": "2B6A" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "11116", "Unicode hex": "2B6C" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "11115", "Unicode hex": "2B6B" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "11117", "Unicode hex": "2B6D" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "11085", "Unicode hex": "2B4D" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "11168", "Unicode hex": "2BA0" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "11169", "Unicode hex": "2BA1" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "11170", "Unicode hex": "2BA2" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "11171", "Unicode hex": "2BA3" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "11172", "Unicode hex": "2BA4" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "11173", "Unicode hex": "2BA5" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "11174", "Unicode hex": "2BA6" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "11175", "Unicode hex": "2BA7" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "11152", "Unicode hex": "2B90" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "11153", "Unicode hex": "2B91" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "11154", "Unicode hex": "2B92" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "11155", "Unicode hex": "2B93" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "11136", "Unicode hex": "2B80" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "11139", "Unicode hex": "2B83" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "11134", "Unicode hex": "2B7E" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "11135", "Unicode hex": "2B7F" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "11140", "Unicode hex": "2B84" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "11142", "Unicode hex": "2B86" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "11141", "Unicode hex": "2B85" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "11143", "Unicode hex": "2B87" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "11151", "Unicode hex": "2B8F" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "11149", "Unicode hex": "2B8D" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "11150", "Unicode hex": "2B8E" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "11148", "Unicode hex": "2B8C" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "11118", "Unicode hex": "2B6E" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "11119", "Unicode hex": "2B6F" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "9099", "Unicode hex": "238B" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "8996", "Unicode hex": "2324" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "8963", "Unicode hex": "2303" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "8997", "Unicode hex": "2325" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "9251", "Unicode hex": "2423" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "9085", "Unicode hex": "237D" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "8682", "Unicode hex": "21EA" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "11192", "Unicode hex": "2BB8" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "129184", "Unicode hex": "1F8A0" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "129185", "Unicode hex": "1F8A1" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "129186", "Unicode hex": "1F8A2" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "129187", "Unicode hex": "1F8A3" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "129188", "Unicode hex": "1F8A4" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "129189", "Unicode hex": "1F8A5" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "129190", "Unicode hex": "1F8A6" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "129191", "Unicode hex": "1F8A7" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "129192", "Unicode hex": "1F8A8" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "129193", "Unicode hex": "1F8A9" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "129194", "Unicode hex": "1F8AA" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "129195", "Unicode hex": "1F8AB" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "129104", "Unicode hex": "1F850" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "129106", "Unicode hex": "1F852" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "129105", "Unicode hex": "1F851" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "129107", "Unicode hex": "1F853" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "129108", "Unicode hex": "1F854" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "129109", "Unicode hex": "1F855" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "129111", "Unicode hex": "1F857" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "129110", "Unicode hex": "1F856" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "129112", "Unicode hex": "1F858" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "129113", "Unicode hex": "1F859" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "9650", "Unicode hex": "25B2" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "9660", "Unicode hex": "25BC" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "9651", "Unicode hex": "25B3" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "9661", "Unicode hex": "25BD" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "9664", "Unicode hex": "25C0" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "9654", "Unicode hex": "25B6" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "9665", "Unicode hex": "25C1" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "9655", "Unicode hex": "25B7" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "9699", "Unicode hex": "25E3" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "9698", "Unicode hex": "25E2" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "9700", "Unicode hex": "25E4" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "9701", "Unicode hex": "25E5" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "128896", "Unicode hex": "1F780" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "128898", "Unicode hex": "1F782" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "128897", "Unicode hex": "1F781" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "128899", "Unicode hex": "1F783" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "11205", "Unicode hex": "2BC5" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "11206", "Unicode hex": "2BC6" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "11207", "Unicode hex": "2BC7" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "11208", "Unicode hex": "2BC8" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "11164", "Unicode hex": "2B9C" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "11166", "Unicode hex": "2B9E" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "11165", "Unicode hex": "2B9D" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "11167", "Unicode hex": "2B9F" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "129040", "Unicode hex": "1F810" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "129042", "Unicode hex": "1F812" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "129041", "Unicode hex": "1F811" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "129043", "Unicode hex": "1F813" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "129044", "Unicode hex": "1F814" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "129046", "Unicode hex": "1F816" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "129045", "Unicode hex": "1F815" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "129047", "Unicode hex": "1F817" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "129048", "Unicode hex": "1F818" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "129050", "Unicode hex": "1F81A" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "129049", "Unicode hex": "1F819" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "129051", "Unicode hex": "1F81B" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "129052", "Unicode hex": "1F81C" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "129054", "Unicode hex": "1F81E" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "129053", "Unicode hex": "1F81D" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "129055", "Unicode hex": "1F81F" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "129024", "Unicode hex": "1F800" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "129026", "Unicode hex": "1F802" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "129025", "Unicode hex": "1F801" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "129027", "Unicode hex": "1F803" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "129028", "Unicode hex": "1F804" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "129030", "Unicode hex": "1F806" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "129029", "Unicode hex": "1F805" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "129031", "Unicode hex": "1F807" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "129032", "Unicode hex": "1F808" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "129034", "Unicode hex": "1F80A" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "129033", "Unicode hex": "1F809" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "129035", "Unicode hex": "1F80B" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "129056", "Unicode hex": "1F820" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "129058", "Unicode hex": "1F822" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "129060", "Unicode hex": "1F824" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "129062", "Unicode hex": "1F826" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "129064", "Unicode hex": "1F828" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "129066", "Unicode hex": "1F82A" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "129068", "Unicode hex": "1F82C" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "129180", "Unicode hex": "1F89C" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "129181", "Unicode hex": "1F89D" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "129182", "Unicode hex": "1F89E" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "129183", "Unicode hex": "1F89F" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "129070", "Unicode hex": "1F82E" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "129072", "Unicode hex": "1F830" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "129074", "Unicode hex": "1F832" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "129076", "Unicode hex": "1F834" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "129078", "Unicode hex": "1F836" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "129080", "Unicode hex": "1F838" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "129082", "Unicode hex": "1F83A" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "129081", "Unicode hex": "1F839" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "129083", "Unicode hex": "1F83B" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "129176", "Unicode hex": "1F898" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "129178", "Unicode hex": "1F89A" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "129177", "Unicode hex": "1F899" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "129179", "Unicode hex": "1F89B" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "129084", "Unicode hex": "1F83C" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "129086", "Unicode hex": "1F83E" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "129085", "Unicode hex": "1F83D" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "129087", "Unicode hex": "1F83F" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "129088", "Unicode hex": "1F840" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "129090", "Unicode hex": "1F842" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "129089", "Unicode hex": "1F841" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "129091", "Unicode hex": "1F843" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "129092", "Unicode hex": "1F844" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "129094", "Unicode hex": "1F846" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "129093", "Unicode hex": "1F845" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "129095", "Unicode hex": "1F847" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "11176", "Unicode hex": "2BA8" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "11177", "Unicode hex": "2BA9" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "11178", "Unicode hex": "2BAA" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "11179", "Unicode hex": "2BAB" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "11180", "Unicode hex": "2BAC" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "11181", "Unicode hex": "2BAD" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "11182", "Unicode hex": "2BAE" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "11183", "Unicode hex": "2BAF" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "129120", "Unicode hex": "1F860" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "129122", "Unicode hex": "1F862" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "129121", "Unicode hex": "1F861" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "129123", "Unicode hex": "1F863" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "129124", "Unicode hex": "1F864" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "129125", "Unicode hex": "1F865" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "129127", "Unicode hex": "1F867" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "129126", "Unicode hex": "1F866" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "129136", "Unicode hex": "1F870" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "129138", "Unicode hex": "1F872" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "129137", "Unicode hex": "1F871" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "129139", "Unicode hex": "1F873" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "129140", "Unicode hex": "1F874" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "129141", "Unicode hex": "1F875" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "129143", "Unicode hex": "1F877" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "129142", "Unicode hex": "1F876" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "129152", "Unicode hex": "1F880" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "129154", "Unicode hex": "1F882" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "129153", "Unicode hex": "1F881" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "129155", "Unicode hex": "1F883" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "129156", "Unicode hex": "1F884" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "129157", "Unicode hex": "1F885" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "129159", "Unicode hex": "1F887" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "129158", "Unicode hex": "1F886" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "129168", "Unicode hex": "1F890" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "129170", "Unicode hex": "1F892" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "129169", "Unicode hex": "1F891" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "129171", "Unicode hex": "1F893" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "129172", "Unicode hex": "1F894" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "129174", "Unicode hex": "1F896" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "129173", "Unicode hex": "1F895" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "129175", "Unicode hex": "1F897" }
      ];
      oe.default = se;
    }, {}], 81: [function(le, de, oe) {
      var se = this && this.__importDefault || function(d) {
        return d && d.__esModule ? d : { default: d };
      };
      Object.defineProperty(oe, "__esModule", { value: !0 }), oe.hex = oe.dec = oe.codePoint = void 0;
      for (var Q = se(le("./dingbats")), u = {}, P = String.fromCodePoint ? String.fromCodePoint : g, t = 0, i = Q.default; t < i.length; t++) {
        var v = i[t], a = parseInt(v["Unicode dec"], 10), e = {
          codePoint: a,
          string: P(a)
        };
        u[v["Typeface name"].toUpperCase() + "_" + v["Dingbat dec"]] = e;
      }
      function y(d, c) {
        return u[d.toUpperCase() + "_" + c];
      }
      oe.codePoint = y;
      function r(d, c) {
        return y(d, parseInt(c, 10));
      }
      oe.dec = r;
      function h(d, c) {
        return y(d, parseInt(c, 16));
      }
      oe.hex = h;
      function g(d) {
        if (d <= 65535)
          return String.fromCharCode(d);
        var c = Math.floor((d - 65536) / 1024) + 55296, n = (d - 65536) % 1024 + 56320;
        return String.fromCharCode(c, n);
      }
    }, { "./dingbats": 80 }], 82: [function(le, de, oe) {
      function se() {
        this._events = this._events || {}, this._maxListeners = this._maxListeners || void 0;
      }
      de.exports = se, se.EventEmitter = se, se.prototype._events = void 0, se.prototype._maxListeners = void 0, se.defaultMaxListeners = 10, se.prototype.setMaxListeners = function(i) {
        if (!u(i) || i < 0 || isNaN(i))
          throw TypeError("n must be a positive number");
        return this._maxListeners = i, this;
      }, se.prototype.emit = function(i) {
        var v, a, e, y, r, h;
        if (this._events || (this._events = {}), i === "error" && (!this._events.error || P(this._events.error) && !this._events.error.length)) {
          if (v = arguments[1], v instanceof Error)
            throw v;
          var g = new Error('Uncaught, unspecified "error" event. (' + v + ")");
          throw g.context = v, g;
        }
        if (a = this._events[i], t(a))
          return !1;
        if (Q(a))
          switch (arguments.length) {
            case 1:
              a.call(this);
              break;
            case 2:
              a.call(this, arguments[1]);
              break;
            case 3:
              a.call(this, arguments[1], arguments[2]);
              break;
            default:
              y = Array.prototype.slice.call(arguments, 1), a.apply(this, y);
          }
        else if (P(a))
          for (y = Array.prototype.slice.call(arguments, 1), h = a.slice(), e = h.length, r = 0; r < e; r++)
            h[r].apply(this, y);
        return !0;
      }, se.prototype.addListener = function(i, v) {
        var a;
        if (!Q(v))
          throw TypeError("listener must be a function");
        return this._events || (this._events = {}), this._events.newListener && this.emit(
          "newListener",
          i,
          Q(v.listener) ? v.listener : v
        ), this._events[i] ? P(this._events[i]) ? this._events[i].push(v) : this._events[i] = [this._events[i], v] : this._events[i] = v, P(this._events[i]) && !this._events[i].warned && (t(this._maxListeners) ? a = se.defaultMaxListeners : a = this._maxListeners, a && a > 0 && this._events[i].length > a && (this._events[i].warned = !0, console.error(
          "(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",
          this._events[i].length
        ), typeof console.trace == "function" && console.trace())), this;
      }, se.prototype.on = se.prototype.addListener, se.prototype.once = function(i, v) {
        if (!Q(v))
          throw TypeError("listener must be a function");
        var a = !1;
        function e() {
          this.removeListener(i, e), a || (a = !0, v.apply(this, arguments));
        }
        return e.listener = v, this.on(i, e), this;
      }, se.prototype.removeListener = function(i, v) {
        var a, e, y, r;
        if (!Q(v))
          throw TypeError("listener must be a function");
        if (!this._events || !this._events[i])
          return this;
        if (a = this._events[i], y = a.length, e = -1, a === v || Q(a.listener) && a.listener === v)
          delete this._events[i], this._events.removeListener && this.emit("removeListener", i, v);
        else if (P(a)) {
          for (r = y; r-- > 0; )
            if (a[r] === v || a[r].listener && a[r].listener === v) {
              e = r;
              break;
            }
          if (e < 0)
            return this;
          a.length === 1 ? (a.length = 0, delete this._events[i]) : a.splice(e, 1), this._events.removeListener && this.emit("removeListener", i, v);
        }
        return this;
      }, se.prototype.removeAllListeners = function(i) {
        var v, a;
        if (!this._events)
          return this;
        if (!this._events.removeListener)
          return arguments.length === 0 ? this._events = {} : this._events[i] && delete this._events[i], this;
        if (arguments.length === 0) {
          for (v in this._events)
            v !== "removeListener" && this.removeAllListeners(v);
          return this.removeAllListeners("removeListener"), this._events = {}, this;
        }
        if (a = this._events[i], Q(a))
          this.removeListener(i, a);
        else if (a)
          for (; a.length; )
            this.removeListener(i, a[a.length - 1]);
        return delete this._events[i], this;
      }, se.prototype.listeners = function(i) {
        var v;
        return !this._events || !this._events[i] ? v = [] : Q(this._events[i]) ? v = [this._events[i]] : v = this._events[i].slice(), v;
      }, se.prototype.listenerCount = function(i) {
        if (this._events) {
          var v = this._events[i];
          if (Q(v))
            return 1;
          if (v)
            return v.length;
        }
        return 0;
      }, se.listenerCount = function(i, v) {
        return i.listenerCount(v);
      };
      function Q(i) {
        return typeof i == "function";
      }
      function u(i) {
        return typeof i == "number";
      }
      function P(i) {
        return typeof i == "object" && i !== null;
      }
      function t(i) {
        return i === void 0;
      }
    }, {}], 83: [function(le, de, oe) {
      oe.read = function(se, Q, u, P, t) {
        var i, v, a = t * 8 - P - 1, e = (1 << a) - 1, y = e >> 1, r = -7, h = u ? t - 1 : 0, g = u ? -1 : 1, d = se[Q + h];
        for (h += g, i = d & (1 << -r) - 1, d >>= -r, r += a; r > 0; i = i * 256 + se[Q + h], h += g, r -= 8)
          ;
        for (v = i & (1 << -r) - 1, i >>= -r, r += P; r > 0; v = v * 256 + se[Q + h], h += g, r -= 8)
          ;
        if (i === 0)
          i = 1 - y;
        else {
          if (i === e)
            return v ? NaN : (d ? -1 : 1) * (1 / 0);
          v = v + Math.pow(2, P), i = i - y;
        }
        return (d ? -1 : 1) * v * Math.pow(2, i - P);
      }, oe.write = function(se, Q, u, P, t, i) {
        var v, a, e, y = i * 8 - t - 1, r = (1 << y) - 1, h = r >> 1, g = t === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = P ? 0 : i - 1, c = P ? 1 : -1, n = Q < 0 || Q === 0 && 1 / Q < 0 ? 1 : 0;
        for (Q = Math.abs(Q), isNaN(Q) || Q === 1 / 0 ? (a = isNaN(Q) ? 1 : 0, v = r) : (v = Math.floor(Math.log(Q) / Math.LN2), Q * (e = Math.pow(2, -v)) < 1 && (v--, e *= 2), v + h >= 1 ? Q += g / e : Q += g * Math.pow(2, 1 - h), Q * e >= 2 && (v++, e /= 2), v + h >= r ? (a = 0, v = r) : v + h >= 1 ? (a = (Q * e - 1) * Math.pow(2, t), v = v + h) : (a = Q * Math.pow(2, h - 1) * Math.pow(2, t), v = 0)); t >= 8; se[u + d] = a & 255, d += c, a /= 256, t -= 8)
          ;
        for (v = v << t | a, y += t; y > 0; se[u + d] = v & 255, d += c, v /= 256, y -= 8)
          ;
        se[u + d - c] |= n * 128;
      };
    }, {}], 84: [function(le, de, oe) {
      typeof Object.create == "function" ? de.exports = function(Q, u) {
        Q.super_ = u, Q.prototype = Object.create(u.prototype, {
          constructor: {
            value: Q,
            enumerable: !1,
            writable: !0,
            configurable: !0
          }
        });
      } : de.exports = function(Q, u) {
        Q.super_ = u;
        var P = function() {
        };
        P.prototype = u.prototype, Q.prototype = new P(), Q.prototype.constructor = Q;
      };
    }, {}], 85: [function(le, de, oe) {
      /*!
       * Determine if an object is a Buffer
       *
       * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
       * @license  MIT
       */
      de.exports = function(u) {
        return u != null && (se(u) || Q(u) || !!u._isBuffer);
      };
      function se(u) {
        return !!u.constructor && typeof u.constructor.isBuffer == "function" && u.constructor.isBuffer(u);
      }
      function Q(u) {
        return typeof u.readFloatLE == "function" && typeof u.slice == "function" && se(u.slice(0, 0));
      }
    }, {}], 86: [function(le, de, oe) {
      var se = {}.toString;
      de.exports = Array.isArray || function(Q) {
        return se.call(Q) == "[object Array]";
      };
    }, {}], 87: [function(le, de, oe) {
      (function(se, Q) {
        /*!
        
        	JSZip v3.7.1 - A JavaScript class for generating and reading zip files
        	<http://stuartk.com/jszip>
        
        	(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
        	Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.
        
        	JSZip uses the library pako released under the MIT license :
        	https://github.com/nodeca/pako/blob/master/LICENSE
        	*/
        (function(u) {
          typeof oe == "object" && typeof de < "u" ? de.exports = u() : (typeof window < "u" ? window : typeof se < "u" ? se : typeof self < "u" ? self : this).JSZip = u();
        })(function() {
          return function u(P, t, i) {
            function v(y, r) {
              if (!t[y]) {
                if (!P[y]) {
                  var h = typeof le == "function" && le;
                  if (!r && h)
                    return h(y, !0);
                  if (a)
                    return a(y, !0);
                  var g = new Error("Cannot find module '" + y + "'");
                  throw g.code = "MODULE_NOT_FOUND", g;
                }
                var d = t[y] = { exports: {} };
                P[y][0].call(d.exports, function(c) {
                  var n = P[y][1][c];
                  return v(n || c);
                }, d, d.exports, u, P, t, i);
              }
              return t[y].exports;
            }
            for (var a = typeof le == "function" && le, e = 0; e < i.length; e++)
              v(i[e]);
            return v;
          }({ 1: [function(u, P, t) {
            var i = u("./utils"), v = u("./support"), a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            t.encode = function(e) {
              for (var y, r, h, g, d, c, n, o = [], x = 0, f = e.length, m = f, C = i.getTypeOf(e) !== "string"; x < e.length; )
                m = f - x, h = C ? (y = e[x++], r = x < f ? e[x++] : 0, x < f ? e[x++] : 0) : (y = e.charCodeAt(x++), r = x < f ? e.charCodeAt(x++) : 0, x < f ? e.charCodeAt(x++) : 0), g = y >> 2, d = (3 & y) << 4 | r >> 4, c = 1 < m ? (15 & r) << 2 | h >> 6 : 64, n = 2 < m ? 63 & h : 64, o.push(a.charAt(g) + a.charAt(d) + a.charAt(c) + a.charAt(n));
              return o.join("");
            }, t.decode = function(e) {
              var y, r, h, g, d, c, n = 0, o = 0, x = "data:";
              if (e.substr(0, x.length) === x)
                throw new Error("Invalid base64 input, it looks like a data url.");
              var f, m = 3 * (e = e.replace(/[^A-Za-z0-9\+\/\=]/g, "")).length / 4;
              if (e.charAt(e.length - 1) === a.charAt(64) && m--, e.charAt(e.length - 2) === a.charAt(64) && m--, m % 1 != 0)
                throw new Error("Invalid base64 input, bad content length.");
              for (f = v.uint8array ? new Uint8Array(0 | m) : new Array(0 | m); n < e.length; )
                y = a.indexOf(e.charAt(n++)) << 2 | (g = a.indexOf(e.charAt(n++))) >> 4, r = (15 & g) << 4 | (d = a.indexOf(e.charAt(n++))) >> 2, h = (3 & d) << 6 | (c = a.indexOf(e.charAt(n++))), f[o++] = y, d !== 64 && (f[o++] = r), c !== 64 && (f[o++] = h);
              return f;
            };
          }, { "./support": 30, "./utils": 32 }], 2: [function(u, P, t) {
            var i = u("./external"), v = u("./stream/DataWorker"), a = u("./stream/Crc32Probe"), e = u("./stream/DataLengthProbe");
            function y(r, h, g, d, c) {
              this.compressedSize = r, this.uncompressedSize = h, this.crc32 = g, this.compression = d, this.compressedContent = c;
            }
            y.prototype = { getContentWorker: function() {
              var r = new v(i.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new e("data_length")), h = this;
              return r.on("end", function() {
                if (this.streamInfo.data_length !== h.uncompressedSize)
                  throw new Error("Bug : uncompressed data size mismatch");
              }), r;
            }, getCompressedWorker: function() {
              return new v(i.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
            } }, y.createWorkerFrom = function(r, h, g) {
              return r.pipe(new a()).pipe(new e("uncompressedSize")).pipe(h.compressWorker(g)).pipe(new e("compressedSize")).withStreamInfo("compression", h);
            }, P.exports = y;
          }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(u, P, t) {
            var i = u("./stream/GenericWorker");
            t.STORE = { magic: "\0\0", compressWorker: function(v) {
              return new i("STORE compression");
            }, uncompressWorker: function() {
              return new i("STORE decompression");
            } }, t.DEFLATE = u("./flate");
          }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(u, P, t) {
            var i = u("./utils"), v = function() {
              for (var a, e = [], y = 0; y < 256; y++) {
                a = y;
                for (var r = 0; r < 8; r++)
                  a = 1 & a ? 3988292384 ^ a >>> 1 : a >>> 1;
                e[y] = a;
              }
              return e;
            }();
            P.exports = function(a, e) {
              return a !== void 0 && a.length ? i.getTypeOf(a) !== "string" ? function(y, r, h, g) {
                var d = v, c = g + h;
                y ^= -1;
                for (var n = g; n < c; n++)
                  y = y >>> 8 ^ d[255 & (y ^ r[n])];
                return -1 ^ y;
              }(0 | e, a, a.length, 0) : function(y, r, h, g) {
                var d = v, c = g + h;
                y ^= -1;
                for (var n = g; n < c; n++)
                  y = y >>> 8 ^ d[255 & (y ^ r.charCodeAt(n))];
                return -1 ^ y;
              }(0 | e, a, a.length, 0) : 0;
            };
          }, { "./utils": 32 }], 5: [function(u, P, t) {
            t.base64 = !1, t.binary = !1, t.dir = !1, t.createFolders = !0, t.date = null, t.compression = null, t.compressionOptions = null, t.comment = null, t.unixPermissions = null, t.dosPermissions = null;
          }, {}], 6: [function(u, P, t) {
            var i = null;
            i = typeof Promise < "u" ? Promise : u("lie"), P.exports = { Promise: i };
          }, { lie: 37 }], 7: [function(u, P, t) {
            var i = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", v = u("pako"), a = u("./utils"), e = u("./stream/GenericWorker"), y = i ? "uint8array" : "array";
            function r(h, g) {
              e.call(this, "FlateWorker/" + h), this._pako = null, this._pakoAction = h, this._pakoOptions = g, this.meta = {};
            }
            t.magic = "\b\0", a.inherits(r, e), r.prototype.processChunk = function(h) {
              this.meta = h.meta, this._pako === null && this._createPako(), this._pako.push(a.transformTo(y, h.data), !1);
            }, r.prototype.flush = function() {
              e.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
            }, r.prototype.cleanUp = function() {
              e.prototype.cleanUp.call(this), this._pako = null;
            }, r.prototype._createPako = function() {
              this._pako = new v[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
              var h = this;
              this._pako.onData = function(g) {
                h.push({ data: g, meta: h.meta });
              };
            }, t.compressWorker = function(h) {
              return new r("Deflate", h);
            }, t.uncompressWorker = function() {
              return new r("Inflate", {});
            };
          }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(u, P, t) {
            function i(d, c) {
              var n, o = "";
              for (n = 0; n < c; n++)
                o += String.fromCharCode(255 & d), d >>>= 8;
              return o;
            }
            function v(d, c, n, o, x, f) {
              var m, C, p = d.file, w = d.compression, X = f !== y.utf8encode, M = a.transformTo("string", f(p.name)), j = a.transformTo("string", y.utf8encode(p.name)), B = p.comment, R = a.transformTo("string", f(B)), D = a.transformTo("string", y.utf8encode(B)), b = j.length !== p.name.length, l = D.length !== B.length, _ = "", S = "", A = "", F = p.dir, T = p.date, O = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
              c && !n || (O.crc32 = d.crc32, O.compressedSize = d.compressedSize, O.uncompressedSize = d.uncompressedSize);
              var U = 0;
              c && (U |= 8), X || !b && !l || (U |= 2048);
              var G = 0, K = 0;
              F && (G |= 16), x === "UNIX" ? (K = 798, G |= function(z, V) {
                var L = z;
                return z || (L = V ? 16893 : 33204), (65535 & L) << 16;
              }(p.unixPermissions, F)) : (K = 20, G |= function(z) {
                return 63 & (z || 0);
              }(p.dosPermissions)), m = T.getUTCHours(), m <<= 6, m |= T.getUTCMinutes(), m <<= 5, m |= T.getUTCSeconds() / 2, C = T.getUTCFullYear() - 1980, C <<= 4, C |= T.getUTCMonth() + 1, C <<= 5, C |= T.getUTCDate(), b && (S = i(1, 1) + i(r(M), 4) + j, _ += "up" + i(S.length, 2) + S), l && (A = i(1, 1) + i(r(R), 4) + D, _ += "uc" + i(A.length, 2) + A);
              var W = "";
              return W += `
\0`, W += i(U, 2), W += w.magic, W += i(m, 2), W += i(C, 2), W += i(O.crc32, 4), W += i(O.compressedSize, 4), W += i(O.uncompressedSize, 4), W += i(M.length, 2), W += i(_.length, 2), { fileRecord: h.LOCAL_FILE_HEADER + W + M + _, dirRecord: h.CENTRAL_FILE_HEADER + i(K, 2) + W + i(R.length, 2) + "\0\0\0\0" + i(G, 4) + i(o, 4) + M + _ + R };
            }
            var a = u("../utils"), e = u("../stream/GenericWorker"), y = u("../utf8"), r = u("../crc32"), h = u("../signature");
            function g(d, c, n, o) {
              e.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = c, this.zipPlatform = n, this.encodeFileName = o, this.streamFiles = d, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
            }
            a.inherits(g, e), g.prototype.push = function(d) {
              var c = d.meta.percent || 0, n = this.entriesCount, o = this._sources.length;
              this.accumulate ? this.contentBuffer.push(d) : (this.bytesWritten += d.data.length, e.prototype.push.call(this, { data: d.data, meta: { currentFile: this.currentFile, percent: n ? (c + 100 * (n - o - 1)) / n : 100 } }));
            }, g.prototype.openedSource = function(d) {
              this.currentSourceOffset = this.bytesWritten, this.currentFile = d.file.name;
              var c = this.streamFiles && !d.file.dir;
              if (c) {
                var n = v(d, c, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
                this.push({ data: n.fileRecord, meta: { percent: 0 } });
              } else
                this.accumulate = !0;
            }, g.prototype.closedSource = function(d) {
              this.accumulate = !1;
              var c = this.streamFiles && !d.file.dir, n = v(d, c, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
              if (this.dirRecords.push(n.dirRecord), c)
                this.push({ data: function(o) {
                  return h.DATA_DESCRIPTOR + i(o.crc32, 4) + i(o.compressedSize, 4) + i(o.uncompressedSize, 4);
                }(d), meta: { percent: 100 } });
              else
                for (this.push({ data: n.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
                  this.push(this.contentBuffer.shift());
              this.currentFile = null;
            }, g.prototype.flush = function() {
              for (var d = this.bytesWritten, c = 0; c < this.dirRecords.length; c++)
                this.push({ data: this.dirRecords[c], meta: { percent: 100 } });
              var n = this.bytesWritten - d, o = function(x, f, m, C, p) {
                var w = a.transformTo("string", p(C));
                return h.CENTRAL_DIRECTORY_END + "\0\0\0\0" + i(x, 2) + i(x, 2) + i(f, 4) + i(m, 4) + i(w.length, 2) + w;
              }(this.dirRecords.length, n, d, this.zipComment, this.encodeFileName);
              this.push({ data: o, meta: { percent: 100 } });
            }, g.prototype.prepareNextSource = function() {
              this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
            }, g.prototype.registerPrevious = function(d) {
              this._sources.push(d);
              var c = this;
              return d.on("data", function(n) {
                c.processChunk(n);
              }), d.on("end", function() {
                c.closedSource(c.previous.streamInfo), c._sources.length ? c.prepareNextSource() : c.end();
              }), d.on("error", function(n) {
                c.error(n);
              }), this;
            }, g.prototype.resume = function() {
              return !!e.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
            }, g.prototype.error = function(d) {
              var c = this._sources;
              if (!e.prototype.error.call(this, d))
                return !1;
              for (var n = 0; n < c.length; n++)
                try {
                  c[n].error(d);
                } catch {
                }
              return !0;
            }, g.prototype.lock = function() {
              e.prototype.lock.call(this);
              for (var d = this._sources, c = 0; c < d.length; c++)
                d[c].lock();
            }, P.exports = g;
          }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(u, P, t) {
            var i = u("../compressions"), v = u("./ZipFileWorker");
            t.generateWorker = function(a, e, y) {
              var r = new v(e.streamFiles, y, e.platform, e.encodeFileName), h = 0;
              try {
                a.forEach(function(g, d) {
                  h++;
                  var c = function(f, m) {
                    var C = f || m, p = i[C];
                    if (!p)
                      throw new Error(C + " is not a valid compression method !");
                    return p;
                  }(d.options.compression, e.compression), n = d.options.compressionOptions || e.compressionOptions || {}, o = d.dir, x = d.date;
                  d._compressWorker(c, n).withStreamInfo("file", { name: g, dir: o, date: x, comment: d.comment || "", unixPermissions: d.unixPermissions, dosPermissions: d.dosPermissions }).pipe(r);
                }), r.entriesCount = h;
              } catch (g) {
                r.error(g);
              }
              return r;
            };
          }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(u, P, t) {
            function i() {
              if (!(this instanceof i))
                return new i();
              if (arguments.length)
                throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
              this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
                var v = new i();
                for (var a in this)
                  typeof this[a] != "function" && (v[a] = this[a]);
                return v;
              };
            }
            (i.prototype = u("./object")).loadAsync = u("./load"), i.support = u("./support"), i.defaults = u("./defaults"), i.version = "3.7.1", i.loadAsync = function(v, a) {
              return new i().loadAsync(v, a);
            }, i.external = u("./external"), P.exports = i;
          }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(u, P, t) {
            var i = u("./utils"), v = u("./external"), a = u("./utf8"), e = u("./zipEntries"), y = u("./stream/Crc32Probe"), r = u("./nodejsUtils");
            function h(g) {
              return new v.Promise(function(d, c) {
                var n = g.decompressed.getContentWorker().pipe(new y());
                n.on("error", function(o) {
                  c(o);
                }).on("end", function() {
                  n.streamInfo.crc32 !== g.decompressed.crc32 ? c(new Error("Corrupted zip : CRC32 mismatch")) : d();
                }).resume();
              });
            }
            P.exports = function(g, d) {
              var c = this;
              return d = i.extend(d || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: a.utf8decode }), r.isNode && r.isStream(g) ? v.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : i.prepareContent("the loaded zip file", g, !0, d.optimizedBinaryString, d.base64).then(function(n) {
                var o = new e(d);
                return o.load(n), o;
              }).then(function(n) {
                var o = [v.Promise.resolve(n)], x = n.files;
                if (d.checkCRC32)
                  for (var f = 0; f < x.length; f++)
                    o.push(h(x[f]));
                return v.Promise.all(o);
              }).then(function(n) {
                for (var o = n.shift(), x = o.files, f = 0; f < x.length; f++) {
                  var m = x[f];
                  c.file(m.fileNameStr, m.decompressed, { binary: !0, optimizedBinaryString: !0, date: m.date, dir: m.dir, comment: m.fileCommentStr.length ? m.fileCommentStr : null, unixPermissions: m.unixPermissions, dosPermissions: m.dosPermissions, createFolders: d.createFolders });
                }
                return o.zipComment.length && (c.comment = o.zipComment), c;
              });
            };
          }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(u, P, t) {
            var i = u("../utils"), v = u("../stream/GenericWorker");
            function a(e, y) {
              v.call(this, "Nodejs stream input adapter for " + e), this._upstreamEnded = !1, this._bindStream(y);
            }
            i.inherits(a, v), a.prototype._bindStream = function(e) {
              var y = this;
              (this._stream = e).pause(), e.on("data", function(r) {
                y.push({ data: r, meta: { percent: 0 } });
              }).on("error", function(r) {
                y.isPaused ? this.generatedError = r : y.error(r);
              }).on("end", function() {
                y.isPaused ? y._upstreamEnded = !0 : y.end();
              });
            }, a.prototype.pause = function() {
              return !!v.prototype.pause.call(this) && (this._stream.pause(), !0);
            }, a.prototype.resume = function() {
              return !!v.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
            }, P.exports = a;
          }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(u, P, t) {
            var i = u("readable-stream").Readable;
            function v(a, e, y) {
              i.call(this, e), this._helper = a;
              var r = this;
              a.on("data", function(h, g) {
                r.push(h) || r._helper.pause(), y && y(g);
              }).on("error", function(h) {
                r.emit("error", h);
              }).on("end", function() {
                r.push(null);
              });
            }
            u("../utils").inherits(v, i), v.prototype._read = function() {
              this._helper.resume();
            }, P.exports = v;
          }, { "../utils": 32, "readable-stream": 16 }], 14: [function(u, P, t) {
            P.exports = { isNode: typeof Q < "u", newBufferFrom: function(i, v) {
              if (Q.from && Q.from !== Uint8Array.from)
                return Q.from(i, v);
              if (typeof i == "number")
                throw new Error('The "data" argument must not be a number');
              return new Q(i, v);
            }, allocBuffer: function(i) {
              if (Q.alloc)
                return Q.alloc(i);
              var v = new Q(i);
              return v.fill(0), v;
            }, isBuffer: function(i) {
              return Q.isBuffer(i);
            }, isStream: function(i) {
              return i && typeof i.on == "function" && typeof i.pause == "function" && typeof i.resume == "function";
            } };
          }, {}], 15: [function(u, P, t) {
            function i(p, w, X) {
              var M, j = a.getTypeOf(w), B = a.extend(X || {}, r);
              B.date = B.date || new Date(), B.compression !== null && (B.compression = B.compression.toUpperCase()), typeof B.unixPermissions == "string" && (B.unixPermissions = parseInt(B.unixPermissions, 8)), B.unixPermissions && 16384 & B.unixPermissions && (B.dir = !0), B.dosPermissions && 16 & B.dosPermissions && (B.dir = !0), B.dir && (p = x(p)), B.createFolders && (M = o(p)) && f.call(this, M, !0);
              var R = j === "string" && B.binary === !1 && B.base64 === !1;
              X && X.binary !== void 0 || (B.binary = !R), (w instanceof h && w.uncompressedSize === 0 || B.dir || !w || w.length === 0) && (B.base64 = !1, B.binary = !0, w = "", B.compression = "STORE", j = "string");
              var D = null;
              D = w instanceof h || w instanceof e ? w : c.isNode && c.isStream(w) ? new n(p, w) : a.prepareContent(p, w, B.binary, B.optimizedBinaryString, B.base64);
              var b = new g(p, D, B);
              this.files[p] = b;
            }
            var v = u("./utf8"), a = u("./utils"), e = u("./stream/GenericWorker"), y = u("./stream/StreamHelper"), r = u("./defaults"), h = u("./compressedObject"), g = u("./zipObject"), d = u("./generate"), c = u("./nodejsUtils"), n = u("./nodejs/NodejsStreamInputAdapter"), o = function(p) {
              p.slice(-1) === "/" && (p = p.substring(0, p.length - 1));
              var w = p.lastIndexOf("/");
              return 0 < w ? p.substring(0, w) : "";
            }, x = function(p) {
              return p.slice(-1) !== "/" && (p += "/"), p;
            }, f = function(p, w) {
              return w = w !== void 0 ? w : r.createFolders, p = x(p), this.files[p] || i.call(this, p, null, { dir: !0, createFolders: w }), this.files[p];
            };
            function m(p) {
              return Object.prototype.toString.call(p) === "[object RegExp]";
            }
            var C = { load: function() {
              throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
            }, forEach: function(p) {
              var w, X, M;
              for (w in this.files)
                M = this.files[w], (X = w.slice(this.root.length, w.length)) && w.slice(0, this.root.length) === this.root && p(X, M);
            }, filter: function(p) {
              var w = [];
              return this.forEach(function(X, M) {
                p(X, M) && w.push(M);
              }), w;
            }, file: function(p, w, X) {
              if (arguments.length !== 1)
                return p = this.root + p, i.call(this, p, w, X), this;
              if (m(p)) {
                var M = p;
                return this.filter(function(B, R) {
                  return !R.dir && M.test(B);
                });
              }
              var j = this.files[this.root + p];
              return j && !j.dir ? j : null;
            }, folder: function(p) {
              if (!p)
                return this;
              if (m(p))
                return this.filter(function(j, B) {
                  return B.dir && p.test(j);
                });
              var w = this.root + p, X = f.call(this, w), M = this.clone();
              return M.root = X.name, M;
            }, remove: function(p) {
              p = this.root + p;
              var w = this.files[p];
              if (w || (p.slice(-1) !== "/" && (p += "/"), w = this.files[p]), w && !w.dir)
                delete this.files[p];
              else
                for (var X = this.filter(function(j, B) {
                  return B.name.slice(0, p.length) === p;
                }), M = 0; M < X.length; M++)
                  delete this.files[X[M].name];
              return this;
            }, generate: function(p) {
              throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
            }, generateInternalStream: function(p) {
              var w, X = {};
              try {
                if ((X = a.extend(p || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: v.utf8encode })).type = X.type.toLowerCase(), X.compression = X.compression.toUpperCase(), X.type === "binarystring" && (X.type = "string"), !X.type)
                  throw new Error("No output type specified.");
                a.checkSupport(X.type), X.platform !== "darwin" && X.platform !== "freebsd" && X.platform !== "linux" && X.platform !== "sunos" || (X.platform = "UNIX"), X.platform === "win32" && (X.platform = "DOS");
                var M = X.comment || this.comment || "";
                w = d.generateWorker(this, X, M);
              } catch (j) {
                (w = new e("error")).error(j);
              }
              return new y(w, X.type || "string", X.mimeType);
            }, generateAsync: function(p, w) {
              return this.generateInternalStream(p).accumulate(w);
            }, generateNodeStream: function(p, w) {
              return (p = p || {}).type || (p.type = "nodebuffer"), this.generateInternalStream(p).toNodejsStream(w);
            } };
            P.exports = C;
          }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(u, P, t) {
            P.exports = u("stream");
          }, { stream: void 0 }], 17: [function(u, P, t) {
            var i = u("./DataReader");
            function v(a) {
              i.call(this, a);
              for (var e = 0; e < this.data.length; e++)
                a[e] = 255 & a[e];
            }
            u("../utils").inherits(v, i), v.prototype.byteAt = function(a) {
              return this.data[this.zero + a];
            }, v.prototype.lastIndexOfSignature = function(a) {
              for (var e = a.charCodeAt(0), y = a.charCodeAt(1), r = a.charCodeAt(2), h = a.charCodeAt(3), g = this.length - 4; 0 <= g; --g)
                if (this.data[g] === e && this.data[g + 1] === y && this.data[g + 2] === r && this.data[g + 3] === h)
                  return g - this.zero;
              return -1;
            }, v.prototype.readAndCheckSignature = function(a) {
              var e = a.charCodeAt(0), y = a.charCodeAt(1), r = a.charCodeAt(2), h = a.charCodeAt(3), g = this.readData(4);
              return e === g[0] && y === g[1] && r === g[2] && h === g[3];
            }, v.prototype.readData = function(a) {
              if (this.checkOffset(a), a === 0)
                return [];
              var e = this.data.slice(this.zero + this.index, this.zero + this.index + a);
              return this.index += a, e;
            }, P.exports = v;
          }, { "../utils": 32, "./DataReader": 18 }], 18: [function(u, P, t) {
            var i = u("../utils");
            function v(a) {
              this.data = a, this.length = a.length, this.index = 0, this.zero = 0;
            }
            v.prototype = { checkOffset: function(a) {
              this.checkIndex(this.index + a);
            }, checkIndex: function(a) {
              if (this.length < this.zero + a || a < 0)
                throw new Error("End of data reached (data length = " + this.length + ", asked index = " + a + "). Corrupted zip ?");
            }, setIndex: function(a) {
              this.checkIndex(a), this.index = a;
            }, skip: function(a) {
              this.setIndex(this.index + a);
            }, byteAt: function(a) {
            }, readInt: function(a) {
              var e, y = 0;
              for (this.checkOffset(a), e = this.index + a - 1; e >= this.index; e--)
                y = (y << 8) + this.byteAt(e);
              return this.index += a, y;
            }, readString: function(a) {
              return i.transformTo("string", this.readData(a));
            }, readData: function(a) {
            }, lastIndexOfSignature: function(a) {
            }, readAndCheckSignature: function(a) {
            }, readDate: function() {
              var a = this.readInt(4);
              return new Date(Date.UTC(1980 + (a >> 25 & 127), (a >> 21 & 15) - 1, a >> 16 & 31, a >> 11 & 31, a >> 5 & 63, (31 & a) << 1));
            } }, P.exports = v;
          }, { "../utils": 32 }], 19: [function(u, P, t) {
            var i = u("./Uint8ArrayReader");
            function v(a) {
              i.call(this, a);
            }
            u("../utils").inherits(v, i), v.prototype.readData = function(a) {
              this.checkOffset(a);
              var e = this.data.slice(this.zero + this.index, this.zero + this.index + a);
              return this.index += a, e;
            }, P.exports = v;
          }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(u, P, t) {
            var i = u("./DataReader");
            function v(a) {
              i.call(this, a);
            }
            u("../utils").inherits(v, i), v.prototype.byteAt = function(a) {
              return this.data.charCodeAt(this.zero + a);
            }, v.prototype.lastIndexOfSignature = function(a) {
              return this.data.lastIndexOf(a) - this.zero;
            }, v.prototype.readAndCheckSignature = function(a) {
              return a === this.readData(4);
            }, v.prototype.readData = function(a) {
              this.checkOffset(a);
              var e = this.data.slice(this.zero + this.index, this.zero + this.index + a);
              return this.index += a, e;
            }, P.exports = v;
          }, { "../utils": 32, "./DataReader": 18 }], 21: [function(u, P, t) {
            var i = u("./ArrayReader");
            function v(a) {
              i.call(this, a);
            }
            u("../utils").inherits(v, i), v.prototype.readData = function(a) {
              if (this.checkOffset(a), a === 0)
                return new Uint8Array(0);
              var e = this.data.subarray(this.zero + this.index, this.zero + this.index + a);
              return this.index += a, e;
            }, P.exports = v;
          }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(u, P, t) {
            var i = u("../utils"), v = u("../support"), a = u("./ArrayReader"), e = u("./StringReader"), y = u("./NodeBufferReader"), r = u("./Uint8ArrayReader");
            P.exports = function(h) {
              var g = i.getTypeOf(h);
              return i.checkSupport(g), g !== "string" || v.uint8array ? g === "nodebuffer" ? new y(h) : v.uint8array ? new r(i.transformTo("uint8array", h)) : new a(i.transformTo("array", h)) : new e(h);
            };
          }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(u, P, t) {
            t.LOCAL_FILE_HEADER = "PK", t.CENTRAL_FILE_HEADER = "PK", t.CENTRAL_DIRECTORY_END = "PK", t.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", t.ZIP64_CENTRAL_DIRECTORY_END = "PK", t.DATA_DESCRIPTOR = "PK\x07\b";
          }, {}], 24: [function(u, P, t) {
            var i = u("./GenericWorker"), v = u("../utils");
            function a(e) {
              i.call(this, "ConvertWorker to " + e), this.destType = e;
            }
            v.inherits(a, i), a.prototype.processChunk = function(e) {
              this.push({ data: v.transformTo(this.destType, e.data), meta: e.meta });
            }, P.exports = a;
          }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(u, P, t) {
            var i = u("./GenericWorker"), v = u("../crc32");
            function a() {
              i.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
            }
            u("../utils").inherits(a, i), a.prototype.processChunk = function(e) {
              this.streamInfo.crc32 = v(e.data, this.streamInfo.crc32 || 0), this.push(e);
            }, P.exports = a;
          }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(u, P, t) {
            var i = u("../utils"), v = u("./GenericWorker");
            function a(e) {
              v.call(this, "DataLengthProbe for " + e), this.propName = e, this.withStreamInfo(e, 0);
            }
            i.inherits(a, v), a.prototype.processChunk = function(e) {
              if (e) {
                var y = this.streamInfo[this.propName] || 0;
                this.streamInfo[this.propName] = y + e.data.length;
              }
              v.prototype.processChunk.call(this, e);
            }, P.exports = a;
          }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(u, P, t) {
            var i = u("../utils"), v = u("./GenericWorker");
            function a(e) {
              v.call(this, "DataWorker");
              var y = this;
              this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, e.then(function(r) {
                y.dataIsReady = !0, y.data = r, y.max = r && r.length || 0, y.type = i.getTypeOf(r), y.isPaused || y._tickAndRepeat();
              }, function(r) {
                y.error(r);
              });
            }
            i.inherits(a, v), a.prototype.cleanUp = function() {
              v.prototype.cleanUp.call(this), this.data = null;
            }, a.prototype.resume = function() {
              return !!v.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, i.delay(this._tickAndRepeat, [], this)), !0);
            }, a.prototype._tickAndRepeat = function() {
              this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (i.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
            }, a.prototype._tick = function() {
              if (this.isPaused || this.isFinished)
                return !1;
              var e = null, y = Math.min(this.max, this.index + 16384);
              if (this.index >= this.max)
                return this.end();
              switch (this.type) {
                case "string":
                  e = this.data.substring(this.index, y);
                  break;
                case "uint8array":
                  e = this.data.subarray(this.index, y);
                  break;
                case "array":
                case "nodebuffer":
                  e = this.data.slice(this.index, y);
              }
              return this.index = y, this.push({ data: e, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
            }, P.exports = a;
          }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(u, P, t) {
            function i(v) {
              this.name = v || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
            }
            i.prototype = { push: function(v) {
              this.emit("data", v);
            }, end: function() {
              if (this.isFinished)
                return !1;
              this.flush();
              try {
                this.emit("end"), this.cleanUp(), this.isFinished = !0;
              } catch (v) {
                this.emit("error", v);
              }
              return !0;
            }, error: function(v) {
              return !this.isFinished && (this.isPaused ? this.generatedError = v : (this.isFinished = !0, this.emit("error", v), this.previous && this.previous.error(v), this.cleanUp()), !0);
            }, on: function(v, a) {
              return this._listeners[v].push(a), this;
            }, cleanUp: function() {
              this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
            }, emit: function(v, a) {
              if (this._listeners[v])
                for (var e = 0; e < this._listeners[v].length; e++)
                  this._listeners[v][e].call(this, a);
            }, pipe: function(v) {
              return v.registerPrevious(this);
            }, registerPrevious: function(v) {
              if (this.isLocked)
                throw new Error("The stream '" + this + "' has already been used.");
              this.streamInfo = v.streamInfo, this.mergeStreamInfo(), this.previous = v;
              var a = this;
              return v.on("data", function(e) {
                a.processChunk(e);
              }), v.on("end", function() {
                a.end();
              }), v.on("error", function(e) {
                a.error(e);
              }), this;
            }, pause: function() {
              return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
            }, resume: function() {
              if (!this.isPaused || this.isFinished)
                return !1;
              var v = this.isPaused = !1;
              return this.generatedError && (this.error(this.generatedError), v = !0), this.previous && this.previous.resume(), !v;
            }, flush: function() {
            }, processChunk: function(v) {
              this.push(v);
            }, withStreamInfo: function(v, a) {
              return this.extraStreamInfo[v] = a, this.mergeStreamInfo(), this;
            }, mergeStreamInfo: function() {
              for (var v in this.extraStreamInfo)
                this.extraStreamInfo.hasOwnProperty(v) && (this.streamInfo[v] = this.extraStreamInfo[v]);
            }, lock: function() {
              if (this.isLocked)
                throw new Error("The stream '" + this + "' has already been used.");
              this.isLocked = !0, this.previous && this.previous.lock();
            }, toString: function() {
              var v = "Worker " + this.name;
              return this.previous ? this.previous + " -> " + v : v;
            } }, P.exports = i;
          }, {}], 29: [function(u, P, t) {
            var i = u("../utils"), v = u("./ConvertWorker"), a = u("./GenericWorker"), e = u("../base64"), y = u("../support"), r = u("../external"), h = null;
            if (y.nodestream)
              try {
                h = u("../nodejs/NodejsStreamOutputAdapter");
              } catch {
              }
            function g(c, n) {
              return new r.Promise(function(o, x) {
                var f = [], m = c._internalType, C = c._outputType, p = c._mimeType;
                c.on("data", function(w, X) {
                  f.push(w), n && n(X);
                }).on("error", function(w) {
                  f = [], x(w);
                }).on("end", function() {
                  try {
                    var w = function(X, M, j) {
                      switch (X) {
                        case "blob":
                          return i.newBlob(i.transformTo("arraybuffer", M), j);
                        case "base64":
                          return e.encode(M);
                        default:
                          return i.transformTo(X, M);
                      }
                    }(C, function(X, M) {
                      var j, B = 0, R = null, D = 0;
                      for (j = 0; j < M.length; j++)
                        D += M[j].length;
                      switch (X) {
                        case "string":
                          return M.join("");
                        case "array":
                          return Array.prototype.concat.apply([], M);
                        case "uint8array":
                          for (R = new Uint8Array(D), j = 0; j < M.length; j++)
                            R.set(M[j], B), B += M[j].length;
                          return R;
                        case "nodebuffer":
                          return Q.concat(M);
                        default:
                          throw new Error("concat : unsupported type '" + X + "'");
                      }
                    }(m, f), p);
                    o(w);
                  } catch (X) {
                    x(X);
                  }
                  f = [];
                }).resume();
              });
            }
            function d(c, n, o) {
              var x = n;
              switch (n) {
                case "blob":
                case "arraybuffer":
                  x = "uint8array";
                  break;
                case "base64":
                  x = "string";
              }
              try {
                this._internalType = x, this._outputType = n, this._mimeType = o, i.checkSupport(x), this._worker = c.pipe(new v(x)), c.lock();
              } catch (f) {
                this._worker = new a("error"), this._worker.error(f);
              }
            }
            d.prototype = { accumulate: function(c) {
              return g(this, c);
            }, on: function(c, n) {
              var o = this;
              return c === "data" ? this._worker.on(c, function(x) {
                n.call(o, x.data, x.meta);
              }) : this._worker.on(c, function() {
                i.delay(n, arguments, o);
              }), this;
            }, resume: function() {
              return i.delay(this._worker.resume, [], this._worker), this;
            }, pause: function() {
              return this._worker.pause(), this;
            }, toNodejsStream: function(c) {
              if (i.checkSupport("nodestream"), this._outputType !== "nodebuffer")
                throw new Error(this._outputType + " is not supported by this method");
              return new h(this, { objectMode: this._outputType !== "nodebuffer" }, c);
            } }, P.exports = d;
          }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(u, P, t) {
            if (t.base64 = !0, t.array = !0, t.string = !0, t.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", t.nodebuffer = typeof Q < "u", t.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u")
              t.blob = !1;
            else {
              var i = new ArrayBuffer(0);
              try {
                t.blob = new Blob([i], { type: "application/zip" }).size === 0;
              } catch {
                try {
                  var v = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
                  v.append(i), t.blob = v.getBlob("application/zip").size === 0;
                } catch {
                  t.blob = !1;
                }
              }
            }
            try {
              t.nodestream = !!u("readable-stream").Readable;
            } catch {
              t.nodestream = !1;
            }
          }, { "readable-stream": 16 }], 31: [function(u, P, t) {
            for (var i = u("./utils"), v = u("./support"), a = u("./nodejsUtils"), e = u("./stream/GenericWorker"), y = new Array(256), r = 0; r < 256; r++)
              y[r] = 252 <= r ? 6 : 248 <= r ? 5 : 240 <= r ? 4 : 224 <= r ? 3 : 192 <= r ? 2 : 1;
            y[254] = y[254] = 1;
            function h() {
              e.call(this, "utf-8 decode"), this.leftOver = null;
            }
            function g() {
              e.call(this, "utf-8 encode");
            }
            t.utf8encode = function(d) {
              return v.nodebuffer ? a.newBufferFrom(d, "utf-8") : function(c) {
                var n, o, x, f, m, C = c.length, p = 0;
                for (f = 0; f < C; f++)
                  (64512 & (o = c.charCodeAt(f))) == 55296 && f + 1 < C && (64512 & (x = c.charCodeAt(f + 1))) == 56320 && (o = 65536 + (o - 55296 << 10) + (x - 56320), f++), p += o < 128 ? 1 : o < 2048 ? 2 : o < 65536 ? 3 : 4;
                for (n = v.uint8array ? new Uint8Array(p) : new Array(p), f = m = 0; m < p; f++)
                  (64512 & (o = c.charCodeAt(f))) == 55296 && f + 1 < C && (64512 & (x = c.charCodeAt(f + 1))) == 56320 && (o = 65536 + (o - 55296 << 10) + (x - 56320), f++), o < 128 ? n[m++] = o : (o < 2048 ? n[m++] = 192 | o >>> 6 : (o < 65536 ? n[m++] = 224 | o >>> 12 : (n[m++] = 240 | o >>> 18, n[m++] = 128 | o >>> 12 & 63), n[m++] = 128 | o >>> 6 & 63), n[m++] = 128 | 63 & o);
                return n;
              }(d);
            }, t.utf8decode = function(d) {
              return v.nodebuffer ? i.transformTo("nodebuffer", d).toString("utf-8") : function(c) {
                var n, o, x, f, m = c.length, C = new Array(2 * m);
                for (n = o = 0; n < m; )
                  if ((x = c[n++]) < 128)
                    C[o++] = x;
                  else if (4 < (f = y[x]))
                    C[o++] = 65533, n += f - 1;
                  else {
                    for (x &= f === 2 ? 31 : f === 3 ? 15 : 7; 1 < f && n < m; )
                      x = x << 6 | 63 & c[n++], f--;
                    1 < f ? C[o++] = 65533 : x < 65536 ? C[o++] = x : (x -= 65536, C[o++] = 55296 | x >> 10 & 1023, C[o++] = 56320 | 1023 & x);
                  }
                return C.length !== o && (C.subarray ? C = C.subarray(0, o) : C.length = o), i.applyFromCharCode(C);
              }(d = i.transformTo(v.uint8array ? "uint8array" : "array", d));
            }, i.inherits(h, e), h.prototype.processChunk = function(d) {
              var c = i.transformTo(v.uint8array ? "uint8array" : "array", d.data);
              if (this.leftOver && this.leftOver.length) {
                if (v.uint8array) {
                  var n = c;
                  (c = new Uint8Array(n.length + this.leftOver.length)).set(this.leftOver, 0), c.set(n, this.leftOver.length);
                } else
                  c = this.leftOver.concat(c);
                this.leftOver = null;
              }
              var o = function(f, m) {
                var C;
                for ((m = m || f.length) > f.length && (m = f.length), C = m - 1; 0 <= C && (192 & f[C]) == 128; )
                  C--;
                return C < 0 || C === 0 ? m : C + y[f[C]] > m ? C : m;
              }(c), x = c;
              o !== c.length && (v.uint8array ? (x = c.subarray(0, o), this.leftOver = c.subarray(o, c.length)) : (x = c.slice(0, o), this.leftOver = c.slice(o, c.length))), this.push({ data: t.utf8decode(x), meta: d.meta });
            }, h.prototype.flush = function() {
              this.leftOver && this.leftOver.length && (this.push({ data: t.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
            }, t.Utf8DecodeWorker = h, i.inherits(g, e), g.prototype.processChunk = function(d) {
              this.push({ data: t.utf8encode(d.data), meta: d.meta });
            }, t.Utf8EncodeWorker = g;
          }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(u, P, t) {
            var i = u("./support"), v = u("./base64"), a = u("./nodejsUtils"), e = u("set-immediate-shim"), y = u("./external");
            function r(o) {
              return o;
            }
            function h(o, x) {
              for (var f = 0; f < o.length; ++f)
                x[f] = 255 & o.charCodeAt(f);
              return x;
            }
            t.newBlob = function(o, x) {
              t.checkSupport("blob");
              try {
                return new Blob([o], { type: x });
              } catch {
                try {
                  var f = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
                  return f.append(o), f.getBlob(x);
                } catch {
                  throw new Error("Bug : can't construct the Blob.");
                }
              }
            };
            var g = { stringifyByChunk: function(o, x, f) {
              var m = [], C = 0, p = o.length;
              if (p <= f)
                return String.fromCharCode.apply(null, o);
              for (; C < p; )
                x === "array" || x === "nodebuffer" ? m.push(String.fromCharCode.apply(null, o.slice(C, Math.min(C + f, p)))) : m.push(String.fromCharCode.apply(null, o.subarray(C, Math.min(C + f, p)))), C += f;
              return m.join("");
            }, stringifyByChar: function(o) {
              for (var x = "", f = 0; f < o.length; f++)
                x += String.fromCharCode(o[f]);
              return x;
            }, applyCanBeUsed: { uint8array: function() {
              try {
                return i.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
              } catch {
                return !1;
              }
            }(), nodebuffer: function() {
              try {
                return i.nodebuffer && String.fromCharCode.apply(null, a.allocBuffer(1)).length === 1;
              } catch {
                return !1;
              }
            }() } };
            function d(o) {
              var x = 65536, f = t.getTypeOf(o), m = !0;
              if (f === "uint8array" ? m = g.applyCanBeUsed.uint8array : f === "nodebuffer" && (m = g.applyCanBeUsed.nodebuffer), m)
                for (; 1 < x; )
                  try {
                    return g.stringifyByChunk(o, f, x);
                  } catch {
                    x = Math.floor(x / 2);
                  }
              return g.stringifyByChar(o);
            }
            function c(o, x) {
              for (var f = 0; f < o.length; f++)
                x[f] = o[f];
              return x;
            }
            t.applyFromCharCode = d;
            var n = {};
            n.string = { string: r, array: function(o) {
              return h(o, new Array(o.length));
            }, arraybuffer: function(o) {
              return n.string.uint8array(o).buffer;
            }, uint8array: function(o) {
              return h(o, new Uint8Array(o.length));
            }, nodebuffer: function(o) {
              return h(o, a.allocBuffer(o.length));
            } }, n.array = { string: d, array: r, arraybuffer: function(o) {
              return new Uint8Array(o).buffer;
            }, uint8array: function(o) {
              return new Uint8Array(o);
            }, nodebuffer: function(o) {
              return a.newBufferFrom(o);
            } }, n.arraybuffer = { string: function(o) {
              return d(new Uint8Array(o));
            }, array: function(o) {
              return c(new Uint8Array(o), new Array(o.byteLength));
            }, arraybuffer: r, uint8array: function(o) {
              return new Uint8Array(o);
            }, nodebuffer: function(o) {
              return a.newBufferFrom(new Uint8Array(o));
            } }, n.uint8array = { string: d, array: function(o) {
              return c(o, new Array(o.length));
            }, arraybuffer: function(o) {
              return o.buffer;
            }, uint8array: r, nodebuffer: function(o) {
              return a.newBufferFrom(o);
            } }, n.nodebuffer = { string: d, array: function(o) {
              return c(o, new Array(o.length));
            }, arraybuffer: function(o) {
              return n.nodebuffer.uint8array(o).buffer;
            }, uint8array: function(o) {
              return c(o, new Uint8Array(o.length));
            }, nodebuffer: r }, t.transformTo = function(o, x) {
              if (x = x || "", !o)
                return x;
              t.checkSupport(o);
              var f = t.getTypeOf(x);
              return n[f][o](x);
            }, t.getTypeOf = function(o) {
              return typeof o == "string" ? "string" : Object.prototype.toString.call(o) === "[object Array]" ? "array" : i.nodebuffer && a.isBuffer(o) ? "nodebuffer" : i.uint8array && o instanceof Uint8Array ? "uint8array" : i.arraybuffer && o instanceof ArrayBuffer ? "arraybuffer" : void 0;
            }, t.checkSupport = function(o) {
              if (!i[o.toLowerCase()])
                throw new Error(o + " is not supported by this platform");
            }, t.MAX_VALUE_16BITS = 65535, t.MAX_VALUE_32BITS = -1, t.pretty = function(o) {
              var x, f, m = "";
              for (f = 0; f < (o || "").length; f++)
                m += "\\x" + ((x = o.charCodeAt(f)) < 16 ? "0" : "") + x.toString(16).toUpperCase();
              return m;
            }, t.delay = function(o, x, f) {
              e(function() {
                o.apply(f || null, x || []);
              });
            }, t.inherits = function(o, x) {
              function f() {
              }
              f.prototype = x.prototype, o.prototype = new f();
            }, t.extend = function() {
              var o, x, f = {};
              for (o = 0; o < arguments.length; o++)
                for (x in arguments[o])
                  arguments[o].hasOwnProperty(x) && f[x] === void 0 && (f[x] = arguments[o][x]);
              return f;
            }, t.prepareContent = function(o, x, f, m, C) {
              return y.Promise.resolve(x).then(function(p) {
                return i.blob && (p instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(p)) !== -1) && typeof FileReader < "u" ? new y.Promise(function(w, X) {
                  var M = new FileReader();
                  M.onload = function(j) {
                    w(j.target.result);
                  }, M.onerror = function(j) {
                    X(j.target.error);
                  }, M.readAsArrayBuffer(p);
                }) : p;
              }).then(function(p) {
                var w = t.getTypeOf(p);
                return w ? (w === "arraybuffer" ? p = t.transformTo("uint8array", p) : w === "string" && (C ? p = v.decode(p) : f && m !== !0 && (p = function(X) {
                  return h(X, i.uint8array ? new Uint8Array(X.length) : new Array(X.length));
                }(p))), p) : y.Promise.reject(new Error("Can't read the data of '" + o + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
              });
            };
          }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, "set-immediate-shim": 54 }], 33: [function(u, P, t) {
            var i = u("./reader/readerFor"), v = u("./utils"), a = u("./signature"), e = u("./zipEntry"), y = (u("./utf8"), u("./support"));
            function r(h) {
              this.files = [], this.loadOptions = h;
            }
            r.prototype = { checkSignature: function(h) {
              if (!this.reader.readAndCheckSignature(h)) {
                this.reader.index -= 4;
                var g = this.reader.readString(4);
                throw new Error("Corrupted zip or bug: unexpected signature (" + v.pretty(g) + ", expected " + v.pretty(h) + ")");
              }
            }, isSignature: function(h, g) {
              var d = this.reader.index;
              this.reader.setIndex(h);
              var c = this.reader.readString(4) === g;
              return this.reader.setIndex(d), c;
            }, readBlockEndOfCentral: function() {
              this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
              var h = this.reader.readData(this.zipCommentLength), g = y.uint8array ? "uint8array" : "array", d = v.transformTo(g, h);
              this.zipComment = this.loadOptions.decodeFileName(d);
            }, readBlockZip64EndOfCentral: function() {
              this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
              for (var h, g, d, c = this.zip64EndOfCentralSize - 44; 0 < c; )
                h = this.reader.readInt(2), g = this.reader.readInt(4), d = this.reader.readData(g), this.zip64ExtensibleData[h] = { id: h, length: g, value: d };
            }, readBlockZip64EndOfCentralLocator: function() {
              if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
                throw new Error("Multi-volumes zip are not supported");
            }, readLocalFiles: function() {
              var h, g;
              for (h = 0; h < this.files.length; h++)
                g = this.files[h], this.reader.setIndex(g.localHeaderOffset), this.checkSignature(a.LOCAL_FILE_HEADER), g.readLocalPart(this.reader), g.handleUTF8(), g.processAttributes();
            }, readCentralDir: function() {
              var h;
              for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(a.CENTRAL_FILE_HEADER); )
                (h = new e({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(h);
              if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0)
                throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
            }, readEndOfCentral: function() {
              var h = this.reader.lastIndexOfSignature(a.CENTRAL_DIRECTORY_END);
              if (h < 0)
                throw this.isSignature(0, a.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
              this.reader.setIndex(h);
              var g = h;
              if (this.checkSignature(a.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === v.MAX_VALUE_16BITS || this.diskWithCentralDirStart === v.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === v.MAX_VALUE_16BITS || this.centralDirRecords === v.MAX_VALUE_16BITS || this.centralDirSize === v.MAX_VALUE_32BITS || this.centralDirOffset === v.MAX_VALUE_32BITS) {
                if (this.zip64 = !0, (h = this.reader.lastIndexOfSignature(a.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
                  throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
                if (this.reader.setIndex(h), this.checkSignature(a.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, a.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(a.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
                  throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
                this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(a.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
              }
              var d = this.centralDirOffset + this.centralDirSize;
              this.zip64 && (d += 20, d += 12 + this.zip64EndOfCentralSize);
              var c = g - d;
              if (0 < c)
                this.isSignature(g, a.CENTRAL_FILE_HEADER) || (this.reader.zero = c);
              else if (c < 0)
                throw new Error("Corrupted zip: missing " + Math.abs(c) + " bytes.");
            }, prepareReader: function(h) {
              this.reader = i(h);
            }, load: function(h) {
              this.prepareReader(h), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
            } }, P.exports = r;
          }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utf8": 31, "./utils": 32, "./zipEntry": 34 }], 34: [function(u, P, t) {
            var i = u("./reader/readerFor"), v = u("./utils"), a = u("./compressedObject"), e = u("./crc32"), y = u("./utf8"), r = u("./compressions"), h = u("./support");
            function g(d, c) {
              this.options = d, this.loadOptions = c;
            }
            g.prototype = { isEncrypted: function() {
              return (1 & this.bitFlag) == 1;
            }, useUTF8: function() {
              return (2048 & this.bitFlag) == 2048;
            }, readLocalPart: function(d) {
              var c, n;
              if (d.skip(22), this.fileNameLength = d.readInt(2), n = d.readInt(2), this.fileName = d.readData(this.fileNameLength), d.skip(n), this.compressedSize === -1 || this.uncompressedSize === -1)
                throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
              if ((c = function(o) {
                for (var x in r)
                  if (r.hasOwnProperty(x) && r[x].magic === o)
                    return r[x];
                return null;
              }(this.compressionMethod)) === null)
                throw new Error("Corrupted zip : compression " + v.pretty(this.compressionMethod) + " unknown (inner file : " + v.transformTo("string", this.fileName) + ")");
              this.decompressed = new a(this.compressedSize, this.uncompressedSize, this.crc32, c, d.readData(this.compressedSize));
            }, readCentralPart: function(d) {
              this.versionMadeBy = d.readInt(2), d.skip(2), this.bitFlag = d.readInt(2), this.compressionMethod = d.readString(2), this.date = d.readDate(), this.crc32 = d.readInt(4), this.compressedSize = d.readInt(4), this.uncompressedSize = d.readInt(4);
              var c = d.readInt(2);
              if (this.extraFieldsLength = d.readInt(2), this.fileCommentLength = d.readInt(2), this.diskNumberStart = d.readInt(2), this.internalFileAttributes = d.readInt(2), this.externalFileAttributes = d.readInt(4), this.localHeaderOffset = d.readInt(4), this.isEncrypted())
                throw new Error("Encrypted zip are not supported");
              d.skip(c), this.readExtraFields(d), this.parseZIP64ExtraField(d), this.fileComment = d.readData(this.fileCommentLength);
            }, processAttributes: function() {
              this.unixPermissions = null, this.dosPermissions = null;
              var d = this.versionMadeBy >> 8;
              this.dir = !!(16 & this.externalFileAttributes), d == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), d == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
            }, parseZIP64ExtraField: function(d) {
              if (this.extraFields[1]) {
                var c = i(this.extraFields[1].value);
                this.uncompressedSize === v.MAX_VALUE_32BITS && (this.uncompressedSize = c.readInt(8)), this.compressedSize === v.MAX_VALUE_32BITS && (this.compressedSize = c.readInt(8)), this.localHeaderOffset === v.MAX_VALUE_32BITS && (this.localHeaderOffset = c.readInt(8)), this.diskNumberStart === v.MAX_VALUE_32BITS && (this.diskNumberStart = c.readInt(4));
              }
            }, readExtraFields: function(d) {
              var c, n, o, x = d.index + this.extraFieldsLength;
              for (this.extraFields || (this.extraFields = {}); d.index + 4 < x; )
                c = d.readInt(2), n = d.readInt(2), o = d.readData(n), this.extraFields[c] = { id: c, length: n, value: o };
              d.setIndex(x);
            }, handleUTF8: function() {
              var d = h.uint8array ? "uint8array" : "array";
              if (this.useUTF8())
                this.fileNameStr = y.utf8decode(this.fileName), this.fileCommentStr = y.utf8decode(this.fileComment);
              else {
                var c = this.findExtraFieldUnicodePath();
                if (c !== null)
                  this.fileNameStr = c;
                else {
                  var n = v.transformTo(d, this.fileName);
                  this.fileNameStr = this.loadOptions.decodeFileName(n);
                }
                var o = this.findExtraFieldUnicodeComment();
                if (o !== null)
                  this.fileCommentStr = o;
                else {
                  var x = v.transformTo(d, this.fileComment);
                  this.fileCommentStr = this.loadOptions.decodeFileName(x);
                }
              }
            }, findExtraFieldUnicodePath: function() {
              var d = this.extraFields[28789];
              if (d) {
                var c = i(d.value);
                return c.readInt(1) !== 1 || e(this.fileName) !== c.readInt(4) ? null : y.utf8decode(c.readData(d.length - 5));
              }
              return null;
            }, findExtraFieldUnicodeComment: function() {
              var d = this.extraFields[25461];
              if (d) {
                var c = i(d.value);
                return c.readInt(1) !== 1 || e(this.fileComment) !== c.readInt(4) ? null : y.utf8decode(c.readData(d.length - 5));
              }
              return null;
            } }, P.exports = g;
          }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(u, P, t) {
            function i(c, n, o) {
              this.name = c, this.dir = o.dir, this.date = o.date, this.comment = o.comment, this.unixPermissions = o.unixPermissions, this.dosPermissions = o.dosPermissions, this._data = n, this._dataBinary = o.binary, this.options = { compression: o.compression, compressionOptions: o.compressionOptions };
            }
            var v = u("./stream/StreamHelper"), a = u("./stream/DataWorker"), e = u("./utf8"), y = u("./compressedObject"), r = u("./stream/GenericWorker");
            i.prototype = { internalStream: function(c) {
              var n = null, o = "string";
              try {
                if (!c)
                  throw new Error("No output type specified.");
                var x = (o = c.toLowerCase()) === "string" || o === "text";
                o !== "binarystring" && o !== "text" || (o = "string"), n = this._decompressWorker();
                var f = !this._dataBinary;
                f && !x && (n = n.pipe(new e.Utf8EncodeWorker())), !f && x && (n = n.pipe(new e.Utf8DecodeWorker()));
              } catch (m) {
                (n = new r("error")).error(m);
              }
              return new v(n, o, "");
            }, async: function(c, n) {
              return this.internalStream(c).accumulate(n);
            }, nodeStream: function(c, n) {
              return this.internalStream(c || "nodebuffer").toNodejsStream(n);
            }, _compressWorker: function(c, n) {
              if (this._data instanceof y && this._data.compression.magic === c.magic)
                return this._data.getCompressedWorker();
              var o = this._decompressWorker();
              return this._dataBinary || (o = o.pipe(new e.Utf8EncodeWorker())), y.createWorkerFrom(o, c, n);
            }, _decompressWorker: function() {
              return this._data instanceof y ? this._data.getContentWorker() : this._data instanceof r ? this._data : new a(this._data);
            } };
            for (var h = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], g = function() {
              throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
            }, d = 0; d < h.length; d++)
              i.prototype[h[d]] = g;
            P.exports = i;
          }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(u, P, t) {
            (function(i) {
              var v, a, e = i.MutationObserver || i.WebKitMutationObserver;
              if (e) {
                var y = 0, r = new e(c), h = i.document.createTextNode("");
                r.observe(h, { characterData: !0 }), v = function() {
                  h.data = y = ++y % 2;
                };
              } else if (i.setImmediate || i.MessageChannel === void 0)
                v = "document" in i && "onreadystatechange" in i.document.createElement("script") ? function() {
                  var n = i.document.createElement("script");
                  n.onreadystatechange = function() {
                    c(), n.onreadystatechange = null, n.parentNode.removeChild(n), n = null;
                  }, i.document.documentElement.appendChild(n);
                } : function() {
                  setTimeout(c, 0);
                };
              else {
                var g = new i.MessageChannel();
                g.port1.onmessage = c, v = function() {
                  g.port2.postMessage(0);
                };
              }
              var d = [];
              function c() {
                var n, o;
                a = !0;
                for (var x = d.length; x; ) {
                  for (o = d, d = [], n = -1; ++n < x; )
                    o[n]();
                  x = d.length;
                }
                a = !1;
              }
              P.exports = function(n) {
                d.push(n) !== 1 || a || v();
              };
            }).call(this, typeof se < "u" ? se : typeof self < "u" ? self : typeof window < "u" ? window : {});
          }, {}], 37: [function(u, P, t) {
            var i = u("immediate");
            function v() {
            }
            var a = {}, e = ["REJECTED"], y = ["FULFILLED"], r = ["PENDING"];
            function h(x) {
              if (typeof x != "function")
                throw new TypeError("resolver must be a function");
              this.state = r, this.queue = [], this.outcome = void 0, x !== v && n(this, x);
            }
            function g(x, f, m) {
              this.promise = x, typeof f == "function" && (this.onFulfilled = f, this.callFulfilled = this.otherCallFulfilled), typeof m == "function" && (this.onRejected = m, this.callRejected = this.otherCallRejected);
            }
            function d(x, f, m) {
              i(function() {
                var C;
                try {
                  C = f(m);
                } catch (p) {
                  return a.reject(x, p);
                }
                C === x ? a.reject(x, new TypeError("Cannot resolve promise with itself")) : a.resolve(x, C);
              });
            }
            function c(x) {
              var f = x && x.then;
              if (x && (typeof x == "object" || typeof x == "function") && typeof f == "function")
                return function() {
                  f.apply(x, arguments);
                };
            }
            function n(x, f) {
              var m = !1;
              function C(X) {
                m || (m = !0, a.reject(x, X));
              }
              function p(X) {
                m || (m = !0, a.resolve(x, X));
              }
              var w = o(function() {
                f(p, C);
              });
              w.status === "error" && C(w.value);
            }
            function o(x, f) {
              var m = {};
              try {
                m.value = x(f), m.status = "success";
              } catch (C) {
                m.status = "error", m.value = C;
              }
              return m;
            }
            (P.exports = h).prototype.finally = function(x) {
              if (typeof x != "function")
                return this;
              var f = this.constructor;
              return this.then(function(m) {
                return f.resolve(x()).then(function() {
                  return m;
                });
              }, function(m) {
                return f.resolve(x()).then(function() {
                  throw m;
                });
              });
            }, h.prototype.catch = function(x) {
              return this.then(null, x);
            }, h.prototype.then = function(x, f) {
              if (typeof x != "function" && this.state === y || typeof f != "function" && this.state === e)
                return this;
              var m = new this.constructor(v);
              return this.state !== r ? d(m, this.state === y ? x : f, this.outcome) : this.queue.push(new g(m, x, f)), m;
            }, g.prototype.callFulfilled = function(x) {
              a.resolve(this.promise, x);
            }, g.prototype.otherCallFulfilled = function(x) {
              d(this.promise, this.onFulfilled, x);
            }, g.prototype.callRejected = function(x) {
              a.reject(this.promise, x);
            }, g.prototype.otherCallRejected = function(x) {
              d(this.promise, this.onRejected, x);
            }, a.resolve = function(x, f) {
              var m = o(c, f);
              if (m.status === "error")
                return a.reject(x, m.value);
              var C = m.value;
              if (C)
                n(x, C);
              else {
                x.state = y, x.outcome = f;
                for (var p = -1, w = x.queue.length; ++p < w; )
                  x.queue[p].callFulfilled(f);
              }
              return x;
            }, a.reject = function(x, f) {
              x.state = e, x.outcome = f;
              for (var m = -1, C = x.queue.length; ++m < C; )
                x.queue[m].callRejected(f);
              return x;
            }, h.resolve = function(x) {
              return x instanceof this ? x : a.resolve(new this(v), x);
            }, h.reject = function(x) {
              var f = new this(v);
              return a.reject(f, x);
            }, h.all = function(x) {
              var f = this;
              if (Object.prototype.toString.call(x) !== "[object Array]")
                return this.reject(new TypeError("must be an array"));
              var m = x.length, C = !1;
              if (!m)
                return this.resolve([]);
              for (var p = new Array(m), w = 0, X = -1, M = new this(v); ++X < m; )
                j(x[X], X);
              return M;
              function j(B, R) {
                f.resolve(B).then(function(D) {
                  p[R] = D, ++w !== m || C || (C = !0, a.resolve(M, p));
                }, function(D) {
                  C || (C = !0, a.reject(M, D));
                });
              }
            }, h.race = function(x) {
              var f = this;
              if (Object.prototype.toString.call(x) !== "[object Array]")
                return this.reject(new TypeError("must be an array"));
              var m = x.length, C = !1;
              if (!m)
                return this.resolve([]);
              for (var p = -1, w = new this(v); ++p < m; )
                X = x[p], f.resolve(X).then(function(M) {
                  C || (C = !0, a.resolve(w, M));
                }, function(M) {
                  C || (C = !0, a.reject(w, M));
                });
              var X;
              return w;
            };
          }, { immediate: 36 }], 38: [function(u, P, t) {
            var i = {};
            (0, u("./lib/utils/common").assign)(i, u("./lib/deflate"), u("./lib/inflate"), u("./lib/zlib/constants")), P.exports = i;
          }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(u, P, t) {
            var i = u("./zlib/deflate"), v = u("./utils/common"), a = u("./utils/strings"), e = u("./zlib/messages"), y = u("./zlib/zstream"), r = Object.prototype.toString, h = 0, g = -1, d = 0, c = 8;
            function n(x) {
              if (!(this instanceof n))
                return new n(x);
              this.options = v.assign({ level: g, method: c, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: d, to: "" }, x || {});
              var f = this.options;
              f.raw && 0 < f.windowBits ? f.windowBits = -f.windowBits : f.gzip && 0 < f.windowBits && f.windowBits < 16 && (f.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new y(), this.strm.avail_out = 0;
              var m = i.deflateInit2(this.strm, f.level, f.method, f.windowBits, f.memLevel, f.strategy);
              if (m !== h)
                throw new Error(e[m]);
              if (f.header && i.deflateSetHeader(this.strm, f.header), f.dictionary) {
                var C;
                if (C = typeof f.dictionary == "string" ? a.string2buf(f.dictionary) : r.call(f.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(f.dictionary) : f.dictionary, (m = i.deflateSetDictionary(this.strm, C)) !== h)
                  throw new Error(e[m]);
                this._dict_set = !0;
              }
            }
            function o(x, f) {
              var m = new n(f);
              if (m.push(x, !0), m.err)
                throw m.msg || e[m.err];
              return m.result;
            }
            n.prototype.push = function(x, f) {
              var m, C, p = this.strm, w = this.options.chunkSize;
              if (this.ended)
                return !1;
              C = f === ~~f ? f : f === !0 ? 4 : 0, typeof x == "string" ? p.input = a.string2buf(x) : r.call(x) === "[object ArrayBuffer]" ? p.input = new Uint8Array(x) : p.input = x, p.next_in = 0, p.avail_in = p.input.length;
              do {
                if (p.avail_out === 0 && (p.output = new v.Buf8(w), p.next_out = 0, p.avail_out = w), (m = i.deflate(p, C)) !== 1 && m !== h)
                  return this.onEnd(m), !(this.ended = !0);
                p.avail_out !== 0 && (p.avail_in !== 0 || C !== 4 && C !== 2) || (this.options.to === "string" ? this.onData(a.buf2binstring(v.shrinkBuf(p.output, p.next_out))) : this.onData(v.shrinkBuf(p.output, p.next_out)));
              } while ((0 < p.avail_in || p.avail_out === 0) && m !== 1);
              return C === 4 ? (m = i.deflateEnd(this.strm), this.onEnd(m), this.ended = !0, m === h) : C !== 2 || (this.onEnd(h), !(p.avail_out = 0));
            }, n.prototype.onData = function(x) {
              this.chunks.push(x);
            }, n.prototype.onEnd = function(x) {
              x === h && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = v.flattenChunks(this.chunks)), this.chunks = [], this.err = x, this.msg = this.strm.msg;
            }, t.Deflate = n, t.deflate = o, t.deflateRaw = function(x, f) {
              return (f = f || {}).raw = !0, o(x, f);
            }, t.gzip = function(x, f) {
              return (f = f || {}).gzip = !0, o(x, f);
            };
          }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(u, P, t) {
            var i = u("./zlib/inflate"), v = u("./utils/common"), a = u("./utils/strings"), e = u("./zlib/constants"), y = u("./zlib/messages"), r = u("./zlib/zstream"), h = u("./zlib/gzheader"), g = Object.prototype.toString;
            function d(n) {
              if (!(this instanceof d))
                return new d(n);
              this.options = v.assign({ chunkSize: 16384, windowBits: 0, to: "" }, n || {});
              var o = this.options;
              o.raw && 0 <= o.windowBits && o.windowBits < 16 && (o.windowBits = -o.windowBits, o.windowBits === 0 && (o.windowBits = -15)), !(0 <= o.windowBits && o.windowBits < 16) || n && n.windowBits || (o.windowBits += 32), 15 < o.windowBits && o.windowBits < 48 && !(15 & o.windowBits) && (o.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new r(), this.strm.avail_out = 0;
              var x = i.inflateInit2(this.strm, o.windowBits);
              if (x !== e.Z_OK)
                throw new Error(y[x]);
              this.header = new h(), i.inflateGetHeader(this.strm, this.header);
            }
            function c(n, o) {
              var x = new d(o);
              if (x.push(n, !0), x.err)
                throw x.msg || y[x.err];
              return x.result;
            }
            d.prototype.push = function(n, o) {
              var x, f, m, C, p, w, X = this.strm, M = this.options.chunkSize, j = this.options.dictionary, B = !1;
              if (this.ended)
                return !1;
              f = o === ~~o ? o : o === !0 ? e.Z_FINISH : e.Z_NO_FLUSH, typeof n == "string" ? X.input = a.binstring2buf(n) : g.call(n) === "[object ArrayBuffer]" ? X.input = new Uint8Array(n) : X.input = n, X.next_in = 0, X.avail_in = X.input.length;
              do {
                if (X.avail_out === 0 && (X.output = new v.Buf8(M), X.next_out = 0, X.avail_out = M), (x = i.inflate(X, e.Z_NO_FLUSH)) === e.Z_NEED_DICT && j && (w = typeof j == "string" ? a.string2buf(j) : g.call(j) === "[object ArrayBuffer]" ? new Uint8Array(j) : j, x = i.inflateSetDictionary(this.strm, w)), x === e.Z_BUF_ERROR && B === !0 && (x = e.Z_OK, B = !1), x !== e.Z_STREAM_END && x !== e.Z_OK)
                  return this.onEnd(x), !(this.ended = !0);
                X.next_out && (X.avail_out !== 0 && x !== e.Z_STREAM_END && (X.avail_in !== 0 || f !== e.Z_FINISH && f !== e.Z_SYNC_FLUSH) || (this.options.to === "string" ? (m = a.utf8border(X.output, X.next_out), C = X.next_out - m, p = a.buf2string(X.output, m), X.next_out = C, X.avail_out = M - C, C && v.arraySet(X.output, X.output, m, C, 0), this.onData(p)) : this.onData(v.shrinkBuf(X.output, X.next_out)))), X.avail_in === 0 && X.avail_out === 0 && (B = !0);
              } while ((0 < X.avail_in || X.avail_out === 0) && x !== e.Z_STREAM_END);
              return x === e.Z_STREAM_END && (f = e.Z_FINISH), f === e.Z_FINISH ? (x = i.inflateEnd(this.strm), this.onEnd(x), this.ended = !0, x === e.Z_OK) : f !== e.Z_SYNC_FLUSH || (this.onEnd(e.Z_OK), !(X.avail_out = 0));
            }, d.prototype.onData = function(n) {
              this.chunks.push(n);
            }, d.prototype.onEnd = function(n) {
              n === e.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = v.flattenChunks(this.chunks)), this.chunks = [], this.err = n, this.msg = this.strm.msg;
            }, t.Inflate = d, t.inflate = c, t.inflateRaw = function(n, o) {
              return (o = o || {}).raw = !0, c(n, o);
            }, t.ungzip = c;
          }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(u, P, t) {
            var i = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
            t.assign = function(e) {
              for (var y = Array.prototype.slice.call(arguments, 1); y.length; ) {
                var r = y.shift();
                if (r) {
                  if (typeof r != "object")
                    throw new TypeError(r + "must be non-object");
                  for (var h in r)
                    r.hasOwnProperty(h) && (e[h] = r[h]);
                }
              }
              return e;
            }, t.shrinkBuf = function(e, y) {
              return e.length === y ? e : e.subarray ? e.subarray(0, y) : (e.length = y, e);
            };
            var v = { arraySet: function(e, y, r, h, g) {
              if (y.subarray && e.subarray)
                e.set(y.subarray(r, r + h), g);
              else
                for (var d = 0; d < h; d++)
                  e[g + d] = y[r + d];
            }, flattenChunks: function(e) {
              var y, r, h, g, d, c;
              for (y = h = 0, r = e.length; y < r; y++)
                h += e[y].length;
              for (c = new Uint8Array(h), y = g = 0, r = e.length; y < r; y++)
                d = e[y], c.set(d, g), g += d.length;
              return c;
            } }, a = { arraySet: function(e, y, r, h, g) {
              for (var d = 0; d < h; d++)
                e[g + d] = y[r + d];
            }, flattenChunks: function(e) {
              return [].concat.apply([], e);
            } };
            t.setTyped = function(e) {
              e ? (t.Buf8 = Uint8Array, t.Buf16 = Uint16Array, t.Buf32 = Int32Array, t.assign(t, v)) : (t.Buf8 = Array, t.Buf16 = Array, t.Buf32 = Array, t.assign(t, a));
            }, t.setTyped(i);
          }, {}], 42: [function(u, P, t) {
            var i = u("./common"), v = !0, a = !0;
            try {
              String.fromCharCode.apply(null, [0]);
            } catch {
              v = !1;
            }
            try {
              String.fromCharCode.apply(null, new Uint8Array(1));
            } catch {
              a = !1;
            }
            for (var e = new i.Buf8(256), y = 0; y < 256; y++)
              e[y] = 252 <= y ? 6 : 248 <= y ? 5 : 240 <= y ? 4 : 224 <= y ? 3 : 192 <= y ? 2 : 1;
            function r(h, g) {
              if (g < 65537 && (h.subarray && a || !h.subarray && v))
                return String.fromCharCode.apply(null, i.shrinkBuf(h, g));
              for (var d = "", c = 0; c < g; c++)
                d += String.fromCharCode(h[c]);
              return d;
            }
            e[254] = e[254] = 1, t.string2buf = function(h) {
              var g, d, c, n, o, x = h.length, f = 0;
              for (n = 0; n < x; n++)
                (64512 & (d = h.charCodeAt(n))) == 55296 && n + 1 < x && (64512 & (c = h.charCodeAt(n + 1))) == 56320 && (d = 65536 + (d - 55296 << 10) + (c - 56320), n++), f += d < 128 ? 1 : d < 2048 ? 2 : d < 65536 ? 3 : 4;
              for (g = new i.Buf8(f), n = o = 0; o < f; n++)
                (64512 & (d = h.charCodeAt(n))) == 55296 && n + 1 < x && (64512 & (c = h.charCodeAt(n + 1))) == 56320 && (d = 65536 + (d - 55296 << 10) + (c - 56320), n++), d < 128 ? g[o++] = d : (d < 2048 ? g[o++] = 192 | d >>> 6 : (d < 65536 ? g[o++] = 224 | d >>> 12 : (g[o++] = 240 | d >>> 18, g[o++] = 128 | d >>> 12 & 63), g[o++] = 128 | d >>> 6 & 63), g[o++] = 128 | 63 & d);
              return g;
            }, t.buf2binstring = function(h) {
              return r(h, h.length);
            }, t.binstring2buf = function(h) {
              for (var g = new i.Buf8(h.length), d = 0, c = g.length; d < c; d++)
                g[d] = h.charCodeAt(d);
              return g;
            }, t.buf2string = function(h, g) {
              var d, c, n, o, x = g || h.length, f = new Array(2 * x);
              for (d = c = 0; d < x; )
                if ((n = h[d++]) < 128)
                  f[c++] = n;
                else if (4 < (o = e[n]))
                  f[c++] = 65533, d += o - 1;
                else {
                  for (n &= o === 2 ? 31 : o === 3 ? 15 : 7; 1 < o && d < x; )
                    n = n << 6 | 63 & h[d++], o--;
                  1 < o ? f[c++] = 65533 : n < 65536 ? f[c++] = n : (n -= 65536, f[c++] = 55296 | n >> 10 & 1023, f[c++] = 56320 | 1023 & n);
                }
              return r(f, c);
            }, t.utf8border = function(h, g) {
              var d;
              for ((g = g || h.length) > h.length && (g = h.length), d = g - 1; 0 <= d && (192 & h[d]) == 128; )
                d--;
              return d < 0 || d === 0 ? g : d + e[h[d]] > g ? d : g;
            };
          }, { "./common": 41 }], 43: [function(u, P, t) {
            P.exports = function(i, v, a, e) {
              for (var y = 65535 & i | 0, r = i >>> 16 & 65535 | 0, h = 0; a !== 0; ) {
                for (a -= h = 2e3 < a ? 2e3 : a; r = r + (y = y + v[e++] | 0) | 0, --h; )
                  ;
                y %= 65521, r %= 65521;
              }
              return y | r << 16 | 0;
            };
          }, {}], 44: [function(u, P, t) {
            P.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
          }, {}], 45: [function(u, P, t) {
            var i = function() {
              for (var v, a = [], e = 0; e < 256; e++) {
                v = e;
                for (var y = 0; y < 8; y++)
                  v = 1 & v ? 3988292384 ^ v >>> 1 : v >>> 1;
                a[e] = v;
              }
              return a;
            }();
            P.exports = function(v, a, e, y) {
              var r = i, h = y + e;
              v ^= -1;
              for (var g = y; g < h; g++)
                v = v >>> 8 ^ r[255 & (v ^ a[g])];
              return -1 ^ v;
            };
          }, {}], 46: [function(u, P, t) {
            var i, v = u("../utils/common"), a = u("./trees"), e = u("./adler32"), y = u("./crc32"), r = u("./messages"), h = 0, g = 4, d = 0, c = -2, n = -1, o = 4, x = 2, f = 8, m = 9, C = 286, p = 30, w = 19, X = 2 * C + 1, M = 15, j = 3, B = 258, R = B + j + 1, D = 42, b = 113, l = 1, _ = 2, S = 3, A = 4;
            function F(E, te) {
              return E.msg = r[te], te;
            }
            function T(E) {
              return (E << 1) - (4 < E ? 9 : 0);
            }
            function O(E) {
              for (var te = E.length; 0 <= --te; )
                E[te] = 0;
            }
            function U(E) {
              var te = E.state, re = te.pending;
              re > E.avail_out && (re = E.avail_out), re !== 0 && (v.arraySet(E.output, te.pending_buf, te.pending_out, re, E.next_out), E.next_out += re, te.pending_out += re, E.total_out += re, E.avail_out -= re, te.pending -= re, te.pending === 0 && (te.pending_out = 0));
            }
            function G(E, te) {
              a._tr_flush_block(E, 0 <= E.block_start ? E.block_start : -1, E.strstart - E.block_start, te), E.block_start = E.strstart, U(E.strm);
            }
            function K(E, te) {
              E.pending_buf[E.pending++] = te;
            }
            function W(E, te) {
              E.pending_buf[E.pending++] = te >>> 8 & 255, E.pending_buf[E.pending++] = 255 & te;
            }
            function z(E, te) {
              var re, ee, $ = E.max_chain_length, k = E.strstart, H = E.prev_length, ne = E.nice_match, ae = E.strstart > E.w_size - R ? E.strstart - (E.w_size - R) : 0, he = E.window, ue = E.w_mask, fe = E.prev, me = E.strstart + B, Fe = he[k + H - 1], we = he[k + H];
              E.prev_length >= E.good_match && ($ >>= 2), ne > E.lookahead && (ne = E.lookahead);
              do
                if (he[(re = te) + H] === we && he[re + H - 1] === Fe && he[re] === he[k] && he[++re] === he[k + 1]) {
                  k += 2, re++;
                  do
                    ;
                  while (he[++k] === he[++re] && he[++k] === he[++re] && he[++k] === he[++re] && he[++k] === he[++re] && he[++k] === he[++re] && he[++k] === he[++re] && he[++k] === he[++re] && he[++k] === he[++re] && k < me);
                  if (ee = B - (me - k), k = me - B, H < ee) {
                    if (E.match_start = te, ne <= (H = ee))
                      break;
                    Fe = he[k + H - 1], we = he[k + H];
                  }
                }
              while ((te = fe[te & ue]) > ae && --$ != 0);
              return H <= E.lookahead ? H : E.lookahead;
            }
            function V(E) {
              var te, re, ee, $, k, H, ne, ae, he, ue, fe = E.w_size;
              do {
                if ($ = E.window_size - E.lookahead - E.strstart, E.strstart >= fe + (fe - R)) {
                  for (v.arraySet(E.window, E.window, fe, fe, 0), E.match_start -= fe, E.strstart -= fe, E.block_start -= fe, te = re = E.hash_size; ee = E.head[--te], E.head[te] = fe <= ee ? ee - fe : 0, --re; )
                    ;
                  for (te = re = fe; ee = E.prev[--te], E.prev[te] = fe <= ee ? ee - fe : 0, --re; )
                    ;
                  $ += fe;
                }
                if (E.strm.avail_in === 0)
                  break;
                if (H = E.strm, ne = E.window, ae = E.strstart + E.lookahead, he = $, ue = void 0, ue = H.avail_in, he < ue && (ue = he), re = ue === 0 ? 0 : (H.avail_in -= ue, v.arraySet(ne, H.input, H.next_in, ue, ae), H.state.wrap === 1 ? H.adler = e(H.adler, ne, ue, ae) : H.state.wrap === 2 && (H.adler = y(H.adler, ne, ue, ae)), H.next_in += ue, H.total_in += ue, ue), E.lookahead += re, E.lookahead + E.insert >= j)
                  for (k = E.strstart - E.insert, E.ins_h = E.window[k], E.ins_h = (E.ins_h << E.hash_shift ^ E.window[k + 1]) & E.hash_mask; E.insert && (E.ins_h = (E.ins_h << E.hash_shift ^ E.window[k + j - 1]) & E.hash_mask, E.prev[k & E.w_mask] = E.head[E.ins_h], E.head[E.ins_h] = k, k++, E.insert--, !(E.lookahead + E.insert < j)); )
                    ;
              } while (E.lookahead < R && E.strm.avail_in !== 0);
            }
            function L(E, te) {
              for (var re, ee; ; ) {
                if (E.lookahead < R) {
                  if (V(E), E.lookahead < R && te === h)
                    return l;
                  if (E.lookahead === 0)
                    break;
                }
                if (re = 0, E.lookahead >= j && (E.ins_h = (E.ins_h << E.hash_shift ^ E.window[E.strstart + j - 1]) & E.hash_mask, re = E.prev[E.strstart & E.w_mask] = E.head[E.ins_h], E.head[E.ins_h] = E.strstart), re !== 0 && E.strstart - re <= E.w_size - R && (E.match_length = z(E, re)), E.match_length >= j)
                  if (ee = a._tr_tally(E, E.strstart - E.match_start, E.match_length - j), E.lookahead -= E.match_length, E.match_length <= E.max_lazy_match && E.lookahead >= j) {
                    for (E.match_length--; E.strstart++, E.ins_h = (E.ins_h << E.hash_shift ^ E.window[E.strstart + j - 1]) & E.hash_mask, re = E.prev[E.strstart & E.w_mask] = E.head[E.ins_h], E.head[E.ins_h] = E.strstart, --E.match_length != 0; )
                      ;
                    E.strstart++;
                  } else
                    E.strstart += E.match_length, E.match_length = 0, E.ins_h = E.window[E.strstart], E.ins_h = (E.ins_h << E.hash_shift ^ E.window[E.strstart + 1]) & E.hash_mask;
                else
                  ee = a._tr_tally(E, 0, E.window[E.strstart]), E.lookahead--, E.strstart++;
                if (ee && (G(E, !1), E.strm.avail_out === 0))
                  return l;
              }
              return E.insert = E.strstart < j - 1 ? E.strstart : j - 1, te === g ? (G(E, !0), E.strm.avail_out === 0 ? S : A) : E.last_lit && (G(E, !1), E.strm.avail_out === 0) ? l : _;
            }
            function Y(E, te) {
              for (var re, ee, $; ; ) {
                if (E.lookahead < R) {
                  if (V(E), E.lookahead < R && te === h)
                    return l;
                  if (E.lookahead === 0)
                    break;
                }
                if (re = 0, E.lookahead >= j && (E.ins_h = (E.ins_h << E.hash_shift ^ E.window[E.strstart + j - 1]) & E.hash_mask, re = E.prev[E.strstart & E.w_mask] = E.head[E.ins_h], E.head[E.ins_h] = E.strstart), E.prev_length = E.match_length, E.prev_match = E.match_start, E.match_length = j - 1, re !== 0 && E.prev_length < E.max_lazy_match && E.strstart - re <= E.w_size - R && (E.match_length = z(E, re), E.match_length <= 5 && (E.strategy === 1 || E.match_length === j && 4096 < E.strstart - E.match_start) && (E.match_length = j - 1)), E.prev_length >= j && E.match_length <= E.prev_length) {
                  for ($ = E.strstart + E.lookahead - j, ee = a._tr_tally(E, E.strstart - 1 - E.prev_match, E.prev_length - j), E.lookahead -= E.prev_length - 1, E.prev_length -= 2; ++E.strstart <= $ && (E.ins_h = (E.ins_h << E.hash_shift ^ E.window[E.strstart + j - 1]) & E.hash_mask, re = E.prev[E.strstart & E.w_mask] = E.head[E.ins_h], E.head[E.ins_h] = E.strstart), --E.prev_length != 0; )
                    ;
                  if (E.match_available = 0, E.match_length = j - 1, E.strstart++, ee && (G(E, !1), E.strm.avail_out === 0))
                    return l;
                } else if (E.match_available) {
                  if ((ee = a._tr_tally(E, 0, E.window[E.strstart - 1])) && G(E, !1), E.strstart++, E.lookahead--, E.strm.avail_out === 0)
                    return l;
                } else
                  E.match_available = 1, E.strstart++, E.lookahead--;
              }
              return E.match_available && (ee = a._tr_tally(E, 0, E.window[E.strstart - 1]), E.match_available = 0), E.insert = E.strstart < j - 1 ? E.strstart : j - 1, te === g ? (G(E, !0), E.strm.avail_out === 0 ? S : A) : E.last_lit && (G(E, !1), E.strm.avail_out === 0) ? l : _;
            }
            function J(E, te, re, ee, $) {
              this.good_length = E, this.max_lazy = te, this.nice_length = re, this.max_chain = ee, this.func = $;
            }
            function ie() {
              this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = f, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new v.Buf16(2 * X), this.dyn_dtree = new v.Buf16(2 * (2 * p + 1)), this.bl_tree = new v.Buf16(2 * (2 * w + 1)), O(this.dyn_ltree), O(this.dyn_dtree), O(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new v.Buf16(M + 1), this.heap = new v.Buf16(2 * C + 1), O(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new v.Buf16(2 * C + 1), O(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
            }
            function q(E) {
              var te;
              return E && E.state ? (E.total_in = E.total_out = 0, E.data_type = x, (te = E.state).pending = 0, te.pending_out = 0, te.wrap < 0 && (te.wrap = -te.wrap), te.status = te.wrap ? D : b, E.adler = te.wrap === 2 ? 0 : 1, te.last_flush = h, a._tr_init(te), d) : F(E, c);
            }
            function N(E) {
              var te = q(E);
              return te === d && function(re) {
                re.window_size = 2 * re.w_size, O(re.head), re.max_lazy_match = i[re.level].max_lazy, re.good_match = i[re.level].good_length, re.nice_match = i[re.level].nice_length, re.max_chain_length = i[re.level].max_chain, re.strstart = 0, re.block_start = 0, re.lookahead = 0, re.insert = 0, re.match_length = re.prev_length = j - 1, re.match_available = 0, re.ins_h = 0;
              }(E.state), te;
            }
            function Z(E, te, re, ee, $, k) {
              if (!E)
                return c;
              var H = 1;
              if (te === n && (te = 6), ee < 0 ? (H = 0, ee = -ee) : 15 < ee && (H = 2, ee -= 16), $ < 1 || m < $ || re !== f || ee < 8 || 15 < ee || te < 0 || 9 < te || k < 0 || o < k)
                return F(E, c);
              ee === 8 && (ee = 9);
              var ne = new ie();
              return (E.state = ne).strm = E, ne.wrap = H, ne.gzhead = null, ne.w_bits = ee, ne.w_size = 1 << ne.w_bits, ne.w_mask = ne.w_size - 1, ne.hash_bits = $ + 7, ne.hash_size = 1 << ne.hash_bits, ne.hash_mask = ne.hash_size - 1, ne.hash_shift = ~~((ne.hash_bits + j - 1) / j), ne.window = new v.Buf8(2 * ne.w_size), ne.head = new v.Buf16(ne.hash_size), ne.prev = new v.Buf16(ne.w_size), ne.lit_bufsize = 1 << $ + 6, ne.pending_buf_size = 4 * ne.lit_bufsize, ne.pending_buf = new v.Buf8(ne.pending_buf_size), ne.d_buf = 1 * ne.lit_bufsize, ne.l_buf = 3 * ne.lit_bufsize, ne.level = te, ne.strategy = k, ne.method = re, N(E);
            }
            i = [new J(0, 0, 0, 0, function(E, te) {
              var re = 65535;
              for (re > E.pending_buf_size - 5 && (re = E.pending_buf_size - 5); ; ) {
                if (E.lookahead <= 1) {
                  if (V(E), E.lookahead === 0 && te === h)
                    return l;
                  if (E.lookahead === 0)
                    break;
                }
                E.strstart += E.lookahead, E.lookahead = 0;
                var ee = E.block_start + re;
                if ((E.strstart === 0 || E.strstart >= ee) && (E.lookahead = E.strstart - ee, E.strstart = ee, G(E, !1), E.strm.avail_out === 0) || E.strstart - E.block_start >= E.w_size - R && (G(E, !1), E.strm.avail_out === 0))
                  return l;
              }
              return E.insert = 0, te === g ? (G(E, !0), E.strm.avail_out === 0 ? S : A) : (E.strstart > E.block_start && (G(E, !1), E.strm.avail_out), l);
            }), new J(4, 4, 8, 4, L), new J(4, 5, 16, 8, L), new J(4, 6, 32, 32, L), new J(4, 4, 16, 16, Y), new J(8, 16, 32, 32, Y), new J(8, 16, 128, 128, Y), new J(8, 32, 128, 256, Y), new J(32, 128, 258, 1024, Y), new J(32, 258, 258, 4096, Y)], t.deflateInit = function(E, te) {
              return Z(E, te, f, 15, 8, 0);
            }, t.deflateInit2 = Z, t.deflateReset = N, t.deflateResetKeep = q, t.deflateSetHeader = function(E, te) {
              return E && E.state ? E.state.wrap !== 2 ? c : (E.state.gzhead = te, d) : c;
            }, t.deflate = function(E, te) {
              var re, ee, $, k;
              if (!E || !E.state || 5 < te || te < 0)
                return E ? F(E, c) : c;
              if (ee = E.state, !E.output || !E.input && E.avail_in !== 0 || ee.status === 666 && te !== g)
                return F(E, E.avail_out === 0 ? -5 : c);
              if (ee.strm = E, re = ee.last_flush, ee.last_flush = te, ee.status === D)
                if (ee.wrap === 2)
                  E.adler = 0, K(ee, 31), K(ee, 139), K(ee, 8), ee.gzhead ? (K(ee, (ee.gzhead.text ? 1 : 0) + (ee.gzhead.hcrc ? 2 : 0) + (ee.gzhead.extra ? 4 : 0) + (ee.gzhead.name ? 8 : 0) + (ee.gzhead.comment ? 16 : 0)), K(ee, 255 & ee.gzhead.time), K(ee, ee.gzhead.time >> 8 & 255), K(ee, ee.gzhead.time >> 16 & 255), K(ee, ee.gzhead.time >> 24 & 255), K(ee, ee.level === 9 ? 2 : 2 <= ee.strategy || ee.level < 2 ? 4 : 0), K(ee, 255 & ee.gzhead.os), ee.gzhead.extra && ee.gzhead.extra.length && (K(ee, 255 & ee.gzhead.extra.length), K(ee, ee.gzhead.extra.length >> 8 & 255)), ee.gzhead.hcrc && (E.adler = y(E.adler, ee.pending_buf, ee.pending, 0)), ee.gzindex = 0, ee.status = 69) : (K(ee, 0), K(ee, 0), K(ee, 0), K(ee, 0), K(ee, 0), K(ee, ee.level === 9 ? 2 : 2 <= ee.strategy || ee.level < 2 ? 4 : 0), K(ee, 3), ee.status = b);
                else {
                  var H = f + (ee.w_bits - 8 << 4) << 8;
                  H |= (2 <= ee.strategy || ee.level < 2 ? 0 : ee.level < 6 ? 1 : ee.level === 6 ? 2 : 3) << 6, ee.strstart !== 0 && (H |= 32), H += 31 - H % 31, ee.status = b, W(ee, H), ee.strstart !== 0 && (W(ee, E.adler >>> 16), W(ee, 65535 & E.adler)), E.adler = 1;
                }
              if (ee.status === 69)
                if (ee.gzhead.extra) {
                  for ($ = ee.pending; ee.gzindex < (65535 & ee.gzhead.extra.length) && (ee.pending !== ee.pending_buf_size || (ee.gzhead.hcrc && ee.pending > $ && (E.adler = y(E.adler, ee.pending_buf, ee.pending - $, $)), U(E), $ = ee.pending, ee.pending !== ee.pending_buf_size)); )
                    K(ee, 255 & ee.gzhead.extra[ee.gzindex]), ee.gzindex++;
                  ee.gzhead.hcrc && ee.pending > $ && (E.adler = y(E.adler, ee.pending_buf, ee.pending - $, $)), ee.gzindex === ee.gzhead.extra.length && (ee.gzindex = 0, ee.status = 73);
                } else
                  ee.status = 73;
              if (ee.status === 73)
                if (ee.gzhead.name) {
                  $ = ee.pending;
                  do {
                    if (ee.pending === ee.pending_buf_size && (ee.gzhead.hcrc && ee.pending > $ && (E.adler = y(E.adler, ee.pending_buf, ee.pending - $, $)), U(E), $ = ee.pending, ee.pending === ee.pending_buf_size)) {
                      k = 1;
                      break;
                    }
                    k = ee.gzindex < ee.gzhead.name.length ? 255 & ee.gzhead.name.charCodeAt(ee.gzindex++) : 0, K(ee, k);
                  } while (k !== 0);
                  ee.gzhead.hcrc && ee.pending > $ && (E.adler = y(E.adler, ee.pending_buf, ee.pending - $, $)), k === 0 && (ee.gzindex = 0, ee.status = 91);
                } else
                  ee.status = 91;
              if (ee.status === 91)
                if (ee.gzhead.comment) {
                  $ = ee.pending;
                  do {
                    if (ee.pending === ee.pending_buf_size && (ee.gzhead.hcrc && ee.pending > $ && (E.adler = y(E.adler, ee.pending_buf, ee.pending - $, $)), U(E), $ = ee.pending, ee.pending === ee.pending_buf_size)) {
                      k = 1;
                      break;
                    }
                    k = ee.gzindex < ee.gzhead.comment.length ? 255 & ee.gzhead.comment.charCodeAt(ee.gzindex++) : 0, K(ee, k);
                  } while (k !== 0);
                  ee.gzhead.hcrc && ee.pending > $ && (E.adler = y(E.adler, ee.pending_buf, ee.pending - $, $)), k === 0 && (ee.status = 103);
                } else
                  ee.status = 103;
              if (ee.status === 103 && (ee.gzhead.hcrc ? (ee.pending + 2 > ee.pending_buf_size && U(E), ee.pending + 2 <= ee.pending_buf_size && (K(ee, 255 & E.adler), K(ee, E.adler >> 8 & 255), E.adler = 0, ee.status = b)) : ee.status = b), ee.pending !== 0) {
                if (U(E), E.avail_out === 0)
                  return ee.last_flush = -1, d;
              } else if (E.avail_in === 0 && T(te) <= T(re) && te !== g)
                return F(E, -5);
              if (ee.status === 666 && E.avail_in !== 0)
                return F(E, -5);
              if (E.avail_in !== 0 || ee.lookahead !== 0 || te !== h && ee.status !== 666) {
                var ne = ee.strategy === 2 ? function(ae, he) {
                  for (var ue; ; ) {
                    if (ae.lookahead === 0 && (V(ae), ae.lookahead === 0)) {
                      if (he === h)
                        return l;
                      break;
                    }
                    if (ae.match_length = 0, ue = a._tr_tally(ae, 0, ae.window[ae.strstart]), ae.lookahead--, ae.strstart++, ue && (G(ae, !1), ae.strm.avail_out === 0))
                      return l;
                  }
                  return ae.insert = 0, he === g ? (G(ae, !0), ae.strm.avail_out === 0 ? S : A) : ae.last_lit && (G(ae, !1), ae.strm.avail_out === 0) ? l : _;
                }(ee, te) : ee.strategy === 3 ? function(ae, he) {
                  for (var ue, fe, me, Fe, we = ae.window; ; ) {
                    if (ae.lookahead <= B) {
                      if (V(ae), ae.lookahead <= B && he === h)
                        return l;
                      if (ae.lookahead === 0)
                        break;
                    }
                    if (ae.match_length = 0, ae.lookahead >= j && 0 < ae.strstart && (fe = we[me = ae.strstart - 1]) === we[++me] && fe === we[++me] && fe === we[++me]) {
                      Fe = ae.strstart + B;
                      do
                        ;
                      while (fe === we[++me] && fe === we[++me] && fe === we[++me] && fe === we[++me] && fe === we[++me] && fe === we[++me] && fe === we[++me] && fe === we[++me] && me < Fe);
                      ae.match_length = B - (Fe - me), ae.match_length > ae.lookahead && (ae.match_length = ae.lookahead);
                    }
                    if (ae.match_length >= j ? (ue = a._tr_tally(ae, 1, ae.match_length - j), ae.lookahead -= ae.match_length, ae.strstart += ae.match_length, ae.match_length = 0) : (ue = a._tr_tally(ae, 0, ae.window[ae.strstart]), ae.lookahead--, ae.strstart++), ue && (G(ae, !1), ae.strm.avail_out === 0))
                      return l;
                  }
                  return ae.insert = 0, he === g ? (G(ae, !0), ae.strm.avail_out === 0 ? S : A) : ae.last_lit && (G(ae, !1), ae.strm.avail_out === 0) ? l : _;
                }(ee, te) : i[ee.level].func(ee, te);
                if (ne !== S && ne !== A || (ee.status = 666), ne === l || ne === S)
                  return E.avail_out === 0 && (ee.last_flush = -1), d;
                if (ne === _ && (te === 1 ? a._tr_align(ee) : te !== 5 && (a._tr_stored_block(ee, 0, 0, !1), te === 3 && (O(ee.head), ee.lookahead === 0 && (ee.strstart = 0, ee.block_start = 0, ee.insert = 0))), U(E), E.avail_out === 0))
                  return ee.last_flush = -1, d;
              }
              return te !== g ? d : ee.wrap <= 0 ? 1 : (ee.wrap === 2 ? (K(ee, 255 & E.adler), K(ee, E.adler >> 8 & 255), K(ee, E.adler >> 16 & 255), K(ee, E.adler >> 24 & 255), K(ee, 255 & E.total_in), K(ee, E.total_in >> 8 & 255), K(ee, E.total_in >> 16 & 255), K(ee, E.total_in >> 24 & 255)) : (W(ee, E.adler >>> 16), W(ee, 65535 & E.adler)), U(E), 0 < ee.wrap && (ee.wrap = -ee.wrap), ee.pending !== 0 ? d : 1);
            }, t.deflateEnd = function(E) {
              var te;
              return E && E.state ? (te = E.state.status) !== D && te !== 69 && te !== 73 && te !== 91 && te !== 103 && te !== b && te !== 666 ? F(E, c) : (E.state = null, te === b ? F(E, -3) : d) : c;
            }, t.deflateSetDictionary = function(E, te) {
              var re, ee, $, k, H, ne, ae, he, ue = te.length;
              if (!E || !E.state || (k = (re = E.state).wrap) === 2 || k === 1 && re.status !== D || re.lookahead)
                return c;
              for (k === 1 && (E.adler = e(E.adler, te, ue, 0)), re.wrap = 0, ue >= re.w_size && (k === 0 && (O(re.head), re.strstart = 0, re.block_start = 0, re.insert = 0), he = new v.Buf8(re.w_size), v.arraySet(he, te, ue - re.w_size, re.w_size, 0), te = he, ue = re.w_size), H = E.avail_in, ne = E.next_in, ae = E.input, E.avail_in = ue, E.next_in = 0, E.input = te, V(re); re.lookahead >= j; ) {
                for (ee = re.strstart, $ = re.lookahead - (j - 1); re.ins_h = (re.ins_h << re.hash_shift ^ re.window[ee + j - 1]) & re.hash_mask, re.prev[ee & re.w_mask] = re.head[re.ins_h], re.head[re.ins_h] = ee, ee++, --$; )
                  ;
                re.strstart = ee, re.lookahead = j - 1, V(re);
              }
              return re.strstart += re.lookahead, re.block_start = re.strstart, re.insert = re.lookahead, re.lookahead = 0, re.match_length = re.prev_length = j - 1, re.match_available = 0, E.next_in = ne, E.input = ae, E.avail_in = H, re.wrap = k, d;
            }, t.deflateInfo = "pako deflate (from Nodeca project)";
          }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(u, P, t) {
            P.exports = function() {
              this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
            };
          }, {}], 48: [function(u, P, t) {
            P.exports = function(i, v) {
              var a, e, y, r, h, g, d, c, n, o, x, f, m, C, p, w, X, M, j, B, R, D, b, l, _;
              a = i.state, e = i.next_in, l = i.input, y = e + (i.avail_in - 5), r = i.next_out, _ = i.output, h = r - (v - i.avail_out), g = r + (i.avail_out - 257), d = a.dmax, c = a.wsize, n = a.whave, o = a.wnext, x = a.window, f = a.hold, m = a.bits, C = a.lencode, p = a.distcode, w = (1 << a.lenbits) - 1, X = (1 << a.distbits) - 1;
              e:
                do {
                  m < 15 && (f += l[e++] << m, m += 8, f += l[e++] << m, m += 8), M = C[f & w];
                  t:
                    for (; ; ) {
                      if (f >>>= j = M >>> 24, m -= j, (j = M >>> 16 & 255) === 0)
                        _[r++] = 65535 & M;
                      else {
                        if (!(16 & j)) {
                          if (!(64 & j)) {
                            M = C[(65535 & M) + (f & (1 << j) - 1)];
                            continue t;
                          }
                          if (32 & j) {
                            a.mode = 12;
                            break e;
                          }
                          i.msg = "invalid literal/length code", a.mode = 30;
                          break e;
                        }
                        B = 65535 & M, (j &= 15) && (m < j && (f += l[e++] << m, m += 8), B += f & (1 << j) - 1, f >>>= j, m -= j), m < 15 && (f += l[e++] << m, m += 8, f += l[e++] << m, m += 8), M = p[f & X];
                        n:
                          for (; ; ) {
                            if (f >>>= j = M >>> 24, m -= j, !(16 & (j = M >>> 16 & 255))) {
                              if (!(64 & j)) {
                                M = p[(65535 & M) + (f & (1 << j) - 1)];
                                continue n;
                              }
                              i.msg = "invalid distance code", a.mode = 30;
                              break e;
                            }
                            if (R = 65535 & M, m < (j &= 15) && (f += l[e++] << m, (m += 8) < j && (f += l[e++] << m, m += 8)), d < (R += f & (1 << j) - 1)) {
                              i.msg = "invalid distance too far back", a.mode = 30;
                              break e;
                            }
                            if (f >>>= j, m -= j, (j = r - h) < R) {
                              if (n < (j = R - j) && a.sane) {
                                i.msg = "invalid distance too far back", a.mode = 30;
                                break e;
                              }
                              if (b = x, (D = 0) === o) {
                                if (D += c - j, j < B) {
                                  for (B -= j; _[r++] = x[D++], --j; )
                                    ;
                                  D = r - R, b = _;
                                }
                              } else if (o < j) {
                                if (D += c + o - j, (j -= o) < B) {
                                  for (B -= j; _[r++] = x[D++], --j; )
                                    ;
                                  if (D = 0, o < B) {
                                    for (B -= j = o; _[r++] = x[D++], --j; )
                                      ;
                                    D = r - R, b = _;
                                  }
                                }
                              } else if (D += o - j, j < B) {
                                for (B -= j; _[r++] = x[D++], --j; )
                                  ;
                                D = r - R, b = _;
                              }
                              for (; 2 < B; )
                                _[r++] = b[D++], _[r++] = b[D++], _[r++] = b[D++], B -= 3;
                              B && (_[r++] = b[D++], 1 < B && (_[r++] = b[D++]));
                            } else {
                              for (D = r - R; _[r++] = _[D++], _[r++] = _[D++], _[r++] = _[D++], 2 < (B -= 3); )
                                ;
                              B && (_[r++] = _[D++], 1 < B && (_[r++] = _[D++]));
                            }
                            break;
                          }
                      }
                      break;
                    }
                } while (e < y && r < g);
              e -= B = m >> 3, f &= (1 << (m -= B << 3)) - 1, i.next_in = e, i.next_out = r, i.avail_in = e < y ? y - e + 5 : 5 - (e - y), i.avail_out = r < g ? g - r + 257 : 257 - (r - g), a.hold = f, a.bits = m;
            };
          }, {}], 49: [function(u, P, t) {
            var i = u("../utils/common"), v = u("./adler32"), a = u("./crc32"), e = u("./inffast"), y = u("./inftrees"), r = 1, h = 2, g = 0, d = -2, c = 1, n = 852, o = 592;
            function x(D) {
              return (D >>> 24 & 255) + (D >>> 8 & 65280) + ((65280 & D) << 8) + ((255 & D) << 24);
            }
            function f() {
              this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new i.Buf16(320), this.work = new i.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
            }
            function m(D) {
              var b;
              return D && D.state ? (b = D.state, D.total_in = D.total_out = b.total = 0, D.msg = "", b.wrap && (D.adler = 1 & b.wrap), b.mode = c, b.last = 0, b.havedict = 0, b.dmax = 32768, b.head = null, b.hold = 0, b.bits = 0, b.lencode = b.lendyn = new i.Buf32(n), b.distcode = b.distdyn = new i.Buf32(o), b.sane = 1, b.back = -1, g) : d;
            }
            function C(D) {
              var b;
              return D && D.state ? ((b = D.state).wsize = 0, b.whave = 0, b.wnext = 0, m(D)) : d;
            }
            function p(D, b) {
              var l, _;
              return D && D.state ? (_ = D.state, b < 0 ? (l = 0, b = -b) : (l = 1 + (b >> 4), b < 48 && (b &= 15)), b && (b < 8 || 15 < b) ? d : (_.window !== null && _.wbits !== b && (_.window = null), _.wrap = l, _.wbits = b, C(D))) : d;
            }
            function w(D, b) {
              var l, _;
              return D ? (_ = new f(), (D.state = _).window = null, (l = p(D, b)) !== g && (D.state = null), l) : d;
            }
            var X, M, j = !0;
            function B(D) {
              if (j) {
                var b;
                for (X = new i.Buf32(512), M = new i.Buf32(32), b = 0; b < 144; )
                  D.lens[b++] = 8;
                for (; b < 256; )
                  D.lens[b++] = 9;
                for (; b < 280; )
                  D.lens[b++] = 7;
                for (; b < 288; )
                  D.lens[b++] = 8;
                for (y(r, D.lens, 0, 288, X, 0, D.work, { bits: 9 }), b = 0; b < 32; )
                  D.lens[b++] = 5;
                y(h, D.lens, 0, 32, M, 0, D.work, { bits: 5 }), j = !1;
              }
              D.lencode = X, D.lenbits = 9, D.distcode = M, D.distbits = 5;
            }
            function R(D, b, l, _) {
              var S, A = D.state;
              return A.window === null && (A.wsize = 1 << A.wbits, A.wnext = 0, A.whave = 0, A.window = new i.Buf8(A.wsize)), _ >= A.wsize ? (i.arraySet(A.window, b, l - A.wsize, A.wsize, 0), A.wnext = 0, A.whave = A.wsize) : (_ < (S = A.wsize - A.wnext) && (S = _), i.arraySet(A.window, b, l - _, S, A.wnext), (_ -= S) ? (i.arraySet(A.window, b, l - _, _, 0), A.wnext = _, A.whave = A.wsize) : (A.wnext += S, A.wnext === A.wsize && (A.wnext = 0), A.whave < A.wsize && (A.whave += S))), 0;
            }
            t.inflateReset = C, t.inflateReset2 = p, t.inflateResetKeep = m, t.inflateInit = function(D) {
              return w(D, 15);
            }, t.inflateInit2 = w, t.inflate = function(D, b) {
              var l, _, S, A, F, T, O, U, G, K, W, z, V, L, Y, J, ie, q, N, Z, E, te, re, ee, $ = 0, k = new i.Buf8(4), H = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
              if (!D || !D.state || !D.output || !D.input && D.avail_in !== 0)
                return d;
              (l = D.state).mode === 12 && (l.mode = 13), F = D.next_out, S = D.output, O = D.avail_out, A = D.next_in, _ = D.input, T = D.avail_in, U = l.hold, G = l.bits, K = T, W = O, te = g;
              e:
                for (; ; )
                  switch (l.mode) {
                    case c:
                      if (l.wrap === 0) {
                        l.mode = 13;
                        break;
                      }
                      for (; G < 16; ) {
                        if (T === 0)
                          break e;
                        T--, U += _[A++] << G, G += 8;
                      }
                      if (2 & l.wrap && U === 35615) {
                        k[l.check = 0] = 255 & U, k[1] = U >>> 8 & 255, l.check = a(l.check, k, 2, 0), G = U = 0, l.mode = 2;
                        break;
                      }
                      if (l.flags = 0, l.head && (l.head.done = !1), !(1 & l.wrap) || (((255 & U) << 8) + (U >> 8)) % 31) {
                        D.msg = "incorrect header check", l.mode = 30;
                        break;
                      }
                      if ((15 & U) != 8) {
                        D.msg = "unknown compression method", l.mode = 30;
                        break;
                      }
                      if (G -= 4, E = 8 + (15 & (U >>>= 4)), l.wbits === 0)
                        l.wbits = E;
                      else if (E > l.wbits) {
                        D.msg = "invalid window size", l.mode = 30;
                        break;
                      }
                      l.dmax = 1 << E, D.adler = l.check = 1, l.mode = 512 & U ? 10 : 12, G = U = 0;
                      break;
                    case 2:
                      for (; G < 16; ) {
                        if (T === 0)
                          break e;
                        T--, U += _[A++] << G, G += 8;
                      }
                      if (l.flags = U, (255 & l.flags) != 8) {
                        D.msg = "unknown compression method", l.mode = 30;
                        break;
                      }
                      if (57344 & l.flags) {
                        D.msg = "unknown header flags set", l.mode = 30;
                        break;
                      }
                      l.head && (l.head.text = U >> 8 & 1), 512 & l.flags && (k[0] = 255 & U, k[1] = U >>> 8 & 255, l.check = a(l.check, k, 2, 0)), G = U = 0, l.mode = 3;
                    case 3:
                      for (; G < 32; ) {
                        if (T === 0)
                          break e;
                        T--, U += _[A++] << G, G += 8;
                      }
                      l.head && (l.head.time = U), 512 & l.flags && (k[0] = 255 & U, k[1] = U >>> 8 & 255, k[2] = U >>> 16 & 255, k[3] = U >>> 24 & 255, l.check = a(l.check, k, 4, 0)), G = U = 0, l.mode = 4;
                    case 4:
                      for (; G < 16; ) {
                        if (T === 0)
                          break e;
                        T--, U += _[A++] << G, G += 8;
                      }
                      l.head && (l.head.xflags = 255 & U, l.head.os = U >> 8), 512 & l.flags && (k[0] = 255 & U, k[1] = U >>> 8 & 255, l.check = a(l.check, k, 2, 0)), G = U = 0, l.mode = 5;
                    case 5:
                      if (1024 & l.flags) {
                        for (; G < 16; ) {
                          if (T === 0)
                            break e;
                          T--, U += _[A++] << G, G += 8;
                        }
                        l.length = U, l.head && (l.head.extra_len = U), 512 & l.flags && (k[0] = 255 & U, k[1] = U >>> 8 & 255, l.check = a(l.check, k, 2, 0)), G = U = 0;
                      } else
                        l.head && (l.head.extra = null);
                      l.mode = 6;
                    case 6:
                      if (1024 & l.flags && (T < (z = l.length) && (z = T), z && (l.head && (E = l.head.extra_len - l.length, l.head.extra || (l.head.extra = new Array(l.head.extra_len)), i.arraySet(l.head.extra, _, A, z, E)), 512 & l.flags && (l.check = a(l.check, _, z, A)), T -= z, A += z, l.length -= z), l.length))
                        break e;
                      l.length = 0, l.mode = 7;
                    case 7:
                      if (2048 & l.flags) {
                        if (T === 0)
                          break e;
                        for (z = 0; E = _[A + z++], l.head && E && l.length < 65536 && (l.head.name += String.fromCharCode(E)), E && z < T; )
                          ;
                        if (512 & l.flags && (l.check = a(l.check, _, z, A)), T -= z, A += z, E)
                          break e;
                      } else
                        l.head && (l.head.name = null);
                      l.length = 0, l.mode = 8;
                    case 8:
                      if (4096 & l.flags) {
                        if (T === 0)
                          break e;
                        for (z = 0; E = _[A + z++], l.head && E && l.length < 65536 && (l.head.comment += String.fromCharCode(E)), E && z < T; )
                          ;
                        if (512 & l.flags && (l.check = a(l.check, _, z, A)), T -= z, A += z, E)
                          break e;
                      } else
                        l.head && (l.head.comment = null);
                      l.mode = 9;
                    case 9:
                      if (512 & l.flags) {
                        for (; G < 16; ) {
                          if (T === 0)
                            break e;
                          T--, U += _[A++] << G, G += 8;
                        }
                        if (U !== (65535 & l.check)) {
                          D.msg = "header crc mismatch", l.mode = 30;
                          break;
                        }
                        G = U = 0;
                      }
                      l.head && (l.head.hcrc = l.flags >> 9 & 1, l.head.done = !0), D.adler = l.check = 0, l.mode = 12;
                      break;
                    case 10:
                      for (; G < 32; ) {
                        if (T === 0)
                          break e;
                        T--, U += _[A++] << G, G += 8;
                      }
                      D.adler = l.check = x(U), G = U = 0, l.mode = 11;
                    case 11:
                      if (l.havedict === 0)
                        return D.next_out = F, D.avail_out = O, D.next_in = A, D.avail_in = T, l.hold = U, l.bits = G, 2;
                      D.adler = l.check = 1, l.mode = 12;
                    case 12:
                      if (b === 5 || b === 6)
                        break e;
                    case 13:
                      if (l.last) {
                        U >>>= 7 & G, G -= 7 & G, l.mode = 27;
                        break;
                      }
                      for (; G < 3; ) {
                        if (T === 0)
                          break e;
                        T--, U += _[A++] << G, G += 8;
                      }
                      switch (l.last = 1 & U, G -= 1, 3 & (U >>>= 1)) {
                        case 0:
                          l.mode = 14;
                          break;
                        case 1:
                          if (B(l), l.mode = 20, b !== 6)
                            break;
                          U >>>= 2, G -= 2;
                          break e;
                        case 2:
                          l.mode = 17;
                          break;
                        case 3:
                          D.msg = "invalid block type", l.mode = 30;
                      }
                      U >>>= 2, G -= 2;
                      break;
                    case 14:
                      for (U >>>= 7 & G, G -= 7 & G; G < 32; ) {
                        if (T === 0)
                          break e;
                        T--, U += _[A++] << G, G += 8;
                      }
                      if ((65535 & U) != (U >>> 16 ^ 65535)) {
                        D.msg = "invalid stored block lengths", l.mode = 30;
                        break;
                      }
                      if (l.length = 65535 & U, G = U = 0, l.mode = 15, b === 6)
                        break e;
                    case 15:
                      l.mode = 16;
                    case 16:
                      if (z = l.length) {
                        if (T < z && (z = T), O < z && (z = O), z === 0)
                          break e;
                        i.arraySet(S, _, A, z, F), T -= z, A += z, O -= z, F += z, l.length -= z;
                        break;
                      }
                      l.mode = 12;
                      break;
                    case 17:
                      for (; G < 14; ) {
                        if (T === 0)
                          break e;
                        T--, U += _[A++] << G, G += 8;
                      }
                      if (l.nlen = 257 + (31 & U), U >>>= 5, G -= 5, l.ndist = 1 + (31 & U), U >>>= 5, G -= 5, l.ncode = 4 + (15 & U), U >>>= 4, G -= 4, 286 < l.nlen || 30 < l.ndist) {
                        D.msg = "too many length or distance symbols", l.mode = 30;
                        break;
                      }
                      l.have = 0, l.mode = 18;
                    case 18:
                      for (; l.have < l.ncode; ) {
                        for (; G < 3; ) {
                          if (T === 0)
                            break e;
                          T--, U += _[A++] << G, G += 8;
                        }
                        l.lens[H[l.have++]] = 7 & U, U >>>= 3, G -= 3;
                      }
                      for (; l.have < 19; )
                        l.lens[H[l.have++]] = 0;
                      if (l.lencode = l.lendyn, l.lenbits = 7, re = { bits: l.lenbits }, te = y(0, l.lens, 0, 19, l.lencode, 0, l.work, re), l.lenbits = re.bits, te) {
                        D.msg = "invalid code lengths set", l.mode = 30;
                        break;
                      }
                      l.have = 0, l.mode = 19;
                    case 19:
                      for (; l.have < l.nlen + l.ndist; ) {
                        for (; J = ($ = l.lencode[U & (1 << l.lenbits) - 1]) >>> 16 & 255, ie = 65535 & $, !((Y = $ >>> 24) <= G); ) {
                          if (T === 0)
                            break e;
                          T--, U += _[A++] << G, G += 8;
                        }
                        if (ie < 16)
                          U >>>= Y, G -= Y, l.lens[l.have++] = ie;
                        else {
                          if (ie === 16) {
                            for (ee = Y + 2; G < ee; ) {
                              if (T === 0)
                                break e;
                              T--, U += _[A++] << G, G += 8;
                            }
                            if (U >>>= Y, G -= Y, l.have === 0) {
                              D.msg = "invalid bit length repeat", l.mode = 30;
                              break;
                            }
                            E = l.lens[l.have - 1], z = 3 + (3 & U), U >>>= 2, G -= 2;
                          } else if (ie === 17) {
                            for (ee = Y + 3; G < ee; ) {
                              if (T === 0)
                                break e;
                              T--, U += _[A++] << G, G += 8;
                            }
                            G -= Y, E = 0, z = 3 + (7 & (U >>>= Y)), U >>>= 3, G -= 3;
                          } else {
                            for (ee = Y + 7; G < ee; ) {
                              if (T === 0)
                                break e;
                              T--, U += _[A++] << G, G += 8;
                            }
                            G -= Y, E = 0, z = 11 + (127 & (U >>>= Y)), U >>>= 7, G -= 7;
                          }
                          if (l.have + z > l.nlen + l.ndist) {
                            D.msg = "invalid bit length repeat", l.mode = 30;
                            break;
                          }
                          for (; z--; )
                            l.lens[l.have++] = E;
                        }
                      }
                      if (l.mode === 30)
                        break;
                      if (l.lens[256] === 0) {
                        D.msg = "invalid code -- missing end-of-block", l.mode = 30;
                        break;
                      }
                      if (l.lenbits = 9, re = { bits: l.lenbits }, te = y(r, l.lens, 0, l.nlen, l.lencode, 0, l.work, re), l.lenbits = re.bits, te) {
                        D.msg = "invalid literal/lengths set", l.mode = 30;
                        break;
                      }
                      if (l.distbits = 6, l.distcode = l.distdyn, re = { bits: l.distbits }, te = y(h, l.lens, l.nlen, l.ndist, l.distcode, 0, l.work, re), l.distbits = re.bits, te) {
                        D.msg = "invalid distances set", l.mode = 30;
                        break;
                      }
                      if (l.mode = 20, b === 6)
                        break e;
                    case 20:
                      l.mode = 21;
                    case 21:
                      if (6 <= T && 258 <= O) {
                        D.next_out = F, D.avail_out = O, D.next_in = A, D.avail_in = T, l.hold = U, l.bits = G, e(D, W), F = D.next_out, S = D.output, O = D.avail_out, A = D.next_in, _ = D.input, T = D.avail_in, U = l.hold, G = l.bits, l.mode === 12 && (l.back = -1);
                        break;
                      }
                      for (l.back = 0; J = ($ = l.lencode[U & (1 << l.lenbits) - 1]) >>> 16 & 255, ie = 65535 & $, !((Y = $ >>> 24) <= G); ) {
                        if (T === 0)
                          break e;
                        T--, U += _[A++] << G, G += 8;
                      }
                      if (J && !(240 & J)) {
                        for (q = Y, N = J, Z = ie; J = ($ = l.lencode[Z + ((U & (1 << q + N) - 1) >> q)]) >>> 16 & 255, ie = 65535 & $, !(q + (Y = $ >>> 24) <= G); ) {
                          if (T === 0)
                            break e;
                          T--, U += _[A++] << G, G += 8;
                        }
                        U >>>= q, G -= q, l.back += q;
                      }
                      if (U >>>= Y, G -= Y, l.back += Y, l.length = ie, J === 0) {
                        l.mode = 26;
                        break;
                      }
                      if (32 & J) {
                        l.back = -1, l.mode = 12;
                        break;
                      }
                      if (64 & J) {
                        D.msg = "invalid literal/length code", l.mode = 30;
                        break;
                      }
                      l.extra = 15 & J, l.mode = 22;
                    case 22:
                      if (l.extra) {
                        for (ee = l.extra; G < ee; ) {
                          if (T === 0)
                            break e;
                          T--, U += _[A++] << G, G += 8;
                        }
                        l.length += U & (1 << l.extra) - 1, U >>>= l.extra, G -= l.extra, l.back += l.extra;
                      }
                      l.was = l.length, l.mode = 23;
                    case 23:
                      for (; J = ($ = l.distcode[U & (1 << l.distbits) - 1]) >>> 16 & 255, ie = 65535 & $, !((Y = $ >>> 24) <= G); ) {
                        if (T === 0)
                          break e;
                        T--, U += _[A++] << G, G += 8;
                      }
                      if (!(240 & J)) {
                        for (q = Y, N = J, Z = ie; J = ($ = l.distcode[Z + ((U & (1 << q + N) - 1) >> q)]) >>> 16 & 255, ie = 65535 & $, !(q + (Y = $ >>> 24) <= G); ) {
                          if (T === 0)
                            break e;
                          T--, U += _[A++] << G, G += 8;
                        }
                        U >>>= q, G -= q, l.back += q;
                      }
                      if (U >>>= Y, G -= Y, l.back += Y, 64 & J) {
                        D.msg = "invalid distance code", l.mode = 30;
                        break;
                      }
                      l.offset = ie, l.extra = 15 & J, l.mode = 24;
                    case 24:
                      if (l.extra) {
                        for (ee = l.extra; G < ee; ) {
                          if (T === 0)
                            break e;
                          T--, U += _[A++] << G, G += 8;
                        }
                        l.offset += U & (1 << l.extra) - 1, U >>>= l.extra, G -= l.extra, l.back += l.extra;
                      }
                      if (l.offset > l.dmax) {
                        D.msg = "invalid distance too far back", l.mode = 30;
                        break;
                      }
                      l.mode = 25;
                    case 25:
                      if (O === 0)
                        break e;
                      if (z = W - O, l.offset > z) {
                        if ((z = l.offset - z) > l.whave && l.sane) {
                          D.msg = "invalid distance too far back", l.mode = 30;
                          break;
                        }
                        V = z > l.wnext ? (z -= l.wnext, l.wsize - z) : l.wnext - z, z > l.length && (z = l.length), L = l.window;
                      } else
                        L = S, V = F - l.offset, z = l.length;
                      for (O < z && (z = O), O -= z, l.length -= z; S[F++] = L[V++], --z; )
                        ;
                      l.length === 0 && (l.mode = 21);
                      break;
                    case 26:
                      if (O === 0)
                        break e;
                      S[F++] = l.length, O--, l.mode = 21;
                      break;
                    case 27:
                      if (l.wrap) {
                        for (; G < 32; ) {
                          if (T === 0)
                            break e;
                          T--, U |= _[A++] << G, G += 8;
                        }
                        if (W -= O, D.total_out += W, l.total += W, W && (D.adler = l.check = l.flags ? a(l.check, S, W, F - W) : v(l.check, S, W, F - W)), W = O, (l.flags ? U : x(U)) !== l.check) {
                          D.msg = "incorrect data check", l.mode = 30;
                          break;
                        }
                        G = U = 0;
                      }
                      l.mode = 28;
                    case 28:
                      if (l.wrap && l.flags) {
                        for (; G < 32; ) {
                          if (T === 0)
                            break e;
                          T--, U += _[A++] << G, G += 8;
                        }
                        if (U !== (4294967295 & l.total)) {
                          D.msg = "incorrect length check", l.mode = 30;
                          break;
                        }
                        G = U = 0;
                      }
                      l.mode = 29;
                    case 29:
                      te = 1;
                      break e;
                    case 30:
                      te = -3;
                      break e;
                    case 31:
                      return -4;
                    case 32:
                    default:
                      return d;
                  }
              return D.next_out = F, D.avail_out = O, D.next_in = A, D.avail_in = T, l.hold = U, l.bits = G, (l.wsize || W !== D.avail_out && l.mode < 30 && (l.mode < 27 || b !== 4)) && R(D, D.output, D.next_out, W - D.avail_out) ? (l.mode = 31, -4) : (K -= D.avail_in, W -= D.avail_out, D.total_in += K, D.total_out += W, l.total += W, l.wrap && W && (D.adler = l.check = l.flags ? a(l.check, S, W, D.next_out - W) : v(l.check, S, W, D.next_out - W)), D.data_type = l.bits + (l.last ? 64 : 0) + (l.mode === 12 ? 128 : 0) + (l.mode === 20 || l.mode === 15 ? 256 : 0), (K == 0 && W === 0 || b === 4) && te === g && (te = -5), te);
            }, t.inflateEnd = function(D) {
              if (!D || !D.state)
                return d;
              var b = D.state;
              return b.window && (b.window = null), D.state = null, g;
            }, t.inflateGetHeader = function(D, b) {
              var l;
              return D && D.state && 2 & (l = D.state).wrap ? ((l.head = b).done = !1, g) : d;
            }, t.inflateSetDictionary = function(D, b) {
              var l, _ = b.length;
              return D && D.state ? (l = D.state).wrap !== 0 && l.mode !== 11 ? d : l.mode === 11 && v(1, b, _, 0) !== l.check ? -3 : R(D, b, _, _) ? (l.mode = 31, -4) : (l.havedict = 1, g) : d;
            }, t.inflateInfo = "pako inflate (from Nodeca project)";
          }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(u, P, t) {
            var i = u("../utils/common"), v = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], a = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], e = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], y = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
            P.exports = function(r, h, g, d, c, n, o, x) {
              var f, m, C, p, w, X, M, j, B, R = x.bits, D = 0, b = 0, l = 0, _ = 0, S = 0, A = 0, F = 0, T = 0, O = 0, U = 0, G = null, K = 0, W = new i.Buf16(16), z = new i.Buf16(16), V = null, L = 0;
              for (D = 0; D <= 15; D++)
                W[D] = 0;
              for (b = 0; b < d; b++)
                W[h[g + b]]++;
              for (S = R, _ = 15; 1 <= _ && W[_] === 0; _--)
                ;
              if (_ < S && (S = _), _ === 0)
                return c[n++] = 20971520, c[n++] = 20971520, x.bits = 1, 0;
              for (l = 1; l < _ && W[l] === 0; l++)
                ;
              for (S < l && (S = l), D = T = 1; D <= 15; D++)
                if (T <<= 1, (T -= W[D]) < 0)
                  return -1;
              if (0 < T && (r === 0 || _ !== 1))
                return -1;
              for (z[1] = 0, D = 1; D < 15; D++)
                z[D + 1] = z[D] + W[D];
              for (b = 0; b < d; b++)
                h[g + b] !== 0 && (o[z[h[g + b]]++] = b);
              if (X = r === 0 ? (G = V = o, 19) : r === 1 ? (G = v, K -= 257, V = a, L -= 257, 256) : (G = e, V = y, -1), D = l, w = n, F = b = U = 0, C = -1, p = (O = 1 << (A = S)) - 1, r === 1 && 852 < O || r === 2 && 592 < O)
                return 1;
              for (; ; ) {
                for (M = D - F, B = o[b] < X ? (j = 0, o[b]) : o[b] > X ? (j = V[L + o[b]], G[K + o[b]]) : (j = 96, 0), f = 1 << D - F, l = m = 1 << A; c[w + (U >> F) + (m -= f)] = M << 24 | j << 16 | B | 0, m !== 0; )
                  ;
                for (f = 1 << D - 1; U & f; )
                  f >>= 1;
                if (f !== 0 ? (U &= f - 1, U += f) : U = 0, b++, --W[D] == 0) {
                  if (D === _)
                    break;
                  D = h[g + o[b]];
                }
                if (S < D && (U & p) !== C) {
                  for (F === 0 && (F = S), w += l, T = 1 << (A = D - F); A + F < _ && !((T -= W[A + F]) <= 0); )
                    A++, T <<= 1;
                  if (O += 1 << A, r === 1 && 852 < O || r === 2 && 592 < O)
                    return 1;
                  c[C = U & p] = S << 24 | A << 16 | w - n | 0;
                }
              }
              return U !== 0 && (c[w + U] = D - F << 24 | 64 << 16 | 0), x.bits = S, 0;
            };
          }, { "../utils/common": 41 }], 51: [function(u, P, t) {
            P.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
          }, {}], 52: [function(u, P, t) {
            var i = u("../utils/common"), v = 0, a = 1;
            function e($) {
              for (var k = $.length; 0 <= --k; )
                $[k] = 0;
            }
            var y = 0, r = 29, h = 256, g = h + 1 + r, d = 30, c = 19, n = 2 * g + 1, o = 15, x = 16, f = 7, m = 256, C = 16, p = 17, w = 18, X = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], M = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], j = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], B = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], R = new Array(2 * (g + 2));
            e(R);
            var D = new Array(2 * d);
            e(D);
            var b = new Array(512);
            e(b);
            var l = new Array(256);
            e(l);
            var _ = new Array(r);
            e(_);
            var S, A, F, T = new Array(d);
            function O($, k, H, ne, ae) {
              this.static_tree = $, this.extra_bits = k, this.extra_base = H, this.elems = ne, this.max_length = ae, this.has_stree = $ && $.length;
            }
            function U($, k) {
              this.dyn_tree = $, this.max_code = 0, this.stat_desc = k;
            }
            function G($) {
              return $ < 256 ? b[$] : b[256 + ($ >>> 7)];
            }
            function K($, k) {
              $.pending_buf[$.pending++] = 255 & k, $.pending_buf[$.pending++] = k >>> 8 & 255;
            }
            function W($, k, H) {
              $.bi_valid > x - H ? ($.bi_buf |= k << $.bi_valid & 65535, K($, $.bi_buf), $.bi_buf = k >> x - $.bi_valid, $.bi_valid += H - x) : ($.bi_buf |= k << $.bi_valid & 65535, $.bi_valid += H);
            }
            function z($, k, H) {
              W($, H[2 * k], H[2 * k + 1]);
            }
            function V($, k) {
              for (var H = 0; H |= 1 & $, $ >>>= 1, H <<= 1, 0 < --k; )
                ;
              return H >>> 1;
            }
            function L($, k, H) {
              var ne, ae, he = new Array(o + 1), ue = 0;
              for (ne = 1; ne <= o; ne++)
                he[ne] = ue = ue + H[ne - 1] << 1;
              for (ae = 0; ae <= k; ae++) {
                var fe = $[2 * ae + 1];
                fe !== 0 && ($[2 * ae] = V(he[fe]++, fe));
              }
            }
            function Y($) {
              var k;
              for (k = 0; k < g; k++)
                $.dyn_ltree[2 * k] = 0;
              for (k = 0; k < d; k++)
                $.dyn_dtree[2 * k] = 0;
              for (k = 0; k < c; k++)
                $.bl_tree[2 * k] = 0;
              $.dyn_ltree[2 * m] = 1, $.opt_len = $.static_len = 0, $.last_lit = $.matches = 0;
            }
            function J($) {
              8 < $.bi_valid ? K($, $.bi_buf) : 0 < $.bi_valid && ($.pending_buf[$.pending++] = $.bi_buf), $.bi_buf = 0, $.bi_valid = 0;
            }
            function ie($, k, H, ne) {
              var ae = 2 * k, he = 2 * H;
              return $[ae] < $[he] || $[ae] === $[he] && ne[k] <= ne[H];
            }
            function q($, k, H) {
              for (var ne = $.heap[H], ae = H << 1; ae <= $.heap_len && (ae < $.heap_len && ie(k, $.heap[ae + 1], $.heap[ae], $.depth) && ae++, !ie(k, ne, $.heap[ae], $.depth)); )
                $.heap[H] = $.heap[ae], H = ae, ae <<= 1;
              $.heap[H] = ne;
            }
            function N($, k, H) {
              var ne, ae, he, ue, fe = 0;
              if ($.last_lit !== 0)
                for (; ne = $.pending_buf[$.d_buf + 2 * fe] << 8 | $.pending_buf[$.d_buf + 2 * fe + 1], ae = $.pending_buf[$.l_buf + fe], fe++, ne === 0 ? z($, ae, k) : (z($, (he = l[ae]) + h + 1, k), (ue = X[he]) !== 0 && W($, ae -= _[he], ue), z($, he = G(--ne), H), (ue = M[he]) !== 0 && W($, ne -= T[he], ue)), fe < $.last_lit; )
                  ;
              z($, m, k);
            }
            function Z($, k) {
              var H, ne, ae, he = k.dyn_tree, ue = k.stat_desc.static_tree, fe = k.stat_desc.has_stree, me = k.stat_desc.elems, Fe = -1;
              for ($.heap_len = 0, $.heap_max = n, H = 0; H < me; H++)
                he[2 * H] !== 0 ? ($.heap[++$.heap_len] = Fe = H, $.depth[H] = 0) : he[2 * H + 1] = 0;
              for (; $.heap_len < 2; )
                he[2 * (ae = $.heap[++$.heap_len] = Fe < 2 ? ++Fe : 0)] = 1, $.depth[ae] = 0, $.opt_len--, fe && ($.static_len -= ue[2 * ae + 1]);
              for (k.max_code = Fe, H = $.heap_len >> 1; 1 <= H; H--)
                q($, he, H);
              for (ae = me; H = $.heap[1], $.heap[1] = $.heap[$.heap_len--], q($, he, 1), ne = $.heap[1], $.heap[--$.heap_max] = H, $.heap[--$.heap_max] = ne, he[2 * ae] = he[2 * H] + he[2 * ne], $.depth[ae] = ($.depth[H] >= $.depth[ne] ? $.depth[H] : $.depth[ne]) + 1, he[2 * H + 1] = he[2 * ne + 1] = ae, $.heap[1] = ae++, q($, he, 1), 2 <= $.heap_len; )
                ;
              $.heap[--$.heap_max] = $.heap[1], function(we, Ae) {
                var De, xe, Te, ve, Se, be, Le = Ae.dyn_tree, ze = Ae.max_code, nt = Ae.stat_desc.static_tree, Ue = Ae.stat_desc.has_stree, Oe = Ae.stat_desc.extra_bits, _e = Ae.stat_desc.extra_base, at = Ae.stat_desc.max_length, Je = 0;
                for (ve = 0; ve <= o; ve++)
                  we.bl_count[ve] = 0;
                for (Le[2 * we.heap[we.heap_max] + 1] = 0, De = we.heap_max + 1; De < n; De++)
                  at < (ve = Le[2 * Le[2 * (xe = we.heap[De]) + 1] + 1] + 1) && (ve = at, Je++), Le[2 * xe + 1] = ve, ze < xe || (we.bl_count[ve]++, Se = 0, _e <= xe && (Se = Oe[xe - _e]), be = Le[2 * xe], we.opt_len += be * (ve + Se), Ue && (we.static_len += be * (nt[2 * xe + 1] + Se)));
                if (Je !== 0) {
                  do {
                    for (ve = at - 1; we.bl_count[ve] === 0; )
                      ve--;
                    we.bl_count[ve]--, we.bl_count[ve + 1] += 2, we.bl_count[at]--, Je -= 2;
                  } while (0 < Je);
                  for (ve = at; ve !== 0; ve--)
                    for (xe = we.bl_count[ve]; xe !== 0; )
                      ze < (Te = we.heap[--De]) || (Le[2 * Te + 1] !== ve && (we.opt_len += (ve - Le[2 * Te + 1]) * Le[2 * Te], Le[2 * Te + 1] = ve), xe--);
                }
              }($, k), L(he, Fe, $.bl_count);
            }
            function E($, k, H) {
              var ne, ae, he = -1, ue = k[1], fe = 0, me = 7, Fe = 4;
              for (ue === 0 && (me = 138, Fe = 3), k[2 * (H + 1) + 1] = 65535, ne = 0; ne <= H; ne++)
                ae = ue, ue = k[2 * (ne + 1) + 1], ++fe < me && ae === ue || (fe < Fe ? $.bl_tree[2 * ae] += fe : ae !== 0 ? (ae !== he && $.bl_tree[2 * ae]++, $.bl_tree[2 * C]++) : fe <= 10 ? $.bl_tree[2 * p]++ : $.bl_tree[2 * w]++, he = ae, Fe = (fe = 0) === ue ? (me = 138, 3) : ae === ue ? (me = 6, 3) : (me = 7, 4));
            }
            function te($, k, H) {
              var ne, ae, he = -1, ue = k[1], fe = 0, me = 7, Fe = 4;
              for (ue === 0 && (me = 138, Fe = 3), ne = 0; ne <= H; ne++)
                if (ae = ue, ue = k[2 * (ne + 1) + 1], !(++fe < me && ae === ue)) {
                  if (fe < Fe)
                    for (; z($, ae, $.bl_tree), --fe != 0; )
                      ;
                  else
                    ae !== 0 ? (ae !== he && (z($, ae, $.bl_tree), fe--), z($, C, $.bl_tree), W($, fe - 3, 2)) : fe <= 10 ? (z($, p, $.bl_tree), W($, fe - 3, 3)) : (z($, w, $.bl_tree), W($, fe - 11, 7));
                  he = ae, Fe = (fe = 0) === ue ? (me = 138, 3) : ae === ue ? (me = 6, 3) : (me = 7, 4);
                }
            }
            e(T);
            var re = !1;
            function ee($, k, H, ne) {
              W($, (y << 1) + (ne ? 1 : 0), 3), function(ae, he, ue, fe) {
                J(ae), fe && (K(ae, ue), K(ae, ~ue)), i.arraySet(ae.pending_buf, ae.window, he, ue, ae.pending), ae.pending += ue;
              }($, k, H, !0);
            }
            t._tr_init = function($) {
              re || (function() {
                var k, H, ne, ae, he, ue = new Array(o + 1);
                for (ae = ne = 0; ae < r - 1; ae++)
                  for (_[ae] = ne, k = 0; k < 1 << X[ae]; k++)
                    l[ne++] = ae;
                for (l[ne - 1] = ae, ae = he = 0; ae < 16; ae++)
                  for (T[ae] = he, k = 0; k < 1 << M[ae]; k++)
                    b[he++] = ae;
                for (he >>= 7; ae < d; ae++)
                  for (T[ae] = he << 7, k = 0; k < 1 << M[ae] - 7; k++)
                    b[256 + he++] = ae;
                for (H = 0; H <= o; H++)
                  ue[H] = 0;
                for (k = 0; k <= 143; )
                  R[2 * k + 1] = 8, k++, ue[8]++;
                for (; k <= 255; )
                  R[2 * k + 1] = 9, k++, ue[9]++;
                for (; k <= 279; )
                  R[2 * k + 1] = 7, k++, ue[7]++;
                for (; k <= 287; )
                  R[2 * k + 1] = 8, k++, ue[8]++;
                for (L(R, g + 1, ue), k = 0; k < d; k++)
                  D[2 * k + 1] = 5, D[2 * k] = V(k, 5);
                S = new O(R, X, h + 1, g, o), A = new O(D, M, 0, d, o), F = new O(new Array(0), j, 0, c, f);
              }(), re = !0), $.l_desc = new U($.dyn_ltree, S), $.d_desc = new U($.dyn_dtree, A), $.bl_desc = new U($.bl_tree, F), $.bi_buf = 0, $.bi_valid = 0, Y($);
            }, t._tr_stored_block = ee, t._tr_flush_block = function($, k, H, ne) {
              var ae, he, ue = 0;
              0 < $.level ? ($.strm.data_type === 2 && ($.strm.data_type = function(fe) {
                var me, Fe = 4093624447;
                for (me = 0; me <= 31; me++, Fe >>>= 1)
                  if (1 & Fe && fe.dyn_ltree[2 * me] !== 0)
                    return v;
                if (fe.dyn_ltree[18] !== 0 || fe.dyn_ltree[20] !== 0 || fe.dyn_ltree[26] !== 0)
                  return a;
                for (me = 32; me < h; me++)
                  if (fe.dyn_ltree[2 * me] !== 0)
                    return a;
                return v;
              }($)), Z($, $.l_desc), Z($, $.d_desc), ue = function(fe) {
                var me;
                for (E(fe, fe.dyn_ltree, fe.l_desc.max_code), E(fe, fe.dyn_dtree, fe.d_desc.max_code), Z(fe, fe.bl_desc), me = c - 1; 3 <= me && fe.bl_tree[2 * B[me] + 1] === 0; me--)
                  ;
                return fe.opt_len += 3 * (me + 1) + 5 + 5 + 4, me;
              }($), ae = $.opt_len + 3 + 7 >>> 3, (he = $.static_len + 3 + 7 >>> 3) <= ae && (ae = he)) : ae = he = H + 5, H + 4 <= ae && k !== -1 ? ee($, k, H, ne) : $.strategy === 4 || he === ae ? (W($, 2 + (ne ? 1 : 0), 3), N($, R, D)) : (W($, 4 + (ne ? 1 : 0), 3), function(fe, me, Fe, we) {
                var Ae;
                for (W(fe, me - 257, 5), W(fe, Fe - 1, 5), W(fe, we - 4, 4), Ae = 0; Ae < we; Ae++)
                  W(fe, fe.bl_tree[2 * B[Ae] + 1], 3);
                te(fe, fe.dyn_ltree, me - 1), te(fe, fe.dyn_dtree, Fe - 1);
              }($, $.l_desc.max_code + 1, $.d_desc.max_code + 1, ue + 1), N($, $.dyn_ltree, $.dyn_dtree)), Y($), ne && J($);
            }, t._tr_tally = function($, k, H) {
              return $.pending_buf[$.d_buf + 2 * $.last_lit] = k >>> 8 & 255, $.pending_buf[$.d_buf + 2 * $.last_lit + 1] = 255 & k, $.pending_buf[$.l_buf + $.last_lit] = 255 & H, $.last_lit++, k === 0 ? $.dyn_ltree[2 * H]++ : ($.matches++, k--, $.dyn_ltree[2 * (l[H] + h + 1)]++, $.dyn_dtree[2 * G(k)]++), $.last_lit === $.lit_bufsize - 1;
            }, t._tr_align = function($) {
              W($, 2, 3), z($, m, R), function(k) {
                k.bi_valid === 16 ? (K(k, k.bi_buf), k.bi_buf = 0, k.bi_valid = 0) : 8 <= k.bi_valid && (k.pending_buf[k.pending++] = 255 & k.bi_buf, k.bi_buf >>= 8, k.bi_valid -= 8);
              }($);
            };
          }, { "../utils/common": 41 }], 53: [function(u, P, t) {
            P.exports = function() {
              this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
            };
          }, {}], 54: [function(u, P, t) {
            P.exports = typeof setImmediate == "function" ? setImmediate : function() {
              var i = [].slice.apply(arguments);
              i.splice(1, 0, 0), setTimeout.apply(null, i);
            };
          }, {}] }, {}, [10])(10);
        });
      }).call(this, typeof commonjsGlobal < "u" ? commonjsGlobal : typeof self < "u" ? self : typeof window < "u" ? window : {}, le("buffer").Buffer);
    }, { buffer: 78 }], 88: [function(le, de, oe) {
      oe.Parser = le("./lib/parser").Parser, oe.rules = le("./lib/rules"), oe.errors = le("./lib/errors"), oe.results = le("./lib/parsing-results"), oe.StringSource = le("./lib/StringSource"), oe.Token = le("./lib/Token"), oe.bottomUp = le("./lib/bottom-up"), oe.RegexTokeniser = le("./lib/regex-tokeniser").RegexTokeniser, oe.rule = function(se) {
        var Q;
        return function(u) {
          return Q || (Q = se()), Q(u);
        };
      };
    }, { "./lib/StringSource": 89, "./lib/Token": 90, "./lib/bottom-up": 92, "./lib/errors": 93, "./lib/parser": 95, "./lib/parsing-results": 96, "./lib/regex-tokeniser": 97, "./lib/rules": 98 }], 89: [function(le, de, oe) {
      var se = le("util");
      de.exports = function(u, P) {
        var t = {
          asString: function() {
            return u;
          },
          range: function(i, v) {
            return new Q(u, P, i, v);
          }
        };
        return t;
      };
      var Q = function(u, P, t, i) {
        this._string = u, this._description = P, this._startIndex = t, this._endIndex = i;
      };
      Q.prototype.to = function(u) {
        return new Q(this._string, this._description, this._startIndex, u._endIndex);
      }, Q.prototype.describe = function() {
        var u = this._position(), P = this._description ? this._description + `
` : "";
        return se.format(
          `%sLine number: %s
Character number: %s`,
          P,
          u.lineNumber,
          u.characterNumber
        );
      }, Q.prototype.lineNumber = function() {
        return this._position().lineNumber;
      }, Q.prototype.characterNumber = function() {
        return this._position().characterNumber;
      }, Q.prototype._position = function() {
        for (var u = this, P = 0, t = function() {
          return u._string.indexOf(`
`, P);
        }, i = 1; t() !== -1 && t() < this._startIndex; )
          P = t() + 1, i += 1;
        var v = this._startIndex - P + 1;
        return { lineNumber: i, characterNumber: v };
      };
    }, { util: 121 }], 90: [function(le, de, oe) {
      de.exports = function(se, Q, u) {
        this.name = se, this.value = Q, u && (this.source = u);
      };
    }, {}], 91: [function(le, de, oe) {
      var se = de.exports = function(Q, u) {
        this._tokens = Q, this._startIndex = u || 0;
      };
      se.prototype.head = function() {
        return this._tokens[this._startIndex];
      }, se.prototype.tail = function(Q) {
        return new se(this._tokens, this._startIndex + 1);
      }, se.prototype.toArray = function() {
        return this._tokens.slice(this._startIndex);
      }, se.prototype.end = function() {
        return this._tokens[this._tokens.length - 1];
      }, se.prototype.to = function(Q) {
        var u = this.head().source, P = Q.head() || Q.end();
        return u.to(P.source);
      };
    }, {}], 92: [function(le, de, oe) {
      var se = le("./rules"), Q = le("./parsing-results");
      oe.parser = function(t, i, v) {
        var a = {
          rule: h,
          leftAssociative: g,
          rightAssociative: d
        }, e = new u(v.map(r)), y = se.firstOf(t, i);
        function r(o) {
          return {
            name: o.name,
            rule: P(o.ruleBuilder.bind(null, a))
          };
        }
        function h() {
          return c(e);
        }
        function g(o) {
          return c(e.untilExclusive(o));
        }
        function d(o) {
          return c(e.untilInclusive(o));
        }
        function c(o) {
          return n.bind(null, o);
        }
        function n(o, x) {
          var f = y(x);
          return f.isSuccess() ? o.apply(f) : f;
        }
        return a;
      };
      function u(t) {
        function i(r) {
          return new u(t.slice(0, a().indexOf(r)));
        }
        function v(r) {
          return new u(t.slice(0, a().indexOf(r) + 1));
        }
        function a() {
          return t.map(function(r) {
            return r.name;
          });
        }
        function e(r) {
          for (var h, g; ; )
            if (h = y(r.remaining()), h.isSuccess())
              g = r.source().to(h.source()), r = Q.success(
                h.value()(r.value(), g),
                h.remaining(),
                g
              );
            else
              return h.isFailure() ? r : h;
        }
        function y(r) {
          return se.firstOf("infix", t.map(function(h) {
            return h.rule;
          }))(r);
        }
        return {
          apply: e,
          untilExclusive: i,
          untilInclusive: v
        };
      }
      oe.infix = function(t, i) {
        function v(a) {
          return oe.infix(t, function(e) {
            var y = i(e);
            return function(r) {
              var h = y(r);
              return h.map(function(g) {
                return function(d, c) {
                  return a(d, g, c);
                };
              });
            };
          });
        }
        return {
          name: t,
          ruleBuilder: i,
          map: v
        };
      };
      var P = function(t) {
        var i;
        return function(v) {
          return i || (i = t()), i(v);
        };
      };
    }, { "./parsing-results": 96, "./rules": 98 }], 93: [function(le, de, oe) {
      oe.error = function(Q) {
        return new se(Q);
      };
      var se = function(Q) {
        this.expected = Q.expected, this.actual = Q.actual, this._location = Q.location;
      };
      se.prototype.describe = function() {
        var Q = this._location ? this._location.describe() + `:
` : "";
        return Q + "Expected " + this.expected + `
but got ` + this.actual;
      }, se.prototype.lineNumber = function() {
        return this._location.lineNumber();
      }, se.prototype.characterNumber = function() {
        return this._location.characterNumber();
      };
    }, {}], 94: [function(le, de, oe) {
      oe.fromArray = function(Q) {
        var u = 0, P = function() {
          return u < Q.length;
        };
        return new se({
          hasNext: P,
          next: function() {
            if (P())
              return Q[u++];
            throw new Error("No more elements");
          }
        });
      };
      var se = function(Q) {
        this._iterator = Q;
      };
      se.prototype.map = function(Q) {
        var u = this._iterator;
        return new se({
          hasNext: function() {
            return u.hasNext();
          },
          next: function() {
            return Q(u.next());
          }
        });
      }, se.prototype.filter = function(Q) {
        var u = this._iterator, P = !1, t = !1, i, v = function() {
          if (!P)
            for (P = !0, t = !1; u.hasNext() && !t; )
              i = u.next(), t = Q(i);
        };
        return new se({
          hasNext: function() {
            return v(), t;
          },
          next: function() {
            v();
            var a = i;
            return P = !1, a;
          }
        });
      }, se.prototype.first = function() {
        var Q = this._iterator;
        return this._iterator.hasNext() ? Q.next() : null;
      }, se.prototype.toArray = function() {
        for (var Q = []; this._iterator.hasNext(); )
          Q.push(this._iterator.next());
        return Q;
      };
    }, {}], 95: [function(le, de, oe) {
      var se = le("./TokenIterator");
      oe.Parser = function(Q) {
        var u = function(P, t) {
          return P(new se(t));
        };
        return {
          parseTokens: u
        };
      };
    }, { "./TokenIterator": 91 }], 96: [function(le, de, oe) {
      de.exports = {
        failure: function(Q, u) {
          if (Q.length < 1)
            throw new Error("Failure must have errors");
          return new se({
            status: "failure",
            remaining: u,
            errors: Q
          });
        },
        error: function(Q, u) {
          if (Q.length < 1)
            throw new Error("Failure must have errors");
          return new se({
            status: "error",
            remaining: u,
            errors: Q
          });
        },
        success: function(Q, u, P) {
          return new se({
            status: "success",
            value: Q,
            source: P,
            remaining: u,
            errors: []
          });
        },
        cut: function(Q) {
          return new se({
            status: "cut",
            remaining: Q,
            errors: []
          });
        }
      };
      var se = function(Q) {
        this._value = Q.value, this._status = Q.status, this._hasValue = Q.value !== void 0, this._remaining = Q.remaining, this._source = Q.source, this._errors = Q.errors;
      };
      se.prototype.map = function(Q) {
        return this._hasValue ? new se({
          value: Q(this._value, this._source),
          status: this._status,
          remaining: this._remaining,
          source: this._source,
          errors: this._errors
        }) : this;
      }, se.prototype.changeRemaining = function(Q) {
        return new se({
          value: this._value,
          status: this._status,
          remaining: Q,
          source: this._source,
          errors: this._errors
        });
      }, se.prototype.isSuccess = function() {
        return this._status === "success" || this._status === "cut";
      }, se.prototype.isFailure = function() {
        return this._status === "failure";
      }, se.prototype.isError = function() {
        return this._status === "error";
      }, se.prototype.isCut = function() {
        return this._status === "cut";
      }, se.prototype.value = function() {
        return this._value;
      }, se.prototype.remaining = function() {
        return this._remaining;
      }, se.prototype.source = function() {
        return this._source;
      }, se.prototype.errors = function() {
        return this._errors;
      };
    }, {}], 97: [function(le, de, oe) {
      var se = le("./Token"), Q = le("./StringSource");
      oe.RegexTokeniser = u;
      function u(P) {
        P = P.map(function(a) {
          return {
            name: a.name,
            regex: new RegExp(a.regex.source, "g")
          };
        });
        function t(a, e) {
          for (var y = new Q(a, e), r = 0, h = []; r < a.length; ) {
            var g = i(a, r, y);
            r = g.endIndex, h.push(g.token);
          }
          return h.push(v(a, y)), h;
        }
        function i(a, e, y) {
          for (var r = 0; r < P.length; r++) {
            var h = P[r].regex;
            h.lastIndex = e;
            var g = h.exec(a);
            if (g) {
              var c = e + g[0].length;
              if (g.index === e && c > e) {
                var d = g[1], n = new se(
                  P[r].name,
                  d,
                  y.range(e, c)
                );
                return { token: n, endIndex: c };
              }
            }
          }
          var c = e + 1, n = new se(
            "unrecognisedCharacter",
            a.substring(e, c),
            y.range(e, c)
          );
          return { token: n, endIndex: c };
        }
        function v(a, e) {
          return new se(
            "end",
            null,
            e.range(a.length, a.length)
          );
        }
        return {
          tokenise: t
        };
      }
    }, { "./StringSource": 89, "./Token": 90 }], 98: [function(le, de, oe) {
      var se = le("underscore"), Q = le("option"), u = le("./parsing-results"), P = le("./errors"), t = le("./lazy-iterators");
      oe.token = function(h, g) {
        var d = g !== void 0;
        return function(c) {
          var n = c.head();
          if (n && n.name === h && (!d || n.value === g))
            return u.success(n.value, c.tail(), n.source);
          var o = y({ name: h, value: g });
          return r(c, o);
        };
      }, oe.tokenOfType = function(h) {
        return oe.token(h);
      }, oe.firstOf = function(h, g) {
        return se.isArray(g) || (g = Array.prototype.slice.call(arguments, 1)), function(d) {
          return t.fromArray(g).map(function(c) {
            return c(d);
          }).filter(function(c) {
            return c.isSuccess() || c.isError();
          }).first() || r(d, h);
        };
      }, oe.then = function(h, g) {
        return function(d) {
          var c = h(d);
          return c.map || console.log(c), c.map(g);
        };
      }, oe.sequence = function() {
        var h = Array.prototype.slice.call(arguments, 0), g = function(c) {
          var n = se.foldl(h, function(x, f) {
            var m = x.result, C = x.hasCut;
            if (!m.isSuccess())
              return { result: m, hasCut: C };
            var p = f(m.remaining());
            if (p.isCut())
              return { result: m, hasCut: !0 };
            if (p.isSuccess()) {
              var w;
              f.isCaptured ? w = m.value().withValue(f, p.value()) : w = m.value();
              var X = p.remaining(), M = c.to(X);
              return {
                result: u.success(w, X, M),
                hasCut: C
              };
            } else
              return C ? { result: u.error(p.errors(), p.remaining()), hasCut: C } : { result: p, hasCut: C };
          }, { result: u.success(new i(), c), hasCut: !1 }).result, o = c.to(n.remaining());
          return n.map(function(x) {
            return x.withValue(oe.sequence.source, o);
          });
        };
        g.head = function() {
          var c = se.find(h, d);
          return oe.then(
            g,
            oe.sequence.extract(c)
          );
        }, g.map = function(c) {
          return oe.then(
            g,
            function(n) {
              return c.apply(this, n.toArray());
            }
          );
        };
        function d(c) {
          return c.isCaptured;
        }
        return g;
      };
      var i = function(h, g) {
        this._values = h || {}, this._valuesArray = g || [];
      };
      i.prototype.withValue = function(h, g) {
        if (h.captureName && h.captureName in this._values)
          throw new Error('Cannot add second value for capture "' + h.captureName + '"');
        var d = se.clone(this._values);
        d[h.captureName] = g;
        var c = this._valuesArray.concat([g]);
        return new i(d, c);
      }, i.prototype.get = function(h) {
        if (h.captureName in this._values)
          return this._values[h.captureName];
        throw new Error('No value for capture "' + h.captureName + '"');
      }, i.prototype.toArray = function() {
        return this._valuesArray;
      }, oe.sequence.capture = function(h, g) {
        var d = function() {
          return h.apply(this, arguments);
        };
        return d.captureName = g, d.isCaptured = !0, d;
      }, oe.sequence.extract = function(h) {
        return function(g) {
          return g.get(h);
        };
      }, oe.sequence.applyValues = function(h) {
        var g = Array.prototype.slice.call(arguments, 1);
        return function(d) {
          var c = g.map(function(n) {
            return d.get(n);
          });
          return h.apply(this, c);
        };
      }, oe.sequence.source = {
        captureName: "☃source☃"
      }, oe.sequence.cut = function() {
        return function(h) {
          return u.cut(h);
        };
      }, oe.optional = function(h) {
        return function(g) {
          var d = h(g);
          return d.isSuccess() ? d.map(Q.some) : d.isFailure() ? u.success(Q.none, g) : d;
        };
      }, oe.zeroOrMoreWithSeparator = function(h, g) {
        return e(h, g, !1);
      }, oe.oneOrMoreWithSeparator = function(h, g) {
        return e(h, g, !0);
      };
      var v = oe.zeroOrMore = function(h) {
        return function(g) {
          for (var d = [], c; (c = h(g)) && c.isSuccess(); )
            g = c.remaining(), d.push(c.value());
          return c.isError() ? c : u.success(d, g);
        };
      };
      oe.oneOrMore = function(h) {
        return oe.oneOrMoreWithSeparator(h, a);
      };
      function a(h) {
        return u.success(null, h);
      }
      var e = function(h, g, d) {
        return function(c) {
          var n = h(c);
          if (n.isSuccess()) {
            var o = oe.sequence.capture(h, "main"), x = v(oe.then(
              oe.sequence(g, o),
              oe.sequence.extract(o)
            )), f = x(n.remaining());
            return u.success([n.value()].concat(f.value()), f.remaining());
          } else
            return d || n.isError() ? n : u.success([], c);
        };
      };
      oe.leftAssociative = function(h, g, d) {
        var c;
        d ? c = [{ func: d, rule: g }] : c = g, c = c.map(function(o) {
          return oe.then(o.rule, function(x) {
            return function(f, m) {
              return o.func(f, x, m);
            };
          });
        });
        var n = oe.firstOf.apply(null, ["rules"].concat(c));
        return function(o) {
          var x = o, f = h(o);
          if (!f.isSuccess())
            return f;
          for (var m = n(f.remaining()); m.isSuccess(); ) {
            var C = m.remaining(), p = x.to(m.remaining()), w = m.value();
            f = u.success(
              w(f.value(), p),
              C,
              p
            ), m = n(f.remaining());
          }
          return m.isError() ? m : f;
        };
      }, oe.leftAssociative.firstOf = function() {
        return Array.prototype.slice.call(arguments, 0);
      }, oe.nonConsuming = function(h) {
        return function(g) {
          return h(g).changeRemaining(g);
        };
      };
      var y = function(h) {
        return h.value ? h.name + ' "' + h.value + '"' : h.name;
      };
      function r(h, g) {
        var d, c = h.head();
        return c ? d = P.error({
          expected: g,
          actual: y(c),
          location: c.source
        }) : d = P.error({
          expected: g,
          actual: "end of tokens"
        }), u.failure([d], h);
      }
    }, { "./errors": 93, "./lazy-iterators": 94, "./parsing-results": 96, option: 99, underscore: 117 }], 99: [function(le, de, oe) {
      oe.none = /* @__PURE__ */ Object.create({
        value: function() {
          throw new Error("Called value on none");
        },
        isNone: function() {
          return !0;
        },
        isSome: function() {
          return !1;
        },
        map: function() {
          return oe.none;
        },
        flatMap: function() {
          return oe.none;
        },
        filter: function() {
          return oe.none;
        },
        toArray: function() {
          return [];
        },
        orElse: se,
        valueOrElse: se
      });
      function se(u) {
        return typeof u == "function" ? u() : u;
      }
      oe.some = function(u) {
        return new Q(u);
      };
      var Q = function(u) {
        this._value = u;
      };
      Q.prototype.value = function() {
        return this._value;
      }, Q.prototype.isNone = function() {
        return !1;
      }, Q.prototype.isSome = function() {
        return !0;
      }, Q.prototype.map = function(u) {
        return new Q(u(this._value));
      }, Q.prototype.flatMap = function(u) {
        return u(this._value);
      }, Q.prototype.filter = function(u) {
        return u(this._value) ? this : oe.none;
      }, Q.prototype.toArray = function() {
        return [this._value];
      }, Q.prototype.orElse = function(u) {
        return this;
      }, Q.prototype.valueOrElse = function(u) {
        return this._value;
      }, oe.isOption = function(u) {
        return u === oe.none || u instanceof Q;
      }, oe.fromNullable = function(u) {
        return u == null ? oe.none : new Q(u);
      };
    }, {}], 100: [function(le, de, oe) {
      (function(se) {
        function Q(v, a) {
          for (var e = 0, y = v.length - 1; y >= 0; y--) {
            var r = v[y];
            r === "." ? v.splice(y, 1) : r === ".." ? (v.splice(y, 1), e++) : e && (v.splice(y, 1), e--);
          }
          if (a)
            for (; e--; e)
              v.unshift("..");
          return v;
        }
        var u = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, P = function(v) {
          return u.exec(v).slice(1);
        };
        oe.resolve = function() {
          for (var v = "", a = !1, e = arguments.length - 1; e >= -1 && !a; e--) {
            var y = e >= 0 ? arguments[e] : se.cwd();
            if (typeof y != "string")
              throw new TypeError("Arguments to path.resolve must be strings");
            if (!y)
              continue;
            v = y + "/" + v, a = y.charAt(0) === "/";
          }
          return v = Q(t(v.split("/"), function(r) {
            return !!r;
          }), !a).join("/"), (a ? "/" : "") + v || ".";
        }, oe.normalize = function(v) {
          var a = oe.isAbsolute(v), e = i(v, -1) === "/";
          return v = Q(t(v.split("/"), function(y) {
            return !!y;
          }), !a).join("/"), !v && !a && (v = "."), v && e && (v += "/"), (a ? "/" : "") + v;
        }, oe.isAbsolute = function(v) {
          return v.charAt(0) === "/";
        }, oe.join = function() {
          var v = Array.prototype.slice.call(arguments, 0);
          return oe.normalize(t(v, function(a, e) {
            if (typeof a != "string")
              throw new TypeError("Arguments to path.join must be strings");
            return a;
          }).join("/"));
        }, oe.relative = function(v, a) {
          v = oe.resolve(v).substr(1), a = oe.resolve(a).substr(1);
          function e(n) {
            for (var o = 0; o < n.length && n[o] === ""; o++)
              ;
            for (var x = n.length - 1; x >= 0 && n[x] === ""; x--)
              ;
            return o > x ? [] : n.slice(o, x - o + 1);
          }
          for (var y = e(v.split("/")), r = e(a.split("/")), h = Math.min(y.length, r.length), g = h, d = 0; d < h; d++)
            if (y[d] !== r[d]) {
              g = d;
              break;
            }
          for (var c = [], d = g; d < y.length; d++)
            c.push("..");
          return c = c.concat(r.slice(g)), c.join("/");
        }, oe.sep = "/", oe.delimiter = ":", oe.dirname = function(v) {
          var a = P(v), e = a[0], y = a[1];
          return !e && !y ? "." : (y && (y = y.substr(0, y.length - 1)), e + y);
        }, oe.basename = function(v, a) {
          var e = P(v)[2];
          return a && e.substr(-1 * a.length) === a && (e = e.substr(0, e.length - a.length)), e;
        }, oe.extname = function(v) {
          return P(v)[3];
        };
        function t(v, a) {
          if (v.filter)
            return v.filter(a);
          for (var e = [], y = 0; y < v.length; y++)
            a(v[y], y, v) && e.push(v[y]);
          return e;
        }
        var i = "ab".substr(-1) === "b" ? function(v, a, e) {
          return v.substr(a, e);
        } : function(v, a, e) {
          return a < 0 && (a = v.length + a), v.substr(a, e);
        };
      }).call(this, le("_process"));
    }, { _process: 102 }], 101: [function(le, de, oe) {
      (function(se) {
        !se.version || se.version.indexOf("v0.") === 0 || se.version.indexOf("v1.") === 0 && se.version.indexOf("v1.8.") !== 0 ? de.exports = Q : de.exports = se.nextTick;
        function Q(u, P, t, i) {
          if (typeof u != "function")
            throw new TypeError('"callback" argument must be a function');
          var v = arguments.length, a, e;
          switch (v) {
            case 0:
            case 1:
              return se.nextTick(u);
            case 2:
              return se.nextTick(function() {
                u.call(null, P);
              });
            case 3:
              return se.nextTick(function() {
                u.call(null, P, t);
              });
            case 4:
              return se.nextTick(function() {
                u.call(null, P, t, i);
              });
            default:
              for (a = new Array(v - 1), e = 0; e < a.length; )
                a[e++] = arguments[e];
              return se.nextTick(function() {
                u.apply(null, a);
              });
          }
        }
      }).call(this, le("_process"));
    }, { _process: 102 }], 102: [function(le, de, oe) {
      var se = de.exports = {}, Q, u;
      function P() {
        throw new Error("setTimeout has not been defined");
      }
      function t() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          typeof setTimeout == "function" ? Q = setTimeout : Q = P;
        } catch {
          Q = P;
        }
        try {
          typeof clearTimeout == "function" ? u = clearTimeout : u = t;
        } catch {
          u = t;
        }
      })();
      function i(n) {
        if (Q === setTimeout)
          return setTimeout(n, 0);
        if ((Q === P || !Q) && setTimeout)
          return Q = setTimeout, setTimeout(n, 0);
        try {
          return Q(n, 0);
        } catch {
          try {
            return Q.call(null, n, 0);
          } catch {
            return Q.call(this, n, 0);
          }
        }
      }
      function v(n) {
        if (u === clearTimeout)
          return clearTimeout(n);
        if ((u === t || !u) && clearTimeout)
          return u = clearTimeout, clearTimeout(n);
        try {
          return u(n);
        } catch {
          try {
            return u.call(null, n);
          } catch {
            return u.call(this, n);
          }
        }
      }
      var a = [], e = !1, y, r = -1;
      function h() {
        !e || !y || (e = !1, y.length ? a = y.concat(a) : r = -1, a.length && g());
      }
      function g() {
        if (!e) {
          var n = i(h);
          e = !0;
          for (var o = a.length; o; ) {
            for (y = a, a = []; ++r < o; )
              y && y[r].run();
            r = -1, o = a.length;
          }
          y = null, e = !1, v(n);
        }
      }
      se.nextTick = function(n) {
        var o = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var x = 1; x < arguments.length; x++)
            o[x - 1] = arguments[x];
        a.push(new d(n, o)), a.length === 1 && !e && i(g);
      };
      function d(n, o) {
        this.fun = n, this.array = o;
      }
      d.prototype.run = function() {
        this.fun.apply(null, this.array);
      }, se.title = "browser", se.browser = !0, se.env = {}, se.argv = [], se.version = "", se.versions = {};
      function c() {
      }
      se.on = c, se.addListener = c, se.once = c, se.off = c, se.removeListener = c, se.removeAllListeners = c, se.emit = c, se.binding = function(n) {
        throw new Error("process.binding is not supported");
      }, se.cwd = function() {
        return "/";
      }, se.chdir = function(n) {
        throw new Error("process.chdir is not supported");
      }, se.umask = function() {
        return 0;
      };
    }, {}], 103: [function(le, de, oe) {
      de.exports = le("./lib/_stream_duplex.js");
    }, { "./lib/_stream_duplex.js": 104 }], 104: [function(le, de, oe) {
      var se = Object.keys || function(h) {
        var g = [];
        for (var d in h)
          g.push(d);
        return g;
      };
      de.exports = e;
      var Q = le("process-nextick-args"), u = le("core-util-is");
      u.inherits = le("inherits");
      var P = le("./_stream_readable"), t = le("./_stream_writable");
      u.inherits(e, P);
      for (var i = se(t.prototype), v = 0; v < i.length; v++) {
        var a = i[v];
        e.prototype[a] || (e.prototype[a] = t.prototype[a]);
      }
      function e(h) {
        if (!(this instanceof e))
          return new e(h);
        P.call(this, h), t.call(this, h), h && h.readable === !1 && (this.readable = !1), h && h.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, h && h.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", y);
      }
      function y() {
        this.allowHalfOpen || this._writableState.ended || Q(r, this);
      }
      function r(h) {
        h.end();
      }
    }, { "./_stream_readable": 106, "./_stream_writable": 108, "core-util-is": 79, inherits: 84, "process-nextick-args": 101 }], 105: [function(le, de, oe) {
      de.exports = u;
      var se = le("./_stream_transform"), Q = le("core-util-is");
      Q.inherits = le("inherits"), Q.inherits(u, se);
      function u(P) {
        if (!(this instanceof u))
          return new u(P);
        se.call(this, P);
      }
      u.prototype._transform = function(P, t, i) {
        i(null, P);
      };
    }, { "./_stream_transform": 107, "core-util-is": 79, inherits: 84 }], 106: [function(le, de, oe) {
      (function(se) {
        de.exports = n;
        var Q = le("process-nextick-args"), u = le("isarray"), P;
        n.ReadableState = c, le("events").EventEmitter;
        var t = function(W, z) {
          return W.listeners(z).length;
        }, i;
        (function() {
          try {
            i = le("stream");
          } catch {
          } finally {
            i || (i = le("events").EventEmitter);
          }
        })();
        var v = le("buffer").Buffer, a = le("buffer-shims"), e = le("core-util-is");
        e.inherits = le("inherits");
        var y = le("util"), r = void 0;
        y && y.debuglog ? r = y.debuglog("stream") : r = function() {
        };
        var h = le("./internal/streams/BufferList"), g;
        e.inherits(n, i);
        function d(W, z, V) {
          if (typeof W.prependListener == "function")
            return W.prependListener(z, V);
          !W._events || !W._events[z] ? W.on(z, V) : u(W._events[z]) ? W._events[z].unshift(V) : W._events[z] = [V, W._events[z]];
        }
        function c(W, z) {
          P = P || le("./_stream_duplex"), W = W || {}, this.objectMode = !!W.objectMode, z instanceof P && (this.objectMode = this.objectMode || !!W.readableObjectMode);
          var V = W.highWaterMark, L = this.objectMode ? 16 : 16 * 1024;
          this.highWaterMark = V || V === 0 ? V : L, this.highWaterMark = ~~this.highWaterMark, this.buffer = new h(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.defaultEncoding = W.defaultEncoding || "utf8", this.ranOut = !1, this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, W.encoding && (g || (g = le("string_decoder/").StringDecoder), this.decoder = new g(W.encoding), this.encoding = W.encoding);
        }
        function n(W) {
          if (P = P || le("./_stream_duplex"), !(this instanceof n))
            return new n(W);
          this._readableState = new c(W, this), this.readable = !0, W && typeof W.read == "function" && (this._read = W.read), i.call(this);
        }
        n.prototype.push = function(W, z) {
          var V = this._readableState;
          return !V.objectMode && typeof W == "string" && (z = z || V.defaultEncoding, z !== V.encoding && (W = a.from(W, z), z = "")), o(this, V, W, z, !1);
        }, n.prototype.unshift = function(W) {
          var z = this._readableState;
          return o(this, z, W, "", !0);
        }, n.prototype.isPaused = function() {
          return this._readableState.flowing === !1;
        };
        function o(W, z, V, L, Y) {
          var J = p(z, V);
          if (J)
            W.emit("error", J);
          else if (V === null)
            z.reading = !1, w(W, z);
          else if (z.objectMode || V && V.length > 0)
            if (z.ended && !Y) {
              var ie = new Error("stream.push() after EOF");
              W.emit("error", ie);
            } else if (z.endEmitted && Y) {
              var q = new Error("stream.unshift() after end event");
              W.emit("error", q);
            } else {
              var N;
              z.decoder && !Y && !L && (V = z.decoder.write(V), N = !z.objectMode && V.length === 0), Y || (z.reading = !1), N || (z.flowing && z.length === 0 && !z.sync ? (W.emit("data", V), W.read(0)) : (z.length += z.objectMode ? 1 : V.length, Y ? z.buffer.unshift(V) : z.buffer.push(V), z.needReadable && X(W))), j(W, z);
            }
          else
            Y || (z.reading = !1);
          return x(z);
        }
        function x(W) {
          return !W.ended && (W.needReadable || W.length < W.highWaterMark || W.length === 0);
        }
        n.prototype.setEncoding = function(W) {
          return g || (g = le("string_decoder/").StringDecoder), this._readableState.decoder = new g(W), this._readableState.encoding = W, this;
        };
        var f = 8388608;
        function m(W) {
          return W >= f ? W = f : (W--, W |= W >>> 1, W |= W >>> 2, W |= W >>> 4, W |= W >>> 8, W |= W >>> 16, W++), W;
        }
        function C(W, z) {
          return W <= 0 || z.length === 0 && z.ended ? 0 : z.objectMode ? 1 : W !== W ? z.flowing && z.length ? z.buffer.head.data.length : z.length : (W > z.highWaterMark && (z.highWaterMark = m(W)), W <= z.length ? W : z.ended ? z.length : (z.needReadable = !0, 0));
        }
        n.prototype.read = function(W) {
          r("read", W), W = parseInt(W, 10);
          var z = this._readableState, V = W;
          if (W !== 0 && (z.emittedReadable = !1), W === 0 && z.needReadable && (z.length >= z.highWaterMark || z.ended))
            return r("read: emitReadable", z.length, z.ended), z.length === 0 && z.ended ? O(this) : X(this), null;
          if (W = C(W, z), W === 0 && z.ended)
            return z.length === 0 && O(this), null;
          var L = z.needReadable;
          r("need readable", L), (z.length === 0 || z.length - W < z.highWaterMark) && (L = !0, r("length less than watermark", L)), z.ended || z.reading ? (L = !1, r("reading or ended", L)) : L && (r("do read"), z.reading = !0, z.sync = !0, z.length === 0 && (z.needReadable = !0), this._read(z.highWaterMark), z.sync = !1, z.reading || (W = C(V, z)));
          var Y;
          return W > 0 ? Y = S(W, z) : Y = null, Y === null ? (z.needReadable = !0, W = 0) : z.length -= W, z.length === 0 && (z.ended || (z.needReadable = !0), V !== W && z.ended && O(this)), Y !== null && this.emit("data", Y), Y;
        };
        function p(W, z) {
          var V = null;
          return !v.isBuffer(z) && typeof z != "string" && z !== null && z !== void 0 && !W.objectMode && (V = new TypeError("Invalid non-string/buffer chunk")), V;
        }
        function w(W, z) {
          if (!z.ended) {
            if (z.decoder) {
              var V = z.decoder.end();
              V && V.length && (z.buffer.push(V), z.length += z.objectMode ? 1 : V.length);
            }
            z.ended = !0, X(W);
          }
        }
        function X(W) {
          var z = W._readableState;
          z.needReadable = !1, z.emittedReadable || (r("emitReadable", z.flowing), z.emittedReadable = !0, z.sync ? Q(M, W) : M(W));
        }
        function M(W) {
          r("emit readable"), W.emit("readable"), _(W);
        }
        function j(W, z) {
          z.readingMore || (z.readingMore = !0, Q(B, W, z));
        }
        function B(W, z) {
          for (var V = z.length; !z.reading && !z.flowing && !z.ended && z.length < z.highWaterMark && (r("maybeReadMore read 0"), W.read(0), V !== z.length); )
            V = z.length;
          z.readingMore = !1;
        }
        n.prototype._read = function(W) {
          this.emit("error", new Error("_read() is not implemented"));
        }, n.prototype.pipe = function(W, z) {
          var V = this, L = this._readableState;
          switch (L.pipesCount) {
            case 0:
              L.pipes = W;
              break;
            case 1:
              L.pipes = [L.pipes, W];
              break;
            default:
              L.pipes.push(W);
              break;
          }
          L.pipesCount += 1, r("pipe count=%d opts=%j", L.pipesCount, z);
          var Y = (!z || z.end !== !1) && W !== se.stdout && W !== se.stderr, J = Y ? q : E;
          L.endEmitted ? Q(J) : V.once("end", J), W.on("unpipe", ie);
          function ie(ne) {
            r("onunpipe"), ne === V && E();
          }
          function q() {
            r("onend"), W.end();
          }
          var N = R(V);
          W.on("drain", N);
          var Z = !1;
          function E() {
            r("cleanup"), W.removeListener("close", $), W.removeListener("finish", k), W.removeListener("drain", N), W.removeListener("error", ee), W.removeListener("unpipe", ie), V.removeListener("end", q), V.removeListener("end", E), V.removeListener("data", re), Z = !0, L.awaitDrain && (!W._writableState || W._writableState.needDrain) && N();
          }
          var te = !1;
          V.on("data", re);
          function re(ne) {
            r("ondata"), te = !1;
            var ae = W.write(ne);
            ae === !1 && !te && ((L.pipesCount === 1 && L.pipes === W || L.pipesCount > 1 && K(L.pipes, W) !== -1) && !Z && (r("false write response, pause", V._readableState.awaitDrain), V._readableState.awaitDrain++, te = !0), V.pause());
          }
          function ee(ne) {
            r("onerror", ne), H(), W.removeListener("error", ee), t(W, "error") === 0 && W.emit("error", ne);
          }
          d(W, "error", ee);
          function $() {
            W.removeListener("finish", k), H();
          }
          W.once("close", $);
          function k() {
            r("onfinish"), W.removeListener("close", $), H();
          }
          W.once("finish", k);
          function H() {
            r("unpipe"), V.unpipe(W);
          }
          return W.emit("pipe", V), L.flowing || (r("pipe resume"), V.resume()), W;
        };
        function R(W) {
          return function() {
            var z = W._readableState;
            r("pipeOnDrain", z.awaitDrain), z.awaitDrain && z.awaitDrain--, z.awaitDrain === 0 && t(W, "data") && (z.flowing = !0, _(W));
          };
        }
        n.prototype.unpipe = function(W) {
          var z = this._readableState;
          if (z.pipesCount === 0)
            return this;
          if (z.pipesCount === 1)
            return W && W !== z.pipes ? this : (W || (W = z.pipes), z.pipes = null, z.pipesCount = 0, z.flowing = !1, W && W.emit("unpipe", this), this);
          if (!W) {
            var V = z.pipes, L = z.pipesCount;
            z.pipes = null, z.pipesCount = 0, z.flowing = !1;
            for (var Y = 0; Y < L; Y++)
              V[Y].emit("unpipe", this);
            return this;
          }
          var J = K(z.pipes, W);
          return J === -1 ? this : (z.pipes.splice(J, 1), z.pipesCount -= 1, z.pipesCount === 1 && (z.pipes = z.pipes[0]), W.emit("unpipe", this), this);
        }, n.prototype.on = function(W, z) {
          var V = i.prototype.on.call(this, W, z);
          if (W === "data")
            this._readableState.flowing !== !1 && this.resume();
          else if (W === "readable") {
            var L = this._readableState;
            !L.endEmitted && !L.readableListening && (L.readableListening = L.needReadable = !0, L.emittedReadable = !1, L.reading ? L.length && X(this) : Q(D, this));
          }
          return V;
        }, n.prototype.addListener = n.prototype.on;
        function D(W) {
          r("readable nexttick read 0"), W.read(0);
        }
        n.prototype.resume = function() {
          var W = this._readableState;
          return W.flowing || (r("resume"), W.flowing = !0, b(this, W)), this;
        };
        function b(W, z) {
          z.resumeScheduled || (z.resumeScheduled = !0, Q(l, W, z));
        }
        function l(W, z) {
          z.reading || (r("resume read 0"), W.read(0)), z.resumeScheduled = !1, z.awaitDrain = 0, W.emit("resume"), _(W), z.flowing && !z.reading && W.read(0);
        }
        n.prototype.pause = function() {
          return r("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (r("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
        };
        function _(W) {
          var z = W._readableState;
          for (r("flow", z.flowing); z.flowing && W.read() !== null; )
            ;
        }
        n.prototype.wrap = function(W) {
          var z = this._readableState, V = !1, L = this;
          W.on("end", function() {
            if (r("wrapped end"), z.decoder && !z.ended) {
              var ie = z.decoder.end();
              ie && ie.length && L.push(ie);
            }
            L.push(null);
          }), W.on("data", function(ie) {
            if (r("wrapped data"), z.decoder && (ie = z.decoder.write(ie)), !(z.objectMode && ie == null) && !(!z.objectMode && (!ie || !ie.length))) {
              var q = L.push(ie);
              q || (V = !0, W.pause());
            }
          });
          for (var Y in W)
            this[Y] === void 0 && typeof W[Y] == "function" && (this[Y] = function(ie) {
              return function() {
                return W[ie].apply(W, arguments);
              };
            }(Y));
          var J = ["error", "close", "destroy", "pause", "resume"];
          return G(J, function(ie) {
            W.on(ie, L.emit.bind(L, ie));
          }), L._read = function(ie) {
            r("wrapped _read", ie), V && (V = !1, W.resume());
          }, L;
        }, n._fromList = S;
        function S(W, z) {
          if (z.length === 0)
            return null;
          var V;
          return z.objectMode ? V = z.buffer.shift() : !W || W >= z.length ? (z.decoder ? V = z.buffer.join("") : z.buffer.length === 1 ? V = z.buffer.head.data : V = z.buffer.concat(z.length), z.buffer.clear()) : V = A(W, z.buffer, z.decoder), V;
        }
        function A(W, z, V) {
          var L;
          return W < z.head.data.length ? (L = z.head.data.slice(0, W), z.head.data = z.head.data.slice(W)) : W === z.head.data.length ? L = z.shift() : L = V ? F(W, z) : T(W, z), L;
        }
        function F(W, z) {
          var V = z.head, L = 1, Y = V.data;
          for (W -= Y.length; V = V.next; ) {
            var J = V.data, ie = W > J.length ? J.length : W;
            if (ie === J.length ? Y += J : Y += J.slice(0, W), W -= ie, W === 0) {
              ie === J.length ? (++L, V.next ? z.head = V.next : z.head = z.tail = null) : (z.head = V, V.data = J.slice(ie));
              break;
            }
            ++L;
          }
          return z.length -= L, Y;
        }
        function T(W, z) {
          var V = a.allocUnsafe(W), L = z.head, Y = 1;
          for (L.data.copy(V), W -= L.data.length; L = L.next; ) {
            var J = L.data, ie = W > J.length ? J.length : W;
            if (J.copy(V, V.length - W, 0, ie), W -= ie, W === 0) {
              ie === J.length ? (++Y, L.next ? z.head = L.next : z.head = z.tail = null) : (z.head = L, L.data = J.slice(ie));
              break;
            }
            ++Y;
          }
          return z.length -= Y, V;
        }
        function O(W) {
          var z = W._readableState;
          if (z.length > 0)
            throw new Error('"endReadable()" called on non-empty stream');
          z.endEmitted || (z.ended = !0, Q(U, z, W));
        }
        function U(W, z) {
          !W.endEmitted && W.length === 0 && (W.endEmitted = !0, z.readable = !1, z.emit("end"));
        }
        function G(W, z) {
          for (var V = 0, L = W.length; V < L; V++)
            z(W[V], V);
        }
        function K(W, z) {
          for (var V = 0, L = W.length; V < L; V++)
            if (W[V] === z)
              return V;
          return -1;
        }
      }).call(this, le("_process"));
    }, { "./_stream_duplex": 104, "./internal/streams/BufferList": 109, _process: 102, buffer: 78, "buffer-shims": 77, "core-util-is": 79, events: 82, inherits: 84, isarray: 86, "process-nextick-args": 101, "string_decoder/": 116, util: 76 }], 107: [function(le, de, oe) {
      de.exports = t;
      var se = le("./_stream_duplex"), Q = le("core-util-is");
      Q.inherits = le("inherits"), Q.inherits(t, se);
      function u(v) {
        this.afterTransform = function(a, e) {
          return P(v, a, e);
        }, this.needTransform = !1, this.transforming = !1, this.writecb = null, this.writechunk = null, this.writeencoding = null;
      }
      function P(v, a, e) {
        var y = v._transformState;
        y.transforming = !1;
        var r = y.writecb;
        if (!r)
          return v.emit("error", new Error("no writecb in Transform class"));
        y.writechunk = null, y.writecb = null, e != null && v.push(e), r(a);
        var h = v._readableState;
        h.reading = !1, (h.needReadable || h.length < h.highWaterMark) && v._read(h.highWaterMark);
      }
      function t(v) {
        if (!(this instanceof t))
          return new t(v);
        se.call(this, v), this._transformState = new u(this);
        var a = this;
        this._readableState.needReadable = !0, this._readableState.sync = !1, v && (typeof v.transform == "function" && (this._transform = v.transform), typeof v.flush == "function" && (this._flush = v.flush)), this.once("prefinish", function() {
          typeof this._flush == "function" ? this._flush(function(e, y) {
            i(a, e, y);
          }) : i(a);
        });
      }
      t.prototype.push = function(v, a) {
        return this._transformState.needTransform = !1, se.prototype.push.call(this, v, a);
      }, t.prototype._transform = function(v, a, e) {
        throw new Error("_transform() is not implemented");
      }, t.prototype._write = function(v, a, e) {
        var y = this._transformState;
        if (y.writecb = e, y.writechunk = v, y.writeencoding = a, !y.transforming) {
          var r = this._readableState;
          (y.needTransform || r.needReadable || r.length < r.highWaterMark) && this._read(r.highWaterMark);
        }
      }, t.prototype._read = function(v) {
        var a = this._transformState;
        a.writechunk !== null && a.writecb && !a.transforming ? (a.transforming = !0, this._transform(a.writechunk, a.writeencoding, a.afterTransform)) : a.needTransform = !0;
      };
      function i(v, a, e) {
        if (a)
          return v.emit("error", a);
        e != null && v.push(e);
        var y = v._writableState, r = v._transformState;
        if (y.length)
          throw new Error("Calling transform done when ws.length != 0");
        if (r.transforming)
          throw new Error("Calling transform done when still transforming");
        return v.push(null);
      }
    }, { "./_stream_duplex": 104, "core-util-is": 79, inherits: 84 }], 108: [function(le, de, oe) {
      (function(se) {
        de.exports = d;
        var Q = le("process-nextick-args"), u = !se.browser && ["v0.10", "v0.9."].indexOf(se.version.slice(0, 5)) > -1 ? setImmediate : Q, P;
        d.WritableState = h;
        var t = le("core-util-is");
        t.inherits = le("inherits");
        var i = {
          deprecate: le("util-deprecate")
        }, v;
        (function() {
          try {
            v = le("stream");
          } catch {
          } finally {
            v || (v = le("events").EventEmitter);
          }
        })();
        var a = le("buffer").Buffer, e = le("buffer-shims");
        t.inherits(d, v);
        function y() {
        }
        function r(l, _, S) {
          this.chunk = l, this.encoding = _, this.callback = S, this.next = null;
        }
        function h(l, _) {
          P = P || le("./_stream_duplex"), l = l || {}, this.objectMode = !!l.objectMode, _ instanceof P && (this.objectMode = this.objectMode || !!l.writableObjectMode);
          var S = l.highWaterMark, A = this.objectMode ? 16 : 16 * 1024;
          this.highWaterMark = S || S === 0 ? S : A, this.highWaterMark = ~~this.highWaterMark, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1;
          var F = l.decodeStrings === !1;
          this.decodeStrings = !F, this.defaultEncoding = l.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(T) {
            p(_, T);
          }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new b(this);
        }
        h.prototype.getBuffer = function() {
          for (var _ = this.bufferedRequest, S = []; _; )
            S.push(_), _ = _.next;
          return S;
        }, function() {
          try {
            Object.defineProperty(h.prototype, "buffer", {
              get: i.deprecate(function() {
                return this.getBuffer();
              }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
            });
          } catch {
          }
        }();
        var g;
        typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (g = Function.prototype[Symbol.hasInstance], Object.defineProperty(d, Symbol.hasInstance, {
          value: function(l) {
            return g.call(this, l) ? !0 : l && l._writableState instanceof h;
          }
        })) : g = function(l) {
          return l instanceof this;
        };
        function d(l) {
          if (P = P || le("./_stream_duplex"), !g.call(d, this) && !(this instanceof P))
            return new d(l);
          this._writableState = new h(l, this), this.writable = !0, l && (typeof l.write == "function" && (this._write = l.write), typeof l.writev == "function" && (this._writev = l.writev)), v.call(this);
        }
        d.prototype.pipe = function() {
          this.emit("error", new Error("Cannot pipe, not readable"));
        };
        function c(l, _) {
          var S = new Error("write after end");
          l.emit("error", S), Q(_, S);
        }
        function n(l, _, S, A) {
          var F = !0, T = !1;
          return S === null ? T = new TypeError("May not write null values to stream") : typeof S != "string" && S !== void 0 && !_.objectMode && (T = new TypeError("Invalid non-string/buffer chunk")), T && (l.emit("error", T), Q(A, T), F = !1), F;
        }
        d.prototype.write = function(l, _, S) {
          var A = this._writableState, F = !1, T = a.isBuffer(l);
          return typeof _ == "function" && (S = _, _ = null), T ? _ = "buffer" : _ || (_ = A.defaultEncoding), typeof S != "function" && (S = y), A.ended ? c(this, S) : (T || n(this, A, l, S)) && (A.pendingcb++, F = x(this, A, T, l, _, S)), F;
        }, d.prototype.cork = function() {
          var l = this._writableState;
          l.corked++;
        }, d.prototype.uncork = function() {
          var l = this._writableState;
          l.corked && (l.corked--, !l.writing && !l.corked && !l.finished && !l.bufferProcessing && l.bufferedRequest && M(this, l));
        }, d.prototype.setDefaultEncoding = function(_) {
          if (typeof _ == "string" && (_ = _.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((_ + "").toLowerCase()) > -1))
            throw new TypeError("Unknown encoding: " + _);
          return this._writableState.defaultEncoding = _, this;
        };
        function o(l, _, S) {
          return !l.objectMode && l.decodeStrings !== !1 && typeof _ == "string" && (_ = e.from(_, S)), _;
        }
        function x(l, _, S, A, F, T) {
          S || (A = o(_, A, F), a.isBuffer(A) && (F = "buffer"));
          var O = _.objectMode ? 1 : A.length;
          _.length += O;
          var U = _.length < _.highWaterMark;
          if (U || (_.needDrain = !0), _.writing || _.corked) {
            var G = _.lastBufferedRequest;
            _.lastBufferedRequest = new r(A, F, T), G ? G.next = _.lastBufferedRequest : _.bufferedRequest = _.lastBufferedRequest, _.bufferedRequestCount += 1;
          } else
            f(l, _, !1, O, A, F, T);
          return U;
        }
        function f(l, _, S, A, F, T, O) {
          _.writelen = A, _.writecb = O, _.writing = !0, _.sync = !0, S ? l._writev(F, _.onwrite) : l._write(F, T, _.onwrite), _.sync = !1;
        }
        function m(l, _, S, A, F) {
          --_.pendingcb, S ? Q(F, A) : F(A), l._writableState.errorEmitted = !0, l.emit("error", A);
        }
        function C(l) {
          l.writing = !1, l.writecb = null, l.length -= l.writelen, l.writelen = 0;
        }
        function p(l, _) {
          var S = l._writableState, A = S.sync, F = S.writecb;
          if (C(S), _)
            m(l, S, A, _, F);
          else {
            var T = j(S);
            !T && !S.corked && !S.bufferProcessing && S.bufferedRequest && M(l, S), A ? u(w, l, S, T, F) : w(l, S, T, F);
          }
        }
        function w(l, _, S, A) {
          S || X(l, _), _.pendingcb--, A(), R(l, _);
        }
        function X(l, _) {
          _.length === 0 && _.needDrain && (_.needDrain = !1, l.emit("drain"));
        }
        function M(l, _) {
          _.bufferProcessing = !0;
          var S = _.bufferedRequest;
          if (l._writev && S && S.next) {
            var A = _.bufferedRequestCount, F = new Array(A), T = _.corkedRequestsFree;
            T.entry = S;
            for (var O = 0; S; )
              F[O] = S, S = S.next, O += 1;
            f(l, _, !0, _.length, F, "", T.finish), _.pendingcb++, _.lastBufferedRequest = null, T.next ? (_.corkedRequestsFree = T.next, T.next = null) : _.corkedRequestsFree = new b(_);
          } else {
            for (; S; ) {
              var U = S.chunk, G = S.encoding, K = S.callback, W = _.objectMode ? 1 : U.length;
              if (f(l, _, !1, W, U, G, K), S = S.next, _.writing)
                break;
            }
            S === null && (_.lastBufferedRequest = null);
          }
          _.bufferedRequestCount = 0, _.bufferedRequest = S, _.bufferProcessing = !1;
        }
        d.prototype._write = function(l, _, S) {
          S(new Error("_write() is not implemented"));
        }, d.prototype._writev = null, d.prototype.end = function(l, _, S) {
          var A = this._writableState;
          typeof l == "function" ? (S = l, l = null, _ = null) : typeof _ == "function" && (S = _, _ = null), l != null && this.write(l, _), A.corked && (A.corked = 1, this.uncork()), !A.ending && !A.finished && D(this, A, S);
        };
        function j(l) {
          return l.ending && l.length === 0 && l.bufferedRequest === null && !l.finished && !l.writing;
        }
        function B(l, _) {
          _.prefinished || (_.prefinished = !0, l.emit("prefinish"));
        }
        function R(l, _) {
          var S = j(_);
          return S && (_.pendingcb === 0 ? (B(l, _), _.finished = !0, l.emit("finish")) : B(l, _)), S;
        }
        function D(l, _, S) {
          _.ending = !0, R(l, _), S && (_.finished ? Q(S) : l.once("finish", S)), _.ended = !0, l.writable = !1;
        }
        function b(l) {
          var _ = this;
          this.next = null, this.entry = null, this.finish = function(S) {
            var A = _.entry;
            for (_.entry = null; A; ) {
              var F = A.callback;
              l.pendingcb--, F(S), A = A.next;
            }
            l.corkedRequestsFree ? l.corkedRequestsFree.next = _ : l.corkedRequestsFree = _;
          };
        }
      }).call(this, le("_process"));
    }, { "./_stream_duplex": 104, _process: 102, buffer: 78, "buffer-shims": 77, "core-util-is": 79, events: 82, inherits: 84, "process-nextick-args": 101, "util-deprecate": 118 }], 109: [function(le, de, oe) {
      le("buffer").Buffer;
      var se = le("buffer-shims");
      de.exports = Q;
      function Q() {
        this.head = null, this.tail = null, this.length = 0;
      }
      Q.prototype.push = function(u) {
        var P = { data: u, next: null };
        this.length > 0 ? this.tail.next = P : this.head = P, this.tail = P, ++this.length;
      }, Q.prototype.unshift = function(u) {
        var P = { data: u, next: this.head };
        this.length === 0 && (this.tail = P), this.head = P, ++this.length;
      }, Q.prototype.shift = function() {
        if (this.length !== 0) {
          var u = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, u;
        }
      }, Q.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, Q.prototype.join = function(u) {
        if (this.length === 0)
          return "";
        for (var P = this.head, t = "" + P.data; P = P.next; )
          t += u + P.data;
        return t;
      }, Q.prototype.concat = function(u) {
        if (this.length === 0)
          return se.alloc(0);
        if (this.length === 1)
          return this.head.data;
        for (var P = se.allocUnsafe(u >>> 0), t = this.head, i = 0; t; )
          t.data.copy(P, i), i += t.data.length, t = t.next;
        return P;
      };
    }, { buffer: 78, "buffer-shims": 77 }], 110: [function(le, de, oe) {
      de.exports = le("./lib/_stream_passthrough.js");
    }, { "./lib/_stream_passthrough.js": 105 }], 111: [function(le, de, oe) {
      (function(se) {
        var Q = function() {
          try {
            return le("stream");
          } catch {
          }
        }();
        oe = de.exports = le("./lib/_stream_readable.js"), oe.Stream = Q || oe, oe.Readable = oe, oe.Writable = le("./lib/_stream_writable.js"), oe.Duplex = le("./lib/_stream_duplex.js"), oe.Transform = le("./lib/_stream_transform.js"), oe.PassThrough = le("./lib/_stream_passthrough.js"), !se.browser && se.env.READABLE_STREAM === "disable" && Q && (de.exports = Q);
      }).call(this, le("_process"));
    }, { "./lib/_stream_duplex.js": 104, "./lib/_stream_passthrough.js": 105, "./lib/_stream_readable.js": 106, "./lib/_stream_transform.js": 107, "./lib/_stream_writable.js": 108, _process: 102 }], 112: [function(le, de, oe) {
      de.exports = le("./lib/_stream_transform.js");
    }, { "./lib/_stream_transform.js": 107 }], 113: [function(le, de, oe) {
      de.exports = le("./lib/_stream_writable.js");
    }, { "./lib/_stream_writable.js": 108 }], 114: [function(le, de, oe) {
      (function(se) {
        (function(Q) {
          Q.parser = function(q, N) {
            return new P(q, N);
          }, Q.SAXParser = P, Q.SAXStream = r, Q.createStream = y, Q.MAX_BUFFER_LENGTH = 64 * 1024;
          var u = [
            "comment",
            "sgmlDecl",
            "textNode",
            "tagName",
            "doctype",
            "procInstName",
            "procInstBody",
            "entity",
            "attribName",
            "attribValue",
            "cdata",
            "script"
          ];
          Q.EVENTS = [
            "text",
            "processinginstruction",
            "sgmldeclaration",
            "doctype",
            "comment",
            "attribute",
            "opentag",
            "closetag",
            "opencdata",
            "cdata",
            "closecdata",
            "error",
            "end",
            "ready",
            "script",
            "opennamespace",
            "closenamespace"
          ];
          function P(q, N) {
            if (!(this instanceof P))
              return new P(q, N);
            var Z = this;
            i(Z), Z.q = Z.c = "", Z.bufferCheckPosition = Q.MAX_BUFFER_LENGTH, Z.opt = N || {}, Z.opt.lowercase = Z.opt.lowercase || Z.opt.lowercasetags, Z.looseCase = Z.opt.lowercase ? "toLowerCase" : "toUpperCase", Z.tags = [], Z.closed = Z.closedRoot = Z.sawRoot = !1, Z.tag = Z.error = null, Z.strict = !!q, Z.noscript = !!(q || Z.opt.noscript), Z.state = b.BEGIN, Z.strictEntities = Z.opt.strictEntities, Z.ENTITIES = Z.strictEntities ? Object.create(Q.XML_ENTITIES) : Object.create(Q.ENTITIES), Z.attribList = [], Z.opt.xmlns && (Z.ns = Object.create(C)), Z.trackPosition = Z.opt.position !== !1, Z.trackPosition && (Z.position = Z.line = Z.column = 0), _(Z, "onready");
          }
          Object.create || (Object.create = function(q) {
            function N() {
            }
            N.prototype = q;
            var Z = new N();
            return Z;
          }), Object.keys || (Object.keys = function(q) {
            var N = [];
            for (var Z in q)
              q.hasOwnProperty(Z) && N.push(Z);
            return N;
          });
          function t(q) {
            for (var N = Math.max(Q.MAX_BUFFER_LENGTH, 10), Z = 0, E = 0, te = u.length; E < te; E++) {
              var re = q[u[E]].length;
              if (re > N)
                switch (u[E]) {
                  case "textNode":
                    A(q);
                    break;
                  case "cdata":
                    S(q, "oncdata", q.cdata), q.cdata = "";
                    break;
                  case "script":
                    S(q, "onscript", q.script), q.script = "";
                    break;
                  default:
                    T(q, "Max buffer length exceeded: " + u[E]);
                }
              Z = Math.max(Z, re);
            }
            var ee = Q.MAX_BUFFER_LENGTH - Z;
            q.bufferCheckPosition = ee + q.position;
          }
          function i(q) {
            for (var N = 0, Z = u.length; N < Z; N++)
              q[u[N]] = "";
          }
          function v(q) {
            A(q), q.cdata !== "" && (S(q, "oncdata", q.cdata), q.cdata = ""), q.script !== "" && (S(q, "onscript", q.script), q.script = "");
          }
          P.prototype = {
            end: function() {
              O(this);
            },
            write: ie,
            resume: function() {
              return this.error = null, this;
            },
            close: function() {
              return this.write(null);
            },
            flush: function() {
              v(this);
            }
          };
          var a;
          try {
            a = le("stream").Stream;
          } catch {
            a = function() {
            };
          }
          var e = Q.EVENTS.filter(function(q) {
            return q !== "error" && q !== "end";
          });
          function y(q, N) {
            return new r(q, N);
          }
          function r(q, N) {
            if (!(this instanceof r))
              return new r(q, N);
            a.apply(this), this._parser = new P(q, N), this.writable = !0, this.readable = !0;
            var Z = this;
            this._parser.onend = function() {
              Z.emit("end");
            }, this._parser.onerror = function(E) {
              Z.emit("error", E), Z._parser.error = null;
            }, this._decoder = null, e.forEach(function(E) {
              Object.defineProperty(Z, "on" + E, {
                get: function() {
                  return Z._parser["on" + E];
                },
                set: function(te) {
                  if (!te)
                    return Z.removeAllListeners(E), Z._parser["on" + E] = te, te;
                  Z.on(E, te);
                },
                enumerable: !0,
                configurable: !1
              });
            });
          }
          r.prototype = Object.create(a.prototype, {
            constructor: {
              value: r
            }
          }), r.prototype.write = function(q) {
            if (typeof se == "function" && typeof se.isBuffer == "function" && se.isBuffer(q)) {
              if (!this._decoder) {
                var N = le("string_decoder").StringDecoder;
                this._decoder = new N("utf8");
              }
              q = this._decoder.write(q);
            }
            return this._parser.write(q.toString()), this.emit("data", q), !0;
          }, r.prototype.end = function(q) {
            return q && q.length && this.write(q), this._parser.end(), !0;
          }, r.prototype.on = function(q, N) {
            var Z = this;
            return !Z._parser["on" + q] && e.indexOf(q) !== -1 && (Z._parser["on" + q] = function() {
              var E = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
              E.splice(0, 0, q), Z.emit.apply(Z, E);
            }), a.prototype.on.call(Z, q, N);
          };
          var h = `\r
	 `, g = "0124356789", d = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", c = `'"`, n = h + ">", o = "[CDATA[", x = "DOCTYPE", f = "http://www.w3.org/XML/1998/namespace", m = "http://www.w3.org/2000/xmlns/", C = { xml: f, xmlns: m };
          h = j(h), g = j(g), d = j(d);
          var p = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, w = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/, X = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, M = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/;
          c = j(c), n = j(n);
          function j(q) {
            return q.split("").reduce(function(N, Z) {
              return N[Z] = !0, N;
            }, {});
          }
          function B(q) {
            return Object.prototype.toString.call(q) === "[object RegExp]";
          }
          function R(q, N) {
            return B(q) ? !!N.match(q) : q[N];
          }
          function D(q, N) {
            return !R(q, N);
          }
          var b = 0;
          Q.STATE = {
            BEGIN: b++,
            // leading byte order mark or whitespace
            BEGIN_WHITESPACE: b++,
            // leading whitespace
            TEXT: b++,
            // general stuff
            TEXT_ENTITY: b++,
            // &amp and such.
            OPEN_WAKA: b++,
            // <
            SGML_DECL: b++,
            // <!BLARG
            SGML_DECL_QUOTED: b++,
            // <!BLARG foo "bar
            DOCTYPE: b++,
            // <!DOCTYPE
            DOCTYPE_QUOTED: b++,
            // <!DOCTYPE "//blah
            DOCTYPE_DTD: b++,
            // <!DOCTYPE "//blah" [ ...
            DOCTYPE_DTD_QUOTED: b++,
            // <!DOCTYPE "//blah" [ "foo
            COMMENT_STARTING: b++,
            // <!-
            COMMENT: b++,
            // <!--
            COMMENT_ENDING: b++,
            // <!-- blah -
            COMMENT_ENDED: b++,
            // <!-- blah --
            CDATA: b++,
            // <![CDATA[ something
            CDATA_ENDING: b++,
            // ]
            CDATA_ENDING_2: b++,
            // ]]
            PROC_INST: b++,
            // <?hi
            PROC_INST_BODY: b++,
            // <?hi there
            PROC_INST_ENDING: b++,
            // <?hi "there" ?
            OPEN_TAG: b++,
            // <strong
            OPEN_TAG_SLASH: b++,
            // <strong /
            ATTRIB: b++,
            // <a
            ATTRIB_NAME: b++,
            // <a foo
            ATTRIB_NAME_SAW_WHITE: b++,
            // <a foo _
            ATTRIB_VALUE: b++,
            // <a foo=
            ATTRIB_VALUE_QUOTED: b++,
            // <a foo="bar
            ATTRIB_VALUE_CLOSED: b++,
            // <a foo="bar"
            ATTRIB_VALUE_UNQUOTED: b++,
            // <a foo=bar
            ATTRIB_VALUE_ENTITY_Q: b++,
            // <foo bar="&quot;"
            ATTRIB_VALUE_ENTITY_U: b++,
            // <foo bar=&quot
            CLOSE_TAG: b++,
            // </a
            CLOSE_TAG_SAW_WHITE: b++,
            // </a   >
            SCRIPT: b++,
            // <script> ...
            SCRIPT_ENDING: b++
            // <script> ... <
          }, Q.XML_ENTITIES = {
            amp: "&",
            gt: ">",
            lt: "<",
            quot: '"',
            apos: "'"
          }, Q.ENTITIES = {
            amp: "&",
            gt: ">",
            lt: "<",
            quot: '"',
            apos: "'",
            AElig: 198,
            Aacute: 193,
            Acirc: 194,
            Agrave: 192,
            Aring: 197,
            Atilde: 195,
            Auml: 196,
            Ccedil: 199,
            ETH: 208,
            Eacute: 201,
            Ecirc: 202,
            Egrave: 200,
            Euml: 203,
            Iacute: 205,
            Icirc: 206,
            Igrave: 204,
            Iuml: 207,
            Ntilde: 209,
            Oacute: 211,
            Ocirc: 212,
            Ograve: 210,
            Oslash: 216,
            Otilde: 213,
            Ouml: 214,
            THORN: 222,
            Uacute: 218,
            Ucirc: 219,
            Ugrave: 217,
            Uuml: 220,
            Yacute: 221,
            aacute: 225,
            acirc: 226,
            aelig: 230,
            agrave: 224,
            aring: 229,
            atilde: 227,
            auml: 228,
            ccedil: 231,
            eacute: 233,
            ecirc: 234,
            egrave: 232,
            eth: 240,
            euml: 235,
            iacute: 237,
            icirc: 238,
            igrave: 236,
            iuml: 239,
            ntilde: 241,
            oacute: 243,
            ocirc: 244,
            ograve: 242,
            oslash: 248,
            otilde: 245,
            ouml: 246,
            szlig: 223,
            thorn: 254,
            uacute: 250,
            ucirc: 251,
            ugrave: 249,
            uuml: 252,
            yacute: 253,
            yuml: 255,
            copy: 169,
            reg: 174,
            nbsp: 160,
            iexcl: 161,
            cent: 162,
            pound: 163,
            curren: 164,
            yen: 165,
            brvbar: 166,
            sect: 167,
            uml: 168,
            ordf: 170,
            laquo: 171,
            not: 172,
            shy: 173,
            macr: 175,
            deg: 176,
            plusmn: 177,
            sup1: 185,
            sup2: 178,
            sup3: 179,
            acute: 180,
            micro: 181,
            para: 182,
            middot: 183,
            cedil: 184,
            ordm: 186,
            raquo: 187,
            frac14: 188,
            frac12: 189,
            frac34: 190,
            iquest: 191,
            times: 215,
            divide: 247,
            OElig: 338,
            oelig: 339,
            Scaron: 352,
            scaron: 353,
            Yuml: 376,
            fnof: 402,
            circ: 710,
            tilde: 732,
            Alpha: 913,
            Beta: 914,
            Gamma: 915,
            Delta: 916,
            Epsilon: 917,
            Zeta: 918,
            Eta: 919,
            Theta: 920,
            Iota: 921,
            Kappa: 922,
            Lambda: 923,
            Mu: 924,
            Nu: 925,
            Xi: 926,
            Omicron: 927,
            Pi: 928,
            Rho: 929,
            Sigma: 931,
            Tau: 932,
            Upsilon: 933,
            Phi: 934,
            Chi: 935,
            Psi: 936,
            Omega: 937,
            alpha: 945,
            beta: 946,
            gamma: 947,
            delta: 948,
            epsilon: 949,
            zeta: 950,
            eta: 951,
            theta: 952,
            iota: 953,
            kappa: 954,
            lambda: 955,
            mu: 956,
            nu: 957,
            xi: 958,
            omicron: 959,
            pi: 960,
            rho: 961,
            sigmaf: 962,
            sigma: 963,
            tau: 964,
            upsilon: 965,
            phi: 966,
            chi: 967,
            psi: 968,
            omega: 969,
            thetasym: 977,
            upsih: 978,
            piv: 982,
            ensp: 8194,
            emsp: 8195,
            thinsp: 8201,
            zwnj: 8204,
            zwj: 8205,
            lrm: 8206,
            rlm: 8207,
            ndash: 8211,
            mdash: 8212,
            lsquo: 8216,
            rsquo: 8217,
            sbquo: 8218,
            ldquo: 8220,
            rdquo: 8221,
            bdquo: 8222,
            dagger: 8224,
            Dagger: 8225,
            bull: 8226,
            hellip: 8230,
            permil: 8240,
            prime: 8242,
            Prime: 8243,
            lsaquo: 8249,
            rsaquo: 8250,
            oline: 8254,
            frasl: 8260,
            euro: 8364,
            image: 8465,
            weierp: 8472,
            real: 8476,
            trade: 8482,
            alefsym: 8501,
            larr: 8592,
            uarr: 8593,
            rarr: 8594,
            darr: 8595,
            harr: 8596,
            crarr: 8629,
            lArr: 8656,
            uArr: 8657,
            rArr: 8658,
            dArr: 8659,
            hArr: 8660,
            forall: 8704,
            part: 8706,
            exist: 8707,
            empty: 8709,
            nabla: 8711,
            isin: 8712,
            notin: 8713,
            ni: 8715,
            prod: 8719,
            sum: 8721,
            minus: 8722,
            lowast: 8727,
            radic: 8730,
            prop: 8733,
            infin: 8734,
            ang: 8736,
            and: 8743,
            or: 8744,
            cap: 8745,
            cup: 8746,
            int: 8747,
            there4: 8756,
            sim: 8764,
            cong: 8773,
            asymp: 8776,
            ne: 8800,
            equiv: 8801,
            le: 8804,
            ge: 8805,
            sub: 8834,
            sup: 8835,
            nsub: 8836,
            sube: 8838,
            supe: 8839,
            oplus: 8853,
            otimes: 8855,
            perp: 8869,
            sdot: 8901,
            lceil: 8968,
            rceil: 8969,
            lfloor: 8970,
            rfloor: 8971,
            lang: 9001,
            rang: 9002,
            loz: 9674,
            spades: 9824,
            clubs: 9827,
            hearts: 9829,
            diams: 9830
          }, Object.keys(Q.ENTITIES).forEach(function(q) {
            var N = Q.ENTITIES[q], Z = typeof N == "number" ? String.fromCharCode(N) : N;
            Q.ENTITIES[q] = Z;
          });
          for (var l in Q.STATE)
            Q.STATE[Q.STATE[l]] = l;
          b = Q.STATE;
          function _(q, N, Z) {
            q[N] && q[N](Z);
          }
          function S(q, N, Z) {
            q.textNode && A(q), _(q, N, Z);
          }
          function A(q) {
            q.textNode = F(q.opt, q.textNode), q.textNode && _(q, "ontext", q.textNode), q.textNode = "";
          }
          function F(q, N) {
            return q.trim && (N = N.trim()), q.normalize && (N = N.replace(/\s+/g, " ")), N;
          }
          function T(q, N) {
            return A(q), q.trackPosition && (N += `
Line: ` + q.line + `
Column: ` + q.column + `
Char: ` + q.c), N = new Error(N), q.error = N, _(q, "onerror", N), q;
          }
          function O(q) {
            return q.sawRoot && !q.closedRoot && U(q, "Unclosed root tag"), q.state !== b.BEGIN && q.state !== b.BEGIN_WHITESPACE && q.state !== b.TEXT && T(q, "Unexpected end"), A(q), q.c = "", q.closed = !0, _(q, "onend"), P.call(q, q.strict, q.opt), q;
          }
          function U(q, N) {
            if (typeof q != "object" || !(q instanceof P))
              throw new Error("bad call to strictFail");
            q.strict && T(q, N);
          }
          function G(q) {
            q.strict || (q.tagName = q.tagName[q.looseCase]());
            var N = q.tags[q.tags.length - 1] || q, Z = q.tag = { name: q.tagName, attributes: {} };
            q.opt.xmlns && (Z.ns = N.ns), q.attribList.length = 0;
          }
          function K(q, N) {
            var Z = q.indexOf(":"), E = Z < 0 ? ["", q] : q.split(":"), te = E[0], re = E[1];
            return N && q === "xmlns" && (te = "xmlns", re = ""), { prefix: te, local: re };
          }
          function W(q) {
            if (q.strict || (q.attribName = q.attribName[q.looseCase]()), q.attribList.indexOf(q.attribName) !== -1 || q.tag.attributes.hasOwnProperty(q.attribName)) {
              q.attribName = q.attribValue = "";
              return;
            }
            if (q.opt.xmlns) {
              var N = K(q.attribName, !0), Z = N.prefix, E = N.local;
              if (Z === "xmlns")
                if (E === "xml" && q.attribValue !== f)
                  U(
                    q,
                    "xml: prefix must be bound to " + f + `
Actual: ` + q.attribValue
                  );
                else if (E === "xmlns" && q.attribValue !== m)
                  U(
                    q,
                    "xmlns: prefix must be bound to " + m + `
Actual: ` + q.attribValue
                  );
                else {
                  var te = q.tag, re = q.tags[q.tags.length - 1] || q;
                  te.ns === re.ns && (te.ns = Object.create(re.ns)), te.ns[E] = q.attribValue;
                }
              q.attribList.push([q.attribName, q.attribValue]);
            } else
              q.tag.attributes[q.attribName] = q.attribValue, S(q, "onattribute", {
                name: q.attribName,
                value: q.attribValue
              });
            q.attribName = q.attribValue = "";
          }
          function z(q, N) {
            if (q.opt.xmlns) {
              var Z = q.tag, E = K(q.tagName);
              Z.prefix = E.prefix, Z.local = E.local, Z.uri = Z.ns[E.prefix] || "", Z.prefix && !Z.uri && (U(q, "Unbound namespace prefix: " + JSON.stringify(q.tagName)), Z.uri = E.prefix);
              var te = q.tags[q.tags.length - 1] || q;
              Z.ns && te.ns !== Z.ns && Object.keys(Z.ns).forEach(function(me) {
                S(q, "onopennamespace", {
                  prefix: me,
                  uri: Z.ns[me]
                });
              });
              for (var re = 0, ee = q.attribList.length; re < ee; re++) {
                var $ = q.attribList[re], k = $[0], H = $[1], ne = K(k, !0), ae = ne.prefix, he = ne.local, ue = ae === "" ? "" : Z.ns[ae] || "", fe = {
                  name: k,
                  value: H,
                  prefix: ae,
                  local: he,
                  uri: ue
                };
                ae && ae !== "xmlns" && !ue && (U(q, "Unbound namespace prefix: " + JSON.stringify(ae)), fe.uri = ae), q.tag.attributes[k] = fe, S(q, "onattribute", fe);
              }
              q.attribList.length = 0;
            }
            q.tag.isSelfClosing = !!N, q.sawRoot = !0, q.tags.push(q.tag), S(q, "onopentag", q.tag), N || (!q.noscript && q.tagName.toLowerCase() === "script" ? q.state = b.SCRIPT : q.state = b.TEXT, q.tag = null, q.tagName = ""), q.attribName = q.attribValue = "", q.attribList.length = 0;
          }
          function V(q) {
            if (!q.tagName) {
              U(q, "Weird empty close tag."), q.textNode += "</>", q.state = b.TEXT;
              return;
            }
            if (q.script) {
              if (q.tagName !== "script") {
                q.script += "</" + q.tagName + ">", q.tagName = "", q.state = b.SCRIPT;
                return;
              }
              S(q, "onscript", q.script), q.script = "";
            }
            var N = q.tags.length, Z = q.tagName;
            q.strict || (Z = Z[q.looseCase]());
            for (var E = Z; N--; ) {
              var te = q.tags[N];
              if (te.name !== E)
                U(q, "Unexpected close tag");
              else
                break;
            }
            if (N < 0) {
              U(q, "Unmatched closing tag: " + q.tagName), q.textNode += "</" + q.tagName + ">", q.state = b.TEXT;
              return;
            }
            q.tagName = Z;
            for (var re = q.tags.length; re-- > N; ) {
              var ee = q.tag = q.tags.pop();
              q.tagName = q.tag.name, S(q, "onclosetag", q.tagName);
              var $ = {};
              for (var k in ee.ns)
                $[k] = ee.ns[k];
              var H = q.tags[q.tags.length - 1] || q;
              q.opt.xmlns && ee.ns !== H.ns && Object.keys(ee.ns).forEach(function(ne) {
                var ae = ee.ns[ne];
                S(q, "onclosenamespace", { prefix: ne, uri: ae });
              });
            }
            N === 0 && (q.closedRoot = !0), q.tagName = q.attribValue = q.attribName = "", q.attribList.length = 0, q.state = b.TEXT;
          }
          function L(q) {
            var N = q.entity, Z = N.toLowerCase(), E, te = "";
            return q.ENTITIES[N] ? q.ENTITIES[N] : q.ENTITIES[Z] ? q.ENTITIES[Z] : (N = Z, N.charAt(0) === "#" && (N.charAt(1) === "x" ? (N = N.slice(2), E = parseInt(N, 16), te = E.toString(16)) : (N = N.slice(1), E = parseInt(N, 10), te = E.toString(10))), N = N.replace(/^0+/, ""), te.toLowerCase() !== N ? (U(q, "Invalid character entity"), "&" + q.entity + ";") : String.fromCodePoint(E));
          }
          function Y(q, N) {
            N === "<" ? (q.state = b.OPEN_WAKA, q.startTagPosition = q.position) : D(h, N) && (U(q, "Non-whitespace before first tag."), q.textNode = N, q.state = b.TEXT);
          }
          function J(q, N) {
            var Z = "";
            return N < q.length && (Z = q.charAt(N)), Z;
          }
          function ie(q) {
            var N = this;
            if (this.error)
              throw this.error;
            if (N.closed)
              return T(
                N,
                "Cannot write after close. Assign an onready handler."
              );
            if (q === null)
              return O(N);
            typeof q == "object" && (q = q.toString());
            for (var Z = 0, E = ""; E = J(q, Z++), N.c = E, !!E; )
              switch (N.trackPosition && (N.position++, E === `
` ? (N.line++, N.column = 0) : N.column++), N.state) {
                case b.BEGIN:
                  if (N.state = b.BEGIN_WHITESPACE, E === "\uFEFF")
                    continue;
                  Y(N, E);
                  continue;
                case b.BEGIN_WHITESPACE:
                  Y(N, E);
                  continue;
                case b.TEXT:
                  if (N.sawRoot && !N.closedRoot) {
                    for (var te = Z - 1; E && E !== "<" && E !== "&"; )
                      E = J(q, Z++), E && N.trackPosition && (N.position++, E === `
` ? (N.line++, N.column = 0) : N.column++);
                    N.textNode += q.substring(te, Z - 1);
                  }
                  E === "<" && !(N.sawRoot && N.closedRoot && !N.strict) ? (N.state = b.OPEN_WAKA, N.startTagPosition = N.position) : (D(h, E) && (!N.sawRoot || N.closedRoot) && U(N, "Text data outside of root node."), E === "&" ? N.state = b.TEXT_ENTITY : N.textNode += E);
                  continue;
                case b.SCRIPT:
                  E === "<" ? N.state = b.SCRIPT_ENDING : N.script += E;
                  continue;
                case b.SCRIPT_ENDING:
                  E === "/" ? N.state = b.CLOSE_TAG : (N.script += "<" + E, N.state = b.SCRIPT);
                  continue;
                case b.OPEN_WAKA:
                  if (E === "!")
                    N.state = b.SGML_DECL, N.sgmlDecl = "";
                  else if (!R(h, E))
                    if (R(p, E))
                      N.state = b.OPEN_TAG, N.tagName = E;
                    else if (E === "/")
                      N.state = b.CLOSE_TAG, N.tagName = "";
                    else if (E === "?")
                      N.state = b.PROC_INST, N.procInstName = N.procInstBody = "";
                    else {
                      if (U(N, "Unencoded <"), N.startTagPosition + 1 < N.position) {
                        var re = N.position - N.startTagPosition;
                        E = new Array(re).join(" ") + E;
                      }
                      N.textNode += "<" + E, N.state = b.TEXT;
                    }
                  continue;
                case b.SGML_DECL:
                  (N.sgmlDecl + E).toUpperCase() === o ? (S(N, "onopencdata"), N.state = b.CDATA, N.sgmlDecl = "", N.cdata = "") : N.sgmlDecl + E === "--" ? (N.state = b.COMMENT, N.comment = "", N.sgmlDecl = "") : (N.sgmlDecl + E).toUpperCase() === x ? (N.state = b.DOCTYPE, (N.doctype || N.sawRoot) && U(
                    N,
                    "Inappropriately located doctype declaration"
                  ), N.doctype = "", N.sgmlDecl = "") : E === ">" ? (S(N, "onsgmldeclaration", N.sgmlDecl), N.sgmlDecl = "", N.state = b.TEXT) : (R(c, E) && (N.state = b.SGML_DECL_QUOTED), N.sgmlDecl += E);
                  continue;
                case b.SGML_DECL_QUOTED:
                  E === N.q && (N.state = b.SGML_DECL, N.q = ""), N.sgmlDecl += E;
                  continue;
                case b.DOCTYPE:
                  E === ">" ? (N.state = b.TEXT, S(N, "ondoctype", N.doctype), N.doctype = !0) : (N.doctype += E, E === "[" ? N.state = b.DOCTYPE_DTD : R(c, E) && (N.state = b.DOCTYPE_QUOTED, N.q = E));
                  continue;
                case b.DOCTYPE_QUOTED:
                  N.doctype += E, E === N.q && (N.q = "", N.state = b.DOCTYPE);
                  continue;
                case b.DOCTYPE_DTD:
                  N.doctype += E, E === "]" ? N.state = b.DOCTYPE : R(c, E) && (N.state = b.DOCTYPE_DTD_QUOTED, N.q = E);
                  continue;
                case b.DOCTYPE_DTD_QUOTED:
                  N.doctype += E, E === N.q && (N.state = b.DOCTYPE_DTD, N.q = "");
                  continue;
                case b.COMMENT:
                  E === "-" ? N.state = b.COMMENT_ENDING : N.comment += E;
                  continue;
                case b.COMMENT_ENDING:
                  E === "-" ? (N.state = b.COMMENT_ENDED, N.comment = F(N.opt, N.comment), N.comment && S(N, "oncomment", N.comment), N.comment = "") : (N.comment += "-" + E, N.state = b.COMMENT);
                  continue;
                case b.COMMENT_ENDED:
                  E !== ">" ? (U(N, "Malformed comment"), N.comment += "--" + E, N.state = b.COMMENT) : N.state = b.TEXT;
                  continue;
                case b.CDATA:
                  E === "]" ? N.state = b.CDATA_ENDING : N.cdata += E;
                  continue;
                case b.CDATA_ENDING:
                  E === "]" ? N.state = b.CDATA_ENDING_2 : (N.cdata += "]" + E, N.state = b.CDATA);
                  continue;
                case b.CDATA_ENDING_2:
                  E === ">" ? (N.cdata && S(N, "oncdata", N.cdata), S(N, "onclosecdata"), N.cdata = "", N.state = b.TEXT) : E === "]" ? N.cdata += "]" : (N.cdata += "]]" + E, N.state = b.CDATA);
                  continue;
                case b.PROC_INST:
                  E === "?" ? N.state = b.PROC_INST_ENDING : R(h, E) ? N.state = b.PROC_INST_BODY : N.procInstName += E;
                  continue;
                case b.PROC_INST_BODY:
                  if (!N.procInstBody && R(h, E))
                    continue;
                  E === "?" ? N.state = b.PROC_INST_ENDING : N.procInstBody += E;
                  continue;
                case b.PROC_INST_ENDING:
                  E === ">" ? (S(N, "onprocessinginstruction", {
                    name: N.procInstName,
                    body: N.procInstBody
                  }), N.procInstName = N.procInstBody = "", N.state = b.TEXT) : (N.procInstBody += "?" + E, N.state = b.PROC_INST_BODY);
                  continue;
                case b.OPEN_TAG:
                  R(w, E) ? N.tagName += E : (G(N), E === ">" ? z(N) : E === "/" ? N.state = b.OPEN_TAG_SLASH : (D(h, E) && U(N, "Invalid character in tag name"), N.state = b.ATTRIB));
                  continue;
                case b.OPEN_TAG_SLASH:
                  E === ">" ? (z(N, !0), V(N)) : (U(N, "Forward-slash in opening tag not followed by >"), N.state = b.ATTRIB);
                  continue;
                case b.ATTRIB:
                  if (R(h, E))
                    continue;
                  E === ">" ? z(N) : E === "/" ? N.state = b.OPEN_TAG_SLASH : R(p, E) ? (N.attribName = E, N.attribValue = "", N.state = b.ATTRIB_NAME) : U(N, "Invalid attribute name");
                  continue;
                case b.ATTRIB_NAME:
                  E === "=" ? N.state = b.ATTRIB_VALUE : E === ">" ? (U(N, "Attribute without value"), N.attribValue = N.attribName, W(N), z(N)) : R(h, E) ? N.state = b.ATTRIB_NAME_SAW_WHITE : R(w, E) ? N.attribName += E : U(N, "Invalid attribute name");
                  continue;
                case b.ATTRIB_NAME_SAW_WHITE:
                  if (E === "=")
                    N.state = b.ATTRIB_VALUE;
                  else {
                    if (R(h, E))
                      continue;
                    U(N, "Attribute without value"), N.tag.attributes[N.attribName] = "", N.attribValue = "", S(N, "onattribute", {
                      name: N.attribName,
                      value: ""
                    }), N.attribName = "", E === ">" ? z(N) : R(p, E) ? (N.attribName = E, N.state = b.ATTRIB_NAME) : (U(N, "Invalid attribute name"), N.state = b.ATTRIB);
                  }
                  continue;
                case b.ATTRIB_VALUE:
                  if (R(h, E))
                    continue;
                  R(c, E) ? (N.q = E, N.state = b.ATTRIB_VALUE_QUOTED) : (U(N, "Unquoted attribute value"), N.state = b.ATTRIB_VALUE_UNQUOTED, N.attribValue = E);
                  continue;
                case b.ATTRIB_VALUE_QUOTED:
                  if (E !== N.q) {
                    E === "&" ? N.state = b.ATTRIB_VALUE_ENTITY_Q : N.attribValue += E;
                    continue;
                  }
                  W(N), N.q = "", N.state = b.ATTRIB_VALUE_CLOSED;
                  continue;
                case b.ATTRIB_VALUE_CLOSED:
                  R(h, E) ? N.state = b.ATTRIB : E === ">" ? z(N) : E === "/" ? N.state = b.OPEN_TAG_SLASH : R(p, E) ? (U(N, "No whitespace between attributes"), N.attribName = E, N.attribValue = "", N.state = b.ATTRIB_NAME) : U(N, "Invalid attribute name");
                  continue;
                case b.ATTRIB_VALUE_UNQUOTED:
                  if (D(n, E)) {
                    E === "&" ? N.state = b.ATTRIB_VALUE_ENTITY_U : N.attribValue += E;
                    continue;
                  }
                  W(N), E === ">" ? z(N) : N.state = b.ATTRIB;
                  continue;
                case b.CLOSE_TAG:
                  if (N.tagName)
                    E === ">" ? V(N) : R(w, E) ? N.tagName += E : N.script ? (N.script += "</" + N.tagName, N.tagName = "", N.state = b.SCRIPT) : (D(h, E) && U(N, "Invalid tagname in closing tag"), N.state = b.CLOSE_TAG_SAW_WHITE);
                  else {
                    if (R(h, E))
                      continue;
                    D(p, E) ? N.script ? (N.script += "</" + E, N.state = b.SCRIPT) : U(N, "Invalid tagname in closing tag.") : N.tagName = E;
                  }
                  continue;
                case b.CLOSE_TAG_SAW_WHITE:
                  if (R(h, E))
                    continue;
                  E === ">" ? V(N) : U(N, "Invalid characters in closing tag");
                  continue;
                case b.TEXT_ENTITY:
                case b.ATTRIB_VALUE_ENTITY_Q:
                case b.ATTRIB_VALUE_ENTITY_U:
                  var ee, $;
                  switch (N.state) {
                    case b.TEXT_ENTITY:
                      ee = b.TEXT, $ = "textNode";
                      break;
                    case b.ATTRIB_VALUE_ENTITY_Q:
                      ee = b.ATTRIB_VALUE_QUOTED, $ = "attribValue";
                      break;
                    case b.ATTRIB_VALUE_ENTITY_U:
                      ee = b.ATTRIB_VALUE_UNQUOTED, $ = "attribValue";
                      break;
                  }
                  E === ";" ? (N[$] += L(N), N.entity = "", N.state = ee) : R(N.entity.length ? M : X, E) ? N.entity += E : (U(N, "Invalid character in entity name"), N[$] += "&" + N.entity + E, N.entity = "", N.state = ee);
                  continue;
                default:
                  throw new Error(N, "Unknown state: " + N.state);
              }
            return N.position >= N.bufferCheckPosition && t(N), N;
          }
          /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
          String.fromCodePoint || function() {
            var q = String.fromCharCode, N = Math.floor, Z = function() {
              var E = 16384, te = [], re, ee, $ = -1, k = arguments.length;
              if (!k)
                return "";
              for (var H = ""; ++$ < k; ) {
                var ne = Number(arguments[$]);
                if (!isFinite(ne) || // `NaN`, `+Infinity`, or `-Infinity`
                ne < 0 || // not a valid Unicode code point
                ne > 1114111 || // not a valid Unicode code point
                N(ne) !== ne)
                  throw RangeError("Invalid code point: " + ne);
                ne <= 65535 ? te.push(ne) : (ne -= 65536, re = (ne >> 10) + 55296, ee = ne % 1024 + 56320, te.push(re, ee)), ($ + 1 === k || te.length > E) && (H += q.apply(null, te), te.length = 0);
              }
              return H;
            };
            Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
              value: Z,
              configurable: !0,
              writable: !0
            }) : String.fromCodePoint = Z;
          }();
        })(typeof oe > "u" ? this.sax = {} : oe);
      }).call(this, le("buffer").Buffer);
    }, { buffer: 78, stream: 115, string_decoder: 116 }], 115: [function(le, de, oe) {
      de.exports = u;
      var se = le("events").EventEmitter, Q = le("inherits");
      Q(u, se), u.Readable = le("readable-stream/readable.js"), u.Writable = le("readable-stream/writable.js"), u.Duplex = le("readable-stream/duplex.js"), u.Transform = le("readable-stream/transform.js"), u.PassThrough = le("readable-stream/passthrough.js"), u.Stream = u;
      function u() {
        se.call(this);
      }
      u.prototype.pipe = function(P, t) {
        var i = this;
        function v(d) {
          P.writable && P.write(d) === !1 && i.pause && i.pause();
        }
        i.on("data", v);
        function a() {
          i.readable && i.resume && i.resume();
        }
        P.on("drain", a), !P._isStdio && (!t || t.end !== !1) && (i.on("end", y), i.on("close", r));
        var e = !1;
        function y() {
          e || (e = !0, P.end());
        }
        function r() {
          e || (e = !0, typeof P.destroy == "function" && P.destroy());
        }
        function h(d) {
          if (g(), se.listenerCount(this, "error") === 0)
            throw d;
        }
        i.on("error", h), P.on("error", h);
        function g() {
          i.removeListener("data", v), P.removeListener("drain", a), i.removeListener("end", y), i.removeListener("close", r), i.removeListener("error", h), P.removeListener("error", h), i.removeListener("end", g), i.removeListener("close", g), P.removeListener("close", g);
        }
        return i.on("end", g), i.on("close", g), P.on("close", g), P.emit("pipe", i), P;
      };
    }, { events: 82, inherits: 84, "readable-stream/duplex.js": 103, "readable-stream/passthrough.js": 110, "readable-stream/readable.js": 111, "readable-stream/transform.js": 112, "readable-stream/writable.js": 113 }], 116: [function(le, de, oe) {
      var se = le("buffer").Buffer, Q = se.isEncoding || function(a) {
        switch (a && a.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return !0;
          default:
            return !1;
        }
      };
      function u(a) {
        if (a && !Q(a))
          throw new Error("Unknown encoding: " + a);
      }
      var P = oe.StringDecoder = function(a) {
        switch (this.encoding = (a || "utf8").toLowerCase().replace(/[-_]/, ""), u(a), this.encoding) {
          case "utf8":
            this.surrogateSize = 3;
            break;
          case "ucs2":
          case "utf16le":
            this.surrogateSize = 2, this.detectIncompleteChar = i;
            break;
          case "base64":
            this.surrogateSize = 3, this.detectIncompleteChar = v;
            break;
          default:
            this.write = t;
            return;
        }
        this.charBuffer = new se(6), this.charReceived = 0, this.charLength = 0;
      };
      P.prototype.write = function(a) {
        for (var e = ""; this.charLength; ) {
          var y = a.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : a.length;
          if (a.copy(this.charBuffer, this.charReceived, 0, y), this.charReceived += y, this.charReceived < this.charLength)
            return "";
          a = a.slice(y, a.length), e = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
          var h = e.charCodeAt(e.length - 1);
          if (h >= 55296 && h <= 56319) {
            this.charLength += this.surrogateSize, e = "";
            continue;
          }
          if (this.charReceived = this.charLength = 0, a.length === 0)
            return e;
          break;
        }
        this.detectIncompleteChar(a);
        var r = a.length;
        this.charLength && (a.copy(this.charBuffer, 0, a.length - this.charReceived, r), r -= this.charReceived), e += a.toString(this.encoding, 0, r);
        var r = e.length - 1, h = e.charCodeAt(r);
        if (h >= 55296 && h <= 56319) {
          var g = this.surrogateSize;
          return this.charLength += g, this.charReceived += g, this.charBuffer.copy(this.charBuffer, g, 0, g), a.copy(this.charBuffer, 0, 0, g), e.substring(0, r);
        }
        return e;
      }, P.prototype.detectIncompleteChar = function(a) {
        for (var e = a.length >= 3 ? 3 : a.length; e > 0; e--) {
          var y = a[a.length - e];
          if (e == 1 && y >> 5 == 6) {
            this.charLength = 2;
            break;
          }
          if (e <= 2 && y >> 4 == 14) {
            this.charLength = 3;
            break;
          }
          if (e <= 3 && y >> 3 == 30) {
            this.charLength = 4;
            break;
          }
        }
        this.charReceived = e;
      }, P.prototype.end = function(a) {
        var e = "";
        if (a && a.length && (e = this.write(a)), this.charReceived) {
          var y = this.charReceived, r = this.charBuffer, h = this.encoding;
          e += r.slice(0, y).toString(h);
        }
        return e;
      };
      function t(a) {
        return a.toString(this.encoding);
      }
      function i(a) {
        this.charReceived = a.length % 2, this.charLength = this.charReceived ? 2 : 0;
      }
      function v(a) {
        this.charReceived = a.length % 3, this.charLength = this.charReceived ? 3 : 0;
      }
    }, { buffer: 78 }], 117: [function(le, de, oe) {
      (function(se) {
        (function(Q, u) {
          typeof oe == "object" && typeof de < "u" ? de.exports = u() : (Q = typeof globalThis < "u" ? globalThis : Q || self, function() {
            var P = Q._, t = Q._ = u();
            t.noConflict = function() {
              return Q._ = P, t;
            };
          }());
        })(this, function() {
          var Q = "1.13.1", u = typeof self == "object" && self.self === self && self || typeof se == "object" && se.global === se && se || Function("return this")() || {}, P = Array.prototype, t = Object.prototype, i = typeof Symbol < "u" ? Symbol.prototype : null, v = P.push, a = P.slice, e = t.toString, y = t.hasOwnProperty, r = typeof ArrayBuffer < "u", h = typeof DataView < "u", g = Array.isArray, d = Object.keys, c = Object.create, n = r && ArrayBuffer.isView, o = isNaN, x = isFinite, f = !{ toString: null }.propertyIsEnumerable("toString"), m = [
            "valueOf",
            "isPrototypeOf",
            "toString",
            "propertyIsEnumerable",
            "hasOwnProperty",
            "toLocaleString"
          ], C = Math.pow(2, 53) - 1;
          function p(pe, Ce) {
            return Ce = Ce == null ? pe.length - 1 : +Ce, function() {
              for (var Me = Math.max(arguments.length - Ce, 0), Be = Array(Me), qe = 0; qe < Me; qe++)
                Be[qe] = arguments[qe + Ce];
              switch (Ce) {
                case 0:
                  return pe.call(this, Be);
                case 1:
                  return pe.call(this, arguments[0], Be);
                case 2:
                  return pe.call(this, arguments[0], arguments[1], Be);
              }
              var He = Array(Ce + 1);
              for (qe = 0; qe < Ce; qe++)
                He[qe] = arguments[qe];
              return He[Ce] = Be, pe.apply(this, He);
            };
          }
          function w(pe) {
            var Ce = typeof pe;
            return Ce === "function" || Ce === "object" && !!pe;
          }
          function X(pe) {
            return pe === null;
          }
          function M(pe) {
            return pe === void 0;
          }
          function j(pe) {
            return pe === !0 || pe === !1 || e.call(pe) === "[object Boolean]";
          }
          function B(pe) {
            return !!(pe && pe.nodeType === 1);
          }
          function R(pe) {
            var Ce = "[object " + pe + "]";
            return function(Me) {
              return e.call(Me) === Ce;
            };
          }
          var D = R("String"), b = R("Number"), l = R("Date"), _ = R("RegExp"), S = R("Error"), A = R("Symbol"), F = R("ArrayBuffer"), T = R("Function"), O = u.document && u.document.childNodes;
          typeof /./ != "function" && typeof Int8Array != "object" && typeof O != "function" && (T = function(pe) {
            return typeof pe == "function" || !1;
          });
          var U = T, G = R("Object"), K = h && G(new DataView(new ArrayBuffer(8))), W = typeof Map < "u" && G(/* @__PURE__ */ new Map()), z = R("DataView");
          function V(pe) {
            return pe != null && U(pe.getInt8) && F(pe.buffer);
          }
          var L = K ? V : z, Y = g || R("Array");
          function J(pe, Ce) {
            return pe != null && y.call(pe, Ce);
          }
          var ie = R("Arguments");
          (function() {
            ie(arguments) || (ie = function(pe) {
              return J(pe, "callee");
            });
          })();
          var q = ie;
          function N(pe) {
            return !A(pe) && x(pe) && !isNaN(parseFloat(pe));
          }
          function Z(pe) {
            return b(pe) && o(pe);
          }
          function E(pe) {
            return function() {
              return pe;
            };
          }
          function te(pe) {
            return function(Ce) {
              var Me = pe(Ce);
              return typeof Me == "number" && Me >= 0 && Me <= C;
            };
          }
          function re(pe) {
            return function(Ce) {
              return Ce == null ? void 0 : Ce[pe];
            };
          }
          var ee = re("byteLength"), $ = te(ee), k = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
          function H(pe) {
            return n ? n(pe) && !L(pe) : $(pe) && k.test(e.call(pe));
          }
          var ne = r ? H : E(!1), ae = re("length");
          function he(pe) {
            for (var Ce = {}, Me = pe.length, Be = 0; Be < Me; ++Be)
              Ce[pe[Be]] = !0;
            return {
              contains: function(qe) {
                return Ce[qe];
              },
              push: function(qe) {
                return Ce[qe] = !0, pe.push(qe);
              }
            };
          }
          function ue(pe, Ce) {
            Ce = he(Ce);
            var Me = m.length, Be = pe.constructor, qe = U(Be) && Be.prototype || t, He = "constructor";
            for (J(pe, He) && !Ce.contains(He) && Ce.push(He); Me--; )
              He = m[Me], He in pe && pe[He] !== qe[He] && !Ce.contains(He) && Ce.push(He);
          }
          function fe(pe) {
            if (!w(pe))
              return [];
            if (d)
              return d(pe);
            var Ce = [];
            for (var Me in pe)
              J(pe, Me) && Ce.push(Me);
            return f && ue(pe, Ce), Ce;
          }
          function me(pe) {
            if (pe == null)
              return !0;
            var Ce = ae(pe);
            return typeof Ce == "number" && (Y(pe) || D(pe) || q(pe)) ? Ce === 0 : ae(fe(pe)) === 0;
          }
          function Fe(pe, Ce) {
            var Me = fe(Ce), Be = Me.length;
            if (pe == null)
              return !Be;
            for (var qe = Object(pe), He = 0; He < Be; He++) {
              var gt = Me[He];
              if (Ce[gt] !== qe[gt] || !(gt in qe))
                return !1;
            }
            return !0;
          }
          function we(pe) {
            if (pe instanceof we)
              return pe;
            if (!(this instanceof we))
              return new we(pe);
            this._wrapped = pe;
          }
          we.VERSION = Q, we.prototype.value = function() {
            return this._wrapped;
          }, we.prototype.valueOf = we.prototype.toJSON = we.prototype.value, we.prototype.toString = function() {
            return String(this._wrapped);
          };
          function Ae(pe) {
            return new Uint8Array(
              pe.buffer || pe,
              pe.byteOffset || 0,
              ee(pe)
            );
          }
          var De = "[object DataView]";
          function xe(pe, Ce, Me, Be) {
            if (pe === Ce)
              return pe !== 0 || 1 / pe === 1 / Ce;
            if (pe == null || Ce == null)
              return !1;
            if (pe !== pe)
              return Ce !== Ce;
            var qe = typeof pe;
            return qe !== "function" && qe !== "object" && typeof Ce != "object" ? !1 : Te(pe, Ce, Me, Be);
          }
          function Te(pe, Ce, Me, Be) {
            pe instanceof we && (pe = pe._wrapped), Ce instanceof we && (Ce = Ce._wrapped);
            var qe = e.call(pe);
            if (qe !== e.call(Ce))
              return !1;
            if (K && qe == "[object Object]" && L(pe)) {
              if (!L(Ce))
                return !1;
              qe = De;
            }
            switch (qe) {
              case "[object RegExp]":
              case "[object String]":
                return "" + pe == "" + Ce;
              case "[object Number]":
                return +pe != +pe ? +Ce != +Ce : +pe == 0 ? 1 / +pe === 1 / Ce : +pe == +Ce;
              case "[object Date]":
              case "[object Boolean]":
                return +pe == +Ce;
              case "[object Symbol]":
                return i.valueOf.call(pe) === i.valueOf.call(Ce);
              case "[object ArrayBuffer]":
              case De:
                return Te(Ae(pe), Ae(Ce), Me, Be);
            }
            var He = qe === "[object Array]";
            if (!He && ne(pe)) {
              var gt = ee(pe);
              if (gt !== ee(Ce))
                return !1;
              if (pe.buffer === Ce.buffer && pe.byteOffset === Ce.byteOffset)
                return !0;
              He = !0;
            }
            if (!He) {
              if (typeof pe != "object" || typeof Ce != "object")
                return !1;
              var kt = pe.constructor, qt = Ce.constructor;
              if (kt !== qt && !(U(kt) && kt instanceof kt && U(qt) && qt instanceof qt) && "constructor" in pe && "constructor" in Ce)
                return !1;
            }
            Me = Me || [], Be = Be || [];
            for (var Gt = Me.length; Gt--; )
              if (Me[Gt] === pe)
                return Be[Gt] === Ce;
            if (Me.push(pe), Be.push(Ce), He) {
              if (Gt = pe.length, Gt !== Ce.length)
                return !1;
              for (; Gt--; )
                if (!xe(pe[Gt], Ce[Gt], Me, Be))
                  return !1;
            } else {
              var cn = fe(pe), un;
              if (Gt = cn.length, fe(Ce).length !== Gt)
                return !1;
              for (; Gt--; )
                if (un = cn[Gt], !(J(Ce, un) && xe(pe[un], Ce[un], Me, Be)))
                  return !1;
            }
            return Me.pop(), Be.pop(), !0;
          }
          function ve(pe, Ce) {
            return xe(pe, Ce);
          }
          function Se(pe) {
            if (!w(pe))
              return [];
            var Ce = [];
            for (var Me in pe)
              Ce.push(Me);
            return f && ue(pe, Ce), Ce;
          }
          function be(pe) {
            var Ce = ae(pe);
            return function(Me) {
              if (Me == null)
                return !1;
              var Be = Se(Me);
              if (ae(Be))
                return !1;
              for (var qe = 0; qe < Ce; qe++)
                if (!U(Me[pe[qe]]))
                  return !1;
              return pe !== _e || !U(Me[Le]);
            };
          }
          var Le = "forEach", ze = "has", nt = ["clear", "delete"], Ue = ["get", ze, "set"], Oe = nt.concat(Le, Ue), _e = nt.concat(Ue), at = ["add"].concat(nt, Le, ze), Je = W ? be(Oe) : R("Map"), ot = W ? be(_e) : R("WeakMap"), mt = W ? be(at) : R("Set"), Ze = R("WeakSet");
          function pt(pe) {
            for (var Ce = fe(pe), Me = Ce.length, Be = Array(Me), qe = 0; qe < Me; qe++)
              Be[qe] = pe[Ce[qe]];
            return Be;
          }
          function Ft(pe) {
            for (var Ce = fe(pe), Me = Ce.length, Be = Array(Me), qe = 0; qe < Me; qe++)
              Be[qe] = [Ce[qe], pe[Ce[qe]]];
            return Be;
          }
          function $e(pe) {
            for (var Ce = {}, Me = fe(pe), Be = 0, qe = Me.length; Be < qe; Be++)
              Ce[pe[Me[Be]]] = Me[Be];
            return Ce;
          }
          function St(pe) {
            var Ce = [];
            for (var Me in pe)
              U(pe[Me]) && Ce.push(Me);
            return Ce.sort();
          }
          function xt(pe, Ce) {
            return function(Me) {
              var Be = arguments.length;
              if (Ce && (Me = Object(Me)), Be < 2 || Me == null)
                return Me;
              for (var qe = 1; qe < Be; qe++)
                for (var He = arguments[qe], gt = pe(He), kt = gt.length, qt = 0; qt < kt; qt++) {
                  var Gt = gt[qt];
                  (!Ce || Me[Gt] === void 0) && (Me[Gt] = He[Gt]);
                }
              return Me;
            };
          }
          var Ie = xt(Se), Ve = xt(fe), st = xt(Se, !0);
          function ct() {
            return function() {
            };
          }
          function Rt(pe) {
            if (!w(pe))
              return {};
            if (c)
              return c(pe);
            var Ce = ct();
            Ce.prototype = pe;
            var Me = new Ce();
            return Ce.prototype = null, Me;
          }
          function Lt(pe, Ce) {
            var Me = Rt(pe);
            return Ce && Ve(Me, Ce), Me;
          }
          function Ge(pe) {
            return w(pe) ? Y(pe) ? pe.slice() : Ie({}, pe) : pe;
          }
          function Ne(pe, Ce) {
            return Ce(pe), pe;
          }
          function rt(pe) {
            return Y(pe) ? pe : [pe];
          }
          we.toPath = rt;
          function tt(pe) {
            return we.toPath(pe);
          }
          function dt(pe, Ce) {
            for (var Me = Ce.length, Be = 0; Be < Me; Be++) {
              if (pe == null)
                return;
              pe = pe[Ce[Be]];
            }
            return Me ? pe : void 0;
          }
          function Ct(pe, Ce, Me) {
            var Be = dt(pe, tt(Ce));
            return M(Be) ? Me : Be;
          }
          function bt(pe, Ce) {
            Ce = tt(Ce);
            for (var Me = Ce.length, Be = 0; Be < Me; Be++) {
              var qe = Ce[Be];
              if (!J(pe, qe))
                return !1;
              pe = pe[qe];
            }
            return !!Me;
          }
          function ht(pe) {
            return pe;
          }
          function vt(pe) {
            return pe = Ve({}, pe), function(Ce) {
              return Fe(Ce, pe);
            };
          }
          function _t(pe) {
            return pe = tt(pe), function(Ce) {
              return dt(Ce, pe);
            };
          }
          function Nt(pe, Ce, Me) {
            if (Ce === void 0)
              return pe;
            switch (Me ?? 3) {
              case 1:
                return function(Be) {
                  return pe.call(Ce, Be);
                };
              case 3:
                return function(Be, qe, He) {
                  return pe.call(Ce, Be, qe, He);
                };
              case 4:
                return function(Be, qe, He, gt) {
                  return pe.call(Ce, Be, qe, He, gt);
                };
            }
            return function() {
              return pe.apply(Ce, arguments);
            };
          }
          function Mt(pe, Ce, Me) {
            return pe == null ? ht : U(pe) ? Nt(pe, Ce, Me) : w(pe) && !Y(pe) ? vt(pe) : _t(pe);
          }
          function Et(pe, Ce) {
            return Mt(pe, Ce, 1 / 0);
          }
          we.iteratee = Et;
          function Re(pe, Ce, Me) {
            return we.iteratee !== Et ? we.iteratee(pe, Ce) : Mt(pe, Ce, Me);
          }
          function We(pe, Ce, Me) {
            Ce = Re(Ce, Me);
            for (var Be = fe(pe), qe = Be.length, He = {}, gt = 0; gt < qe; gt++) {
              var kt = Be[gt];
              He[kt] = Ce(pe[kt], kt, pe);
            }
            return He;
          }
          function it() {
          }
          function et(pe) {
            return pe == null ? it : function(Ce) {
              return Ct(pe, Ce);
            };
          }
          function At(pe, Ce, Me) {
            var Be = Array(Math.max(0, pe));
            Ce = Nt(Ce, Me, 1);
            for (var qe = 0; qe < pe; qe++)
              Be[qe] = Ce(qe);
            return Be;
          }
          function It(pe, Ce) {
            return Ce == null && (Ce = pe, pe = 0), pe + Math.floor(Math.random() * (Ce - pe + 1));
          }
          var Vt = Date.now || function() {
            return new Date().getTime();
          };
          function Ut(pe) {
            var Ce = function(He) {
              return pe[He];
            }, Me = "(?:" + fe(pe).join("|") + ")", Be = RegExp(Me), qe = RegExp(Me, "g");
            return function(He) {
              return He = He == null ? "" : "" + He, Be.test(He) ? He.replace(qe, Ce) : He;
            };
          }
          var Wt = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#x27;",
            "`": "&#x60;"
          }, Kt = Ut(Wt), rn = $e(Wt), ln = Ut(rn), Cn = we.templateSettings = {
            evaluate: /<%([\s\S]+?)%>/g,
            interpolate: /<%=([\s\S]+?)%>/g,
            escape: /<%-([\s\S]+?)%>/g
          }, fn = /(.)^/, Fn = {
            "'": "'",
            "\\": "\\",
            "\r": "r",
            "\n": "n",
            "\u2028": "u2028",
            "\u2029": "u2029"
          }, yn = /\\|'|\r|\n|\u2028|\u2029/g;
          function Dn(pe) {
            return "\\" + Fn[pe];
          }
          var En = /^\s*(\w|\$)+\s*$/;
          function Bn(pe, Ce, Me) {
            !Ce && Me && (Ce = Me), Ce = st({}, Ce, we.templateSettings);
            var Be = RegExp([
              (Ce.escape || fn).source,
              (Ce.interpolate || fn).source,
              (Ce.evaluate || fn).source
            ].join("|") + "|$", "g"), qe = 0, He = "__p+='";
            pe.replace(Be, function(Gt, cn, un, Ii, Pi) {
              return He += pe.slice(qe, Pi).replace(yn, Dn), qe = Pi + Gt.length, cn ? He += `'+
((__t=(` + cn + `))==null?'':_.escape(__t))+
'` : un ? He += `'+
((__t=(` + un + `))==null?'':__t)+
'` : Ii && (He += `';
` + Ii + `
__p+='`), Gt;
            }), He += `';
`;
            var gt = Ce.variable;
            if (gt) {
              if (!En.test(gt))
                throw new Error(
                  "variable is not a bare identifier: " + gt
                );
            } else
              He = `with(obj||{}){
` + He + `}
`, gt = "obj";
            He = `var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
` + He + `return __p;
`;
            var kt;
            try {
              kt = new Function(gt, "_", He);
            } catch (Gt) {
              throw Gt.source = He, Gt;
            }
            var qt = function(Gt) {
              return kt.call(this, Gt, we);
            };
            return qt.source = "function(" + gt + `){
` + He + "}", qt;
          }
          function Ln(pe, Ce, Me) {
            Ce = tt(Ce);
            var Be = Ce.length;
            if (!Be)
              return U(Me) ? Me.call(pe) : Me;
            for (var qe = 0; qe < Be; qe++) {
              var He = pe == null ? void 0 : pe[Ce[qe]];
              He === void 0 && (He = Me, qe = Be), pe = U(He) ? He.call(pe) : He;
            }
            return pe;
          }
          var vn = 0;
          function kn(pe) {
            var Ce = ++vn + "";
            return pe ? pe + Ce : Ce;
          }
          function On(pe) {
            var Ce = we(pe);
            return Ce._chain = !0, Ce;
          }
          function mn(pe, Ce, Me, Be, qe) {
            if (!(Be instanceof Ce))
              return pe.apply(Me, qe);
            var He = Rt(pe.prototype), gt = pe.apply(He, qe);
            return w(gt) ? gt : He;
          }
          var hn = p(function(pe, Ce) {
            var Me = hn.placeholder, Be = function() {
              for (var qe = 0, He = Ce.length, gt = Array(He), kt = 0; kt < He; kt++)
                gt[kt] = Ce[kt] === Me ? arguments[qe++] : Ce[kt];
              for (; qe < arguments.length; )
                gt.push(arguments[qe++]);
              return mn(pe, Be, this, this, gt);
            };
            return Be;
          });
          hn.placeholder = we;
          var gn = p(function(pe, Ce, Me) {
            if (!U(pe))
              throw new TypeError("Bind must be called on a function");
            var Be = p(function(qe) {
              return mn(pe, Be, Ce, this, Me.concat(qe));
            });
            return Be;
          }), an = te(ae);
          function dn(pe, Ce, Me, Be) {
            if (Be = Be || [], !Ce && Ce !== 0)
              Ce = 1 / 0;
            else if (Ce <= 0)
              return Be.concat(pe);
            for (var qe = Be.length, He = 0, gt = ae(pe); He < gt; He++) {
              var kt = pe[He];
              if (an(kt) && (Y(kt) || q(kt)))
                if (Ce > 1)
                  dn(kt, Ce - 1, Me, Be), qe = Be.length;
                else
                  for (var qt = 0, Gt = kt.length; qt < Gt; )
                    Be[qe++] = kt[qt++];
              else
                Me || (Be[qe++] = kt);
            }
            return Be;
          }
          var Tn = p(function(pe, Ce) {
            Ce = dn(Ce, !1, !1);
            var Me = Ce.length;
            if (Me < 1)
              throw new Error("bindAll must be passed function names");
            for (; Me--; ) {
              var Be = Ce[Me];
              pe[Be] = gn(pe[Be], pe);
            }
            return pe;
          });
          function In(pe, Ce) {
            var Me = function(Be) {
              var qe = Me.cache, He = "" + (Ce ? Ce.apply(this, arguments) : Be);
              return J(qe, He) || (qe[He] = pe.apply(this, arguments)), qe[He];
            };
            return Me.cache = {}, Me;
          }
          var wn = p(function(pe, Ce, Me) {
            return setTimeout(function() {
              return pe.apply(null, Me);
            }, Ce);
          }), Nn = hn(wn, we, 1);
          function Pn(pe, Ce, Me) {
            var Be, qe, He, gt, kt = 0;
            Me || (Me = {});
            var qt = function() {
              kt = Me.leading === !1 ? 0 : Vt(), Be = null, gt = pe.apply(qe, He), Be || (qe = He = null);
            }, Gt = function() {
              var cn = Vt();
              !kt && Me.leading === !1 && (kt = cn);
              var un = Ce - (cn - kt);
              return qe = this, He = arguments, un <= 0 || un > Ce ? (Be && (clearTimeout(Be), Be = null), kt = cn, gt = pe.apply(qe, He), Be || (qe = He = null)) : !Be && Me.trailing !== !1 && (Be = setTimeout(qt, un)), gt;
            };
            return Gt.cancel = function() {
              clearTimeout(Be), kt = 0, Be = qe = He = null;
            }, Gt;
          }
          function Rn(pe, Ce, Me) {
            var Be, qe, He, gt, kt, qt = function() {
              var cn = Vt() - qe;
              Ce > cn ? Be = setTimeout(qt, Ce - cn) : (Be = null, Me || (gt = pe.apply(kt, He)), Be || (He = kt = null));
            }, Gt = p(function(cn) {
              return kt = this, He = cn, qe = Vt(), Be || (Be = setTimeout(qt, Ce), Me && (gt = pe.apply(kt, He))), gt;
            });
            return Gt.cancel = function() {
              clearTimeout(Be), Be = He = kt = null;
            }, Gt;
          }
          function Un(pe, Ce) {
            return hn(Ce, pe);
          }
          function _n(pe) {
            return function() {
              return !pe.apply(this, arguments);
            };
          }
          function An() {
            var pe = arguments, Ce = pe.length - 1;
            return function() {
              for (var Me = Ce, Be = pe[Ce].apply(this, arguments); Me--; )
                Be = pe[Me].call(this, Be);
              return Be;
            };
          }
          function Mn(pe, Ce) {
            return function() {
              if (--pe < 1)
                return Ce.apply(this, arguments);
            };
          }
          function xn(pe, Ce) {
            var Me;
            return function() {
              return --pe > 0 && (Me = Ce.apply(this, arguments)), pe <= 1 && (Ce = null), Me;
            };
          }
          var jn = hn(xn, 2);
          function bn(pe, Ce, Me) {
            Ce = Re(Ce, Me);
            for (var Be = fe(pe), qe, He = 0, gt = Be.length; He < gt; He++)
              if (qe = Be[He], Ce(pe[qe], qe, pe))
                return qe;
          }
          function Xe(pe) {
            return function(Ce, Me, Be) {
              Me = Re(Me, Be);
              for (var qe = ae(Ce), He = pe > 0 ? 0 : qe - 1; He >= 0 && He < qe; He += pe)
                if (Me(Ce[He], He, Ce))
                  return He;
              return -1;
            };
          }
          var I = Xe(1), ce = Xe(-1);
          function je(pe, Ce, Me, Be) {
            Me = Re(Me, Be, 1);
            for (var qe = Me(Ce), He = 0, gt = ae(pe); He < gt; ) {
              var kt = Math.floor((He + gt) / 2);
              Me(pe[kt]) < qe ? He = kt + 1 : gt = kt;
            }
            return He;
          }
          function Ke(pe, Ce, Me) {
            return function(Be, qe, He) {
              var gt = 0, kt = ae(Be);
              if (typeof He == "number")
                pe > 0 ? gt = He >= 0 ? He : Math.max(He + kt, gt) : kt = He >= 0 ? Math.min(He + 1, kt) : He + kt + 1;
              else if (Me && He && kt)
                return He = Me(Be, qe), Be[He] === qe ? He : -1;
              if (qe !== qe)
                return He = Ce(a.call(Be, gt, kt), Z), He >= 0 ? He + gt : -1;
              for (He = pe > 0 ? gt : kt - 1; He >= 0 && He < kt; He += pe)
                if (Be[He] === qe)
                  return He;
              return -1;
            };
          }
          var ut = Ke(1, I, je), Ot = Ke(-1, ce);
          function Dt(pe, Ce, Me) {
            var Be = an(pe) ? I : bn, qe = Be(pe, Ce, Me);
            if (qe !== void 0 && qe !== -1)
              return pe[qe];
          }
          function Pt(pe, Ce) {
            return Dt(pe, vt(Ce));
          }
          function jt(pe, Ce, Me) {
            Ce = Nt(Ce, Me);
            var Be, qe;
            if (an(pe))
              for (Be = 0, qe = pe.length; Be < qe; Be++)
                Ce(pe[Be], Be, pe);
            else {
              var He = fe(pe);
              for (Be = 0, qe = He.length; Be < qe; Be++)
                Ce(pe[He[Be]], He[Be], pe);
            }
            return pe;
          }
          function Xt(pe, Ce, Me) {
            Ce = Re(Ce, Me);
            for (var Be = !an(pe) && fe(pe), qe = (Be || pe).length, He = Array(qe), gt = 0; gt < qe; gt++) {
              var kt = Be ? Be[gt] : gt;
              He[gt] = Ce(pe[kt], kt, pe);
            }
            return He;
          }
          function Zt(pe) {
            var Ce = function(Me, Be, qe, He) {
              var gt = !an(Me) && fe(Me), kt = (gt || Me).length, qt = pe > 0 ? 0 : kt - 1;
              for (He || (qe = Me[gt ? gt[qt] : qt], qt += pe); qt >= 0 && qt < kt; qt += pe) {
                var Gt = gt ? gt[qt] : qt;
                qe = Be(qe, Me[Gt], Gt, Me);
              }
              return qe;
            };
            return function(Me, Be, qe, He) {
              var gt = arguments.length >= 3;
              return Ce(Me, Nt(Be, He, 4), qe, gt);
            };
          }
          var Yt = Zt(1), en = Zt(-1);
          function ye(pe, Ce, Me) {
            var Be = [];
            return Ce = Re(Ce, Me), jt(pe, function(qe, He, gt) {
              Ce(qe, He, gt) && Be.push(qe);
            }), Be;
          }
          function Pe(pe, Ce, Me) {
            return ye(pe, _n(Re(Ce)), Me);
          }
          function Qe(pe, Ce, Me) {
            Ce = Re(Ce, Me);
            for (var Be = !an(pe) && fe(pe), qe = (Be || pe).length, He = 0; He < qe; He++) {
              var gt = Be ? Be[He] : He;
              if (!Ce(pe[gt], gt, pe))
                return !1;
            }
            return !0;
          }
          function Ye(pe, Ce, Me) {
            Ce = Re(Ce, Me);
            for (var Be = !an(pe) && fe(pe), qe = (Be || pe).length, He = 0; He < qe; He++) {
              var gt = Be ? Be[He] : He;
              if (Ce(pe[gt], gt, pe))
                return !0;
            }
            return !1;
          }
          function lt(pe, Ce, Me, Be) {
            return an(pe) || (pe = pt(pe)), (typeof Me != "number" || Be) && (Me = 0), ut(pe, Ce, Me) >= 0;
          }
          var Bt = p(function(pe, Ce, Me) {
            var Be, qe;
            return U(Ce) ? qe = Ce : (Ce = tt(Ce), Be = Ce.slice(0, -1), Ce = Ce[Ce.length - 1]), Xt(pe, function(He) {
              var gt = qe;
              if (!gt) {
                if (Be && Be.length && (He = dt(He, Be)), He == null)
                  return;
                gt = He[Ce];
              }
              return gt == null ? gt : gt.apply(He, Me);
            });
          });
          function yt(pe, Ce) {
            return Xt(pe, _t(Ce));
          }
          function $t(pe, Ce) {
            return ye(pe, vt(Ce));
          }
          function Ht(pe, Ce, Me) {
            var Be = -1 / 0, qe = -1 / 0, He, gt;
            if (Ce == null || typeof Ce == "number" && typeof pe[0] != "object" && pe != null) {
              pe = an(pe) ? pe : pt(pe);
              for (var kt = 0, qt = pe.length; kt < qt; kt++)
                He = pe[kt], He != null && He > Be && (Be = He);
            } else
              Ce = Re(Ce, Me), jt(pe, function(Gt, cn, un) {
                gt = Ce(Gt, cn, un), (gt > qe || gt === -1 / 0 && Be === -1 / 0) && (Be = Gt, qe = gt);
              });
            return Be;
          }
          function zt(pe, Ce, Me) {
            var Be = 1 / 0, qe = 1 / 0, He, gt;
            if (Ce == null || typeof Ce == "number" && typeof pe[0] != "object" && pe != null) {
              pe = an(pe) ? pe : pt(pe);
              for (var kt = 0, qt = pe.length; kt < qt; kt++)
                He = pe[kt], He != null && He < Be && (Be = He);
            } else
              Ce = Re(Ce, Me), jt(pe, function(Gt, cn, un) {
                gt = Ce(Gt, cn, un), (gt < qe || gt === 1 / 0 && Be === 1 / 0) && (Be = Gt, qe = gt);
              });
            return Be;
          }
          function Jt(pe, Ce, Me) {
            if (Ce == null || Me)
              return an(pe) || (pe = pt(pe)), pe[It(pe.length - 1)];
            var Be = an(pe) ? Ge(pe) : pt(pe), qe = ae(Be);
            Ce = Math.max(Math.min(Ce, qe), 0);
            for (var He = qe - 1, gt = 0; gt < Ce; gt++) {
              var kt = It(gt, He), qt = Be[gt];
              Be[gt] = Be[kt], Be[kt] = qt;
            }
            return Be.slice(0, Ce);
          }
          function Qt(pe) {
            return Jt(pe, 1 / 0);
          }
          function nn(pe, Ce, Me) {
            var Be = 0;
            return Ce = Re(Ce, Me), yt(Xt(pe, function(qe, He, gt) {
              return {
                value: qe,
                index: Be++,
                criteria: Ce(qe, He, gt)
              };
            }).sort(function(qe, He) {
              var gt = qe.criteria, kt = He.criteria;
              if (gt !== kt) {
                if (gt > kt || gt === void 0)
                  return 1;
                if (gt < kt || kt === void 0)
                  return -1;
              }
              return qe.index - He.index;
            }), "value");
          }
          function tn(pe, Ce) {
            return function(Me, Be, qe) {
              var He = Ce ? [[], []] : {};
              return Be = Re(Be, qe), jt(Me, function(gt, kt) {
                var qt = Be(gt, kt, Me);
                pe(He, gt, qt);
              }), He;
            };
          }
          var on = tn(function(pe, Ce, Me) {
            J(pe, Me) ? pe[Me].push(Ce) : pe[Me] = [Ce];
          }), Wn = tn(function(pe, Ce, Me) {
            pe[Me] = Ce;
          }), Hn = tn(function(pe, Ce, Me) {
            J(pe, Me) ? pe[Me]++ : pe[Me] = 1;
          }), Vn = tn(function(pe, Ce, Me) {
            pe[Me ? 0 : 1].push(Ce);
          }, !0), ii = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
          function qn(pe) {
            return pe ? Y(pe) ? a.call(pe) : D(pe) ? pe.match(ii) : an(pe) ? Xt(pe, ht) : pt(pe) : [];
          }
          function ri(pe) {
            return pe == null ? 0 : an(pe) ? pe.length : fe(pe).length;
          }
          function Yn(pe, Ce, Me) {
            return Ce in Me;
          }
          var Kn = p(function(pe, Ce) {
            var Me = {}, Be = Ce[0];
            if (pe == null)
              return Me;
            U(Be) ? (Ce.length > 1 && (Be = Nt(Be, Ce[1])), Ce = Se(pe)) : (Be = Yn, Ce = dn(Ce, !1, !1), pe = Object(pe));
            for (var qe = 0, He = Ce.length; qe < He; qe++) {
              var gt = Ce[qe], kt = pe[gt];
              Be(kt, gt, pe) && (Me[gt] = kt);
            }
            return Me;
          }), er = p(function(pe, Ce) {
            var Me = Ce[0], Be;
            return U(Me) ? (Me = _n(Me), Ce.length > 1 && (Be = Ce[1])) : (Ce = Xt(dn(Ce, !1, !1), String), Me = function(qe, He) {
              return !lt(Ce, He);
            }), Kn(pe, Me, Be);
          });
          function Ei(pe, Ce, Me) {
            return a.call(pe, 0, Math.max(0, pe.length - (Ce == null || Me ? 1 : Ce)));
          }
          function ai(pe, Ce, Me) {
            return pe == null || pe.length < 1 ? Ce == null || Me ? void 0 : [] : Ce == null || Me ? pe[0] : Ei(pe, pe.length - Ce);
          }
          function Zn(pe, Ce, Me) {
            return a.call(pe, Ce == null || Me ? 1 : Ce);
          }
          function tr(pe, Ce, Me) {
            return pe == null || pe.length < 1 ? Ce == null || Me ? void 0 : [] : Ce == null || Me ? pe[pe.length - 1] : Zn(pe, Math.max(0, pe.length - Ce));
          }
          function nr(pe) {
            return ye(pe, Boolean);
          }
          function ir(pe, Ce) {
            return dn(pe, Ce, !1);
          }
          var ki = p(function(pe, Ce) {
            return Ce = dn(Ce, !0, !0), ye(pe, function(Me) {
              return !lt(Ce, Me);
            });
          }), rr = p(function(pe, Ce) {
            return ki(pe, Ce);
          });
          function si(pe, Ce, Me, Be) {
            j(Ce) || (Be = Me, Me = Ce, Ce = !1), Me != null && (Me = Re(Me, Be));
            for (var qe = [], He = [], gt = 0, kt = ae(pe); gt < kt; gt++) {
              var qt = pe[gt], Gt = Me ? Me(qt, gt, pe) : qt;
              Ce && !Me ? ((!gt || He !== Gt) && qe.push(qt), He = Gt) : Me ? lt(He, Gt) || (He.push(Gt), qe.push(qt)) : lt(qe, qt) || qe.push(qt);
            }
            return qe;
          }
          var ar = p(function(pe) {
            return si(dn(pe, !0, !0));
          });
          function sr(pe) {
            for (var Ce = [], Me = arguments.length, Be = 0, qe = ae(pe); Be < qe; Be++) {
              var He = pe[Be];
              if (!lt(Ce, He)) {
                var gt;
                for (gt = 1; gt < Me && lt(arguments[gt], He); gt++)
                  ;
                gt === Me && Ce.push(He);
              }
            }
            return Ce;
          }
          function oi(pe) {
            for (var Ce = pe && Ht(pe, ae).length || 0, Me = Array(Ce), Be = 0; Be < Ce; Be++)
              Me[Be] = yt(pe, Be);
            return Me;
          }
          var or = p(oi);
          function cr(pe, Ce) {
            for (var Me = {}, Be = 0, qe = ae(pe); Be < qe; Be++)
              Ce ? Me[pe[Be]] = Ce[Be] : Me[pe[Be][0]] = pe[Be][1];
            return Me;
          }
          function lr(pe, Ce, Me) {
            Ce == null && (Ce = pe || 0, pe = 0), Me || (Me = Ce < pe ? -1 : 1);
            for (var Be = Math.max(Math.ceil((Ce - pe) / Me), 0), qe = Array(Be), He = 0; He < Be; He++, pe += Me)
              qe[He] = pe;
            return qe;
          }
          function ur(pe, Ce) {
            if (Ce == null || Ce < 1)
              return [];
            for (var Me = [], Be = 0, qe = pe.length; Be < qe; )
              Me.push(a.call(pe, Be, Be += Ce));
            return Me;
          }
          function ci(pe, Ce) {
            return pe._chain ? we(Ce).chain() : Ce;
          }
          function Oi(pe) {
            return jt(St(pe), function(Ce) {
              var Me = we[Ce] = pe[Ce];
              we.prototype[Ce] = function() {
                var Be = [this._wrapped];
                return v.apply(Be, arguments), ci(this, Me.apply(we, Be));
              };
            }), we;
          }
          jt(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(pe) {
            var Ce = P[pe];
            we.prototype[pe] = function() {
              var Me = this._wrapped;
              return Me != null && (Ce.apply(Me, arguments), (pe === "shift" || pe === "splice") && Me.length === 0 && delete Me[0]), ci(this, Me);
            };
          }), jt(["concat", "join", "slice"], function(pe) {
            var Ce = P[pe];
            we.prototype[pe] = function() {
              var Me = this._wrapped;
              return Me != null && (Me = Ce.apply(Me, arguments)), ci(this, Me);
            };
          });
          var hr = {
            __proto__: null,
            VERSION: Q,
            restArguments: p,
            isObject: w,
            isNull: X,
            isUndefined: M,
            isBoolean: j,
            isElement: B,
            isString: D,
            isNumber: b,
            isDate: l,
            isRegExp: _,
            isError: S,
            isSymbol: A,
            isArrayBuffer: F,
            isDataView: L,
            isArray: Y,
            isFunction: U,
            isArguments: q,
            isFinite: N,
            isNaN: Z,
            isTypedArray: ne,
            isEmpty: me,
            isMatch: Fe,
            isEqual: ve,
            isMap: Je,
            isWeakMap: ot,
            isSet: mt,
            isWeakSet: Ze,
            keys: fe,
            allKeys: Se,
            values: pt,
            pairs: Ft,
            invert: $e,
            functions: St,
            methods: St,
            extend: Ie,
            extendOwn: Ve,
            assign: Ve,
            defaults: st,
            create: Lt,
            clone: Ge,
            tap: Ne,
            get: Ct,
            has: bt,
            mapObject: We,
            identity: ht,
            constant: E,
            noop: it,
            toPath: rt,
            property: _t,
            propertyOf: et,
            matcher: vt,
            matches: vt,
            times: At,
            random: It,
            now: Vt,
            escape: Kt,
            unescape: ln,
            templateSettings: Cn,
            template: Bn,
            result: Ln,
            uniqueId: kn,
            chain: On,
            iteratee: Et,
            partial: hn,
            bind: gn,
            bindAll: Tn,
            memoize: In,
            delay: wn,
            defer: Nn,
            throttle: Pn,
            debounce: Rn,
            wrap: Un,
            negate: _n,
            compose: An,
            after: Mn,
            before: xn,
            once: jn,
            findKey: bn,
            findIndex: I,
            findLastIndex: ce,
            sortedIndex: je,
            indexOf: ut,
            lastIndexOf: Ot,
            find: Dt,
            detect: Dt,
            findWhere: Pt,
            each: jt,
            forEach: jt,
            map: Xt,
            collect: Xt,
            reduce: Yt,
            foldl: Yt,
            inject: Yt,
            reduceRight: en,
            foldr: en,
            filter: ye,
            select: ye,
            reject: Pe,
            every: Qe,
            all: Qe,
            some: Ye,
            any: Ye,
            contains: lt,
            includes: lt,
            include: lt,
            invoke: Bt,
            pluck: yt,
            where: $t,
            max: Ht,
            min: zt,
            shuffle: Qt,
            sample: Jt,
            sortBy: nn,
            groupBy: on,
            indexBy: Wn,
            countBy: Hn,
            partition: Vn,
            toArray: qn,
            size: ri,
            pick: Kn,
            omit: er,
            first: ai,
            head: ai,
            take: ai,
            initial: Ei,
            last: tr,
            rest: Zn,
            tail: Zn,
            drop: Zn,
            compact: nr,
            flatten: ir,
            without: rr,
            uniq: si,
            unique: si,
            union: ar,
            intersection: sr,
            difference: ki,
            unzip: oi,
            transpose: oi,
            zip: or,
            object: cr,
            range: lr,
            chunk: ur,
            mixin: Oi,
            default: we
          }, li = Oi(hr);
          return li._ = li, li;
        });
      }).call(this, typeof commonjsGlobal < "u" ? commonjsGlobal : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 118: [function(le, de, oe) {
      (function(se) {
        de.exports = Q;
        function Q(P, t) {
          if (u("noDeprecation"))
            return P;
          var i = !1;
          function v() {
            if (!i) {
              if (u("throwDeprecation"))
                throw new Error(t);
              u("traceDeprecation") ? console.trace(t) : console.warn(t), i = !0;
            }
            return P.apply(this, arguments);
          }
          return v;
        }
        function u(P) {
          try {
            if (!se.localStorage)
              return !1;
          } catch {
            return !1;
          }
          var t = se.localStorage[P];
          return t == null ? !1 : String(t).toLowerCase() === "true";
        }
      }).call(this, typeof commonjsGlobal < "u" ? commonjsGlobal : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 119: [function(le, de, oe) {
      arguments[4][84][0].apply(oe, arguments);
    }, { dup: 84 }], 120: [function(le, de, oe) {
      de.exports = function(Q) {
        return Q && typeof Q == "object" && typeof Q.copy == "function" && typeof Q.fill == "function" && typeof Q.readUInt8 == "function";
      };
    }, {}], 121: [function(le, de, oe) {
      (function(se, Q) {
        var u = /%[sdj%]/g;
        oe.format = function(F) {
          if (!C(F)) {
            for (var T = [], O = 0; O < arguments.length; O++)
              T.push(i(arguments[O]));
            return T.join(" ");
          }
          for (var O = 1, U = arguments, G = U.length, K = String(F).replace(u, function(z) {
            if (z === "%%")
              return "%";
            if (O >= G)
              return z;
            switch (z) {
              case "%s":
                return String(U[O++]);
              case "%d":
                return Number(U[O++]);
              case "%j":
                try {
                  return JSON.stringify(U[O++]);
                } catch {
                  return "[Circular]";
                }
              default:
                return z;
            }
          }), W = U[O]; O < G; W = U[++O])
            x(W) || !M(W) ? K += " " + W : K += " " + i(W);
          return K;
        }, oe.deprecate = function(F, T) {
          if (w(Q.process))
            return function() {
              return oe.deprecate(F, T).apply(this, arguments);
            };
          if (se.noDeprecation === !0)
            return F;
          var O = !1;
          function U() {
            if (!O) {
              if (se.throwDeprecation)
                throw new Error(T);
              se.traceDeprecation ? console.trace(T) : console.error(T), O = !0;
            }
            return F.apply(this, arguments);
          }
          return U;
        };
        var P = {}, t;
        oe.debuglog = function(F) {
          if (w(t) && (t = se.env.NODE_DEBUG || ""), F = F.toUpperCase(), !P[F])
            if (new RegExp("\\b" + F + "\\b", "i").test(t)) {
              var T = se.pid;
              P[F] = function() {
                var O = oe.format.apply(oe, arguments);
                console.error("%s %d: %s", F, T, O);
              };
            } else
              P[F] = function() {
              };
          return P[F];
        };
        function i(F, T) {
          var O = {
            seen: [],
            stylize: a
          };
          return arguments.length >= 3 && (O.depth = arguments[2]), arguments.length >= 4 && (O.colors = arguments[3]), o(T) ? O.showHidden = T : T && oe._extend(O, T), w(O.showHidden) && (O.showHidden = !1), w(O.depth) && (O.depth = 2), w(O.colors) && (O.colors = !1), w(O.customInspect) && (O.customInspect = !0), O.colors && (O.stylize = v), y(O, F, O.depth);
        }
        oe.inspect = i, i.colors = {
          bold: [1, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          white: [37, 39],
          grey: [90, 39],
          black: [30, 39],
          blue: [34, 39],
          cyan: [36, 39],
          green: [32, 39],
          magenta: [35, 39],
          red: [31, 39],
          yellow: [33, 39]
        }, i.styles = {
          special: "cyan",
          number: "yellow",
          boolean: "yellow",
          undefined: "grey",
          null: "bold",
          string: "green",
          date: "magenta",
          // "name": intentionally not styling
          regexp: "red"
        };
        function v(F, T) {
          var O = i.styles[T];
          return O ? "\x1B[" + i.colors[O][0] + "m" + F + "\x1B[" + i.colors[O][1] + "m" : F;
        }
        function a(F, T) {
          return F;
        }
        function e(F) {
          var T = {};
          return F.forEach(function(O, U) {
            T[O] = !0;
          }), T;
        }
        function y(F, T, O) {
          if (F.customInspect && T && R(T.inspect) && // Filter out the util module, it's inspect function is special
          T.inspect !== oe.inspect && // Also filter out any prototype objects using the circular check.
          !(T.constructor && T.constructor.prototype === T)) {
            var U = T.inspect(O, F);
            return C(U) || (U = y(F, U, O)), U;
          }
          var G = r(F, T);
          if (G)
            return G;
          var K = Object.keys(T), W = e(K);
          if (F.showHidden && (K = Object.getOwnPropertyNames(T)), B(T) && (K.indexOf("message") >= 0 || K.indexOf("description") >= 0))
            return h(T);
          if (K.length === 0) {
            if (R(T)) {
              var z = T.name ? ": " + T.name : "";
              return F.stylize("[Function" + z + "]", "special");
            }
            if (X(T))
              return F.stylize(RegExp.prototype.toString.call(T), "regexp");
            if (j(T))
              return F.stylize(Date.prototype.toString.call(T), "date");
            if (B(T))
              return h(T);
          }
          var V = "", L = !1, Y = ["{", "}"];
          if (n(T) && (L = !0, Y = ["[", "]"]), R(T)) {
            var J = T.name ? ": " + T.name : "";
            V = " [Function" + J + "]";
          }
          if (X(T) && (V = " " + RegExp.prototype.toString.call(T)), j(T) && (V = " " + Date.prototype.toUTCString.call(T)), B(T) && (V = " " + h(T)), K.length === 0 && (!L || T.length == 0))
            return Y[0] + V + Y[1];
          if (O < 0)
            return X(T) ? F.stylize(RegExp.prototype.toString.call(T), "regexp") : F.stylize("[Object]", "special");
          F.seen.push(T);
          var ie;
          return L ? ie = g(F, T, O, W, K) : ie = K.map(function(q) {
            return d(F, T, O, W, q, L);
          }), F.seen.pop(), c(ie, V, Y);
        }
        function r(F, T) {
          if (w(T))
            return F.stylize("undefined", "undefined");
          if (C(T)) {
            var O = "'" + JSON.stringify(T).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
            return F.stylize(O, "string");
          }
          if (m(T))
            return F.stylize("" + T, "number");
          if (o(T))
            return F.stylize("" + T, "boolean");
          if (x(T))
            return F.stylize("null", "null");
        }
        function h(F) {
          return "[" + Error.prototype.toString.call(F) + "]";
        }
        function g(F, T, O, U, G) {
          for (var K = [], W = 0, z = T.length; W < z; ++W)
            A(T, String(W)) ? K.push(d(
              F,
              T,
              O,
              U,
              String(W),
              !0
            )) : K.push("");
          return G.forEach(function(V) {
            V.match(/^\d+$/) || K.push(d(
              F,
              T,
              O,
              U,
              V,
              !0
            ));
          }), K;
        }
        function d(F, T, O, U, G, K) {
          var W, z, V;
          if (V = Object.getOwnPropertyDescriptor(T, G) || { value: T[G] }, V.get ? V.set ? z = F.stylize("[Getter/Setter]", "special") : z = F.stylize("[Getter]", "special") : V.set && (z = F.stylize("[Setter]", "special")), A(U, G) || (W = "[" + G + "]"), z || (F.seen.indexOf(V.value) < 0 ? (x(O) ? z = y(F, V.value, null) : z = y(F, V.value, O - 1), z.indexOf(`
`) > -1 && (K ? z = z.split(`
`).map(function(L) {
            return "  " + L;
          }).join(`
`).substr(2) : z = `
` + z.split(`
`).map(function(L) {
            return "   " + L;
          }).join(`
`))) : z = F.stylize("[Circular]", "special")), w(W)) {
            if (K && G.match(/^\d+$/))
              return z;
            W = JSON.stringify("" + G), W.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (W = W.substr(1, W.length - 2), W = F.stylize(W, "name")) : (W = W.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), W = F.stylize(W, "string"));
          }
          return W + ": " + z;
        }
        function c(F, T, O) {
          var U = F.reduce(function(G, K) {
            return K.indexOf(`
`) >= 0, G + K.replace(/\u001b\[\d\d?m/g, "").length + 1;
          }, 0);
          return U > 60 ? O[0] + (T === "" ? "" : T + `
 `) + " " + F.join(`,
  `) + " " + O[1] : O[0] + T + " " + F.join(", ") + " " + O[1];
        }
        function n(F) {
          return Array.isArray(F);
        }
        oe.isArray = n;
        function o(F) {
          return typeof F == "boolean";
        }
        oe.isBoolean = o;
        function x(F) {
          return F === null;
        }
        oe.isNull = x;
        function f(F) {
          return F == null;
        }
        oe.isNullOrUndefined = f;
        function m(F) {
          return typeof F == "number";
        }
        oe.isNumber = m;
        function C(F) {
          return typeof F == "string";
        }
        oe.isString = C;
        function p(F) {
          return typeof F == "symbol";
        }
        oe.isSymbol = p;
        function w(F) {
          return F === void 0;
        }
        oe.isUndefined = w;
        function X(F) {
          return M(F) && b(F) === "[object RegExp]";
        }
        oe.isRegExp = X;
        function M(F) {
          return typeof F == "object" && F !== null;
        }
        oe.isObject = M;
        function j(F) {
          return M(F) && b(F) === "[object Date]";
        }
        oe.isDate = j;
        function B(F) {
          return M(F) && (b(F) === "[object Error]" || F instanceof Error);
        }
        oe.isError = B;
        function R(F) {
          return typeof F == "function";
        }
        oe.isFunction = R;
        function D(F) {
          return F === null || typeof F == "boolean" || typeof F == "number" || typeof F == "string" || typeof F == "symbol" || // ES6 symbol
          typeof F > "u";
        }
        oe.isPrimitive = D, oe.isBuffer = le("./support/isBuffer");
        function b(F) {
          return Object.prototype.toString.call(F);
        }
        function l(F) {
          return F < 10 ? "0" + F.toString(10) : F.toString(10);
        }
        var _ = [
          "Jan",
          "Feb",
          "Mar",
          "Apr",
          "May",
          "Jun",
          "Jul",
          "Aug",
          "Sep",
          "Oct",
          "Nov",
          "Dec"
        ];
        function S() {
          var F = new Date(), T = [
            l(F.getHours()),
            l(F.getMinutes()),
            l(F.getSeconds())
          ].join(":");
          return [F.getDate(), _[F.getMonth()], T].join(" ");
        }
        oe.log = function() {
          console.log("%s - %s", S(), oe.format.apply(oe, arguments));
        }, oe.inherits = le("inherits"), oe._extend = function(F, T) {
          if (!T || !M(T))
            return F;
          for (var O = Object.keys(T), U = O.length; U--; )
            F[O[U]] = T[O[U]];
          return F;
        };
        function A(F, T) {
          return Object.prototype.hasOwnProperty.call(F, T);
        }
      }).call(this, le("_process"), typeof commonjsGlobal < "u" ? commonjsGlobal : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "./support/isBuffer": 120, _process: 102, inherits: 119 }], 122: [function(le, de, oe) {
      (function() {
        var se, Q, u, P, t, i, v, a = [].slice, e = {}.hasOwnProperty;
        se = function() {
          var y, r, h, g, d, c;
          if (c = arguments[0], d = 2 <= arguments.length ? a.call(arguments, 1) : [], t(Object.assign))
            Object.assign.apply(null, arguments);
          else
            for (y = 0, h = d.length; y < h; y++)
              if (g = d[y], g != null)
                for (r in g)
                  e.call(g, r) && (c[r] = g[r]);
          return c;
        }, t = function(y) {
          return !!y && Object.prototype.toString.call(y) === "[object Function]";
        }, i = function(y) {
          var r;
          return !!y && ((r = typeof y) == "function" || r === "object");
        }, u = function(y) {
          return t(Array.isArray) ? Array.isArray(y) : Object.prototype.toString.call(y) === "[object Array]";
        }, P = function(y) {
          var r;
          if (u(y))
            return !y.length;
          for (r in y)
            if (e.call(y, r))
              return !1;
          return !0;
        }, v = function(y) {
          var r, h;
          return i(y) && (h = Object.getPrototypeOf(y)) && (r = h.constructor) && typeof r == "function" && r instanceof r && Function.prototype.toString.call(r) === Function.prototype.toString.call(Object);
        }, Q = function(y) {
          return t(y.valueOf) ? y.valueOf() : y;
        }, de.exports.assign = se, de.exports.isFunction = t, de.exports.isObject = i, de.exports.isArray = u, de.exports.isEmpty = P, de.exports.isPlainObject = v, de.exports.getValue = Q;
      }).call(this);
    }, {}], 123: [function(le, de, oe) {
      (function() {
        de.exports = function() {
          function se(Q, u, P) {
            if (this.options = Q.options, this.stringify = Q.stringify, this.parent = Q, u == null)
              throw new Error("Missing attribute name. " + this.debugInfo(u));
            if (P == null)
              throw new Error("Missing attribute value. " + this.debugInfo(u));
            this.name = this.stringify.attName(u), this.value = this.stringify.attValue(P);
          }
          return se.prototype.clone = function() {
            return Object.create(this);
          }, se.prototype.toString = function(Q) {
            return this.options.writer.set(Q).attribute(this);
          }, se.prototype.debugInfo = function(Q) {
            var u, P;
            return Q = Q || this.name, Q == null && !((u = this.parent) != null && u.name) ? "" : Q == null ? "parent: <" + this.parent.name + ">" : (P = this.parent) != null && P.name ? "attribute: {" + Q + "}, parent: <" + this.parent.name + ">" : "attribute: {" + Q + "}";
          }, se;
        }();
      }).call(this);
    }, {}], 124: [function(le, de, oe) {
      (function() {
        var se, Q = function(P, t) {
          for (var i in t)
            u.call(t, i) && (P[i] = t[i]);
          function v() {
            this.constructor = P;
          }
          return v.prototype = t.prototype, P.prototype = new v(), P.__super__ = t.prototype, P;
        }, u = {}.hasOwnProperty;
        se = le("./XMLNode"), de.exports = function(P) {
          Q(t, P);
          function t(i, v) {
            if (t.__super__.constructor.call(this, i), v == null)
              throw new Error("Missing CDATA text. " + this.debugInfo());
            this.text = this.stringify.cdata(v);
          }
          return t.prototype.clone = function() {
            return Object.create(this);
          }, t.prototype.toString = function(i) {
            return this.options.writer.set(i).cdata(this);
          }, t;
        }(se);
      }).call(this);
    }, { "./XMLNode": 135 }], 125: [function(le, de, oe) {
      (function() {
        var se, Q = function(P, t) {
          for (var i in t)
            u.call(t, i) && (P[i] = t[i]);
          function v() {
            this.constructor = P;
          }
          return v.prototype = t.prototype, P.prototype = new v(), P.__super__ = t.prototype, P;
        }, u = {}.hasOwnProperty;
        se = le("./XMLNode"), de.exports = function(P) {
          Q(t, P);
          function t(i, v) {
            if (t.__super__.constructor.call(this, i), v == null)
              throw new Error("Missing comment text. " + this.debugInfo());
            this.text = this.stringify.comment(v);
          }
          return t.prototype.clone = function() {
            return Object.create(this);
          }, t.prototype.toString = function(i) {
            return this.options.writer.set(i).comment(this);
          }, t;
        }(se);
      }).call(this);
    }, { "./XMLNode": 135 }], 126: [function(le, de, oe) {
      (function() {
        var se, Q = function(P, t) {
          for (var i in t)
            u.call(t, i) && (P[i] = t[i]);
          function v() {
            this.constructor = P;
          }
          return v.prototype = t.prototype, P.prototype = new v(), P.__super__ = t.prototype, P;
        }, u = {}.hasOwnProperty;
        se = le("./XMLNode"), de.exports = function(P) {
          Q(t, P);
          function t(i, v, a, e, y, r) {
            if (t.__super__.constructor.call(this, i), v == null)
              throw new Error("Missing DTD element name. " + this.debugInfo());
            if (a == null)
              throw new Error("Missing DTD attribute name. " + this.debugInfo(v));
            if (!e)
              throw new Error("Missing DTD attribute type. " + this.debugInfo(v));
            if (!y)
              throw new Error("Missing DTD attribute default. " + this.debugInfo(v));
            if (y.indexOf("#") !== 0 && (y = "#" + y), !y.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/))
              throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(v));
            if (r && !y.match(/^(#FIXED|#DEFAULT)$/))
              throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(v));
            this.elementName = this.stringify.eleName(v), this.attributeName = this.stringify.attName(a), this.attributeType = this.stringify.dtdAttType(e), this.defaultValue = this.stringify.dtdAttDefault(r), this.defaultValueType = y;
          }
          return t.prototype.toString = function(i) {
            return this.options.writer.set(i).dtdAttList(this);
          }, t;
        }(se);
      }).call(this);
    }, { "./XMLNode": 135 }], 127: [function(le, de, oe) {
      (function() {
        var se, Q = function(P, t) {
          for (var i in t)
            u.call(t, i) && (P[i] = t[i]);
          function v() {
            this.constructor = P;
          }
          return v.prototype = t.prototype, P.prototype = new v(), P.__super__ = t.prototype, P;
        }, u = {}.hasOwnProperty;
        se = le("./XMLNode"), de.exports = function(P) {
          Q(t, P);
          function t(i, v, a) {
            if (t.__super__.constructor.call(this, i), v == null)
              throw new Error("Missing DTD element name. " + this.debugInfo());
            a || (a = "(#PCDATA)"), Array.isArray(a) && (a = "(" + a.join(",") + ")"), this.name = this.stringify.eleName(v), this.value = this.stringify.dtdElementValue(a);
          }
          return t.prototype.toString = function(i) {
            return this.options.writer.set(i).dtdElement(this);
          }, t;
        }(se);
      }).call(this);
    }, { "./XMLNode": 135 }], 128: [function(le, de, oe) {
      (function() {
        var se, Q, u = function(t, i) {
          for (var v in i)
            P.call(i, v) && (t[v] = i[v]);
          function a() {
            this.constructor = t;
          }
          return a.prototype = i.prototype, t.prototype = new a(), t.__super__ = i.prototype, t;
        }, P = {}.hasOwnProperty;
        Q = le("./Utility").isObject, se = le("./XMLNode"), de.exports = function(t) {
          u(i, t);
          function i(v, a, e, y) {
            if (i.__super__.constructor.call(this, v), e == null)
              throw new Error("Missing DTD entity name. " + this.debugInfo(e));
            if (y == null)
              throw new Error("Missing DTD entity value. " + this.debugInfo(e));
            if (this.pe = !!a, this.name = this.stringify.eleName(e), !Q(y))
              this.value = this.stringify.dtdEntityValue(y);
            else {
              if (!y.pubID && !y.sysID)
                throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(e));
              if (y.pubID && !y.sysID)
                throw new Error("System identifier is required for a public external entity. " + this.debugInfo(e));
              if (y.pubID != null && (this.pubID = this.stringify.dtdPubID(y.pubID)), y.sysID != null && (this.sysID = this.stringify.dtdSysID(y.sysID)), y.nData != null && (this.nData = this.stringify.dtdNData(y.nData)), this.pe && this.nData)
                throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(e));
            }
          }
          return i.prototype.toString = function(v) {
            return this.options.writer.set(v).dtdEntity(this);
          }, i;
        }(se);
      }).call(this);
    }, { "./Utility": 122, "./XMLNode": 135 }], 129: [function(le, de, oe) {
      (function() {
        var se, Q = function(P, t) {
          for (var i in t)
            u.call(t, i) && (P[i] = t[i]);
          function v() {
            this.constructor = P;
          }
          return v.prototype = t.prototype, P.prototype = new v(), P.__super__ = t.prototype, P;
        }, u = {}.hasOwnProperty;
        se = le("./XMLNode"), de.exports = function(P) {
          Q(t, P);
          function t(i, v, a) {
            if (t.__super__.constructor.call(this, i), v == null)
              throw new Error("Missing DTD notation name. " + this.debugInfo(v));
            if (!a.pubID && !a.sysID)
              throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(v));
            this.name = this.stringify.eleName(v), a.pubID != null && (this.pubID = this.stringify.dtdPubID(a.pubID)), a.sysID != null && (this.sysID = this.stringify.dtdSysID(a.sysID));
          }
          return t.prototype.toString = function(i) {
            return this.options.writer.set(i).dtdNotation(this);
          }, t;
        }(se);
      }).call(this);
    }, { "./XMLNode": 135 }], 130: [function(le, de, oe) {
      (function() {
        var se, Q, u = function(t, i) {
          for (var v in i)
            P.call(i, v) && (t[v] = i[v]);
          function a() {
            this.constructor = t;
          }
          return a.prototype = i.prototype, t.prototype = new a(), t.__super__ = i.prototype, t;
        }, P = {}.hasOwnProperty;
        Q = le("./Utility").isObject, se = le("./XMLNode"), de.exports = function(t) {
          u(i, t);
          function i(v, a, e, y) {
            var r;
            i.__super__.constructor.call(this, v), Q(a) && (r = a, a = r.version, e = r.encoding, y = r.standalone), a || (a = "1.0"), this.version = this.stringify.xmlVersion(a), e != null && (this.encoding = this.stringify.xmlEncoding(e)), y != null && (this.standalone = this.stringify.xmlStandalone(y));
          }
          return i.prototype.toString = function(v) {
            return this.options.writer.set(v).declaration(this);
          }, i;
        }(se);
      }).call(this);
    }, { "./Utility": 122, "./XMLNode": 135 }], 131: [function(le, de, oe) {
      (function() {
        var se, Q, u, P, t, i, v = function(e, y) {
          for (var r in y)
            a.call(y, r) && (e[r] = y[r]);
          function h() {
            this.constructor = e;
          }
          return h.prototype = y.prototype, e.prototype = new h(), e.__super__ = y.prototype, e;
        }, a = {}.hasOwnProperty;
        i = le("./Utility").isObject, t = le("./XMLNode"), se = le("./XMLDTDAttList"), u = le("./XMLDTDEntity"), Q = le("./XMLDTDElement"), P = le("./XMLDTDNotation"), de.exports = function(e) {
          v(y, e);
          function y(r, h, g) {
            var d, c;
            y.__super__.constructor.call(this, r), this.name = "!DOCTYPE", this.documentObject = r, i(h) && (d = h, h = d.pubID, g = d.sysID), g == null && (c = [h, g], g = c[0], h = c[1]), h != null && (this.pubID = this.stringify.dtdPubID(h)), g != null && (this.sysID = this.stringify.dtdSysID(g));
          }
          return y.prototype.element = function(r, h) {
            var g;
            return g = new Q(this, r, h), this.children.push(g), this;
          }, y.prototype.attList = function(r, h, g, d, c) {
            var n;
            return n = new se(this, r, h, g, d, c), this.children.push(n), this;
          }, y.prototype.entity = function(r, h) {
            var g;
            return g = new u(this, !1, r, h), this.children.push(g), this;
          }, y.prototype.pEntity = function(r, h) {
            var g;
            return g = new u(this, !0, r, h), this.children.push(g), this;
          }, y.prototype.notation = function(r, h) {
            var g;
            return g = new P(this, r, h), this.children.push(g), this;
          }, y.prototype.toString = function(r) {
            return this.options.writer.set(r).docType(this);
          }, y.prototype.ele = function(r, h) {
            return this.element(r, h);
          }, y.prototype.att = function(r, h, g, d, c) {
            return this.attList(r, h, g, d, c);
          }, y.prototype.ent = function(r, h) {
            return this.entity(r, h);
          }, y.prototype.pent = function(r, h) {
            return this.pEntity(r, h);
          }, y.prototype.not = function(r, h) {
            return this.notation(r, h);
          }, y.prototype.up = function() {
            return this.root() || this.documentObject;
          }, y;
        }(t);
      }).call(this);
    }, { "./Utility": 122, "./XMLDTDAttList": 126, "./XMLDTDElement": 127, "./XMLDTDEntity": 128, "./XMLDTDNotation": 129, "./XMLNode": 135 }], 132: [function(le, de, oe) {
      (function() {
        var se, Q, u, P, t = function(v, a) {
          for (var e in a)
            i.call(a, e) && (v[e] = a[e]);
          function y() {
            this.constructor = v;
          }
          return y.prototype = a.prototype, v.prototype = new y(), v.__super__ = a.prototype, v;
        }, i = {}.hasOwnProperty;
        P = le("./Utility").isPlainObject, se = le("./XMLNode"), u = le("./XMLStringifier"), Q = le("./XMLStringWriter"), de.exports = function(v) {
          t(a, v);
          function a(e) {
            a.__super__.constructor.call(this, null), this.name = "?xml", e || (e = {}), e.writer || (e.writer = new Q()), this.options = e, this.stringify = new u(e), this.isDocument = !0;
          }
          return a.prototype.end = function(e) {
            var y;
            return e ? P(e) && (y = e, e = this.options.writer.set(y)) : e = this.options.writer, e.document(this);
          }, a.prototype.toString = function(e) {
            return this.options.writer.set(e).document(this);
          }, a;
        }(se);
      }).call(this);
    }, { "./Utility": 122, "./XMLNode": 135, "./XMLStringWriter": 139, "./XMLStringifier": 140 }], 133: [function(le, de, oe) {
      (function() {
        var se, Q, u, P, t, i, v, a, e, y, r, h, g, d, c, n, o, x, f, m, C = {}.hasOwnProperty;
        m = le("./Utility"), x = m.isObject, o = m.isFunction, f = m.isPlainObject, n = m.getValue, y = le("./XMLElement"), Q = le("./XMLCData"), u = le("./XMLComment"), h = le("./XMLRaw"), c = le("./XMLText"), r = le("./XMLProcessingInstruction"), a = le("./XMLDeclaration"), e = le("./XMLDocType"), P = le("./XMLDTDAttList"), i = le("./XMLDTDEntity"), t = le("./XMLDTDElement"), v = le("./XMLDTDNotation"), se = le("./XMLAttribute"), d = le("./XMLStringifier"), g = le("./XMLStringWriter"), de.exports = function() {
          function p(w, X, M) {
            var j;
            this.name = "?xml", w || (w = {}), w.writer ? f(w.writer) && (j = w.writer, w.writer = new g(j)) : w.writer = new g(w), this.options = w, this.writer = w.writer, this.stringify = new d(w), this.onDataCallback = X || function() {
            }, this.onEndCallback = M || function() {
            }, this.currentNode = null, this.currentLevel = -1, this.openTags = {}, this.documentStarted = !1, this.documentCompleted = !1, this.root = null;
          }
          return p.prototype.node = function(w, X, M) {
            var j;
            if (w == null)
              throw new Error("Missing node name.");
            if (this.root && this.currentLevel === -1)
              throw new Error("Document can only have one root node. " + this.debugInfo(w));
            return this.openCurrent(), w = n(w), X == null && (X = {}), X = n(X), x(X) || (j = [X, M], M = j[0], X = j[1]), this.currentNode = new y(this, w, X), this.currentNode.children = !1, this.currentLevel++, this.openTags[this.currentLevel] = this.currentNode, M != null && this.text(M), this;
          }, p.prototype.element = function(w, X, M) {
            return this.currentNode && this.currentNode instanceof e ? this.dtdElement.apply(this, arguments) : this.node(w, X, M);
          }, p.prototype.attribute = function(w, X) {
            var M, j;
            if (!this.currentNode || this.currentNode.children)
              throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(w));
            if (w != null && (w = n(w)), x(w))
              for (M in w)
                C.call(w, M) && (j = w[M], this.attribute(M, j));
            else
              o(X) && (X = X.apply()), (!this.options.skipNullAttributes || X != null) && (this.currentNode.attributes[w] = new se(this, w, X));
            return this;
          }, p.prototype.text = function(w) {
            var X;
            return this.openCurrent(), X = new c(this, w), this.onData(this.writer.text(X, this.currentLevel + 1), this.currentLevel + 1), this;
          }, p.prototype.cdata = function(w) {
            var X;
            return this.openCurrent(), X = new Q(this, w), this.onData(this.writer.cdata(X, this.currentLevel + 1), this.currentLevel + 1), this;
          }, p.prototype.comment = function(w) {
            var X;
            return this.openCurrent(), X = new u(this, w), this.onData(this.writer.comment(X, this.currentLevel + 1), this.currentLevel + 1), this;
          }, p.prototype.raw = function(w) {
            var X;
            return this.openCurrent(), X = new h(this, w), this.onData(this.writer.raw(X, this.currentLevel + 1), this.currentLevel + 1), this;
          }, p.prototype.instruction = function(w, X) {
            var M, j, B, R, D;
            if (this.openCurrent(), w != null && (w = n(w)), X != null && (X = n(X)), Array.isArray(w))
              for (M = 0, R = w.length; M < R; M++)
                j = w[M], this.instruction(j);
            else if (x(w))
              for (j in w)
                C.call(w, j) && (B = w[j], this.instruction(j, B));
            else
              o(X) && (X = X.apply()), D = new r(this, w, X), this.onData(this.writer.processingInstruction(D, this.currentLevel + 1), this.currentLevel + 1);
            return this;
          }, p.prototype.declaration = function(w, X, M) {
            var j;
            if (this.openCurrent(), this.documentStarted)
              throw new Error("declaration() must be the first node.");
            return j = new a(this, w, X, M), this.onData(this.writer.declaration(j, this.currentLevel + 1), this.currentLevel + 1), this;
          }, p.prototype.doctype = function(w, X, M) {
            if (this.openCurrent(), w == null)
              throw new Error("Missing root node name.");
            if (this.root)
              throw new Error("dtd() must come before the root node.");
            return this.currentNode = new e(this, X, M), this.currentNode.rootNodeName = w, this.currentNode.children = !1, this.currentLevel++, this.openTags[this.currentLevel] = this.currentNode, this;
          }, p.prototype.dtdElement = function(w, X) {
            var M;
            return this.openCurrent(), M = new t(this, w, X), this.onData(this.writer.dtdElement(M, this.currentLevel + 1), this.currentLevel + 1), this;
          }, p.prototype.attList = function(w, X, M, j, B) {
            var R;
            return this.openCurrent(), R = new P(this, w, X, M, j, B), this.onData(this.writer.dtdAttList(R, this.currentLevel + 1), this.currentLevel + 1), this;
          }, p.prototype.entity = function(w, X) {
            var M;
            return this.openCurrent(), M = new i(this, !1, w, X), this.onData(this.writer.dtdEntity(M, this.currentLevel + 1), this.currentLevel + 1), this;
          }, p.prototype.pEntity = function(w, X) {
            var M;
            return this.openCurrent(), M = new i(this, !0, w, X), this.onData(this.writer.dtdEntity(M, this.currentLevel + 1), this.currentLevel + 1), this;
          }, p.prototype.notation = function(w, X) {
            var M;
            return this.openCurrent(), M = new v(this, w, X), this.onData(this.writer.dtdNotation(M, this.currentLevel + 1), this.currentLevel + 1), this;
          }, p.prototype.up = function() {
            if (this.currentLevel < 0)
              throw new Error("The document node has no parent.");
            return this.currentNode ? (this.currentNode.children ? this.closeNode(this.currentNode) : this.openNode(this.currentNode), this.currentNode = null) : this.closeNode(this.openTags[this.currentLevel]), delete this.openTags[this.currentLevel], this.currentLevel--, this;
          }, p.prototype.end = function() {
            for (; this.currentLevel >= 0; )
              this.up();
            return this.onEnd();
          }, p.prototype.openCurrent = function() {
            if (this.currentNode)
              return this.currentNode.children = !0, this.openNode(this.currentNode);
          }, p.prototype.openNode = function(w) {
            if (!w.isOpen)
              return !this.root && this.currentLevel === 0 && w instanceof y && (this.root = w), this.onData(this.writer.openNode(w, this.currentLevel), this.currentLevel), w.isOpen = !0;
          }, p.prototype.closeNode = function(w) {
            if (!w.isClosed)
              return this.onData(this.writer.closeNode(w, this.currentLevel), this.currentLevel), w.isClosed = !0;
          }, p.prototype.onData = function(w, X) {
            return this.documentStarted = !0, this.onDataCallback(w, X + 1);
          }, p.prototype.onEnd = function() {
            return this.documentCompleted = !0, this.onEndCallback();
          }, p.prototype.debugInfo = function(w) {
            return w == null ? "" : "node: <" + w + ">";
          }, p.prototype.ele = function() {
            return this.element.apply(this, arguments);
          }, p.prototype.nod = function(w, X, M) {
            return this.node(w, X, M);
          }, p.prototype.txt = function(w) {
            return this.text(w);
          }, p.prototype.dat = function(w) {
            return this.cdata(w);
          }, p.prototype.com = function(w) {
            return this.comment(w);
          }, p.prototype.ins = function(w, X) {
            return this.instruction(w, X);
          }, p.prototype.dec = function(w, X, M) {
            return this.declaration(w, X, M);
          }, p.prototype.dtd = function(w, X, M) {
            return this.doctype(w, X, M);
          }, p.prototype.e = function(w, X, M) {
            return this.element(w, X, M);
          }, p.prototype.n = function(w, X, M) {
            return this.node(w, X, M);
          }, p.prototype.t = function(w) {
            return this.text(w);
          }, p.prototype.d = function(w) {
            return this.cdata(w);
          }, p.prototype.c = function(w) {
            return this.comment(w);
          }, p.prototype.r = function(w) {
            return this.raw(w);
          }, p.prototype.i = function(w, X) {
            return this.instruction(w, X);
          }, p.prototype.att = function() {
            return this.currentNode && this.currentNode instanceof e ? this.attList.apply(this, arguments) : this.attribute.apply(this, arguments);
          }, p.prototype.a = function() {
            return this.currentNode && this.currentNode instanceof e ? this.attList.apply(this, arguments) : this.attribute.apply(this, arguments);
          }, p.prototype.ent = function(w, X) {
            return this.entity(w, X);
          }, p.prototype.pent = function(w, X) {
            return this.pEntity(w, X);
          }, p.prototype.not = function(w, X) {
            return this.notation(w, X);
          }, p;
        }();
      }).call(this);
    }, { "./Utility": 122, "./XMLAttribute": 123, "./XMLCData": 124, "./XMLComment": 125, "./XMLDTDAttList": 126, "./XMLDTDElement": 127, "./XMLDTDEntity": 128, "./XMLDTDNotation": 129, "./XMLDeclaration": 130, "./XMLDocType": 131, "./XMLElement": 134, "./XMLProcessingInstruction": 136, "./XMLRaw": 137, "./XMLStringWriter": 139, "./XMLStringifier": 140, "./XMLText": 141 }], 134: [function(le, de, oe) {
      (function() {
        var se, Q, u, P, t, i, v = function(e, y) {
          for (var r in y)
            a.call(y, r) && (e[r] = y[r]);
          function h() {
            this.constructor = e;
          }
          return h.prototype = y.prototype, e.prototype = new h(), e.__super__ = y.prototype, e;
        }, a = {}.hasOwnProperty;
        i = le("./Utility"), t = i.isObject, P = i.isFunction, u = i.getValue, Q = le("./XMLNode"), se = le("./XMLAttribute"), de.exports = function(e) {
          v(y, e);
          function y(r, h, g) {
            if (y.__super__.constructor.call(this, r), h == null)
              throw new Error("Missing element name. " + this.debugInfo());
            this.name = this.stringify.eleName(h), this.attributes = {}, g != null && this.attribute(g), r.isDocument && (this.isRoot = !0, this.documentObject = r, r.rootObject = this);
          }
          return y.prototype.clone = function() {
            var r, h, g, d;
            g = Object.create(this), g.isRoot && (g.documentObject = null), g.attributes = {}, d = this.attributes;
            for (h in d)
              a.call(d, h) && (r = d[h], g.attributes[h] = r.clone());
            return g.children = [], this.children.forEach(function(c) {
              var n;
              return n = c.clone(), n.parent = g, g.children.push(n);
            }), g;
          }, y.prototype.attribute = function(r, h) {
            var g, d;
            if (r != null && (r = u(r)), t(r))
              for (g in r)
                a.call(r, g) && (d = r[g], this.attribute(g, d));
            else
              P(h) && (h = h.apply()), (!this.options.skipNullAttributes || h != null) && (this.attributes[r] = new se(this, r, h));
            return this;
          }, y.prototype.removeAttribute = function(r) {
            var h, g, d;
            if (r == null)
              throw new Error("Missing attribute name. " + this.debugInfo());
            if (r = u(r), Array.isArray(r))
              for (g = 0, d = r.length; g < d; g++)
                h = r[g], delete this.attributes[h];
            else
              delete this.attributes[r];
            return this;
          }, y.prototype.toString = function(r) {
            return this.options.writer.set(r).element(this);
          }, y.prototype.att = function(r, h) {
            return this.attribute(r, h);
          }, y.prototype.a = function(r, h) {
            return this.attribute(r, h);
          }, y;
        }(Q);
      }).call(this);
    }, { "./Utility": 122, "./XMLAttribute": 123, "./XMLNode": 135 }], 135: [function(le, de, oe) {
      (function() {
        var se, Q, u, P, t, i, v, a, e, y, r, h, g, d = {}.hasOwnProperty;
        g = le("./Utility"), h = g.isObject, r = g.isFunction, y = g.isEmpty, e = g.getValue, t = null, se = null, Q = null, u = null, P = null, v = null, a = null, i = null, de.exports = function() {
          function c(n) {
            this.parent = n, this.parent && (this.options = this.parent.options, this.stringify = this.parent.stringify), this.children = [], t || (t = le("./XMLElement"), se = le("./XMLCData"), Q = le("./XMLComment"), u = le("./XMLDeclaration"), P = le("./XMLDocType"), v = le("./XMLRaw"), a = le("./XMLText"), i = le("./XMLProcessingInstruction"));
          }
          return c.prototype.element = function(n, o, x) {
            var f, m, C, p, w, X, M, j, B, R;
            if (X = null, o == null && (o = {}), o = e(o), h(o) || (B = [o, x], x = B[0], o = B[1]), n != null && (n = e(n)), Array.isArray(n))
              for (C = 0, M = n.length; C < M; C++)
                m = n[C], X = this.element(m);
            else if (r(n))
              X = this.element(n.apply());
            else if (h(n)) {
              for (w in n)
                if (d.call(n, w))
                  if (R = n[w], r(R) && (R = R.apply()), h(R) && y(R) && (R = null), !this.options.ignoreDecorators && this.stringify.convertAttKey && w.indexOf(this.stringify.convertAttKey) === 0)
                    X = this.attribute(w.substr(this.stringify.convertAttKey.length), R);
                  else if (!this.options.separateArrayItems && Array.isArray(R))
                    for (p = 0, j = R.length; p < j; p++)
                      m = R[p], f = {}, f[w] = m, X = this.element(f);
                  else
                    h(R) ? (X = this.element(w), X.element(R)) : X = this.element(w, R);
            } else
              !this.options.ignoreDecorators && this.stringify.convertTextKey && n.indexOf(this.stringify.convertTextKey) === 0 ? X = this.text(x) : !this.options.ignoreDecorators && this.stringify.convertCDataKey && n.indexOf(this.stringify.convertCDataKey) === 0 ? X = this.cdata(x) : !this.options.ignoreDecorators && this.stringify.convertCommentKey && n.indexOf(this.stringify.convertCommentKey) === 0 ? X = this.comment(x) : !this.options.ignoreDecorators && this.stringify.convertRawKey && n.indexOf(this.stringify.convertRawKey) === 0 ? X = this.raw(x) : !this.options.ignoreDecorators && this.stringify.convertPIKey && n.indexOf(this.stringify.convertPIKey) === 0 ? X = this.instruction(n.substr(this.stringify.convertPIKey.length), x) : X = this.node(n, o, x);
            if (X == null)
              throw new Error("Could not create any elements with: " + n + ". " + this.debugInfo());
            return X;
          }, c.prototype.insertBefore = function(n, o, x) {
            var f, m, C;
            if (this.isRoot)
              throw new Error("Cannot insert elements at root level. " + this.debugInfo(n));
            return m = this.parent.children.indexOf(this), C = this.parent.children.splice(m), f = this.parent.element(n, o, x), Array.prototype.push.apply(this.parent.children, C), f;
          }, c.prototype.insertAfter = function(n, o, x) {
            var f, m, C;
            if (this.isRoot)
              throw new Error("Cannot insert elements at root level. " + this.debugInfo(n));
            return m = this.parent.children.indexOf(this), C = this.parent.children.splice(m + 1), f = this.parent.element(n, o, x), Array.prototype.push.apply(this.parent.children, C), f;
          }, c.prototype.remove = function() {
            var n;
            if (this.isRoot)
              throw new Error("Cannot remove the root element. " + this.debugInfo());
            return n = this.parent.children.indexOf(this), [].splice.apply(this.parent.children, [n, n - n + 1].concat([])), this.parent;
          }, c.prototype.node = function(n, o, x) {
            var f, m;
            return n != null && (n = e(n)), o || (o = {}), o = e(o), h(o) || (m = [o, x], x = m[0], o = m[1]), f = new t(this, n, o), x != null && f.text(x), this.children.push(f), f;
          }, c.prototype.text = function(n) {
            var o;
            return o = new a(this, n), this.children.push(o), this;
          }, c.prototype.cdata = function(n) {
            var o;
            return o = new se(this, n), this.children.push(o), this;
          }, c.prototype.comment = function(n) {
            var o;
            return o = new Q(this, n), this.children.push(o), this;
          }, c.prototype.commentBefore = function(n) {
            var o, x;
            return o = this.parent.children.indexOf(this), x = this.parent.children.splice(o), this.parent.comment(n), Array.prototype.push.apply(this.parent.children, x), this;
          }, c.prototype.commentAfter = function(n) {
            var o, x;
            return o = this.parent.children.indexOf(this), x = this.parent.children.splice(o + 1), this.parent.comment(n), Array.prototype.push.apply(this.parent.children, x), this;
          }, c.prototype.raw = function(n) {
            var o;
            return o = new v(this, n), this.children.push(o), this;
          }, c.prototype.instruction = function(n, o) {
            var x, f, m, C, p;
            if (n != null && (n = e(n)), o != null && (o = e(o)), Array.isArray(n))
              for (C = 0, p = n.length; C < p; C++)
                x = n[C], this.instruction(x);
            else if (h(n))
              for (x in n)
                d.call(n, x) && (f = n[x], this.instruction(x, f));
            else
              r(o) && (o = o.apply()), m = new i(this, n, o), this.children.push(m);
            return this;
          }, c.prototype.instructionBefore = function(n, o) {
            var x, f;
            return x = this.parent.children.indexOf(this), f = this.parent.children.splice(x), this.parent.instruction(n, o), Array.prototype.push.apply(this.parent.children, f), this;
          }, c.prototype.instructionAfter = function(n, o) {
            var x, f;
            return x = this.parent.children.indexOf(this), f = this.parent.children.splice(x + 1), this.parent.instruction(n, o), Array.prototype.push.apply(this.parent.children, f), this;
          }, c.prototype.declaration = function(n, o, x) {
            var f, m;
            return f = this.document(), m = new u(f, n, o, x), f.children[0] instanceof u ? f.children[0] = m : f.children.unshift(m), f.root() || f;
          }, c.prototype.doctype = function(n, o) {
            var x, f, m, C, p, w, X, M, j, B;
            for (f = this.document(), m = new P(f, n, o), j = f.children, C = p = 0, X = j.length; p < X; C = ++p)
              if (x = j[C], x instanceof P)
                return f.children[C] = m, m;
            for (B = f.children, C = w = 0, M = B.length; w < M; C = ++w)
              if (x = B[C], x.isRoot)
                return f.children.splice(C, 0, m), m;
            return f.children.push(m), m;
          }, c.prototype.up = function() {
            if (this.isRoot)
              throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
            return this.parent;
          }, c.prototype.root = function() {
            var n;
            for (n = this; n; ) {
              if (n.isDocument)
                return n.rootObject;
              if (n.isRoot)
                return n;
              n = n.parent;
            }
          }, c.prototype.document = function() {
            var n;
            for (n = this; n; ) {
              if (n.isDocument)
                return n;
              n = n.parent;
            }
          }, c.prototype.end = function(n) {
            return this.document().end(n);
          }, c.prototype.prev = function() {
            var n;
            if (n = this.parent.children.indexOf(this), n < 1)
              throw new Error("Already at the first node. " + this.debugInfo());
            return this.parent.children[n - 1];
          }, c.prototype.next = function() {
            var n;
            if (n = this.parent.children.indexOf(this), n === -1 || n === this.parent.children.length - 1)
              throw new Error("Already at the last node. " + this.debugInfo());
            return this.parent.children[n + 1];
          }, c.prototype.importDocument = function(n) {
            var o;
            return o = n.root().clone(), o.parent = this, o.isRoot = !1, this.children.push(o), this;
          }, c.prototype.debugInfo = function(n) {
            var o, x;
            return n = n || this.name, n == null && !((o = this.parent) != null && o.name) ? "" : n == null ? "parent: <" + this.parent.name + ">" : (x = this.parent) != null && x.name ? "node: <" + n + ">, parent: <" + this.parent.name + ">" : "node: <" + n + ">";
          }, c.prototype.ele = function(n, o, x) {
            return this.element(n, o, x);
          }, c.prototype.nod = function(n, o, x) {
            return this.node(n, o, x);
          }, c.prototype.txt = function(n) {
            return this.text(n);
          }, c.prototype.dat = function(n) {
            return this.cdata(n);
          }, c.prototype.com = function(n) {
            return this.comment(n);
          }, c.prototype.ins = function(n, o) {
            return this.instruction(n, o);
          }, c.prototype.doc = function() {
            return this.document();
          }, c.prototype.dec = function(n, o, x) {
            return this.declaration(n, o, x);
          }, c.prototype.dtd = function(n, o) {
            return this.doctype(n, o);
          }, c.prototype.e = function(n, o, x) {
            return this.element(n, o, x);
          }, c.prototype.n = function(n, o, x) {
            return this.node(n, o, x);
          }, c.prototype.t = function(n) {
            return this.text(n);
          }, c.prototype.d = function(n) {
            return this.cdata(n);
          }, c.prototype.c = function(n) {
            return this.comment(n);
          }, c.prototype.r = function(n) {
            return this.raw(n);
          }, c.prototype.i = function(n, o) {
            return this.instruction(n, o);
          }, c.prototype.u = function() {
            return this.up();
          }, c.prototype.importXMLBuilder = function(n) {
            return this.importDocument(n);
          }, c;
        }();
      }).call(this);
    }, { "./Utility": 122, "./XMLCData": 124, "./XMLComment": 125, "./XMLDeclaration": 130, "./XMLDocType": 131, "./XMLElement": 134, "./XMLProcessingInstruction": 136, "./XMLRaw": 137, "./XMLText": 141 }], 136: [function(le, de, oe) {
      (function() {
        var se, Q = function(P, t) {
          for (var i in t)
            u.call(t, i) && (P[i] = t[i]);
          function v() {
            this.constructor = P;
          }
          return v.prototype = t.prototype, P.prototype = new v(), P.__super__ = t.prototype, P;
        }, u = {}.hasOwnProperty;
        se = le("./XMLNode"), de.exports = function(P) {
          Q(t, P);
          function t(i, v, a) {
            if (t.__super__.constructor.call(this, i), v == null)
              throw new Error("Missing instruction target. " + this.debugInfo());
            this.target = this.stringify.insTarget(v), a && (this.value = this.stringify.insValue(a));
          }
          return t.prototype.clone = function() {
            return Object.create(this);
          }, t.prototype.toString = function(i) {
            return this.options.writer.set(i).processingInstruction(this);
          }, t;
        }(se);
      }).call(this);
    }, { "./XMLNode": 135 }], 137: [function(le, de, oe) {
      (function() {
        var se, Q = function(P, t) {
          for (var i in t)
            u.call(t, i) && (P[i] = t[i]);
          function v() {
            this.constructor = P;
          }
          return v.prototype = t.prototype, P.prototype = new v(), P.__super__ = t.prototype, P;
        }, u = {}.hasOwnProperty;
        se = le("./XMLNode"), de.exports = function(P) {
          Q(t, P);
          function t(i, v) {
            if (t.__super__.constructor.call(this, i), v == null)
              throw new Error("Missing raw text. " + this.debugInfo());
            this.value = this.stringify.raw(v);
          }
          return t.prototype.clone = function() {
            return Object.create(this);
          }, t.prototype.toString = function(i) {
            return this.options.writer.set(i).raw(this);
          }, t;
        }(se);
      }).call(this);
    }, { "./XMLNode": 135 }], 138: [function(le, de, oe) {
      (function() {
        var se, Q, u, P, t, i, v, a, e, y, r, h, g, d = function(n, o) {
          for (var x in o)
            c.call(o, x) && (n[x] = o[x]);
          function f() {
            this.constructor = n;
          }
          return f.prototype = o.prototype, n.prototype = new f(), n.__super__ = o.prototype, n;
        }, c = {}.hasOwnProperty;
        v = le("./XMLDeclaration"), a = le("./XMLDocType"), se = le("./XMLCData"), Q = le("./XMLComment"), e = le("./XMLElement"), r = le("./XMLRaw"), h = le("./XMLText"), y = le("./XMLProcessingInstruction"), u = le("./XMLDTDAttList"), P = le("./XMLDTDElement"), t = le("./XMLDTDEntity"), i = le("./XMLDTDNotation"), g = le("./XMLWriterBase"), de.exports = function(n) {
          d(o, n);
          function o(x, f) {
            o.__super__.constructor.call(this, f), this.stream = x;
          }
          return o.prototype.document = function(x) {
            var f, m, C, p, w, X, M, j;
            for (X = x.children, m = 0, p = X.length; m < p; m++)
              f = X[m], f.isLastRootNode = !1;
            for (x.children[x.children.length - 1].isLastRootNode = !0, M = x.children, j = [], C = 0, w = M.length; C < w; C++)
              switch (f = M[C], !1) {
                case !(f instanceof v):
                  j.push(this.declaration(f));
                  break;
                case !(f instanceof a):
                  j.push(this.docType(f));
                  break;
                case !(f instanceof Q):
                  j.push(this.comment(f));
                  break;
                case !(f instanceof y):
                  j.push(this.processingInstruction(f));
                  break;
                default:
                  j.push(this.element(f));
              }
            return j;
          }, o.prototype.attribute = function(x) {
            return this.stream.write(" " + x.name + '="' + x.value + '"');
          }, o.prototype.cdata = function(x, f) {
            return this.stream.write(this.space(f) + "<![CDATA[" + x.text + "]]>" + this.endline(x));
          }, o.prototype.comment = function(x, f) {
            return this.stream.write(this.space(f) + "<!-- " + x.text + " -->" + this.endline(x));
          }, o.prototype.declaration = function(x, f) {
            return this.stream.write(this.space(f)), this.stream.write('<?xml version="' + x.version + '"'), x.encoding != null && this.stream.write(' encoding="' + x.encoding + '"'), x.standalone != null && this.stream.write(' standalone="' + x.standalone + '"'), this.stream.write(this.spacebeforeslash + "?>"), this.stream.write(this.endline(x));
          }, o.prototype.docType = function(x, f) {
            var m, C, p, w;
            if (f || (f = 0), this.stream.write(this.space(f)), this.stream.write("<!DOCTYPE " + x.root().name), x.pubID && x.sysID ? this.stream.write(' PUBLIC "' + x.pubID + '" "' + x.sysID + '"') : x.sysID && this.stream.write(' SYSTEM "' + x.sysID + '"'), x.children.length > 0) {
              for (this.stream.write(" ["), this.stream.write(this.endline(x)), w = x.children, C = 0, p = w.length; C < p; C++)
                switch (m = w[C], !1) {
                  case !(m instanceof u):
                    this.dtdAttList(m, f + 1);
                    break;
                  case !(m instanceof P):
                    this.dtdElement(m, f + 1);
                    break;
                  case !(m instanceof t):
                    this.dtdEntity(m, f + 1);
                    break;
                  case !(m instanceof i):
                    this.dtdNotation(m, f + 1);
                    break;
                  case !(m instanceof se):
                    this.cdata(m, f + 1);
                    break;
                  case !(m instanceof Q):
                    this.comment(m, f + 1);
                    break;
                  case !(m instanceof y):
                    this.processingInstruction(m, f + 1);
                    break;
                  default:
                    throw new Error("Unknown DTD node type: " + m.constructor.name);
                }
              this.stream.write("]");
            }
            return this.stream.write(this.spacebeforeslash + ">"), this.stream.write(this.endline(x));
          }, o.prototype.element = function(x, f) {
            var m, C, p, w, X, M, j, B;
            f || (f = 0), B = this.space(f), this.stream.write(B + "<" + x.name), M = x.attributes;
            for (X in M)
              c.call(M, X) && (m = M[X], this.attribute(m));
            if (x.children.length === 0 || x.children.every(function(R) {
              return R.value === "";
            }))
              this.allowEmpty ? this.stream.write("></" + x.name + ">") : this.stream.write(this.spacebeforeslash + "/>");
            else if (this.pretty && x.children.length === 1 && x.children[0].value != null)
              this.stream.write(">"), this.stream.write(x.children[0].value), this.stream.write("</" + x.name + ">");
            else {
              for (this.stream.write(">" + this.newline), j = x.children, p = 0, w = j.length; p < w; p++)
                switch (C = j[p], !1) {
                  case !(C instanceof se):
                    this.cdata(C, f + 1);
                    break;
                  case !(C instanceof Q):
                    this.comment(C, f + 1);
                    break;
                  case !(C instanceof e):
                    this.element(C, f + 1);
                    break;
                  case !(C instanceof r):
                    this.raw(C, f + 1);
                    break;
                  case !(C instanceof h):
                    this.text(C, f + 1);
                    break;
                  case !(C instanceof y):
                    this.processingInstruction(C, f + 1);
                    break;
                  default:
                    throw new Error("Unknown XML node type: " + C.constructor.name);
                }
              this.stream.write(B + "</" + x.name + ">");
            }
            return this.stream.write(this.endline(x));
          }, o.prototype.processingInstruction = function(x, f) {
            return this.stream.write(this.space(f) + "<?" + x.target), x.value && this.stream.write(" " + x.value), this.stream.write(this.spacebeforeslash + "?>" + this.endline(x));
          }, o.prototype.raw = function(x, f) {
            return this.stream.write(this.space(f) + x.value + this.endline(x));
          }, o.prototype.text = function(x, f) {
            return this.stream.write(this.space(f) + x.value + this.endline(x));
          }, o.prototype.dtdAttList = function(x, f) {
            return this.stream.write(this.space(f) + "<!ATTLIST " + x.elementName + " " + x.attributeName + " " + x.attributeType), x.defaultValueType !== "#DEFAULT" && this.stream.write(" " + x.defaultValueType), x.defaultValue && this.stream.write(' "' + x.defaultValue + '"'), this.stream.write(this.spacebeforeslash + ">" + this.endline(x));
          }, o.prototype.dtdElement = function(x, f) {
            return this.stream.write(this.space(f) + "<!ELEMENT " + x.name + " " + x.value), this.stream.write(this.spacebeforeslash + ">" + this.endline(x));
          }, o.prototype.dtdEntity = function(x, f) {
            return this.stream.write(this.space(f) + "<!ENTITY"), x.pe && this.stream.write(" %"), this.stream.write(" " + x.name), x.value ? this.stream.write(' "' + x.value + '"') : (x.pubID && x.sysID ? this.stream.write(' PUBLIC "' + x.pubID + '" "' + x.sysID + '"') : x.sysID && this.stream.write(' SYSTEM "' + x.sysID + '"'), x.nData && this.stream.write(" NDATA " + x.nData)), this.stream.write(this.spacebeforeslash + ">" + this.endline(x));
          }, o.prototype.dtdNotation = function(x, f) {
            return this.stream.write(this.space(f) + "<!NOTATION " + x.name), x.pubID && x.sysID ? this.stream.write(' PUBLIC "' + x.pubID + '" "' + x.sysID + '"') : x.pubID ? this.stream.write(' PUBLIC "' + x.pubID + '"') : x.sysID && this.stream.write(' SYSTEM "' + x.sysID + '"'), this.stream.write(this.spacebeforeslash + ">" + this.endline(x));
          }, o.prototype.endline = function(x) {
            return x.isLastRootNode ? "" : this.newline;
          }, o;
        }(g);
      }).call(this);
    }, { "./XMLCData": 124, "./XMLComment": 125, "./XMLDTDAttList": 126, "./XMLDTDElement": 127, "./XMLDTDEntity": 128, "./XMLDTDNotation": 129, "./XMLDeclaration": 130, "./XMLDocType": 131, "./XMLElement": 134, "./XMLProcessingInstruction": 136, "./XMLRaw": 137, "./XMLText": 141, "./XMLWriterBase": 142 }], 139: [function(le, de, oe) {
      (function() {
        var se, Q, u, P, t, i, v, a, e, y, r, h, g, d = function(n, o) {
          for (var x in o)
            c.call(o, x) && (n[x] = o[x]);
          function f() {
            this.constructor = n;
          }
          return f.prototype = o.prototype, n.prototype = new f(), n.__super__ = o.prototype, n;
        }, c = {}.hasOwnProperty;
        v = le("./XMLDeclaration"), a = le("./XMLDocType"), se = le("./XMLCData"), Q = le("./XMLComment"), e = le("./XMLElement"), r = le("./XMLRaw"), h = le("./XMLText"), y = le("./XMLProcessingInstruction"), u = le("./XMLDTDAttList"), P = le("./XMLDTDElement"), t = le("./XMLDTDEntity"), i = le("./XMLDTDNotation"), g = le("./XMLWriterBase"), de.exports = function(n) {
          d(o, n);
          function o(x) {
            o.__super__.constructor.call(this, x);
          }
          return o.prototype.document = function(x) {
            var f, m, C, p, w;
            for (this.textispresent = !1, p = "", w = x.children, m = 0, C = w.length; m < C; m++)
              f = w[m], p += function() {
                switch (!1) {
                  case !(f instanceof v):
                    return this.declaration(f);
                  case !(f instanceof a):
                    return this.docType(f);
                  case !(f instanceof Q):
                    return this.comment(f);
                  case !(f instanceof y):
                    return this.processingInstruction(f);
                  default:
                    return this.element(f, 0);
                }
              }.call(this);
            return this.pretty && p.slice(-this.newline.length) === this.newline && (p = p.slice(0, -this.newline.length)), p;
          }, o.prototype.attribute = function(x) {
            return " " + x.name + '="' + x.value + '"';
          }, o.prototype.cdata = function(x, f) {
            return this.space(f) + "<![CDATA[" + x.text + "]]>" + this.newline;
          }, o.prototype.comment = function(x, f) {
            return this.space(f) + "<!-- " + x.text + " -->" + this.newline;
          }, o.prototype.declaration = function(x, f) {
            var m;
            return m = this.space(f), m += '<?xml version="' + x.version + '"', x.encoding != null && (m += ' encoding="' + x.encoding + '"'), x.standalone != null && (m += ' standalone="' + x.standalone + '"'), m += this.spacebeforeslash + "?>", m += this.newline, m;
          }, o.prototype.docType = function(x, f) {
            var m, C, p, w, X;
            if (f || (f = 0), w = this.space(f), w += "<!DOCTYPE " + x.root().name, x.pubID && x.sysID ? w += ' PUBLIC "' + x.pubID + '" "' + x.sysID + '"' : x.sysID && (w += ' SYSTEM "' + x.sysID + '"'), x.children.length > 0) {
              for (w += " [", w += this.newline, X = x.children, C = 0, p = X.length; C < p; C++)
                m = X[C], w += function() {
                  switch (!1) {
                    case !(m instanceof u):
                      return this.dtdAttList(m, f + 1);
                    case !(m instanceof P):
                      return this.dtdElement(m, f + 1);
                    case !(m instanceof t):
                      return this.dtdEntity(m, f + 1);
                    case !(m instanceof i):
                      return this.dtdNotation(m, f + 1);
                    case !(m instanceof se):
                      return this.cdata(m, f + 1);
                    case !(m instanceof Q):
                      return this.comment(m, f + 1);
                    case !(m instanceof y):
                      return this.processingInstruction(m, f + 1);
                    default:
                      throw new Error("Unknown DTD node type: " + m.constructor.name);
                  }
                }.call(this);
              w += "]";
            }
            return w += this.spacebeforeslash + ">", w += this.newline, w;
          }, o.prototype.element = function(x, f) {
            var m, C, p, w, X, M, j, B, R, D, b, l, _;
            f || (f = 0), _ = !1, this.textispresent ? (this.newline = "", this.pretty = !1) : (this.newline = this.newlinedefault, this.pretty = this.prettydefault), l = this.space(f), B = "", B += l + "<" + x.name, R = x.attributes;
            for (j in R)
              c.call(R, j) && (m = R[j], B += this.attribute(m));
            if (x.children.length === 0 || x.children.every(function(S) {
              return S.value === "";
            }))
              this.allowEmpty ? B += "></" + x.name + ">" + this.newline : B += this.spacebeforeslash + "/>" + this.newline;
            else if (this.pretty && x.children.length === 1 && x.children[0].value != null)
              B += ">", B += x.children[0].value, B += "</" + x.name + ">" + this.newline;
            else {
              if (this.dontprettytextnodes) {
                for (D = x.children, p = 0, X = D.length; p < X; p++)
                  if (C = D[p], C.value != null) {
                    this.textispresent++, _ = !0;
                    break;
                  }
              }
              for (this.textispresent && (this.newline = "", this.pretty = !1, l = this.space(f)), B += ">" + this.newline, b = x.children, w = 0, M = b.length; w < M; w++)
                C = b[w], B += function() {
                  switch (!1) {
                    case !(C instanceof se):
                      return this.cdata(C, f + 1);
                    case !(C instanceof Q):
                      return this.comment(C, f + 1);
                    case !(C instanceof e):
                      return this.element(C, f + 1);
                    case !(C instanceof r):
                      return this.raw(C, f + 1);
                    case !(C instanceof h):
                      return this.text(C, f + 1);
                    case !(C instanceof y):
                      return this.processingInstruction(C, f + 1);
                    default:
                      throw new Error("Unknown XML node type: " + C.constructor.name);
                  }
                }.call(this);
              _ && this.textispresent--, this.textispresent || (this.newline = this.newlinedefault, this.pretty = this.prettydefault), B += l + "</" + x.name + ">" + this.newline;
            }
            return B;
          }, o.prototype.processingInstruction = function(x, f) {
            var m;
            return m = this.space(f) + "<?" + x.target, x.value && (m += " " + x.value), m += this.spacebeforeslash + "?>" + this.newline, m;
          }, o.prototype.raw = function(x, f) {
            return this.space(f) + x.value + this.newline;
          }, o.prototype.text = function(x, f) {
            return this.space(f) + x.value + this.newline;
          }, o.prototype.dtdAttList = function(x, f) {
            var m;
            return m = this.space(f) + "<!ATTLIST " + x.elementName + " " + x.attributeName + " " + x.attributeType, x.defaultValueType !== "#DEFAULT" && (m += " " + x.defaultValueType), x.defaultValue && (m += ' "' + x.defaultValue + '"'), m += this.spacebeforeslash + ">" + this.newline, m;
          }, o.prototype.dtdElement = function(x, f) {
            return this.space(f) + "<!ELEMENT " + x.name + " " + x.value + this.spacebeforeslash + ">" + this.newline;
          }, o.prototype.dtdEntity = function(x, f) {
            var m;
            return m = this.space(f) + "<!ENTITY", x.pe && (m += " %"), m += " " + x.name, x.value ? m += ' "' + x.value + '"' : (x.pubID && x.sysID ? m += ' PUBLIC "' + x.pubID + '" "' + x.sysID + '"' : x.sysID && (m += ' SYSTEM "' + x.sysID + '"'), x.nData && (m += " NDATA " + x.nData)), m += this.spacebeforeslash + ">" + this.newline, m;
          }, o.prototype.dtdNotation = function(x, f) {
            var m;
            return m = this.space(f) + "<!NOTATION " + x.name, x.pubID && x.sysID ? m += ' PUBLIC "' + x.pubID + '" "' + x.sysID + '"' : x.pubID ? m += ' PUBLIC "' + x.pubID + '"' : x.sysID && (m += ' SYSTEM "' + x.sysID + '"'), m += this.spacebeforeslash + ">" + this.newline, m;
          }, o.prototype.openNode = function(x, f) {
            var m, C, p, w;
            if (f || (f = 0), x instanceof e) {
              p = this.space(f) + "<" + x.name, w = x.attributes;
              for (C in w)
                c.call(w, C) && (m = w[C], p += this.attribute(m));
              return p += (x.children ? ">" : "/>") + this.newline, p;
            } else
              return p = this.space(f) + "<!DOCTYPE " + x.rootNodeName, x.pubID && x.sysID ? p += ' PUBLIC "' + x.pubID + '" "' + x.sysID + '"' : x.sysID && (p += ' SYSTEM "' + x.sysID + '"'), p += (x.children ? " [" : ">") + this.newline, p;
          }, o.prototype.closeNode = function(x, f) {
            switch (f || (f = 0), !1) {
              case !(x instanceof e):
                return this.space(f) + "</" + x.name + ">" + this.newline;
              case !(x instanceof a):
                return this.space(f) + "]>" + this.newline;
            }
          }, o;
        }(g);
      }).call(this);
    }, { "./XMLCData": 124, "./XMLComment": 125, "./XMLDTDAttList": 126, "./XMLDTDElement": 127, "./XMLDTDEntity": 128, "./XMLDTDNotation": 129, "./XMLDeclaration": 130, "./XMLDocType": 131, "./XMLElement": 134, "./XMLProcessingInstruction": 136, "./XMLRaw": 137, "./XMLText": 141, "./XMLWriterBase": 142 }], 140: [function(le, de, oe) {
      (function() {
        var se = function(u, P) {
          return function() {
            return u.apply(P, arguments);
          };
        }, Q = {}.hasOwnProperty;
        de.exports = function() {
          function u(P) {
            this.assertLegalChar = se(this.assertLegalChar, this);
            var t, i, v;
            P || (P = {}), this.noDoubleEncoding = P.noDoubleEncoding, i = P.stringify || {};
            for (t in i)
              Q.call(i, t) && (v = i[t], this[t] = v);
          }
          return u.prototype.eleName = function(P) {
            return P = "" + P || "", this.assertLegalChar(P);
          }, u.prototype.eleText = function(P) {
            return P = "" + P || "", this.assertLegalChar(this.elEscape(P));
          }, u.prototype.cdata = function(P) {
            return P = "" + P || "", P = P.replace("]]>", "]]]]><![CDATA[>"), this.assertLegalChar(P);
          }, u.prototype.comment = function(P) {
            if (P = "" + P || "", P.match(/--/))
              throw new Error("Comment text cannot contain double-hypen: " + P);
            return this.assertLegalChar(P);
          }, u.prototype.raw = function(P) {
            return "" + P || "";
          }, u.prototype.attName = function(P) {
            return P = "" + P || "";
          }, u.prototype.attValue = function(P) {
            return P = "" + P || "", this.attEscape(P);
          }, u.prototype.insTarget = function(P) {
            return "" + P || "";
          }, u.prototype.insValue = function(P) {
            if (P = "" + P || "", P.match(/\?>/))
              throw new Error("Invalid processing instruction value: " + P);
            return P;
          }, u.prototype.xmlVersion = function(P) {
            if (P = "" + P || "", !P.match(/1\.[0-9]+/))
              throw new Error("Invalid version number: " + P);
            return P;
          }, u.prototype.xmlEncoding = function(P) {
            if (P = "" + P || "", !P.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/))
              throw new Error("Invalid encoding: " + P);
            return P;
          }, u.prototype.xmlStandalone = function(P) {
            return P ? "yes" : "no";
          }, u.prototype.dtdPubID = function(P) {
            return "" + P || "";
          }, u.prototype.dtdSysID = function(P) {
            return "" + P || "";
          }, u.prototype.dtdElementValue = function(P) {
            return "" + P || "";
          }, u.prototype.dtdAttType = function(P) {
            return "" + P || "";
          }, u.prototype.dtdAttDefault = function(P) {
            return P != null ? "" + P || "" : P;
          }, u.prototype.dtdEntityValue = function(P) {
            return "" + P || "";
          }, u.prototype.dtdNData = function(P) {
            return "" + P || "";
          }, u.prototype.convertAttKey = "@", u.prototype.convertPIKey = "?", u.prototype.convertTextKey = "#text", u.prototype.convertCDataKey = "#cdata", u.prototype.convertCommentKey = "#comment", u.prototype.convertRawKey = "#raw", u.prototype.assertLegalChar = function(P) {
            var t;
            if (t = P.match(/[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/), t)
              throw new Error("Invalid character in string: " + P + " at index " + t.index);
            return P;
          }, u.prototype.elEscape = function(P) {
            var t;
            return t = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g, P.replace(t, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;");
          }, u.prototype.attEscape = function(P) {
            var t;
            return t = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g, P.replace(t, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
          }, u;
        }();
      }).call(this);
    }, {}], 141: [function(le, de, oe) {
      (function() {
        var se, Q = function(P, t) {
          for (var i in t)
            u.call(t, i) && (P[i] = t[i]);
          function v() {
            this.constructor = P;
          }
          return v.prototype = t.prototype, P.prototype = new v(), P.__super__ = t.prototype, P;
        }, u = {}.hasOwnProperty;
        se = le("./XMLNode"), de.exports = function(P) {
          Q(t, P);
          function t(i, v) {
            if (t.__super__.constructor.call(this, i), v == null)
              throw new Error("Missing element text. " + this.debugInfo());
            this.value = this.stringify.eleText(v);
          }
          return t.prototype.clone = function() {
            return Object.create(this);
          }, t.prototype.toString = function(i) {
            return this.options.writer.set(i).text(this);
          }, t;
        }(se);
      }).call(this);
    }, { "./XMLNode": 135 }], 142: [function(le, de, oe) {
      (function() {
        var se = {}.hasOwnProperty;
        de.exports = function() {
          function Q(u) {
            var P, t, i, v, a, e, y, r, h;
            u || (u = {}), this.pretty = u.pretty || !1, this.allowEmpty = (t = u.allowEmpty) != null ? t : !1, this.pretty ? (this.indent = (i = u.indent) != null ? i : "  ", this.newline = (v = u.newline) != null ? v : `
`, this.offset = (a = u.offset) != null ? a : 0, this.dontprettytextnodes = (e = u.dontprettytextnodes) != null ? e : 0) : (this.indent = "", this.newline = "", this.offset = 0, this.dontprettytextnodes = 0), this.spacebeforeslash = (y = u.spacebeforeslash) != null ? y : "", this.spacebeforeslash === !0 && (this.spacebeforeslash = " "), this.newlinedefault = this.newline, this.prettydefault = this.pretty, r = u.writer || {};
            for (P in r)
              se.call(r, P) && (h = r[P], this[P] = h);
          }
          return Q.prototype.set = function(u) {
            var P, t, i;
            u || (u = {}), "pretty" in u && (this.pretty = u.pretty), "allowEmpty" in u && (this.allowEmpty = u.allowEmpty), this.pretty ? (this.indent = "indent" in u ? u.indent : "  ", this.newline = "newline" in u ? u.newline : `
`, this.offset = "offset" in u ? u.offset : 0, this.dontprettytextnodes = "dontprettytextnodes" in u ? u.dontprettytextnodes : 0) : (this.indent = "", this.newline = "", this.offset = 0, this.dontprettytextnodes = 0), this.spacebeforeslash = "spacebeforeslash" in u ? u.spacebeforeslash : "", this.spacebeforeslash === !0 && (this.spacebeforeslash = " "), this.newlinedefault = this.newline, this.prettydefault = this.pretty, t = u.writer || {};
            for (P in t)
              se.call(t, P) && (i = t[P], this[P] = i);
            return this;
          }, Q.prototype.space = function(u) {
            var P;
            return this.pretty ? (P = (u || 0) + this.offset + 1, P > 0 ? new Array(P).join(this.indent) : "") : "";
          }, Q;
        }();
      }).call(this);
    }, {}], 143: [function(le, de, oe) {
      (function() {
        var se, Q, u, P, t, i, v;
        v = le("./Utility"), t = v.assign, i = v.isFunction, se = le("./XMLDocument"), Q = le("./XMLDocumentCB"), P = le("./XMLStringWriter"), u = le("./XMLStreamWriter"), de.exports.create = function(a, e, y, r) {
          var h, g;
          if (a == null)
            throw new Error("Root element needs a name.");
          return r = t({}, e, y, r), h = new se(r), g = h.element(a), r.headless || (h.declaration(r), (r.pubID != null || r.sysID != null) && h.doctype(r)), g;
        }, de.exports.begin = function(a, e, y) {
          var r;
          return i(a) && (r = [a, e], e = r[0], y = r[1], a = {}), e ? new Q(a, e, y) : new se(a);
        }, de.exports.stringWriter = function(a) {
          return new P(a);
        }, de.exports.streamWriter = function(a, e) {
          return new u(a, e);
        };
      }).call(this);
    }, { "./Utility": 122, "./XMLDocument": 132, "./XMLDocumentCB": 133, "./XMLStreamWriter": 138, "./XMLStringWriter": 139 }] }, {}, [21])(21);
  });
})(mammoth_browser);
const wrapper$2 = "_wrapper_1n25d_1", thumbnail = "_thumbnail_1n25d_9", loading = "_loading_1n25d_14", s$2 = {
  wrapper: wrapper$2,
  thumbnail,
  loading
}, wrapper$1 = "_wrapper_1awyo_1", s$1 = {
  wrapper: wrapper$1
}, wrapper = "_wrapper_lm3j5_1", viewer = "_viewer_lm3j5_7", s = {
  wrapper,
  viewer
};
