var fr = Object.defineProperty;
var gr = (be, ge, le) => ge in be ? fr(be, ge, { enumerable: !0, configurable: !0, writable: !0, value: le }) : be[ge] = le;
var on = (be, ge, le) => (gr(be, typeof ge != "symbol" ? ge + "" : ge, le), le), hi = (be, ge, le) => {
  if (!ge.has(be))
    throw TypeError("Cannot " + le);
};
var Oe = (be, ge, le) => (hi(be, ge, "read from private field"), le ? le.call(be) : ge.get(be)), gt = (be, ge, le) => {
  if (ge.has(be))
    throw TypeError("Cannot add the same private member more than once");
  ge instanceof WeakSet ? ge.add(be) : ge.set(be, le);
}, Ft = (be, ge, le, ce) => (hi(be, ge, "write to private field"), ce ? ce.call(be, le) : ge.set(be, le), le), di = (be, ge, le, ce) => ({
  set _(re) {
    Ft(be, ge, re, le);
  },
  get _() {
    return Oe(be, ge, ce);
  }
}), At = (be, ge, le) => (hi(be, ge, "access private method"), le);
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(be) {
  return be && be.__esModule && Object.prototype.hasOwnProperty.call(be, "default") ? be.default : be;
}
function getAugmentedNamespace(be) {
  if (be.__esModule)
    return be;
  var ge = be.default;
  if (typeof ge == "function") {
    var le = function ce() {
      if (this instanceof ce) {
        var re = [null];
        re.push.apply(re, arguments);
        var ae = Function.bind.apply(ge, re);
        return new ae();
      }
      return ge.apply(this, arguments);
    };
    le.prototype = ge.prototype;
  } else
    le = {};
  return Object.defineProperty(le, "__esModule", { value: !0 }), Object.keys(be).forEach(function(ce) {
    var re = Object.getOwnPropertyDescriptor(be, ce);
    Object.defineProperty(le, ce, re.get ? re : {
      enumerable: !0,
      get: function() {
        return be[ce];
      }
    });
  }), le;
}
var jsxRuntimeExports = {}, jsxRuntime = {
  get exports() {
    return jsxRuntimeExports;
  },
  set exports(be) {
    jsxRuntimeExports = be;
  }
}, reactJsxRuntime_production_min = {}, reactExports$1 = {}, react = {
  get exports() {
    return reactExports$1;
  },
  set exports(be) {
    reactExports$1 = be;
  }
}, react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReact_production_min;
function requireReact_production_min() {
  if (hasRequiredReact_production_min)
    return react_production_min;
  hasRequiredReact_production_min = 1;
  var be = Symbol.for("react.element"), ge = Symbol.for("react.portal"), le = Symbol.for("react.fragment"), ce = Symbol.for("react.strict_mode"), re = Symbol.for("react.profiler"), ae = Symbol.for("react.provider"), J = Symbol.for("react.context"), o = Symbol.for("react.forward_ref"), F = Symbol.for("react.suspense"), t = Symbol.for("react.memo"), a = Symbol.for("react.lazy"), v = Symbol.iterator;
  function h(D) {
    return D === null || typeof D != "object" ? null : (D = v && D[v] || D["@@iterator"], typeof D == "function" ? D : null);
  }
  var e = { isMounted: function() {
    return !1;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, y = Object.assign, c = {};
  function d(D, _, S) {
    this.props = D, this.context = _, this.refs = c, this.updater = S || e;
  }
  d.prototype.isReactComponent = {}, d.prototype.setState = function(D, _) {
    if (typeof D != "object" && typeof D != "function" && D != null)
      throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, D, _, "setState");
  }, d.prototype.forceUpdate = function(D) {
    this.updater.enqueueForceUpdate(this, D, "forceUpdate");
  };
  function m() {
  }
  m.prototype = d.prototype;
  function p(D, _, S) {
    this.props = D, this.context = _, this.refs = c, this.updater = S || e;
  }
  var g = p.prototype = new m();
  g.constructor = p, y(g, d.prototype), g.isPureReactComponent = !0;
  var n = Array.isArray, i = Object.prototype.hasOwnProperty, l = { current: null }, u = { key: !0, ref: !0, __self: !0, __source: !0 };
  function w(D, _, S) {
    var C, T = {}, P = null, M = null;
    if (_ != null)
      for (C in _.ref !== void 0 && (M = _.ref), _.key !== void 0 && (P = "" + _.key), _)
        i.call(_, C) && !u.hasOwnProperty(C) && (T[C] = _[C]);
    var G = arguments.length - 2;
    if (G === 1)
      T.children = S;
    else if (1 < G) {
      for (var Z = Array(G), $ = 0; $ < G; $++)
        Z[$] = arguments[$ + 2];
      T.children = Z;
    }
    if (D && D.defaultProps)
      for (C in G = D.defaultProps, G)
        T[C] === void 0 && (T[C] = G[C]);
    return { $$typeof: be, type: D, key: P, ref: M, props: T, _owner: l.current };
  }
  function O(D, _) {
    return { $$typeof: be, type: D.type, key: _, ref: D.ref, props: D.props, _owner: D._owner };
  }
  function b(D) {
    return typeof D == "object" && D !== null && D.$$typeof === be;
  }
  function A(D) {
    var _ = { "=": "=0", ":": "=2" };
    return "$" + D.replace(/[=:]/g, function(S) {
      return _[S];
    });
  }
  var Y = /\/+/g;
  function j(D, _) {
    return typeof D == "object" && D !== null && D.key != null ? A("" + D.key) : _.toString(36);
  }
  function X(D, _, S, C, T) {
    var P = typeof D;
    (P === "undefined" || P === "boolean") && (D = null);
    var M = !1;
    if (D === null)
      M = !0;
    else
      switch (P) {
        case "string":
        case "number":
          M = !0;
          break;
        case "object":
          switch (D.$$typeof) {
            case be:
            case ge:
              M = !0;
          }
      }
    if (M)
      return M = D, T = T(M), D = C === "" ? "." + j(M, 0) : C, n(T) ? (S = "", D != null && (S = D.replace(Y, "$&/") + "/"), X(T, _, S, "", function($) {
        return $;
      })) : T != null && (b(T) && (T = O(T, S + (!T.key || M && M.key === T.key ? "" : ("" + T.key).replace(Y, "$&/") + "/") + D)), _.push(T)), 1;
    if (M = 0, C = C === "" ? "." : C + ":", n(D))
      for (var G = 0; G < D.length; G++) {
        P = D[G];
        var Z = C + j(P, G);
        M += X(P, _, S, Z, T);
      }
    else if (Z = h(D), typeof Z == "function")
      for (D = Z.call(D), G = 0; !(P = D.next()).done; )
        P = P.value, Z = C + j(P, G++), M += X(P, _, S, Z, T);
    else if (P === "object")
      throw _ = String(D), Error("Objects are not valid as a React child (found: " + (_ === "[object Object]" ? "object with keys {" + Object.keys(D).join(", ") + "}" : _) + "). If you meant to render a collection of children, use an array instead.");
    return M;
  }
  function B(D, _, S) {
    if (D == null)
      return D;
    var C = [], T = 0;
    return X(D, C, "", "", function(P) {
      return _.call(S, P, T++);
    }), C;
  }
  function U(D) {
    if (D._status === -1) {
      var _ = D._result;
      _ = _(), _.then(function(S) {
        (D._status === 0 || D._status === -1) && (D._status = 1, D._result = S);
      }, function(S) {
        (D._status === 0 || D._status === -1) && (D._status = 2, D._result = S);
      }), D._status === -1 && (D._status = 0, D._result = _);
    }
    if (D._status === 1)
      return D._result.default;
    throw D._result;
  }
  var k = { current: null }, x = { transition: null }, f = { ReactCurrentDispatcher: k, ReactCurrentBatchConfig: x, ReactCurrentOwner: l };
  return react_production_min.Children = { map: B, forEach: function(D, _, S) {
    B(D, function() {
      _.apply(this, arguments);
    }, S);
  }, count: function(D) {
    var _ = 0;
    return B(D, function() {
      _++;
    }), _;
  }, toArray: function(D) {
    return B(D, function(_) {
      return _;
    }) || [];
  }, only: function(D) {
    if (!b(D))
      throw Error("React.Children.only expected to receive a single React element child.");
    return D;
  } }, react_production_min.Component = d, react_production_min.Fragment = le, react_production_min.Profiler = re, react_production_min.PureComponent = p, react_production_min.StrictMode = ce, react_production_min.Suspense = F, react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = f, react_production_min.cloneElement = function(D, _, S) {
    if (D == null)
      throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + D + ".");
    var C = y({}, D.props), T = D.key, P = D.ref, M = D._owner;
    if (_ != null) {
      if (_.ref !== void 0 && (P = _.ref, M = l.current), _.key !== void 0 && (T = "" + _.key), D.type && D.type.defaultProps)
        var G = D.type.defaultProps;
      for (Z in _)
        i.call(_, Z) && !u.hasOwnProperty(Z) && (C[Z] = _[Z] === void 0 && G !== void 0 ? G[Z] : _[Z]);
    }
    var Z = arguments.length - 2;
    if (Z === 1)
      C.children = S;
    else if (1 < Z) {
      G = Array(Z);
      for (var $ = 0; $ < Z; $++)
        G[$] = arguments[$ + 2];
      C.children = G;
    }
    return { $$typeof: be, type: D.type, key: T, ref: P, props: C, _owner: M };
  }, react_production_min.createContext = function(D) {
    return D = { $$typeof: J, _currentValue: D, _currentValue2: D, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, D.Provider = { $$typeof: ae, _context: D }, D.Consumer = D;
  }, react_production_min.createElement = w, react_production_min.createFactory = function(D) {
    var _ = w.bind(null, D);
    return _.type = D, _;
  }, react_production_min.createRef = function() {
    return { current: null };
  }, react_production_min.forwardRef = function(D) {
    return { $$typeof: o, render: D };
  }, react_production_min.isValidElement = b, react_production_min.lazy = function(D) {
    return { $$typeof: a, _payload: { _status: -1, _result: D }, _init: U };
  }, react_production_min.memo = function(D, _) {
    return { $$typeof: t, type: D, compare: _ === void 0 ? null : _ };
  }, react_production_min.startTransition = function(D) {
    var _ = x.transition;
    x.transition = {};
    try {
      D();
    } finally {
      x.transition = _;
    }
  }, react_production_min.unstable_act = function() {
    throw Error("act(...) is not supported in production builds of React.");
  }, react_production_min.useCallback = function(D, _) {
    return k.current.useCallback(D, _);
  }, react_production_min.useContext = function(D) {
    return k.current.useContext(D);
  }, react_production_min.useDebugValue = function() {
  }, react_production_min.useDeferredValue = function(D) {
    return k.current.useDeferredValue(D);
  }, react_production_min.useEffect = function(D, _) {
    return k.current.useEffect(D, _);
  }, react_production_min.useId = function() {
    return k.current.useId();
  }, react_production_min.useImperativeHandle = function(D, _, S) {
    return k.current.useImperativeHandle(D, _, S);
  }, react_production_min.useInsertionEffect = function(D, _) {
    return k.current.useInsertionEffect(D, _);
  }, react_production_min.useLayoutEffect = function(D, _) {
    return k.current.useLayoutEffect(D, _);
  }, react_production_min.useMemo = function(D, _) {
    return k.current.useMemo(D, _);
  }, react_production_min.useReducer = function(D, _, S) {
    return k.current.useReducer(D, _, S);
  }, react_production_min.useRef = function(D) {
    return k.current.useRef(D);
  }, react_production_min.useState = function(D) {
    return k.current.useState(D);
  }, react_production_min.useSyncExternalStore = function(D, _, S) {
    return k.current.useSyncExternalStore(D, _, S);
  }, react_production_min.useTransition = function() {
    return k.current.useTransition();
  }, react_production_min.version = "18.2.0", react_production_min;
}
var react_developmentExports = {}, react_development = {
  get exports() {
    return react_developmentExports;
  },
  set exports(be) {
    react_developmentExports = be;
  }
};
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReact_development;
function requireReact_development() {
  return hasRequiredReact_development || (hasRequiredReact_development = 1, function(be, ge) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var le = "18.2.0", ce = Symbol.for("react.element"), re = Symbol.for("react.portal"), ae = Symbol.for("react.fragment"), J = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), F = Symbol.for("react.provider"), t = Symbol.for("react.context"), a = Symbol.for("react.forward_ref"), v = Symbol.for("react.suspense"), h = Symbol.for("react.suspense_list"), e = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), c = Symbol.for("react.offscreen"), d = Symbol.iterator, m = "@@iterator";
      function p(we) {
        if (we === null || typeof we != "object")
          return null;
        var Re = d && we[d] || we[m];
        return typeof Re == "function" ? Re : null;
      }
      var g = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, n = {
        transition: null
      }, i = {
        current: null,
        // Used to reproduce behavior of `batchedUpdates` in legacy mode.
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1
      }, l = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, u = {}, w = null;
      function O(we) {
        w = we;
      }
      u.setExtraStackFrame = function(we) {
        w = we;
      }, u.getCurrentStack = null, u.getStackAddendum = function() {
        var we = "";
        w && (we += w);
        var Re = u.getCurrentStack;
        return Re && (we += Re() || ""), we;
      };
      var b = !1, A = !1, Y = !1, j = !1, X = !1, B = {
        ReactCurrentDispatcher: g,
        ReactCurrentBatchConfig: n,
        ReactCurrentOwner: l
      };
      B.ReactDebugCurrentFrame = u, B.ReactCurrentActQueue = i;
      function U(we) {
        {
          for (var Re = arguments.length, et = new Array(Re > 1 ? Re - 1 : 0), Ke = 1; Ke < Re; Ke++)
            et[Ke - 1] = arguments[Ke];
          x("warn", we, et);
        }
      }
      function k(we) {
        {
          for (var Re = arguments.length, et = new Array(Re > 1 ? Re - 1 : 0), Ke = 1; Ke < Re; Ke++)
            et[Ke - 1] = arguments[Ke];
          x("error", we, et);
        }
      }
      function x(we, Re, et) {
        {
          var Ke = B.ReactDebugCurrentFrame, ut = Ke.getStackAddendum();
          ut !== "" && (Re += "%s", et = et.concat([ut]));
          var Lt = et.map(function(vt) {
            return String(vt);
          });
          Lt.unshift("Warning: " + Re), Function.prototype.apply.call(console[we], console, Lt);
        }
      }
      var f = {};
      function D(we, Re) {
        {
          var et = we.constructor, Ke = et && (et.displayName || et.name) || "ReactClass", ut = Ke + "." + Re;
          if (f[ut])
            return;
          k("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", Re, Ke), f[ut] = !0;
        }
      }
      var _ = {
        /**
         * Checks whether or not this composite component is mounted.
         * @param {ReactClass} publicInstance The instance we want to test.
         * @return {boolean} True if mounted, false otherwise.
         * @protected
         * @final
         */
        isMounted: function(we) {
          return !1;
        },
        /**
         * Forces an update. This should only be invoked when it is known with
         * certainty that we are **not** in a DOM transaction.
         *
         * You may want to call this when you know that some deeper aspect of the
         * component's state has changed but `setState` was not called.
         *
         * This will not invoke `shouldComponentUpdate`, but it will invoke
         * `componentWillUpdate` and `componentDidUpdate`.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueForceUpdate: function(we, Re, et) {
          D(we, "forceUpdate");
        },
        /**
         * Replaces all of the state. Always use this or `setState` to mutate state.
         * You should treat `this.state` as immutable.
         *
         * There is no guarantee that `this.state` will be immediately updated, so
         * accessing `this.state` after calling this method may return the old value.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} completeState Next state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueReplaceState: function(we, Re, et, Ke) {
          D(we, "replaceState");
        },
        /**
         * Sets a subset of the state. This only exists because _pendingState is
         * internal. This provides a merging strategy that is not available to deep
         * properties which is confusing. TODO: Expose pendingState or don't use it
         * during the merge.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} partialState Next partial state to be merged with state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} Name of the calling function in the public API.
         * @internal
         */
        enqueueSetState: function(we, Re, et, Ke) {
          D(we, "setState");
        }
      }, S = Object.assign, C = {};
      Object.freeze(C);
      function T(we, Re, et) {
        this.props = we, this.context = Re, this.refs = C, this.updater = et || _;
      }
      T.prototype.isReactComponent = {}, T.prototype.setState = function(we, Re) {
        if (typeof we != "object" && typeof we != "function" && we != null)
          throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, we, Re, "setState");
      }, T.prototype.forceUpdate = function(we) {
        this.updater.enqueueForceUpdate(this, we, "forceUpdate");
      };
      {
        var P = {
          isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
          replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
        }, M = function(we, Re) {
          Object.defineProperty(T.prototype, we, {
            get: function() {
              U("%s(...) is deprecated in plain JavaScript React classes. %s", Re[0], Re[1]);
            }
          });
        };
        for (var G in P)
          P.hasOwnProperty(G) && M(G, P[G]);
      }
      function Z() {
      }
      Z.prototype = T.prototype;
      function $(we, Re, et) {
        this.props = we, this.context = Re, this.refs = C, this.updater = et || _;
      }
      var z = $.prototype = new Z();
      z.constructor = $, S(z, T.prototype), z.isPureReactComponent = !0;
      function V() {
        var we = {
          current: null
        };
        return Object.seal(we), we;
      }
      var L = Array.isArray;
      function K(we) {
        return L(we);
      }
      function ne(we) {
        {
          var Re = typeof Symbol == "function" && Symbol.toStringTag, et = Re && we[Symbol.toStringTag] || we.constructor.name || "Object";
          return et;
        }
      }
      function se(we) {
        try {
          return q(we), !1;
        } catch {
          return !0;
        }
      }
      function q(we) {
        return "" + we;
      }
      function N(we) {
        if (se(we))
          return k("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", ne(we)), q(we);
      }
      function Q(we, Re, et) {
        var Ke = we.displayName;
        if (Ke)
          return Ke;
        var ut = Re.displayName || Re.name || "";
        return ut !== "" ? et + "(" + ut + ")" : et;
      }
      function E(we) {
        return we.displayName || "Context";
      }
      function te(we) {
        if (we == null)
          return null;
        if (typeof we.tag == "number" && k("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof we == "function")
          return we.displayName || we.name || null;
        if (typeof we == "string")
          return we;
        switch (we) {
          case ae:
            return "Fragment";
          case re:
            return "Portal";
          case o:
            return "Profiler";
          case J:
            return "StrictMode";
          case v:
            return "Suspense";
          case h:
            return "SuspenseList";
        }
        if (typeof we == "object")
          switch (we.$$typeof) {
            case t:
              var Re = we;
              return E(Re) + ".Consumer";
            case F:
              var et = we;
              return E(et._context) + ".Provider";
            case a:
              return Q(we, we.render, "ForwardRef");
            case e:
              var Ke = we.displayName || null;
              return Ke !== null ? Ke : te(we.type) || "Memo";
            case y: {
              var ut = we, Lt = ut._payload, vt = ut._init;
              try {
                return te(vt(Lt));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var oe = Object.prototype.hasOwnProperty, ee = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, W, I, H;
      H = {};
      function ie(we) {
        if (oe.call(we, "ref")) {
          var Re = Object.getOwnPropertyDescriptor(we, "ref").get;
          if (Re && Re.isReactWarning)
            return !1;
        }
        return we.ref !== void 0;
      }
      function ue(we) {
        if (oe.call(we, "key")) {
          var Re = Object.getOwnPropertyDescriptor(we, "key").get;
          if (Re && Re.isReactWarning)
            return !1;
        }
        return we.key !== void 0;
      }
      function fe(we, Re) {
        var et = function() {
          W || (W = !0, k("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Re));
        };
        et.isReactWarning = !0, Object.defineProperty(we, "key", {
          get: et,
          configurable: !0
        });
      }
      function de(we, Re) {
        var et = function() {
          I || (I = !0, k("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Re));
        };
        et.isReactWarning = !0, Object.defineProperty(we, "ref", {
          get: et,
          configurable: !0
        });
      }
      function pe(we) {
        if (typeof we.ref == "string" && l.current && we.__self && l.current.stateNode !== we.__self) {
          var Re = te(l.current.type);
          H[Re] || (k('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', Re, we.ref), H[Re] = !0);
        }
      }
      var xe = function(we, Re, et, Ke, ut, Lt, vt) {
        var Xt = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: ce,
          // Built-in properties that belong on the element
          type: we,
          key: Re,
          ref: et,
          props: vt,
          // Record the component responsible for creating this element.
          _owner: Lt
        };
        return Xt._store = {}, Object.defineProperty(Xt._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(Xt, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: Ke
        }), Object.defineProperty(Xt, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: ut
        }), Object.freeze && (Object.freeze(Xt.props), Object.freeze(Xt)), Xt;
      };
      function Fe(we, Re, et) {
        var Ke, ut = {}, Lt = null, vt = null, Xt = null, zt = null;
        if (Re != null) {
          ie(Re) && (vt = Re.ref, pe(Re)), ue(Re) && (N(Re.key), Lt = "" + Re.key), Xt = Re.__self === void 0 ? null : Re.__self, zt = Re.__source === void 0 ? null : Re.__source;
          for (Ke in Re)
            oe.call(Re, Ke) && !ee.hasOwnProperty(Ke) && (ut[Ke] = Re[Ke]);
        }
        var Gt = arguments.length - 2;
        if (Gt === 1)
          ut.children = et;
        else if (Gt > 1) {
          for (var Qt = Array(Gt), en = 0; en < Gt; en++)
            Qt[en] = arguments[en + 2];
          Object.freeze && Object.freeze(Qt), ut.children = Qt;
        }
        if (we && we.defaultProps) {
          var rn = we.defaultProps;
          for (Ke in rn)
            ut[Ke] === void 0 && (ut[Ke] = rn[Ke]);
        }
        if (Lt || vt) {
          var nn = typeof we == "function" ? we.displayName || we.name || "Unknown" : we;
          Lt && fe(ut, nn), vt && de(ut, nn);
        }
        return xe(we, Lt, vt, Xt, zt, l.current, ut);
      }
      function Se(we, Re) {
        var et = xe(we.type, Re, we.ref, we._self, we._source, we._owner, we.props);
        return et;
      }
      function Ce(we, Re, et) {
        if (we == null)
          throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + we + ".");
        var Ke, ut = S({}, we.props), Lt = we.key, vt = we.ref, Xt = we._self, zt = we._source, Gt = we._owner;
        if (Re != null) {
          ie(Re) && (vt = Re.ref, Gt = l.current), ue(Re) && (N(Re.key), Lt = "" + Re.key);
          var Qt;
          we.type && we.type.defaultProps && (Qt = we.type.defaultProps);
          for (Ke in Re)
            oe.call(Re, Ke) && !ee.hasOwnProperty(Ke) && (Re[Ke] === void 0 && Qt !== void 0 ? ut[Ke] = Qt[Ke] : ut[Ke] = Re[Ke]);
        }
        var en = arguments.length - 2;
        if (en === 1)
          ut.children = et;
        else if (en > 1) {
          for (var rn = Array(en), nn = 0; nn < en; nn++)
            rn[nn] = arguments[nn + 2];
          ut.children = rn;
        }
        return xe(we.type, Lt, vt, Xt, zt, Gt, ut);
      }
      function ke(we) {
        return typeof we == "object" && we !== null && we.$$typeof === ce;
      }
      var ye = ".", De = ":";
      function Ae(we) {
        var Re = /[=:]/g, et = {
          "=": "=0",
          ":": "=2"
        }, Ke = we.replace(Re, function(ut) {
          return et[ut];
        });
        return "$" + Ke;
      }
      var Te = !1, ve = /\/+/g;
      function Ne(we) {
        return we.replace(ve, "$&/");
      }
      function Ge(we, Re) {
        return typeof we == "object" && we !== null && we.key != null ? (N(we.key), Ae("" + we.key)) : Re.toString(36);
      }
      function it(we, Re, et, Ke, ut) {
        var Lt = typeof we;
        (Lt === "undefined" || Lt === "boolean") && (we = null);
        var vt = !1;
        if (we === null)
          vt = !0;
        else
          switch (Lt) {
            case "string":
            case "number":
              vt = !0;
              break;
            case "object":
              switch (we.$$typeof) {
                case ce:
                case re:
                  vt = !0;
              }
          }
        if (vt) {
          var Xt = we, zt = ut(Xt), Gt = Ke === "" ? ye + Ge(Xt, 0) : Ke;
          if (K(zt)) {
            var Qt = "";
            Gt != null && (Qt = Ne(Gt) + "/"), it(zt, Re, Qt, "", function(Zn) {
              return Zn;
            });
          } else
            zt != null && (ke(zt) && (zt.key && (!Xt || Xt.key !== zt.key) && N(zt.key), zt = Se(
              zt,
              // Keep both the (mapped) and old keys if they differ, just as
              // traverseAllChildren used to do for objects as children
              et + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
              (zt.key && (!Xt || Xt.key !== zt.key) ? (
                // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
                // eslint-disable-next-line react-internal/safe-string-coercion
                Ne("" + zt.key) + "/"
              ) : "") + Gt
            )), Re.push(zt));
          return 1;
        }
        var en, rn, nn = 0, cn = Ke === "" ? ye : Ke + De;
        if (K(we))
          for (var Wn = 0; Wn < we.length; Wn++)
            en = we[Wn], rn = cn + Ge(en, Wn), nn += it(en, Re, et, rn, ut);
        else {
          var zn = p(we);
          if (typeof zn == "function") {
            var qn = we;
            zn === qn.entries && (Te || U("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), Te = !0);
            for (var ri = zn.call(qn), Yn, ai = 0; !(Yn = ri.next()).done; )
              en = Yn.value, rn = cn + Ge(en, ai++), nn += it(en, Re, et, rn, ut);
          } else if (Lt === "object") {
            var Kn = String(we);
            throw new Error("Objects are not valid as a React child (found: " + (Kn === "[object Object]" ? "object with keys {" + Object.keys(we).join(", ") + "}" : Kn) + "). If you meant to render a collection of children, use an array instead.");
          }
        }
        return nn;
      }
      function Me(we, Re, et) {
        if (we == null)
          return we;
        var Ke = [], ut = 0;
        return it(we, Ke, "", "", function(Lt) {
          return Re.call(et, Lt, ut++);
        }), Ke;
      }
      function Ie(we) {
        var Re = 0;
        return Me(we, function() {
          Re++;
        }), Re;
      }
      function Ee(we, Re, et) {
        Me(we, function() {
          Re.apply(this, arguments);
        }, et);
      }
      function st(we) {
        return Me(we, function(Re) {
          return Re;
        }) || [];
      }
      function Qe(we) {
        if (!ke(we))
          throw new Error("React.Children.only expected to receive a single React element child.");
        return we;
      }
      function ct(we) {
        var Re = {
          $$typeof: t,
          // As a workaround to support multiple concurrent renderers, we categorize
          // some renderers as primary and others as secondary. We only expect
          // there to be two concurrent renderers at most: React Native (primary) and
          // Fabric (secondary); React DOM (primary) and React ART (secondary).
          // Secondary renderers store their context values on separate fields.
          _currentValue: we,
          _currentValue2: we,
          // Used to track how many concurrent renderers this context currently
          // supports within in a single renderer. Such as parallel server rendering.
          _threadCount: 0,
          // These are circular
          Provider: null,
          Consumer: null,
          // Add these to use same hidden class in VM as ServerContext
          _defaultValue: null,
          _globalName: null
        };
        Re.Provider = {
          $$typeof: F,
          _context: Re
        };
        var et = !1, Ke = !1, ut = !1;
        {
          var Lt = {
            $$typeof: t,
            _context: Re
          };
          Object.defineProperties(Lt, {
            Provider: {
              get: function() {
                return Ke || (Ke = !0, k("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?")), Re.Provider;
              },
              set: function(vt) {
                Re.Provider = vt;
              }
            },
            _currentValue: {
              get: function() {
                return Re._currentValue;
              },
              set: function(vt) {
                Re._currentValue = vt;
              }
            },
            _currentValue2: {
              get: function() {
                return Re._currentValue2;
              },
              set: function(vt) {
                Re._currentValue2 = vt;
              }
            },
            _threadCount: {
              get: function() {
                return Re._threadCount;
              },
              set: function(vt) {
                Re._threadCount = vt;
              }
            },
            Consumer: {
              get: function() {
                return et || (et = !0, k("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")), Re.Consumer;
              }
            },
            displayName: {
              get: function() {
                return Re.displayName;
              },
              set: function(vt) {
                ut || (U("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", vt), ut = !0);
              }
            }
          }), Re.Consumer = Lt;
        }
        return Re._currentRenderer = null, Re._currentRenderer2 = null, Re;
      }
      var xt = -1, Je = 0, mt = 1, _t = 2;
      function Xe(we) {
        if (we._status === xt) {
          var Re = we._result, et = Re();
          if (et.then(function(Lt) {
            if (we._status === Je || we._status === xt) {
              var vt = we;
              vt._status = mt, vt._result = Lt;
            }
          }, function(Lt) {
            if (we._status === Je || we._status === xt) {
              var vt = we;
              vt._status = _t, vt._result = Lt;
            }
          }), we._status === xt) {
            var Ke = we;
            Ke._status = Je, Ke._result = et;
          }
        }
        if (we._status === mt) {
          var ut = we._result;
          return ut === void 0 && k(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, ut), "default" in ut || k(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, ut), ut.default;
        } else
          throw we._result;
      }
      function Ct(we) {
        var Re = {
          // We use these fields to store the result.
          _status: xt,
          _result: we
        }, et = {
          $$typeof: y,
          _payload: Re,
          _init: Xe
        };
        {
          var Ke, ut;
          Object.defineProperties(et, {
            defaultProps: {
              configurable: !0,
              get: function() {
                return Ke;
              },
              set: function(Lt) {
                k("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), Ke = Lt, Object.defineProperty(et, "defaultProps", {
                  enumerable: !0
                });
              }
            },
            propTypes: {
              configurable: !0,
              get: function() {
                return ut;
              },
              set: function(Lt) {
                k("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), ut = Lt, Object.defineProperty(et, "propTypes", {
                  enumerable: !0
                });
              }
            }
          });
        }
        return et;
      }
      function bt(we) {
        we != null && we.$$typeof === e ? k("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof we != "function" ? k("forwardRef requires a render function but was given %s.", we === null ? "null" : typeof we) : we.length !== 0 && we.length !== 2 && k("forwardRef render functions accept exactly two parameters: props and ref. %s", we.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."), we != null && (we.defaultProps != null || we.propTypes != null) && k("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
        var Re = {
          $$typeof: a,
          render: we
        };
        {
          var et;
          Object.defineProperty(Re, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return et;
            },
            set: function(Ke) {
              et = Ke, !we.name && !we.displayName && (we.displayName = Ke);
            }
          });
        }
        return Re;
      }
      var Pe;
      Pe = Symbol.for("react.module.reference");
      function qe(we) {
        return !!(typeof we == "string" || typeof we == "function" || we === ae || we === o || X || we === J || we === v || we === h || j || we === c || b || A || Y || typeof we == "object" && we !== null && (we.$$typeof === y || we.$$typeof === e || we.$$typeof === F || we.$$typeof === t || we.$$typeof === a || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        we.$$typeof === Pe || we.getModuleId !== void 0));
      }
      function ot(we, Re) {
        qe(we) || k("memo: The first argument must be a component. Instead received: %s", we === null ? "null" : typeof we);
        var et = {
          $$typeof: e,
          type: we,
          compare: Re === void 0 ? null : Re
        };
        {
          var Ke;
          Object.defineProperty(et, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return Ke;
            },
            set: function(ut) {
              Ke = ut, !we.name && !we.displayName && (we.displayName = ut);
            }
          });
        }
        return et;
      }
      function lt() {
        var we = g.current;
        return we === null && k(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`), we;
      }
      function Ut(we) {
        var Re = lt();
        if (we._context !== void 0) {
          var et = we._context;
          et.Consumer === we ? k("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?") : et.Provider === we && k("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
        }
        return Re.useContext(we);
      }
      function Nt(we) {
        var Re = lt();
        return Re.useState(we);
      }
      function Ve(we, Re, et) {
        var Ke = lt();
        return Ke.useReducer(we, Re, et);
      }
      function je(we) {
        var Re = lt();
        return Re.useRef(we);
      }
      function at(we, Re) {
        var et = lt();
        return et.useEffect(we, Re);
      }
      function nt(we, Re) {
        var et = lt();
        return et.useInsertionEffect(we, Re);
      }
      function ft(we, Re) {
        var et = lt();
        return et.useLayoutEffect(we, Re);
      }
      function Tt(we, Re) {
        var et = lt();
        return et.useCallback(we, Re);
      }
      function yt(we, Re) {
        var et = lt();
        return et.useMemo(we, Re);
      }
      function dt(we, Re, et) {
        var Ke = lt();
        return Ke.useImperativeHandle(we, Re, et);
      }
      function wt(we, Re) {
        {
          var et = lt();
          return et.useDebugValue(we, Re);
        }
      }
      function Dt() {
        var we = lt();
        return we.useTransition();
      }
      function jt(we) {
        var Re = lt();
        return Re.useDeferredValue(we);
      }
      function Bt() {
        var we = lt();
        return we.useId();
      }
      function kt(we, Re, et) {
        var Ke = lt();
        return Ke.useSyncExternalStore(we, Re, et);
      }
      var Ue = 0, We, rt, tt, St, Pt, qt, Mt;
      function Wt() {
      }
      Wt.__reactDisabledLog = !0;
      function Zt() {
        {
          if (Ue === 0) {
            We = console.log, rt = console.info, tt = console.warn, St = console.error, Pt = console.group, qt = console.groupCollapsed, Mt = console.groupEnd;
            var we = {
              configurable: !0,
              enumerable: !0,
              value: Wt,
              writable: !0
            };
            Object.defineProperties(console, {
              info: we,
              log: we,
              warn: we,
              error: we,
              group: we,
              groupCollapsed: we,
              groupEnd: we
            });
          }
          Ue++;
        }
      }
      function an() {
        {
          if (Ue--, Ue === 0) {
            var we = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: S({}, we, {
                value: We
              }),
              info: S({}, we, {
                value: rt
              }),
              warn: S({}, we, {
                value: tt
              }),
              error: S({}, we, {
                value: St
              }),
              group: S({}, we, {
                value: Pt
              }),
              groupCollapsed: S({}, we, {
                value: qt
              }),
              groupEnd: S({}, we, {
                value: Mt
              })
            });
          }
          Ue < 0 && k("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var un = B.ReactCurrentDispatcher, Tn;
      function gn(we, Re, et) {
        {
          if (Tn === void 0)
            try {
              throw Error();
            } catch (ut) {
              var Ke = ut.stack.trim().match(/\n( *(at )?)/);
              Tn = Ke && Ke[1] || "";
            }
          return `
` + Tn + we;
        }
      }
      var _n = !1, vn;
      {
        var En = typeof WeakMap == "function" ? WeakMap : Map;
        vn = new En();
      }
      function kn(we, Re) {
        if (!we || _n)
          return "";
        {
          var et = vn.get(we);
          if (et !== void 0)
            return et;
        }
        var Ke;
        _n = !0;
        var ut = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var Lt;
        Lt = un.current, un.current = null, Zt();
        try {
          if (Re) {
            var vt = function() {
              throw Error();
            };
            if (Object.defineProperty(vt.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(vt, []);
              } catch (cn) {
                Ke = cn;
              }
              Reflect.construct(we, [], vt);
            } else {
              try {
                vt.call();
              } catch (cn) {
                Ke = cn;
              }
              we.call(vt.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (cn) {
              Ke = cn;
            }
            we();
          }
        } catch (cn) {
          if (cn && Ke && typeof cn.stack == "string") {
            for (var Xt = cn.stack.split(`
`), zt = Ke.stack.split(`
`), Gt = Xt.length - 1, Qt = zt.length - 1; Gt >= 1 && Qt >= 0 && Xt[Gt] !== zt[Qt]; )
              Qt--;
            for (; Gt >= 1 && Qt >= 0; Gt--, Qt--)
              if (Xt[Gt] !== zt[Qt]) {
                if (Gt !== 1 || Qt !== 1)
                  do
                    if (Gt--, Qt--, Qt < 0 || Xt[Gt] !== zt[Qt]) {
                      var en = `
` + Xt[Gt].replace(" at new ", " at ");
                      return we.displayName && en.includes("<anonymous>") && (en = en.replace("<anonymous>", we.displayName)), typeof we == "function" && vn.set(we, en), en;
                    }
                  while (Gt >= 1 && Qt >= 0);
                break;
              }
          }
        } finally {
          _n = !1, un.current = Lt, an(), Error.prepareStackTrace = ut;
        }
        var rn = we ? we.displayName || we.name : "", nn = rn ? gn(rn) : "";
        return typeof we == "function" && vn.set(we, nn), nn;
      }
      function Ln(we, Re, et) {
        return kn(we, !1);
      }
      function Nn(we) {
        var Re = we.prototype;
        return !!(Re && Re.isReactComponent);
      }
      function wn(we, Re, et) {
        if (we == null)
          return "";
        if (typeof we == "function")
          return kn(we, Nn(we));
        if (typeof we == "string")
          return gn(we);
        switch (we) {
          case v:
            return gn("Suspense");
          case h:
            return gn("SuspenseList");
        }
        if (typeof we == "object")
          switch (we.$$typeof) {
            case a:
              return Ln(we.render);
            case e:
              return wn(we.type, Re, et);
            case y: {
              var Ke = we, ut = Ke._payload, Lt = Ke._init;
              try {
                return wn(Lt(ut), Re, et);
              } catch {
              }
            }
          }
        return "";
      }
      var On = {}, In = B.ReactDebugCurrentFrame;
      function xn(we) {
        if (we) {
          var Re = we._owner, et = wn(we.type, we._source, Re ? Re.type : null);
          In.setExtraStackFrame(et);
        } else
          In.setExtraStackFrame(null);
      }
      function dn(we, Re, et, Ke, ut) {
        {
          var Lt = Function.call.bind(oe);
          for (var vt in we)
            if (Lt(we, vt)) {
              var Xt = void 0;
              try {
                if (typeof we[vt] != "function") {
                  var zt = Error((Ke || "React class") + ": " + et + " type `" + vt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof we[vt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw zt.name = "Invariant Violation", zt;
                }
                Xt = we[vt](Re, vt, Ke, et, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (Gt) {
                Xt = Gt;
              }
              Xt && !(Xt instanceof Error) && (xn(ut), k("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Ke || "React class", et, vt, typeof Xt), xn(null)), Xt instanceof Error && !(Xt.message in On) && (On[Xt.message] = !0, xn(ut), k("Failed %s type: %s", et, Xt.message), xn(null));
            }
        }
      }
      function pn(we) {
        if (we) {
          var Re = we._owner, et = wn(we.type, we._source, Re ? Re.type : null);
          O(et);
        } else
          O(null);
      }
      var sn;
      sn = !1;
      function fn() {
        if (l.current) {
          var we = te(l.current.type);
          if (we)
            return `

Check the render method of \`` + we + "`.";
        }
        return "";
      }
      function Fn(we) {
        if (we !== void 0) {
          var Re = we.fileName.replace(/^.*[\\\/]/, ""), et = we.lineNumber;
          return `

Check your code at ` + Re + ":" + et + ".";
        }
        return "";
      }
      function Pn(we) {
        return we != null ? Fn(we.__source) : "";
      }
      var An = {};
      function jn(we) {
        var Re = fn();
        if (!Re) {
          var et = typeof we == "string" ? we : we.displayName || we.name;
          et && (Re = `

Check the top-level render call using <` + et + ">.");
        }
        return Re;
      }
      function Rn(we, Re) {
        if (!(!we._store || we._store.validated || we.key != null)) {
          we._store.validated = !0;
          var et = jn(Re);
          if (!An[et]) {
            An[et] = !0;
            var Ke = "";
            we && we._owner && we._owner !== l.current && (Ke = " It was passed a child from " + te(we._owner.type) + "."), pn(we), k('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', et, Ke), pn(null);
          }
        }
      }
      function Un(we, Re) {
        if (typeof we == "object") {
          if (K(we))
            for (var et = 0; et < we.length; et++) {
              var Ke = we[et];
              ke(Ke) && Rn(Ke, Re);
            }
          else if (ke(we))
            we._store && (we._store.validated = !0);
          else if (we) {
            var ut = p(we);
            if (typeof ut == "function" && ut !== we.entries)
              for (var Lt = ut.call(we), vt; !(vt = Lt.next()).done; )
                ke(vt.value) && Rn(vt.value, Re);
          }
        }
      }
      function Mn(we) {
        {
          var Re = we.type;
          if (Re == null || typeof Re == "string")
            return;
          var et;
          if (typeof Re == "function")
            et = Re.propTypes;
          else if (typeof Re == "object" && (Re.$$typeof === a || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          Re.$$typeof === e))
            et = Re.propTypes;
          else
            return;
          if (et) {
            var Ke = te(Re);
            dn(et, we.props, "prop", Ke, we);
          } else if (Re.PropTypes !== void 0 && !sn) {
            sn = !0;
            var ut = te(Re);
            k("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ut || "Unknown");
          }
          typeof Re.getDefaultProps == "function" && !Re.getDefaultProps.isReactClassApproved && k("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function Dn(we) {
        {
          for (var Re = Object.keys(we.props), et = 0; et < Re.length; et++) {
            var Ke = Re[et];
            if (Ke !== "children" && Ke !== "key") {
              pn(we), k("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Ke), pn(null);
              break;
            }
          }
          we.ref !== null && (pn(we), k("Invalid attribute `ref` supplied to `React.Fragment`."), pn(null));
        }
      }
      function Sn(we, Re, et) {
        var Ke = qe(we);
        if (!Ke) {
          var ut = "";
          (we === void 0 || typeof we == "object" && we !== null && Object.keys(we).length === 0) && (ut += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Lt = Pn(Re);
          Lt ? ut += Lt : ut += fn();
          var vt;
          we === null ? vt = "null" : K(we) ? vt = "array" : we !== void 0 && we.$$typeof === ce ? (vt = "<" + (te(we.type) || "Unknown") + " />", ut = " Did you accidentally export a JSX literal instead of a component?") : vt = typeof we, k("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", vt, ut);
        }
        var Xt = Fe.apply(this, arguments);
        if (Xt == null)
          return Xt;
        if (Ke)
          for (var zt = 2; zt < arguments.length; zt++)
            Un(arguments[zt], we);
        return we === ae ? Dn(Xt) : Mn(Xt), Xt;
      }
      var Bn = !1;
      function bn(we) {
        var Re = Sn.bind(null, we);
        return Re.type = we, Bn || (Bn = !0, U("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")), Object.defineProperty(Re, "type", {
          enumerable: !1,
          get: function() {
            return U("Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", {
              value: we
            }), we;
          }
        }), Re;
      }
      function $n(we, Re, et) {
        for (var Ke = Ce.apply(this, arguments), ut = 2; ut < arguments.length; ut++)
          Un(arguments[ut], Ke.type);
        return Mn(Ke), Ke;
      }
      function yn(we, Re) {
        var et = n.transition;
        n.transition = {};
        var Ke = n.transition;
        n.transition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          we();
        } finally {
          if (n.transition = et, et === null && Ke._updatedFibers) {
            var ut = Ke._updatedFibers.size;
            ut > 10 && U("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), Ke._updatedFibers.clear();
          }
        }
      }
      var He = !1, R = null;
      function he(we) {
        if (R === null)
          try {
            var Re = ("require" + Math.random()).slice(0, 7), et = be && be[Re];
            R = et.call(be, "timers").setImmediate;
          } catch {
            R = function(ut) {
              He === !1 && (He = !0, typeof MessageChannel > "u" && k("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
              var Lt = new MessageChannel();
              Lt.port1.onmessage = ut, Lt.port2.postMessage(void 0);
            };
          }
        return R(we);
      }
      var $e = 0, Ze = !1;
      function ht(we) {
        {
          var Re = $e;
          $e++, i.current === null && (i.current = []);
          var et = i.isBatchingLegacy, Ke;
          try {
            if (i.isBatchingLegacy = !0, Ke = we(), !et && i.didScheduleLegacyUpdate) {
              var ut = i.current;
              ut !== null && (i.didScheduleLegacyUpdate = !1, $t(ut));
            }
          } catch (rn) {
            throw It(Re), rn;
          } finally {
            i.isBatchingLegacy = et;
          }
          if (Ke !== null && typeof Ke == "object" && typeof Ke.then == "function") {
            var Lt = Ke, vt = !1, Xt = {
              then: function(rn, nn) {
                vt = !0, Lt.then(function(cn) {
                  It(Re), $e === 0 ? Et(cn, rn, nn) : rn(cn);
                }, function(cn) {
                  It(Re), nn(cn);
                });
              }
            };
            return !Ze && typeof Promise < "u" && Promise.resolve().then(function() {
            }).then(function() {
              vt || (Ze = !0, k("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
            }), Xt;
          } else {
            var zt = Ke;
            if (It(Re), $e === 0) {
              var Gt = i.current;
              Gt !== null && ($t(Gt), i.current = null);
              var Qt = {
                then: function(rn, nn) {
                  i.current === null ? (i.current = [], Et(zt, rn, nn)) : rn(zt);
                }
              };
              return Qt;
            } else {
              var en = {
                then: function(rn, nn) {
                  rn(zt);
                }
              };
              return en;
            }
          }
        }
      }
      function It(we) {
        we !== $e - 1 && k("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "), $e = we;
      }
      function Et(we, Re, et) {
        {
          var Ke = i.current;
          if (Ke !== null)
            try {
              $t(Ke), he(function() {
                Ke.length === 0 ? (i.current = null, Re(we)) : Et(we, Re, et);
              });
            } catch (ut) {
              et(ut);
            }
          else
            Re(we);
        }
      }
      var Rt = !1;
      function $t(we) {
        if (!Rt) {
          Rt = !0;
          var Re = 0;
          try {
            for (; Re < we.length; Re++) {
              var et = we[Re];
              do
                et = et(!0);
              while (et !== null);
            }
            we.length = 0;
          } catch (Ke) {
            throw we = we.slice(Re + 1), Ke;
          } finally {
            Rt = !1;
          }
        }
      }
      var Ht = Sn, Jt = $n, Kt = bn, tn = {
        map: Me,
        forEach: Ee,
        count: Ie,
        toArray: st,
        only: Qe
      };
      ge.Children = tn, ge.Component = T, ge.Fragment = ae, ge.Profiler = o, ge.PureComponent = $, ge.StrictMode = J, ge.Suspense = v, ge.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = B, ge.cloneElement = Jt, ge.createContext = ct, ge.createElement = Ht, ge.createFactory = Kt, ge.createRef = V, ge.forwardRef = bt, ge.isValidElement = ke, ge.lazy = Ct, ge.memo = ot, ge.startTransition = yn, ge.unstable_act = ht, ge.useCallback = Tt, ge.useContext = Ut, ge.useDebugValue = wt, ge.useDeferredValue = jt, ge.useEffect = at, ge.useId = Bt, ge.useImperativeHandle = dt, ge.useInsertionEffect = nt, ge.useLayoutEffect = ft, ge.useMemo = yt, ge.useReducer = Ve, ge.useRef = je, ge.useState = Nt, ge.useSyncExternalStore = kt, ge.useTransition = Dt, ge.version = le, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(react_development, react_developmentExports)), react_developmentExports;
}
var hasRequiredReact;
function requireReact() {
  return hasRequiredReact || (hasRequiredReact = 1, function(be) {
    process.env.NODE_ENV === "production" ? be.exports = requireReact_production_min() : be.exports = requireReact_development();
  }(react)), reactExports$1;
}
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min)
    return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var be = requireReact(), ge = Symbol.for("react.element"), le = Symbol.for("react.fragment"), ce = Object.prototype.hasOwnProperty, re = be.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, ae = { key: !0, ref: !0, __self: !0, __source: !0 };
  function J(o, F, t) {
    var a, v = {}, h = null, e = null;
    t !== void 0 && (h = "" + t), F.key !== void 0 && (h = "" + F.key), F.ref !== void 0 && (e = F.ref);
    for (a in F)
      ce.call(F, a) && !ae.hasOwnProperty(a) && (v[a] = F[a]);
    if (o && o.defaultProps)
      for (a in F = o.defaultProps, F)
        v[a] === void 0 && (v[a] = F[a]);
    return { $$typeof: ge, type: o, key: h, ref: e, props: v, _owner: re.current };
  }
  return reactJsxRuntime_production_min.Fragment = le, reactJsxRuntime_production_min.jsx = J, reactJsxRuntime_production_min.jsxs = J, reactJsxRuntime_production_min;
}
var reactJsxRuntime_development = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
  return hasRequiredReactJsxRuntime_development || (hasRequiredReactJsxRuntime_development = 1, process.env.NODE_ENV !== "production" && function() {
    var be = requireReact(), ge = Symbol.for("react.element"), le = Symbol.for("react.portal"), ce = Symbol.for("react.fragment"), re = Symbol.for("react.strict_mode"), ae = Symbol.for("react.profiler"), J = Symbol.for("react.provider"), o = Symbol.for("react.context"), F = Symbol.for("react.forward_ref"), t = Symbol.for("react.suspense"), a = Symbol.for("react.suspense_list"), v = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), e = Symbol.for("react.offscreen"), y = Symbol.iterator, c = "@@iterator";
    function d(Pe) {
      if (Pe === null || typeof Pe != "object")
        return null;
      var qe = y && Pe[y] || Pe[c];
      return typeof qe == "function" ? qe : null;
    }
    var m = be.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function p(Pe) {
      {
        for (var qe = arguments.length, ot = new Array(qe > 1 ? qe - 1 : 0), lt = 1; lt < qe; lt++)
          ot[lt - 1] = arguments[lt];
        g("error", Pe, ot);
      }
    }
    function g(Pe, qe, ot) {
      {
        var lt = m.ReactDebugCurrentFrame, Ut = lt.getStackAddendum();
        Ut !== "" && (qe += "%s", ot = ot.concat([Ut]));
        var Nt = ot.map(function(Ve) {
          return String(Ve);
        });
        Nt.unshift("Warning: " + qe), Function.prototype.apply.call(console[Pe], console, Nt);
      }
    }
    var n = !1, i = !1, l = !1, u = !1, w = !1, O;
    O = Symbol.for("react.module.reference");
    function b(Pe) {
      return !!(typeof Pe == "string" || typeof Pe == "function" || Pe === ce || Pe === ae || w || Pe === re || Pe === t || Pe === a || u || Pe === e || n || i || l || typeof Pe == "object" && Pe !== null && (Pe.$$typeof === h || Pe.$$typeof === v || Pe.$$typeof === J || Pe.$$typeof === o || Pe.$$typeof === F || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      Pe.$$typeof === O || Pe.getModuleId !== void 0));
    }
    function A(Pe, qe, ot) {
      var lt = Pe.displayName;
      if (lt)
        return lt;
      var Ut = qe.displayName || qe.name || "";
      return Ut !== "" ? ot + "(" + Ut + ")" : ot;
    }
    function Y(Pe) {
      return Pe.displayName || "Context";
    }
    function j(Pe) {
      if (Pe == null)
        return null;
      if (typeof Pe.tag == "number" && p("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof Pe == "function")
        return Pe.displayName || Pe.name || null;
      if (typeof Pe == "string")
        return Pe;
      switch (Pe) {
        case ce:
          return "Fragment";
        case le:
          return "Portal";
        case ae:
          return "Profiler";
        case re:
          return "StrictMode";
        case t:
          return "Suspense";
        case a:
          return "SuspenseList";
      }
      if (typeof Pe == "object")
        switch (Pe.$$typeof) {
          case o:
            var qe = Pe;
            return Y(qe) + ".Consumer";
          case J:
            var ot = Pe;
            return Y(ot._context) + ".Provider";
          case F:
            return A(Pe, Pe.render, "ForwardRef");
          case v:
            var lt = Pe.displayName || null;
            return lt !== null ? lt : j(Pe.type) || "Memo";
          case h: {
            var Ut = Pe, Nt = Ut._payload, Ve = Ut._init;
            try {
              return j(Ve(Nt));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var X = Object.assign, B = 0, U, k, x, f, D, _, S;
    function C() {
    }
    C.__reactDisabledLog = !0;
    function T() {
      {
        if (B === 0) {
          U = console.log, k = console.info, x = console.warn, f = console.error, D = console.group, _ = console.groupCollapsed, S = console.groupEnd;
          var Pe = {
            configurable: !0,
            enumerable: !0,
            value: C,
            writable: !0
          };
          Object.defineProperties(console, {
            info: Pe,
            log: Pe,
            warn: Pe,
            error: Pe,
            group: Pe,
            groupCollapsed: Pe,
            groupEnd: Pe
          });
        }
        B++;
      }
    }
    function P() {
      {
        if (B--, B === 0) {
          var Pe = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: X({}, Pe, {
              value: U
            }),
            info: X({}, Pe, {
              value: k
            }),
            warn: X({}, Pe, {
              value: x
            }),
            error: X({}, Pe, {
              value: f
            }),
            group: X({}, Pe, {
              value: D
            }),
            groupCollapsed: X({}, Pe, {
              value: _
            }),
            groupEnd: X({}, Pe, {
              value: S
            })
          });
        }
        B < 0 && p("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var M = m.ReactCurrentDispatcher, G;
    function Z(Pe, qe, ot) {
      {
        if (G === void 0)
          try {
            throw Error();
          } catch (Ut) {
            var lt = Ut.stack.trim().match(/\n( *(at )?)/);
            G = lt && lt[1] || "";
          }
        return `
` + G + Pe;
      }
    }
    var $ = !1, z;
    {
      var V = typeof WeakMap == "function" ? WeakMap : Map;
      z = new V();
    }
    function L(Pe, qe) {
      if (!Pe || $)
        return "";
      {
        var ot = z.get(Pe);
        if (ot !== void 0)
          return ot;
      }
      var lt;
      $ = !0;
      var Ut = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Nt;
      Nt = M.current, M.current = null, T();
      try {
        if (qe) {
          var Ve = function() {
            throw Error();
          };
          if (Object.defineProperty(Ve.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Ve, []);
            } catch (wt) {
              lt = wt;
            }
            Reflect.construct(Pe, [], Ve);
          } else {
            try {
              Ve.call();
            } catch (wt) {
              lt = wt;
            }
            Pe.call(Ve.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (wt) {
            lt = wt;
          }
          Pe();
        }
      } catch (wt) {
        if (wt && lt && typeof wt.stack == "string") {
          for (var je = wt.stack.split(`
`), at = lt.stack.split(`
`), nt = je.length - 1, ft = at.length - 1; nt >= 1 && ft >= 0 && je[nt] !== at[ft]; )
            ft--;
          for (; nt >= 1 && ft >= 0; nt--, ft--)
            if (je[nt] !== at[ft]) {
              if (nt !== 1 || ft !== 1)
                do
                  if (nt--, ft--, ft < 0 || je[nt] !== at[ft]) {
                    var Tt = `
` + je[nt].replace(" at new ", " at ");
                    return Pe.displayName && Tt.includes("<anonymous>") && (Tt = Tt.replace("<anonymous>", Pe.displayName)), typeof Pe == "function" && z.set(Pe, Tt), Tt;
                  }
                while (nt >= 1 && ft >= 0);
              break;
            }
        }
      } finally {
        $ = !1, M.current = Nt, P(), Error.prepareStackTrace = Ut;
      }
      var yt = Pe ? Pe.displayName || Pe.name : "", dt = yt ? Z(yt) : "";
      return typeof Pe == "function" && z.set(Pe, dt), dt;
    }
    function K(Pe, qe, ot) {
      return L(Pe, !1);
    }
    function ne(Pe) {
      var qe = Pe.prototype;
      return !!(qe && qe.isReactComponent);
    }
    function se(Pe, qe, ot) {
      if (Pe == null)
        return "";
      if (typeof Pe == "function")
        return L(Pe, ne(Pe));
      if (typeof Pe == "string")
        return Z(Pe);
      switch (Pe) {
        case t:
          return Z("Suspense");
        case a:
          return Z("SuspenseList");
      }
      if (typeof Pe == "object")
        switch (Pe.$$typeof) {
          case F:
            return K(Pe.render);
          case v:
            return se(Pe.type, qe, ot);
          case h: {
            var lt = Pe, Ut = lt._payload, Nt = lt._init;
            try {
              return se(Nt(Ut), qe, ot);
            } catch {
            }
          }
        }
      return "";
    }
    var q = Object.prototype.hasOwnProperty, N = {}, Q = m.ReactDebugCurrentFrame;
    function E(Pe) {
      if (Pe) {
        var qe = Pe._owner, ot = se(Pe.type, Pe._source, qe ? qe.type : null);
        Q.setExtraStackFrame(ot);
      } else
        Q.setExtraStackFrame(null);
    }
    function te(Pe, qe, ot, lt, Ut) {
      {
        var Nt = Function.call.bind(q);
        for (var Ve in Pe)
          if (Nt(Pe, Ve)) {
            var je = void 0;
            try {
              if (typeof Pe[Ve] != "function") {
                var at = Error((lt || "React class") + ": " + ot + " type `" + Ve + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Pe[Ve] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw at.name = "Invariant Violation", at;
              }
              je = Pe[Ve](qe, Ve, lt, ot, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (nt) {
              je = nt;
            }
            je && !(je instanceof Error) && (E(Ut), p("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", lt || "React class", ot, Ve, typeof je), E(null)), je instanceof Error && !(je.message in N) && (N[je.message] = !0, E(Ut), p("Failed %s type: %s", ot, je.message), E(null));
          }
      }
    }
    var oe = Array.isArray;
    function ee(Pe) {
      return oe(Pe);
    }
    function W(Pe) {
      {
        var qe = typeof Symbol == "function" && Symbol.toStringTag, ot = qe && Pe[Symbol.toStringTag] || Pe.constructor.name || "Object";
        return ot;
      }
    }
    function I(Pe) {
      try {
        return H(Pe), !1;
      } catch {
        return !0;
      }
    }
    function H(Pe) {
      return "" + Pe;
    }
    function ie(Pe) {
      if (I(Pe))
        return p("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", W(Pe)), H(Pe);
    }
    var ue = m.ReactCurrentOwner, fe = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, de, pe, xe;
    xe = {};
    function Fe(Pe) {
      if (q.call(Pe, "ref")) {
        var qe = Object.getOwnPropertyDescriptor(Pe, "ref").get;
        if (qe && qe.isReactWarning)
          return !1;
      }
      return Pe.ref !== void 0;
    }
    function Se(Pe) {
      if (q.call(Pe, "key")) {
        var qe = Object.getOwnPropertyDescriptor(Pe, "key").get;
        if (qe && qe.isReactWarning)
          return !1;
      }
      return Pe.key !== void 0;
    }
    function Ce(Pe, qe) {
      if (typeof Pe.ref == "string" && ue.current && qe && ue.current.stateNode !== qe) {
        var ot = j(ue.current.type);
        xe[ot] || (p('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', j(ue.current.type), Pe.ref), xe[ot] = !0);
      }
    }
    function ke(Pe, qe) {
      {
        var ot = function() {
          de || (de = !0, p("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", qe));
        };
        ot.isReactWarning = !0, Object.defineProperty(Pe, "key", {
          get: ot,
          configurable: !0
        });
      }
    }
    function ye(Pe, qe) {
      {
        var ot = function() {
          pe || (pe = !0, p("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", qe));
        };
        ot.isReactWarning = !0, Object.defineProperty(Pe, "ref", {
          get: ot,
          configurable: !0
        });
      }
    }
    var De = function(Pe, qe, ot, lt, Ut, Nt, Ve) {
      var je = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: ge,
        // Built-in properties that belong on the element
        type: Pe,
        key: qe,
        ref: ot,
        props: Ve,
        // Record the component responsible for creating this element.
        _owner: Nt
      };
      return je._store = {}, Object.defineProperty(je._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(je, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: lt
      }), Object.defineProperty(je, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Ut
      }), Object.freeze && (Object.freeze(je.props), Object.freeze(je)), je;
    };
    function Ae(Pe, qe, ot, lt, Ut) {
      {
        var Nt, Ve = {}, je = null, at = null;
        ot !== void 0 && (ie(ot), je = "" + ot), Se(qe) && (ie(qe.key), je = "" + qe.key), Fe(qe) && (at = qe.ref, Ce(qe, Ut));
        for (Nt in qe)
          q.call(qe, Nt) && !fe.hasOwnProperty(Nt) && (Ve[Nt] = qe[Nt]);
        if (Pe && Pe.defaultProps) {
          var nt = Pe.defaultProps;
          for (Nt in nt)
            Ve[Nt] === void 0 && (Ve[Nt] = nt[Nt]);
        }
        if (je || at) {
          var ft = typeof Pe == "function" ? Pe.displayName || Pe.name || "Unknown" : Pe;
          je && ke(Ve, ft), at && ye(Ve, ft);
        }
        return De(Pe, je, at, Ut, lt, ue.current, Ve);
      }
    }
    var Te = m.ReactCurrentOwner, ve = m.ReactDebugCurrentFrame;
    function Ne(Pe) {
      if (Pe) {
        var qe = Pe._owner, ot = se(Pe.type, Pe._source, qe ? qe.type : null);
        ve.setExtraStackFrame(ot);
      } else
        ve.setExtraStackFrame(null);
    }
    var Ge;
    Ge = !1;
    function it(Pe) {
      return typeof Pe == "object" && Pe !== null && Pe.$$typeof === ge;
    }
    function Me() {
      {
        if (Te.current) {
          var Pe = j(Te.current.type);
          if (Pe)
            return `

Check the render method of \`` + Pe + "`.";
        }
        return "";
      }
    }
    function Ie(Pe) {
      {
        if (Pe !== void 0) {
          var qe = Pe.fileName.replace(/^.*[\\\/]/, ""), ot = Pe.lineNumber;
          return `

Check your code at ` + qe + ":" + ot + ".";
        }
        return "";
      }
    }
    var Ee = {};
    function st(Pe) {
      {
        var qe = Me();
        if (!qe) {
          var ot = typeof Pe == "string" ? Pe : Pe.displayName || Pe.name;
          ot && (qe = `

Check the top-level render call using <` + ot + ">.");
        }
        return qe;
      }
    }
    function Qe(Pe, qe) {
      {
        if (!Pe._store || Pe._store.validated || Pe.key != null)
          return;
        Pe._store.validated = !0;
        var ot = st(qe);
        if (Ee[ot])
          return;
        Ee[ot] = !0;
        var lt = "";
        Pe && Pe._owner && Pe._owner !== Te.current && (lt = " It was passed a child from " + j(Pe._owner.type) + "."), Ne(Pe), p('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ot, lt), Ne(null);
      }
    }
    function ct(Pe, qe) {
      {
        if (typeof Pe != "object")
          return;
        if (ee(Pe))
          for (var ot = 0; ot < Pe.length; ot++) {
            var lt = Pe[ot];
            it(lt) && Qe(lt, qe);
          }
        else if (it(Pe))
          Pe._store && (Pe._store.validated = !0);
        else if (Pe) {
          var Ut = d(Pe);
          if (typeof Ut == "function" && Ut !== Pe.entries)
            for (var Nt = Ut.call(Pe), Ve; !(Ve = Nt.next()).done; )
              it(Ve.value) && Qe(Ve.value, qe);
        }
      }
    }
    function xt(Pe) {
      {
        var qe = Pe.type;
        if (qe == null || typeof qe == "string")
          return;
        var ot;
        if (typeof qe == "function")
          ot = qe.propTypes;
        else if (typeof qe == "object" && (qe.$$typeof === F || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        qe.$$typeof === v))
          ot = qe.propTypes;
        else
          return;
        if (ot) {
          var lt = j(qe);
          te(ot, Pe.props, "prop", lt, Pe);
        } else if (qe.PropTypes !== void 0 && !Ge) {
          Ge = !0;
          var Ut = j(qe);
          p("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Ut || "Unknown");
        }
        typeof qe.getDefaultProps == "function" && !qe.getDefaultProps.isReactClassApproved && p("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Je(Pe) {
      {
        for (var qe = Object.keys(Pe.props), ot = 0; ot < qe.length; ot++) {
          var lt = qe[ot];
          if (lt !== "children" && lt !== "key") {
            Ne(Pe), p("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", lt), Ne(null);
            break;
          }
        }
        Pe.ref !== null && (Ne(Pe), p("Invalid attribute `ref` supplied to `React.Fragment`."), Ne(null));
      }
    }
    function mt(Pe, qe, ot, lt, Ut, Nt) {
      {
        var Ve = b(Pe);
        if (!Ve) {
          var je = "";
          (Pe === void 0 || typeof Pe == "object" && Pe !== null && Object.keys(Pe).length === 0) && (je += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var at = Ie(Ut);
          at ? je += at : je += Me();
          var nt;
          Pe === null ? nt = "null" : ee(Pe) ? nt = "array" : Pe !== void 0 && Pe.$$typeof === ge ? (nt = "<" + (j(Pe.type) || "Unknown") + " />", je = " Did you accidentally export a JSX literal instead of a component?") : nt = typeof Pe, p("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", nt, je);
        }
        var ft = Ae(Pe, qe, ot, Ut, Nt);
        if (ft == null)
          return ft;
        if (Ve) {
          var Tt = qe.children;
          if (Tt !== void 0)
            if (lt)
              if (ee(Tt)) {
                for (var yt = 0; yt < Tt.length; yt++)
                  ct(Tt[yt], Pe);
                Object.freeze && Object.freeze(Tt);
              } else
                p("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              ct(Tt, Pe);
        }
        return Pe === ce ? Je(ft) : xt(ft), ft;
      }
    }
    function _t(Pe, qe, ot) {
      return mt(Pe, qe, ot, !0);
    }
    function Xe(Pe, qe, ot) {
      return mt(Pe, qe, ot, !1);
    }
    var Ct = Xe, bt = _t;
    reactJsxRuntime_development.Fragment = ce, reactJsxRuntime_development.jsx = Ct, reactJsxRuntime_development.jsxs = bt;
  }()), reactJsxRuntime_development;
}
(function(be) {
  process.env.NODE_ENV === "production" ? be.exports = requireReactJsxRuntime_production_min() : be.exports = requireReactJsxRuntime_development();
})(jsxRuntime);
const jsx = jsxRuntimeExports.jsx, jsxs = jsxRuntimeExports.jsxs, wrapper$4 = "_wrapper_1658j_1", image = "_image_1658j_6", thumbnail$2 = "_thumbnail_1658j_10", s$4 = {
  wrapper: wrapper$4,
  image,
  thumbnail: thumbnail$2
}, ImageViewer = ({ filePath: be, isThumbnail: ge }) => /* @__PURE__ */ jsx("div", { className: s$4.wrapper, children: /* @__PURE__ */ jsx(
  "img",
  {
    className: `${s$4.image} ${ge ? s$4.thumbnail : ""}`,
    src: be,
    alt: "Work sample image"
  }
) });
var reactExports = requireReact();
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
function commonjsRequire(be) {
  throw new Error('Could not dynamically require "' + be + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var pdfExports = {}, pdf = {
  get exports() {
    return pdfExports;
  },
  set exports(be) {
    pdfExports = be;
  }
};
const __viteBrowserExternal = {}, __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" })), require$$5 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
(function(module, exports) {
  (function(ge, le) {
    module.exports = le();
  })(globalThis, () => (
    /******/
    (() => {
      var __webpack_modules__ = [
        ,
        /* 1 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.VerbosityLevel = ge.Util = ge.UnknownErrorException = ge.UnexpectedResponseException = ge.UNSUPPORTED_FEATURES = ge.TextRenderingMode = ge.StreamType = ge.RenderingIntentFlag = ge.PermissionFlag = ge.PasswordResponses = ge.PasswordException = ge.PageActionEventType = ge.OPS = ge.MissingPDFException = ge.LINE_FACTOR = ge.LINE_DESCENT_FACTOR = ge.InvalidPDFException = ge.ImageKind = ge.IDENTITY_MATRIX = ge.FormatError = ge.FontType = ge.FeatureTest = ge.FONT_IDENTITY_MATRIX = ge.DocumentActionEventType = ge.CMapCompressionType = ge.BaseException = ge.AnnotationType = ge.AnnotationStateModelType = ge.AnnotationReviewState = ge.AnnotationReplyType = ge.AnnotationMode = ge.AnnotationMarkedState = ge.AnnotationFlag = ge.AnnotationFieldFlag = ge.AnnotationEditorType = ge.AnnotationEditorPrefix = ge.AnnotationEditorParamsType = ge.AnnotationBorderStyleType = ge.AnnotationActionEventType = ge.AbortException = void 0, ge.arrayByteLength = N, ge.arraysToBytes = Q, ge.assert = C, ge.bytesToString = se, ge.createPromiseCapability = De, ge.createValidAbsoluteUrl = P, ge.escapeString = de, ge.getModificationDate = ye, ge.getVerbosityLevel = f, ge.info = D, ge.isArrayBuffer = Ce, ge.isArrayEqual = ke, ge.isAscii = pe, ge.objectFromMap = oe, ge.objectSize = te, ge.setVerbosityLevel = x, ge.shadow = M, ge.string32 = E, ge.stringToBytes = q, ge.stringToPDFString = fe, ge.stringToUTF16BEString = xe, ge.stringToUTF8String = Fe, ge.unreachable = S, ge.utf8StringToString = Se, ge.warn = _, le(2);
          const ce = [1, 0, 0, 1, 0, 0];
          ge.IDENTITY_MATRIX = ce;
          const re = [1e-3, 0, 0, 1e-3, 0, 0];
          ge.FONT_IDENTITY_MATRIX = re;
          const ae = 1.35;
          ge.LINE_FACTOR = ae;
          const J = 0.35;
          ge.LINE_DESCENT_FACTOR = J;
          const o = {
            ANY: 1,
            DISPLAY: 2,
            PRINT: 4,
            ANNOTATIONS_FORMS: 16,
            ANNOTATIONS_STORAGE: 32,
            ANNOTATIONS_DISABLE: 64,
            OPLIST: 256
          };
          ge.RenderingIntentFlag = o;
          const F = {
            DISABLE: 0,
            ENABLE: 1,
            ENABLE_FORMS: 2,
            ENABLE_STORAGE: 3
          };
          ge.AnnotationMode = F;
          const t = "pdfjs_internal_editor_";
          ge.AnnotationEditorPrefix = t;
          const a = {
            DISABLE: -1,
            NONE: 0,
            FREETEXT: 3,
            INK: 15
          };
          ge.AnnotationEditorType = a;
          const v = {
            FREETEXT_SIZE: 1,
            FREETEXT_COLOR: 2,
            FREETEXT_OPACITY: 3,
            INK_COLOR: 11,
            INK_THICKNESS: 12,
            INK_OPACITY: 13
          };
          ge.AnnotationEditorParamsType = v;
          const h = {
            PRINT: 4,
            MODIFY_CONTENTS: 8,
            COPY: 16,
            MODIFY_ANNOTATIONS: 32,
            FILL_INTERACTIVE_FORMS: 256,
            COPY_FOR_ACCESSIBILITY: 512,
            ASSEMBLE: 1024,
            PRINT_HIGH_QUALITY: 2048
          };
          ge.PermissionFlag = h;
          const e = {
            FILL: 0,
            STROKE: 1,
            FILL_STROKE: 2,
            INVISIBLE: 3,
            FILL_ADD_TO_PATH: 4,
            STROKE_ADD_TO_PATH: 5,
            FILL_STROKE_ADD_TO_PATH: 6,
            ADD_TO_PATH: 7,
            FILL_STROKE_MASK: 3,
            ADD_TO_PATH_FLAG: 4
          };
          ge.TextRenderingMode = e;
          const y = {
            GRAYSCALE_1BPP: 1,
            RGB_24BPP: 2,
            RGBA_32BPP: 3
          };
          ge.ImageKind = y;
          const c = {
            TEXT: 1,
            LINK: 2,
            FREETEXT: 3,
            LINE: 4,
            SQUARE: 5,
            CIRCLE: 6,
            POLYGON: 7,
            POLYLINE: 8,
            HIGHLIGHT: 9,
            UNDERLINE: 10,
            SQUIGGLY: 11,
            STRIKEOUT: 12,
            STAMP: 13,
            CARET: 14,
            INK: 15,
            POPUP: 16,
            FILEATTACHMENT: 17,
            SOUND: 18,
            MOVIE: 19,
            WIDGET: 20,
            SCREEN: 21,
            PRINTERMARK: 22,
            TRAPNET: 23,
            WATERMARK: 24,
            THREED: 25,
            REDACT: 26
          };
          ge.AnnotationType = c;
          const d = {
            MARKED: "Marked",
            REVIEW: "Review"
          };
          ge.AnnotationStateModelType = d;
          const m = {
            MARKED: "Marked",
            UNMARKED: "Unmarked"
          };
          ge.AnnotationMarkedState = m;
          const p = {
            ACCEPTED: "Accepted",
            REJECTED: "Rejected",
            CANCELLED: "Cancelled",
            COMPLETED: "Completed",
            NONE: "None"
          };
          ge.AnnotationReviewState = p;
          const g = {
            GROUP: "Group",
            REPLY: "R"
          };
          ge.AnnotationReplyType = g;
          const n = {
            INVISIBLE: 1,
            HIDDEN: 2,
            PRINT: 4,
            NOZOOM: 8,
            NOROTATE: 16,
            NOVIEW: 32,
            READONLY: 64,
            LOCKED: 128,
            TOGGLENOVIEW: 256,
            LOCKEDCONTENTS: 512
          };
          ge.AnnotationFlag = n;
          const i = {
            READONLY: 1,
            REQUIRED: 2,
            NOEXPORT: 4,
            MULTILINE: 4096,
            PASSWORD: 8192,
            NOTOGGLETOOFF: 16384,
            RADIO: 32768,
            PUSHBUTTON: 65536,
            COMBO: 131072,
            EDIT: 262144,
            SORT: 524288,
            FILESELECT: 1048576,
            MULTISELECT: 2097152,
            DONOTSPELLCHECK: 4194304,
            DONOTSCROLL: 8388608,
            COMB: 16777216,
            RICHTEXT: 33554432,
            RADIOSINUNISON: 33554432,
            COMMITONSELCHANGE: 67108864
          };
          ge.AnnotationFieldFlag = i;
          const l = {
            SOLID: 1,
            DASHED: 2,
            BEVELED: 3,
            INSET: 4,
            UNDERLINE: 5
          };
          ge.AnnotationBorderStyleType = l;
          const u = {
            E: "Mouse Enter",
            X: "Mouse Exit",
            D: "Mouse Down",
            U: "Mouse Up",
            Fo: "Focus",
            Bl: "Blur",
            PO: "PageOpen",
            PC: "PageClose",
            PV: "PageVisible",
            PI: "PageInvisible",
            K: "Keystroke",
            F: "Format",
            V: "Validate",
            C: "Calculate"
          };
          ge.AnnotationActionEventType = u;
          const w = {
            WC: "WillClose",
            WS: "WillSave",
            DS: "DidSave",
            WP: "WillPrint",
            DP: "DidPrint"
          };
          ge.DocumentActionEventType = w;
          const O = {
            O: "PageOpen",
            C: "PageClose"
          };
          ge.PageActionEventType = O;
          const b = {
            UNKNOWN: "UNKNOWN",
            FLATE: "FLATE",
            LZW: "LZW",
            DCT: "DCT",
            JPX: "JPX",
            JBIG: "JBIG",
            A85: "A85",
            AHX: "AHX",
            CCF: "CCF",
            RLX: "RLX"
          };
          ge.StreamType = b;
          const A = {
            UNKNOWN: "UNKNOWN",
            TYPE1: "TYPE1",
            TYPE1STANDARD: "TYPE1STANDARD",
            TYPE1C: "TYPE1C",
            CIDFONTTYPE0: "CIDFONTTYPE0",
            CIDFONTTYPE0C: "CIDFONTTYPE0C",
            TRUETYPE: "TRUETYPE",
            CIDFONTTYPE2: "CIDFONTTYPE2",
            TYPE3: "TYPE3",
            OPENTYPE: "OPENTYPE",
            TYPE0: "TYPE0",
            MMTYPE1: "MMTYPE1"
          };
          ge.FontType = A;
          const Y = {
            ERRORS: 0,
            WARNINGS: 1,
            INFOS: 5
          };
          ge.VerbosityLevel = Y;
          const j = {
            NONE: 0,
            BINARY: 1,
            STREAM: 2
          };
          ge.CMapCompressionType = j;
          const X = {
            dependency: 1,
            setLineWidth: 2,
            setLineCap: 3,
            setLineJoin: 4,
            setMiterLimit: 5,
            setDash: 6,
            setRenderingIntent: 7,
            setFlatness: 8,
            setGState: 9,
            save: 10,
            restore: 11,
            transform: 12,
            moveTo: 13,
            lineTo: 14,
            curveTo: 15,
            curveTo2: 16,
            curveTo3: 17,
            closePath: 18,
            rectangle: 19,
            stroke: 20,
            closeStroke: 21,
            fill: 22,
            eoFill: 23,
            fillStroke: 24,
            eoFillStroke: 25,
            closeFillStroke: 26,
            closeEOFillStroke: 27,
            endPath: 28,
            clip: 29,
            eoClip: 30,
            beginText: 31,
            endText: 32,
            setCharSpacing: 33,
            setWordSpacing: 34,
            setHScale: 35,
            setLeading: 36,
            setFont: 37,
            setTextRenderingMode: 38,
            setTextRise: 39,
            moveText: 40,
            setLeadingMoveText: 41,
            setTextMatrix: 42,
            nextLine: 43,
            showText: 44,
            showSpacedText: 45,
            nextLineShowText: 46,
            nextLineSetSpacingShowText: 47,
            setCharWidth: 48,
            setCharWidthAndBounds: 49,
            setStrokeColorSpace: 50,
            setFillColorSpace: 51,
            setStrokeColor: 52,
            setStrokeColorN: 53,
            setFillColor: 54,
            setFillColorN: 55,
            setStrokeGray: 56,
            setFillGray: 57,
            setStrokeRGBColor: 58,
            setFillRGBColor: 59,
            setStrokeCMYKColor: 60,
            setFillCMYKColor: 61,
            shadingFill: 62,
            beginInlineImage: 63,
            beginImageData: 64,
            endInlineImage: 65,
            paintXObject: 66,
            markPoint: 67,
            markPointProps: 68,
            beginMarkedContent: 69,
            beginMarkedContentProps: 70,
            endMarkedContent: 71,
            beginCompat: 72,
            endCompat: 73,
            paintFormXObjectBegin: 74,
            paintFormXObjectEnd: 75,
            beginGroup: 76,
            endGroup: 77,
            beginAnnotations: 78,
            endAnnotations: 79,
            beginAnnotation: 80,
            endAnnotation: 81,
            paintJpegXObject: 82,
            paintImageMaskXObject: 83,
            paintImageMaskXObjectGroup: 84,
            paintImageXObject: 85,
            paintInlineImageXObject: 86,
            paintInlineImageXObjectGroup: 87,
            paintImageXObjectRepeat: 88,
            paintImageMaskXObjectRepeat: 89,
            paintSolidColorImageMask: 90,
            constructPath: 91
          };
          ge.OPS = X;
          const B = {
            unknown: "unknown",
            forms: "forms",
            javaScript: "javaScript",
            signatures: "signatures",
            smask: "smask",
            shadingPattern: "shadingPattern",
            font: "font",
            errorTilingPattern: "errorTilingPattern",
            errorExtGState: "errorExtGState",
            errorXObject: "errorXObject",
            errorFontLoadType3: "errorFontLoadType3",
            errorFontState: "errorFontState",
            errorFontMissing: "errorFontMissing",
            errorFontTranslate: "errorFontTranslate",
            errorColorSpace: "errorColorSpace",
            errorOperatorList: "errorOperatorList",
            errorFontToUnicode: "errorFontToUnicode",
            errorFontLoadNative: "errorFontLoadNative",
            errorFontBuildPath: "errorFontBuildPath",
            errorFontGetPath: "errorFontGetPath",
            errorMarkedContent: "errorMarkedContent",
            errorContentSubStream: "errorContentSubStream"
          };
          ge.UNSUPPORTED_FEATURES = B;
          const U = {
            NEED_PASSWORD: 1,
            INCORRECT_PASSWORD: 2
          };
          ge.PasswordResponses = U;
          let k = Y.WARNINGS;
          function x(Ae) {
            Number.isInteger(Ae) && (k = Ae);
          }
          function f() {
            return k;
          }
          function D(Ae) {
            k >= Y.INFOS && console.log(`Info: ${Ae}`);
          }
          function _(Ae) {
            k >= Y.WARNINGS && console.log(`Warning: ${Ae}`);
          }
          function S(Ae) {
            throw new Error(Ae);
          }
          function C(Ae, Te) {
            Ae || S(Te);
          }
          function T(Ae) {
            if (!Ae)
              return !1;
            switch (Ae.protocol) {
              case "http:":
              case "https:":
              case "ftp:":
              case "mailto:":
              case "tel:":
                return !0;
              default:
                return !1;
            }
          }
          function P(Ae, Te = null, ve = null) {
            if (!Ae)
              return null;
            try {
              if (ve && typeof Ae == "string") {
                if (ve.addDefaultProtocol && Ae.startsWith("www.")) {
                  const Ge = Ae.match(/\./g);
                  Ge && Ge.length >= 2 && (Ae = `http://${Ae}`);
                }
                if (ve.tryConvertEncoding)
                  try {
                    Ae = Fe(Ae);
                  } catch {
                  }
              }
              const Ne = Te ? new URL(Ae, Te) : new URL(Ae);
              if (T(Ne))
                return Ne;
            } catch {
            }
            return null;
          }
          function M(Ae, Te, ve) {
            return Object.defineProperty(Ae, Te, {
              value: ve,
              enumerable: !0,
              configurable: !0,
              writable: !1
            }), ve;
          }
          const G = function() {
            function Te(ve, Ne) {
              this.constructor === Te && S("Cannot initialize BaseException."), this.message = ve, this.name = Ne;
            }
            return Te.prototype = new Error(), Te.constructor = Te, Te;
          }();
          ge.BaseException = G;
          class Z extends G {
            constructor(Te, ve) {
              super(Te, "PasswordException"), this.code = ve;
            }
          }
          ge.PasswordException = Z;
          class $ extends G {
            constructor(Te, ve) {
              super(Te, "UnknownErrorException"), this.details = ve;
            }
          }
          ge.UnknownErrorException = $;
          class z extends G {
            constructor(Te) {
              super(Te, "InvalidPDFException");
            }
          }
          ge.InvalidPDFException = z;
          class V extends G {
            constructor(Te) {
              super(Te, "MissingPDFException");
            }
          }
          ge.MissingPDFException = V;
          class L extends G {
            constructor(Te, ve) {
              super(Te, "UnexpectedResponseException"), this.status = ve;
            }
          }
          ge.UnexpectedResponseException = L;
          class K extends G {
            constructor(Te) {
              super(Te, "FormatError");
            }
          }
          ge.FormatError = K;
          class ne extends G {
            constructor(Te) {
              super(Te, "AbortException");
            }
          }
          ge.AbortException = ne;
          function se(Ae) {
            (typeof Ae != "object" || Ae === null || Ae.length === void 0) && S("Invalid argument for bytesToString");
            const Te = Ae.length, ve = 8192;
            if (Te < ve)
              return String.fromCharCode.apply(null, Ae);
            const Ne = [];
            for (let Ge = 0; Ge < Te; Ge += ve) {
              const it = Math.min(Ge + ve, Te), Me = Ae.subarray(Ge, it);
              Ne.push(String.fromCharCode.apply(null, Me));
            }
            return Ne.join("");
          }
          function q(Ae) {
            typeof Ae != "string" && S("Invalid argument for stringToBytes");
            const Te = Ae.length, ve = new Uint8Array(Te);
            for (let Ne = 0; Ne < Te; ++Ne)
              ve[Ne] = Ae.charCodeAt(Ne) & 255;
            return ve;
          }
          function N(Ae) {
            if (Ae.length !== void 0)
              return Ae.length;
            if (Ae.byteLength !== void 0)
              return Ae.byteLength;
            S("Invalid argument for arrayByteLength");
          }
          function Q(Ae) {
            const Te = Ae.length;
            if (Te === 1 && Ae[0] instanceof Uint8Array)
              return Ae[0];
            let ve = 0;
            for (let it = 0; it < Te; it++)
              ve += N(Ae[it]);
            let Ne = 0;
            const Ge = new Uint8Array(ve);
            for (let it = 0; it < Te; it++) {
              let Me = Ae[it];
              Me instanceof Uint8Array || (typeof Me == "string" ? Me = q(Me) : Me = new Uint8Array(Me));
              const Ie = Me.byteLength;
              Ge.set(Me, Ne), Ne += Ie;
            }
            return Ge;
          }
          function E(Ae) {
            return String.fromCharCode(Ae >> 24 & 255, Ae >> 16 & 255, Ae >> 8 & 255, Ae & 255);
          }
          function te(Ae) {
            return Object.keys(Ae).length;
          }
          function oe(Ae) {
            const Te = /* @__PURE__ */ Object.create(null);
            for (const [ve, Ne] of Ae)
              Te[ve] = Ne;
            return Te;
          }
          function ee() {
            const Ae = new Uint8Array(4);
            return Ae[0] = 1, new Uint32Array(Ae.buffer, 0, 1)[0] === 1;
          }
          function W() {
            try {
              return new Function(""), !0;
            } catch {
              return !1;
            }
          }
          class I {
            static get isLittleEndian() {
              return M(this, "isLittleEndian", ee());
            }
            static get isEvalSupported() {
              return M(this, "isEvalSupported", W());
            }
            static get isOffscreenCanvasSupported() {
              return M(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas < "u");
            }
          }
          ge.FeatureTest = I;
          const H = [...Array(256).keys()].map((Ae) => Ae.toString(16).padStart(2, "0"));
          class ie {
            static makeHexColor(Te, ve, Ne) {
              return `#${H[Te]}${H[ve]}${H[Ne]}`;
            }
            static scaleMinMax(Te, ve) {
              let Ne;
              Te[0] ? (Te[0] < 0 && (Ne = ve[0], ve[0] = ve[1], ve[1] = Ne), ve[0] *= Te[0], ve[1] *= Te[0], Te[3] < 0 && (Ne = ve[2], ve[2] = ve[3], ve[3] = Ne), ve[2] *= Te[3], ve[3] *= Te[3]) : (Ne = ve[0], ve[0] = ve[2], ve[2] = Ne, Ne = ve[1], ve[1] = ve[3], ve[3] = Ne, Te[1] < 0 && (Ne = ve[2], ve[2] = ve[3], ve[3] = Ne), ve[2] *= Te[1], ve[3] *= Te[1], Te[2] < 0 && (Ne = ve[0], ve[0] = ve[1], ve[1] = Ne), ve[0] *= Te[2], ve[1] *= Te[2]), ve[0] += Te[4], ve[1] += Te[4], ve[2] += Te[5], ve[3] += Te[5];
            }
            static transform(Te, ve) {
              return [Te[0] * ve[0] + Te[2] * ve[1], Te[1] * ve[0] + Te[3] * ve[1], Te[0] * ve[2] + Te[2] * ve[3], Te[1] * ve[2] + Te[3] * ve[3], Te[0] * ve[4] + Te[2] * ve[5] + Te[4], Te[1] * ve[4] + Te[3] * ve[5] + Te[5]];
            }
            static applyTransform(Te, ve) {
              const Ne = Te[0] * ve[0] + Te[1] * ve[2] + ve[4], Ge = Te[0] * ve[1] + Te[1] * ve[3] + ve[5];
              return [Ne, Ge];
            }
            static applyInverseTransform(Te, ve) {
              const Ne = ve[0] * ve[3] - ve[1] * ve[2], Ge = (Te[0] * ve[3] - Te[1] * ve[2] + ve[2] * ve[5] - ve[4] * ve[3]) / Ne, it = (-Te[0] * ve[1] + Te[1] * ve[0] + ve[4] * ve[1] - ve[5] * ve[0]) / Ne;
              return [Ge, it];
            }
            static getAxialAlignedBoundingBox(Te, ve) {
              const Ne = ie.applyTransform(Te, ve), Ge = ie.applyTransform(Te.slice(2, 4), ve), it = ie.applyTransform([Te[0], Te[3]], ve), Me = ie.applyTransform([Te[2], Te[1]], ve);
              return [Math.min(Ne[0], Ge[0], it[0], Me[0]), Math.min(Ne[1], Ge[1], it[1], Me[1]), Math.max(Ne[0], Ge[0], it[0], Me[0]), Math.max(Ne[1], Ge[1], it[1], Me[1])];
            }
            static inverseTransform(Te) {
              const ve = Te[0] * Te[3] - Te[1] * Te[2];
              return [Te[3] / ve, -Te[1] / ve, -Te[2] / ve, Te[0] / ve, (Te[2] * Te[5] - Te[4] * Te[3]) / ve, (Te[4] * Te[1] - Te[5] * Te[0]) / ve];
            }
            static apply3dTransform(Te, ve) {
              return [Te[0] * ve[0] + Te[1] * ve[1] + Te[2] * ve[2], Te[3] * ve[0] + Te[4] * ve[1] + Te[5] * ve[2], Te[6] * ve[0] + Te[7] * ve[1] + Te[8] * ve[2]];
            }
            static singularValueDecompose2dScale(Te) {
              const ve = [Te[0], Te[2], Te[1], Te[3]], Ne = Te[0] * ve[0] + Te[1] * ve[2], Ge = Te[0] * ve[1] + Te[1] * ve[3], it = Te[2] * ve[0] + Te[3] * ve[2], Me = Te[2] * ve[1] + Te[3] * ve[3], Ie = (Ne + Me) / 2, Ee = Math.sqrt((Ne + Me) ** 2 - 4 * (Ne * Me - it * Ge)) / 2, st = Ie + Ee || 1, Qe = Ie - Ee || 1;
              return [Math.sqrt(st), Math.sqrt(Qe)];
            }
            static normalizeRect(Te) {
              const ve = Te.slice(0);
              return Te[0] > Te[2] && (ve[0] = Te[2], ve[2] = Te[0]), Te[1] > Te[3] && (ve[1] = Te[3], ve[3] = Te[1]), ve;
            }
            static intersect(Te, ve) {
              const Ne = Math.max(Math.min(Te[0], Te[2]), Math.min(ve[0], ve[2])), Ge = Math.min(Math.max(Te[0], Te[2]), Math.max(ve[0], ve[2]));
              if (Ne > Ge)
                return null;
              const it = Math.max(Math.min(Te[1], Te[3]), Math.min(ve[1], ve[3])), Me = Math.min(Math.max(Te[1], Te[3]), Math.max(ve[1], ve[3]));
              return it > Me ? null : [Ne, it, Ge, Me];
            }
            static bezierBoundingBox(Te, ve, Ne, Ge, it, Me, Ie, Ee) {
              const st = [], Qe = [[], []];
              let ct, xt, Je, mt, _t, Xe, Ct, bt;
              for (let lt = 0; lt < 2; ++lt) {
                if (lt === 0 ? (xt = 6 * Te - 12 * Ne + 6 * it, ct = -3 * Te + 9 * Ne - 9 * it + 3 * Ie, Je = 3 * Ne - 3 * Te) : (xt = 6 * ve - 12 * Ge + 6 * Me, ct = -3 * ve + 9 * Ge - 9 * Me + 3 * Ee, Je = 3 * Ge - 3 * ve), Math.abs(ct) < 1e-12) {
                  if (Math.abs(xt) < 1e-12)
                    continue;
                  mt = -Je / xt, 0 < mt && mt < 1 && st.push(mt);
                  continue;
                }
                Ct = xt * xt - 4 * Je * ct, bt = Math.sqrt(Ct), !(Ct < 0) && (_t = (-xt + bt) / (2 * ct), 0 < _t && _t < 1 && st.push(_t), Xe = (-xt - bt) / (2 * ct), 0 < Xe && Xe < 1 && st.push(Xe));
              }
              let Pe = st.length, qe;
              const ot = Pe;
              for (; Pe--; )
                mt = st[Pe], qe = 1 - mt, Qe[0][Pe] = qe * qe * qe * Te + 3 * qe * qe * mt * Ne + 3 * qe * mt * mt * it + mt * mt * mt * Ie, Qe[1][Pe] = qe * qe * qe * ve + 3 * qe * qe * mt * Ge + 3 * qe * mt * mt * Me + mt * mt * mt * Ee;
              return Qe[0][ot] = Te, Qe[1][ot] = ve, Qe[0][ot + 1] = Ie, Qe[1][ot + 1] = Ee, Qe[0].length = Qe[1].length = ot + 2, [Math.min(...Qe[0]), Math.min(...Qe[1]), Math.max(...Qe[0]), Math.max(...Qe[1])];
            }
          }
          ge.Util = ie;
          const ue = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
          function fe(Ae) {
            if (Ae[0] >= "ï") {
              let ve;
              if (Ae[0] === "þ" && Ae[1] === "ÿ" ? ve = "utf-16be" : Ae[0] === "ÿ" && Ae[1] === "þ" ? ve = "utf-16le" : Ae[0] === "ï" && Ae[1] === "»" && Ae[2] === "¿" && (ve = "utf-8"), ve)
                try {
                  const Ne = new TextDecoder(ve, {
                    fatal: !0
                  }), Ge = q(Ae);
                  return Ne.decode(Ge);
                } catch (Ne) {
                  _(`stringToPDFString: "${Ne}".`);
                }
            }
            const Te = [];
            for (let ve = 0, Ne = Ae.length; ve < Ne; ve++) {
              const Ge = ue[Ae.charCodeAt(ve)];
              Te.push(Ge ? String.fromCharCode(Ge) : Ae.charAt(ve));
            }
            return Te.join("");
          }
          function de(Ae) {
            return Ae.replace(/([()\\\n\r])/g, (Te) => Te === `
` ? "\\n" : Te === "\r" ? "\\r" : `\\${Te}`);
          }
          function pe(Ae) {
            return /^[\x00-\x7F]*$/.test(Ae);
          }
          function xe(Ae) {
            const Te = ["þÿ"];
            for (let ve = 0, Ne = Ae.length; ve < Ne; ve++) {
              const Ge = Ae.charCodeAt(ve);
              Te.push(String.fromCharCode(Ge >> 8 & 255), String.fromCharCode(Ge & 255));
            }
            return Te.join("");
          }
          function Fe(Ae) {
            return decodeURIComponent(escape(Ae));
          }
          function Se(Ae) {
            return unescape(encodeURIComponent(Ae));
          }
          function Ce(Ae) {
            return typeof Ae == "object" && Ae !== null && Ae.byteLength !== void 0;
          }
          function ke(Ae, Te) {
            if (Ae.length !== Te.length)
              return !1;
            for (let ve = 0, Ne = Ae.length; ve < Ne; ve++)
              if (Ae[ve] !== Te[ve])
                return !1;
            return !0;
          }
          function ye(Ae = new Date()) {
            return [Ae.getUTCFullYear().toString(), (Ae.getUTCMonth() + 1).toString().padStart(2, "0"), Ae.getUTCDate().toString().padStart(2, "0"), Ae.getUTCHours().toString().padStart(2, "0"), Ae.getUTCMinutes().toString().padStart(2, "0"), Ae.getUTCSeconds().toString().padStart(2, "0")].join("");
          }
          function De() {
            const Ae = /* @__PURE__ */ Object.create(null);
            let Te = !1;
            return Object.defineProperty(Ae, "settled", {
              get() {
                return Te;
              }
            }), Ae.promise = new Promise(function(ve, Ne) {
              Ae.resolve = function(Ge) {
                Te = !0, ve(Ge);
              }, Ae.reject = function(Ge) {
                Te = !0, Ne(Ge);
              };
            }), Ae;
          }
        },
        /* 2 */
        /***/
        (be, ge, le) => {
          le(3);
        },
        /* 3 */
        /***/
        (be, ge) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.isNodeJS = void 0;
          const le = typeof process == "object" && process + "" == "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
          ge.isNodeJS = le;
        },
        /* 4 */
        /***/
        (__unused_webpack_module, exports, __w_pdfjs_require__) => {
          var be, le, ce, re, ae, J, o, F, t, fi, v, h;
          Object.defineProperty(exports, "__esModule", {
            value: !0
          }), exports.build = exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0, exports.getDocument = getDocument, exports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory, exports.version = void 0;
          var _util = __w_pdfjs_require__(1), _annotation_storage = __w_pdfjs_require__(5), _display_utils = __w_pdfjs_require__(8), _font_loader = __w_pdfjs_require__(11), _canvas = __w_pdfjs_require__(12), _worker_options = __w_pdfjs_require__(15), _is_node = __w_pdfjs_require__(3), _message_handler = __w_pdfjs_require__(16), _metadata = __w_pdfjs_require__(17), _optional_content_config = __w_pdfjs_require__(18), _transport_stream = __w_pdfjs_require__(19), _xfa_text = __w_pdfjs_require__(20);
          const DEFAULT_RANGE_CHUNK_SIZE = 65536, RENDERING_CANCELLED_TIMEOUT = 100;
          let DefaultCanvasFactory = _display_utils.DOMCanvasFactory;
          exports.DefaultCanvasFactory = DefaultCanvasFactory;
          let DefaultCMapReaderFactory = _display_utils.DOMCMapReaderFactory;
          exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;
          let DefaultStandardFontDataFactory = _display_utils.DOMStandardFontDataFactory;
          if (exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory, _is_node.isNodeJS) {
            const {
              NodeCanvasFactory: y,
              NodeCMapReaderFactory: c,
              NodeStandardFontDataFactory: d
            } = __w_pdfjs_require__(21);
            exports.DefaultCanvasFactory = DefaultCanvasFactory = y, exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory = c, exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory = d;
          }
          let createPDFNetworkStream;
          function setPDFNetworkStreamFactory(y) {
            createPDFNetworkStream = y;
          }
          function getDocument(y) {
            const c = new PDFDocumentLoadingTask();
            let d;
            if (typeof y == "string" || y instanceof URL)
              d = {
                url: y
              };
            else if ((0, _util.isArrayBuffer)(y))
              d = {
                data: y
              };
            else if (y instanceof PDFDataRangeTransport)
              d = {
                range: y
              };
            else {
              if (typeof y != "object")
                throw new Error("Invalid parameter in getDocument, need either string, URL, TypedArray, or parameter object.");
              if (!y.url && !y.data && !y.range)
                throw new Error("Invalid parameter object: need either .data, .range or .url");
              d = y;
            }
            const m = /* @__PURE__ */ Object.create(null);
            let p = null, g = null;
            for (const i in d) {
              const l = d[i];
              switch (i) {
                case "url":
                  if (typeof window < "u")
                    try {
                      m[i] = new URL(l, window.location).href;
                      continue;
                    } catch (u) {
                      (0, _util.warn)(`Cannot create valid URL: "${u}".`);
                    }
                  else if (typeof l == "string" || l instanceof URL) {
                    m[i] = l.toString();
                    continue;
                  }
                  throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
                case "range":
                  p = l;
                  continue;
                case "worker":
                  g = l;
                  continue;
                case "data":
                  if (_is_node.isNodeJS && typeof Buffer < "u" && l instanceof Buffer)
                    m[i] = new Uint8Array(l);
                  else {
                    if (l instanceof Uint8Array)
                      break;
                    if (typeof l == "string")
                      m[i] = (0, _util.stringToBytes)(l);
                    else if (typeof l == "object" && l !== null && !isNaN(l.length))
                      m[i] = new Uint8Array(l);
                    else if ((0, _util.isArrayBuffer)(l))
                      m[i] = new Uint8Array(l);
                    else
                      throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
                  }
                  continue;
              }
              m[i] = l;
            }
            if (m.CMapReaderFactory = m.CMapReaderFactory || DefaultCMapReaderFactory, m.StandardFontDataFactory = m.StandardFontDataFactory || DefaultStandardFontDataFactory, m.ignoreErrors = m.stopAtErrors !== !0, m.fontExtraProperties = m.fontExtraProperties === !0, m.pdfBug = m.pdfBug === !0, m.enableXfa = m.enableXfa === !0, (!Number.isInteger(m.rangeChunkSize) || m.rangeChunkSize < 1) && (m.rangeChunkSize = DEFAULT_RANGE_CHUNK_SIZE), (typeof m.docBaseUrl != "string" || (0, _display_utils.isDataScheme)(m.docBaseUrl)) && (m.docBaseUrl = null), (!Number.isInteger(m.maxImageSize) || m.maxImageSize < -1) && (m.maxImageSize = -1), typeof m.cMapUrl != "string" && (m.cMapUrl = null), typeof m.standardFontDataUrl != "string" && (m.standardFontDataUrl = null), typeof m.useWorkerFetch != "boolean" && (m.useWorkerFetch = m.CMapReaderFactory === _display_utils.DOMCMapReaderFactory && m.StandardFontDataFactory === _display_utils.DOMStandardFontDataFactory), typeof m.isEvalSupported != "boolean" && (m.isEvalSupported = !0), typeof m.disableFontFace != "boolean" && (m.disableFontFace = _is_node.isNodeJS), typeof m.useSystemFonts != "boolean" && (m.useSystemFonts = !_is_node.isNodeJS && !m.disableFontFace), (typeof m.ownerDocument != "object" || m.ownerDocument === null) && (m.ownerDocument = globalThis.document), typeof m.disableRange != "boolean" && (m.disableRange = !1), typeof m.disableStream != "boolean" && (m.disableStream = !1), typeof m.disableAutoFetch != "boolean" && (m.disableAutoFetch = !1), (0, _util.setVerbosityLevel)(m.verbosity), !g) {
              const i = {
                verbosity: m.verbosity,
                port: _worker_options.GlobalWorkerOptions.workerPort
              };
              g = i.port ? PDFWorker.fromPort(i) : new PDFWorker(i), c._worker = g;
            }
            const n = c.docId;
            return g.promise.then(function() {
              if (c.destroyed)
                throw new Error("Loading aborted");
              const i = _fetchDocument(g, m, p, n), l = new Promise(function(u) {
                let w;
                p ? w = new _transport_stream.PDFDataTransportStream({
                  length: m.length,
                  initialData: m.initialData,
                  progressiveDone: m.progressiveDone,
                  contentDispositionFilename: m.contentDispositionFilename,
                  disableRange: m.disableRange,
                  disableStream: m.disableStream
                }, p) : m.data || (w = createPDFNetworkStream({
                  url: m.url,
                  length: m.length,
                  httpHeaders: m.httpHeaders,
                  withCredentials: m.withCredentials,
                  rangeChunkSize: m.rangeChunkSize,
                  disableRange: m.disableRange,
                  disableStream: m.disableStream
                })), u(w);
              });
              return Promise.all([i, l]).then(function([u, w]) {
                if (c.destroyed)
                  throw new Error("Loading aborted");
                const O = new _message_handler.MessageHandler(n, u, g.port), b = new WorkerTransport(O, c, w, m);
                c._transport = b, O.send("Ready", null);
              });
            }).catch(c._capability.reject), c;
          }
          async function _fetchDocument(y, c, d, m) {
            if (y.destroyed)
              throw new Error("Worker was destroyed");
            d && (c.length = d.length, c.initialData = d.initialData, c.progressiveDone = d.progressiveDone, c.contentDispositionFilename = d.contentDispositionFilename);
            const p = await y.messageHandler.sendWithPromise("GetDocRequest", {
              docId: m,
              apiVersion: "2.16.105",
              source: {
                data: c.data,
                url: c.url,
                password: c.password,
                disableAutoFetch: c.disableAutoFetch,
                rangeChunkSize: c.rangeChunkSize,
                length: c.length
              },
              maxImageSize: c.maxImageSize,
              disableFontFace: c.disableFontFace,
              docBaseUrl: c.docBaseUrl,
              ignoreErrors: c.ignoreErrors,
              isEvalSupported: c.isEvalSupported,
              fontExtraProperties: c.fontExtraProperties,
              enableXfa: c.enableXfa,
              useSystemFonts: c.useSystemFonts,
              cMapUrl: c.useWorkerFetch ? c.cMapUrl : null,
              standardFontDataUrl: c.useWorkerFetch ? c.standardFontDataUrl : null
            });
            if (c.data && (c.data = null), y.destroyed)
              throw new Error("Worker was destroyed");
            return p;
          }
          const ge = class {
            constructor() {
              this._capability = (0, _util.createPromiseCapability)(), this._transport = null, this._worker = null, this.docId = `d${di(ge, be)._++}`, this.destroyed = !1, this.onPassword = null, this.onProgress = null, this.onUnsupportedFeature = null;
            }
            get promise() {
              return this._capability.promise;
            }
            async destroy() {
              var c;
              this.destroyed = !0, await ((c = this._transport) == null ? void 0 : c.destroy()), this._transport = null, this._worker && (this._worker.destroy(), this._worker = null);
            }
          };
          let PDFDocumentLoadingTask = ge;
          be = new WeakMap(), gt(PDFDocumentLoadingTask, be, 0), exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;
          class PDFDataRangeTransport {
            constructor(c, d, m = !1, p = null) {
              this.length = c, this.initialData = d, this.progressiveDone = m, this.contentDispositionFilename = p, this._rangeListeners = [], this._progressListeners = [], this._progressiveReadListeners = [], this._progressiveDoneListeners = [], this._readyCapability = (0, _util.createPromiseCapability)();
            }
            addRangeListener(c) {
              this._rangeListeners.push(c);
            }
            addProgressListener(c) {
              this._progressListeners.push(c);
            }
            addProgressiveReadListener(c) {
              this._progressiveReadListeners.push(c);
            }
            addProgressiveDoneListener(c) {
              this._progressiveDoneListeners.push(c);
            }
            onDataRange(c, d) {
              for (const m of this._rangeListeners)
                m(c, d);
            }
            onDataProgress(c, d) {
              this._readyCapability.promise.then(() => {
                for (const m of this._progressListeners)
                  m(c, d);
              });
            }
            onDataProgressiveRead(c) {
              this._readyCapability.promise.then(() => {
                for (const d of this._progressiveReadListeners)
                  d(c);
              });
            }
            onDataProgressiveDone() {
              this._readyCapability.promise.then(() => {
                for (const c of this._progressiveDoneListeners)
                  c();
              });
            }
            transportReady() {
              this._readyCapability.resolve();
            }
            requestDataRange(c, d) {
              (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
            }
            abort() {
            }
          }
          exports.PDFDataRangeTransport = PDFDataRangeTransport;
          class PDFDocumentProxy {
            constructor(c, d) {
              this._pdfInfo = c, this._transport = d, Object.defineProperty(this, "fingerprint", {
                get() {
                  return (0, _display_utils.deprecated)("`PDFDocumentProxy.fingerprint`, please use `PDFDocumentProxy.fingerprints` instead."), this.fingerprints[0];
                }
              }), Object.defineProperty(this, "getStats", {
                value: async () => ((0, _display_utils.deprecated)("`PDFDocumentProxy.getStats`, please use the `PDFDocumentProxy.stats`-getter instead."), this.stats || {
                  streamTypes: {},
                  fontTypes: {}
                })
              });
            }
            get annotationStorage() {
              return this._transport.annotationStorage;
            }
            get numPages() {
              return this._pdfInfo.numPages;
            }
            get fingerprints() {
              return this._pdfInfo.fingerprints;
            }
            get stats() {
              return this._transport.stats;
            }
            get isPureXfa() {
              return !!this._transport._htmlForXfa;
            }
            get allXfaHtml() {
              return this._transport._htmlForXfa;
            }
            getPage(c) {
              return this._transport.getPage(c);
            }
            getPageIndex(c) {
              return this._transport.getPageIndex(c);
            }
            getDestinations() {
              return this._transport.getDestinations();
            }
            getDestination(c) {
              return this._transport.getDestination(c);
            }
            getPageLabels() {
              return this._transport.getPageLabels();
            }
            getPageLayout() {
              return this._transport.getPageLayout();
            }
            getPageMode() {
              return this._transport.getPageMode();
            }
            getViewerPreferences() {
              return this._transport.getViewerPreferences();
            }
            getOpenAction() {
              return this._transport.getOpenAction();
            }
            getAttachments() {
              return this._transport.getAttachments();
            }
            getJavaScript() {
              return this._transport.getJavaScript();
            }
            getJSActions() {
              return this._transport.getDocJSActions();
            }
            getOutline() {
              return this._transport.getOutline();
            }
            getOptionalContentConfig() {
              return this._transport.getOptionalContentConfig();
            }
            getPermissions() {
              return this._transport.getPermissions();
            }
            getMetadata() {
              return this._transport.getMetadata();
            }
            getMarkInfo() {
              return this._transport.getMarkInfo();
            }
            getData() {
              return this._transport.getData();
            }
            getDownloadInfo() {
              return this._transport.downloadInfoCapability.promise;
            }
            cleanup(c = !1) {
              return this._transport.startCleanup(c || this.isPureXfa);
            }
            destroy() {
              return this.loadingTask.destroy();
            }
            get loadingParams() {
              return this._transport.loadingParams;
            }
            get loadingTask() {
              return this._transport.loadingTask;
            }
            saveDocument() {
              return this._transport.annotationStorage.size <= 0 && (0, _display_utils.deprecated)("saveDocument called while `annotationStorage` is empty, please use the getData-method instead."), this._transport.saveDocument();
            }
            getFieldObjects() {
              return this._transport.getFieldObjects();
            }
            hasJSActions() {
              return this._transport.hasJSActions();
            }
            getCalculationOrderIds() {
              return this._transport.getCalculationOrderIds();
            }
          }
          exports.PDFDocumentProxy = PDFDocumentProxy;
          class PDFPageProxy {
            constructor(c, d, m, p, g = !1) {
              this._pageIndex = c, this._pageInfo = d, this._ownerDocument = p, this._transport = m, this._stats = g ? new _display_utils.StatTimer() : null, this._pdfBug = g, this.commonObjs = m.commonObjs, this.objs = new PDFObjects(), this._bitmaps = /* @__PURE__ */ new Set(), this.cleanupAfterRender = !1, this.pendingCleanup = !1, this._intentStates = /* @__PURE__ */ new Map(), this._annotationPromises = /* @__PURE__ */ new Map(), this.destroyed = !1;
            }
            get pageNumber() {
              return this._pageIndex + 1;
            }
            get rotate() {
              return this._pageInfo.rotate;
            }
            get ref() {
              return this._pageInfo.ref;
            }
            get userUnit() {
              return this._pageInfo.userUnit;
            }
            get view() {
              return this._pageInfo.view;
            }
            getViewport({
              scale: c,
              rotation: d = this.rotate,
              offsetX: m = 0,
              offsetY: p = 0,
              dontFlip: g = !1
            } = {}) {
              return new _display_utils.PageViewport({
                viewBox: this.view,
                scale: c,
                rotation: d,
                offsetX: m,
                offsetY: p,
                dontFlip: g
              });
            }
            getAnnotations({
              intent: c = "display"
            } = {}) {
              const d = this._transport.getRenderingIntent(c);
              let m = this._annotationPromises.get(d.cacheKey);
              return m || (m = this._transport.getAnnotations(this._pageIndex, d.renderingIntent), this._annotationPromises.set(d.cacheKey, m), m = m.then((p) => {
                for (const g of p)
                  g.titleObj !== void 0 && Object.defineProperty(g, "title", {
                    get() {
                      return (0, _display_utils.deprecated)("`title`-property on annotation, please use `titleObj` instead."), g.titleObj.str;
                    }
                  }), g.contentsObj !== void 0 && Object.defineProperty(g, "contents", {
                    get() {
                      return (0, _display_utils.deprecated)("`contents`-property on annotation, please use `contentsObj` instead."), g.contentsObj.str;
                    }
                  });
                return p;
              })), m;
            }
            getJSActions() {
              return this._jsActionsPromise || (this._jsActionsPromise = this._transport.getPageJSActions(this._pageIndex));
            }
            async getXfa() {
              var c;
              return ((c = this._transport._htmlForXfa) == null ? void 0 : c.children[this._pageIndex]) || null;
            }
            render({
              canvasContext: c,
              viewport: d,
              intent: m = "display",
              annotationMode: p = _util.AnnotationMode.ENABLE,
              transform: g = null,
              imageLayer: n = null,
              canvasFactory: i = null,
              background: l = null,
              optionalContentConfigPromise: u = null,
              annotationCanvasMap: w = null,
              pageColors: O = null,
              printAnnotationStorage: b = null
            }) {
              var x, f;
              ((x = arguments[0]) == null ? void 0 : x.renderInteractiveForms) !== void 0 && ((0, _display_utils.deprecated)("render no longer accepts the `renderInteractiveForms`-option, please use the `annotationMode`-option instead."), arguments[0].renderInteractiveForms === !0 && p === _util.AnnotationMode.ENABLE && (p = _util.AnnotationMode.ENABLE_FORMS)), ((f = arguments[0]) == null ? void 0 : f.includeAnnotationStorage) !== void 0 && ((0, _display_utils.deprecated)("render no longer accepts the `includeAnnotationStorage`-option, please use the `annotationMode`-option instead."), arguments[0].includeAnnotationStorage === !0 && p === _util.AnnotationMode.ENABLE && (p = _util.AnnotationMode.ENABLE_STORAGE)), this._stats && this._stats.time("Overall");
              const A = this._transport.getRenderingIntent(m, p, b);
              this.pendingCleanup = !1, u || (u = this._transport.getOptionalContentConfig());
              let Y = this._intentStates.get(A.cacheKey);
              Y || (Y = /* @__PURE__ */ Object.create(null), this._intentStates.set(A.cacheKey, Y)), Y.streamReaderCancelTimeout && (clearTimeout(Y.streamReaderCancelTimeout), Y.streamReaderCancelTimeout = null);
              const j = i || new DefaultCanvasFactory({
                ownerDocument: this._ownerDocument
              }), X = !!(A.renderingIntent & _util.RenderingIntentFlag.PRINT);
              Y.displayReadyCapability || (Y.displayReadyCapability = (0, _util.createPromiseCapability)(), Y.operatorList = {
                fnArray: [],
                argsArray: [],
                lastChunk: !1,
                separateAnnots: null
              }, this._stats && this._stats.time("Page Request"), this._pumpOperatorList(A));
              const B = (D) => {
                Y.renderTasks.delete(U), (this.cleanupAfterRender || X) && (this.pendingCleanup = !0), this._tryCleanup(), D ? (U.capability.reject(D), this._abortOperatorList({
                  intentState: Y,
                  reason: D instanceof Error ? D : new Error(D)
                })) : U.capability.resolve(), this._stats && (this._stats.timeEnd("Rendering"), this._stats.timeEnd("Overall"));
              }, U = new InternalRenderTask({
                callback: B,
                params: {
                  canvasContext: c,
                  viewport: d,
                  transform: g,
                  imageLayer: n,
                  background: l
                },
                objs: this.objs,
                commonObjs: this.commonObjs,
                annotationCanvasMap: w,
                operatorList: Y.operatorList,
                pageIndex: this._pageIndex,
                canvasFactory: j,
                useRequestAnimationFrame: !X,
                pdfBug: this._pdfBug,
                pageColors: O
              });
              (Y.renderTasks || (Y.renderTasks = /* @__PURE__ */ new Set())).add(U);
              const k = U.task;
              return Promise.all([Y.displayReadyCapability.promise, u]).then(([D, _]) => {
                if (this.pendingCleanup) {
                  B();
                  return;
                }
                this._stats && this._stats.time("Rendering"), U.initializeGraphics({
                  transparency: D,
                  optionalContentConfig: _
                }), U.operatorListChanged();
              }).catch(B), k;
            }
            getOperatorList({
              intent: c = "display",
              annotationMode: d = _util.AnnotationMode.ENABLE,
              printAnnotationStorage: m = null
            } = {}) {
              function p() {
                n.operatorList.lastChunk && (n.opListReadCapability.resolve(n.operatorList), n.renderTasks.delete(i));
              }
              const g = this._transport.getRenderingIntent(c, d, m, !0);
              let n = this._intentStates.get(g.cacheKey);
              n || (n = /* @__PURE__ */ Object.create(null), this._intentStates.set(g.cacheKey, n));
              let i;
              return n.opListReadCapability || (i = /* @__PURE__ */ Object.create(null), i.operatorListChanged = p, n.opListReadCapability = (0, _util.createPromiseCapability)(), (n.renderTasks || (n.renderTasks = /* @__PURE__ */ new Set())).add(i), n.operatorList = {
                fnArray: [],
                argsArray: [],
                lastChunk: !1,
                separateAnnots: null
              }, this._stats && this._stats.time("Page Request"), this._pumpOperatorList(g)), n.opListReadCapability.promise;
            }
            streamTextContent({
              disableCombineTextItems: c = !1,
              includeMarkedContent: d = !1
            } = {}) {
              return this._transport.messageHandler.sendWithStream("GetTextContent", {
                pageIndex: this._pageIndex,
                combineTextItems: c !== !0,
                includeMarkedContent: d === !0
              }, {
                highWaterMark: 100,
                size(p) {
                  return p.items.length;
                }
              });
            }
            getTextContent(c = {}) {
              if (this._transport._htmlForXfa)
                return this.getXfa().then((m) => _xfa_text.XfaText.textContent(m));
              const d = this.streamTextContent(c);
              return new Promise(function(m, p) {
                function g() {
                  n.read().then(function({
                    value: l,
                    done: u
                  }) {
                    if (u) {
                      m(i);
                      return;
                    }
                    Object.assign(i.styles, l.styles), i.items.push(...l.items), g();
                  }, p);
                }
                const n = d.getReader(), i = {
                  items: [],
                  styles: /* @__PURE__ */ Object.create(null)
                };
                g();
              });
            }
            getStructTree() {
              return this._structTreePromise || (this._structTreePromise = this._transport.getStructTree(this._pageIndex));
            }
            _destroy() {
              this.destroyed = !0;
              const c = [];
              for (const d of this._intentStates.values())
                if (this._abortOperatorList({
                  intentState: d,
                  reason: new Error("Page was destroyed."),
                  force: !0
                }), !d.opListReadCapability)
                  for (const m of d.renderTasks)
                    c.push(m.completed), m.cancel();
              this.objs.clear();
              for (const d of this._bitmaps)
                d.close();
              return this._bitmaps.clear(), this._annotationPromises.clear(), this._jsActionsPromise = null, this._structTreePromise = null, this.pendingCleanup = !1, Promise.all(c);
            }
            cleanup(c = !1) {
              return this.pendingCleanup = !0, this._tryCleanup(c);
            }
            _tryCleanup(c = !1) {
              if (!this.pendingCleanup)
                return !1;
              for (const {
                renderTasks: d,
                operatorList: m
              } of this._intentStates.values())
                if (d.size > 0 || !m.lastChunk)
                  return !1;
              this._intentStates.clear(), this.objs.clear(), this._annotationPromises.clear(), this._jsActionsPromise = null, this._structTreePromise = null, c && this._stats && (this._stats = new _display_utils.StatTimer());
              for (const d of this._bitmaps)
                d.close();
              return this._bitmaps.clear(), this.pendingCleanup = !1, !0;
            }
            _startRenderPage(c, d) {
              const m = this._intentStates.get(d);
              m && (this._stats && this._stats.timeEnd("Page Request"), m.displayReadyCapability && m.displayReadyCapability.resolve(c));
            }
            _renderPageChunk(c, d) {
              for (let m = 0, p = c.length; m < p; m++)
                d.operatorList.fnArray.push(c.fnArray[m]), d.operatorList.argsArray.push(c.argsArray[m]);
              d.operatorList.lastChunk = c.lastChunk, d.operatorList.separateAnnots = c.separateAnnots;
              for (const m of d.renderTasks)
                m.operatorListChanged();
              c.lastChunk && this._tryCleanup();
            }
            _pumpOperatorList({
              renderingIntent: c,
              cacheKey: d,
              annotationStorageMap: m
            }) {
              const g = this._transport.messageHandler.sendWithStream("GetOperatorList", {
                pageIndex: this._pageIndex,
                intent: c,
                cacheKey: d,
                annotationStorage: m
              }).getReader(), n = this._intentStates.get(d);
              n.streamReader = g;
              const i = () => {
                g.read().then(({
                  value: l,
                  done: u
                }) => {
                  if (u) {
                    n.streamReader = null;
                    return;
                  }
                  this._transport.destroyed || (this._renderPageChunk(l, n), i());
                }, (l) => {
                  if (n.streamReader = null, !this._transport.destroyed) {
                    if (n.operatorList) {
                      n.operatorList.lastChunk = !0;
                      for (const u of n.renderTasks)
                        u.operatorListChanged();
                      this._tryCleanup();
                    }
                    if (n.displayReadyCapability)
                      n.displayReadyCapability.reject(l);
                    else if (n.opListReadCapability)
                      n.opListReadCapability.reject(l);
                    else
                      throw l;
                  }
                });
              };
              i();
            }
            _abortOperatorList({
              intentState: c,
              reason: d,
              force: m = !1
            }) {
              if (c.streamReader) {
                if (!m) {
                  if (c.renderTasks.size > 0)
                    return;
                  if (d instanceof _display_utils.RenderingCancelledException) {
                    c.streamReaderCancelTimeout = setTimeout(() => {
                      this._abortOperatorList({
                        intentState: c,
                        reason: d,
                        force: !0
                      }), c.streamReaderCancelTimeout = null;
                    }, RENDERING_CANCELLED_TIMEOUT);
                    return;
                  }
                }
                if (c.streamReader.cancel(new _util.AbortException(d.message)).catch(() => {
                }), c.streamReader = null, !this._transport.destroyed) {
                  for (const [p, g] of this._intentStates)
                    if (g === c) {
                      this._intentStates.delete(p);
                      break;
                    }
                  this.cleanup();
                }
              }
            }
            get stats() {
              return this._stats;
            }
          }
          exports.PDFPageProxy = PDFPageProxy;
          class LoopbackPort {
            constructor() {
              this._listeners = [], this._deferred = Promise.resolve();
            }
            postMessage(c, d) {
              const m = {
                data: structuredClone(c, d)
              };
              this._deferred.then(() => {
                for (const p of this._listeners)
                  p.call(this, m);
              });
            }
            addEventListener(c, d) {
              this._listeners.push(d);
            }
            removeEventListener(c, d) {
              const m = this._listeners.indexOf(d);
              this._listeners.splice(m, 1);
            }
            terminate() {
              this._listeners.length = 0;
            }
          }
          exports.LoopbackPort = LoopbackPort;
          const PDFWorkerUtil = {
            isWorkerDisabled: !1,
            fallbackWorkerSrc: null,
            fakeWorkerId: 0
          };
          exports.PDFWorkerUtil = PDFWorkerUtil;
          {
            if (_is_node.isNodeJS && typeof commonjsRequire == "function")
              PDFWorkerUtil.isWorkerDisabled = !0, PDFWorkerUtil.fallbackWorkerSrc = "./pdf.worker.js";
            else if (typeof document == "object") {
              const y = (le = document == null ? void 0 : document.currentScript) == null ? void 0 : le.src;
              y && (PDFWorkerUtil.fallbackWorkerSrc = y.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2"));
            }
            PDFWorkerUtil.isSameOrigin = function(y, c) {
              let d;
              try {
                if (d = new URL(y), !d.origin || d.origin === "null")
                  return !1;
              } catch {
                return !1;
              }
              const m = new URL(c, d);
              return d.origin === m.origin;
            }, PDFWorkerUtil.createCDNWrapper = function(y) {
              const c = `importScripts("${y}");`;
              return URL.createObjectURL(new Blob([c]));
            };
          }
          const _PDFWorker = class {
            constructor({
              name: y = null,
              port: c = null,
              verbosity: d = (0, _util.getVerbosityLevel)()
            } = {}) {
              if (c && Oe(_PDFWorker, ce).has(c))
                throw new Error("Cannot use more than one PDFWorker per port.");
              if (this.name = y, this.destroyed = !1, this.verbosity = d, this._readyCapability = (0, _util.createPromiseCapability)(), this._port = null, this._webWorker = null, this._messageHandler = null, c) {
                Oe(_PDFWorker, ce).set(c, this), this._initializeFromPort(c);
                return;
              }
              this._initialize();
            }
            get promise() {
              return this._readyCapability.promise;
            }
            get port() {
              return this._port;
            }
            get messageHandler() {
              return this._messageHandler;
            }
            _initializeFromPort(y) {
              this._port = y, this._messageHandler = new _message_handler.MessageHandler("main", "worker", y), this._messageHandler.on("ready", function() {
              }), this._readyCapability.resolve();
            }
            _initialize() {
              if (!PDFWorkerUtil.isWorkerDisabled && !_PDFWorker._mainThreadWorkerMessageHandler) {
                let {
                  workerSrc: y
                } = _PDFWorker;
                try {
                  PDFWorkerUtil.isSameOrigin(window.location.href, y) || (y = PDFWorkerUtil.createCDNWrapper(new URL(y, window.location).href));
                  const c = new Worker(y), d = new _message_handler.MessageHandler("main", "worker", c), m = () => {
                    c.removeEventListener("error", p), d.destroy(), c.terminate(), this.destroyed ? this._readyCapability.reject(new Error("Worker was destroyed")) : this._setupFakeWorker();
                  }, p = () => {
                    this._webWorker || m();
                  };
                  c.addEventListener("error", p), d.on("test", (n) => {
                    if (c.removeEventListener("error", p), this.destroyed) {
                      m();
                      return;
                    }
                    n ? (this._messageHandler = d, this._port = c, this._webWorker = c, this._readyCapability.resolve(), d.send("configure", {
                      verbosity: this.verbosity
                    })) : (this._setupFakeWorker(), d.destroy(), c.terminate());
                  }), d.on("ready", (n) => {
                    if (c.removeEventListener("error", p), this.destroyed) {
                      m();
                      return;
                    }
                    try {
                      g();
                    } catch {
                      this._setupFakeWorker();
                    }
                  });
                  const g = () => {
                    const n = new Uint8Array();
                    d.send("test", n, [n.buffer]);
                  };
                  g();
                  return;
                } catch {
                  (0, _util.info)("The worker has been disabled.");
                }
              }
              this._setupFakeWorker();
            }
            _setupFakeWorker() {
              PDFWorkerUtil.isWorkerDisabled || ((0, _util.warn)("Setting up fake worker."), PDFWorkerUtil.isWorkerDisabled = !0), _PDFWorker._setupFakeWorkerGlobal.then((y) => {
                if (this.destroyed) {
                  this._readyCapability.reject(new Error("Worker was destroyed"));
                  return;
                }
                const c = new LoopbackPort();
                this._port = c;
                const d = `fake${PDFWorkerUtil.fakeWorkerId++}`, m = new _message_handler.MessageHandler(d + "_worker", d, c);
                y.setup(m, c);
                const p = new _message_handler.MessageHandler(d, d + "_worker", c);
                this._messageHandler = p, this._readyCapability.resolve(), p.send("configure", {
                  verbosity: this.verbosity
                });
              }).catch((y) => {
                this._readyCapability.reject(new Error(`Setting up fake worker failed: "${y.message}".`));
              });
            }
            destroy() {
              this.destroyed = !0, this._webWorker && (this._webWorker.terminate(), this._webWorker = null), Oe(_PDFWorker, ce).delete(this._port), this._port = null, this._messageHandler && (this._messageHandler.destroy(), this._messageHandler = null);
            }
            static fromPort(y) {
              if (!(y != null && y.port))
                throw new Error("PDFWorker.fromPort - invalid method signature.");
              return Oe(this, ce).has(y.port) ? Oe(this, ce).get(y.port) : new _PDFWorker(y);
            }
            static get workerSrc() {
              if (_worker_options.GlobalWorkerOptions.workerSrc)
                return _worker_options.GlobalWorkerOptions.workerSrc;
              if (PDFWorkerUtil.fallbackWorkerSrc !== null)
                return _is_node.isNodeJS || (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.'), PDFWorkerUtil.fallbackWorkerSrc;
              throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
            }
            static get _mainThreadWorkerMessageHandler() {
              var y;
              try {
                return ((y = globalThis.pdfjsWorker) == null ? void 0 : y.WorkerMessageHandler) || null;
              } catch {
                return null;
              }
            }
            static get _setupFakeWorkerGlobal() {
              const loader = async () => {
                const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler;
                if (mainWorkerMessageHandler)
                  return mainWorkerMessageHandler;
                if (_is_node.isNodeJS && typeof commonjsRequire == "function") {
                  const worker = eval("require")(this.workerSrc);
                  return worker.WorkerMessageHandler;
                }
                return await (0, _display_utils.loadScript)(this.workerSrc), window.pdfjsWorker.WorkerMessageHandler;
              };
              return (0, _util.shadow)(this, "_setupFakeWorkerGlobal", loader());
            }
          };
          let PDFWorker = _PDFWorker;
          ce = new WeakMap(), gt(PDFWorker, ce, /* @__PURE__ */ new WeakMap()), exports.PDFWorker = PDFWorker, PDFWorker.getWorkerSrc = function() {
            return (0, _display_utils.deprecated)("`PDFWorker.getWorkerSrc()`, please use `PDFWorker.workerSrc` instead."), this.workerSrc;
          };
          class WorkerTransport {
            constructor(c, d, m, p) {
              gt(this, re, null);
              gt(this, ae, /* @__PURE__ */ new Map());
              gt(this, J, /* @__PURE__ */ new Map());
              gt(this, o, null);
              this.messageHandler = c, this.loadingTask = d, this.commonObjs = new PDFObjects(), this.fontLoader = new _font_loader.FontLoader({
                docId: d.docId,
                onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
                ownerDocument: p.ownerDocument,
                styleElement: p.styleElement
              }), this._params = p, p.useWorkerFetch || (this.CMapReaderFactory = new p.CMapReaderFactory({
                baseUrl: p.cMapUrl,
                isCompressed: p.cMapPacked
              }), this.StandardFontDataFactory = new p.StandardFontDataFactory({
                baseUrl: p.standardFontDataUrl
              })), this.destroyed = !1, this.destroyCapability = null, this._passwordCapability = null, this._networkStream = m, this._fullReader = null, this._lastProgress = null, this.downloadInfoCapability = (0, _util.createPromiseCapability)(), this.setupMessageHandler();
            }
            get annotationStorage() {
              return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());
            }
            get stats() {
              return Oe(this, re);
            }
            getRenderingIntent(c, d = _util.AnnotationMode.ENABLE, m = null, p = !1) {
              let g = _util.RenderingIntentFlag.DISPLAY, n = null;
              switch (c) {
                case "any":
                  g = _util.RenderingIntentFlag.ANY;
                  break;
                case "display":
                  break;
                case "print":
                  g = _util.RenderingIntentFlag.PRINT;
                  break;
                default:
                  (0, _util.warn)(`getRenderingIntent - invalid intent: ${c}`);
              }
              switch (d) {
                case _util.AnnotationMode.DISABLE:
                  g += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;
                  break;
                case _util.AnnotationMode.ENABLE:
                  break;
                case _util.AnnotationMode.ENABLE_FORMS:
                  g += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;
                  break;
                case _util.AnnotationMode.ENABLE_STORAGE:
                  g += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE, n = (g & _util.RenderingIntentFlag.PRINT && m instanceof _annotation_storage.PrintAnnotationStorage ? m : this.annotationStorage).serializable;
                  break;
                default:
                  (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${d}`);
              }
              return p && (g += _util.RenderingIntentFlag.OPLIST), {
                renderingIntent: g,
                cacheKey: `${g}_${_annotation_storage.AnnotationStorage.getHash(n)}`,
                annotationStorageMap: n
              };
            }
            destroy() {
              if (this.destroyCapability)
                return this.destroyCapability.promise;
              this.destroyed = !0, this.destroyCapability = (0, _util.createPromiseCapability)(), this._passwordCapability && this._passwordCapability.reject(new Error("Worker was destroyed during onPassword callback"));
              const c = [];
              for (const m of Oe(this, ae).values())
                c.push(m._destroy());
              Oe(this, ae).clear(), Oe(this, J).clear(), this.hasOwnProperty("annotationStorage") && this.annotationStorage.resetModified();
              const d = this.messageHandler.sendWithPromise("Terminate", null);
              return c.push(d), Promise.all(c).then(() => {
                this.commonObjs.clear(), this.fontLoader.clear(), Ft(this, o, null), this._getFieldObjectsPromise = null, this._hasJSActionsPromise = null, this._networkStream && this._networkStream.cancelAllRequests(new _util.AbortException("Worker was terminated.")), this.messageHandler && (this.messageHandler.destroy(), this.messageHandler = null), this.destroyCapability.resolve();
              }, this.destroyCapability.reject), this.destroyCapability.promise;
            }
            setupMessageHandler() {
              const {
                messageHandler: c,
                loadingTask: d
              } = this;
              c.on("GetReader", (m, p) => {
                (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available."), this._fullReader = this._networkStream.getFullReader(), this._fullReader.onProgress = (g) => {
                  this._lastProgress = {
                    loaded: g.loaded,
                    total: g.total
                  };
                }, p.onPull = () => {
                  this._fullReader.read().then(function({
                    value: g,
                    done: n
                  }) {
                    if (n) {
                      p.close();
                      return;
                    }
                    (0, _util.assert)((0, _util.isArrayBuffer)(g), "GetReader - expected an ArrayBuffer."), p.enqueue(new Uint8Array(g), 1, [g]);
                  }).catch((g) => {
                    p.error(g);
                  });
                }, p.onCancel = (g) => {
                  this._fullReader.cancel(g), p.ready.catch((n) => {
                    if (!this.destroyed)
                      throw n;
                  });
                };
              }), c.on("ReaderHeadersReady", (m) => {
                const p = (0, _util.createPromiseCapability)(), g = this._fullReader;
                return g.headersReady.then(() => {
                  var n;
                  (!g.isStreamingSupported || !g.isRangeSupported) && (this._lastProgress && ((n = d.onProgress) == null || n.call(d, this._lastProgress)), g.onProgress = (i) => {
                    var l;
                    (l = d.onProgress) == null || l.call(d, {
                      loaded: i.loaded,
                      total: i.total
                    });
                  }), p.resolve({
                    isStreamingSupported: g.isStreamingSupported,
                    isRangeSupported: g.isRangeSupported,
                    contentLength: g.contentLength
                  });
                }, p.reject), p.promise;
              }), c.on("GetRangeReader", (m, p) => {
                (0, _util.assert)(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
                const g = this._networkStream.getRangeReader(m.begin, m.end);
                if (!g) {
                  p.close();
                  return;
                }
                p.onPull = () => {
                  g.read().then(function({
                    value: n,
                    done: i
                  }) {
                    if (i) {
                      p.close();
                      return;
                    }
                    (0, _util.assert)((0, _util.isArrayBuffer)(n), "GetRangeReader - expected an ArrayBuffer."), p.enqueue(new Uint8Array(n), 1, [n]);
                  }).catch((n) => {
                    p.error(n);
                  });
                }, p.onCancel = (n) => {
                  g.cancel(n), p.ready.catch((i) => {
                    if (!this.destroyed)
                      throw i;
                  });
                };
              }), c.on("GetDoc", ({
                pdfInfo: m
              }) => {
                this._numPages = m.numPages, this._htmlForXfa = m.htmlForXfa, delete m.htmlForXfa, d._capability.resolve(new PDFDocumentProxy(m, this));
              }), c.on("DocException", function(m) {
                let p;
                switch (m.name) {
                  case "PasswordException":
                    p = new _util.PasswordException(m.message, m.code);
                    break;
                  case "InvalidPDFException":
                    p = new _util.InvalidPDFException(m.message);
                    break;
                  case "MissingPDFException":
                    p = new _util.MissingPDFException(m.message);
                    break;
                  case "UnexpectedResponseException":
                    p = new _util.UnexpectedResponseException(m.message, m.status);
                    break;
                  case "UnknownErrorException":
                    p = new _util.UnknownErrorException(m.message, m.details);
                    break;
                  default:
                    (0, _util.unreachable)("DocException - expected a valid Error.");
                }
                d._capability.reject(p);
              }), c.on("PasswordRequest", (m) => {
                if (this._passwordCapability = (0, _util.createPromiseCapability)(), d.onPassword) {
                  const p = (g) => {
                    g instanceof Error ? this._passwordCapability.reject(g) : this._passwordCapability.resolve({
                      password: g
                    });
                  };
                  try {
                    d.onPassword(p, m.code);
                  } catch (g) {
                    this._passwordCapability.reject(g);
                  }
                } else
                  this._passwordCapability.reject(new _util.PasswordException(m.message, m.code));
                return this._passwordCapability.promise;
              }), c.on("DataLoaded", (m) => {
                var p;
                (p = d.onProgress) == null || p.call(d, {
                  loaded: m.length,
                  total: m.length
                }), this.downloadInfoCapability.resolve(m);
              }), c.on("StartRenderPage", (m) => {
                if (this.destroyed)
                  return;
                Oe(this, ae).get(m.pageIndex)._startRenderPage(m.transparency, m.cacheKey);
              }), c.on("commonobj", ([m, p, g]) => {
                var n;
                if (!this.destroyed && !this.commonObjs.has(m))
                  switch (p) {
                    case "Font":
                      const i = this._params;
                      if ("error" in g) {
                        const w = g.error;
                        (0, _util.warn)(`Error during font loading: ${w}`), this.commonObjs.resolve(m, w);
                        break;
                      }
                      let l = null;
                      i.pdfBug && ((n = globalThis.FontInspector) != null && n.enabled) && (l = {
                        registerFont(w, O) {
                          globalThis.FontInspector.fontAdded(w, O);
                        }
                      });
                      const u = new _font_loader.FontFaceObject(g, {
                        isEvalSupported: i.isEvalSupported,
                        disableFontFace: i.disableFontFace,
                        ignoreErrors: i.ignoreErrors,
                        onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
                        fontRegistry: l
                      });
                      this.fontLoader.bind(u).catch((w) => c.sendWithPromise("FontFallback", {
                        id: m
                      })).finally(() => {
                        !i.fontExtraProperties && u.data && (u.data = null), this.commonObjs.resolve(m, u);
                      });
                      break;
                    case "FontPath":
                    case "Image":
                      this.commonObjs.resolve(m, g);
                      break;
                    default:
                      throw new Error(`Got unknown common object type ${p}`);
                  }
              }), c.on("obj", ([m, p, g, n]) => {
                var l;
                if (this.destroyed)
                  return;
                const i = Oe(this, ae).get(p);
                if (!i.objs.has(m))
                  switch (g) {
                    case "Image":
                      i.objs.resolve(m, n);
                      const u = 8e6;
                      if (n) {
                        let w;
                        if (n.bitmap) {
                          const {
                            bitmap: O,
                            width: b,
                            height: A
                          } = n;
                          w = b * A * 4, i._bitmaps.add(O);
                        } else
                          w = ((l = n.data) == null ? void 0 : l.length) || 0;
                        w > u && (i.cleanupAfterRender = !0);
                      }
                      break;
                    case "Pattern":
                      i.objs.resolve(m, n);
                      break;
                    default:
                      throw new Error(`Got unknown object type ${g}`);
                  }
              }), c.on("DocProgress", (m) => {
                var p;
                this.destroyed || (p = d.onProgress) == null || p.call(d, {
                  loaded: m.loaded,
                  total: m.total
                });
              }), c.on("DocStats", (m) => {
                this.destroyed || Ft(this, re, Object.freeze({
                  streamTypes: Object.freeze(m.streamTypes),
                  fontTypes: Object.freeze(m.fontTypes)
                }));
              }), c.on("UnsupportedFeature", this._onUnsupportedFeature.bind(this)), c.on("FetchBuiltInCMap", (m) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.CMapReaderFactory ? this.CMapReaderFactory.fetch(m) : Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."))), c.on("FetchStandardFontData", (m) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.StandardFontDataFactory ? this.StandardFontDataFactory.fetch(m) : Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.")));
            }
            _onUnsupportedFeature({
              featureId: c
            }) {
              var d, m;
              this.destroyed || (m = (d = this.loadingTask).onUnsupportedFeature) == null || m.call(d, c);
            }
            getData() {
              return this.messageHandler.sendWithPromise("GetData", null);
            }
            getPage(c) {
              if (!Number.isInteger(c) || c <= 0 || c > this._numPages)
                return Promise.reject(new Error("Invalid page request."));
              const d = c - 1, m = Oe(this, J).get(d);
              if (m)
                return m;
              const p = this.messageHandler.sendWithPromise("GetPage", {
                pageIndex: d
              }).then((g) => {
                if (this.destroyed)
                  throw new Error("Transport destroyed");
                const n = new PDFPageProxy(d, g, this, this._params.ownerDocument, this._params.pdfBug);
                return Oe(this, ae).set(d, n), n;
              });
              return Oe(this, J).set(d, p), p;
            }
            getPageIndex(c) {
              return typeof c != "object" || c === null || !Number.isInteger(c.num) || c.num < 0 || !Number.isInteger(c.gen) || c.gen < 0 ? Promise.reject(new Error("Invalid pageIndex request.")) : this.messageHandler.sendWithPromise("GetPageIndex", {
                num: c.num,
                gen: c.gen
              });
            }
            getAnnotations(c, d) {
              return this.messageHandler.sendWithPromise("GetAnnotations", {
                pageIndex: c,
                intent: d
              });
            }
            saveDocument() {
              var c;
              return this.messageHandler.sendWithPromise("SaveDocument", {
                isPureXfa: !!this._htmlForXfa,
                numPages: this._numPages,
                annotationStorage: this.annotationStorage.serializable,
                filename: ((c = this._fullReader) == null ? void 0 : c.filename) ?? null
              }).finally(() => {
                this.annotationStorage.resetModified();
              });
            }
            getFieldObjects() {
              return this._getFieldObjectsPromise || (this._getFieldObjectsPromise = this.messageHandler.sendWithPromise("GetFieldObjects", null));
            }
            hasJSActions() {
              return this._hasJSActionsPromise || (this._hasJSActionsPromise = this.messageHandler.sendWithPromise("HasJSActions", null));
            }
            getCalculationOrderIds() {
              return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
            }
            getDestinations() {
              return this.messageHandler.sendWithPromise("GetDestinations", null);
            }
            getDestination(c) {
              return typeof c != "string" ? Promise.reject(new Error("Invalid destination request.")) : this.messageHandler.sendWithPromise("GetDestination", {
                id: c
              });
            }
            getPageLabels() {
              return this.messageHandler.sendWithPromise("GetPageLabels", null);
            }
            getPageLayout() {
              return this.messageHandler.sendWithPromise("GetPageLayout", null);
            }
            getPageMode() {
              return this.messageHandler.sendWithPromise("GetPageMode", null);
            }
            getViewerPreferences() {
              return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
            }
            getOpenAction() {
              return this.messageHandler.sendWithPromise("GetOpenAction", null);
            }
            getAttachments() {
              return this.messageHandler.sendWithPromise("GetAttachments", null);
            }
            getJavaScript() {
              return this.messageHandler.sendWithPromise("GetJavaScript", null);
            }
            getDocJSActions() {
              return this.messageHandler.sendWithPromise("GetDocJSActions", null);
            }
            getPageJSActions(c) {
              return this.messageHandler.sendWithPromise("GetPageJSActions", {
                pageIndex: c
              });
            }
            getStructTree(c) {
              return this.messageHandler.sendWithPromise("GetStructTree", {
                pageIndex: c
              });
            }
            getOutline() {
              return this.messageHandler.sendWithPromise("GetOutline", null);
            }
            getOptionalContentConfig() {
              return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then((c) => new _optional_content_config.OptionalContentConfig(c));
            }
            getPermissions() {
              return this.messageHandler.sendWithPromise("GetPermissions", null);
            }
            getMetadata() {
              return Oe(this, o) || Ft(this, o, this.messageHandler.sendWithPromise("GetMetadata", null).then((c) => {
                var d, m;
                return {
                  info: c[0],
                  metadata: c[1] ? new _metadata.Metadata(c[1]) : null,
                  contentDispositionFilename: ((d = this._fullReader) == null ? void 0 : d.filename) ?? null,
                  contentLength: ((m = this._fullReader) == null ? void 0 : m.contentLength) ?? null
                };
              }));
            }
            getMarkInfo() {
              return this.messageHandler.sendWithPromise("GetMarkInfo", null);
            }
            async startCleanup(c = !1) {
              if (await this.messageHandler.sendWithPromise("Cleanup", null), !this.destroyed) {
                for (const d of Oe(this, ae).values())
                  if (!d.cleanup())
                    throw new Error(`startCleanup: Page ${d.pageNumber} is currently rendering.`);
                this.commonObjs.clear(), c || this.fontLoader.clear(), Ft(this, o, null), this._getFieldObjectsPromise = null, this._hasJSActionsPromise = null;
              }
            }
            get loadingParams() {
              const c = this._params;
              return (0, _util.shadow)(this, "loadingParams", {
                disableAutoFetch: c.disableAutoFetch,
                enableXfa: c.enableXfa
              });
            }
          }
          re = new WeakMap(), ae = new WeakMap(), J = new WeakMap(), o = new WeakMap();
          class PDFObjects {
            constructor() {
              gt(this, t);
              gt(this, F, /* @__PURE__ */ Object.create(null));
            }
            get(c, d = null) {
              if (d) {
                const p = At(this, t, fi).call(this, c);
                return p.capability.promise.then(() => d(p.data)), null;
              }
              const m = Oe(this, F)[c];
              if (!(m != null && m.capability.settled))
                throw new Error(`Requesting object that isn't resolved yet ${c}.`);
              return m.data;
            }
            has(c) {
              const d = Oe(this, F)[c];
              return (d == null ? void 0 : d.capability.settled) || !1;
            }
            resolve(c, d = null) {
              const m = At(this, t, fi).call(this, c);
              m.data = d, m.capability.resolve();
            }
            clear() {
              Ft(this, F, /* @__PURE__ */ Object.create(null));
            }
          }
          F = new WeakMap(), t = new WeakSet(), fi = function(c) {
            const d = Oe(this, F)[c];
            return d || (Oe(this, F)[c] = {
              capability: (0, _util.createPromiseCapability)(),
              data: null
            });
          };
          class RenderTask {
            constructor(c) {
              gt(this, v, null);
              Ft(this, v, c), this.onContinue = null;
            }
            get promise() {
              return Oe(this, v).capability.promise;
            }
            cancel() {
              Oe(this, v).cancel();
            }
            get separateAnnots() {
              const {
                separateAnnots: c
              } = Oe(this, v).operatorList;
              if (!c)
                return !1;
              const {
                annotationCanvasMap: d
              } = Oe(this, v);
              return c.form || c.canvas && (d == null ? void 0 : d.size) > 0;
            }
          }
          v = new WeakMap(), exports.RenderTask = RenderTask;
          const e = class {
            constructor({
              callback: c,
              params: d,
              objs: m,
              commonObjs: p,
              annotationCanvasMap: g,
              operatorList: n,
              pageIndex: i,
              canvasFactory: l,
              useRequestAnimationFrame: u = !1,
              pdfBug: w = !1,
              pageColors: O = null
            }) {
              this.callback = c, this.params = d, this.objs = m, this.commonObjs = p, this.annotationCanvasMap = g, this.operatorListIdx = null, this.operatorList = n, this._pageIndex = i, this.canvasFactory = l, this._pdfBug = w, this.pageColors = O, this.running = !1, this.graphicsReadyCallback = null, this.graphicsReady = !1, this._useRequestAnimationFrame = u === !0 && typeof window < "u", this.cancelled = !1, this.capability = (0, _util.createPromiseCapability)(), this.task = new RenderTask(this), this._cancelBound = this.cancel.bind(this), this._continueBound = this._continue.bind(this), this._scheduleNextBound = this._scheduleNext.bind(this), this._nextBound = this._next.bind(this), this._canvas = d.canvasContext.canvas;
            }
            get completed() {
              return this.capability.promise.catch(function() {
              });
            }
            initializeGraphics({
              transparency: c = !1,
              optionalContentConfig: d
            }) {
              var l;
              if (this.cancelled)
                return;
              if (this._canvas) {
                if (Oe(e, h).has(this._canvas))
                  throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
                Oe(e, h).add(this._canvas);
              }
              this._pdfBug && ((l = globalThis.StepperManager) != null && l.enabled) && (this.stepper = globalThis.StepperManager.create(this._pageIndex), this.stepper.init(this.operatorList), this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint());
              const {
                canvasContext: m,
                viewport: p,
                transform: g,
                imageLayer: n,
                background: i
              } = this.params;
              this.gfx = new _canvas.CanvasGraphics(m, this.commonObjs, this.objs, this.canvasFactory, n, d, this.annotationCanvasMap, this.pageColors), this.gfx.beginDrawing({
                transform: g,
                viewport: p,
                transparency: c,
                background: i
              }), this.operatorListIdx = 0, this.graphicsReady = !0, this.graphicsReadyCallback && this.graphicsReadyCallback();
            }
            cancel(c = null) {
              this.running = !1, this.cancelled = !0, this.gfx && this.gfx.endDrawing(), this._canvas && Oe(e, h).delete(this._canvas), this.callback(c || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, "canvas"));
            }
            operatorListChanged() {
              if (!this.graphicsReady) {
                this.graphicsReadyCallback || (this.graphicsReadyCallback = this._continueBound);
                return;
              }
              this.stepper && this.stepper.updateOperatorList(this.operatorList), !this.running && this._continue();
            }
            _continue() {
              this.running = !0, !this.cancelled && (this.task.onContinue ? this.task.onContinue(this._scheduleNextBound) : this._scheduleNext());
            }
            _scheduleNext() {
              this._useRequestAnimationFrame ? window.requestAnimationFrame(() => {
                this._nextBound().catch(this._cancelBound);
              }) : Promise.resolve().then(this._nextBound).catch(this._cancelBound);
            }
            async _next() {
              this.cancelled || (this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper), this.operatorListIdx === this.operatorList.argsArray.length && (this.running = !1, this.operatorList.lastChunk && (this.gfx.endDrawing(), this._canvas && Oe(e, h).delete(this._canvas), this.callback())));
            }
          };
          let InternalRenderTask = e;
          h = new WeakMap(), gt(InternalRenderTask, h, /* @__PURE__ */ new WeakSet());
          const version = "2.16.105";
          exports.version = version;
          const build = "172ccdbe5";
          exports.build = build;
        },
        /* 5 */
        /***/
        (be, ge, le) => {
          var F, Ui, a;
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.PrintAnnotationStorage = ge.AnnotationStorage = void 0;
          var ce = le(1), re = le(6), ae = le(10);
          class J {
            constructor() {
              gt(this, F);
              this._storage = /* @__PURE__ */ new Map(), this._modified = !1, this.onSetModified = null, this.onResetModified = null, this.onAnnotationEditor = null;
            }
            getValue(h, e) {
              const y = this._storage.get(h);
              return y === void 0 ? e : Object.assign(e, y);
            }
            getRawValue(h) {
              return this._storage.get(h);
            }
            remove(h) {
              if (this._storage.delete(h), this._storage.size === 0 && this.resetModified(), typeof this.onAnnotationEditor == "function") {
                for (const e of this._storage.values())
                  if (e instanceof re.AnnotationEditor)
                    return;
                this.onAnnotationEditor(null);
              }
            }
            setValue(h, e) {
              const y = this._storage.get(h);
              let c = !1;
              if (y !== void 0)
                for (const [d, m] of Object.entries(e))
                  y[d] !== m && (c = !0, y[d] = m);
              else
                c = !0, this._storage.set(h, e);
              c && At(this, F, Ui).call(this), e instanceof re.AnnotationEditor && typeof this.onAnnotationEditor == "function" && this.onAnnotationEditor(e.constructor._type);
            }
            has(h) {
              return this._storage.has(h);
            }
            getAll() {
              return this._storage.size > 0 ? (0, ce.objectFromMap)(this._storage) : null;
            }
            get size() {
              return this._storage.size;
            }
            resetModified() {
              this._modified && (this._modified = !1, typeof this.onResetModified == "function" && this.onResetModified());
            }
            get print() {
              return new o(this);
            }
            get serializable() {
              if (this._storage.size === 0)
                return null;
              const h = /* @__PURE__ */ new Map();
              for (const [e, y] of this._storage) {
                const c = y instanceof re.AnnotationEditor ? y.serialize() : y;
                c && h.set(e, c);
              }
              return h;
            }
            static getHash(h) {
              if (!h)
                return "";
              const e = new ae.MurmurHash3_64();
              for (const [y, c] of h)
                e.update(`${y}:${JSON.stringify(c)}`);
              return e.hexdigest();
            }
          }
          F = new WeakSet(), Ui = function() {
            this._modified || (this._modified = !0, typeof this.onSetModified == "function" && this.onSetModified());
          }, ge.AnnotationStorage = J;
          class o extends J {
            constructor(e) {
              super();
              gt(this, a, null);
              Ft(this, a, structuredClone(e.serializable));
            }
            get print() {
              (0, ce.unreachable)("Should not call PrintAnnotationStorage.print");
            }
            get serializable() {
              return Oe(this, a);
            }
          }
          a = new WeakMap(), ge.PrintAnnotationStorage = o;
        },
        /* 6 */
        /***/
        (be, ge, le) => {
          var J, o, F, t, a, v;
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.AnnotationEditor = void 0;
          var ce = le(7), re = le(1);
          const h = class {
            constructor(y) {
              gt(this, J, this.focusin.bind(this));
              gt(this, o, this.focusout.bind(this));
              gt(this, F, !1);
              gt(this, t, !1);
              gt(this, a, !1);
              gt(this, v, h._zIndex++);
              this.constructor === h && (0, re.unreachable)("Cannot initialize AnnotationEditor."), this.parent = y.parent, this.id = y.id, this.width = this.height = null, this.pageIndex = y.parent.pageIndex, this.name = y.name, this.div = null;
              const [c, d] = this.parent.viewportBaseDimensions;
              this.x = y.x / c, this.y = y.y / d, this.rotation = this.parent.viewport.rotation, this.isAttachedToDOM = !1;
            }
            static get _defaultLineColor() {
              return (0, re.shadow)(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
            }
            setInBackground() {
              this.div.style.zIndex = 0;
            }
            setInForeground() {
              this.div.style.zIndex = Oe(this, v);
            }
            focusin(y) {
              Oe(this, F) ? Ft(this, F, !1) : this.parent.setSelected(this);
            }
            focusout(y) {
              if (!this.isAttachedToDOM)
                return;
              const c = y.relatedTarget;
              c != null && c.closest(`#${this.id}`) || (y.preventDefault(), this.parent.isMultipleSelection || this.commitOrRemove());
            }
            commitOrRemove() {
              this.isEmpty() ? this.remove() : this.commit();
            }
            commit() {
              this.parent.addToAnnotationStorage(this);
            }
            dragstart(y) {
              const c = this.parent.div.getBoundingClientRect();
              this.startX = y.clientX - c.x, this.startY = y.clientY - c.y, y.dataTransfer.setData("text/plain", this.id), y.dataTransfer.effectAllowed = "move";
            }
            setAt(y, c, d, m) {
              const [p, g] = this.parent.viewportBaseDimensions;
              [d, m] = this.screenToPageTranslation(d, m), this.x = (y + d) / p, this.y = (c + m) / g, this.div.style.left = `${100 * this.x}%`, this.div.style.top = `${100 * this.y}%`;
            }
            translate(y, c) {
              const [d, m] = this.parent.viewportBaseDimensions;
              [y, c] = this.screenToPageTranslation(y, c), this.x += y / d, this.y += c / m, this.div.style.left = `${100 * this.x}%`, this.div.style.top = `${100 * this.y}%`;
            }
            screenToPageTranslation(y, c) {
              const {
                rotation: d
              } = this.parent.viewport;
              switch (d) {
                case 90:
                  return [c, -y];
                case 180:
                  return [-y, -c];
                case 270:
                  return [-c, y];
                default:
                  return [y, c];
              }
            }
            setDims(y, c) {
              const [d, m] = this.parent.viewportBaseDimensions;
              this.div.style.width = `${100 * y / d}%`, this.div.style.height = `${100 * c / m}%`;
            }
            getInitialTranslation() {
              return [0, 0];
            }
            render() {
              this.div = document.createElement("div"), this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360), this.div.className = this.name, this.div.setAttribute("id", this.id), this.div.setAttribute("tabIndex", 0), this.setInForeground(), this.div.addEventListener("focusin", Oe(this, J)), this.div.addEventListener("focusout", Oe(this, o));
              const [y, c] = this.getInitialTranslation();
              return this.translate(y, c), (0, ce.bindEvents)(this, this.div, ["dragstart", "pointerdown"]), this.div;
            }
            pointerdown(y) {
              const c = ce.KeyboardManager.platform.isMac;
              if (y.button !== 0 || y.ctrlKey && c) {
                y.preventDefault();
                return;
              }
              y.ctrlKey && !c || y.shiftKey || y.metaKey && c ? this.parent.toggleSelected(this) : this.parent.setSelected(this), Ft(this, F, !0);
            }
            getRect(y, c) {
              const [d, m] = this.parent.viewportBaseDimensions, [p, g] = this.parent.pageDimensions, n = p * y / d, i = g * c / m, l = this.x * p, u = this.y * g, w = this.width * p, O = this.height * g;
              switch (this.rotation) {
                case 0:
                  return [l + n, g - u - i - O, l + n + w, g - u - i];
                case 90:
                  return [l + i, g - u + n, l + i + O, g - u + n + w];
                case 180:
                  return [l - n - w, g - u + i, l - n, g - u + i + O];
                case 270:
                  return [l - i - O, g - u - n - w, l - i, g - u - n];
                default:
                  throw new Error("Invalid rotation");
              }
            }
            getRectInCurrentCoords(y, c) {
              const [d, m, p, g] = y, n = p - d, i = g - m;
              switch (this.rotation) {
                case 0:
                  return [d, c - g, n, i];
                case 90:
                  return [d, c - m, i, n];
                case 180:
                  return [p, c - m, n, i];
                case 270:
                  return [p, c - g, i, n];
                default:
                  throw new Error("Invalid rotation");
              }
            }
            onceAdded() {
            }
            isEmpty() {
              return !1;
            }
            enableEditMode() {
              Ft(this, a, !0);
            }
            disableEditMode() {
              Ft(this, a, !1);
            }
            isInEditMode() {
              return Oe(this, a);
            }
            shouldGetKeyboardEvents() {
              return !1;
            }
            needsToBeRebuilt() {
              return this.div && !this.isAttachedToDOM;
            }
            rebuild() {
              var y;
              (y = this.div) == null || y.addEventListener("focusin", Oe(this, J));
            }
            serialize() {
              (0, re.unreachable)("An editor must be serializable");
            }
            static deserialize(y, c) {
              const d = new this.prototype.constructor({
                parent: c,
                id: c.getNextId()
              });
              d.rotation = y.rotation;
              const [m, p] = c.pageDimensions, [g, n, i, l] = d.getRectInCurrentCoords(y.rect, p);
              return d.x = g / m, d.y = n / p, d.width = i / m, d.height = l / p, d;
            }
            remove() {
              this.div.removeEventListener("focusin", Oe(this, J)), this.div.removeEventListener("focusout", Oe(this, o)), this.isEmpty() || this.commit(), this.parent.remove(this);
            }
            select() {
              var y;
              (y = this.div) == null || y.classList.add("selectedEditor");
            }
            unselect() {
              var y;
              (y = this.div) == null || y.classList.remove("selectedEditor");
            }
            updateParams(y, c) {
            }
            disableEditing() {
            }
            enableEditing() {
            }
            get propertiesToUpdate() {
              return {};
            }
            get contentDiv() {
              return this.div;
            }
            get isEditing() {
              return Oe(this, t);
            }
            set isEditing(y) {
              Ft(this, t, y), y ? (this.parent.setSelected(this), this.parent.setActiveEditor(this)) : this.parent.setActiveEditor(null);
            }
          };
          let ae = h;
          J = new WeakMap(), o = new WeakMap(), F = new WeakMap(), t = new WeakMap(), a = new WeakMap(), v = new WeakMap(), on(ae, "_colorManager", new ce.ColorManager()), on(ae, "_zIndex", 1), ge.AnnotationEditor = ae;
        },
        /* 7 */
        /***/
        (be, ge, le) => {
          var e, y, c, d, m, p, Mi, i, u, w, O, b, A, Y, j, X, B, U, k, x, f, D, _, S, C, T, Bi, M, gi, Z, mn, z, Gn, L, Li, ne, Ni, q, pi, Q, Vn, te, Qn;
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.KeyboardManager = ge.CommandManager = ge.ColorManager = ge.AnnotationEditorUIManager = void 0, ge.bindEvents = ae, ge.opacityToHex = J;
          var ce = le(1), re = le(8);
          function ae(W, I, H) {
            for (const ie of H)
              I.addEventListener(ie, W[ie].bind(W));
          }
          function J(W) {
            return Math.round(Math.min(255, Math.max(1, 255 * W))).toString(16).padStart(2, "0");
          }
          class o {
            constructor() {
              gt(this, e, 0);
            }
            getId() {
              return `${ce.AnnotationEditorPrefix}${di(this, e)._++}`;
            }
          }
          e = new WeakMap();
          class F {
            constructor(I = 128) {
              gt(this, y, []);
              gt(this, c, !1);
              gt(this, d, void 0);
              gt(this, m, -1);
              Ft(this, d, I);
            }
            add({
              cmd: I,
              undo: H,
              mustExec: ie,
              type: ue = NaN,
              overwriteIfSameType: fe = !1,
              keepUndo: de = !1
            }) {
              if (ie && I(), Oe(this, c))
                return;
              const pe = {
                cmd: I,
                undo: H,
                type: ue
              };
              if (Oe(this, m) === -1) {
                Oe(this, y).length > 0 && (Oe(this, y).length = 0), Ft(this, m, 0), Oe(this, y).push(pe);
                return;
              }
              if (fe && Oe(this, y)[Oe(this, m)].type === ue) {
                de && (pe.undo = Oe(this, y)[Oe(this, m)].undo), Oe(this, y)[Oe(this, m)] = pe;
                return;
              }
              const xe = Oe(this, m) + 1;
              xe === Oe(this, d) ? Oe(this, y).splice(0, 1) : (Ft(this, m, xe), xe < Oe(this, y).length && Oe(this, y).splice(xe)), Oe(this, y).push(pe);
            }
            undo() {
              Oe(this, m) !== -1 && (Ft(this, c, !0), Oe(this, y)[Oe(this, m)].undo(), Ft(this, c, !1), Ft(this, m, Oe(this, m) - 1));
            }
            redo() {
              Oe(this, m) < Oe(this, y).length - 1 && (Ft(this, m, Oe(this, m) + 1), Ft(this, c, !0), Oe(this, y)[Oe(this, m)].cmd(), Ft(this, c, !1));
            }
            hasSomethingToUndo() {
              return Oe(this, m) !== -1;
            }
            hasSomethingToRedo() {
              return Oe(this, m) < Oe(this, y).length - 1;
            }
            destroy() {
              Ft(this, y, null);
            }
          }
          y = new WeakMap(), c = new WeakMap(), d = new WeakMap(), m = new WeakMap(), ge.CommandManager = F;
          const n = class {
            constructor(I) {
              gt(this, p);
              this.buffer = [], this.callbacks = /* @__PURE__ */ new Map(), this.allKeys = /* @__PURE__ */ new Set();
              const H = n.platform.isMac;
              for (const [ie, ue] of I)
                for (const fe of ie) {
                  const de = fe.startsWith("mac+");
                  H && de ? (this.callbacks.set(fe.slice(4), ue), this.allKeys.add(fe.split("+").at(-1))) : !H && !de && (this.callbacks.set(fe, ue), this.allKeys.add(fe.split("+").at(-1)));
                }
            }
            static get platform() {
              const I = typeof navigator < "u" ? navigator.platform : "";
              return (0, ce.shadow)(this, "platform", {
                isWin: I.includes("Win"),
                isMac: I.includes("Mac")
              });
            }
            exec(I, H) {
              if (!this.allKeys.has(H.key))
                return;
              const ie = this.callbacks.get(At(this, p, Mi).call(this, H));
              ie && (ie.bind(I)(), H.stopPropagation(), H.preventDefault());
            }
          };
          let t = n;
          p = new WeakSet(), Mi = function(I) {
            I.altKey && this.buffer.push("alt"), I.ctrlKey && this.buffer.push("ctrl"), I.metaKey && this.buffer.push("meta"), I.shiftKey && this.buffer.push("shift"), this.buffer.push(I.key);
            const H = this.buffer.join("+");
            return this.buffer.length = 0, H;
          }, ge.KeyboardManager = t;
          class a {
            constructor() {
              gt(this, i, null);
            }
            copy(I) {
              I && (Array.isArray(I) ? Ft(this, i, I.map((H) => H.serialize())) : Ft(this, i, [I.serialize()]), Ft(this, i, Oe(this, i).filter((H) => !!H)), Oe(this, i).length === 0 && Ft(this, i, null));
            }
            paste() {
              return Oe(this, i);
            }
            isEmpty() {
              return Oe(this, i) === null;
            }
            destroy() {
              Ft(this, i, null);
            }
          }
          i = new WeakMap();
          const l = class {
            get _colors() {
              const I = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
              return (0, re.getColorValues)(I), (0, ce.shadow)(this, "_colors", I);
            }
            convert(I) {
              const H = (0, re.getRGB)(I);
              if (!window.matchMedia("(forced-colors: active)").matches)
                return H;
              for (const [ie, ue] of this._colors)
                if (ue.every((fe, de) => fe === H[de]))
                  return l._colorsMapping.get(ie);
              return H;
            }
            getHexCode(I) {
              const H = this._colors.get(I);
              return H ? ce.Util.makeHexColor(...H) : I;
            }
          };
          let v = l;
          on(v, "_colorsMapping", /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]])), ge.ColorManager = v;
          const ee = class {
            constructor(I, H) {
              gt(this, T);
              gt(this, M);
              gt(this, Z);
              gt(this, z);
              gt(this, L);
              gt(this, ne);
              gt(this, q);
              gt(this, Q);
              gt(this, te);
              gt(this, u, null);
              gt(this, w, /* @__PURE__ */ new Map());
              gt(this, O, /* @__PURE__ */ new Map());
              gt(this, b, new a());
              gt(this, A, new F());
              gt(this, Y, 0);
              gt(this, j, null);
              gt(this, X, null);
              gt(this, B, new o());
              gt(this, U, !1);
              gt(this, k, ce.AnnotationEditorType.NONE);
              gt(this, x, /* @__PURE__ */ new Set());
              gt(this, f, this.keydown.bind(this));
              gt(this, D, this.onEditingAction.bind(this));
              gt(this, _, this.onPageChanging.bind(this));
              gt(this, S, {
                isEditing: !1,
                isEmpty: !0,
                hasEmptyClipboard: !0,
                hasSomethingToUndo: !1,
                hasSomethingToRedo: !1,
                hasSelectedEditor: !1
              });
              gt(this, C, null);
              Ft(this, C, I), Ft(this, X, H), Oe(this, X)._on("editingaction", Oe(this, D)), Oe(this, X)._on("pagechanging", Oe(this, _));
            }
            destroy() {
              At(this, M, gi).call(this), Oe(this, X)._off("editingaction", Oe(this, D)), Oe(this, X)._off("pagechanging", Oe(this, _));
              for (const I of Oe(this, O).values())
                I.destroy();
              Oe(this, O).clear(), Oe(this, w).clear(), Ft(this, u, null), Oe(this, x).clear(), Oe(this, b).destroy(), Oe(this, A).destroy();
            }
            onPageChanging({
              pageNumber: I
            }) {
              Ft(this, Y, I - 1);
            }
            focusMainContainer() {
              Oe(this, C).focus();
            }
            keydown(I) {
              var H;
              (H = this.getActive()) != null && H.shouldGetKeyboardEvents() || ee._keyboardManager.exec(this, I);
            }
            onEditingAction(I) {
              ["undo", "redo", "cut", "copy", "paste", "delete", "selectAll"].includes(I.name) && this[I.name]();
            }
            setEditingState(I) {
              I ? (At(this, T, Bi).call(this), At(this, Z, mn).call(this, {
                isEditing: Oe(this, k) !== ce.AnnotationEditorType.NONE,
                isEmpty: At(this, Q, Vn).call(this),
                hasSomethingToUndo: Oe(this, A).hasSomethingToUndo(),
                hasSomethingToRedo: Oe(this, A).hasSomethingToRedo(),
                hasSelectedEditor: !1,
                hasEmptyClipboard: Oe(this, b).isEmpty()
              })) : (At(this, M, gi).call(this), At(this, Z, mn).call(this, {
                isEditing: !1
              }));
            }
            registerEditorTypes(I) {
              Ft(this, j, I);
              for (const H of Oe(this, j))
                At(this, z, Gn).call(this, H.defaultPropertiesToUpdate);
            }
            getId() {
              return Oe(this, B).getId();
            }
            addLayer(I) {
              Oe(this, O).set(I.pageIndex, I), Oe(this, U) ? I.enable() : I.disable();
            }
            removeLayer(I) {
              Oe(this, O).delete(I.pageIndex);
            }
            updateMode(I) {
              if (Ft(this, k, I), I === ce.AnnotationEditorType.NONE)
                this.setEditingState(!1), At(this, ne, Ni).call(this);
              else {
                this.setEditingState(!0), At(this, L, Li).call(this);
                for (const H of Oe(this, O).values())
                  H.updateMode(I);
              }
            }
            updateToolbar(I) {
              I !== Oe(this, k) && Oe(this, X).dispatch("switchannotationeditormode", {
                source: this,
                mode: I
              });
            }
            updateParams(I, H) {
              for (const ie of Oe(this, x))
                ie.updateParams(I, H);
              for (const ie of Oe(this, j))
                ie.updateDefaultParams(I, H);
            }
            getEditors(I) {
              const H = [];
              for (const ie of Oe(this, w).values())
                ie.pageIndex === I && H.push(ie);
              return H;
            }
            getEditor(I) {
              return Oe(this, w).get(I);
            }
            addEditor(I) {
              Oe(this, w).set(I.id, I);
            }
            removeEditor(I) {
              Oe(this, w).delete(I.id), this.unselect(I);
            }
            setActiveEditor(I) {
              Oe(this, u) !== I && (Ft(this, u, I), I && At(this, z, Gn).call(this, I.propertiesToUpdate));
            }
            toggleSelected(I) {
              if (Oe(this, x).has(I)) {
                Oe(this, x).delete(I), I.unselect(), At(this, Z, mn).call(this, {
                  hasSelectedEditor: this.hasSelection
                });
                return;
              }
              Oe(this, x).add(I), I.select(), At(this, z, Gn).call(this, I.propertiesToUpdate), At(this, Z, mn).call(this, {
                hasSelectedEditor: !0
              });
            }
            setSelected(I) {
              for (const H of Oe(this, x))
                H !== I && H.unselect();
              Oe(this, x).clear(), Oe(this, x).add(I), I.select(), At(this, z, Gn).call(this, I.propertiesToUpdate), At(this, Z, mn).call(this, {
                hasSelectedEditor: !0
              });
            }
            isSelected(I) {
              return Oe(this, x).has(I);
            }
            unselect(I) {
              I.unselect(), Oe(this, x).delete(I), At(this, Z, mn).call(this, {
                hasSelectedEditor: this.hasSelection
              });
            }
            get hasSelection() {
              return Oe(this, x).size !== 0;
            }
            undo() {
              Oe(this, A).undo(), At(this, Z, mn).call(this, {
                hasSomethingToUndo: Oe(this, A).hasSomethingToUndo(),
                hasSomethingToRedo: !0,
                isEmpty: At(this, Q, Vn).call(this)
              });
            }
            redo() {
              Oe(this, A).redo(), At(this, Z, mn).call(this, {
                hasSomethingToUndo: !0,
                hasSomethingToRedo: Oe(this, A).hasSomethingToRedo(),
                isEmpty: At(this, Q, Vn).call(this)
              });
            }
            addCommands(I) {
              Oe(this, A).add(I), At(this, Z, mn).call(this, {
                hasSomethingToUndo: !0,
                hasSomethingToRedo: !1,
                isEmpty: At(this, Q, Vn).call(this)
              });
            }
            delete() {
              if (Oe(this, u) && Oe(this, u).commitOrRemove(), !this.hasSelection)
                return;
              const I = [...Oe(this, x)], H = () => {
                for (const ue of I)
                  ue.remove();
              }, ie = () => {
                for (const ue of I)
                  At(this, q, pi).call(this, ue);
              };
              this.addCommands({
                cmd: H,
                undo: ie,
                mustExec: !0
              });
            }
            copy() {
              if (Oe(this, u) && Oe(this, u).commitOrRemove(), this.hasSelection) {
                const I = [];
                for (const H of Oe(this, x))
                  H.isEmpty() || I.push(H);
                if (I.length === 0)
                  return;
                Oe(this, b).copy(I), At(this, Z, mn).call(this, {
                  hasEmptyClipboard: !1
                });
              }
            }
            cut() {
              this.copy(), this.delete();
            }
            paste() {
              if (Oe(this, b).isEmpty())
                return;
              this.unselectAll();
              const I = Oe(this, O).get(Oe(this, Y)), H = Oe(this, b).paste().map((fe) => I.deserialize(fe)), ie = () => {
                for (const fe of H)
                  At(this, q, pi).call(this, fe);
                At(this, te, Qn).call(this, H);
              }, ue = () => {
                for (const fe of H)
                  fe.remove();
              };
              this.addCommands({
                cmd: ie,
                undo: ue,
                mustExec: !0
              });
            }
            selectAll() {
              for (const I of Oe(this, x))
                I.commit();
              At(this, te, Qn).call(this, Oe(this, w).values());
            }
            unselectAll() {
              if (Oe(this, u)) {
                Oe(this, u).commitOrRemove();
                return;
              }
              if (At(this, te, Qn).size !== 0) {
                for (const I of Oe(this, x))
                  I.unselect();
                Oe(this, x).clear(), At(this, Z, mn).call(this, {
                  hasSelectedEditor: !1
                });
              }
            }
            isActive(I) {
              return Oe(this, u) === I;
            }
            getActive() {
              return Oe(this, u);
            }
            getMode() {
              return Oe(this, k);
            }
          };
          let h = ee;
          u = new WeakMap(), w = new WeakMap(), O = new WeakMap(), b = new WeakMap(), A = new WeakMap(), Y = new WeakMap(), j = new WeakMap(), X = new WeakMap(), B = new WeakMap(), U = new WeakMap(), k = new WeakMap(), x = new WeakMap(), f = new WeakMap(), D = new WeakMap(), _ = new WeakMap(), S = new WeakMap(), C = new WeakMap(), T = new WeakSet(), Bi = function() {
            Oe(this, C).addEventListener("keydown", Oe(this, f));
          }, M = new WeakSet(), gi = function() {
            Oe(this, C).removeEventListener("keydown", Oe(this, f));
          }, Z = new WeakSet(), mn = function(I) {
            Object.entries(I).some(([ie, ue]) => Oe(this, S)[ie] !== ue) && Oe(this, X).dispatch("annotationeditorstateschanged", {
              source: this,
              details: Object.assign(Oe(this, S), I)
            });
          }, z = new WeakSet(), Gn = function(I) {
            Oe(this, X).dispatch("annotationeditorparamschanged", {
              source: this,
              details: I
            });
          }, L = new WeakSet(), Li = function() {
            if (!Oe(this, U)) {
              Ft(this, U, !0);
              for (const I of Oe(this, O).values())
                I.enable();
            }
          }, ne = new WeakSet(), Ni = function() {
            if (this.unselectAll(), Oe(this, U)) {
              Ft(this, U, !1);
              for (const I of Oe(this, O).values())
                I.disable();
            }
          }, q = new WeakSet(), pi = function(I) {
            const H = Oe(this, O).get(I.pageIndex);
            H ? H.addOrRebuild(I) : this.addEditor(I);
          }, Q = new WeakSet(), Vn = function() {
            if (Oe(this, w).size === 0)
              return !0;
            if (Oe(this, w).size === 1)
              for (const I of Oe(this, w).values())
                return I.isEmpty();
            return !1;
          }, te = new WeakSet(), Qn = function(I) {
            Oe(this, x).clear();
            for (const H of I)
              H.isEmpty() || (Oe(this, x).add(H), H.select());
            At(this, Z, mn).call(this, {
              hasSelectedEditor: !0
            });
          }, on(h, "_keyboardManager", new t([[["ctrl+a", "mac+meta+a"], ee.prototype.selectAll], [["ctrl+c", "mac+meta+c"], ee.prototype.copy], [["ctrl+v", "mac+meta+v"], ee.prototype.paste], [["ctrl+x", "mac+meta+x"], ee.prototype.cut], [["ctrl+z", "mac+meta+z"], ee.prototype.undo], [["ctrl+y", "ctrl+shift+Z", "mac+meta+shift+Z"], ee.prototype.redo], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete"], ee.prototype.delete], [["Escape", "mac+Escape"], ee.prototype.unselectAll]])), ge.AnnotationEditorUIManager = h;
        },
        /* 8 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.StatTimer = ge.RenderingCancelledException = ge.PixelsPerInch = ge.PageViewport = ge.PDFDateString = ge.DOMStandardFontDataFactory = ge.DOMSVGFactory = ge.DOMCanvasFactory = ge.DOMCMapReaderFactory = ge.AnnotationPrefix = void 0, ge.deprecated = l, ge.getColorValues = A, ge.getCurrentTransform = Y, ge.getCurrentTransformInverse = j, ge.getFilenameFromUrl = m, ge.getPdfFilenameFromUrl = p, ge.getRGB = b, ge.getXfaPageViewport = O, ge.isDataScheme = c, ge.isPdfFile = d, ge.isValidFetchUrl = n, ge.loadScript = i;
          var ce = le(9), re = le(1);
          const ae = "http://www.w3.org/2000/svg", J = "pdfjs_internal_id_";
          ge.AnnotationPrefix = J;
          const X = class {
          };
          let o = X;
          on(o, "CSS", 96), on(o, "PDF", 72), on(o, "PDF_TO_CSS_UNITS", X.CSS / X.PDF), ge.PixelsPerInch = o;
          class F extends ce.BaseCanvasFactory {
            constructor({
              ownerDocument: U = globalThis.document
            } = {}) {
              super(), this._document = U;
            }
            _createCanvas(U, k) {
              const x = this._document.createElement("canvas");
              return x.width = U, x.height = k, x;
            }
          }
          ge.DOMCanvasFactory = F;
          async function t(B, U = !1) {
            if (n(B, document.baseURI)) {
              const k = await fetch(B);
              if (!k.ok)
                throw new Error(k.statusText);
              return U ? new Uint8Array(await k.arrayBuffer()) : (0, re.stringToBytes)(await k.text());
            }
            return new Promise((k, x) => {
              const f = new XMLHttpRequest();
              f.open("GET", B, !0), U && (f.responseType = "arraybuffer"), f.onreadystatechange = () => {
                if (f.readyState === XMLHttpRequest.DONE) {
                  if (f.status === 200 || f.status === 0) {
                    let D;
                    if (U && f.response ? D = new Uint8Array(f.response) : !U && f.responseText && (D = (0, re.stringToBytes)(f.responseText)), D) {
                      k(D);
                      return;
                    }
                  }
                  x(new Error(f.statusText));
                }
              }, f.send(null);
            });
          }
          class a extends ce.BaseCMapReaderFactory {
            _fetchData(U, k) {
              return t(U, this.isCompressed).then((x) => ({
                cMapData: x,
                compressionType: k
              }));
            }
          }
          ge.DOMCMapReaderFactory = a;
          class v extends ce.BaseStandardFontDataFactory {
            _fetchData(U) {
              return t(U, !0);
            }
          }
          ge.DOMStandardFontDataFactory = v;
          class h extends ce.BaseSVGFactory {
            _createSVG(U) {
              return document.createElementNS(ae, U);
            }
          }
          ge.DOMSVGFactory = h;
          class e {
            constructor({
              viewBox: U,
              scale: k,
              rotation: x,
              offsetX: f = 0,
              offsetY: D = 0,
              dontFlip: _ = !1
            }) {
              this.viewBox = U, this.scale = k, this.rotation = x, this.offsetX = f, this.offsetY = D;
              const S = (U[2] + U[0]) / 2, C = (U[3] + U[1]) / 2;
              let T, P, M, G;
              switch (x %= 360, x < 0 && (x += 360), x) {
                case 180:
                  T = -1, P = 0, M = 0, G = 1;
                  break;
                case 90:
                  T = 0, P = 1, M = 1, G = 0;
                  break;
                case 270:
                  T = 0, P = -1, M = -1, G = 0;
                  break;
                case 0:
                  T = 1, P = 0, M = 0, G = -1;
                  break;
                default:
                  throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
              }
              _ && (M = -M, G = -G);
              let Z, $, z, V;
              T === 0 ? (Z = Math.abs(C - U[1]) * k + f, $ = Math.abs(S - U[0]) * k + D, z = Math.abs(U[3] - U[1]) * k, V = Math.abs(U[2] - U[0]) * k) : (Z = Math.abs(S - U[0]) * k + f, $ = Math.abs(C - U[1]) * k + D, z = Math.abs(U[2] - U[0]) * k, V = Math.abs(U[3] - U[1]) * k), this.transform = [T * k, P * k, M * k, G * k, Z - T * k * S - M * k * C, $ - P * k * S - G * k * C], this.width = z, this.height = V;
            }
            clone({
              scale: U = this.scale,
              rotation: k = this.rotation,
              offsetX: x = this.offsetX,
              offsetY: f = this.offsetY,
              dontFlip: D = !1
            } = {}) {
              return new e({
                viewBox: this.viewBox.slice(),
                scale: U,
                rotation: k,
                offsetX: x,
                offsetY: f,
                dontFlip: D
              });
            }
            convertToViewportPoint(U, k) {
              return re.Util.applyTransform([U, k], this.transform);
            }
            convertToViewportRectangle(U) {
              const k = re.Util.applyTransform([U[0], U[1]], this.transform), x = re.Util.applyTransform([U[2], U[3]], this.transform);
              return [k[0], k[1], x[0], x[1]];
            }
            convertToPdfPoint(U, k) {
              return re.Util.applyInverseTransform([U, k], this.transform);
            }
          }
          ge.PageViewport = e;
          class y extends re.BaseException {
            constructor(U, k) {
              super(U, "RenderingCancelledException"), this.type = k;
            }
          }
          ge.RenderingCancelledException = y;
          function c(B) {
            const U = B.length;
            let k = 0;
            for (; k < U && B[k].trim() === ""; )
              k++;
            return B.substring(k, k + 5).toLowerCase() === "data:";
          }
          function d(B) {
            return typeof B == "string" && /\.pdf$/i.test(B);
          }
          function m(B) {
            const U = B.indexOf("#"), k = B.indexOf("?"), x = Math.min(U > 0 ? U : B.length, k > 0 ? k : B.length);
            return B.substring(B.lastIndexOf("/", x) + 1, x);
          }
          function p(B, U = "document.pdf") {
            if (typeof B != "string")
              return U;
            if (c(B))
              return (0, re.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.'), U;
            const k = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/, x = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i, f = k.exec(B);
            let D = x.exec(f[1]) || x.exec(f[2]) || x.exec(f[3]);
            if (D && (D = D[0], D.includes("%")))
              try {
                D = x.exec(decodeURIComponent(D))[0];
              } catch {
              }
            return D || U;
          }
          class g {
            constructor() {
              this.started = /* @__PURE__ */ Object.create(null), this.times = [];
            }
            time(U) {
              U in this.started && (0, re.warn)(`Timer is already running for ${U}`), this.started[U] = Date.now();
            }
            timeEnd(U) {
              U in this.started || (0, re.warn)(`Timer has not been started for ${U}`), this.times.push({
                name: U,
                start: this.started[U],
                end: Date.now()
              }), delete this.started[U];
            }
            toString() {
              const U = [];
              let k = 0;
              for (const x of this.times) {
                const f = x.name;
                f.length > k && (k = f.length);
              }
              for (const x of this.times) {
                const f = x.end - x.start;
                U.push(`${x.name.padEnd(k)} ${f}ms
`);
              }
              return U.join("");
            }
          }
          ge.StatTimer = g;
          function n(B, U) {
            try {
              const {
                protocol: k
              } = U ? new URL(B, U) : new URL(B);
              return k === "http:" || k === "https:";
            } catch {
              return !1;
            }
          }
          function i(B, U = !1) {
            return new Promise((k, x) => {
              const f = document.createElement("script");
              f.src = B, f.onload = function(D) {
                U && f.remove(), k(D);
              }, f.onerror = function() {
                x(new Error(`Cannot load script at: ${f.src}`));
              }, (document.head || document.documentElement).append(f);
            });
          }
          function l(B) {
            console.log("Deprecated API usage: " + B);
          }
          let u;
          class w {
            static toDateObject(U) {
              if (!U || typeof U != "string")
                return null;
              u || (u = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"));
              const k = u.exec(U);
              if (!k)
                return null;
              const x = parseInt(k[1], 10);
              let f = parseInt(k[2], 10);
              f = f >= 1 && f <= 12 ? f - 1 : 0;
              let D = parseInt(k[3], 10);
              D = D >= 1 && D <= 31 ? D : 1;
              let _ = parseInt(k[4], 10);
              _ = _ >= 0 && _ <= 23 ? _ : 0;
              let S = parseInt(k[5], 10);
              S = S >= 0 && S <= 59 ? S : 0;
              let C = parseInt(k[6], 10);
              C = C >= 0 && C <= 59 ? C : 0;
              const T = k[7] || "Z";
              let P = parseInt(k[8], 10);
              P = P >= 0 && P <= 23 ? P : 0;
              let M = parseInt(k[9], 10) || 0;
              return M = M >= 0 && M <= 59 ? M : 0, T === "-" ? (_ += P, S += M) : T === "+" && (_ -= P, S -= M), new Date(Date.UTC(x, f, D, _, S, C));
            }
          }
          ge.PDFDateString = w;
          function O(B, {
            scale: U = 1,
            rotation: k = 0
          }) {
            const {
              width: x,
              height: f
            } = B.attributes.style, D = [0, 0, parseInt(x), parseInt(f)];
            return new e({
              viewBox: D,
              scale: U,
              rotation: k
            });
          }
          function b(B) {
            if (B.startsWith("#")) {
              const U = parseInt(B.slice(1), 16);
              return [(U & 16711680) >> 16, (U & 65280) >> 8, U & 255];
            }
            return B.startsWith("rgb(") ? B.slice(4, -1).split(",").map((U) => parseInt(U)) : B.startsWith("rgba(") ? B.slice(5, -1).split(",").map((U) => parseInt(U)).slice(0, 3) : ((0, re.warn)(`Not a valid color format: "${B}"`), [0, 0, 0]);
          }
          function A(B) {
            const U = document.createElement("span");
            U.style.visibility = "hidden", document.body.append(U);
            for (const k of B.keys()) {
              U.style.color = k;
              const x = window.getComputedStyle(U).color;
              B.set(k, b(x));
            }
            U.remove();
          }
          function Y(B) {
            const {
              a: U,
              b: k,
              c: x,
              d: f,
              e: D,
              f: _
            } = B.getTransform();
            return [U, k, x, f, D, _];
          }
          function j(B) {
            const {
              a: U,
              b: k,
              c: x,
              d: f,
              e: D,
              f: _
            } = B.getTransform().invertSelf();
            return [U, k, x, f, D, _];
          }
        },
        /* 9 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.BaseStandardFontDataFactory = ge.BaseSVGFactory = ge.BaseCanvasFactory = ge.BaseCMapReaderFactory = void 0;
          var ce = le(1);
          class re {
            constructor() {
              this.constructor === re && (0, ce.unreachable)("Cannot initialize BaseCanvasFactory.");
            }
            create(t, a) {
              if (t <= 0 || a <= 0)
                throw new Error("Invalid canvas size");
              const v = this._createCanvas(t, a);
              return {
                canvas: v,
                context: v.getContext("2d")
              };
            }
            reset(t, a, v) {
              if (!t.canvas)
                throw new Error("Canvas is not specified");
              if (a <= 0 || v <= 0)
                throw new Error("Invalid canvas size");
              t.canvas.width = a, t.canvas.height = v;
            }
            destroy(t) {
              if (!t.canvas)
                throw new Error("Canvas is not specified");
              t.canvas.width = 0, t.canvas.height = 0, t.canvas = null, t.context = null;
            }
            _createCanvas(t, a) {
              (0, ce.unreachable)("Abstract method `_createCanvas` called.");
            }
          }
          ge.BaseCanvasFactory = re;
          class ae {
            constructor({
              baseUrl: t = null,
              isCompressed: a = !1
            }) {
              this.constructor === ae && (0, ce.unreachable)("Cannot initialize BaseCMapReaderFactory."), this.baseUrl = t, this.isCompressed = a;
            }
            async fetch({
              name: t
            }) {
              if (!this.baseUrl)
                throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');
              if (!t)
                throw new Error("CMap name must be specified.");
              const a = this.baseUrl + t + (this.isCompressed ? ".bcmap" : ""), v = this.isCompressed ? ce.CMapCompressionType.BINARY : ce.CMapCompressionType.NONE;
              return this._fetchData(a, v).catch((h) => {
                throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${a}`);
              });
            }
            _fetchData(t, a) {
              (0, ce.unreachable)("Abstract method `_fetchData` called.");
            }
          }
          ge.BaseCMapReaderFactory = ae;
          class J {
            constructor({
              baseUrl: t = null
            }) {
              this.constructor === J && (0, ce.unreachable)("Cannot initialize BaseStandardFontDataFactory."), this.baseUrl = t;
            }
            async fetch({
              filename: t
            }) {
              if (!this.baseUrl)
                throw new Error('The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.');
              if (!t)
                throw new Error("Font filename must be specified.");
              const a = `${this.baseUrl}${t}`;
              return this._fetchData(a).catch((v) => {
                throw new Error(`Unable to load font data at: ${a}`);
              });
            }
            _fetchData(t) {
              (0, ce.unreachable)("Abstract method `_fetchData` called.");
            }
          }
          ge.BaseStandardFontDataFactory = J;
          class o {
            constructor() {
              this.constructor === o && (0, ce.unreachable)("Cannot initialize BaseSVGFactory.");
            }
            create(t, a, v = !1) {
              if (t <= 0 || a <= 0)
                throw new Error("Invalid SVG dimensions");
              const h = this._createSVG("svg:svg");
              return h.setAttribute("version", "1.1"), v || (h.setAttribute("width", `${t}px`), h.setAttribute("height", `${a}px`)), h.setAttribute("preserveAspectRatio", "none"), h.setAttribute("viewBox", `0 0 ${t} ${a}`), h;
            }
            createElement(t) {
              if (typeof t != "string")
                throw new Error("Invalid SVG element type");
              return this._createSVG(t);
            }
            _createSVG(t) {
              (0, ce.unreachable)("Abstract method `_createSVG` called.");
            }
          }
          ge.BaseSVGFactory = o;
        },
        /* 10 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.MurmurHash3_64 = void 0;
          var ce = le(1);
          const re = 3285377520, ae = 4294901760, J = 65535;
          class o {
            constructor(t) {
              this.h1 = t ? t & 4294967295 : re, this.h2 = t ? t & 4294967295 : re;
            }
            update(t) {
              let a, v;
              if (typeof t == "string") {
                a = new Uint8Array(t.length * 2), v = 0;
                for (let u = 0, w = t.length; u < w; u++) {
                  const O = t.charCodeAt(u);
                  O <= 255 ? a[v++] = O : (a[v++] = O >>> 8, a[v++] = O & 255);
                }
              } else if ((0, ce.isArrayBuffer)(t))
                a = t.slice(), v = a.byteLength;
              else
                throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");
              const h = v >> 2, e = v - h * 4, y = new Uint32Array(a.buffer, 0, h);
              let c = 0, d = 0, m = this.h1, p = this.h2;
              const g = 3432918353, n = 461845907, i = g & J, l = n & J;
              for (let u = 0; u < h; u++)
                u & 1 ? (c = y[u], c = c * g & ae | c * i & J, c = c << 15 | c >>> 17, c = c * n & ae | c * l & J, m ^= c, m = m << 13 | m >>> 19, m = m * 5 + 3864292196) : (d = y[u], d = d * g & ae | d * i & J, d = d << 15 | d >>> 17, d = d * n & ae | d * l & J, p ^= d, p = p << 13 | p >>> 19, p = p * 5 + 3864292196);
              switch (c = 0, e) {
                case 3:
                  c ^= a[h * 4 + 2] << 16;
                case 2:
                  c ^= a[h * 4 + 1] << 8;
                case 1:
                  c ^= a[h * 4], c = c * g & ae | c * i & J, c = c << 15 | c >>> 17, c = c * n & ae | c * l & J, h & 1 ? m ^= c : p ^= c;
              }
              this.h1 = m, this.h2 = p;
            }
            hexdigest() {
              let t = this.h1, a = this.h2;
              t ^= a >>> 1, t = t * 3981806797 & ae | t * 36045 & J, a = a * 4283543511 & ae | ((a << 16 | t >>> 16) * 2950163797 & ae) >>> 16, t ^= a >>> 1, t = t * 444984403 & ae | t * 60499 & J, a = a * 3301882366 & ae | ((a << 16 | t >>> 16) * 3120437893 & ae) >>> 16, t ^= a >>> 1;
              const v = (t >>> 0).toString(16), h = (a >>> 0).toString(16);
              return v.padStart(8, "0") + h.padStart(8, "0");
            }
          }
          ge.MurmurHash3_64 = o;
        },
        /* 11 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.FontLoader = ge.FontFaceObject = void 0;
          var ce = le(1);
          class re {
            constructor({
              docId: F,
              onUnsupportedFeature: t,
              ownerDocument: a = globalThis.document,
              styleElement: v = null
            }) {
              this.constructor === re && (0, ce.unreachable)("Cannot initialize BaseFontLoader."), this.docId = F, this._onUnsupportedFeature = t, this._document = a, this.nativeFontFaces = [], this.styleElement = null;
            }
            addNativeFontFace(F) {
              this.nativeFontFaces.push(F), this._document.fonts.add(F);
            }
            insertRule(F) {
              let t = this.styleElement;
              t || (t = this.styleElement = this._document.createElement("style"), t.id = `PDFJS_FONT_STYLE_TAG_${this.docId}`, this._document.documentElement.getElementsByTagName("head")[0].append(t));
              const a = t.sheet;
              a.insertRule(F, a.cssRules.length);
            }
            clear() {
              for (const F of this.nativeFontFaces)
                this._document.fonts.delete(F);
              this.nativeFontFaces.length = 0, this.styleElement && (this.styleElement.remove(), this.styleElement = null);
            }
            async bind(F) {
              if (F.attached || F.missingFile)
                return;
              if (F.attached = !0, this.isFontLoadingAPISupported) {
                const a = F.createNativeFontFace();
                if (a) {
                  this.addNativeFontFace(a);
                  try {
                    await a.loaded;
                  } catch (v) {
                    throw this._onUnsupportedFeature({
                      featureId: ce.UNSUPPORTED_FEATURES.errorFontLoadNative
                    }), (0, ce.warn)(`Failed to load font '${a.family}': '${v}'.`), F.disableFontFace = !0, v;
                  }
                }
                return;
              }
              const t = F.createFontFaceRule();
              if (t) {
                if (this.insertRule(t), this.isSyncFontLoadingSupported)
                  return;
                await new Promise((a) => {
                  const v = this._queueLoadingCallback(a);
                  this._prepareFontLoadEvent([t], [F], v);
                });
              }
            }
            _queueLoadingCallback(F) {
              (0, ce.unreachable)("Abstract method `_queueLoadingCallback`.");
            }
            get isFontLoadingAPISupported() {
              var t;
              const F = !!((t = this._document) != null && t.fonts);
              return (0, ce.shadow)(this, "isFontLoadingAPISupported", F);
            }
            get isSyncFontLoadingSupported() {
              (0, ce.unreachable)("Abstract method `isSyncFontLoadingSupported`.");
            }
            get _loadTestFont() {
              (0, ce.unreachable)("Abstract method `_loadTestFont`.");
            }
            _prepareFontLoadEvent(F, t, a) {
              (0, ce.unreachable)("Abstract method `_prepareFontLoadEvent`.");
            }
          }
          let ae;
          ge.FontLoader = ae, ge.FontLoader = ae = class extends re {
            constructor(F) {
              super(F), this.loadingContext = {
                requests: [],
                nextRequestId: 0
              }, this.loadTestFontId = 0;
            }
            get isSyncFontLoadingSupported() {
              let F = !1;
              if (typeof navigator > "u")
                F = !0;
              else {
                const t = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(navigator.userAgent);
                (t == null ? void 0 : t[1]) >= 14 && (F = !0);
              }
              return (0, ce.shadow)(this, "isSyncFontLoadingSupported", F);
            }
            _queueLoadingCallback(F) {
              function t() {
                for ((0, ce.assert)(!v.done, "completeRequest() cannot be called twice."), v.done = !0; a.requests.length > 0 && a.requests[0].done; ) {
                  const h = a.requests.shift();
                  setTimeout(h.callback, 0);
                }
              }
              const a = this.loadingContext, v = {
                id: `pdfjs-font-loading-${a.nextRequestId++}`,
                done: !1,
                complete: t,
                callback: F
              };
              return a.requests.push(v), v;
            }
            get _loadTestFont() {
              const F = function() {
                return atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
              };
              return (0, ce.shadow)(this, "_loadTestFont", F());
            }
            _prepareFontLoadEvent(F, t, a) {
              function v(j, X) {
                return j.charCodeAt(X) << 24 | j.charCodeAt(X + 1) << 16 | j.charCodeAt(X + 2) << 8 | j.charCodeAt(X + 3) & 255;
              }
              function h(j, X, B, U) {
                const k = j.substring(0, X), x = j.substring(X + B);
                return k + U + x;
              }
              let e, y;
              const c = this._document.createElement("canvas");
              c.width = 1, c.height = 1;
              const d = c.getContext("2d");
              let m = 0;
              function p(j, X) {
                if (m++, m > 30) {
                  (0, ce.warn)("Load test font never loaded."), X();
                  return;
                }
                if (d.font = "30px " + j, d.fillText(".", 0, 20), d.getImageData(0, 0, 1, 1).data[3] > 0) {
                  X();
                  return;
                }
                setTimeout(p.bind(null, j, X));
              }
              const g = `lt${Date.now()}${this.loadTestFontId++}`;
              let n = this._loadTestFont;
              n = h(n, 976, g.length, g);
              const l = 16, u = 1482184792;
              let w = v(n, l);
              for (e = 0, y = g.length - 3; e < y; e += 4)
                w = w - u + v(g, e) | 0;
              e < g.length && (w = w - u + v(g + "XXX", e) | 0), n = h(n, l, 4, (0, ce.string32)(w));
              const O = `url(data:font/opentype;base64,${btoa(n)});`, b = `@font-face {font-family:"${g}";src:${O}}`;
              this.insertRule(b);
              const A = [];
              for (const j of t)
                A.push(j.loadedName);
              A.push(g);
              const Y = this._document.createElement("div");
              Y.style.visibility = "hidden", Y.style.width = Y.style.height = "10px", Y.style.position = "absolute", Y.style.top = Y.style.left = "0px";
              for (const j of A) {
                const X = this._document.createElement("span");
                X.textContent = "Hi", X.style.fontFamily = j, Y.append(X);
              }
              this._document.body.append(Y), p(g, () => {
                Y.remove(), a.complete();
              });
            }
          };
          class J {
            constructor(F, {
              isEvalSupported: t = !0,
              disableFontFace: a = !1,
              ignoreErrors: v = !1,
              onUnsupportedFeature: h,
              fontRegistry: e = null
            }) {
              this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
              for (const y in F)
                this[y] = F[y];
              this.isEvalSupported = t !== !1, this.disableFontFace = a === !0, this.ignoreErrors = v === !0, this._onUnsupportedFeature = h, this.fontRegistry = e;
            }
            createNativeFontFace() {
              if (!this.data || this.disableFontFace)
                return null;
              let F;
              if (!this.cssFontInfo)
                F = new FontFace(this.loadedName, this.data, {});
              else {
                const t = {
                  weight: this.cssFontInfo.fontWeight
                };
                this.cssFontInfo.italicAngle && (t.style = `oblique ${this.cssFontInfo.italicAngle}deg`), F = new FontFace(this.cssFontInfo.fontFamily, this.data, t);
              }
              return this.fontRegistry && this.fontRegistry.registerFont(this), F;
            }
            createFontFaceRule() {
              if (!this.data || this.disableFontFace)
                return null;
              const F = (0, ce.bytesToString)(this.data), t = `url(data:${this.mimetype};base64,${btoa(F)});`;
              let a;
              if (!this.cssFontInfo)
                a = `@font-face {font-family:"${this.loadedName}";src:${t}}`;
              else {
                let v = `font-weight: ${this.cssFontInfo.fontWeight};`;
                this.cssFontInfo.italicAngle && (v += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`), a = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${v}src:${t}}`;
              }
              return this.fontRegistry && this.fontRegistry.registerFont(this, t), a;
            }
            getPathGenerator(F, t) {
              if (this.compiledGlyphs[t] !== void 0)
                return this.compiledGlyphs[t];
              let a;
              try {
                a = F.get(this.loadedName + "_path_" + t);
              } catch (v) {
                if (!this.ignoreErrors)
                  throw v;
                return this._onUnsupportedFeature({
                  featureId: ce.UNSUPPORTED_FEATURES.errorFontGetPath
                }), (0, ce.warn)(`getPathGenerator - ignoring character: "${v}".`), this.compiledGlyphs[t] = function(h, e) {
                };
              }
              if (this.isEvalSupported && ce.FeatureTest.isEvalSupported) {
                const v = [];
                for (const h of a) {
                  const e = h.args !== void 0 ? h.args.join(",") : "";
                  v.push("c.", h.cmd, "(", e, `);
`);
                }
                return this.compiledGlyphs[t] = new Function("c", "size", v.join(""));
              }
              return this.compiledGlyphs[t] = function(v, h) {
                for (const e of a)
                  e.cmd === "scale" && (e.args = [h, -h]), v[e.cmd].apply(v, e.args);
              };
            }
          }
          ge.FontFaceObject = J;
        },
        /* 12 */
        /***/
        (be, ge, le) => {
          var f, mi;
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.CanvasGraphics = void 0;
          var ce = le(8), re = le(1), ae = le(13), J = le(14), o = le(3);
          const F = 16, t = 100, a = 4096, v = 15, h = 10, e = o.isNodeJS && typeof Path2D > "u" ? -1 : 1e3, y = 16;
          function c(S, C) {
            if (S._removeMirroring)
              throw new Error("Context is already forwarding operations.");
            S.__originalSave = S.save, S.__originalRestore = S.restore, S.__originalRotate = S.rotate, S.__originalScale = S.scale, S.__originalTranslate = S.translate, S.__originalTransform = S.transform, S.__originalSetTransform = S.setTransform, S.__originalResetTransform = S.resetTransform, S.__originalClip = S.clip, S.__originalMoveTo = S.moveTo, S.__originalLineTo = S.lineTo, S.__originalBezierCurveTo = S.bezierCurveTo, S.__originalRect = S.rect, S.__originalClosePath = S.closePath, S.__originalBeginPath = S.beginPath, S._removeMirroring = () => {
              S.save = S.__originalSave, S.restore = S.__originalRestore, S.rotate = S.__originalRotate, S.scale = S.__originalScale, S.translate = S.__originalTranslate, S.transform = S.__originalTransform, S.setTransform = S.__originalSetTransform, S.resetTransform = S.__originalResetTransform, S.clip = S.__originalClip, S.moveTo = S.__originalMoveTo, S.lineTo = S.__originalLineTo, S.bezierCurveTo = S.__originalBezierCurveTo, S.rect = S.__originalRect, S.closePath = S.__originalClosePath, S.beginPath = S.__originalBeginPath, delete S._removeMirroring;
            }, S.save = function() {
              C.save(), this.__originalSave();
            }, S.restore = function() {
              C.restore(), this.__originalRestore();
            }, S.translate = function(P, M) {
              C.translate(P, M), this.__originalTranslate(P, M);
            }, S.scale = function(P, M) {
              C.scale(P, M), this.__originalScale(P, M);
            }, S.transform = function(P, M, G, Z, $, z) {
              C.transform(P, M, G, Z, $, z), this.__originalTransform(P, M, G, Z, $, z);
            }, S.setTransform = function(P, M, G, Z, $, z) {
              C.setTransform(P, M, G, Z, $, z), this.__originalSetTransform(P, M, G, Z, $, z);
            }, S.resetTransform = function() {
              C.resetTransform(), this.__originalResetTransform();
            }, S.rotate = function(P) {
              C.rotate(P), this.__originalRotate(P);
            }, S.clip = function(P) {
              C.clip(P), this.__originalClip(P);
            }, S.moveTo = function(T, P) {
              C.moveTo(T, P), this.__originalMoveTo(T, P);
            }, S.lineTo = function(T, P) {
              C.lineTo(T, P), this.__originalLineTo(T, P);
            }, S.bezierCurveTo = function(T, P, M, G, Z, $) {
              C.bezierCurveTo(T, P, M, G, Z, $), this.__originalBezierCurveTo(T, P, M, G, Z, $);
            }, S.rect = function(T, P, M, G) {
              C.rect(T, P, M, G), this.__originalRect(T, P, M, G);
            }, S.closePath = function() {
              C.closePath(), this.__originalClosePath();
            }, S.beginPath = function() {
              C.beginPath(), this.__originalBeginPath();
            };
          }
          class d {
            constructor(C) {
              this.canvasFactory = C, this.cache = /* @__PURE__ */ Object.create(null);
            }
            getCanvas(C, T, P) {
              let M;
              return this.cache[C] !== void 0 ? (M = this.cache[C], this.canvasFactory.reset(M, T, P)) : (M = this.canvasFactory.create(T, P), this.cache[C] = M), M;
            }
            delete(C) {
              delete this.cache[C];
            }
            clear() {
              for (const C in this.cache) {
                const T = this.cache[C];
                this.canvasFactory.destroy(T), delete this.cache[C];
              }
            }
          }
          function m(S, C, T, P, M, G, Z, $, z, V) {
            const [L, K, ne, se, q, N] = (0, ce.getCurrentTransform)(S);
            if (K === 0 && ne === 0) {
              const te = Z * L + q, oe = Math.round(te), ee = $ * se + N, W = Math.round(ee), I = (Z + z) * L + q, H = Math.abs(Math.round(I) - oe) || 1, ie = ($ + V) * se + N, ue = Math.abs(Math.round(ie) - W) || 1;
              return S.setTransform(Math.sign(L), 0, 0, Math.sign(se), oe, W), S.drawImage(C, T, P, M, G, 0, 0, H, ue), S.setTransform(L, K, ne, se, q, N), [H, ue];
            }
            if (L === 0 && se === 0) {
              const te = $ * ne + q, oe = Math.round(te), ee = Z * K + N, W = Math.round(ee), I = ($ + V) * ne + q, H = Math.abs(Math.round(I) - oe) || 1, ie = (Z + z) * K + N, ue = Math.abs(Math.round(ie) - W) || 1;
              return S.setTransform(0, Math.sign(K), Math.sign(ne), 0, oe, W), S.drawImage(C, T, P, M, G, 0, 0, ue, H), S.setTransform(L, K, ne, se, q, N), [ue, H];
            }
            S.drawImage(C, T, P, M, G, Z, $, z, V);
            const Q = Math.hypot(L, K), E = Math.hypot(ne, se);
            return [Q * z, E * V];
          }
          function p(S) {
            const {
              width: C,
              height: T
            } = S;
            if (C > e || T > e)
              return null;
            const P = 1e3, M = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]), G = C + 1;
            let Z = new Uint8Array(G * (T + 1)), $, z, V;
            const L = C + 7 & -8;
            let K = new Uint8Array(L * T), ne = 0;
            for (const E of S.data) {
              let te = 128;
              for (; te > 0; )
                K[ne++] = E & te ? 0 : 255, te >>= 1;
            }
            let se = 0;
            for (ne = 0, K[ne] !== 0 && (Z[0] = 1, ++se), z = 1; z < C; z++)
              K[ne] !== K[ne + 1] && (Z[z] = K[ne] ? 2 : 1, ++se), ne++;
            for (K[ne] !== 0 && (Z[z] = 2, ++se), $ = 1; $ < T; $++) {
              ne = $ * L, V = $ * G, K[ne - L] !== K[ne] && (Z[V] = K[ne] ? 1 : 8, ++se);
              let E = (K[ne] ? 4 : 0) + (K[ne - L] ? 8 : 0);
              for (z = 1; z < C; z++)
                E = (E >> 2) + (K[ne + 1] ? 4 : 0) + (K[ne - L + 1] ? 8 : 0), M[E] && (Z[V + z] = M[E], ++se), ne++;
              if (K[ne - L] !== K[ne] && (Z[V + z] = K[ne] ? 2 : 4, ++se), se > P)
                return null;
            }
            for (ne = L * (T - 1), V = $ * G, K[ne] !== 0 && (Z[V] = 8, ++se), z = 1; z < C; z++)
              K[ne] !== K[ne + 1] && (Z[V + z] = K[ne] ? 4 : 8, ++se), ne++;
            if (K[ne] !== 0 && (Z[V + z] = 4, ++se), se > P)
              return null;
            const q = new Int32Array([0, G, -1, 0, -G, 0, 0, 0, 1]), N = new Path2D();
            for ($ = 0; se && $ <= T; $++) {
              let E = $ * G;
              const te = E + C;
              for (; E < te && !Z[E]; )
                E++;
              if (E === te)
                continue;
              N.moveTo(E % G, $);
              const oe = E;
              let ee = Z[E];
              do {
                const W = q[ee];
                do
                  E += W;
                while (!Z[E]);
                const I = Z[E];
                I !== 5 && I !== 10 ? (ee = I, Z[E] = 0) : (ee = I & 51 * ee >> 4, Z[E] &= ee >> 2 | ee << 2), N.lineTo(E % G, E / G | 0), Z[E] || --se;
              } while (oe !== E);
              --$;
            }
            return K = null, Z = null, function(E) {
              E.save(), E.scale(1 / C, -1 / T), E.translate(0, -T), E.fill(N), E.beginPath(), E.restore();
            };
          }
          class g {
            constructor(C, T) {
              this.alphaIsShape = !1, this.fontSize = 0, this.fontSizeScale = 1, this.textMatrix = re.IDENTITY_MATRIX, this.textMatrixScale = 1, this.fontMatrix = re.FONT_IDENTITY_MATRIX, this.leading = 0, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRenderingMode = re.TextRenderingMode.FILL, this.textRise = 0, this.fillColor = "#000000", this.strokeColor = "#000000", this.patternFill = !1, this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.activeSMask = null, this.transferMaps = null, this.startNewPathAndClipBox([0, 0, C, T]);
            }
            clone() {
              const C = Object.create(this);
              return C.clipBox = this.clipBox.slice(), C;
            }
            setCurrentPoint(C, T) {
              this.x = C, this.y = T;
            }
            updatePathMinMax(C, T, P) {
              [T, P] = re.Util.applyTransform([T, P], C), this.minX = Math.min(this.minX, T), this.minY = Math.min(this.minY, P), this.maxX = Math.max(this.maxX, T), this.maxY = Math.max(this.maxY, P);
            }
            updateRectMinMax(C, T) {
              const P = re.Util.applyTransform(T, C), M = re.Util.applyTransform(T.slice(2), C);
              this.minX = Math.min(this.minX, P[0], M[0]), this.minY = Math.min(this.minY, P[1], M[1]), this.maxX = Math.max(this.maxX, P[0], M[0]), this.maxY = Math.max(this.maxY, P[1], M[1]);
            }
            updateScalingPathMinMax(C, T) {
              re.Util.scaleMinMax(C, T), this.minX = Math.min(this.minX, T[0]), this.maxX = Math.max(this.maxX, T[1]), this.minY = Math.min(this.minY, T[2]), this.maxY = Math.max(this.maxY, T[3]);
            }
            updateCurvePathMinMax(C, T, P, M, G, Z, $, z, V, L) {
              const K = re.Util.bezierBoundingBox(T, P, M, G, Z, $, z, V);
              if (L) {
                L[0] = Math.min(L[0], K[0], K[2]), L[1] = Math.max(L[1], K[0], K[2]), L[2] = Math.min(L[2], K[1], K[3]), L[3] = Math.max(L[3], K[1], K[3]);
                return;
              }
              this.updateRectMinMax(C, K);
            }
            getPathBoundingBox(C = ae.PathType.FILL, T = null) {
              const P = [this.minX, this.minY, this.maxX, this.maxY];
              if (C === ae.PathType.STROKE) {
                T || (0, re.unreachable)("Stroke bounding box must include transform.");
                const M = re.Util.singularValueDecompose2dScale(T), G = M[0] * this.lineWidth / 2, Z = M[1] * this.lineWidth / 2;
                P[0] -= G, P[1] -= Z, P[2] += G, P[3] += Z;
              }
              return P;
            }
            updateClipFromPath() {
              const C = re.Util.intersect(this.clipBox, this.getPathBoundingBox());
              this.startNewPathAndClipBox(C || [0, 0, 0, 0]);
            }
            isEmptyClip() {
              return this.minX === 1 / 0;
            }
            startNewPathAndClipBox(C) {
              this.clipBox = C, this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = 0, this.maxY = 0;
            }
            getClippedPathBoundingBox(C = ae.PathType.FILL, T = null) {
              return re.Util.intersect(this.clipBox, this.getPathBoundingBox(C, T));
            }
          }
          function n(S, C, T = null) {
            if (typeof ImageData < "u" && C instanceof ImageData) {
              S.putImageData(C, 0, 0);
              return;
            }
            const P = C.height, M = C.width, G = P % y, Z = (P - G) / y, $ = G === 0 ? Z : Z + 1, z = S.createImageData(M, y);
            let V = 0, L;
            const K = C.data, ne = z.data;
            let se, q, N, Q, E, te, oe, ee;
            if (T)
              switch (T.length) {
                case 1:
                  E = T[0], te = T[0], oe = T[0], ee = T[0];
                  break;
                case 4:
                  E = T[0], te = T[1], oe = T[2], ee = T[3];
                  break;
              }
            if (C.kind === re.ImageKind.GRAYSCALE_1BPP) {
              const W = K.byteLength, I = new Uint32Array(ne.buffer, 0, ne.byteLength >> 2), H = I.length, ie = M + 7 >> 3;
              let ue = 4294967295, fe = re.FeatureTest.isLittleEndian ? 4278190080 : 255;
              for (ee && ee[0] === 255 && ee[255] === 0 && ([ue, fe] = [fe, ue]), se = 0; se < $; se++) {
                for (N = se < Z ? y : G, L = 0, q = 0; q < N; q++) {
                  const de = W - V;
                  let pe = 0;
                  const xe = de > ie ? M : de * 8 - 7, Fe = xe & -8;
                  let Se = 0, Ce = 0;
                  for (; pe < Fe; pe += 8)
                    Ce = K[V++], I[L++] = Ce & 128 ? ue : fe, I[L++] = Ce & 64 ? ue : fe, I[L++] = Ce & 32 ? ue : fe, I[L++] = Ce & 16 ? ue : fe, I[L++] = Ce & 8 ? ue : fe, I[L++] = Ce & 4 ? ue : fe, I[L++] = Ce & 2 ? ue : fe, I[L++] = Ce & 1 ? ue : fe;
                  for (; pe < xe; pe++)
                    Se === 0 && (Ce = K[V++], Se = 128), I[L++] = Ce & Se ? ue : fe, Se >>= 1;
                }
                for (; L < H; )
                  I[L++] = 0;
                S.putImageData(z, 0, se * y);
              }
            } else if (C.kind === re.ImageKind.RGBA_32BPP) {
              const W = !!(E || te || oe);
              for (q = 0, Q = M * y * 4, se = 0; se < Z; se++) {
                if (ne.set(K.subarray(V, V + Q)), V += Q, W)
                  for (let I = 0; I < Q; I += 4)
                    E && (ne[I + 0] = E[ne[I + 0]]), te && (ne[I + 1] = te[ne[I + 1]]), oe && (ne[I + 2] = oe[ne[I + 2]]);
                S.putImageData(z, 0, q), q += y;
              }
              if (se < $) {
                if (Q = M * G * 4, ne.set(K.subarray(V, V + Q)), W)
                  for (let I = 0; I < Q; I += 4)
                    E && (ne[I + 0] = E[ne[I + 0]]), te && (ne[I + 1] = te[ne[I + 1]]), oe && (ne[I + 2] = oe[ne[I + 2]]);
                S.putImageData(z, 0, q);
              }
            } else if (C.kind === re.ImageKind.RGB_24BPP) {
              const W = !!(E || te || oe);
              for (N = y, Q = M * N, se = 0; se < $; se++) {
                for (se >= Z && (N = G, Q = M * N), L = 0, q = Q; q--; )
                  ne[L++] = K[V++], ne[L++] = K[V++], ne[L++] = K[V++], ne[L++] = 255;
                if (W)
                  for (let I = 0; I < L; I += 4)
                    E && (ne[I + 0] = E[ne[I + 0]]), te && (ne[I + 1] = te[ne[I + 1]]), oe && (ne[I + 2] = oe[ne[I + 2]]);
                S.putImageData(z, 0, se * y);
              }
            } else
              throw new Error(`bad image kind: ${C.kind}`);
          }
          function i(S, C) {
            if (C.bitmap) {
              S.drawImage(C.bitmap, 0, 0);
              return;
            }
            const T = C.height, P = C.width, M = T % y, G = (T - M) / y, Z = M === 0 ? G : G + 1, $ = S.createImageData(P, y);
            let z = 0;
            const V = C.data, L = $.data;
            for (let K = 0; K < Z; K++) {
              const ne = K < G ? y : M;
              ({
                srcPos: z
              } = (0, J.applyMaskImageData)({
                src: V,
                srcPos: z,
                dest: L,
                width: P,
                height: ne
              })), S.putImageData($, 0, K * y);
            }
          }
          function l(S, C) {
            const T = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font"];
            for (let P = 0, M = T.length; P < M; P++) {
              const G = T[P];
              S[G] !== void 0 && (C[G] = S[G]);
            }
            S.setLineDash !== void 0 && (C.setLineDash(S.getLineDash()), C.lineDashOffset = S.lineDashOffset);
          }
          function u(S, C) {
            S.strokeStyle = S.fillStyle = C || "#000000", S.fillRule = "nonzero", S.globalAlpha = 1, S.lineWidth = 1, S.lineCap = "butt", S.lineJoin = "miter", S.miterLimit = 10, S.globalCompositeOperation = "source-over", S.font = "10px sans-serif", S.setLineDash !== void 0 && (S.setLineDash([]), S.lineDashOffset = 0);
          }
          function w(S, C, T, P) {
            const M = S.length;
            for (let G = 3; G < M; G += 4) {
              const Z = S[G];
              if (Z === 0)
                S[G - 3] = C, S[G - 2] = T, S[G - 1] = P;
              else if (Z < 255) {
                const $ = 255 - Z;
                S[G - 3] = S[G - 3] * Z + C * $ >> 8, S[G - 2] = S[G - 2] * Z + T * $ >> 8, S[G - 1] = S[G - 1] * Z + P * $ >> 8;
              }
            }
          }
          function O(S, C, T) {
            const P = S.length, M = 1 / 255;
            for (let G = 3; G < P; G += 4) {
              const Z = T ? T[S[G]] : S[G];
              C[G] = C[G] * Z * M | 0;
            }
          }
          function b(S, C, T) {
            const P = S.length;
            for (let M = 3; M < P; M += 4) {
              const G = S[M - 3] * 77 + S[M - 2] * 152 + S[M - 1] * 28;
              C[M] = T ? C[M] * T[G >> 8] >> 8 : C[M] * G >> 16;
            }
          }
          function A(S, C, T, P, M, G, Z, $, z, V, L) {
            const K = !!G, ne = K ? G[0] : 0, se = K ? G[1] : 0, q = K ? G[2] : 0;
            let N;
            M === "Luminosity" ? N = b : N = O;
            const E = Math.min(P, Math.ceil(1048576 / T));
            for (let te = 0; te < P; te += E) {
              const oe = Math.min(E, P - te), ee = S.getImageData($ - V, te + (z - L), T, oe), W = C.getImageData($, te + z, T, oe);
              K && w(ee.data, ne, se, q), N(ee.data, W.data, Z), C.putImageData(W, $, te + z);
            }
          }
          function Y(S, C, T, P) {
            const M = P[0], G = P[1], Z = P[2] - M, $ = P[3] - G;
            Z === 0 || $ === 0 || (A(C.context, T, Z, $, C.subtype, C.backdrop, C.transferMap, M, G, C.offsetX, C.offsetY), S.save(), S.globalAlpha = 1, S.globalCompositeOperation = "source-over", S.setTransform(1, 0, 0, 1, 0, 0), S.drawImage(T.canvas, 0, 0), S.restore());
          }
          function j(S, C) {
            const T = re.Util.singularValueDecompose2dScale(S);
            T[0] = Math.fround(T[0]), T[1] = Math.fround(T[1]);
            const P = Math.fround((globalThis.devicePixelRatio || 1) * ce.PixelsPerInch.PDF_TO_CSS_UNITS);
            return C !== void 0 ? C : T[0] <= P || T[1] <= P;
          }
          const X = ["butt", "round", "square"], B = ["miter", "round", "bevel"], U = {}, k = {}, _ = class {
            constructor(C, T, P, M, G, Z, $, z) {
              gt(this, f);
              this.ctx = C, this.current = new g(this.ctx.canvas.width, this.ctx.canvas.height), this.stateStack = [], this.pendingClip = null, this.pendingEOFill = !1, this.res = null, this.xobjs = null, this.commonObjs = T, this.objs = P, this.canvasFactory = M, this.imageLayer = G, this.groupStack = [], this.processingType3 = null, this.baseTransform = null, this.baseTransformStack = [], this.groupLevel = 0, this.smaskStack = [], this.smaskCounter = 0, this.tempSMask = null, this.suspendedCtx = null, this.contentVisible = !0, this.markedContentStack = [], this.optionalContentConfig = Z, this.cachedCanvases = new d(this.canvasFactory), this.cachedPatterns = /* @__PURE__ */ new Map(), this.annotationCanvasMap = $, this.viewportScale = 1, this.outputScaleX = 1, this.outputScaleY = 1, this.backgroundColor = (z == null ? void 0 : z.background) || null, this.foregroundColor = (z == null ? void 0 : z.foreground) || null, this._cachedScaleForStroking = null, this._cachedGetSinglePixelWidth = null, this._cachedBitmapsMap = /* @__PURE__ */ new Map();
            }
            getObject(C, T = null) {
              return typeof C == "string" ? C.startsWith("g_") ? this.commonObjs.get(C) : this.objs.get(C) : T;
            }
            beginDrawing({
              transform: C,
              viewport: T,
              transparency: P = !1,
              background: M = null
            }) {
              const G = this.ctx.canvas.width, Z = this.ctx.canvas.height, $ = M || "#ffffff";
              if (this.ctx.save(), this.foregroundColor && this.backgroundColor) {
                this.ctx.fillStyle = this.foregroundColor;
                const z = this.foregroundColor = this.ctx.fillStyle;
                this.ctx.fillStyle = this.backgroundColor;
                const V = this.backgroundColor = this.ctx.fillStyle;
                let L = !0, K = $;
                if (this.ctx.fillStyle = $, K = this.ctx.fillStyle, L = typeof K == "string" && /^#[0-9A-Fa-f]{6}$/.test(K), z === "#000000" && V === "#ffffff" || z === V || !L)
                  this.foregroundColor = this.backgroundColor = null;
                else {
                  const [ne, se, q] = (0, ce.getRGB)(K), N = (E) => (E /= 255, E <= 0.03928 ? E / 12.92 : ((E + 0.055) / 1.055) ** 2.4), Q = Math.round(0.2126 * N(ne) + 0.7152 * N(se) + 0.0722 * N(q));
                  this.selectColor = (E, te, oe) => {
                    const ee = 0.2126 * N(E) + 0.7152 * N(te) + 0.0722 * N(oe);
                    return Math.round(ee) === Q ? V : z;
                  };
                }
              }
              if (this.ctx.fillStyle = this.backgroundColor || $, this.ctx.fillRect(0, 0, G, Z), this.ctx.restore(), P) {
                const z = this.cachedCanvases.getCanvas("transparent", G, Z);
                this.compositeCtx = this.ctx, this.transparentCanvas = z.canvas, this.ctx = z.context, this.ctx.save(), this.ctx.transform(...(0, ce.getCurrentTransform)(this.compositeCtx));
              }
              this.ctx.save(), u(this.ctx, this.foregroundColor), C && (this.ctx.transform(...C), this.outputScaleX = C[0], this.outputScaleY = C[0]), this.ctx.transform(...T.transform), this.viewportScale = T.scale, this.baseTransform = (0, ce.getCurrentTransform)(this.ctx), this.imageLayer && ((0, ce.deprecated)("The `imageLayer` functionality will be removed in the future."), this.imageLayer.beginLayout());
            }
            executeOperatorList(C, T, P, M) {
              const G = C.argsArray, Z = C.fnArray;
              let $ = T || 0;
              const z = G.length;
              if (z === $)
                return $;
              const V = z - $ > h && typeof P == "function", L = V ? Date.now() + v : 0;
              let K = 0;
              const ne = this.commonObjs, se = this.objs;
              let q;
              for (; ; ) {
                if (M !== void 0 && $ === M.nextBreakPoint)
                  return M.breakIt($, P), $;
                if (q = Z[$], q !== re.OPS.dependency)
                  this[q].apply(this, G[$]);
                else
                  for (const N of G[$]) {
                    const Q = N.startsWith("g_") ? ne : se;
                    if (!Q.has(N))
                      return Q.get(N, P), $;
                  }
                if ($++, $ === z)
                  return $;
                if (V && ++K > h) {
                  if (Date.now() > L)
                    return P(), $;
                  K = 0;
                }
              }
            }
            endDrawing() {
              At(this, f, mi).call(this), this.cachedCanvases.clear(), this.cachedPatterns.clear();
              for (const C of this._cachedBitmapsMap.values()) {
                for (const T of C.values())
                  typeof HTMLCanvasElement < "u" && T instanceof HTMLCanvasElement && (T.width = T.height = 0);
                C.clear();
              }
              this._cachedBitmapsMap.clear(), this.imageLayer && this.imageLayer.endLayout();
            }
            _scaleImage(C, T) {
              const P = C.width, M = C.height;
              let G = Math.max(Math.hypot(T[0], T[1]), 1), Z = Math.max(Math.hypot(T[2], T[3]), 1), $ = P, z = M, V = "prescale1", L, K;
              for (; G > 2 && $ > 1 || Z > 2 && z > 1; ) {
                let ne = $, se = z;
                G > 2 && $ > 1 && (ne = Math.ceil($ / 2), G /= $ / ne), Z > 2 && z > 1 && (se = Math.ceil(z / 2), Z /= z / se), L = this.cachedCanvases.getCanvas(V, ne, se), K = L.context, K.clearRect(0, 0, ne, se), K.drawImage(C, 0, 0, $, z, 0, 0, ne, se), C = L.canvas, $ = ne, z = se, V = V === "prescale1" ? "prescale2" : "prescale1";
              }
              return {
                img: C,
                paintWidth: $,
                paintHeight: z
              };
            }
            _createMaskCanvas(C) {
              const T = this.ctx, {
                width: P,
                height: M
              } = C, G = this.current.fillColor, Z = this.current.patternFill, $ = (0, ce.getCurrentTransform)(T);
              let z, V, L, K;
              if ((C.bitmap || C.data) && C.count > 1) {
                const H = C.bitmap || C.data.buffer, ie = $.slice(0, 4);
                V = JSON.stringify(Z ? ie : [ie, G]), z = this._cachedBitmapsMap.get(H), z || (z = /* @__PURE__ */ new Map(), this._cachedBitmapsMap.set(H, z));
                const ue = z.get(V);
                if (ue && !Z) {
                  const fe = Math.round(Math.min($[0], $[2]) + $[4]), de = Math.round(Math.min($[1], $[3]) + $[5]);
                  return {
                    canvas: ue,
                    offsetX: fe,
                    offsetY: de
                  };
                }
                L = ue;
              }
              L || (K = this.cachedCanvases.getCanvas("maskCanvas", P, M), i(K.context, C));
              let ne = re.Util.transform($, [1 / P, 0, 0, -1 / M, 0, 0]);
              ne = re.Util.transform(ne, [1, 0, 0, 1, 0, -M]);
              const se = re.Util.applyTransform([0, 0], ne), q = re.Util.applyTransform([P, M], ne), N = re.Util.normalizeRect([se[0], se[1], q[0], q[1]]), Q = Math.round(N[2] - N[0]) || 1, E = Math.round(N[3] - N[1]) || 1, te = this.cachedCanvases.getCanvas("fillCanvas", Q, E), oe = te.context, ee = Math.min(se[0], q[0]), W = Math.min(se[1], q[1]);
              oe.translate(-ee, -W), oe.transform(...ne), L || (L = this._scaleImage(K.canvas, (0, ce.getCurrentTransformInverse)(oe)), L = L.img, z && Z && z.set(V, L)), oe.imageSmoothingEnabled = j((0, ce.getCurrentTransform)(oe), C.interpolate), m(oe, L, 0, 0, L.width, L.height, 0, 0, P, M), oe.globalCompositeOperation = "source-in";
              const I = re.Util.transform((0, ce.getCurrentTransformInverse)(oe), [1, 0, 0, 1, -ee, -W]);
              return oe.fillStyle = Z ? G.getPattern(T, this, I, ae.PathType.FILL) : G, oe.fillRect(0, 0, P, M), z && !Z && (this.cachedCanvases.delete("fillCanvas"), z.set(V, te.canvas)), {
                canvas: te.canvas,
                offsetX: Math.round(ee),
                offsetY: Math.round(W)
              };
            }
            setLineWidth(C) {
              C !== this.current.lineWidth && (this._cachedScaleForStroking = null), this.current.lineWidth = C, this.ctx.lineWidth = C;
            }
            setLineCap(C) {
              this.ctx.lineCap = X[C];
            }
            setLineJoin(C) {
              this.ctx.lineJoin = B[C];
            }
            setMiterLimit(C) {
              this.ctx.miterLimit = C;
            }
            setDash(C, T) {
              const P = this.ctx;
              P.setLineDash !== void 0 && (P.setLineDash(C), P.lineDashOffset = T);
            }
            setRenderingIntent(C) {
            }
            setFlatness(C) {
            }
            setGState(C) {
              for (let T = 0, P = C.length; T < P; T++) {
                const M = C[T], G = M[0], Z = M[1];
                switch (G) {
                  case "LW":
                    this.setLineWidth(Z);
                    break;
                  case "LC":
                    this.setLineCap(Z);
                    break;
                  case "LJ":
                    this.setLineJoin(Z);
                    break;
                  case "ML":
                    this.setMiterLimit(Z);
                    break;
                  case "D":
                    this.setDash(Z[0], Z[1]);
                    break;
                  case "RI":
                    this.setRenderingIntent(Z);
                    break;
                  case "FL":
                    this.setFlatness(Z);
                    break;
                  case "Font":
                    this.setFont(Z[0], Z[1]);
                    break;
                  case "CA":
                    this.current.strokeAlpha = M[1];
                    break;
                  case "ca":
                    this.current.fillAlpha = M[1], this.ctx.globalAlpha = M[1];
                    break;
                  case "BM":
                    this.ctx.globalCompositeOperation = Z;
                    break;
                  case "SMask":
                    this.current.activeSMask = Z ? this.tempSMask : null, this.tempSMask = null, this.checkSMaskState();
                    break;
                  case "TR":
                    this.current.transferMaps = Z;
                }
              }
            }
            get inSMaskMode() {
              return !!this.suspendedCtx;
            }
            checkSMaskState() {
              const C = this.inSMaskMode;
              this.current.activeSMask && !C ? this.beginSMaskMode() : !this.current.activeSMask && C && this.endSMaskMode();
            }
            beginSMaskMode() {
              if (this.inSMaskMode)
                throw new Error("beginSMaskMode called while already in smask mode");
              const C = this.ctx.canvas.width, T = this.ctx.canvas.height, P = "smaskGroupAt" + this.groupLevel, M = this.cachedCanvases.getCanvas(P, C, T);
              this.suspendedCtx = this.ctx, this.ctx = M.context;
              const G = this.ctx;
              G.setTransform(...(0, ce.getCurrentTransform)(this.suspendedCtx)), l(this.suspendedCtx, G), c(G, this.suspendedCtx), this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
            }
            endSMaskMode() {
              if (!this.inSMaskMode)
                throw new Error("endSMaskMode called while not in smask mode");
              this.ctx._removeMirroring(), l(this.ctx, this.suspendedCtx), this.ctx = this.suspendedCtx, this.suspendedCtx = null;
            }
            compose(C) {
              if (!this.current.activeSMask)
                return;
              C ? (C[0] = Math.floor(C[0]), C[1] = Math.floor(C[1]), C[2] = Math.ceil(C[2]), C[3] = Math.ceil(C[3])) : C = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
              const T = this.current.activeSMask, P = this.suspendedCtx;
              Y(P, T, this.ctx, C), this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height), this.ctx.restore();
            }
            save() {
              this.inSMaskMode ? (l(this.ctx, this.suspendedCtx), this.suspendedCtx.save()) : this.ctx.save();
              const C = this.current;
              this.stateStack.push(C), this.current = C.clone();
            }
            restore() {
              this.stateStack.length === 0 && this.inSMaskMode && this.endSMaskMode(), this.stateStack.length !== 0 && (this.current = this.stateStack.pop(), this.inSMaskMode ? (this.suspendedCtx.restore(), l(this.suspendedCtx, this.ctx)) : this.ctx.restore(), this.checkSMaskState(), this.pendingClip = null, this._cachedScaleForStroking = null, this._cachedGetSinglePixelWidth = null);
            }
            transform(C, T, P, M, G, Z) {
              this.ctx.transform(C, T, P, M, G, Z), this._cachedScaleForStroking = null, this._cachedGetSinglePixelWidth = null;
            }
            constructPath(C, T, P) {
              const M = this.ctx, G = this.current;
              let Z = G.x, $ = G.y, z, V;
              const L = (0, ce.getCurrentTransform)(M), K = L[0] === 0 && L[3] === 0 || L[1] === 0 && L[2] === 0, ne = K ? P.slice(0) : null;
              for (let se = 0, q = 0, N = C.length; se < N; se++)
                switch (C[se] | 0) {
                  case re.OPS.rectangle:
                    Z = T[q++], $ = T[q++];
                    const Q = T[q++], E = T[q++], te = Z + Q, oe = $ + E;
                    M.moveTo(Z, $), Q === 0 || E === 0 ? M.lineTo(te, oe) : (M.lineTo(te, $), M.lineTo(te, oe), M.lineTo(Z, oe)), K || G.updateRectMinMax(L, [Z, $, te, oe]), M.closePath();
                    break;
                  case re.OPS.moveTo:
                    Z = T[q++], $ = T[q++], M.moveTo(Z, $), K || G.updatePathMinMax(L, Z, $);
                    break;
                  case re.OPS.lineTo:
                    Z = T[q++], $ = T[q++], M.lineTo(Z, $), K || G.updatePathMinMax(L, Z, $);
                    break;
                  case re.OPS.curveTo:
                    z = Z, V = $, Z = T[q + 4], $ = T[q + 5], M.bezierCurveTo(T[q], T[q + 1], T[q + 2], T[q + 3], Z, $), G.updateCurvePathMinMax(L, z, V, T[q], T[q + 1], T[q + 2], T[q + 3], Z, $, ne), q += 6;
                    break;
                  case re.OPS.curveTo2:
                    z = Z, V = $, M.bezierCurveTo(Z, $, T[q], T[q + 1], T[q + 2], T[q + 3]), G.updateCurvePathMinMax(L, z, V, Z, $, T[q], T[q + 1], T[q + 2], T[q + 3], ne), Z = T[q + 2], $ = T[q + 3], q += 4;
                    break;
                  case re.OPS.curveTo3:
                    z = Z, V = $, Z = T[q + 2], $ = T[q + 3], M.bezierCurveTo(T[q], T[q + 1], Z, $, Z, $), G.updateCurvePathMinMax(L, z, V, T[q], T[q + 1], Z, $, Z, $, ne), q += 4;
                    break;
                  case re.OPS.closePath:
                    M.closePath();
                    break;
                }
              K && G.updateScalingPathMinMax(L, ne), G.setCurrentPoint(Z, $);
            }
            closePath() {
              this.ctx.closePath();
            }
            stroke(C) {
              C = typeof C < "u" ? C : !0;
              const T = this.ctx, P = this.current.strokeColor;
              T.globalAlpha = this.current.strokeAlpha, this.contentVisible && (typeof P == "object" && (P != null && P.getPattern) ? (T.save(), T.strokeStyle = P.getPattern(T, this, (0, ce.getCurrentTransformInverse)(T), ae.PathType.STROKE), this.rescaleAndStroke(!1), T.restore()) : this.rescaleAndStroke(!0)), C && this.consumePath(this.current.getClippedPathBoundingBox()), T.globalAlpha = this.current.fillAlpha;
            }
            closeStroke() {
              this.closePath(), this.stroke();
            }
            fill(C) {
              C = typeof C < "u" ? C : !0;
              const T = this.ctx, P = this.current.fillColor, M = this.current.patternFill;
              let G = !1;
              M && (T.save(), T.fillStyle = P.getPattern(T, this, (0, ce.getCurrentTransformInverse)(T), ae.PathType.FILL), G = !0);
              const Z = this.current.getClippedPathBoundingBox();
              this.contentVisible && Z !== null && (this.pendingEOFill ? (T.fill("evenodd"), this.pendingEOFill = !1) : T.fill()), G && T.restore(), C && this.consumePath(Z);
            }
            eoFill() {
              this.pendingEOFill = !0, this.fill();
            }
            fillStroke() {
              this.fill(!1), this.stroke(!1), this.consumePath();
            }
            eoFillStroke() {
              this.pendingEOFill = !0, this.fillStroke();
            }
            closeFillStroke() {
              this.closePath(), this.fillStroke();
            }
            closeEOFillStroke() {
              this.pendingEOFill = !0, this.closePath(), this.fillStroke();
            }
            endPath() {
              this.consumePath();
            }
            clip() {
              this.pendingClip = U;
            }
            eoClip() {
              this.pendingClip = k;
            }
            beginText() {
              this.current.textMatrix = re.IDENTITY_MATRIX, this.current.textMatrixScale = 1, this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
            }
            endText() {
              const C = this.pendingTextPaths, T = this.ctx;
              if (C === void 0) {
                T.beginPath();
                return;
              }
              T.save(), T.beginPath();
              for (const P of C)
                T.setTransform(...P.transform), T.translate(P.x, P.y), P.addToPath(T, P.fontSize);
              T.restore(), T.clip(), T.beginPath(), delete this.pendingTextPaths;
            }
            setCharSpacing(C) {
              this.current.charSpacing = C;
            }
            setWordSpacing(C) {
              this.current.wordSpacing = C;
            }
            setHScale(C) {
              this.current.textHScale = C / 100;
            }
            setLeading(C) {
              this.current.leading = -C;
            }
            setFont(C, T) {
              const P = this.commonObjs.get(C), M = this.current;
              if (!P)
                throw new Error(`Can't find font for ${C}`);
              if (M.fontMatrix = P.fontMatrix || re.FONT_IDENTITY_MATRIX, (M.fontMatrix[0] === 0 || M.fontMatrix[3] === 0) && (0, re.warn)("Invalid font matrix for font " + C), T < 0 ? (T = -T, M.fontDirection = -1) : M.fontDirection = 1, this.current.font = P, this.current.fontSize = T, P.isType3Font)
                return;
              const G = P.loadedName || "sans-serif";
              let Z = "normal";
              P.black ? Z = "900" : P.bold && (Z = "bold");
              const $ = P.italic ? "italic" : "normal", z = `"${G}", ${P.fallbackName}`;
              let V = T;
              T < F ? V = F : T > t && (V = t), this.current.fontSizeScale = T / V, this.ctx.font = `${$} ${Z} ${V}px ${z}`;
            }
            setTextRenderingMode(C) {
              this.current.textRenderingMode = C;
            }
            setTextRise(C) {
              this.current.textRise = C;
            }
            moveText(C, T) {
              this.current.x = this.current.lineX += C, this.current.y = this.current.lineY += T;
            }
            setLeadingMoveText(C, T) {
              this.setLeading(-T), this.moveText(C, T);
            }
            setTextMatrix(C, T, P, M, G, Z) {
              this.current.textMatrix = [C, T, P, M, G, Z], this.current.textMatrixScale = Math.hypot(C, T), this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
            }
            nextLine() {
              this.moveText(0, this.current.leading);
            }
            paintChar(C, T, P, M) {
              const G = this.ctx, Z = this.current, $ = Z.font, z = Z.textRenderingMode, V = Z.fontSize / Z.fontSizeScale, L = z & re.TextRenderingMode.FILL_STROKE_MASK, K = !!(z & re.TextRenderingMode.ADD_TO_PATH_FLAG), ne = Z.patternFill && !$.missingFile;
              let se;
              ($.disableFontFace || K || ne) && (se = $.getPathGenerator(this.commonObjs, C)), $.disableFontFace || ne ? (G.save(), G.translate(T, P), G.beginPath(), se(G, V), M && G.setTransform(...M), (L === re.TextRenderingMode.FILL || L === re.TextRenderingMode.FILL_STROKE) && G.fill(), (L === re.TextRenderingMode.STROKE || L === re.TextRenderingMode.FILL_STROKE) && G.stroke(), G.restore()) : ((L === re.TextRenderingMode.FILL || L === re.TextRenderingMode.FILL_STROKE) && G.fillText(C, T, P), (L === re.TextRenderingMode.STROKE || L === re.TextRenderingMode.FILL_STROKE) && G.strokeText(C, T, P)), K && (this.pendingTextPaths || (this.pendingTextPaths = [])).push({
                transform: (0, ce.getCurrentTransform)(G),
                x: T,
                y: P,
                fontSize: V,
                addToPath: se
              });
            }
            get isFontSubpixelAAEnabled() {
              const {
                context: C
              } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
              C.scale(1.5, 1), C.fillText("I", 0, 10);
              const T = C.getImageData(0, 0, 10, 10).data;
              let P = !1;
              for (let M = 3; M < T.length; M += 4)
                if (T[M] > 0 && T[M] < 255) {
                  P = !0;
                  break;
                }
              return (0, re.shadow)(this, "isFontSubpixelAAEnabled", P);
            }
            showText(C) {
              const T = this.current, P = T.font;
              if (P.isType3Font)
                return this.showType3Text(C);
              const M = T.fontSize;
              if (M === 0)
                return;
              const G = this.ctx, Z = T.fontSizeScale, $ = T.charSpacing, z = T.wordSpacing, V = T.fontDirection, L = T.textHScale * V, K = C.length, ne = P.vertical, se = ne ? 1 : -1, q = P.defaultVMetrics, N = M * T.fontMatrix[0], Q = T.textRenderingMode === re.TextRenderingMode.FILL && !P.disableFontFace && !T.patternFill;
              G.save(), G.transform(...T.textMatrix), G.translate(T.x, T.y + T.textRise), V > 0 ? G.scale(L, -1) : G.scale(L, 1);
              let E;
              if (T.patternFill) {
                G.save();
                const I = T.fillColor.getPattern(G, this, (0, ce.getCurrentTransformInverse)(G), ae.PathType.FILL);
                E = (0, ce.getCurrentTransform)(G), G.restore(), G.fillStyle = I;
              }
              let te = T.lineWidth;
              const oe = T.textMatrixScale;
              if (oe === 0 || te === 0) {
                const I = T.textRenderingMode & re.TextRenderingMode.FILL_STROKE_MASK;
                (I === re.TextRenderingMode.STROKE || I === re.TextRenderingMode.FILL_STROKE) && (te = this.getSinglePixelWidth());
              } else
                te /= oe;
              Z !== 1 && (G.scale(Z, Z), te /= Z), G.lineWidth = te;
              let ee = 0, W;
              for (W = 0; W < K; ++W) {
                const I = C[W];
                if (typeof I == "number") {
                  ee += se * I * M / 1e3;
                  continue;
                }
                let H = !1;
                const ie = (I.isSpace ? z : 0) + $, ue = I.fontChar, fe = I.accent;
                let de, pe, xe = I.width;
                if (ne) {
                  const Se = I.vmetric || q, Ce = -(I.vmetric ? Se[1] : xe * 0.5) * N, ke = Se[2] * N;
                  xe = Se ? -Se[0] : xe, de = Ce / Z, pe = (ee + ke) / Z;
                } else
                  de = ee / Z, pe = 0;
                if (P.remeasure && xe > 0) {
                  const Se = G.measureText(ue).width * 1e3 / M * Z;
                  if (xe < Se && this.isFontSubpixelAAEnabled) {
                    const Ce = xe / Se;
                    H = !0, G.save(), G.scale(Ce, 1), de /= Ce;
                  } else
                    xe !== Se && (de += (xe - Se) / 2e3 * M / Z);
                }
                if (this.contentVisible && (I.isInFont || P.missingFile)) {
                  if (Q && !fe)
                    G.fillText(ue, de, pe);
                  else if (this.paintChar(ue, de, pe, E), fe) {
                    const Se = de + M * fe.offset.x / Z, Ce = pe - M * fe.offset.y / Z;
                    this.paintChar(fe.fontChar, Se, Ce, E);
                  }
                }
                let Fe;
                ne ? Fe = xe * N - ie * V : Fe = xe * N + ie * V, ee += Fe, H && G.restore();
              }
              ne ? T.y -= ee : T.x += ee * L, G.restore(), this.compose();
            }
            showType3Text(C) {
              const T = this.ctx, P = this.current, M = P.font, G = P.fontSize, Z = P.fontDirection, $ = M.vertical ? 1 : -1, z = P.charSpacing, V = P.wordSpacing, L = P.textHScale * Z, K = P.fontMatrix || re.FONT_IDENTITY_MATRIX, ne = C.length, se = P.textRenderingMode === re.TextRenderingMode.INVISIBLE;
              let q, N, Q, E;
              if (!(se || G === 0)) {
                for (this._cachedScaleForStroking = null, this._cachedGetSinglePixelWidth = null, T.save(), T.transform(...P.textMatrix), T.translate(P.x, P.y), T.scale(L, Z), q = 0; q < ne; ++q) {
                  if (N = C[q], typeof N == "number") {
                    E = $ * N * G / 1e3, this.ctx.translate(E, 0), P.x += E * L;
                    continue;
                  }
                  const te = (N.isSpace ? V : 0) + z, oe = M.charProcOperatorList[N.operatorListId];
                  if (!oe) {
                    (0, re.warn)(`Type3 character "${N.operatorListId}" is not available.`);
                    continue;
                  }
                  this.contentVisible && (this.processingType3 = N, this.save(), T.scale(G, G), T.transform(...K), this.executeOperatorList(oe), this.restore()), Q = re.Util.applyTransform([N.width, 0], K)[0] * G + te, T.translate(Q, 0), P.x += Q * L;
                }
                T.restore(), this.processingType3 = null;
              }
            }
            setCharWidth(C, T) {
            }
            setCharWidthAndBounds(C, T, P, M, G, Z) {
              this.ctx.rect(P, M, G - P, Z - M), this.ctx.clip(), this.endPath();
            }
            getColorN_Pattern(C) {
              let T;
              if (C[0] === "TilingPattern") {
                const P = C[1], M = this.baseTransform || (0, ce.getCurrentTransform)(this.ctx), G = {
                  createCanvasGraphics: (Z) => new _(Z, this.commonObjs, this.objs, this.canvasFactory)
                };
                T = new ae.TilingPattern(C, P, this.ctx, G, M);
              } else
                T = this._getPattern(C[1], C[2]);
              return T;
            }
            setStrokeColorN() {
              this.current.strokeColor = this.getColorN_Pattern(arguments);
            }
            setFillColorN() {
              this.current.fillColor = this.getColorN_Pattern(arguments), this.current.patternFill = !0;
            }
            setStrokeRGBColor(C, T, P) {
              var G;
              const M = ((G = this.selectColor) == null ? void 0 : G.call(this, C, T, P)) || re.Util.makeHexColor(C, T, P);
              this.ctx.strokeStyle = M, this.current.strokeColor = M;
            }
            setFillRGBColor(C, T, P) {
              var G;
              const M = ((G = this.selectColor) == null ? void 0 : G.call(this, C, T, P)) || re.Util.makeHexColor(C, T, P);
              this.ctx.fillStyle = M, this.current.fillColor = M, this.current.patternFill = !1;
            }
            _getPattern(C, T = null) {
              let P;
              return this.cachedPatterns.has(C) ? P = this.cachedPatterns.get(C) : (P = (0, ae.getShadingPattern)(this.objs.get(C)), this.cachedPatterns.set(C, P)), T && (P.matrix = T), P;
            }
            shadingFill(C) {
              if (!this.contentVisible)
                return;
              const T = this.ctx;
              this.save();
              const P = this._getPattern(C);
              T.fillStyle = P.getPattern(T, this, (0, ce.getCurrentTransformInverse)(T), ae.PathType.SHADING);
              const M = (0, ce.getCurrentTransformInverse)(T);
              if (M) {
                const G = T.canvas, Z = G.width, $ = G.height, z = re.Util.applyTransform([0, 0], M), V = re.Util.applyTransform([0, $], M), L = re.Util.applyTransform([Z, 0], M), K = re.Util.applyTransform([Z, $], M), ne = Math.min(z[0], V[0], L[0], K[0]), se = Math.min(z[1], V[1], L[1], K[1]), q = Math.max(z[0], V[0], L[0], K[0]), N = Math.max(z[1], V[1], L[1], K[1]);
                this.ctx.fillRect(ne, se, q - ne, N - se);
              } else
                this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
              this.compose(this.current.getClippedPathBoundingBox()), this.restore();
            }
            beginInlineImage() {
              (0, re.unreachable)("Should not call beginInlineImage");
            }
            beginImageData() {
              (0, re.unreachable)("Should not call beginImageData");
            }
            paintFormXObjectBegin(C, T) {
              if (this.contentVisible && (this.save(), this.baseTransformStack.push(this.baseTransform), Array.isArray(C) && C.length === 6 && this.transform(...C), this.baseTransform = (0, ce.getCurrentTransform)(this.ctx), T)) {
                const P = T[2] - T[0], M = T[3] - T[1];
                this.ctx.rect(T[0], T[1], P, M), this.current.updateRectMinMax((0, ce.getCurrentTransform)(this.ctx), T), this.clip(), this.endPath();
              }
            }
            paintFormXObjectEnd() {
              this.contentVisible && (this.restore(), this.baseTransform = this.baseTransformStack.pop());
            }
            beginGroup(C) {
              if (!this.contentVisible)
                return;
              this.save(), this.inSMaskMode && (this.endSMaskMode(), this.current.activeSMask = null);
              const T = this.ctx;
              C.isolated || (0, re.info)("TODO: Support non-isolated groups."), C.knockout && (0, re.warn)("Knockout groups not supported.");
              const P = (0, ce.getCurrentTransform)(T);
              if (C.matrix && T.transform(...C.matrix), !C.bbox)
                throw new Error("Bounding box is required.");
              let M = re.Util.getAxialAlignedBoundingBox(C.bbox, (0, ce.getCurrentTransform)(T));
              const G = [0, 0, T.canvas.width, T.canvas.height];
              M = re.Util.intersect(M, G) || [0, 0, 0, 0];
              const Z = Math.floor(M[0]), $ = Math.floor(M[1]);
              let z = Math.max(Math.ceil(M[2]) - Z, 1), V = Math.max(Math.ceil(M[3]) - $, 1), L = 1, K = 1;
              z > a && (L = z / a, z = a), V > a && (K = V / a, V = a), this.current.startNewPathAndClipBox([0, 0, z, V]);
              let ne = "groupAt" + this.groupLevel;
              C.smask && (ne += "_smask_" + this.smaskCounter++ % 2);
              const se = this.cachedCanvases.getCanvas(ne, z, V), q = se.context;
              q.scale(1 / L, 1 / K), q.translate(-Z, -$), q.transform(...P), C.smask ? this.smaskStack.push({
                canvas: se.canvas,
                context: q,
                offsetX: Z,
                offsetY: $,
                scaleX: L,
                scaleY: K,
                subtype: C.smask.subtype,
                backdrop: C.smask.backdrop,
                transferMap: C.smask.transferMap || null,
                startTransformInverse: null
              }) : (T.setTransform(1, 0, 0, 1, 0, 0), T.translate(Z, $), T.scale(L, K), T.save()), l(T, q), this.ctx = q, this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]), this.groupStack.push(T), this.groupLevel++;
            }
            endGroup(C) {
              if (!this.contentVisible)
                return;
              this.groupLevel--;
              const T = this.ctx, P = this.groupStack.pop();
              if (this.ctx = P, this.ctx.imageSmoothingEnabled = !1, C.smask)
                this.tempSMask = this.smaskStack.pop(), this.restore();
              else {
                this.ctx.restore();
                const M = (0, ce.getCurrentTransform)(this.ctx);
                this.restore(), this.ctx.save(), this.ctx.setTransform(...M);
                const G = re.Util.getAxialAlignedBoundingBox([0, 0, T.canvas.width, T.canvas.height], M);
                this.ctx.drawImage(T.canvas, 0, 0), this.ctx.restore(), this.compose(G);
              }
            }
            beginAnnotation(C, T, P, M, G) {
              if (At(this, f, mi).call(this), u(this.ctx, this.foregroundColor), this.ctx.save(), this.save(), this.baseTransform && this.ctx.setTransform(...this.baseTransform), Array.isArray(T) && T.length === 4) {
                const Z = T[2] - T[0], $ = T[3] - T[1];
                if (G && this.annotationCanvasMap) {
                  P = P.slice(), P[4] -= T[0], P[5] -= T[1], T = T.slice(), T[0] = T[1] = 0, T[2] = Z, T[3] = $;
                  const [z, V] = re.Util.singularValueDecompose2dScale((0, ce.getCurrentTransform)(this.ctx)), {
                    viewportScale: L
                  } = this, K = Math.ceil(Z * this.outputScaleX * L), ne = Math.ceil($ * this.outputScaleY * L);
                  this.annotationCanvas = this.canvasFactory.create(K, ne);
                  const {
                    canvas: se,
                    context: q
                  } = this.annotationCanvas;
                  this.annotationCanvasMap.set(C, se), this.annotationCanvas.savedCtx = this.ctx, this.ctx = q, this.ctx.setTransform(z, 0, 0, -V, 0, $ * V), u(this.ctx, this.foregroundColor);
                } else
                  u(this.ctx, this.foregroundColor), this.ctx.rect(T[0], T[1], Z, $), this.ctx.clip(), this.endPath();
              }
              this.current = new g(this.ctx.canvas.width, this.ctx.canvas.height), this.transform(...P), this.transform(...M);
            }
            endAnnotation() {
              this.annotationCanvas && (this.ctx = this.annotationCanvas.savedCtx, delete this.annotationCanvas.savedCtx, delete this.annotationCanvas);
            }
            paintImageMaskXObject(C) {
              if (!this.contentVisible)
                return;
              const T = C.count;
              C = this.getObject(C.data, C), C.count = T;
              const P = this.ctx, M = this.processingType3;
              if (M && (M.compiled === void 0 && (M.compiled = p(C)), M.compiled)) {
                M.compiled(P);
                return;
              }
              const G = this._createMaskCanvas(C), Z = G.canvas;
              P.save(), P.setTransform(1, 0, 0, 1, 0, 0), P.drawImage(Z, G.offsetX, G.offsetY), P.restore(), this.compose();
            }
            paintImageMaskXObjectRepeat(C, T, P = 0, M = 0, G, Z) {
              if (!this.contentVisible)
                return;
              C = this.getObject(C.data, C);
              const $ = this.ctx;
              $.save();
              const z = (0, ce.getCurrentTransform)($);
              $.transform(T, P, M, G, 0, 0);
              const V = this._createMaskCanvas(C);
              $.setTransform(1, 0, 0, 1, 0, 0);
              for (let L = 0, K = Z.length; L < K; L += 2) {
                const ne = re.Util.transform(z, [T, P, M, G, Z[L], Z[L + 1]]), [se, q] = re.Util.applyTransform([0, 0], ne);
                $.drawImage(V.canvas, se, q);
              }
              $.restore(), this.compose();
            }
            paintImageMaskXObjectGroup(C) {
              if (!this.contentVisible)
                return;
              const T = this.ctx, P = this.current.fillColor, M = this.current.patternFill;
              for (const G of C) {
                const {
                  data: Z,
                  width: $,
                  height: z,
                  transform: V
                } = G, L = this.cachedCanvases.getCanvas("maskCanvas", $, z), K = L.context;
                K.save();
                const ne = this.getObject(Z, G);
                i(K, ne), K.globalCompositeOperation = "source-in", K.fillStyle = M ? P.getPattern(K, this, (0, ce.getCurrentTransformInverse)(T), ae.PathType.FILL) : P, K.fillRect(0, 0, $, z), K.restore(), T.save(), T.transform(...V), T.scale(1, -1), m(T, L.canvas, 0, 0, $, z, 0, -1, 1, 1), T.restore();
              }
              this.compose();
            }
            paintImageXObject(C) {
              if (!this.contentVisible)
                return;
              const T = this.getObject(C);
              if (!T) {
                (0, re.warn)("Dependent image isn't ready yet");
                return;
              }
              this.paintInlineImageXObject(T);
            }
            paintImageXObjectRepeat(C, T, P, M) {
              if (!this.contentVisible)
                return;
              const G = this.getObject(C);
              if (!G) {
                (0, re.warn)("Dependent image isn't ready yet");
                return;
              }
              const Z = G.width, $ = G.height, z = [];
              for (let V = 0, L = M.length; V < L; V += 2)
                z.push({
                  transform: [T, 0, 0, P, M[V], M[V + 1]],
                  x: 0,
                  y: 0,
                  w: Z,
                  h: $
                });
              this.paintInlineImageXObjectGroup(G, z);
            }
            paintInlineImageXObject(C) {
              if (!this.contentVisible)
                return;
              const T = C.width, P = C.height, M = this.ctx;
              this.save(), M.scale(1 / T, -1 / P);
              let G;
              if (typeof HTMLElement == "function" && C instanceof HTMLElement || !C.data)
                G = C;
              else {
                const V = this.cachedCanvases.getCanvas("inlineImage", T, P), L = V.context;
                n(L, C, this.current.transferMaps), G = V.canvas;
              }
              const Z = this._scaleImage(G, (0, ce.getCurrentTransformInverse)(M));
              M.imageSmoothingEnabled = j((0, ce.getCurrentTransform)(M), C.interpolate);
              const [$, z] = m(M, Z.img, 0, 0, Z.paintWidth, Z.paintHeight, 0, -P, T, P);
              if (this.imageLayer) {
                const [V, L] = re.Util.applyTransform([0, -P], (0, ce.getCurrentTransform)(this.ctx));
                this.imageLayer.appendImage({
                  imgData: C,
                  left: V,
                  top: L,
                  width: $,
                  height: z
                });
              }
              this.compose(), this.restore();
            }
            paintInlineImageXObjectGroup(C, T) {
              if (!this.contentVisible)
                return;
              const P = this.ctx, M = C.width, G = C.height, Z = this.cachedCanvases.getCanvas("inlineImage", M, G), $ = Z.context;
              n($, C, this.current.transferMaps);
              for (const z of T) {
                if (P.save(), P.transform(...z.transform), P.scale(1, -1), m(P, Z.canvas, z.x, z.y, z.w, z.h, 0, -1, 1, 1), this.imageLayer) {
                  const [V, L] = re.Util.applyTransform([z.x, z.y], (0, ce.getCurrentTransform)(this.ctx));
                  this.imageLayer.appendImage({
                    imgData: C,
                    left: V,
                    top: L,
                    width: M,
                    height: G
                  });
                }
                P.restore();
              }
              this.compose();
            }
            paintSolidColorImageMask() {
              this.contentVisible && (this.ctx.fillRect(0, 0, 1, 1), this.compose());
            }
            markPoint(C) {
            }
            markPointProps(C, T) {
            }
            beginMarkedContent(C) {
              this.markedContentStack.push({
                visible: !0
              });
            }
            beginMarkedContentProps(C, T) {
              C === "OC" ? this.markedContentStack.push({
                visible: this.optionalContentConfig.isVisible(T)
              }) : this.markedContentStack.push({
                visible: !0
              }), this.contentVisible = this.isContentVisible();
            }
            endMarkedContent() {
              this.markedContentStack.pop(), this.contentVisible = this.isContentVisible();
            }
            beginCompat() {
            }
            endCompat() {
            }
            consumePath(C) {
              const T = this.current.isEmptyClip();
              this.pendingClip && this.current.updateClipFromPath(), this.pendingClip || this.compose(C);
              const P = this.ctx;
              this.pendingClip && (T || (this.pendingClip === k ? P.clip("evenodd") : P.clip()), this.pendingClip = null), this.current.startNewPathAndClipBox(this.current.clipBox), P.beginPath();
            }
            getSinglePixelWidth() {
              if (!this._cachedGetSinglePixelWidth) {
                const C = (0, ce.getCurrentTransform)(this.ctx);
                if (C[1] === 0 && C[2] === 0)
                  this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(C[0]), Math.abs(C[3]));
                else {
                  const T = Math.abs(C[0] * C[3] - C[2] * C[1]), P = Math.hypot(C[0], C[2]), M = Math.hypot(C[1], C[3]);
                  this._cachedGetSinglePixelWidth = Math.max(P, M) / T;
                }
              }
              return this._cachedGetSinglePixelWidth;
            }
            getScaleForStroking() {
              if (!this._cachedScaleForStroking) {
                const {
                  lineWidth: C
                } = this.current, T = (0, ce.getCurrentTransform)(this.ctx);
                let P, M;
                if (T[1] === 0 && T[2] === 0) {
                  const G = Math.abs(T[0]), Z = Math.abs(T[3]);
                  if (C === 0)
                    P = 1 / G, M = 1 / Z;
                  else {
                    const $ = G * C, z = Z * C;
                    P = $ < 1 ? 1 / $ : 1, M = z < 1 ? 1 / z : 1;
                  }
                } else {
                  const G = Math.abs(T[0] * T[3] - T[2] * T[1]), Z = Math.hypot(T[0], T[1]), $ = Math.hypot(T[2], T[3]);
                  if (C === 0)
                    P = $ / G, M = Z / G;
                  else {
                    const z = C * G;
                    P = $ > z ? $ / z : 1, M = Z > z ? Z / z : 1;
                  }
                }
                this._cachedScaleForStroking = [P, M];
              }
              return this._cachedScaleForStroking;
            }
            rescaleAndStroke(C) {
              const {
                ctx: T
              } = this, {
                lineWidth: P
              } = this.current, [M, G] = this.getScaleForStroking();
              if (T.lineWidth = P || 1, M === 1 && G === 1) {
                T.stroke();
                return;
              }
              let Z, $, z;
              C && (Z = (0, ce.getCurrentTransform)(T), $ = T.getLineDash().slice(), z = T.lineDashOffset), T.scale(M, G);
              const V = Math.max(M, G);
              T.setLineDash(T.getLineDash().map((L) => L / V)), T.lineDashOffset /= V, T.stroke(), C && (T.setTransform(...Z), T.setLineDash($), T.lineDashOffset = z);
            }
            isContentVisible() {
              for (let C = this.markedContentStack.length - 1; C >= 0; C--)
                if (!this.markedContentStack[C].visible)
                  return !1;
              return !0;
            }
          };
          let x = _;
          f = new WeakSet(), mi = function() {
            for (; this.stateStack.length || this.inSMaskMode; )
              this.restore();
            this.ctx.restore(), this.transparentCanvas && (this.ctx = this.compositeCtx, this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.drawImage(this.transparentCanvas, 0, 0), this.ctx.restore(), this.transparentCanvas = null);
          }, ge.CanvasGraphics = x;
          for (const S in re.OPS)
            x.prototype[S] !== void 0 && (x.prototype[re.OPS[S]] = x.prototype[S]);
        },
        /* 13 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.TilingPattern = ge.PathType = void 0, ge.getShadingPattern = y;
          var ce = le(1), re = le(8), ae = le(3);
          const J = {
            FILL: "Fill",
            STROKE: "Stroke",
            SHADING: "Shading"
          };
          ge.PathType = J;
          function o(m, p) {
            if (!p || ae.isNodeJS)
              return;
            const g = p[2] - p[0], n = p[3] - p[1], i = new Path2D();
            i.rect(p[0], p[1], g, n), m.clip(i);
          }
          class F {
            constructor() {
              this.constructor === F && (0, ce.unreachable)("Cannot initialize BaseShadingPattern.");
            }
            getPattern() {
              (0, ce.unreachable)("Abstract method `getPattern` called.");
            }
          }
          class t extends F {
            constructor(p) {
              super(), this._type = p[1], this._bbox = p[2], this._colorStops = p[3], this._p0 = p[4], this._p1 = p[5], this._r0 = p[6], this._r1 = p[7], this.matrix = null;
            }
            _createGradient(p) {
              let g;
              this._type === "axial" ? g = p.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]) : this._type === "radial" && (g = p.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1));
              for (const n of this._colorStops)
                g.addColorStop(n[0], n[1]);
              return g;
            }
            getPattern(p, g, n, i) {
              let l;
              if (i === J.STROKE || i === J.FILL) {
                const u = g.current.getClippedPathBoundingBox(i, (0, re.getCurrentTransform)(p)) || [0, 0, 0, 0], w = Math.ceil(u[2] - u[0]) || 1, O = Math.ceil(u[3] - u[1]) || 1, b = g.cachedCanvases.getCanvas("pattern", w, O, !0), A = b.context;
                A.clearRect(0, 0, A.canvas.width, A.canvas.height), A.beginPath(), A.rect(0, 0, A.canvas.width, A.canvas.height), A.translate(-u[0], -u[1]), n = ce.Util.transform(n, [1, 0, 0, 1, u[0], u[1]]), A.transform(...g.baseTransform), this.matrix && A.transform(...this.matrix), o(A, this._bbox), A.fillStyle = this._createGradient(A), A.fill(), l = p.createPattern(b.canvas, "no-repeat");
                const Y = new DOMMatrix(n);
                try {
                  l.setTransform(Y);
                } catch (j) {
                  (0, ce.warn)(`RadialAxialShadingPattern.getPattern: "${j == null ? void 0 : j.message}".`);
                }
              } else
                o(p, this._bbox), l = this._createGradient(p);
              return l;
            }
          }
          function a(m, p, g, n, i, l, u, w) {
            const O = p.coords, b = p.colors, A = m.data, Y = m.width * 4;
            let j;
            O[g + 1] > O[n + 1] && (j = g, g = n, n = j, j = l, l = u, u = j), O[n + 1] > O[i + 1] && (j = n, n = i, i = j, j = u, u = w, w = j), O[g + 1] > O[n + 1] && (j = g, g = n, n = j, j = l, l = u, u = j);
            const X = (O[g] + p.offsetX) * p.scaleX, B = (O[g + 1] + p.offsetY) * p.scaleY, U = (O[n] + p.offsetX) * p.scaleX, k = (O[n + 1] + p.offsetY) * p.scaleY, x = (O[i] + p.offsetX) * p.scaleX, f = (O[i + 1] + p.offsetY) * p.scaleY;
            if (B >= f)
              return;
            const D = b[l], _ = b[l + 1], S = b[l + 2], C = b[u], T = b[u + 1], P = b[u + 2], M = b[w], G = b[w + 1], Z = b[w + 2], $ = Math.round(B), z = Math.round(f);
            let V, L, K, ne, se, q, N, Q;
            for (let E = $; E <= z; E++) {
              if (E < k) {
                let I;
                E < B ? I = 0 : I = (B - E) / (B - k), V = X - (X - U) * I, L = D - (D - C) * I, K = _ - (_ - T) * I, ne = S - (S - P) * I;
              } else {
                let I;
                E > f ? I = 1 : k === f ? I = 0 : I = (k - E) / (k - f), V = U - (U - x) * I, L = C - (C - M) * I, K = T - (T - G) * I, ne = P - (P - Z) * I;
              }
              let te;
              E < B ? te = 0 : E > f ? te = 1 : te = (B - E) / (B - f), se = X - (X - x) * te, q = D - (D - M) * te, N = _ - (_ - G) * te, Q = S - (S - Z) * te;
              const oe = Math.round(Math.min(V, se)), ee = Math.round(Math.max(V, se));
              let W = Y * E + oe * 4;
              for (let I = oe; I <= ee; I++)
                te = (V - I) / (V - se), te < 0 ? te = 0 : te > 1 && (te = 1), A[W++] = L - (L - q) * te | 0, A[W++] = K - (K - N) * te | 0, A[W++] = ne - (ne - Q) * te | 0, A[W++] = 255;
            }
          }
          function v(m, p, g) {
            const n = p.coords, i = p.colors;
            let l, u;
            switch (p.type) {
              case "lattice":
                const w = p.verticesPerRow, O = Math.floor(n.length / w) - 1, b = w - 1;
                for (l = 0; l < O; l++) {
                  let A = l * w;
                  for (let Y = 0; Y < b; Y++, A++)
                    a(m, g, n[A], n[A + 1], n[A + w], i[A], i[A + 1], i[A + w]), a(m, g, n[A + w + 1], n[A + 1], n[A + w], i[A + w + 1], i[A + 1], i[A + w]);
                }
                break;
              case "triangles":
                for (l = 0, u = n.length; l < u; l += 3)
                  a(m, g, n[l], n[l + 1], n[l + 2], i[l], i[l + 1], i[l + 2]);
                break;
              default:
                throw new Error("illegal figure");
            }
          }
          class h extends F {
            constructor(p) {
              super(), this._coords = p[2], this._colors = p[3], this._figures = p[4], this._bounds = p[5], this._bbox = p[7], this._background = p[8], this.matrix = null;
            }
            _createMeshCanvas(p, g, n) {
              const w = Math.floor(this._bounds[0]), O = Math.floor(this._bounds[1]), b = Math.ceil(this._bounds[2]) - w, A = Math.ceil(this._bounds[3]) - O, Y = Math.min(Math.ceil(Math.abs(b * p[0] * 1.1)), 3e3), j = Math.min(Math.ceil(Math.abs(A * p[1] * 1.1)), 3e3), X = b / Y, B = A / j, U = {
                coords: this._coords,
                colors: this._colors,
                offsetX: -w,
                offsetY: -O,
                scaleX: 1 / X,
                scaleY: 1 / B
              }, k = Y + 2 * 2, x = j + 2 * 2, f = n.getCanvas("mesh", k, x, !1), D = f.context, _ = D.createImageData(Y, j);
              if (g) {
                const C = _.data;
                for (let T = 0, P = C.length; T < P; T += 4)
                  C[T] = g[0], C[T + 1] = g[1], C[T + 2] = g[2], C[T + 3] = 255;
              }
              for (const C of this._figures)
                v(_, C, U);
              return D.putImageData(_, 2, 2), {
                canvas: f.canvas,
                offsetX: w - 2 * X,
                offsetY: O - 2 * B,
                scaleX: X,
                scaleY: B
              };
            }
            getPattern(p, g, n, i) {
              o(p, this._bbox);
              let l;
              if (i === J.SHADING)
                l = ce.Util.singularValueDecompose2dScale((0, re.getCurrentTransform)(p));
              else if (l = ce.Util.singularValueDecompose2dScale(g.baseTransform), this.matrix) {
                const w = ce.Util.singularValueDecompose2dScale(this.matrix);
                l = [l[0] * w[0], l[1] * w[1]];
              }
              const u = this._createMeshCanvas(l, i === J.SHADING ? null : this._background, g.cachedCanvases);
              return i !== J.SHADING && (p.setTransform(...g.baseTransform), this.matrix && p.transform(...this.matrix)), p.translate(u.offsetX, u.offsetY), p.scale(u.scaleX, u.scaleY), p.createPattern(u.canvas, "no-repeat");
            }
          }
          class e extends F {
            getPattern() {
              return "hotpink";
            }
          }
          function y(m) {
            switch (m[0]) {
              case "RadialAxial":
                return new t(m);
              case "Mesh":
                return new h(m);
              case "Dummy":
                return new e();
            }
            throw new Error(`Unknown IR type: ${m[0]}`);
          }
          const c = {
            COLORED: 1,
            UNCOLORED: 2
          };
          class d {
            static get MAX_PATTERN_SIZE() {
              return (0, ce.shadow)(this, "MAX_PATTERN_SIZE", 3e3);
            }
            constructor(p, g, n, i, l) {
              this.operatorList = p[2], this.matrix = p[3] || [1, 0, 0, 1, 0, 0], this.bbox = p[4], this.xstep = p[5], this.ystep = p[6], this.paintType = p[7], this.tilingType = p[8], this.color = g, this.ctx = n, this.canvasGraphicsFactory = i, this.baseTransform = l;
            }
            createPatternCanvas(p) {
              const g = this.operatorList, n = this.bbox, i = this.xstep, l = this.ystep, u = this.paintType, w = this.tilingType, O = this.color, b = this.canvasGraphicsFactory;
              (0, ce.info)("TilingType: " + w);
              const A = n[0], Y = n[1], j = n[2], X = n[3], B = ce.Util.singularValueDecompose2dScale(this.matrix), U = ce.Util.singularValueDecompose2dScale(this.baseTransform), k = [B[0] * U[0], B[1] * U[1]], x = this.getSizeAndScale(i, this.ctx.canvas.width, k[0]), f = this.getSizeAndScale(l, this.ctx.canvas.height, k[1]), D = p.cachedCanvases.getCanvas("pattern", x.size, f.size, !0), _ = D.context, S = b.createCanvasGraphics(_);
              S.groupLevel = p.groupLevel, this.setFillAndStrokeStyleToContext(S, u, O);
              let C = A, T = Y, P = j, M = X;
              return A < 0 && (C = 0, P += Math.abs(A)), Y < 0 && (T = 0, M += Math.abs(Y)), _.translate(-(x.scale * C), -(f.scale * T)), S.transform(x.scale, 0, 0, f.scale, 0, 0), _.save(), this.clipBbox(S, C, T, P, M), S.baseTransform = (0, re.getCurrentTransform)(S.ctx), S.executeOperatorList(g), S.endDrawing(), {
                canvas: D.canvas,
                scaleX: x.scale,
                scaleY: f.scale,
                offsetX: C,
                offsetY: T
              };
            }
            getSizeAndScale(p, g, n) {
              p = Math.abs(p);
              const i = Math.max(d.MAX_PATTERN_SIZE, g);
              let l = Math.ceil(p * n);
              return l >= i ? l = i : n = l / p, {
                scale: n,
                size: l
              };
            }
            clipBbox(p, g, n, i, l) {
              const u = i - g, w = l - n;
              p.ctx.rect(g, n, u, w), p.current.updateRectMinMax((0, re.getCurrentTransform)(p.ctx), [g, n, i, l]), p.clip(), p.endPath();
            }
            setFillAndStrokeStyleToContext(p, g, n) {
              const i = p.ctx, l = p.current;
              switch (g) {
                case c.COLORED:
                  const u = this.ctx;
                  i.fillStyle = u.fillStyle, i.strokeStyle = u.strokeStyle, l.fillColor = u.fillStyle, l.strokeColor = u.strokeStyle;
                  break;
                case c.UNCOLORED:
                  const w = ce.Util.makeHexColor(n[0], n[1], n[2]);
                  i.fillStyle = w, i.strokeStyle = w, l.fillColor = w, l.strokeColor = w;
                  break;
                default:
                  throw new ce.FormatError(`Unsupported paint type: ${g}`);
              }
            }
            getPattern(p, g, n, i) {
              let l = n;
              i !== J.SHADING && (l = ce.Util.transform(l, g.baseTransform), this.matrix && (l = ce.Util.transform(l, this.matrix)));
              const u = this.createPatternCanvas(g);
              let w = new DOMMatrix(l);
              w = w.translate(u.offsetX, u.offsetY), w = w.scale(1 / u.scaleX, 1 / u.scaleY);
              const O = p.createPattern(u.canvas, "repeat");
              try {
                O.setTransform(w);
              } catch (b) {
                (0, ce.warn)(`TilingPattern.getPattern: "${b == null ? void 0 : b.message}".`);
              }
              return O;
            }
          }
          ge.TilingPattern = d;
        },
        /* 14 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.applyMaskImageData = re;
          var ce = le(1);
          function re({
            src: ae,
            srcPos: J = 0,
            dest: o,
            destPos: F = 0,
            width: t,
            height: a,
            inverseDecode: v = !1
          }) {
            const h = ce.FeatureTest.isLittleEndian ? 4278190080 : 255, [e, y] = v ? [0, h] : [h, 0], c = t >> 3, d = t & 7, m = ae.length;
            o = new Uint32Array(o.buffer);
            for (let p = 0; p < a; p++) {
              for (const n = J + c; J < n; J++) {
                const i = J < m ? ae[J] : 255;
                o[F++] = i & 128 ? y : e, o[F++] = i & 64 ? y : e, o[F++] = i & 32 ? y : e, o[F++] = i & 16 ? y : e, o[F++] = i & 8 ? y : e, o[F++] = i & 4 ? y : e, o[F++] = i & 2 ? y : e, o[F++] = i & 1 ? y : e;
              }
              if (d === 0)
                continue;
              const g = J < m ? ae[J++] : 255;
              for (let n = 0; n < d; n++)
                o[F++] = g & 1 << 7 - n ? y : e;
            }
            return {
              srcPos: J,
              destPos: F
            };
          }
        },
        /* 15 */
        /***/
        (be, ge) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.GlobalWorkerOptions = void 0;
          const le = /* @__PURE__ */ Object.create(null);
          ge.GlobalWorkerOptions = le, le.workerPort = le.workerPort === void 0 ? null : le.workerPort, le.workerSrc = le.workerSrc === void 0 ? "" : le.workerSrc;
        },
        /* 16 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.MessageHandler = void 0;
          var ce = le(1);
          const re = {
            UNKNOWN: 0,
            DATA: 1,
            ERROR: 2
          }, ae = {
            UNKNOWN: 0,
            CANCEL: 1,
            CANCEL_COMPLETE: 2,
            CLOSE: 3,
            ENQUEUE: 4,
            ERROR: 5,
            PULL: 6,
            PULL_COMPLETE: 7,
            START_COMPLETE: 8
          };
          function J(F) {
            switch (F instanceof Error || typeof F == "object" && F !== null || (0, ce.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), F.name) {
              case "AbortException":
                return new ce.AbortException(F.message);
              case "MissingPDFException":
                return new ce.MissingPDFException(F.message);
              case "PasswordException":
                return new ce.PasswordException(F.message, F.code);
              case "UnexpectedResponseException":
                return new ce.UnexpectedResponseException(F.message, F.status);
              case "UnknownErrorException":
                return new ce.UnknownErrorException(F.message, F.details);
              default:
                return new ce.UnknownErrorException(F.message, F.toString());
            }
          }
          class o {
            constructor(t, a, v) {
              this.sourceName = t, this.targetName = a, this.comObj = v, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), this._onComObjOnMessage = (h) => {
                const e = h.data;
                if (e.targetName !== this.sourceName)
                  return;
                if (e.stream) {
                  this._processStreamMessage(e);
                  return;
                }
                if (e.callback) {
                  const c = e.callbackId, d = this.callbackCapabilities[c];
                  if (!d)
                    throw new Error(`Cannot resolve callback ${c}`);
                  if (delete this.callbackCapabilities[c], e.callback === re.DATA)
                    d.resolve(e.data);
                  else if (e.callback === re.ERROR)
                    d.reject(J(e.reason));
                  else
                    throw new Error("Unexpected callback case");
                  return;
                }
                const y = this.actionHandler[e.action];
                if (!y)
                  throw new Error(`Unknown action from worker: ${e.action}`);
                if (e.callbackId) {
                  const c = this.sourceName, d = e.sourceName;
                  new Promise(function(m) {
                    m(y(e.data));
                  }).then(function(m) {
                    v.postMessage({
                      sourceName: c,
                      targetName: d,
                      callback: re.DATA,
                      callbackId: e.callbackId,
                      data: m
                    });
                  }, function(m) {
                    v.postMessage({
                      sourceName: c,
                      targetName: d,
                      callback: re.ERROR,
                      callbackId: e.callbackId,
                      reason: J(m)
                    });
                  });
                  return;
                }
                if (e.streamId) {
                  this._createStreamSink(e);
                  return;
                }
                y(e.data);
              }, v.addEventListener("message", this._onComObjOnMessage);
            }
            on(t, a) {
              const v = this.actionHandler;
              if (v[t])
                throw new Error(`There is already an actionName called "${t}"`);
              v[t] = a;
            }
            send(t, a, v) {
              this.comObj.postMessage({
                sourceName: this.sourceName,
                targetName: this.targetName,
                action: t,
                data: a
              }, v);
            }
            sendWithPromise(t, a, v) {
              const h = this.callbackId++, e = (0, ce.createPromiseCapability)();
              this.callbackCapabilities[h] = e;
              try {
                this.comObj.postMessage({
                  sourceName: this.sourceName,
                  targetName: this.targetName,
                  action: t,
                  callbackId: h,
                  data: a
                }, v);
              } catch (y) {
                e.reject(y);
              }
              return e.promise;
            }
            sendWithStream(t, a, v, h) {
              const e = this.streamId++, y = this.sourceName, c = this.targetName, d = this.comObj;
              return new ReadableStream({
                start: (m) => {
                  const p = (0, ce.createPromiseCapability)();
                  return this.streamControllers[e] = {
                    controller: m,
                    startCall: p,
                    pullCall: null,
                    cancelCall: null,
                    isClosed: !1
                  }, d.postMessage({
                    sourceName: y,
                    targetName: c,
                    action: t,
                    streamId: e,
                    data: a,
                    desiredSize: m.desiredSize
                  }, h), p.promise;
                },
                pull: (m) => {
                  const p = (0, ce.createPromiseCapability)();
                  return this.streamControllers[e].pullCall = p, d.postMessage({
                    sourceName: y,
                    targetName: c,
                    stream: ae.PULL,
                    streamId: e,
                    desiredSize: m.desiredSize
                  }), p.promise;
                },
                cancel: (m) => {
                  (0, ce.assert)(m instanceof Error, "cancel must have a valid reason");
                  const p = (0, ce.createPromiseCapability)();
                  return this.streamControllers[e].cancelCall = p, this.streamControllers[e].isClosed = !0, d.postMessage({
                    sourceName: y,
                    targetName: c,
                    stream: ae.CANCEL,
                    streamId: e,
                    reason: J(m)
                  }), p.promise;
                }
              }, v);
            }
            _createStreamSink(t) {
              const a = t.streamId, v = this.sourceName, h = t.sourceName, e = this.comObj, y = this, c = this.actionHandler[t.action], d = {
                enqueue(m, p = 1, g) {
                  if (this.isCancelled)
                    return;
                  const n = this.desiredSize;
                  this.desiredSize -= p, n > 0 && this.desiredSize <= 0 && (this.sinkCapability = (0, ce.createPromiseCapability)(), this.ready = this.sinkCapability.promise), e.postMessage({
                    sourceName: v,
                    targetName: h,
                    stream: ae.ENQUEUE,
                    streamId: a,
                    chunk: m
                  }, g);
                },
                close() {
                  this.isCancelled || (this.isCancelled = !0, e.postMessage({
                    sourceName: v,
                    targetName: h,
                    stream: ae.CLOSE,
                    streamId: a
                  }), delete y.streamSinks[a]);
                },
                error(m) {
                  (0, ce.assert)(m instanceof Error, "error must have a valid reason"), !this.isCancelled && (this.isCancelled = !0, e.postMessage({
                    sourceName: v,
                    targetName: h,
                    stream: ae.ERROR,
                    streamId: a,
                    reason: J(m)
                  }));
                },
                sinkCapability: (0, ce.createPromiseCapability)(),
                onPull: null,
                onCancel: null,
                isCancelled: !1,
                desiredSize: t.desiredSize,
                ready: null
              };
              d.sinkCapability.resolve(), d.ready = d.sinkCapability.promise, this.streamSinks[a] = d, new Promise(function(m) {
                m(c(t.data, d));
              }).then(function() {
                e.postMessage({
                  sourceName: v,
                  targetName: h,
                  stream: ae.START_COMPLETE,
                  streamId: a,
                  success: !0
                });
              }, function(m) {
                e.postMessage({
                  sourceName: v,
                  targetName: h,
                  stream: ae.START_COMPLETE,
                  streamId: a,
                  reason: J(m)
                });
              });
            }
            _processStreamMessage(t) {
              const a = t.streamId, v = this.sourceName, h = t.sourceName, e = this.comObj, y = this.streamControllers[a], c = this.streamSinks[a];
              switch (t.stream) {
                case ae.START_COMPLETE:
                  t.success ? y.startCall.resolve() : y.startCall.reject(J(t.reason));
                  break;
                case ae.PULL_COMPLETE:
                  t.success ? y.pullCall.resolve() : y.pullCall.reject(J(t.reason));
                  break;
                case ae.PULL:
                  if (!c) {
                    e.postMessage({
                      sourceName: v,
                      targetName: h,
                      stream: ae.PULL_COMPLETE,
                      streamId: a,
                      success: !0
                    });
                    break;
                  }
                  c.desiredSize <= 0 && t.desiredSize > 0 && c.sinkCapability.resolve(), c.desiredSize = t.desiredSize, new Promise(function(d) {
                    d(c.onPull && c.onPull());
                  }).then(function() {
                    e.postMessage({
                      sourceName: v,
                      targetName: h,
                      stream: ae.PULL_COMPLETE,
                      streamId: a,
                      success: !0
                    });
                  }, function(d) {
                    e.postMessage({
                      sourceName: v,
                      targetName: h,
                      stream: ae.PULL_COMPLETE,
                      streamId: a,
                      reason: J(d)
                    });
                  });
                  break;
                case ae.ENQUEUE:
                  if ((0, ce.assert)(y, "enqueue should have stream controller"), y.isClosed)
                    break;
                  y.controller.enqueue(t.chunk);
                  break;
                case ae.CLOSE:
                  if ((0, ce.assert)(y, "close should have stream controller"), y.isClosed)
                    break;
                  y.isClosed = !0, y.controller.close(), this._deleteStreamController(y, a);
                  break;
                case ae.ERROR:
                  (0, ce.assert)(y, "error should have stream controller"), y.controller.error(J(t.reason)), this._deleteStreamController(y, a);
                  break;
                case ae.CANCEL_COMPLETE:
                  t.success ? y.cancelCall.resolve() : y.cancelCall.reject(J(t.reason)), this._deleteStreamController(y, a);
                  break;
                case ae.CANCEL:
                  if (!c)
                    break;
                  new Promise(function(d) {
                    d(c.onCancel && c.onCancel(J(t.reason)));
                  }).then(function() {
                    e.postMessage({
                      sourceName: v,
                      targetName: h,
                      stream: ae.CANCEL_COMPLETE,
                      streamId: a,
                      success: !0
                    });
                  }, function(d) {
                    e.postMessage({
                      sourceName: v,
                      targetName: h,
                      stream: ae.CANCEL_COMPLETE,
                      streamId: a,
                      reason: J(d)
                    });
                  }), c.sinkCapability.reject(J(t.reason)), c.isCancelled = !0, delete this.streamSinks[a];
                  break;
                default:
                  throw new Error("Unexpected stream case");
              }
            }
            async _deleteStreamController(t, a) {
              await Promise.allSettled([t.startCall && t.startCall.promise, t.pullCall && t.pullCall.promise, t.cancelCall && t.cancelCall.promise]), delete this.streamControllers[a];
            }
            destroy() {
              this.comObj.removeEventListener("message", this._onComObjOnMessage);
            }
          }
          ge.MessageHandler = o;
        },
        /* 17 */
        /***/
        (be, ge, le) => {
          var ae, J;
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.Metadata = void 0;
          var ce = le(1);
          class re {
            constructor({
              parsedData: F,
              rawData: t
            }) {
              gt(this, ae, void 0);
              gt(this, J, void 0);
              Ft(this, ae, F), Ft(this, J, t);
            }
            getRaw() {
              return Oe(this, J);
            }
            get(F) {
              return Oe(this, ae).get(F) ?? null;
            }
            getAll() {
              return (0, ce.objectFromMap)(Oe(this, ae));
            }
            has(F) {
              return Oe(this, ae).has(F);
            }
          }
          ae = new WeakMap(), J = new WeakMap(), ge.Metadata = re;
        },
        /* 18 */
        /***/
        (be, ge, le) => {
          var o, F, t, a, v, h, xi;
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.OptionalContentConfig = void 0;
          var ce = le(1);
          const re = Symbol("INTERNAL");
          class ae {
            constructor(c, d) {
              gt(this, o, !0);
              this.name = c, this.intent = d;
            }
            get visible() {
              return Oe(this, o);
            }
            _setVisible(c, d) {
              c !== re && (0, ce.unreachable)("Internal method `_setVisible` called."), Ft(this, o, d);
            }
          }
          o = new WeakMap();
          class J {
            constructor(c) {
              gt(this, h);
              gt(this, F, !0);
              gt(this, t, /* @__PURE__ */ new Map());
              gt(this, a, null);
              gt(this, v, null);
              if (this.name = null, this.creator = null, c !== null) {
                this.name = c.name, this.creator = c.creator, Ft(this, v, c.order);
                for (const d of c.groups)
                  Oe(this, t).set(d.id, new ae(d.name, d.intent));
                if (c.baseState === "OFF")
                  for (const d of Oe(this, t).values())
                    d._setVisible(re, !1);
                for (const d of c.on)
                  Oe(this, t).get(d)._setVisible(re, !0);
                for (const d of c.off)
                  Oe(this, t).get(d)._setVisible(re, !1);
                Ft(this, a, /* @__PURE__ */ new Map());
                for (const [d, m] of Oe(this, t))
                  Oe(this, a).set(d, m.visible);
              }
            }
            isVisible(c) {
              if (Oe(this, t).size === 0)
                return !0;
              if (!c)
                return (0, ce.warn)("Optional content group not defined."), !0;
              if (c.type === "OCG")
                return Oe(this, t).has(c.id) ? Oe(this, t).get(c.id).visible : ((0, ce.warn)(`Optional content group not found: ${c.id}`), !0);
              if (c.type === "OCMD") {
                if (c.expression)
                  return At(this, h, xi).call(this, c.expression);
                if (!c.policy || c.policy === "AnyOn") {
                  for (const d of c.ids) {
                    if (!Oe(this, t).has(d))
                      return (0, ce.warn)(`Optional content group not found: ${d}`), !0;
                    if (Oe(this, t).get(d).visible)
                      return !0;
                  }
                  return !1;
                } else if (c.policy === "AllOn") {
                  for (const d of c.ids) {
                    if (!Oe(this, t).has(d))
                      return (0, ce.warn)(`Optional content group not found: ${d}`), !0;
                    if (!Oe(this, t).get(d).visible)
                      return !1;
                  }
                  return !0;
                } else if (c.policy === "AnyOff") {
                  for (const d of c.ids) {
                    if (!Oe(this, t).has(d))
                      return (0, ce.warn)(`Optional content group not found: ${d}`), !0;
                    if (!Oe(this, t).get(d).visible)
                      return !0;
                  }
                  return !1;
                } else if (c.policy === "AllOff") {
                  for (const d of c.ids) {
                    if (!Oe(this, t).has(d))
                      return (0, ce.warn)(`Optional content group not found: ${d}`), !0;
                    if (Oe(this, t).get(d).visible)
                      return !1;
                  }
                  return !0;
                }
                return (0, ce.warn)(`Unknown optional content policy ${c.policy}.`), !0;
              }
              return (0, ce.warn)(`Unknown group type ${c.type}.`), !0;
            }
            setVisibility(c, d = !0) {
              if (!Oe(this, t).has(c)) {
                (0, ce.warn)(`Optional content group not found: ${c}`);
                return;
              }
              Oe(this, t).get(c)._setVisible(re, !!d), Ft(this, F, null);
            }
            get hasInitialVisibility() {
              if (Oe(this, F) !== null)
                return Oe(this, F);
              for (const [c, d] of Oe(this, t)) {
                const m = Oe(this, a).get(c);
                if (d.visible !== m)
                  return Ft(this, F, !1);
              }
              return Ft(this, F, !0);
            }
            getOrder() {
              return Oe(this, t).size ? Oe(this, v) ? Oe(this, v).slice() : [...Oe(this, t).keys()] : null;
            }
            getGroups() {
              return Oe(this, t).size > 0 ? (0, ce.objectFromMap)(Oe(this, t)) : null;
            }
            getGroup(c) {
              return Oe(this, t).get(c) || null;
            }
          }
          F = new WeakMap(), t = new WeakMap(), a = new WeakMap(), v = new WeakMap(), h = new WeakSet(), xi = function(c) {
            const d = c.length;
            if (d < 2)
              return !0;
            const m = c[0];
            for (let p = 1; p < d; p++) {
              const g = c[p];
              let n;
              if (Array.isArray(g))
                n = At(this, h, xi).call(this, g);
              else if (Oe(this, t).has(g))
                n = Oe(this, t).get(g).visible;
              else
                return (0, ce.warn)(`Optional content group not found: ${g}`), !0;
              switch (m) {
                case "And":
                  if (!n)
                    return !1;
                  break;
                case "Or":
                  if (n)
                    return !0;
                  break;
                case "Not":
                  return !n;
                default:
                  return !0;
              }
            }
            return m === "And";
          }, ge.OptionalContentConfig = J;
        },
        /* 19 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.PDFDataTransportStream = void 0;
          var ce = le(1), re = le(8);
          class ae {
            constructor(t, a) {
              (0, ce.assert)(a, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.'), this._queuedChunks = [], this._progressiveDone = t.progressiveDone || !1, this._contentDispositionFilename = t.contentDispositionFilename || null;
              const v = t.initialData;
              if ((v == null ? void 0 : v.length) > 0) {
                const h = new Uint8Array(v).buffer;
                this._queuedChunks.push(h);
              }
              this._pdfDataRangeTransport = a, this._isStreamingSupported = !t.disableStream, this._isRangeSupported = !t.disableRange, this._contentLength = t.length, this._fullRequestReader = null, this._rangeReaders = [], this._pdfDataRangeTransport.addRangeListener((h, e) => {
                this._onReceiveData({
                  begin: h,
                  chunk: e
                });
              }), this._pdfDataRangeTransport.addProgressListener((h, e) => {
                this._onProgress({
                  loaded: h,
                  total: e
                });
              }), this._pdfDataRangeTransport.addProgressiveReadListener((h) => {
                this._onReceiveData({
                  chunk: h
                });
              }), this._pdfDataRangeTransport.addProgressiveDoneListener(() => {
                this._onProgressiveDone();
              }), this._pdfDataRangeTransport.transportReady();
            }
            _onReceiveData(t) {
              const a = new Uint8Array(t.chunk).buffer;
              if (t.begin === void 0)
                this._fullRequestReader ? this._fullRequestReader._enqueue(a) : this._queuedChunks.push(a);
              else {
                const v = this._rangeReaders.some(function(h) {
                  return h._begin !== t.begin ? !1 : (h._enqueue(a), !0);
                });
                (0, ce.assert)(v, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
              }
            }
            get _progressiveDataLength() {
              var t;
              return ((t = this._fullRequestReader) == null ? void 0 : t._loaded) ?? 0;
            }
            _onProgress(t) {
              if (t.total === void 0) {
                const a = this._rangeReaders[0];
                a != null && a.onProgress && a.onProgress({
                  loaded: t.loaded
                });
              } else {
                const a = this._fullRequestReader;
                a != null && a.onProgress && a.onProgress({
                  loaded: t.loaded,
                  total: t.total
                });
              }
            }
            _onProgressiveDone() {
              this._fullRequestReader && this._fullRequestReader.progressiveDone(), this._progressiveDone = !0;
            }
            _removeRangeReader(t) {
              const a = this._rangeReaders.indexOf(t);
              a >= 0 && this._rangeReaders.splice(a, 1);
            }
            getFullReader() {
              (0, ce.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
              const t = this._queuedChunks;
              return this._queuedChunks = null, new J(this, t, this._progressiveDone, this._contentDispositionFilename);
            }
            getRangeReader(t, a) {
              if (a <= this._progressiveDataLength)
                return null;
              const v = new o(this, t, a);
              return this._pdfDataRangeTransport.requestDataRange(t, a), this._rangeReaders.push(v), v;
            }
            cancelAllRequests(t) {
              this._fullRequestReader && this._fullRequestReader.cancel(t);
              for (const a of this._rangeReaders.slice(0))
                a.cancel(t);
              this._pdfDataRangeTransport.abort();
            }
          }
          ge.PDFDataTransportStream = ae;
          class J {
            constructor(t, a, v = !1, h = null) {
              this._stream = t, this._done = v || !1, this._filename = (0, re.isPdfFile)(h) ? h : null, this._queuedChunks = a || [], this._loaded = 0;
              for (const e of this._queuedChunks)
                this._loaded += e.byteLength;
              this._requests = [], this._headersReady = Promise.resolve(), t._fullRequestReader = this, this.onProgress = null;
            }
            _enqueue(t) {
              this._done || (this._requests.length > 0 ? this._requests.shift().resolve({
                value: t,
                done: !1
              }) : this._queuedChunks.push(t), this._loaded += t.byteLength);
            }
            get headersReady() {
              return this._headersReady;
            }
            get filename() {
              return this._filename;
            }
            get isRangeSupported() {
              return this._stream._isRangeSupported;
            }
            get isStreamingSupported() {
              return this._stream._isStreamingSupported;
            }
            get contentLength() {
              return this._stream._contentLength;
            }
            async read() {
              if (this._queuedChunks.length > 0)
                return {
                  value: this._queuedChunks.shift(),
                  done: !1
                };
              if (this._done)
                return {
                  value: void 0,
                  done: !0
                };
              const t = (0, ce.createPromiseCapability)();
              return this._requests.push(t), t.promise;
            }
            cancel(t) {
              this._done = !0;
              for (const a of this._requests)
                a.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0;
            }
            progressiveDone() {
              this._done || (this._done = !0);
            }
          }
          class o {
            constructor(t, a, v) {
              this._stream = t, this._begin = a, this._end = v, this._queuedChunk = null, this._requests = [], this._done = !1, this.onProgress = null;
            }
            _enqueue(t) {
              if (!this._done) {
                if (this._requests.length === 0)
                  this._queuedChunk = t;
                else {
                  this._requests.shift().resolve({
                    value: t,
                    done: !1
                  });
                  for (const v of this._requests)
                    v.resolve({
                      value: void 0,
                      done: !0
                    });
                  this._requests.length = 0;
                }
                this._done = !0, this._stream._removeRangeReader(this);
              }
            }
            get isStreamingSupported() {
              return !1;
            }
            async read() {
              if (this._queuedChunk) {
                const a = this._queuedChunk;
                return this._queuedChunk = null, {
                  value: a,
                  done: !1
                };
              }
              if (this._done)
                return {
                  value: void 0,
                  done: !0
                };
              const t = (0, ce.createPromiseCapability)();
              return this._requests.push(t), t.promise;
            }
            cancel(t) {
              this._done = !0;
              for (const a of this._requests)
                a.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0, this._stream._removeRangeReader(this);
            }
          }
        },
        /* 20 */
        /***/
        (be, ge) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.XfaText = void 0;
          class le {
            static textContent(re) {
              const ae = [], J = {
                items: ae,
                styles: /* @__PURE__ */ Object.create(null)
              };
              function o(F) {
                var v;
                if (!F)
                  return;
                let t = null;
                const a = F.name;
                if (a === "#text")
                  t = F.value;
                else if (le.shouldBuildText(a))
                  (v = F == null ? void 0 : F.attributes) != null && v.textContent ? t = F.attributes.textContent : F.value && (t = F.value);
                else
                  return;
                if (t !== null && ae.push({
                  str: t
                }), !!F.children)
                  for (const h of F.children)
                    o(h);
              }
              return o(re), J;
            }
            static shouldBuildText(re) {
              return !(re === "textarea" || re === "input" || re === "option" || re === "select");
            }
          }
          ge.XfaText = le;
        },
        /* 21 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.NodeStandardFontDataFactory = ge.NodeCanvasFactory = ge.NodeCMapReaderFactory = void 0;
          var ce = le(9);
          const re = function(F) {
            return new Promise((t, a) => {
              require$$5.readFile(F, (h, e) => {
                if (h || !e) {
                  a(new Error(h));
                  return;
                }
                t(new Uint8Array(e));
              });
            });
          };
          class ae extends ce.BaseCanvasFactory {
            _createCanvas(t, a) {
              return require$$5.createCanvas(t, a);
            }
          }
          ge.NodeCanvasFactory = ae;
          class J extends ce.BaseCMapReaderFactory {
            _fetchData(t, a) {
              return re(t).then((v) => ({
                cMapData: v,
                compressionType: a
              }));
            }
          }
          ge.NodeCMapReaderFactory = J;
          class o extends ce.BaseStandardFontDataFactory {
            _fetchData(t) {
              return re(t);
            }
          }
          ge.NodeStandardFontDataFactory = o;
        },
        /* 22 */
        /***/
        (be, ge, le) => {
          var F, t, a, v, h, e, y, c, d, bi, p, ji, n, yi, l, $i;
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.AnnotationEditorLayer = void 0;
          var ce = le(7), re = le(1), ae = le(23), J = le(24);
          const w = class {
            constructor(b) {
              gt(this, d);
              gt(this, p);
              gt(this, n);
              gt(this, l);
              gt(this, F, void 0);
              gt(this, t, !1);
              gt(this, a, this.pointerup.bind(this));
              gt(this, v, this.pointerdown.bind(this));
              gt(this, h, /* @__PURE__ */ new Map());
              gt(this, e, !1);
              gt(this, y, !1);
              gt(this, c, void 0);
              w._initialized || (w._initialized = !0, ae.FreeTextEditor.initialize(b.l10n), J.InkEditor.initialize(b.l10n), b.uiManager.registerEditorTypes([ae.FreeTextEditor, J.InkEditor])), Ft(this, c, b.uiManager), this.annotationStorage = b.annotationStorage, this.pageIndex = b.pageIndex, this.div = b.div, Ft(this, F, b.accessibilityManager), Oe(this, c).addLayer(this);
            }
            updateToolbar(b) {
              Oe(this, c).updateToolbar(b);
            }
            updateMode(b = Oe(this, c).getMode()) {
              At(this, l, $i).call(this), b === re.AnnotationEditorType.INK ? (this.addInkEditorIfNeeded(!1), this.disableClick()) : this.enableClick(), Oe(this, c).unselectAll();
            }
            addInkEditorIfNeeded(b) {
              if (!b && Oe(this, c).getMode() !== re.AnnotationEditorType.INK)
                return;
              if (!b) {
                for (const Y of Oe(this, h).values())
                  if (Y.isEmpty()) {
                    Y.setInBackground();
                    return;
                  }
              }
              At(this, n, yi).call(this, {
                offsetX: 0,
                offsetY: 0
              }).setInBackground();
            }
            setEditingState(b) {
              Oe(this, c).setEditingState(b);
            }
            addCommands(b) {
              Oe(this, c).addCommands(b);
            }
            enable() {
              this.div.style.pointerEvents = "auto";
              for (const b of Oe(this, h).values())
                b.enableEditing();
            }
            disable() {
              this.div.style.pointerEvents = "none";
              for (const b of Oe(this, h).values())
                b.disableEditing();
            }
            setActiveEditor(b) {
              Oe(this, c).getActive() !== b && Oe(this, c).setActiveEditor(b);
            }
            enableClick() {
              this.div.addEventListener("pointerdown", Oe(this, v)), this.div.addEventListener("pointerup", Oe(this, a));
            }
            disableClick() {
              this.div.removeEventListener("pointerdown", Oe(this, v)), this.div.removeEventListener("pointerup", Oe(this, a));
            }
            attach(b) {
              Oe(this, h).set(b.id, b);
            }
            detach(b) {
              var A;
              Oe(this, h).delete(b.id), (A = Oe(this, F)) == null || A.removePointerInTextLayer(b.contentDiv);
            }
            remove(b) {
              Oe(this, c).removeEditor(b), this.detach(b), this.annotationStorage.remove(b.id), b.div.style.display = "none", setTimeout(() => {
                b.div.style.display = "", b.div.remove(), b.isAttachedToDOM = !1, document.activeElement === document.body && Oe(this, c).focusMainContainer();
              }, 0), Oe(this, y) || this.addInkEditorIfNeeded(!1);
            }
            add(b) {
              if (At(this, d, bi).call(this, b), Oe(this, c).addEditor(b), this.attach(b), !b.isAttachedToDOM) {
                const A = b.render();
                this.div.append(A), b.isAttachedToDOM = !0;
              }
              this.moveEditorInDOM(b), b.onceAdded(), this.addToAnnotationStorage(b);
            }
            moveEditorInDOM(b) {
              var A;
              (A = Oe(this, F)) == null || A.moveElementInDOM(this.div, b.div, b.contentDiv, !0);
            }
            addToAnnotationStorage(b) {
              !b.isEmpty() && !this.annotationStorage.has(b.id) && this.annotationStorage.setValue(b.id, b);
            }
            addOrRebuild(b) {
              b.needsToBeRebuilt() ? b.rebuild() : this.add(b);
            }
            addANewEditor(b) {
              const A = () => {
                this.addOrRebuild(b);
              }, Y = () => {
                b.remove();
              };
              this.addCommands({
                cmd: A,
                undo: Y,
                mustExec: !0
              });
            }
            addUndoableEditor(b) {
              const A = () => {
                this.addOrRebuild(b);
              }, Y = () => {
                b.remove();
              };
              this.addCommands({
                cmd: A,
                undo: Y,
                mustExec: !1
              });
            }
            getNextId() {
              return Oe(this, c).getId();
            }
            deserialize(b) {
              switch (b.annotationType) {
                case re.AnnotationEditorType.FREETEXT:
                  return ae.FreeTextEditor.deserialize(b, this);
                case re.AnnotationEditorType.INK:
                  return J.InkEditor.deserialize(b, this);
              }
              return null;
            }
            setSelected(b) {
              Oe(this, c).setSelected(b);
            }
            toggleSelected(b) {
              Oe(this, c).toggleSelected(b);
            }
            isSelected(b) {
              return Oe(this, c).isSelected(b);
            }
            unselect(b) {
              Oe(this, c).unselect(b);
            }
            pointerup(b) {
              const A = ce.KeyboardManager.platform.isMac;
              if (!(b.button !== 0 || b.ctrlKey && A) && b.target === this.div && Oe(this, e)) {
                if (Ft(this, e, !1), !Oe(this, t)) {
                  Ft(this, t, !0);
                  return;
                }
                At(this, n, yi).call(this, b);
              }
            }
            pointerdown(b) {
              const A = ce.KeyboardManager.platform.isMac;
              if (b.button !== 0 || b.ctrlKey && A || b.target !== this.div)
                return;
              Ft(this, e, !0);
              const Y = Oe(this, c).getActive();
              Ft(this, t, !Y || Y.isEmpty());
            }
            drop(b) {
              const A = b.dataTransfer.getData("text/plain"), Y = Oe(this, c).getEditor(A);
              if (!Y)
                return;
              b.preventDefault(), b.dataTransfer.dropEffect = "move", At(this, d, bi).call(this, Y);
              const j = this.div.getBoundingClientRect(), X = b.clientX - j.x, B = b.clientY - j.y;
              Y.translate(X - Y.startX, B - Y.startY), this.moveEditorInDOM(Y), Y.div.focus();
            }
            dragover(b) {
              b.preventDefault();
            }
            destroy() {
              var b, A;
              ((b = Oe(this, c).getActive()) == null ? void 0 : b.parent) === this && Oe(this, c).setActiveEditor(null);
              for (const Y of Oe(this, h).values())
                (A = Oe(this, F)) == null || A.removePointerInTextLayer(Y.contentDiv), Y.isAttachedToDOM = !1, Y.div.remove(), Y.parent = null;
              this.div = null, Oe(this, h).clear(), Oe(this, c).removeLayer(this);
            }
            render(b) {
              this.viewport = b.viewport, (0, ce.bindEvents)(this, this.div, ["dragover", "drop"]), this.setDimensions();
              for (const A of Oe(this, c).getEditors(this.pageIndex))
                this.add(A);
              this.updateMode();
            }
            update(b) {
              this.viewport = b.viewport, this.setDimensions(), this.updateMode();
            }
            get scaleFactor() {
              return this.viewport.scale;
            }
            get pageDimensions() {
              const [b, A, Y, j] = this.viewport.viewBox, X = Y - b, B = j - A;
              return [X, B];
            }
            get viewportBaseDimensions() {
              const {
                width: b,
                height: A,
                rotation: Y
              } = this.viewport;
              return Y % 180 === 0 ? [b, A] : [A, b];
            }
            setDimensions() {
              const {
                width: b,
                height: A,
                rotation: Y
              } = this.viewport, j = Y % 180 !== 0, X = Math.floor(b) + "px", B = Math.floor(A) + "px";
              this.div.style.width = j ? B : X, this.div.style.height = j ? X : B, this.div.setAttribute("data-main-rotation", Y);
            }
          };
          let o = w;
          F = new WeakMap(), t = new WeakMap(), a = new WeakMap(), v = new WeakMap(), h = new WeakMap(), e = new WeakMap(), y = new WeakMap(), c = new WeakMap(), d = new WeakSet(), bi = function(b) {
            var A;
            b.parent !== this && (this.attach(b), b.pageIndex = this.pageIndex, (A = b.parent) == null || A.detach(b), b.parent = this, b.div && b.isAttachedToDOM && (b.div.remove(), this.div.append(b.div)));
          }, p = new WeakSet(), ji = function(b) {
            switch (Oe(this, c).getMode()) {
              case re.AnnotationEditorType.FREETEXT:
                return new ae.FreeTextEditor(b);
              case re.AnnotationEditorType.INK:
                return new J.InkEditor(b);
            }
            return null;
          }, n = new WeakSet(), yi = function(b) {
            const A = this.getNextId(), Y = At(this, p, ji).call(this, {
              parent: this,
              id: A,
              x: b.offsetX,
              y: b.offsetY
            });
            return Y && this.add(Y), Y;
          }, l = new WeakSet(), $i = function() {
            Ft(this, y, !0);
            for (const b of Oe(this, h).values())
              b.isEmpty() && b.remove();
            Ft(this, y, !1);
          }, on(o, "_initialized", !1), ge.AnnotationEditorLayer = o;
        },
        /* 23 */
        /***/
        (be, ge, le) => {
          var o, F, t, a, v, h, e, y, Wi, d, Xi, p, Hi, n, vi;
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.FreeTextEditor = void 0;
          var ce = le(1), re = le(7), ae = le(6);
          const l = class extends ae.AnnotationEditor {
            constructor(O) {
              super({
                ...O,
                name: "freeTextEditor"
              });
              gt(this, y);
              gt(this, d);
              gt(this, p);
              gt(this, n);
              gt(this, o, this.editorDivBlur.bind(this));
              gt(this, F, this.editorDivFocus.bind(this));
              gt(this, t, this.editorDivKeydown.bind(this));
              gt(this, a, void 0);
              gt(this, v, "");
              gt(this, h, !1);
              gt(this, e, void 0);
              Ft(this, a, O.color || l._defaultColor || ae.AnnotationEditor._defaultLineColor), Ft(this, e, O.fontSize || l._defaultFontSize);
            }
            static initialize(O) {
              this._l10nPromise = new Map(["free_text_default_content", "editor_free_text_aria_label"].map((A) => [A, O.get(A)]));
              const b = getComputedStyle(document.documentElement);
              this._internalPadding = parseFloat(b.getPropertyValue("--freetext-padding"));
            }
            static updateDefaultParams(O, b) {
              switch (O) {
                case ce.AnnotationEditorParamsType.FREETEXT_SIZE:
                  l._defaultFontSize = b;
                  break;
                case ce.AnnotationEditorParamsType.FREETEXT_COLOR:
                  l._defaultColor = b;
                  break;
              }
            }
            updateParams(O, b) {
              switch (O) {
                case ce.AnnotationEditorParamsType.FREETEXT_SIZE:
                  At(this, y, Wi).call(this, b);
                  break;
                case ce.AnnotationEditorParamsType.FREETEXT_COLOR:
                  At(this, d, Xi).call(this, b);
                  break;
              }
            }
            static get defaultPropertiesToUpdate() {
              return [[ce.AnnotationEditorParamsType.FREETEXT_SIZE, l._defaultFontSize], [ce.AnnotationEditorParamsType.FREETEXT_COLOR, l._defaultColor || ae.AnnotationEditor._defaultLineColor]];
            }
            get propertiesToUpdate() {
              return [[ce.AnnotationEditorParamsType.FREETEXT_SIZE, Oe(this, e)], [ce.AnnotationEditorParamsType.FREETEXT_COLOR, Oe(this, a)]];
            }
            getInitialTranslation() {
              return [-l._internalPadding * this.parent.scaleFactor, -(l._internalPadding + Oe(this, e)) * this.parent.scaleFactor];
            }
            rebuild() {
              super.rebuild(), this.div !== null && (this.isAttachedToDOM || this.parent.add(this));
            }
            enableEditMode() {
              this.isInEditMode() || (this.parent.setEditingState(!1), this.parent.updateToolbar(ce.AnnotationEditorType.FREETEXT), super.enableEditMode(), this.enableEditing(), this.overlayDiv.classList.remove("enabled"), this.editorDiv.contentEditable = !0, this.div.draggable = !1, this.editorDiv.addEventListener("keydown", Oe(this, t)), this.editorDiv.addEventListener("focus", Oe(this, F)), this.editorDiv.addEventListener("blur", Oe(this, o)));
            }
            disableEditMode() {
              this.isInEditMode() && (this.parent.setEditingState(!0), super.disableEditMode(), this.disableEditing(), this.overlayDiv.classList.add("enabled"), this.editorDiv.contentEditable = !1, this.div.draggable = !0, this.editorDiv.removeEventListener("keydown", Oe(this, t)), this.editorDiv.removeEventListener("focus", Oe(this, F)), this.editorDiv.removeEventListener("blur", Oe(this, o)), this.div.focus(), this.isEditing = !1);
            }
            focusin(O) {
              super.focusin(O), O.target !== this.editorDiv && this.editorDiv.focus();
            }
            onceAdded() {
              this.width || (this.enableEditMode(), this.editorDiv.focus());
            }
            isEmpty() {
              return !this.editorDiv || this.editorDiv.innerText.trim() === "";
            }
            remove() {
              this.isEditing = !1, this.parent.setEditingState(!0), super.remove();
            }
            commit() {
              super.commit(), Oe(this, h) || (Ft(this, h, !0), this.parent.addUndoableEditor(this)), this.disableEditMode(), Ft(this, v, At(this, p, Hi).call(this).trimEnd()), At(this, n, vi).call(this);
            }
            shouldGetKeyboardEvents() {
              return this.isInEditMode();
            }
            dblclick(O) {
              this.enableEditMode(), this.editorDiv.focus();
            }
            keydown(O) {
              O.target === this.div && O.key === "Enter" && (this.enableEditMode(), this.editorDiv.focus());
            }
            editorDivKeydown(O) {
              l._keyboardManager.exec(this, O);
            }
            editorDivFocus(O) {
              this.isEditing = !0;
            }
            editorDivBlur(O) {
              this.isEditing = !1;
            }
            disableEditing() {
              this.editorDiv.setAttribute("role", "comment"), this.editorDiv.removeAttribute("aria-multiline");
            }
            enableEditing() {
              this.editorDiv.setAttribute("role", "textbox"), this.editorDiv.setAttribute("aria-multiline", !0);
            }
            render() {
              if (this.div)
                return this.div;
              let O, b;
              this.width && (O = this.x, b = this.y), super.render(), this.editorDiv = document.createElement("div"), this.editorDiv.className = "internal", this.editorDiv.setAttribute("id", `${this.id}-editor`), this.enableEditing(), l._l10nPromise.get("editor_free_text_aria_label").then((Y) => {
                var j;
                return (j = this.editorDiv) == null ? void 0 : j.setAttribute("aria-label", Y);
              }), l._l10nPromise.get("free_text_default_content").then((Y) => {
                var j;
                return (j = this.editorDiv) == null ? void 0 : j.setAttribute("default-content", Y);
              }), this.editorDiv.contentEditable = !0;
              const {
                style: A
              } = this.editorDiv;
              if (A.fontSize = `calc(${Oe(this, e)}px * var(--scale-factor))`, A.color = Oe(this, a), this.div.append(this.editorDiv), this.overlayDiv = document.createElement("div"), this.overlayDiv.classList.add("overlay", "enabled"), this.div.append(this.overlayDiv), (0, re.bindEvents)(this, this.div, ["dblclick", "keydown"]), this.width) {
                const [Y, j] = this.parent.viewportBaseDimensions;
                this.setAt(O * Y, b * j, this.width * Y, this.height * j);
                for (const X of Oe(this, v).split(`
`)) {
                  const B = document.createElement("div");
                  B.append(X ? document.createTextNode(X) : document.createElement("br")), this.editorDiv.append(B);
                }
                this.div.draggable = !0, this.editorDiv.contentEditable = !1;
              } else
                this.div.draggable = !1, this.editorDiv.contentEditable = !0;
              return this.div;
            }
            get contentDiv() {
              return this.editorDiv;
            }
            static deserialize(O, b) {
              const A = super.deserialize(O, b);
              return Ft(A, e, O.fontSize), Ft(A, a, ce.Util.makeHexColor(...O.color)), Ft(A, v, O.value), A;
            }
            serialize() {
              if (this.isEmpty())
                return null;
              const O = l._internalPadding * this.parent.scaleFactor, b = this.getRect(O, O), A = ae.AnnotationEditor._colorManager.convert(getComputedStyle(this.editorDiv).color);
              return {
                annotationType: ce.AnnotationEditorType.FREETEXT,
                color: A,
                fontSize: Oe(this, e),
                value: Oe(this, v),
                pageIndex: this.parent.pageIndex,
                rect: b,
                rotation: this.rotation
              };
            }
          };
          let J = l;
          o = new WeakMap(), F = new WeakMap(), t = new WeakMap(), a = new WeakMap(), v = new WeakMap(), h = new WeakMap(), e = new WeakMap(), y = new WeakSet(), Wi = function(O) {
            const b = (Y) => {
              this.editorDiv.style.fontSize = `calc(${Y}px * var(--scale-factor))`, this.translate(0, -(Y - Oe(this, e)) * this.parent.scaleFactor), Ft(this, e, Y), At(this, n, vi).call(this);
            }, A = Oe(this, e);
            this.parent.addCommands({
              cmd: () => {
                b(O);
              },
              undo: () => {
                b(A);
              },
              mustExec: !0,
              type: ce.AnnotationEditorParamsType.FREETEXT_SIZE,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }, d = new WeakSet(), Xi = function(O) {
            const b = Oe(this, a);
            this.parent.addCommands({
              cmd: () => {
                Ft(this, a, O), this.editorDiv.style.color = O;
              },
              undo: () => {
                Ft(this, a, b), this.editorDiv.style.color = b;
              },
              mustExec: !0,
              type: ce.AnnotationEditorParamsType.FREETEXT_COLOR,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }, p = new WeakSet(), Hi = function() {
            const O = this.editorDiv.getElementsByTagName("div");
            if (O.length === 0)
              return this.editorDiv.innerText;
            const b = [];
            for (let A = 0, Y = O.length; A < Y; A++) {
              const X = O[A].firstChild;
              (X == null ? void 0 : X.nodeName) === "#text" ? b.push(X.data) : b.push("");
            }
            return b.join(`
`);
          }, n = new WeakSet(), vi = function() {
            const [O, b] = this.parent.viewportBaseDimensions, A = this.div.getBoundingClientRect();
            this.width = A.width / O, this.height = A.height / b;
          }, on(J, "_freeTextDefaultContent", ""), on(J, "_l10nPromise"), on(J, "_internalPadding", 0), on(J, "_defaultColor", null), on(J, "_defaultFontSize", 10), on(J, "_keyboardManager", new re.KeyboardManager([[["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], l.prototype.commitOrRemove]])), on(J, "_type", "freetext"), ge.FreeTextEditor = J;
        },
        /* 24 */
        /***/
        (be, ge, le) => {
          var t, a, v, h, e, y, c, d, m, p, g, n, i, l, u, zi, O, Gi, A, Vi, j, qi, B, wi, k, Yi, f, Ki, _, Zi, C, Cn, P, Ai, G, ei, $, ti, V, Xn, K, Si, se, ni, N, Ci, E, Ji, oe, Qi, W, er, H, Ti, ue, ii, de, Hn, xe, _i;
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.InkEditor = void 0, Object.defineProperty(ge, "fitCurve", {
            enumerable: !0,
            get: function() {
              return ae.fitCurve;
            }
          });
          var ce = le(1), re = le(6), ae = le(25), J = le(7);
          const o = 16, Se = class extends re.AnnotationEditor {
            constructor(ye) {
              super({
                ...ye,
                name: "inkEditor"
              });
              gt(this, u);
              gt(this, O);
              gt(this, A);
              gt(this, j);
              gt(this, B);
              gt(this, k);
              gt(this, f);
              gt(this, _);
              gt(this, C);
              gt(this, P);
              gt(this, G);
              gt(this, $);
              gt(this, V);
              gt(this, K);
              gt(this, se);
              gt(this, E);
              gt(this, oe);
              gt(this, W);
              gt(this, H);
              gt(this, ue);
              gt(this, de);
              gt(this, xe);
              gt(this, t, 0);
              gt(this, a, 0);
              gt(this, v, 0);
              gt(this, h, this.canvasPointermove.bind(this));
              gt(this, e, this.canvasPointerleave.bind(this));
              gt(this, y, this.canvasPointerup.bind(this));
              gt(this, c, this.canvasPointerdown.bind(this));
              gt(this, d, !1);
              gt(this, m, !1);
              gt(this, p, null);
              gt(this, g, null);
              gt(this, n, 0);
              gt(this, i, 0);
              gt(this, l, null);
              this.color = ye.color || null, this.thickness = ye.thickness || null, this.opacity = ye.opacity || null, this.paths = [], this.bezierPath2D = [], this.currentPath = [], this.scaleFactor = 1, this.translationX = this.translationY = 0, this.x = 0, this.y = 0;
            }
            static initialize(ye) {
              this._l10nPromise = new Map(["editor_ink_canvas_aria_label", "editor_ink_aria_label"].map((De) => [De, ye.get(De)]));
            }
            static updateDefaultParams(ye, De) {
              switch (ye) {
                case ce.AnnotationEditorParamsType.INK_THICKNESS:
                  Se._defaultThickness = De;
                  break;
                case ce.AnnotationEditorParamsType.INK_COLOR:
                  Se._defaultColor = De;
                  break;
                case ce.AnnotationEditorParamsType.INK_OPACITY:
                  Se._defaultOpacity = De / 100;
                  break;
              }
            }
            updateParams(ye, De) {
              switch (ye) {
                case ce.AnnotationEditorParamsType.INK_THICKNESS:
                  At(this, u, zi).call(this, De);
                  break;
                case ce.AnnotationEditorParamsType.INK_COLOR:
                  At(this, O, Gi).call(this, De);
                  break;
                case ce.AnnotationEditorParamsType.INK_OPACITY:
                  At(this, A, Vi).call(this, De);
                  break;
              }
            }
            static get defaultPropertiesToUpdate() {
              return [[ce.AnnotationEditorParamsType.INK_THICKNESS, Se._defaultThickness], [ce.AnnotationEditorParamsType.INK_COLOR, Se._defaultColor || re.AnnotationEditor._defaultLineColor], [ce.AnnotationEditorParamsType.INK_OPACITY, Math.round(Se._defaultOpacity * 100)]];
            }
            get propertiesToUpdate() {
              return [[ce.AnnotationEditorParamsType.INK_THICKNESS, this.thickness || Se._defaultThickness], [ce.AnnotationEditorParamsType.INK_COLOR, this.color || Se._defaultColor || re.AnnotationEditor._defaultLineColor], [ce.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * (this.opacity ?? Se._defaultOpacity))]];
            }
            rebuild() {
              super.rebuild(), this.div !== null && (this.canvas || (At(this, G, ei).call(this), At(this, $, ti).call(this)), this.isAttachedToDOM || (this.parent.add(this), At(this, V, Xn).call(this)), At(this, de, Hn).call(this));
            }
            remove() {
              this.canvas !== null && (this.isEmpty() || this.commit(), this.canvas.width = this.canvas.height = 0, this.canvas.remove(), this.canvas = null, Oe(this, g).disconnect(), Ft(this, g, null), super.remove());
            }
            enableEditMode() {
              Oe(this, d) || this.canvas === null || (super.enableEditMode(), this.div.draggable = !1, this.canvas.addEventListener("pointerdown", Oe(this, c)), this.canvas.addEventListener("pointerup", Oe(this, y)));
            }
            disableEditMode() {
              !this.isInEditMode() || this.canvas === null || (super.disableEditMode(), this.div.draggable = !this.isEmpty(), this.div.classList.remove("editing"), this.canvas.removeEventListener("pointerdown", Oe(this, c)), this.canvas.removeEventListener("pointerup", Oe(this, y)));
            }
            onceAdded() {
              this.div.draggable = !this.isEmpty();
            }
            isEmpty() {
              return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;
            }
            commit() {
              Oe(this, d) || (super.commit(), this.isEditing = !1, this.disableEditMode(), this.setInForeground(), Ft(this, d, !0), this.div.classList.add("disabled"), At(this, de, Hn).call(this, !0), this.parent.addInkEditorIfNeeded(!0), this.parent.moveEditorInDOM(this), this.div.focus());
            }
            focusin(ye) {
              super.focusin(ye), this.enableEditMode();
            }
            canvasPointerdown(ye) {
              ye.button !== 0 || !this.isInEditMode() || Oe(this, d) || (this.setInForeground(), ye.type !== "mouse" && this.div.focus(), ye.stopPropagation(), this.canvas.addEventListener("pointerleave", Oe(this, e)), this.canvas.addEventListener("pointermove", Oe(this, h)), At(this, k, Yi).call(this, ye.offsetX, ye.offsetY));
            }
            canvasPointermove(ye) {
              ye.stopPropagation(), At(this, f, Ki).call(this, ye.offsetX, ye.offsetY);
            }
            canvasPointerup(ye) {
              ye.button === 0 && this.isInEditMode() && this.currentPath.length !== 0 && (ye.stopPropagation(), At(this, P, Ai).call(this, ye), this.setInBackground());
            }
            canvasPointerleave(ye) {
              At(this, P, Ai).call(this, ye), this.setInBackground();
            }
            render() {
              if (this.div)
                return this.div;
              let ye, De;
              this.width && (ye = this.x, De = this.y), super.render(), Se._l10nPromise.get("editor_ink_aria_label").then((Ge) => {
                var it;
                return (it = this.div) == null ? void 0 : it.setAttribute("aria-label", Ge);
              });
              const [Ae, Te, ve, Ne] = At(this, j, qi).call(this);
              if (this.setAt(Ae, Te, 0, 0), this.setDims(ve, Ne), At(this, G, ei).call(this), this.width) {
                const [Ge, it] = this.parent.viewportBaseDimensions;
                this.setAt(ye * Ge, De * it, this.width * Ge, this.height * it), Ft(this, m, !0), At(this, V, Xn).call(this), this.setDims(this.width * Ge, this.height * it), At(this, C, Cn).call(this), At(this, xe, _i).call(this), this.div.classList.add("disabled");
              } else
                this.div.classList.add("editing"), this.enableEditMode();
              return At(this, $, ti).call(this), this.div;
            }
            setDimensions(ye, De) {
              const Ae = Math.round(ye), Te = Math.round(De);
              if (Oe(this, n) === Ae && Oe(this, i) === Te)
                return;
              Ft(this, n, Ae), Ft(this, i, Te), this.canvas.style.visibility = "hidden", Oe(this, t) && Math.abs(Oe(this, t) - ye / De) > 0.01 && (De = Math.ceil(ye / Oe(this, t)), this.setDims(ye, De));
              const [ve, Ne] = this.parent.viewportBaseDimensions;
              this.width = ye / ve, this.height = De / Ne, Oe(this, d) && At(this, K, Si).call(this, ye, De), At(this, V, Xn).call(this), At(this, C, Cn).call(this), this.canvas.style.visibility = "visible";
            }
            static deserialize(ye, De) {
              var Ee, st;
              const Ae = super.deserialize(ye, De);
              Ae.thickness = ye.thickness, Ae.color = ce.Util.makeHexColor(...ye.color), Ae.opacity = ye.opacity;
              const [Te, ve] = De.pageDimensions, Ne = Ae.width * Te, Ge = Ae.height * ve, it = De.scaleFactor, Me = ye.thickness / 2;
              Ft(Ae, t, Ne / Ge), Ft(Ae, d, !0), Ft(Ae, n, Math.round(Ne)), Ft(Ae, i, Math.round(Ge));
              for (const {
                bezier: Qe
              } of ye.paths) {
                const ct = [];
                Ae.paths.push(ct);
                let xt = it * (Qe[0] - Me), Je = it * (Ge - Qe[1] - Me);
                for (let _t = 2, Xe = Qe.length; _t < Xe; _t += 6) {
                  const Ct = it * (Qe[_t] - Me), bt = it * (Ge - Qe[_t + 1] - Me), Pe = it * (Qe[_t + 2] - Me), qe = it * (Ge - Qe[_t + 3] - Me), ot = it * (Qe[_t + 4] - Me), lt = it * (Ge - Qe[_t + 5] - Me);
                  ct.push([[xt, Je], [Ct, bt], [Pe, qe], [ot, lt]]), xt = ot, Je = lt;
                }
                const mt = At(this, N, Ci).call(this, ct);
                Ae.bezierPath2D.push(mt);
              }
              const Ie = At(Ee = Ae, H, Ti).call(Ee);
              return Ft(Ae, v, Math.max(o, Ie[2] - Ie[0])), Ft(Ae, a, Math.max(o, Ie[3] - Ie[1])), At(st = Ae, K, Si).call(st, Ne, Ge), Ae;
            }
            serialize() {
              if (this.isEmpty())
                return null;
              const ye = this.getRect(0, 0), De = this.rotation % 180 === 0 ? ye[3] - ye[1] : ye[2] - ye[0], Ae = re.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);
              return {
                annotationType: ce.AnnotationEditorType.INK,
                color: Ae,
                thickness: this.thickness,
                opacity: this.opacity,
                paths: At(this, E, Ji).call(this, this.scaleFactor / this.parent.scaleFactor, this.translationX, this.translationY, De),
                pageIndex: this.parent.pageIndex,
                rect: ye,
                rotation: this.rotation
              };
            }
          };
          let F = Se;
          t = new WeakMap(), a = new WeakMap(), v = new WeakMap(), h = new WeakMap(), e = new WeakMap(), y = new WeakMap(), c = new WeakMap(), d = new WeakMap(), m = new WeakMap(), p = new WeakMap(), g = new WeakMap(), n = new WeakMap(), i = new WeakMap(), l = new WeakMap(), u = new WeakSet(), zi = function(ye) {
            const De = this.thickness;
            this.parent.addCommands({
              cmd: () => {
                this.thickness = ye, At(this, de, Hn).call(this);
              },
              undo: () => {
                this.thickness = De, At(this, de, Hn).call(this);
              },
              mustExec: !0,
              type: ce.AnnotationEditorParamsType.INK_THICKNESS,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }, O = new WeakSet(), Gi = function(ye) {
            const De = this.color;
            this.parent.addCommands({
              cmd: () => {
                this.color = ye, At(this, C, Cn).call(this);
              },
              undo: () => {
                this.color = De, At(this, C, Cn).call(this);
              },
              mustExec: !0,
              type: ce.AnnotationEditorParamsType.INK_COLOR,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }, A = new WeakSet(), Vi = function(ye) {
            ye /= 100;
            const De = this.opacity;
            this.parent.addCommands({
              cmd: () => {
                this.opacity = ye, At(this, C, Cn).call(this);
              },
              undo: () => {
                this.opacity = De, At(this, C, Cn).call(this);
              },
              mustExec: !0,
              type: ce.AnnotationEditorParamsType.INK_OPACITY,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }, j = new WeakSet(), qi = function() {
            const {
              width: ye,
              height: De,
              rotation: Ae
            } = this.parent.viewport;
            switch (Ae) {
              case 90:
                return [0, ye, ye, De];
              case 180:
                return [ye, De, ye, De];
              case 270:
                return [De, 0, ye, De];
              default:
                return [0, 0, ye, De];
            }
          }, B = new WeakSet(), wi = function() {
            this.ctx.lineWidth = this.thickness * this.parent.scaleFactor / this.scaleFactor, this.ctx.lineCap = "round", this.ctx.lineJoin = "round", this.ctx.miterLimit = 10, this.ctx.strokeStyle = `${this.color}${(0, J.opacityToHex)(this.opacity)}`;
          }, k = new WeakSet(), Yi = function(ye, De) {
            this.isEditing = !0, Oe(this, m) || (Ft(this, m, !0), At(this, V, Xn).call(this), this.thickness || (this.thickness = Se._defaultThickness), this.color || (this.color = Se._defaultColor || re.AnnotationEditor._defaultLineColor), this.opacity ?? (this.opacity = Se._defaultOpacity)), this.currentPath.push([ye, De]), Ft(this, p, null), At(this, B, wi).call(this), this.ctx.beginPath(), this.ctx.moveTo(ye, De), Ft(this, l, () => {
              Oe(this, l) && (Oe(this, p) && (this.isEmpty() ? (this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)) : At(this, C, Cn).call(this), this.ctx.lineTo(...Oe(this, p)), Ft(this, p, null), this.ctx.stroke()), window.requestAnimationFrame(Oe(this, l)));
            }), window.requestAnimationFrame(Oe(this, l));
          }, f = new WeakSet(), Ki = function(ye, De) {
            const [Ae, Te] = this.currentPath.at(-1);
            ye === Ae && De === Te || (this.currentPath.push([ye, De]), Ft(this, p, [ye, De]));
          }, _ = new WeakSet(), Zi = function(ye, De) {
            var Me;
            this.ctx.closePath(), Ft(this, l, null), ye = Math.min(Math.max(ye, 0), this.canvas.width), De = Math.min(Math.max(De, 0), this.canvas.height);
            const [Ae, Te] = this.currentPath.at(-1);
            (ye !== Ae || De !== Te) && this.currentPath.push([ye, De]);
            let ve;
            if (this.currentPath.length !== 1)
              ve = (0, ae.fitCurve)(this.currentPath, 30, null);
            else {
              const Ie = [ye, De];
              ve = [[Ie, Ie.slice(), Ie.slice(), Ie]];
            }
            const Ne = At(Me = Se, N, Ci).call(Me, ve);
            this.currentPath.length = 0;
            const Ge = () => {
              this.paths.push(ve), this.bezierPath2D.push(Ne), this.rebuild();
            }, it = () => {
              this.paths.pop(), this.bezierPath2D.pop(), this.paths.length === 0 ? this.remove() : (this.canvas || (At(this, G, ei).call(this), At(this, $, ti).call(this)), At(this, de, Hn).call(this));
            };
            this.parent.addCommands({
              cmd: Ge,
              undo: it,
              mustExec: !0
            });
          }, C = new WeakSet(), Cn = function() {
            if (this.isEmpty()) {
              At(this, se, ni).call(this);
              return;
            }
            At(this, B, wi).call(this);
            const {
              canvas: ye,
              ctx: De
            } = this;
            De.setTransform(1, 0, 0, 1, 0, 0), De.clearRect(0, 0, ye.width, ye.height), At(this, se, ni).call(this);
            for (const Ae of this.bezierPath2D)
              De.stroke(Ae);
          }, P = new WeakSet(), Ai = function(ye) {
            At(this, _, Zi).call(this, ye.offsetX, ye.offsetY), this.canvas.removeEventListener("pointerleave", Oe(this, e)), this.canvas.removeEventListener("pointermove", Oe(this, h)), this.parent.addToAnnotationStorage(this);
          }, G = new WeakSet(), ei = function() {
            this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = 0, this.canvas.className = "inkEditorCanvas", Se._l10nPromise.get("editor_ink_canvas_aria_label").then((ye) => {
              var De;
              return (De = this.canvas) == null ? void 0 : De.setAttribute("aria-label", ye);
            }), this.div.append(this.canvas), this.ctx = this.canvas.getContext("2d");
          }, $ = new WeakSet(), ti = function() {
            Ft(this, g, new ResizeObserver((ye) => {
              const De = ye[0].contentRect;
              De.width && De.height && this.setDimensions(De.width, De.height);
            })), Oe(this, g).observe(this.div);
          }, V = new WeakSet(), Xn = function() {
            if (!Oe(this, m))
              return;
            const [ye, De] = this.parent.viewportBaseDimensions;
            this.canvas.width = Math.ceil(this.width * ye), this.canvas.height = Math.ceil(this.height * De), At(this, se, ni).call(this);
          }, K = new WeakSet(), Si = function(ye, De) {
            const Ae = At(this, ue, ii).call(this), Te = (ye - Ae) / Oe(this, v), ve = (De - Ae) / Oe(this, a);
            this.scaleFactor = Math.min(Te, ve);
          }, se = new WeakSet(), ni = function() {
            const ye = At(this, ue, ii).call(this) / 2;
            this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + ye, this.translationY * this.scaleFactor + ye);
          }, N = new WeakSet(), Ci = function(ye) {
            const De = new Path2D();
            for (let Ae = 0, Te = ye.length; Ae < Te; Ae++) {
              const [ve, Ne, Ge, it] = ye[Ae];
              Ae === 0 && De.moveTo(...ve), De.bezierCurveTo(Ne[0], Ne[1], Ge[0], Ge[1], it[0], it[1]);
            }
            return De;
          }, E = new WeakSet(), Ji = function(ye, De, Ae, Te) {
            const Ne = [], Ge = this.thickness / 2;
            let it, Me;
            for (const Ie of this.paths) {
              it = [], Me = [];
              for (let Ee = 0, st = Ie.length; Ee < st; Ee++) {
                const [Qe, ct, xt, Je] = Ie[Ee], mt = ye * (Qe[0] + De) + Ge, _t = Te - ye * (Qe[1] + Ae) - Ge, Xe = ye * (ct[0] + De) + Ge, Ct = Te - ye * (ct[1] + Ae) - Ge, bt = ye * (xt[0] + De) + Ge, Pe = Te - ye * (xt[1] + Ae) - Ge, qe = ye * (Je[0] + De) + Ge, ot = Te - ye * (Je[1] + Ae) - Ge;
                Ee === 0 && (it.push(mt, _t), Me.push(mt, _t)), it.push(Xe, Ct, bt, Pe, qe, ot), At(this, oe, Qi).call(this, mt, _t, Xe, Ct, bt, Pe, qe, ot, 4, Me);
              }
              Ne.push({
                bezier: it,
                points: Me
              });
            }
            return Ne;
          }, oe = new WeakSet(), Qi = function(ye, De, Ae, Te, ve, Ne, Ge, it, Me, Ie) {
            if (At(this, W, er).call(this, ye, De, Ae, Te, ve, Ne, Ge, it)) {
              Ie.push(Ge, it);
              return;
            }
            for (let Ee = 1; Ee < Me - 1; Ee++) {
              const st = Ee / Me, Qe = 1 - st;
              let ct = st * ye + Qe * Ae, xt = st * De + Qe * Te, Je = st * Ae + Qe * ve, mt = st * Te + Qe * Ne;
              const _t = st * ve + Qe * Ge, Xe = st * Ne + Qe * it;
              ct = st * ct + Qe * Je, xt = st * xt + Qe * mt, Je = st * Je + Qe * _t, mt = st * mt + Qe * Xe, ct = st * ct + Qe * Je, xt = st * xt + Qe * mt, Ie.push(ct, xt);
            }
            Ie.push(Ge, it);
          }, W = new WeakSet(), er = function(ye, De, Ae, Te, ve, Ne, Ge, it) {
            const Ie = (3 * Ae - 2 * ye - Ge) ** 2, Ee = (3 * Te - 2 * De - it) ** 2, st = (3 * ve - ye - 2 * Ge) ** 2, Qe = (3 * Ne - De - 2 * it) ** 2;
            return Math.max(Ie, st) + Math.max(Ee, Qe) <= 10;
          }, H = new WeakSet(), Ti = function() {
            let ye = 1 / 0, De = -1 / 0, Ae = 1 / 0, Te = -1 / 0;
            for (const ve of this.paths)
              for (const [Ne, Ge, it, Me] of ve) {
                const Ie = ce.Util.bezierBoundingBox(...Ne, ...Ge, ...it, ...Me);
                ye = Math.min(ye, Ie[0]), Ae = Math.min(Ae, Ie[1]), De = Math.max(De, Ie[2]), Te = Math.max(Te, Ie[3]);
              }
            return [ye, Ae, De, Te];
          }, ue = new WeakSet(), ii = function() {
            return Oe(this, d) ? Math.ceil(this.thickness * this.parent.scaleFactor) : 0;
          }, de = new WeakSet(), Hn = function(ye = !1) {
            if (this.isEmpty())
              return;
            if (!Oe(this, d)) {
              At(this, C, Cn).call(this);
              return;
            }
            const De = At(this, H, Ti).call(this), Ae = At(this, ue, ii).call(this);
            Ft(this, v, Math.max(o, De[2] - De[0])), Ft(this, a, Math.max(o, De[3] - De[1]));
            const Te = Math.ceil(Ae + Oe(this, v) * this.scaleFactor), ve = Math.ceil(Ae + Oe(this, a) * this.scaleFactor), [Ne, Ge] = this.parent.viewportBaseDimensions;
            this.width = Te / Ne, this.height = ve / Ge, Ft(this, t, Te / ve), At(this, xe, _i).call(this);
            const it = this.translationX, Me = this.translationY;
            this.translationX = -De[0], this.translationY = -De[1], At(this, V, Xn).call(this), At(this, C, Cn).call(this), Ft(this, n, Te), Ft(this, i, ve), this.setDims(Te, ve);
            const Ie = ye ? Ae / this.scaleFactor / 2 : 0;
            this.translate(it - this.translationX - Ie, Me - this.translationY - Ie);
          }, xe = new WeakSet(), _i = function() {
            const {
              style: ye
            } = this.div;
            Oe(this, t) >= 1 ? (ye.minHeight = `${o}px`, ye.minWidth = `${Math.round(Oe(this, t) * o)}px`) : (ye.minWidth = `${o}px`, ye.minHeight = `${Math.round(o / Oe(this, t))}px`);
          }, gt(F, N), on(F, "_defaultColor", null), on(F, "_defaultOpacity", 1), on(F, "_defaultThickness", 1), on(F, "_l10nPromise"), on(F, "_type", "ink"), ge.InkEditor = F;
        },
        /* 25 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.fitCurve = void 0;
          const ce = le(26);
          ge.fitCurve = ce;
        },
        /* 26 */
        /***/
        (be) => {
          function ge(y, c, d) {
            if (!Array.isArray(y))
              throw new TypeError("First argument should be an array");
            if (y.forEach((n) => {
              if (!Array.isArray(n) || n.some((i) => typeof i != "number") || n.length !== y[0].length)
                throw Error("Each point should be an array of numbers. Each point should have the same amount of numbers.");
            }), y = y.filter((n, i) => i === 0 || !n.every((l, u) => l === y[i - 1][u])), y.length < 2)
              return [];
            const m = y.length, p = v(y[1], y[0]), g = v(y[m - 2], y[m - 1]);
            return le(y, p, g, c, d);
          }
          function le(y, c, d, m, p) {
            var n, i, l, u, w, O, b, A, Y, j, X, B, U;
            if (y.length === 2)
              return B = h.vectorLen(h.subtract(y[0], y[1])) / 3, n = [y[0], h.addArrays(y[0], h.mulItems(c, B)), h.addArrays(y[1], h.mulItems(d, B)), y[1]], [n];
            if (i = o(y), [n, u, O] = ce(y, i, i, c, d, p), u === 0 || u < m)
              return [n];
            if (u < m * m)
              for (l = i, w = u, b = O, U = 0; U < 20; U++) {
                if (l = ae(n, y, l), [n, u, O] = ce(y, i, l, c, d, p), u < m)
                  return [n];
                if (O === b) {
                  let k = u / w;
                  if (k > 0.9999 && k < 1.0001)
                    break;
                }
                w = u, b = O;
              }
            return X = [], A = h.subtract(y[O - 1], y[O + 1]), A.every((k) => k === 0) && (A = h.subtract(y[O - 1], y[O]), [A[0], A[1]] = [-A[1], A[0]]), Y = h.normalize(A), j = h.mulItems(Y, -1), X = X.concat(le(y.slice(0, O + 1), c, Y, m, p)), X = X.concat(le(y.slice(O), j, d, m, p)), X;
          }
          function ce(y, c, d, m, p, g) {
            var n, i, l;
            return n = re(y, d, m, p), [i, l] = F(y, n, c), g && g({
              bez: n,
              points: y,
              params: c,
              maxErr: i,
              maxPoint: l
            }), [n, i, l];
          }
          function re(y, c, d, m) {
            var p, g, n, i, l, u, w, O, b, A, Y, j, X, B, U, k, x, f = y[0], D = y[y.length - 1];
            for (p = [f, null, null, D], g = h.zeros_Xx2x2(c.length), X = 0, B = c.length; X < B; X++)
              k = c[X], x = 1 - k, n = g[X], n[0] = h.mulItems(d, 3 * k * (x * x)), n[1] = h.mulItems(m, 3 * x * (k * k));
            for (i = [[0, 0], [0, 0]], l = [0, 0], X = 0, B = y.length; X < B; X++)
              k = c[X], n = g[X], i[0][0] += h.dot(n[0], n[0]), i[0][1] += h.dot(n[0], n[1]), i[1][0] += h.dot(n[0], n[1]), i[1][1] += h.dot(n[1], n[1]), U = h.subtract(y[X], e.q([f, f, D, D], k)), l[0] += h.dot(n[0], U), l[1] += h.dot(n[1], U);
            return u = i[0][0] * i[1][1] - i[1][0] * i[0][1], w = i[0][0] * l[1] - i[1][0] * l[0], O = l[0] * i[1][1] - l[1] * i[0][1], b = u === 0 ? 0 : O / u, A = u === 0 ? 0 : w / u, j = h.vectorLen(h.subtract(f, D)), Y = 1e-6 * j, b < Y || A < Y ? (p[1] = h.addArrays(f, h.mulItems(d, j / 3)), p[2] = h.addArrays(D, h.mulItems(m, j / 3))) : (p[1] = h.addArrays(f, h.mulItems(d, b)), p[2] = h.addArrays(D, h.mulItems(m, A))), p;
          }
          function ae(y, c, d) {
            return d.map((m, p) => J(y, c[p], m));
          }
          function J(y, c, d) {
            var m = h.subtract(e.q(y, d), c), p = e.qprime(y, d), g = h.mulMatrix(m, p), n = h.sum(h.squareItems(p)) + 2 * h.mulMatrix(m, e.qprimeprime(y, d));
            return n === 0 ? d : d - g / n;
          }
          function o(y) {
            var c = [], d, m, p;
            return y.forEach((g, n) => {
              d = n ? m + h.vectorLen(h.subtract(g, p)) : 0, c.push(d), m = d, p = g;
            }), c = c.map((g) => g / m), c;
          }
          function F(y, c, d) {
            var m, p, g, n, i, l, u, w;
            p = 0, g = Math.floor(y.length / 2);
            const O = t(c, 10);
            for (i = 0, l = y.length; i < l; i++)
              u = y[i], w = a(c, d[i], O, 10), n = h.subtract(e.q(c, w), u), m = n[0] * n[0] + n[1] * n[1], m > p && (p = m, g = i);
            return [p, g];
          }
          var t = function(y, c) {
            for (var d, m = [0], p = y[0], g = 0, n = 1; n <= c; n++)
              d = e.q(y, n / c), g += h.vectorLen(h.subtract(d, p)), m.push(g), p = d;
            return m = m.map((i) => i / g), m;
          };
          function a(y, c, d, m) {
            if (c < 0)
              return 0;
            if (c > 1)
              return 1;
            for (var p, g, n, i, l, u = 1; u <= m; u++)
              if (c <= d[u]) {
                i = (u - 1) / m, n = u / m, g = d[u - 1], p = d[u], l = (c - g) / (p - g) * (n - i) + i;
                break;
              }
            return l;
          }
          function v(y, c) {
            return h.normalize(h.subtract(y, c));
          }
          class h {
            static zeros_Xx2x2(c) {
              for (var d = []; c--; )
                d.push([0, 0]);
              return d;
            }
            static mulItems(c, d) {
              return c.map((m) => m * d);
            }
            static mulMatrix(c, d) {
              return c.reduce((m, p, g) => m + p * d[g], 0);
            }
            static subtract(c, d) {
              return c.map((m, p) => m - d[p]);
            }
            static addArrays(c, d) {
              return c.map((m, p) => m + d[p]);
            }
            static addItems(c, d) {
              return c.map((m) => m + d);
            }
            static sum(c) {
              return c.reduce((d, m) => d + m);
            }
            static dot(c, d) {
              return h.mulMatrix(c, d);
            }
            static vectorLen(c) {
              return Math.hypot(...c);
            }
            static divItems(c, d) {
              return c.map((m) => m / d);
            }
            static squareItems(c) {
              return c.map((d) => d * d);
            }
            static normalize(c) {
              return this.divItems(c, this.vectorLen(c));
            }
          }
          class e {
            static q(c, d) {
              var m = 1 - d, p = h.mulItems(c[0], m * m * m), g = h.mulItems(c[1], 3 * m * m * d), n = h.mulItems(c[2], 3 * m * d * d), i = h.mulItems(c[3], d * d * d);
              return h.addArrays(h.addArrays(p, g), h.addArrays(n, i));
            }
            static qprime(c, d) {
              var m = 1 - d, p = h.mulItems(h.subtract(c[1], c[0]), 3 * m * m), g = h.mulItems(h.subtract(c[2], c[1]), 6 * m * d), n = h.mulItems(h.subtract(c[3], c[2]), 3 * d * d);
              return h.addArrays(h.addArrays(p, g), n);
            }
            static qprimeprime(c, d) {
              return h.addArrays(h.mulItems(h.addArrays(h.subtract(c[2], h.mulItems(c[1], 2)), c[0]), 6 * (1 - d)), h.mulItems(h.addArrays(h.subtract(c[3], h.mulItems(c[2], 2)), c[1]), 6 * d));
            }
          }
          be.exports = ge, be.exports.fitCubic = le, be.exports.createTangent = v;
        },
        /* 27 */
        /***/
        (be, ge, le) => {
          var C, Fi, P, Di, G, Ei;
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.AnnotationLayer = void 0;
          var ce = le(1), re = le(8), ae = le(5), J = le(28), o = le(29);
          const F = 1e3, t = 9, a = /* @__PURE__ */ new WeakSet();
          function v(z) {
            return {
              width: z[2] - z[0],
              height: z[3] - z[1]
            };
          }
          class h {
            static create(V) {
              switch (V.data.annotationType) {
                case ce.AnnotationType.LINK:
                  return new y(V);
                case ce.AnnotationType.TEXT:
                  return new c(V);
                case ce.AnnotationType.WIDGET:
                  switch (V.data.fieldType) {
                    case "Tx":
                      return new m(V);
                    case "Btn":
                      return V.data.radioButton ? new g(V) : V.data.checkBox ? new p(V) : new n(V);
                    case "Ch":
                      return new i(V);
                  }
                  return new d(V);
                case ce.AnnotationType.POPUP:
                  return new l(V);
                case ce.AnnotationType.FREETEXT:
                  return new w(V);
                case ce.AnnotationType.LINE:
                  return new O(V);
                case ce.AnnotationType.SQUARE:
                  return new b(V);
                case ce.AnnotationType.CIRCLE:
                  return new A(V);
                case ce.AnnotationType.POLYLINE:
                  return new Y(V);
                case ce.AnnotationType.CARET:
                  return new X(V);
                case ce.AnnotationType.INK:
                  return new B(V);
                case ce.AnnotationType.POLYGON:
                  return new j(V);
                case ce.AnnotationType.HIGHLIGHT:
                  return new U(V);
                case ce.AnnotationType.UNDERLINE:
                  return new k(V);
                case ce.AnnotationType.SQUIGGLY:
                  return new x(V);
                case ce.AnnotationType.STRIKEOUT:
                  return new f(V);
                case ce.AnnotationType.STAMP:
                  return new D(V);
                case ce.AnnotationType.FILEATTACHMENT:
                  return new _(V);
                default:
                  return new e(V);
              }
            }
          }
          class e {
            constructor(V, {
              isRenderable: L = !1,
              ignoreBorder: K = !1,
              createQuadrilaterals: ne = !1
            } = {}) {
              this.isRenderable = L, this.data = V.data, this.layer = V.layer, this.page = V.page, this.viewport = V.viewport, this.linkService = V.linkService, this.downloadManager = V.downloadManager, this.imageResourcesPath = V.imageResourcesPath, this.renderForms = V.renderForms, this.svgFactory = V.svgFactory, this.annotationStorage = V.annotationStorage, this.enableScripting = V.enableScripting, this.hasJSActions = V.hasJSActions, this._fieldObjects = V.fieldObjects, this._mouseState = V.mouseState, L && (this.container = this._createContainer(K)), ne && (this.quadrilaterals = this._createQuadrilaterals(K));
            }
            _createContainer(V = !1) {
              const L = this.data, K = this.page, ne = this.viewport, se = document.createElement("section"), {
                width: q,
                height: N
              } = v(L.rect), [Q, E, te, oe] = ne.viewBox, ee = te - Q, W = oe - E;
              se.setAttribute("data-annotation-id", L.id);
              const I = ce.Util.normalizeRect([L.rect[0], K.view[3] - L.rect[1] + K.view[1], L.rect[2], K.view[3] - L.rect[3] + K.view[1]]);
              if (!V && L.borderStyle.width > 0) {
                se.style.borderWidth = `${L.borderStyle.width}px`;
                const ie = L.borderStyle.horizontalCornerRadius, ue = L.borderStyle.verticalCornerRadius;
                if (ie > 0 || ue > 0) {
                  const de = `calc(${ie}px * var(--scale-factor)) / calc(${ue}px * var(--scale-factor))`;
                  se.style.borderRadius = de;
                } else if (this instanceof g) {
                  const de = `calc(${q}px * var(--scale-factor)) / calc(${N}px * var(--scale-factor))`;
                  se.style.borderRadius = de;
                }
                switch (L.borderStyle.style) {
                  case ce.AnnotationBorderStyleType.SOLID:
                    se.style.borderStyle = "solid";
                    break;
                  case ce.AnnotationBorderStyleType.DASHED:
                    se.style.borderStyle = "dashed";
                    break;
                  case ce.AnnotationBorderStyleType.BEVELED:
                    (0, ce.warn)("Unimplemented border style: beveled");
                    break;
                  case ce.AnnotationBorderStyleType.INSET:
                    (0, ce.warn)("Unimplemented border style: inset");
                    break;
                  case ce.AnnotationBorderStyleType.UNDERLINE:
                    se.style.borderBottomStyle = "solid";
                    break;
                }
                const fe = L.borderColor || null;
                fe ? se.style.borderColor = ce.Util.makeHexColor(fe[0] | 0, fe[1] | 0, fe[2] | 0) : se.style.borderWidth = 0;
              }
              se.style.left = `${100 * (I[0] - Q) / ee}%`, se.style.top = `${100 * (I[1] - E) / W}%`;
              const {
                rotation: H
              } = L;
              return L.hasOwnCanvas || H === 0 ? (se.style.width = `${100 * q / ee}%`, se.style.height = `${100 * N / W}%`) : this.setRotation(H, se), se;
            }
            setRotation(V, L = this.container) {
              const [K, ne, se, q] = this.viewport.viewBox, N = se - K, Q = q - ne, {
                width: E,
                height: te
              } = v(this.data.rect);
              let oe, ee;
              V % 180 === 0 ? (oe = 100 * E / N, ee = 100 * te / Q) : (oe = 100 * te / N, ee = 100 * E / Q), L.style.width = `${oe}%`, L.style.height = `${ee}%`, L.setAttribute("data-main-rotation", (360 - V) % 360);
            }
            get _commonActions() {
              const V = (L, K, ne) => {
                const se = ne.detail[L];
                ne.target.style[K] = J.ColorConverters[`${se[0]}_HTML`](se.slice(1));
              };
              return (0, ce.shadow)(this, "_commonActions", {
                display: (L) => {
                  const K = L.detail.display % 2 === 1;
                  this.container.style.visibility = K ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
                    hidden: K,
                    print: L.detail.display === 0 || L.detail.display === 3
                  });
                },
                print: (L) => {
                  this.annotationStorage.setValue(this.data.id, {
                    print: L.detail.print
                  });
                },
                hidden: (L) => {
                  this.container.style.visibility = L.detail.hidden ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
                    hidden: L.detail.hidden
                  });
                },
                focus: (L) => {
                  setTimeout(() => L.target.focus({
                    preventScroll: !1
                  }), 0);
                },
                userName: (L) => {
                  L.target.title = L.detail.userName;
                },
                readonly: (L) => {
                  L.detail.readonly ? L.target.setAttribute("readonly", "") : L.target.removeAttribute("readonly");
                },
                required: (L) => {
                  this._setRequired(L.target, L.detail.required);
                },
                bgColor: (L) => {
                  V("bgColor", "backgroundColor", L);
                },
                fillColor: (L) => {
                  V("fillColor", "backgroundColor", L);
                },
                fgColor: (L) => {
                  V("fgColor", "color", L);
                },
                textColor: (L) => {
                  V("textColor", "color", L);
                },
                borderColor: (L) => {
                  V("borderColor", "borderColor", L);
                },
                strokeColor: (L) => {
                  V("strokeColor", "borderColor", L);
                },
                rotation: (L) => {
                  const K = L.detail.rotation;
                  this.setRotation(K), this.annotationStorage.setValue(this.data.id, {
                    rotation: K
                  });
                }
              });
            }
            _dispatchEventFromSandbox(V, L) {
              const K = this._commonActions;
              for (const ne of Object.keys(L.detail)) {
                const se = V[ne] || K[ne];
                se && se(L);
              }
            }
            _setDefaultPropertiesFromJS(V) {
              if (!this.enableScripting)
                return;
              const L = this.annotationStorage.getRawValue(this.data.id);
              if (!L)
                return;
              const K = this._commonActions;
              for (const [ne, se] of Object.entries(L)) {
                const q = K[ne];
                if (q) {
                  const N = {
                    detail: {
                      [ne]: se
                    },
                    target: V
                  };
                  q(N), delete L[ne];
                }
              }
            }
            _createQuadrilaterals(V = !1) {
              if (!this.data.quadPoints)
                return null;
              const L = [], K = this.data.rect;
              for (const ne of this.data.quadPoints)
                this.data.rect = [ne[2].x, ne[2].y, ne[1].x, ne[1].y], L.push(this._createContainer(V));
              return this.data.rect = K, L;
            }
            _createPopup(V, L) {
              let K = this.container;
              this.quadrilaterals && (V = V || this.quadrilaterals, K = this.quadrilaterals[0]), V || (V = document.createElement("div"), V.className = "popupTriggerArea", K.append(V));
              const se = new u({
                container: K,
                trigger: V,
                color: L.color,
                titleObj: L.titleObj,
                modificationDate: L.modificationDate,
                contentsObj: L.contentsObj,
                richText: L.richText,
                hideWrapper: !0
              }).render();
              se.style.left = "100%", K.append(se);
            }
            _renderQuadrilaterals(V) {
              for (const L of this.quadrilaterals)
                L.className = V;
              return this.quadrilaterals;
            }
            render() {
              (0, ce.unreachable)("Abstract method `AnnotationElement.render` called");
            }
            _getElementsByName(V, L = null) {
              const K = [];
              if (this._fieldObjects) {
                const ne = this._fieldObjects[V];
                if (ne)
                  for (const {
                    page: se,
                    id: q,
                    exportValues: N
                  } of ne) {
                    if (se === -1 || q === L)
                      continue;
                    const Q = typeof N == "string" ? N : null, E = document.querySelector(`[data-element-id="${q}"]`);
                    if (E && !a.has(E)) {
                      (0, ce.warn)(`_getElementsByName - element not allowed: ${q}`);
                      continue;
                    }
                    K.push({
                      id: q,
                      exportValue: Q,
                      domElement: E
                    });
                  }
                return K;
              }
              for (const ne of document.getElementsByName(V)) {
                const {
                  id: se,
                  exportValue: q
                } = ne;
                se !== L && a.has(ne) && K.push({
                  id: se,
                  exportValue: q,
                  domElement: ne
                });
              }
              return K;
            }
            static get platform() {
              const V = typeof navigator < "u" ? navigator.platform : "";
              return (0, ce.shadow)(this, "platform", {
                isWin: V.includes("Win"),
                isMac: V.includes("Mac")
              });
            }
          }
          class y extends e {
            constructor(V, L = null) {
              super(V, {
                isRenderable: !0,
                ignoreBorder: !!(L != null && L.ignoreBorder),
                createQuadrilaterals: !0
              }), this.isTooltipOnly = V.data.isTooltipOnly;
            }
            render() {
              const {
                data: V,
                linkService: L
              } = this, K = document.createElement("a");
              K.setAttribute("data-element-id", V.id);
              let ne = !1;
              return V.url ? (L.addLinkAttributes(K, V.url, V.newWindow), ne = !0) : V.action ? (this._bindNamedAction(K, V.action), ne = !0) : V.dest ? (this._bindLink(K, V.dest), ne = !0) : (V.actions && (V.actions.Action || V.actions["Mouse Up"] || V.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions && (this._bindJSAction(K, V), ne = !0), V.resetForm ? (this._bindResetFormAction(K, V.resetForm), ne = !0) : this.isTooltipOnly && !ne && (this._bindLink(K, ""), ne = !0)), this.quadrilaterals ? this._renderQuadrilaterals("linkAnnotation").map((se, q) => {
                const N = q === 0 ? K : K.cloneNode();
                return se.append(N), se;
              }) : (this.container.className = "linkAnnotation", ne && this.container.append(K), this.container);
            }
            _bindLink(V, L) {
              V.href = this.linkService.getDestinationHash(L), V.onclick = () => (L && this.linkService.goToDestination(L), !1), (L || L === "") && (V.className = "internalLink");
            }
            _bindNamedAction(V, L) {
              V.href = this.linkService.getAnchorUrl(""), V.onclick = () => (this.linkService.executeNamedAction(L), !1), V.className = "internalLink";
            }
            _bindJSAction(V, L) {
              V.href = this.linkService.getAnchorUrl("");
              const K = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
              for (const ne of Object.keys(L.actions)) {
                const se = K.get(ne);
                se && (V[se] = () => {
                  var q;
                  return (q = this.linkService.eventBus) == null || q.dispatch("dispatcheventinsandbox", {
                    source: this,
                    detail: {
                      id: L.id,
                      name: ne
                    }
                  }), !1;
                });
              }
              V.onclick || (V.onclick = () => !1), V.className = "internalLink";
            }
            _bindResetFormAction(V, L) {
              const K = V.onclick;
              if (K || (V.href = this.linkService.getAnchorUrl("")), V.className = "internalLink", !this._fieldObjects) {
                (0, ce.warn)('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.'), K || (V.onclick = () => !1);
                return;
              }
              V.onclick = () => {
                var te;
                K && K();
                const {
                  fields: ne,
                  refs: se,
                  include: q
                } = L, N = [];
                if (ne.length !== 0 || se.length !== 0) {
                  const oe = new Set(se);
                  for (const ee of ne) {
                    const W = this._fieldObjects[ee] || [];
                    for (const {
                      id: I
                    } of W)
                      oe.add(I);
                  }
                  for (const ee of Object.values(this._fieldObjects))
                    for (const W of ee)
                      oe.has(W.id) === q && N.push(W);
                } else
                  for (const oe of Object.values(this._fieldObjects))
                    N.push(...oe);
                const Q = this.annotationStorage, E = [];
                for (const oe of N) {
                  const {
                    id: ee
                  } = oe;
                  switch (E.push(ee), oe.type) {
                    case "text": {
                      const I = oe.defaultValue || "";
                      Q.setValue(ee, {
                        value: I
                      });
                      break;
                    }
                    case "checkbox":
                    case "radiobutton": {
                      const I = oe.defaultValue === oe.exportValues;
                      Q.setValue(ee, {
                        value: I
                      });
                      break;
                    }
                    case "combobox":
                    case "listbox": {
                      const I = oe.defaultValue || "";
                      Q.setValue(ee, {
                        value: I
                      });
                      break;
                    }
                    default:
                      continue;
                  }
                  const W = document.querySelector(`[data-element-id="${ee}"]`);
                  if (W) {
                    if (!a.has(W)) {
                      (0, ce.warn)(`_bindResetFormAction - element not allowed: ${ee}`);
                      continue;
                    }
                  } else
                    continue;
                  W.dispatchEvent(new Event("resetform"));
                }
                return this.enableScripting && ((te = this.linkService.eventBus) == null || te.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: "app",
                    ids: E,
                    name: "ResetForm"
                  }
                })), !1;
              };
            }
          }
          class c extends e {
            constructor(V) {
              var K, ne, se;
              const L = !!(V.data.hasPopup || (K = V.data.titleObj) != null && K.str || (ne = V.data.contentsObj) != null && ne.str || (se = V.data.richText) != null && se.str);
              super(V, {
                isRenderable: L
              });
            }
            render() {
              this.container.className = "textAnnotation";
              const V = document.createElement("img");
              return V.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg", V.alt = "[{{type}} Annotation]", V.dataset.l10nId = "text_annotation_type", V.dataset.l10nArgs = JSON.stringify({
                type: this.data.name
              }), this.data.hasPopup || this._createPopup(V, this.data), this.container.append(V), this.container;
            }
          }
          class d extends e {
            render() {
              return this.data.alternativeText && (this.container.title = this.data.alternativeText), this.container;
            }
            _getKeyModifier(V) {
              const {
                isWin: L,
                isMac: K
              } = e.platform;
              return L && V.ctrlKey || K && V.metaKey;
            }
            _setEventListener(V, L, K, ne) {
              L.includes("mouse") ? V.addEventListener(L, (se) => {
                var q;
                (q = this.linkService.eventBus) == null || q.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: this.data.id,
                    name: K,
                    value: ne(se),
                    shift: se.shiftKey,
                    modifier: this._getKeyModifier(se)
                  }
                });
              }) : V.addEventListener(L, (se) => {
                var q;
                (q = this.linkService.eventBus) == null || q.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: this.data.id,
                    name: K,
                    value: ne(se)
                  }
                });
              });
            }
            _setEventListeners(V, L, K) {
              var ne;
              for (const [se, q] of L)
                (q === "Action" || (ne = this.data.actions) != null && ne[q]) && this._setEventListener(V, se, q, K);
            }
            _setBackgroundColor(V) {
              const L = this.data.backgroundColor || null;
              V.style.backgroundColor = L === null ? "transparent" : ce.Util.makeHexColor(L[0], L[1], L[2]);
            }
            _setTextStyle(V) {
              const L = ["left", "center", "right"], {
                fontColor: K
              } = this.data.defaultAppearanceData, ne = this.data.defaultAppearanceData.fontSize || t, se = V.style;
              let q;
              if (this.data.multiLine) {
                const N = Math.abs(this.data.rect[3] - this.data.rect[1]), Q = Math.round(N / (ce.LINE_FACTOR * ne)) || 1, E = N / Q;
                q = Math.min(ne, Math.round(E / ce.LINE_FACTOR));
              } else {
                const N = Math.abs(this.data.rect[3] - this.data.rect[1]);
                q = Math.min(ne, Math.round(N / ce.LINE_FACTOR));
              }
              se.fontSize = `calc(${q}px * var(--scale-factor))`, se.color = ce.Util.makeHexColor(K[0], K[1], K[2]), this.data.textAlignment !== null && (se.textAlign = L[this.data.textAlignment]);
            }
            _setRequired(V, L) {
              L ? V.setAttribute("required", !0) : V.removeAttribute("required"), V.setAttribute("aria-required", L);
            }
          }
          class m extends d {
            constructor(V) {
              const L = V.renderForms || !V.data.hasAppearance && !!V.data.fieldValue;
              super(V, {
                isRenderable: L
              });
            }
            setPropertyOnSiblings(V, L, K, ne) {
              const se = this.annotationStorage;
              for (const q of this._getElementsByName(V.name, V.id))
                q.domElement && (q.domElement[L] = K), se.setValue(q.id, {
                  [ne]: K
                });
            }
            render() {
              var ne;
              const V = this.annotationStorage, L = this.data.id;
              this.container.className = "textWidgetAnnotation";
              let K = null;
              if (this.renderForms) {
                const se = V.getValue(L, {
                  value: this.data.fieldValue
                });
                let q = se.formattedValue || se.value || "";
                const N = V.getValue(L, {
                  charLimit: this.data.maxLen
                }).charLimit;
                N && q.length > N && (q = q.slice(0, N));
                const Q = {
                  userValue: q,
                  formattedValue: null,
                  valueOnFocus: ""
                };
                this.data.multiLine ? (K = document.createElement("textarea"), K.textContent = q, this.data.doNotScroll && (K.style.overflowY = "hidden")) : (K = document.createElement("input"), K.type = "text", K.setAttribute("value", q), this.data.doNotScroll && (K.style.overflowX = "hidden")), a.add(K), K.setAttribute("data-element-id", L), K.disabled = this.data.readOnly, K.name = this.data.fieldName, K.tabIndex = F, this._setRequired(K, this.data.required), N && (K.maxLength = N), K.addEventListener("input", (te) => {
                  V.setValue(L, {
                    value: te.target.value
                  }), this.setPropertyOnSiblings(K, "value", te.target.value, "value");
                }), K.addEventListener("resetform", (te) => {
                  const oe = this.data.defaultFieldValue ?? "";
                  K.value = Q.userValue = oe, Q.formattedValue = null;
                });
                let E = (te) => {
                  const {
                    formattedValue: oe
                  } = Q;
                  oe != null && (te.target.value = oe), te.target.scrollLeft = 0;
                };
                if (this.enableScripting && this.hasJSActions) {
                  K.addEventListener("focus", (oe) => {
                    Q.userValue && (oe.target.value = Q.userValue), Q.valueOnFocus = oe.target.value;
                  }), K.addEventListener("updatefromsandbox", (oe) => {
                    const ee = {
                      value(W) {
                        Q.userValue = W.detail.value ?? "", V.setValue(L, {
                          value: Q.userValue.toString()
                        }), W.target.value = Q.userValue;
                      },
                      formattedValue(W) {
                        const {
                          formattedValue: I
                        } = W.detail;
                        Q.formattedValue = I, I != null && W.target !== document.activeElement && (W.target.value = I), V.setValue(L, {
                          formattedValue: I
                        });
                      },
                      selRange(W) {
                        W.target.setSelectionRange(...W.detail.selRange);
                      },
                      charLimit: (W) => {
                        var ue;
                        const {
                          charLimit: I
                        } = W.detail, {
                          target: H
                        } = W;
                        if (I === 0) {
                          H.removeAttribute("maxLength");
                          return;
                        }
                        H.setAttribute("maxLength", I);
                        let ie = Q.userValue;
                        !ie || ie.length <= I || (ie = ie.slice(0, I), H.value = Q.userValue = ie, V.setValue(L, {
                          value: ie
                        }), (ue = this.linkService.eventBus) == null || ue.dispatch("dispatcheventinsandbox", {
                          source: this,
                          detail: {
                            id: L,
                            name: "Keystroke",
                            value: ie,
                            willCommit: !0,
                            commitKey: 1,
                            selStart: H.selectionStart,
                            selEnd: H.selectionEnd
                          }
                        }));
                      }
                    };
                    this._dispatchEventFromSandbox(ee, oe);
                  }), K.addEventListener("keydown", (oe) => {
                    var I;
                    let ee = -1;
                    if (oe.key === "Escape" ? ee = 0 : oe.key === "Enter" ? ee = 2 : oe.key === "Tab" && (ee = 3), ee === -1)
                      return;
                    const {
                      value: W
                    } = oe.target;
                    Q.valueOnFocus !== W && (Q.userValue = W, (I = this.linkService.eventBus) == null || I.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id: L,
                        name: "Keystroke",
                        value: W,
                        willCommit: !0,
                        commitKey: ee,
                        selStart: oe.target.selectionStart,
                        selEnd: oe.target.selectionEnd
                      }
                    }));
                  });
                  const te = E;
                  E = null, K.addEventListener("blur", (oe) => {
                    var W;
                    const {
                      value: ee
                    } = oe.target;
                    Q.userValue = ee, this._mouseState.isDown && Q.valueOnFocus !== ee && ((W = this.linkService.eventBus) == null || W.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id: L,
                        name: "Keystroke",
                        value: ee,
                        willCommit: !0,
                        commitKey: 1,
                        selStart: oe.target.selectionStart,
                        selEnd: oe.target.selectionEnd
                      }
                    })), te(oe);
                  }), (ne = this.data.actions) != null && ne.Keystroke && K.addEventListener("beforeinput", (oe) => {
                    var de;
                    const {
                      data: ee,
                      target: W
                    } = oe, {
                      value: I,
                      selectionStart: H,
                      selectionEnd: ie
                    } = W;
                    let ue = H, fe = ie;
                    switch (oe.inputType) {
                      case "deleteWordBackward": {
                        const pe = I.substring(0, H).match(/\w*[^\w]*$/);
                        pe && (ue -= pe[0].length);
                        break;
                      }
                      case "deleteWordForward": {
                        const pe = I.substring(H).match(/^[^\w]*\w*/);
                        pe && (fe += pe[0].length);
                        break;
                      }
                      case "deleteContentBackward":
                        H === ie && (ue -= 1);
                        break;
                      case "deleteContentForward":
                        H === ie && (fe += 1);
                        break;
                    }
                    oe.preventDefault(), (de = this.linkService.eventBus) == null || de.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id: L,
                        name: "Keystroke",
                        value: I,
                        change: ee || "",
                        willCommit: !1,
                        selStart: ue,
                        selEnd: fe
                      }
                    });
                  }), this._setEventListeners(K, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (oe) => oe.target.value);
                }
                if (E && K.addEventListener("blur", E), this.data.comb) {
                  const oe = (this.data.rect[2] - this.data.rect[0]) / N;
                  K.classList.add("comb"), K.style.letterSpacing = `calc(${oe}px * var(--scale-factor) - 1ch)`;
                }
              } else
                K = document.createElement("div"), K.textContent = this.data.fieldValue, K.style.verticalAlign = "middle", K.style.display = "table-cell";
              return this._setTextStyle(K), this._setBackgroundColor(K), this._setDefaultPropertiesFromJS(K), this.container.append(K), this.container;
            }
          }
          class p extends d {
            constructor(V) {
              super(V, {
                isRenderable: V.renderForms
              });
            }
            render() {
              const V = this.annotationStorage, L = this.data, K = L.id;
              let ne = V.getValue(K, {
                value: L.exportValue === L.fieldValue
              }).value;
              typeof ne == "string" && (ne = ne !== "Off", V.setValue(K, {
                value: ne
              })), this.container.className = "buttonWidgetAnnotation checkBox";
              const se = document.createElement("input");
              return a.add(se), se.setAttribute("data-element-id", K), se.disabled = L.readOnly, this._setRequired(se, this.data.required), se.type = "checkbox", se.name = L.fieldName, ne && se.setAttribute("checked", !0), se.setAttribute("exportValue", L.exportValue), se.tabIndex = F, se.addEventListener("change", (q) => {
                const {
                  name: N,
                  checked: Q
                } = q.target;
                for (const E of this._getElementsByName(N, K)) {
                  const te = Q && E.exportValue === L.exportValue;
                  E.domElement && (E.domElement.checked = te), V.setValue(E.id, {
                    value: te
                  });
                }
                V.setValue(K, {
                  value: Q
                });
              }), se.addEventListener("resetform", (q) => {
                const N = L.defaultFieldValue || "Off";
                q.target.checked = N === L.exportValue;
              }), this.enableScripting && this.hasJSActions && (se.addEventListener("updatefromsandbox", (q) => {
                const N = {
                  value(Q) {
                    Q.target.checked = Q.detail.value !== "Off", V.setValue(K, {
                      value: Q.target.checked
                    });
                  }
                };
                this._dispatchEventFromSandbox(N, q);
              }), this._setEventListeners(se, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (q) => q.target.checked)), this._setBackgroundColor(se), this._setDefaultPropertiesFromJS(se), this.container.append(se), this.container;
            }
          }
          class g extends d {
            constructor(V) {
              super(V, {
                isRenderable: V.renderForms
              });
            }
            render() {
              this.container.className = "buttonWidgetAnnotation radioButton";
              const V = this.annotationStorage, L = this.data, K = L.id;
              let ne = V.getValue(K, {
                value: L.fieldValue === L.buttonValue
              }).value;
              typeof ne == "string" && (ne = ne !== L.buttonValue, V.setValue(K, {
                value: ne
              }));
              const se = document.createElement("input");
              if (a.add(se), se.setAttribute("data-element-id", K), se.disabled = L.readOnly, this._setRequired(se, this.data.required), se.type = "radio", se.name = L.fieldName, ne && se.setAttribute("checked", !0), se.tabIndex = F, se.addEventListener("change", (q) => {
                const {
                  name: N,
                  checked: Q
                } = q.target;
                for (const E of this._getElementsByName(N, K))
                  V.setValue(E.id, {
                    value: !1
                  });
                V.setValue(K, {
                  value: Q
                });
              }), se.addEventListener("resetform", (q) => {
                const N = L.defaultFieldValue;
                q.target.checked = N != null && N === L.buttonValue;
              }), this.enableScripting && this.hasJSActions) {
                const q = L.buttonValue;
                se.addEventListener("updatefromsandbox", (N) => {
                  const Q = {
                    value: (E) => {
                      const te = q === E.detail.value;
                      for (const oe of this._getElementsByName(E.target.name)) {
                        const ee = te && oe.id === K;
                        oe.domElement && (oe.domElement.checked = ee), V.setValue(oe.id, {
                          value: ee
                        });
                      }
                    }
                  };
                  this._dispatchEventFromSandbox(Q, N);
                }), this._setEventListeners(se, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (N) => N.target.checked);
              }
              return this._setBackgroundColor(se), this._setDefaultPropertiesFromJS(se), this.container.append(se), this.container;
            }
          }
          class n extends y {
            constructor(V) {
              super(V, {
                ignoreBorder: V.data.hasAppearance
              });
            }
            render() {
              const V = super.render();
              V.className = "buttonWidgetAnnotation pushButton", this.data.alternativeText && (V.title = this.data.alternativeText);
              const L = V.lastChild;
              return this.enableScripting && this.hasJSActions && L && (this._setDefaultPropertiesFromJS(L), L.addEventListener("updatefromsandbox", (K) => {
                this._dispatchEventFromSandbox({}, K);
              })), V;
            }
          }
          class i extends d {
            constructor(V) {
              super(V, {
                isRenderable: V.renderForms
              });
            }
            render() {
              this.container.className = "choiceWidgetAnnotation";
              const V = this.annotationStorage, L = this.data.id, K = V.getValue(L, {
                value: this.data.fieldValue
              }), ne = document.createElement("select");
              a.add(ne), ne.setAttribute("data-element-id", L), ne.disabled = this.data.readOnly, this._setRequired(ne, this.data.required), ne.name = this.data.fieldName, ne.tabIndex = F;
              let se = this.data.combo && this.data.options.length > 0;
              this.data.combo || (ne.size = this.data.options.length, this.data.multiSelect && (ne.multiple = !0)), ne.addEventListener("resetform", (E) => {
                const te = this.data.defaultFieldValue;
                for (const oe of ne.options)
                  oe.selected = oe.value === te;
              });
              for (const E of this.data.options) {
                const te = document.createElement("option");
                te.textContent = E.displayValue, te.value = E.exportValue, K.value.includes(E.exportValue) && (te.setAttribute("selected", !0), se = !1), ne.append(te);
              }
              let q = null;
              if (se) {
                const E = document.createElement("option");
                E.value = " ", E.setAttribute("hidden", !0), E.setAttribute("selected", !0), ne.prepend(E), q = () => {
                  E.remove(), ne.removeEventListener("input", q), q = null;
                }, ne.addEventListener("input", q);
              }
              const N = (E, te) => {
                const oe = te ? "value" : "textContent", ee = E.target.options;
                return E.target.multiple ? Array.prototype.filter.call(ee, (W) => W.selected).map((W) => W[oe]) : ee.selectedIndex === -1 ? null : ee[ee.selectedIndex][oe];
              }, Q = (E) => {
                const te = E.target.options;
                return Array.prototype.map.call(te, (oe) => ({
                  displayValue: oe.textContent,
                  exportValue: oe.value
                }));
              };
              return this.enableScripting && this.hasJSActions ? (ne.addEventListener("updatefromsandbox", (E) => {
                const te = {
                  value(oe) {
                    q == null || q();
                    const ee = oe.detail.value, W = new Set(Array.isArray(ee) ? ee : [ee]);
                    for (const I of ne.options)
                      I.selected = W.has(I.value);
                    V.setValue(L, {
                      value: N(oe, !0)
                    });
                  },
                  multipleSelection(oe) {
                    ne.multiple = !0;
                  },
                  remove(oe) {
                    const ee = ne.options, W = oe.detail.remove;
                    ee[W].selected = !1, ne.remove(W), ee.length > 0 && Array.prototype.findIndex.call(ee, (H) => H.selected) === -1 && (ee[0].selected = !0), V.setValue(L, {
                      value: N(oe, !0),
                      items: Q(oe)
                    });
                  },
                  clear(oe) {
                    for (; ne.length !== 0; )
                      ne.remove(0);
                    V.setValue(L, {
                      value: null,
                      items: []
                    });
                  },
                  insert(oe) {
                    const {
                      index: ee,
                      displayValue: W,
                      exportValue: I
                    } = oe.detail.insert, H = ne.children[ee], ie = document.createElement("option");
                    ie.textContent = W, ie.value = I, H ? H.before(ie) : ne.append(ie), V.setValue(L, {
                      value: N(oe, !0),
                      items: Q(oe)
                    });
                  },
                  items(oe) {
                    const {
                      items: ee
                    } = oe.detail;
                    for (; ne.length !== 0; )
                      ne.remove(0);
                    for (const W of ee) {
                      const {
                        displayValue: I,
                        exportValue: H
                      } = W, ie = document.createElement("option");
                      ie.textContent = I, ie.value = H, ne.append(ie);
                    }
                    ne.options.length > 0 && (ne.options[0].selected = !0), V.setValue(L, {
                      value: N(oe, !0),
                      items: Q(oe)
                    });
                  },
                  indices(oe) {
                    const ee = new Set(oe.detail.indices);
                    for (const W of oe.target.options)
                      W.selected = ee.has(W.index);
                    V.setValue(L, {
                      value: N(oe, !0)
                    });
                  },
                  editable(oe) {
                    oe.target.disabled = !oe.detail.editable;
                  }
                };
                this._dispatchEventFromSandbox(te, E);
              }), ne.addEventListener("input", (E) => {
                var ee;
                const te = N(E, !0), oe = N(E, !1);
                V.setValue(L, {
                  value: te
                }), (ee = this.linkService.eventBus) == null || ee.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: L,
                    name: "Keystroke",
                    value: oe,
                    changeEx: te,
                    willCommit: !0,
                    commitKey: 1,
                    keyDown: !1
                  }
                });
              }), this._setEventListeners(ne, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"]], (E) => E.target.checked)) : ne.addEventListener("input", function(E) {
                V.setValue(L, {
                  value: N(E, !0)
                });
              }), this.data.combo && this._setTextStyle(ne), this._setBackgroundColor(ne), this._setDefaultPropertiesFromJS(ne), this.container.append(ne), this.container;
            }
          }
          class l extends e {
            constructor(V) {
              var K, ne, se;
              const L = !!((K = V.data.titleObj) != null && K.str || (ne = V.data.contentsObj) != null && ne.str || (se = V.data.richText) != null && se.str);
              super(V, {
                isRenderable: L
              });
            }
            render() {
              const V = ["Line", "Square", "Circle", "PolyLine", "Polygon", "Ink"];
              if (this.container.className = "popupAnnotation", V.includes(this.data.parentType))
                return this.container;
              const L = `[data-annotation-id="${this.data.parentId}"]`, K = this.layer.querySelectorAll(L);
              if (K.length === 0)
                return this.container;
              const ne = new u({
                container: this.container,
                trigger: Array.from(K),
                color: this.data.color,
                titleObj: this.data.titleObj,
                modificationDate: this.data.modificationDate,
                contentsObj: this.data.contentsObj,
                richText: this.data.richText
              }), se = this.page, q = ce.Util.normalizeRect([this.data.parentRect[0], se.view[3] - this.data.parentRect[1] + se.view[1], this.data.parentRect[2], se.view[3] - this.data.parentRect[3] + se.view[1]]), N = q[0] + this.data.parentRect[2] - this.data.parentRect[0], Q = q[1], [E, te, oe, ee] = this.viewport.viewBox, W = oe - E, I = ee - te;
              return this.container.style.left = `${100 * (N - E) / W}%`, this.container.style.top = `${100 * (Q - te) / I}%`, this.container.append(ne.render()), this.container;
            }
          }
          class u {
            constructor(V) {
              this.container = V.container, this.trigger = V.trigger, this.color = V.color, this.titleObj = V.titleObj, this.modificationDate = V.modificationDate, this.contentsObj = V.contentsObj, this.richText = V.richText, this.hideWrapper = V.hideWrapper || !1, this.pinned = !1;
            }
            render() {
              var N, Q;
              const L = document.createElement("div");
              L.className = "popupWrapper", this.hideElement = this.hideWrapper ? L : this.container, this.hideElement.hidden = !0;
              const K = document.createElement("div");
              K.className = "popup";
              const ne = this.color;
              if (ne) {
                const E = 0.7 * (255 - ne[0]) + ne[0], te = 0.7 * (255 - ne[1]) + ne[1], oe = 0.7 * (255 - ne[2]) + ne[2];
                K.style.backgroundColor = ce.Util.makeHexColor(E | 0, te | 0, oe | 0);
              }
              const se = document.createElement("h1");
              se.dir = this.titleObj.dir, se.textContent = this.titleObj.str, K.append(se);
              const q = re.PDFDateString.toDateObject(this.modificationDate);
              if (q) {
                const E = document.createElement("span");
                E.className = "popupDate", E.textContent = "{{date}}, {{time}}", E.dataset.l10nId = "annotation_date_string", E.dataset.l10nArgs = JSON.stringify({
                  date: q.toLocaleDateString(),
                  time: q.toLocaleTimeString()
                }), K.append(E);
              }
              if ((N = this.richText) != null && N.str && (!((Q = this.contentsObj) != null && Q.str) || this.contentsObj.str === this.richText.str))
                o.XfaLayer.render({
                  xfaHtml: this.richText.html,
                  intent: "richText",
                  div: K
                }), K.lastChild.className = "richText popupContent";
              else {
                const E = this._formatContents(this.contentsObj);
                K.append(E);
              }
              Array.isArray(this.trigger) || (this.trigger = [this.trigger]);
              for (const E of this.trigger)
                E.addEventListener("click", this._toggle.bind(this)), E.addEventListener("mouseover", this._show.bind(this, !1)), E.addEventListener("mouseout", this._hide.bind(this, !1));
              return K.addEventListener("click", this._hide.bind(this, !0)), L.append(K), L;
            }
            _formatContents({
              str: V,
              dir: L
            }) {
              const K = document.createElement("p");
              K.className = "popupContent", K.dir = L;
              const ne = V.split(/(?:\r\n?|\n)/);
              for (let se = 0, q = ne.length; se < q; ++se) {
                const N = ne[se];
                K.append(document.createTextNode(N)), se < q - 1 && K.append(document.createElement("br"));
              }
              return K;
            }
            _toggle() {
              this.pinned ? this._hide(!0) : this._show(!0);
            }
            _show(V = !1) {
              V && (this.pinned = !0), this.hideElement.hidden && (this.hideElement.hidden = !1, this.container.style.zIndex = parseInt(this.container.style.zIndex) + 1e3);
            }
            _hide(V = !0) {
              V && (this.pinned = !1), !this.hideElement.hidden && !this.pinned && (this.hideElement.hidden = !0, this.container.style.zIndex = parseInt(this.container.style.zIndex) - 1e3);
            }
          }
          class w extends e {
            constructor(V) {
              var K, ne, se;
              const L = !!(V.data.hasPopup || (K = V.data.titleObj) != null && K.str || (ne = V.data.contentsObj) != null && ne.str || (se = V.data.richText) != null && se.str);
              super(V, {
                isRenderable: L,
                ignoreBorder: !0
              }), this.textContent = V.data.textContent;
            }
            render() {
              if (this.container.className = "freeTextAnnotation", this.textContent) {
                const V = document.createElement("div");
                V.className = "annotationTextContent", V.setAttribute("role", "comment");
                for (const L of this.textContent) {
                  const K = document.createElement("span");
                  K.textContent = L, V.append(K);
                }
                this.container.append(V);
              }
              return this.data.hasPopup || this._createPopup(null, this.data), this.container;
            }
          }
          class O extends e {
            constructor(V) {
              var K, ne, se;
              const L = !!(V.data.hasPopup || (K = V.data.titleObj) != null && K.str || (ne = V.data.contentsObj) != null && ne.str || (se = V.data.richText) != null && se.str);
              super(V, {
                isRenderable: L,
                ignoreBorder: !0
              });
            }
            render() {
              this.container.className = "lineAnnotation";
              const V = this.data, {
                width: L,
                height: K
              } = v(V.rect), ne = this.svgFactory.create(L, K, !0), se = this.svgFactory.createElement("svg:line");
              return se.setAttribute("x1", V.rect[2] - V.lineCoordinates[0]), se.setAttribute("y1", V.rect[3] - V.lineCoordinates[1]), se.setAttribute("x2", V.rect[2] - V.lineCoordinates[2]), se.setAttribute("y2", V.rect[3] - V.lineCoordinates[3]), se.setAttribute("stroke-width", V.borderStyle.width || 1), se.setAttribute("stroke", "transparent"), se.setAttribute("fill", "transparent"), ne.append(se), this.container.append(ne), this._createPopup(se, V), this.container;
            }
          }
          class b extends e {
            constructor(V) {
              var K, ne, se;
              const L = !!(V.data.hasPopup || (K = V.data.titleObj) != null && K.str || (ne = V.data.contentsObj) != null && ne.str || (se = V.data.richText) != null && se.str);
              super(V, {
                isRenderable: L,
                ignoreBorder: !0
              });
            }
            render() {
              this.container.className = "squareAnnotation";
              const V = this.data, {
                width: L,
                height: K
              } = v(V.rect), ne = this.svgFactory.create(L, K, !0), se = V.borderStyle.width, q = this.svgFactory.createElement("svg:rect");
              return q.setAttribute("x", se / 2), q.setAttribute("y", se / 2), q.setAttribute("width", L - se), q.setAttribute("height", K - se), q.setAttribute("stroke-width", se || 1), q.setAttribute("stroke", "transparent"), q.setAttribute("fill", "transparent"), ne.append(q), this.container.append(ne), this._createPopup(q, V), this.container;
            }
          }
          class A extends e {
            constructor(V) {
              var K, ne, se;
              const L = !!(V.data.hasPopup || (K = V.data.titleObj) != null && K.str || (ne = V.data.contentsObj) != null && ne.str || (se = V.data.richText) != null && se.str);
              super(V, {
                isRenderable: L,
                ignoreBorder: !0
              });
            }
            render() {
              this.container.className = "circleAnnotation";
              const V = this.data, {
                width: L,
                height: K
              } = v(V.rect), ne = this.svgFactory.create(L, K, !0), se = V.borderStyle.width, q = this.svgFactory.createElement("svg:ellipse");
              return q.setAttribute("cx", L / 2), q.setAttribute("cy", K / 2), q.setAttribute("rx", L / 2 - se / 2), q.setAttribute("ry", K / 2 - se / 2), q.setAttribute("stroke-width", se || 1), q.setAttribute("stroke", "transparent"), q.setAttribute("fill", "transparent"), ne.append(q), this.container.append(ne), this._createPopup(q, V), this.container;
            }
          }
          class Y extends e {
            constructor(V) {
              var K, ne, se;
              const L = !!(V.data.hasPopup || (K = V.data.titleObj) != null && K.str || (ne = V.data.contentsObj) != null && ne.str || (se = V.data.richText) != null && se.str);
              super(V, {
                isRenderable: L,
                ignoreBorder: !0
              }), this.containerClassName = "polylineAnnotation", this.svgElementName = "svg:polyline";
            }
            render() {
              this.container.className = this.containerClassName;
              const V = this.data, {
                width: L,
                height: K
              } = v(V.rect), ne = this.svgFactory.create(L, K, !0);
              let se = [];
              for (const N of V.vertices) {
                const Q = N.x - V.rect[0], E = V.rect[3] - N.y;
                se.push(Q + "," + E);
              }
              se = se.join(" ");
              const q = this.svgFactory.createElement(this.svgElementName);
              return q.setAttribute("points", se), q.setAttribute("stroke-width", V.borderStyle.width || 1), q.setAttribute("stroke", "transparent"), q.setAttribute("fill", "transparent"), ne.append(q), this.container.append(ne), this._createPopup(q, V), this.container;
            }
          }
          class j extends Y {
            constructor(V) {
              super(V), this.containerClassName = "polygonAnnotation", this.svgElementName = "svg:polygon";
            }
          }
          class X extends e {
            constructor(V) {
              var K, ne, se;
              const L = !!(V.data.hasPopup || (K = V.data.titleObj) != null && K.str || (ne = V.data.contentsObj) != null && ne.str || (se = V.data.richText) != null && se.str);
              super(V, {
                isRenderable: L,
                ignoreBorder: !0
              });
            }
            render() {
              return this.container.className = "caretAnnotation", this.data.hasPopup || this._createPopup(null, this.data), this.container;
            }
          }
          class B extends e {
            constructor(V) {
              var K, ne, se;
              const L = !!(V.data.hasPopup || (K = V.data.titleObj) != null && K.str || (ne = V.data.contentsObj) != null && ne.str || (se = V.data.richText) != null && se.str);
              super(V, {
                isRenderable: L,
                ignoreBorder: !0
              }), this.containerClassName = "inkAnnotation", this.svgElementName = "svg:polyline";
            }
            render() {
              this.container.className = this.containerClassName;
              const V = this.data, {
                width: L,
                height: K
              } = v(V.rect), ne = this.svgFactory.create(L, K, !0);
              for (const se of V.inkLists) {
                let q = [];
                for (const Q of se) {
                  const E = Q.x - V.rect[0], te = V.rect[3] - Q.y;
                  q.push(`${E},${te}`);
                }
                q = q.join(" ");
                const N = this.svgFactory.createElement(this.svgElementName);
                N.setAttribute("points", q), N.setAttribute("stroke-width", V.borderStyle.width || 1), N.setAttribute("stroke", "transparent"), N.setAttribute("fill", "transparent"), this._createPopup(N, V), ne.append(N);
              }
              return this.container.append(ne), this.container;
            }
          }
          class U extends e {
            constructor(V) {
              var K, ne, se;
              const L = !!(V.data.hasPopup || (K = V.data.titleObj) != null && K.str || (ne = V.data.contentsObj) != null && ne.str || (se = V.data.richText) != null && se.str);
              super(V, {
                isRenderable: L,
                ignoreBorder: !0,
                createQuadrilaterals: !0
              });
            }
            render() {
              return this.data.hasPopup || this._createPopup(null, this.data), this.quadrilaterals ? this._renderQuadrilaterals("highlightAnnotation") : (this.container.className = "highlightAnnotation", this.container);
            }
          }
          class k extends e {
            constructor(V) {
              var K, ne, se;
              const L = !!(V.data.hasPopup || (K = V.data.titleObj) != null && K.str || (ne = V.data.contentsObj) != null && ne.str || (se = V.data.richText) != null && se.str);
              super(V, {
                isRenderable: L,
                ignoreBorder: !0,
                createQuadrilaterals: !0
              });
            }
            render() {
              return this.data.hasPopup || this._createPopup(null, this.data), this.quadrilaterals ? this._renderQuadrilaterals("underlineAnnotation") : (this.container.className = "underlineAnnotation", this.container);
            }
          }
          class x extends e {
            constructor(V) {
              var K, ne, se;
              const L = !!(V.data.hasPopup || (K = V.data.titleObj) != null && K.str || (ne = V.data.contentsObj) != null && ne.str || (se = V.data.richText) != null && se.str);
              super(V, {
                isRenderable: L,
                ignoreBorder: !0,
                createQuadrilaterals: !0
              });
            }
            render() {
              return this.data.hasPopup || this._createPopup(null, this.data), this.quadrilaterals ? this._renderQuadrilaterals("squigglyAnnotation") : (this.container.className = "squigglyAnnotation", this.container);
            }
          }
          class f extends e {
            constructor(V) {
              var K, ne, se;
              const L = !!(V.data.hasPopup || (K = V.data.titleObj) != null && K.str || (ne = V.data.contentsObj) != null && ne.str || (se = V.data.richText) != null && se.str);
              super(V, {
                isRenderable: L,
                ignoreBorder: !0,
                createQuadrilaterals: !0
              });
            }
            render() {
              return this.data.hasPopup || this._createPopup(null, this.data), this.quadrilaterals ? this._renderQuadrilaterals("strikeoutAnnotation") : (this.container.className = "strikeoutAnnotation", this.container);
            }
          }
          class D extends e {
            constructor(V) {
              var K, ne, se;
              const L = !!(V.data.hasPopup || (K = V.data.titleObj) != null && K.str || (ne = V.data.contentsObj) != null && ne.str || (se = V.data.richText) != null && se.str);
              super(V, {
                isRenderable: L,
                ignoreBorder: !0
              });
            }
            render() {
              return this.container.className = "stampAnnotation", this.data.hasPopup || this._createPopup(null, this.data), this.container;
            }
          }
          class _ extends e {
            constructor(V) {
              var ne;
              super(V, {
                isRenderable: !0
              });
              const {
                filename: L,
                content: K
              } = this.data.file;
              this.filename = (0, re.getFilenameFromUrl)(L), this.content = K, (ne = this.linkService.eventBus) == null || ne.dispatch("fileattachmentannotation", {
                source: this,
                filename: L,
                content: K
              });
            }
            render() {
              var L, K;
              this.container.className = "fileAttachmentAnnotation";
              const V = document.createElement("div");
              return V.className = "popupTriggerArea", V.addEventListener("dblclick", this._download.bind(this)), !this.data.hasPopup && ((L = this.data.titleObj) != null && L.str || (K = this.data.contentsObj) != null && K.str || this.data.richText) && this._createPopup(V, this.data), this.container.append(V), this.container;
            }
            _download() {
              var V;
              (V = this.downloadManager) == null || V.openOrDownloadData(this.container, this.content, this.filename);
            }
          }
          const $ = class {
            static render(V) {
              var N, Q;
              const {
                annotations: L,
                div: K,
                viewport: ne,
                accessibilityManager: se
              } = V;
              At(this, P, Di).call(this, K, ne);
              let q = 0;
              for (const E of L) {
                if (E.annotationType !== ce.AnnotationType.POPUP) {
                  const {
                    width: oe,
                    height: ee
                  } = v(E.rect);
                  if (oe <= 0 || ee <= 0)
                    continue;
                }
                const te = h.create({
                  data: E,
                  layer: K,
                  page: V.page,
                  viewport: ne,
                  linkService: V.linkService,
                  downloadManager: V.downloadManager,
                  imageResourcesPath: V.imageResourcesPath || "",
                  renderForms: V.renderForms !== !1,
                  svgFactory: new re.DOMSVGFactory(),
                  annotationStorage: V.annotationStorage || new ae.AnnotationStorage(),
                  enableScripting: V.enableScripting,
                  hasJSActions: V.hasJSActions,
                  fieldObjects: V.fieldObjects,
                  mouseState: V.mouseState || {
                    isDown: !1
                  }
                });
                if (te.isRenderable) {
                  const oe = te.render();
                  if (E.hidden && (oe.style.visibility = "hidden"), Array.isArray(oe))
                    for (const ee of oe)
                      ee.style.zIndex = q++, At(N = $, C, Fi).call(N, ee, E.id, K, se);
                  else
                    oe.style.zIndex = q++, te instanceof l ? K.prepend(oe) : At(Q = $, C, Fi).call(Q, oe, E.id, K, se);
                }
              }
              At(this, G, Ei).call(this, K, V.annotationCanvasMap);
            }
            static update(V) {
              const {
                annotationCanvasMap: L,
                div: K,
                viewport: ne
              } = V;
              At(this, P, Di).call(this, K, ne), At(this, G, Ei).call(this, K, L), K.hidden = !1;
            }
          };
          let S = $;
          C = new WeakSet(), Fi = function(V, L, K, ne) {
            const se = V.firstChild || V;
            se.id = `${re.AnnotationPrefix}${L}`, K.append(V), ne == null || ne.moveElementInDOM(K, V, se, !1);
          }, P = new WeakSet(), Di = function(V, {
            width: L,
            height: K,
            rotation: ne
          }) {
            const {
              style: se
            } = V, q = ne % 180 !== 0, N = Math.floor(L) + "px", Q = Math.floor(K) + "px";
            se.width = q ? Q : N, se.height = q ? N : Q, V.setAttribute("data-main-rotation", ne);
          }, G = new WeakSet(), Ei = function(V, L) {
            if (L) {
              for (const [K, ne] of L) {
                const se = V.querySelector(`[data-annotation-id="${K}"]`);
                if (!se)
                  continue;
                const {
                  firstChild: q
                } = se;
                q ? q.nodeName === "CANVAS" ? q.replaceWith(ne) : q.before(ne) : se.append(ne);
              }
              L.clear();
            }
          }, gt(S, C), gt(S, P), gt(S, G), ge.AnnotationLayer = S;
        },
        /* 28 */
        /***/
        (be, ge) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.ColorConverters = void 0;
          function le(re) {
            return Math.floor(Math.max(0, Math.min(1, re)) * 255).toString(16).padStart(2, "0");
          }
          class ce {
            static CMYK_G([ae, J, o, F]) {
              return ["G", 1 - Math.min(1, 0.3 * ae + 0.59 * o + 0.11 * J + F)];
            }
            static G_CMYK([ae]) {
              return ["CMYK", 0, 0, 0, 1 - ae];
            }
            static G_RGB([ae]) {
              return ["RGB", ae, ae, ae];
            }
            static G_HTML([ae]) {
              const J = le(ae);
              return `#${J}${J}${J}`;
            }
            static RGB_G([ae, J, o]) {
              return ["G", 0.3 * ae + 0.59 * J + 0.11 * o];
            }
            static RGB_HTML([ae, J, o]) {
              const F = le(ae), t = le(J), a = le(o);
              return `#${F}${t}${a}`;
            }
            static T_HTML() {
              return "#00000000";
            }
            static CMYK_RGB([ae, J, o, F]) {
              return ["RGB", 1 - Math.min(1, ae + F), 1 - Math.min(1, o + F), 1 - Math.min(1, J + F)];
            }
            static CMYK_HTML(ae) {
              const J = this.CMYK_RGB(ae).slice(1);
              return this.RGB_HTML(J);
            }
            static RGB_CMYK([ae, J, o]) {
              const F = 1 - ae, t = 1 - J, a = 1 - o, v = Math.min(F, t, a);
              return ["CMYK", F, t, a, v];
            }
          }
          ge.ColorConverters = ce;
        },
        /* 29 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.XfaLayer = void 0;
          var ce = le(20);
          class re {
            static setupStorage(J, o, F, t, a) {
              const v = t.getValue(o, {
                value: null
              });
              switch (F.name) {
                case "textarea":
                  if (v.value !== null && (J.textContent = v.value), a === "print")
                    break;
                  J.addEventListener("input", (h) => {
                    t.setValue(o, {
                      value: h.target.value
                    });
                  });
                  break;
                case "input":
                  if (F.attributes.type === "radio" || F.attributes.type === "checkbox") {
                    if (v.value === F.attributes.xfaOn ? J.setAttribute("checked", !0) : v.value === F.attributes.xfaOff && J.removeAttribute("checked"), a === "print")
                      break;
                    J.addEventListener("change", (h) => {
                      t.setValue(o, {
                        value: h.target.checked ? h.target.getAttribute("xfaOn") : h.target.getAttribute("xfaOff")
                      });
                    });
                  } else {
                    if (v.value !== null && J.setAttribute("value", v.value), a === "print")
                      break;
                    J.addEventListener("input", (h) => {
                      t.setValue(o, {
                        value: h.target.value
                      });
                    });
                  }
                  break;
                case "select":
                  if (v.value !== null)
                    for (const h of F.children)
                      h.attributes.value === v.value && (h.attributes.selected = !0);
                  J.addEventListener("input", (h) => {
                    const e = h.target.options, y = e.selectedIndex === -1 ? "" : e[e.selectedIndex].value;
                    t.setValue(o, {
                      value: y
                    });
                  });
                  break;
              }
            }
            static setAttributes({
              html: J,
              element: o,
              storage: F = null,
              intent: t,
              linkService: a
            }) {
              const {
                attributes: v
              } = o, h = J instanceof HTMLAnchorElement;
              v.type === "radio" && (v.name = `${v.name}-${t}`);
              for (const [e, y] of Object.entries(v))
                if (y != null)
                  switch (e) {
                    case "class":
                      y.length && J.setAttribute(e, y.join(" "));
                      break;
                    case "dataId":
                      break;
                    case "id":
                      J.setAttribute("data-element-id", y);
                      break;
                    case "style":
                      Object.assign(J.style, y);
                      break;
                    case "textContent":
                      J.textContent = y;
                      break;
                    default:
                      (!h || e !== "href" && e !== "newWindow") && J.setAttribute(e, y);
                  }
              h && a.addLinkAttributes(J, v.href, v.newWindow), F && v.dataId && this.setupStorage(J, v.dataId, o, F);
            }
            static render(J) {
              var c;
              const o = J.annotationStorage, F = J.linkService, t = J.xfaHtml, a = J.intent || "display", v = document.createElement(t.name);
              t.attributes && this.setAttributes({
                html: v,
                element: t,
                intent: a,
                linkService: F
              });
              const h = [[t, -1, v]], e = J.div;
              if (e.append(v), J.viewport) {
                const d = `matrix(${J.viewport.transform.join(",")})`;
                e.style.transform = d;
              }
              a !== "richText" && e.setAttribute("class", "xfaLayer xfaFont");
              const y = [];
              for (; h.length > 0; ) {
                const [d, m, p] = h.at(-1);
                if (m + 1 === d.children.length) {
                  h.pop();
                  continue;
                }
                const g = d.children[++h.at(-1)[1]];
                if (g === null)
                  continue;
                const {
                  name: n
                } = g;
                if (n === "#text") {
                  const l = document.createTextNode(g.value);
                  y.push(l), p.append(l);
                  continue;
                }
                let i;
                if ((c = g == null ? void 0 : g.attributes) != null && c.xmlns ? i = document.createElementNS(g.attributes.xmlns, n) : i = document.createElement(n), p.append(i), g.attributes && this.setAttributes({
                  html: i,
                  element: g,
                  storage: o,
                  intent: a,
                  linkService: F
                }), g.children && g.children.length > 0)
                  h.push([g, -1, i]);
                else if (g.value) {
                  const l = document.createTextNode(g.value);
                  ce.XfaText.shouldBuildText(n) && y.push(l), i.append(l);
                }
              }
              for (const d of e.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea"))
                d.setAttribute("readOnly", !0);
              return {
                textDivs: y
              };
            }
            static update(J) {
              const o = `matrix(${J.viewport.transform.join(",")})`;
              J.div.style.transform = o, J.div.hidden = !1;
            }
          }
          ge.XfaLayer = re;
        },
        /* 30 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.TextLayerRenderTask = void 0, ge.renderTextLayer = p;
          var ce = le(1), re = le(8);
          const ae = 1e5, J = 30, o = 0.8, F = /* @__PURE__ */ new Map(), t = /^\s+$/g;
          function a(g, n) {
            const i = F.get(g);
            if (i)
              return i;
            n.save(), n.font = `${J}px ${g}`;
            const l = n.measureText("");
            let u = l.fontBoundingBoxAscent, w = Math.abs(l.fontBoundingBoxDescent);
            if (u) {
              n.restore();
              const b = u / (u + w);
              return F.set(g, b), b;
            }
            n.strokeStyle = "red", n.clearRect(0, 0, J, J), n.strokeText("g", 0, 0);
            let O = n.getImageData(0, 0, J, J).data;
            w = 0;
            for (let b = O.length - 1 - 3; b >= 0; b -= 4)
              if (O[b] > 0) {
                w = Math.ceil(b / 4 / J);
                break;
              }
            n.clearRect(0, 0, J, J), n.strokeText("A", 0, J), O = n.getImageData(0, 0, J, J).data, u = 0;
            for (let b = 0, A = O.length; b < A; b += 4)
              if (O[b] > 0) {
                u = J - Math.floor(b / 4 / J);
                break;
              }
            if (n.restore(), u) {
              const b = u / (u + w);
              return F.set(g, b), b;
            }
            return F.set(g, o), o;
          }
          function v(g, n, i, l) {
            const u = document.createElement("span"), w = g._enhanceTextSelection ? {
              angle: 0,
              canvasWidth: 0,
              hasText: n.str !== "",
              hasEOL: n.hasEOL,
              originalTransform: null,
              paddingBottom: 0,
              paddingLeft: 0,
              paddingRight: 0,
              paddingTop: 0,
              scale: 1,
              fontSize: 0
            } : {
              angle: 0,
              canvasWidth: 0,
              hasText: n.str !== "",
              hasEOL: n.hasEOL,
              fontSize: 0
            };
            g._textDivs.push(u);
            const O = ce.Util.transform(g._viewport.transform, n.transform);
            let b = Math.atan2(O[1], O[0]);
            const A = i[n.fontName];
            A.vertical && (b += Math.PI / 2);
            const Y = Math.hypot(O[2], O[3]), j = Y * a(A.fontFamily, l);
            let X, B;
            b === 0 ? (X = O[4], B = O[5] - j) : (X = O[4] + j * Math.sin(b), B = O[5] - j * Math.cos(b)), u.style.left = `${X}px`, u.style.top = `${B}px`, u.style.fontSize = `${Y}px`, u.style.fontFamily = A.fontFamily, w.fontSize = Y, u.setAttribute("role", "presentation"), u.textContent = n.str, u.dir = n.dir, g._fontInspectorEnabled && (u.dataset.fontName = n.fontName), b !== 0 && (w.angle = b * (180 / Math.PI));
            let U = !1;
            if (n.str.length > 1 || g._enhanceTextSelection && t.test(n.str))
              U = !0;
            else if (n.str !== " " && n.transform[0] !== n.transform[3]) {
              const k = Math.abs(n.transform[0]), x = Math.abs(n.transform[3]);
              k !== x && Math.max(k, x) / Math.min(k, x) > 1.5 && (U = !0);
            }
            if (U && (A.vertical ? w.canvasWidth = n.height * g._viewport.scale : w.canvasWidth = n.width * g._viewport.scale), g._textDivProperties.set(u, w), g._textContentStream && g._layoutText(u), g._enhanceTextSelection && w.hasText) {
              let k = 1, x = 0;
              b !== 0 && (k = Math.cos(b), x = Math.sin(b));
              const f = (A.vertical ? n.height : n.width) * g._viewport.scale, D = Y;
              let _, S;
              b !== 0 ? (_ = [k, x, -x, k, X, B], S = ce.Util.getAxialAlignedBoundingBox([0, 0, f, D], _)) : S = [X, B, X + f, B + D], g._bounds.push({
                left: S[0],
                top: S[1],
                right: S[2],
                bottom: S[3],
                div: u,
                size: [f, D],
                m: _
              });
            }
          }
          function h(g) {
            if (g._canceled)
              return;
            const n = g._textDivs, i = g._capability, l = n.length;
            if (l > ae) {
              g._renderingDone = !0, i.resolve();
              return;
            }
            if (!g._textContentStream)
              for (let u = 0; u < l; u++)
                g._layoutText(n[u]);
            g._renderingDone = !0, i.resolve();
          }
          function e(g, n, i) {
            let l = 0;
            for (let u = 0; u < i; u++) {
              const w = g[n++];
              w > 0 && (l = l ? Math.min(w, l) : w);
            }
            return l;
          }
          function y(g) {
            const n = g._bounds, i = g._viewport, l = c(i.width, i.height, n);
            for (let u = 0; u < l.length; u++) {
              const w = n[u].div, O = g._textDivProperties.get(w);
              if (O.angle === 0) {
                O.paddingLeft = n[u].left - l[u].left, O.paddingTop = n[u].top - l[u].top, O.paddingRight = l[u].right - n[u].right, O.paddingBottom = l[u].bottom - n[u].bottom, g._textDivProperties.set(w, O);
                continue;
              }
              const b = l[u], A = n[u], Y = A.m, j = Y[0], X = Y[1], B = [[0, 0], [0, A.size[1]], [A.size[0], 0], A.size], U = new Float64Array(64);
              for (let x = 0, f = B.length; x < f; x++) {
                const D = ce.Util.applyTransform(B[x], Y);
                U[x + 0] = j && (b.left - D[0]) / j, U[x + 4] = X && (b.top - D[1]) / X, U[x + 8] = j && (b.right - D[0]) / j, U[x + 12] = X && (b.bottom - D[1]) / X, U[x + 16] = X && (b.left - D[0]) / -X, U[x + 20] = j && (b.top - D[1]) / j, U[x + 24] = X && (b.right - D[0]) / -X, U[x + 28] = j && (b.bottom - D[1]) / j, U[x + 32] = j && (b.left - D[0]) / -j, U[x + 36] = X && (b.top - D[1]) / -X, U[x + 40] = j && (b.right - D[0]) / -j, U[x + 44] = X && (b.bottom - D[1]) / -X, U[x + 48] = X && (b.left - D[0]) / X, U[x + 52] = j && (b.top - D[1]) / -j, U[x + 56] = X && (b.right - D[0]) / X, U[x + 60] = j && (b.bottom - D[1]) / -j;
              }
              const k = 1 + Math.min(Math.abs(j), Math.abs(X));
              O.paddingLeft = e(U, 32, 16) / k, O.paddingTop = e(U, 48, 16) / k, O.paddingRight = e(U, 0, 16) / k, O.paddingBottom = e(U, 16, 16) / k, g._textDivProperties.set(w, O);
            }
          }
          function c(g, n, i) {
            const l = i.map(function(w, O) {
              return {
                x1: w.left,
                y1: w.top,
                x2: w.right,
                y2: w.bottom,
                index: O,
                x1New: void 0,
                x2New: void 0
              };
            });
            d(g, l);
            const u = new Array(i.length);
            for (const w of l) {
              const O = w.index;
              u[O] = {
                left: w.x1New,
                top: 0,
                right: w.x2New,
                bottom: 0
              };
            }
            i.map(function(w, O) {
              const b = u[O], A = l[O];
              A.x1 = w.top, A.y1 = g - b.right, A.x2 = w.bottom, A.y2 = g - b.left, A.index = O, A.x1New = void 0, A.x2New = void 0;
            }), d(n, l);
            for (const w of l) {
              const O = w.index;
              u[O].top = w.x1New, u[O].bottom = w.x2New;
            }
            return u;
          }
          function d(g, n) {
            n.sort(function(u, w) {
              return u.x1 - w.x1 || u.index - w.index;
            });
            const l = [{
              start: -1 / 0,
              end: 1 / 0,
              boundary: {
                x1: -1 / 0,
                y1: -1 / 0,
                x2: 0,
                y2: 1 / 0,
                index: -1,
                x1New: 0,
                x2New: 0
              }
            }];
            for (const u of n) {
              let w = 0;
              for (; w < l.length && l[w].end <= u.y1; )
                w++;
              let O = l.length - 1;
              for (; O >= 0 && l[O].start >= u.y2; )
                O--;
              let b, A, Y, j, X = -1 / 0;
              for (Y = w; Y <= O; Y++) {
                b = l[Y], A = b.boundary;
                let k;
                A.x2 > u.x1 ? k = A.index > u.index ? A.x1New : u.x1 : A.x2New === void 0 ? k = (A.x2 + u.x1) / 2 : k = A.x2New, k > X && (X = k);
              }
              for (u.x1New = X, Y = w; Y <= O; Y++)
                b = l[Y], A = b.boundary, A.x2New === void 0 ? A.x2 > u.x1 ? A.index > u.index && (A.x2New = A.x2) : A.x2New = X : A.x2New > X && (A.x2New = Math.max(X, A.x2));
              const B = [];
              let U = null;
              for (Y = w; Y <= O; Y++) {
                b = l[Y], A = b.boundary;
                const k = A.x2 > u.x2 ? A : u;
                U === k ? B.at(-1).end = b.end : (B.push({
                  start: b.start,
                  end: b.end,
                  boundary: k
                }), U = k);
              }
              for (l[w].start < u.y1 && (B[0].start = u.y1, B.unshift({
                start: l[w].start,
                end: u.y1,
                boundary: l[w].boundary
              })), u.y2 < l[O].end && (B.at(-1).end = u.y2, B.push({
                start: u.y2,
                end: l[O].end,
                boundary: l[O].boundary
              })), Y = w; Y <= O; Y++) {
                if (b = l[Y], A = b.boundary, A.x2New !== void 0)
                  continue;
                let k = !1;
                for (j = w - 1; !k && j >= 0 && l[j].start >= A.y1; j--)
                  k = l[j].boundary === A;
                for (j = O + 1; !k && j < l.length && l[j].end <= A.y2; j++)
                  k = l[j].boundary === A;
                for (j = 0; !k && j < B.length; j++)
                  k = B[j].boundary === A;
                k || (A.x2New = X);
              }
              Array.prototype.splice.apply(l, [w, O - w + 1, ...B]);
            }
            for (const u of l) {
              const w = u.boundary;
              w.x2New === void 0 && (w.x2New = Math.max(g, w.x2));
            }
          }
          class m {
            constructor({
              textContent: n,
              textContentStream: i,
              container: l,
              viewport: u,
              textDivs: w,
              textContentItemsStr: O,
              enhanceTextSelection: b
            }) {
              var A;
              b && (0, re.deprecated)("The `enhanceTextSelection` functionality will be removed in the future."), this._textContent = n, this._textContentStream = i, this._container = l, this._document = l.ownerDocument, this._viewport = u, this._textDivs = w || [], this._textContentItemsStr = O || [], this._enhanceTextSelection = !!b, this._fontInspectorEnabled = !!((A = globalThis.FontInspector) != null && A.enabled), this._reader = null, this._layoutTextLastFontSize = null, this._layoutTextLastFontFamily = null, this._layoutTextCtx = null, this._textDivProperties = /* @__PURE__ */ new WeakMap(), this._renderingDone = !1, this._canceled = !1, this._capability = (0, ce.createPromiseCapability)(), this._renderTimer = null, this._bounds = [], this._devicePixelRatio = globalThis.devicePixelRatio || 1, this._capability.promise.finally(() => {
                this._enhanceTextSelection || (this._textDivProperties = null), this._layoutTextCtx && (this._layoutTextCtx.canvas.width = 0, this._layoutTextCtx.canvas.height = 0, this._layoutTextCtx = null);
              }).catch(() => {
              });
            }
            get promise() {
              return this._capability.promise;
            }
            cancel() {
              this._canceled = !0, this._reader && (this._reader.cancel(new ce.AbortException("TextLayer task cancelled.")).catch(() => {
              }), this._reader = null), this._renderTimer !== null && (clearTimeout(this._renderTimer), this._renderTimer = null), this._capability.reject(new Error("TextLayer task cancelled."));
            }
            _processItems(n, i) {
              for (let l = 0, u = n.length; l < u; l++) {
                if (n[l].str === void 0) {
                  if (n[l].type === "beginMarkedContentProps" || n[l].type === "beginMarkedContent") {
                    const w = this._container;
                    this._container = document.createElement("span"), this._container.classList.add("markedContent"), n[l].id !== null && this._container.setAttribute("id", `${n[l].id}`), w.append(this._container);
                  } else
                    n[l].type === "endMarkedContent" && (this._container = this._container.parentNode);
                  continue;
                }
                this._textContentItemsStr.push(n[l].str), v(this, n[l], i, this._layoutTextCtx);
              }
            }
            _layoutText(n) {
              const i = this._textDivProperties.get(n);
              let l = "";
              if (i.canvasWidth !== 0 && i.hasText) {
                const {
                  fontFamily: u
                } = n.style, {
                  fontSize: w
                } = i;
                (w !== this._layoutTextLastFontSize || u !== this._layoutTextLastFontFamily) && (this._layoutTextCtx.font = `${w * this._devicePixelRatio}px ${u}`, this._layoutTextLastFontSize = w, this._layoutTextLastFontFamily = u);
                const {
                  width: O
                } = this._layoutTextCtx.measureText(n.textContent);
                if (O > 0) {
                  const b = this._devicePixelRatio * i.canvasWidth / O;
                  this._enhanceTextSelection && (i.scale = b), l = `scaleX(${b})`;
                }
              }
              if (i.angle !== 0 && (l = `rotate(${i.angle}deg) ${l}`), l.length > 0 && (this._enhanceTextSelection && (i.originalTransform = l), n.style.transform = l), i.hasText && this._container.append(n), i.hasEOL) {
                const u = document.createElement("br");
                u.setAttribute("role", "presentation"), this._container.append(u);
              }
            }
            _render(n = 0) {
              const i = (0, ce.createPromiseCapability)();
              let l = /* @__PURE__ */ Object.create(null);
              const u = this._document.createElement("canvas");
              if (u.height = u.width = J, this._layoutTextCtx = u.getContext("2d", {
                alpha: !1
              }), this._textContent) {
                const w = this._textContent.items, O = this._textContent.styles;
                this._processItems(w, O), i.resolve();
              } else if (this._textContentStream) {
                const w = () => {
                  this._reader.read().then(({
                    value: O,
                    done: b
                  }) => {
                    if (b) {
                      i.resolve();
                      return;
                    }
                    Object.assign(l, O.styles), this._processItems(O.items, l), w();
                  }, i.reject);
                };
                this._reader = this._textContentStream.getReader(), w();
              } else
                throw new Error('Neither "textContent" nor "textContentStream" parameters specified.');
              i.promise.then(() => {
                l = null, n ? this._renderTimer = setTimeout(() => {
                  h(this), this._renderTimer = null;
                }, n) : h(this);
              }, this._capability.reject);
            }
            expandTextDivs(n = !1) {
              if (!this._enhanceTextSelection || !this._renderingDone)
                return;
              this._bounds !== null && (y(this), this._bounds = null);
              const i = [], l = [];
              for (let u = 0, w = this._textDivs.length; u < w; u++) {
                const O = this._textDivs[u], b = this._textDivProperties.get(O);
                b.hasText && (n ? (i.length = 0, l.length = 0, b.originalTransform && i.push(b.originalTransform), b.paddingTop > 0 ? (l.push(`${b.paddingTop}px`), i.push(`translateY(${-b.paddingTop}px)`)) : l.push(0), b.paddingRight > 0 ? l.push(`${b.paddingRight / b.scale}px`) : l.push(0), b.paddingBottom > 0 ? l.push(`${b.paddingBottom}px`) : l.push(0), b.paddingLeft > 0 ? (l.push(`${b.paddingLeft / b.scale}px`), i.push(`translateX(${-b.paddingLeft / b.scale}px)`)) : l.push(0), O.style.padding = l.join(" "), i.length && (O.style.transform = i.join(" "))) : (O.style.padding = null, O.style.transform = b.originalTransform));
              }
            }
          }
          ge.TextLayerRenderTask = m;
          function p(g) {
            const n = new m({
              textContent: g.textContent,
              textContentStream: g.textContentStream,
              container: g.container,
              viewport: g.viewport,
              textDivs: g.textDivs,
              textContentItemsStr: g.textContentItemsStr,
              enhanceTextSelection: g.enhanceTextSelection
            });
            return n._render(g.timeout), n;
          }
        },
        /* 31 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.SVGGraphics = void 0;
          var ce = le(8), re = le(1), ae = le(3);
          let J = class {
            constructor() {
              (0, re.unreachable)("Not implemented: SVGGraphics");
            }
          };
          ge.SVGGraphics = J;
          {
            let c = function(i) {
              let l = [];
              const u = [];
              for (const w of i) {
                if (w.fn === "save") {
                  l.push({
                    fnId: 92,
                    fn: "group",
                    items: []
                  }), u.push(l), l = l.at(-1).items;
                  continue;
                }
                w.fn === "restore" ? l = u.pop() : l.push(w);
              }
              return l;
            }, d = function(i) {
              if (Number.isInteger(i))
                return i.toString();
              const l = i.toFixed(10);
              let u = l.length - 1;
              if (l[u] !== "0")
                return l;
              do
                u--;
              while (l[u] === "0");
              return l.substring(0, l[u] === "." ? u : u + 1);
            }, m = function(i) {
              if (i[4] === 0 && i[5] === 0) {
                if (i[1] === 0 && i[2] === 0)
                  return i[0] === 1 && i[3] === 1 ? "" : `scale(${d(i[0])} ${d(i[3])})`;
                if (i[0] === i[3] && i[1] === -i[2]) {
                  const l = Math.acos(i[0]) * 180 / Math.PI;
                  return `rotate(${d(l)})`;
                }
              } else if (i[0] === 1 && i[1] === 0 && i[2] === 0 && i[3] === 1)
                return `translate(${d(i[4])} ${d(i[5])})`;
              return `matrix(${d(i[0])} ${d(i[1])} ${d(i[2])} ${d(i[3])} ${d(i[4])} ${d(i[5])})`;
            };
            const o = {
              fontStyle: "normal",
              fontWeight: "normal",
              fillColor: "#000000"
            }, F = "http://www.w3.org/XML/1998/namespace", t = "http://www.w3.org/1999/xlink", a = ["butt", "round", "square"], v = ["miter", "round", "bevel"], h = function(i, l = "", u = !1) {
              if (URL.createObjectURL && typeof Blob < "u" && !u)
                return URL.createObjectURL(new Blob([i], {
                  type: l
                }));
              const w = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
              let O = `data:${l};base64,`;
              for (let b = 0, A = i.length; b < A; b += 3) {
                const Y = i[b] & 255, j = i[b + 1] & 255, X = i[b + 2] & 255, B = Y >> 2, U = (Y & 3) << 4 | j >> 4, k = b + 1 < A ? (j & 15) << 2 | X >> 6 : 64, x = b + 2 < A ? X & 63 : 64;
                O += w[B] + w[U] + w[k] + w[x];
              }
              return O;
            }, e = function() {
              const i = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]), l = 12, u = new Int32Array(256);
              for (let X = 0; X < 256; X++) {
                let B = X;
                for (let U = 0; U < 8; U++)
                  B & 1 ? B = 3988292384 ^ B >> 1 & 2147483647 : B = B >> 1 & 2147483647;
                u[X] = B;
              }
              function w(X, B, U) {
                let k = -1;
                for (let x = B; x < U; x++) {
                  const f = (k ^ X[x]) & 255, D = u[f];
                  k = k >>> 8 ^ D;
                }
                return k ^ -1;
              }
              function O(X, B, U, k) {
                let x = k;
                const f = B.length;
                U[x] = f >> 24 & 255, U[x + 1] = f >> 16 & 255, U[x + 2] = f >> 8 & 255, U[x + 3] = f & 255, x += 4, U[x] = X.charCodeAt(0) & 255, U[x + 1] = X.charCodeAt(1) & 255, U[x + 2] = X.charCodeAt(2) & 255, U[x + 3] = X.charCodeAt(3) & 255, x += 4, U.set(B, x), x += B.length;
                const D = w(U, k + 4, x);
                U[x] = D >> 24 & 255, U[x + 1] = D >> 16 & 255, U[x + 2] = D >> 8 & 255, U[x + 3] = D & 255;
              }
              function b(X, B, U) {
                let k = 1, x = 0;
                for (let f = B; f < U; ++f)
                  k = (k + (X[f] & 255)) % 65521, x = (x + k) % 65521;
                return x << 16 | k;
              }
              function A(X) {
                if (!ae.isNodeJS)
                  return Y(X);
                try {
                  let B;
                  parseInt(process.versions.node) >= 8 ? B = X : B = Buffer.from(X);
                  const U = require$$5.deflateSync(B, {
                    level: 9
                  });
                  return U instanceof Uint8Array ? U : new Uint8Array(U);
                } catch (B) {
                  (0, re.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + B);
                }
                return Y(X);
              }
              function Y(X) {
                let B = X.length;
                const U = 65535, k = Math.ceil(B / U), x = new Uint8Array(2 + B + k * 5 + 4);
                let f = 0;
                x[f++] = 120, x[f++] = 156;
                let D = 0;
                for (; B > U; )
                  x[f++] = 0, x[f++] = 255, x[f++] = 255, x[f++] = 0, x[f++] = 0, x.set(X.subarray(D, D + U), f), f += U, D += U, B -= U;
                x[f++] = 1, x[f++] = B & 255, x[f++] = B >> 8 & 255, x[f++] = ~B & 65535 & 255, x[f++] = (~B & 65535) >> 8 & 255, x.set(X.subarray(D), f), f += X.length - D;
                const _ = b(X, 0, X.length);
                return x[f++] = _ >> 24 & 255, x[f++] = _ >> 16 & 255, x[f++] = _ >> 8 & 255, x[f++] = _ & 255, x;
              }
              function j(X, B, U, k) {
                const x = X.width, f = X.height;
                let D, _, S;
                const C = X.data;
                switch (B) {
                  case re.ImageKind.GRAYSCALE_1BPP:
                    _ = 0, D = 1, S = x + 7 >> 3;
                    break;
                  case re.ImageKind.RGB_24BPP:
                    _ = 2, D = 8, S = x * 3;
                    break;
                  case re.ImageKind.RGBA_32BPP:
                    _ = 6, D = 8, S = x * 4;
                    break;
                  default:
                    throw new Error("invalid format");
                }
                const T = new Uint8Array((1 + S) * f);
                let P = 0, M = 0;
                for (let L = 0; L < f; ++L)
                  T[P++] = 0, T.set(C.subarray(M, M + S), P), M += S, P += S;
                if (B === re.ImageKind.GRAYSCALE_1BPP && k) {
                  P = 0;
                  for (let L = 0; L < f; L++) {
                    P++;
                    for (let K = 0; K < S; K++)
                      T[P++] ^= 255;
                  }
                }
                const G = new Uint8Array([x >> 24 & 255, x >> 16 & 255, x >> 8 & 255, x & 255, f >> 24 & 255, f >> 16 & 255, f >> 8 & 255, f & 255, D, _, 0, 0, 0]), Z = A(T), $ = i.length + l * 3 + G.length + Z.length, z = new Uint8Array($);
                let V = 0;
                return z.set(i, V), V += i.length, O("IHDR", G, z, V), V += l + G.length, O("IDATA", Z, z, V), V += l + Z.length, O("IEND", new Uint8Array(0), z, V), h(z, "image/png", U);
              }
              return function(B, U, k) {
                const x = B.kind === void 0 ? re.ImageKind.GRAYSCALE_1BPP : B.kind;
                return j(B, x, U, k);
              };
            }();
            class y {
              constructor() {
                this.fontSizeScale = 1, this.fontWeight = o.fontWeight, this.fontSize = 0, this.textMatrix = re.IDENTITY_MATRIX, this.fontMatrix = re.FONT_IDENTITY_MATRIX, this.leading = 0, this.textRenderingMode = re.TextRenderingMode.FILL, this.textMatrixScale = 1, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRise = 0, this.fillColor = o.fillColor, this.strokeColor = "#000000", this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.lineJoin = "", this.lineCap = "", this.miterLimit = 0, this.dashArray = [], this.dashPhase = 0, this.dependencies = [], this.activeClipUrl = null, this.clipGroup = null, this.maskId = "";
              }
              clone() {
                return Object.create(this);
              }
              setCurrentPoint(l, u) {
                this.x = l, this.y = u;
              }
            }
            let p = 0, g = 0, n = 0;
            ge.SVGGraphics = J = class {
              constructor(i, l, u = !1) {
                (0, ce.deprecated)("The SVG back-end is no longer maintained and *may* be removed in the future."), this.svgFactory = new ce.DOMSVGFactory(), this.current = new y(), this.transformMatrix = re.IDENTITY_MATRIX, this.transformStack = [], this.extraStack = [], this.commonObjs = i, this.objs = l, this.pendingClip = null, this.pendingEOFill = !1, this.embedFonts = !1, this.embeddedFonts = /* @__PURE__ */ Object.create(null), this.cssStyle = null, this.forceDataSchema = !!u, this._operatorIdMapping = [];
                for (const w in re.OPS)
                  this._operatorIdMapping[re.OPS[w]] = w;
              }
              save() {
                this.transformStack.push(this.transformMatrix);
                const i = this.current;
                this.extraStack.push(i), this.current = i.clone();
              }
              restore() {
                this.transformMatrix = this.transformStack.pop(), this.current = this.extraStack.pop(), this.pendingClip = null, this.tgrp = null;
              }
              group(i) {
                this.save(), this.executeOpTree(i), this.restore();
              }
              loadDependencies(i) {
                const l = i.fnArray, u = i.argsArray;
                for (let w = 0, O = l.length; w < O; w++)
                  if (l[w] === re.OPS.dependency)
                    for (const b of u[w]) {
                      const A = b.startsWith("g_") ? this.commonObjs : this.objs, Y = new Promise((j) => {
                        A.get(b, j);
                      });
                      this.current.dependencies.push(Y);
                    }
                return Promise.all(this.current.dependencies);
              }
              transform(i, l, u, w, O, b) {
                const A = [i, l, u, w, O, b];
                this.transformMatrix = re.Util.transform(this.transformMatrix, A), this.tgrp = null;
              }
              getSVG(i, l) {
                this.viewport = l;
                const u = this._initialize(l);
                return this.loadDependencies(i).then(() => (this.transformMatrix = re.IDENTITY_MATRIX, this.executeOpTree(this.convertOpList(i)), u));
              }
              convertOpList(i) {
                const l = this._operatorIdMapping, u = i.argsArray, w = i.fnArray, O = [];
                for (let b = 0, A = w.length; b < A; b++) {
                  const Y = w[b];
                  O.push({
                    fnId: Y,
                    fn: l[Y],
                    args: u[b]
                  });
                }
                return c(O);
              }
              executeOpTree(i) {
                for (const l of i) {
                  const u = l.fn, w = l.fnId, O = l.args;
                  switch (w | 0) {
                    case re.OPS.beginText:
                      this.beginText();
                      break;
                    case re.OPS.dependency:
                      break;
                    case re.OPS.setLeading:
                      this.setLeading(O);
                      break;
                    case re.OPS.setLeadingMoveText:
                      this.setLeadingMoveText(O[0], O[1]);
                      break;
                    case re.OPS.setFont:
                      this.setFont(O);
                      break;
                    case re.OPS.showText:
                      this.showText(O[0]);
                      break;
                    case re.OPS.showSpacedText:
                      this.showText(O[0]);
                      break;
                    case re.OPS.endText:
                      this.endText();
                      break;
                    case re.OPS.moveText:
                      this.moveText(O[0], O[1]);
                      break;
                    case re.OPS.setCharSpacing:
                      this.setCharSpacing(O[0]);
                      break;
                    case re.OPS.setWordSpacing:
                      this.setWordSpacing(O[0]);
                      break;
                    case re.OPS.setHScale:
                      this.setHScale(O[0]);
                      break;
                    case re.OPS.setTextMatrix:
                      this.setTextMatrix(O[0], O[1], O[2], O[3], O[4], O[5]);
                      break;
                    case re.OPS.setTextRise:
                      this.setTextRise(O[0]);
                      break;
                    case re.OPS.setTextRenderingMode:
                      this.setTextRenderingMode(O[0]);
                      break;
                    case re.OPS.setLineWidth:
                      this.setLineWidth(O[0]);
                      break;
                    case re.OPS.setLineJoin:
                      this.setLineJoin(O[0]);
                      break;
                    case re.OPS.setLineCap:
                      this.setLineCap(O[0]);
                      break;
                    case re.OPS.setMiterLimit:
                      this.setMiterLimit(O[0]);
                      break;
                    case re.OPS.setFillRGBColor:
                      this.setFillRGBColor(O[0], O[1], O[2]);
                      break;
                    case re.OPS.setStrokeRGBColor:
                      this.setStrokeRGBColor(O[0], O[1], O[2]);
                      break;
                    case re.OPS.setStrokeColorN:
                      this.setStrokeColorN(O);
                      break;
                    case re.OPS.setFillColorN:
                      this.setFillColorN(O);
                      break;
                    case re.OPS.shadingFill:
                      this.shadingFill(O[0]);
                      break;
                    case re.OPS.setDash:
                      this.setDash(O[0], O[1]);
                      break;
                    case re.OPS.setRenderingIntent:
                      this.setRenderingIntent(O[0]);
                      break;
                    case re.OPS.setFlatness:
                      this.setFlatness(O[0]);
                      break;
                    case re.OPS.setGState:
                      this.setGState(O[0]);
                      break;
                    case re.OPS.fill:
                      this.fill();
                      break;
                    case re.OPS.eoFill:
                      this.eoFill();
                      break;
                    case re.OPS.stroke:
                      this.stroke();
                      break;
                    case re.OPS.fillStroke:
                      this.fillStroke();
                      break;
                    case re.OPS.eoFillStroke:
                      this.eoFillStroke();
                      break;
                    case re.OPS.clip:
                      this.clip("nonzero");
                      break;
                    case re.OPS.eoClip:
                      this.clip("evenodd");
                      break;
                    case re.OPS.paintSolidColorImageMask:
                      this.paintSolidColorImageMask();
                      break;
                    case re.OPS.paintImageXObject:
                      this.paintImageXObject(O[0]);
                      break;
                    case re.OPS.paintInlineImageXObject:
                      this.paintInlineImageXObject(O[0]);
                      break;
                    case re.OPS.paintImageMaskXObject:
                      this.paintImageMaskXObject(O[0]);
                      break;
                    case re.OPS.paintFormXObjectBegin:
                      this.paintFormXObjectBegin(O[0], O[1]);
                      break;
                    case re.OPS.paintFormXObjectEnd:
                      this.paintFormXObjectEnd();
                      break;
                    case re.OPS.closePath:
                      this.closePath();
                      break;
                    case re.OPS.closeStroke:
                      this.closeStroke();
                      break;
                    case re.OPS.closeFillStroke:
                      this.closeFillStroke();
                      break;
                    case re.OPS.closeEOFillStroke:
                      this.closeEOFillStroke();
                      break;
                    case re.OPS.nextLine:
                      this.nextLine();
                      break;
                    case re.OPS.transform:
                      this.transform(O[0], O[1], O[2], O[3], O[4], O[5]);
                      break;
                    case re.OPS.constructPath:
                      this.constructPath(O[0], O[1]);
                      break;
                    case re.OPS.endPath:
                      this.endPath();
                      break;
                    case 92:
                      this.group(l.items);
                      break;
                    default:
                      (0, re.warn)(`Unimplemented operator ${u}`);
                      break;
                  }
                }
              }
              setWordSpacing(i) {
                this.current.wordSpacing = i;
              }
              setCharSpacing(i) {
                this.current.charSpacing = i;
              }
              nextLine() {
                this.moveText(0, this.current.leading);
              }
              setTextMatrix(i, l, u, w, O, b) {
                const A = this.current;
                A.textMatrix = A.lineMatrix = [i, l, u, w, O, b], A.textMatrixScale = Math.hypot(i, l), A.x = A.lineX = 0, A.y = A.lineY = 0, A.xcoords = [], A.ycoords = [], A.tspan = this.svgFactory.createElement("svg:tspan"), A.tspan.setAttributeNS(null, "font-family", A.fontFamily), A.tspan.setAttributeNS(null, "font-size", `${d(A.fontSize)}px`), A.tspan.setAttributeNS(null, "y", d(-A.y)), A.txtElement = this.svgFactory.createElement("svg:text"), A.txtElement.append(A.tspan);
              }
              beginText() {
                const i = this.current;
                i.x = i.lineX = 0, i.y = i.lineY = 0, i.textMatrix = re.IDENTITY_MATRIX, i.lineMatrix = re.IDENTITY_MATRIX, i.textMatrixScale = 1, i.tspan = this.svgFactory.createElement("svg:tspan"), i.txtElement = this.svgFactory.createElement("svg:text"), i.txtgrp = this.svgFactory.createElement("svg:g"), i.xcoords = [], i.ycoords = [];
              }
              moveText(i, l) {
                const u = this.current;
                u.x = u.lineX += i, u.y = u.lineY += l, u.xcoords = [], u.ycoords = [], u.tspan = this.svgFactory.createElement("svg:tspan"), u.tspan.setAttributeNS(null, "font-family", u.fontFamily), u.tspan.setAttributeNS(null, "font-size", `${d(u.fontSize)}px`), u.tspan.setAttributeNS(null, "y", d(-u.y));
              }
              showText(i) {
                const l = this.current, u = l.font, w = l.fontSize;
                if (w === 0)
                  return;
                const O = l.fontSizeScale, b = l.charSpacing, A = l.wordSpacing, Y = l.fontDirection, j = l.textHScale * Y, X = u.vertical, B = X ? 1 : -1, U = u.defaultVMetrics, k = w * l.fontMatrix[0];
                let x = 0;
                for (const _ of i) {
                  if (_ === null) {
                    x += Y * A;
                    continue;
                  } else if (typeof _ == "number") {
                    x += B * _ * w / 1e3;
                    continue;
                  }
                  const S = (_.isSpace ? A : 0) + b, C = _.fontChar;
                  let T, P, M = _.width;
                  if (X) {
                    let Z;
                    const $ = _.vmetric || U;
                    Z = _.vmetric ? $[1] : M * 0.5, Z = -Z * k;
                    const z = $[2] * k;
                    M = $ ? -$[0] : M, T = Z / O, P = (x + z) / O;
                  } else
                    T = x / O, P = 0;
                  (_.isInFont || u.missingFile) && (l.xcoords.push(l.x + T), X && l.ycoords.push(-l.y + P), l.tspan.textContent += C);
                  let G;
                  X ? G = M * k - S * Y : G = M * k + S * Y, x += G;
                }
                l.tspan.setAttributeNS(null, "x", l.xcoords.map(d).join(" ")), X ? l.tspan.setAttributeNS(null, "y", l.ycoords.map(d).join(" ")) : l.tspan.setAttributeNS(null, "y", d(-l.y)), X ? l.y -= x : l.x += x * j, l.tspan.setAttributeNS(null, "font-family", l.fontFamily), l.tspan.setAttributeNS(null, "font-size", `${d(l.fontSize)}px`), l.fontStyle !== o.fontStyle && l.tspan.setAttributeNS(null, "font-style", l.fontStyle), l.fontWeight !== o.fontWeight && l.tspan.setAttributeNS(null, "font-weight", l.fontWeight);
                const f = l.textRenderingMode & re.TextRenderingMode.FILL_STROKE_MASK;
                if (f === re.TextRenderingMode.FILL || f === re.TextRenderingMode.FILL_STROKE ? (l.fillColor !== o.fillColor && l.tspan.setAttributeNS(null, "fill", l.fillColor), l.fillAlpha < 1 && l.tspan.setAttributeNS(null, "fill-opacity", l.fillAlpha)) : l.textRenderingMode === re.TextRenderingMode.ADD_TO_PATH ? l.tspan.setAttributeNS(null, "fill", "transparent") : l.tspan.setAttributeNS(null, "fill", "none"), f === re.TextRenderingMode.STROKE || f === re.TextRenderingMode.FILL_STROKE) {
                  const _ = 1 / (l.textMatrixScale || 1);
                  this._setStrokeAttributes(l.tspan, _);
                }
                let D = l.textMatrix;
                l.textRise !== 0 && (D = D.slice(), D[5] += l.textRise), l.txtElement.setAttributeNS(null, "transform", `${m(D)} scale(${d(j)}, -1)`), l.txtElement.setAttributeNS(F, "xml:space", "preserve"), l.txtElement.append(l.tspan), l.txtgrp.append(l.txtElement), this._ensureTransformGroup().append(l.txtElement);
              }
              setLeadingMoveText(i, l) {
                this.setLeading(-l), this.moveText(i, l);
              }
              addFontStyle(i) {
                if (!i.data)
                  throw new Error('addFontStyle: No font data available, ensure that the "fontExtraProperties" API parameter is set.');
                this.cssStyle || (this.cssStyle = this.svgFactory.createElement("svg:style"), this.cssStyle.setAttributeNS(null, "type", "text/css"), this.defs.append(this.cssStyle));
                const l = h(i.data, i.mimetype, this.forceDataSchema);
                this.cssStyle.textContent += `@font-face { font-family: "${i.loadedName}"; src: url(${l}); }
`;
              }
              setFont(i) {
                const l = this.current, u = this.commonObjs.get(i[0]);
                let w = i[1];
                l.font = u, this.embedFonts && !u.missingFile && !this.embeddedFonts[u.loadedName] && (this.addFontStyle(u), this.embeddedFonts[u.loadedName] = u), l.fontMatrix = u.fontMatrix || re.FONT_IDENTITY_MATRIX;
                let O = "normal";
                u.black ? O = "900" : u.bold && (O = "bold");
                const b = u.italic ? "italic" : "normal";
                w < 0 ? (w = -w, l.fontDirection = -1) : l.fontDirection = 1, l.fontSize = w, l.fontFamily = u.loadedName, l.fontWeight = O, l.fontStyle = b, l.tspan = this.svgFactory.createElement("svg:tspan"), l.tspan.setAttributeNS(null, "y", d(-l.y)), l.xcoords = [], l.ycoords = [];
              }
              endText() {
                var l;
                const i = this.current;
                i.textRenderingMode & re.TextRenderingMode.ADD_TO_PATH_FLAG && ((l = i.txtElement) != null && l.hasChildNodes()) && (i.element = i.txtElement, this.clip("nonzero"), this.endPath());
              }
              setLineWidth(i) {
                i > 0 && (this.current.lineWidth = i);
              }
              setLineCap(i) {
                this.current.lineCap = a[i];
              }
              setLineJoin(i) {
                this.current.lineJoin = v[i];
              }
              setMiterLimit(i) {
                this.current.miterLimit = i;
              }
              setStrokeAlpha(i) {
                this.current.strokeAlpha = i;
              }
              setStrokeRGBColor(i, l, u) {
                this.current.strokeColor = re.Util.makeHexColor(i, l, u);
              }
              setFillAlpha(i) {
                this.current.fillAlpha = i;
              }
              setFillRGBColor(i, l, u) {
                this.current.fillColor = re.Util.makeHexColor(i, l, u), this.current.tspan = this.svgFactory.createElement("svg:tspan"), this.current.xcoords = [], this.current.ycoords = [];
              }
              setStrokeColorN(i) {
                this.current.strokeColor = this._makeColorN_Pattern(i);
              }
              setFillColorN(i) {
                this.current.fillColor = this._makeColorN_Pattern(i);
              }
              shadingFill(i) {
                const l = this.viewport.width, u = this.viewport.height, w = re.Util.inverseTransform(this.transformMatrix), O = re.Util.applyTransform([0, 0], w), b = re.Util.applyTransform([0, u], w), A = re.Util.applyTransform([l, 0], w), Y = re.Util.applyTransform([l, u], w), j = Math.min(O[0], b[0], A[0], Y[0]), X = Math.min(O[1], b[1], A[1], Y[1]), B = Math.max(O[0], b[0], A[0], Y[0]), U = Math.max(O[1], b[1], A[1], Y[1]), k = this.svgFactory.createElement("svg:rect");
                k.setAttributeNS(null, "x", j), k.setAttributeNS(null, "y", X), k.setAttributeNS(null, "width", B - j), k.setAttributeNS(null, "height", U - X), k.setAttributeNS(null, "fill", this._makeShadingPattern(i)), this.current.fillAlpha < 1 && k.setAttributeNS(null, "fill-opacity", this.current.fillAlpha), this._ensureTransformGroup().append(k);
              }
              _makeColorN_Pattern(i) {
                return i[0] === "TilingPattern" ? this._makeTilingPattern(i) : this._makeShadingPattern(i);
              }
              _makeTilingPattern(i) {
                const l = i[1], u = i[2], w = i[3] || re.IDENTITY_MATRIX, [O, b, A, Y] = i[4], j = i[5], X = i[6], B = i[7], U = `shading${n++}`, [k, x, f, D] = re.Util.normalizeRect([...re.Util.applyTransform([O, b], w), ...re.Util.applyTransform([A, Y], w)]), [_, S] = re.Util.singularValueDecompose2dScale(w), C = j * _, T = X * S, P = this.svgFactory.createElement("svg:pattern");
                P.setAttributeNS(null, "id", U), P.setAttributeNS(null, "patternUnits", "userSpaceOnUse"), P.setAttributeNS(null, "width", C), P.setAttributeNS(null, "height", T), P.setAttributeNS(null, "x", `${k}`), P.setAttributeNS(null, "y", `${x}`);
                const M = this.svg, G = this.transformMatrix, Z = this.current.fillColor, $ = this.current.strokeColor, z = this.svgFactory.create(f - k, D - x);
                if (this.svg = z, this.transformMatrix = w, B === 2) {
                  const V = re.Util.makeHexColor(...l);
                  this.current.fillColor = V, this.current.strokeColor = V;
                }
                return this.executeOpTree(this.convertOpList(u)), this.svg = M, this.transformMatrix = G, this.current.fillColor = Z, this.current.strokeColor = $, P.append(z.childNodes[0]), this.defs.append(P), `url(#${U})`;
              }
              _makeShadingPattern(i) {
                switch (typeof i == "string" && (i = this.objs.get(i)), i[0]) {
                  case "RadialAxial":
                    const l = `shading${n++}`, u = i[3];
                    let w;
                    switch (i[1]) {
                      case "axial":
                        const O = i[4], b = i[5];
                        w = this.svgFactory.createElement("svg:linearGradient"), w.setAttributeNS(null, "id", l), w.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), w.setAttributeNS(null, "x1", O[0]), w.setAttributeNS(null, "y1", O[1]), w.setAttributeNS(null, "x2", b[0]), w.setAttributeNS(null, "y2", b[1]);
                        break;
                      case "radial":
                        const A = i[4], Y = i[5], j = i[6], X = i[7];
                        w = this.svgFactory.createElement("svg:radialGradient"), w.setAttributeNS(null, "id", l), w.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), w.setAttributeNS(null, "cx", Y[0]), w.setAttributeNS(null, "cy", Y[1]), w.setAttributeNS(null, "r", X), w.setAttributeNS(null, "fx", A[0]), w.setAttributeNS(null, "fy", A[1]), w.setAttributeNS(null, "fr", j);
                        break;
                      default:
                        throw new Error(`Unknown RadialAxial type: ${i[1]}`);
                    }
                    for (const O of u) {
                      const b = this.svgFactory.createElement("svg:stop");
                      b.setAttributeNS(null, "offset", O[0]), b.setAttributeNS(null, "stop-color", O[1]), w.append(b);
                    }
                    return this.defs.append(w), `url(#${l})`;
                  case "Mesh":
                    return (0, re.warn)("Unimplemented pattern Mesh"), null;
                  case "Dummy":
                    return "hotpink";
                  default:
                    throw new Error(`Unknown IR type: ${i[0]}`);
                }
              }
              setDash(i, l) {
                this.current.dashArray = i, this.current.dashPhase = l;
              }
              constructPath(i, l) {
                const u = this.current;
                let w = u.x, O = u.y, b = [], A = 0;
                for (const Y of i)
                  switch (Y | 0) {
                    case re.OPS.rectangle:
                      w = l[A++], O = l[A++];
                      const j = l[A++], X = l[A++], B = w + j, U = O + X;
                      b.push("M", d(w), d(O), "L", d(B), d(O), "L", d(B), d(U), "L", d(w), d(U), "Z");
                      break;
                    case re.OPS.moveTo:
                      w = l[A++], O = l[A++], b.push("M", d(w), d(O));
                      break;
                    case re.OPS.lineTo:
                      w = l[A++], O = l[A++], b.push("L", d(w), d(O));
                      break;
                    case re.OPS.curveTo:
                      w = l[A + 4], O = l[A + 5], b.push("C", d(l[A]), d(l[A + 1]), d(l[A + 2]), d(l[A + 3]), d(w), d(O)), A += 6;
                      break;
                    case re.OPS.curveTo2:
                      b.push("C", d(w), d(O), d(l[A]), d(l[A + 1]), d(l[A + 2]), d(l[A + 3])), w = l[A + 2], O = l[A + 3], A += 4;
                      break;
                    case re.OPS.curveTo3:
                      w = l[A + 2], O = l[A + 3], b.push("C", d(l[A]), d(l[A + 1]), d(w), d(O), d(w), d(O)), A += 4;
                      break;
                    case re.OPS.closePath:
                      b.push("Z");
                      break;
                  }
                b = b.join(" "), u.path && i.length > 0 && i[0] !== re.OPS.rectangle && i[0] !== re.OPS.moveTo ? b = u.path.getAttributeNS(null, "d") + b : (u.path = this.svgFactory.createElement("svg:path"), this._ensureTransformGroup().append(u.path)), u.path.setAttributeNS(null, "d", b), u.path.setAttributeNS(null, "fill", "none"), u.element = u.path, u.setCurrentPoint(w, O);
              }
              endPath() {
                const i = this.current;
                if (i.path = null, !this.pendingClip)
                  return;
                if (!i.element) {
                  this.pendingClip = null;
                  return;
                }
                const l = `clippath${p++}`, u = this.svgFactory.createElement("svg:clipPath");
                u.setAttributeNS(null, "id", l), u.setAttributeNS(null, "transform", m(this.transformMatrix));
                const w = i.element.cloneNode(!0);
                if (this.pendingClip === "evenodd" ? w.setAttributeNS(null, "clip-rule", "evenodd") : w.setAttributeNS(null, "clip-rule", "nonzero"), this.pendingClip = null, u.append(w), this.defs.append(u), i.activeClipUrl) {
                  i.clipGroup = null;
                  for (const O of this.extraStack)
                    O.clipGroup = null;
                  u.setAttributeNS(null, "clip-path", i.activeClipUrl);
                }
                i.activeClipUrl = `url(#${l})`, this.tgrp = null;
              }
              clip(i) {
                this.pendingClip = i;
              }
              closePath() {
                const i = this.current;
                if (i.path) {
                  const l = `${i.path.getAttributeNS(null, "d")}Z`;
                  i.path.setAttributeNS(null, "d", l);
                }
              }
              setLeading(i) {
                this.current.leading = -i;
              }
              setTextRise(i) {
                this.current.textRise = i;
              }
              setTextRenderingMode(i) {
                this.current.textRenderingMode = i;
              }
              setHScale(i) {
                this.current.textHScale = i / 100;
              }
              setRenderingIntent(i) {
              }
              setFlatness(i) {
              }
              setGState(i) {
                for (const [l, u] of i)
                  switch (l) {
                    case "LW":
                      this.setLineWidth(u);
                      break;
                    case "LC":
                      this.setLineCap(u);
                      break;
                    case "LJ":
                      this.setLineJoin(u);
                      break;
                    case "ML":
                      this.setMiterLimit(u);
                      break;
                    case "D":
                      this.setDash(u[0], u[1]);
                      break;
                    case "RI":
                      this.setRenderingIntent(u);
                      break;
                    case "FL":
                      this.setFlatness(u);
                      break;
                    case "Font":
                      this.setFont(u);
                      break;
                    case "CA":
                      this.setStrokeAlpha(u);
                      break;
                    case "ca":
                      this.setFillAlpha(u);
                      break;
                    default:
                      (0, re.warn)(`Unimplemented graphic state operator ${l}`);
                      break;
                  }
              }
              fill() {
                const i = this.current;
                i.element && (i.element.setAttributeNS(null, "fill", i.fillColor), i.element.setAttributeNS(null, "fill-opacity", i.fillAlpha), this.endPath());
              }
              stroke() {
                const i = this.current;
                i.element && (this._setStrokeAttributes(i.element), i.element.setAttributeNS(null, "fill", "none"), this.endPath());
              }
              _setStrokeAttributes(i, l = 1) {
                const u = this.current;
                let w = u.dashArray;
                l !== 1 && w.length > 0 && (w = w.map(function(O) {
                  return l * O;
                })), i.setAttributeNS(null, "stroke", u.strokeColor), i.setAttributeNS(null, "stroke-opacity", u.strokeAlpha), i.setAttributeNS(null, "stroke-miterlimit", d(u.miterLimit)), i.setAttributeNS(null, "stroke-linecap", u.lineCap), i.setAttributeNS(null, "stroke-linejoin", u.lineJoin), i.setAttributeNS(null, "stroke-width", d(l * u.lineWidth) + "px"), i.setAttributeNS(null, "stroke-dasharray", w.map(d).join(" ")), i.setAttributeNS(null, "stroke-dashoffset", d(l * u.dashPhase) + "px");
              }
              eoFill() {
                this.current.element && this.current.element.setAttributeNS(null, "fill-rule", "evenodd"), this.fill();
              }
              fillStroke() {
                this.stroke(), this.fill();
              }
              eoFillStroke() {
                this.current.element && this.current.element.setAttributeNS(null, "fill-rule", "evenodd"), this.fillStroke();
              }
              closeStroke() {
                this.closePath(), this.stroke();
              }
              closeFillStroke() {
                this.closePath(), this.fillStroke();
              }
              closeEOFillStroke() {
                this.closePath(), this.eoFillStroke();
              }
              paintSolidColorImageMask() {
                const i = this.svgFactory.createElement("svg:rect");
                i.setAttributeNS(null, "x", "0"), i.setAttributeNS(null, "y", "0"), i.setAttributeNS(null, "width", "1px"), i.setAttributeNS(null, "height", "1px"), i.setAttributeNS(null, "fill", this.current.fillColor), this._ensureTransformGroup().append(i);
              }
              paintImageXObject(i) {
                const l = i.startsWith("g_") ? this.commonObjs.get(i) : this.objs.get(i);
                if (!l) {
                  (0, re.warn)(`Dependent image with object ID ${i} is not ready yet`);
                  return;
                }
                this.paintInlineImageXObject(l);
              }
              paintInlineImageXObject(i, l) {
                const u = i.width, w = i.height, O = e(i, this.forceDataSchema, !!l), b = this.svgFactory.createElement("svg:rect");
                b.setAttributeNS(null, "x", "0"), b.setAttributeNS(null, "y", "0"), b.setAttributeNS(null, "width", d(u)), b.setAttributeNS(null, "height", d(w)), this.current.element = b, this.clip("nonzero");
                const A = this.svgFactory.createElement("svg:image");
                A.setAttributeNS(t, "xlink:href", O), A.setAttributeNS(null, "x", "0"), A.setAttributeNS(null, "y", d(-w)), A.setAttributeNS(null, "width", d(u) + "px"), A.setAttributeNS(null, "height", d(w) + "px"), A.setAttributeNS(null, "transform", `scale(${d(1 / u)} ${d(-1 / w)})`), l ? l.append(A) : this._ensureTransformGroup().append(A);
              }
              paintImageMaskXObject(i) {
                const l = this.current, u = i.width, w = i.height, O = l.fillColor;
                l.maskId = `mask${g++}`;
                const b = this.svgFactory.createElement("svg:mask");
                b.setAttributeNS(null, "id", l.maskId);
                const A = this.svgFactory.createElement("svg:rect");
                A.setAttributeNS(null, "x", "0"), A.setAttributeNS(null, "y", "0"), A.setAttributeNS(null, "width", d(u)), A.setAttributeNS(null, "height", d(w)), A.setAttributeNS(null, "fill", O), A.setAttributeNS(null, "mask", `url(#${l.maskId})`), this.defs.append(b), this._ensureTransformGroup().append(A), this.paintInlineImageXObject(i, b);
              }
              paintFormXObjectBegin(i, l) {
                if (Array.isArray(i) && i.length === 6 && this.transform(i[0], i[1], i[2], i[3], i[4], i[5]), l) {
                  const u = l[2] - l[0], w = l[3] - l[1], O = this.svgFactory.createElement("svg:rect");
                  O.setAttributeNS(null, "x", l[0]), O.setAttributeNS(null, "y", l[1]), O.setAttributeNS(null, "width", d(u)), O.setAttributeNS(null, "height", d(w)), this.current.element = O, this.clip("nonzero"), this.endPath();
                }
              }
              paintFormXObjectEnd() {
              }
              _initialize(i) {
                const l = this.svgFactory.create(i.width, i.height), u = this.svgFactory.createElement("svg:defs");
                l.append(u), this.defs = u;
                const w = this.svgFactory.createElement("svg:g");
                return w.setAttributeNS(null, "transform", m(i.transform)), l.append(w), this.svg = w, l;
              }
              _ensureClipGroup() {
                if (!this.current.clipGroup) {
                  const i = this.svgFactory.createElement("svg:g");
                  i.setAttributeNS(null, "clip-path", this.current.activeClipUrl), this.svg.append(i), this.current.clipGroup = i;
                }
                return this.current.clipGroup;
              }
              _ensureTransformGroup() {
                return this.tgrp || (this.tgrp = this.svgFactory.createElement("svg:g"), this.tgrp.setAttributeNS(null, "transform", m(this.transformMatrix)), this.current.activeClipUrl ? this._ensureClipGroup().append(this.tgrp) : this.svg.append(this.tgrp)), this.tgrp;
              }
            };
          }
        },
        /* 32 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.PDFNodeStream = void 0;
          var ce = le(1), re = le(33);
          const ae = require$$5, J = require$$5, o = require$$5, F = require$$5, t = /^file:\/\/\/[a-zA-Z]:\//;
          function a(g) {
            const n = F.parse(g);
            return n.protocol === "file:" || n.host ? n : /^[a-z]:[/\\]/i.test(g) ? F.parse(`file:///${g}`) : (n.host || (n.protocol = "file:"), n);
          }
          class v {
            constructor(n) {
              this.source = n, this.url = a(n.url), this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:", this.isFsUrl = this.url.protocol === "file:", this.httpHeaders = this.isHttp && n.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
            }
            get _progressiveDataLength() {
              var n;
              return ((n = this._fullRequestReader) == null ? void 0 : n._loaded) ?? 0;
            }
            getFullReader() {
              return (0, ce.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once."), this._fullRequestReader = this.isFsUrl ? new m(this) : new c(this), this._fullRequestReader;
            }
            getRangeReader(n, i) {
              if (i <= this._progressiveDataLength)
                return null;
              const l = this.isFsUrl ? new p(this, n, i) : new d(this, n, i);
              return this._rangeRequestReaders.push(l), l;
            }
            cancelAllRequests(n) {
              this._fullRequestReader && this._fullRequestReader.cancel(n);
              for (const i of this._rangeRequestReaders.slice(0))
                i.cancel(n);
            }
          }
          ge.PDFNodeStream = v;
          class h {
            constructor(n) {
              this._url = n.url, this._done = !1, this._storedError = null, this.onProgress = null;
              const i = n.source;
              this._contentLength = i.length, this._loaded = 0, this._filename = null, this._disableRange = i.disableRange || !1, this._rangeChunkSize = i.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !i.disableStream, this._isRangeSupported = !i.disableRange, this._readableStream = null, this._readCapability = (0, ce.createPromiseCapability)(), this._headersCapability = (0, ce.createPromiseCapability)();
            }
            get headersReady() {
              return this._headersCapability.promise;
            }
            get filename() {
              return this._filename;
            }
            get contentLength() {
              return this._contentLength;
            }
            get isRangeSupported() {
              return this._isRangeSupported;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            async read() {
              if (await this._readCapability.promise, this._done)
                return {
                  value: void 0,
                  done: !0
                };
              if (this._storedError)
                throw this._storedError;
              const n = this._readableStream.read();
              return n === null ? (this._readCapability = (0, ce.createPromiseCapability)(), this.read()) : (this._loaded += n.length, this.onProgress && this.onProgress({
                loaded: this._loaded,
                total: this._contentLength
              }), {
                value: new Uint8Array(n).buffer,
                done: !1
              });
            }
            cancel(n) {
              if (!this._readableStream) {
                this._error(n);
                return;
              }
              this._readableStream.destroy(n);
            }
            _error(n) {
              this._storedError = n, this._readCapability.resolve();
            }
            _setReadableStream(n) {
              this._readableStream = n, n.on("readable", () => {
                this._readCapability.resolve();
              }), n.on("end", () => {
                n.destroy(), this._done = !0, this._readCapability.resolve();
              }), n.on("error", (i) => {
                this._error(i);
              }), !this._isStreamingSupported && this._isRangeSupported && this._error(new ce.AbortException("streaming is disabled")), this._storedError && this._readableStream.destroy(this._storedError);
            }
          }
          class e {
            constructor(n) {
              this._url = n.url, this._done = !1, this._storedError = null, this.onProgress = null, this._loaded = 0, this._readableStream = null, this._readCapability = (0, ce.createPromiseCapability)();
              const i = n.source;
              this._isStreamingSupported = !i.disableStream;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            async read() {
              if (await this._readCapability.promise, this._done)
                return {
                  value: void 0,
                  done: !0
                };
              if (this._storedError)
                throw this._storedError;
              const n = this._readableStream.read();
              return n === null ? (this._readCapability = (0, ce.createPromiseCapability)(), this.read()) : (this._loaded += n.length, this.onProgress && this.onProgress({
                loaded: this._loaded
              }), {
                value: new Uint8Array(n).buffer,
                done: !1
              });
            }
            cancel(n) {
              if (!this._readableStream) {
                this._error(n);
                return;
              }
              this._readableStream.destroy(n);
            }
            _error(n) {
              this._storedError = n, this._readCapability.resolve();
            }
            _setReadableStream(n) {
              this._readableStream = n, n.on("readable", () => {
                this._readCapability.resolve();
              }), n.on("end", () => {
                n.destroy(), this._done = !0, this._readCapability.resolve();
              }), n.on("error", (i) => {
                this._error(i);
              }), this._storedError && this._readableStream.destroy(this._storedError);
            }
          }
          function y(g, n) {
            return {
              protocol: g.protocol,
              auth: g.auth,
              host: g.hostname,
              port: g.port,
              path: g.path,
              method: "GET",
              headers: n
            };
          }
          class c extends h {
            constructor(n) {
              super(n);
              const i = (l) => {
                if (l.statusCode === 404) {
                  const b = new ce.MissingPDFException(`Missing PDF "${this._url}".`);
                  this._storedError = b, this._headersCapability.reject(b);
                  return;
                }
                this._headersCapability.resolve(), this._setReadableStream(l);
                const u = (b) => this._readableStream.headers[b.toLowerCase()], {
                  allowRangeRequests: w,
                  suggestedLength: O
                } = (0, re.validateRangeRequestCapabilities)({
                  getResponseHeader: u,
                  isHttp: n.isHttp,
                  rangeChunkSize: this._rangeChunkSize,
                  disableRange: this._disableRange
                });
                this._isRangeSupported = w, this._contentLength = O || this._contentLength, this._filename = (0, re.extractFilenameFromHeader)(u);
              };
              this._request = null, this._url.protocol === "http:" ? this._request = J.request(y(this._url, n.httpHeaders), i) : this._request = o.request(y(this._url, n.httpHeaders), i), this._request.on("error", (l) => {
                this._storedError = l, this._headersCapability.reject(l);
              }), this._request.end();
            }
          }
          class d extends e {
            constructor(n, i, l) {
              super(n), this._httpHeaders = {};
              for (const w in n.httpHeaders) {
                const O = n.httpHeaders[w];
                typeof O > "u" || (this._httpHeaders[w] = O);
              }
              this._httpHeaders.Range = `bytes=${i}-${l - 1}`;
              const u = (w) => {
                if (w.statusCode === 404) {
                  const O = new ce.MissingPDFException(`Missing PDF "${this._url}".`);
                  this._storedError = O;
                  return;
                }
                this._setReadableStream(w);
              };
              this._request = null, this._url.protocol === "http:" ? this._request = J.request(y(this._url, this._httpHeaders), u) : this._request = o.request(y(this._url, this._httpHeaders), u), this._request.on("error", (w) => {
                this._storedError = w;
              }), this._request.end();
            }
          }
          class m extends h {
            constructor(n) {
              super(n);
              let i = decodeURIComponent(this._url.path);
              t.test(this._url.href) && (i = i.replace(/^\//, "")), ae.lstat(i, (l, u) => {
                if (l) {
                  l.code === "ENOENT" && (l = new ce.MissingPDFException(`Missing PDF "${i}".`)), this._storedError = l, this._headersCapability.reject(l);
                  return;
                }
                this._contentLength = u.size, this._setReadableStream(ae.createReadStream(i)), this._headersCapability.resolve();
              });
            }
          }
          class p extends e {
            constructor(n, i, l) {
              super(n);
              let u = decodeURIComponent(this._url.path);
              t.test(this._url.href) && (u = u.replace(/^\//, "")), this._setReadableStream(ae.createReadStream(u, {
                start: i,
                end: l - 1
              }));
            }
          }
        },
        /* 33 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.createResponseStatusError = F, ge.extractFilenameFromHeader = o, ge.validateRangeRequestCapabilities = J, ge.validateResponseStatus = t;
          var ce = le(1), re = le(34), ae = le(8);
          function J({
            getResponseHeader: a,
            isHttp: v,
            rangeChunkSize: h,
            disableRange: e
          }) {
            const y = {
              allowRangeRequests: !1,
              suggestedLength: void 0
            }, c = parseInt(a("Content-Length"), 10);
            return !Number.isInteger(c) || (y.suggestedLength = c, c <= 2 * h) || e || !v || a("Accept-Ranges") !== "bytes" || (a("Content-Encoding") || "identity") !== "identity" || (y.allowRangeRequests = !0), y;
          }
          function o(a) {
            const v = a("Content-Disposition");
            if (v) {
              let h = (0, re.getFilenameFromContentDispositionHeader)(v);
              if (h.includes("%"))
                try {
                  h = decodeURIComponent(h);
                } catch {
                }
              if ((0, ae.isPdfFile)(h))
                return h;
            }
            return null;
          }
          function F(a, v) {
            return a === 404 || a === 0 && v.startsWith("file:") ? new ce.MissingPDFException('Missing PDF "' + v + '".') : new ce.UnexpectedResponseException(`Unexpected server response (${a}) while retrieving PDF "${v}".`, a);
          }
          function t(a) {
            return a === 200 || a === 206;
          }
        },
        /* 34 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.getFilenameFromContentDispositionHeader = re;
          var ce = le(1);
          function re(ae) {
            let J = !0, o = F("filename\\*", "i").exec(ae);
            if (o) {
              o = o[1];
              let c = h(o);
              return c = unescape(c), c = e(c), c = y(c), a(c);
            }
            if (o = v(ae), o) {
              const c = y(o);
              return a(c);
            }
            if (o = F("filename", "i").exec(ae), o) {
              o = o[1];
              let c = h(o);
              return c = y(c), a(c);
            }
            function F(c, d) {
              return new RegExp("(?:^|;)\\s*" + c + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', d);
            }
            function t(c, d) {
              if (c) {
                if (!/^[\x00-\xFF]+$/.test(d))
                  return d;
                try {
                  const m = new TextDecoder(c, {
                    fatal: !0
                  }), p = (0, ce.stringToBytes)(d);
                  d = m.decode(p), J = !1;
                } catch {
                }
              }
              return d;
            }
            function a(c) {
              return J && /[\x80-\xff]/.test(c) && (c = t("utf-8", c), J && (c = t("iso-8859-1", c))), c;
            }
            function v(c) {
              const d = [];
              let m;
              const p = F("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
              for (; (m = p.exec(c)) !== null; ) {
                let [, n, i, l] = m;
                if (n = parseInt(n, 10), n in d) {
                  if (n === 0)
                    break;
                  continue;
                }
                d[n] = [i, l];
              }
              const g = [];
              for (let n = 0; n < d.length && n in d; ++n) {
                let [i, l] = d[n];
                l = h(l), i && (l = unescape(l), n === 0 && (l = e(l))), g.push(l);
              }
              return g.join("");
            }
            function h(c) {
              if (c.startsWith('"')) {
                const d = c.slice(1).split('\\"');
                for (let m = 0; m < d.length; ++m) {
                  const p = d[m].indexOf('"');
                  p !== -1 && (d[m] = d[m].slice(0, p), d.length = m + 1), d[m] = d[m].replace(/\\(.)/g, "$1");
                }
                c = d.join('"');
              }
              return c;
            }
            function e(c) {
              const d = c.indexOf("'");
              if (d === -1)
                return c;
              const m = c.slice(0, d), g = c.slice(d + 1).replace(/^[^']*'/, "");
              return t(m, g);
            }
            function y(c) {
              return !c.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(c) ? c : c.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(d, m, p, g) {
                if (p === "q" || p === "Q")
                  return g = g.replace(/_/g, " "), g = g.replace(/=([0-9a-fA-F]{2})/g, function(n, i) {
                    return String.fromCharCode(parseInt(i, 16));
                  }), t(m, g);
                try {
                  g = atob(g);
                } catch {
                }
                return t(m, g);
              });
            }
            return "";
          }
        },
        /* 35 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.PDFNetworkStream = void 0;
          var ce = le(1), re = le(33);
          const ae = 200, J = 206;
          function o(h) {
            const e = h.response;
            return typeof e != "string" ? e : (0, ce.stringToBytes)(e).buffer;
          }
          class F {
            constructor(e, y = {}) {
              this.url = e, this.isHttp = /^https?:/i.test(e), this.httpHeaders = this.isHttp && y.httpHeaders || /* @__PURE__ */ Object.create(null), this.withCredentials = y.withCredentials || !1, this.getXhr = y.getXhr || function() {
                return new XMLHttpRequest();
              }, this.currXhrId = 0, this.pendingRequests = /* @__PURE__ */ Object.create(null);
            }
            requestRange(e, y, c) {
              const d = {
                begin: e,
                end: y
              };
              for (const m in c)
                d[m] = c[m];
              return this.request(d);
            }
            requestFull(e) {
              return this.request(e);
            }
            request(e) {
              const y = this.getXhr(), c = this.currXhrId++, d = this.pendingRequests[c] = {
                xhr: y
              };
              y.open("GET", this.url), y.withCredentials = this.withCredentials;
              for (const m in this.httpHeaders) {
                const p = this.httpHeaders[m];
                typeof p > "u" || y.setRequestHeader(m, p);
              }
              return this.isHttp && "begin" in e && "end" in e ? (y.setRequestHeader("Range", `bytes=${e.begin}-${e.end - 1}`), d.expectedStatus = J) : d.expectedStatus = ae, y.responseType = "arraybuffer", e.onError && (y.onerror = function(m) {
                e.onError(y.status);
              }), y.onreadystatechange = this.onStateChange.bind(this, c), y.onprogress = this.onProgress.bind(this, c), d.onHeadersReceived = e.onHeadersReceived, d.onDone = e.onDone, d.onError = e.onError, d.onProgress = e.onProgress, y.send(null), c;
            }
            onProgress(e, y) {
              var d;
              const c = this.pendingRequests[e];
              c && ((d = c.onProgress) == null || d.call(c, y));
            }
            onStateChange(e, y) {
              var n, i, l;
              const c = this.pendingRequests[e];
              if (!c)
                return;
              const d = c.xhr;
              if (d.readyState >= 2 && c.onHeadersReceived && (c.onHeadersReceived(), delete c.onHeadersReceived), d.readyState !== 4 || !(e in this.pendingRequests))
                return;
              if (delete this.pendingRequests[e], d.status === 0 && this.isHttp) {
                (n = c.onError) == null || n.call(c, d.status);
                return;
              }
              const m = d.status || ae;
              if (!(m === ae && c.expectedStatus === J) && m !== c.expectedStatus) {
                (i = c.onError) == null || i.call(c, d.status);
                return;
              }
              const g = o(d);
              if (m === J) {
                const u = d.getResponseHeader("Content-Range"), w = /bytes (\d+)-(\d+)\/(\d+)/.exec(u);
                c.onDone({
                  begin: parseInt(w[1], 10),
                  chunk: g
                });
              } else
                g ? c.onDone({
                  begin: 0,
                  chunk: g
                }) : (l = c.onError) == null || l.call(c, d.status);
            }
            getRequestXhr(e) {
              return this.pendingRequests[e].xhr;
            }
            isPendingRequest(e) {
              return e in this.pendingRequests;
            }
            abortRequest(e) {
              const y = this.pendingRequests[e].xhr;
              delete this.pendingRequests[e], y.abort();
            }
          }
          class t {
            constructor(e) {
              this._source = e, this._manager = new F(e.url, {
                httpHeaders: e.httpHeaders,
                withCredentials: e.withCredentials
              }), this._rangeChunkSize = e.rangeChunkSize, this._fullRequestReader = null, this._rangeRequestReaders = [];
            }
            _onRangeRequestReaderClosed(e) {
              const y = this._rangeRequestReaders.indexOf(e);
              y >= 0 && this._rangeRequestReaders.splice(y, 1);
            }
            getFullReader() {
              return (0, ce.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once."), this._fullRequestReader = new a(this._manager, this._source), this._fullRequestReader;
            }
            getRangeReader(e, y) {
              const c = new v(this._manager, e, y);
              return c.onClosed = this._onRangeRequestReaderClosed.bind(this), this._rangeRequestReaders.push(c), c;
            }
            cancelAllRequests(e) {
              var y;
              (y = this._fullRequestReader) == null || y.cancel(e);
              for (const c of this._rangeRequestReaders.slice(0))
                c.cancel(e);
            }
          }
          ge.PDFNetworkStream = t;
          class a {
            constructor(e, y) {
              this._manager = e;
              const c = {
                onHeadersReceived: this._onHeadersReceived.bind(this),
                onDone: this._onDone.bind(this),
                onError: this._onError.bind(this),
                onProgress: this._onProgress.bind(this)
              };
              this._url = y.url, this._fullRequestId = e.requestFull(c), this._headersReceivedCapability = (0, ce.createPromiseCapability)(), this._disableRange = y.disableRange || !1, this._contentLength = y.length, this._rangeChunkSize = y.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !1, this._isRangeSupported = !1, this._cachedChunks = [], this._requests = [], this._done = !1, this._storedError = void 0, this._filename = null, this.onProgress = null;
            }
            _onHeadersReceived() {
              const e = this._fullRequestId, y = this._manager.getRequestXhr(e), c = (p) => y.getResponseHeader(p), {
                allowRangeRequests: d,
                suggestedLength: m
              } = (0, re.validateRangeRequestCapabilities)({
                getResponseHeader: c,
                isHttp: this._manager.isHttp,
                rangeChunkSize: this._rangeChunkSize,
                disableRange: this._disableRange
              });
              d && (this._isRangeSupported = !0), this._contentLength = m || this._contentLength, this._filename = (0, re.extractFilenameFromHeader)(c), this._isRangeSupported && this._manager.abortRequest(e), this._headersReceivedCapability.resolve();
            }
            _onDone(e) {
              if (e && (this._requests.length > 0 ? this._requests.shift().resolve({
                value: e.chunk,
                done: !1
              }) : this._cachedChunks.push(e.chunk)), this._done = !0, !(this._cachedChunks.length > 0)) {
                for (const y of this._requests)
                  y.resolve({
                    value: void 0,
                    done: !0
                  });
                this._requests.length = 0;
              }
            }
            _onError(e) {
              this._storedError = (0, re.createResponseStatusError)(e, this._url), this._headersReceivedCapability.reject(this._storedError);
              for (const y of this._requests)
                y.reject(this._storedError);
              this._requests.length = 0, this._cachedChunks.length = 0;
            }
            _onProgress(e) {
              var y;
              (y = this.onProgress) == null || y.call(this, {
                loaded: e.loaded,
                total: e.lengthComputable ? e.total : this._contentLength
              });
            }
            get filename() {
              return this._filename;
            }
            get isRangeSupported() {
              return this._isRangeSupported;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            get contentLength() {
              return this._contentLength;
            }
            get headersReady() {
              return this._headersReceivedCapability.promise;
            }
            async read() {
              if (this._storedError)
                throw this._storedError;
              if (this._cachedChunks.length > 0)
                return {
                  value: this._cachedChunks.shift(),
                  done: !1
                };
              if (this._done)
                return {
                  value: void 0,
                  done: !0
                };
              const e = (0, ce.createPromiseCapability)();
              return this._requests.push(e), e.promise;
            }
            cancel(e) {
              this._done = !0, this._headersReceivedCapability.reject(e);
              for (const y of this._requests)
                y.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0, this._manager.isPendingRequest(this._fullRequestId) && this._manager.abortRequest(this._fullRequestId), this._fullRequestReader = null;
            }
          }
          class v {
            constructor(e, y, c) {
              this._manager = e;
              const d = {
                onDone: this._onDone.bind(this),
                onError: this._onError.bind(this),
                onProgress: this._onProgress.bind(this)
              };
              this._url = e.url, this._requestId = e.requestRange(y, c, d), this._requests = [], this._queuedChunk = null, this._done = !1, this._storedError = void 0, this.onProgress = null, this.onClosed = null;
            }
            _close() {
              var e;
              (e = this.onClosed) == null || e.call(this, this);
            }
            _onDone(e) {
              const y = e.chunk;
              this._requests.length > 0 ? this._requests.shift().resolve({
                value: y,
                done: !1
              }) : this._queuedChunk = y, this._done = !0;
              for (const c of this._requests)
                c.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0, this._close();
            }
            _onError(e) {
              this._storedError = (0, re.createResponseStatusError)(e, this._url);
              for (const y of this._requests)
                y.reject(this._storedError);
              this._requests.length = 0, this._queuedChunk = null;
            }
            _onProgress(e) {
              var y;
              this.isStreamingSupported || (y = this.onProgress) == null || y.call(this, {
                loaded: e.loaded
              });
            }
            get isStreamingSupported() {
              return !1;
            }
            async read() {
              if (this._storedError)
                throw this._storedError;
              if (this._queuedChunk !== null) {
                const y = this._queuedChunk;
                return this._queuedChunk = null, {
                  value: y,
                  done: !1
                };
              }
              if (this._done)
                return {
                  value: void 0,
                  done: !0
                };
              const e = (0, ce.createPromiseCapability)();
              return this._requests.push(e), e.promise;
            }
            cancel(e) {
              this._done = !0;
              for (const y of this._requests)
                y.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0, this._manager.isPendingRequest(this._requestId) && this._manager.abortRequest(this._requestId), this._close();
            }
          }
        },
        /* 36 */
        /***/
        (be, ge, le) => {
          Object.defineProperty(ge, "__esModule", {
            value: !0
          }), ge.PDFFetchStream = void 0;
          var ce = le(1), re = le(33);
          function ae(a, v, h) {
            return {
              method: "GET",
              headers: a,
              signal: h.signal,
              mode: "cors",
              credentials: v ? "include" : "same-origin",
              redirect: "follow"
            };
          }
          function J(a) {
            const v = new Headers();
            for (const h in a) {
              const e = a[h];
              typeof e > "u" || v.append(h, e);
            }
            return v;
          }
          class o {
            constructor(v) {
              this.source = v, this.isHttp = /^https?:/i.test(v.url), this.httpHeaders = this.isHttp && v.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
            }
            get _progressiveDataLength() {
              var v;
              return ((v = this._fullRequestReader) == null ? void 0 : v._loaded) ?? 0;
            }
            getFullReader() {
              return (0, ce.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once."), this._fullRequestReader = new F(this), this._fullRequestReader;
            }
            getRangeReader(v, h) {
              if (h <= this._progressiveDataLength)
                return null;
              const e = new t(this, v, h);
              return this._rangeRequestReaders.push(e), e;
            }
            cancelAllRequests(v) {
              this._fullRequestReader && this._fullRequestReader.cancel(v);
              for (const h of this._rangeRequestReaders.slice(0))
                h.cancel(v);
            }
          }
          ge.PDFFetchStream = o;
          class F {
            constructor(v) {
              this._stream = v, this._reader = null, this._loaded = 0, this._filename = null;
              const h = v.source;
              this._withCredentials = h.withCredentials || !1, this._contentLength = h.length, this._headersCapability = (0, ce.createPromiseCapability)(), this._disableRange = h.disableRange || !1, this._rangeChunkSize = h.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._abortController = new AbortController(), this._isStreamingSupported = !h.disableStream, this._isRangeSupported = !h.disableRange, this._headers = J(this._stream.httpHeaders);
              const e = h.url;
              fetch(e, ae(this._headers, this._withCredentials, this._abortController)).then((y) => {
                if (!(0, re.validateResponseStatus)(y.status))
                  throw (0, re.createResponseStatusError)(y.status, e);
                this._reader = y.body.getReader(), this._headersCapability.resolve();
                const c = (p) => y.headers.get(p), {
                  allowRangeRequests: d,
                  suggestedLength: m
                } = (0, re.validateRangeRequestCapabilities)({
                  getResponseHeader: c,
                  isHttp: this._stream.isHttp,
                  rangeChunkSize: this._rangeChunkSize,
                  disableRange: this._disableRange
                });
                this._isRangeSupported = d, this._contentLength = m || this._contentLength, this._filename = (0, re.extractFilenameFromHeader)(c), !this._isStreamingSupported && this._isRangeSupported && this.cancel(new ce.AbortException("Streaming is disabled."));
              }).catch(this._headersCapability.reject), this.onProgress = null;
            }
            get headersReady() {
              return this._headersCapability.promise;
            }
            get filename() {
              return this._filename;
            }
            get contentLength() {
              return this._contentLength;
            }
            get isRangeSupported() {
              return this._isRangeSupported;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            async read() {
              await this._headersCapability.promise;
              const {
                value: v,
                done: h
              } = await this._reader.read();
              return h ? {
                value: v,
                done: h
              } : (this._loaded += v.byteLength, this.onProgress && this.onProgress({
                loaded: this._loaded,
                total: this._contentLength
              }), {
                value: new Uint8Array(v).buffer,
                done: !1
              });
            }
            cancel(v) {
              this._reader && this._reader.cancel(v), this._abortController.abort();
            }
          }
          class t {
            constructor(v, h, e) {
              this._stream = v, this._reader = null, this._loaded = 0;
              const y = v.source;
              this._withCredentials = y.withCredentials || !1, this._readCapability = (0, ce.createPromiseCapability)(), this._isStreamingSupported = !y.disableStream, this._abortController = new AbortController(), this._headers = J(this._stream.httpHeaders), this._headers.append("Range", `bytes=${h}-${e - 1}`);
              const c = y.url;
              fetch(c, ae(this._headers, this._withCredentials, this._abortController)).then((d) => {
                if (!(0, re.validateResponseStatus)(d.status))
                  throw (0, re.createResponseStatusError)(d.status, c);
                this._readCapability.resolve(), this._reader = d.body.getReader();
              }).catch(this._readCapability.reject), this.onProgress = null;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            async read() {
              await this._readCapability.promise;
              const {
                value: v,
                done: h
              } = await this._reader.read();
              return h ? {
                value: v,
                done: h
              } : (this._loaded += v.byteLength, this.onProgress && this.onProgress({
                loaded: this._loaded
              }), {
                value: new Uint8Array(v).buffer,
                done: !1
              });
            }
            cancel(v) {
              this._reader && this._reader.cancel(v), this._abortController.abort();
            }
          }
        }
        /******/
      ], __webpack_module_cache__ = {};
      function __w_pdfjs_require__(be) {
        var ge = __webpack_module_cache__[be];
        if (ge !== void 0)
          return ge.exports;
        var le = __webpack_module_cache__[be] = {
          /******/
          // no module.id needed
          /******/
          // no module.loaded needed
          /******/
          exports: {}
          /******/
        };
        return __webpack_modules__[be](le, le.exports, __w_pdfjs_require__), le.exports;
      }
      var __webpack_exports__ = {};
      return (() => {
        var be = __webpack_exports__;
        Object.defineProperty(be, "__esModule", {
          value: !0
        }), Object.defineProperty(be, "AnnotationEditorLayer", {
          enumerable: !0,
          get: function() {
            return re.AnnotationEditorLayer;
          }
        }), Object.defineProperty(be, "AnnotationEditorParamsType", {
          enumerable: !0,
          get: function() {
            return ge.AnnotationEditorParamsType;
          }
        }), Object.defineProperty(be, "AnnotationEditorType", {
          enumerable: !0,
          get: function() {
            return ge.AnnotationEditorType;
          }
        }), Object.defineProperty(be, "AnnotationEditorUIManager", {
          enumerable: !0,
          get: function() {
            return ae.AnnotationEditorUIManager;
          }
        }), Object.defineProperty(be, "AnnotationLayer", {
          enumerable: !0,
          get: function() {
            return J.AnnotationLayer;
          }
        }), Object.defineProperty(be, "AnnotationMode", {
          enumerable: !0,
          get: function() {
            return ge.AnnotationMode;
          }
        }), Object.defineProperty(be, "CMapCompressionType", {
          enumerable: !0,
          get: function() {
            return ge.CMapCompressionType;
          }
        }), Object.defineProperty(be, "GlobalWorkerOptions", {
          enumerable: !0,
          get: function() {
            return o.GlobalWorkerOptions;
          }
        }), Object.defineProperty(be, "InvalidPDFException", {
          enumerable: !0,
          get: function() {
            return ge.InvalidPDFException;
          }
        }), Object.defineProperty(be, "LoopbackPort", {
          enumerable: !0,
          get: function() {
            return le.LoopbackPort;
          }
        }), Object.defineProperty(be, "MissingPDFException", {
          enumerable: !0,
          get: function() {
            return ge.MissingPDFException;
          }
        }), Object.defineProperty(be, "OPS", {
          enumerable: !0,
          get: function() {
            return ge.OPS;
          }
        }), Object.defineProperty(be, "PDFDataRangeTransport", {
          enumerable: !0,
          get: function() {
            return le.PDFDataRangeTransport;
          }
        }), Object.defineProperty(be, "PDFDateString", {
          enumerable: !0,
          get: function() {
            return ce.PDFDateString;
          }
        }), Object.defineProperty(be, "PDFWorker", {
          enumerable: !0,
          get: function() {
            return le.PDFWorker;
          }
        }), Object.defineProperty(be, "PasswordResponses", {
          enumerable: !0,
          get: function() {
            return ge.PasswordResponses;
          }
        }), Object.defineProperty(be, "PermissionFlag", {
          enumerable: !0,
          get: function() {
            return ge.PermissionFlag;
          }
        }), Object.defineProperty(be, "PixelsPerInch", {
          enumerable: !0,
          get: function() {
            return ce.PixelsPerInch;
          }
        }), Object.defineProperty(be, "RenderingCancelledException", {
          enumerable: !0,
          get: function() {
            return ce.RenderingCancelledException;
          }
        }), Object.defineProperty(be, "SVGGraphics", {
          enumerable: !0,
          get: function() {
            return a.SVGGraphics;
          }
        }), Object.defineProperty(be, "UNSUPPORTED_FEATURES", {
          enumerable: !0,
          get: function() {
            return ge.UNSUPPORTED_FEATURES;
          }
        }), Object.defineProperty(be, "UnexpectedResponseException", {
          enumerable: !0,
          get: function() {
            return ge.UnexpectedResponseException;
          }
        }), Object.defineProperty(be, "Util", {
          enumerable: !0,
          get: function() {
            return ge.Util;
          }
        }), Object.defineProperty(be, "VerbosityLevel", {
          enumerable: !0,
          get: function() {
            return ge.VerbosityLevel;
          }
        }), Object.defineProperty(be, "XfaLayer", {
          enumerable: !0,
          get: function() {
            return v.XfaLayer;
          }
        }), Object.defineProperty(be, "build", {
          enumerable: !0,
          get: function() {
            return le.build;
          }
        }), Object.defineProperty(be, "createPromiseCapability", {
          enumerable: !0,
          get: function() {
            return ge.createPromiseCapability;
          }
        }), Object.defineProperty(be, "createValidAbsoluteUrl", {
          enumerable: !0,
          get: function() {
            return ge.createValidAbsoluteUrl;
          }
        }), Object.defineProperty(be, "getDocument", {
          enumerable: !0,
          get: function() {
            return le.getDocument;
          }
        }), Object.defineProperty(be, "getFilenameFromUrl", {
          enumerable: !0,
          get: function() {
            return ce.getFilenameFromUrl;
          }
        }), Object.defineProperty(be, "getPdfFilenameFromUrl", {
          enumerable: !0,
          get: function() {
            return ce.getPdfFilenameFromUrl;
          }
        }), Object.defineProperty(be, "getXfaPageViewport", {
          enumerable: !0,
          get: function() {
            return ce.getXfaPageViewport;
          }
        }), Object.defineProperty(be, "isPdfFile", {
          enumerable: !0,
          get: function() {
            return ce.isPdfFile;
          }
        }), Object.defineProperty(be, "loadScript", {
          enumerable: !0,
          get: function() {
            return ce.loadScript;
          }
        }), Object.defineProperty(be, "renderTextLayer", {
          enumerable: !0,
          get: function() {
            return t.renderTextLayer;
          }
        }), Object.defineProperty(be, "shadow", {
          enumerable: !0,
          get: function() {
            return ge.shadow;
          }
        }), Object.defineProperty(be, "version", {
          enumerable: !0,
          get: function() {
            return le.version;
          }
        });
        var ge = __w_pdfjs_require__(1), le = __w_pdfjs_require__(4), ce = __w_pdfjs_require__(8), re = __w_pdfjs_require__(22), ae = __w_pdfjs_require__(7), J = __w_pdfjs_require__(27), o = __w_pdfjs_require__(15), F = __w_pdfjs_require__(3), t = __w_pdfjs_require__(30), a = __w_pdfjs_require__(31), v = __w_pdfjs_require__(29);
        if (F.isNodeJS) {
          const {
            PDFNodeStream: h
          } = __w_pdfjs_require__(32);
          (0, le.setPDFNetworkStreamFactory)((e) => new h(e));
        } else {
          const {
            PDFNetworkStream: h
          } = __w_pdfjs_require__(35), {
            PDFFetchStream: e
          } = __w_pdfjs_require__(36);
          (0, le.setPDFNetworkStreamFactory)((y) => (0, ce.isValidFetchUrl)(y.url) ? new e(y) : new h(y));
        }
      })(), __webpack_exports__;
    })()
  ));
})(pdf);
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(be) {
    for (var ge = 1; ge < arguments.length; ge++) {
      var le = arguments[ge];
      for (var ce in le)
        Object.prototype.hasOwnProperty.call(le, ce) && (be[ce] = le[ce]);
    }
    return be;
  }, _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(be, ge) {
  if (be == null)
    return {};
  var le = {}, ce = Object.keys(be), re, ae;
  for (ae = 0; ae < ce.length; ae++)
    re = ce[ae], !(ge.indexOf(re) >= 0) && (le[re] = be[re]);
  return le;
}
function _objectWithoutProperties(be, ge) {
  if (be == null)
    return {};
  var le = _objectWithoutPropertiesLoose(be, ge), ce, re;
  if (Object.getOwnPropertySymbols) {
    var ae = Object.getOwnPropertySymbols(be);
    for (re = 0; re < ae.length; re++)
      ce = ae[re], !(ge.indexOf(ce) >= 0) && Object.prototype.propertyIsEnumerable.call(be, ce) && (le[ce] = be[ce]);
  }
  return le;
}
function _typeof(be) {
  return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ge) {
    return typeof ge;
  } : function(ge) {
    return ge && typeof Symbol == "function" && ge.constructor === Symbol && ge !== Symbol.prototype ? "symbol" : typeof ge;
  }, _typeof(be);
}
function _classCallCheck(be, ge) {
  if (!(be instanceof ge))
    throw new TypeError("Cannot call a class as a function");
}
function _toPrimitive(be, ge) {
  if (_typeof(be) !== "object" || be === null)
    return be;
  var le = be[Symbol.toPrimitive];
  if (le !== void 0) {
    var ce = le.call(be, ge || "default");
    if (_typeof(ce) !== "object")
      return ce;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (ge === "string" ? String : Number)(be);
}
function _toPropertyKey(be) {
  var ge = _toPrimitive(be, "string");
  return _typeof(ge) === "symbol" ? ge : String(ge);
}
function _defineProperties(be, ge) {
  for (var le = 0; le < ge.length; le++) {
    var ce = ge[le];
    ce.enumerable = ce.enumerable || !1, ce.configurable = !0, "value" in ce && (ce.writable = !0), Object.defineProperty(be, _toPropertyKey(ce.key), ce);
  }
}
function _createClass(be, ge, le) {
  return ge && _defineProperties(be.prototype, ge), le && _defineProperties(be, le), Object.defineProperty(be, "prototype", {
    writable: !1
  }), be;
}
function _assertThisInitialized(be) {
  if (be === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return be;
}
function _setPrototypeOf(be, ge) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(ce, re) {
    return ce.__proto__ = re, ce;
  }, _setPrototypeOf(be, ge);
}
function _inherits(be, ge) {
  if (typeof ge != "function" && ge !== null)
    throw new TypeError("Super expression must either be null or a function");
  be.prototype = Object.create(ge && ge.prototype, {
    constructor: {
      value: be,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(be, "prototype", {
    writable: !1
  }), ge && _setPrototypeOf(be, ge);
}
function _possibleConstructorReturn(be, ge) {
  if (ge && (_typeof(ge) === "object" || typeof ge == "function"))
    return ge;
  if (ge !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(be);
}
function _getPrototypeOf(be) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(le) {
    return le.__proto__ || Object.getPrototypeOf(le);
  }, _getPrototypeOf(be);
}
function _defineProperty(be, ge, le) {
  return ge = _toPropertyKey(ge), ge in be ? Object.defineProperty(be, ge, {
    value: le,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : be[ge] = le, be;
}
var propTypesExports = {}, propTypes = {
  get exports() {
    return propTypesExports;
  },
  set exports(be) {
    propTypesExports = be;
  }
}, reactIsExports = {}, reactIs = {
  get exports() {
    return reactIsExports;
  },
  set exports(be) {
    reactIsExports = be;
  }
}, reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
  if (hasRequiredReactIs_production_min)
    return reactIs_production_min;
  hasRequiredReactIs_production_min = 1;
  var be = typeof Symbol == "function" && Symbol.for, ge = be ? Symbol.for("react.element") : 60103, le = be ? Symbol.for("react.portal") : 60106, ce = be ? Symbol.for("react.fragment") : 60107, re = be ? Symbol.for("react.strict_mode") : 60108, ae = be ? Symbol.for("react.profiler") : 60114, J = be ? Symbol.for("react.provider") : 60109, o = be ? Symbol.for("react.context") : 60110, F = be ? Symbol.for("react.async_mode") : 60111, t = be ? Symbol.for("react.concurrent_mode") : 60111, a = be ? Symbol.for("react.forward_ref") : 60112, v = be ? Symbol.for("react.suspense") : 60113, h = be ? Symbol.for("react.suspense_list") : 60120, e = be ? Symbol.for("react.memo") : 60115, y = be ? Symbol.for("react.lazy") : 60116, c = be ? Symbol.for("react.block") : 60121, d = be ? Symbol.for("react.fundamental") : 60117, m = be ? Symbol.for("react.responder") : 60118, p = be ? Symbol.for("react.scope") : 60119;
  function g(i) {
    if (typeof i == "object" && i !== null) {
      var l = i.$$typeof;
      switch (l) {
        case ge:
          switch (i = i.type, i) {
            case F:
            case t:
            case ce:
            case ae:
            case re:
            case v:
              return i;
            default:
              switch (i = i && i.$$typeof, i) {
                case o:
                case a:
                case y:
                case e:
                case J:
                  return i;
                default:
                  return l;
              }
          }
        case le:
          return l;
      }
    }
  }
  function n(i) {
    return g(i) === t;
  }
  return reactIs_production_min.AsyncMode = F, reactIs_production_min.ConcurrentMode = t, reactIs_production_min.ContextConsumer = o, reactIs_production_min.ContextProvider = J, reactIs_production_min.Element = ge, reactIs_production_min.ForwardRef = a, reactIs_production_min.Fragment = ce, reactIs_production_min.Lazy = y, reactIs_production_min.Memo = e, reactIs_production_min.Portal = le, reactIs_production_min.Profiler = ae, reactIs_production_min.StrictMode = re, reactIs_production_min.Suspense = v, reactIs_production_min.isAsyncMode = function(i) {
    return n(i) || g(i) === F;
  }, reactIs_production_min.isConcurrentMode = n, reactIs_production_min.isContextConsumer = function(i) {
    return g(i) === o;
  }, reactIs_production_min.isContextProvider = function(i) {
    return g(i) === J;
  }, reactIs_production_min.isElement = function(i) {
    return typeof i == "object" && i !== null && i.$$typeof === ge;
  }, reactIs_production_min.isForwardRef = function(i) {
    return g(i) === a;
  }, reactIs_production_min.isFragment = function(i) {
    return g(i) === ce;
  }, reactIs_production_min.isLazy = function(i) {
    return g(i) === y;
  }, reactIs_production_min.isMemo = function(i) {
    return g(i) === e;
  }, reactIs_production_min.isPortal = function(i) {
    return g(i) === le;
  }, reactIs_production_min.isProfiler = function(i) {
    return g(i) === ae;
  }, reactIs_production_min.isStrictMode = function(i) {
    return g(i) === re;
  }, reactIs_production_min.isSuspense = function(i) {
    return g(i) === v;
  }, reactIs_production_min.isValidElementType = function(i) {
    return typeof i == "string" || typeof i == "function" || i === ce || i === t || i === ae || i === re || i === v || i === h || typeof i == "object" && i !== null && (i.$$typeof === y || i.$$typeof === e || i.$$typeof === J || i.$$typeof === o || i.$$typeof === a || i.$$typeof === d || i.$$typeof === m || i.$$typeof === p || i.$$typeof === c);
  }, reactIs_production_min.typeOf = g, reactIs_production_min;
}
var reactIs_development = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_development;
function requireReactIs_development() {
  return hasRequiredReactIs_development || (hasRequiredReactIs_development = 1, process.env.NODE_ENV !== "production" && function() {
    var be = typeof Symbol == "function" && Symbol.for, ge = be ? Symbol.for("react.element") : 60103, le = be ? Symbol.for("react.portal") : 60106, ce = be ? Symbol.for("react.fragment") : 60107, re = be ? Symbol.for("react.strict_mode") : 60108, ae = be ? Symbol.for("react.profiler") : 60114, J = be ? Symbol.for("react.provider") : 60109, o = be ? Symbol.for("react.context") : 60110, F = be ? Symbol.for("react.async_mode") : 60111, t = be ? Symbol.for("react.concurrent_mode") : 60111, a = be ? Symbol.for("react.forward_ref") : 60112, v = be ? Symbol.for("react.suspense") : 60113, h = be ? Symbol.for("react.suspense_list") : 60120, e = be ? Symbol.for("react.memo") : 60115, y = be ? Symbol.for("react.lazy") : 60116, c = be ? Symbol.for("react.block") : 60121, d = be ? Symbol.for("react.fundamental") : 60117, m = be ? Symbol.for("react.responder") : 60118, p = be ? Symbol.for("react.scope") : 60119;
    function g(L) {
      return typeof L == "string" || typeof L == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      L === ce || L === t || L === ae || L === re || L === v || L === h || typeof L == "object" && L !== null && (L.$$typeof === y || L.$$typeof === e || L.$$typeof === J || L.$$typeof === o || L.$$typeof === a || L.$$typeof === d || L.$$typeof === m || L.$$typeof === p || L.$$typeof === c);
    }
    function n(L) {
      if (typeof L == "object" && L !== null) {
        var K = L.$$typeof;
        switch (K) {
          case ge:
            var ne = L.type;
            switch (ne) {
              case F:
              case t:
              case ce:
              case ae:
              case re:
              case v:
                return ne;
              default:
                var se = ne && ne.$$typeof;
                switch (se) {
                  case o:
                  case a:
                  case y:
                  case e:
                  case J:
                    return se;
                  default:
                    return K;
                }
            }
          case le:
            return K;
        }
      }
    }
    var i = F, l = t, u = o, w = J, O = ge, b = a, A = ce, Y = y, j = e, X = le, B = ae, U = re, k = v, x = !1;
    function f(L) {
      return x || (x = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), D(L) || n(L) === F;
    }
    function D(L) {
      return n(L) === t;
    }
    function _(L) {
      return n(L) === o;
    }
    function S(L) {
      return n(L) === J;
    }
    function C(L) {
      return typeof L == "object" && L !== null && L.$$typeof === ge;
    }
    function T(L) {
      return n(L) === a;
    }
    function P(L) {
      return n(L) === ce;
    }
    function M(L) {
      return n(L) === y;
    }
    function G(L) {
      return n(L) === e;
    }
    function Z(L) {
      return n(L) === le;
    }
    function $(L) {
      return n(L) === ae;
    }
    function z(L) {
      return n(L) === re;
    }
    function V(L) {
      return n(L) === v;
    }
    reactIs_development.AsyncMode = i, reactIs_development.ConcurrentMode = l, reactIs_development.ContextConsumer = u, reactIs_development.ContextProvider = w, reactIs_development.Element = O, reactIs_development.ForwardRef = b, reactIs_development.Fragment = A, reactIs_development.Lazy = Y, reactIs_development.Memo = j, reactIs_development.Portal = X, reactIs_development.Profiler = B, reactIs_development.StrictMode = U, reactIs_development.Suspense = k, reactIs_development.isAsyncMode = f, reactIs_development.isConcurrentMode = D, reactIs_development.isContextConsumer = _, reactIs_development.isContextProvider = S, reactIs_development.isElement = C, reactIs_development.isForwardRef = T, reactIs_development.isFragment = P, reactIs_development.isLazy = M, reactIs_development.isMemo = G, reactIs_development.isPortal = Z, reactIs_development.isProfiler = $, reactIs_development.isStrictMode = z, reactIs_development.isSuspense = V, reactIs_development.isValidElementType = g, reactIs_development.typeOf = n;
  }()), reactIs_development;
}
var hasRequiredReactIs;
function requireReactIs() {
  return hasRequiredReactIs || (hasRequiredReactIs = 1, function(be) {
    process.env.NODE_ENV === "production" ? be.exports = requireReactIs_production_min() : be.exports = requireReactIs_development();
  }(reactIs)), reactIsExports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var objectAssign, hasRequiredObjectAssign;
function requireObjectAssign() {
  if (hasRequiredObjectAssign)
    return objectAssign;
  hasRequiredObjectAssign = 1;
  var be = Object.getOwnPropertySymbols, ge = Object.prototype.hasOwnProperty, le = Object.prototype.propertyIsEnumerable;
  function ce(ae) {
    if (ae == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(ae);
  }
  function re() {
    try {
      if (!Object.assign)
        return !1;
      var ae = new String("abc");
      if (ae[5] = "de", Object.getOwnPropertyNames(ae)[0] === "5")
        return !1;
      for (var J = {}, o = 0; o < 10; o++)
        J["_" + String.fromCharCode(o)] = o;
      var F = Object.getOwnPropertyNames(J).map(function(a) {
        return J[a];
      });
      if (F.join("") !== "0123456789")
        return !1;
      var t = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(a) {
        t[a] = a;
      }), Object.keys(Object.assign({}, t)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return objectAssign = re() ? Object.assign : function(ae, J) {
    for (var o, F = ce(ae), t, a = 1; a < arguments.length; a++) {
      o = Object(arguments[a]);
      for (var v in o)
        ge.call(o, v) && (F[v] = o[v]);
      if (be) {
        t = be(o);
        for (var h = 0; h < t.length; h++)
          le.call(o, t[h]) && (F[t[h]] = o[t[h]]);
      }
    }
    return F;
  }, objectAssign;
}
var ReactPropTypesSecret_1, hasRequiredReactPropTypesSecret;
function requireReactPropTypesSecret() {
  if (hasRequiredReactPropTypesSecret)
    return ReactPropTypesSecret_1;
  hasRequiredReactPropTypesSecret = 1;
  var be = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return ReactPropTypesSecret_1 = be, ReactPropTypesSecret_1;
}
var has, hasRequiredHas;
function requireHas() {
  return hasRequiredHas || (hasRequiredHas = 1, has = Function.call.bind(Object.prototype.hasOwnProperty)), has;
}
var checkPropTypes_1, hasRequiredCheckPropTypes;
function requireCheckPropTypes() {
  if (hasRequiredCheckPropTypes)
    return checkPropTypes_1;
  hasRequiredCheckPropTypes = 1;
  var be = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var ge = requireReactPropTypesSecret(), le = {}, ce = requireHas();
    be = function(ae) {
      var J = "Warning: " + ae;
      typeof console < "u" && console.error(J);
      try {
        throw new Error(J);
      } catch {
      }
    };
  }
  function re(ae, J, o, F, t) {
    if (process.env.NODE_ENV !== "production") {
      for (var a in ae)
        if (ce(ae, a)) {
          var v;
          try {
            if (typeof ae[a] != "function") {
              var h = Error(
                (F || "React class") + ": " + o + " type `" + a + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof ae[a] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw h.name = "Invariant Violation", h;
            }
            v = ae[a](J, a, F, o, null, ge);
          } catch (y) {
            v = y;
          }
          if (v && !(v instanceof Error) && be(
            (F || "React class") + ": type specification of " + o + " `" + a + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof v + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), v instanceof Error && !(v.message in le)) {
            le[v.message] = !0;
            var e = t ? t() : "";
            be(
              "Failed " + o + " type: " + v.message + (e ?? "")
            );
          }
        }
    }
  }
  return re.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (le = {});
  }, checkPropTypes_1 = re, checkPropTypes_1;
}
var factoryWithTypeCheckers, hasRequiredFactoryWithTypeCheckers;
function requireFactoryWithTypeCheckers() {
  if (hasRequiredFactoryWithTypeCheckers)
    return factoryWithTypeCheckers;
  hasRequiredFactoryWithTypeCheckers = 1;
  var be = requireReactIs(), ge = requireObjectAssign(), le = requireReactPropTypesSecret(), ce = requireHas(), re = requireCheckPropTypes(), ae = function() {
  };
  process.env.NODE_ENV !== "production" && (ae = function(o) {
    var F = "Warning: " + o;
    typeof console < "u" && console.error(F);
    try {
      throw new Error(F);
    } catch {
    }
  });
  function J() {
    return null;
  }
  return factoryWithTypeCheckers = function(o, F) {
    var t = typeof Symbol == "function" && Symbol.iterator, a = "@@iterator";
    function v(D) {
      var _ = D && (t && D[t] || D[a]);
      if (typeof _ == "function")
        return _;
    }
    var h = "<<anonymous>>", e = {
      array: m("array"),
      bigint: m("bigint"),
      bool: m("boolean"),
      func: m("function"),
      number: m("number"),
      object: m("object"),
      string: m("string"),
      symbol: m("symbol"),
      any: p(),
      arrayOf: g,
      element: n(),
      elementType: i(),
      instanceOf: l,
      node: b(),
      objectOf: w,
      oneOf: u,
      oneOfType: O,
      shape: Y,
      exact: j
    };
    function y(D, _) {
      return D === _ ? D !== 0 || 1 / D === 1 / _ : D !== D && _ !== _;
    }
    function c(D, _) {
      this.message = D, this.data = _ && typeof _ == "object" ? _ : {}, this.stack = "";
    }
    c.prototype = Error.prototype;
    function d(D) {
      if (process.env.NODE_ENV !== "production")
        var _ = {}, S = 0;
      function C(P, M, G, Z, $, z, V) {
        if (Z = Z || h, z = z || G, V !== le) {
          if (F) {
            var L = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw L.name = "Invariant Violation", L;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var K = Z + ":" + G;
            !_[K] && // Avoid spamming the console because they are often not actionable except for lib authors
            S < 3 && (ae(
              "You are manually calling a React.PropTypes validation function for the `" + z + "` prop on `" + Z + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), _[K] = !0, S++);
          }
        }
        return M[G] == null ? P ? M[G] === null ? new c("The " + $ + " `" + z + "` is marked as required " + ("in `" + Z + "`, but its value is `null`.")) : new c("The " + $ + " `" + z + "` is marked as required in " + ("`" + Z + "`, but its value is `undefined`.")) : null : D(M, G, Z, $, z);
      }
      var T = C.bind(null, !1);
      return T.isRequired = C.bind(null, !0), T;
    }
    function m(D) {
      function _(S, C, T, P, M, G) {
        var Z = S[C], $ = U(Z);
        if ($ !== D) {
          var z = k(Z);
          return new c(
            "Invalid " + P + " `" + M + "` of type " + ("`" + z + "` supplied to `" + T + "`, expected ") + ("`" + D + "`."),
            { expectedType: D }
          );
        }
        return null;
      }
      return d(_);
    }
    function p() {
      return d(J);
    }
    function g(D) {
      function _(S, C, T, P, M) {
        if (typeof D != "function")
          return new c("Property `" + M + "` of component `" + T + "` has invalid PropType notation inside arrayOf.");
        var G = S[C];
        if (!Array.isArray(G)) {
          var Z = U(G);
          return new c("Invalid " + P + " `" + M + "` of type " + ("`" + Z + "` supplied to `" + T + "`, expected an array."));
        }
        for (var $ = 0; $ < G.length; $++) {
          var z = D(G, $, T, P, M + "[" + $ + "]", le);
          if (z instanceof Error)
            return z;
        }
        return null;
      }
      return d(_);
    }
    function n() {
      function D(_, S, C, T, P) {
        var M = _[S];
        if (!o(M)) {
          var G = U(M);
          return new c("Invalid " + T + " `" + P + "` of type " + ("`" + G + "` supplied to `" + C + "`, expected a single ReactElement."));
        }
        return null;
      }
      return d(D);
    }
    function i() {
      function D(_, S, C, T, P) {
        var M = _[S];
        if (!be.isValidElementType(M)) {
          var G = U(M);
          return new c("Invalid " + T + " `" + P + "` of type " + ("`" + G + "` supplied to `" + C + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return d(D);
    }
    function l(D) {
      function _(S, C, T, P, M) {
        if (!(S[C] instanceof D)) {
          var G = D.name || h, Z = f(S[C]);
          return new c("Invalid " + P + " `" + M + "` of type " + ("`" + Z + "` supplied to `" + T + "`, expected ") + ("instance of `" + G + "`."));
        }
        return null;
      }
      return d(_);
    }
    function u(D) {
      if (!Array.isArray(D))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? ae(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : ae("Invalid argument supplied to oneOf, expected an array.")), J;
      function _(S, C, T, P, M) {
        for (var G = S[C], Z = 0; Z < D.length; Z++)
          if (y(G, D[Z]))
            return null;
        var $ = JSON.stringify(D, function(V, L) {
          var K = k(L);
          return K === "symbol" ? String(L) : L;
        });
        return new c("Invalid " + P + " `" + M + "` of value `" + String(G) + "` " + ("supplied to `" + T + "`, expected one of " + $ + "."));
      }
      return d(_);
    }
    function w(D) {
      function _(S, C, T, P, M) {
        if (typeof D != "function")
          return new c("Property `" + M + "` of component `" + T + "` has invalid PropType notation inside objectOf.");
        var G = S[C], Z = U(G);
        if (Z !== "object")
          return new c("Invalid " + P + " `" + M + "` of type " + ("`" + Z + "` supplied to `" + T + "`, expected an object."));
        for (var $ in G)
          if (ce(G, $)) {
            var z = D(G, $, T, P, M + "." + $, le);
            if (z instanceof Error)
              return z;
          }
        return null;
      }
      return d(_);
    }
    function O(D) {
      if (!Array.isArray(D))
        return process.env.NODE_ENV !== "production" && ae("Invalid argument supplied to oneOfType, expected an instance of array."), J;
      for (var _ = 0; _ < D.length; _++) {
        var S = D[_];
        if (typeof S != "function")
          return ae(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + x(S) + " at index " + _ + "."
          ), J;
      }
      function C(T, P, M, G, Z) {
        for (var $ = [], z = 0; z < D.length; z++) {
          var V = D[z], L = V(T, P, M, G, Z, le);
          if (L == null)
            return null;
          L.data && ce(L.data, "expectedType") && $.push(L.data.expectedType);
        }
        var K = $.length > 0 ? ", expected one of type [" + $.join(", ") + "]" : "";
        return new c("Invalid " + G + " `" + Z + "` supplied to " + ("`" + M + "`" + K + "."));
      }
      return d(C);
    }
    function b() {
      function D(_, S, C, T, P) {
        return X(_[S]) ? null : new c("Invalid " + T + " `" + P + "` supplied to " + ("`" + C + "`, expected a ReactNode."));
      }
      return d(D);
    }
    function A(D, _, S, C, T) {
      return new c(
        (D || "React class") + ": " + _ + " type `" + S + "." + C + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + T + "`."
      );
    }
    function Y(D) {
      function _(S, C, T, P, M) {
        var G = S[C], Z = U(G);
        if (Z !== "object")
          return new c("Invalid " + P + " `" + M + "` of type `" + Z + "` " + ("supplied to `" + T + "`, expected `object`."));
        for (var $ in D) {
          var z = D[$];
          if (typeof z != "function")
            return A(T, P, M, $, k(z));
          var V = z(G, $, T, P, M + "." + $, le);
          if (V)
            return V;
        }
        return null;
      }
      return d(_);
    }
    function j(D) {
      function _(S, C, T, P, M) {
        var G = S[C], Z = U(G);
        if (Z !== "object")
          return new c("Invalid " + P + " `" + M + "` of type `" + Z + "` " + ("supplied to `" + T + "`, expected `object`."));
        var $ = ge({}, S[C], D);
        for (var z in $) {
          var V = D[z];
          if (ce(D, z) && typeof V != "function")
            return A(T, P, M, z, k(V));
          if (!V)
            return new c(
              "Invalid " + P + " `" + M + "` key `" + z + "` supplied to `" + T + "`.\nBad object: " + JSON.stringify(S[C], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(D), null, "  ")
            );
          var L = V(G, z, T, P, M + "." + z, le);
          if (L)
            return L;
        }
        return null;
      }
      return d(_);
    }
    function X(D) {
      switch (typeof D) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !D;
        case "object":
          if (Array.isArray(D))
            return D.every(X);
          if (D === null || o(D))
            return !0;
          var _ = v(D);
          if (_) {
            var S = _.call(D), C;
            if (_ !== D.entries) {
              for (; !(C = S.next()).done; )
                if (!X(C.value))
                  return !1;
            } else
              for (; !(C = S.next()).done; ) {
                var T = C.value;
                if (T && !X(T[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function B(D, _) {
      return D === "symbol" ? !0 : _ ? _["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && _ instanceof Symbol : !1;
    }
    function U(D) {
      var _ = typeof D;
      return Array.isArray(D) ? "array" : D instanceof RegExp ? "object" : B(_, D) ? "symbol" : _;
    }
    function k(D) {
      if (typeof D > "u" || D === null)
        return "" + D;
      var _ = U(D);
      if (_ === "object") {
        if (D instanceof Date)
          return "date";
        if (D instanceof RegExp)
          return "regexp";
      }
      return _;
    }
    function x(D) {
      var _ = k(D);
      switch (_) {
        case "array":
        case "object":
          return "an " + _;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + _;
        default:
          return _;
      }
    }
    function f(D) {
      return !D.constructor || !D.constructor.name ? h : D.constructor.name;
    }
    return e.checkPropTypes = re, e.resetWarningCache = re.resetWarningCache, e.PropTypes = e, e;
  }, factoryWithTypeCheckers;
}
var factoryWithThrowingShims, hasRequiredFactoryWithThrowingShims;
function requireFactoryWithThrowingShims() {
  if (hasRequiredFactoryWithThrowingShims)
    return factoryWithThrowingShims;
  hasRequiredFactoryWithThrowingShims = 1;
  var be = requireReactPropTypesSecret();
  function ge() {
  }
  function le() {
  }
  return le.resetWarningCache = ge, factoryWithThrowingShims = function() {
    function ce(J, o, F, t, a, v) {
      if (v !== be) {
        var h = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw h.name = "Invariant Violation", h;
      }
    }
    ce.isRequired = ce;
    function re() {
      return ce;
    }
    var ae = {
      array: ce,
      bigint: ce,
      bool: ce,
      func: ce,
      number: ce,
      object: ce,
      string: ce,
      symbol: ce,
      any: ce,
      arrayOf: re,
      element: ce,
      elementType: ce,
      instanceOf: re,
      node: ce,
      objectOf: re,
      oneOf: re,
      oneOfType: re,
      shape: re,
      exact: re,
      checkPropTypes: le,
      resetWarningCache: ge
    };
    return ae.PropTypes = ae, ae;
  }, factoryWithThrowingShims;
}
if (process.env.NODE_ENV !== "production") {
  var ReactIs = requireReactIs(), throwOnDirectAccess = !0;
  propTypes.exports = requireFactoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
} else
  propTypes.exports = requireFactoryWithThrowingShims()();
var __spreadArray = globalThis && globalThis.__spreadArray || function(be, ge, le) {
  if (le || arguments.length === 2)
    for (var ce = 0, re = ge.length, ae; ce < re; ce++)
      (ae || !(ce in ge)) && (ae || (ae = Array.prototype.slice.call(ge, 0, ce)), ae[ce] = ge[ce]);
  return be.concat(ae || Array.prototype.slice.call(ge));
}, clipboardEvents = ["onCopy", "onCut", "onPaste"], compositionEvents = [
  "onCompositionEnd",
  "onCompositionStart",
  "onCompositionUpdate"
], keyboardEvents = ["onKeyDown", "onKeyPress", "onKeyUp"], focusEvents = ["onFocus", "onBlur"], formEvents = ["onChange", "onInput", "onInvalid", "onReset", "onSubmit"], genericEvents = ["onError", "onLoad"], mouseEvents = [
  "onClick",
  "onContextMenu",
  "onDoubleClick",
  "onDrag",
  "onDragEnd",
  "onDragEnter",
  "onDragExit",
  "onDragLeave",
  "onDragOver",
  "onDragStart",
  "onDrop",
  "onMouseDown",
  "onMouseEnter",
  "onMouseLeave",
  "onMouseMove",
  "onMouseOut",
  "onMouseOver",
  "onMouseUp"
], pointerEvents = [
  "onPointerDown",
  "onPointerMove",
  "onPointerUp",
  "onPointerCancel",
  "onGotPointerCapture",
  "onLostPointerCapture",
  "onPointerEnter",
  "onPointerLeave",
  "onPointerOver",
  "onPointerOut"
], selectionEvents = ["onSelect"], touchEvents = ["onTouchCancel", "onTouchEnd", "onTouchMove", "onTouchStart"], uiEvents = ["onScroll"], wheelEvents = ["onWheel"], mediaEvents = [
  "onAbort",
  "onCanPlay",
  "onCanPlayThrough",
  "onDurationChange",
  "onEmptied",
  "onEncrypted",
  "onEnded",
  "onError",
  "onLoadedData",
  "onLoadedMetadata",
  "onLoadStart",
  "onPause",
  "onPlay",
  "onPlaying",
  "onProgress",
  "onRateChange",
  "onSeeked",
  "onSeeking",
  "onStalled",
  "onSuspend",
  "onTimeUpdate",
  "onVolumeChange",
  "onWaiting"
], imageEvents = ["onLoad", "onError"], animationEvents = [
  "onAnimationStart",
  "onAnimationEnd",
  "onAnimationIteration"
], transitionEvents = ["onTransitionEnd"], otherEvents = ["onToggle"], allEvents = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], clipboardEvents, !0), compositionEvents, !0), keyboardEvents, !0), focusEvents, !0), formEvents, !0), genericEvents, !0), mouseEvents, !0), pointerEvents, !0), selectionEvents, !0), touchEvents, !0), uiEvents, !0), wheelEvents, !0), mediaEvents, !0), imageEvents, !0), animationEvents, !0), transitionEvents, !0), otherEvents, !0);
function makeEventProps(be, ge) {
  var le = {};
  return allEvents.forEach(function(ce) {
    var re = be[ce];
    if (re) {
      if (!ge) {
        le[ce] = re;
        return;
      }
      le[ce] = function(ae) {
        return re(ae, ge(ce));
      };
    }
  }), le;
}
function makeCancellablePromise(be) {
  var ge = !1, le = new Promise(function(ce, re) {
    be.then(function(ae) {
      return !ge && ce(ae);
    }).catch(function(ae) {
      return !ge && re(ae);
    });
  });
  return {
    promise: le,
    cancel: function() {
      ge = !0;
    }
  };
}
function r(be) {
  var ge, le, ce = "";
  if (typeof be == "string" || typeof be == "number")
    ce += be;
  else if (typeof be == "object")
    if (Array.isArray(be))
      for (ge = 0; ge < be.length; ge++)
        be[ge] && (le = r(be[ge])) && (ce && (ce += " "), ce += le);
    else
      for (ge in be)
        be[ge] && (ce && (ce += " "), ce += ge);
  return ce;
}
function clsx() {
  for (var be, ge, le = 0, ce = ""; le < arguments.length; )
    (be = arguments[le++]) && (ge = r(be)) && (ce && (ce += " "), ce += ge);
  return ce;
}
var isProduction$1 = process.env.NODE_ENV === "production", prefix = "Invariant failed";
function invariant(be, ge) {
  if (!be) {
    if (isProduction$1)
      throw new Error(prefix);
    var le = typeof ge == "function" ? ge() : ge, ce = le ? "".concat(prefix, ": ").concat(le) : prefix;
    throw new Error(ce);
  }
}
var isProduction = process.env.NODE_ENV === "production";
function warning(be, ge) {
  if (!isProduction) {
    if (be)
      return;
    var le = "Warning: " + ge;
    typeof console < "u" && console.warn(le);
    try {
      throw Error(le);
    } catch {
    }
  }
}
const DocumentContext = /* @__PURE__ */ reactExports.createContext(null);
function Message(be) {
  var ge = be.children, le = be.type;
  return /* @__PURE__ */ React.createElement("div", {
    className: "react-pdf__message react-pdf__message--".concat(le)
  }, ge);
}
Message.propTypes = {
  children: propTypesExports.node,
  type: propTypesExports.oneOf(["error", "loading", "no-data"]).isRequired
};
var DEFAULT_LINK_REL = "noopener noreferrer nofollow", LinkService = /* @__PURE__ */ function() {
  function be() {
    _classCallCheck(this, be), this.externalLinkTarget = null, this.externalLinkRel = null;
  }
  return _createClass(be, [{
    key: "setDocument",
    value: function(le) {
      this.pdfDocument = le;
    }
  }, {
    key: "setViewer",
    value: function(le) {
      this.pdfViewer = le;
    }
  }, {
    key: "setExternalLinkRel",
    value: function(le) {
      this.externalLinkRel = le;
    }
  }, {
    key: "setExternalLinkTarget",
    value: function(le) {
      this.externalLinkTarget = le;
    }
  }, {
    key: "setHistory",
    value: function() {
    }
  }, {
    key: "pagesCount",
    get: function() {
      return this.pdfDocument ? this.pdfDocument.numPages : 0;
    }
  }, {
    key: "page",
    get: function() {
      return this.pdfViewer.currentPageNumber;
    },
    set: function(le) {
      this.pdfViewer.currentPageNumber = le;
    }
  }, {
    key: "rotation",
    get: function() {
      return 0;
    },
    set: function(le) {
    }
  }, {
    key: "goToDestination",
    value: function(le) {
      var ce = this;
      new Promise(function(re) {
        typeof le == "string" ? ce.pdfDocument.getDestination(le).then(re) : Array.isArray(le) ? re(le) : le.then(re);
      }).then(function(re) {
        invariant(Array.isArray(re), '"'.concat(re, '" is not a valid destination array.'));
        var ae = re[0];
        new Promise(function(J) {
          ae instanceof Object ? ce.pdfDocument.getPageIndex(ae).then(function(o) {
            J(o);
          }).catch(function() {
            invariant(!1, '"'.concat(ae, '" is not a valid page reference.'));
          }) : typeof ae == "number" ? J(ae) : invariant(!1, '"'.concat(ae, '" is not a valid destination reference.'));
        }).then(function(J) {
          var o = J + 1;
          invariant(o >= 1 && o <= ce.pagesCount, '"'.concat(o, '" is not a valid page number.')), ce.pdfViewer.scrollPageIntoView({
            dest: le,
            pageIndex: J,
            pageNumber: o
          });
        });
      });
    }
  }, {
    key: "navigateTo",
    value: function(le) {
      this.goToDestination(le);
    }
  }, {
    key: "goToPage",
    value: function() {
    }
  }, {
    key: "addLinkAttributes",
    value: function(le, ce, re) {
      le.href = ce, le.rel = this.externalLinkRel || DEFAULT_LINK_REL, le.target = re ? "_blank" : this.externalLinkTarget || "";
    }
  }, {
    key: "getDestinationHash",
    value: function() {
      return "#";
    }
  }, {
    key: "getAnchorUrl",
    value: function() {
      return "#";
    }
  }, {
    key: "setHash",
    value: function() {
    }
  }, {
    key: "executeNamedAction",
    value: function() {
    }
  }, {
    key: "cachePageRef",
    value: function() {
    }
  }, {
    key: "isPageVisible",
    value: function() {
      return !0;
    }
  }, {
    key: "isPageCached",
    value: function() {
      return !0;
    }
  }]), be;
}(), PasswordResponses = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};
function _arrayWithHoles(be) {
  if (Array.isArray(be))
    return be;
}
function _iterableToArrayLimit(be, ge) {
  var le = be == null ? null : typeof Symbol < "u" && be[Symbol.iterator] || be["@@iterator"];
  if (le != null) {
    var ce, re, ae, J, o = [], F = !0, t = !1;
    try {
      if (ae = (le = le.call(be)).next, ge === 0) {
        if (Object(le) !== le)
          return;
        F = !1;
      } else
        for (; !(F = (ce = ae.call(le)).done) && (o.push(ce.value), o.length !== ge); F = !0)
          ;
    } catch (a) {
      t = !0, re = a;
    } finally {
      try {
        if (!F && le.return != null && (J = le.return(), Object(J) !== J))
          return;
      } finally {
        if (t)
          throw re;
      }
    }
    return o;
  }
}
function _arrayLikeToArray(be, ge) {
  (ge == null || ge > be.length) && (ge = be.length);
  for (var le = 0, ce = new Array(ge); le < ge; le++)
    ce[le] = be[le];
  return ce;
}
function _unsupportedIterableToArray(be, ge) {
  if (be) {
    if (typeof be == "string")
      return _arrayLikeToArray(be, ge);
    var le = Object.prototype.toString.call(be).slice(8, -1);
    if (le === "Object" && be.constructor && (le = be.constructor.name), le === "Map" || le === "Set")
      return Array.from(be);
    if (le === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(le))
      return _arrayLikeToArray(be, ge);
  }
}
function _nonIterableRest() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _slicedToArray(be, ge) {
  return _arrayWithHoles(be) || _iterableToArrayLimit(be, ge) || _unsupportedIterableToArray(be, ge) || _nonIterableRest();
}
var isBrowser = typeof document < "u", isLocalFileSystem = isBrowser && window.location.protocol === "file:";
function isDefined(be) {
  return typeof be < "u";
}
function isProvided(be) {
  return isDefined(be) && be !== null;
}
function isString(be) {
  return typeof be == "string";
}
function isArrayBuffer(be) {
  return be instanceof ArrayBuffer;
}
function isBlob(be) {
  return invariant(isBrowser, "isBlob can only be used in a browser environment"), be instanceof Blob;
}
function isFile$1(be) {
  return invariant(isBrowser, "isFile can only be used in a browser environment"), be instanceof File;
}
function isDataURI(be) {
  return isString(be) && /^data:/.test(be);
}
function dataURItoByteString(be) {
  invariant(isDataURI(be), "Invalid data URI.");
  var ge = be.split(","), le = _slicedToArray(ge, 2), ce = le[0], re = le[1], ae = ce.split(";");
  return ae.indexOf("base64") !== -1 ? atob(re) : unescape(re);
}
function getDevicePixelRatio() {
  return isBrowser && window.devicePixelRatio || 1;
}
var allowFileAccessFromFilesTip = "On Chromium based browsers, you can use --allow-file-access-from-files flag for debugging purposes.";
function displayCORSWarning() {
  warning(!isLocalFileSystem, "Loading PDF as base64 strings/URLs may not work on protocols other than HTTP/HTTPS. ".concat(allowFileAccessFromFilesTip));
}
function displayWorkerWarning() {
  warning(!isLocalFileSystem, "Loading PDF.js worker may not work on protocols other than HTTP/HTTPS. ".concat(allowFileAccessFromFilesTip));
}
function cancelRunningTask(be) {
  be && be.cancel && be.cancel();
}
function makePageCallback(be, ge) {
  return Object.defineProperty(be, "width", {
    get: function() {
      return this.view[2] * ge;
    },
    configurable: !0
  }), Object.defineProperty(be, "height", {
    get: function() {
      return this.view[3] * ge;
    },
    configurable: !0
  }), Object.defineProperty(be, "originalWidth", {
    get: function() {
      return this.view[2];
    },
    configurable: !0
  }), Object.defineProperty(be, "originalHeight", {
    get: function() {
      return this.view[3];
    },
    configurable: !0
  }), be;
}
function isCancelException(be) {
  return be.name === "RenderingCancelledException";
}
function loadFromFile(be) {
  return new Promise(function(ge, le) {
    var ce = new FileReader();
    return ce.onload = function() {
      return ge(new Uint8Array(ce.result));
    }, ce.onerror = function(re) {
      switch (re.target.error.code) {
        case re.target.error.NOT_FOUND_ERR:
          return le(new Error("Error while reading a file: File not found."));
        case re.target.error.NOT_READABLE_ERR:
          return le(new Error("Error while reading a file: File not readable."));
        case re.target.error.SECURITY_ERR:
          return le(new Error("Error while reading a file: Security error."));
        case re.target.error.ABORT_ERR:
          return le(new Error("Error while reading a file: Aborted."));
        default:
          return le(new Error("Error while reading a file."));
      }
    }, ce.readAsArrayBuffer(be), null;
  });
}
function _arrayWithoutHoles(be) {
  if (Array.isArray(be))
    return _arrayLikeToArray(be);
}
function _iterableToArray(be) {
  if (typeof Symbol < "u" && be[Symbol.iterator] != null || be["@@iterator"] != null)
    return Array.from(be);
}
function _nonIterableSpread() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _toConsumableArray(be) {
  return _arrayWithoutHoles(be) || _iterableToArray(be) || _unsupportedIterableToArray(be) || _nonIterableSpread();
}
var eventProps = function() {
  var be = {};
  return [].concat(_toConsumableArray(mouseEvents), _toConsumableArray(touchEvents), _toConsumableArray(keyboardEvents)).forEach(function(ge) {
    be[ge] = propTypesExports.func;
  }), be;
}(), fileTypes = [propTypesExports.string, propTypesExports.instanceOf(ArrayBuffer), propTypesExports.shape({
  data: propTypesExports.oneOfType([propTypesExports.object, propTypesExports.string]),
  httpHeaders: propTypesExports.object,
  range: propTypesExports.object,
  url: propTypesExports.string,
  withCredentials: propTypesExports.bool
})];
typeof File < "u" && fileTypes.push(propTypesExports.instanceOf(File));
typeof Blob < "u" && fileTypes.push(propTypesExports.instanceOf(Blob));
var isClassName = propTypesExports.oneOfType([propTypesExports.string, propTypesExports.arrayOf(propTypesExports.string)]), isFile = propTypesExports.oneOfType(fileTypes), isLinkService = propTypesExports.instanceOf(LinkService);
propTypesExports.oneOf(["_self", "_blank", "_parent", "_top"]);
var isPage = propTypesExports.shape({
  commonObjs: propTypesExports.shape({}).isRequired,
  getAnnotations: propTypesExports.func.isRequired,
  getTextContent: propTypesExports.func.isRequired,
  getViewport: propTypesExports.func.isRequired,
  render: propTypesExports.func.isRequired
}), isPageIndex = function be(ge, le, ce) {
  var re = ge[le], ae = ge.pageNumber, J = ge.pdf;
  if (!isDefined(J))
    return null;
  if (isDefined(re)) {
    if (typeof re != "number")
      return new Error("`".concat(le, "` of type `").concat(_typeof(re), "` supplied to `").concat(ce, "`, expected `number`."));
    if (re < 0)
      return new Error("Expected `".concat(le, "` to be greater or equal to 0."));
    var o = J.numPages;
    if (re + 1 > o)
      return new Error("Expected `".concat(le, "` to be less or equal to ").concat(o - 1, "."));
  } else if (!isDefined(ae))
    return new Error("`".concat(le, "` not supplied. Either pageIndex or pageNumber must be supplied to `").concat(ce, "`."));
  return null;
}, isPageNumber = function be(ge, le, ce) {
  var re = ge[le], ae = ge.pageIndex, J = ge.pdf;
  if (!isDefined(J))
    return null;
  if (isDefined(re)) {
    if (typeof re != "number")
      return new Error("`".concat(le, "` of type `").concat(_typeof(re), "` supplied to `").concat(ce, "`, expected `number`."));
    if (re < 1)
      return new Error("Expected `".concat(le, "` to be greater or equal to 1."));
    var o = J.numPages;
    if (re > o)
      return new Error("Expected `".concat(le, "` to be less or equal to ").concat(o, "."));
  } else if (!isDefined(ae))
    return new Error("`".concat(le, "` not supplied. Either pageIndex or pageNumber must be supplied to `").concat(ce, "`."));
  return null;
}, isPdf = propTypesExports.oneOfType([propTypesExports.shape({
  getDestination: propTypesExports.func.isRequired,
  getOutline: propTypesExports.func.isRequired,
  getPage: propTypesExports.func.isRequired,
  numPages: propTypesExports.number.isRequired
}), propTypesExports.bool]), isRef = propTypesExports.oneOfType([propTypesExports.func, propTypesExports.shape({
  current: propTypesExports.any
})]), isRenderMode = propTypesExports.oneOf(["canvas", "none", "svg"]), isRotate = propTypesExports.oneOf([0, 90, 180, 270]), _excluded = ["url"];
function ownKeys$3(be, ge) {
  var le = Object.keys(be);
  if (Object.getOwnPropertySymbols) {
    var ce = Object.getOwnPropertySymbols(be);
    ge && (ce = ce.filter(function(re) {
      return Object.getOwnPropertyDescriptor(be, re).enumerable;
    })), le.push.apply(le, ce);
  }
  return le;
}
function _objectSpread$3(be) {
  for (var ge = 1; ge < arguments.length; ge++) {
    var le = arguments[ge] != null ? arguments[ge] : {};
    ge % 2 ? ownKeys$3(Object(le), !0).forEach(function(ce) {
      _defineProperty(be, ce, le[ce]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(be, Object.getOwnPropertyDescriptors(le)) : ownKeys$3(Object(le)).forEach(function(ce) {
      Object.defineProperty(be, ce, Object.getOwnPropertyDescriptor(le, ce));
    });
  }
  return be;
}
function _createSuper$5(be) {
  var ge = _isNativeReflectConstruct$5();
  return function() {
    var ce = _getPrototypeOf(be), re;
    if (ge) {
      var ae = _getPrototypeOf(this).constructor;
      re = Reflect.construct(ce, arguments, ae);
    } else
      re = ce.apply(this, arguments);
    return _possibleConstructorReturn(this, re);
  };
}
function _isNativeReflectConstruct$5() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
var PDFDataRangeTransport = pdfExports.PDFDataRangeTransport, Document = /* @__PURE__ */ function(be) {
  _inherits(le, be);
  var ge = _createSuper$5(le);
  function le() {
    var ce;
    _classCallCheck(this, le);
    for (var re = arguments.length, ae = new Array(re), J = 0; J < re; J++)
      ae[J] = arguments[J];
    return ce = ge.call.apply(ge, [this].concat(ae)), _defineProperty(_assertThisInitialized(ce), "state", {
      pdf: null
    }), _defineProperty(_assertThisInitialized(ce), "viewer", {
      scrollPageIntoView: function(F) {
        var t = F.dest, a = F.pageIndex, v = F.pageNumber, h = ce.props.onItemClick;
        if (h) {
          h({
            dest: t,
            pageIndex: a,
            pageNumber: v
          });
          return;
        }
        var e = ce.pages[a];
        if (e) {
          e.scrollIntoView();
          return;
        }
        warning(!1, "An internal link leading to page ".concat(v, " was clicked, but neither <Document> was provided with onItemClick nor it was able to find the page within itself. Either provide onItemClick to <Document> and handle navigating by yourself or ensure that all pages are rendered within <Document>."));
      }
    }), _defineProperty(_assertThisInitialized(ce), "linkService", new LinkService()), _defineProperty(_assertThisInitialized(ce), "loadDocument", function() {
      cancelRunningTask(ce.runningTask), ce.loadingTask && ce.loadingTask.destroy();
      var o = makeCancellablePromise(ce.findDocumentSource());
      ce.runningTask = o, o.promise.then(function(F) {
        if (ce.onSourceSuccess(), !!F) {
          ce.setState(function(y) {
            return y.pdf ? {
              pdf: null
            } : null;
          });
          var t = ce.props, a = t.options, v = t.onLoadProgress, h = t.onPassword, e = pdfExports.getDocument(_objectSpread$3(_objectSpread$3({}, F), a));
          e.onPassword = h, v && (e.onProgress = v), ce.loadingTask = e, e.promise.then(function(y) {
            ce.setState(function(c) {
              return c.pdf && c.pdf.fingerprint === y.fingerprint ? null : {
                pdf: y
              };
            }, ce.onLoadSuccess);
          }).catch(function(y) {
            ce.onLoadError(y);
          });
        }
      }).catch(function(F) {
        ce.onSourceError(F);
      });
    }), _defineProperty(_assertThisInitialized(ce), "setupLinkService", function() {
      var o = ce.props, F = o.externalLinkRel, t = o.externalLinkTarget;
      ce.linkService.setViewer(ce.viewer), ce.linkService.setExternalLinkRel(F), ce.linkService.setExternalLinkTarget(t);
    }), _defineProperty(_assertThisInitialized(ce), "onSourceSuccess", function() {
      var o = ce.props.onSourceSuccess;
      o && o();
    }), _defineProperty(_assertThisInitialized(ce), "onSourceError", function(o) {
      warning(o);
      var F = ce.props.onSourceError;
      F && F(o);
    }), _defineProperty(_assertThisInitialized(ce), "onLoadSuccess", function() {
      var o = ce.props.onLoadSuccess, F = ce.state.pdf;
      o && o(F), ce.pages = new Array(F.numPages), ce.linkService.setDocument(F);
    }), _defineProperty(_assertThisInitialized(ce), "onLoadError", function(o) {
      ce.setState({
        pdf: !1
      }), warning(o);
      var F = ce.props.onLoadError;
      F && F(o);
    }), _defineProperty(_assertThisInitialized(ce), "findDocumentSource", function() {
      return new Promise(function(o) {
        var F = ce.props.file;
        if (F || o(null), typeof F == "string") {
          if (isDataURI(F)) {
            var t = dataURItoByteString(F);
            o({
              data: t
            });
          }
          displayCORSWarning(), o({
            url: F
          });
        }
        if (F instanceof PDFDataRangeTransport && o({
          range: F
        }), isArrayBuffer(F) && o({
          data: F
        }), isBrowser && (isBlob(F) || isFile$1(F))) {
          loadFromFile(F).then(function(e) {
            o({
              data: e
            });
          });
          return;
        }
        if (invariant(_typeof(F) === "object", "Invalid parameter in file, need either Uint8Array, string or a parameter object"), invariant(F.url || F.data || F.range, "Invalid parameter object: need either .data, .range or .url"), typeof F.url == "string") {
          if (isDataURI(F.url)) {
            var a = F.url, v = _objectWithoutProperties(F, _excluded), h = dataURItoByteString(a);
            o(_objectSpread$3({
              data: h
            }, v));
          }
          displayCORSWarning();
        }
        o(F);
      });
    }), _defineProperty(_assertThisInitialized(ce), "registerPage", function(o, F) {
      ce.pages[o] = F;
    }), _defineProperty(_assertThisInitialized(ce), "unregisterPage", function(o) {
      delete ce.pages[o];
    }), ce;
  }
  return _createClass(le, [{
    key: "componentDidMount",
    value: function() {
      this.loadDocument(), this.setupLinkService();
    }
  }, {
    key: "componentDidUpdate",
    value: function(re) {
      var ae = this.props.file;
      ae !== re.file && this.loadDocument();
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      cancelRunningTask(this.runningTask), this.loadingTask && this.loadingTask.destroy();
    }
  }, {
    key: "childContext",
    get: function() {
      var re = this.linkService, ae = this.registerPage, J = this.unregisterPage, o = this.props, F = o.imageResourcesPath, t = o.renderMode, a = o.rotate, v = this.state.pdf;
      return {
        imageResourcesPath: F,
        linkService: re,
        pdf: v,
        registerPage: ae,
        renderMode: t,
        rotate: a,
        unregisterPage: J
      };
    }
  }, {
    key: "eventProps",
    get: function() {
      var re = this;
      return makeEventProps(this.props, function() {
        return re.state.pdf;
      });
    }
    /**
     * Called when a document source is resolved correctly
     */
  }, {
    key: "renderChildren",
    value: function() {
      var re = this.props.children;
      return /* @__PURE__ */ React.createElement(DocumentContext.Provider, {
        value: this.childContext
      }, re);
    }
  }, {
    key: "renderContent",
    value: function() {
      var re = this.props.file, ae = this.state.pdf;
      if (!re) {
        var J = this.props.noData;
        return /* @__PURE__ */ React.createElement(Message, {
          type: "no-data"
        }, typeof J == "function" ? J() : J);
      }
      if (ae === null) {
        var o = this.props.loading;
        return /* @__PURE__ */ React.createElement(Message, {
          type: "loading"
        }, typeof o == "function" ? o() : o);
      }
      if (ae === !1) {
        var F = this.props.error;
        return /* @__PURE__ */ React.createElement(Message, {
          type: "error"
        }, typeof F == "function" ? F() : F);
      }
      return this.renderChildren();
    }
  }, {
    key: "render",
    value: function() {
      var re = this.props, ae = re.className, J = re.inputRef;
      return /* @__PURE__ */ React.createElement("div", _extends({
        className: clsx("react-pdf__Document", ae),
        ref: J
      }, this.eventProps), this.renderContent());
    }
  }]), le;
}(reactExports.PureComponent);
Document.defaultProps = {
  error: "Failed to load PDF file.",
  loading: "Loading PDF…",
  noData: "No PDF file specified.",
  onPassword: function be(ge, le) {
    switch (le) {
      case PasswordResponses.NEED_PASSWORD: {
        var ce = prompt("Enter the password to open this PDF file.");
        ge(ce);
        break;
      }
      case PasswordResponses.INCORRECT_PASSWORD: {
        var re = prompt("Invalid password. Please try again.");
        ge(re);
        break;
      }
    }
  }
};
var isFunctionOrNode$1 = propTypesExports.oneOfType([propTypesExports.func, propTypesExports.node]);
Document.propTypes = _objectSpread$3(_objectSpread$3({}, eventProps), {}, {
  children: propTypesExports.node,
  className: isClassName,
  error: isFunctionOrNode$1,
  externalLinkRel: propTypesExports.string,
  externalLinkTarget: propTypesExports.string,
  file: isFile,
  imageResourcesPath: propTypesExports.string,
  inputRef: isRef,
  loading: isFunctionOrNode$1,
  noData: isFunctionOrNode$1,
  onItemClick: propTypesExports.func,
  onLoadError: propTypesExports.func,
  onLoadProgress: propTypesExports.func,
  onLoadSuccess: propTypesExports.func,
  onPassword: propTypesExports.func,
  onSourceError: propTypesExports.func,
  onSourceSuccess: propTypesExports.func,
  rotate: propTypesExports.number
});
var isDestination = propTypesExports.oneOfType([propTypesExports.string, propTypesExports.arrayOf(propTypesExports.any)]);
propTypesExports.shape({
  dest: isDestination,
  items: propTypesExports.arrayOf(propTypesExports.shape({
    dest: isDestination,
    title: propTypesExports.string
  })),
  title: propTypesExports.string
}).isRequired, propTypesExports.func, isPdf.isRequired;
function ownKeys$2(be, ge) {
  var le = Object.keys(be);
  if (Object.getOwnPropertySymbols) {
    var ce = Object.getOwnPropertySymbols(be);
    ge && (ce = ce.filter(function(re) {
      return Object.getOwnPropertyDescriptor(be, re).enumerable;
    })), le.push.apply(le, ce);
  }
  return le;
}
function _objectSpread$2(be) {
  for (var ge = 1; ge < arguments.length; ge++) {
    var le = arguments[ge] != null ? arguments[ge] : {};
    ge % 2 ? ownKeys$2(Object(le), !0).forEach(function(ce) {
      _defineProperty(be, ce, le[ce]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(be, Object.getOwnPropertyDescriptors(le)) : ownKeys$2(Object(le)).forEach(function(ce) {
      Object.defineProperty(be, ce, Object.getOwnPropertyDescriptor(le, ce));
    });
  }
  return be;
}
_objectSpread$2({
  className: isClassName,
  inputRef: isRef,
  onItemClick: propTypesExports.func,
  onLoadError: propTypesExports.func,
  onLoadSuccess: propTypesExports.func,
  pdf: isPdf
}, eventProps);
function mergeRefs() {
  for (var be = [], ge = 0; ge < arguments.length; ge++)
    be[ge] = arguments[ge];
  var le = be.filter(Boolean);
  if (le.length <= 1) {
    var ce = le[0];
    return ce || null;
  }
  return function(ae) {
    le.forEach(function(J) {
      typeof J == "function" ? J(ae) : J && (J.current = ae);
    });
  };
}
const PageContext = /* @__PURE__ */ reactExports.createContext(null);
function _createSuper$4(be) {
  var ge = _isNativeReflectConstruct$4();
  return function() {
    var ce = _getPrototypeOf(be), re;
    if (ge) {
      var ae = _getPrototypeOf(this).constructor;
      re = Reflect.construct(ce, arguments, ae);
    } else
      re = ce.apply(this, arguments);
    return _possibleConstructorReturn(this, re);
  };
}
function _isNativeReflectConstruct$4() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
var ANNOTATION_MODE = pdfExports.AnnotationMode, PageCanvasInternal = /* @__PURE__ */ function(be) {
  _inherits(le, be);
  var ge = _createSuper$4(le);
  function le() {
    var ce;
    _classCallCheck(this, le);
    for (var re = arguments.length, ae = new Array(re), J = 0; J < re; J++)
      ae[J] = arguments[J];
    return ce = ge.call.apply(ge, [this].concat(ae)), _defineProperty(_assertThisInitialized(ce), "canvasElement", /* @__PURE__ */ reactExports.createRef()), _defineProperty(_assertThisInitialized(ce), "onRenderSuccess", function() {
      ce.renderer = null;
      var o = ce.props, F = o.onRenderSuccess, t = o.page, a = o.scale;
      F && F(makePageCallback(t, a));
    }), _defineProperty(_assertThisInitialized(ce), "onRenderError", function(o) {
      if (!isCancelException(o)) {
        warning(o);
        var F = ce.props.onRenderError;
        F && F(o);
      }
    }), _defineProperty(_assertThisInitialized(ce), "drawPageOnCanvas", function() {
      var o = ce.canvasElement.current;
      if (!o)
        return null;
      var F = _assertThisInitialized(ce), t = F.renderViewport, a = F.viewport, v = ce.props, h = v.canvasBackground, e = v.page, y = v.renderForms;
      o.width = t.width, o.height = t.height, o.style.width = "".concat(Math.floor(a.width), "px"), o.style.height = "".concat(Math.floor(a.height), "px");
      var c = {
        annotationMode: y ? ANNOTATION_MODE.ENABLE_FORMS : ANNOTATION_MODE.ENABLE,
        get canvasContext() {
          return o.getContext("2d", {
            alpha: !1
          });
        },
        viewport: t
      };
      h && (c.background = h), ce.cancelRenderingTask();
      var d = e.render(c);
      return ce.renderer = d, d.promise.then(ce.onRenderSuccess).catch(ce.onRenderError);
    }), ce;
  }
  return _createClass(le, [{
    key: "componentDidMount",
    value: function() {
      this.drawPageOnCanvas();
    }
  }, {
    key: "componentDidUpdate",
    value: function(re) {
      var ae = this.props, J = ae.canvasBackground, o = ae.devicePixelRatio, F = ae.page, t = ae.renderForms;
      (J !== re.canvasBackground || o !== re.devicePixelRatio || t !== re.renderForms) && (F.cleanup(), this.drawPageOnCanvas());
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      this.cancelRenderingTask();
      var re = this.canvasElement.current;
      re && (re.width = 0, re.height = 0);
    }
  }, {
    key: "cancelRenderingTask",
    value: function() {
      this.renderer && (this.renderer.cancel(), this.renderer = null);
    }
    /**
     * Called when a page is rendered successfully.
     */
  }, {
    key: "devicePixelRatio",
    get: function() {
      var re = this.props.devicePixelRatio;
      return re || getDevicePixelRatio();
    }
  }, {
    key: "renderViewport",
    get: function() {
      var re = this.devicePixelRatio, ae = this.props, J = ae.page, o = ae.rotate, F = ae.scale;
      return J.getViewport({
        scale: F * re,
        rotation: o
      });
    }
  }, {
    key: "viewport",
    get: function() {
      var re = this.props, ae = re.page, J = re.rotate, o = re.scale;
      return ae.getViewport({
        scale: o,
        rotation: J
      });
    }
  }, {
    key: "render",
    value: function() {
      var re = this.props.canvasRef;
      return /* @__PURE__ */ React.createElement("canvas", {
        className: "react-pdf__Page__canvas",
        dir: "ltr",
        ref: mergeRefs(re, this.canvasElement),
        style: {
          display: "block",
          userSelect: "none"
        }
      });
    }
  }]), le;
}(reactExports.PureComponent);
PageCanvasInternal.propTypes = {
  canvasBackground: propTypesExports.string,
  canvasRef: isRef,
  devicePixelRatio: propTypesExports.number,
  onRenderError: propTypesExports.func,
  onRenderSuccess: propTypesExports.func,
  page: isPage.isRequired,
  renderForms: propTypesExports.bool,
  rotate: isRotate,
  scale: propTypesExports.number.isRequired
};
function PageCanvas(be) {
  return /* @__PURE__ */ React.createElement(PageContext.Consumer, null, function(ge) {
    return /* @__PURE__ */ React.createElement(PageCanvasInternal, _extends({}, ge, be));
  });
}
function _createSuper$3(be) {
  var ge = _isNativeReflectConstruct$3();
  return function() {
    var ce = _getPrototypeOf(be), re;
    if (ge) {
      var ae = _getPrototypeOf(this).constructor;
      re = Reflect.construct(ce, arguments, ae);
    } else
      re = ce.apply(this, arguments);
    return _possibleConstructorReturn(this, re);
  };
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
var PageSVGInternal = /* @__PURE__ */ function(be) {
  _inherits(le, be);
  var ge = _createSuper$3(le);
  function le() {
    var ce;
    _classCallCheck(this, le);
    for (var re = arguments.length, ae = new Array(re), J = 0; J < re; J++)
      ae[J] = arguments[J];
    return ce = ge.call.apply(ge, [this].concat(ae)), _defineProperty(_assertThisInitialized(ce), "state", {
      svg: null
    }), _defineProperty(_assertThisInitialized(ce), "onRenderSuccess", function() {
      ce.renderer = null;
      var o = ce.props, F = o.onRenderSuccess, t = o.page, a = o.scale;
      F && F(makePageCallback(t, a));
    }), _defineProperty(_assertThisInitialized(ce), "onRenderError", function(o) {
      if (!isCancelException(o)) {
        warning(o);
        var F = ce.props.onRenderError;
        F && F(o);
      }
    }), _defineProperty(_assertThisInitialized(ce), "renderSVG", function() {
      var o = ce.props.page;
      return ce.renderer = o.getOperatorList(), ce.renderer.then(function(F) {
        var t = new pdfExports.SVGGraphics(o.commonObjs, o.objs);
        ce.renderer = t.getSVG(F, ce.viewport).then(function(a) {
          ce.setState({
            svg: a
          }, ce.onRenderSuccess);
        }).catch(ce.onRenderError);
      }).catch(ce.onRenderError);
    }), _defineProperty(_assertThisInitialized(ce), "drawPageOnContainer", function(o) {
      var F = ce.state.svg;
      if (!(!o || !F)) {
        o.firstElementChild || o.appendChild(F);
        var t = ce.viewport, a = t.width, v = t.height;
        F.setAttribute("width", a), F.setAttribute("height", v);
      }
    }), ce;
  }
  return _createClass(le, [{
    key: "componentDidMount",
    value: function() {
      this.renderSVG();
    }
    /**
     * Called when a page is rendered successfully.
     */
  }, {
    key: "viewport",
    get: function() {
      var re = this.props, ae = re.page, J = re.rotate, o = re.scale;
      return ae.getViewport({
        scale: o,
        rotation: J
      });
    }
  }, {
    key: "render",
    value: function() {
      var re = this, ae = this.viewport, J = ae.width, o = ae.height;
      return /* @__PURE__ */ React.createElement("div", {
        className: "react-pdf__Page__svg",
        ref: function(t) {
          return re.drawPageOnContainer(t);
        },
        style: {
          display: "block",
          backgroundColor: "white",
          overflow: "hidden",
          width: J,
          height: o,
          userSelect: "none"
        }
      });
    }
  }]), le;
}(reactExports.PureComponent);
PageSVGInternal.propTypes = {
  onRenderError: propTypesExports.func,
  onRenderSuccess: propTypesExports.func,
  page: isPage.isRequired,
  rotate: isRotate,
  scale: propTypesExports.number.isRequired
};
function PageSVG(be) {
  return /* @__PURE__ */ React.createElement(PageContext.Consumer, null, function(ge) {
    return /* @__PURE__ */ React.createElement(PageSVGInternal, _extends({}, ge, be));
  });
}
function ownKeys$1(be, ge) {
  var le = Object.keys(be);
  if (Object.getOwnPropertySymbols) {
    var ce = Object.getOwnPropertySymbols(be);
    ge && (ce = ce.filter(function(re) {
      return Object.getOwnPropertyDescriptor(be, re).enumerable;
    })), le.push.apply(le, ce);
  }
  return le;
}
function _objectSpread$1(be) {
  for (var ge = 1; ge < arguments.length; ge++) {
    var le = arguments[ge] != null ? arguments[ge] : {};
    ge % 2 ? ownKeys$1(Object(le), !0).forEach(function(ce) {
      _defineProperty(be, ce, le[ce]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(be, Object.getOwnPropertyDescriptors(le)) : ownKeys$1(Object(le)).forEach(function(ce) {
      Object.defineProperty(be, ce, Object.getOwnPropertyDescriptor(le, ce));
    });
  }
  return be;
}
function _createSuper$2(be) {
  var ge = _isNativeReflectConstruct$2();
  return function() {
    var ce = _getPrototypeOf(be), re;
    if (ge) {
      var ae = _getPrototypeOf(this).constructor;
      re = Reflect.construct(ce, arguments, ae);
    } else
      re = ce.apply(this, arguments);
    return _possibleConstructorReturn(this, re);
  };
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
var TextLayerInternal = /* @__PURE__ */ function(be) {
  _inherits(le, be);
  var ge = _createSuper$2(le);
  function le() {
    var ce;
    _classCallCheck(this, le);
    for (var re = arguments.length, ae = new Array(re), J = 0; J < re; J++)
      ae[J] = arguments[J];
    return ce = ge.call.apply(ge, [this].concat(ae)), _defineProperty(_assertThisInitialized(ce), "state", {
      textContent: null
    }), _defineProperty(_assertThisInitialized(ce), "layerElement", /* @__PURE__ */ reactExports.createRef()), _defineProperty(_assertThisInitialized(ce), "endElement", /* @__PURE__ */ reactExports.createRef()), _defineProperty(_assertThisInitialized(ce), "loadTextContent", function() {
      var o = ce.props.page, F = makeCancellablePromise(o.getTextContent());
      ce.runningTask = F, F.promise.then(function(t) {
        ce.setState({
          textContent: t
        }, ce.onLoadSuccess);
      }).catch(function(t) {
        ce.onLoadError(t);
      });
    }), _defineProperty(_assertThisInitialized(ce), "onLoadSuccess", function() {
      var o = ce.props.onGetTextSuccess, F = ce.state.textContent;
      o && o(F);
    }), _defineProperty(_assertThisInitialized(ce), "onLoadError", function(o) {
      ce.setState({
        textItems: !1
      }), warning(o);
      var F = ce.props.onGetTextError;
      F && F(o);
    }), _defineProperty(_assertThisInitialized(ce), "onRenderSuccess", function() {
      var o = ce.props.onRenderTextLayerSuccess;
      o && o();
    }), _defineProperty(_assertThisInitialized(ce), "onRenderError", function(o) {
      warning(o);
      var F = ce.props.onRenderTextLayerError;
      F && F(o);
    }), _defineProperty(_assertThisInitialized(ce), "onMouseDown", function() {
      var o = ce.endElement.current;
      o && o.classList.add("active");
    }), _defineProperty(_assertThisInitialized(ce), "onMouseUp", function() {
      var o = ce.endElement.current;
      o && o.classList.remove("active");
    }), ce;
  }
  return _createClass(le, [{
    key: "componentDidMount",
    value: function() {
      var re = this.props.page;
      invariant(re, "Attempted to load page text content, but no page was specified."), warning(parseInt(window.getComputedStyle(document.body).getPropertyValue("--react-pdf-text-layer"), 10) === 1, "TextLayer styles not found. Read more: https://github.com/wojtekmaj/react-pdf#support-for-text-layer"), this.loadTextContent();
    }
  }, {
    key: "componentDidUpdate",
    value: function(re) {
      var ae = this.props.page;
      re.page && ae !== re.page && this.loadTextContent();
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      cancelRunningTask(this.runningTask);
    }
  }, {
    key: "viewport",
    get: function() {
      var re = this.props, ae = re.page, J = re.rotate, o = re.scale;
      return ae.getViewport({
        scale: o,
        rotation: J
      });
    }
  }, {
    key: "unrotatedViewport",
    get: function() {
      var re = this.props, ae = re.page, J = re.scale;
      return ae.getViewport({
        scale: J
      });
    }
    /**
     * It might happen that the page is rotated by default. In such cases, we shouldn't rotate
     * text content.
     */
  }, {
    key: "rotate",
    get: function() {
      var re = this.props, ae = re.page, J = re.rotate;
      return J - ae.rotate;
    }
  }, {
    key: "renderTextLayer",
    value: function() {
      var re = this, ae = this.state.textContent;
      if (!ae)
        return null;
      var J = this.layerElement.current, o = this.viewport, F = this.props, t = F.customTextRenderer, a = F.pageIndex, v = F.pageNumber;
      cancelRunningTask(this.runningTask), J.innerHTML = "";
      var h = {
        container: J,
        textContent: ae,
        viewport: o
      }, e = pdfExports.renderTextLayer(h);
      this.runningTask = e, e.promise.then(function() {
        var y = document.createElement("div");
        if (y.className = "endOfContent", J.append(y), re.endElement.current = y, t) {
          var c = 0;
          ae.items.forEach(function(d, m) {
            var p = re.layerElement.current.children[c], g = t(_objectSpread$1({
              pageIndex: a,
              pageNumber: v,
              itemIndex: m
            }, d));
            p.innerHTML = g, c += d.str && d.hasEOL ? 2 : 1;
          });
        }
        re.onRenderSuccess();
      }).catch(function(y) {
        re.onRenderError(y);
      });
    }
  }, {
    key: "render",
    value: function() {
      return (
        // eslint-disable-next-line jsx-a11y/no-static-element-interactions
        /* @__PURE__ */ React.createElement("div", {
          className: "react-pdf__Page__textContent textLayer",
          onMouseUp: this.onMouseUp,
          onMouseDown: this.onMouseDown,
          ref: this.layerElement
        }, this.renderTextLayer())
      );
    }
  }]), le;
}(reactExports.PureComponent);
TextLayerInternal.propTypes = {
  customTextRenderer: propTypesExports.func,
  onGetTextError: propTypesExports.func,
  onGetTextSuccess: propTypesExports.func,
  onRenderTextLayerError: propTypesExports.func,
  onRenderTextLayerSuccess: propTypesExports.func,
  page: isPage.isRequired,
  pageIndex: propTypesExports.number.isRequired,
  pageNumber: propTypesExports.number.isRequired,
  rotate: isRotate,
  scale: propTypesExports.number
};
function TextLayer(be) {
  return /* @__PURE__ */ React.createElement(PageContext.Consumer, null, function(ge) {
    return /* @__PURE__ */ React.createElement(TextLayerInternal, _extends({}, ge, be));
  });
}
function _createSuper$1(be) {
  var ge = _isNativeReflectConstruct$1();
  return function() {
    var ce = _getPrototypeOf(be), re;
    if (ge) {
      var ae = _getPrototypeOf(this).constructor;
      re = Reflect.construct(ce, arguments, ae);
    } else
      re = ce.apply(this, arguments);
    return _possibleConstructorReturn(this, re);
  };
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
var AnnotationLayerInternal = /* @__PURE__ */ function(be) {
  _inherits(le, be);
  var ge = _createSuper$1(le);
  function le() {
    var ce;
    _classCallCheck(this, le);
    for (var re = arguments.length, ae = new Array(re), J = 0; J < re; J++)
      ae[J] = arguments[J];
    return ce = ge.call.apply(ge, [this].concat(ae)), _defineProperty(_assertThisInitialized(ce), "state", {
      annotations: null
    }), _defineProperty(_assertThisInitialized(ce), "layerElement", /* @__PURE__ */ reactExports.createRef()), _defineProperty(_assertThisInitialized(ce), "loadAnnotations", function() {
      var o = ce.props.page, F = makeCancellablePromise(o.getAnnotations());
      ce.runningTask = F, F.promise.then(function(t) {
        ce.setState({
          annotations: t
        }, ce.onLoadSuccess);
      }).catch(function(t) {
        ce.onLoadError(t);
      });
    }), _defineProperty(_assertThisInitialized(ce), "onLoadSuccess", function() {
      var o = ce.props.onGetAnnotationsSuccess, F = ce.state.annotations;
      o && o(F);
    }), _defineProperty(_assertThisInitialized(ce), "onLoadError", function(o) {
      ce.setState({
        annotations: !1
      }), warning(o);
      var F = ce.props.onGetAnnotationsError;
      F && F(o);
    }), _defineProperty(_assertThisInitialized(ce), "onRenderSuccess", function() {
      var o = ce.props.onRenderAnnotationLayerSuccess;
      o && o();
    }), _defineProperty(_assertThisInitialized(ce), "onRenderError", function(o) {
      warning(o);
      var F = ce.props.onRenderAnnotationLayerError;
      F && F(o);
    }), ce;
  }
  return _createClass(le, [{
    key: "componentDidMount",
    value: function() {
      var re = this.props.page;
      invariant(re, "Attempted to load page annotations, but no page was specified."), warning(parseInt(window.getComputedStyle(document.body).getPropertyValue("--react-pdf-annotation-layer"), 10) === 1, "AnnotationLayer styles not found. Read more: https://github.com/wojtekmaj/react-pdf#support-for-annotations"), this.loadAnnotations();
    }
  }, {
    key: "componentDidUpdate",
    value: function(re) {
      var ae = this.props, J = ae.page, o = ae.renderForms;
      (re.page && J !== re.page || o !== re.renderForms) && this.loadAnnotations();
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      cancelRunningTask(this.runningTask);
    }
  }, {
    key: "viewport",
    get: function() {
      var re = this.props, ae = re.page, J = re.rotate, o = re.scale;
      return ae.getViewport({
        scale: o,
        rotation: J
      });
    }
  }, {
    key: "renderAnnotationLayer",
    value: function() {
      var re = this.state.annotations;
      if (re) {
        var ae = this.props, J = ae.imageResourcesPath, o = ae.linkService, F = ae.page, t = ae.renderForms, a = this.viewport.clone({
          dontFlip: !0
        }), v = {
          annotations: re,
          div: this.layerElement.current,
          imageResourcesPath: J,
          linkService: o,
          page: F,
          renderForms: t,
          viewport: a
        };
        this.layerElement.current.innerHTML = "";
        try {
          pdfExports.AnnotationLayer.render(v), this.onRenderSuccess();
        } catch (h) {
          this.onRenderError(h);
        }
      }
    }
  }, {
    key: "render",
    value: function() {
      return /* @__PURE__ */ React.createElement("div", {
        className: "react-pdf__Page__annotations annotationLayer",
        ref: this.layerElement
      }, this.renderAnnotationLayer());
    }
  }]), le;
}(reactExports.PureComponent);
AnnotationLayerInternal.propTypes = {
  imageResourcesPath: propTypesExports.string,
  linkService: isLinkService.isRequired,
  onGetAnnotationsError: propTypesExports.func,
  onGetAnnotationsSuccess: propTypesExports.func,
  onRenderAnnotationLayerError: propTypesExports.func,
  onRenderAnnotationLayerSuccess: propTypesExports.func,
  page: isPage,
  renderForms: propTypesExports.bool,
  rotate: isRotate,
  scale: propTypesExports.number
};
var AnnotationLayer = function be(ge) {
  return /* @__PURE__ */ React.createElement(DocumentContext.Consumer, null, function(le) {
    return /* @__PURE__ */ React.createElement(PageContext.Consumer, null, function(ce) {
      return /* @__PURE__ */ React.createElement(AnnotationLayerInternal, _extends({}, le, ce, ge));
    });
  });
};
function ownKeys(be, ge) {
  var le = Object.keys(be);
  if (Object.getOwnPropertySymbols) {
    var ce = Object.getOwnPropertySymbols(be);
    ge && (ce = ce.filter(function(re) {
      return Object.getOwnPropertyDescriptor(be, re).enumerable;
    })), le.push.apply(le, ce);
  }
  return le;
}
function _objectSpread(be) {
  for (var ge = 1; ge < arguments.length; ge++) {
    var le = arguments[ge] != null ? arguments[ge] : {};
    ge % 2 ? ownKeys(Object(le), !0).forEach(function(ce) {
      _defineProperty(be, ce, le[ce]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(be, Object.getOwnPropertyDescriptors(le)) : ownKeys(Object(le)).forEach(function(ce) {
      Object.defineProperty(be, ce, Object.getOwnPropertyDescriptor(le, ce));
    });
  }
  return be;
}
function _createSuper(be) {
  var ge = _isNativeReflectConstruct();
  return function() {
    var ce = _getPrototypeOf(be), re;
    if (ge) {
      var ae = _getPrototypeOf(this).constructor;
      re = Reflect.construct(ce, arguments, ae);
    } else
      re = ce.apply(this, arguments);
    return _possibleConstructorReturn(this, re);
  };
}
function _isNativeReflectConstruct() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
var defaultScale = 1, PageInternal = /* @__PURE__ */ function(be) {
  _inherits(le, be);
  var ge = _createSuper(le);
  function le() {
    var ce;
    _classCallCheck(this, le);
    for (var re = arguments.length, ae = new Array(re), J = 0; J < re; J++)
      ae[J] = arguments[J];
    return ce = ge.call.apply(ge, [this].concat(ae)), _defineProperty(_assertThisInitialized(ce), "state", {
      page: null
    }), _defineProperty(_assertThisInitialized(ce), "pageElement", /* @__PURE__ */ reactExports.createRef()), _defineProperty(_assertThisInitialized(ce), "onLoadSuccess", function() {
      var o = ce.props, F = o.onLoadSuccess, t = o.registerPage, a = ce.state.page;
      F && F(makePageCallback(a, ce.scale)), t && t(ce.pageIndex, ce.pageElement.current);
    }), _defineProperty(_assertThisInitialized(ce), "onLoadError", function(o) {
      ce.setState({
        page: !1
      }), warning(o);
      var F = ce.props.onLoadError;
      F && F(o);
    }), _defineProperty(_assertThisInitialized(ce), "loadPage", function() {
      var o = ce.props.pdf, F = ce.getPageNumber();
      if (F) {
        ce.setState(function(a) {
          return a.page ? {
            page: null
          } : null;
        });
        var t = makeCancellablePromise(o.getPage(F));
        ce.runningTask = t, t.promise.then(function(a) {
          ce.setState({
            page: a
          }, ce.onLoadSuccess);
        }).catch(function(a) {
          ce.onLoadError(a);
        });
      }
    }), ce;
  }
  return _createClass(le, [{
    key: "componentDidMount",
    value: function() {
      var re = this.props.pdf;
      invariant(re, "Attempted to load a page, but no document was specified."), this.loadPage();
    }
  }, {
    key: "componentDidUpdate",
    value: function(re) {
      var ae = this.props.pdf;
      if (re.pdf && ae !== re.pdf || this.getPageNumber() !== this.getPageNumber(re)) {
        var J = this.props.unregisterPage;
        J && J(this.getPageIndex(re)), this.loadPage();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      var re = this.props.unregisterPage;
      re && re(this.pageIndex), cancelRunningTask(this.runningTask);
    }
  }, {
    key: "childContext",
    get: function() {
      var re = this.pageIndex, ae = this.pageNumber, J = this.state.page;
      if (!J)
        return {};
      var o = this.props, F = o.canvasBackground, t = o.customTextRenderer, a = o.devicePixelRatio, v = o.onGetAnnotationsError, h = o.onGetAnnotationsSuccess, e = o.onGetTextError, y = o.onGetTextSuccess, c = o.onRenderAnnotationLayerError, d = o.onRenderAnnotationLayerSuccess, m = o.onRenderError, p = o.onRenderSuccess, g = o.onRenderTextLayerError, n = o.onRenderTextLayerSuccess, i = o.renderForms, l = o.renderInteractiveForms;
      return {
        canvasBackground: F,
        customTextRenderer: t,
        devicePixelRatio: a,
        onGetAnnotationsError: v,
        onGetAnnotationsSuccess: h,
        onGetTextError: e,
        onGetTextSuccess: y,
        onRenderAnnotationLayerError: c,
        onRenderAnnotationLayerSuccess: d,
        onRenderError: m,
        onRenderSuccess: p,
        onRenderTextLayerError: g,
        onRenderTextLayerSuccess: n,
        page: J,
        pageIndex: re,
        pageNumber: ae,
        renderForms: i ?? l,
        // For backward compatibility
        rotate: this.rotate,
        scale: this.scale
      };
    }
    /**
     * Called when a page is loaded successfully
     */
  }, {
    key: "getPageIndex",
    value: function() {
      var re = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.props;
      return isProvided(re.pageNumber) ? re.pageNumber - 1 : isProvided(re.pageIndex) ? re.pageIndex : null;
    }
  }, {
    key: "getPageNumber",
    value: function() {
      var re = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.props;
      return isProvided(re.pageNumber) ? re.pageNumber : isProvided(re.pageIndex) ? re.pageIndex + 1 : null;
    }
  }, {
    key: "pageIndex",
    get: function() {
      return this.getPageIndex();
    }
  }, {
    key: "pageNumber",
    get: function() {
      return this.getPageNumber();
    }
  }, {
    key: "rotate",
    get: function() {
      var re = this.props.rotate;
      if (isProvided(re))
        return re;
      var ae = this.state.page;
      return ae ? ae.rotate : null;
    }
  }, {
    key: "scale",
    get: function() {
      var re = this.state.page;
      if (!re)
        return null;
      var ae = this.props, J = ae.scale, o = ae.width, F = ae.height, t = this.rotate, a = 1, v = J === null ? defaultScale : J;
      if (o || F) {
        var h = re.getViewport({
          scale: 1,
          rotation: t
        });
        a = o ? o / h.width : F / h.height;
      }
      return v * a;
    }
  }, {
    key: "eventProps",
    get: function() {
      var re = this;
      return makeEventProps(this.props, function() {
        var ae = re.state.page;
        return ae && makePageCallback(ae, re.scale);
      });
    }
  }, {
    key: "pageKey",
    get: function() {
      return "".concat(this.pageIndex, "@").concat(this.scale, "/").concat(this.rotate);
    }
  }, {
    key: "pageKeyNoScale",
    get: function() {
      return "".concat(this.pageIndex, "/").concat(this.rotate);
    }
  }, {
    key: "renderMainLayer",
    value: function() {
      var re = this.props, ae = re.canvasRef, J = re.renderMode;
      switch (J) {
        case "none":
          return null;
        case "svg":
          return /* @__PURE__ */ React.createElement(PageSVG, {
            key: "".concat(this.pageKeyNoScale, "_svg")
          });
        case "canvas":
        default:
          return /* @__PURE__ */ React.createElement(PageCanvas, {
            key: "".concat(this.pageKey, "_canvas"),
            canvasRef: ae
          });
      }
    }
  }, {
    key: "renderTextLayer",
    value: function() {
      var re = this.props.renderTextLayer;
      return re ? /* @__PURE__ */ React.createElement(TextLayer, {
        key: "".concat(this.pageKey, "_text")
      }) : null;
    }
  }, {
    key: "renderAnnotationLayer",
    value: function() {
      var re = this.props.renderAnnotationLayer;
      return re ? /* @__PURE__ */ React.createElement(AnnotationLayer, {
        key: "".concat(this.pageKey, "_annotations")
      }) : null;
    }
  }, {
    key: "renderChildren",
    value: function() {
      var re = this.props.children;
      return /* @__PURE__ */ React.createElement(PageContext.Provider, {
        value: this.childContext
      }, this.renderMainLayer(), this.renderTextLayer(), this.renderAnnotationLayer(), re);
    }
  }, {
    key: "renderContent",
    value: function() {
      var re = this.pageNumber, ae = this.props.pdf, J = this.state.page;
      if (!re) {
        var o = this.props.noData;
        return /* @__PURE__ */ React.createElement(Message, {
          type: "no-data"
        }, typeof o == "function" ? o() : o);
      }
      if (ae === null || J === null) {
        var F = this.props.loading;
        return /* @__PURE__ */ React.createElement(Message, {
          type: "loading"
        }, typeof F == "function" ? F() : F);
      }
      if (ae === !1 || J === !1) {
        var t = this.props.error;
        return /* @__PURE__ */ React.createElement(Message, {
          type: "error"
        }, typeof t == "function" ? t() : t);
      }
      return this.renderChildren();
    }
  }, {
    key: "render",
    value: function() {
      var re = this.pageNumber, ae = this.props, J = ae.className, o = ae.inputRef;
      return /* @__PURE__ */ React.createElement("div", _extends({
        className: clsx("react-pdf__Page", J),
        "data-page-number": re,
        ref: mergeRefs(o, this.pageElement),
        style: {
          position: "relative",
          minWidth: "min-content",
          minHeight: "min-content"
        }
      }, this.eventProps), this.renderContent());
    }
  }]), le;
}(reactExports.PureComponent);
PageInternal.defaultProps = {
  error: "Failed to load the page.",
  loading: "Loading page…",
  noData: "No page specified.",
  renderAnnotationLayer: !0,
  renderMode: "canvas",
  renderTextLayer: !0,
  scale: defaultScale
};
var isFunctionOrNode = propTypesExports.oneOfType([propTypesExports.func, propTypesExports.node]);
PageInternal.propTypes = _objectSpread(_objectSpread({}, eventProps), {}, {
  canvasBackground: propTypesExports.string,
  children: propTypesExports.node,
  className: isClassName,
  customTextRenderer: propTypesExports.func,
  devicePixelRatio: propTypesExports.number,
  error: isFunctionOrNode,
  height: propTypesExports.number,
  imageResourcesPath: propTypesExports.string,
  inputRef: isRef,
  loading: isFunctionOrNode,
  noData: isFunctionOrNode,
  onGetTextError: propTypesExports.func,
  onGetTextSuccess: propTypesExports.func,
  onLoadError: propTypesExports.func,
  onLoadSuccess: propTypesExports.func,
  onRenderError: propTypesExports.func,
  onRenderSuccess: propTypesExports.func,
  onRenderTextLayerError: propTypesExports.func,
  onRenderTextLayerSuccess: propTypesExports.func,
  pageIndex: isPageIndex,
  pageNumber: isPageNumber,
  pdf: isPdf,
  registerPage: propTypesExports.func,
  renderAnnotationLayer: propTypesExports.bool,
  renderForms: propTypesExports.bool,
  renderInteractiveForms: propTypesExports.bool,
  // For backward compatibility
  renderMode: isRenderMode,
  renderTextLayer: propTypesExports.bool,
  rotate: isRotate,
  scale: propTypesExports.number,
  unregisterPage: propTypesExports.func,
  width: propTypesExports.number
});
function Page(be, ge) {
  return /* @__PURE__ */ React.createElement(DocumentContext.Consumer, null, function(le) {
    return /* @__PURE__ */ React.createElement(PageInternal, _extends({
      ref: ge
    }, le, be));
  });
}
const Page$1 = /* @__PURE__ */ React.forwardRef(Page);
displayWorkerWarning();
pdfExports.GlobalWorkerOptions.workerSrc = "pdf.worker.js";
var pdf_worker_entry = {}, pdf_workerExports = {}, pdf_worker = {
  get exports() {
    return pdf_workerExports;
  },
  set exports(be) {
    pdf_workerExports = be;
  }
};
(function(be, ge) {
  (function(ce, re) {
    be.exports = re();
  })(globalThis, () => (
    /******/
    (() => {
      var le = [
        ,
        /* 1 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.WorkerTask = o.WorkerMessageHandler = void 0;
          var t = F(2), a = F(5), v = F(6), h = F(8), e = F(71), y = F(65), c = F(4), d = F(102), m = F(103);
          class p {
            constructor(l) {
              this.name = l, this.terminated = !1, this._capability = (0, t.createPromiseCapability)();
            }
            get finished() {
              return this._capability.promise;
            }
            finish() {
              this._capability.resolve();
            }
            terminate() {
              this.terminated = !0;
            }
            ensureNotTerminated() {
              if (this.terminated)
                throw new Error("Worker task was terminated");
            }
          }
          o.WorkerTask = p;
          class g {
            static setup(l, u) {
              let w = !1;
              l.on("test", function(b) {
                w || (w = !0, l.send("test", b instanceof Uint8Array));
              }), l.on("configure", function(b) {
                (0, t.setVerbosityLevel)(b.verbosity);
              }), l.on("GetDocRequest", function(b) {
                return g.createDocumentHandler(b, u);
              });
            }
            static createDocumentHandler(l, u) {
              let w, O = !1, b = null;
              const A = [], Y = (0, t.getVerbosityLevel)(), j = l.apiVersion, X = "2.16.105";
              if (j !== X)
                throw new Error(`The API version "${j}" does not match the Worker version "${X}".`);
              const B = [];
              for (const M in [])
                B.push(M);
              if (B.length)
                throw new Error("The `Array.prototype` contains unexpected enumerable properties: " + B.join(", ") + "; thus breaking e.g. `for...in` iteration of `Array`s.");
              if (typeof ReadableStream > "u") {
                const M = "The browser/environment lacks native support for critical functionality used by the PDF.js library (e.g. `ReadableStream`); ";
                throw c.isNodeJS ? new Error(M + "please use a `legacy`-build instead.") : new Error(M + "please update to a supported browser.");
              }
              const U = l.docId, k = l.docBaseUrl, x = l.docId + "_worker";
              let f = new d.MessageHandler(x, U, u);
              function D() {
                if (O)
                  throw new Error("Worker was terminated");
              }
              function _(M) {
                A.push(M);
              }
              function S(M) {
                M.finish();
                const G = A.indexOf(M);
                A.splice(G, 1);
              }
              async function C(M) {
                await w.ensureDoc("checkHeader"), await w.ensureDoc("parseStartXRef"), await w.ensureDoc("parse", [M]), await w.ensureDoc("checkFirstPage", [M]), await w.ensureDoc("checkLastPage", [M]);
                const G = await w.ensureDoc("isPureXfa");
                if (G) {
                  const V = new p("loadXfaFonts");
                  _(V), await Promise.all([w.loadXfaFonts(f, V).catch((L) => {
                  }).then(() => S(V)), w.loadXfaImages()]);
                }
                const [Z, $] = await Promise.all([w.ensureDoc("numPages"), w.ensureDoc("fingerprints")]), z = G ? await w.ensureDoc("htmlForXfa") : null;
                return {
                  numPages: Z,
                  fingerprints: $,
                  htmlForXfa: z
                };
              }
              function T(M, G, Z) {
                const $ = (0, t.createPromiseCapability)();
                let z;
                const V = M.source;
                if (V.data) {
                  try {
                    z = new h.LocalPdfManager(U, V.data, V.password, f, G, Z, k), $.resolve(z);
                  } catch (Q) {
                    $.reject(Q);
                  }
                  return $.promise;
                }
                let L, K = [];
                try {
                  L = new m.PDFWorkerStream(f);
                } catch (Q) {
                  return $.reject(Q), $.promise;
                }
                const ne = L.getFullReader();
                ne.headersReady.then(function() {
                  if (!ne.isRangeSupported)
                    return;
                  const Q = V.disableAutoFetch || ne.isStreamingSupported;
                  z = new h.NetworkPdfManager(U, L, {
                    msgHandler: f,
                    password: V.password,
                    length: ne.contentLength,
                    disableAutoFetch: Q,
                    rangeChunkSize: V.rangeChunkSize
                  }, G, Z, k);
                  for (const E of K)
                    z.sendProgressiveData(E);
                  K = [], $.resolve(z), b = null;
                }).catch(function(Q) {
                  $.reject(Q), b = null;
                });
                let se = 0;
                const q = function() {
                  const Q = (0, t.arraysToBytes)(K);
                  V.length && Q.length !== V.length && (0, t.warn)("reported HTTP length is different from actual");
                  try {
                    z = new h.LocalPdfManager(U, Q, V.password, f, G, Z, k), $.resolve(z);
                  } catch (E) {
                    $.reject(E);
                  }
                  K = [];
                };
                return new Promise(function(Q, E) {
                  const te = function({
                    value: oe,
                    done: ee
                  }) {
                    try {
                      if (D(), ee) {
                        z || q(), b = null;
                        return;
                      }
                      se += (0, t.arrayByteLength)(oe), ne.isStreamingSupported || f.send("DocProgress", {
                        loaded: se,
                        total: Math.max(se, ne.contentLength || 0)
                      }), z ? z.sendProgressiveData(oe) : K.push(oe), ne.read().then(te, E);
                    } catch (W) {
                      E(W);
                    }
                  };
                  ne.read().then(te, E);
                }).catch(function(Q) {
                  $.reject(Q), b = null;
                }), b = function(Q) {
                  L.cancelAllRequests(Q);
                }, $.promise;
              }
              function P(M) {
                function G(V) {
                  D(), f.send("GetDoc", {
                    pdfInfo: V
                  });
                }
                function Z(V) {
                  if (D(), V instanceof t.PasswordException) {
                    const L = new p(`PasswordException: response ${V.code}`);
                    _(L), f.sendWithPromise("PasswordRequest", V).then(function({
                      password: K
                    }) {
                      S(L), w.updatePassword(K), $();
                    }).catch(function() {
                      S(L), f.send("DocException", V);
                    });
                  } else
                    V instanceof t.InvalidPDFException || V instanceof t.MissingPDFException || V instanceof t.UnexpectedResponseException || V instanceof t.UnknownErrorException ? f.send("DocException", V) : f.send("DocException", new t.UnknownErrorException(V.message, V.toString()));
                }
                function $() {
                  D(), C(!1).then(G, function(V) {
                    if (D(), !(V instanceof v.XRefParseException)) {
                      Z(V);
                      return;
                    }
                    w.requestLoadedStream(), w.onLoadedStream().then(function() {
                      D(), C(!0).then(G, Z);
                    });
                  });
                }
                D();
                const z = {
                  maxImageSize: M.maxImageSize,
                  disableFontFace: M.disableFontFace,
                  ignoreErrors: M.ignoreErrors,
                  isEvalSupported: M.isEvalSupported,
                  fontExtraProperties: M.fontExtraProperties,
                  useSystemFonts: M.useSystemFonts,
                  cMapUrl: M.cMapUrl,
                  standardFontDataUrl: M.standardFontDataUrl
                };
                T(M, z, M.enableXfa).then(function(V) {
                  if (O)
                    throw V.terminate(new t.AbortException("Worker was terminated.")), new Error("Worker was terminated");
                  w = V, w.onLoadedStream().then(function(L) {
                    f.send("DataLoaded", {
                      length: L.bytes.byteLength
                    });
                  });
                }).then($, Z);
              }
              return f.on("GetPage", function(G) {
                return w.getPage(G.pageIndex).then(function(Z) {
                  return Promise.all([w.ensure(Z, "rotate"), w.ensure(Z, "ref"), w.ensure(Z, "userUnit"), w.ensure(Z, "view")]).then(function([$, z, V, L]) {
                    return {
                      rotate: $,
                      ref: z,
                      userUnit: V,
                      view: L
                    };
                  });
                });
              }), f.on("GetPageIndex", function(G) {
                const Z = a.Ref.get(G.num, G.gen);
                return w.ensureCatalog("getPageIndex", [Z]);
              }), f.on("GetDestinations", function(G) {
                return w.ensureCatalog("destinations");
              }), f.on("GetDestination", function(G) {
                return w.ensureCatalog("getDestination", [G.id]);
              }), f.on("GetPageLabels", function(G) {
                return w.ensureCatalog("pageLabels");
              }), f.on("GetPageLayout", function(G) {
                return w.ensureCatalog("pageLayout");
              }), f.on("GetPageMode", function(G) {
                return w.ensureCatalog("pageMode");
              }), f.on("GetViewerPreferences", function(M) {
                return w.ensureCatalog("viewerPreferences");
              }), f.on("GetOpenAction", function(M) {
                return w.ensureCatalog("openAction");
              }), f.on("GetAttachments", function(G) {
                return w.ensureCatalog("attachments");
              }), f.on("GetJavaScript", function(G) {
                return w.ensureCatalog("javaScript");
              }), f.on("GetDocJSActions", function(G) {
                return w.ensureCatalog("jsActions");
              }), f.on("GetPageJSActions", function({
                pageIndex: M
              }) {
                return w.getPage(M).then(function(G) {
                  return w.ensure(G, "jsActions");
                });
              }), f.on("GetOutline", function(G) {
                return w.ensureCatalog("documentOutline");
              }), f.on("GetOptionalContentConfig", function(M) {
                return w.ensureCatalog("optionalContentConfig");
              }), f.on("GetPermissions", function(M) {
                return w.ensureCatalog("permissions");
              }), f.on("GetMetadata", function(G) {
                return Promise.all([w.ensureDoc("documentInfo"), w.ensureCatalog("metadata")]);
              }), f.on("GetMarkInfo", function(G) {
                return w.ensureCatalog("markInfo");
              }), f.on("GetData", function(G) {
                return w.requestLoadedStream(), w.onLoadedStream().then(function(Z) {
                  return Z.bytes;
                });
              }), f.on("GetAnnotations", function({
                pageIndex: M,
                intent: G
              }) {
                return w.getPage(M).then(function(Z) {
                  const $ = new p(`GetAnnotations: page ${M}`);
                  return _($), Z.getAnnotationsData(f, $, G).then((z) => (S($), z), (z) => {
                    S($);
                  });
                });
              }), f.on("GetFieldObjects", function(M) {
                return w.ensureDoc("fieldObjects");
              }), f.on("HasJSActions", function(M) {
                return w.ensureDoc("hasJSActions");
              }), f.on("GetCalculationOrderIds", function(M) {
                return w.ensureDoc("calculationOrderIds");
              }), f.on("SaveDocument", function({
                isPureXfa: M,
                numPages: G,
                annotationStorage: Z,
                filename: $
              }) {
                w.requestLoadedStream();
                const z = M ? null : (0, v.getNewAnnotationsMap)(Z), V = [w.onLoadedStream(), w.ensureCatalog("acroForm"), w.ensureCatalog("acroFormRef"), w.ensureDoc("xref"), w.ensureDoc("startXRef")];
                if (z)
                  for (const [L, K] of z)
                    V.push(w.getPage(L).then((ne) => {
                      const se = new p(`Save (editor): page ${L}`);
                      return ne.saveNewAnnotations(f, se, K).finally(function() {
                        S(se);
                      });
                    }));
                if (M)
                  V.push(w.serializeXfaData(Z));
                else
                  for (let L = 0; L < G; L++)
                    V.push(w.getPage(L).then(function(K) {
                      const ne = new p(`Save: page ${L}`);
                      return K.save(f, ne, Z).finally(function() {
                        S(ne);
                      });
                    }));
                return Promise.all(V).then(function([L, K, ne, se, q, ...N]) {
                  let Q = [], E = null;
                  if (M) {
                    if (E = N[0], !E)
                      return L.bytes;
                  } else if (Q = N.flat(2), Q.length === 0)
                    return L.bytes;
                  const te = K instanceof a.Dict && K.get("XFA") || null;
                  let oe = null, ee = !1;
                  if (Array.isArray(te)) {
                    for (let I = 0, H = te.length; I < H; I += 2)
                      te[I] === "datasets" && (oe = te[I + 1], ne = null, ee = !0);
                    oe === null && (oe = se.getNewRef());
                  } else
                    te && (ne = null, (0, t.warn)("Unsupported XFA type."));
                  let W = /* @__PURE__ */ Object.create(null);
                  if (se.trailer) {
                    const I = /* @__PURE__ */ Object.create(null), H = se.trailer.get("Info") || null;
                    H instanceof a.Dict && H.forEach((ie, ue) => {
                      typeof ue == "string" && (I[ie] = (0, t.stringToPDFString)(ue));
                    }), W = {
                      rootRef: se.trailer.getRaw("Root") || null,
                      encryptRef: se.trailer.getRaw("Encrypt") || null,
                      newRef: se.getNewRef(),
                      infoRef: se.trailer.getRaw("Info") || null,
                      info: I,
                      fileIds: se.trailer.get("ID") || null,
                      startXRef: q,
                      filename: $
                    };
                  }
                  return se.resetNewRef(), (0, y.incrementalUpdate)({
                    originalData: L.bytes,
                    xrefInfo: W,
                    newRefs: Q,
                    xref: se,
                    hasXfa: !!te,
                    xfaDatasetsRef: oe,
                    hasXfaDatasetsEntry: ee,
                    acroFormRef: ne,
                    acroForm: K,
                    xfaData: E
                  });
                });
              }), f.on("GetOperatorList", function(G, Z) {
                const $ = G.pageIndex;
                w.getPage($).then(function(z) {
                  const V = new p(`GetOperatorList: page ${$}`);
                  _(V);
                  const L = Y >= t.VerbosityLevel.INFOS ? Date.now() : 0;
                  z.getOperatorList({
                    handler: f,
                    sink: Z,
                    task: V,
                    intent: G.intent,
                    cacheKey: G.cacheKey,
                    annotationStorage: G.annotationStorage
                  }).then(function(K) {
                    S(V), L && (0, t.info)(`page=${$ + 1} - getOperatorList: time=${Date.now() - L}ms, len=${K.length}`), Z.close();
                  }, function(K) {
                    S(V), !V.terminated && (f.send("UnsupportedFeature", {
                      featureId: t.UNSUPPORTED_FEATURES.errorOperatorList
                    }), Z.error(K));
                  });
                });
              }), f.on("GetTextContent", function(G, Z) {
                const $ = G.pageIndex;
                w.getPage($).then(function(z) {
                  const V = new p("GetTextContent: page " + $);
                  _(V);
                  const L = Y >= t.VerbosityLevel.INFOS ? Date.now() : 0;
                  z.extractTextContent({
                    handler: f,
                    task: V,
                    sink: Z,
                    includeMarkedContent: G.includeMarkedContent,
                    combineTextItems: G.combineTextItems
                  }).then(function() {
                    S(V), L && (0, t.info)(`page=${$ + 1} - getTextContent: time=${Date.now() - L}ms`), Z.close();
                  }, function(K) {
                    S(V), !V.terminated && Z.error(K);
                  });
                });
              }), f.on("GetStructTree", function(G) {
                return w.getPage(G.pageIndex).then(function(Z) {
                  return w.ensure(Z, "getStructTree");
                });
              }), f.on("FontFallback", function(M) {
                return w.fontFallback(M.id, f);
              }), f.on("Cleanup", function(G) {
                return w.cleanup(!0);
              }), f.on("Terminate", function(G) {
                O = !0;
                const Z = [];
                if (w) {
                  w.terminate(new t.AbortException("Worker was terminated."));
                  const $ = w.cleanup();
                  Z.push($), w = null;
                } else
                  (0, e.clearGlobalCaches)();
                b && b(new t.AbortException("Worker was terminated."));
                for (const $ of A)
                  Z.push($.finished), $.terminate();
                return Promise.all(Z).then(function() {
                  f.destroy(), f = null;
                });
              }), f.on("Ready", function(G) {
                P(l), l = null;
              }), x;
            }
            static initializeFromPort(l) {
              const u = new d.MessageHandler("worker", "main", l);
              g.setup(u, l), u.send("ready", null);
            }
          }
          o.WorkerMessageHandler = g;
          function n(i) {
            return typeof i.postMessage == "function" && "onmessage" in i;
          }
          typeof window > "u" && !c.isNodeJS && typeof self < "u" && n(self) && g.initializeFromPort(self);
        },
        /* 2 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.VerbosityLevel = o.Util = o.UnknownErrorException = o.UnexpectedResponseException = o.UNSUPPORTED_FEATURES = o.TextRenderingMode = o.StreamType = o.RenderingIntentFlag = o.PermissionFlag = o.PasswordResponses = o.PasswordException = o.PageActionEventType = o.OPS = o.MissingPDFException = o.LINE_FACTOR = o.LINE_DESCENT_FACTOR = o.InvalidPDFException = o.ImageKind = o.IDENTITY_MATRIX = o.FormatError = o.FontType = o.FeatureTest = o.FONT_IDENTITY_MATRIX = o.DocumentActionEventType = o.CMapCompressionType = o.BaseException = o.AnnotationType = o.AnnotationStateModelType = o.AnnotationReviewState = o.AnnotationReplyType = o.AnnotationMode = o.AnnotationMarkedState = o.AnnotationFlag = o.AnnotationFieldFlag = o.AnnotationEditorType = o.AnnotationEditorPrefix = o.AnnotationEditorParamsType = o.AnnotationBorderStyleType = o.AnnotationActionEventType = o.AbortException = void 0, o.arrayByteLength = W, o.arraysToBytes = I, o.assert = $, o.bytesToString = oe, o.createPromiseCapability = it, o.createValidAbsoluteUrl = V, o.escapeString = ke, o.getModificationDate = Ge, o.getVerbosityLevel = P, o.info = M, o.isArrayBuffer = ve, o.isArrayEqual = Ne, o.isAscii = ye, o.objectFromMap = ue, o.objectSize = ie, o.setVerbosityLevel = T, o.shadow = L, o.string32 = H, o.stringToBytes = ee, o.stringToPDFString = Ce, o.stringToUTF16BEString = De, o.stringToUTF8String = Ae, o.unreachable = Z, o.utf8StringToString = Te, o.warn = G, F(3);
          const t = [1, 0, 0, 1, 0, 0];
          o.IDENTITY_MATRIX = t;
          const a = [1e-3, 0, 0, 1e-3, 0, 0];
          o.FONT_IDENTITY_MATRIX = a;
          const v = 1.35;
          o.LINE_FACTOR = v;
          const h = 0.35;
          o.LINE_DESCENT_FACTOR = h;
          const e = {
            ANY: 1,
            DISPLAY: 2,
            PRINT: 4,
            ANNOTATIONS_FORMS: 16,
            ANNOTATIONS_STORAGE: 32,
            ANNOTATIONS_DISABLE: 64,
            OPLIST: 256
          };
          o.RenderingIntentFlag = e;
          const y = {
            DISABLE: 0,
            ENABLE: 1,
            ENABLE_FORMS: 2,
            ENABLE_STORAGE: 3
          };
          o.AnnotationMode = y;
          const c = "pdfjs_internal_editor_";
          o.AnnotationEditorPrefix = c;
          const d = {
            DISABLE: -1,
            NONE: 0,
            FREETEXT: 3,
            INK: 15
          };
          o.AnnotationEditorType = d;
          const m = {
            FREETEXT_SIZE: 1,
            FREETEXT_COLOR: 2,
            FREETEXT_OPACITY: 3,
            INK_COLOR: 11,
            INK_THICKNESS: 12,
            INK_OPACITY: 13
          };
          o.AnnotationEditorParamsType = m;
          const p = {
            PRINT: 4,
            MODIFY_CONTENTS: 8,
            COPY: 16,
            MODIFY_ANNOTATIONS: 32,
            FILL_INTERACTIVE_FORMS: 256,
            COPY_FOR_ACCESSIBILITY: 512,
            ASSEMBLE: 1024,
            PRINT_HIGH_QUALITY: 2048
          };
          o.PermissionFlag = p;
          const g = {
            FILL: 0,
            STROKE: 1,
            FILL_STROKE: 2,
            INVISIBLE: 3,
            FILL_ADD_TO_PATH: 4,
            STROKE_ADD_TO_PATH: 5,
            FILL_STROKE_ADD_TO_PATH: 6,
            ADD_TO_PATH: 7,
            FILL_STROKE_MASK: 3,
            ADD_TO_PATH_FLAG: 4
          };
          o.TextRenderingMode = g;
          const n = {
            GRAYSCALE_1BPP: 1,
            RGB_24BPP: 2,
            RGBA_32BPP: 3
          };
          o.ImageKind = n;
          const i = {
            TEXT: 1,
            LINK: 2,
            FREETEXT: 3,
            LINE: 4,
            SQUARE: 5,
            CIRCLE: 6,
            POLYGON: 7,
            POLYLINE: 8,
            HIGHLIGHT: 9,
            UNDERLINE: 10,
            SQUIGGLY: 11,
            STRIKEOUT: 12,
            STAMP: 13,
            CARET: 14,
            INK: 15,
            POPUP: 16,
            FILEATTACHMENT: 17,
            SOUND: 18,
            MOVIE: 19,
            WIDGET: 20,
            SCREEN: 21,
            PRINTERMARK: 22,
            TRAPNET: 23,
            WATERMARK: 24,
            THREED: 25,
            REDACT: 26
          };
          o.AnnotationType = i;
          const l = {
            MARKED: "Marked",
            REVIEW: "Review"
          };
          o.AnnotationStateModelType = l;
          const u = {
            MARKED: "Marked",
            UNMARKED: "Unmarked"
          };
          o.AnnotationMarkedState = u;
          const w = {
            ACCEPTED: "Accepted",
            REJECTED: "Rejected",
            CANCELLED: "Cancelled",
            COMPLETED: "Completed",
            NONE: "None"
          };
          o.AnnotationReviewState = w;
          const O = {
            GROUP: "Group",
            REPLY: "R"
          };
          o.AnnotationReplyType = O;
          const b = {
            INVISIBLE: 1,
            HIDDEN: 2,
            PRINT: 4,
            NOZOOM: 8,
            NOROTATE: 16,
            NOVIEW: 32,
            READONLY: 64,
            LOCKED: 128,
            TOGGLENOVIEW: 256,
            LOCKEDCONTENTS: 512
          };
          o.AnnotationFlag = b;
          const A = {
            READONLY: 1,
            REQUIRED: 2,
            NOEXPORT: 4,
            MULTILINE: 4096,
            PASSWORD: 8192,
            NOTOGGLETOOFF: 16384,
            RADIO: 32768,
            PUSHBUTTON: 65536,
            COMBO: 131072,
            EDIT: 262144,
            SORT: 524288,
            FILESELECT: 1048576,
            MULTISELECT: 2097152,
            DONOTSPELLCHECK: 4194304,
            DONOTSCROLL: 8388608,
            COMB: 16777216,
            RICHTEXT: 33554432,
            RADIOSINUNISON: 33554432,
            COMMITONSELCHANGE: 67108864
          };
          o.AnnotationFieldFlag = A;
          const Y = {
            SOLID: 1,
            DASHED: 2,
            BEVELED: 3,
            INSET: 4,
            UNDERLINE: 5
          };
          o.AnnotationBorderStyleType = Y;
          const j = {
            E: "Mouse Enter",
            X: "Mouse Exit",
            D: "Mouse Down",
            U: "Mouse Up",
            Fo: "Focus",
            Bl: "Blur",
            PO: "PageOpen",
            PC: "PageClose",
            PV: "PageVisible",
            PI: "PageInvisible",
            K: "Keystroke",
            F: "Format",
            V: "Validate",
            C: "Calculate"
          };
          o.AnnotationActionEventType = j;
          const X = {
            WC: "WillClose",
            WS: "WillSave",
            DS: "DidSave",
            WP: "WillPrint",
            DP: "DidPrint"
          };
          o.DocumentActionEventType = X;
          const B = {
            O: "PageOpen",
            C: "PageClose"
          };
          o.PageActionEventType = B;
          const U = {
            UNKNOWN: "UNKNOWN",
            FLATE: "FLATE",
            LZW: "LZW",
            DCT: "DCT",
            JPX: "JPX",
            JBIG: "JBIG",
            A85: "A85",
            AHX: "AHX",
            CCF: "CCF",
            RLX: "RLX"
          };
          o.StreamType = U;
          const k = {
            UNKNOWN: "UNKNOWN",
            TYPE1: "TYPE1",
            TYPE1STANDARD: "TYPE1STANDARD",
            TYPE1C: "TYPE1C",
            CIDFONTTYPE0: "CIDFONTTYPE0",
            CIDFONTTYPE0C: "CIDFONTTYPE0C",
            TRUETYPE: "TRUETYPE",
            CIDFONTTYPE2: "CIDFONTTYPE2",
            TYPE3: "TYPE3",
            OPENTYPE: "OPENTYPE",
            TYPE0: "TYPE0",
            MMTYPE1: "MMTYPE1"
          };
          o.FontType = k;
          const x = {
            ERRORS: 0,
            WARNINGS: 1,
            INFOS: 5
          };
          o.VerbosityLevel = x;
          const f = {
            NONE: 0,
            BINARY: 1,
            STREAM: 2
          };
          o.CMapCompressionType = f;
          const D = {
            dependency: 1,
            setLineWidth: 2,
            setLineCap: 3,
            setLineJoin: 4,
            setMiterLimit: 5,
            setDash: 6,
            setRenderingIntent: 7,
            setFlatness: 8,
            setGState: 9,
            save: 10,
            restore: 11,
            transform: 12,
            moveTo: 13,
            lineTo: 14,
            curveTo: 15,
            curveTo2: 16,
            curveTo3: 17,
            closePath: 18,
            rectangle: 19,
            stroke: 20,
            closeStroke: 21,
            fill: 22,
            eoFill: 23,
            fillStroke: 24,
            eoFillStroke: 25,
            closeFillStroke: 26,
            closeEOFillStroke: 27,
            endPath: 28,
            clip: 29,
            eoClip: 30,
            beginText: 31,
            endText: 32,
            setCharSpacing: 33,
            setWordSpacing: 34,
            setHScale: 35,
            setLeading: 36,
            setFont: 37,
            setTextRenderingMode: 38,
            setTextRise: 39,
            moveText: 40,
            setLeadingMoveText: 41,
            setTextMatrix: 42,
            nextLine: 43,
            showText: 44,
            showSpacedText: 45,
            nextLineShowText: 46,
            nextLineSetSpacingShowText: 47,
            setCharWidth: 48,
            setCharWidthAndBounds: 49,
            setStrokeColorSpace: 50,
            setFillColorSpace: 51,
            setStrokeColor: 52,
            setStrokeColorN: 53,
            setFillColor: 54,
            setFillColorN: 55,
            setStrokeGray: 56,
            setFillGray: 57,
            setStrokeRGBColor: 58,
            setFillRGBColor: 59,
            setStrokeCMYKColor: 60,
            setFillCMYKColor: 61,
            shadingFill: 62,
            beginInlineImage: 63,
            beginImageData: 64,
            endInlineImage: 65,
            paintXObject: 66,
            markPoint: 67,
            markPointProps: 68,
            beginMarkedContent: 69,
            beginMarkedContentProps: 70,
            endMarkedContent: 71,
            beginCompat: 72,
            endCompat: 73,
            paintFormXObjectBegin: 74,
            paintFormXObjectEnd: 75,
            beginGroup: 76,
            endGroup: 77,
            beginAnnotations: 78,
            endAnnotations: 79,
            beginAnnotation: 80,
            endAnnotation: 81,
            paintJpegXObject: 82,
            paintImageMaskXObject: 83,
            paintImageMaskXObjectGroup: 84,
            paintImageXObject: 85,
            paintInlineImageXObject: 86,
            paintInlineImageXObjectGroup: 87,
            paintImageXObjectRepeat: 88,
            paintImageMaskXObjectRepeat: 89,
            paintSolidColorImageMask: 90,
            constructPath: 91
          };
          o.OPS = D;
          const _ = {
            unknown: "unknown",
            forms: "forms",
            javaScript: "javaScript",
            signatures: "signatures",
            smask: "smask",
            shadingPattern: "shadingPattern",
            font: "font",
            errorTilingPattern: "errorTilingPattern",
            errorExtGState: "errorExtGState",
            errorXObject: "errorXObject",
            errorFontLoadType3: "errorFontLoadType3",
            errorFontState: "errorFontState",
            errorFontMissing: "errorFontMissing",
            errorFontTranslate: "errorFontTranslate",
            errorColorSpace: "errorColorSpace",
            errorOperatorList: "errorOperatorList",
            errorFontToUnicode: "errorFontToUnicode",
            errorFontLoadNative: "errorFontLoadNative",
            errorFontBuildPath: "errorFontBuildPath",
            errorFontGetPath: "errorFontGetPath",
            errorMarkedContent: "errorMarkedContent",
            errorContentSubStream: "errorContentSubStream"
          };
          o.UNSUPPORTED_FEATURES = _;
          const S = {
            NEED_PASSWORD: 1,
            INCORRECT_PASSWORD: 2
          };
          o.PasswordResponses = S;
          let C = x.WARNINGS;
          function T(Me) {
            Number.isInteger(Me) && (C = Me);
          }
          function P() {
            return C;
          }
          function M(Me) {
            C >= x.INFOS && console.log(`Info: ${Me}`);
          }
          function G(Me) {
            C >= x.WARNINGS && console.log(`Warning: ${Me}`);
          }
          function Z(Me) {
            throw new Error(Me);
          }
          function $(Me, Ie) {
            Me || Z(Ie);
          }
          function z(Me) {
            if (!Me)
              return !1;
            switch (Me.protocol) {
              case "http:":
              case "https:":
              case "ftp:":
              case "mailto:":
              case "tel:":
                return !0;
              default:
                return !1;
            }
          }
          function V(Me, Ie = null, Ee = null) {
            if (!Me)
              return null;
            try {
              if (Ee && typeof Me == "string") {
                if (Ee.addDefaultProtocol && Me.startsWith("www.")) {
                  const Qe = Me.match(/\./g);
                  Qe && Qe.length >= 2 && (Me = `http://${Me}`);
                }
                if (Ee.tryConvertEncoding)
                  try {
                    Me = Ae(Me);
                  } catch {
                  }
              }
              const st = Ie ? new URL(Me, Ie) : new URL(Me);
              if (z(st))
                return st;
            } catch {
            }
            return null;
          }
          function L(Me, Ie, Ee) {
            return Object.defineProperty(Me, Ie, {
              value: Ee,
              enumerable: !0,
              configurable: !0,
              writable: !1
            }), Ee;
          }
          const K = function() {
            function Ie(Ee, st) {
              this.constructor === Ie && Z("Cannot initialize BaseException."), this.message = Ee, this.name = st;
            }
            return Ie.prototype = new Error(), Ie.constructor = Ie, Ie;
          }();
          o.BaseException = K;
          class ne extends K {
            constructor(Ie, Ee) {
              super(Ie, "PasswordException"), this.code = Ee;
            }
          }
          o.PasswordException = ne;
          class se extends K {
            constructor(Ie, Ee) {
              super(Ie, "UnknownErrorException"), this.details = Ee;
            }
          }
          o.UnknownErrorException = se;
          class q extends K {
            constructor(Ie) {
              super(Ie, "InvalidPDFException");
            }
          }
          o.InvalidPDFException = q;
          class N extends K {
            constructor(Ie) {
              super(Ie, "MissingPDFException");
            }
          }
          o.MissingPDFException = N;
          class Q extends K {
            constructor(Ie, Ee) {
              super(Ie, "UnexpectedResponseException"), this.status = Ee;
            }
          }
          o.UnexpectedResponseException = Q;
          class E extends K {
            constructor(Ie) {
              super(Ie, "FormatError");
            }
          }
          o.FormatError = E;
          class te extends K {
            constructor(Ie) {
              super(Ie, "AbortException");
            }
          }
          o.AbortException = te;
          function oe(Me) {
            (typeof Me != "object" || Me === null || Me.length === void 0) && Z("Invalid argument for bytesToString");
            const Ie = Me.length, Ee = 8192;
            if (Ie < Ee)
              return String.fromCharCode.apply(null, Me);
            const st = [];
            for (let Qe = 0; Qe < Ie; Qe += Ee) {
              const ct = Math.min(Qe + Ee, Ie), xt = Me.subarray(Qe, ct);
              st.push(String.fromCharCode.apply(null, xt));
            }
            return st.join("");
          }
          function ee(Me) {
            typeof Me != "string" && Z("Invalid argument for stringToBytes");
            const Ie = Me.length, Ee = new Uint8Array(Ie);
            for (let st = 0; st < Ie; ++st)
              Ee[st] = Me.charCodeAt(st) & 255;
            return Ee;
          }
          function W(Me) {
            if (Me.length !== void 0)
              return Me.length;
            if (Me.byteLength !== void 0)
              return Me.byteLength;
            Z("Invalid argument for arrayByteLength");
          }
          function I(Me) {
            const Ie = Me.length;
            if (Ie === 1 && Me[0] instanceof Uint8Array)
              return Me[0];
            let Ee = 0;
            for (let ct = 0; ct < Ie; ct++)
              Ee += W(Me[ct]);
            let st = 0;
            const Qe = new Uint8Array(Ee);
            for (let ct = 0; ct < Ie; ct++) {
              let xt = Me[ct];
              xt instanceof Uint8Array || (typeof xt == "string" ? xt = ee(xt) : xt = new Uint8Array(xt));
              const Je = xt.byteLength;
              Qe.set(xt, st), st += Je;
            }
            return Qe;
          }
          function H(Me) {
            return String.fromCharCode(Me >> 24 & 255, Me >> 16 & 255, Me >> 8 & 255, Me & 255);
          }
          function ie(Me) {
            return Object.keys(Me).length;
          }
          function ue(Me) {
            const Ie = /* @__PURE__ */ Object.create(null);
            for (const [Ee, st] of Me)
              Ie[Ee] = st;
            return Ie;
          }
          function fe() {
            const Me = new Uint8Array(4);
            return Me[0] = 1, new Uint32Array(Me.buffer, 0, 1)[0] === 1;
          }
          function de() {
            try {
              return new Function(""), !0;
            } catch {
              return !1;
            }
          }
          class pe {
            static get isLittleEndian() {
              return L(this, "isLittleEndian", fe());
            }
            static get isEvalSupported() {
              return L(this, "isEvalSupported", de());
            }
            static get isOffscreenCanvasSupported() {
              return L(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas < "u");
            }
          }
          o.FeatureTest = pe;
          const xe = [...Array(256).keys()].map((Me) => Me.toString(16).padStart(2, "0"));
          class Fe {
            static makeHexColor(Ie, Ee, st) {
              return `#${xe[Ie]}${xe[Ee]}${xe[st]}`;
            }
            static scaleMinMax(Ie, Ee) {
              let st;
              Ie[0] ? (Ie[0] < 0 && (st = Ee[0], Ee[0] = Ee[1], Ee[1] = st), Ee[0] *= Ie[0], Ee[1] *= Ie[0], Ie[3] < 0 && (st = Ee[2], Ee[2] = Ee[3], Ee[3] = st), Ee[2] *= Ie[3], Ee[3] *= Ie[3]) : (st = Ee[0], Ee[0] = Ee[2], Ee[2] = st, st = Ee[1], Ee[1] = Ee[3], Ee[3] = st, Ie[1] < 0 && (st = Ee[2], Ee[2] = Ee[3], Ee[3] = st), Ee[2] *= Ie[1], Ee[3] *= Ie[1], Ie[2] < 0 && (st = Ee[0], Ee[0] = Ee[1], Ee[1] = st), Ee[0] *= Ie[2], Ee[1] *= Ie[2]), Ee[0] += Ie[4], Ee[1] += Ie[4], Ee[2] += Ie[5], Ee[3] += Ie[5];
            }
            static transform(Ie, Ee) {
              return [Ie[0] * Ee[0] + Ie[2] * Ee[1], Ie[1] * Ee[0] + Ie[3] * Ee[1], Ie[0] * Ee[2] + Ie[2] * Ee[3], Ie[1] * Ee[2] + Ie[3] * Ee[3], Ie[0] * Ee[4] + Ie[2] * Ee[5] + Ie[4], Ie[1] * Ee[4] + Ie[3] * Ee[5] + Ie[5]];
            }
            static applyTransform(Ie, Ee) {
              const st = Ie[0] * Ee[0] + Ie[1] * Ee[2] + Ee[4], Qe = Ie[0] * Ee[1] + Ie[1] * Ee[3] + Ee[5];
              return [st, Qe];
            }
            static applyInverseTransform(Ie, Ee) {
              const st = Ee[0] * Ee[3] - Ee[1] * Ee[2], Qe = (Ie[0] * Ee[3] - Ie[1] * Ee[2] + Ee[2] * Ee[5] - Ee[4] * Ee[3]) / st, ct = (-Ie[0] * Ee[1] + Ie[1] * Ee[0] + Ee[4] * Ee[1] - Ee[5] * Ee[0]) / st;
              return [Qe, ct];
            }
            static getAxialAlignedBoundingBox(Ie, Ee) {
              const st = Fe.applyTransform(Ie, Ee), Qe = Fe.applyTransform(Ie.slice(2, 4), Ee), ct = Fe.applyTransform([Ie[0], Ie[3]], Ee), xt = Fe.applyTransform([Ie[2], Ie[1]], Ee);
              return [Math.min(st[0], Qe[0], ct[0], xt[0]), Math.min(st[1], Qe[1], ct[1], xt[1]), Math.max(st[0], Qe[0], ct[0], xt[0]), Math.max(st[1], Qe[1], ct[1], xt[1])];
            }
            static inverseTransform(Ie) {
              const Ee = Ie[0] * Ie[3] - Ie[1] * Ie[2];
              return [Ie[3] / Ee, -Ie[1] / Ee, -Ie[2] / Ee, Ie[0] / Ee, (Ie[2] * Ie[5] - Ie[4] * Ie[3]) / Ee, (Ie[4] * Ie[1] - Ie[5] * Ie[0]) / Ee];
            }
            static apply3dTransform(Ie, Ee) {
              return [Ie[0] * Ee[0] + Ie[1] * Ee[1] + Ie[2] * Ee[2], Ie[3] * Ee[0] + Ie[4] * Ee[1] + Ie[5] * Ee[2], Ie[6] * Ee[0] + Ie[7] * Ee[1] + Ie[8] * Ee[2]];
            }
            static singularValueDecompose2dScale(Ie) {
              const Ee = [Ie[0], Ie[2], Ie[1], Ie[3]], st = Ie[0] * Ee[0] + Ie[1] * Ee[2], Qe = Ie[0] * Ee[1] + Ie[1] * Ee[3], ct = Ie[2] * Ee[0] + Ie[3] * Ee[2], xt = Ie[2] * Ee[1] + Ie[3] * Ee[3], Je = (st + xt) / 2, mt = Math.sqrt((st + xt) ** 2 - 4 * (st * xt - ct * Qe)) / 2, _t = Je + mt || 1, Xe = Je - mt || 1;
              return [Math.sqrt(_t), Math.sqrt(Xe)];
            }
            static normalizeRect(Ie) {
              const Ee = Ie.slice(0);
              return Ie[0] > Ie[2] && (Ee[0] = Ie[2], Ee[2] = Ie[0]), Ie[1] > Ie[3] && (Ee[1] = Ie[3], Ee[3] = Ie[1]), Ee;
            }
            static intersect(Ie, Ee) {
              const st = Math.max(Math.min(Ie[0], Ie[2]), Math.min(Ee[0], Ee[2])), Qe = Math.min(Math.max(Ie[0], Ie[2]), Math.max(Ee[0], Ee[2]));
              if (st > Qe)
                return null;
              const ct = Math.max(Math.min(Ie[1], Ie[3]), Math.min(Ee[1], Ee[3])), xt = Math.min(Math.max(Ie[1], Ie[3]), Math.max(Ee[1], Ee[3]));
              return ct > xt ? null : [st, ct, Qe, xt];
            }
            static bezierBoundingBox(Ie, Ee, st, Qe, ct, xt, Je, mt) {
              const _t = [], Xe = [[], []];
              let Ct, bt, Pe, qe, ot, lt, Ut, Nt;
              for (let nt = 0; nt < 2; ++nt) {
                if (nt === 0 ? (bt = 6 * Ie - 12 * st + 6 * ct, Ct = -3 * Ie + 9 * st - 9 * ct + 3 * Je, Pe = 3 * st - 3 * Ie) : (bt = 6 * Ee - 12 * Qe + 6 * xt, Ct = -3 * Ee + 9 * Qe - 9 * xt + 3 * mt, Pe = 3 * Qe - 3 * Ee), Math.abs(Ct) < 1e-12) {
                  if (Math.abs(bt) < 1e-12)
                    continue;
                  qe = -Pe / bt, 0 < qe && qe < 1 && _t.push(qe);
                  continue;
                }
                Ut = bt * bt - 4 * Pe * Ct, Nt = Math.sqrt(Ut), !(Ut < 0) && (ot = (-bt + Nt) / (2 * Ct), 0 < ot && ot < 1 && _t.push(ot), lt = (-bt - Nt) / (2 * Ct), 0 < lt && lt < 1 && _t.push(lt));
              }
              let Ve = _t.length, je;
              const at = Ve;
              for (; Ve--; )
                qe = _t[Ve], je = 1 - qe, Xe[0][Ve] = je * je * je * Ie + 3 * je * je * qe * st + 3 * je * qe * qe * ct + qe * qe * qe * Je, Xe[1][Ve] = je * je * je * Ee + 3 * je * je * qe * Qe + 3 * je * qe * qe * xt + qe * qe * qe * mt;
              return Xe[0][at] = Ie, Xe[1][at] = Ee, Xe[0][at + 1] = Je, Xe[1][at + 1] = mt, Xe[0].length = Xe[1].length = at + 2, [Math.min(...Xe[0]), Math.min(...Xe[1]), Math.max(...Xe[0]), Math.max(...Xe[1])];
            }
          }
          o.Util = Fe;
          const Se = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
          function Ce(Me) {
            if (Me[0] >= "ï") {
              let Ee;
              if (Me[0] === "þ" && Me[1] === "ÿ" ? Ee = "utf-16be" : Me[0] === "ÿ" && Me[1] === "þ" ? Ee = "utf-16le" : Me[0] === "ï" && Me[1] === "»" && Me[2] === "¿" && (Ee = "utf-8"), Ee)
                try {
                  const st = new TextDecoder(Ee, {
                    fatal: !0
                  }), Qe = ee(Me);
                  return st.decode(Qe);
                } catch (st) {
                  G(`stringToPDFString: "${st}".`);
                }
            }
            const Ie = [];
            for (let Ee = 0, st = Me.length; Ee < st; Ee++) {
              const Qe = Se[Me.charCodeAt(Ee)];
              Ie.push(Qe ? String.fromCharCode(Qe) : Me.charAt(Ee));
            }
            return Ie.join("");
          }
          function ke(Me) {
            return Me.replace(/([()\\\n\r])/g, (Ie) => Ie === `
` ? "\\n" : Ie === "\r" ? "\\r" : `\\${Ie}`);
          }
          function ye(Me) {
            return /^[\x00-\x7F]*$/.test(Me);
          }
          function De(Me) {
            const Ie = ["þÿ"];
            for (let Ee = 0, st = Me.length; Ee < st; Ee++) {
              const Qe = Me.charCodeAt(Ee);
              Ie.push(String.fromCharCode(Qe >> 8 & 255), String.fromCharCode(Qe & 255));
            }
            return Ie.join("");
          }
          function Ae(Me) {
            return decodeURIComponent(escape(Me));
          }
          function Te(Me) {
            return unescape(encodeURIComponent(Me));
          }
          function ve(Me) {
            return typeof Me == "object" && Me !== null && Me.byteLength !== void 0;
          }
          function Ne(Me, Ie) {
            if (Me.length !== Ie.length)
              return !1;
            for (let Ee = 0, st = Me.length; Ee < st; Ee++)
              if (Me[Ee] !== Ie[Ee])
                return !1;
            return !0;
          }
          function Ge(Me = new Date()) {
            return [Me.getUTCFullYear().toString(), (Me.getUTCMonth() + 1).toString().padStart(2, "0"), Me.getUTCDate().toString().padStart(2, "0"), Me.getUTCHours().toString().padStart(2, "0"), Me.getUTCMinutes().toString().padStart(2, "0"), Me.getUTCSeconds().toString().padStart(2, "0")].join("");
          }
          function it() {
            const Me = /* @__PURE__ */ Object.create(null);
            let Ie = !1;
            return Object.defineProperty(Me, "settled", {
              get() {
                return Ie;
              }
            }), Me.promise = new Promise(function(Ee, st) {
              Me.resolve = function(Qe) {
                Ie = !0, Ee(Qe);
              }, Me.reject = function(Qe) {
                Ie = !0, st(Qe);
              };
            }), Me;
          }
        },
        /* 3 */
        /***/
        (J, o, F) => {
          F(4);
        },
        /* 4 */
        /***/
        (J, o) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.isNodeJS = void 0;
          const F = typeof process == "object" && process + "" == "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
          o.isNodeJS = F;
        },
        /* 5 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.RefSetCache = o.RefSet = o.Ref = o.Name = o.EOF = o.Dict = o.Cmd = o.CIRCULAR_REF = void 0, o.clearPrimitiveCaches = u, o.isCmd = n, o.isDict = i, o.isName = g, o.isRefsEqual = l;
          var t = F(2);
          const a = Symbol("CIRCULAR_REF");
          o.CIRCULAR_REF = a;
          const v = Symbol("EOF");
          o.EOF = v;
          const h = function() {
            let O = /* @__PURE__ */ Object.create(null);
            class b {
              constructor(Y) {
                this.name = Y;
              }
              static get(Y) {
                return O[Y] || (O[Y] = new b(Y));
              }
              static _clearCache() {
                O = /* @__PURE__ */ Object.create(null);
              }
            }
            return b;
          }();
          o.Name = h;
          const e = function() {
            let O = /* @__PURE__ */ Object.create(null);
            class b {
              constructor(Y) {
                this.cmd = Y;
              }
              static get(Y) {
                return O[Y] || (O[Y] = new b(Y));
              }
              static _clearCache() {
                O = /* @__PURE__ */ Object.create(null);
              }
            }
            return b;
          }();
          o.Cmd = e;
          const y = function() {
            return y;
          };
          class c {
            constructor(O = null) {
              this._map = /* @__PURE__ */ Object.create(null), this.xref = O, this.objId = null, this.suppressEncryption = !1, this.__nonSerializable__ = y;
            }
            assignXref(O) {
              this.xref = O;
            }
            get size() {
              return Object.keys(this._map).length;
            }
            get(O, b, A) {
              let Y = this._map[O];
              return Y === void 0 && b !== void 0 && (Y = this._map[b], Y === void 0 && A !== void 0 && (Y = this._map[A])), Y instanceof d && this.xref ? this.xref.fetch(Y, this.suppressEncryption) : Y;
            }
            async getAsync(O, b, A) {
              let Y = this._map[O];
              return Y === void 0 && b !== void 0 && (Y = this._map[b], Y === void 0 && A !== void 0 && (Y = this._map[A])), Y instanceof d && this.xref ? this.xref.fetchAsync(Y, this.suppressEncryption) : Y;
            }
            getArray(O, b, A) {
              let Y = this._map[O];
              if (Y === void 0 && b !== void 0 && (Y = this._map[b], Y === void 0 && A !== void 0 && (Y = this._map[A])), Y instanceof d && this.xref && (Y = this.xref.fetch(Y, this.suppressEncryption)), Array.isArray(Y)) {
                Y = Y.slice();
                for (let j = 0, X = Y.length; j < X; j++)
                  Y[j] instanceof d && this.xref && (Y[j] = this.xref.fetch(Y[j], this.suppressEncryption));
              }
              return Y;
            }
            getRaw(O) {
              return this._map[O];
            }
            getKeys() {
              return Object.keys(this._map);
            }
            getRawValues() {
              return Object.values(this._map);
            }
            set(O, b) {
              this._map[O] = b;
            }
            has(O) {
              return this._map[O] !== void 0;
            }
            forEach(O) {
              for (const b in this._map)
                O(b, this.get(b));
            }
            static get empty() {
              const O = new c(null);
              return O.set = (b, A) => {
                (0, t.unreachable)("Should not call `set` on the empty dictionary.");
              }, (0, t.shadow)(this, "empty", O);
            }
            static merge({
              xref: O,
              dictArray: b,
              mergeSubDicts: A = !1
            }) {
              const Y = new c(O), j = /* @__PURE__ */ new Map();
              for (const X of b)
                if (X instanceof c)
                  for (const [B, U] of Object.entries(X._map)) {
                    let k = j.get(B);
                    if (k === void 0)
                      k = [], j.set(B, k);
                    else if (!A || !(U instanceof c))
                      continue;
                    k.push(U);
                  }
              for (const [X, B] of j) {
                if (B.length === 1 || !(B[0] instanceof c)) {
                  Y._map[X] = B[0];
                  continue;
                }
                const U = new c(O);
                for (const k of B)
                  for (const [x, f] of Object.entries(k._map))
                    U._map[x] === void 0 && (U._map[x] = f);
                U.size > 0 && (Y._map[X] = U);
              }
              return j.clear(), Y.size > 0 ? Y : c.empty;
            }
          }
          o.Dict = c;
          const d = function() {
            let O = /* @__PURE__ */ Object.create(null);
            class b {
              constructor(Y, j) {
                this.num = Y, this.gen = j;
              }
              toString() {
                return this.gen === 0 ? `${this.num}R` : `${this.num}R${this.gen}`;
              }
              static get(Y, j) {
                const X = j === 0 ? `${Y}R` : `${Y}R${j}`;
                return O[X] || (O[X] = new b(Y, j));
              }
              static _clearCache() {
                O = /* @__PURE__ */ Object.create(null);
              }
            }
            return b;
          }();
          o.Ref = d;
          class m {
            constructor(O = null) {
              this._set = new Set(O && O._set);
            }
            has(O) {
              return this._set.has(O.toString());
            }
            put(O) {
              this._set.add(O.toString());
            }
            remove(O) {
              this._set.delete(O.toString());
            }
            [Symbol.iterator]() {
              return this._set.values();
            }
            clear() {
              this._set.clear();
            }
          }
          o.RefSet = m;
          class p {
            constructor() {
              this._map = /* @__PURE__ */ new Map();
            }
            get size() {
              return this._map.size;
            }
            get(O) {
              return this._map.get(O.toString());
            }
            has(O) {
              return this._map.has(O.toString());
            }
            put(O, b) {
              this._map.set(O.toString(), b);
            }
            putAlias(O, b) {
              this._map.set(O.toString(), this.get(b));
            }
            [Symbol.iterator]() {
              return this._map.values();
            }
            clear() {
              this._map.clear();
            }
          }
          o.RefSetCache = p;
          function g(w, O) {
            return w instanceof h && (O === void 0 || w.name === O);
          }
          function n(w, O) {
            return w instanceof e && (O === void 0 || w.cmd === O);
          }
          function i(w, O) {
            return w instanceof c && (O === void 0 || g(w.get("Type"), O));
          }
          function l(w, O) {
            return w.num === O.num && w.gen === O.gen;
          }
          function u() {
            e._clearCache(), h._clearCache(), d._clearCache();
          }
        },
        /* 6 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.XRefParseException = o.XRefEntryException = o.ParserEOFException = o.MissingDataException = o.DocStats = void 0, o.collectActions = X, o.encodeToXmlString = U, o.escapePDFName = Y, o.getArrayLookupTableFactory = e, o.getInheritableProperty = g, o.getLookupTableFactory = h, o.getNewAnnotationsMap = D, o.isWhiteSpace = b, o.log2 = l, o.numberToString = f, o.parseXFAPath = A, o.readInt8 = u, o.readUint16 = w, o.readUint32 = O, o.recoverJsURL = x, o.toRomanNumerals = i, o.validateCSSFont = k;
          var t = F(2), a = F(5), v = F(7);
          function h(_) {
            let S;
            return function() {
              return _ && (S = /* @__PURE__ */ Object.create(null), _(S), _ = null), S;
            };
          }
          function e(_) {
            let S;
            return function() {
              if (_) {
                let C = _();
                _ = null, S = /* @__PURE__ */ Object.create(null);
                for (let T = 0, P = C.length; T < P; T += 2)
                  S[C[T]] = C[T + 1];
                C = null;
              }
              return S;
            };
          }
          class y extends t.BaseException {
            constructor(S, C) {
              super(`Missing data [${S}, ${C})`, "MissingDataException"), this.begin = S, this.end = C;
            }
          }
          o.MissingDataException = y;
          class c extends t.BaseException {
            constructor(S) {
              super(S, "ParserEOFException");
            }
          }
          o.ParserEOFException = c;
          class d extends t.BaseException {
            constructor(S) {
              super(S, "XRefEntryException");
            }
          }
          o.XRefEntryException = d;
          class m extends t.BaseException {
            constructor(S) {
              super(S, "XRefParseException");
            }
          }
          o.XRefParseException = m;
          class p {
            constructor(S) {
              this._handler = S, this._streamTypes = /* @__PURE__ */ new Set(), this._fontTypes = /* @__PURE__ */ new Set();
            }
            _send() {
              const S = /* @__PURE__ */ Object.create(null), C = /* @__PURE__ */ Object.create(null);
              for (const T of this._streamTypes)
                S[T] = !0;
              for (const T of this._fontTypes)
                C[T] = !0;
              this._handler.send("DocStats", {
                streamTypes: S,
                fontTypes: C
              });
            }
            addStreamType(S) {
              this._streamTypes.has(S) || (this._streamTypes.add(S), this._send());
            }
            addFontType(S) {
              this._fontTypes.has(S) || (this._fontTypes.add(S), this._send());
            }
          }
          o.DocStats = p;
          function g({
            dict: _,
            key: S,
            getArray: C = !1,
            stopWhenFound: T = !0
          }) {
            let P;
            const M = new a.RefSet();
            for (; _ instanceof a.Dict && !(_.objId && M.has(_.objId)); ) {
              _.objId && M.put(_.objId);
              const G = C ? _.getArray(S) : _.get(S);
              if (G !== void 0) {
                if (T)
                  return G;
                P || (P = []), P.push(G);
              }
              _ = _.get("Parent");
            }
            return P;
          }
          const n = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
          function i(_, S = !1) {
            (0, t.assert)(Number.isInteger(_) && _ > 0, "The number should be a positive integer.");
            const C = [];
            let T;
            for (; _ >= 1e3; )
              _ -= 1e3, C.push("M");
            T = _ / 100 | 0, _ %= 100, C.push(n[T]), T = _ / 10 | 0, _ %= 10, C.push(n[10 + T]), C.push(n[20 + _]);
            const P = C.join("");
            return S ? P.toLowerCase() : P;
          }
          function l(_) {
            return _ <= 0 ? 0 : Math.ceil(Math.log2(_));
          }
          function u(_, S) {
            return _[S] << 24 >> 24;
          }
          function w(_, S) {
            return _[S] << 8 | _[S + 1];
          }
          function O(_, S) {
            return (_[S] << 24 | _[S + 1] << 16 | _[S + 2] << 8 | _[S + 3]) >>> 0;
          }
          function b(_) {
            return _ === 32 || _ === 9 || _ === 13 || _ === 10;
          }
          function A(_) {
            const S = /(.+)\[(\d+)\]$/;
            return _.split(".").map((C) => {
              const T = C.match(S);
              return T ? {
                name: T[1],
                pos: parseInt(T[2], 10)
              } : {
                name: C,
                pos: 0
              };
            });
          }
          function Y(_) {
            const S = [];
            let C = 0;
            for (let T = 0, P = _.length; T < P; T++) {
              const M = _.charCodeAt(T);
              (M < 33 || M > 126 || M === 35 || M === 40 || M === 41 || M === 60 || M === 62 || M === 91 || M === 93 || M === 123 || M === 125 || M === 47 || M === 37) && (C < T && S.push(_.substring(C, T)), S.push(`#${M.toString(16)}`), C = T + 1);
            }
            return S.length === 0 ? _ : (C < _.length && S.push(_.substring(C, _.length)), S.join(""));
          }
          function j(_, S, C, T) {
            if (!_)
              return;
            let P = null;
            if (_ instanceof a.Ref) {
              if (T.has(_))
                return;
              P = _, T.put(P), _ = S.fetch(_);
            }
            if (Array.isArray(_))
              for (const M of _)
                j(M, S, C, T);
            else if (_ instanceof a.Dict) {
              if ((0, a.isName)(_.get("S"), "JavaScript")) {
                const M = _.get("JS");
                let G;
                M instanceof v.BaseStream ? G = M.getString() : typeof M == "string" && (G = M), G = G && (0, t.stringToPDFString)(G).replace(/\u0000/g, ""), G && C.push(G);
              }
              j(_.getRaw("Next"), S, C, T);
            }
            P && T.remove(P);
          }
          function X(_, S, C) {
            const T = /* @__PURE__ */ Object.create(null), P = g({
              dict: S,
              key: "AA",
              stopWhenFound: !1
            });
            if (P)
              for (let M = P.length - 1; M >= 0; M--) {
                const G = P[M];
                if (G instanceof a.Dict)
                  for (const Z of G.getKeys()) {
                    const $ = C[Z];
                    if (!$)
                      continue;
                    const z = G.getRaw(Z), V = new a.RefSet(), L = [];
                    j(z, _, L, V), L.length > 0 && (T[$] = L);
                  }
              }
            if (S.has("A")) {
              const M = S.get("A"), G = new a.RefSet(), Z = [];
              j(M, _, Z, G), Z.length > 0 && (T.Action = Z);
            }
            return (0, t.objectSize)(T) > 0 ? T : null;
          }
          const B = {
            60: "&lt;",
            62: "&gt;",
            38: "&amp;",
            34: "&quot;",
            39: "&apos;"
          };
          function U(_) {
            const S = [];
            let C = 0;
            for (let T = 0, P = _.length; T < P; T++) {
              const M = _.codePointAt(T);
              if (32 <= M && M <= 126) {
                const G = B[M];
                G && (C < T && S.push(_.substring(C, T)), S.push(G), C = T + 1);
              } else
                C < T && S.push(_.substring(C, T)), S.push(`&#x${M.toString(16).toUpperCase()};`), M > 55295 && (M < 57344 || M > 65533) && T++, C = T + 1;
            }
            return S.length === 0 ? _ : (C < _.length && S.push(_.substring(C, _.length)), S.join(""));
          }
          function k(_) {
            const S = "14", C = "400", T = /* @__PURE__ */ new Set(["100", "200", "300", "400", "500", "600", "700", "800", "900", "1000", "normal", "bold", "bolder", "lighter"]), {
              fontFamily: P,
              fontWeight: M,
              italicAngle: G
            } = _;
            if (/^".*"$/.test(P)) {
              if (/[^\\]"/.test(P.slice(1, P.length - 1)))
                return (0, t.warn)(`XFA - FontFamily contains some unescaped ": ${P}.`), !1;
            } else if (/^'.*'$/.test(P)) {
              if (/[^\\]'/.test(P.slice(1, P.length - 1)))
                return (0, t.warn)(`XFA - FontFamily contains some unescaped ': ${P}.`), !1;
            } else
              for (const z of P.split(/[ \t]+/))
                if (/^(\d|(-(\d|-)))/.test(z) || !/^[\w-\\]+$/.test(z))
                  return (0, t.warn)(`XFA - FontFamily contains some invalid <custom-ident>: ${P}.`), !1;
            const Z = M ? M.toString() : "";
            _.fontWeight = T.has(Z) ? Z : C;
            const $ = parseFloat(G);
            return _.italicAngle = isNaN($) || $ < -90 || $ > 90 ? S : G.toString(), !0;
          }
          function x(_) {
            const S = ["app.launchURL", "window.open", "xfa.host.gotoURL"], T = new RegExp("^\\s*(" + S.join("|").split(".").join("\\.") + `)\\((?:'|")([^'"]*)(?:'|")(?:,\\s*(\\w+)\\)|\\))`, "i").exec(_);
            if (T && T[2]) {
              const P = T[2];
              let M = !1;
              return T[3] === "true" && T[1] === "app.launchURL" && (M = !0), {
                url: P,
                newWindow: M
              };
            }
            return null;
          }
          function f(_) {
            if (Number.isInteger(_))
              return _.toString();
            const S = Math.round(_ * 100);
            return S % 100 === 0 ? (S / 100).toString() : S % 10 === 0 ? _.toFixed(1) : _.toFixed(2);
          }
          function D(_) {
            if (!_)
              return null;
            const S = /* @__PURE__ */ new Map();
            for (const [C, T] of _) {
              if (!C.startsWith(t.AnnotationEditorPrefix))
                continue;
              let P = S.get(T.pageIndex);
              P || (P = [], S.set(T.pageIndex, P)), P.push(T);
            }
            return S.size > 0 ? S : null;
          }
        },
        /* 7 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.BaseStream = void 0;
          var t = F(2);
          class a {
            constructor() {
              this.constructor === a && (0, t.unreachable)("Cannot initialize BaseStream.");
            }
            get length() {
              (0, t.unreachable)("Abstract getter `length` accessed");
            }
            get isEmpty() {
              (0, t.unreachable)("Abstract getter `isEmpty` accessed");
            }
            get isDataLoaded() {
              return (0, t.shadow)(this, "isDataLoaded", !0);
            }
            getByte() {
              (0, t.unreachable)("Abstract method `getByte` called");
            }
            getBytes(h) {
              (0, t.unreachable)("Abstract method `getBytes` called");
            }
            peekByte() {
              const h = this.getByte();
              return h !== -1 && this.pos--, h;
            }
            peekBytes(h) {
              const e = this.getBytes(h);
              return this.pos -= e.length, e;
            }
            getUint16() {
              const h = this.getByte(), e = this.getByte();
              return h === -1 || e === -1 ? -1 : (h << 8) + e;
            }
            getInt32() {
              const h = this.getByte(), e = this.getByte(), y = this.getByte(), c = this.getByte();
              return (h << 24) + (e << 16) + (y << 8) + c;
            }
            getByteRange(h, e) {
              (0, t.unreachable)("Abstract method `getByteRange` called");
            }
            getString(h) {
              return (0, t.bytesToString)(this.getBytes(h));
            }
            skip(h) {
              this.pos += h || 1;
            }
            reset() {
              (0, t.unreachable)("Abstract method `reset` called");
            }
            moveStart() {
              (0, t.unreachable)("Abstract method `moveStart` called");
            }
            makeSubStream(h, e, y = null) {
              (0, t.unreachable)("Abstract method `makeSubStream` called");
            }
            getBaseStreams() {
              return null;
            }
          }
          o.BaseStream = a;
        },
        /* 8 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.NetworkPdfManager = o.LocalPdfManager = void 0;
          var t = F(2), a = F(9), v = F(6), h = F(11), e = F(10);
          function y(p) {
            if (p) {
              const g = (0, t.createValidAbsoluteUrl)(p);
              if (g)
                return g.href;
              (0, t.warn)(`Invalid absolute docBaseUrl: "${p}".`);
            }
            return null;
          }
          class c {
            constructor() {
              this.constructor === c && (0, t.unreachable)("Cannot initialize BasePdfManager.");
            }
            get docId() {
              return this._docId;
            }
            get password() {
              return this._password;
            }
            get docBaseUrl() {
              const g = this.pdfDocument.catalog;
              return (0, t.shadow)(this, "docBaseUrl", g.baseUrl || this._docBaseUrl);
            }
            onLoadedStream() {
              (0, t.unreachable)("Abstract method `onLoadedStream` called");
            }
            ensureDoc(g, n) {
              return this.ensure(this.pdfDocument, g, n);
            }
            ensureXRef(g, n) {
              return this.ensure(this.pdfDocument.xref, g, n);
            }
            ensureCatalog(g, n) {
              return this.ensure(this.pdfDocument.catalog, g, n);
            }
            getPage(g) {
              return this.pdfDocument.getPage(g);
            }
            fontFallback(g, n) {
              return this.pdfDocument.fontFallback(g, n);
            }
            loadXfaFonts(g, n) {
              return this.pdfDocument.loadXfaFonts(g, n);
            }
            loadXfaImages() {
              return this.pdfDocument.loadXfaImages();
            }
            serializeXfaData(g) {
              return this.pdfDocument.serializeXfaData(g);
            }
            cleanup(g = !1) {
              return this.pdfDocument.cleanup(g);
            }
            async ensure(g, n, i) {
              (0, t.unreachable)("Abstract method `ensure` called");
            }
            requestRange(g, n) {
              (0, t.unreachable)("Abstract method `requestRange` called");
            }
            requestLoadedStream() {
              (0, t.unreachable)("Abstract method `requestLoadedStream` called");
            }
            sendProgressiveData(g) {
              (0, t.unreachable)("Abstract method `sendProgressiveData` called");
            }
            updatePassword(g) {
              this._password = g;
            }
            terminate(g) {
              (0, t.unreachable)("Abstract method `terminate` called");
            }
          }
          class d extends c {
            constructor(g, n, i, l, u, w, O) {
              super(), this._docId = g, this._password = i, this._docBaseUrl = y(O), this.msgHandler = l, this.evaluatorOptions = u, this.enableXfa = w;
              const b = new e.Stream(n);
              this.pdfDocument = new h.PDFDocument(this, b), this._loadedStreamPromise = Promise.resolve(b);
            }
            async ensure(g, n, i) {
              const l = g[n];
              return typeof l == "function" ? l.apply(g, i) : l;
            }
            requestRange(g, n) {
              return Promise.resolve();
            }
            requestLoadedStream() {
            }
            onLoadedStream() {
              return this._loadedStreamPromise;
            }
            terminate(g) {
            }
          }
          o.LocalPdfManager = d;
          class m extends c {
            constructor(g, n, i, l, u, w) {
              super(), this._docId = g, this._password = i.password, this._docBaseUrl = y(w), this.msgHandler = i.msgHandler, this.evaluatorOptions = l, this.enableXfa = u, this.streamManager = new a.ChunkedStreamManager(n, {
                msgHandler: i.msgHandler,
                length: i.length,
                disableAutoFetch: i.disableAutoFetch,
                rangeChunkSize: i.rangeChunkSize
              }), this.pdfDocument = new h.PDFDocument(this, this.streamManager.getStream());
            }
            async ensure(g, n, i) {
              try {
                const l = g[n];
                return typeof l == "function" ? l.apply(g, i) : l;
              } catch (l) {
                if (!(l instanceof v.MissingDataException))
                  throw l;
                return await this.requestRange(l.begin, l.end), this.ensure(g, n, i);
              }
            }
            requestRange(g, n) {
              return this.streamManager.requestRange(g, n);
            }
            requestLoadedStream() {
              this.streamManager.requestAllChunks();
            }
            sendProgressiveData(g) {
              this.streamManager.onReceiveData({
                chunk: g
              });
            }
            onLoadedStream() {
              return this.streamManager.onLoadedStream();
            }
            terminate(g) {
              this.streamManager.abort(g);
            }
          }
          o.NetworkPdfManager = m;
        },
        /* 9 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.ChunkedStreamManager = o.ChunkedStream = void 0;
          var t = F(2), a = F(6), v = F(10);
          class h extends v.Stream {
            constructor(c, d, m) {
              super(new Uint8Array(c), 0, c, null), this.chunkSize = d, this._loadedChunks = /* @__PURE__ */ new Set(), this.numChunks = Math.ceil(c / d), this.manager = m, this.progressiveDataLength = 0, this.lastSuccessfulEnsureByteChunk = -1;
            }
            getMissingChunks() {
              const c = [];
              for (let d = 0, m = this.numChunks; d < m; ++d)
                this._loadedChunks.has(d) || c.push(d);
              return c;
            }
            get numChunksLoaded() {
              return this._loadedChunks.size;
            }
            get isDataLoaded() {
              return this.numChunksLoaded === this.numChunks;
            }
            onReceiveData(c, d) {
              const m = this.chunkSize;
              if (c % m !== 0)
                throw new Error(`Bad begin offset: ${c}`);
              const p = c + d.byteLength;
              if (p % m !== 0 && p !== this.bytes.length)
                throw new Error(`Bad end offset: ${p}`);
              this.bytes.set(new Uint8Array(d), c);
              const g = Math.floor(c / m), n = Math.floor((p - 1) / m) + 1;
              for (let i = g; i < n; ++i)
                this._loadedChunks.add(i);
            }
            onReceiveProgressiveData(c) {
              let d = this.progressiveDataLength;
              const m = Math.floor(d / this.chunkSize);
              this.bytes.set(new Uint8Array(c), d), d += c.byteLength, this.progressiveDataLength = d;
              const p = d >= this.end ? this.numChunks : Math.floor(d / this.chunkSize);
              for (let g = m; g < p; ++g)
                this._loadedChunks.add(g);
            }
            ensureByte(c) {
              if (c < this.progressiveDataLength)
                return;
              const d = Math.floor(c / this.chunkSize);
              if (!(d > this.numChunks) && d !== this.lastSuccessfulEnsureByteChunk) {
                if (!this._loadedChunks.has(d))
                  throw new a.MissingDataException(c, c + 1);
                this.lastSuccessfulEnsureByteChunk = d;
              }
            }
            ensureRange(c, d) {
              if (c >= d || d <= this.progressiveDataLength)
                return;
              const m = Math.floor(c / this.chunkSize);
              if (m > this.numChunks)
                return;
              const p = Math.min(Math.floor((d - 1) / this.chunkSize) + 1, this.numChunks);
              for (let g = m; g < p; ++g)
                if (!this._loadedChunks.has(g))
                  throw new a.MissingDataException(c, d);
            }
            nextEmptyChunk(c) {
              const d = this.numChunks;
              for (let m = 0; m < d; ++m) {
                const p = (c + m) % d;
                if (!this._loadedChunks.has(p))
                  return p;
              }
              return null;
            }
            hasChunk(c) {
              return this._loadedChunks.has(c);
            }
            getByte() {
              const c = this.pos;
              return c >= this.end ? -1 : (c >= this.progressiveDataLength && this.ensureByte(c), this.bytes[this.pos++]);
            }
            getBytes(c) {
              const d = this.bytes, m = this.pos, p = this.end;
              if (!c)
                return p > this.progressiveDataLength && this.ensureRange(m, p), d.subarray(m, p);
              let g = m + c;
              return g > p && (g = p), g > this.progressiveDataLength && this.ensureRange(m, g), this.pos = g, d.subarray(m, g);
            }
            getByteRange(c, d) {
              return c < 0 && (c = 0), d > this.end && (d = this.end), d > this.progressiveDataLength && this.ensureRange(c, d), this.bytes.subarray(c, d);
            }
            makeSubStream(c, d, m = null) {
              d ? c + d > this.progressiveDataLength && this.ensureRange(c, c + d) : c >= this.progressiveDataLength && this.ensureByte(c);
              function p() {
              }
              p.prototype = Object.create(this), p.prototype.getMissingChunks = function() {
                const n = this.chunkSize, i = Math.floor(this.start / n), l = Math.floor((this.end - 1) / n) + 1, u = [];
                for (let w = i; w < l; ++w)
                  this._loadedChunks.has(w) || u.push(w);
                return u;
              }, Object.defineProperty(p.prototype, "isDataLoaded", {
                get() {
                  return this.numChunksLoaded === this.numChunks ? !0 : this.getMissingChunks().length === 0;
                },
                configurable: !0
              });
              const g = new p();
              return g.pos = g.start = c, g.end = c + d || this.end, g.dict = m, g;
            }
            getBaseStreams() {
              return [this];
            }
          }
          o.ChunkedStream = h;
          class e {
            constructor(c, d) {
              this.length = d.length, this.chunkSize = d.rangeChunkSize, this.stream = new h(this.length, this.chunkSize, this), this.pdfNetworkStream = c, this.disableAutoFetch = d.disableAutoFetch, this.msgHandler = d.msgHandler, this.currRequestId = 0, this._chunksNeededByRequest = /* @__PURE__ */ new Map(), this._requestsByChunk = /* @__PURE__ */ new Map(), this._promisesByRequest = /* @__PURE__ */ new Map(), this.progressiveDataLength = 0, this.aborted = !1, this._loadedStreamCapability = (0, t.createPromiseCapability)();
            }
            onLoadedStream() {
              return this._loadedStreamCapability.promise;
            }
            sendRequest(c, d) {
              const m = this.pdfNetworkStream.getRangeReader(c, d);
              m.isStreamingSupported || (m.onProgress = this.onProgress.bind(this));
              let p = [], g = 0;
              return new Promise((n, i) => {
                const l = (u) => {
                  try {
                    if (!u.done) {
                      const O = u.value;
                      p.push(O), g += (0, t.arrayByteLength)(O), m.isStreamingSupported && this.onProgress({
                        loaded: g
                      }), m.read().then(l, i);
                      return;
                    }
                    const w = (0, t.arraysToBytes)(p);
                    p = null, n(w);
                  } catch (w) {
                    i(w);
                  }
                };
                m.read().then(l, i);
              }).then((n) => {
                this.aborted || this.onReceiveData({
                  chunk: n,
                  begin: c
                });
              });
            }
            requestAllChunks() {
              const c = this.stream.getMissingChunks();
              return this._requestChunks(c), this._loadedStreamCapability.promise;
            }
            _requestChunks(c) {
              const d = this.currRequestId++, m = /* @__PURE__ */ new Set();
              this._chunksNeededByRequest.set(d, m);
              for (const n of c)
                this.stream.hasChunk(n) || m.add(n);
              if (m.size === 0)
                return Promise.resolve();
              const p = (0, t.createPromiseCapability)();
              this._promisesByRequest.set(d, p);
              const g = [];
              for (const n of m) {
                let i = this._requestsByChunk.get(n);
                i || (i = [], this._requestsByChunk.set(n, i), g.push(n)), i.push(d);
              }
              if (g.length > 0) {
                const n = this.groupChunks(g);
                for (const i of n) {
                  const l = i.beginChunk * this.chunkSize, u = Math.min(i.endChunk * this.chunkSize, this.length);
                  this.sendRequest(l, u).catch(p.reject);
                }
              }
              return p.promise.catch((n) => {
                if (!this.aborted)
                  throw n;
              });
            }
            getStream() {
              return this.stream;
            }
            requestRange(c, d) {
              d = Math.min(d, this.length);
              const m = this.getBeginChunk(c), p = this.getEndChunk(d), g = [];
              for (let n = m; n < p; ++n)
                g.push(n);
              return this._requestChunks(g);
            }
            requestRanges(c = []) {
              const d = [];
              for (const m of c) {
                const p = this.getBeginChunk(m.begin), g = this.getEndChunk(m.end);
                for (let n = p; n < g; ++n)
                  d.includes(n) || d.push(n);
              }
              return d.sort(function(m, p) {
                return m - p;
              }), this._requestChunks(d);
            }
            groupChunks(c) {
              const d = [];
              let m = -1, p = -1;
              for (let g = 0, n = c.length; g < n; ++g) {
                const i = c[g];
                m < 0 && (m = i), p >= 0 && p + 1 !== i && (d.push({
                  beginChunk: m,
                  endChunk: p + 1
                }), m = i), g + 1 === c.length && d.push({
                  beginChunk: m,
                  endChunk: i + 1
                }), p = i;
              }
              return d;
            }
            onProgress(c) {
              this.msgHandler.send("DocProgress", {
                loaded: this.stream.numChunksLoaded * this.chunkSize + c.loaded,
                total: this.length
              });
            }
            onReceiveData(c) {
              const d = c.chunk, m = c.begin === void 0, p = m ? this.progressiveDataLength : c.begin, g = p + d.byteLength, n = Math.floor(p / this.chunkSize), i = g < this.length ? Math.floor(g / this.chunkSize) : Math.ceil(g / this.chunkSize);
              m ? (this.stream.onReceiveProgressiveData(d), this.progressiveDataLength = g) : this.stream.onReceiveData(p, d), this.stream.isDataLoaded && this._loadedStreamCapability.resolve(this.stream);
              const l = [];
              for (let u = n; u < i; ++u) {
                const w = this._requestsByChunk.get(u);
                if (w) {
                  this._requestsByChunk.delete(u);
                  for (const O of w) {
                    const b = this._chunksNeededByRequest.get(O);
                    b.has(u) && b.delete(u), !(b.size > 0) && l.push(O);
                  }
                }
              }
              if (!this.disableAutoFetch && this._requestsByChunk.size === 0) {
                let u;
                if (this.stream.numChunksLoaded === 1) {
                  const w = this.stream.numChunks - 1;
                  this.stream.hasChunk(w) || (u = w);
                } else
                  u = this.stream.nextEmptyChunk(i);
                Number.isInteger(u) && this._requestChunks([u]);
              }
              for (const u of l) {
                const w = this._promisesByRequest.get(u);
                this._promisesByRequest.delete(u), w.resolve();
              }
              this.msgHandler.send("DocProgress", {
                loaded: this.stream.numChunksLoaded * this.chunkSize,
                total: this.length
              });
            }
            onError(c) {
              this._loadedStreamCapability.reject(c);
            }
            getBeginChunk(c) {
              return Math.floor(c / this.chunkSize);
            }
            getEndChunk(c) {
              return Math.floor((c - 1) / this.chunkSize) + 1;
            }
            abort(c) {
              this.aborted = !0, this.pdfNetworkStream && this.pdfNetworkStream.cancelAllRequests(c);
              for (const d of this._promisesByRequest.values())
                d.reject(c);
            }
          }
          o.ChunkedStreamManager = e;
        },
        /* 10 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.StringStream = o.Stream = o.NullStream = void 0;
          var t = F(7), a = F(2);
          class v extends t.BaseStream {
            constructor(c, d, m, p) {
              super(), this.bytes = c instanceof Uint8Array ? c : new Uint8Array(c), this.start = d || 0, this.pos = this.start, this.end = d + m || this.bytes.length, this.dict = p;
            }
            get length() {
              return this.end - this.start;
            }
            get isEmpty() {
              return this.length === 0;
            }
            getByte() {
              return this.pos >= this.end ? -1 : this.bytes[this.pos++];
            }
            getBytes(c) {
              const d = this.bytes, m = this.pos, p = this.end;
              if (!c)
                return d.subarray(m, p);
              let g = m + c;
              return g > p && (g = p), this.pos = g, d.subarray(m, g);
            }
            getByteRange(c, d) {
              return c < 0 && (c = 0), d > this.end && (d = this.end), this.bytes.subarray(c, d);
            }
            reset() {
              this.pos = this.start;
            }
            moveStart() {
              this.start = this.pos;
            }
            makeSubStream(c, d, m = null) {
              return new v(this.bytes.buffer, c, d, m);
            }
          }
          o.Stream = v;
          class h extends v {
            constructor(c) {
              super((0, a.stringToBytes)(c));
            }
          }
          o.StringStream = h;
          class e extends v {
            constructor() {
              super(new Uint8Array(0));
            }
          }
          o.NullStream = e;
        },
        /* 11 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.Page = o.PDFDocument = void 0;
          var t = F(12), a = F(2), v = F(6), h = F(5), e = F(51), y = F(7), c = F(67), d = F(69), m = F(71), p = F(100), g = F(17), n = F(10), i = F(75), l = F(62), u = F(15), w = F(19), O = F(74), b = F(65), A = F(76), Y = F(101);
          const j = 1, X = [0, 0, 612, 792];
          class B {
            constructor({
              pdfManager: P,
              xref: M,
              pageIndex: G,
              pageDict: Z,
              ref: $,
              globalIdFactory: z,
              fontCache: V,
              builtInCMapCache: L,
              standardFontDataCache: K,
              globalImageCache: ne,
              nonBlendModesSet: se,
              xfaFactory: q
            }) {
              this.pdfManager = P, this.pageIndex = G, this.pageDict = Z, this.xref = M, this.ref = $, this.fontCache = V, this.builtInCMapCache = L, this.standardFontDataCache = K, this.globalImageCache = ne, this.nonBlendModesSet = se, this.evaluatorOptions = P.evaluatorOptions, this.resourcesPromise = null, this.xfaFactory = q;
              const N = {
                obj: 0
              };
              this._localIdFactory = class extends z {
                static createObjId() {
                  return `p${G}_${++N.obj}`;
                }
                static getPageObjId() {
                  return `page${$.toString()}`;
                }
              };
            }
            _getInheritableProperty(P, M = !1) {
              const G = (0, v.getInheritableProperty)({
                dict: this.pageDict,
                key: P,
                getArray: M,
                stopWhenFound: !1
              });
              return Array.isArray(G) ? G.length === 1 || !(G[0] instanceof h.Dict) ? G[0] : h.Dict.merge({
                xref: this.xref,
                dictArray: G
              }) : G;
            }
            get content() {
              return this.pageDict.getArray("Contents");
            }
            get resources() {
              const P = this._getInheritableProperty("Resources");
              return (0, a.shadow)(this, "resources", P instanceof h.Dict ? P : h.Dict.empty);
            }
            _getBoundingBox(P) {
              if (this.xfaData)
                return this.xfaData.bbox;
              const M = this._getInheritableProperty(P, !0);
              if (Array.isArray(M) && M.length === 4) {
                if (M[2] - M[0] !== 0 && M[3] - M[1] !== 0)
                  return M;
                (0, a.warn)(`Empty /${P} entry.`);
              }
              return null;
            }
            get mediaBox() {
              return (0, a.shadow)(this, "mediaBox", this._getBoundingBox("MediaBox") || X);
            }
            get cropBox() {
              return (0, a.shadow)(this, "cropBox", this._getBoundingBox("CropBox") || this.mediaBox);
            }
            get userUnit() {
              let P = this.pageDict.get("UserUnit");
              return (typeof P != "number" || P <= 0) && (P = j), (0, a.shadow)(this, "userUnit", P);
            }
            get view() {
              const {
                cropBox: P,
                mediaBox: M
              } = this;
              let G;
              if (P === M || (0, a.isArrayEqual)(P, M))
                G = M;
              else {
                const Z = a.Util.intersect(P, M);
                Z && Z[2] - Z[0] !== 0 && Z[3] - Z[1] !== 0 ? G = Z : (0, a.warn)("Empty /CropBox and /MediaBox intersection.");
              }
              return (0, a.shadow)(this, "view", G || M);
            }
            get rotate() {
              let P = this._getInheritableProperty("Rotate") || 0;
              return P % 90 !== 0 ? P = 0 : P >= 360 ? P %= 360 : P < 0 && (P = (P % 360 + 360) % 360), (0, a.shadow)(this, "rotate", P);
            }
            _onSubStreamError(P, M, G) {
              if (this.evaluatorOptions.ignoreErrors) {
                P.send("UnsupportedFeature", {
                  featureId: a.UNSUPPORTED_FEATURES.errorContentSubStream
                }), (0, a.warn)(`getContentStream - ignoring sub-stream (${G}): "${M}".`);
                return;
              }
              throw M;
            }
            getContentStream(P) {
              return this.pdfManager.ensure(this, "content").then((M) => M instanceof y.BaseStream ? M : Array.isArray(M) ? new w.StreamsSequenceStream(M, this._onSubStreamError.bind(this, P)) : new n.NullStream());
            }
            get xfaData() {
              return (0, a.shadow)(this, "xfaData", this.xfaFactory ? {
                bbox: this.xfaFactory.getBoundingBox(this.pageIndex)
              } : null);
            }
            async saveNewAnnotations(P, M, G) {
              if (this.xfaFactory)
                throw new Error("XFA: Cannot save new annotations.");
              const Z = new u.PartialEvaluator({
                xref: this.xref,
                handler: P,
                pageIndex: this.pageIndex,
                idFactory: this._localIdFactory,
                fontCache: this.fontCache,
                builtInCMapCache: this.builtInCMapCache,
                standardFontDataCache: this.standardFontDataCache,
                globalImageCache: this.globalImageCache,
                options: this.evaluatorOptions
              }), $ = this.pageDict, z = this.annotations.slice(), V = await t.AnnotationFactory.saveNewAnnotations(Z, M, G);
              for (const {
                ref: q
              } of V.annotations)
                z.push(q);
              const L = $.get("Annots");
              $.set("Annots", z);
              const K = [];
              let ne = null;
              this.xref.encrypt && (ne = this.xref.encrypt.createCipherTransform(this.ref.num, this.ref.gen)), (0, b.writeObject)(this.ref, $, K, ne), L && $.set("Annots", L);
              const se = V.dependencies;
              return se.push({
                ref: this.ref,
                data: K.join("")
              }, ...V.annotations), se;
            }
            save(P, M, G) {
              const Z = new u.PartialEvaluator({
                xref: this.xref,
                handler: P,
                pageIndex: this.pageIndex,
                idFactory: this._localIdFactory,
                fontCache: this.fontCache,
                builtInCMapCache: this.builtInCMapCache,
                standardFontDataCache: this.standardFontDataCache,
                globalImageCache: this.globalImageCache,
                options: this.evaluatorOptions
              });
              return this._parsedAnnotations.then(function($) {
                const z = [];
                for (const V of $)
                  V.mustBePrinted(G) && z.push(V.save(Z, M, G).catch(function(L) {
                    return (0, a.warn)(`save - ignoring annotation data during "${M.name}" task: "${L}".`), null;
                  }));
                return Promise.all(z).then(function(V) {
                  return V.filter((L) => !!L);
                });
              });
            }
            loadResources(P) {
              return this.resourcesPromise || (this.resourcesPromise = this.pdfManager.ensure(this, "resources")), this.resourcesPromise.then(() => new i.ObjectLoader(this.resources, P, this.xref).load());
            }
            getOperatorList({
              handler: P,
              sink: M,
              task: G,
              intent: Z,
              cacheKey: $,
              annotationStorage: z = null
            }) {
              const V = this.getContentStream(P), L = this.loadResources(["ColorSpace", "ExtGState", "Font", "Pattern", "Properties", "Shading", "XObject"]), K = new u.PartialEvaluator({
                xref: this.xref,
                handler: P,
                pageIndex: this.pageIndex,
                idFactory: this._localIdFactory,
                fontCache: this.fontCache,
                builtInCMapCache: this.builtInCMapCache,
                standardFontDataCache: this.standardFontDataCache,
                globalImageCache: this.globalImageCache,
                options: this.evaluatorOptions
              }), ne = this.xfaFactory ? null : (0, v.getNewAnnotationsMap)(z);
              let se = Promise.resolve(null);
              if (ne) {
                const Q = ne.get(this.pageIndex);
                Q && (se = t.AnnotationFactory.printNewAnnotations(K, G, Q));
              }
              const N = Promise.all([V, L]).then(([Q]) => {
                const E = new l.OperatorList(Z, M);
                return P.send("StartRenderPage", {
                  transparency: K.hasBlendModes(this.resources, this.nonBlendModesSet),
                  pageIndex: this.pageIndex,
                  cacheKey: $
                }), K.getOperatorList({
                  stream: Q,
                  task: G,
                  resources: this.resources,
                  operatorList: E
                }).then(function() {
                  return E;
                });
              });
              return Promise.all([N, this._parsedAnnotations, se]).then(function([Q, E, te]) {
                if (te && (E = E.concat(te)), E.length === 0 || Z & a.RenderingIntentFlag.ANNOTATIONS_DISABLE)
                  return Q.flush(!0), {
                    length: Q.totalLength
                  };
                const oe = !!(Z & a.RenderingIntentFlag.ANNOTATIONS_FORMS), ee = !!(Z & a.RenderingIntentFlag.ANY), W = !!(Z & a.RenderingIntentFlag.DISPLAY), I = !!(Z & a.RenderingIntentFlag.PRINT), H = [];
                for (const ie of E)
                  (ee || W && ie.mustBeViewed(z) || I && ie.mustBePrinted(z)) && H.push(ie.getOperatorList(K, G, Z, oe, z).catch(function(ue) {
                    return (0, a.warn)(`getOperatorList - ignoring annotation data during "${G.name}" task: "${ue}".`), null;
                  }));
                return Promise.all(H).then(function(ie) {
                  let ue = !1, fe = !1;
                  for (const {
                    opList: de,
                    separateForm: pe,
                    separateCanvas: xe
                  } of ie)
                    Q.addOpList(de), pe && (ue = pe), xe && (fe = xe);
                  return Q.flush(!0, {
                    form: ue,
                    canvas: fe
                  }), {
                    length: Q.totalLength
                  };
                });
              });
            }
            extractTextContent({
              handler: P,
              task: M,
              includeMarkedContent: G,
              sink: Z,
              combineTextItems: $
            }) {
              const z = this.getContentStream(P), V = this.loadResources(["ExtGState", "Font", "Properties", "XObject"]);
              return Promise.all([z, V]).then(([K]) => new u.PartialEvaluator({
                xref: this.xref,
                handler: P,
                pageIndex: this.pageIndex,
                idFactory: this._localIdFactory,
                fontCache: this.fontCache,
                builtInCMapCache: this.builtInCMapCache,
                standardFontDataCache: this.standardFontDataCache,
                globalImageCache: this.globalImageCache,
                options: this.evaluatorOptions
              }).getTextContent({
                stream: K,
                task: M,
                resources: this.resources,
                includeMarkedContent: G,
                combineTextItems: $,
                sink: Z,
                viewBox: this.view
              }));
            }
            async getStructTree() {
              const P = await this.pdfManager.ensureCatalog("structTreeRoot");
              return P ? (await this.pdfManager.ensure(this, "_parseStructTree", [P])).serializable : null;
            }
            _parseStructTree(P) {
              const M = new O.StructTreePage(P, this.pageDict);
              return M.parse(), M;
            }
            async getAnnotationsData(P, M, G) {
              const Z = await this._parsedAnnotations;
              if (Z.length === 0)
                return [];
              const $ = [], z = [];
              let V;
              const L = !!(G & a.RenderingIntentFlag.ANY), K = !!(G & a.RenderingIntentFlag.DISPLAY), ne = !!(G & a.RenderingIntentFlag.PRINT);
              for (const se of Z) {
                const q = L || K && se.viewable;
                (q || ne && se.printable) && z.push(se.data), se.hasTextContent && q && (V || (V = new u.PartialEvaluator({
                  xref: this.xref,
                  handler: P,
                  pageIndex: this.pageIndex,
                  idFactory: this._localIdFactory,
                  fontCache: this.fontCache,
                  builtInCMapCache: this.builtInCMapCache,
                  standardFontDataCache: this.standardFontDataCache,
                  globalImageCache: this.globalImageCache,
                  options: this.evaluatorOptions
                })), $.push(se.extractTextContent(V, M, this.view).catch(function(N) {
                  (0, a.warn)(`getAnnotationsData - ignoring textContent during "${M.name}" task: "${N}".`);
                })));
              }
              return await Promise.all($), z;
            }
            get annotations() {
              const P = this._getInheritableProperty("Annots");
              return (0, a.shadow)(this, "annotations", Array.isArray(P) ? P : []);
            }
            get _parsedAnnotations() {
              const P = this.pdfManager.ensure(this, "annotations").then(() => {
                const M = [];
                for (const G of this.annotations)
                  M.push(t.AnnotationFactory.create(this.xref, G, this.pdfManager, this._localIdFactory, !1).catch(function(Z) {
                    return (0, a.warn)(`_parsedAnnotations: "${Z}".`), null;
                  }));
                return Promise.all(M).then(function(G) {
                  if (G.length === 0)
                    return G;
                  const Z = [];
                  let $;
                  for (const z of G)
                    if (z) {
                      if (z instanceof t.PopupAnnotation) {
                        $ || ($ = []), $.push(z);
                        continue;
                      }
                      Z.push(z);
                    }
                  return $ && Z.push(...$), Z;
                });
              });
              return (0, a.shadow)(this, "_parsedAnnotations", P);
            }
            get jsActions() {
              const P = (0, v.collectActions)(this.xref, this.pageDict, a.PageActionEventType);
              return (0, a.shadow)(this, "jsActions", P);
            }
          }
          o.Page = B;
          const U = new Uint8Array([37, 80, 68, 70, 45]), k = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]), x = new Uint8Array([101, 110, 100, 111, 98, 106]), f = 1024, D = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", _ = /^[1-9]\.\d$/;
          function S(T, P, M = 1024, G = !1) {
            const Z = P.length, $ = T.peekBytes(M), z = $.length - Z;
            if (z <= 0)
              return !1;
            if (G) {
              const V = Z - 1;
              let L = $.length - 1;
              for (; L >= V; ) {
                let K = 0;
                for (; K < Z && $[L - K] === P[V - K]; )
                  K++;
                if (K >= Z)
                  return T.pos += L - V, !0;
                L--;
              }
            } else {
              let V = 0;
              for (; V <= z; ) {
                let L = 0;
                for (; L < Z && $[V + L] === P[L]; )
                  L++;
                if (L >= Z)
                  return T.pos += V, !0;
                V++;
              }
            }
            return !1;
          }
          class C {
            constructor(P, M) {
              if (M.length <= 0)
                throw new a.InvalidPDFException("The PDF file is empty, i.e. its size is zero bytes.");
              this.pdfManager = P, this.stream = M, this.xref = new Y.XRef(M, P), this._pagePromises = /* @__PURE__ */ new Map(), this._version = null;
              const G = {
                font: 0
              };
              this._globalIdFactory = class {
                static getDocId() {
                  return `g_${P.docId}`;
                }
                static createFontId() {
                  return `f${++G.font}`;
                }
                static createObjId() {
                  (0, a.unreachable)("Abstract method `createObjId` called.");
                }
                static getPageObjId() {
                  (0, a.unreachable)("Abstract method `getPageObjId` called.");
                }
              };
            }
            parse(P) {
              this.xref.parse(P), this.catalog = new d.Catalog(this.pdfManager, this.xref), this.catalog.version && (this._version = this.catalog.version);
            }
            get linearization() {
              let P = null;
              try {
                P = g.Linearization.create(this.stream);
              } catch (M) {
                if (M instanceof v.MissingDataException)
                  throw M;
                (0, a.info)(M);
              }
              return (0, a.shadow)(this, "linearization", P);
            }
            get startXRef() {
              const P = this.stream;
              let M = 0;
              if (this.linearization)
                P.reset(), S(P, x) && (M = P.pos + 6 - P.start);
              else {
                const Z = k.length;
                let $ = !1, z = P.end;
                for (; !$ && z > 0; )
                  z -= 1024 - Z, z < 0 && (z = 0), P.pos = z, $ = S(P, k, 1024, !0);
                if ($) {
                  P.skip(9);
                  let V;
                  do
                    V = P.getByte();
                  while ((0, v.isWhiteSpace)(V));
                  let L = "";
                  for (; V >= 32 && V <= 57; )
                    L += String.fromCharCode(V), V = P.getByte();
                  M = parseInt(L, 10), isNaN(M) && (M = 0);
                }
              }
              return (0, a.shadow)(this, "startXRef", M);
            }
            checkHeader() {
              const P = this.stream;
              if (P.reset(), !S(P, U))
                return;
              P.moveStart();
              const M = 12;
              let G = "", Z;
              for (; (Z = P.getByte()) > 32 && !(G.length >= M); )
                G += String.fromCharCode(Z);
              this._version || (this._version = G.substring(5));
            }
            parseStartXRef() {
              this.xref.setStartXRef(this.startXRef);
            }
            get numPages() {
              let P = 0;
              return this.catalog.hasActualNumPages ? P = this.catalog.numPages : this.xfaFactory ? P = this.xfaFactory.getNumPages() : this.linearization ? P = this.linearization.numPages : P = this.catalog.numPages, (0, a.shadow)(this, "numPages", P);
            }
            _hasOnlyDocumentSignatures(P, M = 0) {
              return Array.isArray(P) ? P.every((Z) => {
                if (Z = this.xref.fetchIfRef(Z), !(Z instanceof h.Dict))
                  return !1;
                if (Z.has("Kids"))
                  return ++M > 10 ? ((0, a.warn)("_hasOnlyDocumentSignatures: maximum recursion depth reached"), !1) : this._hasOnlyDocumentSignatures(Z.get("Kids"), M);
                const $ = (0, h.isName)(Z.get("FT"), "Sig"), z = Z.get("Rect"), V = Array.isArray(z) && z.every((L) => L === 0);
                return $ && V;
              }) : !1;
            }
            get _xfaStreams() {
              const P = this.catalog.acroForm;
              if (!P)
                return null;
              const M = P.get("XFA"), G = {
                "xdp:xdp": "",
                template: "",
                datasets: "",
                config: "",
                connectionSet: "",
                localeSet: "",
                stylesheet: "",
                "/xdp:xdp": ""
              };
              if (M instanceof y.BaseStream && !M.isEmpty)
                return G["xdp:xdp"] = M, G;
              if (!Array.isArray(M) || M.length === 0)
                return null;
              for (let Z = 0, $ = M.length; Z < $; Z += 2) {
                let z;
                if (Z === 0 ? z = "xdp:xdp" : Z === $ - 2 ? z = "/xdp:xdp" : z = M[Z], !G.hasOwnProperty(z))
                  continue;
                const V = this.xref.fetchIfRef(M[Z + 1]);
                !(V instanceof y.BaseStream) || V.isEmpty || (G[z] = V);
              }
              return G;
            }
            get xfaDatasets() {
              const P = this._xfaStreams;
              if (!P)
                return (0, a.shadow)(this, "xfaDatasets", null);
              for (const M of ["datasets", "xdp:xdp"]) {
                const G = P[M];
                if (G)
                  try {
                    const Z = (0, a.stringToUTF8String)(G.getString()), $ = {
                      [M]: Z
                    };
                    return (0, a.shadow)(this, "xfaDatasets", new p.DatasetReader($));
                  } catch {
                    (0, a.warn)("XFA - Invalid utf-8 string.");
                    break;
                  }
              }
              return (0, a.shadow)(this, "xfaDatasets", null);
            }
            get xfaData() {
              const P = this._xfaStreams;
              if (!P)
                return null;
              const M = /* @__PURE__ */ Object.create(null);
              for (const [G, Z] of Object.entries(P))
                if (Z)
                  try {
                    M[G] = (0, a.stringToUTF8String)(Z.getString());
                  } catch {
                    return (0, a.warn)("XFA - Invalid utf-8 string."), null;
                  }
              return M;
            }
            get xfaFactory() {
              let P;
              return this.pdfManager.enableXfa && this.catalog.needsRendering && this.formInfo.hasXfa && !this.formInfo.hasAcroForm && (P = this.xfaData), (0, a.shadow)(this, "xfaFactory", P ? new A.XFAFactory(P) : null);
            }
            get isPureXfa() {
              return this.xfaFactory ? this.xfaFactory.isValid() : !1;
            }
            get htmlForXfa() {
              return this.xfaFactory ? this.xfaFactory.getPages() : null;
            }
            async loadXfaImages() {
              const P = await this.pdfManager.ensureCatalog("xfaImages");
              if (!P)
                return;
              const M = P.getKeys();
              await new i.ObjectLoader(P, M, this.xref).load();
              const Z = /* @__PURE__ */ new Map();
              for (const $ of M) {
                const z = P.get($);
                z instanceof y.BaseStream && Z.set($, z.getBytes());
              }
              this.xfaFactory.setImages(Z);
            }
            async loadXfaFonts(P, M) {
              const G = await this.pdfManager.ensureCatalog("acroForm");
              if (!G)
                return;
              const Z = await G.getAsync("DR");
              if (!(Z instanceof h.Dict))
                return;
              await new i.ObjectLoader(Z, ["Font"], this.xref).load();
              const z = Z.get("Font");
              if (!(z instanceof h.Dict))
                return;
              const V = Object.assign(/* @__PURE__ */ Object.create(null), this.pdfManager.evaluatorOptions);
              V.useSystemFonts = !1;
              const L = new u.PartialEvaluator({
                xref: this.xref,
                handler: P,
                pageIndex: -1,
                idFactory: this._globalIdFactory,
                fontCache: this.catalog.fontCache,
                builtInCMapCache: this.catalog.builtInCMapCache,
                standardFontDataCache: this.catalog.standardFontDataCache,
                options: V
              }), K = new l.OperatorList(), ne = [], se = {
                get font() {
                  return ne.at(-1);
                },
                set font(te) {
                  ne.push(te);
                },
                clone() {
                  return this;
                }
              }, q = /* @__PURE__ */ new Map();
              z.forEach((te, oe) => {
                q.set(te, oe);
              });
              const N = [];
              for (const [te, oe] of q) {
                const ee = oe.get("FontDescriptor");
                if (!(ee instanceof h.Dict))
                  continue;
                let W = ee.get("FontFamily");
                W = W.replace(/[ ]+(\d)/g, "$1");
                const I = ee.get("FontWeight"), H = -ee.get("ItalicAngle"), ie = {
                  fontFamily: W,
                  fontWeight: I,
                  italicAngle: H
                };
                (0, v.validateCSSFont)(ie) && N.push(L.handleSetFont(Z, [h.Name.get(te), 1], null, K, M, se, null, ie).catch(function(ue) {
                  return (0, a.warn)(`loadXfaFonts: "${ue}".`), null;
                }));
              }
              await Promise.all(N);
              const Q = this.xfaFactory.setFonts(ne);
              if (!Q)
                return;
              V.ignoreErrors = !0, N.length = 0, ne.length = 0;
              const E = /* @__PURE__ */ new Set();
              for (const te of Q)
                (0, e.getXfaFontName)(`${te}-Regular`) || E.add(te);
              E.size && Q.push("PdfJS-Fallback");
              for (const te of Q)
                if (!E.has(te))
                  for (const oe of [{
                    name: "Regular",
                    fontWeight: 400,
                    italicAngle: 0
                  }, {
                    name: "Bold",
                    fontWeight: 700,
                    italicAngle: 0
                  }, {
                    name: "Italic",
                    fontWeight: 400,
                    italicAngle: 12
                  }, {
                    name: "BoldItalic",
                    fontWeight: 700,
                    italicAngle: 12
                  }]) {
                    const ee = `${te}-${oe.name}`, W = (0, e.getXfaFontDict)(ee);
                    N.push(L.handleSetFont(Z, [h.Name.get(ee), 1], null, K, M, se, W, {
                      fontFamily: te,
                      fontWeight: oe.fontWeight,
                      italicAngle: oe.italicAngle
                    }).catch(function(I) {
                      return (0, a.warn)(`loadXfaFonts: "${I}".`), null;
                    }));
                  }
              await Promise.all(N), this.xfaFactory.appendFonts(ne, E);
            }
            async serializeXfaData(P) {
              return this.xfaFactory ? this.xfaFactory.serializeData(P) : null;
            }
            get formInfo() {
              const P = {
                hasFields: !1,
                hasAcroForm: !1,
                hasXfa: !1,
                hasSignatures: !1
              }, M = this.catalog.acroForm;
              if (!M)
                return (0, a.shadow)(this, "formInfo", P);
              try {
                const G = M.get("Fields"), Z = Array.isArray(G) && G.length > 0;
                P.hasFields = Z;
                const $ = M.get("XFA");
                P.hasXfa = Array.isArray($) && $.length > 0 || $ instanceof y.BaseStream && !$.isEmpty;
                const V = !!(M.get("SigFlags") & 1), L = V && this._hasOnlyDocumentSignatures(G);
                P.hasAcroForm = Z && !L, P.hasSignatures = V;
              } catch (G) {
                if (G instanceof v.MissingDataException)
                  throw G;
                (0, a.warn)(`Cannot fetch form information: "${G}".`);
              }
              return (0, a.shadow)(this, "formInfo", P);
            }
            get documentInfo() {
              let P = this._version;
              (typeof P != "string" || !_.test(P)) && ((0, a.warn)(`Invalid PDF header version number: ${P}`), P = null);
              const M = {
                PDFFormatVersion: P,
                Language: this.catalog.lang,
                EncryptFilterName: this.xref.encrypt ? this.xref.encrypt.filterName : null,
                IsLinearized: !!this.linearization,
                IsAcroFormPresent: this.formInfo.hasAcroForm,
                IsXFAPresent: this.formInfo.hasXfa,
                IsCollectionPresent: !!this.catalog.collection,
                IsSignaturesPresent: this.formInfo.hasSignatures
              };
              let G;
              try {
                G = this.xref.trailer.get("Info");
              } catch (Z) {
                if (Z instanceof v.MissingDataException)
                  throw Z;
                (0, a.info)("The document information dictionary is invalid.");
              }
              if (!(G instanceof h.Dict))
                return (0, a.shadow)(this, "documentInfo", M);
              for (const Z of G.getKeys()) {
                const $ = G.get(Z);
                switch (Z) {
                  case "Title":
                  case "Author":
                  case "Subject":
                  case "Keywords":
                  case "Creator":
                  case "Producer":
                  case "CreationDate":
                  case "ModDate":
                    if (typeof $ == "string") {
                      M[Z] = (0, a.stringToPDFString)($);
                      continue;
                    }
                    break;
                  case "Trapped":
                    if ($ instanceof h.Name) {
                      M[Z] = $;
                      continue;
                    }
                    break;
                  default:
                    let z;
                    switch (typeof $) {
                      case "string":
                        z = (0, a.stringToPDFString)($);
                        break;
                      case "number":
                      case "boolean":
                        z = $;
                        break;
                      default:
                        $ instanceof h.Name && (z = $);
                        break;
                    }
                    if (z === void 0) {
                      (0, a.warn)(`Bad value, for custom key "${Z}", in Info: ${$}.`);
                      continue;
                    }
                    M.Custom || (M.Custom = /* @__PURE__ */ Object.create(null)), M.Custom[Z] = z;
                    continue;
                }
                (0, a.warn)(`Bad value, for key "${Z}", in Info: ${$}.`);
              }
              return (0, a.shadow)(this, "documentInfo", M);
            }
            get fingerprints() {
              function P(z) {
                return typeof z == "string" && z.length > 0 && z !== D;
              }
              function M(z) {
                const V = [];
                for (let L = 0, K = z.length; L < K; L++) {
                  const ne = z[L].toString(16);
                  V.push(ne.padStart(2, "0"));
                }
                return V.join("");
              }
              const G = this.xref.trailer.get("ID");
              let Z, $;
              return Array.isArray(G) && P(G[0]) ? (Z = (0, a.stringToBytes)(G[0]), G[1] !== G[0] && P(G[1]) && ($ = (0, a.stringToBytes)(G[1]))) : Z = (0, c.calculateMD5)(this.stream.getByteRange(0, f), 0, f), (0, a.shadow)(this, "fingerprints", [M(Z), $ ? M($) : null]);
            }
            async _getLinearizationPage(P) {
              const {
                catalog: M,
                linearization: G,
                xref: Z
              } = this, $ = h.Ref.get(G.objectNumberFirst, 0);
              try {
                const z = await Z.fetchAsync($);
                if (z instanceof h.Dict) {
                  let V = z.getRaw("Type");
                  if (V instanceof h.Ref && (V = await Z.fetchAsync(V)), (0, h.isName)(V, "Page") || !z.has("Type") && !z.has("Kids"))
                    return M.pageKidsCountCache.has($) || M.pageKidsCountCache.put($, 1), M.pageIndexCache.has($) || M.pageIndexCache.put($, 0), [z, $];
                }
                throw new a.FormatError("The Linearization dictionary doesn't point to a valid Page dictionary.");
              } catch (z) {
                return (0, a.warn)(`_getLinearizationPage: "${z.message}".`), M.getPageDict(P);
              }
            }
            getPage(P) {
              const M = this._pagePromises.get(P);
              if (M)
                return M;
              const {
                catalog: G,
                linearization: Z,
                xfaFactory: $
              } = this;
              let z;
              return $ ? z = Promise.resolve([h.Dict.empty, null]) : Z && Z.pageFirst === P ? z = this._getLinearizationPage(P) : z = G.getPageDict(P), z = z.then(([V, L]) => new B({
                pdfManager: this.pdfManager,
                xref: this.xref,
                pageIndex: P,
                pageDict: V,
                ref: L,
                globalIdFactory: this._globalIdFactory,
                fontCache: G.fontCache,
                builtInCMapCache: G.builtInCMapCache,
                standardFontDataCache: G.standardFontDataCache,
                globalImageCache: G.globalImageCache,
                nonBlendModesSet: G.nonBlendModesSet,
                xfaFactory: $
              })), this._pagePromises.set(P, z), z;
            }
            async checkFirstPage(P = !1) {
              if (!P)
                try {
                  await this.getPage(0);
                } catch (M) {
                  if (M instanceof v.XRefEntryException)
                    throw this._pagePromises.delete(0), await this.cleanup(), new v.XRefParseException();
                }
            }
            async checkLastPage(P = !1) {
              const {
                catalog: M,
                pdfManager: G
              } = this;
              M.setActualNumPages();
              let Z;
              try {
                if (await Promise.all([G.ensureDoc("xfaFactory"), G.ensureDoc("linearization"), G.ensureCatalog("numPages")]), this.xfaFactory)
                  return;
                if (this.linearization ? Z = this.linearization.numPages : Z = M.numPages, Number.isInteger(Z)) {
                  if (Z <= 1)
                    return;
                } else
                  throw new a.FormatError("Page count is not an integer.");
                await this.getPage(Z - 1);
              } catch ($) {
                if (this._pagePromises.delete(Z - 1), await this.cleanup(), $ instanceof v.XRefEntryException && !P)
                  throw new v.XRefParseException();
                (0, a.warn)(`checkLastPage - invalid /Pages tree /Count: ${Z}.`);
                let z;
                try {
                  z = await M.getAllPageDicts(P);
                } catch (V) {
                  if (V instanceof v.XRefEntryException && !P)
                    throw new v.XRefParseException();
                  M.setActualNumPages(1);
                  return;
                }
                for (const [V, [L, K]] of z) {
                  let ne;
                  L instanceof Error ? (ne = Promise.reject(L), ne.catch(() => {
                  })) : ne = Promise.resolve(new B({
                    pdfManager: G,
                    xref: this.xref,
                    pageIndex: V,
                    pageDict: L,
                    ref: K,
                    globalIdFactory: this._globalIdFactory,
                    fontCache: M.fontCache,
                    builtInCMapCache: M.builtInCMapCache,
                    standardFontDataCache: M.standardFontDataCache,
                    globalImageCache: M.globalImageCache,
                    nonBlendModesSet: M.nonBlendModesSet,
                    xfaFactory: null
                  })), this._pagePromises.set(V, ne);
                }
                M.setActualNumPages(z.size);
              }
            }
            fontFallback(P, M) {
              return this.catalog.fontFallback(P, M);
            }
            async cleanup(P = !1) {
              return this.catalog ? this.catalog.cleanup(P) : (0, m.clearGlobalCaches)();
            }
            _collectFieldObjects(P, M, G) {
              const Z = this.xref.fetchIfRef(M);
              if (Z.has("T")) {
                const $ = (0, a.stringToPDFString)(Z.get("T"));
                P === "" ? P = $ : P = `${P}.${$}`;
              }
              if (G.has(P) || G.set(P, []), G.get(P).push(t.AnnotationFactory.create(this.xref, M, this.pdfManager, this._localIdFactory, !0).then(($) => $ && $.getFieldObject()).catch(function($) {
                return (0, a.warn)(`_collectFieldObjects: "${$}".`), null;
              })), Z.has("Kids")) {
                const $ = Z.get("Kids");
                for (const z of $)
                  this._collectFieldObjects(P, z, G);
              }
            }
            get fieldObjects() {
              if (!this.formInfo.hasFields)
                return (0, a.shadow)(this, "fieldObjects", Promise.resolve(null));
              const P = /* @__PURE__ */ Object.create(null), M = /* @__PURE__ */ new Map();
              for (const Z of this.catalog.acroForm.get("Fields"))
                this._collectFieldObjects("", Z, M);
              const G = [];
              for (const [Z, $] of M)
                G.push(Promise.all($).then((z) => {
                  z = z.filter((V) => !!V), z.length > 0 && (P[Z] = z);
                }));
              return (0, a.shadow)(this, "fieldObjects", Promise.all(G).then(() => P));
            }
            get hasJSActions() {
              const P = this.pdfManager.ensureDoc("_parseHasJSActions");
              return (0, a.shadow)(this, "hasJSActions", P);
            }
            async _parseHasJSActions() {
              const [P, M] = await Promise.all([this.pdfManager.ensureCatalog("jsActions"), this.pdfManager.ensureDoc("fieldObjects")]);
              return P ? !0 : M ? Object.values(M).some((G) => G.some((Z) => Z.actions !== null)) : !1;
            }
            get calculationOrderIds() {
              const P = this.catalog.acroForm;
              if (!P || !P.has("CO"))
                return (0, a.shadow)(this, "calculationOrderIds", null);
              const M = P.get("CO");
              if (!Array.isArray(M) || M.length === 0)
                return (0, a.shadow)(this, "calculationOrderIds", null);
              const G = [];
              for (const Z of M)
                Z instanceof h.Ref && G.push(Z.toString());
              return G.length === 0 ? (0, a.shadow)(this, "calculationOrderIds", null) : (0, a.shadow)(this, "calculationOrderIds", G);
            }
          }
          o.PDFDocument = C;
        },
        /* 12 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.PopupAnnotation = o.MarkupAnnotation = o.AnnotationFactory = o.AnnotationBorderStyle = o.Annotation = void 0, o.getQuadPoints = O;
          var t = F(2), a = F(6), v = F(13), h = F(5), e = F(65), y = F(7), c = F(60), d = F(69), m = F(14), p = F(72), g = F(75), n = F(62), i = F(10), l = F(76);
          class u {
            static create(N, Q, E, te, oe) {
              return Promise.all([E.ensureCatalog("acroForm"), E.ensureCatalog("baseUrl"), E.ensureDoc("xfaDatasets"), oe ? this._getPageIndex(N, Q, E) : -1]).then(([ee, W, I, H]) => E.ensure(this, "_create", [N, Q, E, te, ee, I, oe, H]));
            }
            static _create(N, Q, E, te, oe, ee, W, I = -1) {
              const H = N.fetchIfRef(Q);
              if (!(H instanceof h.Dict))
                return;
              const ie = Q instanceof h.Ref ? Q.toString() : `annot_${te.createObjId()}`;
              let ue = H.get("Subtype");
              ue = ue instanceof h.Name ? ue.name : null;
              const fe = {
                xref: N,
                ref: Q,
                dict: H,
                subtype: ue,
                id: ie,
                pdfManager: E,
                acroForm: oe instanceof h.Dict ? oe : h.Dict.empty,
                xfaDatasets: ee,
                collectFields: W,
                pageIndex: I
              };
              switch (ue) {
                case "Link":
                  return new D(fe);
                case "Text":
                  return new f(fe);
                case "Widget":
                  let de = (0, a.getInheritableProperty)({
                    dict: H,
                    key: "FT"
                  });
                  switch (de = de instanceof h.Name ? de.name : null, de) {
                    case "Tx":
                      return new B(fe);
                    case "Btn":
                      return new U(fe);
                    case "Ch":
                      return new k(fe);
                    case "Sig":
                      return new x(fe);
                  }
                  return (0, t.warn)(`Unimplemented widget field type "${de}", falling back to base field type.`), new X(fe);
                case "Popup":
                  return new _(fe);
                case "FreeText":
                  return new S(fe);
                case "Line":
                  return new C(fe);
                case "Square":
                  return new T(fe);
                case "Circle":
                  return new P(fe);
                case "PolyLine":
                  return new M(fe);
                case "Polygon":
                  return new G(fe);
                case "Caret":
                  return new Z(fe);
                case "Ink":
                  return new $(fe);
                case "Highlight":
                  return new z(fe);
                case "Underline":
                  return new V(fe);
                case "Squiggly":
                  return new L(fe);
                case "StrikeOut":
                  return new K(fe);
                case "Stamp":
                  return new ne(fe);
                case "FileAttachment":
                  return new se(fe);
                default:
                  return W || (ue ? (0, t.warn)(`Unimplemented annotation type "${ue}", falling back to base annotation.`) : (0, t.warn)("Annotation is missing the required /Subtype.")), new A(fe);
              }
            }
            static async _getPageIndex(N, Q, E) {
              try {
                const te = await N.fetchIfRefAsync(Q);
                if (!(te instanceof h.Dict))
                  return -1;
                const oe = te.getRaw("P");
                return oe instanceof h.Ref ? await E.ensureCatalog("getPageIndex", [oe]) : -1;
              } catch (te) {
                return (0, t.warn)(`_getPageIndex: "${te}".`), -1;
              }
            }
            static async saveNewAnnotations(N, Q, E) {
              const te = N.xref;
              let oe;
              const ee = [], W = [];
              for (const I of E)
                switch (I.annotationType) {
                  case t.AnnotationEditorType.FREETEXT:
                    if (!oe) {
                      const H = new h.Dict(te);
                      H.set("BaseFont", h.Name.get("Helvetica")), H.set("Type", h.Name.get("Font")), H.set("Subtype", h.Name.get("Type1")), H.set("Encoding", h.Name.get("WinAnsiEncoding"));
                      const ie = [];
                      oe = te.getNewRef(), (0, e.writeObject)(oe, H, ie, null), ee.push({
                        ref: oe,
                        data: ie.join("")
                      });
                    }
                    W.push(S.createNewAnnotation(te, I, ee, {
                      evaluator: N,
                      task: Q,
                      baseFontRef: oe
                    }));
                    break;
                  case t.AnnotationEditorType.INK:
                    W.push($.createNewAnnotation(te, I, ee));
                }
              return {
                annotations: await Promise.all(W),
                dependencies: ee
              };
            }
            static async printNewAnnotations(N, Q, E) {
              if (!E)
                return null;
              const te = N.xref, oe = [];
              for (const ee of E)
                switch (ee.annotationType) {
                  case t.AnnotationEditorType.FREETEXT:
                    oe.push(S.createNewPrintAnnotation(te, ee, {
                      evaluator: N,
                      task: Q
                    }));
                    break;
                  case t.AnnotationEditorType.INK:
                    oe.push($.createNewPrintAnnotation(te, ee));
                    break;
                }
              return Promise.all(oe);
            }
          }
          o.AnnotationFactory = u;
          function w(q, N = new Uint8ClampedArray(3)) {
            if (!Array.isArray(q))
              return N;
            const Q = N || new Uint8ClampedArray(3);
            switch (q.length) {
              case 0:
                return null;
              case 1:
                return m.ColorSpace.singletons.gray.getRgbItem(q, 0, Q, 0), Q;
              case 3:
                return m.ColorSpace.singletons.rgb.getRgbItem(q, 0, Q, 0), Q;
              case 4:
                return m.ColorSpace.singletons.cmyk.getRgbItem(q, 0, Q, 0), Q;
              default:
                return N;
            }
          }
          function O(q, N) {
            if (!q.has("QuadPoints"))
              return null;
            const Q = q.getArray("QuadPoints");
            if (!Array.isArray(Q) || Q.length === 0 || Q.length % 8 > 0)
              return null;
            const E = [];
            for (let te = 0, oe = Q.length / 8; te < oe; te++) {
              E.push([]);
              for (let ee = te * 8, W = te * 8 + 8; ee < W; ee += 2) {
                const I = Q[ee], H = Q[ee + 1];
                if (N !== null && (I < N[0] || I > N[2] || H < N[1] || H > N[3]))
                  return null;
                E[te].push({
                  x: I,
                  y: H
                });
              }
            }
            return E.map((te) => {
              const [oe, ee, W, I] = te.reduce(([H, ie, ue, fe], de) => [Math.min(H, de.x), Math.max(ie, de.x), Math.min(ue, de.y), Math.max(fe, de.y)], [Number.MAX_VALUE, Number.MIN_VALUE, Number.MAX_VALUE, Number.MIN_VALUE]);
              return [{
                x: oe,
                y: I
              }, {
                x: ee,
                y: I
              }, {
                x: oe,
                y: W
              }, {
                x: ee,
                y: W
              }];
            });
          }
          function b(q, N, Q) {
            const [E, te, oe, ee] = t.Util.getAxialAlignedBoundingBox(N, Q);
            if (E === oe || te === ee)
              return [1, 0, 0, 1, q[0], q[1]];
            const W = (q[2] - q[0]) / (oe - E), I = (q[3] - q[1]) / (ee - te);
            return [W, 0, 0, I, q[0] - E * W, q[1] - te * I];
          }
          class A {
            constructor(N) {
              const Q = N.dict;
              this.setTitle(Q.get("T")), this.setContents(Q.get("Contents")), this.setModificationDate(Q.get("M")), this.setFlags(Q.get("F")), this.setRectangle(Q.getArray("Rect")), this.setColor(Q.getArray("C")), this.setBorderStyle(Q), this.setAppearance(Q), this.setOptionalContent(Q);
              const E = Q.get("MK");
              if (this.setBorderAndBackgroundColors(E), this.setRotation(E), this._streams = [], this.appearance && this._streams.push(this.appearance), this.data = {
                annotationFlags: this.flags,
                borderStyle: this.borderStyle,
                color: this.color,
                backgroundColor: this.backgroundColor,
                borderColor: this.borderColor,
                rotation: this.rotation,
                contentsObj: this._contents,
                hasAppearance: !!this.appearance,
                id: N.id,
                modificationDate: this.modificationDate,
                rect: this.rectangle,
                subtype: N.subtype,
                hasOwnCanvas: !1
              }, N.collectFields) {
                const te = Q.get("Kids");
                if (Array.isArray(te)) {
                  const oe = [];
                  for (const ee of te)
                    ee instanceof h.Ref && oe.push(ee.toString());
                  oe.length !== 0 && (this.data.kidIds = oe);
                }
                this.data.actions = (0, a.collectActions)(N.xref, Q, t.AnnotationActionEventType), this.data.fieldName = this._constructFieldName(Q), this.data.pageIndex = N.pageIndex;
              }
              this._fallbackFontDict = null;
            }
            _hasFlag(N, Q) {
              return !!(N & Q);
            }
            _isViewable(N) {
              return !this._hasFlag(N, t.AnnotationFlag.INVISIBLE) && !this._hasFlag(N, t.AnnotationFlag.NOVIEW);
            }
            _isPrintable(N) {
              return this._hasFlag(N, t.AnnotationFlag.PRINT) && !this._hasFlag(N, t.AnnotationFlag.INVISIBLE);
            }
            mustBeViewed(N) {
              const Q = N && N.get(this.data.id);
              return Q && Q.hidden !== void 0 ? !Q.hidden : this.viewable && !this._hasFlag(this.flags, t.AnnotationFlag.HIDDEN);
            }
            mustBePrinted(N) {
              const Q = N && N.get(this.data.id);
              return Q && Q.print !== void 0 ? Q.print : this.printable;
            }
            get viewable() {
              return this.data.quadPoints === null ? !1 : this.flags === 0 ? !0 : this._isViewable(this.flags);
            }
            get printable() {
              return this.data.quadPoints === null || this.flags === 0 ? !1 : this._isPrintable(this.flags);
            }
            _parseStringHelper(N) {
              const Q = typeof N == "string" ? (0, t.stringToPDFString)(N) : "", E = Q && (0, c.bidi)(Q).dir === "rtl" ? "rtl" : "ltr";
              return {
                str: Q,
                dir: E
              };
            }
            setTitle(N) {
              this._title = this._parseStringHelper(N);
            }
            setContents(N) {
              this._contents = this._parseStringHelper(N);
            }
            setModificationDate(N) {
              this.modificationDate = typeof N == "string" ? N : null;
            }
            setFlags(N) {
              this.flags = Number.isInteger(N) && N > 0 ? N : 0;
            }
            hasFlag(N) {
              return this._hasFlag(this.flags, N);
            }
            setRectangle(N) {
              Array.isArray(N) && N.length === 4 ? this.rectangle = t.Util.normalizeRect(N) : this.rectangle = [0, 0, 0, 0];
            }
            setColor(N) {
              this.color = w(N);
            }
            setLineEndings(N) {
              if (this.lineEndings = ["None", "None"], Array.isArray(N) && N.length === 2)
                for (let Q = 0; Q < 2; Q++) {
                  const E = N[Q];
                  if (E instanceof h.Name)
                    switch (E.name) {
                      case "None":
                        continue;
                      case "Square":
                      case "Circle":
                      case "Diamond":
                      case "OpenArrow":
                      case "ClosedArrow":
                      case "Butt":
                      case "ROpenArrow":
                      case "RClosedArrow":
                      case "Slash":
                        this.lineEndings[Q] = E.name;
                        continue;
                    }
                  (0, t.warn)(`Ignoring invalid lineEnding: ${E}`);
                }
            }
            setRotation(N) {
              if (this.rotation = 0, N instanceof h.Dict) {
                let Q = N.get("R") || 0;
                Number.isInteger(Q) && Q !== 0 && (Q %= 360, Q < 0 && (Q += 360), Q % 90 === 0 && (this.rotation = Q));
              }
            }
            setBorderAndBackgroundColors(N) {
              N instanceof h.Dict ? (this.borderColor = w(N.getArray("BC"), null), this.backgroundColor = w(N.getArray("BG"), null)) : this.borderColor = this.backgroundColor = null;
            }
            setBorderStyle(N) {
              if (this.borderStyle = new Y(), N instanceof h.Dict)
                if (N.has("BS")) {
                  const Q = N.get("BS"), E = Q.get("Type");
                  (!E || (0, h.isName)(E, "Border")) && (this.borderStyle.setWidth(Q.get("W"), this.rectangle), this.borderStyle.setStyle(Q.get("S")), this.borderStyle.setDashArray(Q.getArray("D")));
                } else if (N.has("Border")) {
                  const Q = N.getArray("Border");
                  Array.isArray(Q) && Q.length >= 3 && (this.borderStyle.setHorizontalCornerRadius(Q[0]), this.borderStyle.setVerticalCornerRadius(Q[1]), this.borderStyle.setWidth(Q[2], this.rectangle), Q.length === 4 && this.borderStyle.setDashArray(Q[3], !0));
                } else
                  this.borderStyle.setWidth(0);
            }
            setAppearance(N) {
              this.appearance = null;
              const Q = N.get("AP");
              if (!(Q instanceof h.Dict))
                return;
              const E = Q.get("N");
              if (E instanceof y.BaseStream) {
                this.appearance = E;
                return;
              }
              if (!(E instanceof h.Dict))
                return;
              const te = N.get("AS");
              !(te instanceof h.Name) || !E.has(te.name) || (this.appearance = E.get(te.name));
            }
            setOptionalContent(N) {
              this.oc = null;
              const Q = N.get("OC");
              Q instanceof h.Name ? (0, t.warn)("setOptionalContent: Support for /Name-entry is not implemented.") : Q instanceof h.Dict && (this.oc = Q);
            }
            loadResources(N, Q) {
              return Q.dict.getAsync("Resources").then((E) => E ? new g.ObjectLoader(E, N, E.xref).load().then(function() {
                return E;
              }) : void 0);
            }
            async getOperatorList(N, Q, E, te, oe) {
              const ee = this.data;
              let W = this.appearance;
              const I = !!(this.data.hasOwnCanvas && E & t.RenderingIntentFlag.DISPLAY);
              if (!W) {
                if (!I)
                  return {
                    opList: new n.OperatorList(),
                    separateForm: !1,
                    separateCanvas: !1
                  };
                W = new i.StringStream(""), W.dict = new h.Dict();
              }
              const H = W.dict, ie = await this.loadResources(["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"], W), ue = H.getArray("BBox") || [0, 0, 1, 1], fe = H.getArray("Matrix") || [1, 0, 0, 1, 0, 0], de = b(ee.rect, ue, fe), pe = new n.OperatorList();
              let xe;
              return this.oc && (xe = await N.parseMarkedContentProps(this.oc, null)), xe !== void 0 && pe.addOp(t.OPS.beginMarkedContentProps, ["OC", xe]), pe.addOp(t.OPS.beginAnnotation, [ee.id, ee.rect, de, fe, I]), await N.getOperatorList({
                stream: W,
                task: Q,
                resources: ie,
                operatorList: pe,
                fallbackFontDict: this._fallbackFontDict
              }), pe.addOp(t.OPS.endAnnotation, []), xe !== void 0 && pe.addOp(t.OPS.endMarkedContent, []), this.reset(), {
                opList: pe,
                separateForm: !1,
                separateCanvas: I
              };
            }
            async save(N, Q, E) {
              return null;
            }
            get hasTextContent() {
              return !1;
            }
            async extractTextContent(N, Q, E) {
              if (!this.appearance)
                return;
              const te = await this.loadResources(["ExtGState", "Font", "Properties", "XObject"], this.appearance), oe = [], ee = [], W = {
                desiredSize: Math.Infinity,
                ready: !0,
                enqueue(I, H) {
                  for (const ie of I.items)
                    ee.push(ie.str), ie.hasEOL && (oe.push(ee.join("")), ee.length = 0);
                }
              };
              await N.getTextContent({
                stream: this.appearance,
                task: Q,
                resources: te,
                includeMarkedContent: !0,
                combineTextItems: !0,
                sink: W,
                viewBox: E
              }), this.reset(), ee.length && oe.push(ee.join("")), oe.length > 0 && (this.data.textContent = oe);
            }
            getFieldObject() {
              return this.data.kidIds ? {
                id: this.data.id,
                actions: this.data.actions,
                name: this.data.fieldName,
                strokeColor: this.data.borderColor,
                fillColor: this.data.backgroundColor,
                type: "",
                kidIds: this.data.kidIds,
                page: this.data.pageIndex,
                rotation: this.rotation
              } : null;
            }
            reset() {
              for (const N of this._streams)
                N.reset();
            }
            _constructFieldName(N) {
              if (!N.has("T") && !N.has("Parent"))
                return (0, t.warn)("Unknown field name, falling back to empty field name."), "";
              if (!N.has("Parent"))
                return (0, t.stringToPDFString)(N.get("T"));
              const Q = [];
              N.has("T") && Q.unshift((0, t.stringToPDFString)(N.get("T")));
              let E = N;
              const te = new h.RefSet();
              for (N.objId && te.put(N.objId); E.has("Parent") && (E = E.get("Parent"), !(!(E instanceof h.Dict) || E.objId && te.has(E.objId))); )
                E.objId && te.put(E.objId), E.has("T") && Q.unshift((0, t.stringToPDFString)(E.get("T")));
              return Q.join(".");
            }
          }
          o.Annotation = A;
          class Y {
            constructor() {
              this.width = 1, this.style = t.AnnotationBorderStyleType.SOLID, this.dashArray = [3], this.horizontalCornerRadius = 0, this.verticalCornerRadius = 0;
            }
            setWidth(N, Q = [0, 0, 0, 0]) {
              if (N instanceof h.Name) {
                this.width = 0;
                return;
              }
              if (typeof N == "number") {
                if (N > 0) {
                  const E = (Q[2] - Q[0]) / 2, te = (Q[3] - Q[1]) / 2;
                  E > 0 && te > 0 && (N > E || N > te) && ((0, t.warn)(`AnnotationBorderStyle.setWidth - ignoring width: ${N}`), N = 1);
                }
                this.width = N;
              }
            }
            setStyle(N) {
              if (N instanceof h.Name)
                switch (N.name) {
                  case "S":
                    this.style = t.AnnotationBorderStyleType.SOLID;
                    break;
                  case "D":
                    this.style = t.AnnotationBorderStyleType.DASHED;
                    break;
                  case "B":
                    this.style = t.AnnotationBorderStyleType.BEVELED;
                    break;
                  case "I":
                    this.style = t.AnnotationBorderStyleType.INSET;
                    break;
                  case "U":
                    this.style = t.AnnotationBorderStyleType.UNDERLINE;
                    break;
                }
            }
            setDashArray(N, Q = !1) {
              if (Array.isArray(N) && N.length > 0) {
                let E = !0, te = !0;
                for (const oe of N)
                  if (+oe >= 0)
                    oe > 0 && (te = !1);
                  else {
                    E = !1;
                    break;
                  }
                E && !te ? (this.dashArray = N, Q && this.setStyle(h.Name.get("D"))) : this.width = 0;
              } else
                N && (this.width = 0);
            }
            setHorizontalCornerRadius(N) {
              Number.isInteger(N) && (this.horizontalCornerRadius = N);
            }
            setVerticalCornerRadius(N) {
              Number.isInteger(N) && (this.verticalCornerRadius = N);
            }
          }
          o.AnnotationBorderStyle = Y;
          class j extends A {
            constructor(N) {
              super(N);
              const Q = N.dict;
              if (Q.has("IRT")) {
                const E = Q.getRaw("IRT");
                this.data.inReplyTo = E instanceof h.Ref ? E.toString() : null;
                const te = Q.get("RT");
                this.data.replyType = te instanceof h.Name ? te.name : t.AnnotationReplyType.REPLY;
              }
              if (this.data.replyType === t.AnnotationReplyType.GROUP) {
                const E = Q.get("IRT");
                this.setTitle(E.get("T")), this.data.titleObj = this._title, this.setContents(E.get("Contents")), this.data.contentsObj = this._contents, E.has("CreationDate") ? (this.setCreationDate(E.get("CreationDate")), this.data.creationDate = this.creationDate) : this.data.creationDate = null, E.has("M") ? (this.setModificationDate(E.get("M")), this.data.modificationDate = this.modificationDate) : this.data.modificationDate = null, this.data.hasPopup = E.has("Popup"), E.has("C") ? (this.setColor(E.getArray("C")), this.data.color = this.color) : this.data.color = null;
              } else
                this.data.titleObj = this._title, this.setCreationDate(Q.get("CreationDate")), this.data.creationDate = this.creationDate, this.data.hasPopup = Q.has("Popup"), Q.has("C") || (this.data.color = null);
              Q.has("RC") && (this.data.richText = l.XFAFactory.getRichTextAsHtml(Q.get("RC")));
            }
            setCreationDate(N) {
              this.creationDate = typeof N == "string" ? N : null;
            }
            _setDefaultAppearance({
              xref: N,
              extra: Q,
              strokeColor: E,
              fillColor: te,
              blendMode: oe,
              strokeAlpha: ee,
              fillAlpha: W,
              pointsCallback: I
            }) {
              let H = Number.MAX_VALUE, ie = Number.MAX_VALUE, ue = Number.MIN_VALUE, fe = Number.MIN_VALUE;
              const de = ["q"];
              Q && de.push(Q), E && de.push(`${E[0]} ${E[1]} ${E[2]} RG`), te && de.push(`${te[0]} ${te[1]} ${te[2]} rg`);
              let pe = this.data.quadPoints;
              pe || (pe = [[{
                x: this.rectangle[0],
                y: this.rectangle[3]
              }, {
                x: this.rectangle[2],
                y: this.rectangle[3]
              }, {
                x: this.rectangle[0],
                y: this.rectangle[1]
              }, {
                x: this.rectangle[2],
                y: this.rectangle[1]
              }]]);
              for (const Te of pe) {
                const [ve, Ne, Ge, it] = I(de, Te);
                H = Math.min(H, ve), ue = Math.max(ue, Ne), ie = Math.min(ie, Ge), fe = Math.max(fe, it);
              }
              de.push("Q");
              const xe = new h.Dict(N), Fe = new h.Dict(N);
              Fe.set("Subtype", h.Name.get("Form"));
              const Se = new i.StringStream(de.join(" "));
              Se.dict = Fe, xe.set("Fm0", Se);
              const Ce = new h.Dict(N);
              oe && Ce.set("BM", h.Name.get(oe)), typeof ee == "number" && Ce.set("CA", ee), typeof W == "number" && Ce.set("ca", W);
              const ke = new h.Dict(N);
              ke.set("GS0", Ce);
              const ye = new h.Dict(N);
              ye.set("ExtGState", ke), ye.set("XObject", xe);
              const De = new h.Dict(N);
              De.set("Resources", ye);
              const Ae = this.data.rect = [H, ie, ue, fe];
              De.set("BBox", Ae), this.appearance = new i.StringStream("/GS0 gs /Fm0 Do"), this.appearance.dict = De, this._streams.push(this.appearance, Se);
            }
            static async createNewAnnotation(N, Q, E, te) {
              const oe = N.getNewRef(), ee = N.getNewRef(), W = this.createNewDict(Q, N, {
                apRef: ee
              }), I = await this.createNewAppearanceStream(Q, N, te), H = [];
              let ie = N.encrypt ? N.encrypt.createCipherTransform(ee.num, ee.gen) : null;
              return (0, e.writeObject)(ee, I, H, ie), E.push({
                ref: ee,
                data: H.join("")
              }), H.length = 0, ie = N.encrypt ? N.encrypt.createCipherTransform(oe.num, oe.gen) : null, (0, e.writeObject)(oe, W, H, ie), {
                ref: oe,
                data: H.join("")
              };
            }
            static async createNewPrintAnnotation(N, Q, E) {
              const te = await this.createNewAppearanceStream(Q, N, E), oe = this.createNewDict(Q, N, {
                ap: te
              });
              return new this.prototype.constructor({
                dict: oe,
                xref: N
              });
            }
          }
          o.MarkupAnnotation = j;
          class X extends A {
            constructor(N) {
              super(N);
              const Q = N.dict, E = this.data;
              this.ref = N.ref, E.annotationType = t.AnnotationType.WIDGET, E.fieldName === void 0 && (E.fieldName = this._constructFieldName(Q)), E.actions === void 0 && (E.actions = (0, a.collectActions)(N.xref, Q, t.AnnotationActionEventType));
              let te = (0, a.getInheritableProperty)({
                dict: Q,
                key: "V",
                getArray: !0
              });
              E.fieldValue = this._decodeFormValue(te);
              const oe = (0, a.getInheritableProperty)({
                dict: Q,
                key: "DV",
                getArray: !0
              });
              if (E.defaultFieldValue = this._decodeFormValue(oe), te === void 0 && N.xfaDatasets) {
                const ue = this._title.str;
                ue && (this._hasValueFromXFA = !0, E.fieldValue = te = N.xfaDatasets.getValue(ue));
              }
              te === void 0 && E.defaultFieldValue !== null && (E.fieldValue = E.defaultFieldValue), E.alternativeText = (0, t.stringToPDFString)(Q.get("TU") || "");
              const ee = (0, a.getInheritableProperty)({
                dict: Q,
                key: "DA"
              }) || N.acroForm.get("DA");
              this._defaultAppearance = typeof ee == "string" ? ee : "", E.defaultAppearanceData = (0, v.parseDefaultAppearance)(this._defaultAppearance);
              const W = (0, a.getInheritableProperty)({
                dict: Q,
                key: "FT"
              });
              E.fieldType = W instanceof h.Name ? W.name : null;
              const I = (0, a.getInheritableProperty)({
                dict: Q,
                key: "DR"
              }), H = N.acroForm.get("DR"), ie = this.appearance && this.appearance.dict.get("Resources");
              this._fieldResources = {
                localResources: I,
                acroFormResources: H,
                appearanceResources: ie,
                mergedResources: h.Dict.merge({
                  xref: N.xref,
                  dictArray: [I, ie, H],
                  mergeSubDicts: !0
                })
              }, E.fieldFlags = (0, a.getInheritableProperty)({
                dict: Q,
                key: "Ff"
              }), (!Number.isInteger(E.fieldFlags) || E.fieldFlags < 0) && (E.fieldFlags = 0), E.readOnly = this.hasFieldFlag(t.AnnotationFieldFlag.READONLY), E.required = this.hasFieldFlag(t.AnnotationFieldFlag.REQUIRED), E.hidden = this._hasFlag(E.annotationFlags, t.AnnotationFlag.HIDDEN);
            }
            _decodeFormValue(N) {
              return Array.isArray(N) ? N.filter((Q) => typeof Q == "string").map((Q) => (0, t.stringToPDFString)(Q)) : N instanceof h.Name ? (0, t.stringToPDFString)(N.name) : typeof N == "string" ? (0, t.stringToPDFString)(N) : null;
            }
            hasFieldFlag(N) {
              return !!(this.data.fieldFlags & N);
            }
            static _getRotationMatrix(N, Q, E) {
              switch (N) {
                case 90:
                  return [0, 1, -1, 0, Q, 0];
                case 180:
                  return [-1, 0, 0, -1, Q, E];
                case 270:
                  return [0, -1, 1, 0, 0, E];
                default:
                  throw new Error("Invalid rotation");
              }
            }
            getRotationMatrix(N) {
              const Q = N ? N.get(this.data.id) : void 0;
              let E = Q && Q.rotation;
              if (E === void 0 && (E = this.rotation), E === 0)
                return t.IDENTITY_MATRIX;
              const te = this.data.rect[2] - this.data.rect[0], oe = this.data.rect[3] - this.data.rect[1];
              return X._getRotationMatrix(E, te, oe);
            }
            getBorderAndBackgroundAppearances(N) {
              const Q = N ? N.get(this.data.id) : void 0;
              let E = Q && Q.rotation;
              if (E === void 0 && (E = this.rotation), !this.backgroundColor && !this.borderColor)
                return "";
              const te = this.data.rect[2] - this.data.rect[0], oe = this.data.rect[3] - this.data.rect[1], ee = E === 0 || E === 180 ? `0 0 ${te} ${oe} re` : `0 0 ${oe} ${te} re`;
              let W = "";
              if (this.backgroundColor && (W = `${(0, v.getPdfColor)(this.backgroundColor, !0)} ${ee} f `), this.borderColor) {
                const I = this.borderStyle.width || 1;
                W += `${I} w ${(0, v.getPdfColor)(this.borderColor, !1)} ${ee} S `;
              }
              return W;
            }
            async getOperatorList(N, Q, E, te, oe) {
              if (te && !(this instanceof x))
                return {
                  opList: new n.OperatorList(),
                  separateForm: !0,
                  separateCanvas: !1
                };
              if (!this._hasText)
                return super.getOperatorList(N, Q, E, te, oe);
              const ee = await this._getAppearance(N, Q, oe);
              if (this.appearance && ee === null)
                return super.getOperatorList(N, Q, E, te, oe);
              const W = new n.OperatorList();
              if (!this._defaultAppearance || ee === null)
                return {
                  opList: W,
                  separateForm: !1,
                  separateCanvas: !1
                };
              const I = [1, 0, 0, 1, 0, 0], H = [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]], ie = b(this.data.rect, H, I);
              let ue;
              this.oc && (ue = await N.parseMarkedContentProps(this.oc, null)), ue !== void 0 && W.addOp(t.OPS.beginMarkedContentProps, ["OC", ue]), W.addOp(t.OPS.beginAnnotation, [this.data.id, this.data.rect, ie, this.getRotationMatrix(oe), !1]);
              const fe = new i.StringStream(ee);
              return await N.getOperatorList({
                stream: fe,
                task: Q,
                resources: this._fieldResources.mergedResources,
                operatorList: W
              }), W.addOp(t.OPS.endAnnotation, []), ue !== void 0 && W.addOp(t.OPS.endMarkedContent, []), {
                opList: W,
                separateForm: !1,
                separateCanvas: !1
              };
            }
            _getMKDict(N) {
              const Q = new h.Dict(null);
              return N && Q.set("R", N), this.borderColor && Q.set("BC", Array.from(this.borderColor).map((E) => E / 255)), this.backgroundColor && Q.set("BG", Array.from(this.backgroundColor).map((E) => E / 255)), Q.size > 0 ? Q : null;
            }
            async save(N, Q, E) {
              const te = E ? E.get(this.data.id) : void 0;
              let oe = te && te.value, ee = te && te.rotation;
              if (oe === this.data.fieldValue || oe === void 0) {
                if (!this._hasValueFromXFA && ee === void 0)
                  return null;
                oe = oe || this.data.fieldValue;
              }
              if (ee === void 0 && !this._hasValueFromXFA && Array.isArray(oe) && Array.isArray(this.data.fieldValue) && oe.length === this.data.fieldValue.length && oe.every((Te, ve) => Te === this.data.fieldValue[ve]))
                return null;
              ee === void 0 && (ee = this.rotation);
              let W = await this._getAppearance(N, Q, E);
              if (W === null)
                return null;
              const {
                xref: I
              } = N, H = I.fetchIfRef(this.ref);
              if (!(H instanceof h.Dict))
                return null;
              const ie = [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]], ue = {
                path: (0, t.stringToPDFString)(H.get("T") || ""),
                value: oe
              }, fe = I.getNewRef(), de = new h.Dict(I);
              de.set("N", fe);
              const pe = I.encrypt;
              let xe = null, Fe = null;
              pe && (xe = pe.createCipherTransform(this.ref.num, this.ref.gen), Fe = pe.createCipherTransform(fe.num, fe.gen), W = Fe.encryptString(W));
              const Se = (Te) => (0, t.isAscii)(Te) ? Te : (0, t.stringToUTF16BEString)(Te);
              H.set("V", Array.isArray(oe) ? oe.map(Se) : Se(oe)), H.set("AP", de), H.set("M", `D:${(0, t.getModificationDate)()}`);
              const Ce = this._getMKDict(ee);
              Ce && H.set("MK", Ce);
              const ke = new h.Dict(I);
              ke.set("Length", W.length), ke.set("Subtype", h.Name.get("Form")), ke.set("Resources", this._getSaveFieldResources(I)), ke.set("BBox", ie);
              const ye = this.getRotationMatrix(E);
              ye !== t.IDENTITY_MATRIX && ke.set("Matrix", ye);
              const De = [`${this.ref.num} ${this.ref.gen} obj
`];
              (0, e.writeDict)(H, De, xe), De.push(`
endobj
`);
              const Ae = [`${fe.num} ${fe.gen} obj
`];
              return (0, e.writeDict)(ke, Ae, Fe), Ae.push(` stream
`, W, `
endstream
endobj
`), [{
                ref: this.ref,
                data: De.join(""),
                xfa: ue
              }, {
                ref: fe,
                data: Ae.join(""),
                xfa: null
              }];
            }
            async _getAppearance(N, Q, E) {
              if (this.hasFieldFlag(t.AnnotationFieldFlag.PASSWORD))
                return null;
              const oe = E ? E.get(this.data.id) : void 0;
              let ee, W;
              if (oe && (ee = oe.formattedValue || oe.value, W = oe.rotation), W === void 0 && ee === void 0 && (!this._hasValueFromXFA || this.appearance))
                return null;
              if (ee === void 0 && (ee = this.data.fieldValue, !ee) || (Array.isArray(ee) && ee.length === 1 && (ee = ee[0]), (0, t.assert)(typeof ee == "string", "Expected `value` to be a string."), ee = ee.trim(), ee === ""))
                return "";
              W === void 0 && (W = this.rotation);
              let I = -1;
              this.data.multiLine && (I = ee.split(/\r\n|\r|\n/).length);
              const H = 2, ie = H;
              let ue = this.data.rect[3] - this.data.rect[1], fe = this.data.rect[2] - this.data.rect[0];
              (W === 90 || W === 270) && ([fe, ue] = [ue, fe]), this._defaultAppearance || (this.data.defaultAppearanceData = (0, v.parseDefaultAppearance)(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
              const de = await X._getFontData(N, Q, this.data.defaultAppearanceData, this._fieldResources.mergedResources), [pe, xe] = this._computeFontSize(ue - H, fe - 2 * ie, ee, de, I);
              let Fe = de.descent;
              isNaN(Fe) && (Fe = 0);
              const Ce = Math.min(Math.floor((ue - xe) / 2), H) + Math.abs(Fe) * xe, ke = this.data.textAlignment;
              if (this.data.multiLine)
                return this._getMultilineAppearance(pe, ee, de, xe, fe, ue, ke, ie, Ce, E);
              const ye = de.encodeString(ee).join("");
              if (this.data.comb)
                return this._getCombAppearance(pe, de, ye, fe, ie, Ce, E);
              const De = this.getBorderAndBackgroundAppearances(E);
              if (ke === 0 || ke > 2)
                return `/Tx BMC q ${De}BT ` + pe + ` 1 0 0 1 ${ie} ${Ce} Tm (${(0, t.escapeString)(ye)}) Tj ET Q EMC`;
              const Ae = this._renderText(ye, de, xe, fe, ke, ie, Ce);
              return `/Tx BMC q ${De}BT ` + pe + ` 1 0 0 1 0 0 Tm ${Ae} ET Q EMC`;
            }
            static async _getFontData(N, Q, E, te) {
              const oe = new n.OperatorList(), ee = {
                font: null,
                clone() {
                  return this;
                }
              }, {
                fontName: W,
                fontSize: I
              } = E;
              return await N.handleSetFont(te, [W && h.Name.get(W), I], null, oe, Q, ee, null), ee.font;
            }
            _getTextWidth(N, Q) {
              return Q.charsToGlyphs(N).reduce((E, te) => E + te.width, 0) / 1e3;
            }
            _computeFontSize(N, Q, E, te, oe) {
              let {
                fontSize: ee
              } = this.data.defaultAppearanceData;
              if (!ee) {
                const W = (ie) => Math.floor(ie * 100) / 100;
                if (oe === -1) {
                  const ie = this._getTextWidth(E, te);
                  ee = W(Math.min(N / t.LINE_FACTOR, Q / ie));
                } else {
                  const ie = E.split(/\r\n?|\n/), ue = [];
                  for (const xe of ie) {
                    const Fe = te.encodeString(xe).join(""), Se = te.charsToGlyphs(Fe), Ce = te.getCharPositions(Fe);
                    ue.push({
                      line: Fe,
                      glyphs: Se,
                      positions: Ce
                    });
                  }
                  const fe = (xe) => {
                    let Fe = 0;
                    for (const Se of ue) {
                      const Ce = this._splitLine(null, te, xe, Q, Se);
                      if (Fe += Ce.length * xe, Fe > N)
                        return !0;
                    }
                    return !1;
                  };
                  ee = 12;
                  let de = ee * t.LINE_FACTOR, pe = Math.round(N / de);
                  for (pe = Math.max(pe, oe); ; ) {
                    if (de = N / pe, ee = W(de / t.LINE_FACTOR), fe(ee)) {
                      pe++;
                      continue;
                    }
                    break;
                  }
                }
                const {
                  fontName: I,
                  fontColor: H
                } = this.data.defaultAppearanceData;
                this._defaultAppearance = (0, v.createDefaultAppearance)({
                  fontSize: ee,
                  fontName: I,
                  fontColor: H
                });
              }
              return [this._defaultAppearance, ee];
            }
            _renderText(N, Q, E, te, oe, ee, W) {
              let I;
              if (oe === 1) {
                const H = this._getTextWidth(N, Q) * E;
                I = (te - H) / 2;
              } else if (oe === 2) {
                const H = this._getTextWidth(N, Q) * E;
                I = te - H - ee;
              } else
                I = ee;
              return I = (0, a.numberToString)(I), W = (0, a.numberToString)(W), `${I} ${W} Td (${(0, t.escapeString)(N)}) Tj`;
            }
            _getSaveFieldResources(N) {
              const {
                localResources: Q,
                appearanceResources: E,
                acroFormResources: te
              } = this._fieldResources, oe = this.data.defaultAppearanceData && this.data.defaultAppearanceData.fontName;
              if (!oe)
                return Q || h.Dict.empty;
              for (const ee of [Q, E])
                if (ee instanceof h.Dict) {
                  const W = ee.get("Font");
                  if (W instanceof h.Dict && W.has(oe))
                    return ee;
                }
              if (te instanceof h.Dict) {
                const ee = te.get("Font");
                if (ee instanceof h.Dict && ee.has(oe)) {
                  const W = new h.Dict(N);
                  W.set(oe, ee.getRaw(oe));
                  const I = new h.Dict(N);
                  return I.set("Font", W), h.Dict.merge({
                    xref: N,
                    dictArray: [I, Q],
                    mergeSubDicts: !0
                  });
                }
              }
              return Q || h.Dict.empty;
            }
            getFieldObject() {
              return null;
            }
          }
          class B extends X {
            constructor(N) {
              super(N), this._hasText = !0;
              const Q = N.dict;
              typeof this.data.fieldValue != "string" && (this.data.fieldValue = "");
              let E = (0, a.getInheritableProperty)({
                dict: Q,
                key: "Q"
              });
              (!Number.isInteger(E) || E < 0 || E > 2) && (E = null), this.data.textAlignment = E;
              let te = (0, a.getInheritableProperty)({
                dict: Q,
                key: "MaxLen"
              });
              (!Number.isInteger(te) || te < 0) && (te = 0), this.data.maxLen = te, this.data.multiLine = this.hasFieldFlag(t.AnnotationFieldFlag.MULTILINE), this.data.comb = this.hasFieldFlag(t.AnnotationFieldFlag.COMB) && !this.hasFieldFlag(t.AnnotationFieldFlag.MULTILINE) && !this.hasFieldFlag(t.AnnotationFieldFlag.PASSWORD) && !this.hasFieldFlag(t.AnnotationFieldFlag.FILESELECT) && this.data.maxLen !== 0, this.data.doNotScroll = this.hasFieldFlag(t.AnnotationFieldFlag.DONOTSCROLL);
            }
            _getCombAppearance(N, Q, E, te, oe, ee, W) {
              const I = (0, a.numberToString)(te / this.data.maxLen), H = [], ie = Q.getCharPositions(E);
              for (const [de, pe] of ie)
                H.push(`(${(0, t.escapeString)(E.substring(de, pe))}) Tj`);
              const ue = this.getBorderAndBackgroundAppearances(W), fe = H.join(` ${I} 0 Td `);
              return `/Tx BMC q ${ue}BT ` + N + ` 1 0 0 1 ${oe} ${ee} Tm ${fe} ET Q EMC`;
            }
            _getMultilineAppearance(N, Q, E, te, oe, ee, W, I, H, ie) {
              const ue = Q.split(/\r\n?|\n/), fe = [], de = oe - 2 * I;
              for (const Fe of ue) {
                const Se = this._splitLine(Fe, E, te, de);
                for (const Ce of Se) {
                  const ke = fe.length === 0 ? I : 0;
                  fe.push(this._renderText(Ce, E, te, oe, W, ke, -te));
                }
              }
              const pe = fe.join(`
`);
              return `/Tx BMC q ${this.getBorderAndBackgroundAppearances(ie)}BT ` + N + ` 1 0 0 1 0 ${ee} Tm ${pe} ET Q EMC`;
            }
            _splitLine(N, Q, E, te, oe = {}) {
              N = oe.line || Q.encodeString(N).join("");
              const ee = oe.glyphs || Q.charsToGlyphs(N);
              if (ee.length <= 1)
                return [N];
              const W = oe.positions || Q.getCharPositions(N), I = E / 1e3, H = [];
              let ie = -1, ue = -1, fe = -1, de = 0, pe = 0;
              for (let xe = 0, Fe = ee.length; xe < Fe; xe++) {
                const [Se, Ce] = W[xe], ke = ee[xe], ye = ke.width * I;
                ke.unicode === " " ? pe + ye > te ? (H.push(N.substring(de, Se)), de = Se, pe = ye, ie = -1, fe = -1) : (pe += ye, ie = Se, ue = Ce, fe = xe) : pe + ye > te ? ie !== -1 ? (H.push(N.substring(de, ue)), de = ue, xe = fe + 1, ie = -1, pe = 0) : (H.push(N.substring(de, Se)), de = Se, pe = ye) : pe += ye;
              }
              return de < N.length && H.push(N.substring(de, N.length)), H;
            }
            getFieldObject() {
              return {
                id: this.data.id,
                value: this.data.fieldValue,
                defaultValue: this.data.defaultFieldValue || "",
                multiline: this.data.multiLine,
                password: this.hasFieldFlag(t.AnnotationFieldFlag.PASSWORD),
                charLimit: this.data.maxLen,
                comb: this.data.comb,
                editable: !this.data.readOnly,
                hidden: this.data.hidden,
                name: this.data.fieldName,
                rect: this.data.rect,
                actions: this.data.actions,
                page: this.data.pageIndex,
                strokeColor: this.data.borderColor,
                fillColor: this.data.backgroundColor,
                rotation: this.rotation,
                type: "text"
              };
            }
          }
          class U extends X {
            constructor(N) {
              super(N), this.checkedAppearance = null, this.uncheckedAppearance = null, this.data.checkBox = !this.hasFieldFlag(t.AnnotationFieldFlag.RADIO) && !this.hasFieldFlag(t.AnnotationFieldFlag.PUSHBUTTON), this.data.radioButton = this.hasFieldFlag(t.AnnotationFieldFlag.RADIO) && !this.hasFieldFlag(t.AnnotationFieldFlag.PUSHBUTTON), this.data.pushButton = this.hasFieldFlag(t.AnnotationFieldFlag.PUSHBUTTON), this.data.isTooltipOnly = !1, this.data.checkBox ? this._processCheckBox(N) : this.data.radioButton ? this._processRadioButton(N) : this.data.pushButton ? (this.data.hasOwnCanvas = !0, this._processPushButton(N)) : (0, t.warn)("Invalid field flags for button widget annotation");
            }
            async getOperatorList(N, Q, E, te, oe) {
              if (this.data.pushButton)
                return super.getOperatorList(N, Q, E, !1, oe);
              let ee = null, W = null;
              if (oe) {
                const H = oe.get(this.data.id);
                ee = H ? H.value : null, W = H ? H.rotation : null;
              }
              if (ee === null && this.appearance)
                return super.getOperatorList(N, Q, E, te, oe);
              ee == null && (this.data.checkBox ? ee = this.data.fieldValue === this.data.exportValue : ee = this.data.fieldValue === this.data.buttonValue);
              const I = ee ? this.checkedAppearance : this.uncheckedAppearance;
              if (I) {
                const H = this.appearance, ie = I.dict.getArray("Matrix") || t.IDENTITY_MATRIX;
                W && I.dict.set("Matrix", this.getRotationMatrix(oe)), this.appearance = I;
                const ue = super.getOperatorList(N, Q, E, te, oe);
                return this.appearance = H, I.dict.set("Matrix", ie), ue;
              }
              return {
                opList: new n.OperatorList(),
                separateForm: !1,
                separateCanvas: !1
              };
            }
            async save(N, Q, E) {
              return this.data.checkBox ? this._saveCheckbox(N, Q, E) : this.data.radioButton ? this._saveRadioButton(N, Q, E) : null;
            }
            async _saveCheckbox(N, Q, E) {
              if (!E)
                return null;
              const te = E.get(this.data.id);
              let oe = te && te.rotation, ee = te && te.value;
              if (oe === void 0 && (ee === void 0 || this.data.fieldValue === this.data.exportValue === ee))
                return null;
              const W = N.xref.fetchIfRef(this.ref);
              if (!(W instanceof h.Dict))
                return null;
              oe === void 0 && (oe = this.rotation), ee === void 0 && (ee = this.data.fieldValue === this.data.exportValue);
              const I = {
                path: (0, t.stringToPDFString)(W.get("T") || ""),
                value: ee ? this.data.exportValue : ""
              }, H = h.Name.get(ee ? this.data.exportValue : "Off");
              W.set("V", H), W.set("AS", H), W.set("M", `D:${(0, t.getModificationDate)()}`);
              const ie = this._getMKDict(oe);
              ie && W.set("MK", ie);
              const ue = N.xref.encrypt;
              let fe = null;
              ue && (fe = ue.createCipherTransform(this.ref.num, this.ref.gen));
              const de = [`${this.ref.num} ${this.ref.gen} obj
`];
              return (0, e.writeDict)(W, de, fe), de.push(`
endobj
`), [{
                ref: this.ref,
                data: de.join(""),
                xfa: I
              }];
            }
            async _saveRadioButton(N, Q, E) {
              if (!E)
                return null;
              const te = E.get(this.data.id);
              let oe = te && te.rotation, ee = te && te.value;
              if (oe === void 0 && (ee === void 0 || this.data.fieldValue === this.data.buttonValue === ee))
                return null;
              const W = N.xref.fetchIfRef(this.ref);
              if (!(W instanceof h.Dict))
                return null;
              ee === void 0 && (ee = this.data.fieldValue === this.data.buttonValue), oe === void 0 && (oe = this.rotation);
              const I = {
                path: (0, t.stringToPDFString)(W.get("T") || ""),
                value: ee ? this.data.buttonValue : ""
              }, H = h.Name.get(ee ? this.data.buttonValue : "Off");
              let ie = null;
              const ue = N.xref.encrypt;
              if (ee)
                if (this.parent instanceof h.Ref) {
                  const Fe = N.xref.fetch(this.parent);
                  let Se = null;
                  ue && (Se = ue.createCipherTransform(this.parent.num, this.parent.gen)), Fe.set("V", H), ie = [`${this.parent.num} ${this.parent.gen} obj
`], (0, e.writeDict)(Fe, ie, Se), ie.push(`
endobj
`);
                } else
                  this.parent instanceof h.Dict && this.parent.set("V", H);
              W.set("AS", H), W.set("M", `D:${(0, t.getModificationDate)()}`);
              const fe = this._getMKDict(oe);
              fe && W.set("MK", fe);
              let de = null;
              ue && (de = ue.createCipherTransform(this.ref.num, this.ref.gen));
              const pe = [`${this.ref.num} ${this.ref.gen} obj
`];
              (0, e.writeDict)(W, pe, de), pe.push(`
endobj
`);
              const xe = [{
                ref: this.ref,
                data: pe.join(""),
                xfa: I
              }];
              return ie !== null && xe.push({
                ref: this.parent,
                data: ie.join(""),
                xfa: null
              }), xe;
            }
            _getDefaultCheckedAppearance(N, Q) {
              const E = this.data.rect[2] - this.data.rect[0], te = this.data.rect[3] - this.data.rect[1], oe = [0, 0, E, te], ee = 0.8, W = Math.min(E, te) * ee;
              let I, H;
              Q === "check" ? (I = {
                width: 0.755 * W,
                height: 0.705 * W
              }, H = "3") : Q === "disc" ? (I = {
                width: 0.791 * W,
                height: 0.705 * W
              }, H = "l") : (0, t.unreachable)(`_getDefaultCheckedAppearance - unsupported type: ${Q}`);
              const ie = (0, a.numberToString)((E - I.width) / 2), ue = (0, a.numberToString)((te - I.height) / 2), fe = `q BT /PdfJsZaDb ${W} Tf 0 g ${ie} ${ue} Td (${H}) Tj ET Q`, de = new h.Dict(N.xref);
              de.set("FormType", 1), de.set("Subtype", h.Name.get("Form")), de.set("Type", h.Name.get("XObject")), de.set("BBox", oe), de.set("Matrix", [1, 0, 0, 1, 0, 0]), de.set("Length", fe.length);
              const pe = new h.Dict(N.xref), xe = new h.Dict(N.xref);
              xe.set("PdfJsZaDb", this.fallbackFontDict), pe.set("Font", xe), de.set("Resources", pe), this.checkedAppearance = new i.StringStream(fe), this.checkedAppearance.dict = de, this._streams.push(this.checkedAppearance);
            }
            _processCheckBox(N) {
              const Q = N.dict.get("AP");
              if (!(Q instanceof h.Dict))
                return;
              const E = Q.get("N");
              if (!(E instanceof h.Dict))
                return;
              const te = this._decodeFormValue(N.dict.get("AS"));
              typeof te == "string" && (this.data.fieldValue = te);
              const oe = this.data.fieldValue !== null && this.data.fieldValue !== "Off" ? this.data.fieldValue : "Yes", ee = E.getKeys();
              if (ee.length === 0)
                ee.push("Off", oe);
              else if (ee.length === 1)
                ee[0] === "Off" ? ee.push(oe) : ee.unshift("Off");
              else if (ee.includes(oe))
                ee.length = 0, ee.push("Off", oe);
              else {
                const W = ee.find((I) => I !== "Off");
                ee.length = 0, ee.push("Off", W);
              }
              ee.includes(this.data.fieldValue) || (this.data.fieldValue = "Off"), this.data.exportValue = ee[1], this.checkedAppearance = E.get(this.data.exportValue) || null, this.uncheckedAppearance = E.get("Off") || null, this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(N, "check"), this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance), this._fallbackFontDict = this.fallbackFontDict;
            }
            _processRadioButton(N) {
              this.data.fieldValue = this.data.buttonValue = null;
              const Q = N.dict.get("Parent");
              if (Q instanceof h.Dict) {
                this.parent = N.dict.getRaw("Parent");
                const oe = Q.get("V");
                oe instanceof h.Name && (this.data.fieldValue = this._decodeFormValue(oe));
              }
              const E = N.dict.get("AP");
              if (!(E instanceof h.Dict))
                return;
              const te = E.get("N");
              if (te instanceof h.Dict) {
                for (const oe of te.getKeys())
                  if (oe !== "Off") {
                    this.data.buttonValue = this._decodeFormValue(oe);
                    break;
                  }
                this.checkedAppearance = te.get(this.data.buttonValue) || null, this.uncheckedAppearance = te.get("Off") || null, this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(N, "disc"), this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance), this._fallbackFontDict = this.fallbackFontDict;
              }
            }
            _processPushButton(N) {
              if (!N.dict.has("A") && !N.dict.has("AA") && !this.data.alternativeText) {
                (0, t.warn)("Push buttons without action dictionaries are not supported");
                return;
              }
              this.data.isTooltipOnly = !N.dict.has("A") && !N.dict.has("AA"), d.Catalog.parseDestDictionary({
                destDict: N.dict,
                resultObj: this.data,
                docBaseUrl: N.pdfManager.docBaseUrl
              });
            }
            getFieldObject() {
              let N = "button", Q;
              return this.data.checkBox ? (N = "checkbox", Q = this.data.exportValue) : this.data.radioButton && (N = "radiobutton", Q = this.data.buttonValue), {
                id: this.data.id,
                value: this.data.fieldValue || "Off",
                defaultValue: this.data.defaultFieldValue,
                exportValues: Q,
                editable: !this.data.readOnly,
                name: this.data.fieldName,
                rect: this.data.rect,
                hidden: this.data.hidden,
                actions: this.data.actions,
                page: this.data.pageIndex,
                strokeColor: this.data.borderColor,
                fillColor: this.data.backgroundColor,
                rotation: this.rotation,
                type: N
              };
            }
            get fallbackFontDict() {
              const N = new h.Dict();
              return N.set("BaseFont", h.Name.get("ZapfDingbats")), N.set("Type", h.Name.get("FallbackType")), N.set("Subtype", h.Name.get("FallbackType")), N.set("Encoding", h.Name.get("ZapfDingbatsEncoding")), (0, t.shadow)(this, "fallbackFontDict", N);
            }
          }
          class k extends X {
            constructor(N) {
              super(N), this.data.options = [];
              const Q = (0, a.getInheritableProperty)({
                dict: N.dict,
                key: "Opt"
              });
              if (Array.isArray(Q)) {
                const E = N.xref;
                for (let te = 0, oe = Q.length; te < oe; te++) {
                  const ee = E.fetchIfRef(Q[te]), W = Array.isArray(ee);
                  this.data.options[te] = {
                    exportValue: this._decodeFormValue(W ? E.fetchIfRef(ee[0]) : ee),
                    displayValue: this._decodeFormValue(W ? E.fetchIfRef(ee[1]) : ee)
                  };
                }
              }
              typeof this.data.fieldValue == "string" ? this.data.fieldValue = [this.data.fieldValue] : this.data.fieldValue || (this.data.fieldValue = []), this.data.combo = this.hasFieldFlag(t.AnnotationFieldFlag.COMBO), this.data.multiSelect = this.hasFieldFlag(t.AnnotationFieldFlag.MULTISELECT), this._hasText = !0;
            }
            getFieldObject() {
              const N = this.data.combo ? "combobox" : "listbox", Q = this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
              return {
                id: this.data.id,
                value: Q,
                defaultValue: this.data.defaultFieldValue,
                editable: !this.data.readOnly,
                name: this.data.fieldName,
                rect: this.data.rect,
                numItems: this.data.fieldValue.length,
                multipleSelection: this.data.multiSelect,
                hidden: this.data.hidden,
                actions: this.data.actions,
                items: this.data.options,
                page: this.data.pageIndex,
                strokeColor: this.data.borderColor,
                fillColor: this.data.backgroundColor,
                rotation: this.rotation,
                type: N
              };
            }
            async _getAppearance(N, Q, E) {
              if (this.data.combo)
                return super._getAppearance(N, Q, E);
              if (!E)
                return null;
              const te = E.get(this.data.id);
              if (!te)
                return null;
              const oe = te.rotation;
              let ee = te.value;
              if (oe === void 0 && ee === void 0)
                return null;
              ee === void 0 ? ee = this.data.fieldValue : Array.isArray(ee) || (ee = [ee]);
              const W = 2, I = W;
              let H = this.data.rect[3] - this.data.rect[1], ie = this.data.rect[2] - this.data.rect[0];
              (oe === 90 || oe === 270) && ([ie, H] = [H, ie]);
              const ue = this.data.options.length, fe = [];
              for (let Ae = 0; Ae < ue; Ae++) {
                const {
                  exportValue: Te
                } = this.data.options[Ae];
                ee.includes(Te) && fe.push(Ae);
              }
              this._defaultAppearance || (this.data.defaultAppearanceData = (0, v.parseDefaultAppearance)(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
              const de = await X._getFontData(N, Q, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
              let pe, {
                fontSize: xe
              } = this.data.defaultAppearanceData;
              if (xe)
                pe = this._defaultAppearance;
              else {
                const Ae = (H - W) / ue;
                let Te = -1, ve;
                for (const {
                  displayValue: Ne
                } of this.data.options) {
                  const Ge = this._getTextWidth(Ne, de);
                  Ge > Te && (Te = Ge, ve = Ne);
                }
                [pe, xe] = this._computeFontSize(Ae, ie - 2 * I, ve, de, -1);
              }
              const Fe = xe * t.LINE_FACTOR, Se = (Fe - xe) / 2, Ce = Math.floor(H / Fe);
              let ke;
              if (fe.length === 1) {
                const Ae = fe[0], Te = Ae % Ce;
                ke = Ae - Te;
              } else
                ke = fe.length ? fe[0] : 0;
              const ye = Math.min(ke + Ce + 1, ue), De = ["/Tx BMC q", `1 1 ${ie} ${H} re W n`];
              if (fe.length) {
                De.push("0.600006 0.756866 0.854904 rg");
                for (const Ae of fe)
                  ke <= Ae && Ae < ye && De.push(`1 ${H - (Ae - ke + 1) * Fe} ${ie} ${Fe} re f`);
              }
              De.push("BT", pe, `1 0 0 1 0 ${H} Tm`);
              for (let Ae = ke; Ae < ye; Ae++) {
                const {
                  displayValue: Te
                } = this.data.options[Ae], ve = Ae === ke ? I : 0, Ne = Ae === ke ? Se : 0;
                De.push(this._renderText(Te, de, xe, ie, 0, ve, -Fe + Ne));
              }
              return De.push("ET Q EMC"), De.join(`
`);
            }
          }
          class x extends X {
            constructor(N) {
              super(N), this.data.fieldValue = null;
            }
            getFieldObject() {
              return {
                id: this.data.id,
                value: null,
                page: this.data.pageIndex,
                type: "signature"
              };
            }
          }
          class f extends j {
            constructor(N) {
              super(N);
              const E = N.dict;
              this.data.annotationType = t.AnnotationType.TEXT, this.data.hasAppearance ? this.data.name = "NoIcon" : (this.data.rect[1] = this.data.rect[3] - 22, this.data.rect[2] = this.data.rect[0] + 22, this.data.name = E.has("Name") ? E.get("Name").name : "Note"), E.has("State") ? (this.data.state = E.get("State") || null, this.data.stateModel = E.get("StateModel") || null) : (this.data.state = null, this.data.stateModel = null);
            }
          }
          class D extends A {
            constructor(N) {
              super(N), this.data.annotationType = t.AnnotationType.LINK;
              const Q = O(N.dict, this.rectangle);
              Q && (this.data.quadPoints = Q), this.data.borderColor = this.data.borderColor || this.data.color, d.Catalog.parseDestDictionary({
                destDict: N.dict,
                resultObj: this.data,
                docBaseUrl: N.pdfManager.docBaseUrl
              });
            }
          }
          class _ extends A {
            constructor(N) {
              super(N), this.data.annotationType = t.AnnotationType.POPUP;
              let Q = N.dict.get("Parent");
              if (!Q) {
                (0, t.warn)("Popup annotation has a missing or invalid parent annotation.");
                return;
              }
              const E = Q.get("Subtype");
              this.data.parentType = E instanceof h.Name ? E.name : null;
              const te = N.dict.getRaw("Parent");
              this.data.parentId = te instanceof h.Ref ? te.toString() : null;
              const oe = Q.getArray("Rect");
              Array.isArray(oe) && oe.length === 4 ? this.data.parentRect = t.Util.normalizeRect(oe) : this.data.parentRect = [0, 0, 0, 0];
              const ee = Q.get("RT");
              if ((0, h.isName)(ee, t.AnnotationReplyType.GROUP) && (Q = Q.get("IRT")), Q.has("M") ? (this.setModificationDate(Q.get("M")), this.data.modificationDate = this.modificationDate) : this.data.modificationDate = null, Q.has("C") ? (this.setColor(Q.getArray("C")), this.data.color = this.color) : this.data.color = null, !this.viewable) {
                const W = Q.get("F");
                this._isViewable(W) && this.setFlags(W);
              }
              this.setTitle(Q.get("T")), this.data.titleObj = this._title, this.setContents(Q.get("Contents")), this.data.contentsObj = this._contents, Q.has("RC") && (this.data.richText = l.XFAFactory.getRichTextAsHtml(Q.get("RC")));
            }
          }
          o.PopupAnnotation = _;
          class S extends j {
            constructor(N) {
              super(N), this.data.annotationType = t.AnnotationType.FREETEXT;
            }
            get hasTextContent() {
              return !!this.appearance;
            }
            static createNewDict(N, Q, {
              apRef: E,
              ap: te
            }) {
              const {
                color: oe,
                fontSize: ee,
                rect: W,
                rotation: I,
                user: H,
                value: ie
              } = N, ue = new h.Dict(Q);
              ue.set("Type", h.Name.get("Annot")), ue.set("Subtype", h.Name.get("FreeText")), ue.set("CreationDate", `D:${(0, t.getModificationDate)()}`), ue.set("Rect", W);
              const fe = `/Helv ${ee} Tf ${(0, v.getPdfColor)(oe, !0)}`;
              ue.set("DA", fe), ue.set("Contents", ie), ue.set("F", 4), ue.set("Border", [0, 0, 0]), ue.set("Rotate", I), H && ue.set("T", (0, t.stringToUTF8String)(H));
              const de = new h.Dict(Q);
              return ue.set("AP", de), E ? de.set("N", E) : de.set("N", te), ue;
            }
            static async createNewAppearanceStream(N, Q, E) {
              const {
                baseFontRef: te,
                evaluator: oe,
                task: ee
              } = E, {
                color: W,
                fontSize: I,
                rect: H,
                rotation: ie,
                value: ue
              } = N, fe = new h.Dict(Q), de = new h.Dict(Q);
              if (te)
                de.set("Helv", te);
              else {
                const _t = new h.Dict(Q);
                _t.set("BaseFont", h.Name.get("Helvetica")), _t.set("Type", h.Name.get("Font")), _t.set("Subtype", h.Name.get("Type1")), _t.set("Encoding", h.Name.get("WinAnsiEncoding")), de.set("Helv", _t);
              }
              fe.set("Font", de);
              const pe = await X._getFontData(oe, ee, {
                fontName: "Helvetica",
                fontSize: I
              }, fe), [xe, Fe, Se, Ce] = H;
              let ke = Se - xe, ye = Ce - Fe;
              ie % 180 !== 0 && ([ke, ye] = [ye, ke]);
              const De = ue.split(`
`), Ae = I / 1e3;
              let Te = -1 / 0;
              const ve = [];
              for (let _t of De) {
                _t = pe.encodeString(_t).join(""), ve.push(_t);
                let Xe = 0;
                const Ct = pe.charsToGlyphs(_t);
                for (const bt of Ct)
                  Xe += bt.width * Ae;
                Te = Math.max(Te, Xe);
              }
              let Ne = 1;
              Te > ke && (Ne = ke / Te);
              let Ge = 1;
              const it = t.LINE_FACTOR * I, Me = t.LINE_DESCENT_FACTOR * I, Ie = it * De.length;
              Ie > ye && (Ge = ye / Ie);
              const Ee = Math.min(Ne, Ge), st = I * Ee, Qe = ["q", `0 0 ${(0, a.numberToString)(ke)} ${(0, a.numberToString)(ye)} re W n`, "BT", `1 0 0 1 0 ${(0, a.numberToString)(ye + Me)} Tm 0 Tc ${(0, v.getPdfColor)(W, !0)}`, `/Helv ${(0, a.numberToString)(st)} Tf`], ct = (0, a.numberToString)(it);
              for (const _t of ve)
                Qe.push(`0 -${ct} Td (${(0, t.escapeString)(_t)}) Tj`);
              Qe.push("ET", "Q");
              const xt = Qe.join(`
`), Je = new h.Dict(Q);
              if (Je.set("FormType", 1), Je.set("Subtype", h.Name.get("Form")), Je.set("Type", h.Name.get("XObject")), Je.set("BBox", [0, 0, ke, ye]), Je.set("Length", xt.length), Je.set("Resources", fe), ie) {
                const _t = X._getRotationMatrix(ie, ke, ye);
                Je.set("Matrix", _t);
              }
              const mt = new i.StringStream(xt);
              return mt.dict = Je, mt;
            }
          }
          class C extends j {
            constructor(N) {
              super(N);
              const {
                dict: Q
              } = N;
              this.data.annotationType = t.AnnotationType.LINE;
              const E = Q.getArray("L");
              if (this.data.lineCoordinates = t.Util.normalizeRect(E), this.setLineEndings(Q.getArray("LE")), this.data.lineEndings = this.lineEndings, !this.appearance) {
                const te = this.color ? Array.from(this.color).map((fe) => fe / 255) : [0, 0, 0], oe = Q.get("CA");
                let ee = null, W = Q.getArray("IC");
                W && (W = w(W, null), ee = W ? Array.from(W).map((fe) => fe / 255) : null);
                const I = ee ? oe : null, H = this.borderStyle.width || 1, ie = 2 * H, ue = [this.data.lineCoordinates[0] - ie, this.data.lineCoordinates[1] - ie, this.data.lineCoordinates[2] + ie, this.data.lineCoordinates[3] + ie];
                t.Util.intersect(this.rectangle, ue) || (this.rectangle = ue), this._setDefaultAppearance({
                  xref: N.xref,
                  extra: `${H} w`,
                  strokeColor: te,
                  fillColor: ee,
                  strokeAlpha: oe,
                  fillAlpha: I,
                  pointsCallback: (fe, de) => (fe.push(`${E[0]} ${E[1]} m`, `${E[2]} ${E[3]} l`, "S"), [de[0].x - H, de[1].x + H, de[3].y - H, de[1].y + H])
                });
              }
            }
          }
          class T extends j {
            constructor(N) {
              if (super(N), this.data.annotationType = t.AnnotationType.SQUARE, !this.appearance) {
                const Q = this.color ? Array.from(this.color).map((W) => W / 255) : [0, 0, 0], E = N.dict.get("CA");
                let te = null, oe = N.dict.getArray("IC");
                oe && (oe = w(oe, null), te = oe ? Array.from(oe).map((W) => W / 255) : null);
                const ee = te ? E : null;
                if (this.borderStyle.width === 0 && !te)
                  return;
                this._setDefaultAppearance({
                  xref: N.xref,
                  extra: `${this.borderStyle.width} w`,
                  strokeColor: Q,
                  fillColor: te,
                  strokeAlpha: E,
                  fillAlpha: ee,
                  pointsCallback: (W, I) => {
                    const H = I[2].x + this.borderStyle.width / 2, ie = I[2].y + this.borderStyle.width / 2, ue = I[3].x - I[2].x - this.borderStyle.width, fe = I[1].y - I[3].y - this.borderStyle.width;
                    return W.push(`${H} ${ie} ${ue} ${fe} re`), te ? W.push("B") : W.push("S"), [I[0].x, I[1].x, I[3].y, I[1].y];
                  }
                });
              }
            }
          }
          class P extends j {
            constructor(N) {
              if (super(N), this.data.annotationType = t.AnnotationType.CIRCLE, !this.appearance) {
                const Q = this.color ? Array.from(this.color).map((I) => I / 255) : [0, 0, 0], E = N.dict.get("CA");
                let te = null, oe = N.dict.getArray("IC");
                oe && (oe = w(oe, null), te = oe ? Array.from(oe).map((I) => I / 255) : null);
                const ee = te ? E : null;
                if (this.borderStyle.width === 0 && !te)
                  return;
                const W = 4 / 3 * Math.tan(Math.PI / (2 * 4));
                this._setDefaultAppearance({
                  xref: N.xref,
                  extra: `${this.borderStyle.width} w`,
                  strokeColor: Q,
                  fillColor: te,
                  strokeAlpha: E,
                  fillAlpha: ee,
                  pointsCallback: (I, H) => {
                    const ie = H[0].x + this.borderStyle.width / 2, ue = H[0].y - this.borderStyle.width / 2, fe = H[3].x - this.borderStyle.width / 2, de = H[3].y + this.borderStyle.width / 2, pe = ie + (fe - ie) / 2, xe = ue + (de - ue) / 2, Fe = (fe - ie) / 2 * W, Se = (de - ue) / 2 * W;
                    return I.push(`${pe} ${de} m`, `${pe + Fe} ${de} ${fe} ${xe + Se} ${fe} ${xe} c`, `${fe} ${xe - Se} ${pe + Fe} ${ue} ${pe} ${ue} c`, `${pe - Fe} ${ue} ${ie} ${xe - Se} ${ie} ${xe} c`, `${ie} ${xe + Se} ${pe - Fe} ${de} ${pe} ${de} c`, "h"), te ? I.push("B") : I.push("S"), [H[0].x, H[1].x, H[3].y, H[1].y];
                  }
                });
              }
            }
          }
          class M extends j {
            constructor(N) {
              super(N);
              const {
                dict: Q
              } = N;
              this.data.annotationType = t.AnnotationType.POLYLINE, this.data.vertices = [], this instanceof G || (this.setLineEndings(Q.getArray("LE")), this.data.lineEndings = this.lineEndings);
              const E = Q.getArray("Vertices");
              if (Array.isArray(E)) {
                for (let te = 0, oe = E.length; te < oe; te += 2)
                  this.data.vertices.push({
                    x: E[te],
                    y: E[te + 1]
                  });
                if (!this.appearance) {
                  const te = this.color ? Array.from(this.color).map((H) => H / 255) : [0, 0, 0], oe = Q.get("CA"), ee = this.borderStyle.width || 1, W = 2 * ee, I = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                  for (const H of this.data.vertices)
                    I[0] = Math.min(I[0], H.x - W), I[1] = Math.min(I[1], H.y - W), I[2] = Math.max(I[2], H.x + W), I[3] = Math.max(I[3], H.y + W);
                  t.Util.intersect(this.rectangle, I) || (this.rectangle = I), this._setDefaultAppearance({
                    xref: N.xref,
                    extra: `${ee} w`,
                    strokeColor: te,
                    strokeAlpha: oe,
                    pointsCallback: (H, ie) => {
                      const ue = this.data.vertices;
                      for (let fe = 0, de = ue.length; fe < de; fe++)
                        H.push(`${ue[fe].x} ${ue[fe].y} ${fe === 0 ? "m" : "l"}`);
                      return H.push("S"), [ie[0].x, ie[1].x, ie[3].y, ie[1].y];
                    }
                  });
                }
              }
            }
          }
          class G extends M {
            constructor(N) {
              super(N), this.data.annotationType = t.AnnotationType.POLYGON;
            }
          }
          class Z extends j {
            constructor(N) {
              super(N), this.data.annotationType = t.AnnotationType.CARET;
            }
          }
          class $ extends j {
            constructor(N) {
              super(N), this.data.annotationType = t.AnnotationType.INK, this.data.inkLists = [];
              const Q = N.dict.getArray("InkList");
              if (!Array.isArray(Q))
                return;
              const E = N.xref;
              for (let te = 0, oe = Q.length; te < oe; ++te) {
                this.data.inkLists.push([]);
                for (let ee = 0, W = Q[te].length; ee < W; ee += 2)
                  this.data.inkLists[te].push({
                    x: E.fetchIfRef(Q[te][ee]),
                    y: E.fetchIfRef(Q[te][ee + 1])
                  });
              }
              if (!this.appearance) {
                const te = this.color ? Array.from(this.color).map((H) => H / 255) : [0, 0, 0], oe = N.dict.get("CA"), ee = this.borderStyle.width || 1, W = 2 * ee, I = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                for (const H of this.data.inkLists)
                  for (const ie of H)
                    I[0] = Math.min(I[0], ie.x - W), I[1] = Math.min(I[1], ie.y - W), I[2] = Math.max(I[2], ie.x + W), I[3] = Math.max(I[3], ie.y + W);
                t.Util.intersect(this.rectangle, I) || (this.rectangle = I), this._setDefaultAppearance({
                  xref: N.xref,
                  extra: `${ee} w`,
                  strokeColor: te,
                  strokeAlpha: oe,
                  pointsCallback: (H, ie) => {
                    for (const ue of this.data.inkLists) {
                      for (let fe = 0, de = ue.length; fe < de; fe++)
                        H.push(`${ue[fe].x} ${ue[fe].y} ${fe === 0 ? "m" : "l"}`);
                      H.push("S");
                    }
                    return [ie[0].x, ie[1].x, ie[3].y, ie[1].y];
                  }
                });
              }
            }
            static createNewDict(N, Q, {
              apRef: E,
              ap: te
            }) {
              const {
                paths: oe,
                rect: ee,
                rotation: W
              } = N, I = new h.Dict(Q);
              I.set("Type", h.Name.get("Annot")), I.set("Subtype", h.Name.get("Ink")), I.set("CreationDate", `D:${(0, t.getModificationDate)()}`), I.set("Rect", ee), I.set("InkList", oe.map((ie) => ie.points)), I.set("F", 4), I.set("Border", [0, 0, 0]), I.set("Rotate", W);
              const H = new h.Dict(Q);
              return I.set("AP", H), E ? H.set("N", E) : H.set("N", te), I;
            }
            static async createNewAppearanceStream(N, Q, E) {
              const {
                color: te,
                rect: oe,
                rotation: ee,
                paths: W,
                thickness: I,
                opacity: H
              } = N, [ie, ue, fe, de] = oe;
              let pe = fe - ie, xe = de - ue;
              ee % 180 !== 0 && ([pe, xe] = [xe, pe]);
              const Fe = [`${I} w 1 J 1 j`, `${(0, v.getPdfColor)(te, !1)}`];
              H !== 1 && Fe.push("/R0 gs");
              const Se = [];
              for (const {
                bezier: De
              } of W) {
                Se.length = 0, Se.push(`${(0, a.numberToString)(De[0])} ${(0, a.numberToString)(De[1])} m`);
                for (let Ae = 2, Te = De.length; Ae < Te; Ae += 6) {
                  const ve = De.slice(Ae, Ae + 6).map(a.numberToString).join(" ");
                  Se.push(`${ve} c`);
                }
                Se.push("S"), Fe.push(Se.join(`
`));
              }
              const Ce = Fe.join(`
`), ke = new h.Dict(Q);
              if (ke.set("FormType", 1), ke.set("Subtype", h.Name.get("Form")), ke.set("Type", h.Name.get("XObject")), ke.set("BBox", [0, 0, pe, xe]), ke.set("Length", Ce.length), ee) {
                const De = X._getRotationMatrix(ee, pe, xe);
                ke.set("Matrix", De);
              }
              if (H !== 1) {
                const De = new h.Dict(Q), Ae = new h.Dict(Q), Te = new h.Dict(Q);
                Te.set("CA", H), Te.set("Type", h.Name.get("ExtGState")), Ae.set("R0", Te), De.set("ExtGState", Ae), ke.set("Resources", De);
              }
              const ye = new i.StringStream(Ce);
              return ye.dict = ke, ye;
            }
          }
          class z extends j {
            constructor(N) {
              if (super(N), this.data.annotationType = t.AnnotationType.HIGHLIGHT, this.data.quadPoints = O(N.dict, null)) {
                const E = this.appearance && this.appearance.dict.get("Resources");
                if (!this.appearance || !(E && E.has("ExtGState"))) {
                  this.appearance && (0, t.warn)("HighlightAnnotation - ignoring built-in appearance stream.");
                  const te = this.color ? Array.from(this.color).map((ee) => ee / 255) : [1, 1, 0], oe = N.dict.get("CA");
                  this._setDefaultAppearance({
                    xref: N.xref,
                    fillColor: te,
                    blendMode: "Multiply",
                    fillAlpha: oe,
                    pointsCallback: (ee, W) => (ee.push(`${W[0].x} ${W[0].y} m`, `${W[1].x} ${W[1].y} l`, `${W[3].x} ${W[3].y} l`, `${W[2].x} ${W[2].y} l`, "f"), [W[0].x, W[1].x, W[3].y, W[1].y])
                  });
                }
              } else
                this.data.hasPopup = !1;
            }
          }
          class V extends j {
            constructor(N) {
              if (super(N), this.data.annotationType = t.AnnotationType.UNDERLINE, this.data.quadPoints = O(N.dict, null)) {
                if (!this.appearance) {
                  const E = this.color ? Array.from(this.color).map((oe) => oe / 255) : [0, 0, 0], te = N.dict.get("CA");
                  this._setDefaultAppearance({
                    xref: N.xref,
                    extra: "[] 0 d 1 w",
                    strokeColor: E,
                    strokeAlpha: te,
                    pointsCallback: (oe, ee) => (oe.push(`${ee[2].x} ${ee[2].y} m`, `${ee[3].x} ${ee[3].y} l`, "S"), [ee[0].x, ee[1].x, ee[3].y, ee[1].y])
                  });
                }
              } else
                this.data.hasPopup = !1;
            }
          }
          class L extends j {
            constructor(N) {
              if (super(N), this.data.annotationType = t.AnnotationType.SQUIGGLY, this.data.quadPoints = O(N.dict, null)) {
                if (!this.appearance) {
                  const E = this.color ? Array.from(this.color).map((oe) => oe / 255) : [0, 0, 0], te = N.dict.get("CA");
                  this._setDefaultAppearance({
                    xref: N.xref,
                    extra: "[] 0 d 1 w",
                    strokeColor: E,
                    strokeAlpha: te,
                    pointsCallback: (oe, ee) => {
                      const W = (ee[0].y - ee[2].y) / 6;
                      let I = W, H = ee[2].x;
                      const ie = ee[2].y, ue = ee[3].x;
                      oe.push(`${H} ${ie + I} m`);
                      do
                        H += 2, I = I === 0 ? W : 0, oe.push(`${H} ${ie + I} l`);
                      while (H < ue);
                      return oe.push("S"), [ee[2].x, ue, ie - 2 * W, ie + 2 * W];
                    }
                  });
                }
              } else
                this.data.hasPopup = !1;
            }
          }
          class K extends j {
            constructor(N) {
              if (super(N), this.data.annotationType = t.AnnotationType.STRIKEOUT, this.data.quadPoints = O(N.dict, null)) {
                if (!this.appearance) {
                  const E = this.color ? Array.from(this.color).map((oe) => oe / 255) : [0, 0, 0], te = N.dict.get("CA");
                  this._setDefaultAppearance({
                    xref: N.xref,
                    extra: "[] 0 d 1 w",
                    strokeColor: E,
                    strokeAlpha: te,
                    pointsCallback: (oe, ee) => (oe.push(`${(ee[0].x + ee[2].x) / 2} ${(ee[0].y + ee[2].y) / 2} m`, `${(ee[1].x + ee[3].x) / 2} ${(ee[1].y + ee[3].y) / 2} l`, "S"), [ee[0].x, ee[1].x, ee[3].y, ee[1].y])
                  });
                }
              } else
                this.data.hasPopup = !1;
            }
          }
          class ne extends j {
            constructor(N) {
              super(N), this.data.annotationType = t.AnnotationType.STAMP;
            }
          }
          class se extends j {
            constructor(N) {
              super(N);
              const Q = new p.FileSpec(N.dict.get("FS"), N.xref);
              this.data.annotationType = t.AnnotationType.FILEATTACHMENT, this.data.file = Q.serializable;
            }
          }
        },
        /* 13 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.createDefaultAppearance = p, o.getPdfColor = m, o.parseDefaultAppearance = d;
          var t = F(6), a = F(2), v = F(14), h = F(15), e = F(5), y = F(10);
          class c extends h.EvaluatorPreprocessor {
            constructor(n) {
              super(new y.StringStream(n));
            }
            parse() {
              const n = {
                fn: 0,
                args: []
              }, i = {
                fontSize: 0,
                fontName: "",
                fontColor: new Uint8ClampedArray(3)
              };
              try {
                for (; n.args.length = 0, !!this.read(n); ) {
                  if (this.savedStatesDepth !== 0)
                    continue;
                  const {
                    fn: l,
                    args: u
                  } = n;
                  switch (l | 0) {
                    case a.OPS.setFont:
                      const [w, O] = u;
                      w instanceof e.Name && (i.fontName = w.name), typeof O == "number" && O > 0 && (i.fontSize = O);
                      break;
                    case a.OPS.setFillRGBColor:
                      v.ColorSpace.singletons.rgb.getRgbItem(u, 0, i.fontColor, 0);
                      break;
                    case a.OPS.setFillGray:
                      v.ColorSpace.singletons.gray.getRgbItem(u, 0, i.fontColor, 0);
                      break;
                    case a.OPS.setFillColorSpace:
                      v.ColorSpace.singletons.cmyk.getRgbItem(u, 0, i.fontColor, 0);
                      break;
                  }
                }
              } catch (l) {
                (0, a.warn)(`parseDefaultAppearance - ignoring errors: "${l}".`);
              }
              return i;
            }
          }
          function d(g) {
            return new c(g).parse();
          }
          function m(g, n) {
            if (g[0] === g[1] && g[1] === g[2]) {
              const i = g[0] / 255;
              return `${(0, t.numberToString)(i)} ${n ? "g" : "G"}`;
            }
            return Array.from(g).map((i) => (0, t.numberToString)(i / 255)).join(" ") + ` ${n ? "rg" : "RG"}`;
          }
          function p({
            fontSize: g,
            fontName: n,
            fontColor: i
          }) {
            return `/${(0, t.escapePDFName)(n)} ${g} Tf ${m(i, !0)}`;
          }
        },
        /* 14 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.ColorSpace = void 0;
          var t = F(2), a = F(5), v = F(7), h = F(6);
          function e(w, O, b, A, Y, j, X) {
            X = X !== 1 ? 0 : X;
            const U = b / Y, k = A / j;
            let x = 0, f;
            const D = new Uint16Array(Y), _ = b * 3;
            for (let S = 0; S < Y; S++)
              D[S] = Math.floor(S * U) * 3;
            for (let S = 0; S < j; S++) {
              const C = Math.floor(S * k) * _;
              for (let T = 0; T < Y; T++)
                f = C + D[T], O[x++] = w[f++], O[x++] = w[f++], O[x++] = w[f++], x += X;
            }
          }
          class y {
            constructor(O, b) {
              this.constructor === y && (0, t.unreachable)("Cannot initialize ColorSpace."), this.name = O, this.numComps = b;
            }
            getRgb(O, b) {
              const A = new Uint8ClampedArray(3);
              return this.getRgbItem(O, b, A, 0), A;
            }
            getRgbItem(O, b, A, Y) {
              (0, t.unreachable)("Should not call ColorSpace.getRgbItem");
            }
            getRgbBuffer(O, b, A, Y, j, X, B) {
              (0, t.unreachable)("Should not call ColorSpace.getRgbBuffer");
            }
            getOutputLength(O, b) {
              (0, t.unreachable)("Should not call ColorSpace.getOutputLength");
            }
            isPassthrough(O) {
              return !1;
            }
            isDefaultDecode(O, b) {
              return y.isDefaultDecode(O, this.numComps);
            }
            fillRgb(O, b, A, Y, j, X, B, U, k) {
              const x = b * A;
              let f = null;
              const D = 1 << B, _ = A !== j || b !== Y;
              if (this.isPassthrough(B))
                f = U;
              else if (this.numComps === 1 && x > D && this.name !== "DeviceGray" && this.name !== "DeviceRGB") {
                const S = B <= 8 ? new Uint8Array(D) : new Uint16Array(D);
                for (let T = 0; T < D; T++)
                  S[T] = T;
                const C = new Uint8ClampedArray(D * 3);
                if (this.getRgbBuffer(S, 0, D, C, 0, B, 0), _) {
                  f = new Uint8Array(x * 3);
                  let T = 0;
                  for (let P = 0; P < x; ++P) {
                    const M = U[P] * 3;
                    f[T++] = C[M], f[T++] = C[M + 1], f[T++] = C[M + 2];
                  }
                } else {
                  let T = 0;
                  for (let P = 0; P < x; ++P) {
                    const M = U[P] * 3;
                    O[T++] = C[M], O[T++] = C[M + 1], O[T++] = C[M + 2], T += k;
                  }
                }
              } else
                _ ? (f = new Uint8ClampedArray(x * 3), this.getRgbBuffer(U, 0, x, f, 0, B, 0)) : this.getRgbBuffer(U, 0, Y * X, O, 0, B, k);
              if (f)
                if (_)
                  e(f, O, b, A, Y, j, k);
                else {
                  let S = 0, C = 0;
                  for (let T = 0, P = Y * X; T < P; T++)
                    O[S++] = f[C++], O[S++] = f[C++], O[S++] = f[C++], S += k;
                }
            }
            get usesZeroToOneRange() {
              return (0, t.shadow)(this, "usesZeroToOneRange", !0);
            }
            static _cache(O, b, A, Y) {
              if (!A)
                throw new Error('ColorSpace._cache - expected "localColorSpaceCache" argument.');
              if (!Y)
                throw new Error('ColorSpace._cache - expected "parsedColorSpace" argument.');
              let j, X;
              O instanceof a.Ref && (X = O, O = b.fetch(O)), O instanceof a.Name && (j = O.name), (j || X) && A.set(j, X, Y);
            }
            static getCached(O, b, A) {
              if (!A)
                throw new Error('ColorSpace.getCached - expected "localColorSpaceCache" argument.');
              if (O instanceof a.Ref) {
                const Y = A.getByRef(O);
                if (Y)
                  return Y;
                try {
                  O = b.fetch(O);
                } catch (j) {
                  if (j instanceof h.MissingDataException)
                    throw j;
                }
              }
              if (O instanceof a.Name) {
                const Y = A.getByName(O.name);
                if (Y)
                  return Y;
              }
              return null;
            }
            static async parseAsync({
              cs: O,
              xref: b,
              resources: A = null,
              pdfFunctionFactory: Y,
              localColorSpaceCache: j
            }) {
              const X = this._parse(O, b, A, Y);
              return this._cache(O, b, j, X), X;
            }
            static parse({
              cs: O,
              xref: b,
              resources: A = null,
              pdfFunctionFactory: Y,
              localColorSpaceCache: j
            }) {
              const X = this.getCached(O, b, j);
              if (X)
                return X;
              const B = this._parse(O, b, A, Y);
              return this._cache(O, b, j, B), B;
            }
            static _parse(O, b, A = null, Y) {
              if (O = b.fetchIfRef(O), O instanceof a.Name)
                switch (O.name) {
                  case "G":
                  case "DeviceGray":
                    return this.singletons.gray;
                  case "RGB":
                  case "DeviceRGB":
                    return this.singletons.rgb;
                  case "CMYK":
                  case "DeviceCMYK":
                    return this.singletons.cmyk;
                  case "Pattern":
                    return new d(null);
                  default:
                    if (A instanceof a.Dict) {
                      const j = A.get("ColorSpace");
                      if (j instanceof a.Dict) {
                        const X = j.get(O.name);
                        if (X) {
                          if (X instanceof a.Name)
                            return this._parse(X, b, A, Y);
                          O = X;
                          break;
                        }
                      }
                    }
                    throw new t.FormatError(`Unrecognized ColorSpace: ${O.name}`);
                }
              if (Array.isArray(O)) {
                const j = b.fetchIfRef(O[0]).name;
                let X, B, U, k, x, f;
                switch (j) {
                  case "G":
                  case "DeviceGray":
                    return this.singletons.gray;
                  case "RGB":
                  case "DeviceRGB":
                    return this.singletons.rgb;
                  case "CMYK":
                  case "DeviceCMYK":
                    return this.singletons.cmyk;
                  case "CalGray":
                    return X = b.fetchIfRef(O[1]), k = X.getArray("WhitePoint"), x = X.getArray("BlackPoint"), f = X.get("Gamma"), new i(k, x, f);
                  case "CalRGB":
                    X = b.fetchIfRef(O[1]), k = X.getArray("WhitePoint"), x = X.getArray("BlackPoint"), f = X.getArray("Gamma");
                    const D = X.getArray("Matrix");
                    return new l(k, x, f, D);
                  case "ICCBased":
                    const S = b.fetchIfRef(O[1]).dict;
                    B = S.get("N");
                    const C = S.get("Alternate");
                    if (C) {
                      const $ = this._parse(C, b, A, Y);
                      if ($.numComps === B)
                        return $;
                      (0, t.warn)("ICCBased color space: Ignoring incorrect /Alternate entry.");
                    }
                    if (B === 1)
                      return this.singletons.gray;
                    if (B === 3)
                      return this.singletons.rgb;
                    if (B === 4)
                      return this.singletons.cmyk;
                    break;
                  case "Pattern":
                    return U = O[1] || null, U && (U = this._parse(U, b, A, Y)), new d(U);
                  case "I":
                  case "Indexed":
                    U = this._parse(O[1], b, A, Y);
                    const T = b.fetchIfRef(O[2]) + 1, P = b.fetchIfRef(O[3]);
                    return new m(U, T, P);
                  case "Separation":
                  case "DeviceN":
                    const M = b.fetchIfRef(O[1]);
                    B = Array.isArray(M) ? M.length : 1, U = this._parse(O[2], b, A, Y);
                    const G = Y.create(O[3]);
                    return new c(B, U, G);
                  case "Lab":
                    X = b.fetchIfRef(O[1]), k = X.getArray("WhitePoint"), x = X.getArray("BlackPoint");
                    const Z = X.getArray("Range");
                    return new u(k, x, Z);
                  default:
                    throw new t.FormatError(`Unimplemented ColorSpace object: ${j}`);
                }
              }
              throw new t.FormatError(`Unrecognized ColorSpace object: ${O}`);
            }
            static isDefaultDecode(O, b) {
              if (!Array.isArray(O))
                return !0;
              if (b * 2 !== O.length)
                return (0, t.warn)("The decode map is not the correct length"), !0;
              for (let A = 0, Y = O.length; A < Y; A += 2)
                if (O[A] !== 0 || O[A + 1] !== 1)
                  return !1;
              return !0;
            }
            static get singletons() {
              return (0, t.shadow)(this, "singletons", {
                get gray() {
                  return (0, t.shadow)(this, "gray", new p());
                },
                get rgb() {
                  return (0, t.shadow)(this, "rgb", new g());
                },
                get cmyk() {
                  return (0, t.shadow)(this, "cmyk", new n());
                }
              });
            }
          }
          o.ColorSpace = y;
          class c extends y {
            constructor(O, b, A) {
              super("Alternate", O), this.base = b, this.tintFn = A, this.tmpBuf = new Float32Array(b.numComps);
            }
            getRgbItem(O, b, A, Y) {
              const j = this.tmpBuf;
              this.tintFn(O, b, j, 0), this.base.getRgbItem(j, 0, A, Y);
            }
            getRgbBuffer(O, b, A, Y, j, X, B) {
              const U = this.tintFn, k = this.base, x = 1 / ((1 << X) - 1), f = k.numComps, D = k.usesZeroToOneRange, _ = (k.isPassthrough(8) || !D) && B === 0;
              let S = _ ? j : 0;
              const C = _ ? Y : new Uint8ClampedArray(f * A), T = this.numComps, P = new Float32Array(T), M = new Float32Array(f);
              let G, Z;
              for (G = 0; G < A; G++) {
                for (Z = 0; Z < T; Z++)
                  P[Z] = O[b++] * x;
                if (U(P, 0, M, 0), D)
                  for (Z = 0; Z < f; Z++)
                    C[S++] = M[Z] * 255;
                else
                  k.getRgbItem(M, 0, C, S), S += f;
              }
              _ || k.getRgbBuffer(C, 0, A, Y, j, 8, B);
            }
            getOutputLength(O, b) {
              return this.base.getOutputLength(O * this.base.numComps / this.numComps, b);
            }
          }
          class d extends y {
            constructor(O) {
              super("Pattern", null), this.base = O;
            }
            isDefaultDecode(O, b) {
              (0, t.unreachable)("Should not call PatternCS.isDefaultDecode");
            }
          }
          class m extends y {
            constructor(O, b, A) {
              super("Indexed", 1), this.base = O, this.highVal = b;
              const Y = O.numComps * b;
              if (this.lookup = new Uint8Array(Y), A instanceof v.BaseStream) {
                const j = A.getBytes(Y);
                this.lookup.set(j);
              } else if (typeof A == "string")
                for (let j = 0; j < Y; ++j)
                  this.lookup[j] = A.charCodeAt(j) & 255;
              else
                throw new t.FormatError(`IndexedCS - unrecognized lookup table: ${A}`);
            }
            getRgbItem(O, b, A, Y) {
              const j = this.base.numComps, X = O[b] * j;
              this.base.getRgbBuffer(this.lookup, X, 1, A, Y, 8, 0);
            }
            getRgbBuffer(O, b, A, Y, j, X, B) {
              const U = this.base, k = U.numComps, x = U.getOutputLength(k, B), f = this.lookup;
              for (let D = 0; D < A; ++D) {
                const _ = O[b++] * k;
                U.getRgbBuffer(f, _, 1, Y, j, 8, B), j += x;
              }
            }
            getOutputLength(O, b) {
              return this.base.getOutputLength(O * this.base.numComps, b);
            }
            isDefaultDecode(O, b) {
              return Array.isArray(O) ? O.length !== 2 ? ((0, t.warn)("Decode map length is not correct"), !0) : !Number.isInteger(b) || b < 1 ? ((0, t.warn)("Bits per component is not correct"), !0) : O[0] === 0 && O[1] === (1 << b) - 1 : !0;
            }
          }
          class p extends y {
            constructor() {
              super("DeviceGray", 1);
            }
            getRgbItem(O, b, A, Y) {
              const j = O[b] * 255;
              A[Y] = A[Y + 1] = A[Y + 2] = j;
            }
            getRgbBuffer(O, b, A, Y, j, X, B) {
              const U = 255 / ((1 << X) - 1);
              let k = b, x = j;
              for (let f = 0; f < A; ++f) {
                const D = U * O[k++];
                Y[x++] = D, Y[x++] = D, Y[x++] = D, x += B;
              }
            }
            getOutputLength(O, b) {
              return O * (3 + b);
            }
          }
          class g extends y {
            constructor() {
              super("DeviceRGB", 3);
            }
            getRgbItem(O, b, A, Y) {
              A[Y] = O[b] * 255, A[Y + 1] = O[b + 1] * 255, A[Y + 2] = O[b + 2] * 255;
            }
            getRgbBuffer(O, b, A, Y, j, X, B) {
              if (X === 8 && B === 0) {
                Y.set(O.subarray(b, b + A * 3), j);
                return;
              }
              const U = 255 / ((1 << X) - 1);
              let k = b, x = j;
              for (let f = 0; f < A; ++f)
                Y[x++] = U * O[k++], Y[x++] = U * O[k++], Y[x++] = U * O[k++], x += B;
            }
            getOutputLength(O, b) {
              return O * (3 + b) / 3 | 0;
            }
            isPassthrough(O) {
              return O === 8;
            }
          }
          const n = function() {
            function O(A, Y, j, X, B) {
              const U = A[Y] * j, k = A[Y + 1] * j, x = A[Y + 2] * j, f = A[Y + 3] * j;
              X[B] = 255 + U * (-4.387332384609988 * U + 54.48615194189176 * k + 18.82290502165302 * x + 212.25662451639585 * f + -285.2331026137004) + k * (1.7149763477362134 * k - 5.6096736904047315 * x + -17.873870861415444 * f - 5.497006427196366) + x * (-2.5217340131683033 * x - 21.248923337353073 * f + 17.5119270841813) + f * (-21.86122147463605 * f - 189.48180835922747), X[B + 1] = 255 + U * (8.841041422036149 * U + 60.118027045597366 * k + 6.871425592049007 * x + 31.159100130055922 * f + -79.2970844816548) + k * (-15.310361306967817 * k + 17.575251261109482 * x + 131.35250912493976 * f - 190.9453302588951) + x * (4.444339102852739 * x + 9.8632861493405 * f - 24.86741582555878) + f * (-20.737325471181034 * f - 187.80453709719578), X[B + 2] = 255 + U * (0.8842522430003296 * U + 8.078677503112928 * k + 30.89978309703729 * x - 0.23883238689178934 * f + -14.183576799673286) + k * (10.49593273432072 * k + 63.02378494754052 * x + 50.606957656360734 * f - 112.23884253719248) + x * (0.03296041114873217 * x + 115.60384449646641 * f + -193.58209356861505) + f * (-22.33816807309886 * f - 180.12613974708367);
            }
            class b extends y {
              constructor() {
                super("DeviceCMYK", 4);
              }
              getRgbItem(Y, j, X, B) {
                O(Y, j, 1, X, B);
              }
              getRgbBuffer(Y, j, X, B, U, k, x) {
                const f = 1 / ((1 << k) - 1);
                for (let D = 0; D < X; D++)
                  O(Y, j, f, B, U), j += 4, U += 3 + x;
              }
              getOutputLength(Y, j) {
                return Y / 4 * (3 + j) | 0;
              }
            }
            return b;
          }(), i = function() {
            function O(A, Y, j, X, B, U) {
              const x = (Y[j] * U) ** A.G, f = A.YW * x, D = Math.max(295.8 * f ** 0.3333333333333333 - 40.8, 0);
              X[B] = D, X[B + 1] = D, X[B + 2] = D;
            }
            class b extends y {
              constructor(Y, j, X) {
                if (super("CalGray", 1), !Y)
                  throw new t.FormatError("WhitePoint missing - required for color space CalGray");
                if (j = j || [0, 0, 0], X = X || 1, this.XW = Y[0], this.YW = Y[1], this.ZW = Y[2], this.XB = j[0], this.YB = j[1], this.ZB = j[2], this.G = X, this.XW < 0 || this.ZW < 0 || this.YW !== 1)
                  throw new t.FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
                (this.XB < 0 || this.YB < 0 || this.ZB < 0) && ((0, t.info)(`Invalid BlackPoint for ${this.name}, falling back to default.`), this.XB = this.YB = this.ZB = 0), (this.XB !== 0 || this.YB !== 0 || this.ZB !== 0) && (0, t.warn)(`${this.name}, BlackPoint: XB: ${this.XB}, YB: ${this.YB}, ZB: ${this.ZB}, only default values are supported.`), this.G < 1 && ((0, t.info)(`Invalid Gamma: ${this.G} for ${this.name}, falling back to default.`), this.G = 1);
              }
              getRgbItem(Y, j, X, B) {
                O(this, Y, j, X, B, 1);
              }
              getRgbBuffer(Y, j, X, B, U, k, x) {
                const f = 1 / ((1 << k) - 1);
                for (let D = 0; D < X; ++D)
                  O(this, Y, j, B, U, f), j += 1, U += 3 + x;
              }
              getOutputLength(Y, j) {
                return Y * (3 + j);
              }
            }
            return b;
          }(), l = function() {
            const O = new Float32Array([0.8951, 0.2664, -0.1614, -0.7502, 1.7135, 0.0367, 0.0389, -0.0685, 1.0296]), b = new Float32Array([0.9869929, -0.1470543, 0.1599627, 0.4323053, 0.5183603, 0.0492912, -85287e-7, 0.0400428, 0.9684867]), A = new Float32Array([3.2404542, -1.5371385, -0.4985314, -0.969266, 1.8760108, 0.041556, 0.0556434, -0.2040259, 1.0572252]), Y = new Float32Array([1, 1, 1]), j = new Float32Array(3), X = new Float32Array(3), B = new Float32Array(3), U = ((8 + 16) / 116) ** 3 / 8;
            function k(Z, $, z) {
              z[0] = Z[0] * $[0] + Z[1] * $[1] + Z[2] * $[2], z[1] = Z[3] * $[0] + Z[4] * $[1] + Z[5] * $[2], z[2] = Z[6] * $[0] + Z[7] * $[1] + Z[8] * $[2];
            }
            function x(Z, $, z) {
              z[0] = $[0] * 1 / Z[0], z[1] = $[1] * 1 / Z[1], z[2] = $[2] * 1 / Z[2];
            }
            function f(Z, $, z) {
              z[0] = $[0] * 0.95047 / Z[0], z[1] = $[1] * 1 / Z[1], z[2] = $[2] * 1.08883 / Z[2];
            }
            function D(Z) {
              return Z <= 31308e-7 ? _(0, 1, 12.92 * Z) : Z >= 0.99554525 ? 1 : _(0, 1, (1 + 0.055) * Z ** (1 / 2.4) - 0.055);
            }
            function _(Z, $, z) {
              return Math.max(Z, Math.min($, z));
            }
            function S(Z) {
              return Z < 0 ? -S(-Z) : Z > 8 ? ((Z + 16) / 116) ** 3 : Z * U;
            }
            function C(Z, $, z) {
              if (Z[0] === 0 && Z[1] === 0 && Z[2] === 0) {
                z[0] = $[0], z[1] = $[1], z[2] = $[2];
                return;
              }
              const V = S(0), L = V, K = S(Z[0]), ne = V, se = S(Z[1]), q = V, N = S(Z[2]), Q = (1 - L) / (1 - K), E = 1 - Q, te = (1 - ne) / (1 - se), oe = 1 - te, ee = (1 - q) / (1 - N), W = 1 - ee;
              z[0] = $[0] * Q + E, z[1] = $[1] * te + oe, z[2] = $[2] * ee + W;
            }
            function T(Z, $, z) {
              if (Z[0] === 1 && Z[2] === 1) {
                z[0] = $[0], z[1] = $[1], z[2] = $[2];
                return;
              }
              const V = z;
              k(O, $, V);
              const L = j;
              x(Z, V, L), k(b, L, z);
            }
            function P(Z, $, z) {
              const V = z;
              k(O, $, V);
              const L = j;
              f(Z, V, L), k(b, L, z);
            }
            function M(Z, $, z, V, L, K) {
              const ne = _(0, 1, $[z] * K), se = _(0, 1, $[z + 1] * K), q = _(0, 1, $[z + 2] * K), N = ne === 1 ? 1 : ne ** Z.GR, Q = se === 1 ? 1 : se ** Z.GG, E = q === 1 ? 1 : q ** Z.GB, te = Z.MXA * N + Z.MXB * Q + Z.MXC * E, oe = Z.MYA * N + Z.MYB * Q + Z.MYC * E, ee = Z.MZA * N + Z.MZB * Q + Z.MZC * E, W = X;
              W[0] = te, W[1] = oe, W[2] = ee;
              const I = B;
              T(Z.whitePoint, W, I);
              const H = X;
              C(Z.blackPoint, I, H);
              const ie = B;
              P(Y, H, ie);
              const ue = X;
              k(A, ie, ue), V[L] = D(ue[0]) * 255, V[L + 1] = D(ue[1]) * 255, V[L + 2] = D(ue[2]) * 255;
            }
            class G extends y {
              constructor($, z, V, L) {
                if (super("CalRGB", 3), !$)
                  throw new t.FormatError("WhitePoint missing - required for color space CalRGB");
                z = z || new Float32Array(3), V = V || new Float32Array([1, 1, 1]), L = L || new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
                const K = $[0], ne = $[1], se = $[2];
                this.whitePoint = $;
                const q = z[0], N = z[1], Q = z[2];
                if (this.blackPoint = z, this.GR = V[0], this.GG = V[1], this.GB = V[2], this.MXA = L[0], this.MYA = L[1], this.MZA = L[2], this.MXB = L[3], this.MYB = L[4], this.MZB = L[5], this.MXC = L[6], this.MYC = L[7], this.MZC = L[8], K < 0 || se < 0 || ne !== 1)
                  throw new t.FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
                (q < 0 || N < 0 || Q < 0) && ((0, t.info)(`Invalid BlackPoint for ${this.name} [${q}, ${N}, ${Q}], falling back to default.`), this.blackPoint = new Float32Array(3)), (this.GR < 0 || this.GG < 0 || this.GB < 0) && ((0, t.info)(`Invalid Gamma [${this.GR}, ${this.GG}, ${this.GB}] for ${this.name}, falling back to default.`), this.GR = this.GG = this.GB = 1);
              }
              getRgbItem($, z, V, L) {
                M(this, $, z, V, L, 1);
              }
              getRgbBuffer($, z, V, L, K, ne, se) {
                const q = 1 / ((1 << ne) - 1);
                for (let N = 0; N < V; ++N)
                  M(this, $, z, L, K, q), z += 3, K += 3 + se;
              }
              getOutputLength($, z) {
                return $ * (3 + z) / 3 | 0;
              }
            }
            return G;
          }(), u = function() {
            function O(j) {
              let X;
              return j >= 6 / 29 ? X = j ** 3 : X = 108 / 841 * (j - 4 / 29), X;
            }
            function b(j, X, B, U) {
              return B + j * (U - B) / X;
            }
            function A(j, X, B, U, k, x) {
              let f = X[B], D = X[B + 1], _ = X[B + 2];
              U !== !1 && (f = b(f, U, 0, 100), D = b(D, U, j.amin, j.amax), _ = b(_, U, j.bmin, j.bmax)), D > j.amax ? D = j.amax : D < j.amin && (D = j.amin), _ > j.bmax ? _ = j.bmax : _ < j.bmin && (_ = j.bmin);
              const S = (f + 16) / 116, C = S + D / 500, T = S - _ / 200, P = j.XW * O(C), M = j.YW * O(S), G = j.ZW * O(T);
              let Z, $, z;
              j.ZW < 1 ? (Z = P * 3.1339 + M * -1.617 + G * -0.4906, $ = P * -0.9785 + M * 1.916 + G * 0.0333, z = P * 0.072 + M * -0.229 + G * 1.4057) : (Z = P * 3.2406 + M * -1.5372 + G * -0.4986, $ = P * -0.9689 + M * 1.8758 + G * 0.0415, z = P * 0.0557 + M * -0.204 + G * 1.057), k[x] = Math.sqrt(Z) * 255, k[x + 1] = Math.sqrt($) * 255, k[x + 2] = Math.sqrt(z) * 255;
            }
            class Y extends y {
              constructor(X, B, U) {
                if (super("Lab", 3), !X)
                  throw new t.FormatError("WhitePoint missing - required for color space Lab");
                if (B = B || [0, 0, 0], U = U || [-100, 100, -100, 100], this.XW = X[0], this.YW = X[1], this.ZW = X[2], this.amin = U[0], this.amax = U[1], this.bmin = U[2], this.bmax = U[3], this.XB = B[0], this.YB = B[1], this.ZB = B[2], this.XW < 0 || this.ZW < 0 || this.YW !== 1)
                  throw new t.FormatError("Invalid WhitePoint components, no fallback available");
                (this.XB < 0 || this.YB < 0 || this.ZB < 0) && ((0, t.info)("Invalid BlackPoint, falling back to default"), this.XB = this.YB = this.ZB = 0), (this.amin > this.amax || this.bmin > this.bmax) && ((0, t.info)("Invalid Range, falling back to defaults"), this.amin = -100, this.amax = 100, this.bmin = -100, this.bmax = 100);
              }
              getRgbItem(X, B, U, k) {
                A(this, X, B, !1, U, k);
              }
              getRgbBuffer(X, B, U, k, x, f, D) {
                const _ = (1 << f) - 1;
                for (let S = 0; S < U; S++)
                  A(this, X, B, _, k, x), B += 3, x += 3 + D;
              }
              getOutputLength(X, B) {
                return X * (3 + B) / 3 | 0;
              }
              isDefaultDecode(X, B) {
                return !0;
              }
              get usesZeroToOneRange() {
                return (0, t.shadow)(this, "usesZeroToOneRange", !1);
              }
            }
            return Y;
          }();
        },
        /* 15 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.PartialEvaluator = o.EvaluatorPreprocessor = void 0;
          var t = F(2), a = F(16), v = F(5), h = F(34), e = F(38), y = F(37), c = F(41), d = F(40), m = F(50), p = F(51), g = F(42), n = F(57), i = F(17), l = F(59), u = F(10), w = F(7), O = F(60), b = F(14), A = F(19), Y = F(39), j = F(6), X = F(45), B = F(61), U = F(62), k = F(63);
          const x = Object.freeze({
            maxImageSize: -1,
            disableFontFace: !1,
            ignoreErrors: !1,
            isEvalSupported: !0,
            fontExtraProperties: !1,
            useSystemFonts: !0,
            cMapUrl: null,
            standardFontDataUrl: null
          }), f = {
            TILING: 1,
            SHADING: 2
          }, D = 10, _ = Promise.resolve();
          function S(V, L = !1) {
            if (Array.isArray(V)) {
              for (let K = 0, ne = V.length; K < ne; K++) {
                const se = S(V[K], !0);
                if (se)
                  return se;
              }
              return (0, t.warn)(`Unsupported blend mode Array: ${V}`), "source-over";
            }
            if (!(V instanceof v.Name))
              return L ? null : "source-over";
            switch (V.name) {
              case "Normal":
              case "Compatible":
                return "source-over";
              case "Multiply":
                return "multiply";
              case "Screen":
                return "screen";
              case "Overlay":
                return "overlay";
              case "Darken":
                return "darken";
              case "Lighten":
                return "lighten";
              case "ColorDodge":
                return "color-dodge";
              case "ColorBurn":
                return "color-burn";
              case "HardLight":
                return "hard-light";
              case "SoftLight":
                return "soft-light";
              case "Difference":
                return "difference";
              case "Exclusion":
                return "exclusion";
              case "Hue":
                return "hue";
              case "Saturation":
                return "saturation";
              case "Color":
                return "color";
              case "Luminosity":
                return "luminosity";
            }
            return L ? null : ((0, t.warn)(`Unsupported blend mode: ${V.name}`), "source-over");
          }
          function C(V) {
            V.fn === t.OPS.paintImageMaskXObject && V.args[0] && V.args[0].count > 0 && V.args[0].count++;
          }
          class T {
            static get TIME_SLOT_DURATION_MS() {
              return (0, t.shadow)(this, "TIME_SLOT_DURATION_MS", 20);
            }
            static get CHECK_TIME_EVERY() {
              return (0, t.shadow)(this, "CHECK_TIME_EVERY", 100);
            }
            constructor() {
              this.reset();
            }
            check() {
              return ++this.checked < T.CHECK_TIME_EVERY ? !1 : (this.checked = 0, this.endTime <= Date.now());
            }
            reset() {
              this.endTime = Date.now() + T.TIME_SLOT_DURATION_MS, this.checked = 0;
            }
          }
          class P {
            constructor({
              xref: L,
              handler: K,
              pageIndex: ne,
              idFactory: se,
              fontCache: q,
              builtInCMapCache: N,
              standardFontDataCache: Q,
              globalImageCache: E,
              options: te = null
            }) {
              this.xref = L, this.handler = K, this.pageIndex = ne, this.idFactory = se, this.fontCache = q, this.builtInCMapCache = N, this.standardFontDataCache = Q, this.globalImageCache = E, this.options = te || x, this.parsingType3Font = !1, this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);
            }
            get _pdfFunctionFactory() {
              const L = new n.PDFFunctionFactory({
                xref: this.xref,
                isEvalSupported: this.options.isEvalSupported
              });
              return (0, t.shadow)(this, "_pdfFunctionFactory", L);
            }
            clone(L = null) {
              const K = Object.create(this);
              return K.options = Object.assign(/* @__PURE__ */ Object.create(null), this.options, L), K;
            }
            hasBlendModes(L, K) {
              if (!(L instanceof v.Dict) || L.objId && K.has(L.objId))
                return !1;
              const ne = new v.RefSet(K);
              L.objId && ne.put(L.objId);
              const se = [L], q = this.xref;
              for (; se.length; ) {
                const N = se.shift(), Q = N.get("ExtGState");
                if (Q instanceof v.Dict)
                  for (let te of Q.getRawValues()) {
                    if (te instanceof v.Ref) {
                      if (ne.has(te))
                        continue;
                      try {
                        te = q.fetch(te);
                      } catch (ee) {
                        ne.put(te), (0, t.info)(`hasBlendModes - ignoring ExtGState: "${ee}".`);
                        continue;
                      }
                    }
                    if (!(te instanceof v.Dict))
                      continue;
                    te.objId && ne.put(te.objId);
                    const oe = te.get("BM");
                    if (oe instanceof v.Name) {
                      if (oe.name !== "Normal")
                        return !0;
                      continue;
                    }
                    if (oe !== void 0 && Array.isArray(oe)) {
                      for (const ee of oe)
                        if (ee instanceof v.Name && ee.name !== "Normal")
                          return !0;
                    }
                  }
                const E = N.get("XObject");
                if (E instanceof v.Dict)
                  for (let te of E.getRawValues()) {
                    if (te instanceof v.Ref) {
                      if (ne.has(te))
                        continue;
                      try {
                        te = q.fetch(te);
                      } catch (ee) {
                        ne.put(te), (0, t.info)(`hasBlendModes - ignoring XObject: "${ee}".`);
                        continue;
                      }
                    }
                    if (!(te instanceof w.BaseStream))
                      continue;
                    te.dict.objId && ne.put(te.dict.objId);
                    const oe = te.dict.get("Resources");
                    oe instanceof v.Dict && (oe.objId && ne.has(oe.objId) || (se.push(oe), oe.objId && ne.put(oe.objId)));
                  }
              }
              for (const N of ne)
                K.put(N);
              return !1;
            }
            async fetchBuiltInCMap(L) {
              const K = this.builtInCMapCache.get(L);
              if (K)
                return K;
              let ne;
              if (this.options.cMapUrl !== null) {
                const se = `${this.options.cMapUrl}${L}.bcmap`, q = await fetch(se);
                if (!q.ok)
                  throw new Error(`fetchBuiltInCMap: failed to fetch file "${se}" with "${q.statusText}".`);
                ne = {
                  cMapData: new Uint8Array(await q.arrayBuffer()),
                  compressionType: t.CMapCompressionType.BINARY
                };
              } else
                ne = await this.handler.sendWithPromise("FetchBuiltInCMap", {
                  name: L
                });
              return ne.compressionType !== t.CMapCompressionType.NONE && this.builtInCMapCache.set(L, ne), ne;
            }
            async fetchStandardFontData(L) {
              const K = this.standardFontDataCache.get(L);
              if (K)
                return new u.Stream(K);
              if (this.options.useSystemFonts && L !== "Symbol" && L !== "ZapfDingbats")
                return null;
              const ne = (0, c.getFontNameToFileMap)(), se = ne[L];
              let q;
              if (this.options.standardFontDataUrl !== null) {
                const N = `${this.options.standardFontDataUrl}${se}`, Q = await fetch(N);
                Q.ok ? q = await Q.arrayBuffer() : (0, t.warn)(`fetchStandardFontData: failed to fetch file "${N}" with "${Q.statusText}".`);
              } else
                try {
                  q = await this.handler.sendWithPromise("FetchStandardFontData", {
                    filename: se
                  });
                } catch (N) {
                  (0, t.warn)(`fetchStandardFontData: failed to fetch file "${se}" with "${N}".`);
                }
              return q ? (this.standardFontDataCache.set(L, q), new u.Stream(q)) : null;
            }
            async buildFormXObject(L, K, ne, se, q, N, Q) {
              const E = K.dict, te = E.getArray("Matrix");
              let oe = E.getArray("BBox");
              Array.isArray(oe) && oe.length === 4 ? oe = t.Util.normalizeRect(oe) : oe = null;
              let ee, W;
              E.has("OC") && (ee = await this.parseMarkedContentProps(E.get("OC"), L)), ee !== void 0 && se.addOp(t.OPS.beginMarkedContentProps, ["OC", ee]);
              const I = E.get("Group");
              if (I) {
                W = {
                  matrix: te,
                  bbox: oe,
                  smask: ne,
                  isolated: !1,
                  knockout: !1
                };
                const ie = I.get("S");
                let ue = null;
                if ((0, v.isName)(ie, "Transparency") && (W.isolated = I.get("I") || !1, W.knockout = I.get("K") || !1, I.has("CS"))) {
                  const fe = I.getRaw("CS"), de = b.ColorSpace.getCached(fe, this.xref, Q);
                  de ? ue = de : ue = await this.parseColorSpace({
                    cs: fe,
                    resources: L,
                    localColorSpaceCache: Q
                  });
                }
                ne && ne.backdrop && (ue = ue || b.ColorSpace.singletons.rgb, ne.backdrop = ue.getRgb(ne.backdrop, 0)), se.addOp(t.OPS.beginGroup, [W]);
              }
              const H = I ? [te, null] : [te, oe];
              return se.addOp(t.OPS.paintFormXObjectBegin, H), this.getOperatorList({
                stream: K,
                task: q,
                resources: E.get("Resources") || L,
                operatorList: se,
                initialState: N
              }).then(function() {
                se.addOp(t.OPS.paintFormXObjectEnd, []), I && se.addOp(t.OPS.endGroup, [W]), ee !== void 0 && se.addOp(t.OPS.endMarkedContent, []);
              });
            }
            _sendImgData(L, K, ne = !1) {
              const se = K ? [K.bitmap || K.data.buffer] : null;
              return this.parsingType3Font || ne ? this.handler.send("commonobj", [L, "Image", K], se) : this.handler.send("obj", [L, this.pageIndex, "Image", K], se);
            }
            async buildPaintImageXObject({
              resources: L,
              image: K,
              isInline: ne = !1,
              operatorList: se,
              cacheKey: q,
              localImageCache: N,
              localColorSpaceCache: Q
            }) {
              const E = K.dict, te = E.objId, oe = E.get("W", "Width"), ee = E.get("H", "Height");
              if (!(oe && typeof oe == "number") || !(ee && typeof ee == "number")) {
                (0, t.warn)("Image dimensions are missing, or not numbers.");
                return;
              }
              const W = this.options.maxImageSize;
              if (W !== -1 && oe * ee > W) {
                const Se = "Image exceeded maximum allowed size and was removed.";
                if (this.options.ignoreErrors) {
                  (0, t.warn)(Se);
                  return;
                }
                throw new Error(Se);
              }
              let I;
              E.has("OC") && (I = await this.parseMarkedContentProps(E.get("OC"), L));
              const H = E.get("IM", "ImageMask") || !1;
              let ie, ue;
              if (H) {
                const Se = E.get("I", "Interpolate"), Ce = oe + 7 >> 3, ke = K.getBytes(Ce * ee), ye = E.getArray("D", "Decode");
                if (this.parsingType3Font) {
                  ie = k.PDFImage.createRawMask({
                    imgArray: ke,
                    width: oe,
                    height: ee,
                    imageIsFromDecodeStream: K instanceof A.DecodeStream,
                    inverseDecode: !!ye && ye[0] > 0,
                    interpolate: Se
                  }), ie.cached = !!q, ue = [ie], se.addImageOps(t.OPS.paintImageMaskXObject, ue, I), q && N.set(q, te, {
                    fn: t.OPS.paintImageMaskXObject,
                    args: ue,
                    optionalContent: I
                  });
                  return;
                }
                if (ie = k.PDFImage.createMask({
                  imgArray: ke,
                  width: oe,
                  height: ee,
                  imageIsFromDecodeStream: K instanceof A.DecodeStream,
                  inverseDecode: !!ye && ye[0] > 0,
                  interpolate: Se
                }), ie.isSingleOpaquePixel) {
                  se.addImageOps(t.OPS.paintSolidColorImageMask, [], I), q && N.set(q, te, {
                    fn: t.OPS.paintSolidColorImageMask,
                    args: [],
                    optionalContent: I
                  });
                  return;
                }
                const De = `mask_${this.idFactory.createObjId()}`;
                se.addDependency(De), this._sendImgData(De, ie), ue = [{
                  data: De,
                  width: ie.width,
                  height: ie.height,
                  interpolate: ie.interpolate,
                  count: 1
                }], se.addImageOps(t.OPS.paintImageMaskXObject, ue, I), q && N.set(q, te, {
                  fn: t.OPS.paintImageMaskXObject,
                  args: ue,
                  optionalContent: I
                });
                return;
              }
              const fe = E.get("SM", "SMask") || !1, de = E.get("Mask") || !1, pe = 200;
              if (ne && !fe && !de && oe + ee < pe) {
                ie = new k.PDFImage({
                  xref: this.xref,
                  res: L,
                  image: K,
                  isInline: ne,
                  pdfFunctionFactory: this._pdfFunctionFactory,
                  localColorSpaceCache: Q
                }).createImageData(!0), se.addImageOps(t.OPS.paintInlineImageXObject, [ie], I);
                return;
              }
              let xe = `img_${this.idFactory.createObjId()}`, Fe = !1;
              this.parsingType3Font ? xe = `${this.idFactory.getDocId()}_type3_${xe}` : te && (Fe = this.globalImageCache.shouldCache(te, this.pageIndex), Fe && (xe = `${this.idFactory.getDocId()}_${xe}`)), se.addDependency(xe), ue = [xe, oe, ee], k.PDFImage.buildImage({
                xref: this.xref,
                res: L,
                image: K,
                isInline: ne,
                pdfFunctionFactory: this._pdfFunctionFactory,
                localColorSpaceCache: Q
              }).then((Se) => (ie = Se.createImageData(!1), q && te && Fe && this.globalImageCache.addByteSize(te, ie.data.length), this._sendImgData(xe, ie, Fe))).catch((Se) => ((0, t.warn)(`Unable to decode image "${xe}": "${Se}".`), this._sendImgData(xe, null, Fe))), se.addImageOps(t.OPS.paintImageXObject, ue, I), q && (N.set(q, te, {
                fn: t.OPS.paintImageXObject,
                args: ue,
                optionalContent: I
              }), te && ((0, t.assert)(!ne, "Cannot cache an inline image globally."), this.globalImageCache.addPageIndex(te, this.pageIndex), Fe && this.globalImageCache.setData(te, {
                objId: xe,
                fn: t.OPS.paintImageXObject,
                args: ue,
                optionalContent: I,
                byteSize: 0
              })));
            }
            handleSMask(L, K, ne, se, q, N) {
              const Q = L.get("G"), E = {
                subtype: L.get("S").name,
                backdrop: L.get("BC")
              }, te = L.get("TR");
              if ((0, n.isPDFFunction)(te)) {
                const oe = this._pdfFunctionFactory.create(te), ee = new Uint8Array(256), W = new Float32Array(1);
                for (let I = 0; I < 256; I++)
                  W[0] = I / 255, oe(W, 0, W, 0), ee[I] = W[0] * 255 | 0;
                E.transferMap = ee;
              }
              return this.buildFormXObject(K, Q, E, ne, se, q.state.clone(), N);
            }
            handleTransferFunction(L) {
              let K;
              if (Array.isArray(L))
                K = L;
              else if ((0, n.isPDFFunction)(L))
                K = [L];
              else
                return null;
              const ne = [];
              let se = 0, q = 0;
              for (const N of K) {
                const Q = this.xref.fetchIfRef(N);
                if (se++, (0, v.isName)(Q, "Identity")) {
                  ne.push(null);
                  continue;
                } else if (!(0, n.isPDFFunction)(Q))
                  return null;
                const E = this._pdfFunctionFactory.create(Q), te = new Uint8Array(256), oe = new Float32Array(1);
                for (let ee = 0; ee < 256; ee++)
                  oe[0] = ee / 255, E(oe, 0, oe, 0), te[ee] = oe[0] * 255 | 0;
                ne.push(te), q++;
              }
              return !(se === 1 || se === 4) || q === 0 ? null : ne;
            }
            handleTilingType(L, K, ne, se, q, N, Q, E) {
              const te = new U.OperatorList(), oe = v.Dict.merge({
                xref: this.xref,
                dictArray: [q.get("Resources"), ne]
              });
              return this.getOperatorList({
                stream: se,
                task: Q,
                resources: oe,
                operatorList: te
              }).then(function() {
                const ee = te.getIR(), W = (0, m.getTilingPatternIR)(ee, q, K);
                N.addDependencies(te.dependencies), N.addOp(L, W), q.objId && E.set(null, q.objId, {
                  operatorListIR: ee,
                  dict: q
                });
              }).catch((ee) => {
                if (!(ee instanceof t.AbortException)) {
                  if (this.options.ignoreErrors) {
                    this.handler.send("UnsupportedFeature", {
                      featureId: t.UNSUPPORTED_FEATURES.errorTilingPattern
                    }), (0, t.warn)(`handleTilingType - ignoring pattern: "${ee}".`);
                    return;
                  }
                  throw ee;
                }
              });
            }
            handleSetFont(L, K, ne, se, q, N, Q = null, E = null) {
              const te = K && K[0] instanceof v.Name ? K[0].name : null;
              return this.loadFont(te, ne, L, Q, E).then((oe) => oe.font.isType3Font ? oe.loadType3Data(this, L, q).then(function() {
                return se.addDependencies(oe.type3Dependencies), oe;
              }).catch((ee) => (this.handler.send("UnsupportedFeature", {
                featureId: t.UNSUPPORTED_FEATURES.errorFontLoadType3
              }), new M({
                loadedName: "g_font_error",
                font: new h.ErrorFont(`Type3 font load error: ${ee}`),
                dict: oe.font,
                evaluatorOptions: this.options
              }))) : oe).then((oe) => (N.font = oe.font, oe.send(this.handler), oe.loadedName));
            }
            handleText(L, K) {
              const ne = K.font, se = ne.charsToGlyphs(L);
              return ne.data && (K.textRenderingMode & t.TextRenderingMode.ADD_TO_PATH_FLAG || K.fillColorSpace.name === "Pattern" || ne.disableFontFace || this.options.disableFontFace) && P.buildFontPaths(ne, se, this.handler, this.options), se;
            }
            ensureStateFont(L) {
              if (L.font)
                return;
              const K = new t.FormatError("Missing setFont (Tf) operator before text rendering operator.");
              if (this.options.ignoreErrors) {
                this.handler.send("UnsupportedFeature", {
                  featureId: t.UNSUPPORTED_FEATURES.errorFontState
                }), (0, t.warn)(`ensureStateFont: "${K}".`);
                return;
              }
              throw K;
            }
            async setGState({
              resources: L,
              gState: K,
              operatorList: ne,
              cacheKey: se,
              task: q,
              stateManager: N,
              localGStateCache: Q,
              localColorSpaceCache: E
            }) {
              const te = K.objId;
              let oe = !0;
              const ee = [], W = K.getKeys();
              let I = Promise.resolve();
              for (let H = 0, ie = W.length; H < ie; H++) {
                const ue = W[H], fe = K.get(ue);
                switch (ue) {
                  case "Type":
                    break;
                  case "LW":
                  case "LC":
                  case "LJ":
                  case "ML":
                  case "D":
                  case "RI":
                  case "FL":
                  case "CA":
                  case "ca":
                    ee.push([ue, fe]);
                    break;
                  case "Font":
                    oe = !1, I = I.then(() => this.handleSetFont(L, null, fe[0], ne, q, N.state).then(function(pe) {
                      ne.addDependency(pe), ee.push([ue, [pe, fe[1]]]);
                    }));
                    break;
                  case "BM":
                    ee.push([ue, S(fe)]);
                    break;
                  case "SMask":
                    if ((0, v.isName)(fe, "None")) {
                      ee.push([ue, !1]);
                      break;
                    }
                    fe instanceof v.Dict ? (oe = !1, I = I.then(() => this.handleSMask(fe, L, ne, q, N, E)), ee.push([ue, !0])) : (0, t.warn)("Unsupported SMask type");
                    break;
                  case "TR":
                    const de = this.handleTransferFunction(fe);
                    ee.push([ue, de]);
                    break;
                  case "OP":
                  case "op":
                  case "OPM":
                  case "BG":
                  case "BG2":
                  case "UCR":
                  case "UCR2":
                  case "TR2":
                  case "HT":
                  case "SM":
                  case "SA":
                  case "AIS":
                  case "TK":
                    (0, t.info)("graphic state operator " + ue);
                    break;
                  default:
                    (0, t.info)("Unknown graphic state operator " + ue);
                    break;
                }
              }
              return I.then(function() {
                ee.length > 0 && ne.addOp(t.OPS.setGState, [ee]), oe && Q.set(se, te, ee);
              });
            }
            loadFont(L, K, ne, se = null, q = null) {
              const N = async () => new M({
                loadedName: "g_font_error",
                font: new h.ErrorFont(`Font "${L}" is not available.`),
                dict: K,
                evaluatorOptions: this.options
              }), Q = this.xref;
              let E;
              if (K)
                K instanceof v.Ref && (E = K);
              else {
                const ie = ne.get("Font");
                ie && (E = ie.getRaw(L));
              }
              if (!E) {
                const ie = `Font "${L || K && K.toString()}" is not available`;
                if (!this.options.ignoreErrors && !this.parsingType3Font)
                  return (0, t.warn)(`${ie}.`), N();
                this.handler.send("UnsupportedFeature", {
                  featureId: t.UNSUPPORTED_FEATURES.errorFontMissing
                }), (0, t.warn)(`${ie} -- attempting to fallback to a default font.`), se ? E = se : E = P.fallbackFontDict;
              }
              if (this.parsingType3Font && this.type3FontRefs.has(E))
                return N();
              if (this.fontCache.has(E))
                return this.fontCache.get(E);
              if (K = Q.fetchIfRef(E), !(K instanceof v.Dict))
                return N();
              if (K.cacheKey && this.fontCache.has(K.cacheKey))
                return this.fontCache.get(K.cacheKey);
              const te = (0, t.createPromiseCapability)();
              let oe;
              try {
                oe = this.preEvaluateFont(K), oe.cssFontInfo = q;
              } catch (ie) {
                return (0, t.warn)(`loadFont - preEvaluateFont failed: "${ie}".`), N();
              }
              const {
                descriptor: ee,
                hash: W
              } = oe, I = E instanceof v.Ref;
              let H;
              if (I && (H = `f${E.toString()}`), W && ee instanceof v.Dict) {
                ee.fontAliases || (ee.fontAliases = /* @__PURE__ */ Object.create(null));
                const ie = ee.fontAliases;
                if (ie[W]) {
                  const ue = ie[W].aliasRef;
                  if (I && ue && this.fontCache.has(ue))
                    return this.fontCache.putAlias(E, ue), this.fontCache.get(E);
                } else
                  ie[W] = {
                    fontID: this.idFactory.createFontId()
                  };
                I && (ie[W].aliasRef = E), H = ie[W].fontID;
              }
              return I ? this.fontCache.put(E, te.promise) : (H || (H = this.idFactory.createFontId()), K.cacheKey = `cacheKey_${H}`, this.fontCache.put(K.cacheKey, te.promise)), (0, t.assert)(H && H.startsWith("f"), 'The "fontID" must be (correctly) defined.'), K.loadedName = `${this.idFactory.getDocId()}_${H}`, this.translateFont(oe).then((ie) => {
                ie.fontType !== void 0 && Q.stats.addFontType(ie.fontType), te.resolve(new M({
                  loadedName: K.loadedName,
                  font: ie,
                  dict: K,
                  evaluatorOptions: this.options
                }));
              }).catch((ie) => {
                this.handler.send("UnsupportedFeature", {
                  featureId: t.UNSUPPORTED_FEATURES.errorFontTranslate
                }), (0, t.warn)(`loadFont - translateFont failed: "${ie}".`);
                try {
                  const ue = ee && ee.get("FontFile3"), fe = ue && ue.get("Subtype"), de = (0, e.getFontType)(oe.type, fe && fe.name);
                  de !== void 0 && Q.stats.addFontType(de);
                } catch {
                }
                te.resolve(new M({
                  loadedName: K.loadedName,
                  font: new h.ErrorFont(ie instanceof Error ? ie.message : ie),
                  dict: K,
                  evaluatorOptions: this.options
                }));
              }), te.promise;
            }
            buildPath(L, K, ne, se = !1) {
              const q = L.length - 1;
              ne || (ne = []);
              let N;
              if (q < 0 || L.fnArray[q] !== t.OPS.constructPath)
                se && ((0, t.warn)(`Encountered path operator "${K}" inside of a text object.`), L.addOp(t.OPS.save, null)), N = [1 / 0, -1 / 0, 1 / 0, -1 / 0], L.addOp(t.OPS.constructPath, [[K], ne, N]), se && L.addOp(t.OPS.restore, null);
              else {
                const Q = L.argsArray[q];
                Q[0].push(K), Array.prototype.push.apply(Q[1], ne), N = Q[2];
              }
              switch (K) {
                case t.OPS.rectangle:
                  N[0] = Math.min(N[0], ne[0], ne[0] + ne[2]), N[1] = Math.max(N[1], ne[0], ne[0] + ne[2]), N[2] = Math.min(N[2], ne[1], ne[1] + ne[3]), N[3] = Math.max(N[3], ne[1], ne[1] + ne[3]);
                  break;
                case t.OPS.moveTo:
                case t.OPS.lineTo:
                  N[0] = Math.min(N[0], ne[0]), N[1] = Math.max(N[1], ne[0]), N[2] = Math.min(N[2], ne[1]), N[3] = Math.max(N[3], ne[1]);
                  break;
              }
            }
            parseColorSpace({
              cs: L,
              resources: K,
              localColorSpaceCache: ne
            }) {
              return b.ColorSpace.parseAsync({
                cs: L,
                xref: this.xref,
                resources: K,
                pdfFunctionFactory: this._pdfFunctionFactory,
                localColorSpaceCache: ne
              }).catch((se) => {
                if (se instanceof t.AbortException)
                  return null;
                if (this.options.ignoreErrors)
                  return this.handler.send("UnsupportedFeature", {
                    featureId: t.UNSUPPORTED_FEATURES.errorColorSpace
                  }), (0, t.warn)(`parseColorSpace - ignoring ColorSpace: "${se}".`), null;
                throw se;
              });
            }
            parseShading({
              shading: L,
              resources: K,
              localColorSpaceCache: ne,
              localShadingPatternCache: se
            }) {
              let q = se.get(L);
              if (!q) {
                var N = m.Pattern.parseShading(L, this.xref, K, this.handler, this._pdfFunctionFactory, ne);
                const Q = N.getIR();
                q = `pattern_${this.idFactory.createObjId()}`, se.set(L, q), this.handler.send("obj", [q, this.pageIndex, "Pattern", Q]);
              }
              return q;
            }
            handleColorN(L, K, ne, se, q, N, Q, E, te, oe) {
              const ee = ne.pop();
              if (ee instanceof v.Name) {
                const W = q.getRaw(ee.name), I = W instanceof v.Ref && te.getByRef(W);
                if (I)
                  try {
                    const ie = se.base ? se.base.getRgb(ne, 0) : null, ue = (0, m.getTilingPatternIR)(I.operatorListIR, I.dict, ie);
                    L.addOp(K, ue);
                    return;
                  } catch {
                  }
                const H = this.xref.fetchIfRef(W);
                if (H) {
                  const ie = H instanceof w.BaseStream ? H.dict : H, ue = ie.get("PatternType");
                  if (ue === f.TILING) {
                    const fe = se.base ? se.base.getRgb(ne, 0) : null;
                    return this.handleTilingType(K, fe, N, H, ie, L, Q, te);
                  } else if (ue === f.SHADING) {
                    const fe = ie.get("Shading"), de = ie.getArray("Matrix"), pe = this.parseShading({
                      shading: fe,
                      resources: N,
                      localColorSpaceCache: E,
                      localShadingPatternCache: oe
                    });
                    L.addOp(K, ["Shading", pe, de]);
                    return;
                  }
                  throw new t.FormatError(`Unknown PatternType: ${ue}`);
                }
              }
              throw new t.FormatError(`Unknown PatternName: ${ee}`);
            }
            _parseVisibilityExpression(L, K, ne) {
              if (++K > 10) {
                (0, t.warn)("Visibility expression is too deeply nested");
                return;
              }
              const q = L.length, N = this.xref.fetchIfRef(L[0]);
              if (q < 2 || !(N instanceof v.Name)) {
                (0, t.warn)("Invalid visibility expression");
                return;
              }
              switch (N.name) {
                case "And":
                case "Or":
                case "Not":
                  ne.push(N.name);
                  break;
                default:
                  (0, t.warn)(`Invalid operator ${N.name} in visibility expression`);
                  return;
              }
              for (let Q = 1; Q < q; Q++) {
                const E = L[Q], te = this.xref.fetchIfRef(E);
                if (Array.isArray(te)) {
                  const oe = [];
                  ne.push(oe), this._parseVisibilityExpression(te, K, oe);
                } else
                  E instanceof v.Ref && ne.push(E.toString());
              }
            }
            async parseMarkedContentProps(L, K) {
              let ne;
              if (L instanceof v.Name)
                ne = K.get("Properties").get(L.name);
              else if (L instanceof v.Dict)
                ne = L;
              else
                throw new t.FormatError("Optional content properties malformed.");
              const se = ne.get("Type").name;
              if (se === "OCG")
                return {
                  type: se,
                  id: ne.objId
                };
              if (se === "OCMD") {
                const q = ne.get("VE");
                if (Array.isArray(q)) {
                  const Q = [];
                  if (this._parseVisibilityExpression(q, 0, Q), Q.length > 0)
                    return {
                      type: "OCMD",
                      expression: Q
                    };
                }
                const N = ne.get("OCGs");
                if (Array.isArray(N) || N instanceof v.Dict) {
                  const Q = [];
                  if (Array.isArray(N))
                    for (const E of N)
                      Q.push(E.toString());
                  else
                    Q.push(N.objId);
                  return {
                    type: se,
                    ids: Q,
                    policy: ne.get("P") instanceof v.Name ? ne.get("P").name : null,
                    expression: null
                  };
                } else if (N instanceof v.Ref)
                  return {
                    type: se,
                    id: N.toString()
                  };
              }
              return null;
            }
            getOperatorList({
              stream: L,
              task: K,
              resources: ne,
              operatorList: se,
              initialState: q = null,
              fallbackFontDict: N = null
            }) {
              if (ne = ne || v.Dict.empty, q = q || new $(), !se)
                throw new Error('getOperatorList: missing "operatorList" parameter');
              const Q = this, E = this.xref;
              let te = !1;
              const oe = new l.LocalImageCache(), ee = new l.LocalColorSpaceCache(), W = new l.LocalGStateCache(), I = new l.LocalTilingPatternCache(), H = /* @__PURE__ */ new Map(), ie = ne.get("XObject") || v.Dict.empty, ue = ne.get("Pattern") || v.Dict.empty, fe = new G(q), de = new z(L, E, fe), pe = new T();
              function xe(Fe) {
                for (let Se = 0, Ce = de.savedStatesDepth; Se < Ce; Se++)
                  se.addOp(t.OPS.restore, []);
              }
              return new Promise(function Fe(Se, Ce) {
                const ke = function(Je) {
                  Promise.all([Je, se.ready]).then(function() {
                    try {
                      Fe(Se, Ce);
                    } catch (mt) {
                      Ce(mt);
                    }
                  }, Ce);
                };
                K.ensureNotTerminated(), pe.reset();
                const ye = {};
                let De, Ae, Te, ve, Ne, Ge;
                for (; !(De = pe.check()) && (ye.args = null, !!de.read(ye)); ) {
                  let Je = ye.args, mt = ye.fn;
                  switch (mt | 0) {
                    case t.OPS.paintXObject:
                      if (Ge = Je[0] instanceof v.Name, Ne = Je[0].name, Ge) {
                        const Xe = oe.getByName(Ne);
                        if (Xe) {
                          se.addImageOps(Xe.fn, Xe.args, Xe.optionalContent), C(Xe), Je = null;
                          continue;
                        }
                      }
                      ke(new Promise(function(Xe, Ct) {
                        if (!Ge)
                          throw new t.FormatError("XObject must be referred to by name.");
                        let bt = ie.getRaw(Ne);
                        if (bt instanceof v.Ref) {
                          const qe = oe.getByRef(bt);
                          if (qe) {
                            se.addImageOps(qe.fn, qe.args, qe.optionalContent), C(qe), Xe();
                            return;
                          }
                          const ot = Q.globalImageCache.getData(bt, Q.pageIndex);
                          if (ot) {
                            se.addDependency(ot.objId), se.addImageOps(ot.fn, ot.args, ot.optionalContent), Xe();
                            return;
                          }
                          bt = E.fetch(bt);
                        }
                        if (!(bt instanceof w.BaseStream))
                          throw new t.FormatError("XObject should be a stream");
                        const Pe = bt.dict.get("Subtype");
                        if (!(Pe instanceof v.Name))
                          throw new t.FormatError("XObject should have a Name subtype");
                        if (Pe.name === "Form") {
                          fe.save(), Q.buildFormXObject(ne, bt, null, se, K, fe.state.clone(), ee).then(function() {
                            fe.restore(), Xe();
                          }, Ct);
                          return;
                        } else if (Pe.name === "Image") {
                          Q.buildPaintImageXObject({
                            resources: ne,
                            image: bt,
                            operatorList: se,
                            cacheKey: Ne,
                            localImageCache: oe,
                            localColorSpaceCache: ee
                          }).then(Xe, Ct);
                          return;
                        } else if (Pe.name === "PS")
                          (0, t.info)("Ignored XObject subtype PS");
                        else
                          throw new t.FormatError(`Unhandled XObject subtype ${Pe.name}`);
                        Xe();
                      }).catch(function(Xe) {
                        if (!(Xe instanceof t.AbortException)) {
                          if (Q.options.ignoreErrors) {
                            Q.handler.send("UnsupportedFeature", {
                              featureId: t.UNSUPPORTED_FEATURES.errorXObject
                            }), (0, t.warn)(`getOperatorList - ignoring XObject: "${Xe}".`);
                            return;
                          }
                          throw Xe;
                        }
                      }));
                      return;
                    case t.OPS.setFont:
                      var it = Je[1];
                      ke(Q.handleSetFont(ne, Je, null, se, K, fe.state, N).then(function(Xe) {
                        se.addDependency(Xe), se.addOp(t.OPS.setFont, [Xe, it]);
                      }));
                      return;
                    case t.OPS.beginText:
                      te = !0;
                      break;
                    case t.OPS.endText:
                      te = !1;
                      break;
                    case t.OPS.endInlineImage:
                      var Me = Je[0].cacheKey;
                      if (Me) {
                        const Xe = oe.getByName(Me);
                        if (Xe) {
                          se.addImageOps(Xe.fn, Xe.args, Xe.optionalContent), C(Xe), Je = null;
                          continue;
                        }
                      }
                      ke(Q.buildPaintImageXObject({
                        resources: ne,
                        image: Je[0],
                        isInline: !0,
                        operatorList: se,
                        cacheKey: Me,
                        localImageCache: oe,
                        localColorSpaceCache: ee
                      }));
                      return;
                    case t.OPS.showText:
                      if (!fe.state.font) {
                        Q.ensureStateFont(fe.state);
                        continue;
                      }
                      Je[0] = Q.handleText(Je[0], fe.state);
                      break;
                    case t.OPS.showSpacedText:
                      if (!fe.state.font) {
                        Q.ensureStateFont(fe.state);
                        continue;
                      }
                      var Ie = Je[0], Ee = [], st = Ie.length, Qe = fe.state;
                      for (Ae = 0; Ae < st; ++Ae) {
                        const Xe = Ie[Ae];
                        typeof Xe == "string" ? Array.prototype.push.apply(Ee, Q.handleText(Xe, Qe)) : typeof Xe == "number" && Ee.push(Xe);
                      }
                      Je[0] = Ee, mt = t.OPS.showText;
                      break;
                    case t.OPS.nextLineShowText:
                      if (!fe.state.font) {
                        Q.ensureStateFont(fe.state);
                        continue;
                      }
                      se.addOp(t.OPS.nextLine), Je[0] = Q.handleText(Je[0], fe.state), mt = t.OPS.showText;
                      break;
                    case t.OPS.nextLineSetSpacingShowText:
                      if (!fe.state.font) {
                        Q.ensureStateFont(fe.state);
                        continue;
                      }
                      se.addOp(t.OPS.nextLine), se.addOp(t.OPS.setWordSpacing, [Je.shift()]), se.addOp(t.OPS.setCharSpacing, [Je.shift()]), Je[0] = Q.handleText(Je[0], fe.state), mt = t.OPS.showText;
                      break;
                    case t.OPS.setTextRenderingMode:
                      fe.state.textRenderingMode = Je[0];
                      break;
                    case t.OPS.setFillColorSpace: {
                      const Xe = b.ColorSpace.getCached(Je[0], E, ee);
                      if (Xe) {
                        fe.state.fillColorSpace = Xe;
                        continue;
                      }
                      ke(Q.parseColorSpace({
                        cs: Je[0],
                        resources: ne,
                        localColorSpaceCache: ee
                      }).then(function(Ct) {
                        Ct && (fe.state.fillColorSpace = Ct);
                      }));
                      return;
                    }
                    case t.OPS.setStrokeColorSpace: {
                      const Xe = b.ColorSpace.getCached(Je[0], E, ee);
                      if (Xe) {
                        fe.state.strokeColorSpace = Xe;
                        continue;
                      }
                      ke(Q.parseColorSpace({
                        cs: Je[0],
                        resources: ne,
                        localColorSpaceCache: ee
                      }).then(function(Ct) {
                        Ct && (fe.state.strokeColorSpace = Ct);
                      }));
                      return;
                    }
                    case t.OPS.setFillColor:
                      ve = fe.state.fillColorSpace, Je = ve.getRgb(Je, 0), mt = t.OPS.setFillRGBColor;
                      break;
                    case t.OPS.setStrokeColor:
                      ve = fe.state.strokeColorSpace, Je = ve.getRgb(Je, 0), mt = t.OPS.setStrokeRGBColor;
                      break;
                    case t.OPS.setFillGray:
                      fe.state.fillColorSpace = b.ColorSpace.singletons.gray, Je = b.ColorSpace.singletons.gray.getRgb(Je, 0), mt = t.OPS.setFillRGBColor;
                      break;
                    case t.OPS.setStrokeGray:
                      fe.state.strokeColorSpace = b.ColorSpace.singletons.gray, Je = b.ColorSpace.singletons.gray.getRgb(Je, 0), mt = t.OPS.setStrokeRGBColor;
                      break;
                    case t.OPS.setFillCMYKColor:
                      fe.state.fillColorSpace = b.ColorSpace.singletons.cmyk, Je = b.ColorSpace.singletons.cmyk.getRgb(Je, 0), mt = t.OPS.setFillRGBColor;
                      break;
                    case t.OPS.setStrokeCMYKColor:
                      fe.state.strokeColorSpace = b.ColorSpace.singletons.cmyk, Je = b.ColorSpace.singletons.cmyk.getRgb(Je, 0), mt = t.OPS.setStrokeRGBColor;
                      break;
                    case t.OPS.setFillRGBColor:
                      fe.state.fillColorSpace = b.ColorSpace.singletons.rgb, Je = b.ColorSpace.singletons.rgb.getRgb(Je, 0);
                      break;
                    case t.OPS.setStrokeRGBColor:
                      fe.state.strokeColorSpace = b.ColorSpace.singletons.rgb, Je = b.ColorSpace.singletons.rgb.getRgb(Je, 0);
                      break;
                    case t.OPS.setFillColorN:
                      if (ve = fe.state.fillColorSpace, ve.name === "Pattern") {
                        ke(Q.handleColorN(se, t.OPS.setFillColorN, Je, ve, ue, ne, K, ee, I, H));
                        return;
                      }
                      Je = ve.getRgb(Je, 0), mt = t.OPS.setFillRGBColor;
                      break;
                    case t.OPS.setStrokeColorN:
                      if (ve = fe.state.strokeColorSpace, ve.name === "Pattern") {
                        ke(Q.handleColorN(se, t.OPS.setStrokeColorN, Je, ve, ue, ne, K, ee, I, H));
                        return;
                      }
                      Je = ve.getRgb(Je, 0), mt = t.OPS.setStrokeRGBColor;
                      break;
                    case t.OPS.shadingFill:
                      var ct = ne.get("Shading");
                      if (!ct)
                        throw new t.FormatError("No shading resource found");
                      var xt = ct.get(Je[0].name);
                      if (!xt)
                        throw new t.FormatError("No shading object found");
                      Je = [Q.parseShading({
                        shading: xt,
                        resources: ne,
                        localColorSpaceCache: ee,
                        localShadingPatternCache: H
                      })], mt = t.OPS.shadingFill;
                      break;
                    case t.OPS.setGState:
                      if (Ge = Je[0] instanceof v.Name, Ne = Je[0].name, Ge) {
                        const Xe = W.getByName(Ne);
                        if (Xe) {
                          Xe.length > 0 && se.addOp(t.OPS.setGState, [Xe]), Je = null;
                          continue;
                        }
                      }
                      ke(new Promise(function(Xe, Ct) {
                        if (!Ge)
                          throw new t.FormatError("GState must be referred to by name.");
                        const bt = ne.get("ExtGState");
                        if (!(bt instanceof v.Dict))
                          throw new t.FormatError("ExtGState should be a dictionary.");
                        const Pe = bt.get(Ne);
                        if (!(Pe instanceof v.Dict))
                          throw new t.FormatError("GState should be a dictionary.");
                        Q.setGState({
                          resources: ne,
                          gState: Pe,
                          operatorList: se,
                          cacheKey: Ne,
                          task: K,
                          stateManager: fe,
                          localGStateCache: W,
                          localColorSpaceCache: ee
                        }).then(Xe, Ct);
                      }).catch(function(Xe) {
                        if (!(Xe instanceof t.AbortException)) {
                          if (Q.options.ignoreErrors) {
                            Q.handler.send("UnsupportedFeature", {
                              featureId: t.UNSUPPORTED_FEATURES.errorExtGState
                            }), (0, t.warn)(`getOperatorList - ignoring ExtGState: "${Xe}".`);
                            return;
                          }
                          throw Xe;
                        }
                      }));
                      return;
                    case t.OPS.moveTo:
                    case t.OPS.lineTo:
                    case t.OPS.curveTo:
                    case t.OPS.curveTo2:
                    case t.OPS.curveTo3:
                    case t.OPS.closePath:
                    case t.OPS.rectangle:
                      Q.buildPath(se, mt, Je, te);
                      continue;
                    case t.OPS.markPoint:
                    case t.OPS.markPointProps:
                    case t.OPS.beginCompat:
                    case t.OPS.endCompat:
                      continue;
                    case t.OPS.beginMarkedContentProps:
                      if (!(Je[0] instanceof v.Name)) {
                        (0, t.warn)(`Expected name for beginMarkedContentProps arg0=${Je[0]}`);
                        continue;
                      }
                      if (Je[0].name === "OC") {
                        ke(Q.parseMarkedContentProps(Je[1], ne).then((Xe) => {
                          se.addOp(t.OPS.beginMarkedContentProps, ["OC", Xe]);
                        }).catch((Xe) => {
                          if (!(Xe instanceof t.AbortException)) {
                            if (Q.options.ignoreErrors) {
                              Q.handler.send("UnsupportedFeature", {
                                featureId: t.UNSUPPORTED_FEATURES.errorMarkedContent
                              }), (0, t.warn)(`getOperatorList - ignoring beginMarkedContentProps: "${Xe}".`);
                              return;
                            }
                            throw Xe;
                          }
                        }));
                        return;
                      }
                      Je = [Je[0].name, Je[1] instanceof v.Dict ? Je[1].get("MCID") : null];
                      break;
                    case t.OPS.beginMarkedContent:
                    case t.OPS.endMarkedContent:
                    default:
                      if (Je !== null) {
                        for (Ae = 0, Te = Je.length; Ae < Te && !(Je[Ae] instanceof v.Dict); Ae++)
                          ;
                        if (Ae < Te) {
                          (0, t.warn)("getOperatorList - ignoring operator: " + mt);
                          continue;
                        }
                      }
                  }
                  se.addOp(mt, Je);
                }
                if (De) {
                  ke(_);
                  return;
                }
                xe(), Se();
              }).catch((Fe) => {
                if (!(Fe instanceof t.AbortException)) {
                  if (this.options.ignoreErrors) {
                    this.handler.send("UnsupportedFeature", {
                      featureId: t.UNSUPPORTED_FEATURES.errorOperatorList
                    }), (0, t.warn)(`getOperatorList - ignoring errors during "${K.name}" task: "${Fe}".`), xe();
                    return;
                  }
                  throw Fe;
                }
              });
            }
            getTextContent({
              stream: L,
              task: K,
              resources: ne,
              stateManager: se = null,
              combineTextItems: q = !1,
              includeMarkedContent: N = !1,
              sink: Q,
              seenStyles: E = /* @__PURE__ */ new Set(),
              viewBox: te
            }) {
              ne = ne || v.Dict.empty, se = se || new G(new Z());
              const oe = (0, d.getNormalizedUnicodes)(), ee = {
                items: [],
                styles: /* @__PURE__ */ Object.create(null)
              }, W = {
                initialized: !1,
                str: [],
                totalWidth: 0,
                totalHeight: 0,
                width: 0,
                height: 0,
                vertical: !1,
                prevTransform: null,
                textAdvanceScale: 0,
                spaceInFlowMin: 0,
                spaceInFlowMax: 0,
                trackingSpaceMin: 1 / 0,
                negativeSpaceMax: -1 / 0,
                notASpace: -1 / 0,
                transform: null,
                fontName: null,
                hasEOL: !1
              }, I = [" ", " "];
              let H = 0;
              function ie(Xe) {
                const Ct = (H + 1) % 2, bt = I[H] !== " " && I[Ct] === " ";
                return I[H] = Xe, H = Ct, bt;
              }
              function ue() {
                I[0] = I[1] = " ", H = 0;
              }
              const fe = 0.1, de = 0.03, pe = -0.2, xe = 0.1, Fe = 0.6, Se = this, Ce = this.xref, ke = [];
              let ye = null;
              const De = new l.LocalImageCache(), Ae = new l.LocalGStateCache(), Te = new z(L, Ce, se);
              let ve;
              function Ne() {
                const Xe = ve.font, Ct = [ve.fontSize * ve.textHScale, 0, 0, ve.fontSize, 0, ve.textRise];
                if (Xe.isType3Font && (ve.fontSize <= 1 || Xe.isCharBBox) && !(0, t.isArrayEqual)(ve.fontMatrix, t.FONT_IDENTITY_MATRIX)) {
                  const bt = Xe.bbox[3] - Xe.bbox[1];
                  bt > 0 && (Ct[3] *= bt * ve.fontMatrix[3]);
                }
                return t.Util.transform(ve.ctm, t.Util.transform(ve.textMatrix, Ct));
              }
              function Ge() {
                if (W.initialized)
                  return W;
                const Xe = ve.font, Ct = Xe.loadedName;
                E.has(Ct) || (E.add(Ct), ee.styles[Ct] = {
                  fontFamily: Xe.fallbackName,
                  ascent: Xe.ascent,
                  descent: Xe.descent,
                  vertical: Xe.vertical
                }), W.fontName = Ct;
                const bt = W.transform = Ne();
                Xe.vertical ? (W.width = W.totalWidth = Math.hypot(bt[0], bt[1]), W.height = W.totalHeight = 0, W.vertical = !0) : (W.width = W.totalWidth = 0, W.height = W.totalHeight = Math.hypot(bt[2], bt[3]), W.vertical = !1);
                const Pe = Math.hypot(ve.textLineMatrix[0], ve.textLineMatrix[1]), qe = Math.hypot(ve.ctm[0], ve.ctm[1]);
                return W.textAdvanceScale = qe * Pe, W.trackingSpaceMin = ve.fontSize * fe, W.notASpace = ve.fontSize * de, W.negativeSpaceMax = ve.fontSize * pe, W.spaceInFlowMin = ve.fontSize * xe, W.spaceInFlowMax = ve.fontSize * Fe, W.hasEOL = !1, W.initialized = !0, W;
              }
              function it() {
                if (!W.initialized)
                  return;
                const Xe = Math.hypot(ve.textLineMatrix[0], ve.textLineMatrix[1]), bt = Math.hypot(ve.ctm[0], ve.ctm[1]) * Xe;
                bt !== W.textAdvanceScale && (W.vertical ? (W.totalHeight += W.height * W.textAdvanceScale, W.height = 0) : (W.totalWidth += W.width * W.textAdvanceScale, W.width = 0), W.textAdvanceScale = bt);
              }
              function Me(Xe) {
                const Ct = Xe.str.join(""), bt = (0, O.bidi)(Ct, -1, Xe.vertical);
                return {
                  str: bt.str,
                  dir: bt.dir,
                  width: Math.abs(Xe.totalWidth),
                  height: Math.abs(Xe.totalHeight),
                  transform: Xe.transform,
                  fontName: Xe.fontName,
                  hasEOL: Xe.hasEOL
                };
              }
              function Ie(Xe, Ct) {
                return Se.loadFont(Xe, Ct, ne).then(function(bt) {
                  return bt.font.isType3Font ? bt.loadType3Data(Se, ne, K).catch(function() {
                  }).then(function() {
                    return bt;
                  }) : bt;
                }).then(function(bt) {
                  ve.font = bt.font, ve.fontMatrix = bt.font.fontMatrix || t.FONT_IDENTITY_MATRIX;
                });
              }
              function Ee(Xe, Ct, bt) {
                const Pe = Math.hypot(bt[0], bt[1]);
                return [(bt[0] * Xe + bt[1] * Ct) / Pe, (bt[2] * Xe + bt[3] * Ct) / Pe];
              }
              function st() {
                const Xe = Ne();
                let Ct = Xe[4], bt = Xe[5];
                const Pe = Ct - te[0], qe = bt - te[1];
                if (Pe < 0 || Pe > te[2] || qe < 0 || qe > te[3])
                  return !1;
                if (!q || !ve.font || !W.prevTransform)
                  return !0;
                let ot = W.prevTransform[4], lt = W.prevTransform[5];
                if (ot === Ct && lt === bt)
                  return !0;
                let Ut = -1;
                switch (Xe[0] && Xe[1] === 0 && Xe[2] === 0 ? Ut = Xe[0] > 0 ? 0 : 180 : Xe[1] && Xe[0] === 0 && Xe[3] === 0 && (Ut = Xe[1] > 0 ? 90 : 270), Ut) {
                  case 0:
                    break;
                  case 90:
                    [Ct, bt] = [bt, Ct], [ot, lt] = [lt, ot];
                    break;
                  case 180:
                    [Ct, bt, ot, lt] = [-Ct, -bt, -ot, -lt];
                    break;
                  case 270:
                    [Ct, bt] = [-bt, -Ct], [ot, lt] = [-lt, -ot];
                    break;
                  default:
                    [Ct, bt] = Ee(Ct, bt, Xe), [ot, lt] = Ee(ot, lt, W.prevTransform);
                }
                if (ve.font.vertical) {
                  const at = (lt - bt) / W.textAdvanceScale, nt = Ct - ot, ft = Math.sign(W.height);
                  return at < ft * W.negativeSpaceMax ? Math.abs(nt) > 0.5 * W.width ? (ct(), !0) : (ue(), Je(), !0) : Math.abs(nt) > W.width ? (ct(), !0) : (at <= ft * W.notASpace && ue(), at <= ft * W.trackingSpaceMin ? W.height += at : xt(at, W.prevTransform, ft) || (W.str.length === 0 ? (ue(), ee.items.push({
                    str: " ",
                    dir: "ltr",
                    width: 0,
                    height: Math.abs(at),
                    transform: W.prevTransform,
                    fontName: W.fontName,
                    hasEOL: !1
                  })) : W.height += at), !0);
                }
                const Nt = (Ct - ot) / W.textAdvanceScale, Ve = bt - lt, je = Math.sign(W.width);
                return Nt < je * W.negativeSpaceMax ? Math.abs(Ve) > 0.5 * W.height ? (ct(), !0) : (ue(), Je(), !0) : Math.abs(Ve) > W.height ? (ct(), !0) : (Nt <= je * W.notASpace && ue(), Nt <= je * W.trackingSpaceMin ? W.width += Nt : xt(Nt, W.prevTransform, je) || (W.str.length === 0 ? (ue(), ee.items.push({
                  str: " ",
                  dir: "ltr",
                  width: Math.abs(Nt),
                  height: 0,
                  transform: W.prevTransform,
                  fontName: W.fontName,
                  hasEOL: !1
                })) : W.width += Nt), !0);
              }
              function Qe({
                chars: Xe,
                extraSpacing: Ct
              }) {
                const bt = ve.font;
                if (!Xe) {
                  const ot = ve.charSpacing + Ct;
                  ot && (bt.vertical ? ve.translateTextMatrix(0, -ot) : ve.translateTextMatrix(ot * ve.textHScale, 0));
                  return;
                }
                const Pe = bt.charsToGlyphs(Xe), qe = ve.fontMatrix[0] * ve.fontSize;
                for (let ot = 0, lt = Pe.length; ot < lt; ot++) {
                  const Ut = Pe[ot];
                  if (Ut.isInvisibleFormatMark)
                    continue;
                  let Nt = ve.charSpacing + (ot + 1 === lt ? Ct : 0), Ve = Ut.width;
                  bt.vertical && (Ve = Ut.vmetric ? Ut.vmetric[0] : -Ve);
                  let je = Ve * qe;
                  if (Ut.isWhitespace) {
                    bt.vertical ? (Nt += -je + ve.wordSpacing, ve.translateTextMatrix(0, -Nt)) : (Nt += je + ve.wordSpacing, ve.translateTextMatrix(Nt * ve.textHScale, 0)), ie(" ");
                    continue;
                  }
                  if (!st())
                    continue;
                  const at = Ge();
                  Ut.isZeroWidthDiacritic && (je = 0), bt.vertical ? (ve.translateTextMatrix(0, je), je = Math.abs(je), at.height += je) : (je *= ve.textHScale, ve.translateTextMatrix(je, 0), at.width += je), je && (at.prevTransform = Ne());
                  let nt = Ut.unicode;
                  nt = oe[nt] || nt, nt = (0, d.reverseIfRtl)(nt), ie(nt) && at.str.push(" "), at.str.push(nt), Nt && (bt.vertical ? ve.translateTextMatrix(0, -Nt) : ve.translateTextMatrix(Nt * ve.textHScale, 0));
                }
              }
              function ct() {
                ue(), W.initialized ? (W.hasEOL = !0, Je()) : ee.items.push({
                  str: "",
                  dir: "ltr",
                  width: 0,
                  height: 0,
                  transform: Ne(),
                  fontName: ve.font.loadedName,
                  hasEOL: !0
                });
              }
              function xt(Xe, Ct, bt) {
                if (bt * W.spaceInFlowMin <= Xe && Xe <= bt * W.spaceInFlowMax)
                  return W.initialized && (ue(), W.str.push(" ")), !1;
                const Pe = W.fontName;
                let qe = 0;
                return W.vertical && (qe = Xe, Xe = 0), Je(), ue(), ee.items.push({
                  str: " ",
                  dir: "ltr",
                  width: Math.abs(Xe),
                  height: Math.abs(qe),
                  transform: Ct || Ne(),
                  fontName: Pe,
                  hasEOL: !1
                }), !0;
              }
              function Je() {
                !W.initialized || !W.str || (W.vertical ? W.totalHeight += W.height * W.textAdvanceScale : W.totalWidth += W.width * W.textAdvanceScale, ee.items.push(Me(W)), W.initialized = !1, W.str.length = 0);
              }
              function mt(Xe = !1) {
                const Ct = ee.items.length;
                Ct !== 0 && (Xe && Ct < D || (Q.enqueue(ee, Ct), ee.items = [], ee.styles = /* @__PURE__ */ Object.create(null)));
              }
              const _t = new T();
              return new Promise(function Xe(Ct, bt) {
                const Pe = function(at) {
                  mt(!0), Promise.all([at, Q.ready]).then(function() {
                    try {
                      Xe(Ct, bt);
                    } catch (nt) {
                      bt(nt);
                    }
                  }, bt);
                };
                K.ensureNotTerminated(), _t.reset();
                const qe = {};
                let ot, lt = [];
                for (; !(ot = _t.check()) && (lt.length = 0, qe.args = lt, !!Te.read(qe)); ) {
                  ve = se.state;
                  const at = qe.fn;
                  switch (lt = qe.args, at | 0) {
                    case t.OPS.setFont:
                      var Ut = lt[0].name, Nt = lt[1];
                      if (ve.font && Ut === ve.fontName && Nt === ve.fontSize)
                        break;
                      Je(), ve.fontName = Ut, ve.fontSize = Nt, Pe(Ie(Ut, null));
                      return;
                    case t.OPS.setTextRise:
                      ve.textRise = lt[0];
                      break;
                    case t.OPS.setHScale:
                      ve.textHScale = lt[0] / 100;
                      break;
                    case t.OPS.setLeading:
                      ve.leading = lt[0];
                      break;
                    case t.OPS.moveText:
                      ve.translateTextLineMatrix(lt[0], lt[1]), ve.textMatrix = ve.textLineMatrix.slice();
                      break;
                    case t.OPS.setLeadingMoveText:
                      ve.leading = -lt[1], ve.translateTextLineMatrix(lt[0], lt[1]), ve.textMatrix = ve.textLineMatrix.slice();
                      break;
                    case t.OPS.nextLine:
                      ve.carriageReturn();
                      break;
                    case t.OPS.setTextMatrix:
                      ve.setTextMatrix(lt[0], lt[1], lt[2], lt[3], lt[4], lt[5]), ve.setTextLineMatrix(lt[0], lt[1], lt[2], lt[3], lt[4], lt[5]), it();
                      break;
                    case t.OPS.setCharSpacing:
                      ve.charSpacing = lt[0];
                      break;
                    case t.OPS.setWordSpacing:
                      ve.wordSpacing = lt[0];
                      break;
                    case t.OPS.beginText:
                      ve.textMatrix = t.IDENTITY_MATRIX.slice(), ve.textLineMatrix = t.IDENTITY_MATRIX.slice();
                      break;
                    case t.OPS.showSpacedText:
                      if (!se.state.font) {
                        Se.ensureStateFont(se.state);
                        continue;
                      }
                      const nt = (ve.font.vertical ? 1 : -1) * ve.fontSize / 1e3, ft = lt[0];
                      for (let yt = 0, dt = ft.length; yt < dt - 1; yt++) {
                        const wt = ft[yt];
                        if (typeof wt == "string")
                          ke.push(wt);
                        else if (typeof wt == "number" && wt !== 0) {
                          const Dt = ke.join("");
                          ke.length = 0, Qe({
                            chars: Dt,
                            extraSpacing: wt * nt
                          });
                        }
                      }
                      const Tt = ft.at(-1);
                      if (typeof Tt == "string" && ke.push(Tt), ke.length > 0) {
                        const yt = ke.join("");
                        ke.length = 0, Qe({
                          chars: yt,
                          extraSpacing: 0
                        });
                      }
                      break;
                    case t.OPS.showText:
                      if (!se.state.font) {
                        Se.ensureStateFont(se.state);
                        continue;
                      }
                      Qe({
                        chars: lt[0],
                        extraSpacing: 0
                      });
                      break;
                    case t.OPS.nextLineShowText:
                      if (!se.state.font) {
                        Se.ensureStateFont(se.state);
                        continue;
                      }
                      ve.carriageReturn(), Qe({
                        chars: lt[0],
                        extraSpacing: 0
                      });
                      break;
                    case t.OPS.nextLineSetSpacingShowText:
                      if (!se.state.font) {
                        Se.ensureStateFont(se.state);
                        continue;
                      }
                      ve.wordSpacing = lt[0], ve.charSpacing = lt[1], ve.carriageReturn(), Qe({
                        chars: lt[2],
                        extraSpacing: 0
                      });
                      break;
                    case t.OPS.paintXObject:
                      Je(), ye || (ye = ne.get("XObject") || v.Dict.empty);
                      var Ve = lt[0] instanceof v.Name, je = lt[0].name;
                      if (Ve && De.getByName(je))
                        break;
                      Pe(new Promise(function(yt, dt) {
                        if (!Ve)
                          throw new t.FormatError("XObject must be referred to by name.");
                        let wt = ye.getRaw(je);
                        if (wt instanceof v.Ref) {
                          if (De.getByRef(wt)) {
                            yt();
                            return;
                          }
                          if (Se.globalImageCache.getData(wt, Se.pageIndex)) {
                            yt();
                            return;
                          }
                          wt = Ce.fetch(wt);
                        }
                        if (!(wt instanceof w.BaseStream))
                          throw new t.FormatError("XObject should be a stream");
                        const Dt = wt.dict.get("Subtype");
                        if (!(Dt instanceof v.Name))
                          throw new t.FormatError("XObject should have a Name subtype");
                        if (Dt.name !== "Form") {
                          De.set(je, wt.dict.objId, !0), yt();
                          return;
                        }
                        const jt = se.state.clone(), Bt = new G(jt), kt = wt.dict.getArray("Matrix");
                        Array.isArray(kt) && kt.length === 6 && Bt.transform(kt), mt();
                        const Ue = {
                          enqueueInvoked: !1,
                          enqueue(We, rt) {
                            this.enqueueInvoked = !0, Q.enqueue(We, rt);
                          },
                          get desiredSize() {
                            return Q.desiredSize;
                          },
                          get ready() {
                            return Q.ready;
                          }
                        };
                        Se.getTextContent({
                          stream: wt,
                          task: K,
                          resources: wt.dict.get("Resources") || ne,
                          stateManager: Bt,
                          combineTextItems: q,
                          includeMarkedContent: N,
                          sink: Ue,
                          seenStyles: E,
                          viewBox: te
                        }).then(function() {
                          Ue.enqueueInvoked || De.set(je, wt.dict.objId, !0), yt();
                        }, dt);
                      }).catch(function(yt) {
                        if (!(yt instanceof t.AbortException)) {
                          if (Se.options.ignoreErrors) {
                            (0, t.warn)(`getTextContent - ignoring XObject: "${yt}".`);
                            return;
                          }
                          throw yt;
                        }
                      }));
                      return;
                    case t.OPS.setGState:
                      if (Ve = lt[0] instanceof v.Name, je = lt[0].name, Ve && Ae.getByName(je))
                        break;
                      Pe(new Promise(function(yt, dt) {
                        if (!Ve)
                          throw new t.FormatError("GState must be referred to by name.");
                        const wt = ne.get("ExtGState");
                        if (!(wt instanceof v.Dict))
                          throw new t.FormatError("ExtGState should be a dictionary.");
                        const Dt = wt.get(je);
                        if (!(Dt instanceof v.Dict))
                          throw new t.FormatError("GState should be a dictionary.");
                        const jt = Dt.get("Font");
                        if (!jt) {
                          Ae.set(je, Dt.objId, !0), yt();
                          return;
                        }
                        Je(), ve.fontName = null, ve.fontSize = jt[1], Ie(null, jt[0]).then(yt, dt);
                      }).catch(function(yt) {
                        if (!(yt instanceof t.AbortException)) {
                          if (Se.options.ignoreErrors) {
                            (0, t.warn)(`getTextContent - ignoring ExtGState: "${yt}".`);
                            return;
                          }
                          throw yt;
                        }
                      }));
                      return;
                    case t.OPS.beginMarkedContent:
                      Je(), N && ee.items.push({
                        type: "beginMarkedContent",
                        tag: lt[0] instanceof v.Name ? lt[0].name : null
                      });
                      break;
                    case t.OPS.beginMarkedContentProps:
                      if (Je(), N) {
                        let yt = null;
                        lt[1] instanceof v.Dict && (yt = lt[1].get("MCID")), ee.items.push({
                          type: "beginMarkedContentProps",
                          id: Number.isInteger(yt) ? `${Se.idFactory.getPageObjId()}_mcid${yt}` : null,
                          tag: lt[0] instanceof v.Name ? lt[0].name : null
                        });
                      }
                      break;
                    case t.OPS.endMarkedContent:
                      Je(), N && ee.items.push({
                        type: "endMarkedContent"
                      });
                      break;
                  }
                  if (ee.items.length >= Q.desiredSize) {
                    ot = !0;
                    break;
                  }
                }
                if (ot) {
                  Pe(_);
                  return;
                }
                Je(), mt(), Ct();
              }).catch((Xe) => {
                if (!(Xe instanceof t.AbortException)) {
                  if (this.options.ignoreErrors) {
                    (0, t.warn)(`getTextContent - ignoring errors during "${K.name}" task: "${Xe}".`), Je(), mt();
                    return;
                  }
                  throw Xe;
                }
              });
            }
            extractDataStructures(L, K, ne) {
              const se = this.xref;
              let q;
              const N = this.readToUnicode(ne.toUnicode || L.get("ToUnicode") || K.get("ToUnicode"));
              if (ne.composite) {
                const oe = L.get("CIDSystemInfo");
                oe instanceof v.Dict && (ne.cidSystemInfo = {
                  registry: (0, t.stringToPDFString)(oe.get("Registry")),
                  ordering: (0, t.stringToPDFString)(oe.get("Ordering")),
                  supplement: oe.get("Supplement")
                });
                try {
                  const ee = L.get("CIDToGIDMap");
                  ee instanceof w.BaseStream && (q = ee.getBytes());
                } catch (ee) {
                  if (!this.options.ignoreErrors)
                    throw ee;
                  (0, t.warn)(`extractDataStructures - ignoring CIDToGIDMap data: "${ee}".`);
                }
              }
              const Q = [];
              let E = null, te;
              if (L.has("Encoding")) {
                if (te = L.get("Encoding"), te instanceof v.Dict) {
                  if (E = te.get("BaseEncoding"), E = E instanceof v.Name ? E.name : null, te.has("Differences")) {
                    const oe = te.get("Differences");
                    let ee = 0;
                    for (let W = 0, I = oe.length; W < I; W++) {
                      const H = se.fetchIfRef(oe[W]);
                      if (typeof H == "number")
                        ee = H;
                      else if (H instanceof v.Name)
                        Q[ee++] = H.name;
                      else
                        throw new t.FormatError(`Invalid entry in 'Differences' array: ${H}`);
                    }
                  }
                } else if (te instanceof v.Name)
                  E = te.name;
                else {
                  const oe = "Encoding is not a Name nor a Dict";
                  if (!this.options.ignoreErrors)
                    throw new t.FormatError(oe);
                  (0, t.warn)(oe);
                }
                E !== "MacRomanEncoding" && E !== "MacExpertEncoding" && E !== "WinAnsiEncoding" && (E = null);
              }
              if (E)
                ne.defaultEncoding = (0, y.getEncoding)(E);
              else {
                const oe = !!(ne.flags & e.FontFlags.Symbolic), ee = !!(ne.flags & e.FontFlags.Nonsymbolic);
                te = y.StandardEncoding, ne.type === "TrueType" && !ee && (te = y.WinAnsiEncoding), oe && (te = y.MacRomanEncoding, (!ne.file || ne.isInternalFont) && (/Symbol/i.test(ne.name) ? te = y.SymbolSetEncoding : /Dingbats|Wingdings/i.test(ne.name) && (te = y.ZapfDingbatsEncoding))), ne.defaultEncoding = te;
              }
              return ne.differences = Q, ne.baseEncodingName = E, ne.hasEncoding = !!E || Q.length > 0, ne.dict = L, N.then((oe) => (ne.toUnicode = oe, this.buildToUnicode(ne))).then((oe) => (ne.toUnicode = oe, q && (ne.cidToGidMap = this.readCidToGidMap(q, oe)), ne));
            }
            _simpleFontToUnicode(L, K = !1) {
              (0, t.assert)(!L.composite, "Must be a simple font.");
              const ne = [], se = L.defaultEncoding.slice(), q = L.baseEncodingName, N = L.differences;
              for (const E in N) {
                const te = N[E];
                te !== ".notdef" && (se[E] = te);
              }
              const Q = (0, Y.getGlyphsUnicode)();
              for (const E in se) {
                let te = se[E];
                if (te !== "") {
                  if (Q[te] === void 0) {
                    let oe = 0;
                    switch (te[0]) {
                      case "G":
                        te.length === 3 && (oe = parseInt(te.substring(1), 16));
                        break;
                      case "g":
                        te.length === 5 && (oe = parseInt(te.substring(1), 16));
                        break;
                      case "C":
                      case "c":
                        if (te.length >= 3 && te.length <= 4) {
                          const W = te.substring(1);
                          if (K) {
                            oe = parseInt(W, 16);
                            break;
                          }
                          if (oe = +W, Number.isNaN(oe) && Number.isInteger(parseInt(W, 16)))
                            return this._simpleFontToUnicode(L, !0);
                        }
                        break;
                      default:
                        const ee = (0, d.getUnicodeForGlyph)(te, Q);
                        ee !== -1 && (oe = ee);
                    }
                    if (oe > 0 && oe <= 1114111 && Number.isInteger(oe)) {
                      if (q && oe === +E) {
                        const ee = (0, y.getEncoding)(q);
                        if (ee && (te = ee[E])) {
                          ne[E] = String.fromCharCode(Q[te]);
                          continue;
                        }
                      }
                      ne[E] = String.fromCodePoint(oe);
                    }
                    continue;
                  }
                  ne[E] = String.fromCharCode(Q[te]);
                }
              }
              return ne;
            }
            async buildToUnicode(L) {
              if (L.hasIncludedToUnicodeMap = !!L.toUnicode && L.toUnicode.length > 0, L.hasIncludedToUnicodeMap)
                return !L.composite && L.hasEncoding && (L.fallbackToUnicode = this._simpleFontToUnicode(L)), L.toUnicode;
              if (!L.composite)
                return new g.ToUnicodeMap(this._simpleFontToUnicode(L));
              if (L.composite && (L.cMap.builtInCMap && !(L.cMap instanceof a.IdentityCMap) || L.cidSystemInfo.registry === "Adobe" && (L.cidSystemInfo.ordering === "GB1" || L.cidSystemInfo.ordering === "CNS1" || L.cidSystemInfo.ordering === "Japan1" || L.cidSystemInfo.ordering === "Korea1"))) {
                const {
                  registry: K,
                  ordering: ne
                } = L.cidSystemInfo, se = v.Name.get(`${K}-${ne}-UCS2`), q = await a.CMapFactory.create({
                  encoding: se,
                  fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                  useCMap: null
                }), N = [];
                return L.cMap.forEach(function(Q, E) {
                  if (E > 65535)
                    throw new t.FormatError("Max size of CID is 65,535");
                  const te = q.lookup(E);
                  te && (N[Q] = String.fromCharCode((te.charCodeAt(0) << 8) + te.charCodeAt(1)));
                }), new g.ToUnicodeMap(N);
              }
              return new g.IdentityToUnicodeMap(L.firstChar, L.lastChar);
            }
            readToUnicode(L) {
              return L ? L instanceof v.Name ? a.CMapFactory.create({
                encoding: L,
                fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                useCMap: null
              }).then(function(K) {
                return K instanceof a.IdentityCMap ? new g.IdentityToUnicodeMap(0, 65535) : new g.ToUnicodeMap(K.getMap());
              }) : L instanceof w.BaseStream ? a.CMapFactory.create({
                encoding: L,
                fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                useCMap: null
              }).then(function(K) {
                if (K instanceof a.IdentityCMap)
                  return new g.IdentityToUnicodeMap(0, 65535);
                const ne = new Array(K.length);
                return K.forEach(function(se, q) {
                  if (typeof q == "number") {
                    ne[se] = String.fromCodePoint(q);
                    return;
                  }
                  const N = [];
                  for (let Q = 0; Q < q.length; Q += 2) {
                    const E = q.charCodeAt(Q) << 8 | q.charCodeAt(Q + 1);
                    if ((E & 63488) !== 55296) {
                      N.push(E);
                      continue;
                    }
                    Q += 2;
                    const te = q.charCodeAt(Q) << 8 | q.charCodeAt(Q + 1);
                    N.push(((E & 1023) << 10) + (te & 1023) + 65536);
                  }
                  ne[se] = String.fromCodePoint(...N);
                }), new g.ToUnicodeMap(ne);
              }, (K) => {
                if (K instanceof t.AbortException)
                  return null;
                if (this.options.ignoreErrors)
                  return this.handler.send("UnsupportedFeature", {
                    featureId: t.UNSUPPORTED_FEATURES.errorFontToUnicode
                  }), (0, t.warn)(`readToUnicode - ignoring ToUnicode data: "${K}".`), null;
                throw K;
              }) : Promise.resolve(null) : Promise.resolve(null);
            }
            readCidToGidMap(L, K) {
              const ne = [];
              for (let se = 0, q = L.length; se < q; se++) {
                const N = L[se++] << 8 | L[se], Q = se >> 1;
                N === 0 && !K.has(Q) || (ne[Q] = N);
              }
              return ne;
            }
            extractWidths(L, K, ne) {
              const se = this.xref;
              let q = [], N = 0;
              const Q = [];
              let E, te, oe, ee, W, I, H, ie;
              if (ne.composite) {
                if (N = L.has("DW") ? L.get("DW") : 1e3, ie = L.get("W"), ie)
                  for (te = 0, oe = ie.length; te < oe; te++)
                    if (I = se.fetchIfRef(ie[te++]), H = se.fetchIfRef(ie[te]), Array.isArray(H))
                      for (ee = 0, W = H.length; ee < W; ee++)
                        q[I++] = se.fetchIfRef(H[ee]);
                    else {
                      const de = se.fetchIfRef(ie[++te]);
                      for (ee = I; ee <= H; ee++)
                        q[ee] = de;
                    }
                if (ne.vertical) {
                  let de = L.getArray("DW2") || [880, -1e3];
                  if (E = [de[1], N * 0.5, de[0]], de = L.get("W2"), de)
                    for (te = 0, oe = de.length; te < oe; te++)
                      if (I = se.fetchIfRef(de[te++]), H = se.fetchIfRef(de[te]), Array.isArray(H))
                        for (ee = 0, W = H.length; ee < W; ee++)
                          Q[I++] = [se.fetchIfRef(H[ee++]), se.fetchIfRef(H[ee++]), se.fetchIfRef(H[ee])];
                      else {
                        const pe = [se.fetchIfRef(de[++te]), se.fetchIfRef(de[++te]), se.fetchIfRef(de[++te])];
                        for (ee = I; ee <= H; ee++)
                          Q[ee] = pe;
                      }
                }
              } else {
                const de = ne.firstChar;
                if (ie = L.get("Widths"), ie) {
                  for (ee = de, te = 0, oe = ie.length; te < oe; te++)
                    q[ee++] = se.fetchIfRef(ie[te]);
                  N = parseFloat(K.get("MissingWidth")) || 0;
                } else {
                  const pe = L.get("BaseFont");
                  if (pe instanceof v.Name) {
                    const xe = this.getBaseFontMetrics(pe.name);
                    q = this.buildCharCodeToWidth(xe.widths, ne), N = xe.defaultWidth;
                  }
                }
              }
              let ue = !0, fe = N;
              for (const de in q) {
                const pe = q[de];
                if (pe) {
                  if (!fe) {
                    fe = pe;
                    continue;
                  }
                  if (fe !== pe) {
                    ue = !1;
                    break;
                  }
                }
              }
              ue && (ne.flags |= e.FontFlags.FixedPitch), ne.defaultWidth = N, ne.widths = q, ne.defaultVMetrics = E, ne.vmetrics = Q;
            }
            isSerifFont(L) {
              const K = L.split("-")[0];
              return K in (0, c.getSerifFonts)() || K.search(/serif/gi) !== -1;
            }
            getBaseFontMetrics(L) {
              let K = 0, ne = /* @__PURE__ */ Object.create(null), se = !1, N = (0, c.getStdFontMap)()[L] || L;
              const Q = (0, X.getMetrics)();
              N in Q || (this.isSerifFont(L) ? N = "Times-Roman" : N = "Helvetica");
              const E = Q[N];
              return typeof E == "number" ? (K = E, se = !0) : ne = E(), {
                defaultWidth: K,
                monospace: se,
                widths: ne
              };
            }
            buildCharCodeToWidth(L, K) {
              const ne = /* @__PURE__ */ Object.create(null), se = K.differences, q = K.defaultEncoding;
              for (let N = 0; N < 256; N++) {
                if (N in se && L[se[N]]) {
                  ne[N] = L[se[N]];
                  continue;
                }
                if (N in q && L[q[N]]) {
                  ne[N] = L[q[N]];
                  continue;
                }
              }
              return ne;
            }
            preEvaluateFont(L) {
              const K = L;
              let ne = L.get("Subtype");
              if (!(ne instanceof v.Name))
                throw new t.FormatError("invalid font Subtype");
              let se = !1, q, N;
              if (ne.name === "Type0") {
                const oe = L.get("DescendantFonts");
                if (!oe)
                  throw new t.FormatError("Descendant fonts are not specified");
                if (L = Array.isArray(oe) ? this.xref.fetchIfRef(oe[0]) : oe, !(L instanceof v.Dict))
                  throw new t.FormatError("Descendant font is not a dictionary.");
                if (ne = L.get("Subtype"), !(ne instanceof v.Name))
                  throw new t.FormatError("invalid font Subtype");
                se = !0;
              }
              const Q = L.get("FirstChar") || 0, E = L.get("LastChar") || (se ? 65535 : 255), te = L.get("FontDescriptor");
              if (te) {
                q = new B.MurmurHash3_64();
                const oe = K.getRaw("Encoding");
                if (oe instanceof v.Name)
                  q.update(oe.name);
                else if (oe instanceof v.Ref)
                  q.update(oe.toString());
                else if (oe instanceof v.Dict) {
                  for (const W of oe.getRawValues())
                    if (W instanceof v.Name)
                      q.update(W.name);
                    else if (W instanceof v.Ref)
                      q.update(W.toString());
                    else if (Array.isArray(W)) {
                      const I = W.length, H = new Array(I);
                      for (let ie = 0; ie < I; ie++) {
                        const ue = W[ie];
                        ue instanceof v.Name ? H[ie] = ue.name : (typeof ue == "number" || ue instanceof v.Ref) && (H[ie] = ue.toString());
                      }
                      q.update(H.join());
                    }
                }
                if (q.update(`${Q}-${E}`), N = L.get("ToUnicode") || K.get("ToUnicode"), N instanceof w.BaseStream) {
                  const W = N.str || N, I = W.buffer ? new Uint8Array(W.buffer.buffer, 0, W.bufferLength) : new Uint8Array(W.bytes.buffer, W.start, W.end - W.start);
                  q.update(I);
                } else
                  N instanceof v.Name && q.update(N.name);
                const ee = L.get("Widths") || K.get("Widths");
                if (Array.isArray(ee)) {
                  const W = [];
                  for (const I of ee)
                    (typeof I == "number" || I instanceof v.Ref) && W.push(I.toString());
                  q.update(W.join());
                }
                if (se) {
                  q.update("compositeFont");
                  const W = L.get("W") || K.get("W");
                  if (Array.isArray(W)) {
                    const H = [];
                    for (const ie of W)
                      if (typeof ie == "number" || ie instanceof v.Ref)
                        H.push(ie.toString());
                      else if (Array.isArray(ie)) {
                        const ue = [];
                        for (const fe of ie)
                          (typeof fe == "number" || fe instanceof v.Ref) && ue.push(fe.toString());
                        H.push(`[${ue.join()}]`);
                      }
                    q.update(H.join());
                  }
                  const I = L.getRaw("CIDToGIDMap") || K.getRaw("CIDToGIDMap");
                  I instanceof v.Name ? q.update(I.name) : I instanceof v.Ref ? q.update(I.toString()) : I instanceof w.BaseStream && q.update(I.peekBytes());
                }
              }
              return {
                descriptor: te,
                dict: L,
                baseDict: K,
                composite: se,
                type: ne.name,
                firstChar: Q,
                lastChar: E,
                toUnicode: N,
                hash: q ? q.hexdigest() : ""
              };
            }
            async translateFont({
              descriptor: L,
              dict: K,
              baseDict: ne,
              composite: se,
              type: q,
              firstChar: N,
              lastChar: Q,
              toUnicode: E,
              cssFontInfo: te
            }) {
              const oe = q === "Type3";
              let ee;
              if (!L)
                if (oe)
                  L = new v.Dict(null), L.set("FontName", v.Name.get(q)), L.set("FontBBox", K.getArray("FontBBox") || [0, 0, 0, 0]);
                else {
                  let Se = K.get("BaseFont");
                  if (!(Se instanceof v.Name))
                    throw new t.FormatError("Base font is not specified");
                  Se = Se.name.replace(/[,_]/g, "-");
                  const Ce = this.getBaseFontMetrics(Se), ke = Se.split("-")[0], ye = (this.isSerifFont(ke) ? e.FontFlags.Serif : 0) | (Ce.monospace ? e.FontFlags.FixedPitch : 0) | ((0, c.getSymbolsFonts)()[ke] ? e.FontFlags.Symbolic : e.FontFlags.Nonsymbolic);
                  ee = {
                    type: q,
                    name: Se,
                    loadedName: ne.loadedName,
                    widths: Ce.widths,
                    defaultWidth: Ce.defaultWidth,
                    isSimulatedFlags: !0,
                    flags: ye,
                    firstChar: N,
                    lastChar: Q,
                    toUnicode: E,
                    xHeight: 0,
                    capHeight: 0,
                    italicAngle: 0,
                    isType3Font: oe
                  };
                  const De = K.get("Widths"), Ae = (0, c.getStandardFontName)(Se);
                  let Te = null;
                  return Ae && (ee.isStandardFont = !0, Te = await this.fetchStandardFontData(Ae), ee.isInternalFont = !!Te), this.extractDataStructures(K, K, ee).then((ve) => {
                    if (De) {
                      const Ne = [];
                      let Ge = N;
                      for (let it = 0, Me = De.length; it < Me; it++)
                        Ne[Ge++] = this.xref.fetchIfRef(De[it]);
                      ve.widths = Ne;
                    } else
                      ve.widths = this.buildCharCodeToWidth(Ce.widths, ve);
                    return new h.Font(Se, Te, ve);
                  });
                }
              let W = L.get("FontName"), I = K.get("BaseFont");
              if (typeof W == "string" && (W = v.Name.get(W)), typeof I == "string" && (I = v.Name.get(I)), !oe) {
                const Se = W && W.name, Ce = I && I.name;
                Se !== Ce && ((0, t.info)(`The FontDescriptor's FontName is "${Se}" but should be the same as the Font's BaseFont "${Ce}".`), Se && Ce && Ce.startsWith(Se) && (W = I));
              }
              if (W = W || I, !(W instanceof v.Name))
                throw new t.FormatError("invalid font name");
              let H, ie, ue, fe, de;
              try {
                H = L.get("FontFile", "FontFile2", "FontFile3");
              } catch (Se) {
                if (!this.options.ignoreErrors)
                  throw Se;
                (0, t.warn)(`translateFont - fetching "${W.name}" font file: "${Se}".`), H = new u.NullStream();
              }
              let pe = !1, xe = !1, Fe = null;
              if (H) {
                if (H.dict) {
                  const Se = H.dict.get("Subtype");
                  Se instanceof v.Name && (ie = Se.name), ue = H.dict.get("Length1"), fe = H.dict.get("Length2"), de = H.dict.get("Length3");
                }
              } else if (te) {
                const Se = (0, p.getXfaFontName)(W.name);
                Se && (te.fontFamily = `${te.fontFamily}-PdfJS-XFA`, te.metrics = Se.metrics || null, Fe = Se.factors || null, H = await this.fetchStandardFontData(Se.name), xe = !!H, ne = K = (0, p.getXfaFontDict)(W.name), se = !0);
              } else if (!oe) {
                const Se = (0, c.getStandardFontName)(W.name);
                Se && (pe = !0, H = await this.fetchStandardFontData(Se), xe = !!H);
              }
              if (ee = {
                type: q,
                name: W.name,
                subtype: ie,
                file: H,
                length1: ue,
                length2: fe,
                length3: de,
                isStandardFont: pe,
                isInternalFont: xe,
                loadedName: ne.loadedName,
                composite: se,
                fixedPitch: !1,
                fontMatrix: K.getArray("FontMatrix") || t.FONT_IDENTITY_MATRIX,
                firstChar: N,
                lastChar: Q,
                toUnicode: E,
                bbox: L.getArray("FontBBox") || K.getArray("FontBBox"),
                ascent: L.get("Ascent"),
                descent: L.get("Descent"),
                xHeight: L.get("XHeight") || 0,
                capHeight: L.get("CapHeight") || 0,
                flags: L.get("Flags"),
                italicAngle: L.get("ItalicAngle") || 0,
                isType3Font: oe,
                cssFontInfo: te,
                scaleFactors: Fe
              }, se) {
                const Se = ne.get("Encoding");
                Se instanceof v.Name && (ee.cidEncoding = Se.name);
                const Ce = await a.CMapFactory.create({
                  encoding: Se,
                  fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                  useCMap: null
                });
                ee.cMap = Ce, ee.vertical = ee.cMap.vertical;
              }
              return this.extractDataStructures(K, ne, ee).then((Se) => (this.extractWidths(K, L, Se), new h.Font(W.name, H, Se)));
            }
            static buildFontPaths(L, K, ne, se) {
              function q(N) {
                const Q = `${L.loadedName}_path_${N}`;
                try {
                  if (L.renderer.hasBuiltPath(N))
                    return;
                  ne.send("commonobj", [Q, "FontPath", L.renderer.getPathJs(N)]);
                } catch (E) {
                  if (se.ignoreErrors) {
                    ne.send("UnsupportedFeature", {
                      featureId: t.UNSUPPORTED_FEATURES.errorFontBuildPath
                    }), (0, t.warn)(`buildFontPaths - ignoring ${Q} glyph: "${E}".`);
                    return;
                  }
                  throw E;
                }
              }
              for (const N of K) {
                q(N.fontChar);
                const Q = N.accent;
                Q && Q.fontChar && q(Q.fontChar);
              }
            }
            static get fallbackFontDict() {
              const L = new v.Dict();
              return L.set("BaseFont", v.Name.get("PDFJS-FallbackFont")), L.set("Type", v.Name.get("FallbackType")), L.set("Subtype", v.Name.get("FallbackType")), L.set("Encoding", v.Name.get("WinAnsiEncoding")), (0, t.shadow)(this, "fallbackFontDict", L);
            }
          }
          o.PartialEvaluator = P;
          class M {
            constructor({
              loadedName: L,
              font: K,
              dict: ne,
              evaluatorOptions: se
            }) {
              this.loadedName = L, this.font = K, this.dict = ne, this._evaluatorOptions = se || x, this.type3Loaded = null, this.type3Dependencies = K.isType3Font ? /* @__PURE__ */ new Set() : null, this.sent = !1;
            }
            send(L) {
              this.sent || (this.sent = !0, L.send("commonobj", [this.loadedName, "Font", this.font.exportData(this._evaluatorOptions.fontExtraProperties)]));
            }
            fallback(L) {
              this.font.data && (this.font.disableFontFace = !0, P.buildFontPaths(this.font, this.font.glyphCacheValues, L, this._evaluatorOptions));
            }
            loadType3Data(L, K, ne) {
              if (this.type3Loaded)
                return this.type3Loaded;
              if (!this.font.isType3Font)
                throw new Error("Must be a Type3 font.");
              const se = L.clone({
                ignoreErrors: !1
              });
              se.parsingType3Font = !0;
              const q = new v.RefSet(L.type3FontRefs);
              this.dict.objId && !q.has(this.dict.objId) && q.put(this.dict.objId), se.type3FontRefs = q;
              const N = this.font, Q = this.type3Dependencies;
              let E = Promise.resolve();
              const te = this.dict.get("CharProcs"), oe = this.dict.get("Resources") || K, ee = /* @__PURE__ */ Object.create(null), W = t.Util.normalizeRect(N.bbox || [0, 0, 0, 0]), I = W[2] - W[0], H = W[3] - W[1], ie = Math.hypot(I, H);
              for (const ue of te.getKeys())
                E = E.then(() => {
                  const fe = te.get(ue), de = new U.OperatorList();
                  return se.getOperatorList({
                    stream: fe,
                    task: ne,
                    resources: oe,
                    operatorList: de
                  }).then(() => {
                    de.fnArray[0] === t.OPS.setCharWidthAndBounds && this._removeType3ColorOperators(de, ie), ee[ue] = de.getIR();
                    for (const pe of de.dependencies)
                      Q.add(pe);
                  }).catch(function(pe) {
                    (0, t.warn)(`Type3 font resource "${ue}" is not available.`);
                    const xe = new U.OperatorList();
                    ee[ue] = xe.getIR();
                  });
                });
              return this.type3Loaded = E.then(() => {
                N.charProcOperatorList = ee, this._bbox && (N.isCharBBox = !0, N.bbox = this._bbox);
              }), this.type3Loaded;
            }
            _removeType3ColorOperators(L, K = NaN) {
              const ne = t.Util.normalizeRect(L.argsArray[0].slice(2)), se = ne[2] - ne[0], q = ne[3] - ne[1], N = Math.hypot(se, q);
              se === 0 || q === 0 ? (L.fnArray.splice(0, 1), L.argsArray.splice(0, 1)) : (K === 0 || Math.round(N / K) >= 10) && (this._bbox || (this._bbox = [1 / 0, 1 / 0, -1 / 0, -1 / 0]), this._bbox[0] = Math.min(this._bbox[0], ne[0]), this._bbox[1] = Math.min(this._bbox[1], ne[1]), this._bbox[2] = Math.max(this._bbox[2], ne[2]), this._bbox[3] = Math.max(this._bbox[3], ne[3]));
              let Q = 0, E = L.length;
              for (; Q < E; ) {
                switch (L.fnArray[Q]) {
                  case t.OPS.setCharWidthAndBounds:
                    break;
                  case t.OPS.setStrokeColorSpace:
                  case t.OPS.setFillColorSpace:
                  case t.OPS.setStrokeColor:
                  case t.OPS.setStrokeColorN:
                  case t.OPS.setFillColor:
                  case t.OPS.setFillColorN:
                  case t.OPS.setStrokeGray:
                  case t.OPS.setFillGray:
                  case t.OPS.setStrokeRGBColor:
                  case t.OPS.setFillRGBColor:
                  case t.OPS.setStrokeCMYKColor:
                  case t.OPS.setFillCMYKColor:
                  case t.OPS.shadingFill:
                  case t.OPS.setRenderingIntent:
                    L.fnArray.splice(Q, 1), L.argsArray.splice(Q, 1), E--;
                    continue;
                  case t.OPS.setGState:
                    const [te] = L.argsArray[Q];
                    let oe = 0, ee = te.length;
                    for (; oe < ee; ) {
                      const [W] = te[oe];
                      switch (W) {
                        case "TR":
                        case "TR2":
                        case "HT":
                        case "BG":
                        case "BG2":
                        case "UCR":
                        case "UCR2":
                          te.splice(oe, 1), ee--;
                          continue;
                      }
                      oe++;
                    }
                    break;
                }
                Q++;
              }
            }
          }
          class G {
            constructor(L = new $()) {
              this.state = L, this.stateStack = [];
            }
            save() {
              const L = this.state;
              this.stateStack.push(this.state), this.state = L.clone();
            }
            restore() {
              const L = this.stateStack.pop();
              L && (this.state = L);
            }
            transform(L) {
              this.state.ctm = t.Util.transform(this.state.ctm, L);
            }
          }
          class Z {
            constructor() {
              this.ctm = new Float32Array(t.IDENTITY_MATRIX), this.fontName = null, this.fontSize = 0, this.font = null, this.fontMatrix = t.FONT_IDENTITY_MATRIX, this.textMatrix = t.IDENTITY_MATRIX.slice(), this.textLineMatrix = t.IDENTITY_MATRIX.slice(), this.charSpacing = 0, this.wordSpacing = 0, this.leading = 0, this.textHScale = 1, this.textRise = 0;
            }
            setTextMatrix(L, K, ne, se, q, N) {
              const Q = this.textMatrix;
              Q[0] = L, Q[1] = K, Q[2] = ne, Q[3] = se, Q[4] = q, Q[5] = N;
            }
            setTextLineMatrix(L, K, ne, se, q, N) {
              const Q = this.textLineMatrix;
              Q[0] = L, Q[1] = K, Q[2] = ne, Q[3] = se, Q[4] = q, Q[5] = N;
            }
            translateTextMatrix(L, K) {
              const ne = this.textMatrix;
              ne[4] = ne[0] * L + ne[2] * K + ne[4], ne[5] = ne[1] * L + ne[3] * K + ne[5];
            }
            translateTextLineMatrix(L, K) {
              const ne = this.textLineMatrix;
              ne[4] = ne[0] * L + ne[2] * K + ne[4], ne[5] = ne[1] * L + ne[3] * K + ne[5];
            }
            carriageReturn() {
              this.translateTextLineMatrix(0, -this.leading), this.textMatrix = this.textLineMatrix.slice();
            }
            clone() {
              const L = Object.create(this);
              return L.textMatrix = this.textMatrix.slice(), L.textLineMatrix = this.textLineMatrix.slice(), L.fontMatrix = this.fontMatrix.slice(), L;
            }
          }
          class $ {
            constructor() {
              this.ctm = new Float32Array(t.IDENTITY_MATRIX), this.font = null, this.textRenderingMode = t.TextRenderingMode.FILL, this.fillColorSpace = b.ColorSpace.singletons.gray, this.strokeColorSpace = b.ColorSpace.singletons.gray;
            }
            clone() {
              return Object.create(this);
            }
          }
          class z {
            static get opMap() {
              const L = (0, j.getLookupTableFactory)(function(K) {
                K.w = {
                  id: t.OPS.setLineWidth,
                  numArgs: 1,
                  variableArgs: !1
                }, K.J = {
                  id: t.OPS.setLineCap,
                  numArgs: 1,
                  variableArgs: !1
                }, K.j = {
                  id: t.OPS.setLineJoin,
                  numArgs: 1,
                  variableArgs: !1
                }, K.M = {
                  id: t.OPS.setMiterLimit,
                  numArgs: 1,
                  variableArgs: !1
                }, K.d = {
                  id: t.OPS.setDash,
                  numArgs: 2,
                  variableArgs: !1
                }, K.ri = {
                  id: t.OPS.setRenderingIntent,
                  numArgs: 1,
                  variableArgs: !1
                }, K.i = {
                  id: t.OPS.setFlatness,
                  numArgs: 1,
                  variableArgs: !1
                }, K.gs = {
                  id: t.OPS.setGState,
                  numArgs: 1,
                  variableArgs: !1
                }, K.q = {
                  id: t.OPS.save,
                  numArgs: 0,
                  variableArgs: !1
                }, K.Q = {
                  id: t.OPS.restore,
                  numArgs: 0,
                  variableArgs: !1
                }, K.cm = {
                  id: t.OPS.transform,
                  numArgs: 6,
                  variableArgs: !1
                }, K.m = {
                  id: t.OPS.moveTo,
                  numArgs: 2,
                  variableArgs: !1
                }, K.l = {
                  id: t.OPS.lineTo,
                  numArgs: 2,
                  variableArgs: !1
                }, K.c = {
                  id: t.OPS.curveTo,
                  numArgs: 6,
                  variableArgs: !1
                }, K.v = {
                  id: t.OPS.curveTo2,
                  numArgs: 4,
                  variableArgs: !1
                }, K.y = {
                  id: t.OPS.curveTo3,
                  numArgs: 4,
                  variableArgs: !1
                }, K.h = {
                  id: t.OPS.closePath,
                  numArgs: 0,
                  variableArgs: !1
                }, K.re = {
                  id: t.OPS.rectangle,
                  numArgs: 4,
                  variableArgs: !1
                }, K.S = {
                  id: t.OPS.stroke,
                  numArgs: 0,
                  variableArgs: !1
                }, K.s = {
                  id: t.OPS.closeStroke,
                  numArgs: 0,
                  variableArgs: !1
                }, K.f = {
                  id: t.OPS.fill,
                  numArgs: 0,
                  variableArgs: !1
                }, K.F = {
                  id: t.OPS.fill,
                  numArgs: 0,
                  variableArgs: !1
                }, K["f*"] = {
                  id: t.OPS.eoFill,
                  numArgs: 0,
                  variableArgs: !1
                }, K.B = {
                  id: t.OPS.fillStroke,
                  numArgs: 0,
                  variableArgs: !1
                }, K["B*"] = {
                  id: t.OPS.eoFillStroke,
                  numArgs: 0,
                  variableArgs: !1
                }, K.b = {
                  id: t.OPS.closeFillStroke,
                  numArgs: 0,
                  variableArgs: !1
                }, K["b*"] = {
                  id: t.OPS.closeEOFillStroke,
                  numArgs: 0,
                  variableArgs: !1
                }, K.n = {
                  id: t.OPS.endPath,
                  numArgs: 0,
                  variableArgs: !1
                }, K.W = {
                  id: t.OPS.clip,
                  numArgs: 0,
                  variableArgs: !1
                }, K["W*"] = {
                  id: t.OPS.eoClip,
                  numArgs: 0,
                  variableArgs: !1
                }, K.BT = {
                  id: t.OPS.beginText,
                  numArgs: 0,
                  variableArgs: !1
                }, K.ET = {
                  id: t.OPS.endText,
                  numArgs: 0,
                  variableArgs: !1
                }, K.Tc = {
                  id: t.OPS.setCharSpacing,
                  numArgs: 1,
                  variableArgs: !1
                }, K.Tw = {
                  id: t.OPS.setWordSpacing,
                  numArgs: 1,
                  variableArgs: !1
                }, K.Tz = {
                  id: t.OPS.setHScale,
                  numArgs: 1,
                  variableArgs: !1
                }, K.TL = {
                  id: t.OPS.setLeading,
                  numArgs: 1,
                  variableArgs: !1
                }, K.Tf = {
                  id: t.OPS.setFont,
                  numArgs: 2,
                  variableArgs: !1
                }, K.Tr = {
                  id: t.OPS.setTextRenderingMode,
                  numArgs: 1,
                  variableArgs: !1
                }, K.Ts = {
                  id: t.OPS.setTextRise,
                  numArgs: 1,
                  variableArgs: !1
                }, K.Td = {
                  id: t.OPS.moveText,
                  numArgs: 2,
                  variableArgs: !1
                }, K.TD = {
                  id: t.OPS.setLeadingMoveText,
                  numArgs: 2,
                  variableArgs: !1
                }, K.Tm = {
                  id: t.OPS.setTextMatrix,
                  numArgs: 6,
                  variableArgs: !1
                }, K["T*"] = {
                  id: t.OPS.nextLine,
                  numArgs: 0,
                  variableArgs: !1
                }, K.Tj = {
                  id: t.OPS.showText,
                  numArgs: 1,
                  variableArgs: !1
                }, K.TJ = {
                  id: t.OPS.showSpacedText,
                  numArgs: 1,
                  variableArgs: !1
                }, K["'"] = {
                  id: t.OPS.nextLineShowText,
                  numArgs: 1,
                  variableArgs: !1
                }, K['"'] = {
                  id: t.OPS.nextLineSetSpacingShowText,
                  numArgs: 3,
                  variableArgs: !1
                }, K.d0 = {
                  id: t.OPS.setCharWidth,
                  numArgs: 2,
                  variableArgs: !1
                }, K.d1 = {
                  id: t.OPS.setCharWidthAndBounds,
                  numArgs: 6,
                  variableArgs: !1
                }, K.CS = {
                  id: t.OPS.setStrokeColorSpace,
                  numArgs: 1,
                  variableArgs: !1
                }, K.cs = {
                  id: t.OPS.setFillColorSpace,
                  numArgs: 1,
                  variableArgs: !1
                }, K.SC = {
                  id: t.OPS.setStrokeColor,
                  numArgs: 4,
                  variableArgs: !0
                }, K.SCN = {
                  id: t.OPS.setStrokeColorN,
                  numArgs: 33,
                  variableArgs: !0
                }, K.sc = {
                  id: t.OPS.setFillColor,
                  numArgs: 4,
                  variableArgs: !0
                }, K.scn = {
                  id: t.OPS.setFillColorN,
                  numArgs: 33,
                  variableArgs: !0
                }, K.G = {
                  id: t.OPS.setStrokeGray,
                  numArgs: 1,
                  variableArgs: !1
                }, K.g = {
                  id: t.OPS.setFillGray,
                  numArgs: 1,
                  variableArgs: !1
                }, K.RG = {
                  id: t.OPS.setStrokeRGBColor,
                  numArgs: 3,
                  variableArgs: !1
                }, K.rg = {
                  id: t.OPS.setFillRGBColor,
                  numArgs: 3,
                  variableArgs: !1
                }, K.K = {
                  id: t.OPS.setStrokeCMYKColor,
                  numArgs: 4,
                  variableArgs: !1
                }, K.k = {
                  id: t.OPS.setFillCMYKColor,
                  numArgs: 4,
                  variableArgs: !1
                }, K.sh = {
                  id: t.OPS.shadingFill,
                  numArgs: 1,
                  variableArgs: !1
                }, K.BI = {
                  id: t.OPS.beginInlineImage,
                  numArgs: 0,
                  variableArgs: !1
                }, K.ID = {
                  id: t.OPS.beginImageData,
                  numArgs: 0,
                  variableArgs: !1
                }, K.EI = {
                  id: t.OPS.endInlineImage,
                  numArgs: 1,
                  variableArgs: !1
                }, K.Do = {
                  id: t.OPS.paintXObject,
                  numArgs: 1,
                  variableArgs: !1
                }, K.MP = {
                  id: t.OPS.markPoint,
                  numArgs: 1,
                  variableArgs: !1
                }, K.DP = {
                  id: t.OPS.markPointProps,
                  numArgs: 2,
                  variableArgs: !1
                }, K.BMC = {
                  id: t.OPS.beginMarkedContent,
                  numArgs: 1,
                  variableArgs: !1
                }, K.BDC = {
                  id: t.OPS.beginMarkedContentProps,
                  numArgs: 2,
                  variableArgs: !1
                }, K.EMC = {
                  id: t.OPS.endMarkedContent,
                  numArgs: 0,
                  variableArgs: !1
                }, K.BX = {
                  id: t.OPS.beginCompat,
                  numArgs: 0,
                  variableArgs: !1
                }, K.EX = {
                  id: t.OPS.endCompat,
                  numArgs: 0,
                  variableArgs: !1
                }, K.BM = null, K.BD = null, K.true = null, K.fa = null, K.fal = null, K.fals = null, K.false = null, K.nu = null, K.nul = null, K.null = null;
              });
              return (0, t.shadow)(this, "opMap", L());
            }
            static get MAX_INVALID_PATH_OPS() {
              return (0, t.shadow)(this, "MAX_INVALID_PATH_OPS", 10);
            }
            constructor(L, K, ne = new G()) {
              this.parser = new i.Parser({
                lexer: new i.Lexer(L, z.opMap),
                xref: K
              }), this.stateManager = ne, this.nonProcessedArgs = [], this._isPathOp = !1, this._numInvalidPathOPS = 0;
            }
            get savedStatesDepth() {
              return this.stateManager.stateStack.length;
            }
            read(L) {
              let K = L.args;
              for (; ; ) {
                const ne = this.parser.getObj();
                if (ne instanceof v.Cmd) {
                  const se = ne.cmd, q = z.opMap[se];
                  if (!q) {
                    (0, t.warn)(`Unknown command "${se}".`);
                    continue;
                  }
                  const N = q.id, Q = q.numArgs;
                  let E = K !== null ? K.length : 0;
                  if (this._isPathOp || (this._numInvalidPathOPS = 0), this._isPathOp = N >= t.OPS.moveTo && N <= t.OPS.endPath, q.variableArgs)
                    E > Q && (0, t.info)(`Command ${se}: expected [0, ${Q}] args, but received ${E} args.`);
                  else {
                    if (E !== Q) {
                      const te = this.nonProcessedArgs;
                      for (; E > Q; )
                        te.push(K.shift()), E--;
                      for (; E < Q && te.length !== 0; )
                        K === null && (K = []), K.unshift(te.pop()), E++;
                    }
                    if (E < Q) {
                      const te = `command ${se}: expected ${Q} args, but received ${E} args.`;
                      if (this._isPathOp && ++this._numInvalidPathOPS > z.MAX_INVALID_PATH_OPS)
                        throw new t.FormatError(`Invalid ${te}`);
                      (0, t.warn)(`Skipping ${te}`), K !== null && (K.length = 0);
                      continue;
                    }
                  }
                  return this.preprocessCommand(N, K), L.fn = N, L.args = K, !0;
                }
                if (ne === v.EOF)
                  return !1;
                if (ne !== null && (K === null && (K = []), K.push(ne), K.length > 33))
                  throw new t.FormatError("Too many arguments");
              }
            }
            preprocessCommand(L, K) {
              switch (L | 0) {
                case t.OPS.save:
                  this.stateManager.save();
                  break;
                case t.OPS.restore:
                  this.stateManager.restore();
                  break;
                case t.OPS.transform:
                  this.stateManager.transform(K);
                  break;
              }
            }
          }
          o.EvaluatorPreprocessor = z;
        },
        /* 16 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.IdentityCMap = o.CMapFactory = o.CMap = void 0;
          var t = F(2), a = F(5), v = F(7), h = F(17), e = F(6), y = F(10);
          const c = ["Adobe-GB1-UCS2", "Adobe-CNS1-UCS2", "Adobe-Japan1-UCS2", "Adobe-Korea1-UCS2", "78-EUC-H", "78-EUC-V", "78-H", "78-RKSJ-H", "78-RKSJ-V", "78-V", "78ms-RKSJ-H", "78ms-RKSJ-V", "83pv-RKSJ-H", "90ms-RKSJ-H", "90ms-RKSJ-V", "90msp-RKSJ-H", "90msp-RKSJ-V", "90pv-RKSJ-H", "90pv-RKSJ-V", "Add-H", "Add-RKSJ-H", "Add-RKSJ-V", "Add-V", "Adobe-CNS1-0", "Adobe-CNS1-1", "Adobe-CNS1-2", "Adobe-CNS1-3", "Adobe-CNS1-4", "Adobe-CNS1-5", "Adobe-CNS1-6", "Adobe-GB1-0", "Adobe-GB1-1", "Adobe-GB1-2", "Adobe-GB1-3", "Adobe-GB1-4", "Adobe-GB1-5", "Adobe-Japan1-0", "Adobe-Japan1-1", "Adobe-Japan1-2", "Adobe-Japan1-3", "Adobe-Japan1-4", "Adobe-Japan1-5", "Adobe-Japan1-6", "Adobe-Korea1-0", "Adobe-Korea1-1", "Adobe-Korea1-2", "B5-H", "B5-V", "B5pc-H", "B5pc-V", "CNS-EUC-H", "CNS-EUC-V", "CNS1-H", "CNS1-V", "CNS2-H", "CNS2-V", "ETHK-B5-H", "ETHK-B5-V", "ETen-B5-H", "ETen-B5-V", "ETenms-B5-H", "ETenms-B5-V", "EUC-H", "EUC-V", "Ext-H", "Ext-RKSJ-H", "Ext-RKSJ-V", "Ext-V", "GB-EUC-H", "GB-EUC-V", "GB-H", "GB-V", "GBK-EUC-H", "GBK-EUC-V", "GBK2K-H", "GBK2K-V", "GBKp-EUC-H", "GBKp-EUC-V", "GBT-EUC-H", "GBT-EUC-V", "GBT-H", "GBT-V", "GBTpc-EUC-H", "GBTpc-EUC-V", "GBpc-EUC-H", "GBpc-EUC-V", "H", "HKdla-B5-H", "HKdla-B5-V", "HKdlb-B5-H", "HKdlb-B5-V", "HKgccs-B5-H", "HKgccs-B5-V", "HKm314-B5-H", "HKm314-B5-V", "HKm471-B5-H", "HKm471-B5-V", "HKscs-B5-H", "HKscs-B5-V", "Hankaku", "Hiragana", "KSC-EUC-H", "KSC-EUC-V", "KSC-H", "KSC-Johab-H", "KSC-Johab-V", "KSC-V", "KSCms-UHC-H", "KSCms-UHC-HW-H", "KSCms-UHC-HW-V", "KSCms-UHC-V", "KSCpc-EUC-H", "KSCpc-EUC-V", "Katakana", "NWP-H", "NWP-V", "RKSJ-H", "RKSJ-V", "Roman", "UniCNS-UCS2-H", "UniCNS-UCS2-V", "UniCNS-UTF16-H", "UniCNS-UTF16-V", "UniCNS-UTF32-H", "UniCNS-UTF32-V", "UniCNS-UTF8-H", "UniCNS-UTF8-V", "UniGB-UCS2-H", "UniGB-UCS2-V", "UniGB-UTF16-H", "UniGB-UTF16-V", "UniGB-UTF32-H", "UniGB-UTF32-V", "UniGB-UTF8-H", "UniGB-UTF8-V", "UniJIS-UCS2-H", "UniJIS-UCS2-HW-H", "UniJIS-UCS2-HW-V", "UniJIS-UCS2-V", "UniJIS-UTF16-H", "UniJIS-UTF16-V", "UniJIS-UTF32-H", "UniJIS-UTF32-V", "UniJIS-UTF8-H", "UniJIS-UTF8-V", "UniJIS2004-UTF16-H", "UniJIS2004-UTF16-V", "UniJIS2004-UTF32-H", "UniJIS2004-UTF32-V", "UniJIS2004-UTF8-H", "UniJIS2004-UTF8-V", "UniJISPro-UCS2-HW-V", "UniJISPro-UCS2-V", "UniJISPro-UTF8-V", "UniJISX0213-UTF32-H", "UniJISX0213-UTF32-V", "UniJISX02132004-UTF32-H", "UniJISX02132004-UTF32-V", "UniKS-UCS2-H", "UniKS-UCS2-V", "UniKS-UTF16-H", "UniKS-UTF16-V", "UniKS-UTF32-H", "UniKS-UTF32-V", "UniKS-UTF8-H", "UniKS-UTF8-V", "V", "WP-Symbol"], d = 2 ** 24 - 1;
          class m {
            constructor(l = !1) {
              this.codespaceRanges = [[], [], [], []], this.numCodespaceRanges = 0, this._map = [], this.name = "", this.vertical = !1, this.useCMap = null, this.builtInCMap = l;
            }
            addCodespaceRange(l, u, w) {
              this.codespaceRanges[l - 1].push(u, w), this.numCodespaceRanges++;
            }
            mapCidRange(l, u, w) {
              if (u - l > d)
                throw new Error("mapCidRange - ignoring data above MAX_MAP_RANGE.");
              for (; l <= u; )
                this._map[l++] = w++;
            }
            mapBfRange(l, u, w) {
              if (u - l > d)
                throw new Error("mapBfRange - ignoring data above MAX_MAP_RANGE.");
              const O = w.length - 1;
              for (; l <= u; ) {
                this._map[l++] = w;
                const b = w.charCodeAt(O) + 1;
                if (b > 255) {
                  w = w.substring(0, O - 1) + String.fromCharCode(w.charCodeAt(O - 1) + 1) + "\0";
                  continue;
                }
                w = w.substring(0, O) + String.fromCharCode(b);
              }
            }
            mapBfRangeToArray(l, u, w) {
              if (u - l > d)
                throw new Error("mapBfRangeToArray - ignoring data above MAX_MAP_RANGE.");
              const O = w.length;
              let b = 0;
              for (; l <= u && b < O; )
                this._map[l] = w[b++], ++l;
            }
            mapOne(l, u) {
              this._map[l] = u;
            }
            lookup(l) {
              return this._map[l];
            }
            contains(l) {
              return this._map[l] !== void 0;
            }
            forEach(l) {
              const u = this._map, w = u.length;
              if (w <= 65536)
                for (let O = 0; O < w; O++)
                  u[O] !== void 0 && l(O, u[O]);
              else
                for (const O in u)
                  l(O, u[O]);
            }
            charCodeOf(l) {
              const u = this._map;
              if (u.length <= 65536)
                return u.indexOf(l);
              for (const w in u)
                if (u[w] === l)
                  return w | 0;
              return -1;
            }
            getMap() {
              return this._map;
            }
            readCharCode(l, u, w) {
              let O = 0;
              const b = this.codespaceRanges;
              for (let A = 0, Y = b.length; A < Y; A++) {
                O = (O << 8 | l.charCodeAt(u + A)) >>> 0;
                const j = b[A];
                for (let X = 0, B = j.length; X < B; ) {
                  const U = j[X++], k = j[X++];
                  if (O >= U && O <= k) {
                    w.charcode = O, w.length = A + 1;
                    return;
                  }
                }
              }
              w.charcode = 0, w.length = 1;
            }
            getCharCodeLength(l) {
              const u = this.codespaceRanges;
              for (let w = 0, O = u.length; w < O; w++) {
                const b = u[w];
                for (let A = 0, Y = b.length; A < Y; ) {
                  const j = b[A++], X = b[A++];
                  if (l >= j && l <= X)
                    return w + 1;
                }
              }
              return 1;
            }
            get length() {
              return this._map.length;
            }
            get isIdentityCMap() {
              if (!(this.name === "Identity-H" || this.name === "Identity-V") || this._map.length !== 65536)
                return !1;
              for (let l = 0; l < 65536; l++)
                if (this._map[l] !== l)
                  return !1;
              return !0;
            }
          }
          o.CMap = m;
          class p extends m {
            constructor(l, u) {
              super(), this.vertical = l, this.addCodespaceRange(u, 0, 65535);
            }
            mapCidRange(l, u, w) {
              (0, t.unreachable)("should not call mapCidRange");
            }
            mapBfRange(l, u, w) {
              (0, t.unreachable)("should not call mapBfRange");
            }
            mapBfRangeToArray(l, u, w) {
              (0, t.unreachable)("should not call mapBfRangeToArray");
            }
            mapOne(l, u) {
              (0, t.unreachable)("should not call mapCidOne");
            }
            lookup(l) {
              return Number.isInteger(l) && l <= 65535 ? l : void 0;
            }
            contains(l) {
              return Number.isInteger(l) && l <= 65535;
            }
            forEach(l) {
              for (let u = 0; u <= 65535; u++)
                l(u, u);
            }
            charCodeOf(l) {
              return Number.isInteger(l) && l <= 65535 ? l : -1;
            }
            getMap() {
              const l = new Array(65536);
              for (let u = 0; u <= 65535; u++)
                l[u] = u;
              return l;
            }
            get length() {
              return 65536;
            }
            get isIdentityCMap() {
              (0, t.unreachable)("should not access .isIdentityCMap");
            }
          }
          o.IdentityCMap = p;
          const g = function() {
            function l(X, B) {
              let U = 0;
              for (let k = 0; k <= B; k++)
                U = U << 8 | X[k];
              return U >>> 0;
            }
            function u(X, B) {
              return B === 1 ? String.fromCharCode(X[0], X[1]) : B === 3 ? String.fromCharCode(X[0], X[1], X[2], X[3]) : String.fromCharCode.apply(null, X.subarray(0, B + 1));
            }
            function w(X, B, U) {
              let k = 0;
              for (let x = U; x >= 0; x--)
                k += X[x] + B[x], X[x] = k & 255, k >>= 8;
            }
            function O(X, B) {
              let U = 1;
              for (let k = B; k >= 0 && U > 0; k--)
                U += X[k], X[k] = U & 255, U >>= 8;
            }
            const b = 16, A = 19;
            class Y {
              constructor(B) {
                this.buffer = B, this.pos = 0, this.end = B.length, this.tmpBuf = new Uint8Array(A);
              }
              readByte() {
                return this.pos >= this.end ? -1 : this.buffer[this.pos++];
              }
              readNumber() {
                let B = 0, U;
                do {
                  const k = this.readByte();
                  if (k < 0)
                    throw new t.FormatError("unexpected EOF in bcmap");
                  U = !(k & 128), B = B << 7 | k & 127;
                } while (!U);
                return B;
              }
              readSigned() {
                const B = this.readNumber();
                return B & 1 ? ~(B >>> 1) : B >>> 1;
              }
              readHex(B, U) {
                B.set(this.buffer.subarray(this.pos, this.pos + U + 1)), this.pos += U + 1;
              }
              readHexNumber(B, U) {
                let k;
                const x = this.tmpBuf;
                let f = 0;
                do {
                  const C = this.readByte();
                  if (C < 0)
                    throw new t.FormatError("unexpected EOF in bcmap");
                  k = !(C & 128), x[f++] = C & 127;
                } while (!k);
                let D = U, _ = 0, S = 0;
                for (; D >= 0; ) {
                  for (; S < 8 && x.length > 0; )
                    _ |= x[--f] << S, S += 7;
                  B[D] = _ & 255, D--, _ >>= 8, S -= 8;
                }
              }
              readHexSigned(B, U) {
                this.readHexNumber(B, U);
                const k = B[U] & 1 ? 255 : 0;
                let x = 0;
                for (let f = 0; f <= U; f++)
                  x = (x & 1) << 8 | B[f], B[f] = x >> 1 ^ k;
              }
              readString() {
                const B = this.readNumber();
                let U = "";
                for (let k = 0; k < B; k++)
                  U += String.fromCharCode(this.readNumber());
                return U;
              }
            }
            class j {
              async process(B, U, k) {
                const x = new Y(B), f = x.readByte();
                U.vertical = !!(f & 1);
                let D = null;
                const _ = new Uint8Array(b), S = new Uint8Array(b), C = new Uint8Array(b), T = new Uint8Array(b), P = new Uint8Array(b);
                let M, G;
                for (; (G = x.readByte()) >= 0; ) {
                  const Z = G >> 5;
                  if (Z === 7) {
                    switch (G & 31) {
                      case 0:
                        x.readString();
                        break;
                      case 1:
                        D = x.readString();
                        break;
                    }
                    continue;
                  }
                  const $ = !!(G & 16), z = G & 15;
                  if (z + 1 > b)
                    throw new Error("BinaryCMapReader.process: Invalid dataSize.");
                  const V = 1, L = x.readNumber();
                  switch (Z) {
                    case 0:
                      x.readHex(_, z), x.readHexNumber(S, z), w(S, _, z), U.addCodespaceRange(z + 1, l(_, z), l(S, z));
                      for (let K = 1; K < L; K++)
                        O(S, z), x.readHexNumber(_, z), w(_, S, z), x.readHexNumber(S, z), w(S, _, z), U.addCodespaceRange(z + 1, l(_, z), l(S, z));
                      break;
                    case 1:
                      x.readHex(_, z), x.readHexNumber(S, z), w(S, _, z), x.readNumber();
                      for (let K = 1; K < L; K++)
                        O(S, z), x.readHexNumber(_, z), w(_, S, z), x.readHexNumber(S, z), w(S, _, z), x.readNumber();
                      break;
                    case 2:
                      x.readHex(C, z), M = x.readNumber(), U.mapOne(l(C, z), M);
                      for (let K = 1; K < L; K++)
                        O(C, z), $ || (x.readHexNumber(P, z), w(C, P, z)), M = x.readSigned() + (M + 1), U.mapOne(l(C, z), M);
                      break;
                    case 3:
                      x.readHex(_, z), x.readHexNumber(S, z), w(S, _, z), M = x.readNumber(), U.mapCidRange(l(_, z), l(S, z), M);
                      for (let K = 1; K < L; K++)
                        O(S, z), $ ? _.set(S) : (x.readHexNumber(_, z), w(_, S, z)), x.readHexNumber(S, z), w(S, _, z), M = x.readNumber(), U.mapCidRange(l(_, z), l(S, z), M);
                      break;
                    case 4:
                      x.readHex(C, V), x.readHex(T, z), U.mapOne(l(C, V), u(T, z));
                      for (let K = 1; K < L; K++)
                        O(C, V), $ || (x.readHexNumber(P, V), w(C, P, V)), O(T, z), x.readHexSigned(P, z), w(T, P, z), U.mapOne(l(C, V), u(T, z));
                      break;
                    case 5:
                      x.readHex(_, V), x.readHexNumber(S, V), w(S, _, V), x.readHex(T, z), U.mapBfRange(l(_, V), l(S, V), u(T, z));
                      for (let K = 1; K < L; K++)
                        O(S, V), $ ? _.set(S) : (x.readHexNumber(_, V), w(_, S, V)), x.readHexNumber(S, V), w(S, _, V), x.readHex(T, z), U.mapBfRange(l(_, V), l(S, V), u(T, z));
                      break;
                    default:
                      throw new Error(`BinaryCMapReader.process - unknown type: ${Z}`);
                  }
                }
                return D ? k(D) : U;
              }
            }
            return j;
          }(), n = function() {
            function l(f) {
              let D = 0;
              for (let _ = 0; _ < f.length; _++)
                D = D << 8 | f.charCodeAt(_);
              return D >>> 0;
            }
            function u(f) {
              if (typeof f != "string")
                throw new t.FormatError("Malformed CMap: expected string.");
            }
            function w(f) {
              if (!Number.isInteger(f))
                throw new t.FormatError("Malformed CMap: expected int.");
            }
            function O(f, D) {
              for (; ; ) {
                let _ = D.getObj();
                if (_ === a.EOF)
                  break;
                if ((0, a.isCmd)(_, "endbfchar"))
                  return;
                u(_);
                const S = l(_);
                _ = D.getObj(), u(_);
                const C = _;
                f.mapOne(S, C);
              }
            }
            function b(f, D) {
              for (; ; ) {
                let _ = D.getObj();
                if (_ === a.EOF)
                  break;
                if ((0, a.isCmd)(_, "endbfrange"))
                  return;
                u(_);
                const S = l(_);
                _ = D.getObj(), u(_);
                const C = l(_);
                if (_ = D.getObj(), Number.isInteger(_) || typeof _ == "string") {
                  const T = Number.isInteger(_) ? String.fromCharCode(_) : _;
                  f.mapBfRange(S, C, T);
                } else if ((0, a.isCmd)(_, "[")) {
                  _ = D.getObj();
                  const T = [];
                  for (; !(0, a.isCmd)(_, "]") && _ !== a.EOF; )
                    T.push(_), _ = D.getObj();
                  f.mapBfRangeToArray(S, C, T);
                } else
                  break;
              }
              throw new t.FormatError("Invalid bf range.");
            }
            function A(f, D) {
              for (; ; ) {
                let _ = D.getObj();
                if (_ === a.EOF)
                  break;
                if ((0, a.isCmd)(_, "endcidchar"))
                  return;
                u(_);
                const S = l(_);
                _ = D.getObj(), w(_);
                const C = _;
                f.mapOne(S, C);
              }
            }
            function Y(f, D) {
              for (; ; ) {
                let _ = D.getObj();
                if (_ === a.EOF)
                  break;
                if ((0, a.isCmd)(_, "endcidrange"))
                  return;
                u(_);
                const S = l(_);
                _ = D.getObj(), u(_);
                const C = l(_);
                _ = D.getObj(), w(_);
                const T = _;
                f.mapCidRange(S, C, T);
              }
            }
            function j(f, D) {
              for (; ; ) {
                let _ = D.getObj();
                if (_ === a.EOF)
                  break;
                if ((0, a.isCmd)(_, "endcodespacerange"))
                  return;
                if (typeof _ != "string")
                  break;
                const S = l(_);
                if (_ = D.getObj(), typeof _ != "string")
                  break;
                const C = l(_);
                f.addCodespaceRange(_.length, S, C);
              }
              throw new t.FormatError("Invalid codespace range.");
            }
            function X(f, D) {
              const _ = D.getObj();
              Number.isInteger(_) && (f.vertical = !!_);
            }
            function B(f, D) {
              const _ = D.getObj();
              _ instanceof a.Name && (f.name = _.name);
            }
            async function U(f, D, _, S) {
              let C, T;
              e:
                for (; ; )
                  try {
                    const P = D.getObj();
                    if (P === a.EOF)
                      break;
                    if (P instanceof a.Name)
                      P.name === "WMode" ? X(f, D) : P.name === "CMapName" && B(f, D), C = P;
                    else if (P instanceof a.Cmd)
                      switch (P.cmd) {
                        case "endcmap":
                          break e;
                        case "usecmap":
                          C instanceof a.Name && (T = C.name);
                          break;
                        case "begincodespacerange":
                          j(f, D);
                          break;
                        case "beginbfchar":
                          O(f, D);
                          break;
                        case "begincidchar":
                          A(f, D);
                          break;
                        case "beginbfrange":
                          b(f, D);
                          break;
                        case "begincidrange":
                          Y(f, D);
                          break;
                      }
                  } catch (P) {
                    if (P instanceof e.MissingDataException)
                      throw P;
                    (0, t.warn)("Invalid cMap data: " + P);
                    continue;
                  }
              return !S && T && (S = T), S ? k(f, _, S) : f;
            }
            async function k(f, D, _) {
              if (f.useCMap = await x(_, D), f.numCodespaceRanges === 0) {
                const S = f.useCMap.codespaceRanges;
                for (let C = 0; C < S.length; C++)
                  f.codespaceRanges[C] = S[C].slice();
                f.numCodespaceRanges = f.useCMap.numCodespaceRanges;
              }
              return f.useCMap.forEach(function(S, C) {
                f.contains(S) || f.mapOne(S, f.useCMap.lookup(S));
              }), f;
            }
            async function x(f, D) {
              if (f === "Identity-H")
                return new p(!1, 2);
              if (f === "Identity-V")
                return new p(!0, 2);
              if (!c.includes(f))
                throw new Error("Unknown CMap name: " + f);
              if (!D)
                throw new Error("Built-in CMap parameters are not provided.");
              const {
                cMapData: _,
                compressionType: S
              } = await D(f), C = new m(!0);
              if (S === t.CMapCompressionType.BINARY)
                return new g().process(_, C, (T) => k(C, D, T));
              if (S === t.CMapCompressionType.NONE) {
                const T = new h.Lexer(new y.Stream(_));
                return U(C, T, D, null);
              }
              throw new Error("TODO: Only BINARY/NONE CMap compression is currently supported.");
            }
            return {
              async create(f) {
                const D = f.encoding, _ = f.fetchBuiltInCMap, S = f.useCMap;
                if (D instanceof a.Name)
                  return x(D.name, _);
                if (D instanceof v.BaseStream) {
                  const C = await U(new m(), new h.Lexer(D), _, S);
                  return C.isIdentityCMap ? x(C.name, _) : C;
                }
                throw new Error("Encoding required.");
              }
            };
          }();
          o.CMapFactory = n;
        },
        /* 17 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.Parser = o.Linearization = o.Lexer = void 0;
          var t = F(2), a = F(5), v = F(6), h = F(18), e = F(20), y = F(21), c = F(23), d = F(24), m = F(27), p = F(29), g = F(31), n = F(10), i = F(32), l = F(33);
          const u = 1e3, w = 5552;
          function O(B) {
            const U = B.length;
            let k = 1, x = 0;
            for (let f = 0; f < U; ++f)
              k += B[f] & 255, x += k;
            return x % 65521 << 16 | k % 65521;
          }
          class b {
            constructor({
              lexer: U,
              xref: k,
              allowStreams: x = !1,
              recoveryMode: f = !1
            }) {
              this.lexer = U, this.xref = k, this.allowStreams = x, this.recoveryMode = f, this.imageCache = /* @__PURE__ */ Object.create(null), this.refill();
            }
            refill() {
              this.buf1 = this.lexer.getObj(), this.buf2 = this.lexer.getObj();
            }
            shift() {
              this.buf2 instanceof a.Cmd && this.buf2.cmd === "ID" ? (this.buf1 = this.buf2, this.buf2 = null) : (this.buf1 = this.buf2, this.buf2 = this.lexer.getObj());
            }
            tryShift() {
              try {
                return this.shift(), !0;
              } catch (U) {
                if (U instanceof v.MissingDataException)
                  throw U;
                return !1;
              }
            }
            getObj(U = null) {
              const k = this.buf1;
              if (this.shift(), k instanceof a.Cmd)
                switch (k.cmd) {
                  case "BI":
                    return this.makeInlineImage(U);
                  case "[":
                    const x = [];
                    for (; !(0, a.isCmd)(this.buf1, "]") && this.buf1 !== a.EOF; )
                      x.push(this.getObj(U));
                    if (this.buf1 === a.EOF) {
                      if (this.recoveryMode)
                        return x;
                      throw new v.ParserEOFException("End of file inside array.");
                    }
                    return this.shift(), x;
                  case "<<":
                    const f = new a.Dict(this.xref);
                    for (; !(0, a.isCmd)(this.buf1, ">>") && this.buf1 !== a.EOF; ) {
                      if (!(this.buf1 instanceof a.Name)) {
                        (0, t.info)("Malformed dictionary: key must be a name object"), this.shift();
                        continue;
                      }
                      const D = this.buf1.name;
                      if (this.shift(), this.buf1 === a.EOF)
                        break;
                      f.set(D, this.getObj(U));
                    }
                    if (this.buf1 === a.EOF) {
                      if (this.recoveryMode)
                        return f;
                      throw new v.ParserEOFException("End of file inside dictionary.");
                    }
                    return (0, a.isCmd)(this.buf2, "stream") ? this.allowStreams ? this.makeStream(f, U) : f : (this.shift(), f);
                  default:
                    return k;
                }
              if (Number.isInteger(k)) {
                if (Number.isInteger(this.buf1) && (0, a.isCmd)(this.buf2, "R")) {
                  const x = a.Ref.get(k, this.buf1);
                  return this.shift(), this.shift(), x;
                }
                return k;
              }
              return typeof k == "string" && U ? U.decryptString(k) : k;
            }
            findDefaultInlineStreamEnd(U) {
              const C = this.lexer, T = U.pos, P = 10;
              let M = 0, G, Z;
              for (; (G = U.getByte()) !== -1; )
                if (M === 0)
                  M = G === 69 ? 1 : 0;
                else if (M === 1)
                  M = G === 73 ? 2 : 0;
                else if ((0, t.assert)(M === 2, "findDefaultInlineStreamEnd - invalid state."), G === 32 || G === 10 || G === 13) {
                  Z = U.pos;
                  const z = U.peekBytes(P);
                  for (let V = 0, L = z.length; V < L; V++)
                    if (G = z[V], !(G === 0 && z[V + 1] !== 0) && G !== 10 && G !== 13 && (G < 32 || G > 127)) {
                      M = 0;
                      break;
                    }
                  if (M !== 2)
                    continue;
                  if (C.knownCommands) {
                    const V = C.peekObj();
                    V instanceof a.Cmd && !C.knownCommands[V.cmd] && (M = 0);
                  } else
                    (0, t.warn)("findDefaultInlineStreamEnd - `lexer.knownCommands` is undefined.");
                  if (M === 2)
                    break;
                } else
                  M = 0;
              G === -1 && ((0, t.warn)("findDefaultInlineStreamEnd: Reached the end of the stream without finding a valid EI marker"), Z && ((0, t.warn)('... trying to recover by using the last "EI" occurrence.'), U.skip(-(U.pos - Z))));
              let $ = 4;
              return U.skip(-$), G = U.peekByte(), U.skip($), (0, v.isWhiteSpace)(G) || $--, U.pos - $ - T;
            }
            findDCTDecodeInlineStreamEnd(U) {
              const k = U.pos;
              let x = !1, f, D;
              for (; (f = U.getByte()) !== -1; )
                if (f === 255) {
                  switch (U.getByte()) {
                    case 0:
                      break;
                    case 255:
                      U.skip(-1);
                      break;
                    case 217:
                      x = !0;
                      break;
                    case 192:
                    case 193:
                    case 194:
                    case 195:
                    case 197:
                    case 198:
                    case 199:
                    case 201:
                    case 202:
                    case 203:
                    case 205:
                    case 206:
                    case 207:
                    case 196:
                    case 204:
                    case 218:
                    case 219:
                    case 220:
                    case 221:
                    case 222:
                    case 223:
                    case 224:
                    case 225:
                    case 226:
                    case 227:
                    case 228:
                    case 229:
                    case 230:
                    case 231:
                    case 232:
                    case 233:
                    case 234:
                    case 235:
                    case 236:
                    case 237:
                    case 238:
                    case 239:
                    case 254:
                      D = U.getUint16(), D > 2 ? U.skip(D - 2) : U.skip(-2);
                      break;
                  }
                  if (x)
                    break;
                }
              const _ = U.pos - k;
              return f === -1 ? ((0, t.warn)("Inline DCTDecode image stream: EOI marker not found, searching for /EI/ instead."), U.skip(-_), this.findDefaultInlineStreamEnd(U)) : (this.inlineStreamSkipEI(U), _);
            }
            findASCII85DecodeInlineStreamEnd(U) {
              const f = U.pos;
              let D;
              for (; (D = U.getByte()) !== -1; )
                if (D === 126) {
                  const S = U.pos;
                  for (D = U.peekByte(); (0, v.isWhiteSpace)(D); )
                    U.skip(), D = U.peekByte();
                  if (D === 62) {
                    U.skip();
                    break;
                  }
                  if (U.pos > S) {
                    const C = U.peekBytes(2);
                    if (C[0] === 69 && C[1] === 73)
                      break;
                  }
                }
              const _ = U.pos - f;
              return D === -1 ? ((0, t.warn)("Inline ASCII85Decode image stream: EOD marker not found, searching for /EI/ instead."), U.skip(-_), this.findDefaultInlineStreamEnd(U)) : (this.inlineStreamSkipEI(U), _);
            }
            findASCIIHexDecodeInlineStreamEnd(U) {
              const x = U.pos;
              let f;
              for (; (f = U.getByte()) !== -1 && f !== 62; )
                ;
              const D = U.pos - x;
              return f === -1 ? ((0, t.warn)("Inline ASCIIHexDecode image stream: EOD marker not found, searching for /EI/ instead."), U.skip(-D), this.findDefaultInlineStreamEnd(U)) : (this.inlineStreamSkipEI(U), D);
            }
            inlineStreamSkipEI(U) {
              let f = 0, D;
              for (; (D = U.getByte()) !== -1; )
                if (f === 0)
                  f = D === 69 ? 1 : 0;
                else if (f === 1)
                  f = D === 73 ? 2 : 0;
                else if (f === 2)
                  break;
            }
            makeInlineImage(U) {
              const k = this.lexer, x = k.stream, f = new a.Dict(this.xref);
              let D;
              for (; !(0, a.isCmd)(this.buf1, "ID") && this.buf1 !== a.EOF; ) {
                if (!(this.buf1 instanceof a.Name))
                  throw new t.FormatError("Dictionary key must be a name object");
                const G = this.buf1.name;
                if (this.shift(), this.buf1 === a.EOF)
                  break;
                f.set(G, this.getObj(U));
              }
              k.beginInlineImagePos !== -1 && (D = x.pos - k.beginInlineImagePos);
              const _ = f.get("F", "Filter");
              let S;
              if (_ instanceof a.Name)
                S = _.name;
              else if (Array.isArray(_)) {
                const G = this.xref.fetchIfRef(_[0]);
                G instanceof a.Name && (S = G.name);
              }
              const C = x.pos;
              let T;
              switch (S) {
                case "DCT":
                case "DCTDecode":
                  T = this.findDCTDecodeInlineStreamEnd(x);
                  break;
                case "A85":
                case "ASCII85Decode":
                  T = this.findASCII85DecodeInlineStreamEnd(x);
                  break;
                case "AHx":
                case "ASCIIHexDecode":
                  T = this.findASCIIHexDecodeInlineStreamEnd(x);
                  break;
                default:
                  T = this.findDefaultInlineStreamEnd(x);
              }
              let P = x.makeSubStream(C, T, f), M;
              if (T < u && D < w) {
                const G = P.getBytes();
                P.reset();
                const Z = x.pos;
                x.pos = k.beginInlineImagePos;
                const $ = x.getBytes(D);
                x.pos = Z, M = O(G) + "_" + O($);
                const z = this.imageCache[M];
                if (z !== void 0)
                  return this.buf2 = a.Cmd.get("EI"), this.shift(), z.reset(), z;
              }
              return U && (P = U.createStream(P, T)), P = this.filter(P, f, T), P.dict = f, M !== void 0 && (P.cacheKey = `inline_${T}_${M}`, this.imageCache[M] = P), this.buf2 = a.Cmd.get("EI"), this.shift(), P;
            }
            _findStreamLength(U, k) {
              const {
                stream: x
              } = this.lexer;
              x.pos = U;
              const f = 2048, D = k.length;
              for (; x.pos < x.end; ) {
                const _ = x.peekBytes(f), S = _.length - D;
                if (S <= 0)
                  break;
                let C = 0;
                for (; C < S; ) {
                  let T = 0;
                  for (; T < D && _[C + T] === k[T]; )
                    T++;
                  if (T >= D)
                    return x.pos += C, x.pos - U;
                  C++;
                }
                x.pos += S;
              }
              return -1;
            }
            makeStream(U, k) {
              const x = this.lexer;
              let f = x.stream;
              x.skipToNextLine();
              const D = f.pos - 1;
              let _ = U.get("Length");
              if (Number.isInteger(_) || ((0, t.info)(`Bad length "${_ && _.toString()}" in stream.`), _ = 0), f.pos = D + _, x.nextChar(), this.tryShift() && (0, a.isCmd)(this.buf2, "endstream"))
                this.shift();
              else {
                const S = new Uint8Array([101, 110, 100, 115, 116, 114, 101, 97, 109]);
                let C = this._findStreamLength(D, S);
                if (C < 0) {
                  for (let P = 1; P <= 1; P++) {
                    const M = S.length - P, G = S.slice(0, M), Z = this._findStreamLength(D, G);
                    if (Z >= 0) {
                      const $ = f.peekBytes(M + 1)[M];
                      if (!(0, v.isWhiteSpace)($))
                        break;
                      (0, t.info)(`Found "${(0, t.bytesToString)(G)}" when searching for endstream command.`), C = Z;
                      break;
                    }
                  }
                  if (C < 0)
                    throw new t.FormatError("Missing endstream command.");
                }
                _ = C, x.nextChar(), this.shift(), this.shift();
              }
              return this.shift(), f = f.makeSubStream(D, _, U), k && (f = k.createStream(f, _)), f = this.filter(f, U, _), f.dict = U, f;
            }
            filter(U, k, x) {
              let f = k.get("F", "Filter"), D = k.get("DP", "DecodeParms");
              if (f instanceof a.Name)
                return Array.isArray(D) && (0, t.warn)("/DecodeParms should not be an Array, when /Filter is a Name."), this.makeFilter(U, f.name, x, D);
              let _ = x;
              if (Array.isArray(f)) {
                const S = f, C = D;
                for (let T = 0, P = S.length; T < P; ++T) {
                  if (f = this.xref.fetchIfRef(S[T]), !(f instanceof a.Name))
                    throw new t.FormatError(`Bad filter name "${f}"`);
                  D = null, Array.isArray(C) && T in C && (D = this.xref.fetchIfRef(C[T])), U = this.makeFilter(U, f.name, _, D), _ = null;
                }
              }
              return U;
            }
            makeFilter(U, k, x, f) {
              if (x === 0)
                return (0, t.warn)(`Empty "${k}" stream.`), new n.NullStream();
              const D = this.xref.stats;
              try {
                switch (k) {
                  case "Fl":
                  case "FlateDecode":
                    return D.addStreamType(t.StreamType.FLATE), f ? new i.PredictorStream(new c.FlateStream(U, x), x, f) : new c.FlateStream(U, x);
                  case "LZW":
                  case "LZWDecode":
                    D.addStreamType(t.StreamType.LZW);
                    let _ = 1;
                    return f ? (f.has("EarlyChange") && (_ = f.get("EarlyChange")), new i.PredictorStream(new g.LZWStream(U, x, _), x, f)) : new g.LZWStream(U, x, _);
                  case "DCT":
                  case "DCTDecode":
                    return D.addStreamType(t.StreamType.DCT), new m.JpegStream(U, x, f);
                  case "JPX":
                  case "JPXDecode":
                    return D.addStreamType(t.StreamType.JPX), new p.JpxStream(U, x, f);
                  case "A85":
                  case "ASCII85Decode":
                    return D.addStreamType(t.StreamType.A85), new h.Ascii85Stream(U, x);
                  case "AHx":
                  case "ASCIIHexDecode":
                    return D.addStreamType(t.StreamType.AHX), new e.AsciiHexStream(U, x);
                  case "CCF":
                  case "CCITTFaxDecode":
                    return D.addStreamType(t.StreamType.CCF), new y.CCITTFaxStream(U, x, f);
                  case "RL":
                  case "RunLengthDecode":
                    return D.addStreamType(t.StreamType.RLX), new l.RunLengthStream(U, x);
                  case "JBIG2Decode":
                    return D.addStreamType(t.StreamType.JBIG), new d.Jbig2Stream(U, x, f);
                }
                return (0, t.warn)(`Filter "${k}" is not supported.`), U;
              } catch (_) {
                if (_ instanceof v.MissingDataException)
                  throw _;
                return (0, t.warn)(`Invalid stream: "${_}"`), new n.NullStream();
              }
            }
          }
          o.Parser = b;
          const A = [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          function Y(B) {
            return B >= 48 && B <= 57 ? B & 15 : B >= 65 && B <= 70 || B >= 97 && B <= 102 ? (B & 15) + 9 : -1;
          }
          class j {
            constructor(U, k = null) {
              this.stream = U, this.nextChar(), this.strBuf = [], this.knownCommands = k, this._hexStringNumWarn = 0, this.beginInlineImagePos = -1;
            }
            nextChar() {
              return this.currentChar = this.stream.getByte();
            }
            peekChar() {
              return this.stream.peekByte();
            }
            getNumber() {
              let U = this.currentChar, k = !1, x = 0, f = 0;
              if (U === 45 ? (f = -1, U = this.nextChar(), U === 45 && (U = this.nextChar())) : U === 43 && (f = 1, U = this.nextChar()), U === 10 || U === 13)
                do
                  U = this.nextChar();
                while (U === 10 || U === 13);
              if (U === 46 && (x = 10, U = this.nextChar()), U < 48 || U > 57) {
                if ((0, v.isWhiteSpace)(U) || U === -1) {
                  if (x === 10 && f === 0)
                    return (0, t.warn)("Lexer.getNumber - treating a single decimal point as zero."), 0;
                  if (x === 0 && f === -1)
                    return (0, t.warn)("Lexer.getNumber - treating a single minus sign as zero."), 0;
                }
                throw new t.FormatError(`Invalid number: ${String.fromCharCode(U)} (charCode ${U})`);
              }
              f = f || 1;
              let D = U - 48, _ = 0, S = 1;
              for (; (U = this.nextChar()) >= 0; )
                if (U >= 48 && U <= 57) {
                  const C = U - 48;
                  k ? _ = _ * 10 + C : (x !== 0 && (x *= 10), D = D * 10 + C);
                } else if (U === 46)
                  if (x === 0)
                    x = 1;
                  else
                    break;
                else if (U === 45)
                  (0, t.warn)("Badly formatted number: minus sign in the middle");
                else if (U === 69 || U === 101) {
                  if (U = this.peekChar(), U === 43 || U === 45)
                    S = U === 45 ? -1 : 1, this.nextChar();
                  else if (U < 48 || U > 57)
                    break;
                  k = !0;
                } else
                  break;
              return x !== 0 && (D /= x), k && (D *= 10 ** (S * _)), f * D;
            }
            getString() {
              let U = 1, k = !1;
              const x = this.strBuf;
              x.length = 0;
              let f = this.nextChar();
              for (; ; ) {
                let D = !1;
                switch (f | 0) {
                  case -1:
                    (0, t.warn)("Unterminated string"), k = !0;
                    break;
                  case 40:
                    ++U, x.push("(");
                    break;
                  case 41:
                    --U === 0 ? (this.nextChar(), k = !0) : x.push(")");
                    break;
                  case 92:
                    switch (f = this.nextChar(), f) {
                      case -1:
                        (0, t.warn)("Unterminated string"), k = !0;
                        break;
                      case 110:
                        x.push(`
`);
                        break;
                      case 114:
                        x.push("\r");
                        break;
                      case 116:
                        x.push("	");
                        break;
                      case 98:
                        x.push("\b");
                        break;
                      case 102:
                        x.push("\f");
                        break;
                      case 92:
                      case 40:
                      case 41:
                        x.push(String.fromCharCode(f));
                        break;
                      case 48:
                      case 49:
                      case 50:
                      case 51:
                      case 52:
                      case 53:
                      case 54:
                      case 55:
                        let _ = f & 15;
                        f = this.nextChar(), D = !0, f >= 48 && f <= 55 && (_ = (_ << 3) + (f & 15), f = this.nextChar(), f >= 48 && f <= 55 && (D = !1, _ = (_ << 3) + (f & 15))), x.push(String.fromCharCode(_));
                        break;
                      case 13:
                        this.peekChar() === 10 && this.nextChar();
                        break;
                      case 10:
                        break;
                      default:
                        x.push(String.fromCharCode(f));
                        break;
                    }
                    break;
                  default:
                    x.push(String.fromCharCode(f));
                    break;
                }
                if (k)
                  break;
                D || (f = this.nextChar());
              }
              return x.join("");
            }
            getName() {
              let U, k;
              const x = this.strBuf;
              for (x.length = 0; (U = this.nextChar()) >= 0 && !A[U]; )
                if (U === 35) {
                  if (U = this.nextChar(), A[U]) {
                    (0, t.warn)("Lexer_getName: NUMBER SIGN (#) should be followed by a hexadecimal number."), x.push("#");
                    break;
                  }
                  const f = Y(U);
                  if (f !== -1) {
                    k = U, U = this.nextChar();
                    const D = Y(U);
                    if (D === -1) {
                      if ((0, t.warn)(`Lexer_getName: Illegal digit (${String.fromCharCode(U)}) in hexadecimal number.`), x.push("#", String.fromCharCode(k)), A[U])
                        break;
                      x.push(String.fromCharCode(U));
                      continue;
                    }
                    x.push(String.fromCharCode(f << 4 | D));
                  } else
                    x.push("#", String.fromCharCode(U));
                } else
                  x.push(String.fromCharCode(U));
              return x.length > 127 && (0, t.warn)(`Name token is longer than allowed by the spec: ${x.length}`), a.Name.get(x.join(""));
            }
            _hexStringWarn(U) {
              if (this._hexStringNumWarn++ === 5) {
                (0, t.warn)("getHexString - ignoring additional invalid characters.");
                return;
              }
              this._hexStringNumWarn > 5 || (0, t.warn)(`getHexString - ignoring invalid character: ${U}`);
            }
            getHexString() {
              const U = this.strBuf;
              U.length = 0;
              let k = this.currentChar, x = !0, f, D;
              for (this._hexStringNumWarn = 0; ; )
                if (k < 0) {
                  (0, t.warn)("Unterminated hex string");
                  break;
                } else if (k === 62) {
                  this.nextChar();
                  break;
                } else if (A[k] === 1) {
                  k = this.nextChar();
                  continue;
                } else {
                  if (x) {
                    if (f = Y(k), f === -1) {
                      this._hexStringWarn(k), k = this.nextChar();
                      continue;
                    }
                  } else {
                    if (D = Y(k), D === -1) {
                      this._hexStringWarn(k), k = this.nextChar();
                      continue;
                    }
                    U.push(String.fromCharCode(f << 4 | D));
                  }
                  x = !x, k = this.nextChar();
                }
              return U.join("");
            }
            getObj() {
              let U = !1, k = this.currentChar;
              for (; ; ) {
                if (k < 0)
                  return a.EOF;
                if (U)
                  (k === 10 || k === 13) && (U = !1);
                else if (k === 37)
                  U = !0;
                else if (A[k] !== 1)
                  break;
                k = this.nextChar();
              }
              switch (k | 0) {
                case 48:
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                case 43:
                case 45:
                case 46:
                  return this.getNumber();
                case 40:
                  return this.getString();
                case 47:
                  return this.getName();
                case 91:
                  return this.nextChar(), a.Cmd.get("[");
                case 93:
                  return this.nextChar(), a.Cmd.get("]");
                case 60:
                  return k = this.nextChar(), k === 60 ? (this.nextChar(), a.Cmd.get("<<")) : this.getHexString();
                case 62:
                  return k = this.nextChar(), k === 62 ? (this.nextChar(), a.Cmd.get(">>")) : a.Cmd.get(">");
                case 123:
                  return this.nextChar(), a.Cmd.get("{");
                case 125:
                  return this.nextChar(), a.Cmd.get("}");
                case 41:
                  throw this.nextChar(), new t.FormatError(`Illegal character: ${k}`);
              }
              let x = String.fromCharCode(k);
              if (k < 32 || k > 127) {
                const _ = this.peekChar();
                if (_ >= 32 && _ <= 127)
                  return this.nextChar(), a.Cmd.get(x);
              }
              const f = this.knownCommands;
              let D = f && f[x] !== void 0;
              for (; (k = this.nextChar()) >= 0 && !A[k]; ) {
                const _ = x + String.fromCharCode(k);
                if (D && f[_] === void 0)
                  break;
                if (x.length === 128)
                  throw new t.FormatError(`Command token too long: ${x.length}`);
                x = _, D = f && f[x] !== void 0;
              }
              return x === "true" ? !0 : x === "false" ? !1 : x === "null" ? null : (x === "BI" && (this.beginInlineImagePos = this.stream.pos), a.Cmd.get(x));
            }
            peekObj() {
              const U = this.stream.pos, k = this.currentChar, x = this.beginInlineImagePos;
              let f;
              try {
                f = this.getObj();
              } catch (D) {
                if (D instanceof v.MissingDataException)
                  throw D;
                (0, t.warn)(`peekObj: ${D}`);
              }
              return this.stream.pos = U, this.currentChar = k, this.beginInlineImagePos = x, f;
            }
            skipToNextLine() {
              let U = this.currentChar;
              for (; U >= 0; ) {
                if (U === 13) {
                  U = this.nextChar(), U === 10 && this.nextChar();
                  break;
                } else if (U === 10) {
                  this.nextChar();
                  break;
                }
                U = this.nextChar();
              }
            }
          }
          o.Lexer = j;
          class X {
            static create(U) {
              function k(M, G, Z = !1) {
                const $ = M.get(G);
                if (Number.isInteger($) && (Z ? $ >= 0 : $ > 0))
                  return $;
                throw new Error(`The "${G}" parameter in the linearization dictionary is invalid.`);
              }
              function x(M) {
                const G = M.get("H");
                let Z;
                if (Array.isArray(G) && ((Z = G.length) === 2 || Z === 4)) {
                  for (let $ = 0; $ < Z; $++) {
                    const z = G[$];
                    if (!(Number.isInteger(z) && z > 0))
                      throw new Error(`Hint (${$}) in the linearization dictionary is invalid.`);
                  }
                  return G;
                }
                throw new Error("Hint array in the linearization dictionary is invalid.");
              }
              const f = new b({
                lexer: new j(U),
                xref: null
              }), D = f.getObj(), _ = f.getObj(), S = f.getObj(), C = f.getObj();
              let T, P;
              if (Number.isInteger(D) && Number.isInteger(_) && (0, a.isCmd)(S, "obj") && C instanceof a.Dict && typeof (T = C.get("Linearized")) == "number" && T > 0) {
                if ((P = k(C, "L")) !== U.length)
                  throw new Error('The "L" parameter in the linearization dictionary does not equal the stream length.');
              } else
                return null;
              return {
                length: P,
                hints: x(C),
                objectNumberFirst: k(C, "O"),
                endFirst: k(C, "E"),
                numPages: k(C, "N"),
                mainXRefEntriesOffset: k(C, "T"),
                pageFirst: C.has("P") ? k(C, "P", !0) : 0
              };
            }
          }
          o.Linearization = X;
        },
        /* 18 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.Ascii85Stream = void 0;
          var t = F(19), a = F(6);
          class v extends t.DecodeStream {
            constructor(e, y) {
              y && (y *= 0.8), super(y), this.str = e, this.dict = e.dict, this.input = new Uint8Array(5);
            }
            readBlock() {
              const d = this.str;
              let m = d.getByte();
              for (; (0, a.isWhiteSpace)(m); )
                m = d.getByte();
              if (m === -1 || m === 126) {
                this.eof = !0;
                return;
              }
              const p = this.bufferLength;
              let g, n;
              if (m === 122) {
                for (g = this.ensureBuffer(p + 4), n = 0; n < 4; ++n)
                  g[p + n] = 0;
                this.bufferLength += 4;
              } else {
                const i = this.input;
                for (i[0] = m, n = 1; n < 5; ++n) {
                  for (m = d.getByte(); (0, a.isWhiteSpace)(m); )
                    m = d.getByte();
                  if (i[n] = m, m === -1 || m === 126)
                    break;
                }
                if (g = this.ensureBuffer(p + n - 1), this.bufferLength += n - 1, n < 5) {
                  for (; n < 5; ++n)
                    i[n] = 117;
                  this.eof = !0;
                }
                let l = 0;
                for (n = 0; n < 5; ++n)
                  l = l * 85 + (i[n] - 33);
                for (n = 3; n >= 0; --n)
                  g[p + n] = l & 255, l >>= 8;
              }
            }
          }
          o.Ascii85Stream = v;
        },
        /* 19 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.StreamsSequenceStream = o.DecodeStream = void 0;
          var t = F(7), a = F(10);
          const v = new Uint8Array(0);
          class h extends t.BaseStream {
            constructor(c) {
              if (super(), this._rawMinBufferLength = c || 0, this.pos = 0, this.bufferLength = 0, this.eof = !1, this.buffer = v, this.minBufferLength = 512, c)
                for (; this.minBufferLength < c; )
                  this.minBufferLength *= 2;
            }
            get isEmpty() {
              for (; !this.eof && this.bufferLength === 0; )
                this.readBlock();
              return this.bufferLength === 0;
            }
            ensureBuffer(c) {
              const d = this.buffer;
              if (c <= d.byteLength)
                return d;
              let m = this.minBufferLength;
              for (; m < c; )
                m *= 2;
              const p = new Uint8Array(m);
              return p.set(d), this.buffer = p;
            }
            getByte() {
              const c = this.pos;
              for (; this.bufferLength <= c; ) {
                if (this.eof)
                  return -1;
                this.readBlock();
              }
              return this.buffer[this.pos++];
            }
            getBytes(c) {
              const d = this.pos;
              let m;
              if (c) {
                for (this.ensureBuffer(d + c), m = d + c; !this.eof && this.bufferLength < m; )
                  this.readBlock();
                const p = this.bufferLength;
                m > p && (m = p);
              } else {
                for (; !this.eof; )
                  this.readBlock();
                m = this.bufferLength;
              }
              return this.pos = m, this.buffer.subarray(d, m);
            }
            reset() {
              this.pos = 0;
            }
            makeSubStream(c, d, m = null) {
              if (d === void 0)
                for (; !this.eof; )
                  this.readBlock();
              else {
                const p = c + d;
                for (; this.bufferLength <= p && !this.eof; )
                  this.readBlock();
              }
              return new a.Stream(this.buffer, c, d, m);
            }
            getBaseStreams() {
              return this.str ? this.str.getBaseStreams() : null;
            }
          }
          o.DecodeStream = h;
          class e extends h {
            constructor(c, d = null) {
              let m = 0;
              for (const p of c)
                m += p instanceof h ? p._rawMinBufferLength : p.length;
              super(m), this.streams = c, this._onError = d;
            }
            readBlock() {
              const c = this.streams;
              if (c.length === 0) {
                this.eof = !0;
                return;
              }
              const d = c.shift();
              let m;
              try {
                m = d.getBytes();
              } catch (i) {
                if (this._onError) {
                  this._onError(i, d.dict && d.dict.objId);
                  return;
                }
                throw i;
              }
              const p = this.bufferLength, g = p + m.length;
              this.ensureBuffer(g).set(m, p), this.bufferLength = g;
            }
            getBaseStreams() {
              const c = [];
              for (const d of this.streams) {
                const m = d.getBaseStreams();
                m && c.push(...m);
              }
              return c.length > 0 ? c : null;
            }
          }
          o.StreamsSequenceStream = e;
        },
        /* 20 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.AsciiHexStream = void 0;
          var t = F(19);
          class a extends t.DecodeStream {
            constructor(h, e) {
              e && (e *= 0.5), super(e), this.str = h, this.dict = h.dict, this.firstDigit = -1;
            }
            readBlock() {
              const e = this.str.getBytes(8e3);
              if (!e.length) {
                this.eof = !0;
                return;
              }
              const y = e.length + 1 >> 1, c = this.ensureBuffer(this.bufferLength + y);
              let d = this.bufferLength, m = this.firstDigit;
              for (const p of e) {
                let g;
                if (p >= 48 && p <= 57)
                  g = p & 15;
                else if (p >= 65 && p <= 70 || p >= 97 && p <= 102)
                  g = (p & 15) + 9;
                else if (p === 62) {
                  this.eof = !0;
                  break;
                } else
                  continue;
                m < 0 ? m = g : (c[d++] = m << 4 | g, m = -1);
              }
              m >= 0 && this.eof && (c[d++] = m << 4, m = -1), this.firstDigit = m, this.bufferLength = d;
            }
          }
          o.AsciiHexStream = a;
        },
        /* 21 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.CCITTFaxStream = void 0;
          var t = F(22), a = F(19), v = F(5);
          class h extends a.DecodeStream {
            constructor(y, c, d) {
              super(c), this.str = y, this.dict = y.dict, d instanceof v.Dict || (d = v.Dict.empty);
              const m = {
                next() {
                  return y.getByte();
                }
              };
              this.ccittFaxDecoder = new t.CCITTFaxDecoder(m, {
                K: d.get("K"),
                EndOfLine: d.get("EndOfLine"),
                EncodedByteAlign: d.get("EncodedByteAlign"),
                Columns: d.get("Columns"),
                Rows: d.get("Rows"),
                EndOfBlock: d.get("EndOfBlock"),
                BlackIs1: d.get("BlackIs1")
              });
            }
            readBlock() {
              for (; !this.eof; ) {
                const y = this.ccittFaxDecoder.readNextChar();
                if (y === -1) {
                  this.eof = !0;
                  return;
                }
                this.ensureBuffer(this.bufferLength + 1), this.buffer[this.bufferLength++] = y;
              }
            }
          }
          o.CCITTFaxStream = h;
        },
        /* 22 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.CCITTFaxDecoder = void 0;
          var t = F(2);
          const a = -2, v = -1, h = 0, e = 1, y = 2, c = 3, d = 4, m = 5, p = 6, g = 7, n = 8, i = [[-1, -1], [-1, -1], [7, n], [7, g], [6, p], [6, p], [6, m], [6, m], [4, h], [4, h], [4, h], [4, h], [4, h], [4, h], [4, h], [4, h], [3, e], [3, e], [3, e], [3, e], [3, e], [3, e], [3, e], [3, e], [3, e], [3, e], [3, e], [3, e], [3, e], [3, e], [3, e], [3, e], [3, d], [3, d], [3, d], [3, d], [3, d], [3, d], [3, d], [3, d], [3, d], [3, d], [3, d], [3, d], [3, d], [3, d], [3, d], [3, d], [3, c], [3, c], [3, c], [3, c], [3, c], [3, c], [3, c], [3, c], [3, c], [3, c], [3, c], [3, c], [3, c], [3, c], [3, c], [3, c], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y], [1, y]], l = [[-1, -1], [12, a], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [12, 1984], [12, 2048], [12, 2112], [12, 2176], [12, 2240], [12, 2304], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [12, 2368], [12, 2432], [12, 2496], [12, 2560]], u = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [8, 29], [8, 29], [8, 30], [8, 30], [8, 45], [8, 45], [8, 46], [8, 46], [7, 22], [7, 22], [7, 22], [7, 22], [7, 23], [7, 23], [7, 23], [7, 23], [8, 47], [8, 47], [8, 48], [8, 48], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [7, 20], [7, 20], [7, 20], [7, 20], [8, 33], [8, 33], [8, 34], [8, 34], [8, 35], [8, 35], [8, 36], [8, 36], [8, 37], [8, 37], [8, 38], [8, 38], [7, 19], [7, 19], [7, 19], [7, 19], [8, 31], [8, 31], [8, 32], [8, 32], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [8, 53], [8, 53], [8, 54], [8, 54], [7, 26], [7, 26], [7, 26], [7, 26], [8, 39], [8, 39], [8, 40], [8, 40], [8, 41], [8, 41], [8, 42], [8, 42], [8, 43], [8, 43], [8, 44], [8, 44], [7, 21], [7, 21], [7, 21], [7, 21], [7, 28], [7, 28], [7, 28], [7, 28], [8, 61], [8, 61], [8, 62], [8, 62], [8, 63], [8, 63], [8, 0], [8, 0], [8, 320], [8, 320], [8, 384], [8, 384], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [7, 27], [7, 27], [7, 27], [7, 27], [8, 59], [8, 59], [8, 60], [8, 60], [9, 1472], [9, 1536], [9, 1600], [9, 1728], [7, 18], [7, 18], [7, 18], [7, 18], [7, 24], [7, 24], [7, 24], [7, 24], [8, 49], [8, 49], [8, 50], [8, 50], [8, 51], [8, 51], [8, 52], [8, 52], [7, 25], [7, 25], [7, 25], [7, 25], [8, 55], [8, 55], [8, 56], [8, 56], [8, 57], [8, 57], [8, 58], [8, 58], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [8, 448], [8, 448], [8, 512], [8, 512], [9, 704], [9, 768], [8, 640], [8, 640], [8, 576], [8, 576], [9, 832], [9, 896], [9, 960], [9, 1024], [9, 1088], [9, 1152], [9, 1216], [9, 1280], [9, 1344], [9, 1408], [7, 256], [7, 256], [7, 256], [7, 256], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7]], w = [[-1, -1], [-1, -1], [12, a], [12, a], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [11, 1792], [11, 1792], [12, 1984], [12, 1984], [12, 2048], [12, 2048], [12, 2112], [12, 2112], [12, 2176], [12, 2176], [12, 2240], [12, 2240], [12, 2304], [12, 2304], [11, 1856], [11, 1856], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [11, 1920], [11, 1920], [12, 2368], [12, 2368], [12, 2432], [12, 2432], [12, 2496], [12, 2496], [12, 2560], [12, 2560], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [12, 52], [12, 52], [13, 640], [13, 704], [13, 768], [13, 832], [12, 55], [12, 55], [12, 56], [12, 56], [13, 1280], [13, 1344], [13, 1408], [13, 1472], [12, 59], [12, 59], [12, 60], [12, 60], [13, 1536], [13, 1600], [11, 24], [11, 24], [11, 24], [11, 24], [11, 25], [11, 25], [11, 25], [11, 25], [13, 1664], [13, 1728], [12, 320], [12, 320], [12, 384], [12, 384], [12, 448], [12, 448], [13, 512], [13, 576], [12, 53], [12, 53], [12, 54], [12, 54], [13, 896], [13, 960], [13, 1024], [13, 1088], [13, 1152], [13, 1216], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64]], O = [[8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [11, 23], [11, 23], [12, 50], [12, 51], [12, 44], [12, 45], [12, 46], [12, 47], [12, 57], [12, 58], [12, 61], [12, 256], [10, 16], [10, 16], [10, 16], [10, 16], [10, 17], [10, 17], [10, 17], [10, 17], [12, 48], [12, 49], [12, 62], [12, 63], [12, 30], [12, 31], [12, 32], [12, 33], [12, 40], [12, 41], [11, 22], [11, 22], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [12, 128], [12, 192], [12, 26], [12, 27], [12, 28], [12, 29], [11, 19], [11, 19], [11, 20], [11, 20], [12, 34], [12, 35], [12, 36], [12, 37], [12, 38], [12, 39], [11, 21], [11, 21], [12, 42], [12, 43], [10, 0], [10, 0], [10, 0], [10, 0], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12]], b = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [6, 9], [6, 8], [5, 7], [5, 7], [4, 6], [4, 6], [4, 6], [4, 6], [4, 5], [4, 5], [4, 5], [4, 5], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2]];
          class A {
            constructor(j, X = {}) {
              if (!j || typeof j.next != "function")
                throw new Error('CCITTFaxDecoder - invalid "source" parameter.');
              this.source = j, this.eof = !1, this.encoding = X.K || 0, this.eoline = X.EndOfLine || !1, this.byteAlign = X.EncodedByteAlign || !1, this.columns = X.Columns || 1728, this.rows = X.Rows || 0;
              let B = X.EndOfBlock;
              B == null && (B = !0), this.eoblock = B, this.black = X.BlackIs1 || !1, this.codingLine = new Uint32Array(this.columns + 1), this.refLine = new Uint32Array(this.columns + 2), this.codingLine[0] = this.columns, this.codingPos = 0, this.row = 0, this.nextLine2D = this.encoding < 0, this.inputBits = 0, this.inputBuf = 0, this.outputBits = 0, this.rowsDone = !1;
              let U;
              for (; (U = this._lookBits(12)) === 0; )
                this._eatBits(1);
              U === 1 && this._eatBits(12), this.encoding > 0 && (this.nextLine2D = !this._lookBits(1), this._eatBits(1));
            }
            readNextChar() {
              if (this.eof)
                return -1;
              const j = this.refLine, X = this.codingLine, B = this.columns;
              let U, k, x, f;
              if (this.outputBits === 0) {
                if (this.rowsDone && (this.eof = !0), this.eof)
                  return -1;
                this.err = !1;
                let _, S, C;
                if (this.nextLine2D) {
                  for (f = 0; X[f] < B; ++f)
                    j[f] = X[f];
                  for (j[f++] = B, j[f] = B, X[0] = 0, this.codingPos = 0, U = 0, k = 0; X[this.codingPos] < B; )
                    switch (_ = this._getTwoDimCode(), _) {
                      case h:
                        this._addPixels(j[U + 1], k), j[U + 1] < B && (U += 2);
                        break;
                      case e:
                        if (_ = S = 0, k) {
                          do
                            _ += C = this._getBlackCode();
                          while (C >= 64);
                          do
                            S += C = this._getWhiteCode();
                          while (C >= 64);
                        } else {
                          do
                            _ += C = this._getWhiteCode();
                          while (C >= 64);
                          do
                            S += C = this._getBlackCode();
                          while (C >= 64);
                        }
                        for (this._addPixels(X[this.codingPos] + _, k), X[this.codingPos] < B && this._addPixels(X[this.codingPos] + S, k ^ 1); j[U] <= X[this.codingPos] && j[U] < B; )
                          U += 2;
                        break;
                      case g:
                        if (this._addPixels(j[U] + 3, k), k ^= 1, X[this.codingPos] < B)
                          for (++U; j[U] <= X[this.codingPos] && j[U] < B; )
                            U += 2;
                        break;
                      case m:
                        if (this._addPixels(j[U] + 2, k), k ^= 1, X[this.codingPos] < B)
                          for (++U; j[U] <= X[this.codingPos] && j[U] < B; )
                            U += 2;
                        break;
                      case c:
                        if (this._addPixels(j[U] + 1, k), k ^= 1, X[this.codingPos] < B)
                          for (++U; j[U] <= X[this.codingPos] && j[U] < B; )
                            U += 2;
                        break;
                      case y:
                        if (this._addPixels(j[U], k), k ^= 1, X[this.codingPos] < B)
                          for (++U; j[U] <= X[this.codingPos] && j[U] < B; )
                            U += 2;
                        break;
                      case n:
                        if (this._addPixelsNeg(j[U] - 3, k), k ^= 1, X[this.codingPos] < B)
                          for (U > 0 ? --U : ++U; j[U] <= X[this.codingPos] && j[U] < B; )
                            U += 2;
                        break;
                      case p:
                        if (this._addPixelsNeg(j[U] - 2, k), k ^= 1, X[this.codingPos] < B)
                          for (U > 0 ? --U : ++U; j[U] <= X[this.codingPos] && j[U] < B; )
                            U += 2;
                        break;
                      case d:
                        if (this._addPixelsNeg(j[U] - 1, k), k ^= 1, X[this.codingPos] < B)
                          for (U > 0 ? --U : ++U; j[U] <= X[this.codingPos] && j[U] < B; )
                            U += 2;
                        break;
                      case v:
                        this._addPixels(B, 0), this.eof = !0;
                        break;
                      default:
                        (0, t.info)("bad 2d code"), this._addPixels(B, 0), this.err = !0;
                    }
                } else
                  for (X[0] = 0, this.codingPos = 0, k = 0; X[this.codingPos] < B; ) {
                    if (_ = 0, k)
                      do
                        _ += C = this._getBlackCode();
                      while (C >= 64);
                    else
                      do
                        _ += C = this._getWhiteCode();
                      while (C >= 64);
                    this._addPixels(X[this.codingPos] + _, k), k ^= 1;
                  }
                let T = !1;
                if (this.byteAlign && (this.inputBits &= -8), !this.eoblock && this.row === this.rows - 1)
                  this.rowsDone = !0;
                else {
                  if (_ = this._lookBits(12), this.eoline)
                    for (; _ !== v && _ !== 1; )
                      this._eatBits(1), _ = this._lookBits(12);
                  else
                    for (; _ === 0; )
                      this._eatBits(1), _ = this._lookBits(12);
                  _ === 1 ? (this._eatBits(12), T = !0) : _ === v && (this.eof = !0);
                }
                if (!this.eof && this.encoding > 0 && !this.rowsDone && (this.nextLine2D = !this._lookBits(1), this._eatBits(1)), this.eoblock && T && this.byteAlign) {
                  if (_ = this._lookBits(12), _ === 1) {
                    if (this._eatBits(12), this.encoding > 0 && (this._lookBits(1), this._eatBits(1)), this.encoding >= 0)
                      for (f = 0; f < 4; ++f)
                        _ = this._lookBits(12), _ !== 1 && (0, t.info)("bad rtc code: " + _), this._eatBits(12), this.encoding > 0 && (this._lookBits(1), this._eatBits(1));
                    this.eof = !0;
                  }
                } else if (this.err && this.eoline) {
                  for (; ; ) {
                    if (_ = this._lookBits(13), _ === v)
                      return this.eof = !0, -1;
                    if (_ >> 1 === 1)
                      break;
                    this._eatBits(1);
                  }
                  this._eatBits(12), this.encoding > 0 && (this._eatBits(1), this.nextLine2D = !(_ & 1));
                }
                X[0] > 0 ? this.outputBits = X[this.codingPos = 0] : this.outputBits = X[this.codingPos = 1], this.row++;
              }
              let D;
              if (this.outputBits >= 8)
                D = this.codingPos & 1 ? 0 : 255, this.outputBits -= 8, this.outputBits === 0 && X[this.codingPos] < B && (this.codingPos++, this.outputBits = X[this.codingPos] - X[this.codingPos - 1]);
              else {
                x = 8, D = 0;
                do {
                  if (typeof this.outputBits != "number")
                    throw new t.FormatError('Invalid /CCITTFaxDecode data, "outputBits" must be a number.');
                  this.outputBits > x ? (D <<= x, this.codingPos & 1 || (D |= 255 >> 8 - x), this.outputBits -= x, x = 0) : (D <<= this.outputBits, this.codingPos & 1 || (D |= 255 >> 8 - this.outputBits), x -= this.outputBits, this.outputBits = 0, X[this.codingPos] < B ? (this.codingPos++, this.outputBits = X[this.codingPos] - X[this.codingPos - 1]) : x > 0 && (D <<= x, x = 0));
                } while (x);
              }
              return this.black && (D ^= 255), D;
            }
            _addPixels(j, X) {
              const B = this.codingLine;
              let U = this.codingPos;
              j > B[U] && (j > this.columns && ((0, t.info)("row is wrong length"), this.err = !0, j = this.columns), U & 1 ^ X && ++U, B[U] = j), this.codingPos = U;
            }
            _addPixelsNeg(j, X) {
              const B = this.codingLine;
              let U = this.codingPos;
              if (j > B[U])
                j > this.columns && ((0, t.info)("row is wrong length"), this.err = !0, j = this.columns), U & 1 ^ X && ++U, B[U] = j;
              else if (j < B[U]) {
                for (j < 0 && ((0, t.info)("invalid code"), this.err = !0, j = 0); U > 0 && j < B[U - 1]; )
                  --U;
                B[U] = j;
              }
              this.codingPos = U;
            }
            _findTableCode(j, X, B, U) {
              const k = U || 0;
              for (let x = j; x <= X; ++x) {
                let f = this._lookBits(x);
                if (f === v)
                  return [!0, 1, !1];
                if (x < X && (f <<= X - x), !k || f >= k) {
                  const D = B[f - k];
                  if (D[0] === x)
                    return this._eatBits(x), [!0, D[1], !0];
                }
              }
              return [!1, 0, !1];
            }
            _getTwoDimCode() {
              let j = 0, X;
              if (this.eoblock) {
                if (j = this._lookBits(7), X = i[j], X && X[0] > 0)
                  return this._eatBits(X[0]), X[1];
              } else {
                const B = this._findTableCode(1, 7, i);
                if (B[0] && B[2])
                  return B[1];
              }
              return (0, t.info)("Bad two dim code"), v;
            }
            _getWhiteCode() {
              let j = 0, X;
              if (this.eoblock) {
                if (j = this._lookBits(12), j === v)
                  return 1;
                if (j >> 5 ? X = u[j >> 3] : X = l[j], X[0] > 0)
                  return this._eatBits(X[0]), X[1];
              } else {
                let B = this._findTableCode(1, 9, u);
                if (B[0] || (B = this._findTableCode(11, 12, l), B[0]))
                  return B[1];
              }
              return (0, t.info)("bad white code"), this._eatBits(1), 1;
            }
            _getBlackCode() {
              let j, X;
              if (this.eoblock) {
                if (j = this._lookBits(13), j === v)
                  return 1;
                if (j >> 7 ? !(j >> 9) && j >> 7 ? X = O[(j >> 1) - 64] : X = b[j >> 7] : X = w[j], X[0] > 0)
                  return this._eatBits(X[0]), X[1];
              } else {
                let B = this._findTableCode(2, 6, b);
                if (B[0] || (B = this._findTableCode(7, 12, O, 64), B[0]) || (B = this._findTableCode(10, 13, w), B[0]))
                  return B[1];
              }
              return (0, t.info)("bad black code"), this._eatBits(1), 1;
            }
            _lookBits(j) {
              let X;
              for (; this.inputBits < j; ) {
                if ((X = this.source.next()) === -1)
                  return this.inputBits === 0 ? v : this.inputBuf << j - this.inputBits & 65535 >> 16 - j;
                this.inputBuf = this.inputBuf << 8 | X, this.inputBits += 8;
              }
              return this.inputBuf >> this.inputBits - j & 65535 >> 16 - j;
            }
            _eatBits(j) {
              (this.inputBits -= j) < 0 && (this.inputBits = 0);
            }
          }
          o.CCITTFaxDecoder = A;
        },
        /* 23 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.FlateStream = void 0;
          var t = F(19), a = F(2);
          const v = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), h = new Int32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]), e = new Int32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353, 876545]), y = [new Int32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9], c = [new Int32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5];
          class d extends t.DecodeStream {
            constructor(p, g) {
              super(g), this.str = p, this.dict = p.dict;
              const n = p.getByte(), i = p.getByte();
              if (n === -1 || i === -1)
                throw new a.FormatError(`Invalid header in flate stream: ${n}, ${i}`);
              if ((n & 15) !== 8)
                throw new a.FormatError(`Unknown compression method in flate stream: ${n}, ${i}`);
              if (((n << 8) + i) % 31 !== 0)
                throw new a.FormatError(`Bad FCHECK in flate stream: ${n}, ${i}`);
              if (i & 32)
                throw new a.FormatError(`FDICT bit set in flate stream: ${n}, ${i}`);
              this.codeSize = 0, this.codeBuf = 0;
            }
            getBits(p) {
              const g = this.str;
              let n = this.codeSize, i = this.codeBuf, l;
              for (; n < p; ) {
                if ((l = g.getByte()) === -1)
                  throw new a.FormatError("Bad encoding in flate stream");
                i |= l << n, n += 8;
              }
              return l = i & (1 << p) - 1, this.codeBuf = i >> p, this.codeSize = n -= p, l;
            }
            getCode(p) {
              const g = this.str, n = p[0], i = p[1];
              let l = this.codeSize, u = this.codeBuf, w;
              for (; l < i && (w = g.getByte()) !== -1; )
                u |= w << l, l += 8;
              const O = n[u & (1 << i) - 1], b = O >> 16, A = O & 65535;
              if (b < 1 || l < b)
                throw new a.FormatError("Bad encoding in flate stream");
              return this.codeBuf = u >> b, this.codeSize = l - b, A;
            }
            generateHuffmanTable(p) {
              const g = p.length;
              let n = 0, i;
              for (i = 0; i < g; ++i)
                p[i] > n && (n = p[i]);
              const l = 1 << n, u = new Int32Array(l);
              for (let w = 1, O = 0, b = 2; w <= n; ++w, O <<= 1, b <<= 1)
                for (let A = 0; A < g; ++A)
                  if (p[A] === w) {
                    let Y = 0, j = O;
                    for (i = 0; i < w; ++i)
                      Y = Y << 1 | j & 1, j >>= 1;
                    for (i = Y; i < l; i += b)
                      u[i] = w << 16 | A;
                    ++O;
                  }
              return [u, n];
            }
            readBlock() {
              let p, g;
              const n = this.str;
              let i = this.getBits(3);
              if (i & 1 && (this.eof = !0), i >>= 1, i === 0) {
                let b;
                if ((b = n.getByte()) === -1)
                  throw new a.FormatError("Bad block header in flate stream");
                let A = b;
                if ((b = n.getByte()) === -1)
                  throw new a.FormatError("Bad block header in flate stream");
                if (A |= b << 8, (b = n.getByte()) === -1)
                  throw new a.FormatError("Bad block header in flate stream");
                let Y = b;
                if ((b = n.getByte()) === -1)
                  throw new a.FormatError("Bad block header in flate stream");
                if (Y |= b << 8, Y !== (~A & 65535) && (A !== 0 || Y !== 0))
                  throw new a.FormatError("Bad uncompressed block length in flate stream");
                this.codeBuf = 0, this.codeSize = 0;
                const j = this.bufferLength, X = j + A;
                if (p = this.ensureBuffer(X), this.bufferLength = X, A === 0)
                  n.peekByte() === -1 && (this.eof = !0);
                else {
                  const B = n.getBytes(A);
                  p.set(B, j), B.length < A && (this.eof = !0);
                }
                return;
              }
              let l, u;
              if (i === 1)
                l = y, u = c;
              else if (i === 2) {
                const b = this.getBits(5) + 257, A = this.getBits(5) + 1, Y = this.getBits(4) + 4, j = new Uint8Array(v.length);
                let X;
                for (X = 0; X < Y; ++X)
                  j[v[X]] = this.getBits(3);
                const B = this.generateHuffmanTable(j);
                g = 0, X = 0;
                const U = b + A, k = new Uint8Array(U);
                let x, f, D;
                for (; X < U; ) {
                  const _ = this.getCode(B);
                  if (_ === 16)
                    x = 2, f = 3, D = g;
                  else if (_ === 17)
                    x = 3, f = 3, D = g = 0;
                  else if (_ === 18)
                    x = 7, f = 11, D = g = 0;
                  else {
                    k[X++] = g = _;
                    continue;
                  }
                  let S = this.getBits(x) + f;
                  for (; S-- > 0; )
                    k[X++] = D;
                }
                l = this.generateHuffmanTable(k.subarray(0, b)), u = this.generateHuffmanTable(k.subarray(b, U));
              } else
                throw new a.FormatError("Unknown block type in flate stream");
              p = this.buffer;
              let w = p ? p.length : 0, O = this.bufferLength;
              for (; ; ) {
                let b = this.getCode(l);
                if (b < 256) {
                  O + 1 >= w && (p = this.ensureBuffer(O + 1), w = p.length), p[O++] = b;
                  continue;
                }
                if (b === 256) {
                  this.bufferLength = O;
                  return;
                }
                b -= 257, b = h[b];
                let A = b >> 16;
                A > 0 && (A = this.getBits(A)), g = (b & 65535) + A, b = this.getCode(u), b = e[b], A = b >> 16, A > 0 && (A = this.getBits(A));
                const Y = (b & 65535) + A;
                O + g >= w && (p = this.ensureBuffer(O + g), w = p.length);
                for (let j = 0; j < g; ++j, ++O)
                  p[O] = p[O - Y];
              }
            }
          }
          o.FlateStream = d;
        },
        /* 24 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.Jbig2Stream = void 0;
          var t = F(7), a = F(19), v = F(5), h = F(25), e = F(2);
          class y extends a.DecodeStream {
            constructor(d, m, p) {
              super(m), this.stream = d, this.dict = d.dict, this.maybeLength = m, this.params = p;
            }
            get bytes() {
              return (0, e.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
            }
            ensureBuffer(d) {
            }
            readBlock() {
              if (this.eof)
                return;
              const d = new h.Jbig2Image(), m = [];
              if (this.params instanceof v.Dict) {
                const n = this.params.get("JBIG2Globals");
                if (n instanceof t.BaseStream) {
                  const i = n.getBytes();
                  m.push({
                    data: i,
                    start: 0,
                    end: i.length
                  });
                }
              }
              m.push({
                data: this.bytes,
                start: 0,
                end: this.bytes.length
              });
              const p = d.parseChunks(m), g = p.length;
              for (let n = 0; n < g; n++)
                p[n] ^= 255;
              this.buffer = p, this.bufferLength = g, this.eof = !0;
            }
          }
          o.Jbig2Stream = y;
        },
        /* 25 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.Jbig2Image = void 0;
          var t = F(2), a = F(6), v = F(26), h = F(22);
          class e extends t.BaseException {
            constructor(q) {
              super(`JBIG2 error: ${q}`, "Jbig2Error");
            }
          }
          class y {
            getContexts(q) {
              return q in this ? this[q] : this[q] = new Int8Array(65536);
            }
          }
          class c {
            constructor(q, N, Q) {
              this.data = q, this.start = N, this.end = Q;
            }
            get decoder() {
              const q = new v.ArithmeticDecoder(this.data, this.start, this.end);
              return (0, t.shadow)(this, "decoder", q);
            }
            get contextCache() {
              const q = new y();
              return (0, t.shadow)(this, "contextCache", q);
            }
          }
          function d(se, q, N) {
            const Q = se.getContexts(q);
            let E = 1;
            function te(W) {
              let I = 0;
              for (let H = 0; H < W; H++) {
                const ie = N.readBit(Q, E);
                E = E < 256 ? E << 1 | ie : (E << 1 | ie) & 511 | 256, I = I << 1 | ie;
              }
              return I >>> 0;
            }
            const oe = te(1), ee = te(1) ? te(1) ? te(1) ? te(1) ? te(1) ? te(32) + 4436 : te(12) + 340 : te(8) + 84 : te(6) + 20 : te(4) + 4 : te(2);
            return oe === 0 ? ee : ee > 0 ? -ee : null;
          }
          function m(se, q, N) {
            const Q = se.getContexts("IAID");
            let E = 1;
            for (let te = 0; te < N; te++) {
              const oe = q.readBit(Q, E);
              E = E << 1 | oe;
            }
            return N < 31 ? E & (1 << N) - 1 : E & 2147483647;
          }
          const p = ["SymbolDictionary", null, null, null, "IntermediateTextRegion", null, "ImmediateTextRegion", "ImmediateLosslessTextRegion", null, null, null, null, null, null, null, null, "PatternDictionary", null, null, null, "IntermediateHalftoneRegion", null, "ImmediateHalftoneRegion", "ImmediateLosslessHalftoneRegion", null, null, null, null, null, null, null, null, null, null, null, null, "IntermediateGenericRegion", null, "ImmediateGenericRegion", "ImmediateLosslessGenericRegion", "IntermediateGenericRefinementRegion", null, "ImmediateGenericRefinementRegion", "ImmediateLosslessGenericRefinementRegion", null, null, null, null, "PageInformation", "EndOfPage", "EndOfStripe", "EndOfFile", "Profiles", "Tables", null, null, null, null, null, null, null, null, "Extension"], g = [[{
            x: -1,
            y: -2
          }, {
            x: 0,
            y: -2
          }, {
            x: 1,
            y: -2
          }, {
            x: -2,
            y: -1
          }, {
            x: -1,
            y: -1
          }, {
            x: 0,
            y: -1
          }, {
            x: 1,
            y: -1
          }, {
            x: 2,
            y: -1
          }, {
            x: -4,
            y: 0
          }, {
            x: -3,
            y: 0
          }, {
            x: -2,
            y: 0
          }, {
            x: -1,
            y: 0
          }], [{
            x: -1,
            y: -2
          }, {
            x: 0,
            y: -2
          }, {
            x: 1,
            y: -2
          }, {
            x: 2,
            y: -2
          }, {
            x: -2,
            y: -1
          }, {
            x: -1,
            y: -1
          }, {
            x: 0,
            y: -1
          }, {
            x: 1,
            y: -1
          }, {
            x: 2,
            y: -1
          }, {
            x: -3,
            y: 0
          }, {
            x: -2,
            y: 0
          }, {
            x: -1,
            y: 0
          }], [{
            x: -1,
            y: -2
          }, {
            x: 0,
            y: -2
          }, {
            x: 1,
            y: -2
          }, {
            x: -2,
            y: -1
          }, {
            x: -1,
            y: -1
          }, {
            x: 0,
            y: -1
          }, {
            x: 1,
            y: -1
          }, {
            x: -2,
            y: 0
          }, {
            x: -1,
            y: 0
          }], [{
            x: -3,
            y: -1
          }, {
            x: -2,
            y: -1
          }, {
            x: -1,
            y: -1
          }, {
            x: 0,
            y: -1
          }, {
            x: 1,
            y: -1
          }, {
            x: -4,
            y: 0
          }, {
            x: -3,
            y: 0
          }, {
            x: -2,
            y: 0
          }, {
            x: -1,
            y: 0
          }]], n = [{
            coding: [{
              x: 0,
              y: -1
            }, {
              x: 1,
              y: -1
            }, {
              x: -1,
              y: 0
            }],
            reference: [{
              x: 0,
              y: -1
            }, {
              x: 1,
              y: -1
            }, {
              x: -1,
              y: 0
            }, {
              x: 0,
              y: 0
            }, {
              x: 1,
              y: 0
            }, {
              x: -1,
              y: 1
            }, {
              x: 0,
              y: 1
            }, {
              x: 1,
              y: 1
            }]
          }, {
            coding: [{
              x: -1,
              y: -1
            }, {
              x: 0,
              y: -1
            }, {
              x: 1,
              y: -1
            }, {
              x: -1,
              y: 0
            }],
            reference: [{
              x: 0,
              y: -1
            }, {
              x: -1,
              y: 0
            }, {
              x: 0,
              y: 0
            }, {
              x: 1,
              y: 0
            }, {
              x: 0,
              y: 1
            }, {
              x: 1,
              y: 1
            }]
          }], i = [39717, 1941, 229, 405], l = [32, 8];
          function u(se, q, N) {
            const Q = N.decoder, E = N.contextCache.getContexts("GB"), te = [];
            let oe, ee, W, I, H, ie, ue;
            const fe = 31735;
            for (ee = 0; ee < q; ee++)
              for (H = te[ee] = new Uint8Array(se), ie = ee < 1 ? H : te[ee - 1], ue = ee < 2 ? H : te[ee - 2], oe = ue[0] << 13 | ue[1] << 12 | ue[2] << 11 | ie[0] << 7 | ie[1] << 6 | ie[2] << 5 | ie[3] << 4, W = 0; W < se; W++)
                H[W] = I = Q.readBit(E, oe), oe = (oe & fe) << 1 | (W + 3 < se ? ue[W + 3] << 11 : 0) | (W + 4 < se ? ie[W + 4] << 4 : 0) | I;
            return te;
          }
          function w(se, q, N, Q, E, te, oe, ee) {
            if (se) {
              const Xe = new Z(ee.data, ee.start, ee.end);
              return K(Xe, q, N, !1);
            }
            if (Q === 0 && !te && !E && oe.length === 4 && oe[0].x === 3 && oe[0].y === -1 && oe[1].x === -3 && oe[1].y === -1 && oe[2].x === 2 && oe[2].y === -2 && oe[3].x === -2 && oe[3].y === -2)
              return u(q, N, ee);
            const W = !!te, I = g[Q].concat(oe);
            I.sort(function(Xe, Ct) {
              return Xe.y - Ct.y || Xe.x - Ct.x;
            });
            const H = I.length, ie = new Int8Array(H), ue = new Int8Array(H), fe = [];
            let de = 0, pe = 0, xe = 0, Fe = 0, Se, Ce;
            for (Ce = 0; Ce < H; Ce++)
              ie[Ce] = I[Ce].x, ue[Ce] = I[Ce].y, pe = Math.min(pe, I[Ce].x), xe = Math.max(xe, I[Ce].x), Fe = Math.min(Fe, I[Ce].y), Ce < H - 1 && I[Ce].y === I[Ce + 1].y && I[Ce].x === I[Ce + 1].x - 1 ? de |= 1 << H - 1 - Ce : fe.push(Ce);
            const ke = fe.length, ye = new Int8Array(ke), De = new Int8Array(ke), Ae = new Uint16Array(ke);
            for (Se = 0; Se < ke; Se++)
              Ce = fe[Se], ye[Se] = I[Ce].x, De[Se] = I[Ce].y, Ae[Se] = 1 << H - 1 - Ce;
            const Te = -pe, ve = -Fe, Ne = q - xe, Ge = i[Q];
            let it = new Uint8Array(q);
            const Me = [], Ie = ee.decoder, Ee = ee.contextCache.getContexts("GB");
            let st = 0, Qe, ct, xt, Je = 0, mt, _t;
            for (let Xe = 0; Xe < N; Xe++) {
              if (E) {
                const Ct = Ie.readBit(Ee, Ge);
                if (st ^= Ct, st) {
                  Me.push(it);
                  continue;
                }
              }
              for (it = new Uint8Array(it), Me.push(it), Qe = 0; Qe < q; Qe++) {
                if (W && te[Xe][Qe]) {
                  it[Qe] = 0;
                  continue;
                }
                if (Qe >= Te && Qe < Ne && Xe >= ve)
                  for (Je = Je << 1 & de, Ce = 0; Ce < ke; Ce++)
                    ct = Xe + De[Ce], xt = Qe + ye[Ce], mt = Me[ct][xt], mt && (mt = Ae[Ce], Je |= mt);
                else
                  for (Je = 0, _t = H - 1, Ce = 0; Ce < H; Ce++, _t--)
                    xt = Qe + ie[Ce], xt >= 0 && xt < q && (ct = Xe + ue[Ce], ct >= 0 && (mt = Me[ct][xt], mt && (Je |= mt << _t)));
                const Ct = Ie.readBit(Ee, Je);
                it[Qe] = Ct;
              }
            }
            return Me;
          }
          function O(se, q, N, Q, E, te, oe, ee, W) {
            let I = n[N].coding;
            N === 0 && (I = I.concat([ee[0]]));
            const H = I.length, ie = new Int32Array(H), ue = new Int32Array(H);
            let fe;
            for (fe = 0; fe < H; fe++)
              ie[fe] = I[fe].x, ue[fe] = I[fe].y;
            let de = n[N].reference;
            N === 0 && (de = de.concat([ee[1]]));
            const pe = de.length, xe = new Int32Array(pe), Fe = new Int32Array(pe);
            for (fe = 0; fe < pe; fe++)
              xe[fe] = de[fe].x, Fe[fe] = de[fe].y;
            const Se = Q[0].length, Ce = Q.length, ke = l[N], ye = [], De = W.decoder, Ae = W.contextCache.getContexts("GR");
            let Te = 0;
            for (let ve = 0; ve < q; ve++) {
              if (oe) {
                const Ge = De.readBit(Ae, ke);
                if (Te ^= Ge, Te)
                  throw new e("prediction is not supported");
              }
              const Ne = new Uint8Array(se);
              ye.push(Ne);
              for (let Ge = 0; Ge < se; Ge++) {
                let it, Me, Ie = 0;
                for (fe = 0; fe < H; fe++)
                  it = ve + ue[fe], Me = Ge + ie[fe], it < 0 || Me < 0 || Me >= se ? Ie <<= 1 : Ie = Ie << 1 | ye[it][Me];
                for (fe = 0; fe < pe; fe++)
                  it = ve + Fe[fe] - te, Me = Ge + xe[fe] - E, it < 0 || it >= Ce || Me < 0 || Me >= Se ? Ie <<= 1 : Ie = Ie << 1 | Q[it][Me];
                const Ee = De.readBit(Ae, Ie);
                Ne[Ge] = Ee;
              }
            }
            return ye;
          }
          function b(se, q, N, Q, E, te, oe, ee, W, I, H, ie) {
            if (se && q)
              throw new e("symbol refinement with Huffman is not supported");
            const ue = [];
            let fe = 0, de = (0, a.log2)(N.length + Q);
            const pe = H.decoder, xe = H.contextCache;
            let Fe, Se;
            for (se && (Fe = G(1), Se = [], de = Math.max(de, 1)); ue.length < Q; ) {
              const ve = se ? te.tableDeltaHeight.decode(ie) : d(xe, "IADH", pe);
              fe += ve;
              let Ne = 0, Ge = 0;
              const it = se ? Se.length : 0;
              for (; ; ) {
                const Me = se ? te.tableDeltaWidth.decode(ie) : d(xe, "IADW", pe);
                if (Me === null)
                  break;
                Ne += Me, Ge += Ne;
                let Ie;
                if (q) {
                  const Ee = d(xe, "IAAI", pe);
                  if (Ee > 1)
                    Ie = A(se, q, Ne, fe, 0, Ee, 1, N.concat(ue), de, 0, 0, 1, 0, te, W, I, H, 0, ie);
                  else {
                    const st = m(xe, pe, de), Qe = d(xe, "IARDX", pe), ct = d(xe, "IARDY", pe), xt = st < N.length ? N[st] : ue[st - N.length];
                    Ie = O(Ne, fe, W, xt, Qe, ct, !1, I, H);
                  }
                  ue.push(Ie);
                } else
                  se ? Se.push(Ne) : (Ie = w(!1, Ne, fe, oe, !1, null, ee, H), ue.push(Ie));
              }
              if (se && !q) {
                const Me = te.tableBitmapSize.decode(ie);
                ie.byteAlign();
                let Ie;
                if (Me === 0)
                  Ie = L(ie, Ge, fe);
                else {
                  const st = ie.end, Qe = ie.position + Me;
                  ie.end = Qe, Ie = K(ie, Ge, fe, !1), ie.end = st, ie.position = Qe;
                }
                const Ee = Se.length;
                if (it === Ee - 1)
                  ue.push(Ie);
                else {
                  let st, Qe, ct = 0, xt, Je, mt;
                  for (st = it; st < Ee; st++) {
                    for (Je = Se[st], xt = ct + Je, mt = [], Qe = 0; Qe < fe; Qe++)
                      mt.push(Ie[Qe].subarray(ct, xt));
                    ue.push(mt), ct = xt;
                  }
                }
              }
            }
            const Ce = [], ke = [];
            let ye = !1, De, Ae;
            const Te = N.length + Q;
            for (; ke.length < Te; ) {
              let ve = se ? Fe.decode(ie) : d(xe, "IAEX", pe);
              for (; ve--; )
                ke.push(ye);
              ye = !ye;
            }
            for (De = 0, Ae = N.length; De < Ae; De++)
              ke[De] && Ce.push(N[De]);
            for (let ve = 0; ve < Q; De++, ve++)
              ke[De] && Ce.push(ue[ve]);
            return Ce;
          }
          function A(se, q, N, Q, E, te, oe, ee, W, I, H, ie, ue, fe, de, pe, xe, Fe, Se) {
            if (se && q)
              throw new e("refinement with Huffman is not supported");
            const Ce = [];
            let ke, ye;
            for (ke = 0; ke < Q; ke++) {
              if (ye = new Uint8Array(N), E)
                for (let Ne = 0; Ne < N; Ne++)
                  ye[Ne] = E;
              Ce.push(ye);
            }
            const De = xe.decoder, Ae = xe.contextCache;
            let Te = se ? -fe.tableDeltaT.decode(Se) : -d(Ae, "IADT", De), ve = 0;
            for (ke = 0; ke < te; ) {
              const Ne = se ? fe.tableDeltaT.decode(Se) : d(Ae, "IADT", De);
              Te += Ne;
              const Ge = se ? fe.tableFirstS.decode(Se) : d(Ae, "IAFS", De);
              ve += Ge;
              let it = ve;
              do {
                let Me = 0;
                oe > 1 && (Me = se ? Se.readBits(Fe) : d(Ae, "IAIT", De));
                const Ie = oe * Te + Me, Ee = se ? fe.symbolIDTable.decode(Se) : m(Ae, De, W), st = q && (se ? Se.readBit() : d(Ae, "IARI", De));
                let Qe = ee[Ee], ct = Qe[0].length, xt = Qe.length;
                if (st) {
                  const Pe = d(Ae, "IARDW", De), qe = d(Ae, "IARDH", De), ot = d(Ae, "IARDX", De), lt = d(Ae, "IARDY", De);
                  ct += Pe, xt += qe, Qe = O(ct, xt, de, Qe, (Pe >> 1) + ot, (qe >> 1) + lt, !1, pe, xe);
                }
                const Je = Ie - (ie & 1 ? 0 : xt - 1), mt = it - (ie & 2 ? ct - 1 : 0);
                let _t, Xe, Ct;
                if (I) {
                  for (_t = 0; _t < xt; _t++) {
                    if (ye = Ce[mt + _t], !ye)
                      continue;
                    Ct = Qe[_t];
                    const Pe = Math.min(N - Je, ct);
                    switch (ue) {
                      case 0:
                        for (Xe = 0; Xe < Pe; Xe++)
                          ye[Je + Xe] |= Ct[Xe];
                        break;
                      case 2:
                        for (Xe = 0; Xe < Pe; Xe++)
                          ye[Je + Xe] ^= Ct[Xe];
                        break;
                      default:
                        throw new e(`operator ${ue} is not supported`);
                    }
                  }
                  it += xt - 1;
                } else {
                  for (Xe = 0; Xe < xt; Xe++)
                    if (ye = Ce[Je + Xe], !!ye)
                      switch (Ct = Qe[Xe], ue) {
                        case 0:
                          for (_t = 0; _t < ct; _t++)
                            ye[mt + _t] |= Ct[_t];
                          break;
                        case 2:
                          for (_t = 0; _t < ct; _t++)
                            ye[mt + _t] ^= Ct[_t];
                          break;
                        default:
                          throw new e(`operator ${ue} is not supported`);
                      }
                  it += ct - 1;
                }
                ke++;
                const bt = se ? fe.tableDeltaS.decode(Se) : d(Ae, "IADS", De);
                if (bt === null)
                  break;
                it += bt + H;
              } while (!0);
            }
            return Ce;
          }
          function Y(se, q, N, Q, E, te) {
            const oe = [];
            se || (oe.push({
              x: -q,
              y: 0
            }), E === 0 && oe.push({
              x: -3,
              y: -1
            }, {
              x: 2,
              y: -2
            }, {
              x: -2,
              y: -2
            }));
            const ee = (Q + 1) * q, W = w(se, ee, N, E, !1, null, oe, te), I = [];
            for (let H = 0; H <= Q; H++) {
              const ie = [], ue = q * H, fe = ue + q;
              for (let de = 0; de < N; de++)
                ie.push(W[de].subarray(ue, fe));
              I.push(ie);
            }
            return I;
          }
          function j(se, q, N, Q, E, te, oe, ee, W, I, H, ie, ue, fe, de) {
            if (oe)
              throw new e("skip is not supported");
            if (ee !== 0)
              throw new e(`operator "${ee}" is not supported in halftone region`);
            const xe = [];
            let Fe, Se, Ce;
            for (Fe = 0; Fe < E; Fe++) {
              if (Ce = new Uint8Array(Q), te)
                for (Se = 0; Se < Q; Se++)
                  Ce[Se] = te;
              xe.push(Ce);
            }
            const ke = q.length, ye = q[0], De = ye[0].length, Ae = ye.length, Te = (0, a.log2)(ke), ve = [];
            se || (ve.push({
              x: N <= 1 ? 3 : 2,
              y: -1
            }), N === 0 && ve.push({
              x: -3,
              y: -1
            }, {
              x: 2,
              y: -2
            }, {
              x: -2,
              y: -2
            }));
            const Ne = [];
            let Ge, it;
            for (se && (Ge = new Z(de.data, de.start, de.end)), Fe = Te - 1; Fe >= 0; Fe--)
              se ? it = K(Ge, W, I, !0) : it = w(!1, W, I, N, !1, null, ve, de), Ne[Fe] = it;
            let Me, Ie, Ee, st, Qe, ct, xt, Je, mt;
            for (Me = 0; Me < I; Me++)
              for (Ie = 0; Ie < W; Ie++) {
                for (Ee = 0, st = 0, Se = Te - 1; Se >= 0; Se--)
                  Ee ^= Ne[Se][Me][Ie], st |= Ee << Se;
                if (Qe = q[st], ct = H + Me * fe + Ie * ue >> 8, xt = ie + Me * ue - Ie * fe >> 8, ct >= 0 && ct + De <= Q && xt >= 0 && xt + Ae <= E)
                  for (Fe = 0; Fe < Ae; Fe++)
                    for (mt = xe[xt + Fe], Je = Qe[Fe], Se = 0; Se < De; Se++)
                      mt[ct + Se] |= Je[Se];
                else {
                  let _t, Xe;
                  for (Fe = 0; Fe < Ae; Fe++)
                    if (Xe = xt + Fe, !(Xe < 0 || Xe >= E))
                      for (mt = xe[Xe], Je = Qe[Fe], Se = 0; Se < De; Se++)
                        _t = ct + Se, _t >= 0 && _t < Q && (mt[_t] |= Je[Se]);
                }
              }
            return xe;
          }
          function X(se, q) {
            const N = {};
            N.number = (0, a.readUint32)(se, q);
            const Q = se[q + 4], E = Q & 63;
            if (!p[E])
              throw new e("invalid segment type: " + E);
            N.type = E, N.typeName = p[E], N.deferredNonRetain = !!(Q & 128);
            const te = !!(Q & 64), oe = se[q + 5];
            let ee = oe >> 5 & 7;
            const W = [oe & 31];
            let I = q + 6;
            if (oe === 7) {
              ee = (0, a.readUint32)(se, I - 1) & 536870911, I += 3;
              let de = ee + 7 >> 3;
              for (W[0] = se[I++]; --de > 0; )
                W.push(se[I++]);
            } else if (oe === 5 || oe === 6)
              throw new e("invalid referred-to flags");
            N.retainBits = W;
            let H = 4;
            N.number <= 256 ? H = 1 : N.number <= 65536 && (H = 2);
            const ie = [];
            let ue, fe;
            for (ue = 0; ue < ee; ue++) {
              let de;
              H === 1 ? de = se[I] : H === 2 ? de = (0, a.readUint16)(se, I) : de = (0, a.readUint32)(se, I), ie.push(de), I += H;
            }
            if (N.referredTo = ie, te ? (N.pageAssociation = (0, a.readUint32)(se, I), I += 4) : N.pageAssociation = se[I++], N.length = (0, a.readUint32)(se, I), I += 4, N.length === 4294967295)
              if (E === 38) {
                const de = U(se, I), xe = !!(se[I + k] & 1), Fe = 6, Se = new Uint8Array(Fe);
                for (xe || (Se[0] = 255, Se[1] = 172), Se[2] = de.height >>> 24 & 255, Se[3] = de.height >> 16 & 255, Se[4] = de.height >> 8 & 255, Se[5] = de.height & 255, ue = I, fe = se.length; ue < fe; ue++) {
                  let Ce = 0;
                  for (; Ce < Fe && Se[Ce] === se[ue + Ce]; )
                    Ce++;
                  if (Ce === Fe) {
                    N.length = ue + Fe;
                    break;
                  }
                }
                if (N.length === 4294967295)
                  throw new e("segment end was not found");
              } else
                throw new e("invalid unknown segment length");
            return N.headerEnd = I, N;
          }
          function B(se, q, N, Q) {
            const E = [];
            let te = N;
            for (; te < Q; ) {
              const oe = X(q, te);
              te = oe.headerEnd;
              const ee = {
                header: oe,
                data: q
              };
              if (se.randomAccess || (ee.start = te, te += oe.length, ee.end = te), E.push(ee), oe.type === 51)
                break;
            }
            if (se.randomAccess)
              for (let oe = 0, ee = E.length; oe < ee; oe++)
                E[oe].start = te, te += E[oe].header.length, E[oe].end = te;
            return E;
          }
          function U(se, q) {
            return {
              width: (0, a.readUint32)(se, q),
              height: (0, a.readUint32)(se, q + 4),
              x: (0, a.readUint32)(se, q + 8),
              y: (0, a.readUint32)(se, q + 12),
              combinationOperator: se[q + 16] & 7
            };
          }
          const k = 17;
          function x(se, q) {
            const N = se.header, Q = se.data, E = se.end;
            let te = se.start, oe, ee, W, I;
            switch (N.type) {
              case 0:
                const ie = {}, ue = (0, a.readUint16)(Q, te);
                if (ie.huffman = !!(ue & 1), ie.refinement = !!(ue & 2), ie.huffmanDHSelector = ue >> 2 & 3, ie.huffmanDWSelector = ue >> 4 & 3, ie.bitmapSizeSelector = ue >> 6 & 1, ie.aggregationInstancesSelector = ue >> 7 & 1, ie.bitmapCodingContextUsed = !!(ue & 256), ie.bitmapCodingContextRetained = !!(ue & 512), ie.template = ue >> 10 & 3, ie.refinementTemplate = ue >> 12 & 1, te += 2, !ie.huffman) {
                  for (I = ie.template === 0 ? 4 : 1, ee = [], W = 0; W < I; W++)
                    ee.push({
                      x: (0, a.readInt8)(Q, te),
                      y: (0, a.readInt8)(Q, te + 1)
                    }), te += 2;
                  ie.at = ee;
                }
                if (ie.refinement && !ie.refinementTemplate) {
                  for (ee = [], W = 0; W < 2; W++)
                    ee.push({
                      x: (0, a.readInt8)(Q, te),
                      y: (0, a.readInt8)(Q, te + 1)
                    }), te += 2;
                  ie.refinementAt = ee;
                }
                ie.numberOfExportedSymbols = (0, a.readUint32)(Q, te), te += 4, ie.numberOfNewSymbols = (0, a.readUint32)(Q, te), te += 4, oe = [ie, N.number, N.referredTo, Q, te, E];
                break;
              case 6:
              case 7:
                const fe = {};
                fe.info = U(Q, te), te += k;
                const de = (0, a.readUint16)(Q, te);
                if (te += 2, fe.huffman = !!(de & 1), fe.refinement = !!(de & 2), fe.logStripSize = de >> 2 & 3, fe.stripSize = 1 << fe.logStripSize, fe.referenceCorner = de >> 4 & 3, fe.transposed = !!(de & 64), fe.combinationOperator = de >> 7 & 3, fe.defaultPixelValue = de >> 9 & 1, fe.dsOffset = de << 17 >> 27, fe.refinementTemplate = de >> 15 & 1, fe.huffman) {
                  const Ae = (0, a.readUint16)(Q, te);
                  te += 2, fe.huffmanFS = Ae & 3, fe.huffmanDS = Ae >> 2 & 3, fe.huffmanDT = Ae >> 4 & 3, fe.huffmanRefinementDW = Ae >> 6 & 3, fe.huffmanRefinementDH = Ae >> 8 & 3, fe.huffmanRefinementDX = Ae >> 10 & 3, fe.huffmanRefinementDY = Ae >> 12 & 3, fe.huffmanRefinementSizeSelector = !!(Ae & 16384);
                }
                if (fe.refinement && !fe.refinementTemplate) {
                  for (ee = [], W = 0; W < 2; W++)
                    ee.push({
                      x: (0, a.readInt8)(Q, te),
                      y: (0, a.readInt8)(Q, te + 1)
                    }), te += 2;
                  fe.refinementAt = ee;
                }
                fe.numberOfSymbolInstances = (0, a.readUint32)(Q, te), te += 4, oe = [fe, N.referredTo, Q, te, E];
                break;
              case 16:
                const pe = {}, xe = Q[te++];
                pe.mmr = !!(xe & 1), pe.template = xe >> 1 & 3, pe.patternWidth = Q[te++], pe.patternHeight = Q[te++], pe.maxPatternIndex = (0, a.readUint32)(Q, te), te += 4, oe = [pe, N.number, Q, te, E];
                break;
              case 22:
              case 23:
                const Fe = {};
                Fe.info = U(Q, te), te += k;
                const Se = Q[te++];
                Fe.mmr = !!(Se & 1), Fe.template = Se >> 1 & 3, Fe.enableSkip = !!(Se & 8), Fe.combinationOperator = Se >> 4 & 7, Fe.defaultPixelValue = Se >> 7 & 1, Fe.gridWidth = (0, a.readUint32)(Q, te), te += 4, Fe.gridHeight = (0, a.readUint32)(Q, te), te += 4, Fe.gridOffsetX = (0, a.readUint32)(Q, te) & 4294967295, te += 4, Fe.gridOffsetY = (0, a.readUint32)(Q, te) & 4294967295, te += 4, Fe.gridVectorX = (0, a.readUint16)(Q, te), te += 2, Fe.gridVectorY = (0, a.readUint16)(Q, te), te += 2, oe = [Fe, N.referredTo, Q, te, E];
                break;
              case 38:
              case 39:
                const Ce = {};
                Ce.info = U(Q, te), te += k;
                const ke = Q[te++];
                if (Ce.mmr = !!(ke & 1), Ce.template = ke >> 1 & 3, Ce.prediction = !!(ke & 8), !Ce.mmr) {
                  for (I = Ce.template === 0 ? 4 : 1, ee = [], W = 0; W < I; W++)
                    ee.push({
                      x: (0, a.readInt8)(Q, te),
                      y: (0, a.readInt8)(Q, te + 1)
                    }), te += 2;
                  Ce.at = ee;
                }
                oe = [Ce, Q, te, E];
                break;
              case 48:
                const ye = {
                  width: (0, a.readUint32)(Q, te),
                  height: (0, a.readUint32)(Q, te + 4),
                  resolutionX: (0, a.readUint32)(Q, te + 8),
                  resolutionY: (0, a.readUint32)(Q, te + 12)
                };
                ye.height === 4294967295 && delete ye.height;
                const De = Q[te + 16];
                (0, a.readUint16)(Q, te + 17), ye.lossless = !!(De & 1), ye.refinement = !!(De & 2), ye.defaultPixelValue = De >> 2 & 1, ye.combinationOperator = De >> 3 & 3, ye.requiresBuffer = !!(De & 32), ye.combinationOperatorOverride = !!(De & 64), oe = [ye];
                break;
              case 49:
                break;
              case 50:
                break;
              case 51:
                break;
              case 53:
                oe = [N.number, Q, te, E];
                break;
              case 62:
                break;
              default:
                throw new e(`segment type ${N.typeName}(${N.type}) is not implemented`);
            }
            const H = "on" + N.typeName;
            H in q && q[H].apply(q, oe);
          }
          function f(se, q) {
            for (let N = 0, Q = se.length; N < Q; N++)
              x(se[N], q);
          }
          function D(se) {
            const q = new _();
            for (let N = 0, Q = se.length; N < Q; N++) {
              const E = se[N], te = B({}, E.data, E.start, E.end);
              f(te, q);
            }
            return q.buffer;
          }
          class _ {
            onPageInformation(q) {
              this.currentPageInfo = q;
              const N = q.width + 7 >> 3, Q = new Uint8ClampedArray(N * q.height);
              q.defaultPixelValue && Q.fill(255), this.buffer = Q;
            }
            drawBitmap(q, N) {
              const Q = this.currentPageInfo, E = q.width, te = q.height, oe = Q.width + 7 >> 3, ee = Q.combinationOperatorOverride ? q.combinationOperator : Q.combinationOperator, W = this.buffer, I = 128 >> (q.x & 7);
              let H = q.y * oe + (q.x >> 3), ie, ue, fe, de;
              switch (ee) {
                case 0:
                  for (ie = 0; ie < te; ie++) {
                    for (fe = I, de = H, ue = 0; ue < E; ue++)
                      N[ie][ue] && (W[de] |= fe), fe >>= 1, fe || (fe = 128, de++);
                    H += oe;
                  }
                  break;
                case 2:
                  for (ie = 0; ie < te; ie++) {
                    for (fe = I, de = H, ue = 0; ue < E; ue++)
                      N[ie][ue] && (W[de] ^= fe), fe >>= 1, fe || (fe = 128, de++);
                    H += oe;
                  }
                  break;
                default:
                  throw new e(`operator ${ee} is not supported`);
              }
            }
            onImmediateGenericRegion(q, N, Q, E) {
              const te = q.info, oe = new c(N, Q, E), ee = w(q.mmr, te.width, te.height, q.template, q.prediction, null, q.at, oe);
              this.drawBitmap(te, ee);
            }
            onImmediateLosslessGenericRegion() {
              this.onImmediateGenericRegion(...arguments);
            }
            onSymbolDictionary(q, N, Q, E, te, oe) {
              let ee, W;
              q.huffman && (ee = V(q, Q, this.customTables), W = new Z(E, te, oe));
              let I = this.symbols;
              I || (this.symbols = I = {});
              const H = [];
              for (const ue of Q) {
                const fe = I[ue];
                fe && H.push(...fe);
              }
              const ie = new c(E, te, oe);
              I[N] = b(q.huffman, q.refinement, H, q.numberOfNewSymbols, q.numberOfExportedSymbols, ee, q.template, q.at, q.refinementTemplate, q.refinementAt, ie, W);
            }
            onImmediateTextRegion(q, N, Q, E, te) {
              const oe = q.info;
              let ee, W;
              const I = this.symbols, H = [];
              for (const de of N) {
                const pe = I[de];
                pe && H.push(...pe);
              }
              const ie = (0, a.log2)(H.length);
              q.huffman && (W = new Z(Q, E, te), ee = z(q, N, this.customTables, H.length, W));
              const ue = new c(Q, E, te), fe = A(q.huffman, q.refinement, oe.width, oe.height, q.defaultPixelValue, q.numberOfSymbolInstances, q.stripSize, H, ie, q.transposed, q.dsOffset, q.referenceCorner, q.combinationOperator, ee, q.refinementTemplate, q.refinementAt, ue, q.logStripSize, W);
              this.drawBitmap(oe, fe);
            }
            onImmediateLosslessTextRegion() {
              this.onImmediateTextRegion(...arguments);
            }
            onPatternDictionary(q, N, Q, E, te) {
              let oe = this.patterns;
              oe || (this.patterns = oe = {});
              const ee = new c(Q, E, te);
              oe[N] = Y(q.mmr, q.patternWidth, q.patternHeight, q.maxPatternIndex, q.template, ee);
            }
            onImmediateHalftoneRegion(q, N, Q, E, te) {
              const oe = this.patterns[N[0]], ee = q.info, W = new c(Q, E, te), I = j(q.mmr, oe, q.template, ee.width, ee.height, q.defaultPixelValue, q.enableSkip, q.combinationOperator, q.gridWidth, q.gridHeight, q.gridOffsetX, q.gridOffsetY, q.gridVectorX, q.gridVectorY, W);
              this.drawBitmap(ee, I);
            }
            onImmediateLosslessHalftoneRegion() {
              this.onImmediateHalftoneRegion(...arguments);
            }
            onTables(q, N, Q, E) {
              let te = this.customTables;
              te || (this.customTables = te = {}), te[q] = P(N, Q, E);
            }
          }
          class S {
            constructor(q) {
              q.length === 2 ? (this.isOOB = !0, this.rangeLow = 0, this.prefixLength = q[0], this.rangeLength = 0, this.prefixCode = q[1], this.isLowerRange = !1) : (this.isOOB = !1, this.rangeLow = q[0], this.prefixLength = q[1], this.rangeLength = q[2], this.prefixCode = q[3], this.isLowerRange = q[4] === "lower");
            }
          }
          class C {
            constructor(q) {
              this.children = [], q ? (this.isLeaf = !0, this.rangeLength = q.rangeLength, this.rangeLow = q.rangeLow, this.isLowerRange = q.isLowerRange, this.isOOB = q.isOOB) : this.isLeaf = !1;
            }
            buildTree(q, N) {
              const Q = q.prefixCode >> N & 1;
              if (N <= 0)
                this.children[Q] = new C(q);
              else {
                let E = this.children[Q];
                E || (this.children[Q] = E = new C(null)), E.buildTree(q, N - 1);
              }
            }
            decodeNode(q) {
              if (this.isLeaf) {
                if (this.isOOB)
                  return null;
                const Q = q.readBits(this.rangeLength);
                return this.rangeLow + (this.isLowerRange ? -Q : Q);
              }
              const N = this.children[q.readBit()];
              if (!N)
                throw new e("invalid Huffman data");
              return N.decodeNode(q);
            }
          }
          class T {
            constructor(q, N) {
              N || this.assignPrefixCodes(q), this.rootNode = new C(null);
              for (let Q = 0, E = q.length; Q < E; Q++) {
                const te = q[Q];
                te.prefixLength > 0 && this.rootNode.buildTree(te, te.prefixLength - 1);
              }
            }
            decode(q) {
              return this.rootNode.decodeNode(q);
            }
            assignPrefixCodes(q) {
              const N = q.length;
              let Q = 0;
              for (let H = 0; H < N; H++)
                Q = Math.max(Q, q[H].prefixLength);
              const E = new Uint32Array(Q + 1);
              for (let H = 0; H < N; H++)
                E[q[H].prefixLength]++;
              let te = 1, oe = 0, ee, W, I;
              for (E[0] = 0; te <= Q; ) {
                for (oe = oe + E[te - 1] << 1, ee = oe, W = 0; W < N; )
                  I = q[W], I.prefixLength === te && (I.prefixCode = ee, ee++), W++;
                te++;
              }
            }
          }
          function P(se, q, N) {
            const Q = se[q], E = (0, a.readUint32)(se, q + 1) & 4294967295, te = (0, a.readUint32)(se, q + 5) & 4294967295, oe = new Z(se, q + 9, N), ee = (Q >> 1 & 7) + 1, W = (Q >> 4 & 7) + 1, I = [];
            let H, ie, ue = E;
            do
              H = oe.readBits(ee), ie = oe.readBits(W), I.push(new S([ue, H, ie, 0])), ue += 1 << ie;
            while (ue < te);
            return H = oe.readBits(ee), I.push(new S([E - 1, H, 32, 0, "lower"])), H = oe.readBits(ee), I.push(new S([te, H, 32, 0])), Q & 1 && (H = oe.readBits(ee), I.push(new S([H, 0]))), new T(I, !1);
          }
          const M = {};
          function G(se) {
            let q = M[se];
            if (q)
              return q;
            let N;
            switch (se) {
              case 1:
                N = [[0, 1, 4, 0], [16, 2, 8, 2], [272, 3, 16, 6], [65808, 3, 32, 7]];
                break;
              case 2:
                N = [[0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [75, 6, 32, 62], [6, 63]];
                break;
              case 3:
                N = [[-256, 8, 8, 254], [0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [-257, 8, 32, 255, "lower"], [75, 7, 32, 126], [6, 62]];
                break;
              case 4:
                N = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [76, 5, 32, 31]];
                break;
              case 5:
                N = [[-255, 7, 8, 126], [1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [-256, 7, 32, 127, "lower"], [76, 6, 32, 62]];
                break;
              case 6:
                N = [[-2048, 5, 10, 28], [-1024, 4, 9, 8], [-512, 4, 8, 9], [-256, 4, 7, 10], [-128, 5, 6, 29], [-64, 5, 5, 30], [-32, 4, 5, 11], [0, 2, 7, 0], [128, 3, 7, 2], [256, 3, 8, 3], [512, 4, 9, 12], [1024, 4, 10, 13], [-2049, 6, 32, 62, "lower"], [2048, 6, 32, 63]];
                break;
              case 7:
                N = [[-1024, 4, 9, 8], [-512, 3, 8, 0], [-256, 4, 7, 9], [-128, 5, 6, 26], [-64, 5, 5, 27], [-32, 4, 5, 10], [0, 4, 5, 11], [32, 5, 5, 28], [64, 5, 6, 29], [128, 4, 7, 12], [256, 3, 8, 1], [512, 3, 9, 2], [1024, 3, 10, 3], [-1025, 5, 32, 30, "lower"], [2048, 5, 32, 31]];
                break;
              case 8:
                N = [[-15, 8, 3, 252], [-7, 9, 1, 508], [-5, 8, 1, 253], [-3, 9, 0, 509], [-2, 7, 0, 124], [-1, 4, 0, 10], [0, 2, 1, 0], [2, 5, 0, 26], [3, 6, 0, 58], [4, 3, 4, 4], [20, 6, 1, 59], [22, 4, 4, 11], [38, 4, 5, 12], [70, 5, 6, 27], [134, 5, 7, 28], [262, 6, 7, 60], [390, 7, 8, 125], [646, 6, 10, 61], [-16, 9, 32, 510, "lower"], [1670, 9, 32, 511], [2, 1]];
                break;
              case 9:
                N = [[-31, 8, 4, 252], [-15, 9, 2, 508], [-11, 8, 2, 253], [-7, 9, 1, 509], [-5, 7, 1, 124], [-3, 4, 1, 10], [-1, 3, 1, 2], [1, 3, 1, 3], [3, 5, 1, 26], [5, 6, 1, 58], [7, 3, 5, 4], [39, 6, 2, 59], [43, 4, 5, 11], [75, 4, 6, 12], [139, 5, 7, 27], [267, 5, 8, 28], [523, 6, 8, 60], [779, 7, 9, 125], [1291, 6, 11, 61], [-32, 9, 32, 510, "lower"], [3339, 9, 32, 511], [2, 0]];
                break;
              case 10:
                N = [[-21, 7, 4, 122], [-5, 8, 0, 252], [-4, 7, 0, 123], [-3, 5, 0, 24], [-2, 2, 2, 0], [2, 5, 0, 25], [3, 6, 0, 54], [4, 7, 0, 124], [5, 8, 0, 253], [6, 2, 6, 1], [70, 5, 5, 26], [102, 6, 5, 55], [134, 6, 6, 56], [198, 6, 7, 57], [326, 6, 8, 58], [582, 6, 9, 59], [1094, 6, 10, 60], [2118, 7, 11, 125], [-22, 8, 32, 254, "lower"], [4166, 8, 32, 255], [2, 2]];
                break;
              case 11:
                N = [[1, 1, 0, 0], [2, 2, 1, 2], [4, 4, 0, 12], [5, 4, 1, 13], [7, 5, 1, 28], [9, 5, 2, 29], [13, 6, 2, 60], [17, 7, 2, 122], [21, 7, 3, 123], [29, 7, 4, 124], [45, 7, 5, 125], [77, 7, 6, 126], [141, 7, 32, 127]];
                break;
              case 12:
                N = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 1, 6], [5, 5, 0, 28], [6, 5, 1, 29], [8, 6, 1, 60], [10, 7, 0, 122], [11, 7, 1, 123], [13, 7, 2, 124], [17, 7, 3, 125], [25, 7, 4, 126], [41, 8, 5, 254], [73, 8, 32, 255]];
                break;
              case 13:
                N = [[1, 1, 0, 0], [2, 3, 0, 4], [3, 4, 0, 12], [4, 5, 0, 28], [5, 4, 1, 13], [7, 3, 3, 5], [15, 6, 1, 58], [17, 6, 2, 59], [21, 6, 3, 60], [29, 6, 4, 61], [45, 6, 5, 62], [77, 7, 6, 126], [141, 7, 32, 127]];
                break;
              case 14:
                N = [[-2, 3, 0, 4], [-1, 3, 0, 5], [0, 1, 0, 0], [1, 3, 0, 6], [2, 3, 0, 7]];
                break;
              case 15:
                N = [[-24, 7, 4, 124], [-8, 6, 2, 60], [-4, 5, 1, 28], [-2, 4, 0, 12], [-1, 3, 0, 4], [0, 1, 0, 0], [1, 3, 0, 5], [2, 4, 0, 13], [3, 5, 1, 29], [5, 6, 2, 61], [9, 7, 4, 125], [-25, 7, 32, 126, "lower"], [25, 7, 32, 127]];
                break;
              default:
                throw new e(`standard table B.${se} does not exist`);
            }
            for (let Q = 0, E = N.length; Q < E; Q++)
              N[Q] = new S(N[Q]);
            return q = new T(N, !0), M[se] = q, q;
          }
          class Z {
            constructor(q, N, Q) {
              this.data = q, this.start = N, this.end = Q, this.position = N, this.shift = -1, this.currentByte = 0;
            }
            readBit() {
              if (this.shift < 0) {
                if (this.position >= this.end)
                  throw new e("end of data while reading bit");
                this.currentByte = this.data[this.position++], this.shift = 7;
              }
              const q = this.currentByte >> this.shift & 1;
              return this.shift--, q;
            }
            readBits(q) {
              let N = 0, Q;
              for (Q = q - 1; Q >= 0; Q--)
                N |= this.readBit() << Q;
              return N;
            }
            byteAlign() {
              this.shift = -1;
            }
            next() {
              return this.position >= this.end ? -1 : this.data[this.position++];
            }
          }
          function $(se, q, N) {
            let Q = 0;
            for (let E = 0, te = q.length; E < te; E++) {
              const oe = N[q[E]];
              if (oe) {
                if (se === Q)
                  return oe;
                Q++;
              }
            }
            throw new e("can't find custom Huffman table");
          }
          function z(se, q, N, Q, E) {
            const te = [];
            for (let ue = 0; ue <= 34; ue++) {
              const fe = E.readBits(4);
              te.push(new S([ue, fe, 0, 0]));
            }
            const oe = new T(te, !1);
            te.length = 0;
            for (let ue = 0; ue < Q; ) {
              const fe = oe.decode(E);
              if (fe >= 32) {
                let de, pe, xe;
                switch (fe) {
                  case 32:
                    if (ue === 0)
                      throw new e("no previous value in symbol ID table");
                    pe = E.readBits(2) + 3, de = te[ue - 1].prefixLength;
                    break;
                  case 33:
                    pe = E.readBits(3) + 3, de = 0;
                    break;
                  case 34:
                    pe = E.readBits(7) + 11, de = 0;
                    break;
                  default:
                    throw new e("invalid code length in symbol ID table");
                }
                for (xe = 0; xe < pe; xe++)
                  te.push(new S([ue, de, 0, 0])), ue++;
              } else
                te.push(new S([ue, fe, 0, 0])), ue++;
            }
            E.byteAlign();
            const ee = new T(te, !1);
            let W = 0, I, H, ie;
            switch (se.huffmanFS) {
              case 0:
              case 1:
                I = G(se.huffmanFS + 6);
                break;
              case 3:
                I = $(W, q, N), W++;
                break;
              default:
                throw new e("invalid Huffman FS selector");
            }
            switch (se.huffmanDS) {
              case 0:
              case 1:
              case 2:
                H = G(se.huffmanDS + 8);
                break;
              case 3:
                H = $(W, q, N), W++;
                break;
              default:
                throw new e("invalid Huffman DS selector");
            }
            switch (se.huffmanDT) {
              case 0:
              case 1:
              case 2:
                ie = G(se.huffmanDT + 11);
                break;
              case 3:
                ie = $(W, q, N), W++;
                break;
              default:
                throw new e("invalid Huffman DT selector");
            }
            if (se.refinement)
              throw new e("refinement with Huffman is not supported");
            return {
              symbolIDTable: ee,
              tableFirstS: I,
              tableDeltaS: H,
              tableDeltaT: ie
            };
          }
          function V(se, q, N) {
            let Q = 0, E, te;
            switch (se.huffmanDHSelector) {
              case 0:
              case 1:
                E = G(se.huffmanDHSelector + 4);
                break;
              case 3:
                E = $(Q, q, N), Q++;
                break;
              default:
                throw new e("invalid Huffman DH selector");
            }
            switch (se.huffmanDWSelector) {
              case 0:
              case 1:
                te = G(se.huffmanDWSelector + 2);
                break;
              case 3:
                te = $(Q, q, N), Q++;
                break;
              default:
                throw new e("invalid Huffman DW selector");
            }
            let oe, ee;
            return se.bitmapSizeSelector ? (oe = $(Q, q, N), Q++) : oe = G(1), se.aggregationInstancesSelector ? ee = $(Q, q, N) : ee = G(1), {
              tableDeltaHeight: E,
              tableDeltaWidth: te,
              tableBitmapSize: oe,
              tableAggregateInstances: ee
            };
          }
          function L(se, q, N) {
            const Q = [];
            for (let E = 0; E < N; E++) {
              const te = new Uint8Array(q);
              Q.push(te);
              for (let oe = 0; oe < q; oe++)
                te[oe] = se.readBit();
              se.byteAlign();
            }
            return Q;
          }
          function K(se, q, N, Q) {
            const E = {
              K: -1,
              Columns: q,
              Rows: N,
              BlackIs1: !0,
              EndOfBlock: Q
            }, te = new h.CCITTFaxDecoder(se, E), oe = [];
            let ee, W = !1;
            for (let I = 0; I < N; I++) {
              const H = new Uint8Array(q);
              oe.push(H);
              let ie = -1;
              for (let ue = 0; ue < q; ue++)
                ie < 0 && (ee = te.readNextChar(), ee === -1 && (ee = 0, W = !0), ie = 7), H[ue] = ee >> ie & 1, ie--;
            }
            if (Q && !W)
              for (let H = 0; H < 5 && te.readNextChar() !== -1; H++)
                ;
            return oe;
          }
          class ne {
            parseChunks(q) {
              return D(q);
            }
            parse(q) {
              throw new Error("Not implemented: Jbig2Image.parse");
            }
          }
          o.Jbig2Image = ne;
        },
        /* 26 */
        /***/
        (J, o) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.ArithmeticDecoder = void 0;
          const F = [{
            qe: 22017,
            nmps: 1,
            nlps: 1,
            switchFlag: 1
          }, {
            qe: 13313,
            nmps: 2,
            nlps: 6,
            switchFlag: 0
          }, {
            qe: 6145,
            nmps: 3,
            nlps: 9,
            switchFlag: 0
          }, {
            qe: 2753,
            nmps: 4,
            nlps: 12,
            switchFlag: 0
          }, {
            qe: 1313,
            nmps: 5,
            nlps: 29,
            switchFlag: 0
          }, {
            qe: 545,
            nmps: 38,
            nlps: 33,
            switchFlag: 0
          }, {
            qe: 22017,
            nmps: 7,
            nlps: 6,
            switchFlag: 1
          }, {
            qe: 21505,
            nmps: 8,
            nlps: 14,
            switchFlag: 0
          }, {
            qe: 18433,
            nmps: 9,
            nlps: 14,
            switchFlag: 0
          }, {
            qe: 14337,
            nmps: 10,
            nlps: 14,
            switchFlag: 0
          }, {
            qe: 12289,
            nmps: 11,
            nlps: 17,
            switchFlag: 0
          }, {
            qe: 9217,
            nmps: 12,
            nlps: 18,
            switchFlag: 0
          }, {
            qe: 7169,
            nmps: 13,
            nlps: 20,
            switchFlag: 0
          }, {
            qe: 5633,
            nmps: 29,
            nlps: 21,
            switchFlag: 0
          }, {
            qe: 22017,
            nmps: 15,
            nlps: 14,
            switchFlag: 1
          }, {
            qe: 21505,
            nmps: 16,
            nlps: 14,
            switchFlag: 0
          }, {
            qe: 20737,
            nmps: 17,
            nlps: 15,
            switchFlag: 0
          }, {
            qe: 18433,
            nmps: 18,
            nlps: 16,
            switchFlag: 0
          }, {
            qe: 14337,
            nmps: 19,
            nlps: 17,
            switchFlag: 0
          }, {
            qe: 13313,
            nmps: 20,
            nlps: 18,
            switchFlag: 0
          }, {
            qe: 12289,
            nmps: 21,
            nlps: 19,
            switchFlag: 0
          }, {
            qe: 10241,
            nmps: 22,
            nlps: 19,
            switchFlag: 0
          }, {
            qe: 9217,
            nmps: 23,
            nlps: 20,
            switchFlag: 0
          }, {
            qe: 8705,
            nmps: 24,
            nlps: 21,
            switchFlag: 0
          }, {
            qe: 7169,
            nmps: 25,
            nlps: 22,
            switchFlag: 0
          }, {
            qe: 6145,
            nmps: 26,
            nlps: 23,
            switchFlag: 0
          }, {
            qe: 5633,
            nmps: 27,
            nlps: 24,
            switchFlag: 0
          }, {
            qe: 5121,
            nmps: 28,
            nlps: 25,
            switchFlag: 0
          }, {
            qe: 4609,
            nmps: 29,
            nlps: 26,
            switchFlag: 0
          }, {
            qe: 4353,
            nmps: 30,
            nlps: 27,
            switchFlag: 0
          }, {
            qe: 2753,
            nmps: 31,
            nlps: 28,
            switchFlag: 0
          }, {
            qe: 2497,
            nmps: 32,
            nlps: 29,
            switchFlag: 0
          }, {
            qe: 2209,
            nmps: 33,
            nlps: 30,
            switchFlag: 0
          }, {
            qe: 1313,
            nmps: 34,
            nlps: 31,
            switchFlag: 0
          }, {
            qe: 1089,
            nmps: 35,
            nlps: 32,
            switchFlag: 0
          }, {
            qe: 673,
            nmps: 36,
            nlps: 33,
            switchFlag: 0
          }, {
            qe: 545,
            nmps: 37,
            nlps: 34,
            switchFlag: 0
          }, {
            qe: 321,
            nmps: 38,
            nlps: 35,
            switchFlag: 0
          }, {
            qe: 273,
            nmps: 39,
            nlps: 36,
            switchFlag: 0
          }, {
            qe: 133,
            nmps: 40,
            nlps: 37,
            switchFlag: 0
          }, {
            qe: 73,
            nmps: 41,
            nlps: 38,
            switchFlag: 0
          }, {
            qe: 37,
            nmps: 42,
            nlps: 39,
            switchFlag: 0
          }, {
            qe: 21,
            nmps: 43,
            nlps: 40,
            switchFlag: 0
          }, {
            qe: 9,
            nmps: 44,
            nlps: 41,
            switchFlag: 0
          }, {
            qe: 5,
            nmps: 45,
            nlps: 42,
            switchFlag: 0
          }, {
            qe: 1,
            nmps: 45,
            nlps: 43,
            switchFlag: 0
          }, {
            qe: 22017,
            nmps: 46,
            nlps: 46,
            switchFlag: 0
          }];
          class t {
            constructor(v, h, e) {
              this.data = v, this.bp = h, this.dataEnd = e, this.chigh = v[h], this.clow = 0, this.byteIn(), this.chigh = this.chigh << 7 & 65535 | this.clow >> 9 & 127, this.clow = this.clow << 7 & 65535, this.ct -= 7, this.a = 32768;
            }
            byteIn() {
              const v = this.data;
              let h = this.bp;
              v[h] === 255 ? v[h + 1] > 143 ? (this.clow += 65280, this.ct = 8) : (h++, this.clow += v[h] << 9, this.ct = 7, this.bp = h) : (h++, this.clow += h < this.dataEnd ? v[h] << 8 : 65280, this.ct = 8, this.bp = h), this.clow > 65535 && (this.chigh += this.clow >> 16, this.clow &= 65535);
            }
            readBit(v, h) {
              let e = v[h] >> 1, y = v[h] & 1;
              const c = F[e], d = c.qe;
              let m, p = this.a - d;
              if (this.chigh < d)
                p < d ? (p = d, m = y, e = c.nmps) : (p = d, m = 1 ^ y, c.switchFlag === 1 && (y = m), e = c.nlps);
              else {
                if (this.chigh -= d, p & 32768)
                  return this.a = p, y;
                p < d ? (m = 1 ^ y, c.switchFlag === 1 && (y = m), e = c.nlps) : (m = y, e = c.nmps);
              }
              do
                this.ct === 0 && this.byteIn(), p <<= 1, this.chigh = this.chigh << 1 & 65535 | this.clow >> 15 & 1, this.clow = this.clow << 1 & 65535, this.ct--;
              while (!(p & 32768));
              return this.a = p, v[h] = e << 1 | y, m;
            }
          }
          o.ArithmeticDecoder = t;
        },
        /* 27 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.JpegStream = void 0;
          var t = F(19), a = F(5), v = F(28), h = F(2);
          class e extends t.DecodeStream {
            constructor(c, d, m) {
              let p;
              for (; (p = c.getByte()) !== -1; )
                if (p === 255) {
                  c.skip(-1);
                  break;
                }
              super(d), this.stream = c, this.dict = c.dict, this.maybeLength = d, this.params = m;
            }
            get bytes() {
              return (0, h.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
            }
            ensureBuffer(c) {
            }
            readBlock() {
              if (this.eof)
                return;
              const c = {
                decodeTransform: void 0,
                colorTransform: void 0
              }, d = this.dict.getArray("D", "Decode");
              if (this.forceRGB && Array.isArray(d)) {
                const g = this.dict.get("BPC", "BitsPerComponent") || 8, n = d.length, i = new Int32Array(n);
                let l = !1;
                const u = (1 << g) - 1;
                for (let w = 0; w < n; w += 2)
                  i[w] = (d[w + 1] - d[w]) * 256 | 0, i[w + 1] = d[w] * u | 0, (i[w] !== 256 || i[w + 1] !== 0) && (l = !0);
                l && (c.decodeTransform = i);
              }
              if (this.params instanceof a.Dict) {
                const g = this.params.get("ColorTransform");
                Number.isInteger(g) && (c.colorTransform = g);
              }
              const m = new v.JpegImage(c);
              m.parse(this.bytes);
              const p = m.getData({
                width: this.drawWidth,
                height: this.drawHeight,
                forceRGB: this.forceRGB,
                isSourcePDF: !0
              });
              this.buffer = p, this.bufferLength = p.length, this.eof = !0;
            }
          }
          o.JpegStream = e;
        },
        /* 28 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.JpegImage = void 0;
          var t = F(2), a = F(6);
          class v extends t.BaseException {
            constructor(B) {
              super(`JPEG error: ${B}`, "JpegError");
            }
          }
          class h extends t.BaseException {
            constructor(B, U) {
              super(B, "DNLMarkerError"), this.scanLines = U;
            }
          }
          class e extends t.BaseException {
            constructor(B) {
              super(B, "EOIMarkerError");
            }
          }
          const y = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), c = 4017, d = 799, m = 3406, p = 2276, g = 1567, n = 3784, i = 5793, l = 2896;
          function u(X, B) {
            let U = 0, k, x, f = 16;
            for (; f > 0 && !X[f - 1]; )
              f--;
            const D = [{
              children: [],
              index: 0
            }];
            let _ = D[0], S;
            for (k = 0; k < f; k++) {
              for (x = 0; x < X[k]; x++) {
                for (_ = D.pop(), _.children[_.index] = B[U]; _.index > 0; )
                  _ = D.pop();
                for (_.index++, D.push(_); D.length <= k; )
                  D.push(S = {
                    children: [],
                    index: 0
                  }), _.children[_.index] = S.children, _ = S;
                U++;
              }
              k + 1 < f && (D.push(S = {
                children: [],
                index: 0
              }), _.children[_.index] = S.children, _ = S);
            }
            return D[0].children;
          }
          function w(X, B, U) {
            return 64 * ((X.blocksPerLine + 1) * B + U);
          }
          function O(X, B, U, k, x, f, D, _, S, C = !1) {
            const T = U.mcusPerLine, P = U.progressive, M = B;
            let G = 0, Z = 0;
            function $() {
              if (Z > 0)
                return Z--, G >> Z & 1;
              if (G = X[B++], G === 255) {
                const ye = X[B++];
                if (ye) {
                  if (ye === 220 && C) {
                    B += 2;
                    const De = (0, a.readUint16)(X, B);
                    if (B += 2, De > 0 && De !== U.scanLines)
                      throw new h("Found DNL marker (0xFFDC) while parsing scan data", De);
                  } else if (ye === 217) {
                    if (C) {
                      const De = oe * (U.precision === 8 ? 8 : 0);
                      if (De > 0 && Math.round(U.scanLines / De) >= 10)
                        throw new h("Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter", De);
                    }
                    throw new e("Found EOI marker (0xFFD9) while parsing scan data");
                  }
                  throw new v(`unexpected marker ${(G << 8 | ye).toString(16)}`);
                }
              }
              return Z = 7, G >>> 7;
            }
            function z(ye) {
              let De = ye;
              for (; ; ) {
                switch (De = De[$()], typeof De) {
                  case "number":
                    return De;
                  case "object":
                    continue;
                }
                throw new v("invalid huffman sequence");
              }
            }
            function V(ye) {
              let De = 0;
              for (; ye > 0; )
                De = De << 1 | $(), ye--;
              return De;
            }
            function L(ye) {
              if (ye === 1)
                return $() === 1 ? 1 : -1;
              const De = V(ye);
              return De >= 1 << ye - 1 ? De : De + (-1 << ye) + 1;
            }
            function K(ye, De) {
              const Ae = z(ye.huffmanTableDC), Te = Ae === 0 ? 0 : L(Ae);
              ye.blockData[De] = ye.pred += Te;
              let ve = 1;
              for (; ve < 64; ) {
                const Ne = z(ye.huffmanTableAC), Ge = Ne & 15, it = Ne >> 4;
                if (Ge === 0) {
                  if (it < 15)
                    break;
                  ve += 16;
                  continue;
                }
                ve += it;
                const Me = y[ve];
                ye.blockData[De + Me] = L(Ge), ve++;
              }
            }
            function ne(ye, De) {
              const Ae = z(ye.huffmanTableDC), Te = Ae === 0 ? 0 : L(Ae) << S;
              ye.blockData[De] = ye.pred += Te;
            }
            function se(ye, De) {
              ye.blockData[De] |= $() << S;
            }
            let q = 0;
            function N(ye, De) {
              if (q > 0) {
                q--;
                return;
              }
              let Ae = f;
              const Te = D;
              for (; Ae <= Te; ) {
                const ve = z(ye.huffmanTableAC), Ne = ve & 15, Ge = ve >> 4;
                if (Ne === 0) {
                  if (Ge < 15) {
                    q = V(Ge) + (1 << Ge) - 1;
                    break;
                  }
                  Ae += 16;
                  continue;
                }
                Ae += Ge;
                const it = y[Ae];
                ye.blockData[De + it] = L(Ne) * (1 << S), Ae++;
              }
            }
            let Q = 0, E;
            function te(ye, De) {
              let Ae = f;
              const Te = D;
              let ve = 0, Ne, Ge;
              for (; Ae <= Te; ) {
                const it = De + y[Ae], Me = ye.blockData[it] < 0 ? -1 : 1;
                switch (Q) {
                  case 0:
                    if (Ge = z(ye.huffmanTableAC), Ne = Ge & 15, ve = Ge >> 4, Ne === 0)
                      ve < 15 ? (q = V(ve) + (1 << ve), Q = 4) : (ve = 16, Q = 1);
                    else {
                      if (Ne !== 1)
                        throw new v("invalid ACn encoding");
                      E = L(Ne), Q = ve ? 2 : 3;
                    }
                    continue;
                  case 1:
                  case 2:
                    ye.blockData[it] ? ye.blockData[it] += Me * ($() << S) : (ve--, ve === 0 && (Q = Q === 2 ? 3 : 0));
                    break;
                  case 3:
                    ye.blockData[it] ? ye.blockData[it] += Me * ($() << S) : (ye.blockData[it] = E << S, Q = 0);
                    break;
                  case 4:
                    ye.blockData[it] && (ye.blockData[it] += Me * ($() << S));
                    break;
                }
                Ae++;
              }
              Q === 4 && (q--, q === 0 && (Q = 0));
            }
            let oe = 0;
            function ee(ye, De, Ae, Te, ve) {
              const Ne = Ae / T | 0, Ge = Ae % T;
              oe = Ne * ye.v + Te;
              const it = Ge * ye.h + ve, Me = w(ye, oe, it);
              De(ye, Me);
            }
            function W(ye, De, Ae) {
              oe = Ae / ye.blocksPerLine | 0;
              const Te = Ae % ye.blocksPerLine, ve = w(ye, oe, Te);
              De(ye, ve);
            }
            const I = k.length;
            let H, ie, ue, fe, de, pe;
            P ? f === 0 ? pe = _ === 0 ? ne : se : pe = _ === 0 ? N : te : pe = K;
            let xe = 0, Fe, Se;
            I === 1 ? Se = k[0].blocksPerLine * k[0].blocksPerColumn : Se = T * U.mcusPerColumn;
            let Ce, ke;
            for (; xe <= Se; ) {
              const ye = x ? Math.min(Se - xe, x) : Se;
              if (ye > 0) {
                for (ie = 0; ie < I; ie++)
                  k[ie].pred = 0;
                if (q = 0, I === 1)
                  for (H = k[0], de = 0; de < ye; de++)
                    W(H, pe, xe), xe++;
                else
                  for (de = 0; de < ye; de++) {
                    for (ie = 0; ie < I; ie++)
                      for (H = k[ie], Ce = H.h, ke = H.v, ue = 0; ue < ke; ue++)
                        for (fe = 0; fe < Ce; fe++)
                          ee(H, pe, xe, ue, fe);
                    xe++;
                  }
              }
              if (Z = 0, Fe = Y(X, B), !Fe)
                break;
              if (Fe.invalid) {
                const De = ye > 0 ? "unexpected" : "excessive";
                (0, t.warn)(`decodeScan - ${De} MCU data, current marker is: ${Fe.invalid}`), B = Fe.offset;
              }
              if (Fe.marker >= 65488 && Fe.marker <= 65495)
                B += 2;
              else
                break;
            }
            return B - M;
          }
          function b(X, B, U) {
            const k = X.quantizationTable, x = X.blockData;
            let f, D, _, S, C, T, P, M, G, Z, $, z, V, L, K, ne, se;
            if (!k)
              throw new v("missing required Quantization Table.");
            for (let q = 0; q < 64; q += 8) {
              if (G = x[B + q], Z = x[B + q + 1], $ = x[B + q + 2], z = x[B + q + 3], V = x[B + q + 4], L = x[B + q + 5], K = x[B + q + 6], ne = x[B + q + 7], G *= k[q], !(Z | $ | z | V | L | K | ne)) {
                se = i * G + 512 >> 10, U[q] = se, U[q + 1] = se, U[q + 2] = se, U[q + 3] = se, U[q + 4] = se, U[q + 5] = se, U[q + 6] = se, U[q + 7] = se;
                continue;
              }
              Z *= k[q + 1], $ *= k[q + 2], z *= k[q + 3], V *= k[q + 4], L *= k[q + 5], K *= k[q + 6], ne *= k[q + 7], f = i * G + 128 >> 8, D = i * V + 128 >> 8, _ = $, S = K, C = l * (Z - ne) + 128 >> 8, M = l * (Z + ne) + 128 >> 8, T = z << 4, P = L << 4, f = f + D + 1 >> 1, D = f - D, se = _ * n + S * g + 128 >> 8, _ = _ * g - S * n + 128 >> 8, S = se, C = C + P + 1 >> 1, P = C - P, M = M + T + 1 >> 1, T = M - T, f = f + S + 1 >> 1, S = f - S, D = D + _ + 1 >> 1, _ = D - _, se = C * p + M * m + 2048 >> 12, C = C * m - M * p + 2048 >> 12, M = se, se = T * d + P * c + 2048 >> 12, T = T * c - P * d + 2048 >> 12, P = se, U[q] = f + M, U[q + 7] = f - M, U[q + 1] = D + P, U[q + 6] = D - P, U[q + 2] = _ + T, U[q + 5] = _ - T, U[q + 3] = S + C, U[q + 4] = S - C;
            }
            for (let q = 0; q < 8; ++q) {
              if (G = U[q], Z = U[q + 8], $ = U[q + 16], z = U[q + 24], V = U[q + 32], L = U[q + 40], K = U[q + 48], ne = U[q + 56], !(Z | $ | z | V | L | K | ne)) {
                se = i * G + 8192 >> 14, se < -2040 ? se = 0 : se >= 2024 ? se = 255 : se = se + 2056 >> 4, x[B + q] = se, x[B + q + 8] = se, x[B + q + 16] = se, x[B + q + 24] = se, x[B + q + 32] = se, x[B + q + 40] = se, x[B + q + 48] = se, x[B + q + 56] = se;
                continue;
              }
              f = i * G + 2048 >> 12, D = i * V + 2048 >> 12, _ = $, S = K, C = l * (Z - ne) + 2048 >> 12, M = l * (Z + ne) + 2048 >> 12, T = z, P = L, f = (f + D + 1 >> 1) + 4112, D = f - D, se = _ * n + S * g + 2048 >> 12, _ = _ * g - S * n + 2048 >> 12, S = se, C = C + P + 1 >> 1, P = C - P, M = M + T + 1 >> 1, T = M - T, f = f + S + 1 >> 1, S = f - S, D = D + _ + 1 >> 1, _ = D - _, se = C * p + M * m + 2048 >> 12, C = C * m - M * p + 2048 >> 12, M = se, se = T * d + P * c + 2048 >> 12, T = T * c - P * d + 2048 >> 12, P = se, G = f + M, ne = f - M, Z = D + P, K = D - P, $ = _ + T, L = _ - T, z = S + C, V = S - C, G < 16 ? G = 0 : G >= 4080 ? G = 255 : G >>= 4, Z < 16 ? Z = 0 : Z >= 4080 ? Z = 255 : Z >>= 4, $ < 16 ? $ = 0 : $ >= 4080 ? $ = 255 : $ >>= 4, z < 16 ? z = 0 : z >= 4080 ? z = 255 : z >>= 4, V < 16 ? V = 0 : V >= 4080 ? V = 255 : V >>= 4, L < 16 ? L = 0 : L >= 4080 ? L = 255 : L >>= 4, K < 16 ? K = 0 : K >= 4080 ? K = 255 : K >>= 4, ne < 16 ? ne = 0 : ne >= 4080 ? ne = 255 : ne >>= 4, x[B + q] = G, x[B + q + 8] = Z, x[B + q + 16] = $, x[B + q + 24] = z, x[B + q + 32] = V, x[B + q + 40] = L, x[B + q + 48] = K, x[B + q + 56] = ne;
            }
          }
          function A(X, B) {
            const U = B.blocksPerLine, k = B.blocksPerColumn, x = new Int16Array(64);
            for (let f = 0; f < k; f++)
              for (let D = 0; D < U; D++) {
                const _ = w(B, f, D);
                b(B, _, x);
              }
            return B.blockData;
          }
          function Y(X, B, U = B) {
            const k = X.length - 1;
            let x = U < B ? U : B;
            if (B >= k)
              return null;
            const f = (0, a.readUint16)(X, B);
            if (f >= 65472 && f <= 65534)
              return {
                invalid: null,
                marker: f,
                offset: B
              };
            let D = (0, a.readUint16)(X, x);
            for (; !(D >= 65472 && D <= 65534); ) {
              if (++x >= k)
                return null;
              D = (0, a.readUint16)(X, x);
            }
            return {
              invalid: f.toString(16),
              marker: D,
              offset: x
            };
          }
          class j {
            constructor({
              decodeTransform: B = null,
              colorTransform: U = -1
            } = {}) {
              this._decodeTransform = B, this._colorTransform = U;
            }
            parse(B, {
              dnlScanLines: U = null
            } = {}) {
              function k() {
                const $ = (0, a.readUint16)(B, f);
                f += 2;
                let z = f + $ - 2;
                const V = Y(B, z, f);
                V && V.invalid && ((0, t.warn)("readDataBlock - incorrect length, current marker is: " + V.invalid), z = V.offset);
                const L = B.subarray(f, z);
                return f += L.length, L;
              }
              function x($) {
                const z = Math.ceil($.samplesPerLine / 8 / $.maxH), V = Math.ceil($.scanLines / 8 / $.maxV);
                for (let L = 0, K = $.components.length; L < K; L++) {
                  const ne = $.components[L], se = Math.ceil(Math.ceil($.samplesPerLine / 8) * ne.h / $.maxH), q = Math.ceil(Math.ceil($.scanLines / 8) * ne.v / $.maxV), N = z * ne.h, E = 64 * (V * ne.v) * (N + 1);
                  ne.blockData = new Int16Array(E), ne.blocksPerLine = se, ne.blocksPerColumn = q;
                }
                $.mcusPerLine = z, $.mcusPerColumn = V;
              }
              let f = 0, D = null, _ = null, S, C, T = 0;
              const P = [], M = [], G = [];
              let Z = (0, a.readUint16)(B, f);
              if (f += 2, Z !== 65496)
                throw new v("SOI not found");
              Z = (0, a.readUint16)(B, f), f += 2;
              e:
                for (; Z !== 65497; ) {
                  let $, z, V;
                  switch (Z) {
                    case 65504:
                    case 65505:
                    case 65506:
                    case 65507:
                    case 65508:
                    case 65509:
                    case 65510:
                    case 65511:
                    case 65512:
                    case 65513:
                    case 65514:
                    case 65515:
                    case 65516:
                    case 65517:
                    case 65518:
                    case 65519:
                    case 65534:
                      const L = k();
                      Z === 65504 && L[0] === 74 && L[1] === 70 && L[2] === 73 && L[3] === 70 && L[4] === 0 && (D = {
                        version: {
                          major: L[5],
                          minor: L[6]
                        },
                        densityUnits: L[7],
                        xDensity: L[8] << 8 | L[9],
                        yDensity: L[10] << 8 | L[11],
                        thumbWidth: L[12],
                        thumbHeight: L[13],
                        thumbData: L.subarray(14, 14 + 3 * L[12] * L[13])
                      }), Z === 65518 && L[0] === 65 && L[1] === 100 && L[2] === 111 && L[3] === 98 && L[4] === 101 && (_ = {
                        version: L[5] << 8 | L[6],
                        flags0: L[7] << 8 | L[8],
                        flags1: L[9] << 8 | L[10],
                        transformCode: L[11]
                      });
                      break;
                    case 65499:
                      const K = (0, a.readUint16)(B, f);
                      f += 2;
                      const ne = K + f - 2;
                      let se;
                      for (; f < ne; ) {
                        const fe = B[f++], de = new Uint16Array(64);
                        if (fe >> 4)
                          if (fe >> 4 === 1)
                            for (z = 0; z < 64; z++)
                              se = y[z], de[se] = (0, a.readUint16)(B, f), f += 2;
                          else
                            throw new v("DQT - invalid table spec");
                        else
                          for (z = 0; z < 64; z++)
                            se = y[z], de[se] = B[f++];
                        P[fe & 15] = de;
                      }
                      break;
                    case 65472:
                    case 65473:
                    case 65474:
                      if (S)
                        throw new v("Only single frame JPEGs supported");
                      f += 2, S = {}, S.extended = Z === 65473, S.progressive = Z === 65474, S.precision = B[f++];
                      const q = (0, a.readUint16)(B, f);
                      f += 2, S.scanLines = U || q, S.samplesPerLine = (0, a.readUint16)(B, f), f += 2, S.components = [], S.componentIds = {};
                      const N = B[f++];
                      let Q = 0, E = 0;
                      for ($ = 0; $ < N; $++) {
                        const fe = B[f], de = B[f + 1] >> 4, pe = B[f + 1] & 15;
                        Q < de && (Q = de), E < pe && (E = pe);
                        const xe = B[f + 2];
                        V = S.components.push({
                          h: de,
                          v: pe,
                          quantizationId: xe,
                          quantizationTable: null
                        }), S.componentIds[fe] = V - 1, f += 3;
                      }
                      S.maxH = Q, S.maxV = E, x(S);
                      break;
                    case 65476:
                      const te = (0, a.readUint16)(B, f);
                      for (f += 2, $ = 2; $ < te; ) {
                        const fe = B[f++], de = new Uint8Array(16);
                        let pe = 0;
                        for (z = 0; z < 16; z++, f++)
                          pe += de[z] = B[f];
                        const xe = new Uint8Array(pe);
                        for (z = 0; z < pe; z++, f++)
                          xe[z] = B[f];
                        $ += 17 + pe, (fe >> 4 ? M : G)[fe & 15] = u(de, xe);
                      }
                      break;
                    case 65501:
                      f += 2, C = (0, a.readUint16)(B, f), f += 2;
                      break;
                    case 65498:
                      const oe = ++T === 1 && !U;
                      f += 2;
                      const ee = B[f++], W = [];
                      for ($ = 0; $ < ee; $++) {
                        const fe = B[f++], de = S.componentIds[fe], pe = S.components[de];
                        pe.index = fe;
                        const xe = B[f++];
                        pe.huffmanTableDC = G[xe >> 4], pe.huffmanTableAC = M[xe & 15], W.push(pe);
                      }
                      const I = B[f++], H = B[f++], ie = B[f++];
                      try {
                        const fe = O(B, f, S, W, C, I, H, ie >> 4, ie & 15, oe);
                        f += fe;
                      } catch (fe) {
                        if (fe instanceof h)
                          return (0, t.warn)(`${fe.message} -- attempting to re-parse the JPEG image.`), this.parse(B, {
                            dnlScanLines: fe.scanLines
                          });
                        if (fe instanceof e) {
                          (0, t.warn)(`${fe.message} -- ignoring the rest of the image data.`);
                          break e;
                        }
                        throw fe;
                      }
                      break;
                    case 65500:
                      f += 4;
                      break;
                    case 65535:
                      B[f] !== 255 && f--;
                      break;
                    default:
                      const ue = Y(B, f - 2, f - 3);
                      if (ue && ue.invalid) {
                        (0, t.warn)("JpegImage.parse - unexpected data, current marker is: " + ue.invalid), f = ue.offset;
                        break;
                      }
                      if (!ue || f >= B.length - 1) {
                        (0, t.warn)("JpegImage.parse - reached the end of the image data without finding an EOI marker (0xFFD9).");
                        break e;
                      }
                      throw new v("JpegImage.parse - unknown marker: " + Z.toString(16));
                  }
                  Z = (0, a.readUint16)(B, f), f += 2;
                }
              this.width = S.samplesPerLine, this.height = S.scanLines, this.jfif = D, this.adobe = _, this.components = [];
              for (let $ = 0, z = S.components.length; $ < z; $++) {
                const V = S.components[$], L = P[V.quantizationId];
                L && (V.quantizationTable = L), this.components.push({
                  index: V.index,
                  output: A(S, V),
                  scaleX: V.h / S.maxH,
                  scaleY: V.v / S.maxV,
                  blocksPerLine: V.blocksPerLine,
                  blocksPerColumn: V.blocksPerColumn
                });
              }
              this.numComponents = this.components.length;
            }
            _getLinearizedBlockData(B, U, k = !1) {
              const x = this.width / B, f = this.height / U;
              let D, _, S, C, T, P, M, G, Z, $, z = 0, V;
              const L = this.components.length, K = B * U * L, ne = new Uint8ClampedArray(K), se = new Uint32Array(B), q = 4294967288;
              let N;
              for (M = 0; M < L; M++) {
                if (D = this.components[M], _ = D.scaleX * x, S = D.scaleY * f, z = M, V = D.output, C = D.blocksPerLine + 1 << 3, _ !== N) {
                  for (T = 0; T < B; T++)
                    G = 0 | T * _, se[T] = (G & q) << 3 | G & 7;
                  N = _;
                }
                for (P = 0; P < U; P++)
                  for (G = 0 | P * S, $ = C * (G & q) | (G & 7) << 3, T = 0; T < B; T++)
                    ne[z] = V[$ + se[T]], z += L;
              }
              let Q = this._decodeTransform;
              if (!k && L === 4 && !Q && (Q = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255])), Q)
                for (M = 0; M < K; )
                  for (G = 0, Z = 0; G < L; G++, M++, Z += 2)
                    ne[M] = (ne[M] * Q[Z] >> 8) + Q[Z + 1];
              return ne;
            }
            get _isColorConversionNeeded() {
              return this.adobe ? !!this.adobe.transformCode : this.numComponents === 3 ? this._colorTransform === 0 ? !1 : !(this.components[0].index === 82 && this.components[1].index === 71 && this.components[2].index === 66) : this._colorTransform === 1;
            }
            _convertYccToRgb(B) {
              let U, k, x;
              for (let f = 0, D = B.length; f < D; f += 3)
                U = B[f], k = B[f + 1], x = B[f + 2], B[f] = U - 179.456 + 1.402 * x, B[f + 1] = U + 135.459 - 0.344 * k - 0.714 * x, B[f + 2] = U - 226.816 + 1.772 * k;
              return B;
            }
            _convertYcckToRgb(B) {
              let U, k, x, f, D = 0;
              for (let _ = 0, S = B.length; _ < S; _ += 4)
                U = B[_], k = B[_ + 1], x = B[_ + 2], f = B[_ + 3], B[D++] = -122.67195406894 + k * (-660635669420364e-19 * k + 437130475926232e-18 * x - 54080610064599e-18 * U + 48449797120281e-17 * f - 0.154362151871126) + x * (-957964378445773e-18 * x + 817076911346625e-18 * U - 0.00477271405408747 * f + 1.53380253221734) + U * (961250184130688e-18 * U - 0.00266257332283933 * f + 0.48357088451265) + f * (-336197177618394e-18 * f + 0.484791561490776), B[D++] = 107.268039397724 + k * (219927104525741e-19 * k - 640992018297945e-18 * x + 659397001245577e-18 * U + 426105652938837e-18 * f - 0.176491792462875) + x * (-778269941513683e-18 * x + 0.00130872261408275 * U + 770482631801132e-18 * f - 0.151051492775562) + U * (0.00126935368114843 * U - 0.00265090189010898 * f + 0.25802910206845) + f * (-318913117588328e-18 * f - 0.213742400323665), B[D++] = -20.810012546947 + k * (-570115196973677e-18 * k - 263409051004589e-19 * x + 0.0020741088115012 * U - 0.00288260236853442 * f + 0.814272968359295) + x * (-153496057440975e-19 * x - 132689043961446e-18 * U + 560833691242812e-18 * f - 0.195152027534049) + U * (0.00174418132927582 * U - 0.00255243321439347 * f + 0.116935020465145) + f * (-343531996510555e-18 * f + 0.24165260232407);
              return B.subarray(0, D);
            }
            _convertYcckToCmyk(B) {
              let U, k, x;
              for (let f = 0, D = B.length; f < D; f += 4)
                U = B[f], k = B[f + 1], x = B[f + 2], B[f] = 434.456 - U - 1.402 * x, B[f + 1] = 119.541 - U + 0.344 * k + 0.714 * x, B[f + 2] = 481.816 - U - 1.772 * k;
              return B;
            }
            _convertCmykToRgb(B) {
              let U, k, x, f, D = 0;
              for (let _ = 0, S = B.length; _ < S; _ += 4)
                U = B[_], k = B[_ + 1], x = B[_ + 2], f = B[_ + 3], B[D++] = 255 + U * (-6747147073602441e-20 * U + 8379262121013727e-19 * k + 2894718188643294e-19 * x + 0.003264231057537806 * f - 1.1185611867203937) + k * (26374107616089405e-21 * k - 8626949158638572e-20 * x - 2748769067499491e-19 * f - 0.02155688794978967) + x * (-3878099212869363e-20 * x - 3267808279485286e-19 * f + 0.0686742238595345) - f * (3361971776183937e-19 * f + 0.7430659151342254), B[D++] = 255 + U * (13596372813588848e-20 * U + 924537132573585e-18 * k + 10567359618683593e-20 * x + 4791864687436512e-19 * f - 0.3109689587515875) + k * (-23545346108370344e-20 * k + 2702845253534714e-19 * x + 0.0020200308977307156 * f - 0.7488052167015494) + x * (6834815998235662e-20 * x + 15168452363460973e-20 * f - 0.09751927774728933) - f * (3189131175883281e-19 * f + 0.7364883807733168), B[D++] = 255 + U * (13598650411385307e-21 * U + 12423956175490851e-20 * k + 4751985097583589e-19 * x - 36729317476630422e-22 * f - 0.05562186980264034) + k * (16141380598724676e-20 * k + 9692239130725186e-19 * x + 7782692450036253e-19 * f - 0.44015232367526463) + x * (5068882914068769e-22 * x + 0.0017778369011375071 * f - 0.7591454649749609) - f * (3435319965105553e-19 * f + 0.7063770186160144);
              return B.subarray(0, D);
            }
            getData({
              width: B,
              height: U,
              forceRGB: k = !1,
              isSourcePDF: x = !1
            }) {
              if (this.numComponents > 4)
                throw new v("Unsupported color mode");
              const f = this._getLinearizedBlockData(B, U, x);
              if (this.numComponents === 1 && k) {
                const D = f.length, _ = new Uint8ClampedArray(D * 3);
                let S = 0;
                for (let C = 0; C < D; C++) {
                  const T = f[C];
                  _[S++] = T, _[S++] = T, _[S++] = T;
                }
                return _;
              } else {
                if (this.numComponents === 3 && this._isColorConversionNeeded)
                  return this._convertYccToRgb(f);
                if (this.numComponents === 4) {
                  if (this._isColorConversionNeeded)
                    return k ? this._convertYcckToRgb(f) : this._convertYcckToCmyk(f);
                  if (k)
                    return this._convertCmykToRgb(f);
                }
              }
              return f;
            }
          }
          o.JpegImage = j;
        },
        /* 29 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.JpxStream = void 0;
          var t = F(19), a = F(30), v = F(2);
          class h extends t.DecodeStream {
            constructor(y, c, d) {
              super(c), this.stream = y, this.dict = y.dict, this.maybeLength = c, this.params = d;
            }
            get bytes() {
              return (0, v.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
            }
            ensureBuffer(y) {
            }
            readBlock() {
              if (this.eof)
                return;
              const y = new a.JpxImage();
              y.parse(this.bytes);
              const c = y.width, d = y.height, m = y.componentsCount, p = y.tiles.length;
              if (p === 1)
                this.buffer = y.tiles[0].items;
              else {
                const g = new Uint8ClampedArray(c * d * m);
                for (let n = 0; n < p; n++) {
                  const i = y.tiles[n], l = i.width, u = i.height, w = i.left, O = i.top, b = i.items;
                  let A = 0, Y = (c * O + w) * m;
                  const j = c * m, X = l * m;
                  for (let B = 0; B < u; B++) {
                    const U = b.subarray(A, A + X);
                    g.set(U, Y), A += X, Y += j;
                  }
                }
                this.buffer = g;
              }
              this.bufferLength = this.buffer.length, this.eof = !0;
            }
          }
          o.JpxStream = h;
        },
        /* 30 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.JpxImage = void 0;
          var t = F(2), a = F(6), v = F(26);
          class h extends t.BaseException {
            constructor(P) {
              super(`JPX error: ${P}`, "JpxError");
            }
          }
          const e = {
            LL: 0,
            LH: 1,
            HL: 1,
            HH: 2
          };
          class y {
            constructor() {
              this.failOnCorruptedImage = !1;
            }
            parse(P) {
              if ((0, a.readUint16)(P, 0) === 65359) {
                this.parseCodestream(P, 0, P.length);
                return;
              }
              const G = P.length;
              let Z = 0;
              for (; Z < G; ) {
                let $ = 8, z = (0, a.readUint32)(P, Z);
                const V = (0, a.readUint32)(P, Z + 4);
                if (Z += $, z === 1 && (z = (0, a.readUint32)(P, Z) * 4294967296 + (0, a.readUint32)(P, Z + 4), Z += 8, $ += 8), z === 0 && (z = G - Z + $), z < $)
                  throw new h("Invalid box field size");
                const L = z - $;
                let K = !0;
                switch (V) {
                  case 1785737832:
                    K = !1;
                    break;
                  case 1668246642:
                    const ne = P[Z];
                    if (ne === 1) {
                      const q = (0, a.readUint32)(P, Z + 3);
                      switch (q) {
                        case 16:
                        case 17:
                        case 18:
                          break;
                        default:
                          (0, t.warn)("Unknown colorspace " + q);
                          break;
                      }
                    } else
                      ne === 2 && (0, t.info)("ICC profile not supported");
                    break;
                  case 1785737827:
                    this.parseCodestream(P, Z, Z + L);
                    break;
                  case 1783636e3:
                    (0, a.readUint32)(P, Z) !== 218793738 && (0, t.warn)("Invalid JP2 signature");
                    break;
                  case 1783634458:
                  case 1718909296:
                  case 1920099697:
                  case 1919251232:
                  case 1768449138:
                    break;
                  default:
                    const se = String.fromCharCode(V >> 24 & 255, V >> 16 & 255, V >> 8 & 255, V & 255);
                    (0, t.warn)(`Unsupported header type ${V} (${se}).`);
                    break;
                }
                K && (Z += L);
              }
            }
            parseImageProperties(P) {
              let M = P.getByte();
              for (; M >= 0; ) {
                const G = M;
                if (M = P.getByte(), (G << 8 | M) === 65361) {
                  P.skip(4);
                  const $ = P.getInt32() >>> 0, z = P.getInt32() >>> 0, V = P.getInt32() >>> 0, L = P.getInt32() >>> 0;
                  P.skip(16);
                  const K = P.getUint16();
                  this.width = $ - V, this.height = z - L, this.componentsCount = K, this.bitsPerComponent = 8;
                  return;
                }
              }
              throw new h("No size marker found in JPX stream");
            }
            parseCodestream(P, M, G) {
              const Z = {};
              let $ = !1;
              try {
                let z = M;
                for (; z + 1 < G; ) {
                  const V = (0, a.readUint16)(P, z);
                  z += 2;
                  let L = 0, K, ne, se, q, N, Q;
                  switch (V) {
                    case 65359:
                      Z.mainHeader = !0;
                      break;
                    case 65497:
                      break;
                    case 65361:
                      L = (0, a.readUint16)(P, z);
                      const E = {};
                      E.Xsiz = (0, a.readUint32)(P, z + 4), E.Ysiz = (0, a.readUint32)(P, z + 8), E.XOsiz = (0, a.readUint32)(P, z + 12), E.YOsiz = (0, a.readUint32)(P, z + 16), E.XTsiz = (0, a.readUint32)(P, z + 20), E.YTsiz = (0, a.readUint32)(P, z + 24), E.XTOsiz = (0, a.readUint32)(P, z + 28), E.YTOsiz = (0, a.readUint32)(P, z + 32);
                      const te = (0, a.readUint16)(P, z + 36);
                      E.Csiz = te;
                      const oe = [];
                      K = z + 38;
                      for (let de = 0; de < te; de++) {
                        const pe = {
                          precision: (P[K] & 127) + 1,
                          isSigned: !!(P[K] & 128),
                          XRsiz: P[K + 1],
                          YRsiz: P[K + 2]
                        };
                        K += 3, c(pe, E), oe.push(pe);
                      }
                      Z.SIZ = E, Z.components = oe, d(Z, oe), Z.QCC = [], Z.COC = [];
                      break;
                    case 65372:
                      L = (0, a.readUint16)(P, z);
                      const ee = {};
                      switch (K = z + 2, ne = P[K++], ne & 31) {
                        case 0:
                          q = 8, N = !0;
                          break;
                        case 1:
                          q = 16, N = !1;
                          break;
                        case 2:
                          q = 16, N = !0;
                          break;
                        default:
                          throw new Error("Invalid SQcd value " + ne);
                      }
                      for (ee.noQuantization = q === 8, ee.scalarExpounded = N, ee.guardBits = ne >> 5, se = []; K < L + z; ) {
                        const de = {};
                        q === 8 ? (de.epsilon = P[K++] >> 3, de.mu = 0) : (de.epsilon = P[K] >> 3, de.mu = (P[K] & 7) << 8 | P[K + 1], K += 2), se.push(de);
                      }
                      ee.SPqcds = se, Z.mainHeader ? Z.QCD = ee : (Z.currentTile.QCD = ee, Z.currentTile.QCC = []);
                      break;
                    case 65373:
                      L = (0, a.readUint16)(P, z);
                      const W = {};
                      K = z + 2;
                      let I;
                      switch (Z.SIZ.Csiz < 257 ? I = P[K++] : (I = (0, a.readUint16)(P, K), K += 2), ne = P[K++], ne & 31) {
                        case 0:
                          q = 8, N = !0;
                          break;
                        case 1:
                          q = 16, N = !1;
                          break;
                        case 2:
                          q = 16, N = !0;
                          break;
                        default:
                          throw new Error("Invalid SQcd value " + ne);
                      }
                      for (W.noQuantization = q === 8, W.scalarExpounded = N, W.guardBits = ne >> 5, se = []; K < L + z; ) {
                        const de = {};
                        q === 8 ? (de.epsilon = P[K++] >> 3, de.mu = 0) : (de.epsilon = P[K] >> 3, de.mu = (P[K] & 7) << 8 | P[K + 1], K += 2), se.push(de);
                      }
                      W.SPqcds = se, Z.mainHeader ? Z.QCC[I] = W : Z.currentTile.QCC[I] = W;
                      break;
                    case 65362:
                      L = (0, a.readUint16)(P, z);
                      const H = {};
                      K = z + 2;
                      const ie = P[K++];
                      H.entropyCoderWithCustomPrecincts = !!(ie & 1), H.sopMarkerUsed = !!(ie & 2), H.ephMarkerUsed = !!(ie & 4), H.progressionOrder = P[K++], H.layersCount = (0, a.readUint16)(P, K), K += 2, H.multipleComponentTransform = P[K++], H.decompositionLevelsCount = P[K++], H.xcb = (P[K++] & 15) + 2, H.ycb = (P[K++] & 15) + 2;
                      const ue = P[K++];
                      if (H.selectiveArithmeticCodingBypass = !!(ue & 1), H.resetContextProbabilities = !!(ue & 2), H.terminationOnEachCodingPass = !!(ue & 4), H.verticallyStripe = !!(ue & 8), H.predictableTermination = !!(ue & 16), H.segmentationSymbolUsed = !!(ue & 32), H.reversibleTransformation = P[K++], H.entropyCoderWithCustomPrecincts) {
                        const de = [];
                        for (; K < L + z; ) {
                          const pe = P[K++];
                          de.push({
                            PPx: pe & 15,
                            PPy: pe >> 4
                          });
                        }
                        H.precinctsSizes = de;
                      }
                      const fe = [];
                      H.selectiveArithmeticCodingBypass && fe.push("selectiveArithmeticCodingBypass"), H.terminationOnEachCodingPass && fe.push("terminationOnEachCodingPass"), H.verticallyStripe && fe.push("verticallyStripe"), H.predictableTermination && fe.push("predictableTermination"), fe.length > 0 && ($ = !0, (0, t.warn)(`JPX: Unsupported COD options (${fe.join(", ")}).`)), Z.mainHeader ? Z.COD = H : (Z.currentTile.COD = H, Z.currentTile.COC = []);
                      break;
                    case 65424:
                      L = (0, a.readUint16)(P, z), Q = {}, Q.index = (0, a.readUint16)(P, z + 2), Q.length = (0, a.readUint32)(P, z + 4), Q.dataEnd = Q.length + z - 2, Q.partIndex = P[z + 8], Q.partsCount = P[z + 9], Z.mainHeader = !1, Q.partIndex === 0 && (Q.COD = Z.COD, Q.COC = Z.COC.slice(0), Q.QCD = Z.QCD, Q.QCC = Z.QCC.slice(0)), Z.currentTile = Q;
                      break;
                    case 65427:
                      Q = Z.currentTile, Q.partIndex === 0 && (k(Z, Q.index), Y(Z)), L = Q.dataEnd - z, j(Z, P, z, L);
                      break;
                    case 65363:
                      (0, t.warn)("JPX: Codestream code 0xFF53 (COC) is not implemented.");
                    case 65365:
                    case 65367:
                    case 65368:
                    case 65380:
                      L = (0, a.readUint16)(P, z);
                      break;
                    default:
                      throw new Error("Unknown codestream code: " + V.toString(16));
                  }
                  z += L;
                }
              } catch (z) {
                if ($ || this.failOnCorruptedImage)
                  throw new h(z.message);
                (0, t.warn)(`JPX: Trying to recover from: "${z.message}".`);
              }
              this.tiles = U(Z), this.width = Z.SIZ.Xsiz - Z.SIZ.XOsiz, this.height = Z.SIZ.Ysiz - Z.SIZ.YOsiz, this.componentsCount = Z.SIZ.Csiz;
            }
          }
          o.JpxImage = y;
          function c(T, P) {
            T.x0 = Math.ceil(P.XOsiz / T.XRsiz), T.x1 = Math.ceil(P.Xsiz / T.XRsiz), T.y0 = Math.ceil(P.YOsiz / T.YRsiz), T.y1 = Math.ceil(P.Ysiz / T.YRsiz), T.width = T.x1 - T.x0, T.height = T.y1 - T.y0;
          }
          function d(T, P) {
            const M = T.SIZ, G = [];
            let Z;
            const $ = Math.ceil((M.Xsiz - M.XTOsiz) / M.XTsiz), z = Math.ceil((M.Ysiz - M.YTOsiz) / M.YTsiz);
            for (let L = 0; L < z; L++)
              for (let K = 0; K < $; K++)
                Z = {}, Z.tx0 = Math.max(M.XTOsiz + K * M.XTsiz, M.XOsiz), Z.ty0 = Math.max(M.YTOsiz + L * M.YTsiz, M.YOsiz), Z.tx1 = Math.min(M.XTOsiz + (K + 1) * M.XTsiz, M.Xsiz), Z.ty1 = Math.min(M.YTOsiz + (L + 1) * M.YTsiz, M.Ysiz), Z.width = Z.tx1 - Z.tx0, Z.height = Z.ty1 - Z.ty0, Z.components = [], G.push(Z);
            T.tiles = G;
            const V = M.Csiz;
            for (let L = 0, K = V; L < K; L++) {
              const ne = P[L];
              for (let se = 0, q = G.length; se < q; se++) {
                const N = {};
                Z = G[se], N.tcx0 = Math.ceil(Z.tx0 / ne.XRsiz), N.tcy0 = Math.ceil(Z.ty0 / ne.YRsiz), N.tcx1 = Math.ceil(Z.tx1 / ne.XRsiz), N.tcy1 = Math.ceil(Z.ty1 / ne.YRsiz), N.width = N.tcx1 - N.tcx0, N.height = N.tcy1 - N.tcy0, Z.components[L] = N;
              }
            }
          }
          function m(T, P, M) {
            const G = P.codingStyleParameters, Z = {};
            return G.entropyCoderWithCustomPrecincts ? (Z.PPx = G.precinctsSizes[M].PPx, Z.PPy = G.precinctsSizes[M].PPy) : (Z.PPx = 15, Z.PPy = 15), Z.xcb_ = M > 0 ? Math.min(G.xcb, Z.PPx - 1) : Math.min(G.xcb, Z.PPx), Z.ycb_ = M > 0 ? Math.min(G.ycb, Z.PPy - 1) : Math.min(G.ycb, Z.PPy), Z;
          }
          function p(T, P, M) {
            const G = 1 << M.PPx, Z = 1 << M.PPy, $ = P.resLevel === 0, z = 1 << M.PPx + ($ ? 0 : -1), V = 1 << M.PPy + ($ ? 0 : -1), L = P.trx1 > P.trx0 ? Math.ceil(P.trx1 / G) - Math.floor(P.trx0 / G) : 0, K = P.try1 > P.try0 ? Math.ceil(P.try1 / Z) - Math.floor(P.try0 / Z) : 0, ne = L * K;
            P.precinctParameters = {
              precinctWidth: G,
              precinctHeight: Z,
              numprecinctswide: L,
              numprecinctshigh: K,
              numprecincts: ne,
              precinctWidthInSubband: z,
              precinctHeightInSubband: V
            };
          }
          function g(T, P, M) {
            const G = M.xcb_, Z = M.ycb_, $ = 1 << G, z = 1 << Z, V = P.tbx0 >> G, L = P.tby0 >> Z, K = P.tbx1 + $ - 1 >> G, ne = P.tby1 + z - 1 >> Z, se = P.resolution.precinctParameters, q = [], N = [];
            let Q, E, te, oe;
            for (E = L; E < ne; E++)
              for (Q = V; Q < K; Q++) {
                te = {
                  cbx: Q,
                  cby: E,
                  tbx0: $ * Q,
                  tby0: z * E,
                  tbx1: $ * (Q + 1),
                  tby1: z * (E + 1)
                }, te.tbx0_ = Math.max(P.tbx0, te.tbx0), te.tby0_ = Math.max(P.tby0, te.tby0), te.tbx1_ = Math.min(P.tbx1, te.tbx1), te.tby1_ = Math.min(P.tby1, te.tby1);
                const ee = Math.floor((te.tbx0_ - P.tbx0) / se.precinctWidthInSubband), W = Math.floor((te.tby0_ - P.tby0) / se.precinctHeightInSubband);
                if (oe = ee + W * se.numprecinctswide, te.precinctNumber = oe, te.subbandType = P.type, te.Lblock = 3, te.tbx1_ <= te.tbx0_ || te.tby1_ <= te.tby0_)
                  continue;
                q.push(te);
                let I = N[oe];
                I !== void 0 ? (Q < I.cbxMin ? I.cbxMin = Q : Q > I.cbxMax && (I.cbxMax = Q), E < I.cbyMin ? I.cbxMin = E : E > I.cbyMax && (I.cbyMax = E)) : N[oe] = I = {
                  cbxMin: Q,
                  cbyMin: E,
                  cbxMax: Q,
                  cbyMax: E
                }, te.precinct = I;
              }
            P.codeblockParameters = {
              codeblockWidth: G,
              codeblockHeight: Z,
              numcodeblockwide: K - V + 1,
              numcodeblockhigh: ne - L + 1
            }, P.codeblocks = q, P.precincts = N;
          }
          function n(T, P, M) {
            const G = [], Z = T.subbands;
            for (let $ = 0, z = Z.length; $ < z; $++) {
              const L = Z[$].codeblocks;
              for (let K = 0, ne = L.length; K < ne; K++) {
                const se = L[K];
                se.precinctNumber === P && G.push(se);
              }
            }
            return {
              layerNumber: M,
              codeblocks: G
            };
          }
          function i(T) {
            const P = T.SIZ, M = T.currentTile.index, G = T.tiles[M], Z = G.codingStyleDefaultParameters.layersCount, $ = P.Csiz;
            let z = 0;
            for (let se = 0; se < $; se++)
              z = Math.max(z, G.components[se].codingStyleParameters.decompositionLevelsCount);
            let V = 0, L = 0, K = 0, ne = 0;
            this.nextPacket = function() {
              for (; V < Z; V++) {
                for (; L <= z; L++) {
                  for (; K < $; K++) {
                    const q = G.components[K];
                    if (L > q.codingStyleParameters.decompositionLevelsCount)
                      continue;
                    const N = q.resolutions[L], Q = N.precinctParameters.numprecincts;
                    for (; ne < Q; ) {
                      const E = n(N, ne, V);
                      return ne++, E;
                    }
                    ne = 0;
                  }
                  K = 0;
                }
                L = 0;
              }
              throw new h("Out of packets");
            };
          }
          function l(T) {
            const P = T.SIZ, M = T.currentTile.index, G = T.tiles[M], Z = G.codingStyleDefaultParameters.layersCount, $ = P.Csiz;
            let z = 0;
            for (let se = 0; se < $; se++)
              z = Math.max(z, G.components[se].codingStyleParameters.decompositionLevelsCount);
            let V = 0, L = 0, K = 0, ne = 0;
            this.nextPacket = function() {
              for (; V <= z; V++) {
                for (; L < Z; L++) {
                  for (; K < $; K++) {
                    const q = G.components[K];
                    if (V > q.codingStyleParameters.decompositionLevelsCount)
                      continue;
                    const N = q.resolutions[V], Q = N.precinctParameters.numprecincts;
                    for (; ne < Q; ) {
                      const E = n(N, ne, L);
                      return ne++, E;
                    }
                    ne = 0;
                  }
                  K = 0;
                }
                L = 0;
              }
              throw new h("Out of packets");
            };
          }
          function u(T) {
            const P = T.SIZ, M = T.currentTile.index, G = T.tiles[M], Z = G.codingStyleDefaultParameters.layersCount, $ = P.Csiz;
            let z, V, L, K, ne = 0;
            for (L = 0; L < $; L++) {
              const q = G.components[L];
              ne = Math.max(ne, q.codingStyleParameters.decompositionLevelsCount);
            }
            const se = new Int32Array(ne + 1);
            for (V = 0; V <= ne; ++V) {
              let q = 0;
              for (L = 0; L < $; ++L) {
                const N = G.components[L].resolutions;
                V < N.length && (q = Math.max(q, N[V].precinctParameters.numprecincts));
              }
              se[V] = q;
            }
            z = 0, V = 0, L = 0, K = 0, this.nextPacket = function() {
              for (; V <= ne; V++) {
                for (; K < se[V]; K++) {
                  for (; L < $; L++) {
                    const N = G.components[L];
                    if (V > N.codingStyleParameters.decompositionLevelsCount)
                      continue;
                    const Q = N.resolutions[V], E = Q.precinctParameters.numprecincts;
                    if (!(K >= E)) {
                      for (; z < Z; ) {
                        const te = n(Q, K, z);
                        return z++, te;
                      }
                      z = 0;
                    }
                  }
                  L = 0;
                }
                K = 0;
              }
              throw new h("Out of packets");
            };
          }
          function w(T) {
            const P = T.SIZ, M = T.currentTile.index, G = T.tiles[M], Z = G.codingStyleDefaultParameters.layersCount, $ = P.Csiz, z = A(G), V = z;
            let L = 0, K = 0, ne = 0, se = 0, q = 0;
            this.nextPacket = function() {
              for (; q < V.maxNumHigh; q++) {
                for (; se < V.maxNumWide; se++) {
                  for (; ne < $; ne++) {
                    const Q = G.components[ne], E = Q.codingStyleParameters.decompositionLevelsCount;
                    for (; K <= E; K++) {
                      const te = Q.resolutions[K], oe = z.components[ne].resolutions[K], ee = b(se, q, oe, V, te);
                      if (ee !== null) {
                        for (; L < Z; ) {
                          const W = n(te, ee, L);
                          return L++, W;
                        }
                        L = 0;
                      }
                    }
                    K = 0;
                  }
                  ne = 0;
                }
                se = 0;
              }
              throw new h("Out of packets");
            };
          }
          function O(T) {
            const P = T.SIZ, M = T.currentTile.index, G = T.tiles[M], Z = G.codingStyleDefaultParameters.layersCount, $ = P.Csiz, z = A(G);
            let V = 0, L = 0, K = 0, ne = 0, se = 0;
            this.nextPacket = function() {
              for (; K < $; ++K) {
                const N = G.components[K], Q = z.components[K], E = N.codingStyleParameters.decompositionLevelsCount;
                for (; se < Q.maxNumHigh; se++) {
                  for (; ne < Q.maxNumWide; ne++) {
                    for (; L <= E; L++) {
                      const te = N.resolutions[L], oe = Q.resolutions[L], ee = b(ne, se, oe, Q, te);
                      if (ee !== null) {
                        for (; V < Z; ) {
                          const W = n(te, ee, V);
                          return V++, W;
                        }
                        V = 0;
                      }
                    }
                    L = 0;
                  }
                  ne = 0;
                }
                se = 0;
              }
              throw new h("Out of packets");
            };
          }
          function b(T, P, M, G, Z) {
            const $ = T * G.minWidth, z = P * G.minHeight;
            if ($ % M.width !== 0 || z % M.height !== 0)
              return null;
            const V = z / M.width * Z.precinctParameters.numprecinctswide;
            return $ / M.height + V;
          }
          function A(T) {
            const P = T.components.length;
            let M = Number.MAX_VALUE, G = Number.MAX_VALUE, Z = 0, $ = 0;
            const z = new Array(P);
            for (let V = 0; V < P; V++) {
              const L = T.components[V], K = L.codingStyleParameters.decompositionLevelsCount, ne = new Array(K + 1);
              let se = Number.MAX_VALUE, q = Number.MAX_VALUE, N = 0, Q = 0, E = 1;
              for (let te = K; te >= 0; --te) {
                const oe = L.resolutions[te], ee = E * oe.precinctParameters.precinctWidth, W = E * oe.precinctParameters.precinctHeight;
                se = Math.min(se, ee), q = Math.min(q, W), N = Math.max(N, oe.precinctParameters.numprecinctswide), Q = Math.max(Q, oe.precinctParameters.numprecinctshigh), ne[te] = {
                  width: ee,
                  height: W
                }, E <<= 1;
              }
              M = Math.min(M, se), G = Math.min(G, q), Z = Math.max(Z, N), $ = Math.max($, Q), z[V] = {
                resolutions: ne,
                minWidth: se,
                minHeight: q,
                maxNumWide: N,
                maxNumHigh: Q
              };
            }
            return {
              components: z,
              minWidth: M,
              minHeight: G,
              maxNumWide: Z,
              maxNumHigh: $
            };
          }
          function Y(T) {
            const P = T.SIZ, M = T.currentTile.index, G = T.tiles[M], Z = P.Csiz;
            for (let z = 0; z < Z; z++) {
              const V = G.components[z], L = V.codingStyleParameters.decompositionLevelsCount, K = [], ne = [];
              for (let se = 0; se <= L; se++) {
                const q = m(T, V, se), N = {}, Q = 1 << L - se;
                N.trx0 = Math.ceil(V.tcx0 / Q), N.try0 = Math.ceil(V.tcy0 / Q), N.trx1 = Math.ceil(V.tcx1 / Q), N.try1 = Math.ceil(V.tcy1 / Q), N.resLevel = se, p(T, N, q), K.push(N);
                let E;
                if (se === 0)
                  E = {}, E.type = "LL", E.tbx0 = Math.ceil(V.tcx0 / Q), E.tby0 = Math.ceil(V.tcy0 / Q), E.tbx1 = Math.ceil(V.tcx1 / Q), E.tby1 = Math.ceil(V.tcy1 / Q), E.resolution = N, g(T, E, q), ne.push(E), N.subbands = [E];
                else {
                  const te = 1 << L - se + 1, oe = [];
                  E = {}, E.type = "HL", E.tbx0 = Math.ceil(V.tcx0 / te - 0.5), E.tby0 = Math.ceil(V.tcy0 / te), E.tbx1 = Math.ceil(V.tcx1 / te - 0.5), E.tby1 = Math.ceil(V.tcy1 / te), E.resolution = N, g(T, E, q), ne.push(E), oe.push(E), E = {}, E.type = "LH", E.tbx0 = Math.ceil(V.tcx0 / te), E.tby0 = Math.ceil(V.tcy0 / te - 0.5), E.tbx1 = Math.ceil(V.tcx1 / te), E.tby1 = Math.ceil(V.tcy1 / te - 0.5), E.resolution = N, g(T, E, q), ne.push(E), oe.push(E), E = {}, E.type = "HH", E.tbx0 = Math.ceil(V.tcx0 / te - 0.5), E.tby0 = Math.ceil(V.tcy0 / te - 0.5), E.tbx1 = Math.ceil(V.tcx1 / te - 0.5), E.tby1 = Math.ceil(V.tcy1 / te - 0.5), E.resolution = N, g(T, E, q), ne.push(E), oe.push(E), N.subbands = oe;
                }
              }
              V.resolutions = K, V.subbands = ne;
            }
            const $ = G.codingStyleDefaultParameters.progressionOrder;
            switch ($) {
              case 0:
                G.packetsIterator = new i(T);
                break;
              case 1:
                G.packetsIterator = new l(T);
                break;
              case 2:
                G.packetsIterator = new u(T);
                break;
              case 3:
                G.packetsIterator = new w(T);
                break;
              case 4:
                G.packetsIterator = new O(T);
                break;
              default:
                throw new h(`Unsupported progression order ${$}`);
            }
          }
          function j(T, P, M, G) {
            let Z = 0, $, z = 0, V = !1;
            function L(ee) {
              for (; z < ee; ) {
                const W = P[M + Z];
                Z++, V ? ($ = $ << 7 | W, z += 7, V = !1) : ($ = $ << 8 | W, z += 8), W === 255 && (V = !0);
              }
              return z -= ee, $ >>> z & (1 << ee) - 1;
            }
            function K(ee) {
              return P[M + Z - 1] === 255 && P[M + Z] === ee ? (ne(1), !0) : P[M + Z] === 255 && P[M + Z + 1] === ee ? (ne(2), !0) : !1;
            }
            function ne(ee) {
              Z += ee;
            }
            function se() {
              z = 0, V && (Z++, V = !1);
            }
            function q() {
              if (L(1) === 0)
                return 1;
              if (L(1) === 0)
                return 2;
              let ee = L(2);
              return ee < 3 ? ee + 3 : (ee = L(5), ee < 31 ? ee + 6 : (ee = L(7), ee + 37));
            }
            const N = T.currentTile.index, Q = T.tiles[N], E = T.COD.sopMarkerUsed, te = T.COD.ephMarkerUsed, oe = Q.packetsIterator;
            for (; Z < G; ) {
              se(), E && K(145) && ne(4);
              const ee = oe.nextPacket();
              if (!L(1))
                continue;
              const W = ee.layerNumber, I = [];
              let H;
              for (let ie = 0, ue = ee.codeblocks.length; ie < ue; ie++) {
                H = ee.codeblocks[ie];
                let fe = H.precinct;
                const de = H.cbx - fe.cbxMin, pe = H.cby - fe.cbyMin;
                let xe = !1, Fe = !1, Se, Ce;
                if (H.included !== void 0)
                  xe = !!L(1);
                else {
                  fe = H.precinct;
                  let Te;
                  if (fe.inclusionTree !== void 0)
                    Te = fe.inclusionTree;
                  else {
                    const ve = fe.cbxMax - fe.cbxMin + 1, Ne = fe.cbyMax - fe.cbyMin + 1;
                    Te = new f(ve, Ne, W), Ce = new x(ve, Ne), fe.inclusionTree = Te, fe.zeroBitPlanesTree = Ce;
                    for (let Ge = 0; Ge < W; Ge++)
                      if (L(1) !== 0)
                        throw new h("Invalid tag tree");
                  }
                  if (Te.reset(de, pe, W))
                    for (; ; )
                      if (L(1)) {
                        if (Se = !Te.nextLevel(), Se) {
                          H.included = !0, xe = Fe = !0;
                          break;
                        }
                      } else {
                        Te.incrementValue(W);
                        break;
                      }
                }
                if (!xe)
                  continue;
                if (Fe) {
                  for (Ce = fe.zeroBitPlanesTree, Ce.reset(de, pe); ; )
                    if (L(1)) {
                      if (Se = !Ce.nextLevel(), Se)
                        break;
                    } else
                      Ce.incrementValue();
                  H.zeroBitPlanes = Ce.value;
                }
                const ke = q();
                for (; L(1); )
                  H.Lblock++;
                const ye = (0, a.log2)(ke), De = (ke < 1 << ye ? ye - 1 : ye) + H.Lblock, Ae = L(De);
                I.push({
                  codeblock: H,
                  codingpasses: ke,
                  dataLength: Ae
                });
              }
              for (se(), te && K(146); I.length > 0; ) {
                const ie = I.shift();
                H = ie.codeblock, H.data === void 0 && (H.data = []), H.data.push({
                  data: P,
                  start: M + Z,
                  end: M + Z + ie.dataLength,
                  codingpasses: ie.codingpasses
                }), Z += ie.dataLength;
              }
            }
            return Z;
          }
          function X(T, P, M, G, Z, $, z, V, L) {
            const K = G.tbx0, ne = G.tby0, se = G.tbx1 - G.tbx0, q = G.codeblocks, N = G.type.charAt(0) === "H" ? 1 : 0, Q = G.type.charAt(1) === "H" ? P : 0;
            for (let E = 0, te = q.length; E < te; ++E) {
              const oe = q[E], ee = oe.tbx1_ - oe.tbx0_, W = oe.tby1_ - oe.tby0_;
              if (ee === 0 || W === 0 || oe.data === void 0)
                continue;
              const I = new D(ee, W, oe.subbandType, oe.zeroBitPlanes, $);
              let H = 2;
              const ie = oe.data;
              let ue = 0, fe = 0, de, pe, xe;
              for (de = 0, pe = ie.length; de < pe; de++)
                xe = ie[de], ue += xe.end - xe.start, fe += xe.codingpasses;
              const Fe = new Uint8Array(ue);
              let Se = 0;
              for (de = 0, pe = ie.length; de < pe; de++) {
                xe = ie[de];
                const Me = xe.data.subarray(xe.start, xe.end);
                Fe.set(Me, Se), Se += Me.length;
              }
              const Ce = new v.ArithmeticDecoder(Fe, 0, ue);
              for (I.setDecoder(Ce), de = 0; de < fe; de++) {
                switch (H) {
                  case 0:
                    I.runSignificancePropagationPass();
                    break;
                  case 1:
                    I.runMagnitudeRefinementPass();
                    break;
                  case 2:
                    I.runCleanupPass(), V && I.checkSegmentationSymbol();
                    break;
                }
                L && I.reset(), H = (H + 1) % 3;
              }
              let ke = oe.tbx0_ - K + (oe.tby0_ - ne) * se;
              const ye = I.coefficentsSign, De = I.coefficentsMagnitude, Ae = I.bitsDecoded, Te = z ? 0 : 0.5;
              let ve, Ne, Ge;
              Se = 0;
              const it = G.type !== "LL";
              for (de = 0; de < W; de++) {
                const Ie = 2 * (ke / se | 0) * (P - se) + N + Q;
                for (ve = 0; ve < ee; ve++) {
                  if (Ne = De[Se], Ne !== 0) {
                    Ne = (Ne + Te) * Z, ye[Se] !== 0 && (Ne = -Ne), Ge = Ae[Se];
                    const Ee = it ? Ie + (ke << 1) : ke;
                    z && Ge >= $ ? T[Ee] = Ne : T[Ee] = Ne * (1 << $ - Ge);
                  }
                  ke++, Se++;
                }
                ke += se - ee;
              }
            }
          }
          function B(T, P, M) {
            const G = P.components[M], Z = G.codingStyleParameters, $ = G.quantizationParameters, z = Z.decompositionLevelsCount, V = $.SPqcds, L = $.scalarExpounded, K = $.guardBits, ne = Z.segmentationSymbolUsed, se = Z.resetContextProbabilities, q = T.components[M].precision, N = Z.reversibleTransformation, Q = N ? new C() : new S(), E = [];
            let te = 0;
            for (let ee = 0; ee <= z; ee++) {
              const W = G.resolutions[ee], I = W.trx1 - W.trx0, H = W.try1 - W.try0, ie = new Float32Array(I * H);
              for (let ue = 0, fe = W.subbands.length; ue < fe; ue++) {
                let de, pe;
                L ? (de = V[te].mu, pe = V[te].epsilon, te++) : (de = V[0].mu, pe = V[0].epsilon + (ee > 0 ? 1 - ee : 0));
                const xe = W.subbands[ue], Fe = e[xe.type], Se = N ? 1 : 2 ** (q + Fe - pe) * (1 + de / 2048), Ce = K + pe - 1;
                X(ie, I, H, xe, Se, Ce, N, ne, se);
              }
              E.push({
                width: I,
                height: H,
                items: ie
              });
            }
            const oe = Q.calculate(E, G.tcx0, G.tcy0);
            return {
              left: G.tcx0,
              top: G.tcy0,
              width: oe.width,
              height: oe.height,
              items: oe.items
            };
          }
          function U(T) {
            const P = T.SIZ, M = T.components, G = P.Csiz, Z = [];
            for (let $ = 0, z = T.tiles.length; $ < z; $++) {
              const V = T.tiles[$], L = [];
              for (let I = 0; I < G; I++)
                L[I] = B(T, V, I);
              const K = L[0], ne = new Uint8ClampedArray(K.items.length * G), se = {
                left: K.left,
                top: K.top,
                width: K.width,
                height: K.height,
                items: ne
              };
              let q, N, Q = 0, E, te, oe, ee, W;
              if (V.codingStyleDefaultParameters.multipleComponentTransform) {
                const I = G === 4, H = L[0].items, ie = L[1].items, ue = L[2].items, fe = I ? L[3].items : null;
                q = M[0].precision - 8, N = (128 << q) + 0.5;
                const de = V.components[0], pe = G - 3;
                if (te = H.length, de.codingStyleParameters.reversibleTransformation)
                  for (E = 0; E < te; E++, Q += pe) {
                    oe = H[E] + N, ee = ie[E], W = ue[E];
                    const xe = oe - (W + ee >> 2);
                    ne[Q++] = xe + W >> q, ne[Q++] = xe >> q, ne[Q++] = xe + ee >> q;
                  }
                else
                  for (E = 0; E < te; E++, Q += pe)
                    oe = H[E] + N, ee = ie[E], W = ue[E], ne[Q++] = oe + 1.402 * W >> q, ne[Q++] = oe - 0.34413 * ee - 0.71414 * W >> q, ne[Q++] = oe + 1.772 * ee >> q;
                if (I)
                  for (E = 0, Q = 3; E < te; E++, Q += 4)
                    ne[Q] = fe[E] + N >> q;
              } else
                for (let I = 0; I < G; I++) {
                  const H = L[I].items;
                  for (q = M[I].precision - 8, N = (128 << q) + 0.5, Q = I, E = 0, te = H.length; E < te; E++)
                    ne[Q] = H[E] + N >> q, Q += G;
                }
              Z.push(se);
            }
            return Z;
          }
          function k(T, P) {
            const G = T.SIZ.Csiz, Z = T.tiles[P];
            for (let $ = 0; $ < G; $++) {
              const z = Z.components[$], V = T.currentTile.QCC[$] !== void 0 ? T.currentTile.QCC[$] : T.currentTile.QCD;
              z.quantizationParameters = V;
              const L = T.currentTile.COC[$] !== void 0 ? T.currentTile.COC[$] : T.currentTile.COD;
              z.codingStyleParameters = L;
            }
            Z.codingStyleDefaultParameters = T.currentTile.COD;
          }
          class x {
            constructor(P, M) {
              const G = (0, a.log2)(Math.max(P, M)) + 1;
              this.levels = [];
              for (let Z = 0; Z < G; Z++) {
                const $ = {
                  width: P,
                  height: M,
                  items: []
                };
                this.levels.push($), P = Math.ceil(P / 2), M = Math.ceil(M / 2);
              }
            }
            reset(P, M) {
              let G = 0, Z = 0, $;
              for (; G < this.levels.length; ) {
                $ = this.levels[G];
                const z = P + M * $.width;
                if ($.items[z] !== void 0) {
                  Z = $.items[z];
                  break;
                }
                $.index = z, P >>= 1, M >>= 1, G++;
              }
              G--, $ = this.levels[G], $.items[$.index] = Z, this.currentLevel = G, delete this.value;
            }
            incrementValue() {
              const P = this.levels[this.currentLevel];
              P.items[P.index]++;
            }
            nextLevel() {
              let P = this.currentLevel, M = this.levels[P];
              const G = M.items[M.index];
              return P--, P < 0 ? (this.value = G, !1) : (this.currentLevel = P, M = this.levels[P], M.items[M.index] = G, !0);
            }
          }
          class f {
            constructor(P, M, G) {
              const Z = (0, a.log2)(Math.max(P, M)) + 1;
              this.levels = [];
              for (let $ = 0; $ < Z; $++) {
                const z = new Uint8Array(P * M);
                for (let L = 0, K = z.length; L < K; L++)
                  z[L] = G;
                const V = {
                  width: P,
                  height: M,
                  items: z
                };
                this.levels.push(V), P = Math.ceil(P / 2), M = Math.ceil(M / 2);
              }
            }
            reset(P, M, G) {
              let Z = 0;
              for (; Z < this.levels.length; ) {
                const $ = this.levels[Z], z = P + M * $.width;
                $.index = z;
                const V = $.items[z];
                if (V === 255)
                  break;
                if (V > G)
                  return this.currentLevel = Z, this.propagateValues(), !1;
                P >>= 1, M >>= 1, Z++;
              }
              return this.currentLevel = Z - 1, !0;
            }
            incrementValue(P) {
              const M = this.levels[this.currentLevel];
              M.items[M.index] = P + 1, this.propagateValues();
            }
            propagateValues() {
              let P = this.currentLevel, M = this.levels[P];
              const G = M.items[M.index];
              for (; --P >= 0; )
                M = this.levels[P], M.items[M.index] = G;
            }
            nextLevel() {
              let P = this.currentLevel, M = this.levels[P];
              const G = M.items[M.index];
              return M.items[M.index] = 255, P--, P < 0 ? !1 : (this.currentLevel = P, M = this.levels[P], M.items[M.index] = G, !0);
            }
          }
          const D = function() {
            const G = new Uint8Array([0, 5, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 1, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8]), Z = new Uint8Array([0, 3, 4, 0, 5, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 1, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8]), $ = new Uint8Array([0, 1, 2, 0, 1, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 3, 4, 5, 0, 4, 5, 5, 0, 5, 5, 5, 0, 0, 0, 0, 0, 6, 7, 7, 0, 7, 7, 7, 0, 7, 7, 7, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8]);
            class z {
              constructor(L, K, ne, se, q) {
                this.width = L, this.height = K;
                let N;
                ne === "HH" ? N = $ : ne === "HL" ? N = Z : N = G, this.contextLabelTable = N;
                const Q = L * K;
                this.neighborsSignificance = new Uint8Array(Q), this.coefficentsSign = new Uint8Array(Q);
                let E;
                q > 14 ? E = new Uint32Array(Q) : q > 6 ? E = new Uint16Array(Q) : E = new Uint8Array(Q), this.coefficentsMagnitude = E, this.processingFlags = new Uint8Array(Q);
                const te = new Uint8Array(Q);
                if (se !== 0)
                  for (let oe = 0; oe < Q; oe++)
                    te[oe] = se;
                this.bitsDecoded = te, this.reset();
              }
              setDecoder(L) {
                this.decoder = L;
              }
              reset() {
                this.contexts = new Int8Array(19), this.contexts[0] = 4 << 1 | 0, this.contexts[17] = 46 << 1 | 0, this.contexts[18] = 3 << 1 | 0;
              }
              setNeighborsSignificance(L, K, ne) {
                const se = this.neighborsSignificance, q = this.width, N = this.height, Q = K > 0, E = K + 1 < q;
                let te;
                L > 0 && (te = ne - q, Q && (se[te - 1] += 16), E && (se[te + 1] += 16), se[te] += 4), L + 1 < N && (te = ne + q, Q && (se[te - 1] += 16), E && (se[te + 1] += 16), se[te] += 4), Q && (se[ne - 1] += 1), E && (se[ne + 1] += 1), se[ne] |= 128;
              }
              runSignificancePropagationPass() {
                const L = this.decoder, K = this.width, ne = this.height, se = this.coefficentsMagnitude, q = this.coefficentsSign, N = this.neighborsSignificance, Q = this.processingFlags, E = this.contexts, te = this.contextLabelTable, oe = this.bitsDecoded, ee = -2, W = 1, I = 2;
                for (let H = 0; H < ne; H += 4)
                  for (let ie = 0; ie < K; ie++) {
                    let ue = H * K + ie;
                    for (let fe = 0; fe < 4; fe++, ue += K) {
                      const de = H + fe;
                      if (de >= ne)
                        break;
                      if (Q[ue] &= ee, se[ue] || !N[ue])
                        continue;
                      const pe = te[N[ue]];
                      if (L.readBit(E, pe)) {
                        const Fe = this.decodeSignBit(de, ie, ue);
                        q[ue] = Fe, se[ue] = 1, this.setNeighborsSignificance(de, ie, ue), Q[ue] |= I;
                      }
                      oe[ue]++, Q[ue] |= W;
                    }
                  }
              }
              decodeSignBit(L, K, ne) {
                const se = this.width, q = this.height, N = this.coefficentsMagnitude, Q = this.coefficentsSign;
                let E, te, oe, ee, W, I;
                ee = K > 0 && N[ne - 1] !== 0, K + 1 < se && N[ne + 1] !== 0 ? (oe = Q[ne + 1], ee ? (te = Q[ne - 1], E = 1 - oe - te) : E = 1 - oe - oe) : ee ? (te = Q[ne - 1], E = 1 - te - te) : E = 0;
                const H = 3 * E;
                return ee = L > 0 && N[ne - se] !== 0, L + 1 < q && N[ne + se] !== 0 ? (oe = Q[ne + se], ee ? (te = Q[ne - se], E = 1 - oe - te + H) : E = 1 - oe - oe + H) : ee ? (te = Q[ne - se], E = 1 - te - te + H) : E = H, E >= 0 ? (W = 9 + E, I = this.decoder.readBit(this.contexts, W)) : (W = 9 - E, I = this.decoder.readBit(this.contexts, W) ^ 1), I;
              }
              runMagnitudeRefinementPass() {
                const L = this.decoder, K = this.width, ne = this.height, se = this.coefficentsMagnitude, q = this.neighborsSignificance, N = this.contexts, Q = this.bitsDecoded, E = this.processingFlags, te = 1, oe = 2, ee = K * ne, W = K * 4;
                for (let I = 0, H; I < ee; I = H) {
                  H = Math.min(ee, I + W);
                  for (let ie = 0; ie < K; ie++)
                    for (let ue = I + ie; ue < H; ue += K) {
                      if (!se[ue] || E[ue] & te)
                        continue;
                      let fe = 16;
                      E[ue] & oe && (E[ue] ^= oe, fe = (q[ue] & 127) === 0 ? 15 : 14);
                      const de = L.readBit(N, fe);
                      se[ue] = se[ue] << 1 | de, Q[ue]++, E[ue] |= te;
                    }
                }
              }
              runCleanupPass() {
                const L = this.decoder, K = this.width, ne = this.height, se = this.neighborsSignificance, q = this.coefficentsMagnitude, N = this.coefficentsSign, Q = this.contexts, E = this.contextLabelTable, te = this.bitsDecoded, oe = this.processingFlags, ee = 1, W = 2, I = K, H = K * 2, ie = K * 3;
                let ue;
                for (let fe = 0; fe < ne; fe = ue) {
                  ue = Math.min(fe + 4, ne);
                  const de = fe * K, pe = fe + 3 < ne;
                  for (let xe = 0; xe < K; xe++) {
                    const Fe = de + xe, Se = pe && oe[Fe] === 0 && oe[Fe + I] === 0 && oe[Fe + H] === 0 && oe[Fe + ie] === 0 && se[Fe] === 0 && se[Fe + I] === 0 && se[Fe + H] === 0 && se[Fe + ie] === 0;
                    let Ce = 0, ke = Fe, ye = fe, De;
                    if (Se) {
                      if (!L.readBit(Q, 18)) {
                        te[Fe]++, te[Fe + I]++, te[Fe + H]++, te[Fe + ie]++;
                        continue;
                      }
                      Ce = L.readBit(Q, 17) << 1 | L.readBit(Q, 17), Ce !== 0 && (ye = fe + Ce, ke += Ce * K), De = this.decodeSignBit(ye, xe, ke), N[ke] = De, q[ke] = 1, this.setNeighborsSignificance(ye, xe, ke), oe[ke] |= W, ke = Fe;
                      for (let Te = fe; Te <= ye; Te++, ke += K)
                        te[ke]++;
                      Ce++;
                    }
                    for (ye = fe + Ce; ye < ue; ye++, ke += K) {
                      if (q[ke] || oe[ke] & ee)
                        continue;
                      const Ae = E[se[ke]];
                      L.readBit(Q, Ae) === 1 && (De = this.decodeSignBit(ye, xe, ke), N[ke] = De, q[ke] = 1, this.setNeighborsSignificance(ye, xe, ke), oe[ke] |= W), te[ke]++;
                    }
                  }
                }
              }
              checkSegmentationSymbol() {
                const L = this.decoder, K = this.contexts;
                if ((L.readBit(K, 17) << 3 | L.readBit(K, 17) << 2 | L.readBit(K, 17) << 1 | L.readBit(K, 17)) !== 10)
                  throw new h("Invalid segmentation symbol");
              }
            }
            return z;
          }();
          class _ {
            constructor() {
              this.constructor === _ && (0, t.unreachable)("Cannot initialize Transform.");
            }
            calculate(P, M, G) {
              let Z = P[0];
              for (let $ = 1, z = P.length; $ < z; $++)
                Z = this.iterate(Z, P[$], M, G);
              return Z;
            }
            extend(P, M, G) {
              let Z = M - 1, $ = M + 1, z = M + G - 2, V = M + G;
              P[Z--] = P[$++], P[V++] = P[z--], P[Z--] = P[$++], P[V++] = P[z--], P[Z--] = P[$++], P[V++] = P[z--], P[Z] = P[$], P[V] = P[z];
            }
            filter(P, M, G) {
              (0, t.unreachable)("Abstract method `filter` called");
            }
            iterate(P, M, G, Z) {
              const $ = P.width, z = P.height;
              let V = P.items;
              const L = M.width, K = M.height, ne = M.items;
              let se, q, N, Q, E, te;
              for (N = 0, se = 0; se < z; se++)
                for (Q = se * 2 * L, q = 0; q < $; q++, N++, Q += 2)
                  ne[Q] = V[N];
              V = P.items = null;
              const oe = 4, ee = new Float32Array(L + 2 * oe);
              if (L === 1) {
                if (G & 1)
                  for (te = 0, N = 0; te < K; te++, N += L)
                    ne[N] *= 0.5;
              } else
                for (te = 0, N = 0; te < K; te++, N += L)
                  ee.set(ne.subarray(N, N + L), oe), this.extend(ee, oe, L), this.filter(ee, oe, L), ne.set(ee.subarray(oe, oe + L), N);
              let W = 16;
              const I = [];
              for (se = 0; se < W; se++)
                I.push(new Float32Array(K + 2 * oe));
              let H, ie = 0;
              if (P = oe + K, K === 1) {
                if (Z & 1)
                  for (E = 0; E < L; E++)
                    ne[E] *= 0.5;
              } else
                for (E = 0; E < L; E++) {
                  if (ie === 0) {
                    for (W = Math.min(L - E, W), N = E, Q = oe; Q < P; N += L, Q++)
                      for (H = 0; H < W; H++)
                        I[H][Q] = ne[N + H];
                    ie = W;
                  }
                  ie--;
                  const ue = I[ie];
                  if (this.extend(ue, oe, K), this.filter(ue, oe, K), ie === 0)
                    for (N = E - W + 1, Q = oe; Q < P; N += L, Q++)
                      for (H = 0; H < W; H++)
                        ne[N + H] = I[H][Q];
                }
              return {
                width: L,
                height: K,
                items: ne
              };
            }
          }
          class S extends _ {
            filter(P, M, G) {
              const Z = G >> 1;
              M |= 0;
              let $, z, V, L;
              const K = -1.586134342059924, ne = -0.052980118572961, se = 0.882911075530934, q = 0.443506852043971, N = 1.230174104914001, Q = 1 / N;
              for ($ = M - 3, z = Z + 4; z--; $ += 2)
                P[$] *= Q;
              for ($ = M - 2, V = q * P[$ - 1], z = Z + 3; z-- && (L = q * P[$ + 1], P[$] = N * P[$] - V - L, z--); $ += 2)
                $ += 2, V = q * P[$ + 1], P[$] = N * P[$] - V - L;
              for ($ = M - 1, V = se * P[$ - 1], z = Z + 2; z-- && (L = se * P[$ + 1], P[$] -= V + L, z--); $ += 2)
                $ += 2, V = se * P[$ + 1], P[$] -= V + L;
              for ($ = M, V = ne * P[$ - 1], z = Z + 1; z-- && (L = ne * P[$ + 1], P[$] -= V + L, z--); $ += 2)
                $ += 2, V = ne * P[$ + 1], P[$] -= V + L;
              if (Z !== 0)
                for ($ = M + 1, V = K * P[$ - 1], z = Z; z-- && (L = K * P[$ + 1], P[$] -= V + L, z--); $ += 2)
                  $ += 2, V = K * P[$ + 1], P[$] -= V + L;
            }
          }
          class C extends _ {
            filter(P, M, G) {
              const Z = G >> 1;
              M |= 0;
              let $, z;
              for ($ = M, z = Z + 1; z--; $ += 2)
                P[$] -= P[$ - 1] + P[$ + 1] + 2 >> 2;
              for ($ = M + 1, z = Z; z--; $ += 2)
                P[$] += P[$ - 1] + P[$ + 1] >> 1;
            }
          }
        },
        /* 31 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.LZWStream = void 0;
          var t = F(19);
          class a extends t.DecodeStream {
            constructor(h, e, y) {
              super(e), this.str = h, this.dict = h.dict, this.cachedData = 0, this.bitsCached = 0;
              const c = 4096, d = {
                earlyChange: y,
                codeLength: 9,
                nextCode: 258,
                dictionaryValues: new Uint8Array(c),
                dictionaryLengths: new Uint16Array(c),
                dictionaryPrevCodes: new Uint16Array(c),
                currentSequence: new Uint8Array(c),
                currentSequenceLength: 0
              };
              for (let m = 0; m < 256; ++m)
                d.dictionaryValues[m] = m, d.dictionaryLengths[m] = 1;
              this.lzwState = d;
            }
            readBits(h) {
              let e = this.bitsCached, y = this.cachedData;
              for (; e < h; ) {
                const c = this.str.getByte();
                if (c === -1)
                  return this.eof = !0, null;
                y = y << 8 | c, e += 8;
              }
              return this.bitsCached = e -= h, this.cachedData = y, this.lastCode = null, y >>> e & (1 << h) - 1;
            }
            readBlock() {
              let y = 1024, c, d, m;
              const p = this.lzwState;
              if (!p)
                return;
              const g = p.earlyChange;
              let n = p.nextCode;
              const i = p.dictionaryValues, l = p.dictionaryLengths, u = p.dictionaryPrevCodes;
              let w = p.codeLength, O = p.prevCode;
              const b = p.currentSequence;
              let A = p.currentSequenceLength, Y = 0, j = this.bufferLength, X = this.ensureBuffer(this.bufferLength + y);
              for (c = 0; c < 512; c++) {
                const B = this.readBits(w), U = A > 0;
                if (B < 256)
                  b[0] = B, A = 1;
                else if (B >= 258)
                  if (B < n)
                    for (A = l[B], d = A - 1, m = B; d >= 0; d--)
                      b[d] = i[m], m = u[m];
                  else
                    b[A++] = b[0];
                else if (B === 256) {
                  w = 9, n = 258, A = 0;
                  continue;
                } else {
                  this.eof = !0, delete this.lzwState;
                  break;
                }
                if (U && (u[n] = O, l[n] = l[O] + 1, i[n] = b[0], n++, w = n + g & n + g - 1 ? w : Math.min(Math.log(n + g) / 0.6931471805599453 + 1, 12) | 0), O = B, Y += A, y < Y) {
                  do
                    y += 512;
                  while (y < Y);
                  X = this.ensureBuffer(this.bufferLength + y);
                }
                for (d = 0; d < A; d++)
                  X[j++] = b[d];
              }
              p.nextCode = n, p.codeLength = w, p.prevCode = O, p.currentSequenceLength = A, this.bufferLength = j;
            }
          }
          o.LZWStream = a;
        },
        /* 32 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.PredictorStream = void 0;
          var t = F(19), a = F(5), v = F(2);
          class h extends t.DecodeStream {
            constructor(y, c, d) {
              if (super(c), !(d instanceof a.Dict))
                return y;
              const m = this.predictor = d.get("Predictor") || 1;
              if (m <= 1)
                return y;
              if (m !== 2 && (m < 10 || m > 15))
                throw new v.FormatError(`Unsupported predictor: ${m}`);
              m === 2 ? this.readBlock = this.readBlockTiff : this.readBlock = this.readBlockPng, this.str = y, this.dict = y.dict;
              const p = this.colors = d.get("Colors") || 1, g = this.bits = d.get("BPC", "BitsPerComponent") || 8, n = this.columns = d.get("Columns") || 1;
              return this.pixBytes = p * g + 7 >> 3, this.rowBytes = n * p * g + 7 >> 3, this;
            }
            readBlockTiff() {
              const y = this.rowBytes, c = this.bufferLength, d = this.ensureBuffer(c + y), m = this.bits, p = this.colors, g = this.str.getBytes(y);
              if (this.eof = !g.length, this.eof)
                return;
              let n = 0, i = 0, l = 0, u = 0, w = c, O;
              if (m === 1 && p === 1)
                for (O = 0; O < y; ++O) {
                  let b = g[O] ^ n;
                  b ^= b >> 1, b ^= b >> 2, b ^= b >> 4, n = (b & 1) << 7, d[w++] = b;
                }
              else if (m === 8) {
                for (O = 0; O < p; ++O)
                  d[w++] = g[O];
                for (; O < y; ++O)
                  d[w] = d[w - p] + g[O], w++;
              } else if (m === 16) {
                const b = p * 2;
                for (O = 0; O < b; ++O)
                  d[w++] = g[O];
                for (; O < y; O += 2) {
                  const A = ((g[O] & 255) << 8) + (g[O + 1] & 255) + ((d[w - b] & 255) << 8) + (d[w - b + 1] & 255);
                  d[w++] = A >> 8 & 255, d[w++] = A & 255;
                }
              } else {
                const b = new Uint8Array(p + 1), A = (1 << m) - 1;
                let Y = 0, j = c;
                const X = this.columns;
                for (O = 0; O < X; ++O)
                  for (let B = 0; B < p; ++B)
                    l < m && (n = n << 8 | g[Y++] & 255, l += 8), b[B] = b[B] + (n >> l - m) & A, l -= m, i = i << m | b[B], u += m, u >= 8 && (d[j++] = i >> u - 8 & 255, u -= 8);
                u > 0 && (d[j++] = (i << 8 - u) + (n & (1 << 8 - u) - 1));
              }
              this.bufferLength += y;
            }
            readBlockPng() {
              const y = this.rowBytes, c = this.pixBytes, d = this.str.getByte(), m = this.str.getBytes(y);
              if (this.eof = !m.length, this.eof)
                return;
              const p = this.bufferLength, g = this.ensureBuffer(p + y);
              let n = g.subarray(p - y, p);
              n.length === 0 && (n = new Uint8Array(y));
              let i, l = p, u, w;
              switch (d) {
                case 0:
                  for (i = 0; i < y; ++i)
                    g[l++] = m[i];
                  break;
                case 1:
                  for (i = 0; i < c; ++i)
                    g[l++] = m[i];
                  for (; i < y; ++i)
                    g[l] = g[l - c] + m[i] & 255, l++;
                  break;
                case 2:
                  for (i = 0; i < y; ++i)
                    g[l++] = n[i] + m[i] & 255;
                  break;
                case 3:
                  for (i = 0; i < c; ++i)
                    g[l++] = (n[i] >> 1) + m[i];
                  for (; i < y; ++i)
                    g[l] = (n[i] + g[l - c] >> 1) + m[i] & 255, l++;
                  break;
                case 4:
                  for (i = 0; i < c; ++i)
                    u = n[i], w = m[i], g[l++] = u + w;
                  for (; i < y; ++i) {
                    u = n[i];
                    const O = n[i - c], b = g[l - c], A = b + u - O;
                    let Y = A - b;
                    Y < 0 && (Y = -Y);
                    let j = A - u;
                    j < 0 && (j = -j);
                    let X = A - O;
                    X < 0 && (X = -X), w = m[i], Y <= j && Y <= X ? g[l++] = b + w : j <= X ? g[l++] = u + w : g[l++] = O + w;
                  }
                  break;
                default:
                  throw new v.FormatError(`Unsupported predictor: ${d}`);
              }
              this.bufferLength += y;
            }
          }
          o.PredictorStream = h;
        },
        /* 33 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.RunLengthStream = void 0;
          var t = F(19);
          class a extends t.DecodeStream {
            constructor(h, e) {
              super(e), this.str = h, this.dict = h.dict;
            }
            readBlock() {
              const h = this.str.getBytes(2);
              if (!h || h.length < 2 || h[0] === 128) {
                this.eof = !0;
                return;
              }
              let e, y = this.bufferLength, c = h[0];
              if (c < 128) {
                if (e = this.ensureBuffer(y + c + 1), e[y++] = h[1], c > 0) {
                  const d = this.str.getBytes(c);
                  e.set(d, y), y += c;
                }
              } else {
                c = 257 - c;
                const d = h[1];
                e = this.ensureBuffer(y + c + 1);
                for (let m = 0; m < c; m++)
                  e[y++] = d;
              }
              this.bufferLength = y;
            }
          }
          o.RunLengthStream = a;
        },
        /* 34 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.Font = o.ErrorFont = void 0;
          var t = F(2), a = F(35), v = F(38), h = F(40), e = F(39), y = F(37), c = F(41), d = F(42), m = F(43), p = F(44), g = F(45), n = F(46), i = F(16), l = F(47), u = F(6), w = F(10), O = F(48);
          const b = [[57344, 63743], [1048576, 1114109]], A = 1e3, Y = ["ascent", "bbox", "black", "bold", "charProcOperatorList", "composite", "cssFontInfo", "data", "defaultVMetrics", "defaultWidth", "descent", "fallbackName", "fontMatrix", "fontType", "isType3Font", "italic", "loadedName", "mimetype", "missingFile", "name", "remeasure", "subtype", "type", "vertical"], j = ["cMap", "defaultEncoding", "differences", "isMonospace", "isSerifFont", "isSymbolicFont", "seacMap", "toFontChar", "toUnicode", "vmetrics", "widths"];
          function X(W) {
            if (!W.fontMatrix || W.fontMatrix[0] === t.FONT_IDENTITY_MATRIX[0])
              return;
            const I = 1e-3 / W.fontMatrix[0], H = W.widths;
            for (const ie in H)
              H[ie] *= I;
            W.defaultWidth *= I;
          }
          function B(W, I) {
            if (W.isInternalFont || I === W.defaultEncoding || W.toUnicode instanceof d.IdentityToUnicodeMap)
              return;
            const H = [], ie = (0, e.getGlyphsUnicode)();
            for (const ue in I) {
              if (W.hasIncludedToUnicodeMap) {
                if (W.toUnicode.has(ue))
                  continue;
              } else if (W.hasEncoding && (W.differences.length === 0 || W.differences[ue] !== void 0))
                continue;
              const fe = I[ue], de = (0, h.getUnicodeForGlyph)(fe, ie);
              de !== -1 && (H[ue] = String.fromCharCode(de));
            }
            H.length > 0 && W.toUnicode.amend(H);
          }
          function U(W) {
            if (!W.fallbackToUnicode || W.toUnicode instanceof d.IdentityToUnicodeMap)
              return;
            const I = [];
            for (const H in W.fallbackToUnicode)
              W.toUnicode.has(H) || (I[H] = W.fallbackToUnicode[H]);
            I.length > 0 && W.toUnicode.amend(I);
          }
          class k {
            constructor(I, H, ie, ue, fe, de, pe, xe, Fe) {
              this.originalCharCode = I, this.fontChar = H, this.unicode = ie, this.accent = ue, this.width = fe, this.vmetric = de, this.operatorListId = pe, this.isSpace = xe, this.isInFont = Fe;
              const Se = (0, h.getCharUnicodeCategory)(ie);
              this.isWhitespace = Se.isWhitespace, this.isZeroWidthDiacritic = Se.isZeroWidthDiacritic, this.isInvisibleFormatMark = Se.isInvisibleFormatMark;
            }
            matchesForCache(I, H, ie, ue, fe, de, pe, xe, Fe) {
              return this.originalCharCode === I && this.fontChar === H && this.unicode === ie && this.accent === ue && this.width === fe && this.vmetric === de && this.operatorListId === pe && this.isSpace === xe && this.isInFont === Fe;
            }
          }
          function x(W, I) {
            return (W << 8) + I;
          }
          function f(W, I, H) {
            W[I + 1] = H, W[I] = H >>> 8;
          }
          function D(W, I) {
            const H = (W << 8) + I;
            return H & 32768 ? H - 65536 : H;
          }
          function _(W, I, H, ie) {
            return (W << 24) + (I << 16) + (H << 8) + ie;
          }
          function S(W) {
            return String.fromCharCode(W >> 8 & 255, W & 255);
          }
          function C(W) {
            return W > 32767 ? W = 32767 : W < -32768 && (W = -32768), String.fromCharCode(W >> 8 & 255, W & 255);
          }
          function T(W) {
            const I = W.peekBytes(4);
            return (0, u.readUint32)(I, 0) === 65536 || (0, t.bytesToString)(I) === "true";
          }
          function P(W) {
            const I = W.peekBytes(4);
            return (0, t.bytesToString)(I) === "ttcf";
          }
          function M(W) {
            const I = W.peekBytes(4);
            return (0, t.bytesToString)(I) === "OTTO";
          }
          function G(W) {
            const I = W.peekBytes(2);
            return I[0] === 37 && I[1] === 33 || I[0] === 128 && I[1] === 1;
          }
          function Z(W) {
            const I = W.peekBytes(4);
            return I[0] >= 1 && I[3] >= 1 && I[3] <= 4;
          }
          function $(W, {
            type: I,
            subtype: H,
            composite: ie
          }) {
            let ue, fe;
            return T(W) || P(W) ? ie ? ue = "CIDFontType2" : ue = "TrueType" : M(W) ? ie ? ue = "CIDFontType2" : ue = "OpenType" : G(W) ? ie ? ue = "CIDFontType0" : ue = I === "MMType1" ? "MMType1" : "Type1" : Z(W) ? ie ? (ue = "CIDFontType0", fe = "CIDFontType0C") : (ue = I === "MMType1" ? "MMType1" : "Type1", fe = "Type1C") : ((0, t.warn)("getFontFileType: Unable to detect correct font file Type/Subtype."), ue = I, fe = H), [ue, fe];
          }
          function z(W, I) {
            for (const H in I)
              W[+H] = I[H];
          }
          function V(W, I, H) {
            const ie = [];
            let ue;
            for (let fe = 0, de = W.length; fe < de; fe++)
              ue = (0, h.getUnicodeForGlyph)(W[fe], I), ue !== -1 && (ie[fe] = ue);
            for (const fe in H)
              ue = (0, h.getUnicodeForGlyph)(H[fe], I), ue !== -1 && (ie[+fe] = ue);
            return ie;
          }
          function L(W, I, H = !1) {
            switch (I.length) {
              case 1:
                return I.charCodeAt(0);
              case 2:
                return I.charCodeAt(0) << 8 | I.charCodeAt(1);
            }
            const ie = `Unsupported CID string (charCode ${W}): "${I}".`;
            if (H)
              throw new t.FormatError(ie);
            return (0, t.warn)(ie), I;
          }
          function K(W, I, H, ie) {
            const ue = /* @__PURE__ */ Object.create(null), fe = /* @__PURE__ */ new Map(), de = [], pe = /* @__PURE__ */ new Set();
            let xe = 0;
            const Fe = b[xe][0];
            let Se = Fe, Ce = b[xe][1];
            for (let ke in W) {
              ke |= 0;
              let ye = W[ke];
              if (!I(ye))
                continue;
              if (Se > Ce) {
                if (xe++, xe >= b.length) {
                  (0, t.warn)("Ran out of space in font private use area.");
                  break;
                }
                Se = b[xe][0], Ce = b[xe][1];
              }
              const De = Se++;
              ye === 0 && (ye = H);
              let Ae = ie.get(ke);
              typeof Ae == "string" && (Ae = Ae.codePointAt(0)), Ae && Ae < Fe && !pe.has(ye) && (fe.set(Ae, ye), pe.add(ye)), ue[De] = ye, de[ke] = De;
            }
            return {
              toFontChar: de,
              charCodeToGlyphId: ue,
              toUnicodeExtraMap: fe,
              nextAvailableFontCharCode: Se
            };
          }
          function ne(W, I, H) {
            const ie = [];
            for (const de in W)
              W[de] >= H || ie.push({
                fontCharCode: de | 0,
                glyphId: W[de]
              });
            if (I)
              for (const [de, pe] of I)
                pe >= H || ie.push({
                  fontCharCode: de,
                  glyphId: pe
                });
            ie.length === 0 && ie.push({
              fontCharCode: 0,
              glyphId: 0
            }), ie.sort(function(pe, xe) {
              return pe.fontCharCode - xe.fontCharCode;
            });
            const ue = [], fe = ie.length;
            for (let de = 0; de < fe; ) {
              const pe = ie[de].fontCharCode, xe = [ie[de].glyphId];
              ++de;
              let Fe = pe;
              for (; de < fe && Fe + 1 === ie[de].fontCharCode && (xe.push(ie[de].glyphId), ++Fe, ++de, Fe !== 65535); )
                ;
              ue.push([pe, Fe, xe]);
            }
            return ue;
          }
          function se(W, I, H) {
            const ie = ne(W, I, H), ue = ie.at(-1)[1] > 65535 ? 2 : 1;
            let fe = "\0\0" + S(ue) + "\0\0" + (0, t.string32)(4 + ue * 8), de, pe, xe, Fe;
            for (de = ie.length - 1; de >= 0 && !(ie[de][0] <= 65535); --de)
              ;
            const Se = de + 1;
            ie[de][0] < 65535 && ie[de][1] === 65535 && (ie[de][1] = 65534);
            const Ce = ie[de][1] < 65535 ? 1 : 0, ke = Se + Ce, ye = l.OpenTypeFileBuilder.getSearchParams(ke, 2);
            let De = "", Ae = "", Te = "", ve = "", Ne = "", Ge = 0, it, Me, Ie, Ee;
            for (de = 0, pe = Se; de < pe; de++) {
              it = ie[de], Me = it[0], Ie = it[1], De += S(Me), Ae += S(Ie), Ee = it[2];
              let xt = !0;
              for (xe = 1, Fe = Ee.length; xe < Fe; ++xe)
                if (Ee[xe] !== Ee[xe - 1] + 1) {
                  xt = !1;
                  break;
                }
              if (xt) {
                const Je = Ee[0];
                Te += S(Je - Me & 65535), ve += S(0);
              } else {
                const Je = (ke - de) * 2 + Ge * 2;
                for (Ge += Ie - Me + 1, Te += S(0), ve += S(Je), xe = 0, Fe = Ee.length; xe < Fe; ++xe)
                  Ne += S(Ee[xe]);
              }
            }
            Ce > 0 && (Ae += "ÿÿ", De += "ÿÿ", Te += "\0", ve += "\0\0");
            const st = "\0\0" + S(2 * ke) + S(ye.range) + S(ye.entry) + S(ye.rangeShift) + Ae + "\0\0" + De + Te + ve + Ne;
            let Qe = "", ct = "";
            if (ue > 1) {
              for (fe += `\0\0
` + (0, t.string32)(4 + ue * 8 + 4 + st.length), Qe = "", de = 0, pe = ie.length; de < pe; de++) {
                it = ie[de], Me = it[0], Ee = it[2];
                let xt = Ee[0];
                for (xe = 1, Fe = Ee.length; xe < Fe; ++xe)
                  Ee[xe] !== Ee[xe - 1] + 1 && (Ie = it[0] + xe - 1, Qe += (0, t.string32)(Me) + (0, t.string32)(Ie) + (0, t.string32)(xt), Me = Ie + 1, xt = Ee[xe]);
                Qe += (0, t.string32)(Me) + (0, t.string32)(it[1]) + (0, t.string32)(xt);
              }
              ct = "\0\f\0\0" + (0, t.string32)(Qe.length + 16) + "\0\0\0\0" + (0, t.string32)(Qe.length / 12);
            }
            return fe + "\0" + S(st.length + 4) + st + ct + Qe;
          }
          function q(W, I) {
            I.pos = (I.start || 0) + W.offset;
            const H = I.getUint16();
            I.skip(60);
            const ie = I.getUint16();
            if (H < 4 && ie & 768)
              return !1;
            const ue = I.getUint16(), fe = I.getUint16();
            return ue > fe || (I.skip(6), I.getUint16() === 0) ? !1 : (W.data[8] = W.data[9] = 0, !0);
          }
          function N(W, I, H) {
            H = H || {
              unitsPerEm: 0,
              yMax: 0,
              yMin: 0,
              ascent: 0,
              descent: 0
            };
            let ie = 0, ue = 0, fe = 0, de = 0, pe = null, xe = 0;
            if (I) {
              for (let Te in I) {
                Te |= 0, (pe > Te || !pe) && (pe = Te), xe < Te && (xe = Te);
                const ve = (0, h.getUnicodeRangeFor)(Te);
                if (ve < 32)
                  ie |= 1 << ve;
                else if (ve < 64)
                  ue |= 1 << ve - 32;
                else if (ve < 96)
                  fe |= 1 << ve - 64;
                else if (ve < 123)
                  de |= 1 << ve - 96;
                else
                  throw new t.FormatError("Unicode ranges Bits > 123 are reserved for internal usage");
              }
              xe > 65535 && (xe = 65535);
            } else
              pe = 0, xe = 255;
            const Fe = W.bbox || [0, 0, 0, 0], Se = H.unitsPerEm || 1 / (W.fontMatrix || t.FONT_IDENTITY_MATRIX)[0], Ce = W.ascentScaled ? 1 : Se / A, ke = H.ascent || Math.round(Ce * (W.ascent || Fe[3]));
            let ye = H.descent || Math.round(Ce * (W.descent || Fe[1]));
            ye > 0 && W.descent > 0 && Fe[1] < 0 && (ye = -ye);
            const De = H.yMax || ke, Ae = -H.yMin || -ye;
            return "\0$ô\0\0\0»\0\0\0»\0\0ß\x001\0\0\0\0" + String.fromCharCode(W.fixedPitch ? 9 : 0) + "\0\0\0\0\0\0" + (0, t.string32)(ie) + (0, t.string32)(ue) + (0, t.string32)(fe) + (0, t.string32)(de) + "*21*" + S(W.italicAngle ? 1 : 0) + S(pe || W.firstChar) + S(xe || W.lastChar) + S(ke) + S(ye) + "\0d" + S(De) + S(Ae) + "\0\0\0\0\0\0\0\0" + S(W.xHeight) + S(W.capHeight) + S(0) + S(pe || W.firstChar) + "\0";
          }
          function Q(W) {
            const I = Math.floor(W.italicAngle * 65536);
            return "\0\0\0" + (0, t.string32)(I) + "\0\0\0\0" + (0, t.string32)(W.fixedPitch ? 1 : 0) + "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
          }
          function E(W) {
            return W.replace(/[^\x21-\x7E]|[[\](){}<>/%]/g, "").slice(0, 63);
          }
          function te(W, I) {
            I || (I = [[], []]);
            const H = [I[0][0] || "Original licence", I[0][1] || W, I[0][2] || "Unknown", I[0][3] || "uniqueID", I[0][4] || W, I[0][5] || "Version 0.11", I[0][6] || E(W), I[0][7] || "Unknown", I[0][8] || "Unknown", I[0][9] || "Unknown"], ie = [];
            let ue, fe, de, pe, xe;
            for (ue = 0, fe = H.length; ue < fe; ue++) {
              xe = I[1][ue] || H[ue];
              const Te = [];
              for (de = 0, pe = xe.length; de < pe; de++)
                Te.push(S(xe.charCodeAt(de)));
              ie.push(Te.join(""));
            }
            const Fe = [H, ie], Se = ["\0", "\0"], Ce = ["\0\0", "\0"], ke = ["\0\0", "	"], ye = H.length * Se.length;
            let De = "\0\0" + S(ye) + S(ye * 12 + 6), Ae = 0;
            for (ue = 0, fe = Se.length; ue < fe; ue++) {
              const Te = Fe[ue];
              for (de = 0, pe = Te.length; de < pe; de++) {
                xe = Te[de];
                const ve = Se[ue] + Ce[ue] + ke[ue] + S(de) + S(xe.length) + S(Ae);
                De += ve, Ae += xe.length;
              }
            }
            return De += H.join("") + ie.join(""), De;
          }
          class oe {
            constructor(I, H, ie) {
              this.name = I, this.psName = null, this.mimetype = null, this.disableFontFace = !1, this.loadedName = ie.loadedName, this.isType3Font = ie.isType3Font, this.missingFile = !1, this.cssFontInfo = ie.cssFontInfo, this._charsCache = /* @__PURE__ */ Object.create(null), this._glyphCache = /* @__PURE__ */ Object.create(null);
              let ue = !!(ie.flags & v.FontFlags.Serif);
              if (!ue && !ie.isSimulatedFlags) {
                const Fe = I.replace(/[,_]/g, "-").split("-")[0], Se = (0, c.getSerifFonts)();
                for (const Ce of Fe.split("+"))
                  if (Se[Ce]) {
                    ue = !0;
                    break;
                  }
              }
              this.isSerifFont = ue, this.isSymbolicFont = !!(ie.flags & v.FontFlags.Symbolic), this.isMonospace = !!(ie.flags & v.FontFlags.FixedPitch);
              let fe = ie.type, de = ie.subtype;
              this.type = fe, this.subtype = de;
              let pe = "sans-serif";
              if (this.isMonospace ? pe = "monospace" : this.isSerifFont && (pe = "serif"), this.fallbackName = pe, this.differences = ie.differences, this.widths = ie.widths, this.defaultWidth = ie.defaultWidth, this.composite = ie.composite, this.cMap = ie.cMap, this.capHeight = ie.capHeight / A, this.ascent = ie.ascent / A, this.descent = ie.descent / A, this.lineHeight = this.ascent - this.descent, this.fontMatrix = ie.fontMatrix, this.bbox = ie.bbox, this.defaultEncoding = ie.defaultEncoding, this.toUnicode = ie.toUnicode, this.toFontChar = [], ie.type === "Type3") {
                for (let Fe = 0; Fe < 256; Fe++)
                  this.toFontChar[Fe] = this.differences[Fe] || ie.defaultEncoding[Fe];
                this.fontType = t.FontType.TYPE3;
                return;
              }
              if (this.cidEncoding = ie.cidEncoding || "", this.vertical = !!ie.vertical, this.vertical && (this.vmetrics = ie.vmetrics, this.defaultVMetrics = ie.defaultVMetrics), !H || H.isEmpty) {
                H && (0, t.warn)('Font file is empty in "' + I + '" (' + this.loadedName + ")"), this.fallbackToSystemFont(ie);
                return;
              }
              [fe, de] = $(H, ie), (fe !== this.type || de !== this.subtype) && (0, t.info)(`Inconsistent font file Type/SubType, expected: ${this.type}/${this.subtype} but found: ${fe}/${de}.`);
              let xe;
              try {
                switch (fe) {
                  case "MMType1":
                    (0, t.info)("MMType1 font (" + I + "), falling back to Type1.");
                  case "Type1":
                  case "CIDFontType0":
                    this.mimetype = "font/opentype";
                    const Fe = de === "Type1C" || de === "CIDFontType0C" ? new m.CFFFont(H, ie) : new O.Type1Font(I, H, ie);
                    X(ie), xe = this.convert(I, Fe, ie);
                    break;
                  case "OpenType":
                  case "TrueType":
                  case "CIDFontType2":
                    this.mimetype = "font/opentype", xe = this.checkAndRepair(I, H, ie), this.isOpenType && (X(ie), fe = "OpenType");
                    break;
                  default:
                    throw new t.FormatError(`Font ${fe} is not supported`);
                }
              } catch (Fe) {
                (0, t.warn)(Fe), this.fallbackToSystemFont(ie);
                return;
              }
              U(ie), this.data = xe, this.fontType = (0, v.getFontType)(fe, de, ie.isStandardFont), this.fontMatrix = ie.fontMatrix, this.widths = ie.widths, this.defaultWidth = ie.defaultWidth, this.toUnicode = ie.toUnicode, this.seacMap = ie.seacMap;
            }
            get renderer() {
              const I = p.FontRendererFactory.create(this, v.SEAC_ANALYSIS_ENABLED);
              return (0, t.shadow)(this, "renderer", I);
            }
            exportData(I = !1) {
              const H = I ? [...Y, ...j] : Y, ie = /* @__PURE__ */ Object.create(null);
              let ue, fe;
              for (ue of H)
                fe = this[ue], fe !== void 0 && (ie[ue] = fe);
              return ie;
            }
            fallbackToSystemFont(I) {
              this.missingFile = !0;
              const H = this.name, ie = this.type, ue = this.subtype;
              let fe = (0, v.normalizeFontName)(H);
              const de = (0, c.getStdFontMap)(), pe = (0, c.getNonStdFontMap)(), xe = !!de[fe], Fe = !!(pe[fe] && de[pe[fe]]);
              fe = de[fe] || pe[fe] || fe;
              const Ce = (0, g.getFontBasicMetrics)()[fe];
              Ce && (isNaN(this.ascent) && (this.ascent = Ce.ascent / A), isNaN(this.descent) && (this.descent = Ce.descent / A), isNaN(this.capHeight) && (this.capHeight = Ce.capHeight / A)), this.bold = fe.search(/bold/gi) !== -1, this.italic = fe.search(/oblique/gi) !== -1 || fe.search(/italic/gi) !== -1, this.black = H.search(/Black/g) !== -1;
              const ke = H.search(/Narrow/g) !== -1;
              if (this.remeasure = (!xe || ke) && Object.keys(this.widths).length > 0, (xe || Fe) && ie === "CIDFontType2" && this.cidEncoding.startsWith("Identity-")) {
                const ye = I.cidToGidMap, De = [];
                if (z(De, (0, c.getGlyphMapForStandardFonts)()), /Arial-?Black/i.test(H) ? z(De, (0, c.getSupplementalGlyphMapForArialBlack)()) : /Calibri/i.test(H) && z(De, (0, c.getSupplementalGlyphMapForCalibri)()), ye) {
                  for (const Ae in De) {
                    const Te = De[Ae];
                    ye[Te] !== void 0 && (De[+Ae] = ye[Te]);
                  }
                  ye.length !== this.toUnicode.length && I.hasIncludedToUnicodeMap && this.toUnicode instanceof d.IdentityToUnicodeMap && this.toUnicode.forEach(function(Ae, Te) {
                    const ve = De[Ae];
                    ye[ve] === void 0 && (De[+Ae] = Te);
                  });
                }
                this.toUnicode instanceof d.IdentityToUnicodeMap || this.toUnicode.forEach(function(Ae, Te) {
                  De[+Ae] = Te;
                }), this.toFontChar = De, this.toUnicode = new d.ToUnicodeMap(De);
              } else if (/Symbol/i.test(fe))
                this.toFontChar = V(y.SymbolSetEncoding, (0, e.getGlyphsUnicode)(), this.differences);
              else if (/Dingbats/i.test(fe))
                /Wingdings/i.test(H) && (0, t.warn)("Non-embedded Wingdings font, falling back to ZapfDingbats."), this.toFontChar = V(y.ZapfDingbatsEncoding, (0, e.getDingbatsGlyphsUnicode)(), this.differences);
              else if (xe) {
                const ye = V(this.defaultEncoding, (0, e.getGlyphsUnicode)(), this.differences);
                ie === "CIDFontType2" && !this.cidEncoding.startsWith("Identity-") && !(this.toUnicode instanceof d.IdentityToUnicodeMap) && this.toUnicode.forEach(function(De, Ae) {
                  ye[+De] = Ae;
                }), this.toFontChar = ye;
              } else {
                const ye = (0, e.getGlyphsUnicode)(), De = [];
                this.toUnicode.forEach((Ae, Te) => {
                  if (!this.composite) {
                    const ve = this.differences[Ae] || this.defaultEncoding[Ae], Ne = (0, h.getUnicodeForGlyph)(ve, ye);
                    Ne !== -1 && (Te = Ne);
                  }
                  De[+Ae] = Te;
                }), this.composite && this.toUnicode instanceof d.IdentityToUnicodeMap && /Verdana/i.test(H) && z(De, (0, c.getGlyphMapForStandardFonts)()), this.toFontChar = De;
              }
              U(I), this.loadedName = fe.split("-")[0], this.fontType = (0, v.getFontType)(ie, ue, I.isStandardFont);
            }
            checkAndRepair(I, H, ie) {
              const ue = ["OS/2", "cmap", "head", "hhea", "hmtx", "maxp", "name", "post", "loca", "glyf", "fpgm", "prep", "cvt ", "CFF "];
              function fe(Ve, je) {
                const at = /* @__PURE__ */ Object.create(null);
                at["OS/2"] = null, at.cmap = null, at.head = null, at.hhea = null, at.hmtx = null, at.maxp = null, at.name = null, at.post = null;
                for (let nt = 0; nt < je; nt++) {
                  const ft = de(Ve);
                  ue.includes(ft.tag) && ft.length !== 0 && (at[ft.tag] = ft);
                }
                return at;
              }
              function de(Ve) {
                const je = Ve.getString(4), at = Ve.getInt32() >>> 0, nt = Ve.getInt32() >>> 0, ft = Ve.getInt32() >>> 0, Tt = Ve.pos;
                Ve.pos = Ve.start || 0, Ve.skip(nt);
                const yt = Ve.getBytes(ft);
                return Ve.pos = Tt, je === "head" && (yt[8] = yt[9] = yt[10] = yt[11] = 0, yt[17] |= 32), {
                  tag: je,
                  checksum: at,
                  length: ft,
                  offset: nt,
                  data: yt
                };
              }
              function pe(Ve) {
                return {
                  version: Ve.getString(4),
                  numTables: Ve.getUint16(),
                  searchRange: Ve.getUint16(),
                  entrySelector: Ve.getUint16(),
                  rangeShift: Ve.getUint16()
                };
              }
              function xe(Ve) {
                const je = Ve.getString(4);
                (0, t.assert)(je === "ttcf", "Must be a TrueType Collection font.");
                const at = Ve.getUint16(), nt = Ve.getUint16(), ft = Ve.getInt32() >>> 0, Tt = [];
                for (let dt = 0; dt < ft; dt++)
                  Tt.push(Ve.getInt32() >>> 0);
                const yt = {
                  ttcTag: je,
                  majorVersion: at,
                  minorVersion: nt,
                  numFonts: ft,
                  offsetTable: Tt
                };
                switch (at) {
                  case 1:
                    return yt;
                  case 2:
                    return yt.dsigTag = Ve.getInt32() >>> 0, yt.dsigLength = Ve.getInt32() >>> 0, yt.dsigOffset = Ve.getInt32() >>> 0, yt;
                }
                throw new t.FormatError(`Invalid TrueType Collection majorVersion: ${at}.`);
              }
              function Fe(Ve, je) {
                const {
                  numFonts: at,
                  offsetTable: nt
                } = xe(Ve), ft = je.split("+");
                let Tt;
                for (let yt = 0; yt < at; yt++) {
                  Ve.pos = (Ve.start || 0) + nt[yt];
                  const dt = pe(Ve), wt = fe(Ve, dt.numTables);
                  if (!wt.name)
                    throw new t.FormatError('TrueType Collection font must contain a "name" table.');
                  const Dt = Te(wt.name);
                  for (let jt = 0, Bt = Dt.length; jt < Bt; jt++)
                    for (let kt = 0, Ue = Dt[jt].length; kt < Ue; kt++) {
                      const We = Dt[jt][kt] && Dt[jt][kt].replace(/\s/g, "");
                      if (We) {
                        if (We === je)
                          return {
                            header: dt,
                            tables: wt
                          };
                        if (!(ft.length < 2))
                          for (const rt of ft)
                            We === rt && (Tt = {
                              name: rt,
                              header: dt,
                              tables: wt
                            });
                      }
                    }
                }
                if (Tt)
                  return (0, t.warn)(`TrueType Collection does not contain "${je}" font, falling back to "${Tt.name}" font instead.`), {
                    header: Tt.header,
                    tables: Tt.tables
                  };
                throw new t.FormatError(`TrueType Collection does not contain "${je}" font.`);
              }
              function Se(Ve, je, at, nt) {
                if (!Ve)
                  return (0, t.warn)("No cmap table available."), {
                    platformId: -1,
                    encodingId: -1,
                    mappings: [],
                    hasShortCmap: !1
                  };
                let ft, Tt = (je.start || 0) + Ve.offset;
                je.pos = Tt, je.skip(2);
                const yt = je.getUint16();
                let dt, wt = !1;
                for (let We = 0; We < yt; We++) {
                  const rt = je.getUint16(), tt = je.getUint16(), St = je.getInt32() >>> 0;
                  let Pt = !1;
                  if (!(dt && dt.platformId === rt && dt.encodingId === tt)) {
                    if (rt === 0 && (tt === 0 || tt === 1 || tt === 3))
                      Pt = !0;
                    else if (rt === 1 && tt === 0)
                      Pt = !0;
                    else if (rt === 3 && tt === 1 && (nt || !dt))
                      Pt = !0, at || (wt = !0);
                    else if (at && rt === 3 && tt === 0) {
                      Pt = !0;
                      let qt = !0;
                      if (We < yt - 1) {
                        const Mt = je.peekBytes(2);
                        x(Mt[0], Mt[1]) < rt && (qt = !1);
                      }
                      qt && (wt = !0);
                    }
                    if (Pt && (dt = {
                      platformId: rt,
                      encodingId: tt,
                      offset: St
                    }), wt)
                      break;
                  }
                }
                if (dt && (je.pos = Tt + dt.offset), !dt || je.peekByte() === -1)
                  return (0, t.warn)("Could not find a preferred cmap table."), {
                    platformId: -1,
                    encodingId: -1,
                    mappings: [],
                    hasShortCmap: !1
                  };
                const Dt = je.getUint16();
                let jt = !1;
                const Bt = [];
                let kt, Ue;
                if (Dt === 0) {
                  for (je.skip(4), kt = 0; kt < 256; kt++) {
                    const We = je.getByte();
                    We && Bt.push({
                      charCode: kt,
                      glyphId: We
                    });
                  }
                  jt = !0;
                } else if (Dt === 2) {
                  je.skip(4);
                  const We = [];
                  let rt = 0;
                  for (let St = 0; St < 256; St++) {
                    const Pt = je.getUint16() >> 3;
                    We.push(Pt), rt = Math.max(Pt, rt);
                  }
                  const tt = [];
                  for (let St = 0; St <= rt; St++)
                    tt.push({
                      firstCode: je.getUint16(),
                      entryCount: je.getUint16(),
                      idDelta: D(je.getByte(), je.getByte()),
                      idRangePos: je.pos + je.getUint16()
                    });
                  for (let St = 0; St < 256; St++)
                    if (We[St] === 0)
                      je.pos = tt[0].idRangePos + 2 * St, Ue = je.getUint16(), Bt.push({
                        charCode: St,
                        glyphId: Ue
                      });
                    else {
                      const Pt = tt[We[St]];
                      for (kt = 0; kt < Pt.entryCount; kt++) {
                        const qt = (St << 8) + kt + Pt.firstCode;
                        je.pos = Pt.idRangePos + 2 * kt, Ue = je.getUint16(), Ue !== 0 && (Ue = (Ue + Pt.idDelta) % 65536), Bt.push({
                          charCode: qt,
                          glyphId: Ue
                        });
                      }
                    }
                } else if (Dt === 4) {
                  je.skip(4);
                  const We = je.getUint16() >> 1;
                  je.skip(6);
                  const rt = [];
                  let tt;
                  for (tt = 0; tt < We; tt++)
                    rt.push({
                      end: je.getUint16()
                    });
                  for (je.skip(2), tt = 0; tt < We; tt++)
                    rt[tt].start = je.getUint16();
                  for (tt = 0; tt < We; tt++)
                    rt[tt].delta = je.getUint16();
                  let St = 0, Pt;
                  for (tt = 0; tt < We; tt++) {
                    ft = rt[tt];
                    const Mt = je.getUint16();
                    if (!Mt) {
                      ft.offsetIndex = -1;
                      continue;
                    }
                    Pt = (Mt >> 1) - (We - tt), ft.offsetIndex = Pt, St = Math.max(St, Pt + ft.end - ft.start + 1);
                  }
                  const qt = [];
                  for (kt = 0; kt < St; kt++)
                    qt.push(je.getUint16());
                  for (tt = 0; tt < We; tt++) {
                    ft = rt[tt], Tt = ft.start;
                    const Mt = ft.end, Wt = ft.delta;
                    for (Pt = ft.offsetIndex, kt = Tt; kt <= Mt; kt++)
                      kt !== 65535 && (Ue = Pt < 0 ? kt : qt[Pt + kt - Tt], Ue = Ue + Wt & 65535, Bt.push({
                        charCode: kt,
                        glyphId: Ue
                      }));
                  }
                } else if (Dt === 6) {
                  je.skip(4);
                  const We = je.getUint16(), rt = je.getUint16();
                  for (kt = 0; kt < rt; kt++) {
                    Ue = je.getUint16();
                    const tt = We + kt;
                    Bt.push({
                      charCode: tt,
                      glyphId: Ue
                    });
                  }
                } else if (Dt === 12) {
                  je.skip(10);
                  const We = je.getInt32() >>> 0;
                  for (kt = 0; kt < We; kt++) {
                    const rt = je.getInt32() >>> 0, tt = je.getInt32() >>> 0;
                    let St = je.getInt32() >>> 0;
                    for (let Pt = rt; Pt <= tt; Pt++)
                      Bt.push({
                        charCode: Pt,
                        glyphId: St++
                      });
                  }
                } else
                  return (0, t.warn)("cmap table has unsupported format: " + Dt), {
                    platformId: -1,
                    encodingId: -1,
                    mappings: [],
                    hasShortCmap: !1
                  };
                Bt.sort(function(We, rt) {
                  return We.charCode - rt.charCode;
                });
                for (let We = 1; We < Bt.length; We++)
                  Bt[We - 1].charCode === Bt[We].charCode && (Bt.splice(We, 1), We--);
                return {
                  platformId: dt.platformId,
                  encodingId: dt.encodingId,
                  mappings: Bt,
                  hasShortCmap: jt
                };
              }
              function Ce(Ve, je, at, nt, ft, Tt) {
                if (!je) {
                  at && (at.data = null);
                  return;
                }
                Ve.pos = (Ve.start || 0) + je.offset, Ve.pos += 4, Ve.pos += 2, Ve.pos += 2, Ve.pos += 2, Ve.pos += 2, Ve.pos += 2, Ve.pos += 2, Ve.pos += 2, Ve.pos += 2, Ve.pos += 2;
                const yt = Ve.getUint16();
                Ve.pos += 8, Ve.pos += 2;
                let dt = Ve.getUint16();
                yt !== 0 && (x(nt.data[44], nt.data[45]) & 2 || (je.data[22] = 0, je.data[23] = 0)), dt > ft && ((0, t.info)(`The numOfMetrics (${dt}) should not be greater than the numGlyphs (${ft}).`), dt = ft, je.data[34] = (dt & 65280) >> 8, je.data[35] = dt & 255);
                const Dt = ft - dt - (at.length - dt * 4 >> 1);
                if (Dt > 0) {
                  const jt = new Uint8Array(at.length + Dt * 2);
                  jt.set(at.data), Tt && (jt[at.length] = at.data[2], jt[at.length + 1] = at.data[3]), at.data = jt;
                }
              }
              function ke(Ve, je, at, nt, ft, Tt) {
                const yt = {
                  length: 0,
                  sizeOfInstructions: 0
                };
                if (at - je <= 12)
                  return yt;
                const dt = Ve.subarray(je, at);
                let wt = D(dt[0], dt[1]);
                if (wt < 0)
                  return wt = -1, f(dt, 0, wt), nt.set(dt, ft), yt.length = dt.length, yt;
                let Dt, jt = 10, Bt = 0;
                for (Dt = 0; Dt < wt; Dt++)
                  Bt = (dt[jt] << 8 | dt[jt + 1]) + 1, jt += 2;
                const kt = jt, Ue = dt[jt] << 8 | dt[jt + 1];
                yt.sizeOfInstructions = Ue, jt += 2 + Ue;
                const We = jt;
                let rt = 0;
                for (Dt = 0; Dt < Bt; Dt++) {
                  const St = dt[jt++];
                  St & 192 && (dt[jt - 1] = St & 63);
                  let Pt = 2;
                  St & 2 ? Pt = 1 : St & 16 && (Pt = 0);
                  let qt = 2;
                  St & 4 ? qt = 1 : St & 32 && (qt = 0);
                  const Mt = Pt + qt;
                  if (rt += Mt, St & 8) {
                    const Wt = dt[jt++];
                    Dt += Wt, rt += Wt * Mt;
                  }
                }
                if (rt === 0)
                  return yt;
                let tt = jt + rt;
                return tt > dt.length ? yt : !Tt && Ue > 0 ? (nt.set(dt.subarray(0, kt), ft), nt.set([0, 0], ft + kt), nt.set(dt.subarray(We, tt), ft + kt + 2), tt -= Ue, dt.length - tt > 3 && (tt = tt + 3 & -4), yt.length = tt, yt) : dt.length - tt > 3 ? (tt = tt + 3 & -4, nt.set(dt.subarray(0, tt), ft), yt.length = tt, yt) : (nt.set(dt, ft), yt.length = dt.length, yt);
              }
              function ye(Ve, je, at) {
                const nt = Ve.data, ft = _(nt[0], nt[1], nt[2], nt[3]);
                ft >> 16 !== 1 && ((0, t.info)("Attempting to fix invalid version in head table: " + ft), nt[0] = 0, nt[1] = 1, nt[2] = 0, nt[3] = 0);
                const Tt = x(nt[50], nt[51]);
                if (Tt < 0 || Tt > 1) {
                  (0, t.info)("Attempting to fix invalid indexToLocFormat in head table: " + Tt);
                  const yt = je + 1;
                  if (at === yt << 1)
                    nt[50] = 0, nt[51] = 0;
                  else if (at === yt << 2)
                    nt[50] = 0, nt[51] = 1;
                  else
                    throw new t.FormatError("Could not fix indexToLocFormat: " + Tt);
                }
              }
              function De(Ve, je, at, nt, ft, Tt, yt) {
                let dt, wt, Dt;
                nt ? (dt = 4, wt = function(Zt, an) {
                  return Zt[an] << 24 | Zt[an + 1] << 16 | Zt[an + 2] << 8 | Zt[an + 3];
                }, Dt = function(Zt, an, un) {
                  Zt[an] = un >>> 24 & 255, Zt[an + 1] = un >> 16 & 255, Zt[an + 2] = un >> 8 & 255, Zt[an + 3] = un & 255;
                }) : (dt = 2, wt = function(Zt, an) {
                  return Zt[an] << 9 | Zt[an + 1] << 1;
                }, Dt = function(Zt, an, un) {
                  Zt[an] = un >> 9 & 255, Zt[an + 1] = un >> 1 & 255;
                });
                const jt = Tt ? at + 1 : at, Bt = dt * (1 + jt), kt = new Uint8Array(Bt);
                kt.set(Ve.data.subarray(0, Bt)), Ve.data = kt;
                const Ue = je.data, We = Ue.length, rt = new Uint8Array(We);
                let tt, St;
                const Pt = [];
                for (tt = 0, St = 0; tt < at + 1; tt++, St += dt) {
                  let Wt = wt(kt, St);
                  Wt > We && (Wt = We), Pt.push({
                    index: tt,
                    offset: Wt,
                    endOffset: 0
                  });
                }
                for (Pt.sort((Wt, Zt) => Wt.offset - Zt.offset), tt = 0; tt < at; tt++)
                  Pt[tt].endOffset = Pt[tt + 1].offset;
                for (Pt.sort((Wt, Zt) => Wt.index - Zt.index), tt = 0; tt < at; tt++) {
                  const {
                    offset: Wt,
                    endOffset: Zt
                  } = Pt[tt];
                  if (Wt !== 0 || Zt !== 0)
                    break;
                  const an = Pt[tt + 1].offset;
                  if (an !== 0) {
                    Pt[tt].endOffset = an;
                    break;
                  }
                }
                const qt = /* @__PURE__ */ Object.create(null);
                let Mt = 0;
                for (Dt(kt, 0, Mt), tt = 0, St = dt; tt < at; tt++, St += dt) {
                  const Wt = ke(Ue, Pt[tt].offset, Pt[tt].endOffset, rt, Mt, ft), Zt = Wt.length;
                  Zt === 0 && (qt[tt] = !0), Wt.sizeOfInstructions > yt && (yt = Wt.sizeOfInstructions), Mt += Zt, Dt(kt, St, Mt);
                }
                if (Mt === 0) {
                  const Wt = new Uint8Array([0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0]);
                  for (tt = 0, St = dt; tt < jt; tt++, St += dt)
                    Dt(kt, St, Wt.length);
                  je.data = Wt;
                } else if (Tt) {
                  const Wt = wt(kt, dt);
                  rt.length > Wt + Mt ? je.data = rt.subarray(0, Wt + Mt) : (je.data = new Uint8Array(Wt + Mt), je.data.set(rt.subarray(0, Mt))), je.data.set(rt.subarray(0, Wt), Mt), Dt(Ve.data, kt.length - dt, Mt + Wt);
                } else
                  je.data = rt.subarray(0, Mt);
                return {
                  missingGlyphs: qt,
                  maxSizeOfInstructions: yt
                };
              }
              function Ae(Ve, je, at) {
                const nt = (H.start || 0) + Ve.offset;
                H.pos = nt;
                const ft = Ve.length, Tt = nt + ft, yt = H.getInt32();
                H.skip(28);
                let dt, wt = !0, Dt;
                switch (yt) {
                  case 65536:
                    dt = v.MacStandardGlyphOrdering;
                    break;
                  case 131072:
                    const jt = H.getUint16();
                    if (jt !== at) {
                      wt = !1;
                      break;
                    }
                    const Bt = [];
                    for (Dt = 0; Dt < jt; ++Dt) {
                      const We = H.getUint16();
                      if (We >= 32768) {
                        wt = !1;
                        break;
                      }
                      Bt.push(We);
                    }
                    if (!wt)
                      break;
                    const kt = [], Ue = [];
                    for (; H.pos < Tt; ) {
                      const We = H.getByte();
                      for (Ue.length = We, Dt = 0; Dt < We; ++Dt)
                        Ue[Dt] = String.fromCharCode(H.getByte());
                      kt.push(Ue.join(""));
                    }
                    for (dt = [], Dt = 0; Dt < jt; ++Dt) {
                      const We = Bt[Dt];
                      if (We < 258) {
                        dt.push(v.MacStandardGlyphOrdering[We]);
                        continue;
                      }
                      dt.push(kt[We - 258]);
                    }
                    break;
                  case 196608:
                    break;
                  default:
                    (0, t.warn)("Unknown/unsupported post table version " + yt), wt = !1, je.defaultEncoding && (dt = je.defaultEncoding);
                    break;
                }
                return je.glyphNames = dt, wt;
              }
              function Te(Ve) {
                const je = (H.start || 0) + Ve.offset;
                H.pos = je;
                const at = [[], []], nt = Ve.length, ft = je + nt;
                if (H.getUint16() !== 0 || nt < 6)
                  return at;
                const dt = H.getUint16(), wt = H.getUint16(), Dt = [], jt = 12;
                let Bt, kt;
                for (Bt = 0; Bt < dt && H.pos + jt <= ft; Bt++) {
                  const Ue = {
                    platform: H.getUint16(),
                    encoding: H.getUint16(),
                    language: H.getUint16(),
                    name: H.getUint16(),
                    length: H.getUint16(),
                    offset: H.getUint16()
                  };
                  (Ue.platform === 1 && Ue.encoding === 0 && Ue.language === 0 || Ue.platform === 3 && Ue.encoding === 1 && Ue.language === 1033) && Dt.push(Ue);
                }
                for (Bt = 0, kt = Dt.length; Bt < kt; Bt++) {
                  const Ue = Dt[Bt];
                  if (Ue.length <= 0)
                    continue;
                  const We = je + wt + Ue.offset;
                  if (We + Ue.length > ft)
                    continue;
                  H.pos = We;
                  const rt = Ue.name;
                  if (Ue.encoding) {
                    let tt = "";
                    for (let St = 0, Pt = Ue.length; St < Pt; St += 2)
                      tt += String.fromCharCode(H.getUint16());
                    at[1][rt] = tt;
                  } else
                    at[0][rt] = H.getString(Ue.length);
                }
                return at;
              }
              const ve = [0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1, 0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2, 0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1, -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];
              function Ne(Ve, je) {
                let at = Ve.data, nt = 0, ft, Tt, yt, dt, wt, Dt = 0, jt = 0;
                const Bt = [], kt = [], Ue = [];
                let We = je.tooComplexToFollowFunctions, rt = !1, tt = 0, St = 0;
                for (let qt = at.length; nt < qt; ) {
                  const Mt = at[nt++];
                  if (Mt === 64)
                    if (Tt = at[nt++], rt || St)
                      nt += Tt;
                    else
                      for (ft = 0; ft < Tt; ft++)
                        Bt.push(at[nt++]);
                  else if (Mt === 65)
                    if (Tt = at[nt++], rt || St)
                      nt += Tt * 2;
                    else
                      for (ft = 0; ft < Tt; ft++)
                        yt = at[nt++], Bt.push(yt << 8 | at[nt++]);
                  else if ((Mt & 248) === 176)
                    if (Tt = Mt - 176 + 1, rt || St)
                      nt += Tt;
                    else
                      for (ft = 0; ft < Tt; ft++)
                        Bt.push(at[nt++]);
                  else if ((Mt & 248) === 184)
                    if (Tt = Mt - 184 + 1, rt || St)
                      nt += Tt * 2;
                    else
                      for (ft = 0; ft < Tt; ft++)
                        yt = at[nt++], Bt.push(yt << 8 | at[nt++]);
                  else if (Mt === 43 && !We) {
                    if (!rt && !St) {
                      if (dt = Bt.at(-1), isNaN(dt))
                        (0, t.info)("TT: CALL empty stack (or invalid entry).");
                      else if (je.functionsUsed[dt] = !0, dt in je.functionsStackDeltas) {
                        const Wt = Bt.length + je.functionsStackDeltas[dt];
                        if (Wt < 0) {
                          (0, t.warn)("TT: CALL invalid functions stack delta."), je.hintsValid = !1;
                          return;
                        }
                        Bt.length = Wt;
                      } else if (dt in je.functionsDefined && !Ue.includes(dt)) {
                        if (kt.push({
                          data: at,
                          i: nt,
                          stackTop: Bt.length - 1
                        }), Ue.push(dt), wt = je.functionsDefined[dt], !wt) {
                          (0, t.warn)("TT: CALL non-existent function"), je.hintsValid = !1;
                          return;
                        }
                        at = wt.data, nt = wt.i;
                      }
                    }
                  } else if (Mt === 44 && !We)
                    (rt || St) && ((0, t.warn)("TT: nested FDEFs not allowed"), We = !0), rt = !0, jt = nt, dt = Bt.pop(), je.functionsDefined[dt] = {
                      data: at,
                      i: nt
                    };
                  else if (Mt === 45)
                    if (rt)
                      rt = !1, Dt = nt;
                    else {
                      if (wt = kt.pop(), !wt) {
                        (0, t.warn)("TT: ENDF bad stack"), je.hintsValid = !1;
                        return;
                      }
                      dt = Ue.pop(), at = wt.data, nt = wt.i, je.functionsStackDeltas[dt] = Bt.length - wt.stackTop;
                    }
                  else if (Mt === 137)
                    (rt || St) && ((0, t.warn)("TT: nested IDEFs not allowed"), We = !0), rt = !0, jt = nt;
                  else if (Mt === 88)
                    ++tt;
                  else if (Mt === 27)
                    St = tt;
                  else if (Mt === 89)
                    St === tt && (St = 0), --tt;
                  else if (Mt === 28 && !rt && !St) {
                    const Wt = Bt.at(-1);
                    Wt > 0 && (nt += Wt - 1);
                  }
                  if (!rt && !St) {
                    let Wt = 0;
                    for (Mt <= 142 ? Wt = ve[Mt] : Mt >= 192 && Mt <= 223 ? Wt = -1 : Mt >= 224 && (Wt = -2), Mt >= 113 && Mt <= 117 && (Tt = Bt.pop(), isNaN(Tt) || (Wt = -Tt * 2)); Wt < 0 && Bt.length > 0; )
                      Bt.pop(), Wt++;
                    for (; Wt > 0; )
                      Bt.push(NaN), Wt--;
                  }
                }
                je.tooComplexToFollowFunctions = We;
                const Pt = [at];
                nt > at.length && Pt.push(new Uint8Array(nt - at.length)), jt > Dt && ((0, t.warn)("TT: complementing a missing function tail"), Pt.push(new Uint8Array([34, 45]))), it(Ve, Pt);
              }
              function Ge(Ve, je) {
                if (!Ve.tooComplexToFollowFunctions) {
                  if (Ve.functionsDefined.length > je) {
                    (0, t.warn)("TT: more functions defined than expected"), Ve.hintsValid = !1;
                    return;
                  }
                  for (let at = 0, nt = Ve.functionsUsed.length; at < nt; at++) {
                    if (at > je) {
                      (0, t.warn)("TT: invalid function id: " + at), Ve.hintsValid = !1;
                      return;
                    }
                    if (Ve.functionsUsed[at] && !Ve.functionsDefined[at]) {
                      (0, t.warn)("TT: undefined function: " + at), Ve.hintsValid = !1;
                      return;
                    }
                  }
                }
              }
              function it(Ve, je) {
                if (je.length > 1) {
                  let at = 0, nt, ft;
                  for (nt = 0, ft = je.length; nt < ft; nt++)
                    at += je[nt].length;
                  at = at + 3 & -4;
                  const Tt = new Uint8Array(at);
                  let yt = 0;
                  for (nt = 0, ft = je.length; nt < ft; nt++)
                    Tt.set(je[nt], yt), yt += je[nt].length;
                  Ve.data = Tt, Ve.length = at;
                }
              }
              function Me(Ve, je, at, nt) {
                const ft = {
                  functionsDefined: [],
                  functionsUsed: [],
                  functionsStackDeltas: [],
                  tooComplexToFollowFunctions: !1,
                  hintsValid: !0
                };
                if (Ve && Ne(Ve, ft), je && Ne(je, ft), Ve && Ge(ft, nt), at && at.length & 1) {
                  const Tt = new Uint8Array(at.length + 1);
                  Tt.set(at.data), at.data = Tt;
                }
                return ft.hintsValid;
              }
              H = new w.Stream(new Uint8Array(H.getBytes()));
              let Ie, Ee;
              if (P(H)) {
                const Ve = Fe(H, this.name);
                Ie = Ve.header, Ee = Ve.tables;
              } else
                Ie = pe(H), Ee = fe(H, Ie.numTables);
              let st, Qe;
              const ct = !Ee["CFF "];
              if (ct) {
                if (!Ee.loca)
                  throw new t.FormatError('Required "loca" table is not found');
                Ee.glyf || ((0, t.warn)('Required "glyf" table is not found -- trying to recover.'), Ee.glyf = {
                  tag: "glyf",
                  data: new Uint8Array(0)
                }), this.isOpenType = !1;
              } else {
                const Ve = ie.composite && ((ie.cidToGidMap || []).length > 0 || !(ie.cMap instanceof i.IdentityCMap));
                if (Ie.version === "OTTO" && !Ve || !Ee.head || !Ee.hhea || !Ee.maxp || !Ee.post)
                  return Qe = new w.Stream(Ee["CFF "].data), st = new m.CFFFont(Qe, ie), X(ie), this.convert(I, st, ie);
                delete Ee.glyf, delete Ee.loca, delete Ee.fpgm, delete Ee.prep, delete Ee["cvt "], this.isOpenType = !0;
              }
              if (!Ee.maxp)
                throw new t.FormatError('Required "maxp" table is not found');
              H.pos = (H.start || 0) + Ee.maxp.offset;
              const xt = H.getInt32(), Je = H.getUint16();
              if (ie.scaleFactors && ie.scaleFactors.length === Je && ct) {
                const {
                  scaleFactors: Ve
                } = ie, je = x(Ee.head.data[50], Ee.head.data[51]), at = new n.GlyfTable({
                  glyfTable: Ee.glyf.data,
                  isGlyphLocationsLong: je,
                  locaTable: Ee.loca.data,
                  numGlyphs: Je
                });
                at.scale(Ve);
                const {
                  glyf: nt,
                  loca: ft,
                  isLocationLong: Tt
                } = at.write();
                Ee.glyf.data = nt, Ee.loca.data = ft, Tt !== !!je && (Ee.head.data[50] = 0, Ee.head.data[51] = Tt ? 1 : 0);
                const yt = Ee.hmtx.data;
                for (let dt = 0; dt < Je; dt++) {
                  const wt = 4 * dt, Dt = Math.round(Ve[dt] * x(yt[wt], yt[wt + 1]));
                  yt[wt] = Dt >> 8 & 255, yt[wt + 1] = Dt & 255;
                  const jt = Math.round(Ve[dt] * D(yt[wt + 2], yt[wt + 3]));
                  f(yt, wt + 2, jt);
                }
              }
              let mt = Je + 1, _t = !0;
              mt > 65535 && (_t = !1, mt = Je, (0, t.warn)("Not enough space in glyfs to duplicate first glyph."));
              let Xe = 0, Ct = 0;
              xt >= 65536 && Ee.maxp.length >= 22 && (H.pos += 8, H.getUint16() > 2 && (Ee.maxp.data[14] = 0, Ee.maxp.data[15] = 2), H.pos += 4, Xe = H.getUint16(), H.pos += 4, Ct = H.getUint16()), Ee.maxp.data[4] = mt >> 8, Ee.maxp.data[5] = mt & 255;
              const bt = Me(Ee.fpgm, Ee.prep, Ee["cvt "], Xe);
              if (bt || (delete Ee.fpgm, delete Ee.prep, delete Ee["cvt "]), Ce(H, Ee.hhea, Ee.hmtx, Ee.head, mt, _t), !Ee.head)
                throw new t.FormatError('Required "head" table is not found');
              ye(Ee.head, Je, ct ? Ee.loca.length : 0);
              let Pe = /* @__PURE__ */ Object.create(null);
              if (ct) {
                const Ve = x(Ee.head.data[50], Ee.head.data[51]), je = De(Ee.loca, Ee.glyf, Je, Ve, bt, _t, Ct);
                Pe = je.missingGlyphs, xt >= 65536 && Ee.maxp.length >= 22 && (Ee.maxp.data[26] = je.maxSizeOfInstructions >> 8, Ee.maxp.data[27] = je.maxSizeOfInstructions & 255);
              }
              if (!Ee.hhea)
                throw new t.FormatError('Required "hhea" table is not found');
              Ee.hhea.data[10] === 0 && Ee.hhea.data[11] === 0 && (Ee.hhea.data[10] = 255, Ee.hhea.data[11] = 255);
              const qe = {
                unitsPerEm: x(Ee.head.data[18], Ee.head.data[19]),
                yMax: x(Ee.head.data[42], Ee.head.data[43]),
                yMin: D(Ee.head.data[38], Ee.head.data[39]),
                ascent: D(Ee.hhea.data[4], Ee.hhea.data[5]),
                descent: D(Ee.hhea.data[6], Ee.hhea.data[7]),
                lineGap: D(Ee.hhea.data[8], Ee.hhea.data[9])
              };
              this.ascent = qe.ascent / qe.unitsPerEm, this.descent = qe.descent / qe.unitsPerEm, this.lineGap = qe.lineGap / qe.unitsPerEm, this.cssFontInfo && this.cssFontInfo.lineHeight ? (this.lineHeight = this.cssFontInfo.metrics.lineHeight, this.lineGap = this.cssFontInfo.metrics.lineGap) : this.lineHeight = this.ascent - this.descent + this.lineGap, Ee.post && Ae(Ee.post, ie, Je), Ee.post = {
                tag: "post",
                data: Q(ie)
              };
              const ot = [];
              function lt(Ve) {
                return !Pe[Ve];
              }
              if (ie.composite) {
                const Ve = ie.cidToGidMap || [], je = Ve.length === 0;
                ie.cMap.forEach(function(at, nt) {
                  if (typeof nt == "string" && (nt = L(at, nt, !0)), nt > 65535)
                    throw new t.FormatError("Max size of CID is 65,535");
                  let ft = -1;
                  je ? ft = nt : Ve[nt] !== void 0 && (ft = Ve[nt]), ft >= 0 && ft < Je && lt(ft) && (ot[at] = ft);
                });
              } else {
                const Ve = Se(Ee.cmap, H, this.isSymbolicFont, ie.hasEncoding), je = Ve.platformId, at = Ve.encodingId, nt = Ve.mappings, ft = nt.length;
                let Tt = [], yt = !1;
                if (ie.hasEncoding && (ie.baseEncodingName === "MacRomanEncoding" || ie.baseEncodingName === "WinAnsiEncoding") && (Tt = (0, y.getEncoding)(ie.baseEncodingName)), ie.hasEncoding && !this.isSymbolicFont && (je === 3 && at === 1 || je === 1 && at === 0)) {
                  const dt = (0, e.getGlyphsUnicode)();
                  for (let wt = 0; wt < 256; wt++) {
                    let Dt;
                    if (this.differences[wt] !== void 0 ? Dt = this.differences[wt] : Tt.length && Tt[wt] !== "" ? Dt = Tt[wt] : Dt = y.StandardEncoding[wt], !Dt)
                      continue;
                    const jt = (0, v.recoverGlyphName)(Dt, dt);
                    let Bt;
                    if (je === 3 && at === 1 ? Bt = dt[jt] : je === 1 && at === 0 && (Bt = y.MacRomanEncoding.indexOf(jt)), Bt === void 0) {
                      if (!ie.glyphNames && ie.hasIncludedToUnicodeMap && !(this.toUnicode instanceof d.IdentityToUnicodeMap)) {
                        const kt = this.toUnicode.get(wt);
                        kt && (Bt = kt.codePointAt(0));
                      }
                      if (Bt === void 0)
                        continue;
                    }
                    for (let kt = 0; kt < ft; ++kt)
                      if (nt[kt].charCode === Bt) {
                        ot[wt] = nt[kt].glyphId;
                        break;
                      }
                  }
                } else if (je === 0) {
                  for (let dt = 0; dt < ft; ++dt)
                    ot[nt[dt].charCode] = nt[dt].glyphId;
                  yt = !0;
                } else
                  for (let dt = 0; dt < ft; ++dt) {
                    let wt = nt[dt].charCode;
                    je === 3 && wt >= 61440 && wt <= 61695 && (wt &= 255), ot[wt] = nt[dt].glyphId;
                  }
                if (ie.glyphNames && (Tt.length || this.differences.length))
                  for (let dt = 0; dt < 256; ++dt) {
                    if (!yt && ot[dt] !== void 0)
                      continue;
                    const wt = this.differences[dt] || Tt[dt];
                    if (!wt)
                      continue;
                    const Dt = ie.glyphNames.indexOf(wt);
                    Dt > 0 && lt(Dt) && (ot[dt] = Dt);
                  }
              }
              ot.length === 0 && (ot[0] = 0);
              let Ut = mt - 1;
              if (_t || (Ut = 0), !ie.cssFontInfo) {
                const Ve = K(ot, lt, Ut, this.toUnicode);
                this.toFontChar = Ve.toFontChar, Ee.cmap = {
                  tag: "cmap",
                  data: se(Ve.charCodeToGlyphId, Ve.toUnicodeExtraMap, mt)
                }, (!Ee["OS/2"] || !q(Ee["OS/2"], H)) && (Ee["OS/2"] = {
                  tag: "OS/2",
                  data: N(ie, Ve.charCodeToGlyphId, qe)
                });
              }
              if (!ct)
                try {
                  Qe = new w.Stream(Ee["CFF "].data), st = new a.CFFParser(Qe, ie, v.SEAC_ANALYSIS_ENABLED).parse(), st.duplicateFirstGlyph();
                  const je = new a.CFFCompiler(st);
                  Ee["CFF "].data = je.compile();
                } catch {
                  (0, t.warn)("Failed to compile font " + ie.loadedName);
                }
              if (!Ee.name)
                Ee.name = {
                  tag: "name",
                  data: te(this.name)
                };
              else {
                const Ve = Te(Ee.name);
                Ee.name.data = te(I, Ve), this.psName = Ve[0][6] || null;
              }
              const Nt = new l.OpenTypeFileBuilder(Ie.version);
              for (const Ve in Ee)
                Nt.addTable(Ve, Ee[Ve].data);
              return Nt.toArray();
            }
            convert(I, H, ie) {
              ie.fixedPitch = !1, ie.builtInEncoding && B(ie, ie.builtInEncoding);
              let ue = 1;
              H instanceof m.CFFFont && (ue = H.numGlyphs - 1);
              const fe = H.getGlyphMapping(ie);
              let de = null, pe = fe, xe = null;
              ie.cssFontInfo || (de = K(fe, H.hasGlyphId.bind(H), ue, this.toUnicode), this.toFontChar = de.toFontChar, pe = de.charCodeToGlyphId, xe = de.toUnicodeExtraMap);
              const Fe = H.numGlyphs;
              function Se(Ae, Te) {
                let ve = null;
                for (const Ne in Ae)
                  Te === Ae[Ne] && (ve || (ve = []), ve.push(Ne | 0));
                return ve;
              }
              function Ce(Ae, Te) {
                for (const ve in Ae)
                  if (Te === Ae[ve])
                    return ve | 0;
                return de.charCodeToGlyphId[de.nextAvailableFontCharCode] = Te, de.nextAvailableFontCharCode++;
              }
              const ke = H.seacs;
              if (de && v.SEAC_ANALYSIS_ENABLED && ke && ke.length) {
                const Ae = ie.fontMatrix || t.FONT_IDENTITY_MATRIX, Te = H.getCharset(), ve = /* @__PURE__ */ Object.create(null);
                for (let Ne in ke) {
                  Ne |= 0;
                  const Ge = ke[Ne], it = y.StandardEncoding[Ge[2]], Me = y.StandardEncoding[Ge[3]], Ie = Te.indexOf(it), Ee = Te.indexOf(Me);
                  if (Ie < 0 || Ee < 0)
                    continue;
                  const st = {
                    x: Ge[0] * Ae[0] + Ge[1] * Ae[2] + Ae[4],
                    y: Ge[0] * Ae[1] + Ge[1] * Ae[3] + Ae[5]
                  }, Qe = Se(fe, Ne);
                  if (Qe)
                    for (let ct = 0, xt = Qe.length; ct < xt; ct++) {
                      const Je = Qe[ct], mt = de.charCodeToGlyphId, _t = Ce(mt, Ie), Xe = Ce(mt, Ee);
                      ve[Je] = {
                        baseFontCharCode: _t,
                        accentFontCharCode: Xe,
                        accentOffset: st
                      };
                    }
                }
                ie.seacMap = ve;
              }
              const ye = 1 / (ie.fontMatrix || t.FONT_IDENTITY_MATRIX)[0], De = new l.OpenTypeFileBuilder("OTTO");
              return De.addTable("CFF ", H.data), De.addTable("OS/2", N(ie, pe)), De.addTable("cmap", se(pe, xe, Fe)), De.addTable("head", "\0\0\0\0\0\0\0\0\0\0_<õ\0\0" + C(ye) + "\0\0\0\0\v~'\0\0\0\0\v~'\0\0" + C(ie.descent) + "ÿ" + C(ie.ascent) + S(ie.italicAngle ? 2 : 0) + "\0\0\0\0\0\0\0"), De.addTable("hhea", "\0\0\0" + C(ie.ascent) + C(ie.descent) + "\0\0ÿÿ\0\0\0\0\0\0" + C(ie.capHeight) + C(Math.tan(ie.italicAngle) * ie.xHeight) + "\0\0\0\0\0\0\0\0\0\0\0\0" + S(Fe)), De.addTable("hmtx", function() {
                const Te = H.charstrings, ve = H.cff ? H.cff.widths : null;
                let Ne = "\0\0\0\0";
                for (let Ge = 1, it = Fe; Ge < it; Ge++) {
                  let Me = 0;
                  if (Te) {
                    const Ie = Te[Ge - 1];
                    Me = "width" in Ie ? Ie.width : 0;
                  } else
                    ve && (Me = Math.ceil(ve[Ge] || 0));
                  Ne += S(Me) + S(0);
                }
                return Ne;
              }()), De.addTable("maxp", "\0\0P\0" + S(Fe)), De.addTable("name", te(I)), De.addTable("post", Q(ie)), De.toArray();
            }
            get spaceWidth() {
              const I = ["space", "minus", "one", "i", "I"];
              let H;
              for (let ie = 0, ue = I.length; ie < ue; ie++) {
                const fe = I[ie];
                if (fe in this.widths) {
                  H = this.widths[fe];
                  break;
                }
                const pe = (0, e.getGlyphsUnicode)()[fe];
                let xe = 0;
                if (this.composite && this.cMap.contains(pe) && (xe = this.cMap.lookup(pe), typeof xe == "string" && (xe = L(pe, xe))), !xe && this.toUnicode && (xe = this.toUnicode.charCodeOf(pe)), xe <= 0 && (xe = pe), H = this.widths[xe], H)
                  break;
              }
              return H = H || this.defaultWidth, (0, t.shadow)(this, "spaceWidth", H);
            }
            _charToGlyph(I, H = !1) {
              let ie, ue, fe, de = I;
              this.cMap && this.cMap.contains(I) && (de = this.cMap.lookup(I), typeof de == "string" && (de = L(I, de))), ue = this.widths[de], typeof ue != "number" && (ue = this.defaultWidth);
              const pe = this.vmetrics && this.vmetrics[de];
              let xe = this.toUnicode.get(I) || I;
              typeof xe == "number" && (xe = String.fromCharCode(xe));
              let Fe = this.toFontChar[I] !== void 0;
              if (ie = this.toFontChar[I] || I, this.missingFile) {
                const ye = this.differences[I] || this.defaultEncoding[I];
                (ye === ".notdef" || ye === "") && this.type === "Type1" && (ie = 32), ie = (0, h.mapSpecialUnicodeValues)(ie);
              }
              this.isType3Font && (fe = ie);
              let Se = null;
              if (this.seacMap && this.seacMap[I]) {
                Fe = !0;
                const ye = this.seacMap[I];
                ie = ye.baseFontCharCode, Se = {
                  fontChar: String.fromCodePoint(ye.accentFontCharCode),
                  offset: ye.accentOffset
                };
              }
              let Ce = "";
              typeof ie == "number" && (ie <= 1114111 ? Ce = String.fromCodePoint(ie) : (0, t.warn)(`charToGlyph - invalid fontCharCode: ${ie}`));
              let ke = this._glyphCache[I];
              return (!ke || !ke.matchesForCache(I, Ce, xe, Se, ue, pe, fe, H, Fe)) && (ke = new k(I, Ce, xe, Se, ue, pe, fe, H, Fe), this._glyphCache[I] = ke), ke;
            }
            charsToGlyphs(I) {
              let H = this._charsCache[I];
              if (H)
                return H;
              if (H = [], this.cMap) {
                const ie = /* @__PURE__ */ Object.create(null), ue = I.length;
                let fe = 0;
                for (; fe < ue; ) {
                  this.cMap.readCharCode(I, fe, ie);
                  const {
                    charcode: de,
                    length: pe
                  } = ie;
                  fe += pe;
                  const xe = this._charToGlyph(de, pe === 1 && I.charCodeAt(fe - 1) === 32);
                  H.push(xe);
                }
              } else
                for (let ie = 0, ue = I.length; ie < ue; ++ie) {
                  const fe = I.charCodeAt(ie), de = this._charToGlyph(fe, fe === 32);
                  H.push(de);
                }
              return this._charsCache[I] = H;
            }
            getCharPositions(I) {
              const H = [];
              if (this.cMap) {
                const ie = /* @__PURE__ */ Object.create(null);
                let ue = 0;
                for (; ue < I.length; ) {
                  this.cMap.readCharCode(I, ue, ie);
                  const fe = ie.length;
                  H.push([ue, ue + fe]), ue += fe;
                }
              } else
                for (let ie = 0, ue = I.length; ie < ue; ++ie)
                  H.push([ie, ie + 1]);
              return H;
            }
            get glyphCacheValues() {
              return Object.values(this._glyphCache);
            }
            encodeString(I) {
              const H = [], ie = [], ue = () => H.length % 2 === 1, fe = this.toUnicode instanceof d.IdentityToUnicodeMap ? (de) => this.toUnicode.charCodeOf(de) : (de) => this.toUnicode.charCodeOf(String.fromCodePoint(de));
              for (let de = 0, pe = I.length; de < pe; de++) {
                const xe = I.codePointAt(de);
                if (xe > 55295 && (xe < 57344 || xe > 65533) && de++, this.toUnicode) {
                  const Fe = fe(xe);
                  if (Fe !== -1) {
                    ue() && (H.push(ie.join("")), ie.length = 0);
                    const Se = this.cMap ? this.cMap.getCharCodeLength(Fe) : 1;
                    for (let Ce = Se - 1; Ce >= 0; Ce--)
                      ie.push(String.fromCharCode(Fe >> 8 * Ce & 255));
                    continue;
                  }
                }
                ue() || (H.push(ie.join("")), ie.length = 0), ie.push(String.fromCodePoint(xe));
              }
              return H.push(ie.join("")), H;
            }
          }
          o.Font = oe;
          class ee {
            constructor(I) {
              this.error = I, this.loadedName = "g_font_error", this.missingFile = !0;
            }
            charsToGlyphs() {
              return [];
            }
            encodeString(I) {
              return [I];
            }
            exportData(I = !1) {
              return {
                error: this.error
              };
            }
          }
          o.ErrorFont = ee;
        },
        /* 35 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.CFFTopDict = o.CFFStrings = o.CFFStandardStrings = o.CFFPrivateDict = o.CFFParser = o.CFFIndex = o.CFFHeader = o.CFFFDSelect = o.CFFCompiler = o.CFFCharset = o.CFF = void 0;
          var t = F(2), a = F(36), v = F(37);
          const h = 10, e = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"];
          o.CFFStandardStrings = e;
          const y = 391, c = [null, {
            id: "hstem",
            min: 2,
            stackClearing: !0,
            stem: !0
          }, null, {
            id: "vstem",
            min: 2,
            stackClearing: !0,
            stem: !0
          }, {
            id: "vmoveto",
            min: 1,
            stackClearing: !0
          }, {
            id: "rlineto",
            min: 2,
            resetStack: !0
          }, {
            id: "hlineto",
            min: 1,
            resetStack: !0
          }, {
            id: "vlineto",
            min: 1,
            resetStack: !0
          }, {
            id: "rrcurveto",
            min: 6,
            resetStack: !0
          }, null, {
            id: "callsubr",
            min: 1,
            undefStack: !0
          }, {
            id: "return",
            min: 0,
            undefStack: !0
          }, null, null, {
            id: "endchar",
            min: 0,
            stackClearing: !0
          }, null, null, null, {
            id: "hstemhm",
            min: 2,
            stackClearing: !0,
            stem: !0
          }, {
            id: "hintmask",
            min: 0,
            stackClearing: !0
          }, {
            id: "cntrmask",
            min: 0,
            stackClearing: !0
          }, {
            id: "rmoveto",
            min: 2,
            stackClearing: !0
          }, {
            id: "hmoveto",
            min: 1,
            stackClearing: !0
          }, {
            id: "vstemhm",
            min: 2,
            stackClearing: !0,
            stem: !0
          }, {
            id: "rcurveline",
            min: 8,
            resetStack: !0
          }, {
            id: "rlinecurve",
            min: 8,
            resetStack: !0
          }, {
            id: "vvcurveto",
            min: 4,
            resetStack: !0
          }, {
            id: "hhcurveto",
            min: 4,
            resetStack: !0
          }, null, {
            id: "callgsubr",
            min: 1,
            undefStack: !0
          }, {
            id: "vhcurveto",
            min: 4,
            resetStack: !0
          }, {
            id: "hvcurveto",
            min: 4,
            resetStack: !0
          }], d = [null, null, null, {
            id: "and",
            min: 2,
            stackDelta: -1
          }, {
            id: "or",
            min: 2,
            stackDelta: -1
          }, {
            id: "not",
            min: 1,
            stackDelta: 0
          }, null, null, null, {
            id: "abs",
            min: 1,
            stackDelta: 0
          }, {
            id: "add",
            min: 2,
            stackDelta: -1,
            stackFn(k, x) {
              k[x - 2] = k[x - 2] + k[x - 1];
            }
          }, {
            id: "sub",
            min: 2,
            stackDelta: -1,
            stackFn(k, x) {
              k[x - 2] = k[x - 2] - k[x - 1];
            }
          }, {
            id: "div",
            min: 2,
            stackDelta: -1,
            stackFn(k, x) {
              k[x - 2] = k[x - 2] / k[x - 1];
            }
          }, null, {
            id: "neg",
            min: 1,
            stackDelta: 0,
            stackFn(k, x) {
              k[x - 1] = -k[x - 1];
            }
          }, {
            id: "eq",
            min: 2,
            stackDelta: -1
          }, null, null, {
            id: "drop",
            min: 1,
            stackDelta: -1
          }, null, {
            id: "put",
            min: 2,
            stackDelta: -2
          }, {
            id: "get",
            min: 1,
            stackDelta: 0
          }, {
            id: "ifelse",
            min: 4,
            stackDelta: -3
          }, {
            id: "random",
            min: 0,
            stackDelta: 1
          }, {
            id: "mul",
            min: 2,
            stackDelta: -1,
            stackFn(k, x) {
              k[x - 2] = k[x - 2] * k[x - 1];
            }
          }, null, {
            id: "sqrt",
            min: 1,
            stackDelta: 0
          }, {
            id: "dup",
            min: 1,
            stackDelta: 1
          }, {
            id: "exch",
            min: 2,
            stackDelta: 0
          }, {
            id: "index",
            min: 2,
            stackDelta: 0
          }, {
            id: "roll",
            min: 3,
            stackDelta: -2
          }, null, null, null, {
            id: "hflex",
            min: 7,
            resetStack: !0
          }, {
            id: "flex",
            min: 13,
            resetStack: !0
          }, {
            id: "hflex1",
            min: 9,
            resetStack: !0
          }, {
            id: "flex1",
            min: 11,
            resetStack: !0
          }];
          class m {
            constructor(x, f, D) {
              this.bytes = x.getBytes(), this.properties = f, this.seacAnalysisEnabled = !!D;
            }
            parse() {
              const x = this.properties, f = new p();
              this.cff = f;
              const D = this.parseHeader(), _ = this.parseIndex(D.endPos), S = this.parseIndex(_.endPos), C = this.parseIndex(S.endPos), T = this.parseIndex(C.endPos), P = this.parseDict(S.obj.get(0)), M = this.createDict(w, P, f.strings);
              f.header = D.obj, f.names = this.parseNameIndex(_.obj), f.strings = this.parseStringIndex(C.obj), f.topDict = M, f.globalSubrIndex = T.obj, this.parsePrivateDict(f.topDict), f.isCIDFont = M.hasName("ROS");
              const G = M.getByName("CharStrings"), Z = this.parseIndex(G).obj, $ = M.getByName("FontMatrix");
              $ && (x.fontMatrix = $);
              const z = M.getByName("FontBBox");
              z && (x.ascent = Math.max(z[3], z[1]), x.descent = Math.min(z[1], z[3]), x.ascentScaled = !0);
              let V, L;
              if (f.isCIDFont) {
                const ne = this.parseIndex(M.getByName("FDArray")).obj;
                for (let se = 0, q = ne.count; se < q; ++se) {
                  const N = ne.get(se), Q = this.createDict(w, this.parseDict(N), f.strings);
                  this.parsePrivateDict(Q), f.fdArray.push(Q);
                }
                L = null, V = this.parseCharsets(M.getByName("charset"), Z.count, f.strings, !0), f.fdSelect = this.parseFDSelect(M.getByName("FDSelect"), Z.count);
              } else
                V = this.parseCharsets(M.getByName("charset"), Z.count, f.strings, !1), L = this.parseEncoding(M.getByName("Encoding"), x, f.strings, V.charset);
              f.charset = V, f.encoding = L;
              const K = this.parseCharStrings({
                charStrings: Z,
                localSubrIndex: M.privateDict.subrsIndex,
                globalSubrIndex: T.obj,
                fdSelect: f.fdSelect,
                fdArray: f.fdArray,
                privateDict: M.privateDict
              });
              return f.charStrings = K.charStrings, f.seacs = K.seacs, f.widths = K.widths, f;
            }
            parseHeader() {
              let x = this.bytes;
              const f = x.length;
              let D = 0;
              for (; D < f && x[D] !== 1; )
                ++D;
              if (D >= f)
                throw new t.FormatError("Invalid CFF header");
              D !== 0 && ((0, t.info)("cff data is shifted"), x = x.subarray(D), this.bytes = x);
              const _ = x[0], S = x[1], C = x[2], T = x[3];
              return {
                obj: new g(_, S, C, T),
                endPos: C
              };
            }
            parseDict(x) {
              let f = 0;
              function D() {
                let P = x[f++];
                return P === 30 ? _() : P === 28 ? (P = x[f++], P = (P << 24 | x[f++] << 16) >> 16, P) : P === 29 ? (P = x[f++], P = P << 8 | x[f++], P = P << 8 | x[f++], P = P << 8 | x[f++], P) : P >= 32 && P <= 246 ? P - 139 : P >= 247 && P <= 250 ? (P - 247) * 256 + x[f++] + 108 : P >= 251 && P <= 254 ? -((P - 251) * 256) - x[f++] - 108 : ((0, t.warn)('CFFParser_parseDict: "' + P + '" is a reserved command.'), NaN);
              }
              function _() {
                let P = "";
                const G = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"], Z = x.length;
                for (; f < Z; ) {
                  const $ = x[f++], z = $ >> 4, V = $ & 15;
                  if (z === 15 || (P += G[z], V === 15))
                    break;
                  P += G[V];
                }
                return parseFloat(P);
              }
              let S = [];
              const C = [];
              f = 0;
              const T = x.length;
              for (; f < T; ) {
                let P = x[f];
                P <= 21 ? (P === 12 && (P = P << 8 | x[++f]), C.push([P, S]), S = [], ++f) : S.push(D());
              }
              return C;
            }
            parseIndex(x) {
              const f = new i(), D = this.bytes, _ = D[x++] << 8 | D[x++], S = [];
              let C = x, T, P;
              if (_ !== 0) {
                const M = D[x++], G = x + (_ + 1) * M - 1;
                for (T = 0, P = _ + 1; T < P; ++T) {
                  let Z = 0;
                  for (let $ = 0; $ < M; ++$)
                    Z <<= 8, Z += D[x++];
                  S.push(G + Z);
                }
                C = S[_];
              }
              for (T = 0, P = S.length - 1; T < P; ++T) {
                const M = S[T], G = S[T + 1];
                f.add(D.subarray(M, G));
              }
              return {
                obj: f,
                endPos: C
              };
            }
            parseNameIndex(x) {
              const f = [];
              for (let D = 0, _ = x.count; D < _; ++D) {
                const S = x.get(D);
                f.push((0, t.bytesToString)(S));
              }
              return f;
            }
            parseStringIndex(x) {
              const f = new n();
              for (let D = 0, _ = x.count; D < _; ++D) {
                const S = x.get(D);
                f.add((0, t.bytesToString)(S));
              }
              return f;
            }
            createDict(x, f, D) {
              const _ = new x(D);
              for (let S = 0, C = f.length; S < C; ++S) {
                const T = f[S], P = T[0], M = T[1];
                _.setByKey(P, M);
              }
              return _;
            }
            parseCharString(x, f, D, _) {
              if (!f || x.callDepth > h)
                return !1;
              let S = x.stackSize;
              const C = x.stack, T = f.length;
              for (let P = 0; P < T; ) {
                const M = f[P++];
                let G = null;
                if (M === 12) {
                  const Z = f[P++];
                  Z === 0 ? (f[P - 2] = 139, f[P - 1] = 22, S = 0) : G = d[Z];
                } else if (M === 28)
                  C[S] = (f[P] << 24 | f[P + 1] << 16) >> 16, P += 2, S++;
                else if (M === 14) {
                  if (S >= 4 && (S -= 4, this.seacAnalysisEnabled))
                    return x.seac = C.slice(S, S + 4), !1;
                  G = c[M];
                } else if (M >= 32 && M <= 246)
                  C[S] = M - 139, S++;
                else if (M >= 247 && M <= 254)
                  C[S] = M < 251 ? (M - 247 << 8) + f[P] + 108 : -(M - 251 << 8) - f[P] - 108, P++, S++;
                else if (M === 255)
                  C[S] = (f[P] << 24 | f[P + 1] << 16 | f[P + 2] << 8 | f[P + 3]) / 65536, P += 4, S++;
                else if (M === 19 || M === 20)
                  x.hints += S >> 1, P += x.hints + 7 >> 3, S %= 2, G = c[M];
                else if (M === 10 || M === 29) {
                  let Z;
                  if (M === 10 ? Z = D : Z = _, !Z)
                    return G = c[M], (0, t.warn)("Missing subrsIndex for " + G.id), !1;
                  let $ = 32768;
                  Z.count < 1240 ? $ = 107 : Z.count < 33900 && ($ = 1131);
                  const z = C[--S] + $;
                  if (z < 0 || z >= Z.count || isNaN(z))
                    return G = c[M], (0, t.warn)("Out of bounds subrIndex for " + G.id), !1;
                  if (x.stackSize = S, x.callDepth++, !this.parseCharString(x, Z.get(z), D, _))
                    return !1;
                  x.callDepth--, S = x.stackSize;
                  continue;
                } else {
                  if (M === 11)
                    return x.stackSize = S, !0;
                  M === 0 && P === f.length ? (f[P - 1] = 14, G = c[14]) : G = c[M];
                }
                if (G) {
                  if (G.stem && (x.hints += S >> 1, M === 3 || M === 23 ? x.hasVStems = !0 : x.hasVStems && (M === 1 || M === 18) && ((0, t.warn)("CFF stem hints are in wrong order"), f[P - 1] = M === 1 ? 3 : 23)), "min" in G && !x.undefStack && S < G.min)
                    return (0, t.warn)("Not enough parameters for " + G.id + "; actual: " + S + ", expected: " + G.min), S === 0 ? (f[P - 1] = 14, !0) : !1;
                  x.firstStackClearing && G.stackClearing && (x.firstStackClearing = !1, S -= G.min, S >= 2 && G.stem ? S %= 2 : S > 1 && (0, t.warn)("Found too many parameters for stack-clearing command"), S > 0 && (x.width = C[S - 1])), "stackDelta" in G ? ("stackFn" in G && G.stackFn(C, S), S += G.stackDelta) : G.stackClearing ? S = 0 : G.resetStack ? (S = 0, x.undefStack = !1) : G.undefStack && (S = 0, x.undefStack = !0, x.firstStackClearing = !1);
                }
              }
              return x.stackSize = S, !0;
            }
            parseCharStrings({
              charStrings: x,
              localSubrIndex: f,
              globalSubrIndex: D,
              fdSelect: _,
              fdArray: S,
              privateDict: C
            }) {
              const T = [], P = [], M = x.count;
              for (let G = 0; G < M; G++) {
                const Z = x.get(G), $ = {
                  callDepth: 0,
                  stackSize: 0,
                  stack: [],
                  undefStack: !0,
                  hints: 0,
                  firstStackClearing: !0,
                  seac: null,
                  width: null,
                  hasVStems: !1
                };
                let z = !0, V = null, L = C;
                if (_ && S.length) {
                  const K = _.getFDIndex(G);
                  K === -1 && ((0, t.warn)("Glyph index is not in fd select."), z = !1), K >= S.length && ((0, t.warn)("Invalid fd index for glyph index."), z = !1), z && (L = S[K].privateDict, V = L.subrsIndex);
                } else
                  f && (V = f);
                if (z && (z = this.parseCharString($, Z, V, D)), $.width !== null) {
                  const K = L.getByName("nominalWidthX");
                  P[G] = K + $.width;
                } else {
                  const K = L.getByName("defaultWidthX");
                  P[G] = K;
                }
                $.seac !== null && (T[G] = $.seac), z || x.set(G, new Uint8Array([14]));
              }
              return {
                charStrings: x,
                seacs: T,
                widths: P
              };
            }
            emptyPrivateDictionary(x) {
              const f = this.createDict(b, [], x.strings);
              x.setByKey(18, [0, 0]), x.privateDict = f;
            }
            parsePrivateDict(x) {
              if (!x.hasName("Private")) {
                this.emptyPrivateDictionary(x);
                return;
              }
              const f = x.getByName("Private");
              if (!Array.isArray(f) || f.length !== 2) {
                x.removeByName("Private");
                return;
              }
              const D = f[0], _ = f[1];
              if (D === 0 || _ >= this.bytes.length) {
                this.emptyPrivateDictionary(x);
                return;
              }
              const S = _ + D, C = this.bytes.subarray(_, S), T = this.parseDict(C), P = this.createDict(b, T, x.strings);
              if (x.privateDict = P, !P.getByName("Subrs"))
                return;
              const M = P.getByName("Subrs"), G = _ + M;
              if (M === 0 || G >= this.bytes.length) {
                this.emptyPrivateDictionary(x);
                return;
              }
              const Z = this.parseIndex(G);
              P.subrsIndex = Z.obj;
            }
            parseCharsets(x, f, D, _) {
              if (x === 0)
                return new Y(!0, A.ISO_ADOBE, a.ISOAdobeCharset);
              if (x === 1)
                return new Y(!0, A.EXPERT, a.ExpertCharset);
              if (x === 2)
                return new Y(!0, A.EXPERT_SUBSET, a.ExpertSubsetCharset);
              const S = this.bytes, C = x, T = S[x++], P = [_ ? 0 : ".notdef"];
              let M, G, Z;
              switch (f -= 1, T) {
                case 0:
                  for (Z = 0; Z < f; Z++)
                    M = S[x++] << 8 | S[x++], P.push(_ ? M : D.get(M));
                  break;
                case 1:
                  for (; P.length <= f; )
                    for (M = S[x++] << 8 | S[x++], G = S[x++], Z = 0; Z <= G; Z++)
                      P.push(_ ? M++ : D.get(M++));
                  break;
                case 2:
                  for (; P.length <= f; )
                    for (M = S[x++] << 8 | S[x++], G = S[x++] << 8 | S[x++], Z = 0; Z <= G; Z++)
                      P.push(_ ? M++ : D.get(M++));
                  break;
                default:
                  throw new t.FormatError("Unknown charset format");
              }
              const $ = x, z = S.subarray(C, $);
              return new Y(!1, T, P, z);
            }
            parseEncoding(x, f, D, _) {
              const S = /* @__PURE__ */ Object.create(null), C = this.bytes;
              let T = !1, P, M, G, Z = null;
              function $() {
                const z = C[x++];
                for (M = 0; M < z; M++) {
                  const V = C[x++], L = (C[x++] << 8) + (C[x++] & 255);
                  S[V] = _.indexOf(D.get(L));
                }
              }
              if (x === 0 || x === 1) {
                T = !0, P = x;
                const z = x ? v.ExpertEncoding : v.StandardEncoding;
                for (M = 0, G = _.length; M < G; M++) {
                  const V = z.indexOf(_[M]);
                  V !== -1 && (S[V] = M);
                }
              } else {
                const z = x;
                switch (P = C[x++], P & 127) {
                  case 0:
                    const L = C[x++];
                    for (M = 1; M <= L; M++)
                      S[C[x++]] = M;
                    break;
                  case 1:
                    const K = C[x++];
                    let ne = 1;
                    for (M = 0; M < K; M++) {
                      const se = C[x++], q = C[x++];
                      for (let N = se; N <= se + q; N++)
                        S[N] = ne++;
                    }
                    break;
                  default:
                    throw new t.FormatError(`Unknown encoding format: ${P} in CFF`);
                }
                const V = x;
                P & 128 && (C[z] &= 127, $()), Z = C.subarray(z, V);
              }
              return P &= 127, new j(T, P, S, Z);
            }
            parseFDSelect(x, f) {
              const D = this.bytes, _ = D[x++], S = [];
              let C;
              switch (_) {
                case 0:
                  for (C = 0; C < f; ++C) {
                    const P = D[x++];
                    S.push(P);
                  }
                  break;
                case 3:
                  const T = D[x++] << 8 | D[x++];
                  for (C = 0; C < T; ++C) {
                    let P = D[x++] << 8 | D[x++];
                    C === 0 && P !== 0 && ((0, t.warn)("parseFDSelect: The first range must have a first GID of 0 -- trying to recover."), P = 0);
                    const M = D[x++], G = D[x] << 8 | D[x + 1];
                    for (let Z = P; Z < G; ++Z)
                      S.push(M);
                  }
                  x += 2;
                  break;
                default:
                  throw new t.FormatError(`parseFDSelect: Unknown format "${_}".`);
              }
              if (S.length !== f)
                throw new t.FormatError("parseFDSelect: Invalid font data.");
              return new X(_, S);
            }
          }
          o.CFFParser = m;
          class p {
            constructor() {
              this.header = null, this.names = [], this.topDict = null, this.strings = new n(), this.globalSubrIndex = null, this.encoding = null, this.charset = null, this.charStrings = null, this.fdArray = [], this.fdSelect = null, this.isCIDFont = !1;
            }
            duplicateFirstGlyph() {
              if (this.charStrings.count >= 65535) {
                (0, t.warn)("Not enough space in charstrings to duplicate first glyph.");
                return;
              }
              const x = this.charStrings.get(0);
              this.charStrings.add(x), this.isCIDFont && this.fdSelect.fdSelect.push(this.fdSelect.fdSelect[0]);
            }
            hasGlyphId(x) {
              return x < 0 || x >= this.charStrings.count ? !1 : this.charStrings.get(x).length > 0;
            }
          }
          o.CFF = p;
          class g {
            constructor(x, f, D, _) {
              this.major = x, this.minor = f, this.hdrSize = D, this.offSize = _;
            }
          }
          o.CFFHeader = g;
          class n {
            constructor() {
              this.strings = [];
            }
            get(x) {
              return x >= 0 && x <= y - 1 ? e[x] : x - y <= this.strings.length ? this.strings[x - y] : e[0];
            }
            getSID(x) {
              let f = e.indexOf(x);
              return f !== -1 ? f : (f = this.strings.indexOf(x), f !== -1 ? f + y : -1);
            }
            add(x) {
              this.strings.push(x);
            }
            get count() {
              return this.strings.length;
            }
          }
          o.CFFStrings = n;
          class i {
            constructor() {
              this.objects = [], this.length = 0;
            }
            add(x) {
              this.length += x.length, this.objects.push(x);
            }
            set(x, f) {
              this.length += f.length - this.objects[x].length, this.objects[x] = f;
            }
            get(x) {
              return this.objects[x];
            }
            get count() {
              return this.objects.length;
            }
          }
          o.CFFIndex = i;
          class l {
            constructor(x, f) {
              this.keyToNameMap = x.keyToNameMap, this.nameToKeyMap = x.nameToKeyMap, this.defaults = x.defaults, this.types = x.types, this.opcodes = x.opcodes, this.order = x.order, this.strings = f, this.values = /* @__PURE__ */ Object.create(null);
            }
            setByKey(x, f) {
              if (!(x in this.keyToNameMap))
                return !1;
              const D = f.length;
              if (D === 0)
                return !0;
              for (let S = 0; S < D; S++)
                if (isNaN(f[S]))
                  return (0, t.warn)('Invalid CFFDict value: "' + f + '" for key "' + x + '".'), !0;
              const _ = this.types[x];
              return (_ === "num" || _ === "sid" || _ === "offset") && (f = f[0]), this.values[x] = f, !0;
            }
            setByName(x, f) {
              if (!(x in this.nameToKeyMap))
                throw new t.FormatError(`Invalid dictionary name "${x}"`);
              this.values[this.nameToKeyMap[x]] = f;
            }
            hasName(x) {
              return this.nameToKeyMap[x] in this.values;
            }
            getByName(x) {
              if (!(x in this.nameToKeyMap))
                throw new t.FormatError(`Invalid dictionary name ${x}"`);
              const f = this.nameToKeyMap[x];
              return f in this.values ? this.values[f] : this.defaults[f];
            }
            removeByName(x) {
              delete this.values[this.nameToKeyMap[x]];
            }
            static createTables(x) {
              const f = {
                keyToNameMap: {},
                nameToKeyMap: {},
                defaults: {},
                types: {},
                opcodes: {},
                order: []
              };
              for (let D = 0, _ = x.length; D < _; ++D) {
                const S = x[D], C = Array.isArray(S[0]) ? (S[0][0] << 8) + S[0][1] : S[0];
                f.keyToNameMap[C] = S[1], f.nameToKeyMap[S[1]] = C, f.types[C] = S[2], f.defaults[C] = S[3], f.opcodes[C] = Array.isArray(S[0]) ? S[0] : [S[0]], f.order.push(C);
              }
              return f;
            }
          }
          const u = [[[12, 30], "ROS", ["sid", "sid", "num"], null], [[12, 20], "SyntheticBase", "num", null], [0, "version", "sid", null], [1, "Notice", "sid", null], [[12, 0], "Copyright", "sid", null], [2, "FullName", "sid", null], [3, "FamilyName", "sid", null], [4, "Weight", "sid", null], [[12, 1], "isFixedPitch", "num", 0], [[12, 2], "ItalicAngle", "num", 0], [[12, 3], "UnderlinePosition", "num", -100], [[12, 4], "UnderlineThickness", "num", 50], [[12, 5], "PaintType", "num", 0], [[12, 6], "CharstringType", "num", 2], [[12, 7], "FontMatrix", ["num", "num", "num", "num", "num", "num"], [1e-3, 0, 0, 1e-3, 0, 0]], [13, "UniqueID", "num", null], [5, "FontBBox", ["num", "num", "num", "num"], [0, 0, 0, 0]], [[12, 8], "StrokeWidth", "num", 0], [14, "XUID", "array", null], [15, "charset", "offset", 0], [16, "Encoding", "offset", 0], [17, "CharStrings", "offset", 0], [18, "Private", ["offset", "offset"], null], [[12, 21], "PostScript", "sid", null], [[12, 22], "BaseFontName", "sid", null], [[12, 23], "BaseFontBlend", "delta", null], [[12, 31], "CIDFontVersion", "num", 0], [[12, 32], "CIDFontRevision", "num", 0], [[12, 33], "CIDFontType", "num", 0], [[12, 34], "CIDCount", "num", 8720], [[12, 35], "UIDBase", "num", null], [[12, 37], "FDSelect", "offset", null], [[12, 36], "FDArray", "offset", null], [[12, 38], "FontName", "sid", null]];
          class w extends l {
            static get tables() {
              return (0, t.shadow)(this, "tables", this.createTables(u));
            }
            constructor(x) {
              super(w.tables, x), this.privateDict = null;
            }
          }
          o.CFFTopDict = w;
          const O = [[6, "BlueValues", "delta", null], [7, "OtherBlues", "delta", null], [8, "FamilyBlues", "delta", null], [9, "FamilyOtherBlues", "delta", null], [[12, 9], "BlueScale", "num", 0.039625], [[12, 10], "BlueShift", "num", 7], [[12, 11], "BlueFuzz", "num", 1], [10, "StdHW", "num", null], [11, "StdVW", "num", null], [[12, 12], "StemSnapH", "delta", null], [[12, 13], "StemSnapV", "delta", null], [[12, 14], "ForceBold", "num", 0], [[12, 17], "LanguageGroup", "num", 0], [[12, 18], "ExpansionFactor", "num", 0.06], [[12, 19], "initialRandomSeed", "num", 0], [20, "defaultWidthX", "num", 0], [21, "nominalWidthX", "num", 0], [19, "Subrs", "offset", null]];
          class b extends l {
            static get tables() {
              return (0, t.shadow)(this, "tables", this.createTables(O));
            }
            constructor(x) {
              super(b.tables, x), this.subrsIndex = null;
            }
          }
          o.CFFPrivateDict = b;
          const A = {
            ISO_ADOBE: 0,
            EXPERT: 1,
            EXPERT_SUBSET: 2
          };
          class Y {
            constructor(x, f, D, _) {
              this.predefined = x, this.format = f, this.charset = D, this.raw = _;
            }
          }
          o.CFFCharset = Y;
          class j {
            constructor(x, f, D, _) {
              this.predefined = x, this.format = f, this.encoding = D, this.raw = _;
            }
          }
          class X {
            constructor(x, f) {
              this.format = x, this.fdSelect = f;
            }
            getFDIndex(x) {
              return x < 0 || x >= this.fdSelect.length ? -1 : this.fdSelect[x];
            }
          }
          o.CFFFDSelect = X;
          class B {
            constructor() {
              this.offsets = /* @__PURE__ */ Object.create(null);
            }
            isTracking(x) {
              return x in this.offsets;
            }
            track(x, f) {
              if (x in this.offsets)
                throw new t.FormatError(`Already tracking location of ${x}`);
              this.offsets[x] = f;
            }
            offset(x) {
              for (const f in this.offsets)
                this.offsets[f] += x;
            }
            setEntryLocation(x, f, D) {
              if (!(x in this.offsets))
                throw new t.FormatError(`Not tracking location of ${x}`);
              const _ = D.data, S = this.offsets[x], C = 5;
              for (let T = 0, P = f.length; T < P; ++T) {
                const M = T * C + S, G = M + 1, Z = M + 2, $ = M + 3, z = M + 4;
                if (_[M] !== 29 || _[G] !== 0 || _[Z] !== 0 || _[$] !== 0 || _[z] !== 0)
                  throw new t.FormatError("writing to an offset that is not empty");
                const V = f[T];
                _[M] = 29, _[G] = V >> 24 & 255, _[Z] = V >> 16 & 255, _[$] = V >> 8 & 255, _[z] = V & 255;
              }
            }
          }
          class U {
            constructor(x) {
              this.cff = x;
            }
            compile() {
              const x = this.cff, f = {
                data: [],
                length: 0,
                add($) {
                  this.data = this.data.concat($), this.length = this.data.length;
                }
              }, D = this.compileHeader(x.header);
              f.add(D);
              const _ = this.compileNameIndex(x.names);
              if (f.add(_), x.isCIDFont && x.topDict.hasName("FontMatrix")) {
                const $ = x.topDict.getByName("FontMatrix");
                x.topDict.removeByName("FontMatrix");
                for (let z = 0, V = x.fdArray.length; z < V; z++) {
                  const L = x.fdArray[z];
                  let K = $.slice(0);
                  L.hasName("FontMatrix") && (K = t.Util.transform(K, L.getByName("FontMatrix"))), L.setByName("FontMatrix", K);
                }
              }
              const S = x.topDict.getByName("XUID");
              S && S.length > 16 && x.topDict.removeByName("XUID"), x.topDict.setByName("charset", 0);
              let C = this.compileTopDicts([x.topDict], f.length, x.isCIDFont);
              f.add(C.output);
              const T = C.trackers[0], P = this.compileStringIndex(x.strings.strings);
              f.add(P);
              const M = this.compileIndex(x.globalSubrIndex);
              if (f.add(M), x.encoding && x.topDict.hasName("Encoding"))
                if (x.encoding.predefined)
                  T.setEntryLocation("Encoding", [x.encoding.format], f);
                else {
                  const $ = this.compileEncoding(x.encoding);
                  T.setEntryLocation("Encoding", [f.length], f), f.add($);
                }
              const G = this.compileCharset(x.charset, x.charStrings.count, x.strings, x.isCIDFont);
              T.setEntryLocation("charset", [f.length], f), f.add(G);
              const Z = this.compileCharStrings(x.charStrings);
              if (T.setEntryLocation("CharStrings", [f.length], f), f.add(Z), x.isCIDFont) {
                T.setEntryLocation("FDSelect", [f.length], f);
                const $ = this.compileFDSelect(x.fdSelect);
                f.add($), C = this.compileTopDicts(x.fdArray, f.length, !0), T.setEntryLocation("FDArray", [f.length], f), f.add(C.output);
                const z = C.trackers;
                this.compilePrivateDicts(x.fdArray, z, f);
              }
              return this.compilePrivateDicts([x.topDict], [T], f), f.add([0]), f.data;
            }
            encodeNumber(x) {
              return Number.isInteger(x) ? this.encodeInteger(x) : this.encodeFloat(x);
            }
            static get EncodeFloatRegExp() {
              return (0, t.shadow)(this, "EncodeFloatRegExp", /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/);
            }
            encodeFloat(x) {
              let f = x.toString();
              const D = U.EncodeFloatRegExp.exec(f);
              if (D) {
                const P = parseFloat("1e" + ((D[2] ? +D[2] : 0) + D[1].length));
                f = (Math.round(x * P) / P).toString();
              }
              let _ = "", S, C;
              for (S = 0, C = f.length; S < C; ++S) {
                const P = f[S];
                P === "e" ? _ += f[++S] === "-" ? "c" : "b" : P === "." ? _ += "a" : P === "-" ? _ += "e" : _ += P;
              }
              _ += _.length & 1 ? "f" : "ff";
              const T = [30];
              for (S = 0, C = _.length; S < C; S += 2)
                T.push(parseInt(_.substring(S, S + 2), 16));
              return T;
            }
            encodeInteger(x) {
              let f;
              return x >= -107 && x <= 107 ? f = [x + 139] : x >= 108 && x <= 1131 ? (x -= 108, f = [(x >> 8) + 247, x & 255]) : x >= -1131 && x <= -108 ? (x = -x - 108, f = [(x >> 8) + 251, x & 255]) : x >= -32768 && x <= 32767 ? f = [28, x >> 8 & 255, x & 255] : f = [29, x >> 24 & 255, x >> 16 & 255, x >> 8 & 255, x & 255], f;
            }
            compileHeader(x) {
              return [x.major, x.minor, 4, x.offSize];
            }
            compileNameIndex(x) {
              const f = new i();
              for (let D = 0, _ = x.length; D < _; ++D) {
                const S = x[D], C = Math.min(S.length, 127);
                let T = new Array(C);
                for (let P = 0; P < C; P++) {
                  let M = S[P];
                  (M < "!" || M > "~" || M === "[" || M === "]" || M === "(" || M === ")" || M === "{" || M === "}" || M === "<" || M === ">" || M === "/" || M === "%") && (M = "_"), T[P] = M;
                }
                T = T.join(""), T === "" && (T = "Bad_Font_Name"), f.add((0, t.stringToBytes)(T));
              }
              return this.compileIndex(f);
            }
            compileTopDicts(x, f, D) {
              const _ = [];
              let S = new i();
              for (let C = 0, T = x.length; C < T; ++C) {
                const P = x[C];
                D && (P.removeByName("CIDFontVersion"), P.removeByName("CIDFontRevision"), P.removeByName("CIDFontType"), P.removeByName("CIDCount"), P.removeByName("UIDBase"));
                const M = new B(), G = this.compileDict(P, M);
                _.push(M), S.add(G), M.offset(f);
              }
              return S = this.compileIndex(S, _), {
                trackers: _,
                output: S
              };
            }
            compilePrivateDicts(x, f, D) {
              for (let _ = 0, S = x.length; _ < S; ++_) {
                const C = x[_], T = C.privateDict;
                if (!T || !C.hasName("Private"))
                  throw new t.FormatError("There must be a private dictionary.");
                const P = new B(), M = this.compileDict(T, P);
                let G = D.length;
                if (P.offset(G), M.length || (G = 0), f[_].setEntryLocation("Private", [M.length, G], D), D.add(M), T.subrsIndex && T.hasName("Subrs")) {
                  const Z = this.compileIndex(T.subrsIndex);
                  P.setEntryLocation("Subrs", [M.length], D), D.add(Z);
                }
              }
            }
            compileDict(x, f) {
              const D = [];
              for (const _ of x.order) {
                if (!(_ in x.values))
                  continue;
                let S = x.values[_], C = x.types[_];
                if (Array.isArray(C) || (C = [C]), Array.isArray(S) || (S = [S]), S.length !== 0) {
                  for (let T = 0, P = C.length; T < P; ++T) {
                    const M = C[T], G = S[T];
                    switch (M) {
                      case "num":
                      case "sid":
                        D.push(...this.encodeNumber(G));
                        break;
                      case "offset":
                        const Z = x.keyToNameMap[_];
                        f.isTracking(Z) || f.track(Z, D.length), D.push(29, 0, 0, 0, 0);
                        break;
                      case "array":
                      case "delta":
                        D.push(...this.encodeNumber(G));
                        for (let $ = 1, z = S.length; $ < z; ++$)
                          D.push(...this.encodeNumber(S[$]));
                        break;
                      default:
                        throw new t.FormatError(`Unknown data type of ${M}`);
                    }
                  }
                  D.push(...x.opcodes[_]);
                }
              }
              return D;
            }
            compileStringIndex(x) {
              const f = new i();
              for (let D = 0, _ = x.length; D < _; ++D)
                f.add((0, t.stringToBytes)(x[D]));
              return this.compileIndex(f);
            }
            compileGlobalSubrIndex() {
              const x = this.cff.globalSubrIndex;
              this.out.writeByteArray(this.compileIndex(x));
            }
            compileCharStrings(x) {
              const f = new i();
              for (let D = 0; D < x.count; D++) {
                const _ = x.get(D);
                if (_.length === 0) {
                  f.add(new Uint8Array([139, 14]));
                  continue;
                }
                f.add(_);
              }
              return this.compileIndex(f);
            }
            compileCharset(x, f, D, _) {
              let S;
              const C = f - 1;
              if (_)
                S = new Uint8Array([2, 0, 0, C >> 8 & 255, C & 255]);
              else {
                const T = 1 + C * 2;
                S = new Uint8Array(T), S[0] = 0;
                let P = 0;
                const M = x.charset.length;
                let G = !1;
                for (let Z = 1; Z < S.length; Z += 2) {
                  let $ = 0;
                  if (P < M) {
                    const z = x.charset[P++];
                    $ = D.getSID(z), $ === -1 && ($ = 0, G || (G = !0, (0, t.warn)(`Couldn't find ${z} in CFF strings`)));
                  }
                  S[Z] = $ >> 8 & 255, S[Z + 1] = $ & 255;
                }
              }
              return this.compileTypedArray(S);
            }
            compileEncoding(x) {
              return this.compileTypedArray(x.raw);
            }
            compileFDSelect(x) {
              const f = x.format;
              let D, _;
              switch (f) {
                case 0:
                  for (D = new Uint8Array(1 + x.fdSelect.length), D[0] = f, _ = 0; _ < x.fdSelect.length; _++)
                    D[_ + 1] = x.fdSelect[_];
                  break;
                case 3:
                  const S = 0;
                  let C = x.fdSelect[0];
                  const T = [f, 0, 0, S >> 8 & 255, S & 255, C];
                  for (_ = 1; _ < x.fdSelect.length; _++) {
                    const M = x.fdSelect[_];
                    M !== C && (T.push(_ >> 8 & 255, _ & 255, M), C = M);
                  }
                  const P = (T.length - 3) / 3;
                  T[1] = P >> 8 & 255, T[2] = P & 255, T.push(_ >> 8 & 255, _ & 255), D = new Uint8Array(T);
                  break;
              }
              return this.compileTypedArray(D);
            }
            compileTypedArray(x) {
              const f = [];
              for (let D = 0, _ = x.length; D < _; ++D)
                f[D] = x[D];
              return f;
            }
            compileIndex(x, f = []) {
              const D = x.objects, _ = D.length;
              if (_ === 0)
                return [0, 0];
              const S = [_ >> 8 & 255, _ & 255];
              let C = 1, T;
              for (T = 0; T < _; ++T)
                C += D[T].length;
              let P;
              C < 256 ? P = 1 : C < 65536 ? P = 2 : C < 16777216 ? P = 3 : P = 4, S.push(P);
              let M = 1;
              for (T = 0; T < _ + 1; T++)
                P === 1 ? S.push(M & 255) : P === 2 ? S.push(M >> 8 & 255, M & 255) : P === 3 ? S.push(M >> 16 & 255, M >> 8 & 255, M & 255) : S.push(M >>> 24 & 255, M >> 16 & 255, M >> 8 & 255, M & 255), D[T] && (M += D[T].length);
              for (T = 0; T < _; T++) {
                f[T] && f[T].offset(S.length);
                for (let G = 0, Z = D[T].length; G < Z; G++)
                  S.push(D[T][G]);
              }
              return S;
            }
          }
          o.CFFCompiler = U;
        },
        /* 36 */
        /***/
        (J, o) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.ISOAdobeCharset = o.ExpertSubsetCharset = o.ExpertCharset = void 0;
          const F = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron"];
          o.ISOAdobeCharset = F;
          const t = [".notdef", "space", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
          o.ExpertCharset = t;
          const a = [".notdef", "space", "dollaroldstyle", "dollarsuperior", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "hyphensuperior", "colonmonetary", "onefitted", "rupiah", "centoldstyle", "figuredash", "hypheninferior", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior"];
          o.ExpertSubsetCharset = a;
        },
        /* 37 */
        /***/
        (J, o) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.ZapfDingbatsEncoding = o.WinAnsiEncoding = o.SymbolSetEncoding = o.StandardEncoding = o.MacRomanEncoding = o.ExpertEncoding = void 0, o.getEncoding = c;
          const F = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
          o.ExpertEncoding = F;
          const t = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "centoldstyle", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "", "threequartersemdash", "", "questionsmall", "", "", "", "", "Ethsmall", "", "", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "", "", "", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hypheninferior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "asuperior", "centsuperior", "", "", "", "", "Aacutesmall", "Agravesmall", "Acircumflexsmall", "Adieresissmall", "Atildesmall", "Aringsmall", "Ccedillasmall", "Eacutesmall", "Egravesmall", "Ecircumflexsmall", "Edieresissmall", "Iacutesmall", "Igravesmall", "Icircumflexsmall", "Idieresissmall", "Ntildesmall", "Oacutesmall", "Ogravesmall", "Ocircumflexsmall", "Odieresissmall", "Otildesmall", "Uacutesmall", "Ugravesmall", "Ucircumflexsmall", "Udieresissmall", "", "eightsuperior", "fourinferior", "threeinferior", "sixinferior", "eightinferior", "seveninferior", "Scaronsmall", "", "centinferior", "twoinferior", "", "Dieresissmall", "", "Caronsmall", "osuperior", "fiveinferior", "", "commainferior", "periodinferior", "Yacutesmall", "", "dollarinferior", "", "", "Thornsmall", "", "nineinferior", "zeroinferior", "Zcaronsmall", "AEsmall", "Oslashsmall", "questiondownsmall", "oneinferior", "Lslashsmall", "", "", "", "", "", "", "Cedillasmall", "", "", "", "", "", "OEsmall", "figuredash", "hyphensuperior", "", "", "", "", "exclamdownsmall", "", "Ydieresissmall", "", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "ninesuperior", "zerosuperior", "", "esuperior", "rsuperior", "tsuperior", "", "", "isuperior", "ssuperior", "dsuperior", "", "", "", "", "", "lsuperior", "Ogoneksmall", "Brevesmall", "Macronsmall", "bsuperior", "nsuperior", "msuperior", "commasuperior", "periodsuperior", "Dotaccentsmall", "Ringsmall", "", "", "", ""], a = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "space", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron"];
          o.MacRomanEncoding = a;
          const v = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls", "", "", "", ""];
          o.StandardEncoding = v;
          const h = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "bullet", "Euro", "bullet", "quotesinglbase", "florin", "quotedblbase", "ellipsis", "dagger", "daggerdbl", "circumflex", "perthousand", "Scaron", "guilsinglleft", "OE", "bullet", "Zcaron", "bullet", "bullet", "quoteleft", "quoteright", "quotedblleft", "quotedblright", "bullet", "endash", "emdash", "tilde", "trademark", "scaron", "guilsinglright", "oe", "bullet", "zcaron", "Ydieresis", "space", "exclamdown", "cent", "sterling", "currency", "yen", "brokenbar", "section", "dieresis", "copyright", "ordfeminine", "guillemotleft", "logicalnot", "hyphen", "registered", "macron", "degree", "plusminus", "twosuperior", "threesuperior", "acute", "mu", "paragraph", "periodcentered", "cedilla", "onesuperior", "ordmasculine", "guillemotright", "onequarter", "onehalf", "threequarters", "questiondown", "Agrave", "Aacute", "Acircumflex", "Atilde", "Adieresis", "Aring", "AE", "Ccedilla", "Egrave", "Eacute", "Ecircumflex", "Edieresis", "Igrave", "Iacute", "Icircumflex", "Idieresis", "Eth", "Ntilde", "Ograve", "Oacute", "Ocircumflex", "Otilde", "Odieresis", "multiply", "Oslash", "Ugrave", "Uacute", "Ucircumflex", "Udieresis", "Yacute", "Thorn", "germandbls", "agrave", "aacute", "acircumflex", "atilde", "adieresis", "aring", "ae", "ccedilla", "egrave", "eacute", "ecircumflex", "edieresis", "igrave", "iacute", "icircumflex", "idieresis", "eth", "ntilde", "ograve", "oacute", "ocircumflex", "otilde", "odieresis", "divide", "oslash", "ugrave", "uacute", "ucircumflex", "udieresis", "yacute", "thorn", "ydieresis"];
          o.WinAnsiEncoding = h;
          const e = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "universal", "numbersign", "existential", "percent", "ampersand", "suchthat", "parenleft", "parenright", "asteriskmath", "plus", "comma", "minus", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "congruent", "Alpha", "Beta", "Chi", "Delta", "Epsilon", "Phi", "Gamma", "Eta", "Iota", "theta1", "Kappa", "Lambda", "Mu", "Nu", "Omicron", "Pi", "Theta", "Rho", "Sigma", "Tau", "Upsilon", "sigma1", "Omega", "Xi", "Psi", "Zeta", "bracketleft", "therefore", "bracketright", "perpendicular", "underscore", "radicalex", "alpha", "beta", "chi", "delta", "epsilon", "phi", "gamma", "eta", "iota", "phi1", "kappa", "lambda", "mu", "nu", "omicron", "pi", "theta", "rho", "sigma", "tau", "upsilon", "omega1", "omega", "xi", "psi", "zeta", "braceleft", "bar", "braceright", "similar", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Euro", "Upsilon1", "minute", "lessequal", "fraction", "infinity", "florin", "club", "diamond", "heart", "spade", "arrowboth", "arrowleft", "arrowup", "arrowright", "arrowdown", "degree", "plusminus", "second", "greaterequal", "multiply", "proportional", "partialdiff", "bullet", "divide", "notequal", "equivalence", "approxequal", "ellipsis", "arrowvertex", "arrowhorizex", "carriagereturn", "aleph", "Ifraktur", "Rfraktur", "weierstrass", "circlemultiply", "circleplus", "emptyset", "intersection", "union", "propersuperset", "reflexsuperset", "notsubset", "propersubset", "reflexsubset", "element", "notelement", "angle", "gradient", "registerserif", "copyrightserif", "trademarkserif", "product", "radical", "dotmath", "logicalnot", "logicaland", "logicalor", "arrowdblboth", "arrowdblleft", "arrowdblup", "arrowdblright", "arrowdbldown", "lozenge", "angleleft", "registersans", "copyrightsans", "trademarksans", "summation", "parenlefttp", "parenleftex", "parenleftbt", "bracketlefttp", "bracketleftex", "bracketleftbt", "bracelefttp", "braceleftmid", "braceleftbt", "braceex", "", "angleright", "integral", "integraltp", "integralex", "integralbt", "parenrighttp", "parenrightex", "parenrightbt", "bracketrighttp", "bracketrightex", "bracketrightbt", "bracerighttp", "bracerightmid", "bracerightbt", ""];
          o.SymbolSetEncoding = e;
          const y = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "a1", "a2", "a202", "a3", "a4", "a5", "a119", "a118", "a117", "a11", "a12", "a13", "a14", "a15", "a16", "a105", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24", "a25", "a26", "a27", "a28", "a6", "a7", "a8", "a9", "a10", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36", "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48", "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60", "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72", "a73", "a74", "a203", "a75", "a204", "a76", "a77", "a78", "a79", "a81", "a82", "a83", "a84", "a97", "a98", "a99", "a100", "", "a89", "a90", "a93", "a94", "a91", "a92", "a205", "a85", "a206", "a86", "a87", "a88", "a95", "a96", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "a101", "a102", "a103", "a104", "a106", "a107", "a108", "a112", "a111", "a110", "a109", "a120", "a121", "a122", "a123", "a124", "a125", "a126", "a127", "a128", "a129", "a130", "a131", "a132", "a133", "a134", "a135", "a136", "a137", "a138", "a139", "a140", "a141", "a142", "a143", "a144", "a145", "a146", "a147", "a148", "a149", "a150", "a151", "a152", "a153", "a154", "a155", "a156", "a157", "a158", "a159", "a160", "a161", "a163", "a164", "a196", "a165", "a192", "a166", "a167", "a168", "a169", "a170", "a171", "a172", "a173", "a162", "a174", "a175", "a176", "a177", "a178", "a179", "a193", "a180", "a199", "a181", "a200", "a182", "", "a201", "a183", "a184", "a197", "a185", "a194", "a198", "a186", "a195", "a187", "a188", "a189", "a190", "a191", ""];
          o.ZapfDingbatsEncoding = y;
          function c(d) {
            switch (d) {
              case "WinAnsiEncoding":
                return h;
              case "StandardEncoding":
                return v;
              case "MacRomanEncoding":
                return a;
              case "SymbolSetEncoding":
                return e;
              case "ZapfDingbatsEncoding":
                return y;
              case "ExpertEncoding":
                return F;
              case "MacExpertEncoding":
                return t;
              default:
                return null;
            }
          }
        },
        /* 38 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.SEAC_ANALYSIS_ENABLED = o.MacStandardGlyphOrdering = o.FontFlags = void 0, o.getFontType = d, o.normalizeFontName = g, o.recoverGlyphName = m, o.type1FontGlyphMapping = p;
          var t = F(2), a = F(37), v = F(39), h = F(40);
          const e = !0;
          o.SEAC_ANALYSIS_ENABLED = e;
          const y = {
            FixedPitch: 1,
            Serif: 2,
            Symbolic: 4,
            Script: 8,
            Nonsymbolic: 32,
            Italic: 64,
            AllCap: 65536,
            SmallCap: 131072,
            ForceBold: 262144
          };
          o.FontFlags = y;
          const c = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];
          o.MacStandardGlyphOrdering = c;
          function d(n, i, l = !1) {
            switch (n) {
              case "Type1":
                return l ? t.FontType.TYPE1STANDARD : i === "Type1C" ? t.FontType.TYPE1C : t.FontType.TYPE1;
              case "CIDFontType0":
                return i === "CIDFontType0C" ? t.FontType.CIDFONTTYPE0C : t.FontType.CIDFONTTYPE0;
              case "OpenType":
                return t.FontType.OPENTYPE;
              case "TrueType":
                return t.FontType.TRUETYPE;
              case "CIDFontType2":
                return t.FontType.CIDFONTTYPE2;
              case "MMType1":
                return t.FontType.MMTYPE1;
              case "Type0":
                return t.FontType.TYPE0;
              default:
                return t.FontType.UNKNOWN;
            }
          }
          function m(n, i) {
            if (i[n] !== void 0)
              return n;
            const l = (0, h.getUnicodeForGlyph)(n, i);
            if (l !== -1) {
              for (const u in i)
                if (i[u] === l)
                  return u;
            }
            return (0, t.info)("Unable to recover a standard glyph name for: " + n), n;
          }
          function p(n, i, l) {
            const u = /* @__PURE__ */ Object.create(null);
            let w, O, b;
            const A = !!(n.flags & y.Symbolic);
            if (n.isInternalFont)
              for (b = i, O = 0; O < b.length; O++)
                w = l.indexOf(b[O]), w >= 0 ? u[O] = w : u[O] = 0;
            else if (n.baseEncodingName)
              for (b = (0, a.getEncoding)(n.baseEncodingName), O = 0; O < b.length; O++)
                w = l.indexOf(b[O]), w >= 0 ? u[O] = w : u[O] = 0;
            else if (A)
              for (O in i)
                u[O] = i[O];
            else
              for (b = a.StandardEncoding, O = 0; O < b.length; O++)
                w = l.indexOf(b[O]), w >= 0 ? u[O] = w : u[O] = 0;
            const Y = n.differences;
            let j;
            if (Y)
              for (O in Y) {
                const X = Y[O];
                if (w = l.indexOf(X), w === -1) {
                  j || (j = (0, v.getGlyphsUnicode)());
                  const B = m(X, j);
                  B !== X && (w = l.indexOf(B));
                }
                w >= 0 ? u[O] = w : u[O] = 0;
              }
            return u;
          }
          function g(n) {
            return n.replace(/[,_]/g, "-").replace(/\s/g, "");
          }
        },
        /* 39 */
        /***/
        (J, o, F) => {
          F.r(o), F.d(o, {
            /* harmony export */
            getDingbatsGlyphsUnicode: () => (
              /* binding */
              v
            ),
            /* harmony export */
            getGlyphsUnicode: () => (
              /* binding */
              a
            )
            /* harmony export */
          });
          var t = F(6);
          const a = (0, t.getArrayLookupTableFactory)(function() {
            return [
              "A",
              65,
              "AE",
              198,
              "AEacute",
              508,
              "AEmacron",
              482,
              "AEsmall",
              63462,
              "Aacute",
              193,
              "Aacutesmall",
              63457,
              "Abreve",
              258,
              "Abreveacute",
              7854,
              "Abrevecyrillic",
              1232,
              "Abrevedotbelow",
              7862,
              "Abrevegrave",
              7856,
              "Abrevehookabove",
              7858,
              "Abrevetilde",
              7860,
              "Acaron",
              461,
              "Acircle",
              9398,
              "Acircumflex",
              194,
              "Acircumflexacute",
              7844,
              "Acircumflexdotbelow",
              7852,
              "Acircumflexgrave",
              7846,
              "Acircumflexhookabove",
              7848,
              "Acircumflexsmall",
              63458,
              "Acircumflextilde",
              7850,
              "Acute",
              63177,
              "Acutesmall",
              63412,
              "Acyrillic",
              1040,
              "Adblgrave",
              512,
              "Adieresis",
              196,
              "Adieresiscyrillic",
              1234,
              "Adieresismacron",
              478,
              "Adieresissmall",
              63460,
              "Adotbelow",
              7840,
              "Adotmacron",
              480,
              "Agrave",
              192,
              "Agravesmall",
              63456,
              "Ahookabove",
              7842,
              "Aiecyrillic",
              1236,
              "Ainvertedbreve",
              514,
              "Alpha",
              913,
              "Alphatonos",
              902,
              "Amacron",
              256,
              "Amonospace",
              65313,
              "Aogonek",
              260,
              "Aring",
              197,
              "Aringacute",
              506,
              "Aringbelow",
              7680,
              "Aringsmall",
              63461,
              "Asmall",
              63329,
              "Atilde",
              195,
              "Atildesmall",
              63459,
              "Aybarmenian",
              1329,
              "B",
              66,
              "Bcircle",
              9399,
              "Bdotaccent",
              7682,
              "Bdotbelow",
              7684,
              "Becyrillic",
              1041,
              "Benarmenian",
              1330,
              "Beta",
              914,
              "Bhook",
              385,
              "Blinebelow",
              7686,
              "Bmonospace",
              65314,
              "Brevesmall",
              63220,
              "Bsmall",
              63330,
              "Btopbar",
              386,
              "C",
              67,
              "Caarmenian",
              1342,
              "Cacute",
              262,
              "Caron",
              63178,
              "Caronsmall",
              63221,
              "Ccaron",
              268,
              "Ccedilla",
              199,
              "Ccedillaacute",
              7688,
              "Ccedillasmall",
              63463,
              "Ccircle",
              9400,
              "Ccircumflex",
              264,
              "Cdot",
              266,
              "Cdotaccent",
              266,
              "Cedillasmall",
              63416,
              "Chaarmenian",
              1353,
              "Cheabkhasiancyrillic",
              1212,
              "Checyrillic",
              1063,
              "Chedescenderabkhasiancyrillic",
              1214,
              "Chedescendercyrillic",
              1206,
              "Chedieresiscyrillic",
              1268,
              "Cheharmenian",
              1347,
              "Chekhakassiancyrillic",
              1227,
              "Cheverticalstrokecyrillic",
              1208,
              "Chi",
              935,
              "Chook",
              391,
              "Circumflexsmall",
              63222,
              "Cmonospace",
              65315,
              "Coarmenian",
              1361,
              "Csmall",
              63331,
              "D",
              68,
              "DZ",
              497,
              "DZcaron",
              452,
              "Daarmenian",
              1332,
              "Dafrican",
              393,
              "Dcaron",
              270,
              "Dcedilla",
              7696,
              "Dcircle",
              9401,
              "Dcircumflexbelow",
              7698,
              "Dcroat",
              272,
              "Ddotaccent",
              7690,
              "Ddotbelow",
              7692,
              "Decyrillic",
              1044,
              "Deicoptic",
              1006,
              "Delta",
              8710,
              "Deltagreek",
              916,
              "Dhook",
              394,
              "Dieresis",
              63179,
              "DieresisAcute",
              63180,
              "DieresisGrave",
              63181,
              "Dieresissmall",
              63400,
              "Digammagreek",
              988,
              "Djecyrillic",
              1026,
              "Dlinebelow",
              7694,
              "Dmonospace",
              65316,
              "Dotaccentsmall",
              63223,
              "Dslash",
              272,
              "Dsmall",
              63332,
              "Dtopbar",
              395,
              "Dz",
              498,
              "Dzcaron",
              453,
              "Dzeabkhasiancyrillic",
              1248,
              "Dzecyrillic",
              1029,
              "Dzhecyrillic",
              1039,
              "E",
              69,
              "Eacute",
              201,
              "Eacutesmall",
              63465,
              "Ebreve",
              276,
              "Ecaron",
              282,
              "Ecedillabreve",
              7708,
              "Echarmenian",
              1333,
              "Ecircle",
              9402,
              "Ecircumflex",
              202,
              "Ecircumflexacute",
              7870,
              "Ecircumflexbelow",
              7704,
              "Ecircumflexdotbelow",
              7878,
              "Ecircumflexgrave",
              7872,
              "Ecircumflexhookabove",
              7874,
              "Ecircumflexsmall",
              63466,
              "Ecircumflextilde",
              7876,
              "Ecyrillic",
              1028,
              "Edblgrave",
              516,
              "Edieresis",
              203,
              "Edieresissmall",
              63467,
              "Edot",
              278,
              "Edotaccent",
              278,
              "Edotbelow",
              7864,
              "Efcyrillic",
              1060,
              "Egrave",
              200,
              "Egravesmall",
              63464,
              "Eharmenian",
              1335,
              "Ehookabove",
              7866,
              "Eightroman",
              8551,
              "Einvertedbreve",
              518,
              "Eiotifiedcyrillic",
              1124,
              "Elcyrillic",
              1051,
              "Elevenroman",
              8554,
              "Emacron",
              274,
              "Emacronacute",
              7702,
              "Emacrongrave",
              7700,
              "Emcyrillic",
              1052,
              "Emonospace",
              65317,
              "Encyrillic",
              1053,
              "Endescendercyrillic",
              1186,
              "Eng",
              330,
              "Enghecyrillic",
              1188,
              "Enhookcyrillic",
              1223,
              "Eogonek",
              280,
              "Eopen",
              400,
              "Epsilon",
              917,
              "Epsilontonos",
              904,
              "Ercyrillic",
              1056,
              "Ereversed",
              398,
              "Ereversedcyrillic",
              1069,
              "Escyrillic",
              1057,
              "Esdescendercyrillic",
              1194,
              "Esh",
              425,
              "Esmall",
              63333,
              "Eta",
              919,
              "Etarmenian",
              1336,
              "Etatonos",
              905,
              "Eth",
              208,
              "Ethsmall",
              63472,
              "Etilde",
              7868,
              "Etildebelow",
              7706,
              "Euro",
              8364,
              "Ezh",
              439,
              "Ezhcaron",
              494,
              "Ezhreversed",
              440,
              "F",
              70,
              "Fcircle",
              9403,
              "Fdotaccent",
              7710,
              "Feharmenian",
              1366,
              "Feicoptic",
              996,
              "Fhook",
              401,
              "Fitacyrillic",
              1138,
              "Fiveroman",
              8548,
              "Fmonospace",
              65318,
              "Fourroman",
              8547,
              "Fsmall",
              63334,
              "G",
              71,
              "GBsquare",
              13191,
              "Gacute",
              500,
              "Gamma",
              915,
              "Gammaafrican",
              404,
              "Gangiacoptic",
              1002,
              "Gbreve",
              286,
              "Gcaron",
              486,
              "Gcedilla",
              290,
              "Gcircle",
              9404,
              "Gcircumflex",
              284,
              "Gcommaaccent",
              290,
              "Gdot",
              288,
              "Gdotaccent",
              288,
              "Gecyrillic",
              1043,
              "Ghadarmenian",
              1346,
              "Ghemiddlehookcyrillic",
              1172,
              "Ghestrokecyrillic",
              1170,
              "Gheupturncyrillic",
              1168,
              "Ghook",
              403,
              "Gimarmenian",
              1331,
              "Gjecyrillic",
              1027,
              "Gmacron",
              7712,
              "Gmonospace",
              65319,
              "Grave",
              63182,
              "Gravesmall",
              63328,
              "Gsmall",
              63335,
              "Gsmallhook",
              667,
              "Gstroke",
              484,
              "H",
              72,
              "H18533",
              9679,
              "H18543",
              9642,
              "H18551",
              9643,
              "H22073",
              9633,
              "HPsquare",
              13259,
              "Haabkhasiancyrillic",
              1192,
              "Hadescendercyrillic",
              1202,
              "Hardsigncyrillic",
              1066,
              "Hbar",
              294,
              "Hbrevebelow",
              7722,
              "Hcedilla",
              7720,
              "Hcircle",
              9405,
              "Hcircumflex",
              292,
              "Hdieresis",
              7718,
              "Hdotaccent",
              7714,
              "Hdotbelow",
              7716,
              "Hmonospace",
              65320,
              "Hoarmenian",
              1344,
              "Horicoptic",
              1e3,
              "Hsmall",
              63336,
              "Hungarumlaut",
              63183,
              "Hungarumlautsmall",
              63224,
              "Hzsquare",
              13200,
              "I",
              73,
              "IAcyrillic",
              1071,
              "IJ",
              306,
              "IUcyrillic",
              1070,
              "Iacute",
              205,
              "Iacutesmall",
              63469,
              "Ibreve",
              300,
              "Icaron",
              463,
              "Icircle",
              9406,
              "Icircumflex",
              206,
              "Icircumflexsmall",
              63470,
              "Icyrillic",
              1030,
              "Idblgrave",
              520,
              "Idieresis",
              207,
              "Idieresisacute",
              7726,
              "Idieresiscyrillic",
              1252,
              "Idieresissmall",
              63471,
              "Idot",
              304,
              "Idotaccent",
              304,
              "Idotbelow",
              7882,
              "Iebrevecyrillic",
              1238,
              "Iecyrillic",
              1045,
              "Ifraktur",
              8465,
              "Igrave",
              204,
              "Igravesmall",
              63468,
              "Ihookabove",
              7880,
              "Iicyrillic",
              1048,
              "Iinvertedbreve",
              522,
              "Iishortcyrillic",
              1049,
              "Imacron",
              298,
              "Imacroncyrillic",
              1250,
              "Imonospace",
              65321,
              "Iniarmenian",
              1339,
              "Iocyrillic",
              1025,
              "Iogonek",
              302,
              "Iota",
              921,
              "Iotaafrican",
              406,
              "Iotadieresis",
              938,
              "Iotatonos",
              906,
              "Ismall",
              63337,
              "Istroke",
              407,
              "Itilde",
              296,
              "Itildebelow",
              7724,
              "Izhitsacyrillic",
              1140,
              "Izhitsadblgravecyrillic",
              1142,
              "J",
              74,
              "Jaarmenian",
              1345,
              "Jcircle",
              9407,
              "Jcircumflex",
              308,
              "Jecyrillic",
              1032,
              "Jheharmenian",
              1355,
              "Jmonospace",
              65322,
              "Jsmall",
              63338,
              "K",
              75,
              "KBsquare",
              13189,
              "KKsquare",
              13261,
              "Kabashkircyrillic",
              1184,
              "Kacute",
              7728,
              "Kacyrillic",
              1050,
              "Kadescendercyrillic",
              1178,
              "Kahookcyrillic",
              1219,
              "Kappa",
              922,
              "Kastrokecyrillic",
              1182,
              "Kaverticalstrokecyrillic",
              1180,
              "Kcaron",
              488,
              "Kcedilla",
              310,
              "Kcircle",
              9408,
              "Kcommaaccent",
              310,
              "Kdotbelow",
              7730,
              "Keharmenian",
              1364,
              "Kenarmenian",
              1343,
              "Khacyrillic",
              1061,
              "Kheicoptic",
              998,
              "Khook",
              408,
              "Kjecyrillic",
              1036,
              "Klinebelow",
              7732,
              "Kmonospace",
              65323,
              "Koppacyrillic",
              1152,
              "Koppagreek",
              990,
              "Ksicyrillic",
              1134,
              "Ksmall",
              63339,
              "L",
              76,
              "LJ",
              455,
              "LL",
              63167,
              "Lacute",
              313,
              "Lambda",
              923,
              "Lcaron",
              317,
              "Lcedilla",
              315,
              "Lcircle",
              9409,
              "Lcircumflexbelow",
              7740,
              "Lcommaaccent",
              315,
              "Ldot",
              319,
              "Ldotaccent",
              319,
              "Ldotbelow",
              7734,
              "Ldotbelowmacron",
              7736,
              "Liwnarmenian",
              1340,
              "Lj",
              456,
              "Ljecyrillic",
              1033,
              "Llinebelow",
              7738,
              "Lmonospace",
              65324,
              "Lslash",
              321,
              "Lslashsmall",
              63225,
              "Lsmall",
              63340,
              "M",
              77,
              "MBsquare",
              13190,
              "Macron",
              63184,
              "Macronsmall",
              63407,
              "Macute",
              7742,
              "Mcircle",
              9410,
              "Mdotaccent",
              7744,
              "Mdotbelow",
              7746,
              "Menarmenian",
              1348,
              "Mmonospace",
              65325,
              "Msmall",
              63341,
              "Mturned",
              412,
              "Mu",
              924,
              "N",
              78,
              "NJ",
              458,
              "Nacute",
              323,
              "Ncaron",
              327,
              "Ncedilla",
              325,
              "Ncircle",
              9411,
              "Ncircumflexbelow",
              7754,
              "Ncommaaccent",
              325,
              "Ndotaccent",
              7748,
              "Ndotbelow",
              7750,
              "Nhookleft",
              413,
              "Nineroman",
              8552,
              "Nj",
              459,
              "Njecyrillic",
              1034,
              "Nlinebelow",
              7752,
              "Nmonospace",
              65326,
              "Nowarmenian",
              1350,
              "Nsmall",
              63342,
              "Ntilde",
              209,
              "Ntildesmall",
              63473,
              "Nu",
              925,
              "O",
              79,
              "OE",
              338,
              "OEsmall",
              63226,
              "Oacute",
              211,
              "Oacutesmall",
              63475,
              "Obarredcyrillic",
              1256,
              "Obarreddieresiscyrillic",
              1258,
              "Obreve",
              334,
              "Ocaron",
              465,
              "Ocenteredtilde",
              415,
              "Ocircle",
              9412,
              "Ocircumflex",
              212,
              "Ocircumflexacute",
              7888,
              "Ocircumflexdotbelow",
              7896,
              "Ocircumflexgrave",
              7890,
              "Ocircumflexhookabove",
              7892,
              "Ocircumflexsmall",
              63476,
              "Ocircumflextilde",
              7894,
              "Ocyrillic",
              1054,
              "Odblacute",
              336,
              "Odblgrave",
              524,
              "Odieresis",
              214,
              "Odieresiscyrillic",
              1254,
              "Odieresissmall",
              63478,
              "Odotbelow",
              7884,
              "Ogoneksmall",
              63227,
              "Ograve",
              210,
              "Ogravesmall",
              63474,
              "Oharmenian",
              1365,
              "Ohm",
              8486,
              "Ohookabove",
              7886,
              "Ohorn",
              416,
              "Ohornacute",
              7898,
              "Ohorndotbelow",
              7906,
              "Ohorngrave",
              7900,
              "Ohornhookabove",
              7902,
              "Ohorntilde",
              7904,
              "Ohungarumlaut",
              336,
              "Oi",
              418,
              "Oinvertedbreve",
              526,
              "Omacron",
              332,
              "Omacronacute",
              7762,
              "Omacrongrave",
              7760,
              "Omega",
              8486,
              "Omegacyrillic",
              1120,
              "Omegagreek",
              937,
              "Omegaroundcyrillic",
              1146,
              "Omegatitlocyrillic",
              1148,
              "Omegatonos",
              911,
              "Omicron",
              927,
              "Omicrontonos",
              908,
              "Omonospace",
              65327,
              "Oneroman",
              8544,
              "Oogonek",
              490,
              "Oogonekmacron",
              492,
              "Oopen",
              390,
              "Oslash",
              216,
              "Oslashacute",
              510,
              "Oslashsmall",
              63480,
              "Osmall",
              63343,
              "Ostrokeacute",
              510,
              "Otcyrillic",
              1150,
              "Otilde",
              213,
              "Otildeacute",
              7756,
              "Otildedieresis",
              7758,
              "Otildesmall",
              63477,
              "P",
              80,
              "Pacute",
              7764,
              "Pcircle",
              9413,
              "Pdotaccent",
              7766,
              "Pecyrillic",
              1055,
              "Peharmenian",
              1354,
              "Pemiddlehookcyrillic",
              1190,
              "Phi",
              934,
              "Phook",
              420,
              "Pi",
              928,
              "Piwrarmenian",
              1363,
              "Pmonospace",
              65328,
              "Psi",
              936,
              "Psicyrillic",
              1136,
              "Psmall",
              63344,
              "Q",
              81,
              "Qcircle",
              9414,
              "Qmonospace",
              65329,
              "Qsmall",
              63345,
              "R",
              82,
              "Raarmenian",
              1356,
              "Racute",
              340,
              "Rcaron",
              344,
              "Rcedilla",
              342,
              "Rcircle",
              9415,
              "Rcommaaccent",
              342,
              "Rdblgrave",
              528,
              "Rdotaccent",
              7768,
              "Rdotbelow",
              7770,
              "Rdotbelowmacron",
              7772,
              "Reharmenian",
              1360,
              "Rfraktur",
              8476,
              "Rho",
              929,
              "Ringsmall",
              63228,
              "Rinvertedbreve",
              530,
              "Rlinebelow",
              7774,
              "Rmonospace",
              65330,
              "Rsmall",
              63346,
              "Rsmallinverted",
              641,
              "Rsmallinvertedsuperior",
              694,
              "S",
              83,
              "SF010000",
              9484,
              "SF020000",
              9492,
              "SF030000",
              9488,
              "SF040000",
              9496,
              "SF050000",
              9532,
              "SF060000",
              9516,
              "SF070000",
              9524,
              "SF080000",
              9500,
              "SF090000",
              9508,
              "SF100000",
              9472,
              "SF110000",
              9474,
              "SF190000",
              9569,
              "SF200000",
              9570,
              "SF210000",
              9558,
              "SF220000",
              9557,
              "SF230000",
              9571,
              "SF240000",
              9553,
              "SF250000",
              9559,
              "SF260000",
              9565,
              "SF270000",
              9564,
              "SF280000",
              9563,
              "SF360000",
              9566,
              "SF370000",
              9567,
              "SF380000",
              9562,
              "SF390000",
              9556,
              "SF400000",
              9577,
              "SF410000",
              9574,
              "SF420000",
              9568,
              "SF430000",
              9552,
              "SF440000",
              9580,
              "SF450000",
              9575,
              "SF460000",
              9576,
              "SF470000",
              9572,
              "SF480000",
              9573,
              "SF490000",
              9561,
              "SF500000",
              9560,
              "SF510000",
              9554,
              "SF520000",
              9555,
              "SF530000",
              9579,
              "SF540000",
              9578,
              "Sacute",
              346,
              "Sacutedotaccent",
              7780,
              "Sampigreek",
              992,
              "Scaron",
              352,
              "Scarondotaccent",
              7782,
              "Scaronsmall",
              63229,
              "Scedilla",
              350,
              "Schwa",
              399,
              "Schwacyrillic",
              1240,
              "Schwadieresiscyrillic",
              1242,
              "Scircle",
              9416,
              "Scircumflex",
              348,
              "Scommaaccent",
              536,
              "Sdotaccent",
              7776,
              "Sdotbelow",
              7778,
              "Sdotbelowdotaccent",
              7784,
              "Seharmenian",
              1357,
              "Sevenroman",
              8550,
              "Shaarmenian",
              1351,
              "Shacyrillic",
              1064,
              "Shchacyrillic",
              1065,
              "Sheicoptic",
              994,
              "Shhacyrillic",
              1210,
              "Shimacoptic",
              1004,
              "Sigma",
              931,
              "Sixroman",
              8549,
              "Smonospace",
              65331,
              "Softsigncyrillic",
              1068,
              "Ssmall",
              63347,
              "Stigmagreek",
              986,
              "T",
              84,
              "Tau",
              932,
              "Tbar",
              358,
              "Tcaron",
              356,
              "Tcedilla",
              354,
              "Tcircle",
              9417,
              "Tcircumflexbelow",
              7792,
              "Tcommaaccent",
              354,
              "Tdotaccent",
              7786,
              "Tdotbelow",
              7788,
              "Tecyrillic",
              1058,
              "Tedescendercyrillic",
              1196,
              "Tenroman",
              8553,
              "Tetsecyrillic",
              1204,
              "Theta",
              920,
              "Thook",
              428,
              "Thorn",
              222,
              "Thornsmall",
              63486,
              "Threeroman",
              8546,
              "Tildesmall",
              63230,
              "Tiwnarmenian",
              1359,
              "Tlinebelow",
              7790,
              "Tmonospace",
              65332,
              "Toarmenian",
              1337,
              "Tonefive",
              444,
              "Tonesix",
              388,
              "Tonetwo",
              423,
              "Tretroflexhook",
              430,
              "Tsecyrillic",
              1062,
              "Tshecyrillic",
              1035,
              "Tsmall",
              63348,
              "Twelveroman",
              8555,
              "Tworoman",
              8545,
              "U",
              85,
              "Uacute",
              218,
              "Uacutesmall",
              63482,
              "Ubreve",
              364,
              "Ucaron",
              467,
              "Ucircle",
              9418,
              "Ucircumflex",
              219,
              "Ucircumflexbelow",
              7798,
              "Ucircumflexsmall",
              63483,
              "Ucyrillic",
              1059,
              "Udblacute",
              368,
              "Udblgrave",
              532,
              "Udieresis",
              220,
              "Udieresisacute",
              471,
              "Udieresisbelow",
              7794,
              "Udieresiscaron",
              473,
              "Udieresiscyrillic",
              1264,
              "Udieresisgrave",
              475,
              "Udieresismacron",
              469,
              "Udieresissmall",
              63484,
              "Udotbelow",
              7908,
              "Ugrave",
              217,
              "Ugravesmall",
              63481,
              "Uhookabove",
              7910,
              "Uhorn",
              431,
              "Uhornacute",
              7912,
              "Uhorndotbelow",
              7920,
              "Uhorngrave",
              7914,
              "Uhornhookabove",
              7916,
              "Uhorntilde",
              7918,
              "Uhungarumlaut",
              368,
              "Uhungarumlautcyrillic",
              1266,
              "Uinvertedbreve",
              534,
              "Ukcyrillic",
              1144,
              "Umacron",
              362,
              "Umacroncyrillic",
              1262,
              "Umacrondieresis",
              7802,
              "Umonospace",
              65333,
              "Uogonek",
              370,
              "Upsilon",
              933,
              "Upsilon1",
              978,
              "Upsilonacutehooksymbolgreek",
              979,
              "Upsilonafrican",
              433,
              "Upsilondieresis",
              939,
              "Upsilondieresishooksymbolgreek",
              980,
              "Upsilonhooksymbol",
              978,
              "Upsilontonos",
              910,
              "Uring",
              366,
              "Ushortcyrillic",
              1038,
              "Usmall",
              63349,
              "Ustraightcyrillic",
              1198,
              "Ustraightstrokecyrillic",
              1200,
              "Utilde",
              360,
              "Utildeacute",
              7800,
              "Utildebelow",
              7796,
              "V",
              86,
              "Vcircle",
              9419,
              "Vdotbelow",
              7806,
              "Vecyrillic",
              1042,
              "Vewarmenian",
              1358,
              "Vhook",
              434,
              "Vmonospace",
              65334,
              "Voarmenian",
              1352,
              "Vsmall",
              63350,
              "Vtilde",
              7804,
              "W",
              87,
              "Wacute",
              7810,
              "Wcircle",
              9420,
              "Wcircumflex",
              372,
              "Wdieresis",
              7812,
              "Wdotaccent",
              7814,
              "Wdotbelow",
              7816,
              "Wgrave",
              7808,
              "Wmonospace",
              65335,
              "Wsmall",
              63351,
              "X",
              88,
              "Xcircle",
              9421,
              "Xdieresis",
              7820,
              "Xdotaccent",
              7818,
              "Xeharmenian",
              1341,
              "Xi",
              926,
              "Xmonospace",
              65336,
              "Xsmall",
              63352,
              "Y",
              89,
              "Yacute",
              221,
              "Yacutesmall",
              63485,
              "Yatcyrillic",
              1122,
              "Ycircle",
              9422,
              "Ycircumflex",
              374,
              "Ydieresis",
              376,
              "Ydieresissmall",
              63487,
              "Ydotaccent",
              7822,
              "Ydotbelow",
              7924,
              "Yericyrillic",
              1067,
              "Yerudieresiscyrillic",
              1272,
              "Ygrave",
              7922,
              "Yhook",
              435,
              "Yhookabove",
              7926,
              "Yiarmenian",
              1349,
              "Yicyrillic",
              1031,
              "Yiwnarmenian",
              1362,
              "Ymonospace",
              65337,
              "Ysmall",
              63353,
              "Ytilde",
              7928,
              "Yusbigcyrillic",
              1130,
              "Yusbigiotifiedcyrillic",
              1132,
              "Yuslittlecyrillic",
              1126,
              "Yuslittleiotifiedcyrillic",
              1128,
              "Z",
              90,
              "Zaarmenian",
              1334,
              "Zacute",
              377,
              "Zcaron",
              381,
              "Zcaronsmall",
              63231,
              "Zcircle",
              9423,
              "Zcircumflex",
              7824,
              "Zdot",
              379,
              "Zdotaccent",
              379,
              "Zdotbelow",
              7826,
              "Zecyrillic",
              1047,
              "Zedescendercyrillic",
              1176,
              "Zedieresiscyrillic",
              1246,
              "Zeta",
              918,
              "Zhearmenian",
              1338,
              "Zhebrevecyrillic",
              1217,
              "Zhecyrillic",
              1046,
              "Zhedescendercyrillic",
              1174,
              "Zhedieresiscyrillic",
              1244,
              "Zlinebelow",
              7828,
              "Zmonospace",
              65338,
              "Zsmall",
              63354,
              "Zstroke",
              437,
              "a",
              97,
              "aabengali",
              2438,
              "aacute",
              225,
              "aadeva",
              2310,
              "aagujarati",
              2694,
              "aagurmukhi",
              2566,
              "aamatragurmukhi",
              2622,
              "aarusquare",
              13059,
              "aavowelsignbengali",
              2494,
              "aavowelsigndeva",
              2366,
              "aavowelsigngujarati",
              2750,
              "abbreviationmarkarmenian",
              1375,
              "abbreviationsigndeva",
              2416,
              "abengali",
              2437,
              "abopomofo",
              12570,
              "abreve",
              259,
              "abreveacute",
              7855,
              "abrevecyrillic",
              1233,
              "abrevedotbelow",
              7863,
              "abrevegrave",
              7857,
              "abrevehookabove",
              7859,
              "abrevetilde",
              7861,
              "acaron",
              462,
              "acircle",
              9424,
              "acircumflex",
              226,
              "acircumflexacute",
              7845,
              "acircumflexdotbelow",
              7853,
              "acircumflexgrave",
              7847,
              "acircumflexhookabove",
              7849,
              "acircumflextilde",
              7851,
              "acute",
              180,
              "acutebelowcmb",
              791,
              "acutecmb",
              769,
              "acutecomb",
              769,
              "acutedeva",
              2388,
              "acutelowmod",
              719,
              "acutetonecmb",
              833,
              "acyrillic",
              1072,
              "adblgrave",
              513,
              "addakgurmukhi",
              2673,
              "adeva",
              2309,
              "adieresis",
              228,
              "adieresiscyrillic",
              1235,
              "adieresismacron",
              479,
              "adotbelow",
              7841,
              "adotmacron",
              481,
              "ae",
              230,
              "aeacute",
              509,
              "aekorean",
              12624,
              "aemacron",
              483,
              "afii00208",
              8213,
              "afii08941",
              8356,
              "afii10017",
              1040,
              "afii10018",
              1041,
              "afii10019",
              1042,
              "afii10020",
              1043,
              "afii10021",
              1044,
              "afii10022",
              1045,
              "afii10023",
              1025,
              "afii10024",
              1046,
              "afii10025",
              1047,
              "afii10026",
              1048,
              "afii10027",
              1049,
              "afii10028",
              1050,
              "afii10029",
              1051,
              "afii10030",
              1052,
              "afii10031",
              1053,
              "afii10032",
              1054,
              "afii10033",
              1055,
              "afii10034",
              1056,
              "afii10035",
              1057,
              "afii10036",
              1058,
              "afii10037",
              1059,
              "afii10038",
              1060,
              "afii10039",
              1061,
              "afii10040",
              1062,
              "afii10041",
              1063,
              "afii10042",
              1064,
              "afii10043",
              1065,
              "afii10044",
              1066,
              "afii10045",
              1067,
              "afii10046",
              1068,
              "afii10047",
              1069,
              "afii10048",
              1070,
              "afii10049",
              1071,
              "afii10050",
              1168,
              "afii10051",
              1026,
              "afii10052",
              1027,
              "afii10053",
              1028,
              "afii10054",
              1029,
              "afii10055",
              1030,
              "afii10056",
              1031,
              "afii10057",
              1032,
              "afii10058",
              1033,
              "afii10059",
              1034,
              "afii10060",
              1035,
              "afii10061",
              1036,
              "afii10062",
              1038,
              "afii10063",
              63172,
              "afii10064",
              63173,
              "afii10065",
              1072,
              "afii10066",
              1073,
              "afii10067",
              1074,
              "afii10068",
              1075,
              "afii10069",
              1076,
              "afii10070",
              1077,
              "afii10071",
              1105,
              "afii10072",
              1078,
              "afii10073",
              1079,
              "afii10074",
              1080,
              "afii10075",
              1081,
              "afii10076",
              1082,
              "afii10077",
              1083,
              "afii10078",
              1084,
              "afii10079",
              1085,
              "afii10080",
              1086,
              "afii10081",
              1087,
              "afii10082",
              1088,
              "afii10083",
              1089,
              "afii10084",
              1090,
              "afii10085",
              1091,
              "afii10086",
              1092,
              "afii10087",
              1093,
              "afii10088",
              1094,
              "afii10089",
              1095,
              "afii10090",
              1096,
              "afii10091",
              1097,
              "afii10092",
              1098,
              "afii10093",
              1099,
              "afii10094",
              1100,
              "afii10095",
              1101,
              "afii10096",
              1102,
              "afii10097",
              1103,
              "afii10098",
              1169,
              "afii10099",
              1106,
              "afii10100",
              1107,
              "afii10101",
              1108,
              "afii10102",
              1109,
              "afii10103",
              1110,
              "afii10104",
              1111,
              "afii10105",
              1112,
              "afii10106",
              1113,
              "afii10107",
              1114,
              "afii10108",
              1115,
              "afii10109",
              1116,
              "afii10110",
              1118,
              "afii10145",
              1039,
              "afii10146",
              1122,
              "afii10147",
              1138,
              "afii10148",
              1140,
              "afii10192",
              63174,
              "afii10193",
              1119,
              "afii10194",
              1123,
              "afii10195",
              1139,
              "afii10196",
              1141,
              "afii10831",
              63175,
              "afii10832",
              63176,
              "afii10846",
              1241,
              "afii299",
              8206,
              "afii300",
              8207,
              "afii301",
              8205,
              "afii57381",
              1642,
              "afii57388",
              1548,
              "afii57392",
              1632,
              "afii57393",
              1633,
              "afii57394",
              1634,
              "afii57395",
              1635,
              "afii57396",
              1636,
              "afii57397",
              1637,
              "afii57398",
              1638,
              "afii57399",
              1639,
              "afii57400",
              1640,
              "afii57401",
              1641,
              "afii57403",
              1563,
              "afii57407",
              1567,
              "afii57409",
              1569,
              "afii57410",
              1570,
              "afii57411",
              1571,
              "afii57412",
              1572,
              "afii57413",
              1573,
              "afii57414",
              1574,
              "afii57415",
              1575,
              "afii57416",
              1576,
              "afii57417",
              1577,
              "afii57418",
              1578,
              "afii57419",
              1579,
              "afii57420",
              1580,
              "afii57421",
              1581,
              "afii57422",
              1582,
              "afii57423",
              1583,
              "afii57424",
              1584,
              "afii57425",
              1585,
              "afii57426",
              1586,
              "afii57427",
              1587,
              "afii57428",
              1588,
              "afii57429",
              1589,
              "afii57430",
              1590,
              "afii57431",
              1591,
              "afii57432",
              1592,
              "afii57433",
              1593,
              "afii57434",
              1594,
              "afii57440",
              1600,
              "afii57441",
              1601,
              "afii57442",
              1602,
              "afii57443",
              1603,
              "afii57444",
              1604,
              "afii57445",
              1605,
              "afii57446",
              1606,
              "afii57448",
              1608,
              "afii57449",
              1609,
              "afii57450",
              1610,
              "afii57451",
              1611,
              "afii57452",
              1612,
              "afii57453",
              1613,
              "afii57454",
              1614,
              "afii57455",
              1615,
              "afii57456",
              1616,
              "afii57457",
              1617,
              "afii57458",
              1618,
              "afii57470",
              1607,
              "afii57505",
              1700,
              "afii57506",
              1662,
              "afii57507",
              1670,
              "afii57508",
              1688,
              "afii57509",
              1711,
              "afii57511",
              1657,
              "afii57512",
              1672,
              "afii57513",
              1681,
              "afii57514",
              1722,
              "afii57519",
              1746,
              "afii57534",
              1749,
              "afii57636",
              8362,
              "afii57645",
              1470,
              "afii57658",
              1475,
              "afii57664",
              1488,
              "afii57665",
              1489,
              "afii57666",
              1490,
              "afii57667",
              1491,
              "afii57668",
              1492,
              "afii57669",
              1493,
              "afii57670",
              1494,
              "afii57671",
              1495,
              "afii57672",
              1496,
              "afii57673",
              1497,
              "afii57674",
              1498,
              "afii57675",
              1499,
              "afii57676",
              1500,
              "afii57677",
              1501,
              "afii57678",
              1502,
              "afii57679",
              1503,
              "afii57680",
              1504,
              "afii57681",
              1505,
              "afii57682",
              1506,
              "afii57683",
              1507,
              "afii57684",
              1508,
              "afii57685",
              1509,
              "afii57686",
              1510,
              "afii57687",
              1511,
              "afii57688",
              1512,
              "afii57689",
              1513,
              "afii57690",
              1514,
              "afii57694",
              64298,
              "afii57695",
              64299,
              "afii57700",
              64331,
              "afii57705",
              64287,
              "afii57716",
              1520,
              "afii57717",
              1521,
              "afii57718",
              1522,
              "afii57723",
              64309,
              "afii57793",
              1460,
              "afii57794",
              1461,
              "afii57795",
              1462,
              "afii57796",
              1467,
              "afii57797",
              1464,
              "afii57798",
              1463,
              "afii57799",
              1456,
              "afii57800",
              1458,
              "afii57801",
              1457,
              "afii57802",
              1459,
              "afii57803",
              1474,
              "afii57804",
              1473,
              "afii57806",
              1465,
              "afii57807",
              1468,
              "afii57839",
              1469,
              "afii57841",
              1471,
              "afii57842",
              1472,
              "afii57929",
              700,
              "afii61248",
              8453,
              "afii61289",
              8467,
              "afii61352",
              8470,
              "afii61573",
              8236,
              "afii61574",
              8237,
              "afii61575",
              8238,
              "afii61664",
              8204,
              "afii63167",
              1645,
              "afii64937",
              701,
              "agrave",
              224,
              "agujarati",
              2693,
              "agurmukhi",
              2565,
              "ahiragana",
              12354,
              "ahookabove",
              7843,
              "aibengali",
              2448,
              "aibopomofo",
              12574,
              "aideva",
              2320,
              "aiecyrillic",
              1237,
              "aigujarati",
              2704,
              "aigurmukhi",
              2576,
              "aimatragurmukhi",
              2632,
              "ainarabic",
              1593,
              "ainfinalarabic",
              65226,
              "aininitialarabic",
              65227,
              "ainmedialarabic",
              65228,
              "ainvertedbreve",
              515,
              "aivowelsignbengali",
              2504,
              "aivowelsigndeva",
              2376,
              "aivowelsigngujarati",
              2760,
              "akatakana",
              12450,
              "akatakanahalfwidth",
              65393,
              "akorean",
              12623,
              "alef",
              1488,
              "alefarabic",
              1575,
              "alefdageshhebrew",
              64304,
              "aleffinalarabic",
              65166,
              "alefhamzaabovearabic",
              1571,
              "alefhamzaabovefinalarabic",
              65156,
              "alefhamzabelowarabic",
              1573,
              "alefhamzabelowfinalarabic",
              65160,
              "alefhebrew",
              1488,
              "aleflamedhebrew",
              64335,
              "alefmaddaabovearabic",
              1570,
              "alefmaddaabovefinalarabic",
              65154,
              "alefmaksuraarabic",
              1609,
              "alefmaksurafinalarabic",
              65264,
              "alefmaksurainitialarabic",
              65267,
              "alefmaksuramedialarabic",
              65268,
              "alefpatahhebrew",
              64302,
              "alefqamatshebrew",
              64303,
              "aleph",
              8501,
              "allequal",
              8780,
              "alpha",
              945,
              "alphatonos",
              940,
              "amacron",
              257,
              "amonospace",
              65345,
              "ampersand",
              38,
              "ampersandmonospace",
              65286,
              "ampersandsmall",
              63270,
              "amsquare",
              13250,
              "anbopomofo",
              12578,
              "angbopomofo",
              12580,
              "angbracketleft",
              12296,
              "angbracketright",
              12297,
              "angkhankhuthai",
              3674,
              "angle",
              8736,
              "anglebracketleft",
              12296,
              "anglebracketleftvertical",
              65087,
              "anglebracketright",
              12297,
              "anglebracketrightvertical",
              65088,
              "angleleft",
              9001,
              "angleright",
              9002,
              "angstrom",
              8491,
              "anoteleia",
              903,
              "anudattadeva",
              2386,
              "anusvarabengali",
              2434,
              "anusvaradeva",
              2306,
              "anusvaragujarati",
              2690,
              "aogonek",
              261,
              "apaatosquare",
              13056,
              "aparen",
              9372,
              "apostrophearmenian",
              1370,
              "apostrophemod",
              700,
              "apple",
              63743,
              "approaches",
              8784,
              "approxequal",
              8776,
              "approxequalorimage",
              8786,
              "approximatelyequal",
              8773,
              "araeaekorean",
              12686,
              "araeakorean",
              12685,
              "arc",
              8978,
              "arighthalfring",
              7834,
              "aring",
              229,
              "aringacute",
              507,
              "aringbelow",
              7681,
              "arrowboth",
              8596,
              "arrowdashdown",
              8675,
              "arrowdashleft",
              8672,
              "arrowdashright",
              8674,
              "arrowdashup",
              8673,
              "arrowdblboth",
              8660,
              "arrowdbldown",
              8659,
              "arrowdblleft",
              8656,
              "arrowdblright",
              8658,
              "arrowdblup",
              8657,
              "arrowdown",
              8595,
              "arrowdownleft",
              8601,
              "arrowdownright",
              8600,
              "arrowdownwhite",
              8681,
              "arrowheaddownmod",
              709,
              "arrowheadleftmod",
              706,
              "arrowheadrightmod",
              707,
              "arrowheadupmod",
              708,
              "arrowhorizex",
              63719,
              "arrowleft",
              8592,
              "arrowleftdbl",
              8656,
              "arrowleftdblstroke",
              8653,
              "arrowleftoverright",
              8646,
              "arrowleftwhite",
              8678,
              "arrowright",
              8594,
              "arrowrightdblstroke",
              8655,
              "arrowrightheavy",
              10142,
              "arrowrightoverleft",
              8644,
              "arrowrightwhite",
              8680,
              "arrowtableft",
              8676,
              "arrowtabright",
              8677,
              "arrowup",
              8593,
              "arrowupdn",
              8597,
              "arrowupdnbse",
              8616,
              "arrowupdownbase",
              8616,
              "arrowupleft",
              8598,
              "arrowupleftofdown",
              8645,
              "arrowupright",
              8599,
              "arrowupwhite",
              8679,
              "arrowvertex",
              63718,
              "asciicircum",
              94,
              "asciicircummonospace",
              65342,
              "asciitilde",
              126,
              "asciitildemonospace",
              65374,
              "ascript",
              593,
              "ascriptturned",
              594,
              "asmallhiragana",
              12353,
              "asmallkatakana",
              12449,
              "asmallkatakanahalfwidth",
              65383,
              "asterisk",
              42,
              "asteriskaltonearabic",
              1645,
              "asteriskarabic",
              1645,
              "asteriskmath",
              8727,
              "asteriskmonospace",
              65290,
              "asterisksmall",
              65121,
              "asterism",
              8258,
              "asuperior",
              63209,
              "asymptoticallyequal",
              8771,
              "at",
              64,
              "atilde",
              227,
              "atmonospace",
              65312,
              "atsmall",
              65131,
              "aturned",
              592,
              "aubengali",
              2452,
              "aubopomofo",
              12576,
              "audeva",
              2324,
              "augujarati",
              2708,
              "augurmukhi",
              2580,
              "aulengthmarkbengali",
              2519,
              "aumatragurmukhi",
              2636,
              "auvowelsignbengali",
              2508,
              "auvowelsigndeva",
              2380,
              "auvowelsigngujarati",
              2764,
              "avagrahadeva",
              2365,
              "aybarmenian",
              1377,
              "ayin",
              1506,
              "ayinaltonehebrew",
              64288,
              "ayinhebrew",
              1506,
              "b",
              98,
              "babengali",
              2476,
              "backslash",
              92,
              "backslashmonospace",
              65340,
              "badeva",
              2348,
              "bagujarati",
              2732,
              "bagurmukhi",
              2604,
              "bahiragana",
              12400,
              "bahtthai",
              3647,
              "bakatakana",
              12496,
              "bar",
              124,
              "barmonospace",
              65372,
              "bbopomofo",
              12549,
              "bcircle",
              9425,
              "bdotaccent",
              7683,
              "bdotbelow",
              7685,
              "beamedsixteenthnotes",
              9836,
              "because",
              8757,
              "becyrillic",
              1073,
              "beharabic",
              1576,
              "behfinalarabic",
              65168,
              "behinitialarabic",
              65169,
              "behiragana",
              12409,
              "behmedialarabic",
              65170,
              "behmeeminitialarabic",
              64671,
              "behmeemisolatedarabic",
              64520,
              "behnoonfinalarabic",
              64621,
              "bekatakana",
              12505,
              "benarmenian",
              1378,
              "bet",
              1489,
              "beta",
              946,
              "betasymbolgreek",
              976,
              "betdagesh",
              64305,
              "betdageshhebrew",
              64305,
              "bethebrew",
              1489,
              "betrafehebrew",
              64332,
              "bhabengali",
              2477,
              "bhadeva",
              2349,
              "bhagujarati",
              2733,
              "bhagurmukhi",
              2605,
              "bhook",
              595,
              "bihiragana",
              12403,
              "bikatakana",
              12499,
              "bilabialclick",
              664,
              "bindigurmukhi",
              2562,
              "birusquare",
              13105,
              "blackcircle",
              9679,
              "blackdiamond",
              9670,
              "blackdownpointingtriangle",
              9660,
              "blackleftpointingpointer",
              9668,
              "blackleftpointingtriangle",
              9664,
              "blacklenticularbracketleft",
              12304,
              "blacklenticularbracketleftvertical",
              65083,
              "blacklenticularbracketright",
              12305,
              "blacklenticularbracketrightvertical",
              65084,
              "blacklowerlefttriangle",
              9699,
              "blacklowerrighttriangle",
              9698,
              "blackrectangle",
              9644,
              "blackrightpointingpointer",
              9658,
              "blackrightpointingtriangle",
              9654,
              "blacksmallsquare",
              9642,
              "blacksmilingface",
              9787,
              "blacksquare",
              9632,
              "blackstar",
              9733,
              "blackupperlefttriangle",
              9700,
              "blackupperrighttriangle",
              9701,
              "blackuppointingsmalltriangle",
              9652,
              "blackuppointingtriangle",
              9650,
              "blank",
              9251,
              "blinebelow",
              7687,
              "block",
              9608,
              "bmonospace",
              65346,
              "bobaimaithai",
              3610,
              "bohiragana",
              12412,
              "bokatakana",
              12508,
              "bparen",
              9373,
              "bqsquare",
              13251,
              "braceex",
              63732,
              "braceleft",
              123,
              "braceleftbt",
              63731,
              "braceleftmid",
              63730,
              "braceleftmonospace",
              65371,
              "braceleftsmall",
              65115,
              "bracelefttp",
              63729,
              "braceleftvertical",
              65079,
              "braceright",
              125,
              "bracerightbt",
              63742,
              "bracerightmid",
              63741,
              "bracerightmonospace",
              65373,
              "bracerightsmall",
              65116,
              "bracerighttp",
              63740,
              "bracerightvertical",
              65080,
              "bracketleft",
              91,
              "bracketleftbt",
              63728,
              "bracketleftex",
              63727,
              "bracketleftmonospace",
              65339,
              "bracketlefttp",
              63726,
              "bracketright",
              93,
              "bracketrightbt",
              63739,
              "bracketrightex",
              63738,
              "bracketrightmonospace",
              65341,
              "bracketrighttp",
              63737,
              "breve",
              728,
              "brevebelowcmb",
              814,
              "brevecmb",
              774,
              "breveinvertedbelowcmb",
              815,
              "breveinvertedcmb",
              785,
              "breveinverteddoublecmb",
              865,
              "bridgebelowcmb",
              810,
              "bridgeinvertedbelowcmb",
              826,
              "brokenbar",
              166,
              "bstroke",
              384,
              "bsuperior",
              63210,
              "btopbar",
              387,
              "buhiragana",
              12406,
              "bukatakana",
              12502,
              "bullet",
              8226,
              "bulletinverse",
              9688,
              "bulletoperator",
              8729,
              "bullseye",
              9678,
              "c",
              99,
              "caarmenian",
              1390,
              "cabengali",
              2458,
              "cacute",
              263,
              "cadeva",
              2330,
              "cagujarati",
              2714,
              "cagurmukhi",
              2586,
              "calsquare",
              13192,
              "candrabindubengali",
              2433,
              "candrabinducmb",
              784,
              "candrabindudeva",
              2305,
              "candrabindugujarati",
              2689,
              "capslock",
              8682,
              "careof",
              8453,
              "caron",
              711,
              "caronbelowcmb",
              812,
              "caroncmb",
              780,
              "carriagereturn",
              8629,
              "cbopomofo",
              12568,
              "ccaron",
              269,
              "ccedilla",
              231,
              "ccedillaacute",
              7689,
              "ccircle",
              9426,
              "ccircumflex",
              265,
              "ccurl",
              597,
              "cdot",
              267,
              "cdotaccent",
              267,
              "cdsquare",
              13253,
              "cedilla",
              184,
              "cedillacmb",
              807,
              "cent",
              162,
              "centigrade",
              8451,
              "centinferior",
              63199,
              "centmonospace",
              65504,
              "centoldstyle",
              63394,
              "centsuperior",
              63200,
              "chaarmenian",
              1401,
              "chabengali",
              2459,
              "chadeva",
              2331,
              "chagujarati",
              2715,
              "chagurmukhi",
              2587,
              "chbopomofo",
              12564,
              "cheabkhasiancyrillic",
              1213,
              "checkmark",
              10003,
              "checyrillic",
              1095,
              "chedescenderabkhasiancyrillic",
              1215,
              "chedescendercyrillic",
              1207,
              "chedieresiscyrillic",
              1269,
              "cheharmenian",
              1395,
              "chekhakassiancyrillic",
              1228,
              "cheverticalstrokecyrillic",
              1209,
              "chi",
              967,
              "chieuchacirclekorean",
              12919,
              "chieuchaparenkorean",
              12823,
              "chieuchcirclekorean",
              12905,
              "chieuchkorean",
              12618,
              "chieuchparenkorean",
              12809,
              "chochangthai",
              3594,
              "chochanthai",
              3592,
              "chochingthai",
              3593,
              "chochoethai",
              3596,
              "chook",
              392,
              "cieucacirclekorean",
              12918,
              "cieucaparenkorean",
              12822,
              "cieuccirclekorean",
              12904,
              "cieuckorean",
              12616,
              "cieucparenkorean",
              12808,
              "cieucuparenkorean",
              12828,
              "circle",
              9675,
              "circlecopyrt",
              169,
              "circlemultiply",
              8855,
              "circleot",
              8857,
              "circleplus",
              8853,
              "circlepostalmark",
              12342,
              "circlewithlefthalfblack",
              9680,
              "circlewithrighthalfblack",
              9681,
              "circumflex",
              710,
              "circumflexbelowcmb",
              813,
              "circumflexcmb",
              770,
              "clear",
              8999,
              "clickalveolar",
              450,
              "clickdental",
              448,
              "clicklateral",
              449,
              "clickretroflex",
              451,
              "club",
              9827,
              "clubsuitblack",
              9827,
              "clubsuitwhite",
              9831,
              "cmcubedsquare",
              13220,
              "cmonospace",
              65347,
              "cmsquaredsquare",
              13216,
              "coarmenian",
              1409,
              "colon",
              58,
              "colonmonetary",
              8353,
              "colonmonospace",
              65306,
              "colonsign",
              8353,
              "colonsmall",
              65109,
              "colontriangularhalfmod",
              721,
              "colontriangularmod",
              720,
              "comma",
              44,
              "commaabovecmb",
              787,
              "commaaboverightcmb",
              789,
              "commaaccent",
              63171,
              "commaarabic",
              1548,
              "commaarmenian",
              1373,
              "commainferior",
              63201,
              "commamonospace",
              65292,
              "commareversedabovecmb",
              788,
              "commareversedmod",
              701,
              "commasmall",
              65104,
              "commasuperior",
              63202,
              "commaturnedabovecmb",
              786,
              "commaturnedmod",
              699,
              "compass",
              9788,
              "congruent",
              8773,
              "contourintegral",
              8750,
              "control",
              8963,
              "controlACK",
              6,
              "controlBEL",
              7,
              "controlBS",
              8,
              "controlCAN",
              24,
              "controlCR",
              13,
              "controlDC1",
              17,
              "controlDC2",
              18,
              "controlDC3",
              19,
              "controlDC4",
              20,
              "controlDEL",
              127,
              "controlDLE",
              16,
              "controlEM",
              25,
              "controlENQ",
              5,
              "controlEOT",
              4,
              "controlESC",
              27,
              "controlETB",
              23,
              "controlETX",
              3,
              "controlFF",
              12,
              "controlFS",
              28,
              "controlGS",
              29,
              "controlHT",
              9,
              "controlLF",
              10,
              "controlNAK",
              21,
              "controlNULL",
              0,
              "controlRS",
              30,
              "controlSI",
              15,
              "controlSO",
              14,
              "controlSOT",
              2,
              "controlSTX",
              1,
              "controlSUB",
              26,
              "controlSYN",
              22,
              "controlUS",
              31,
              "controlVT",
              11,
              "copyright",
              169,
              "copyrightsans",
              63721,
              "copyrightserif",
              63193,
              "cornerbracketleft",
              12300,
              "cornerbracketlefthalfwidth",
              65378,
              "cornerbracketleftvertical",
              65089,
              "cornerbracketright",
              12301,
              "cornerbracketrighthalfwidth",
              65379,
              "cornerbracketrightvertical",
              65090,
              "corporationsquare",
              13183,
              "cosquare",
              13255,
              "coverkgsquare",
              13254,
              "cparen",
              9374,
              "cruzeiro",
              8354,
              "cstretched",
              663,
              "curlyand",
              8911,
              "curlyor",
              8910,
              "currency",
              164,
              "cyrBreve",
              63185,
              "cyrFlex",
              63186,
              "cyrbreve",
              63188,
              "cyrflex",
              63189,
              "d",
              100,
              "daarmenian",
              1380,
              "dabengali",
              2470,
              "dadarabic",
              1590,
              "dadeva",
              2342,
              "dadfinalarabic",
              65214,
              "dadinitialarabic",
              65215,
              "dadmedialarabic",
              65216,
              "dagesh",
              1468,
              "dageshhebrew",
              1468,
              "dagger",
              8224,
              "daggerdbl",
              8225,
              "dagujarati",
              2726,
              "dagurmukhi",
              2598,
              "dahiragana",
              12384,
              "dakatakana",
              12480,
              "dalarabic",
              1583,
              "dalet",
              1491,
              "daletdagesh",
              64307,
              "daletdageshhebrew",
              64307,
              "dalethebrew",
              1491,
              "dalfinalarabic",
              65194,
              "dammaarabic",
              1615,
              "dammalowarabic",
              1615,
              "dammatanaltonearabic",
              1612,
              "dammatanarabic",
              1612,
              "danda",
              2404,
              "dargahebrew",
              1447,
              "dargalefthebrew",
              1447,
              "dasiapneumatacyrilliccmb",
              1157,
              "dblGrave",
              63187,
              "dblanglebracketleft",
              12298,
              "dblanglebracketleftvertical",
              65085,
              "dblanglebracketright",
              12299,
              "dblanglebracketrightvertical",
              65086,
              "dblarchinvertedbelowcmb",
              811,
              "dblarrowleft",
              8660,
              "dblarrowright",
              8658,
              "dbldanda",
              2405,
              "dblgrave",
              63190,
              "dblgravecmb",
              783,
              "dblintegral",
              8748,
              "dbllowline",
              8215,
              "dbllowlinecmb",
              819,
              "dbloverlinecmb",
              831,
              "dblprimemod",
              698,
              "dblverticalbar",
              8214,
              "dblverticallineabovecmb",
              782,
              "dbopomofo",
              12553,
              "dbsquare",
              13256,
              "dcaron",
              271,
              "dcedilla",
              7697,
              "dcircle",
              9427,
              "dcircumflexbelow",
              7699,
              "dcroat",
              273,
              "ddabengali",
              2465,
              "ddadeva",
              2337,
              "ddagujarati",
              2721,
              "ddagurmukhi",
              2593,
              "ddalarabic",
              1672,
              "ddalfinalarabic",
              64393,
              "dddhadeva",
              2396,
              "ddhabengali",
              2466,
              "ddhadeva",
              2338,
              "ddhagujarati",
              2722,
              "ddhagurmukhi",
              2594,
              "ddotaccent",
              7691,
              "ddotbelow",
              7693,
              "decimalseparatorarabic",
              1643,
              "decimalseparatorpersian",
              1643,
              "decyrillic",
              1076,
              "degree",
              176,
              "dehihebrew",
              1453,
              "dehiragana",
              12391,
              "deicoptic",
              1007,
              "dekatakana",
              12487,
              "deleteleft",
              9003,
              "deleteright",
              8998,
              "delta",
              948,
              "deltaturned",
              397,
              "denominatorminusonenumeratorbengali",
              2552,
              "dezh",
              676,
              "dhabengali",
              2471,
              "dhadeva",
              2343,
              "dhagujarati",
              2727,
              "dhagurmukhi",
              2599,
              "dhook",
              599,
              "dialytikatonos",
              901,
              "dialytikatonoscmb",
              836,
              "diamond",
              9830,
              "diamondsuitwhite",
              9826,
              "dieresis",
              168,
              "dieresisacute",
              63191,
              "dieresisbelowcmb",
              804,
              "dieresiscmb",
              776,
              "dieresisgrave",
              63192,
              "dieresistonos",
              901,
              "dihiragana",
              12386,
              "dikatakana",
              12482,
              "dittomark",
              12291,
              "divide",
              247,
              "divides",
              8739,
              "divisionslash",
              8725,
              "djecyrillic",
              1106,
              "dkshade",
              9619,
              "dlinebelow",
              7695,
              "dlsquare",
              13207,
              "dmacron",
              273,
              "dmonospace",
              65348,
              "dnblock",
              9604,
              "dochadathai",
              3598,
              "dodekthai",
              3604,
              "dohiragana",
              12393,
              "dokatakana",
              12489,
              "dollar",
              36,
              "dollarinferior",
              63203,
              "dollarmonospace",
              65284,
              "dollaroldstyle",
              63268,
              "dollarsmall",
              65129,
              "dollarsuperior",
              63204,
              "dong",
              8363,
              "dorusquare",
              13094,
              "dotaccent",
              729,
              "dotaccentcmb",
              775,
              "dotbelowcmb",
              803,
              "dotbelowcomb",
              803,
              "dotkatakana",
              12539,
              "dotlessi",
              305,
              "dotlessj",
              63166,
              "dotlessjstrokehook",
              644,
              "dotmath",
              8901,
              "dottedcircle",
              9676,
              "doubleyodpatah",
              64287,
              "doubleyodpatahhebrew",
              64287,
              "downtackbelowcmb",
              798,
              "downtackmod",
              725,
              "dparen",
              9375,
              "dsuperior",
              63211,
              "dtail",
              598,
              "dtopbar",
              396,
              "duhiragana",
              12389,
              "dukatakana",
              12485,
              "dz",
              499,
              "dzaltone",
              675,
              "dzcaron",
              454,
              "dzcurl",
              677,
              "dzeabkhasiancyrillic",
              1249,
              "dzecyrillic",
              1109,
              "dzhecyrillic",
              1119,
              "e",
              101,
              "eacute",
              233,
              "earth",
              9793,
              "ebengali",
              2447,
              "ebopomofo",
              12572,
              "ebreve",
              277,
              "ecandradeva",
              2317,
              "ecandragujarati",
              2701,
              "ecandravowelsigndeva",
              2373,
              "ecandravowelsigngujarati",
              2757,
              "ecaron",
              283,
              "ecedillabreve",
              7709,
              "echarmenian",
              1381,
              "echyiwnarmenian",
              1415,
              "ecircle",
              9428,
              "ecircumflex",
              234,
              "ecircumflexacute",
              7871,
              "ecircumflexbelow",
              7705,
              "ecircumflexdotbelow",
              7879,
              "ecircumflexgrave",
              7873,
              "ecircumflexhookabove",
              7875,
              "ecircumflextilde",
              7877,
              "ecyrillic",
              1108,
              "edblgrave",
              517,
              "edeva",
              2319,
              "edieresis",
              235,
              "edot",
              279,
              "edotaccent",
              279,
              "edotbelow",
              7865,
              "eegurmukhi",
              2575,
              "eematragurmukhi",
              2631,
              "efcyrillic",
              1092,
              "egrave",
              232,
              "egujarati",
              2703,
              "eharmenian",
              1383,
              "ehbopomofo",
              12573,
              "ehiragana",
              12360,
              "ehookabove",
              7867,
              "eibopomofo",
              12575,
              "eight",
              56,
              "eightarabic",
              1640,
              "eightbengali",
              2542,
              "eightcircle",
              9319,
              "eightcircleinversesansserif",
              10129,
              "eightdeva",
              2414,
              "eighteencircle",
              9329,
              "eighteenparen",
              9349,
              "eighteenperiod",
              9369,
              "eightgujarati",
              2798,
              "eightgurmukhi",
              2670,
              "eighthackarabic",
              1640,
              "eighthangzhou",
              12328,
              "eighthnotebeamed",
              9835,
              "eightideographicparen",
              12839,
              "eightinferior",
              8328,
              "eightmonospace",
              65304,
              "eightoldstyle",
              63288,
              "eightparen",
              9339,
              "eightperiod",
              9359,
              "eightpersian",
              1784,
              "eightroman",
              8567,
              "eightsuperior",
              8312,
              "eightthai",
              3672,
              "einvertedbreve",
              519,
              "eiotifiedcyrillic",
              1125,
              "ekatakana",
              12456,
              "ekatakanahalfwidth",
              65396,
              "ekonkargurmukhi",
              2676,
              "ekorean",
              12628,
              "elcyrillic",
              1083,
              "element",
              8712,
              "elevencircle",
              9322,
              "elevenparen",
              9342,
              "elevenperiod",
              9362,
              "elevenroman",
              8570,
              "ellipsis",
              8230,
              "ellipsisvertical",
              8942,
              "emacron",
              275,
              "emacronacute",
              7703,
              "emacrongrave",
              7701,
              "emcyrillic",
              1084,
              "emdash",
              8212,
              "emdashvertical",
              65073,
              "emonospace",
              65349,
              "emphasismarkarmenian",
              1371,
              "emptyset",
              8709,
              "enbopomofo",
              12579,
              "encyrillic",
              1085,
              "endash",
              8211,
              "endashvertical",
              65074,
              "endescendercyrillic",
              1187,
              "eng",
              331,
              "engbopomofo",
              12581,
              "enghecyrillic",
              1189,
              "enhookcyrillic",
              1224,
              "enspace",
              8194,
              "eogonek",
              281,
              "eokorean",
              12627,
              "eopen",
              603,
              "eopenclosed",
              666,
              "eopenreversed",
              604,
              "eopenreversedclosed",
              606,
              "eopenreversedhook",
              605,
              "eparen",
              9376,
              "epsilon",
              949,
              "epsilontonos",
              941,
              "equal",
              61,
              "equalmonospace",
              65309,
              "equalsmall",
              65126,
              "equalsuperior",
              8316,
              "equivalence",
              8801,
              "erbopomofo",
              12582,
              "ercyrillic",
              1088,
              "ereversed",
              600,
              "ereversedcyrillic",
              1101,
              "escyrillic",
              1089,
              "esdescendercyrillic",
              1195,
              "esh",
              643,
              "eshcurl",
              646,
              "eshortdeva",
              2318,
              "eshortvowelsigndeva",
              2374,
              "eshreversedloop",
              426,
              "eshsquatreversed",
              645,
              "esmallhiragana",
              12359,
              "esmallkatakana",
              12455,
              "esmallkatakanahalfwidth",
              65386,
              "estimated",
              8494,
              "esuperior",
              63212,
              "eta",
              951,
              "etarmenian",
              1384,
              "etatonos",
              942,
              "eth",
              240,
              "etilde",
              7869,
              "etildebelow",
              7707,
              "etnahtafoukhhebrew",
              1425,
              "etnahtafoukhlefthebrew",
              1425,
              "etnahtahebrew",
              1425,
              "etnahtalefthebrew",
              1425,
              "eturned",
              477,
              "eukorean",
              12641,
              "euro",
              8364,
              "evowelsignbengali",
              2503,
              "evowelsigndeva",
              2375,
              "evowelsigngujarati",
              2759,
              "exclam",
              33,
              "exclamarmenian",
              1372,
              "exclamdbl",
              8252,
              "exclamdown",
              161,
              "exclamdownsmall",
              63393,
              "exclammonospace",
              65281,
              "exclamsmall",
              63265,
              "existential",
              8707,
              "ezh",
              658,
              "ezhcaron",
              495,
              "ezhcurl",
              659,
              "ezhreversed",
              441,
              "ezhtail",
              442,
              "f",
              102,
              "fadeva",
              2398,
              "fagurmukhi",
              2654,
              "fahrenheit",
              8457,
              "fathaarabic",
              1614,
              "fathalowarabic",
              1614,
              "fathatanarabic",
              1611,
              "fbopomofo",
              12552,
              "fcircle",
              9429,
              "fdotaccent",
              7711,
              "feharabic",
              1601,
              "feharmenian",
              1414,
              "fehfinalarabic",
              65234,
              "fehinitialarabic",
              65235,
              "fehmedialarabic",
              65236,
              "feicoptic",
              997,
              "female",
              9792,
              "ff",
              64256,
              "f_f",
              64256,
              "ffi",
              64259,
              "ffl",
              64260,
              "fi",
              64257,
              "fifteencircle",
              9326,
              "fifteenparen",
              9346,
              "fifteenperiod",
              9366,
              "figuredash",
              8210,
              "filledbox",
              9632,
              "filledrect",
              9644,
              "finalkaf",
              1498,
              "finalkafdagesh",
              64314,
              "finalkafdageshhebrew",
              64314,
              "finalkafhebrew",
              1498,
              "finalmem",
              1501,
              "finalmemhebrew",
              1501,
              "finalnun",
              1503,
              "finalnunhebrew",
              1503,
              "finalpe",
              1507,
              "finalpehebrew",
              1507,
              "finaltsadi",
              1509,
              "finaltsadihebrew",
              1509,
              "firsttonechinese",
              713,
              "fisheye",
              9673,
              "fitacyrillic",
              1139,
              "five",
              53,
              "fivearabic",
              1637,
              "fivebengali",
              2539,
              "fivecircle",
              9316,
              "fivecircleinversesansserif",
              10126,
              "fivedeva",
              2411,
              "fiveeighths",
              8541,
              "fivegujarati",
              2795,
              "fivegurmukhi",
              2667,
              "fivehackarabic",
              1637,
              "fivehangzhou",
              12325,
              "fiveideographicparen",
              12836,
              "fiveinferior",
              8325,
              "fivemonospace",
              65301,
              "fiveoldstyle",
              63285,
              "fiveparen",
              9336,
              "fiveperiod",
              9356,
              "fivepersian",
              1781,
              "fiveroman",
              8564,
              "fivesuperior",
              8309,
              "fivethai",
              3669,
              "fl",
              64258,
              "florin",
              402,
              "fmonospace",
              65350,
              "fmsquare",
              13209,
              "fofanthai",
              3615,
              "fofathai",
              3613,
              "fongmanthai",
              3663,
              "forall",
              8704,
              "four",
              52,
              "fourarabic",
              1636,
              "fourbengali",
              2538,
              "fourcircle",
              9315,
              "fourcircleinversesansserif",
              10125,
              "fourdeva",
              2410,
              "fourgujarati",
              2794,
              "fourgurmukhi",
              2666,
              "fourhackarabic",
              1636,
              "fourhangzhou",
              12324,
              "fourideographicparen",
              12835,
              "fourinferior",
              8324,
              "fourmonospace",
              65300,
              "fournumeratorbengali",
              2551,
              "fouroldstyle",
              63284,
              "fourparen",
              9335,
              "fourperiod",
              9355,
              "fourpersian",
              1780,
              "fourroman",
              8563,
              "foursuperior",
              8308,
              "fourteencircle",
              9325,
              "fourteenparen",
              9345,
              "fourteenperiod",
              9365,
              "fourthai",
              3668,
              "fourthtonechinese",
              715,
              "fparen",
              9377,
              "fraction",
              8260,
              "franc",
              8355,
              "g",
              103,
              "gabengali",
              2455,
              "gacute",
              501,
              "gadeva",
              2327,
              "gafarabic",
              1711,
              "gaffinalarabic",
              64403,
              "gafinitialarabic",
              64404,
              "gafmedialarabic",
              64405,
              "gagujarati",
              2711,
              "gagurmukhi",
              2583,
              "gahiragana",
              12364,
              "gakatakana",
              12460,
              "gamma",
              947,
              "gammalatinsmall",
              611,
              "gammasuperior",
              736,
              "gangiacoptic",
              1003,
              "gbopomofo",
              12557,
              "gbreve",
              287,
              "gcaron",
              487,
              "gcedilla",
              291,
              "gcircle",
              9430,
              "gcircumflex",
              285,
              "gcommaaccent",
              291,
              "gdot",
              289,
              "gdotaccent",
              289,
              "gecyrillic",
              1075,
              "gehiragana",
              12370,
              "gekatakana",
              12466,
              "geometricallyequal",
              8785,
              "gereshaccenthebrew",
              1436,
              "gereshhebrew",
              1523,
              "gereshmuqdamhebrew",
              1437,
              "germandbls",
              223,
              "gershayimaccenthebrew",
              1438,
              "gershayimhebrew",
              1524,
              "getamark",
              12307,
              "ghabengali",
              2456,
              "ghadarmenian",
              1394,
              "ghadeva",
              2328,
              "ghagujarati",
              2712,
              "ghagurmukhi",
              2584,
              "ghainarabic",
              1594,
              "ghainfinalarabic",
              65230,
              "ghaininitialarabic",
              65231,
              "ghainmedialarabic",
              65232,
              "ghemiddlehookcyrillic",
              1173,
              "ghestrokecyrillic",
              1171,
              "gheupturncyrillic",
              1169,
              "ghhadeva",
              2394,
              "ghhagurmukhi",
              2650,
              "ghook",
              608,
              "ghzsquare",
              13203,
              "gihiragana",
              12366,
              "gikatakana",
              12462,
              "gimarmenian",
              1379,
              "gimel",
              1490,
              "gimeldagesh",
              64306,
              "gimeldageshhebrew",
              64306,
              "gimelhebrew",
              1490,
              "gjecyrillic",
              1107,
              "glottalinvertedstroke",
              446,
              "glottalstop",
              660,
              "glottalstopinverted",
              662,
              "glottalstopmod",
              704,
              "glottalstopreversed",
              661,
              "glottalstopreversedmod",
              705,
              "glottalstopreversedsuperior",
              740,
              "glottalstopstroke",
              673,
              "glottalstopstrokereversed",
              674,
              "gmacron",
              7713,
              "gmonospace",
              65351,
              "gohiragana",
              12372,
              "gokatakana",
              12468,
              "gparen",
              9378,
              "gpasquare",
              13228,
              "gradient",
              8711,
              "grave",
              96,
              "gravebelowcmb",
              790,
              "gravecmb",
              768,
              "gravecomb",
              768,
              "gravedeva",
              2387,
              "gravelowmod",
              718,
              "gravemonospace",
              65344,
              "gravetonecmb",
              832,
              "greater",
              62,
              "greaterequal",
              8805,
              "greaterequalorless",
              8923,
              "greatermonospace",
              65310,
              "greaterorequivalent",
              8819,
              "greaterorless",
              8823,
              "greateroverequal",
              8807,
              "greatersmall",
              65125,
              "gscript",
              609,
              "gstroke",
              485,
              "guhiragana",
              12368,
              "guillemotleft",
              171,
              "guillemotright",
              187,
              "guilsinglleft",
              8249,
              "guilsinglright",
              8250,
              "gukatakana",
              12464,
              "guramusquare",
              13080,
              "gysquare",
              13257,
              "h",
              104,
              "haabkhasiancyrillic",
              1193,
              "haaltonearabic",
              1729,
              "habengali",
              2489,
              "hadescendercyrillic",
              1203,
              "hadeva",
              2361,
              "hagujarati",
              2745,
              "hagurmukhi",
              2617,
              "haharabic",
              1581,
              "hahfinalarabic",
              65186,
              "hahinitialarabic",
              65187,
              "hahiragana",
              12399,
              "hahmedialarabic",
              65188,
              "haitusquare",
              13098,
              "hakatakana",
              12495,
              "hakatakanahalfwidth",
              65418,
              "halantgurmukhi",
              2637,
              "hamzaarabic",
              1569,
              "hamzalowarabic",
              1569,
              "hangulfiller",
              12644,
              "hardsigncyrillic",
              1098,
              "harpoonleftbarbup",
              8636,
              "harpoonrightbarbup",
              8640,
              "hasquare",
              13258,
              "hatafpatah",
              1458,
              "hatafpatah16",
              1458,
              "hatafpatah23",
              1458,
              "hatafpatah2f",
              1458,
              "hatafpatahhebrew",
              1458,
              "hatafpatahnarrowhebrew",
              1458,
              "hatafpatahquarterhebrew",
              1458,
              "hatafpatahwidehebrew",
              1458,
              "hatafqamats",
              1459,
              "hatafqamats1b",
              1459,
              "hatafqamats28",
              1459,
              "hatafqamats34",
              1459,
              "hatafqamatshebrew",
              1459,
              "hatafqamatsnarrowhebrew",
              1459,
              "hatafqamatsquarterhebrew",
              1459,
              "hatafqamatswidehebrew",
              1459,
              "hatafsegol",
              1457,
              "hatafsegol17",
              1457,
              "hatafsegol24",
              1457,
              "hatafsegol30",
              1457,
              "hatafsegolhebrew",
              1457,
              "hatafsegolnarrowhebrew",
              1457,
              "hatafsegolquarterhebrew",
              1457,
              "hatafsegolwidehebrew",
              1457,
              "hbar",
              295,
              "hbopomofo",
              12559,
              "hbrevebelow",
              7723,
              "hcedilla",
              7721,
              "hcircle",
              9431,
              "hcircumflex",
              293,
              "hdieresis",
              7719,
              "hdotaccent",
              7715,
              "hdotbelow",
              7717,
              "he",
              1492,
              "heart",
              9829,
              "heartsuitblack",
              9829,
              "heartsuitwhite",
              9825,
              "hedagesh",
              64308,
              "hedageshhebrew",
              64308,
              "hehaltonearabic",
              1729,
              "heharabic",
              1607,
              "hehebrew",
              1492,
              "hehfinalaltonearabic",
              64423,
              "hehfinalalttwoarabic",
              65258,
              "hehfinalarabic",
              65258,
              "hehhamzaabovefinalarabic",
              64421,
              "hehhamzaaboveisolatedarabic",
              64420,
              "hehinitialaltonearabic",
              64424,
              "hehinitialarabic",
              65259,
              "hehiragana",
              12408,
              "hehmedialaltonearabic",
              64425,
              "hehmedialarabic",
              65260,
              "heiseierasquare",
              13179,
              "hekatakana",
              12504,
              "hekatakanahalfwidth",
              65421,
              "hekutaarusquare",
              13110,
              "henghook",
              615,
              "herutusquare",
              13113,
              "het",
              1495,
              "hethebrew",
              1495,
              "hhook",
              614,
              "hhooksuperior",
              689,
              "hieuhacirclekorean",
              12923,
              "hieuhaparenkorean",
              12827,
              "hieuhcirclekorean",
              12909,
              "hieuhkorean",
              12622,
              "hieuhparenkorean",
              12813,
              "hihiragana",
              12402,
              "hikatakana",
              12498,
              "hikatakanahalfwidth",
              65419,
              "hiriq",
              1460,
              "hiriq14",
              1460,
              "hiriq21",
              1460,
              "hiriq2d",
              1460,
              "hiriqhebrew",
              1460,
              "hiriqnarrowhebrew",
              1460,
              "hiriqquarterhebrew",
              1460,
              "hiriqwidehebrew",
              1460,
              "hlinebelow",
              7830,
              "hmonospace",
              65352,
              "hoarmenian",
              1392,
              "hohipthai",
              3627,
              "hohiragana",
              12411,
              "hokatakana",
              12507,
              "hokatakanahalfwidth",
              65422,
              "holam",
              1465,
              "holam19",
              1465,
              "holam26",
              1465,
              "holam32",
              1465,
              "holamhebrew",
              1465,
              "holamnarrowhebrew",
              1465,
              "holamquarterhebrew",
              1465,
              "holamwidehebrew",
              1465,
              "honokhukthai",
              3630,
              "hookabovecomb",
              777,
              "hookcmb",
              777,
              "hookpalatalizedbelowcmb",
              801,
              "hookretroflexbelowcmb",
              802,
              "hoonsquare",
              13122,
              "horicoptic",
              1001,
              "horizontalbar",
              8213,
              "horncmb",
              795,
              "hotsprings",
              9832,
              "house",
              8962,
              "hparen",
              9379,
              "hsuperior",
              688,
              "hturned",
              613,
              "huhiragana",
              12405,
              "huiitosquare",
              13107,
              "hukatakana",
              12501,
              "hukatakanahalfwidth",
              65420,
              "hungarumlaut",
              733,
              "hungarumlautcmb",
              779,
              "hv",
              405,
              "hyphen",
              45,
              "hypheninferior",
              63205,
              "hyphenmonospace",
              65293,
              "hyphensmall",
              65123,
              "hyphensuperior",
              63206,
              "hyphentwo",
              8208,
              "i",
              105,
              "iacute",
              237,
              "iacyrillic",
              1103,
              "ibengali",
              2439,
              "ibopomofo",
              12583,
              "ibreve",
              301,
              "icaron",
              464,
              "icircle",
              9432,
              "icircumflex",
              238,
              "icyrillic",
              1110,
              "idblgrave",
              521,
              "ideographearthcircle",
              12943,
              "ideographfirecircle",
              12939,
              "ideographicallianceparen",
              12863,
              "ideographiccallparen",
              12858,
              "ideographiccentrecircle",
              12965,
              "ideographicclose",
              12294,
              "ideographiccomma",
              12289,
              "ideographiccommaleft",
              65380,
              "ideographiccongratulationparen",
              12855,
              "ideographiccorrectcircle",
              12963,
              "ideographicearthparen",
              12847,
              "ideographicenterpriseparen",
              12861,
              "ideographicexcellentcircle",
              12957,
              "ideographicfestivalparen",
              12864,
              "ideographicfinancialcircle",
              12950,
              "ideographicfinancialparen",
              12854,
              "ideographicfireparen",
              12843,
              "ideographichaveparen",
              12850,
              "ideographichighcircle",
              12964,
              "ideographiciterationmark",
              12293,
              "ideographiclaborcircle",
              12952,
              "ideographiclaborparen",
              12856,
              "ideographicleftcircle",
              12967,
              "ideographiclowcircle",
              12966,
              "ideographicmedicinecircle",
              12969,
              "ideographicmetalparen",
              12846,
              "ideographicmoonparen",
              12842,
              "ideographicnameparen",
              12852,
              "ideographicperiod",
              12290,
              "ideographicprintcircle",
              12958,
              "ideographicreachparen",
              12867,
              "ideographicrepresentparen",
              12857,
              "ideographicresourceparen",
              12862,
              "ideographicrightcircle",
              12968,
              "ideographicsecretcircle",
              12953,
              "ideographicselfparen",
              12866,
              "ideographicsocietyparen",
              12851,
              "ideographicspace",
              12288,
              "ideographicspecialparen",
              12853,
              "ideographicstockparen",
              12849,
              "ideographicstudyparen",
              12859,
              "ideographicsunparen",
              12848,
              "ideographicsuperviseparen",
              12860,
              "ideographicwaterparen",
              12844,
              "ideographicwoodparen",
              12845,
              "ideographiczero",
              12295,
              "ideographmetalcircle",
              12942,
              "ideographmooncircle",
              12938,
              "ideographnamecircle",
              12948,
              "ideographsuncircle",
              12944,
              "ideographwatercircle",
              12940,
              "ideographwoodcircle",
              12941,
              "ideva",
              2311,
              "idieresis",
              239,
              "idieresisacute",
              7727,
              "idieresiscyrillic",
              1253,
              "idotbelow",
              7883,
              "iebrevecyrillic",
              1239,
              "iecyrillic",
              1077,
              "ieungacirclekorean",
              12917,
              "ieungaparenkorean",
              12821,
              "ieungcirclekorean",
              12903,
              "ieungkorean",
              12615,
              "ieungparenkorean",
              12807,
              "igrave",
              236,
              "igujarati",
              2695,
              "igurmukhi",
              2567,
              "ihiragana",
              12356,
              "ihookabove",
              7881,
              "iibengali",
              2440,
              "iicyrillic",
              1080,
              "iideva",
              2312,
              "iigujarati",
              2696,
              "iigurmukhi",
              2568,
              "iimatragurmukhi",
              2624,
              "iinvertedbreve",
              523,
              "iishortcyrillic",
              1081,
              "iivowelsignbengali",
              2496,
              "iivowelsigndeva",
              2368,
              "iivowelsigngujarati",
              2752,
              "ij",
              307,
              "ikatakana",
              12452,
              "ikatakanahalfwidth",
              65394,
              "ikorean",
              12643,
              "ilde",
              732,
              "iluyhebrew",
              1452,
              "imacron",
              299,
              "imacroncyrillic",
              1251,
              "imageorapproximatelyequal",
              8787,
              "imatragurmukhi",
              2623,
              "imonospace",
              65353,
              "increment",
              8710,
              "infinity",
              8734,
              "iniarmenian",
              1387,
              "integral",
              8747,
              "integralbottom",
              8993,
              "integralbt",
              8993,
              "integralex",
              63733,
              "integraltop",
              8992,
              "integraltp",
              8992,
              "intersection",
              8745,
              "intisquare",
              13061,
              "invbullet",
              9688,
              "invcircle",
              9689,
              "invsmileface",
              9787,
              "iocyrillic",
              1105,
              "iogonek",
              303,
              "iota",
              953,
              "iotadieresis",
              970,
              "iotadieresistonos",
              912,
              "iotalatin",
              617,
              "iotatonos",
              943,
              "iparen",
              9380,
              "irigurmukhi",
              2674,
              "ismallhiragana",
              12355,
              "ismallkatakana",
              12451,
              "ismallkatakanahalfwidth",
              65384,
              "issharbengali",
              2554,
              "istroke",
              616,
              "isuperior",
              63213,
              "iterationhiragana",
              12445,
              "iterationkatakana",
              12541,
              "itilde",
              297,
              "itildebelow",
              7725,
              "iubopomofo",
              12585,
              "iucyrillic",
              1102,
              "ivowelsignbengali",
              2495,
              "ivowelsigndeva",
              2367,
              "ivowelsigngujarati",
              2751,
              "izhitsacyrillic",
              1141,
              "izhitsadblgravecyrillic",
              1143,
              "j",
              106,
              "jaarmenian",
              1393,
              "jabengali",
              2460,
              "jadeva",
              2332,
              "jagujarati",
              2716,
              "jagurmukhi",
              2588,
              "jbopomofo",
              12560,
              "jcaron",
              496,
              "jcircle",
              9433,
              "jcircumflex",
              309,
              "jcrossedtail",
              669,
              "jdotlessstroke",
              607,
              "jecyrillic",
              1112,
              "jeemarabic",
              1580,
              "jeemfinalarabic",
              65182,
              "jeeminitialarabic",
              65183,
              "jeemmedialarabic",
              65184,
              "jeharabic",
              1688,
              "jehfinalarabic",
              64395,
              "jhabengali",
              2461,
              "jhadeva",
              2333,
              "jhagujarati",
              2717,
              "jhagurmukhi",
              2589,
              "jheharmenian",
              1403,
              "jis",
              12292,
              "jmonospace",
              65354,
              "jparen",
              9381,
              "jsuperior",
              690,
              "k",
              107,
              "kabashkircyrillic",
              1185,
              "kabengali",
              2453,
              "kacute",
              7729,
              "kacyrillic",
              1082,
              "kadescendercyrillic",
              1179,
              "kadeva",
              2325,
              "kaf",
              1499,
              "kafarabic",
              1603,
              "kafdagesh",
              64315,
              "kafdageshhebrew",
              64315,
              "kaffinalarabic",
              65242,
              "kafhebrew",
              1499,
              "kafinitialarabic",
              65243,
              "kafmedialarabic",
              65244,
              "kafrafehebrew",
              64333,
              "kagujarati",
              2709,
              "kagurmukhi",
              2581,
              "kahiragana",
              12363,
              "kahookcyrillic",
              1220,
              "kakatakana",
              12459,
              "kakatakanahalfwidth",
              65398,
              "kappa",
              954,
              "kappasymbolgreek",
              1008,
              "kapyeounmieumkorean",
              12657,
              "kapyeounphieuphkorean",
              12676,
              "kapyeounpieupkorean",
              12664,
              "kapyeounssangpieupkorean",
              12665,
              "karoriisquare",
              13069,
              "kashidaautoarabic",
              1600,
              "kashidaautonosidebearingarabic",
              1600,
              "kasmallkatakana",
              12533,
              "kasquare",
              13188,
              "kasraarabic",
              1616,
              "kasratanarabic",
              1613,
              "kastrokecyrillic",
              1183,
              "katahiraprolongmarkhalfwidth",
              65392,
              "kaverticalstrokecyrillic",
              1181,
              "kbopomofo",
              12558,
              "kcalsquare",
              13193,
              "kcaron",
              489,
              "kcedilla",
              311,
              "kcircle",
              9434,
              "kcommaaccent",
              311,
              "kdotbelow",
              7731,
              "keharmenian",
              1412,
              "kehiragana",
              12369,
              "kekatakana",
              12465,
              "kekatakanahalfwidth",
              65401,
              "kenarmenian",
              1391,
              "kesmallkatakana",
              12534,
              "kgreenlandic",
              312,
              "khabengali",
              2454,
              "khacyrillic",
              1093,
              "khadeva",
              2326,
              "khagujarati",
              2710,
              "khagurmukhi",
              2582,
              "khaharabic",
              1582,
              "khahfinalarabic",
              65190,
              "khahinitialarabic",
              65191,
              "khahmedialarabic",
              65192,
              "kheicoptic",
              999,
              "khhadeva",
              2393,
              "khhagurmukhi",
              2649,
              "khieukhacirclekorean",
              12920,
              "khieukhaparenkorean",
              12824,
              "khieukhcirclekorean",
              12906,
              "khieukhkorean",
              12619,
              "khieukhparenkorean",
              12810,
              "khokhaithai",
              3586,
              "khokhonthai",
              3589,
              "khokhuatthai",
              3587,
              "khokhwaithai",
              3588,
              "khomutthai",
              3675,
              "khook",
              409,
              "khorakhangthai",
              3590,
              "khzsquare",
              13201,
              "kihiragana",
              12365,
              "kikatakana",
              12461,
              "kikatakanahalfwidth",
              65399,
              "kiroguramusquare",
              13077,
              "kiromeetorusquare",
              13078,
              "kirosquare",
              13076,
              "kiyeokacirclekorean",
              12910,
              "kiyeokaparenkorean",
              12814,
              "kiyeokcirclekorean",
              12896,
              "kiyeokkorean",
              12593,
              "kiyeokparenkorean",
              12800,
              "kiyeoksioskorean",
              12595,
              "kjecyrillic",
              1116,
              "klinebelow",
              7733,
              "klsquare",
              13208,
              "kmcubedsquare",
              13222,
              "kmonospace",
              65355,
              "kmsquaredsquare",
              13218,
              "kohiragana",
              12371,
              "kohmsquare",
              13248,
              "kokaithai",
              3585,
              "kokatakana",
              12467,
              "kokatakanahalfwidth",
              65402,
              "kooposquare",
              13086,
              "koppacyrillic",
              1153,
              "koreanstandardsymbol",
              12927,
              "koroniscmb",
              835,
              "kparen",
              9382,
              "kpasquare",
              13226,
              "ksicyrillic",
              1135,
              "ktsquare",
              13263,
              "kturned",
              670,
              "kuhiragana",
              12367,
              "kukatakana",
              12463,
              "kukatakanahalfwidth",
              65400,
              "kvsquare",
              13240,
              "kwsquare",
              13246,
              "l",
              108,
              "labengali",
              2482,
              "lacute",
              314,
              "ladeva",
              2354,
              "lagujarati",
              2738,
              "lagurmukhi",
              2610,
              "lakkhangyaothai",
              3653,
              "lamaleffinalarabic",
              65276,
              "lamalefhamzaabovefinalarabic",
              65272,
              "lamalefhamzaaboveisolatedarabic",
              65271,
              "lamalefhamzabelowfinalarabic",
              65274,
              "lamalefhamzabelowisolatedarabic",
              65273,
              "lamalefisolatedarabic",
              65275,
              "lamalefmaddaabovefinalarabic",
              65270,
              "lamalefmaddaaboveisolatedarabic",
              65269,
              "lamarabic",
              1604,
              "lambda",
              955,
              "lambdastroke",
              411,
              "lamed",
              1500,
              "lameddagesh",
              64316,
              "lameddageshhebrew",
              64316,
              "lamedhebrew",
              1500,
              "lamfinalarabic",
              65246,
              "lamhahinitialarabic",
              64714,
              "laminitialarabic",
              65247,
              "lamjeeminitialarabic",
              64713,
              "lamkhahinitialarabic",
              64715,
              "lamlamhehisolatedarabic",
              65010,
              "lammedialarabic",
              65248,
              "lammeemhahinitialarabic",
              64904,
              "lammeeminitialarabic",
              64716,
              "largecircle",
              9711,
              "lbar",
              410,
              "lbelt",
              620,
              "lbopomofo",
              12556,
              "lcaron",
              318,
              "lcedilla",
              316,
              "lcircle",
              9435,
              "lcircumflexbelow",
              7741,
              "lcommaaccent",
              316,
              "ldot",
              320,
              "ldotaccent",
              320,
              "ldotbelow",
              7735,
              "ldotbelowmacron",
              7737,
              "leftangleabovecmb",
              794,
              "lefttackbelowcmb",
              792,
              "less",
              60,
              "lessequal",
              8804,
              "lessequalorgreater",
              8922,
              "lessmonospace",
              65308,
              "lessorequivalent",
              8818,
              "lessorgreater",
              8822,
              "lessoverequal",
              8806,
              "lesssmall",
              65124,
              "lezh",
              622,
              "lfblock",
              9612,
              "lhookretroflex",
              621,
              "lira",
              8356,
              "liwnarmenian",
              1388,
              "lj",
              457,
              "ljecyrillic",
              1113,
              "ll",
              63168,
              "lladeva",
              2355,
              "llagujarati",
              2739,
              "llinebelow",
              7739,
              "llladeva",
              2356,
              "llvocalicbengali",
              2529,
              "llvocalicdeva",
              2401,
              "llvocalicvowelsignbengali",
              2531,
              "llvocalicvowelsigndeva",
              2403,
              "lmiddletilde",
              619,
              "lmonospace",
              65356,
              "lmsquare",
              13264,
              "lochulathai",
              3628,
              "logicaland",
              8743,
              "logicalnot",
              172,
              "logicalnotreversed",
              8976,
              "logicalor",
              8744,
              "lolingthai",
              3621,
              "longs",
              383,
              "lowlinecenterline",
              65102,
              "lowlinecmb",
              818,
              "lowlinedashed",
              65101,
              "lozenge",
              9674,
              "lparen",
              9383,
              "lslash",
              322,
              "lsquare",
              8467,
              "lsuperior",
              63214,
              "ltshade",
              9617,
              "luthai",
              3622,
              "lvocalicbengali",
              2444,
              "lvocalicdeva",
              2316,
              "lvocalicvowelsignbengali",
              2530,
              "lvocalicvowelsigndeva",
              2402,
              "lxsquare",
              13267,
              "m",
              109,
              "mabengali",
              2478,
              "macron",
              175,
              "macronbelowcmb",
              817,
              "macroncmb",
              772,
              "macronlowmod",
              717,
              "macronmonospace",
              65507,
              "macute",
              7743,
              "madeva",
              2350,
              "magujarati",
              2734,
              "magurmukhi",
              2606,
              "mahapakhhebrew",
              1444,
              "mahapakhlefthebrew",
              1444,
              "mahiragana",
              12414,
              "maichattawalowleftthai",
              63637,
              "maichattawalowrightthai",
              63636,
              "maichattawathai",
              3659,
              "maichattawaupperleftthai",
              63635,
              "maieklowleftthai",
              63628,
              "maieklowrightthai",
              63627,
              "maiekthai",
              3656,
              "maiekupperleftthai",
              63626,
              "maihanakatleftthai",
              63620,
              "maihanakatthai",
              3633,
              "maitaikhuleftthai",
              63625,
              "maitaikhuthai",
              3655,
              "maitholowleftthai",
              63631,
              "maitholowrightthai",
              63630,
              "maithothai",
              3657,
              "maithoupperleftthai",
              63629,
              "maitrilowleftthai",
              63634,
              "maitrilowrightthai",
              63633,
              "maitrithai",
              3658,
              "maitriupperleftthai",
              63632,
              "maiyamokthai",
              3654,
              "makatakana",
              12510,
              "makatakanahalfwidth",
              65423,
              "male",
              9794,
              "mansyonsquare",
              13127,
              "maqafhebrew",
              1470,
              "mars",
              9794,
              "masoracirclehebrew",
              1455,
              "masquare",
              13187,
              "mbopomofo",
              12551,
              "mbsquare",
              13268,
              "mcircle",
              9436,
              "mcubedsquare",
              13221,
              "mdotaccent",
              7745,
              "mdotbelow",
              7747,
              "meemarabic",
              1605,
              "meemfinalarabic",
              65250,
              "meeminitialarabic",
              65251,
              "meemmedialarabic",
              65252,
              "meemmeeminitialarabic",
              64721,
              "meemmeemisolatedarabic",
              64584,
              "meetorusquare",
              13133,
              "mehiragana",
              12417,
              "meizierasquare",
              13182,
              "mekatakana",
              12513,
              "mekatakanahalfwidth",
              65426,
              "mem",
              1502,
              "memdagesh",
              64318,
              "memdageshhebrew",
              64318,
              "memhebrew",
              1502,
              "menarmenian",
              1396,
              "merkhahebrew",
              1445,
              "merkhakefulahebrew",
              1446,
              "merkhakefulalefthebrew",
              1446,
              "merkhalefthebrew",
              1445,
              "mhook",
              625,
              "mhzsquare",
              13202,
              "middledotkatakanahalfwidth",
              65381,
              "middot",
              183,
              "mieumacirclekorean",
              12914,
              "mieumaparenkorean",
              12818,
              "mieumcirclekorean",
              12900,
              "mieumkorean",
              12609,
              "mieumpansioskorean",
              12656,
              "mieumparenkorean",
              12804,
              "mieumpieupkorean",
              12654,
              "mieumsioskorean",
              12655,
              "mihiragana",
              12415,
              "mikatakana",
              12511,
              "mikatakanahalfwidth",
              65424,
              "minus",
              8722,
              "minusbelowcmb",
              800,
              "minuscircle",
              8854,
              "minusmod",
              727,
              "minusplus",
              8723,
              "minute",
              8242,
              "miribaarusquare",
              13130,
              "mirisquare",
              13129,
              "mlonglegturned",
              624,
              "mlsquare",
              13206,
              "mmcubedsquare",
              13219,
              "mmonospace",
              65357,
              "mmsquaredsquare",
              13215,
              "mohiragana",
              12418,
              "mohmsquare",
              13249,
              "mokatakana",
              12514,
              "mokatakanahalfwidth",
              65427,
              "molsquare",
              13270,
              "momathai",
              3617,
              "moverssquare",
              13223,
              "moverssquaredsquare",
              13224,
              "mparen",
              9384,
              "mpasquare",
              13227,
              "mssquare",
              13235,
              "msuperior",
              63215,
              "mturned",
              623,
              "mu",
              181,
              "mu1",
              181,
              "muasquare",
              13186,
              "muchgreater",
              8811,
              "muchless",
              8810,
              "mufsquare",
              13196,
              "mugreek",
              956,
              "mugsquare",
              13197,
              "muhiragana",
              12416,
              "mukatakana",
              12512,
              "mukatakanahalfwidth",
              65425,
              "mulsquare",
              13205,
              "multiply",
              215,
              "mumsquare",
              13211,
              "munahhebrew",
              1443,
              "munahlefthebrew",
              1443,
              "musicalnote",
              9834,
              "musicalnotedbl",
              9835,
              "musicflatsign",
              9837,
              "musicsharpsign",
              9839,
              "mussquare",
              13234,
              "muvsquare",
              13238,
              "muwsquare",
              13244,
              "mvmegasquare",
              13241,
              "mvsquare",
              13239,
              "mwmegasquare",
              13247,
              "mwsquare",
              13245,
              "n",
              110,
              "nabengali",
              2472,
              "nabla",
              8711,
              "nacute",
              324,
              "nadeva",
              2344,
              "nagujarati",
              2728,
              "nagurmukhi",
              2600,
              "nahiragana",
              12394,
              "nakatakana",
              12490,
              "nakatakanahalfwidth",
              65413,
              "napostrophe",
              329,
              "nasquare",
              13185,
              "nbopomofo",
              12555,
              "nbspace",
              160,
              "ncaron",
              328,
              "ncedilla",
              326,
              "ncircle",
              9437,
              "ncircumflexbelow",
              7755,
              "ncommaaccent",
              326,
              "ndotaccent",
              7749,
              "ndotbelow",
              7751,
              "nehiragana",
              12397,
              "nekatakana",
              12493,
              "nekatakanahalfwidth",
              65416,
              "newsheqelsign",
              8362,
              "nfsquare",
              13195,
              "ngabengali",
              2457,
              "ngadeva",
              2329,
              "ngagujarati",
              2713,
              "ngagurmukhi",
              2585,
              "ngonguthai",
              3591,
              "nhiragana",
              12435,
              "nhookleft",
              626,
              "nhookretroflex",
              627,
              "nieunacirclekorean",
              12911,
              "nieunaparenkorean",
              12815,
              "nieuncieuckorean",
              12597,
              "nieuncirclekorean",
              12897,
              "nieunhieuhkorean",
              12598,
              "nieunkorean",
              12596,
              "nieunpansioskorean",
              12648,
              "nieunparenkorean",
              12801,
              "nieunsioskorean",
              12647,
              "nieuntikeutkorean",
              12646,
              "nihiragana",
              12395,
              "nikatakana",
              12491,
              "nikatakanahalfwidth",
              65414,
              "nikhahitleftthai",
              63641,
              "nikhahitthai",
              3661,
              "nine",
              57,
              "ninearabic",
              1641,
              "ninebengali",
              2543,
              "ninecircle",
              9320,
              "ninecircleinversesansserif",
              10130,
              "ninedeva",
              2415,
              "ninegujarati",
              2799,
              "ninegurmukhi",
              2671,
              "ninehackarabic",
              1641,
              "ninehangzhou",
              12329,
              "nineideographicparen",
              12840,
              "nineinferior",
              8329,
              "ninemonospace",
              65305,
              "nineoldstyle",
              63289,
              "nineparen",
              9340,
              "nineperiod",
              9360,
              "ninepersian",
              1785,
              "nineroman",
              8568,
              "ninesuperior",
              8313,
              "nineteencircle",
              9330,
              "nineteenparen",
              9350,
              "nineteenperiod",
              9370,
              "ninethai",
              3673,
              "nj",
              460,
              "njecyrillic",
              1114,
              "nkatakana",
              12531,
              "nkatakanahalfwidth",
              65437,
              "nlegrightlong",
              414,
              "nlinebelow",
              7753,
              "nmonospace",
              65358,
              "nmsquare",
              13210,
              "nnabengali",
              2467,
              "nnadeva",
              2339,
              "nnagujarati",
              2723,
              "nnagurmukhi",
              2595,
              "nnnadeva",
              2345,
              "nohiragana",
              12398,
              "nokatakana",
              12494,
              "nokatakanahalfwidth",
              65417,
              "nonbreakingspace",
              160,
              "nonenthai",
              3603,
              "nonuthai",
              3609,
              "noonarabic",
              1606,
              "noonfinalarabic",
              65254,
              "noonghunnaarabic",
              1722,
              "noonghunnafinalarabic",
              64415,
              "nooninitialarabic",
              65255,
              "noonjeeminitialarabic",
              64722,
              "noonjeemisolatedarabic",
              64587,
              "noonmedialarabic",
              65256,
              "noonmeeminitialarabic",
              64725,
              "noonmeemisolatedarabic",
              64590,
              "noonnoonfinalarabic",
              64653,
              "notcontains",
              8716,
              "notelement",
              8713,
              "notelementof",
              8713,
              "notequal",
              8800,
              "notgreater",
              8815,
              "notgreaternorequal",
              8817,
              "notgreaternorless",
              8825,
              "notidentical",
              8802,
              "notless",
              8814,
              "notlessnorequal",
              8816,
              "notparallel",
              8742,
              "notprecedes",
              8832,
              "notsubset",
              8836,
              "notsucceeds",
              8833,
              "notsuperset",
              8837,
              "nowarmenian",
              1398,
              "nparen",
              9385,
              "nssquare",
              13233,
              "nsuperior",
              8319,
              "ntilde",
              241,
              "nu",
              957,
              "nuhiragana",
              12396,
              "nukatakana",
              12492,
              "nukatakanahalfwidth",
              65415,
              "nuktabengali",
              2492,
              "nuktadeva",
              2364,
              "nuktagujarati",
              2748,
              "nuktagurmukhi",
              2620,
              "numbersign",
              35,
              "numbersignmonospace",
              65283,
              "numbersignsmall",
              65119,
              "numeralsigngreek",
              884,
              "numeralsignlowergreek",
              885,
              "numero",
              8470,
              "nun",
              1504,
              "nundagesh",
              64320,
              "nundageshhebrew",
              64320,
              "nunhebrew",
              1504,
              "nvsquare",
              13237,
              "nwsquare",
              13243,
              "nyabengali",
              2462,
              "nyadeva",
              2334,
              "nyagujarati",
              2718,
              "nyagurmukhi",
              2590,
              "o",
              111,
              "oacute",
              243,
              "oangthai",
              3629,
              "obarred",
              629,
              "obarredcyrillic",
              1257,
              "obarreddieresiscyrillic",
              1259,
              "obengali",
              2451,
              "obopomofo",
              12571,
              "obreve",
              335,
              "ocandradeva",
              2321,
              "ocandragujarati",
              2705,
              "ocandravowelsigndeva",
              2377,
              "ocandravowelsigngujarati",
              2761,
              "ocaron",
              466,
              "ocircle",
              9438,
              "ocircumflex",
              244,
              "ocircumflexacute",
              7889,
              "ocircumflexdotbelow",
              7897,
              "ocircumflexgrave",
              7891,
              "ocircumflexhookabove",
              7893,
              "ocircumflextilde",
              7895,
              "ocyrillic",
              1086,
              "odblacute",
              337,
              "odblgrave",
              525,
              "odeva",
              2323,
              "odieresis",
              246,
              "odieresiscyrillic",
              1255,
              "odotbelow",
              7885,
              "oe",
              339,
              "oekorean",
              12634,
              "ogonek",
              731,
              "ogonekcmb",
              808,
              "ograve",
              242,
              "ogujarati",
              2707,
              "oharmenian",
              1413,
              "ohiragana",
              12362,
              "ohookabove",
              7887,
              "ohorn",
              417,
              "ohornacute",
              7899,
              "ohorndotbelow",
              7907,
              "ohorngrave",
              7901,
              "ohornhookabove",
              7903,
              "ohorntilde",
              7905,
              "ohungarumlaut",
              337,
              "oi",
              419,
              "oinvertedbreve",
              527,
              "okatakana",
              12458,
              "okatakanahalfwidth",
              65397,
              "okorean",
              12631,
              "olehebrew",
              1451,
              "omacron",
              333,
              "omacronacute",
              7763,
              "omacrongrave",
              7761,
              "omdeva",
              2384,
              "omega",
              969,
              "omega1",
              982,
              "omegacyrillic",
              1121,
              "omegalatinclosed",
              631,
              "omegaroundcyrillic",
              1147,
              "omegatitlocyrillic",
              1149,
              "omegatonos",
              974,
              "omgujarati",
              2768,
              "omicron",
              959,
              "omicrontonos",
              972,
              "omonospace",
              65359,
              "one",
              49,
              "onearabic",
              1633,
              "onebengali",
              2535,
              "onecircle",
              9312,
              "onecircleinversesansserif",
              10122,
              "onedeva",
              2407,
              "onedotenleader",
              8228,
              "oneeighth",
              8539,
              "onefitted",
              63196,
              "onegujarati",
              2791,
              "onegurmukhi",
              2663,
              "onehackarabic",
              1633,
              "onehalf",
              189,
              "onehangzhou",
              12321,
              "oneideographicparen",
              12832,
              "oneinferior",
              8321,
              "onemonospace",
              65297,
              "onenumeratorbengali",
              2548,
              "oneoldstyle",
              63281,
              "oneparen",
              9332,
              "oneperiod",
              9352,
              "onepersian",
              1777,
              "onequarter",
              188,
              "oneroman",
              8560,
              "onesuperior",
              185,
              "onethai",
              3665,
              "onethird",
              8531,
              "oogonek",
              491,
              "oogonekmacron",
              493,
              "oogurmukhi",
              2579,
              "oomatragurmukhi",
              2635,
              "oopen",
              596,
              "oparen",
              9386,
              "openbullet",
              9702,
              "option",
              8997,
              "ordfeminine",
              170,
              "ordmasculine",
              186,
              "orthogonal",
              8735,
              "oshortdeva",
              2322,
              "oshortvowelsigndeva",
              2378,
              "oslash",
              248,
              "oslashacute",
              511,
              "osmallhiragana",
              12361,
              "osmallkatakana",
              12457,
              "osmallkatakanahalfwidth",
              65387,
              "ostrokeacute",
              511,
              "osuperior",
              63216,
              "otcyrillic",
              1151,
              "otilde",
              245,
              "otildeacute",
              7757,
              "otildedieresis",
              7759,
              "oubopomofo",
              12577,
              "overline",
              8254,
              "overlinecenterline",
              65098,
              "overlinecmb",
              773,
              "overlinedashed",
              65097,
              "overlinedblwavy",
              65100,
              "overlinewavy",
              65099,
              "overscore",
              175,
              "ovowelsignbengali",
              2507,
              "ovowelsigndeva",
              2379,
              "ovowelsigngujarati",
              2763,
              "p",
              112,
              "paampssquare",
              13184,
              "paasentosquare",
              13099,
              "pabengali",
              2474,
              "pacute",
              7765,
              "padeva",
              2346,
              "pagedown",
              8671,
              "pageup",
              8670,
              "pagujarati",
              2730,
              "pagurmukhi",
              2602,
              "pahiragana",
              12401,
              "paiyannoithai",
              3631,
              "pakatakana",
              12497,
              "palatalizationcyrilliccmb",
              1156,
              "palochkacyrillic",
              1216,
              "pansioskorean",
              12671,
              "paragraph",
              182,
              "parallel",
              8741,
              "parenleft",
              40,
              "parenleftaltonearabic",
              64830,
              "parenleftbt",
              63725,
              "parenleftex",
              63724,
              "parenleftinferior",
              8333,
              "parenleftmonospace",
              65288,
              "parenleftsmall",
              65113,
              "parenleftsuperior",
              8317,
              "parenlefttp",
              63723,
              "parenleftvertical",
              65077,
              "parenright",
              41,
              "parenrightaltonearabic",
              64831,
              "parenrightbt",
              63736,
              "parenrightex",
              63735,
              "parenrightinferior",
              8334,
              "parenrightmonospace",
              65289,
              "parenrightsmall",
              65114,
              "parenrightsuperior",
              8318,
              "parenrighttp",
              63734,
              "parenrightvertical",
              65078,
              "partialdiff",
              8706,
              "paseqhebrew",
              1472,
              "pashtahebrew",
              1433,
              "pasquare",
              13225,
              "patah",
              1463,
              "patah11",
              1463,
              "patah1d",
              1463,
              "patah2a",
              1463,
              "patahhebrew",
              1463,
              "patahnarrowhebrew",
              1463,
              "patahquarterhebrew",
              1463,
              "patahwidehebrew",
              1463,
              "pazerhebrew",
              1441,
              "pbopomofo",
              12550,
              "pcircle",
              9439,
              "pdotaccent",
              7767,
              "pe",
              1508,
              "pecyrillic",
              1087,
              "pedagesh",
              64324,
              "pedageshhebrew",
              64324,
              "peezisquare",
              13115,
              "pefinaldageshhebrew",
              64323,
              "peharabic",
              1662,
              "peharmenian",
              1402,
              "pehebrew",
              1508,
              "pehfinalarabic",
              64343,
              "pehinitialarabic",
              64344,
              "pehiragana",
              12410,
              "pehmedialarabic",
              64345,
              "pekatakana",
              12506,
              "pemiddlehookcyrillic",
              1191,
              "perafehebrew",
              64334,
              "percent",
              37,
              "percentarabic",
              1642,
              "percentmonospace",
              65285,
              "percentsmall",
              65130,
              "period",
              46,
              "periodarmenian",
              1417,
              "periodcentered",
              183,
              "periodhalfwidth",
              65377,
              "periodinferior",
              63207,
              "periodmonospace",
              65294,
              "periodsmall",
              65106,
              "periodsuperior",
              63208,
              "perispomenigreekcmb",
              834,
              "perpendicular",
              8869,
              "perthousand",
              8240,
              "peseta",
              8359,
              "pfsquare",
              13194,
              "phabengali",
              2475,
              "phadeva",
              2347,
              "phagujarati",
              2731,
              "phagurmukhi",
              2603,
              "phi",
              966,
              "phi1",
              981,
              "phieuphacirclekorean",
              12922,
              "phieuphaparenkorean",
              12826,
              "phieuphcirclekorean",
              12908,
              "phieuphkorean",
              12621,
              "phieuphparenkorean",
              12812,
              "philatin",
              632,
              "phinthuthai",
              3642,
              "phisymbolgreek",
              981,
              "phook",
              421,
              "phophanthai",
              3614,
              "phophungthai",
              3612,
              "phosamphaothai",
              3616,
              "pi",
              960,
              "pieupacirclekorean",
              12915,
              "pieupaparenkorean",
              12819,
              "pieupcieuckorean",
              12662,
              "pieupcirclekorean",
              12901,
              "pieupkiyeokkorean",
              12658,
              "pieupkorean",
              12610,
              "pieupparenkorean",
              12805,
              "pieupsioskiyeokkorean",
              12660,
              "pieupsioskorean",
              12612,
              "pieupsiostikeutkorean",
              12661,
              "pieupthieuthkorean",
              12663,
              "pieuptikeutkorean",
              12659,
              "pihiragana",
              12404,
              "pikatakana",
              12500,
              "pisymbolgreek",
              982,
              "piwrarmenian",
              1411,
              "plus",
              43,
              "plusbelowcmb",
              799,
              "pluscircle",
              8853,
              "plusminus",
              177,
              "plusmod",
              726,
              "plusmonospace",
              65291,
              "plussmall",
              65122,
              "plussuperior",
              8314,
              "pmonospace",
              65360,
              "pmsquare",
              13272,
              "pohiragana",
              12413,
              "pointingindexdownwhite",
              9759,
              "pointingindexleftwhite",
              9756,
              "pointingindexrightwhite",
              9758,
              "pointingindexupwhite",
              9757,
              "pokatakana",
              12509,
              "poplathai",
              3611,
              "postalmark",
              12306,
              "postalmarkface",
              12320,
              "pparen",
              9387,
              "precedes",
              8826,
              "prescription",
              8478,
              "primemod",
              697,
              "primereversed",
              8245,
              "product",
              8719,
              "projective",
              8965,
              "prolongedkana",
              12540,
              "propellor",
              8984,
              "propersubset",
              8834,
              "propersuperset",
              8835,
              "proportion",
              8759,
              "proportional",
              8733,
              "psi",
              968,
              "psicyrillic",
              1137,
              "psilipneumatacyrilliccmb",
              1158,
              "pssquare",
              13232,
              "puhiragana",
              12407,
              "pukatakana",
              12503,
              "pvsquare",
              13236,
              "pwsquare",
              13242,
              "q",
              113,
              "qadeva",
              2392,
              "qadmahebrew",
              1448,
              "qafarabic",
              1602,
              "qaffinalarabic",
              65238,
              "qafinitialarabic",
              65239,
              "qafmedialarabic",
              65240,
              "qamats",
              1464,
              "qamats10",
              1464,
              "qamats1a",
              1464,
              "qamats1c",
              1464,
              "qamats27",
              1464,
              "qamats29",
              1464,
              "qamats33",
              1464,
              "qamatsde",
              1464,
              "qamatshebrew",
              1464,
              "qamatsnarrowhebrew",
              1464,
              "qamatsqatanhebrew",
              1464,
              "qamatsqatannarrowhebrew",
              1464,
              "qamatsqatanquarterhebrew",
              1464,
              "qamatsqatanwidehebrew",
              1464,
              "qamatsquarterhebrew",
              1464,
              "qamatswidehebrew",
              1464,
              "qarneyparahebrew",
              1439,
              "qbopomofo",
              12561,
              "qcircle",
              9440,
              "qhook",
              672,
              "qmonospace",
              65361,
              "qof",
              1511,
              "qofdagesh",
              64327,
              "qofdageshhebrew",
              64327,
              "qofhebrew",
              1511,
              "qparen",
              9388,
              "quarternote",
              9833,
              "qubuts",
              1467,
              "qubuts18",
              1467,
              "qubuts25",
              1467,
              "qubuts31",
              1467,
              "qubutshebrew",
              1467,
              "qubutsnarrowhebrew",
              1467,
              "qubutsquarterhebrew",
              1467,
              "qubutswidehebrew",
              1467,
              "question",
              63,
              "questionarabic",
              1567,
              "questionarmenian",
              1374,
              "questiondown",
              191,
              "questiondownsmall",
              63423,
              "questiongreek",
              894,
              "questionmonospace",
              65311,
              "questionsmall",
              63295,
              "quotedbl",
              34,
              "quotedblbase",
              8222,
              "quotedblleft",
              8220,
              "quotedblmonospace",
              65282,
              "quotedblprime",
              12318,
              "quotedblprimereversed",
              12317,
              "quotedblright",
              8221,
              "quoteleft",
              8216,
              "quoteleftreversed",
              8219,
              "quotereversed",
              8219,
              "quoteright",
              8217,
              "quoterightn",
              329,
              "quotesinglbase",
              8218,
              "quotesingle",
              39,
              "quotesinglemonospace",
              65287,
              "r",
              114,
              "raarmenian",
              1404,
              "rabengali",
              2480,
              "racute",
              341,
              "radeva",
              2352,
              "radical",
              8730,
              "radicalex",
              63717,
              "radoverssquare",
              13230,
              "radoverssquaredsquare",
              13231,
              "radsquare",
              13229,
              "rafe",
              1471,
              "rafehebrew",
              1471,
              "ragujarati",
              2736,
              "ragurmukhi",
              2608,
              "rahiragana",
              12425,
              "rakatakana",
              12521,
              "rakatakanahalfwidth",
              65431,
              "ralowerdiagonalbengali",
              2545,
              "ramiddlediagonalbengali",
              2544,
              "ramshorn",
              612,
              "ratio",
              8758,
              "rbopomofo",
              12566,
              "rcaron",
              345,
              "rcedilla",
              343,
              "rcircle",
              9441,
              "rcommaaccent",
              343,
              "rdblgrave",
              529,
              "rdotaccent",
              7769,
              "rdotbelow",
              7771,
              "rdotbelowmacron",
              7773,
              "referencemark",
              8251,
              "reflexsubset",
              8838,
              "reflexsuperset",
              8839,
              "registered",
              174,
              "registersans",
              63720,
              "registerserif",
              63194,
              "reharabic",
              1585,
              "reharmenian",
              1408,
              "rehfinalarabic",
              65198,
              "rehiragana",
              12428,
              "rekatakana",
              12524,
              "rekatakanahalfwidth",
              65434,
              "resh",
              1512,
              "reshdageshhebrew",
              64328,
              "reshhebrew",
              1512,
              "reversedtilde",
              8765,
              "reviahebrew",
              1431,
              "reviamugrashhebrew",
              1431,
              "revlogicalnot",
              8976,
              "rfishhook",
              638,
              "rfishhookreversed",
              639,
              "rhabengali",
              2525,
              "rhadeva",
              2397,
              "rho",
              961,
              "rhook",
              637,
              "rhookturned",
              635,
              "rhookturnedsuperior",
              693,
              "rhosymbolgreek",
              1009,
              "rhotichookmod",
              734,
              "rieulacirclekorean",
              12913,
              "rieulaparenkorean",
              12817,
              "rieulcirclekorean",
              12899,
              "rieulhieuhkorean",
              12608,
              "rieulkiyeokkorean",
              12602,
              "rieulkiyeoksioskorean",
              12649,
              "rieulkorean",
              12601,
              "rieulmieumkorean",
              12603,
              "rieulpansioskorean",
              12652,
              "rieulparenkorean",
              12803,
              "rieulphieuphkorean",
              12607,
              "rieulpieupkorean",
              12604,
              "rieulpieupsioskorean",
              12651,
              "rieulsioskorean",
              12605,
              "rieulthieuthkorean",
              12606,
              "rieultikeutkorean",
              12650,
              "rieulyeorinhieuhkorean",
              12653,
              "rightangle",
              8735,
              "righttackbelowcmb",
              793,
              "righttriangle",
              8895,
              "rihiragana",
              12426,
              "rikatakana",
              12522,
              "rikatakanahalfwidth",
              65432,
              "ring",
              730,
              "ringbelowcmb",
              805,
              "ringcmb",
              778,
              "ringhalfleft",
              703,
              "ringhalfleftarmenian",
              1369,
              "ringhalfleftbelowcmb",
              796,
              "ringhalfleftcentered",
              723,
              "ringhalfright",
              702,
              "ringhalfrightbelowcmb",
              825,
              "ringhalfrightcentered",
              722,
              "rinvertedbreve",
              531,
              "rittorusquare",
              13137,
              "rlinebelow",
              7775,
              "rlongleg",
              636,
              "rlonglegturned",
              634,
              "rmonospace",
              65362,
              "rohiragana",
              12429,
              "rokatakana",
              12525,
              "rokatakanahalfwidth",
              65435,
              "roruathai",
              3619,
              "rparen",
              9389,
              "rrabengali",
              2524,
              "rradeva",
              2353,
              "rragurmukhi",
              2652,
              "rreharabic",
              1681,
              "rrehfinalarabic",
              64397,
              "rrvocalicbengali",
              2528,
              "rrvocalicdeva",
              2400,
              "rrvocalicgujarati",
              2784,
              "rrvocalicvowelsignbengali",
              2500,
              "rrvocalicvowelsigndeva",
              2372,
              "rrvocalicvowelsigngujarati",
              2756,
              "rsuperior",
              63217,
              "rtblock",
              9616,
              "rturned",
              633,
              "rturnedsuperior",
              692,
              "ruhiragana",
              12427,
              "rukatakana",
              12523,
              "rukatakanahalfwidth",
              65433,
              "rupeemarkbengali",
              2546,
              "rupeesignbengali",
              2547,
              "rupiah",
              63197,
              "ruthai",
              3620,
              "rvocalicbengali",
              2443,
              "rvocalicdeva",
              2315,
              "rvocalicgujarati",
              2699,
              "rvocalicvowelsignbengali",
              2499,
              "rvocalicvowelsigndeva",
              2371,
              "rvocalicvowelsigngujarati",
              2755,
              "s",
              115,
              "sabengali",
              2488,
              "sacute",
              347,
              "sacutedotaccent",
              7781,
              "sadarabic",
              1589,
              "sadeva",
              2360,
              "sadfinalarabic",
              65210,
              "sadinitialarabic",
              65211,
              "sadmedialarabic",
              65212,
              "sagujarati",
              2744,
              "sagurmukhi",
              2616,
              "sahiragana",
              12373,
              "sakatakana",
              12469,
              "sakatakanahalfwidth",
              65403,
              "sallallahoualayhewasallamarabic",
              65018,
              "samekh",
              1505,
              "samekhdagesh",
              64321,
              "samekhdageshhebrew",
              64321,
              "samekhhebrew",
              1505,
              "saraaathai",
              3634,
              "saraaethai",
              3649,
              "saraaimaimalaithai",
              3652,
              "saraaimaimuanthai",
              3651,
              "saraamthai",
              3635,
              "saraathai",
              3632,
              "saraethai",
              3648,
              "saraiileftthai",
              63622,
              "saraiithai",
              3637,
              "saraileftthai",
              63621,
              "saraithai",
              3636,
              "saraothai",
              3650,
              "saraueeleftthai",
              63624,
              "saraueethai",
              3639,
              "saraueleftthai",
              63623,
              "sarauethai",
              3638,
              "sarauthai",
              3640,
              "sarauuthai",
              3641,
              "sbopomofo",
              12569,
              "scaron",
              353,
              "scarondotaccent",
              7783,
              "scedilla",
              351,
              "schwa",
              601,
              "schwacyrillic",
              1241,
              "schwadieresiscyrillic",
              1243,
              "schwahook",
              602,
              "scircle",
              9442,
              "scircumflex",
              349,
              "scommaaccent",
              537,
              "sdotaccent",
              7777,
              "sdotbelow",
              7779,
              "sdotbelowdotaccent",
              7785,
              "seagullbelowcmb",
              828,
              "second",
              8243,
              "secondtonechinese",
              714,
              "section",
              167,
              "seenarabic",
              1587,
              "seenfinalarabic",
              65202,
              "seeninitialarabic",
              65203,
              "seenmedialarabic",
              65204,
              "segol",
              1462,
              "segol13",
              1462,
              "segol1f",
              1462,
              "segol2c",
              1462,
              "segolhebrew",
              1462,
              "segolnarrowhebrew",
              1462,
              "segolquarterhebrew",
              1462,
              "segoltahebrew",
              1426,
              "segolwidehebrew",
              1462,
              "seharmenian",
              1405,
              "sehiragana",
              12379,
              "sekatakana",
              12475,
              "sekatakanahalfwidth",
              65406,
              "semicolon",
              59,
              "semicolonarabic",
              1563,
              "semicolonmonospace",
              65307,
              "semicolonsmall",
              65108,
              "semivoicedmarkkana",
              12444,
              "semivoicedmarkkanahalfwidth",
              65439,
              "sentisquare",
              13090,
              "sentosquare",
              13091,
              "seven",
              55,
              "sevenarabic",
              1639,
              "sevenbengali",
              2541,
              "sevencircle",
              9318,
              "sevencircleinversesansserif",
              10128,
              "sevendeva",
              2413,
              "seveneighths",
              8542,
              "sevengujarati",
              2797,
              "sevengurmukhi",
              2669,
              "sevenhackarabic",
              1639,
              "sevenhangzhou",
              12327,
              "sevenideographicparen",
              12838,
              "seveninferior",
              8327,
              "sevenmonospace",
              65303,
              "sevenoldstyle",
              63287,
              "sevenparen",
              9338,
              "sevenperiod",
              9358,
              "sevenpersian",
              1783,
              "sevenroman",
              8566,
              "sevensuperior",
              8311,
              "seventeencircle",
              9328,
              "seventeenparen",
              9348,
              "seventeenperiod",
              9368,
              "seventhai",
              3671,
              "sfthyphen",
              173,
              "shaarmenian",
              1399,
              "shabengali",
              2486,
              "shacyrillic",
              1096,
              "shaddaarabic",
              1617,
              "shaddadammaarabic",
              64609,
              "shaddadammatanarabic",
              64606,
              "shaddafathaarabic",
              64608,
              "shaddakasraarabic",
              64610,
              "shaddakasratanarabic",
              64607,
              "shade",
              9618,
              "shadedark",
              9619,
              "shadelight",
              9617,
              "shademedium",
              9618,
              "shadeva",
              2358,
              "shagujarati",
              2742,
              "shagurmukhi",
              2614,
              "shalshelethebrew",
              1427,
              "shbopomofo",
              12565,
              "shchacyrillic",
              1097,
              "sheenarabic",
              1588,
              "sheenfinalarabic",
              65206,
              "sheeninitialarabic",
              65207,
              "sheenmedialarabic",
              65208,
              "sheicoptic",
              995,
              "sheqel",
              8362,
              "sheqelhebrew",
              8362,
              "sheva",
              1456,
              "sheva115",
              1456,
              "sheva15",
              1456,
              "sheva22",
              1456,
              "sheva2e",
              1456,
              "shevahebrew",
              1456,
              "shevanarrowhebrew",
              1456,
              "shevaquarterhebrew",
              1456,
              "shevawidehebrew",
              1456,
              "shhacyrillic",
              1211,
              "shimacoptic",
              1005,
              "shin",
              1513,
              "shindagesh",
              64329,
              "shindageshhebrew",
              64329,
              "shindageshshindot",
              64300,
              "shindageshshindothebrew",
              64300,
              "shindageshsindot",
              64301,
              "shindageshsindothebrew",
              64301,
              "shindothebrew",
              1473,
              "shinhebrew",
              1513,
              "shinshindot",
              64298,
              "shinshindothebrew",
              64298,
              "shinsindot",
              64299,
              "shinsindothebrew",
              64299,
              "shook",
              642,
              "sigma",
              963,
              "sigma1",
              962,
              "sigmafinal",
              962,
              "sigmalunatesymbolgreek",
              1010,
              "sihiragana",
              12375,
              "sikatakana",
              12471,
              "sikatakanahalfwidth",
              65404,
              "siluqhebrew",
              1469,
              "siluqlefthebrew",
              1469,
              "similar",
              8764,
              "sindothebrew",
              1474,
              "siosacirclekorean",
              12916,
              "siosaparenkorean",
              12820,
              "sioscieuckorean",
              12670,
              "sioscirclekorean",
              12902,
              "sioskiyeokkorean",
              12666,
              "sioskorean",
              12613,
              "siosnieunkorean",
              12667,
              "siosparenkorean",
              12806,
              "siospieupkorean",
              12669,
              "siostikeutkorean",
              12668,
              "six",
              54,
              "sixarabic",
              1638,
              "sixbengali",
              2540,
              "sixcircle",
              9317,
              "sixcircleinversesansserif",
              10127,
              "sixdeva",
              2412,
              "sixgujarati",
              2796,
              "sixgurmukhi",
              2668,
              "sixhackarabic",
              1638,
              "sixhangzhou",
              12326,
              "sixideographicparen",
              12837,
              "sixinferior",
              8326,
              "sixmonospace",
              65302,
              "sixoldstyle",
              63286,
              "sixparen",
              9337,
              "sixperiod",
              9357,
              "sixpersian",
              1782,
              "sixroman",
              8565,
              "sixsuperior",
              8310,
              "sixteencircle",
              9327,
              "sixteencurrencydenominatorbengali",
              2553,
              "sixteenparen",
              9347,
              "sixteenperiod",
              9367,
              "sixthai",
              3670,
              "slash",
              47,
              "slashmonospace",
              65295,
              "slong",
              383,
              "slongdotaccent",
              7835,
              "smileface",
              9786,
              "smonospace",
              65363,
              "sofpasuqhebrew",
              1475,
              "softhyphen",
              173,
              "softsigncyrillic",
              1100,
              "sohiragana",
              12381,
              "sokatakana",
              12477,
              "sokatakanahalfwidth",
              65407,
              "soliduslongoverlaycmb",
              824,
              "solidusshortoverlaycmb",
              823,
              "sorusithai",
              3625,
              "sosalathai",
              3624,
              "sosothai",
              3595,
              "sosuathai",
              3626,
              "space",
              32,
              "spacehackarabic",
              32,
              "spade",
              9824,
              "spadesuitblack",
              9824,
              "spadesuitwhite",
              9828,
              "sparen",
              9390,
              "squarebelowcmb",
              827,
              "squarecc",
              13252,
              "squarecm",
              13213,
              "squarediagonalcrosshatchfill",
              9641,
              "squarehorizontalfill",
              9636,
              "squarekg",
              13199,
              "squarekm",
              13214,
              "squarekmcapital",
              13262,
              "squareln",
              13265,
              "squarelog",
              13266,
              "squaremg",
              13198,
              "squaremil",
              13269,
              "squaremm",
              13212,
              "squaremsquared",
              13217,
              "squareorthogonalcrosshatchfill",
              9638,
              "squareupperlefttolowerrightfill",
              9639,
              "squareupperrighttolowerleftfill",
              9640,
              "squareverticalfill",
              9637,
              "squarewhitewithsmallblack",
              9635,
              "srsquare",
              13275,
              "ssabengali",
              2487,
              "ssadeva",
              2359,
              "ssagujarati",
              2743,
              "ssangcieuckorean",
              12617,
              "ssanghieuhkorean",
              12677,
              "ssangieungkorean",
              12672,
              "ssangkiyeokkorean",
              12594,
              "ssangnieunkorean",
              12645,
              "ssangpieupkorean",
              12611,
              "ssangsioskorean",
              12614,
              "ssangtikeutkorean",
              12600,
              "ssuperior",
              63218,
              "sterling",
              163,
              "sterlingmonospace",
              65505,
              "strokelongoverlaycmb",
              822,
              "strokeshortoverlaycmb",
              821,
              "subset",
              8834,
              "subsetnotequal",
              8842,
              "subsetorequal",
              8838,
              "succeeds",
              8827,
              "suchthat",
              8715,
              "suhiragana",
              12377,
              "sukatakana",
              12473,
              "sukatakanahalfwidth",
              65405,
              "sukunarabic",
              1618,
              "summation",
              8721,
              "sun",
              9788,
              "superset",
              8835,
              "supersetnotequal",
              8843,
              "supersetorequal",
              8839,
              "svsquare",
              13276,
              "syouwaerasquare",
              13180,
              "t",
              116,
              "tabengali",
              2468,
              "tackdown",
              8868,
              "tackleft",
              8867,
              "tadeva",
              2340,
              "tagujarati",
              2724,
              "tagurmukhi",
              2596,
              "taharabic",
              1591,
              "tahfinalarabic",
              65218,
              "tahinitialarabic",
              65219,
              "tahiragana",
              12383,
              "tahmedialarabic",
              65220,
              "taisyouerasquare",
              13181,
              "takatakana",
              12479,
              "takatakanahalfwidth",
              65408,
              "tatweelarabic",
              1600,
              "tau",
              964,
              "tav",
              1514,
              "tavdages",
              64330,
              "tavdagesh",
              64330,
              "tavdageshhebrew",
              64330,
              "tavhebrew",
              1514,
              "tbar",
              359,
              "tbopomofo",
              12554,
              "tcaron",
              357,
              "tccurl",
              680,
              "tcedilla",
              355,
              "tcheharabic",
              1670,
              "tchehfinalarabic",
              64379,
              "tchehinitialarabic",
              64380,
              "tchehmedialarabic",
              64381,
              "tcircle",
              9443,
              "tcircumflexbelow",
              7793,
              "tcommaaccent",
              355,
              "tdieresis",
              7831,
              "tdotaccent",
              7787,
              "tdotbelow",
              7789,
              "tecyrillic",
              1090,
              "tedescendercyrillic",
              1197,
              "teharabic",
              1578,
              "tehfinalarabic",
              65174,
              "tehhahinitialarabic",
              64674,
              "tehhahisolatedarabic",
              64524,
              "tehinitialarabic",
              65175,
              "tehiragana",
              12390,
              "tehjeeminitialarabic",
              64673,
              "tehjeemisolatedarabic",
              64523,
              "tehmarbutaarabic",
              1577,
              "tehmarbutafinalarabic",
              65172,
              "tehmedialarabic",
              65176,
              "tehmeeminitialarabic",
              64676,
              "tehmeemisolatedarabic",
              64526,
              "tehnoonfinalarabic",
              64627,
              "tekatakana",
              12486,
              "tekatakanahalfwidth",
              65411,
              "telephone",
              8481,
              "telephoneblack",
              9742,
              "telishagedolahebrew",
              1440,
              "telishaqetanahebrew",
              1449,
              "tencircle",
              9321,
              "tenideographicparen",
              12841,
              "tenparen",
              9341,
              "tenperiod",
              9361,
              "tenroman",
              8569,
              "tesh",
              679,
              "tet",
              1496,
              "tetdagesh",
              64312,
              "tetdageshhebrew",
              64312,
              "tethebrew",
              1496,
              "tetsecyrillic",
              1205,
              "tevirhebrew",
              1435,
              "tevirlefthebrew",
              1435,
              "thabengali",
              2469,
              "thadeva",
              2341,
              "thagujarati",
              2725,
              "thagurmukhi",
              2597,
              "thalarabic",
              1584,
              "thalfinalarabic",
              65196,
              "thanthakhatlowleftthai",
              63640,
              "thanthakhatlowrightthai",
              63639,
              "thanthakhatthai",
              3660,
              "thanthakhatupperleftthai",
              63638,
              "theharabic",
              1579,
              "thehfinalarabic",
              65178,
              "thehinitialarabic",
              65179,
              "thehmedialarabic",
              65180,
              "thereexists",
              8707,
              "therefore",
              8756,
              "theta",
              952,
              "theta1",
              977,
              "thetasymbolgreek",
              977,
              "thieuthacirclekorean",
              12921,
              "thieuthaparenkorean",
              12825,
              "thieuthcirclekorean",
              12907,
              "thieuthkorean",
              12620,
              "thieuthparenkorean",
              12811,
              "thirteencircle",
              9324,
              "thirteenparen",
              9344,
              "thirteenperiod",
              9364,
              "thonangmonthothai",
              3601,
              "thook",
              429,
              "thophuthaothai",
              3602,
              "thorn",
              254,
              "thothahanthai",
              3607,
              "thothanthai",
              3600,
              "thothongthai",
              3608,
              "thothungthai",
              3606,
              "thousandcyrillic",
              1154,
              "thousandsseparatorarabic",
              1644,
              "thousandsseparatorpersian",
              1644,
              "three",
              51,
              "threearabic",
              1635,
              "threebengali",
              2537,
              "threecircle",
              9314,
              "threecircleinversesansserif",
              10124,
              "threedeva",
              2409,
              "threeeighths",
              8540,
              "threegujarati",
              2793,
              "threegurmukhi",
              2665,
              "threehackarabic",
              1635,
              "threehangzhou",
              12323,
              "threeideographicparen",
              12834,
              "threeinferior",
              8323,
              "threemonospace",
              65299,
              "threenumeratorbengali",
              2550,
              "threeoldstyle",
              63283,
              "threeparen",
              9334,
              "threeperiod",
              9354,
              "threepersian",
              1779,
              "threequarters",
              190,
              "threequartersemdash",
              63198,
              "threeroman",
              8562,
              "threesuperior",
              179,
              "threethai",
              3667,
              "thzsquare",
              13204,
              "tihiragana",
              12385,
              "tikatakana",
              12481,
              "tikatakanahalfwidth",
              65409,
              "tikeutacirclekorean",
              12912,
              "tikeutaparenkorean",
              12816,
              "tikeutcirclekorean",
              12898,
              "tikeutkorean",
              12599,
              "tikeutparenkorean",
              12802,
              "tilde",
              732,
              "tildebelowcmb",
              816,
              "tildecmb",
              771,
              "tildecomb",
              771,
              "tildedoublecmb",
              864,
              "tildeoperator",
              8764,
              "tildeoverlaycmb",
              820,
              "tildeverticalcmb",
              830,
              "timescircle",
              8855,
              "tipehahebrew",
              1430,
              "tipehalefthebrew",
              1430,
              "tippigurmukhi",
              2672,
              "titlocyrilliccmb",
              1155,
              "tiwnarmenian",
              1407,
              "tlinebelow",
              7791,
              "tmonospace",
              65364,
              "toarmenian",
              1385,
              "tohiragana",
              12392,
              "tokatakana",
              12488,
              "tokatakanahalfwidth",
              65412,
              "tonebarextrahighmod",
              741,
              "tonebarextralowmod",
              745,
              "tonebarhighmod",
              742,
              "tonebarlowmod",
              744,
              "tonebarmidmod",
              743,
              "tonefive",
              445,
              "tonesix",
              389,
              "tonetwo",
              424,
              "tonos",
              900,
              "tonsquare",
              13095,
              "topatakthai",
              3599,
              "tortoiseshellbracketleft",
              12308,
              "tortoiseshellbracketleftsmall",
              65117,
              "tortoiseshellbracketleftvertical",
              65081,
              "tortoiseshellbracketright",
              12309,
              "tortoiseshellbracketrightsmall",
              65118,
              "tortoiseshellbracketrightvertical",
              65082,
              "totaothai",
              3605,
              "tpalatalhook",
              427,
              "tparen",
              9391,
              "trademark",
              8482,
              "trademarksans",
              63722,
              "trademarkserif",
              63195,
              "tretroflexhook",
              648,
              "triagdn",
              9660,
              "triaglf",
              9668,
              "triagrt",
              9658,
              "triagup",
              9650,
              "ts",
              678,
              "tsadi",
              1510,
              "tsadidagesh",
              64326,
              "tsadidageshhebrew",
              64326,
              "tsadihebrew",
              1510,
              "tsecyrillic",
              1094,
              "tsere",
              1461,
              "tsere12",
              1461,
              "tsere1e",
              1461,
              "tsere2b",
              1461,
              "tserehebrew",
              1461,
              "tserenarrowhebrew",
              1461,
              "tserequarterhebrew",
              1461,
              "tserewidehebrew",
              1461,
              "tshecyrillic",
              1115,
              "tsuperior",
              63219,
              "ttabengali",
              2463,
              "ttadeva",
              2335,
              "ttagujarati",
              2719,
              "ttagurmukhi",
              2591,
              "tteharabic",
              1657,
              "ttehfinalarabic",
              64359,
              "ttehinitialarabic",
              64360,
              "ttehmedialarabic",
              64361,
              "tthabengali",
              2464,
              "tthadeva",
              2336,
              "tthagujarati",
              2720,
              "tthagurmukhi",
              2592,
              "tturned",
              647,
              "tuhiragana",
              12388,
              "tukatakana",
              12484,
              "tukatakanahalfwidth",
              65410,
              "tusmallhiragana",
              12387,
              "tusmallkatakana",
              12483,
              "tusmallkatakanahalfwidth",
              65391,
              "twelvecircle",
              9323,
              "twelveparen",
              9343,
              "twelveperiod",
              9363,
              "twelveroman",
              8571,
              "twentycircle",
              9331,
              "twentyhangzhou",
              21316,
              "twentyparen",
              9351,
              "twentyperiod",
              9371,
              "two",
              50,
              "twoarabic",
              1634,
              "twobengali",
              2536,
              "twocircle",
              9313,
              "twocircleinversesansserif",
              10123,
              "twodeva",
              2408,
              "twodotenleader",
              8229,
              "twodotleader",
              8229,
              "twodotleadervertical",
              65072,
              "twogujarati",
              2792,
              "twogurmukhi",
              2664,
              "twohackarabic",
              1634,
              "twohangzhou",
              12322,
              "twoideographicparen",
              12833,
              "twoinferior",
              8322,
              "twomonospace",
              65298,
              "twonumeratorbengali",
              2549,
              "twooldstyle",
              63282,
              "twoparen",
              9333,
              "twoperiod",
              9353,
              "twopersian",
              1778,
              "tworoman",
              8561,
              "twostroke",
              443,
              "twosuperior",
              178,
              "twothai",
              3666,
              "twothirds",
              8532,
              "u",
              117,
              "uacute",
              250,
              "ubar",
              649,
              "ubengali",
              2441,
              "ubopomofo",
              12584,
              "ubreve",
              365,
              "ucaron",
              468,
              "ucircle",
              9444,
              "ucircumflex",
              251,
              "ucircumflexbelow",
              7799,
              "ucyrillic",
              1091,
              "udattadeva",
              2385,
              "udblacute",
              369,
              "udblgrave",
              533,
              "udeva",
              2313,
              "udieresis",
              252,
              "udieresisacute",
              472,
              "udieresisbelow",
              7795,
              "udieresiscaron",
              474,
              "udieresiscyrillic",
              1265,
              "udieresisgrave",
              476,
              "udieresismacron",
              470,
              "udotbelow",
              7909,
              "ugrave",
              249,
              "ugujarati",
              2697,
              "ugurmukhi",
              2569,
              "uhiragana",
              12358,
              "uhookabove",
              7911,
              "uhorn",
              432,
              "uhornacute",
              7913,
              "uhorndotbelow",
              7921,
              "uhorngrave",
              7915,
              "uhornhookabove",
              7917,
              "uhorntilde",
              7919,
              "uhungarumlaut",
              369,
              "uhungarumlautcyrillic",
              1267,
              "uinvertedbreve",
              535,
              "ukatakana",
              12454,
              "ukatakanahalfwidth",
              65395,
              "ukcyrillic",
              1145,
              "ukorean",
              12636,
              "umacron",
              363,
              "umacroncyrillic",
              1263,
              "umacrondieresis",
              7803,
              "umatragurmukhi",
              2625,
              "umonospace",
              65365,
              "underscore",
              95,
              "underscoredbl",
              8215,
              "underscoremonospace",
              65343,
              "underscorevertical",
              65075,
              "underscorewavy",
              65103,
              "union",
              8746,
              "universal",
              8704,
              "uogonek",
              371,
              "uparen",
              9392,
              "upblock",
              9600,
              "upperdothebrew",
              1476,
              "upsilon",
              965,
              "upsilondieresis",
              971,
              "upsilondieresistonos",
              944,
              "upsilonlatin",
              650,
              "upsilontonos",
              973,
              "uptackbelowcmb",
              797,
              "uptackmod",
              724,
              "uragurmukhi",
              2675,
              "uring",
              367,
              "ushortcyrillic",
              1118,
              "usmallhiragana",
              12357,
              "usmallkatakana",
              12453,
              "usmallkatakanahalfwidth",
              65385,
              "ustraightcyrillic",
              1199,
              "ustraightstrokecyrillic",
              1201,
              "utilde",
              361,
              "utildeacute",
              7801,
              "utildebelow",
              7797,
              "uubengali",
              2442,
              "uudeva",
              2314,
              "uugujarati",
              2698,
              "uugurmukhi",
              2570,
              "uumatragurmukhi",
              2626,
              "uuvowelsignbengali",
              2498,
              "uuvowelsigndeva",
              2370,
              "uuvowelsigngujarati",
              2754,
              "uvowelsignbengali",
              2497,
              "uvowelsigndeva",
              2369,
              "uvowelsigngujarati",
              2753,
              "v",
              118,
              "vadeva",
              2357,
              "vagujarati",
              2741,
              "vagurmukhi",
              2613,
              "vakatakana",
              12535,
              "vav",
              1493,
              "vavdagesh",
              64309,
              "vavdagesh65",
              64309,
              "vavdageshhebrew",
              64309,
              "vavhebrew",
              1493,
              "vavholam",
              64331,
              "vavholamhebrew",
              64331,
              "vavvavhebrew",
              1520,
              "vavyodhebrew",
              1521,
              "vcircle",
              9445,
              "vdotbelow",
              7807,
              "vecyrillic",
              1074,
              "veharabic",
              1700,
              "vehfinalarabic",
              64363,
              "vehinitialarabic",
              64364,
              "vehmedialarabic",
              64365,
              "vekatakana",
              12537,
              "venus",
              9792,
              "verticalbar",
              124,
              "verticallineabovecmb",
              781,
              "verticallinebelowcmb",
              809,
              "verticallinelowmod",
              716,
              "verticallinemod",
              712,
              "vewarmenian",
              1406,
              "vhook",
              651,
              "vikatakana",
              12536,
              "viramabengali",
              2509,
              "viramadeva",
              2381,
              "viramagujarati",
              2765,
              "visargabengali",
              2435,
              "visargadeva",
              2307,
              "visargagujarati",
              2691,
              "vmonospace",
              65366,
              "voarmenian",
              1400,
              "voicediterationhiragana",
              12446,
              "voicediterationkatakana",
              12542,
              "voicedmarkkana",
              12443,
              "voicedmarkkanahalfwidth",
              65438,
              "vokatakana",
              12538,
              "vparen",
              9393,
              "vtilde",
              7805,
              "vturned",
              652,
              "vuhiragana",
              12436,
              "vukatakana",
              12532,
              "w",
              119,
              "wacute",
              7811,
              "waekorean",
              12633,
              "wahiragana",
              12431,
              "wakatakana",
              12527,
              "wakatakanahalfwidth",
              65436,
              "wakorean",
              12632,
              "wasmallhiragana",
              12430,
              "wasmallkatakana",
              12526,
              "wattosquare",
              13143,
              "wavedash",
              12316,
              "wavyunderscorevertical",
              65076,
              "wawarabic",
              1608,
              "wawfinalarabic",
              65262,
              "wawhamzaabovearabic",
              1572,
              "wawhamzaabovefinalarabic",
              65158,
              "wbsquare",
              13277,
              "wcircle",
              9446,
              "wcircumflex",
              373,
              "wdieresis",
              7813,
              "wdotaccent",
              7815,
              "wdotbelow",
              7817,
              "wehiragana",
              12433,
              "weierstrass",
              8472,
              "wekatakana",
              12529,
              "wekorean",
              12638,
              "weokorean",
              12637,
              "wgrave",
              7809,
              "whitebullet",
              9702,
              "whitecircle",
              9675,
              "whitecircleinverse",
              9689,
              "whitecornerbracketleft",
              12302,
              "whitecornerbracketleftvertical",
              65091,
              "whitecornerbracketright",
              12303,
              "whitecornerbracketrightvertical",
              65092,
              "whitediamond",
              9671,
              "whitediamondcontainingblacksmalldiamond",
              9672,
              "whitedownpointingsmalltriangle",
              9663,
              "whitedownpointingtriangle",
              9661,
              "whiteleftpointingsmalltriangle",
              9667,
              "whiteleftpointingtriangle",
              9665,
              "whitelenticularbracketleft",
              12310,
              "whitelenticularbracketright",
              12311,
              "whiterightpointingsmalltriangle",
              9657,
              "whiterightpointingtriangle",
              9655,
              "whitesmallsquare",
              9643,
              "whitesmilingface",
              9786,
              "whitesquare",
              9633,
              "whitestar",
              9734,
              "whitetelephone",
              9743,
              "whitetortoiseshellbracketleft",
              12312,
              "whitetortoiseshellbracketright",
              12313,
              "whiteuppointingsmalltriangle",
              9653,
              "whiteuppointingtriangle",
              9651,
              "wihiragana",
              12432,
              "wikatakana",
              12528,
              "wikorean",
              12639,
              "wmonospace",
              65367,
              "wohiragana",
              12434,
              "wokatakana",
              12530,
              "wokatakanahalfwidth",
              65382,
              "won",
              8361,
              "wonmonospace",
              65510,
              "wowaenthai",
              3623,
              "wparen",
              9394,
              "wring",
              7832,
              "wsuperior",
              695,
              "wturned",
              653,
              "wynn",
              447,
              "x",
              120,
              "xabovecmb",
              829,
              "xbopomofo",
              12562,
              "xcircle",
              9447,
              "xdieresis",
              7821,
              "xdotaccent",
              7819,
              "xeharmenian",
              1389,
              "xi",
              958,
              "xmonospace",
              65368,
              "xparen",
              9395,
              "xsuperior",
              739,
              "y",
              121,
              "yaadosquare",
              13134,
              "yabengali",
              2479,
              "yacute",
              253,
              "yadeva",
              2351,
              "yaekorean",
              12626,
              "yagujarati",
              2735,
              "yagurmukhi",
              2607,
              "yahiragana",
              12420,
              "yakatakana",
              12516,
              "yakatakanahalfwidth",
              65428,
              "yakorean",
              12625,
              "yamakkanthai",
              3662,
              "yasmallhiragana",
              12419,
              "yasmallkatakana",
              12515,
              "yasmallkatakanahalfwidth",
              65388,
              "yatcyrillic",
              1123,
              "ycircle",
              9448,
              "ycircumflex",
              375,
              "ydieresis",
              255,
              "ydotaccent",
              7823,
              "ydotbelow",
              7925,
              "yeharabic",
              1610,
              "yehbarreearabic",
              1746,
              "yehbarreefinalarabic",
              64431,
              "yehfinalarabic",
              65266,
              "yehhamzaabovearabic",
              1574,
              "yehhamzaabovefinalarabic",
              65162,
              "yehhamzaaboveinitialarabic",
              65163,
              "yehhamzaabovemedialarabic",
              65164,
              "yehinitialarabic",
              65267,
              "yehmedialarabic",
              65268,
              "yehmeeminitialarabic",
              64733,
              "yehmeemisolatedarabic",
              64600,
              "yehnoonfinalarabic",
              64660,
              "yehthreedotsbelowarabic",
              1745,
              "yekorean",
              12630,
              "yen",
              165,
              "yenmonospace",
              65509,
              "yeokorean",
              12629,
              "yeorinhieuhkorean",
              12678,
              "yerahbenyomohebrew",
              1450,
              "yerahbenyomolefthebrew",
              1450,
              "yericyrillic",
              1099,
              "yerudieresiscyrillic",
              1273,
              "yesieungkorean",
              12673,
              "yesieungpansioskorean",
              12675,
              "yesieungsioskorean",
              12674,
              "yetivhebrew",
              1434,
              "ygrave",
              7923,
              "yhook",
              436,
              "yhookabove",
              7927,
              "yiarmenian",
              1397,
              "yicyrillic",
              1111,
              "yikorean",
              12642,
              "yinyang",
              9775,
              "yiwnarmenian",
              1410,
              "ymonospace",
              65369,
              "yod",
              1497,
              "yoddagesh",
              64313,
              "yoddageshhebrew",
              64313,
              "yodhebrew",
              1497,
              "yodyodhebrew",
              1522,
              "yodyodpatahhebrew",
              64287,
              "yohiragana",
              12424,
              "yoikorean",
              12681,
              "yokatakana",
              12520,
              "yokatakanahalfwidth",
              65430,
              "yokorean",
              12635,
              "yosmallhiragana",
              12423,
              "yosmallkatakana",
              12519,
              "yosmallkatakanahalfwidth",
              65390,
              "yotgreek",
              1011,
              "yoyaekorean",
              12680,
              "yoyakorean",
              12679,
              "yoyakthai",
              3618,
              "yoyingthai",
              3597,
              "yparen",
              9396,
              "ypogegrammeni",
              890,
              "ypogegrammenigreekcmb",
              837,
              "yr",
              422,
              "yring",
              7833,
              "ysuperior",
              696,
              "ytilde",
              7929,
              "yturned",
              654,
              "yuhiragana",
              12422,
              "yuikorean",
              12684,
              "yukatakana",
              12518,
              "yukatakanahalfwidth",
              65429,
              "yukorean",
              12640,
              "yusbigcyrillic",
              1131,
              "yusbigiotifiedcyrillic",
              1133,
              "yuslittlecyrillic",
              1127,
              "yuslittleiotifiedcyrillic",
              1129,
              "yusmallhiragana",
              12421,
              "yusmallkatakana",
              12517,
              "yusmallkatakanahalfwidth",
              65389,
              "yuyekorean",
              12683,
              "yuyeokorean",
              12682,
              "yyabengali",
              2527,
              "yyadeva",
              2399,
              "z",
              122,
              "zaarmenian",
              1382,
              "zacute",
              378,
              "zadeva",
              2395,
              "zagurmukhi",
              2651,
              "zaharabic",
              1592,
              "zahfinalarabic",
              65222,
              "zahinitialarabic",
              65223,
              "zahiragana",
              12374,
              "zahmedialarabic",
              65224,
              "zainarabic",
              1586,
              "zainfinalarabic",
              65200,
              "zakatakana",
              12470,
              "zaqefgadolhebrew",
              1429,
              "zaqefqatanhebrew",
              1428,
              "zarqahebrew",
              1432,
              "zayin",
              1494,
              "zayindagesh",
              64310,
              "zayindageshhebrew",
              64310,
              "zayinhebrew",
              1494,
              "zbopomofo",
              12567,
              "zcaron",
              382,
              "zcircle",
              9449,
              "zcircumflex",
              7825,
              "zcurl",
              657,
              "zdot",
              380,
              "zdotaccent",
              380,
              "zdotbelow",
              7827,
              "zecyrillic",
              1079,
              "zedescendercyrillic",
              1177,
              "zedieresiscyrillic",
              1247,
              "zehiragana",
              12380,
              "zekatakana",
              12476,
              "zero",
              48,
              "zeroarabic",
              1632,
              "zerobengali",
              2534,
              "zerodeva",
              2406,
              "zerogujarati",
              2790,
              "zerogurmukhi",
              2662,
              "zerohackarabic",
              1632,
              "zeroinferior",
              8320,
              "zeromonospace",
              65296,
              "zerooldstyle",
              63280,
              "zeropersian",
              1776,
              "zerosuperior",
              8304,
              "zerothai",
              3664,
              "zerowidthjoiner",
              65279,
              "zerowidthnonjoiner",
              8204,
              "zerowidthspace",
              8203,
              "zeta",
              950,
              "zhbopomofo",
              12563,
              "zhearmenian",
              1386,
              "zhebrevecyrillic",
              1218,
              "zhecyrillic",
              1078,
              "zhedescendercyrillic",
              1175,
              "zhedieresiscyrillic",
              1245,
              "zihiragana",
              12376,
              "zikatakana",
              12472,
              "zinorhebrew",
              1454,
              "zlinebelow",
              7829,
              "zmonospace",
              65370,
              "zohiragana",
              12382,
              "zokatakana",
              12478,
              "zparen",
              9397,
              "zretroflexhook",
              656,
              "zstroke",
              438,
              "zuhiragana",
              12378,
              "zukatakana",
              12474,
              ".notdef",
              0,
              "angbracketleftbig",
              9001,
              "angbracketleftBig",
              9001,
              "angbracketleftbigg",
              9001,
              "angbracketleftBigg",
              9001,
              "angbracketrightBig",
              9002,
              "angbracketrightbig",
              9002,
              "angbracketrightBigg",
              9002,
              "angbracketrightbigg",
              9002,
              "arrowhookleft",
              8618,
              "arrowhookright",
              8617,
              "arrowlefttophalf",
              8636,
              "arrowleftbothalf",
              8637,
              "arrownortheast",
              8599,
              "arrownorthwest",
              8598,
              "arrowrighttophalf",
              8640,
              "arrowrightbothalf",
              8641,
              "arrowsoutheast",
              8600,
              "arrowsouthwest",
              8601,
              "backslashbig",
              8726,
              "backslashBig",
              8726,
              "backslashBigg",
              8726,
              "backslashbigg",
              8726,
              "bardbl",
              8214,
              "bracehtipdownleft",
              65079,
              "bracehtipdownright",
              65079,
              "bracehtipupleft",
              65080,
              "bracehtipupright",
              65080,
              "braceleftBig",
              123,
              "braceleftbig",
              123,
              "braceleftbigg",
              123,
              "braceleftBigg",
              123,
              "bracerightBig",
              125,
              "bracerightbig",
              125,
              "bracerightbigg",
              125,
              "bracerightBigg",
              125,
              "bracketleftbig",
              91,
              "bracketleftBig",
              91,
              "bracketleftbigg",
              91,
              "bracketleftBigg",
              91,
              "bracketrightBig",
              93,
              "bracketrightbig",
              93,
              "bracketrightbigg",
              93,
              "bracketrightBigg",
              93,
              "ceilingleftbig",
              8968,
              "ceilingleftBig",
              8968,
              "ceilingleftBigg",
              8968,
              "ceilingleftbigg",
              8968,
              "ceilingrightbig",
              8969,
              "ceilingrightBig",
              8969,
              "ceilingrightbigg",
              8969,
              "ceilingrightBigg",
              8969,
              "circledotdisplay",
              8857,
              "circledottext",
              8857,
              "circlemultiplydisplay",
              8855,
              "circlemultiplytext",
              8855,
              "circleplusdisplay",
              8853,
              "circleplustext",
              8853,
              "contintegraldisplay",
              8750,
              "contintegraltext",
              8750,
              "coproductdisplay",
              8720,
              "coproducttext",
              8720,
              "floorleftBig",
              8970,
              "floorleftbig",
              8970,
              "floorleftbigg",
              8970,
              "floorleftBigg",
              8970,
              "floorrightbig",
              8971,
              "floorrightBig",
              8971,
              "floorrightBigg",
              8971,
              "floorrightbigg",
              8971,
              "hatwide",
              770,
              "hatwider",
              770,
              "hatwidest",
              770,
              "intercal",
              7488,
              "integraldisplay",
              8747,
              "integraltext",
              8747,
              "intersectiondisplay",
              8898,
              "intersectiontext",
              8898,
              "logicalanddisplay",
              8743,
              "logicalandtext",
              8743,
              "logicalordisplay",
              8744,
              "logicalortext",
              8744,
              "parenleftBig",
              40,
              "parenleftbig",
              40,
              "parenleftBigg",
              40,
              "parenleftbigg",
              40,
              "parenrightBig",
              41,
              "parenrightbig",
              41,
              "parenrightBigg",
              41,
              "parenrightbigg",
              41,
              "prime",
              8242,
              "productdisplay",
              8719,
              "producttext",
              8719,
              "radicalbig",
              8730,
              "radicalBig",
              8730,
              "radicalBigg",
              8730,
              "radicalbigg",
              8730,
              "radicalbt",
              8730,
              "radicaltp",
              8730,
              "radicalvertex",
              8730,
              "slashbig",
              47,
              "slashBig",
              47,
              "slashBigg",
              47,
              "slashbigg",
              47,
              "summationdisplay",
              8721,
              "summationtext",
              8721,
              "tildewide",
              732,
              "tildewider",
              732,
              "tildewidest",
              732,
              "uniondisplay",
              8899,
              "unionmultidisplay",
              8846,
              "unionmultitext",
              8846,
              "unionsqdisplay",
              8852,
              "unionsqtext",
              8852,
              "uniontext",
              8899,
              "vextenddouble",
              8741,
              "vextendsingle",
              8739
            ];
          }), v = (0, t.getArrayLookupTableFactory)(function() {
            return [
              "space",
              32,
              "a1",
              9985,
              "a2",
              9986,
              "a202",
              9987,
              "a3",
              9988,
              "a4",
              9742,
              "a5",
              9990,
              "a119",
              9991,
              "a118",
              9992,
              "a117",
              9993,
              "a11",
              9755,
              "a12",
              9758,
              "a13",
              9996,
              "a14",
              9997,
              "a15",
              9998,
              "a16",
              9999,
              "a105",
              1e4,
              "a17",
              10001,
              "a18",
              10002,
              "a19",
              10003,
              "a20",
              10004,
              "a21",
              10005,
              "a22",
              10006,
              "a23",
              10007,
              "a24",
              10008,
              "a25",
              10009,
              "a26",
              10010,
              "a27",
              10011,
              "a28",
              10012,
              "a6",
              10013,
              "a7",
              10014,
              "a8",
              10015,
              "a9",
              10016,
              "a10",
              10017,
              "a29",
              10018,
              "a30",
              10019,
              "a31",
              10020,
              "a32",
              10021,
              "a33",
              10022,
              "a34",
              10023,
              "a35",
              9733,
              "a36",
              10025,
              "a37",
              10026,
              "a38",
              10027,
              "a39",
              10028,
              "a40",
              10029,
              "a41",
              10030,
              "a42",
              10031,
              "a43",
              10032,
              "a44",
              10033,
              "a45",
              10034,
              "a46",
              10035,
              "a47",
              10036,
              "a48",
              10037,
              "a49",
              10038,
              "a50",
              10039,
              "a51",
              10040,
              "a52",
              10041,
              "a53",
              10042,
              "a54",
              10043,
              "a55",
              10044,
              "a56",
              10045,
              "a57",
              10046,
              "a58",
              10047,
              "a59",
              10048,
              "a60",
              10049,
              "a61",
              10050,
              "a62",
              10051,
              "a63",
              10052,
              "a64",
              10053,
              "a65",
              10054,
              "a66",
              10055,
              "a67",
              10056,
              "a68",
              10057,
              "a69",
              10058,
              "a70",
              10059,
              "a71",
              9679,
              "a72",
              10061,
              "a73",
              9632,
              "a74",
              10063,
              "a203",
              10064,
              "a75",
              10065,
              "a204",
              10066,
              "a76",
              9650,
              "a77",
              9660,
              "a78",
              9670,
              "a79",
              10070,
              "a81",
              9687,
              "a82",
              10072,
              "a83",
              10073,
              "a84",
              10074,
              "a97",
              10075,
              "a98",
              10076,
              "a99",
              10077,
              "a100",
              10078,
              "a101",
              10081,
              "a102",
              10082,
              "a103",
              10083,
              "a104",
              10084,
              "a106",
              10085,
              "a107",
              10086,
              "a108",
              10087,
              "a112",
              9827,
              "a111",
              9830,
              "a110",
              9829,
              "a109",
              9824,
              "a120",
              9312,
              "a121",
              9313,
              "a122",
              9314,
              "a123",
              9315,
              "a124",
              9316,
              "a125",
              9317,
              "a126",
              9318,
              "a127",
              9319,
              "a128",
              9320,
              "a129",
              9321,
              "a130",
              10102,
              "a131",
              10103,
              "a132",
              10104,
              "a133",
              10105,
              "a134",
              10106,
              "a135",
              10107,
              "a136",
              10108,
              "a137",
              10109,
              "a138",
              10110,
              "a139",
              10111,
              "a140",
              10112,
              "a141",
              10113,
              "a142",
              10114,
              "a143",
              10115,
              "a144",
              10116,
              "a145",
              10117,
              "a146",
              10118,
              "a147",
              10119,
              "a148",
              10120,
              "a149",
              10121,
              "a150",
              10122,
              "a151",
              10123,
              "a152",
              10124,
              "a153",
              10125,
              "a154",
              10126,
              "a155",
              10127,
              "a156",
              10128,
              "a157",
              10129,
              "a158",
              10130,
              "a159",
              10131,
              "a160",
              10132,
              "a161",
              8594,
              "a163",
              8596,
              "a164",
              8597,
              "a196",
              10136,
              "a165",
              10137,
              "a192",
              10138,
              "a166",
              10139,
              "a167",
              10140,
              "a168",
              10141,
              "a169",
              10142,
              "a170",
              10143,
              "a171",
              10144,
              "a172",
              10145,
              "a173",
              10146,
              "a162",
              10147,
              "a174",
              10148,
              "a175",
              10149,
              "a176",
              10150,
              "a177",
              10151,
              "a178",
              10152,
              "a179",
              10153,
              "a193",
              10154,
              "a180",
              10155,
              "a199",
              10156,
              "a181",
              10157,
              "a200",
              10158,
              "a182",
              10159,
              "a201",
              10161,
              "a183",
              10162,
              "a184",
              10163,
              "a197",
              10164,
              "a185",
              10165,
              "a194",
              10166,
              "a198",
              10167,
              "a186",
              10168,
              "a195",
              10169,
              "a187",
              10170,
              "a188",
              10171,
              "a189",
              10172,
              "a190",
              10173,
              "a191",
              10174,
              "a89",
              10088,
              "a90",
              10089,
              "a93",
              10090,
              "a94",
              10091,
              "a91",
              10092,
              "a92",
              10093,
              "a205",
              10094,
              "a85",
              10095,
              "a206",
              10096,
              "a86",
              10097,
              "a87",
              10098,
              "a88",
              10099,
              "a95",
              10100,
              "a96",
              10101,
              ".notdef",
              0
            ];
          });
        },
        /* 40 */
        /***/
        (J, o, F) => {
          F.r(o), F.d(o, {
            /* harmony export */
            clearUnicodeCaches: () => (
              /* binding */
              i
            ),
            /* harmony export */
            getCharUnicodeCategory: () => (
              /* binding */
              n
            ),
            /* harmony export */
            getNormalizedUnicodes: () => (
              /* binding */
              d
            ),
            /* harmony export */
            getUnicodeForGlyph: () => (
              /* binding */
              h
            ),
            /* harmony export */
            getUnicodeRangeFor: () => (
              /* binding */
              y
            ),
            /* harmony export */
            mapSpecialUnicodeValues: () => (
              /* binding */
              v
            ),
            /* harmony export */
            reverseIfRtl: () => (
              /* binding */
              m
            )
            /* harmony export */
          });
          var t = F(6);
          const a = (0, t.getLookupTableFactory)(function(l) {
            l[63721] = 169, l[63193] = 169, l[63720] = 174, l[63194] = 174, l[63722] = 8482, l[63195] = 8482, l[63729] = 9127, l[63730] = 9128, l[63731] = 9129, l[63740] = 9131, l[63741] = 9132, l[63742] = 9133, l[63726] = 9121, l[63727] = 9122, l[63728] = 9123, l[63737] = 9124, l[63738] = 9125, l[63739] = 9126, l[63723] = 9115, l[63724] = 9116, l[63725] = 9117, l[63734] = 9118, l[63735] = 9119, l[63736] = 9120;
          });
          function v(l) {
            return l >= 65520 && l <= 65535 ? 0 : l >= 62976 && l <= 63743 ? a()[l] || l : l === 173 ? 45 : l;
          }
          function h(l, u) {
            let w = u[l];
            if (w !== void 0)
              return w;
            if (!l)
              return -1;
            if (l[0] === "u") {
              const O = l.length;
              let b;
              if (O === 7 && l[1] === "n" && l[2] === "i")
                b = l.substring(3);
              else if (O >= 5 && O <= 7)
                b = l.substring(1);
              else
                return -1;
              if (b === b.toUpperCase() && (w = parseInt(b, 16), w >= 0))
                return w;
            }
            return -1;
          }
          const e = [
            {
              begin: 0,
              end: 127
            },
            {
              begin: 128,
              end: 255
            },
            {
              begin: 256,
              end: 383
            },
            {
              begin: 384,
              end: 591
            },
            {
              begin: 592,
              end: 687
            },
            {
              begin: 688,
              end: 767
            },
            {
              begin: 768,
              end: 879
            },
            {
              begin: 880,
              end: 1023
            },
            {
              begin: 11392,
              end: 11519
            },
            {
              begin: 1024,
              end: 1279
            },
            {
              begin: 1328,
              end: 1423
            },
            {
              begin: 1424,
              end: 1535
            },
            {
              begin: 42240,
              end: 42559
            },
            {
              begin: 1536,
              end: 1791
            },
            {
              begin: 1984,
              end: 2047
            },
            {
              begin: 2304,
              end: 2431
            },
            {
              begin: 2432,
              end: 2559
            },
            {
              begin: 2560,
              end: 2687
            },
            {
              begin: 2688,
              end: 2815
            },
            {
              begin: 2816,
              end: 2943
            },
            {
              begin: 2944,
              end: 3071
            },
            {
              begin: 3072,
              end: 3199
            },
            {
              begin: 3200,
              end: 3327
            },
            {
              begin: 3328,
              end: 3455
            },
            {
              begin: 3584,
              end: 3711
            },
            {
              begin: 3712,
              end: 3839
            },
            {
              begin: 4256,
              end: 4351
            },
            {
              begin: 6912,
              end: 7039
            },
            {
              begin: 4352,
              end: 4607
            },
            {
              begin: 7680,
              end: 7935
            },
            {
              begin: 7936,
              end: 8191
            },
            {
              begin: 8192,
              end: 8303
            },
            {
              begin: 8304,
              end: 8351
            },
            {
              begin: 8352,
              end: 8399
            },
            {
              begin: 8400,
              end: 8447
            },
            {
              begin: 8448,
              end: 8527
            },
            {
              begin: 8528,
              end: 8591
            },
            {
              begin: 8592,
              end: 8703
            },
            {
              begin: 8704,
              end: 8959
            },
            {
              begin: 8960,
              end: 9215
            },
            {
              begin: 9216,
              end: 9279
            },
            {
              begin: 9280,
              end: 9311
            },
            {
              begin: 9312,
              end: 9471
            },
            {
              begin: 9472,
              end: 9599
            },
            {
              begin: 9600,
              end: 9631
            },
            {
              begin: 9632,
              end: 9727
            },
            {
              begin: 9728,
              end: 9983
            },
            {
              begin: 9984,
              end: 10175
            },
            {
              begin: 12288,
              end: 12351
            },
            {
              begin: 12352,
              end: 12447
            },
            {
              begin: 12448,
              end: 12543
            },
            {
              begin: 12544,
              end: 12591
            },
            {
              begin: 12592,
              end: 12687
            },
            {
              begin: 43072,
              end: 43135
            },
            {
              begin: 12800,
              end: 13055
            },
            {
              begin: 13056,
              end: 13311
            },
            {
              begin: 44032,
              end: 55215
            },
            {
              begin: 55296,
              end: 57343
            },
            {
              begin: 67840,
              end: 67871
            },
            {
              begin: 19968,
              end: 40959
            },
            {
              begin: 57344,
              end: 63743
            },
            {
              begin: 12736,
              end: 12783
            },
            {
              begin: 64256,
              end: 64335
            },
            {
              begin: 64336,
              end: 65023
            },
            {
              begin: 65056,
              end: 65071
            },
            {
              begin: 65040,
              end: 65055
            },
            {
              begin: 65104,
              end: 65135
            },
            {
              begin: 65136,
              end: 65279
            },
            {
              begin: 65280,
              end: 65519
            },
            {
              begin: 65520,
              end: 65535
            },
            {
              begin: 3840,
              end: 4095
            },
            {
              begin: 1792,
              end: 1871
            },
            {
              begin: 1920,
              end: 1983
            },
            {
              begin: 3456,
              end: 3583
            },
            {
              begin: 4096,
              end: 4255
            },
            {
              begin: 4608,
              end: 4991
            },
            {
              begin: 5024,
              end: 5119
            },
            {
              begin: 5120,
              end: 5759
            },
            {
              begin: 5760,
              end: 5791
            },
            {
              begin: 5792,
              end: 5887
            },
            {
              begin: 6016,
              end: 6143
            },
            {
              begin: 6144,
              end: 6319
            },
            {
              begin: 10240,
              end: 10495
            },
            {
              begin: 40960,
              end: 42127
            },
            {
              begin: 5888,
              end: 5919
            },
            {
              begin: 66304,
              end: 66351
            },
            {
              begin: 66352,
              end: 66383
            },
            {
              begin: 66560,
              end: 66639
            },
            {
              begin: 118784,
              end: 119039
            },
            {
              begin: 119808,
              end: 120831
            },
            {
              begin: 1044480,
              end: 1048573
            },
            {
              begin: 65024,
              end: 65039
            },
            {
              begin: 917504,
              end: 917631
            },
            {
              begin: 6400,
              end: 6479
            },
            {
              begin: 6480,
              end: 6527
            },
            {
              begin: 6528,
              end: 6623
            },
            {
              begin: 6656,
              end: 6687
            },
            {
              begin: 11264,
              end: 11359
            },
            {
              begin: 11568,
              end: 11647
            },
            {
              begin: 19904,
              end: 19967
            },
            {
              begin: 43008,
              end: 43055
            },
            {
              begin: 65536,
              end: 65663
            },
            {
              begin: 65856,
              end: 65935
            },
            {
              begin: 66432,
              end: 66463
            },
            {
              begin: 66464,
              end: 66527
            },
            {
              begin: 66640,
              end: 66687
            },
            {
              begin: 66688,
              end: 66735
            },
            {
              begin: 67584,
              end: 67647
            },
            {
              begin: 68096,
              end: 68191
            },
            {
              begin: 119552,
              end: 119647
            },
            {
              begin: 73728,
              end: 74751
            },
            {
              begin: 119648,
              end: 119679
            },
            {
              begin: 7040,
              end: 7103
            },
            {
              begin: 7168,
              end: 7247
            },
            {
              begin: 7248,
              end: 7295
            },
            {
              begin: 43136,
              end: 43231
            },
            {
              begin: 43264,
              end: 43311
            },
            {
              begin: 43312,
              end: 43359
            },
            {
              begin: 43520,
              end: 43615
            },
            {
              begin: 65936,
              end: 65999
            },
            {
              begin: 66e3,
              end: 66047
            },
            {
              begin: 66208,
              end: 66271
            },
            {
              begin: 127024,
              end: 127135
            }
          ];
          function y(l) {
            for (let u = 0, w = e.length; u < w; u++) {
              const O = e[u];
              if (l >= O.begin && l < O.end)
                return u;
            }
            return -1;
          }
          function c(l) {
            let u = e[13];
            return l >= u.begin && l < u.end || (u = e[11], l >= u.begin && l < u.end);
          }
          const d = (0, t.getArrayLookupTableFactory)(function() {
            return [
              "¨",
              " ̈",
              "¯",
              " ̄",
              "´",
              " ́",
              "µ",
              "μ",
              "¸",
              " ̧",
              "Ĳ",
              "IJ",
              "ĳ",
              "ij",
              "Ŀ",
              "L·",
              "ŀ",
              "l·",
              "ŉ",
              "ʼn",
              "ſ",
              "s",
              "Ǆ",
              "DŽ",
              "ǅ",
              "Dž",
              "ǆ",
              "dž",
              "Ǉ",
              "LJ",
              "ǈ",
              "Lj",
              "ǉ",
              "lj",
              "Ǌ",
              "NJ",
              "ǋ",
              "Nj",
              "ǌ",
              "nj",
              "Ǳ",
              "DZ",
              "ǲ",
              "Dz",
              "ǳ",
              "dz",
              "˘",
              " ̆",
              "˙",
              " ̇",
              "˚",
              " ̊",
              "˛",
              " ̨",
              "˜",
              " ̃",
              "˝",
              " ̋",
              "ͺ",
              " ͅ",
              "΄",
              " ́",
              "ϐ",
              "β",
              "ϑ",
              "θ",
              "ϒ",
              "Υ",
              "ϕ",
              "φ",
              "ϖ",
              "π",
              "ϰ",
              "κ",
              "ϱ",
              "ρ",
              "ϲ",
              "ς",
              "ϴ",
              "Θ",
              "ϵ",
              "ε",
              "Ϲ",
              "Σ",
              "և",
              "եւ",
              "ٵ",
              "اٴ",
              "ٶ",
              "وٴ",
              "ٷ",
              "ۇٴ",
              "ٸ",
              "يٴ",
              "ำ",
              "ํา",
              "ຳ",
              "ໍາ",
              "ໜ",
              "ຫນ",
              "ໝ",
              "ຫມ",
              "ཷ",
              "ྲཱྀ",
              "ཹ",
              "ླཱྀ",
              "ẚ",
              "aʾ",
              "᾽",
              " ̓",
              "᾿",
              " ̓",
              "῀",
              " ͂",
              "῾",
              " ̔",
              " ",
              " ",
              " ",
              " ",
              " ",
              " ",
              " ",
              " ",
              " ",
              " ",
              " ",
              " ",
              " ",
              " ",
              " ",
              " ",
              "‗",
              " ̳",
              "․",
              ".",
              "‥",
              "..",
              "…",
              "...",
              "″",
              "′′",
              "‴",
              "′′′",
              "‶",
              "‵‵",
              "‷",
              "‵‵‵",
              "‼",
              "!!",
              "‾",
              " ̅",
              "⁇",
              "??",
              "⁈",
              "?!",
              "⁉",
              "!?",
              "⁗",
              "′′′′",
              " ",
              " ",
              "₨",
              "Rs",
              "℀",
              "a/c",
              "℁",
              "a/s",
              "℃",
              "°C",
              "℅",
              "c/o",
              "℆",
              "c/u",
              "ℇ",
              "Ɛ",
              "℉",
              "°F",
              "№",
              "No",
              "℡",
              "TEL",
              "ℵ",
              "א",
              "ℶ",
              "ב",
              "ℷ",
              "ג",
              "ℸ",
              "ד",
              "℻",
              "FAX",
              "Ⅰ",
              "I",
              "Ⅱ",
              "II",
              "Ⅲ",
              "III",
              "Ⅳ",
              "IV",
              "Ⅴ",
              "V",
              "Ⅵ",
              "VI",
              "Ⅶ",
              "VII",
              "Ⅷ",
              "VIII",
              "Ⅸ",
              "IX",
              "Ⅹ",
              "X",
              "Ⅺ",
              "XI",
              "Ⅻ",
              "XII",
              "Ⅼ",
              "L",
              "Ⅽ",
              "C",
              "Ⅾ",
              "D",
              "Ⅿ",
              "M",
              "ⅰ",
              "i",
              "ⅱ",
              "ii",
              "ⅲ",
              "iii",
              "ⅳ",
              "iv",
              "ⅴ",
              "v",
              "ⅵ",
              "vi",
              "ⅶ",
              "vii",
              "ⅷ",
              "viii",
              "ⅸ",
              "ix",
              "ⅹ",
              "x",
              "ⅺ",
              "xi",
              "ⅻ",
              "xii",
              "ⅼ",
              "l",
              "ⅽ",
              "c",
              "ⅾ",
              "d",
              "ⅿ",
              "m",
              "∬",
              "∫∫",
              "∭",
              "∫∫∫",
              "∯",
              "∮∮",
              "∰",
              "∮∮∮",
              "⑴",
              "(1)",
              "⑵",
              "(2)",
              "⑶",
              "(3)",
              "⑷",
              "(4)",
              "⑸",
              "(5)",
              "⑹",
              "(6)",
              "⑺",
              "(7)",
              "⑻",
              "(8)",
              "⑼",
              "(9)",
              "⑽",
              "(10)",
              "⑾",
              "(11)",
              "⑿",
              "(12)",
              "⒀",
              "(13)",
              "⒁",
              "(14)",
              "⒂",
              "(15)",
              "⒃",
              "(16)",
              "⒄",
              "(17)",
              "⒅",
              "(18)",
              "⒆",
              "(19)",
              "⒇",
              "(20)",
              "⒈",
              "1.",
              "⒉",
              "2.",
              "⒊",
              "3.",
              "⒋",
              "4.",
              "⒌",
              "5.",
              "⒍",
              "6.",
              "⒎",
              "7.",
              "⒏",
              "8.",
              "⒐",
              "9.",
              "⒑",
              "10.",
              "⒒",
              "11.",
              "⒓",
              "12.",
              "⒔",
              "13.",
              "⒕",
              "14.",
              "⒖",
              "15.",
              "⒗",
              "16.",
              "⒘",
              "17.",
              "⒙",
              "18.",
              "⒚",
              "19.",
              "⒛",
              "20.",
              "⒜",
              "(a)",
              "⒝",
              "(b)",
              "⒞",
              "(c)",
              "⒟",
              "(d)",
              "⒠",
              "(e)",
              "⒡",
              "(f)",
              "⒢",
              "(g)",
              "⒣",
              "(h)",
              "⒤",
              "(i)",
              "⒥",
              "(j)",
              "⒦",
              "(k)",
              "⒧",
              "(l)",
              "⒨",
              "(m)",
              "⒩",
              "(n)",
              "⒪",
              "(o)",
              "⒫",
              "(p)",
              "⒬",
              "(q)",
              "⒭",
              "(r)",
              "⒮",
              "(s)",
              "⒯",
              "(t)",
              "⒰",
              "(u)",
              "⒱",
              "(v)",
              "⒲",
              "(w)",
              "⒳",
              "(x)",
              "⒴",
              "(y)",
              "⒵",
              "(z)",
              "⨌",
              "∫∫∫∫",
              "⩴",
              "::=",
              "⩵",
              "==",
              "⩶",
              "===",
              "⺟",
              "母",
              "⻳",
              "龟",
              "⼀",
              "一",
              "⼁",
              "丨",
              "⼂",
              "丶",
              "⼃",
              "丿",
              "⼄",
              "乙",
              "⼅",
              "亅",
              "⼆",
              "二",
              "⼇",
              "亠",
              "⼈",
              "人",
              "⼉",
              "儿",
              "⼊",
              "入",
              "⼋",
              "八",
              "⼌",
              "冂",
              "⼍",
              "冖",
              "⼎",
              "冫",
              "⼏",
              "几",
              "⼐",
              "凵",
              "⼑",
              "刀",
              "⼒",
              "力",
              "⼓",
              "勹",
              "⼔",
              "匕",
              "⼕",
              "匚",
              "⼖",
              "匸",
              "⼗",
              "十",
              "⼘",
              "卜",
              "⼙",
              "卩",
              "⼚",
              "厂",
              "⼛",
              "厶",
              "⼜",
              "又",
              "⼝",
              "口",
              "⼞",
              "囗",
              "⼟",
              "土",
              "⼠",
              "士",
              "⼡",
              "夂",
              "⼢",
              "夊",
              "⼣",
              "夕",
              "⼤",
              "大",
              "⼥",
              "女",
              "⼦",
              "子",
              "⼧",
              "宀",
              "⼨",
              "寸",
              "⼩",
              "小",
              "⼪",
              "尢",
              "⼫",
              "尸",
              "⼬",
              "屮",
              "⼭",
              "山",
              "⼮",
              "巛",
              "⼯",
              "工",
              "⼰",
              "己",
              "⼱",
              "巾",
              "⼲",
              "干",
              "⼳",
              "幺",
              "⼴",
              "广",
              "⼵",
              "廴",
              "⼶",
              "廾",
              "⼷",
              "弋",
              "⼸",
              "弓",
              "⼹",
              "彐",
              "⼺",
              "彡",
              "⼻",
              "彳",
              "⼼",
              "心",
              "⼽",
              "戈",
              "⼾",
              "戶",
              "⼿",
              "手",
              "⽀",
              "支",
              "⽁",
              "攴",
              "⽂",
              "文",
              "⽃",
              "斗",
              "⽄",
              "斤",
              "⽅",
              "方",
              "⽆",
              "无",
              "⽇",
              "日",
              "⽈",
              "曰",
              "⽉",
              "月",
              "⽊",
              "木",
              "⽋",
              "欠",
              "⽌",
              "止",
              "⽍",
              "歹",
              "⽎",
              "殳",
              "⽏",
              "毋",
              "⽐",
              "比",
              "⽑",
              "毛",
              "⽒",
              "氏",
              "⽓",
              "气",
              "⽔",
              "水",
              "⽕",
              "火",
              "⽖",
              "爪",
              "⽗",
              "父",
              "⽘",
              "爻",
              "⽙",
              "爿",
              "⽚",
              "片",
              "⽛",
              "牙",
              "⽜",
              "牛",
              "⽝",
              "犬",
              "⽞",
              "玄",
              "⽟",
              "玉",
              "⽠",
              "瓜",
              "⽡",
              "瓦",
              "⽢",
              "甘",
              "⽣",
              "生",
              "⽤",
              "用",
              "⽥",
              "田",
              "⽦",
              "疋",
              "⽧",
              "疒",
              "⽨",
              "癶",
              "⽩",
              "白",
              "⽪",
              "皮",
              "⽫",
              "皿",
              "⽬",
              "目",
              "⽭",
              "矛",
              "⽮",
              "矢",
              "⽯",
              "石",
              "⽰",
              "示",
              "⽱",
              "禸",
              "⽲",
              "禾",
              "⽳",
              "穴",
              "⽴",
              "立",
              "⽵",
              "竹",
              "⽶",
              "米",
              "⽷",
              "糸",
              "⽸",
              "缶",
              "⽹",
              "网",
              "⽺",
              "羊",
              "⽻",
              "羽",
              "⽼",
              "老",
              "⽽",
              "而",
              "⽾",
              "耒",
              "⽿",
              "耳",
              "⾀",
              "聿",
              "⾁",
              "肉",
              "⾂",
              "臣",
              "⾃",
              "自",
              "⾄",
              "至",
              "⾅",
              "臼",
              "⾆",
              "舌",
              "⾇",
              "舛",
              "⾈",
              "舟",
              "⾉",
              "艮",
              "⾊",
              "色",
              "⾋",
              "艸",
              "⾌",
              "虍",
              "⾍",
              "虫",
              "⾎",
              "血",
              "⾏",
              "行",
              "⾐",
              "衣",
              "⾑",
              "襾",
              "⾒",
              "見",
              "⾓",
              "角",
              "⾔",
              "言",
              "⾕",
              "谷",
              "⾖",
              "豆",
              "⾗",
              "豕",
              "⾘",
              "豸",
              "⾙",
              "貝",
              "⾚",
              "赤",
              "⾛",
              "走",
              "⾜",
              "足",
              "⾝",
              "身",
              "⾞",
              "車",
              "⾟",
              "辛",
              "⾠",
              "辰",
              "⾡",
              "辵",
              "⾢",
              "邑",
              "⾣",
              "酉",
              "⾤",
              "釆",
              "⾥",
              "里",
              "⾦",
              "金",
              "⾧",
              "長",
              "⾨",
              "門",
              "⾩",
              "阜",
              "⾪",
              "隶",
              "⾫",
              "隹",
              "⾬",
              "雨",
              "⾭",
              "靑",
              "⾮",
              "非",
              "⾯",
              "面",
              "⾰",
              "革",
              "⾱",
              "韋",
              "⾲",
              "韭",
              "⾳",
              "音",
              "⾴",
              "頁",
              "⾵",
              "風",
              "⾶",
              "飛",
              "⾷",
              "食",
              "⾸",
              "首",
              "⾹",
              "香",
              "⾺",
              "馬",
              "⾻",
              "骨",
              "⾼",
              "高",
              "⾽",
              "髟",
              "⾾",
              "鬥",
              "⾿",
              "鬯",
              "⿀",
              "鬲",
              "⿁",
              "鬼",
              "⿂",
              "魚",
              "⿃",
              "鳥",
              "⿄",
              "鹵",
              "⿅",
              "鹿",
              "⿆",
              "麥",
              "⿇",
              "麻",
              "⿈",
              "黃",
              "⿉",
              "黍",
              "⿊",
              "黑",
              "⿋",
              "黹",
              "⿌",
              "黽",
              "⿍",
              "鼎",
              "⿎",
              "鼓",
              "⿏",
              "鼠",
              "⿐",
              "鼻",
              "⿑",
              "齊",
              "⿒",
              "齒",
              "⿓",
              "龍",
              "⿔",
              "龜",
              "⿕",
              "龠",
              "〶",
              "〒",
              "〸",
              "十",
              "〹",
              "卄",
              "〺",
              "卅",
              "゛",
              " ゙",
              "゜",
              " ゚",
              "ㄱ",
              "ᄀ",
              "ㄲ",
              "ᄁ",
              "ㄳ",
              "ᆪ",
              "ㄴ",
              "ᄂ",
              "ㄵ",
              "ᆬ",
              "ㄶ",
              "ᆭ",
              "ㄷ",
              "ᄃ",
              "ㄸ",
              "ᄄ",
              "ㄹ",
              "ᄅ",
              "ㄺ",
              "ᆰ",
              "ㄻ",
              "ᆱ",
              "ㄼ",
              "ᆲ",
              "ㄽ",
              "ᆳ",
              "ㄾ",
              "ᆴ",
              "ㄿ",
              "ᆵ",
              "ㅀ",
              "ᄚ",
              "ㅁ",
              "ᄆ",
              "ㅂ",
              "ᄇ",
              "ㅃ",
              "ᄈ",
              "ㅄ",
              "ᄡ",
              "ㅅ",
              "ᄉ",
              "ㅆ",
              "ᄊ",
              "ㅇ",
              "ᄋ",
              "ㅈ",
              "ᄌ",
              "ㅉ",
              "ᄍ",
              "ㅊ",
              "ᄎ",
              "ㅋ",
              "ᄏ",
              "ㅌ",
              "ᄐ",
              "ㅍ",
              "ᄑ",
              "ㅎ",
              "ᄒ",
              "ㅏ",
              "ᅡ",
              "ㅐ",
              "ᅢ",
              "ㅑ",
              "ᅣ",
              "ㅒ",
              "ᅤ",
              "ㅓ",
              "ᅥ",
              "ㅔ",
              "ᅦ",
              "ㅕ",
              "ᅧ",
              "ㅖ",
              "ᅨ",
              "ㅗ",
              "ᅩ",
              "ㅘ",
              "ᅪ",
              "ㅙ",
              "ᅫ",
              "ㅚ",
              "ᅬ",
              "ㅛ",
              "ᅭ",
              "ㅜ",
              "ᅮ",
              "ㅝ",
              "ᅯ",
              "ㅞ",
              "ᅰ",
              "ㅟ",
              "ᅱ",
              "ㅠ",
              "ᅲ",
              "ㅡ",
              "ᅳ",
              "ㅢ",
              "ᅴ",
              "ㅣ",
              "ᅵ",
              "ㅤ",
              "ᅠ",
              "ㅥ",
              "ᄔ",
              "ㅦ",
              "ᄕ",
              "ㅧ",
              "ᇇ",
              "ㅨ",
              "ᇈ",
              "ㅩ",
              "ᇌ",
              "ㅪ",
              "ᇎ",
              "ㅫ",
              "ᇓ",
              "ㅬ",
              "ᇗ",
              "ㅭ",
              "ᇙ",
              "ㅮ",
              "ᄜ",
              "ㅯ",
              "ᇝ",
              "ㅰ",
              "ᇟ",
              "ㅱ",
              "ᄝ",
              "ㅲ",
              "ᄞ",
              "ㅳ",
              "ᄠ",
              "ㅴ",
              "ᄢ",
              "ㅵ",
              "ᄣ",
              "ㅶ",
              "ᄧ",
              "ㅷ",
              "ᄩ",
              "ㅸ",
              "ᄫ",
              "ㅹ",
              "ᄬ",
              "ㅺ",
              "ᄭ",
              "ㅻ",
              "ᄮ",
              "ㅼ",
              "ᄯ",
              "ㅽ",
              "ᄲ",
              "ㅾ",
              "ᄶ",
              "ㅿ",
              "ᅀ",
              "ㆀ",
              "ᅇ",
              "ㆁ",
              "ᅌ",
              "ㆂ",
              "ᇱ",
              "ㆃ",
              "ᇲ",
              "ㆄ",
              "ᅗ",
              "ㆅ",
              "ᅘ",
              "ㆆ",
              "ᅙ",
              "ㆇ",
              "ᆄ",
              "ㆈ",
              "ᆅ",
              "ㆉ",
              "ᆈ",
              "ㆊ",
              "ᆑ",
              "ㆋ",
              "ᆒ",
              "ㆌ",
              "ᆔ",
              "ㆍ",
              "ᆞ",
              "ㆎ",
              "ᆡ",
              "㈀",
              "(ᄀ)",
              "㈁",
              "(ᄂ)",
              "㈂",
              "(ᄃ)",
              "㈃",
              "(ᄅ)",
              "㈄",
              "(ᄆ)",
              "㈅",
              "(ᄇ)",
              "㈆",
              "(ᄉ)",
              "㈇",
              "(ᄋ)",
              "㈈",
              "(ᄌ)",
              "㈉",
              "(ᄎ)",
              "㈊",
              "(ᄏ)",
              "㈋",
              "(ᄐ)",
              "㈌",
              "(ᄑ)",
              "㈍",
              "(ᄒ)",
              "㈎",
              "(가)",
              "㈏",
              "(나)",
              "㈐",
              "(다)",
              "㈑",
              "(라)",
              "㈒",
              "(마)",
              "㈓",
              "(바)",
              "㈔",
              "(사)",
              "㈕",
              "(아)",
              "㈖",
              "(자)",
              "㈗",
              "(차)",
              "㈘",
              "(카)",
              "㈙",
              "(타)",
              "㈚",
              "(파)",
              "㈛",
              "(하)",
              "㈜",
              "(주)",
              "㈝",
              "(오전)",
              "㈞",
              "(오후)",
              "㈠",
              "(一)",
              "㈡",
              "(二)",
              "㈢",
              "(三)",
              "㈣",
              "(四)",
              "㈤",
              "(五)",
              "㈥",
              "(六)",
              "㈦",
              "(七)",
              "㈧",
              "(八)",
              "㈨",
              "(九)",
              "㈩",
              "(十)",
              "㈪",
              "(月)",
              "㈫",
              "(火)",
              "㈬",
              "(水)",
              "㈭",
              "(木)",
              "㈮",
              "(金)",
              "㈯",
              "(土)",
              "㈰",
              "(日)",
              "㈱",
              "(株)",
              "㈲",
              "(有)",
              "㈳",
              "(社)",
              "㈴",
              "(名)",
              "㈵",
              "(特)",
              "㈶",
              "(財)",
              "㈷",
              "(祝)",
              "㈸",
              "(労)",
              "㈹",
              "(代)",
              "㈺",
              "(呼)",
              "㈻",
              "(学)",
              "㈼",
              "(監)",
              "㈽",
              "(企)",
              "㈾",
              "(資)",
              "㈿",
              "(協)",
              "㉀",
              "(祭)",
              "㉁",
              "(休)",
              "㉂",
              "(自)",
              "㉃",
              "(至)",
              "㋀",
              "1月",
              "㋁",
              "2月",
              "㋂",
              "3月",
              "㋃",
              "4月",
              "㋄",
              "5月",
              "㋅",
              "6月",
              "㋆",
              "7月",
              "㋇",
              "8月",
              "㋈",
              "9月",
              "㋉",
              "10月",
              "㋊",
              "11月",
              "㋋",
              "12月",
              "㍘",
              "0点",
              "㍙",
              "1点",
              "㍚",
              "2点",
              "㍛",
              "3点",
              "㍜",
              "4点",
              "㍝",
              "5点",
              "㍞",
              "6点",
              "㍟",
              "7点",
              "㍠",
              "8点",
              "㍡",
              "9点",
              "㍢",
              "10点",
              "㍣",
              "11点",
              "㍤",
              "12点",
              "㍥",
              "13点",
              "㍦",
              "14点",
              "㍧",
              "15点",
              "㍨",
              "16点",
              "㍩",
              "17点",
              "㍪",
              "18点",
              "㍫",
              "19点",
              "㍬",
              "20点",
              "㍭",
              "21点",
              "㍮",
              "22点",
              "㍯",
              "23点",
              "㍰",
              "24点",
              "㏠",
              "1日",
              "㏡",
              "2日",
              "㏢",
              "3日",
              "㏣",
              "4日",
              "㏤",
              "5日",
              "㏥",
              "6日",
              "㏦",
              "7日",
              "㏧",
              "8日",
              "㏨",
              "9日",
              "㏩",
              "10日",
              "㏪",
              "11日",
              "㏫",
              "12日",
              "㏬",
              "13日",
              "㏭",
              "14日",
              "㏮",
              "15日",
              "㏯",
              "16日",
              "㏰",
              "17日",
              "㏱",
              "18日",
              "㏲",
              "19日",
              "㏳",
              "20日",
              "㏴",
              "21日",
              "㏵",
              "22日",
              "㏶",
              "23日",
              "㏷",
              "24日",
              "㏸",
              "25日",
              "㏹",
              "26日",
              "㏺",
              "27日",
              "㏻",
              "28日",
              "㏼",
              "29日",
              "㏽",
              "30日",
              "㏾",
              "31日",
              "ﬀ",
              "ff",
              "ﬁ",
              "fi",
              "ﬂ",
              "fl",
              "ﬃ",
              "ffi",
              "ﬄ",
              "ffl",
              "ﬅ",
              "ſt",
              "ﬆ",
              "st",
              "ﬓ",
              "մն",
              "ﬔ",
              "մե",
              "ﬕ",
              "մի",
              "ﬖ",
              "վն",
              "ﬗ",
              "մխ",
              "ﭏ",
              "אל",
              "ﭐ",
              "ٱ",
              "ﭑ",
              "ٱ",
              "ﭒ",
              "ٻ",
              "ﭓ",
              "ٻ",
              "ﭔ",
              "ٻ",
              "ﭕ",
              "ٻ",
              "ﭖ",
              "پ",
              "ﭗ",
              "پ",
              "ﭘ",
              "پ",
              "ﭙ",
              "پ",
              "ﭚ",
              "ڀ",
              "ﭛ",
              "ڀ",
              "ﭜ",
              "ڀ",
              "ﭝ",
              "ڀ",
              "ﭞ",
              "ٺ",
              "ﭟ",
              "ٺ",
              "ﭠ",
              "ٺ",
              "ﭡ",
              "ٺ",
              "ﭢ",
              "ٿ",
              "ﭣ",
              "ٿ",
              "ﭤ",
              "ٿ",
              "ﭥ",
              "ٿ",
              "ﭦ",
              "ٹ",
              "ﭧ",
              "ٹ",
              "ﭨ",
              "ٹ",
              "ﭩ",
              "ٹ",
              "ﭪ",
              "ڤ",
              "ﭫ",
              "ڤ",
              "ﭬ",
              "ڤ",
              "ﭭ",
              "ڤ",
              "ﭮ",
              "ڦ",
              "ﭯ",
              "ڦ",
              "ﭰ",
              "ڦ",
              "ﭱ",
              "ڦ",
              "ﭲ",
              "ڄ",
              "ﭳ",
              "ڄ",
              "ﭴ",
              "ڄ",
              "ﭵ",
              "ڄ",
              "ﭶ",
              "ڃ",
              "ﭷ",
              "ڃ",
              "ﭸ",
              "ڃ",
              "ﭹ",
              "ڃ",
              "ﭺ",
              "چ",
              "ﭻ",
              "چ",
              "ﭼ",
              "چ",
              "ﭽ",
              "چ",
              "ﭾ",
              "ڇ",
              "ﭿ",
              "ڇ",
              "ﮀ",
              "ڇ",
              "ﮁ",
              "ڇ",
              "ﮂ",
              "ڍ",
              "ﮃ",
              "ڍ",
              "ﮄ",
              "ڌ",
              "ﮅ",
              "ڌ",
              "ﮆ",
              "ڎ",
              "ﮇ",
              "ڎ",
              "ﮈ",
              "ڈ",
              "ﮉ",
              "ڈ",
              "ﮊ",
              "ژ",
              "ﮋ",
              "ژ",
              "ﮌ",
              "ڑ",
              "ﮍ",
              "ڑ",
              "ﮎ",
              "ک",
              "ﮏ",
              "ک",
              "ﮐ",
              "ک",
              "ﮑ",
              "ک",
              "ﮒ",
              "گ",
              "ﮓ",
              "گ",
              "ﮔ",
              "گ",
              "ﮕ",
              "گ",
              "ﮖ",
              "ڳ",
              "ﮗ",
              "ڳ",
              "ﮘ",
              "ڳ",
              "ﮙ",
              "ڳ",
              "ﮚ",
              "ڱ",
              "ﮛ",
              "ڱ",
              "ﮜ",
              "ڱ",
              "ﮝ",
              "ڱ",
              "ﮞ",
              "ں",
              "ﮟ",
              "ں",
              "ﮠ",
              "ڻ",
              "ﮡ",
              "ڻ",
              "ﮢ",
              "ڻ",
              "ﮣ",
              "ڻ",
              "ﮤ",
              "ۀ",
              "ﮥ",
              "ۀ",
              "ﮦ",
              "ہ",
              "ﮧ",
              "ہ",
              "ﮨ",
              "ہ",
              "ﮩ",
              "ہ",
              "ﮪ",
              "ھ",
              "ﮫ",
              "ھ",
              "ﮬ",
              "ھ",
              "ﮭ",
              "ھ",
              "ﮮ",
              "ے",
              "ﮯ",
              "ے",
              "ﮰ",
              "ۓ",
              "ﮱ",
              "ۓ",
              "ﯓ",
              "ڭ",
              "ﯔ",
              "ڭ",
              "ﯕ",
              "ڭ",
              "ﯖ",
              "ڭ",
              "ﯗ",
              "ۇ",
              "ﯘ",
              "ۇ",
              "ﯙ",
              "ۆ",
              "ﯚ",
              "ۆ",
              "ﯛ",
              "ۈ",
              "ﯜ",
              "ۈ",
              "ﯝ",
              "ٷ",
              "ﯞ",
              "ۋ",
              "ﯟ",
              "ۋ",
              "ﯠ",
              "ۅ",
              "ﯡ",
              "ۅ",
              "ﯢ",
              "ۉ",
              "ﯣ",
              "ۉ",
              "ﯤ",
              "ې",
              "ﯥ",
              "ې",
              "ﯦ",
              "ې",
              "ﯧ",
              "ې",
              "ﯨ",
              "ى",
              "ﯩ",
              "ى",
              "ﯪ",
              "ئا",
              "ﯫ",
              "ئا",
              "ﯬ",
              "ئە",
              "ﯭ",
              "ئە",
              "ﯮ",
              "ئو",
              "ﯯ",
              "ئو",
              "ﯰ",
              "ئۇ",
              "ﯱ",
              "ئۇ",
              "ﯲ",
              "ئۆ",
              "ﯳ",
              "ئۆ",
              "ﯴ",
              "ئۈ",
              "ﯵ",
              "ئۈ",
              "ﯶ",
              "ئې",
              "ﯷ",
              "ئې",
              "ﯸ",
              "ئې",
              "ﯹ",
              "ئى",
              "ﯺ",
              "ئى",
              "ﯻ",
              "ئى",
              "ﯼ",
              "ی",
              "ﯽ",
              "ی",
              "ﯾ",
              "ی",
              "ﯿ",
              "ی",
              "ﰀ",
              "ئج",
              "ﰁ",
              "ئح",
              "ﰂ",
              "ئم",
              "ﰃ",
              "ئى",
              "ﰄ",
              "ئي",
              "ﰅ",
              "بج",
              "ﰆ",
              "بح",
              "ﰇ",
              "بخ",
              "ﰈ",
              "بم",
              "ﰉ",
              "بى",
              "ﰊ",
              "بي",
              "ﰋ",
              "تج",
              "ﰌ",
              "تح",
              "ﰍ",
              "تخ",
              "ﰎ",
              "تم",
              "ﰏ",
              "تى",
              "ﰐ",
              "تي",
              "ﰑ",
              "ثج",
              "ﰒ",
              "ثم",
              "ﰓ",
              "ثى",
              "ﰔ",
              "ثي",
              "ﰕ",
              "جح",
              "ﰖ",
              "جم",
              "ﰗ",
              "حج",
              "ﰘ",
              "حم",
              "ﰙ",
              "خج",
              "ﰚ",
              "خح",
              "ﰛ",
              "خم",
              "ﰜ",
              "سج",
              "ﰝ",
              "سح",
              "ﰞ",
              "سخ",
              "ﰟ",
              "سم",
              "ﰠ",
              "صح",
              "ﰡ",
              "صم",
              "ﰢ",
              "ضج",
              "ﰣ",
              "ضح",
              "ﰤ",
              "ضخ",
              "ﰥ",
              "ضم",
              "ﰦ",
              "طح",
              "ﰧ",
              "طم",
              "ﰨ",
              "ظم",
              "ﰩ",
              "عج",
              "ﰪ",
              "عم",
              "ﰫ",
              "غج",
              "ﰬ",
              "غم",
              "ﰭ",
              "فج",
              "ﰮ",
              "فح",
              "ﰯ",
              "فخ",
              "ﰰ",
              "فم",
              "ﰱ",
              "فى",
              "ﰲ",
              "في",
              "ﰳ",
              "قح",
              "ﰴ",
              "قم",
              "ﰵ",
              "قى",
              "ﰶ",
              "قي",
              "ﰷ",
              "كا",
              "ﰸ",
              "كج",
              "ﰹ",
              "كح",
              "ﰺ",
              "كخ",
              "ﰻ",
              "كل",
              "ﰼ",
              "كم",
              "ﰽ",
              "كى",
              "ﰾ",
              "كي",
              "ﰿ",
              "لج",
              "ﱀ",
              "لح",
              "ﱁ",
              "لخ",
              "ﱂ",
              "لم",
              "ﱃ",
              "لى",
              "ﱄ",
              "لي",
              "ﱅ",
              "مج",
              "ﱆ",
              "مح",
              "ﱇ",
              "مخ",
              "ﱈ",
              "مم",
              "ﱉ",
              "مى",
              "ﱊ",
              "مي",
              "ﱋ",
              "نج",
              "ﱌ",
              "نح",
              "ﱍ",
              "نخ",
              "ﱎ",
              "نم",
              "ﱏ",
              "نى",
              "ﱐ",
              "ني",
              "ﱑ",
              "هج",
              "ﱒ",
              "هم",
              "ﱓ",
              "هى",
              "ﱔ",
              "هي",
              "ﱕ",
              "يج",
              "ﱖ",
              "يح",
              "ﱗ",
              "يخ",
              "ﱘ",
              "يم",
              "ﱙ",
              "يى",
              "ﱚ",
              "يي",
              "ﱛ",
              "ذٰ",
              "ﱜ",
              "رٰ",
              "ﱝ",
              "ىٰ",
              "ﱞ",
              " ٌّ",
              "ﱟ",
              " ٍّ",
              "ﱠ",
              " َّ",
              "ﱡ",
              " ُّ",
              "ﱢ",
              " ِّ",
              "ﱣ",
              " ّٰ",
              "ﱤ",
              "ئر",
              "ﱥ",
              "ئز",
              "ﱦ",
              "ئم",
              "ﱧ",
              "ئن",
              "ﱨ",
              "ئى",
              "ﱩ",
              "ئي",
              "ﱪ",
              "بر",
              "ﱫ",
              "بز",
              "ﱬ",
              "بم",
              "ﱭ",
              "بن",
              "ﱮ",
              "بى",
              "ﱯ",
              "بي",
              "ﱰ",
              "تر",
              "ﱱ",
              "تز",
              "ﱲ",
              "تم",
              "ﱳ",
              "تن",
              "ﱴ",
              "تى",
              "ﱵ",
              "تي",
              "ﱶ",
              "ثر",
              "ﱷ",
              "ثز",
              "ﱸ",
              "ثم",
              "ﱹ",
              "ثن",
              "ﱺ",
              "ثى",
              "ﱻ",
              "ثي",
              "ﱼ",
              "فى",
              "ﱽ",
              "في",
              "ﱾ",
              "قى",
              "ﱿ",
              "قي",
              "ﲀ",
              "كا",
              "ﲁ",
              "كل",
              "ﲂ",
              "كم",
              "ﲃ",
              "كى",
              "ﲄ",
              "كي",
              "ﲅ",
              "لم",
              "ﲆ",
              "لى",
              "ﲇ",
              "لي",
              "ﲈ",
              "ما",
              "ﲉ",
              "مم",
              "ﲊ",
              "نر",
              "ﲋ",
              "نز",
              "ﲌ",
              "نم",
              "ﲍ",
              "نن",
              "ﲎ",
              "نى",
              "ﲏ",
              "ني",
              "ﲐ",
              "ىٰ",
              "ﲑ",
              "ير",
              "ﲒ",
              "يز",
              "ﲓ",
              "يم",
              "ﲔ",
              "ين",
              "ﲕ",
              "يى",
              "ﲖ",
              "يي",
              "ﲗ",
              "ئج",
              "ﲘ",
              "ئح",
              "ﲙ",
              "ئخ",
              "ﲚ",
              "ئم",
              "ﲛ",
              "ئه",
              "ﲜ",
              "بج",
              "ﲝ",
              "بح",
              "ﲞ",
              "بخ",
              "ﲟ",
              "بم",
              "ﲠ",
              "به",
              "ﲡ",
              "تج",
              "ﲢ",
              "تح",
              "ﲣ",
              "تخ",
              "ﲤ",
              "تم",
              "ﲥ",
              "ته",
              "ﲦ",
              "ثم",
              "ﲧ",
              "جح",
              "ﲨ",
              "جم",
              "ﲩ",
              "حج",
              "ﲪ",
              "حم",
              "ﲫ",
              "خج",
              "ﲬ",
              "خم",
              "ﲭ",
              "سج",
              "ﲮ",
              "سح",
              "ﲯ",
              "سخ",
              "ﲰ",
              "سم",
              "ﲱ",
              "صح",
              "ﲲ",
              "صخ",
              "ﲳ",
              "صم",
              "ﲴ",
              "ضج",
              "ﲵ",
              "ضح",
              "ﲶ",
              "ضخ",
              "ﲷ",
              "ضم",
              "ﲸ",
              "طح",
              "ﲹ",
              "ظم",
              "ﲺ",
              "عج",
              "ﲻ",
              "عم",
              "ﲼ",
              "غج",
              "ﲽ",
              "غم",
              "ﲾ",
              "فج",
              "ﲿ",
              "فح",
              "ﳀ",
              "فخ",
              "ﳁ",
              "فم",
              "ﳂ",
              "قح",
              "ﳃ",
              "قم",
              "ﳄ",
              "كج",
              "ﳅ",
              "كح",
              "ﳆ",
              "كخ",
              "ﳇ",
              "كل",
              "ﳈ",
              "كم",
              "ﳉ",
              "لج",
              "ﳊ",
              "لح",
              "ﳋ",
              "لخ",
              "ﳌ",
              "لم",
              "ﳍ",
              "له",
              "ﳎ",
              "مج",
              "ﳏ",
              "مح",
              "ﳐ",
              "مخ",
              "ﳑ",
              "مم",
              "ﳒ",
              "نج",
              "ﳓ",
              "نح",
              "ﳔ",
              "نخ",
              "ﳕ",
              "نم",
              "ﳖ",
              "نه",
              "ﳗ",
              "هج",
              "ﳘ",
              "هم",
              "ﳙ",
              "هٰ",
              "ﳚ",
              "يج",
              "ﳛ",
              "يح",
              "ﳜ",
              "يخ",
              "ﳝ",
              "يم",
              "ﳞ",
              "يه",
              "ﳟ",
              "ئم",
              "ﳠ",
              "ئه",
              "ﳡ",
              "بم",
              "ﳢ",
              "به",
              "ﳣ",
              "تم",
              "ﳤ",
              "ته",
              "ﳥ",
              "ثم",
              "ﳦ",
              "ثه",
              "ﳧ",
              "سم",
              "ﳨ",
              "سه",
              "ﳩ",
              "شم",
              "ﳪ",
              "شه",
              "ﳫ",
              "كل",
              "ﳬ",
              "كم",
              "ﳭ",
              "لم",
              "ﳮ",
              "نم",
              "ﳯ",
              "نه",
              "ﳰ",
              "يم",
              "ﳱ",
              "يه",
              "ﳲ",
              "ـَّ",
              "ﳳ",
              "ـُّ",
              "ﳴ",
              "ـِّ",
              "ﳵ",
              "طى",
              "ﳶ",
              "طي",
              "ﳷ",
              "عى",
              "ﳸ",
              "عي",
              "ﳹ",
              "غى",
              "ﳺ",
              "غي",
              "ﳻ",
              "سى",
              "ﳼ",
              "سي",
              "ﳽ",
              "شى",
              "ﳾ",
              "شي",
              "ﳿ",
              "حى",
              "ﴀ",
              "حي",
              "ﴁ",
              "جى",
              "ﴂ",
              "جي",
              "ﴃ",
              "خى",
              "ﴄ",
              "خي",
              "ﴅ",
              "صى",
              "ﴆ",
              "صي",
              "ﴇ",
              "ضى",
              "ﴈ",
              "ضي",
              "ﴉ",
              "شج",
              "ﴊ",
              "شح",
              "ﴋ",
              "شخ",
              "ﴌ",
              "شم",
              "ﴍ",
              "شر",
              "ﴎ",
              "سر",
              "ﴏ",
              "صر",
              "ﴐ",
              "ضر",
              "ﴑ",
              "طى",
              "ﴒ",
              "طي",
              "ﴓ",
              "عى",
              "ﴔ",
              "عي",
              "ﴕ",
              "غى",
              "ﴖ",
              "غي",
              "ﴗ",
              "سى",
              "ﴘ",
              "سي",
              "ﴙ",
              "شى",
              "ﴚ",
              "شي",
              "ﴛ",
              "حى",
              "ﴜ",
              "حي",
              "ﴝ",
              "جى",
              "ﴞ",
              "جي",
              "ﴟ",
              "خى",
              "ﴠ",
              "خي",
              "ﴡ",
              "صى",
              "ﴢ",
              "صي",
              "ﴣ",
              "ضى",
              "ﴤ",
              "ضي",
              "ﴥ",
              "شج",
              "ﴦ",
              "شح",
              "ﴧ",
              "شخ",
              "ﴨ",
              "شم",
              "ﴩ",
              "شر",
              "ﴪ",
              "سر",
              "ﴫ",
              "صر",
              "ﴬ",
              "ضر",
              "ﴭ",
              "شج",
              "ﴮ",
              "شح",
              "ﴯ",
              "شخ",
              "ﴰ",
              "شم",
              "ﴱ",
              "سه",
              "ﴲ",
              "شه",
              "ﴳ",
              "طم",
              "ﴴ",
              "سج",
              "ﴵ",
              "سح",
              "ﴶ",
              "سخ",
              "ﴷ",
              "شج",
              "ﴸ",
              "شح",
              "ﴹ",
              "شخ",
              "ﴺ",
              "طم",
              "ﴻ",
              "ظم",
              "ﴼ",
              "اً",
              "ﴽ",
              "اً",
              "ﵐ",
              "تجم",
              "ﵑ",
              "تحج",
              "ﵒ",
              "تحج",
              "ﵓ",
              "تحم",
              "ﵔ",
              "تخم",
              "ﵕ",
              "تمج",
              "ﵖ",
              "تمح",
              "ﵗ",
              "تمخ",
              "ﵘ",
              "جمح",
              "ﵙ",
              "جمح",
              "ﵚ",
              "حمي",
              "ﵛ",
              "حمى",
              "ﵜ",
              "سحج",
              "ﵝ",
              "سجح",
              "ﵞ",
              "سجى",
              "ﵟ",
              "سمح",
              "ﵠ",
              "سمح",
              "ﵡ",
              "سمج",
              "ﵢ",
              "سمم",
              "ﵣ",
              "سمم",
              "ﵤ",
              "صحح",
              "ﵥ",
              "صحح",
              "ﵦ",
              "صمم",
              "ﵧ",
              "شحم",
              "ﵨ",
              "شحم",
              "ﵩ",
              "شجي",
              "ﵪ",
              "شمخ",
              "ﵫ",
              "شمخ",
              "ﵬ",
              "شمم",
              "ﵭ",
              "شمم",
              "ﵮ",
              "ضحى",
              "ﵯ",
              "ضخم",
              "ﵰ",
              "ضخم",
              "ﵱ",
              "طمح",
              "ﵲ",
              "طمح",
              "ﵳ",
              "طمم",
              "ﵴ",
              "طمي",
              "ﵵ",
              "عجم",
              "ﵶ",
              "عمم",
              "ﵷ",
              "عمم",
              "ﵸ",
              "عمى",
              "ﵹ",
              "غمم",
              "ﵺ",
              "غمي",
              "ﵻ",
              "غمى",
              "ﵼ",
              "فخم",
              "ﵽ",
              "فخم",
              "ﵾ",
              "قمح",
              "ﵿ",
              "قمم",
              "ﶀ",
              "لحم",
              "ﶁ",
              "لحي",
              "ﶂ",
              "لحى",
              "ﶃ",
              "لجج",
              "ﶄ",
              "لجج",
              "ﶅ",
              "لخم",
              "ﶆ",
              "لخم",
              "ﶇ",
              "لمح",
              "ﶈ",
              "لمح",
              "ﶉ",
              "محج",
              "ﶊ",
              "محم",
              "ﶋ",
              "محي",
              "ﶌ",
              "مجح",
              "ﶍ",
              "مجم",
              "ﶎ",
              "مخج",
              "ﶏ",
              "مخم",
              "ﶒ",
              "مجخ",
              "ﶓ",
              "همج",
              "ﶔ",
              "همم",
              "ﶕ",
              "نحم",
              "ﶖ",
              "نحى",
              "ﶗ",
              "نجم",
              "ﶘ",
              "نجم",
              "ﶙ",
              "نجى",
              "ﶚ",
              "نمي",
              "ﶛ",
              "نمى",
              "ﶜ",
              "يمم",
              "ﶝ",
              "يمم",
              "ﶞ",
              "بخي",
              "ﶟ",
              "تجي",
              "ﶠ",
              "تجى",
              "ﶡ",
              "تخي",
              "ﶢ",
              "تخى",
              "ﶣ",
              "تمي",
              "ﶤ",
              "تمى",
              "ﶥ",
              "جمي",
              "ﶦ",
              "جحى",
              "ﶧ",
              "جمى",
              "ﶨ",
              "سخى",
              "ﶩ",
              "صحي",
              "ﶪ",
              "شحي",
              "ﶫ",
              "ضحي",
              "ﶬ",
              "لجي",
              "ﶭ",
              "لمي",
              "ﶮ",
              "يحي",
              "ﶯ",
              "يجي",
              "ﶰ",
              "يمي",
              "ﶱ",
              "ممي",
              "ﶲ",
              "قمي",
              "ﶳ",
              "نحي",
              "ﶴ",
              "قمح",
              "ﶵ",
              "لحم",
              "ﶶ",
              "عمي",
              "ﶷ",
              "كمي",
              "ﶸ",
              "نجح",
              "ﶹ",
              "مخي",
              "ﶺ",
              "لجم",
              "ﶻ",
              "كمم",
              "ﶼ",
              "لجم",
              "ﶽ",
              "نجح",
              "ﶾ",
              "جحي",
              "ﶿ",
              "حجي",
              "ﷀ",
              "مجي",
              "ﷁ",
              "فمي",
              "ﷂ",
              "بحي",
              "ﷃ",
              "كمم",
              "ﷄ",
              "عجم",
              "ﷅ",
              "صمم",
              "ﷆ",
              "سخي",
              "ﷇ",
              "نجي",
              "﹉",
              "‾",
              "﹊",
              "‾",
              "﹋",
              "‾",
              "﹌",
              "‾",
              "﹍",
              "_",
              "﹎",
              "_",
              "﹏",
              "_",
              "ﺀ",
              "ء",
              "ﺁ",
              "آ",
              "ﺂ",
              "آ",
              "ﺃ",
              "أ",
              "ﺄ",
              "أ",
              "ﺅ",
              "ؤ",
              "ﺆ",
              "ؤ",
              "ﺇ",
              "إ",
              "ﺈ",
              "إ",
              "ﺉ",
              "ئ",
              "ﺊ",
              "ئ",
              "ﺋ",
              "ئ",
              "ﺌ",
              "ئ",
              "ﺍ",
              "ا",
              "ﺎ",
              "ا",
              "ﺏ",
              "ب",
              "ﺐ",
              "ب",
              "ﺑ",
              "ب",
              "ﺒ",
              "ب",
              "ﺓ",
              "ة",
              "ﺔ",
              "ة",
              "ﺕ",
              "ت",
              "ﺖ",
              "ت",
              "ﺗ",
              "ت",
              "ﺘ",
              "ت",
              "ﺙ",
              "ث",
              "ﺚ",
              "ث",
              "ﺛ",
              "ث",
              "ﺜ",
              "ث",
              "ﺝ",
              "ج",
              "ﺞ",
              "ج",
              "ﺟ",
              "ج",
              "ﺠ",
              "ج",
              "ﺡ",
              "ح",
              "ﺢ",
              "ح",
              "ﺣ",
              "ح",
              "ﺤ",
              "ح",
              "ﺥ",
              "خ",
              "ﺦ",
              "خ",
              "ﺧ",
              "خ",
              "ﺨ",
              "خ",
              "ﺩ",
              "د",
              "ﺪ",
              "د",
              "ﺫ",
              "ذ",
              "ﺬ",
              "ذ",
              "ﺭ",
              "ر",
              "ﺮ",
              "ر",
              "ﺯ",
              "ز",
              "ﺰ",
              "ز",
              "ﺱ",
              "س",
              "ﺲ",
              "س",
              "ﺳ",
              "س",
              "ﺴ",
              "س",
              "ﺵ",
              "ش",
              "ﺶ",
              "ش",
              "ﺷ",
              "ش",
              "ﺸ",
              "ش",
              "ﺹ",
              "ص",
              "ﺺ",
              "ص",
              "ﺻ",
              "ص",
              "ﺼ",
              "ص",
              "ﺽ",
              "ض",
              "ﺾ",
              "ض",
              "ﺿ",
              "ض",
              "ﻀ",
              "ض",
              "ﻁ",
              "ط",
              "ﻂ",
              "ط",
              "ﻃ",
              "ط",
              "ﻄ",
              "ط",
              "ﻅ",
              "ظ",
              "ﻆ",
              "ظ",
              "ﻇ",
              "ظ",
              "ﻈ",
              "ظ",
              "ﻉ",
              "ع",
              "ﻊ",
              "ع",
              "ﻋ",
              "ع",
              "ﻌ",
              "ع",
              "ﻍ",
              "غ",
              "ﻎ",
              "غ",
              "ﻏ",
              "غ",
              "ﻐ",
              "غ",
              "ﻑ",
              "ف",
              "ﻒ",
              "ف",
              "ﻓ",
              "ف",
              "ﻔ",
              "ف",
              "ﻕ",
              "ق",
              "ﻖ",
              "ق",
              "ﻗ",
              "ق",
              "ﻘ",
              "ق",
              "ﻙ",
              "ك",
              "ﻚ",
              "ك",
              "ﻛ",
              "ك",
              "ﻜ",
              "ك",
              "ﻝ",
              "ل",
              "ﻞ",
              "ل",
              "ﻟ",
              "ل",
              "ﻠ",
              "ل",
              "ﻡ",
              "م",
              "ﻢ",
              "م",
              "ﻣ",
              "م",
              "ﻤ",
              "م",
              "ﻥ",
              "ن",
              "ﻦ",
              "ن",
              "ﻧ",
              "ن",
              "ﻨ",
              "ن",
              "ﻩ",
              "ه",
              "ﻪ",
              "ه",
              "ﻫ",
              "ه",
              "ﻬ",
              "ه",
              "ﻭ",
              "و",
              "ﻮ",
              "و",
              "ﻯ",
              "ى",
              "ﻰ",
              "ى",
              "ﻱ",
              "ي",
              "ﻲ",
              "ي",
              "ﻳ",
              "ي",
              "ﻴ",
              "ي",
              "ﻵ",
              "لآ",
              "ﻶ",
              "لآ",
              "ﻷ",
              "لأ",
              "ﻸ",
              "لأ",
              "ﻹ",
              "لإ",
              "ﻺ",
              "لإ",
              "ﻻ",
              "لا",
              "ﻼ",
              "لا"
            ];
          });
          function m(l) {
            const u = l.length;
            if (u <= 1 || !c(l.charCodeAt(0)))
              return l;
            const w = [];
            for (let O = u - 1; O >= 0; O--)
              w.push(l[O]);
            return w.join("");
          }
          const p = new RegExp("^(\\s)|(\\p{Mn})|(\\p{Cf})$", "u"), g = /* @__PURE__ */ new Map();
          function n(l) {
            const u = g.get(l);
            if (u)
              return u;
            const w = l.match(p), O = {
              isWhitespace: !!(w && w[1]),
              isZeroWidthDiacritic: !!(w && w[2]),
              isInvisibleFormatMark: !!(w && w[3])
            };
            return g.set(l, O), O;
          }
          function i() {
            g.clear();
          }
        },
        /* 41 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.getSerifFonts = o.getNonStdFontMap = o.getGlyphMapForStandardFonts = o.getFontNameToFileMap = void 0, o.getStandardFontName = g, o.getSymbolsFonts = o.getSupplementalGlyphMapForCalibri = o.getSupplementalGlyphMapForArialBlack = o.getStdFontMap = void 0;
          var t = F(6), a = F(38);
          const v = (0, t.getLookupTableFactory)(function(n) {
            n["Times-Roman"] = "Times-Roman", n.Helvetica = "Helvetica", n.Courier = "Courier", n.Symbol = "Symbol", n["Times-Bold"] = "Times-Bold", n["Helvetica-Bold"] = "Helvetica-Bold", n["Courier-Bold"] = "Courier-Bold", n.ZapfDingbats = "ZapfDingbats", n["Times-Italic"] = "Times-Italic", n["Helvetica-Oblique"] = "Helvetica-Oblique", n["Courier-Oblique"] = "Courier-Oblique", n["Times-BoldItalic"] = "Times-BoldItalic", n["Helvetica-BoldOblique"] = "Helvetica-BoldOblique", n["Courier-BoldOblique"] = "Courier-BoldOblique", n.ArialNarrow = "Helvetica", n["ArialNarrow-Bold"] = "Helvetica-Bold", n["ArialNarrow-BoldItalic"] = "Helvetica-BoldOblique", n["ArialNarrow-Italic"] = "Helvetica-Oblique", n.ArialBlack = "Helvetica", n["ArialBlack-Bold"] = "Helvetica-Bold", n["ArialBlack-BoldItalic"] = "Helvetica-BoldOblique", n["ArialBlack-Italic"] = "Helvetica-Oblique", n["Arial-Black"] = "Helvetica", n["Arial-Black-Bold"] = "Helvetica-Bold", n["Arial-Black-BoldItalic"] = "Helvetica-BoldOblique", n["Arial-Black-Italic"] = "Helvetica-Oblique", n.Arial = "Helvetica", n["Arial-Bold"] = "Helvetica-Bold", n["Arial-BoldItalic"] = "Helvetica-BoldOblique", n["Arial-Italic"] = "Helvetica-Oblique", n.ArialMT = "Helvetica", n["Arial-BoldItalicMT"] = "Helvetica-BoldOblique", n["Arial-BoldMT"] = "Helvetica-Bold", n["Arial-ItalicMT"] = "Helvetica-Oblique", n.ArialUnicodeMS = "Helvetica", n["ArialUnicodeMS-Bold"] = "Helvetica-Bold", n["ArialUnicodeMS-BoldItalic"] = "Helvetica-BoldOblique", n["ArialUnicodeMS-Italic"] = "Helvetica-Oblique", n["Courier-BoldItalic"] = "Courier-BoldOblique", n["Courier-Italic"] = "Courier-Oblique", n.CourierNew = "Courier", n["CourierNew-Bold"] = "Courier-Bold", n["CourierNew-BoldItalic"] = "Courier-BoldOblique", n["CourierNew-Italic"] = "Courier-Oblique", n["CourierNewPS-BoldItalicMT"] = "Courier-BoldOblique", n["CourierNewPS-BoldMT"] = "Courier-Bold", n["CourierNewPS-ItalicMT"] = "Courier-Oblique", n.CourierNewPSMT = "Courier", n["Helvetica-BoldItalic"] = "Helvetica-BoldOblique", n["Helvetica-Italic"] = "Helvetica-Oblique", n["Symbol-Bold"] = "Symbol", n["Symbol-BoldItalic"] = "Symbol", n["Symbol-Italic"] = "Symbol", n.TimesNewRoman = "Times-Roman", n["TimesNewRoman-Bold"] = "Times-Bold", n["TimesNewRoman-BoldItalic"] = "Times-BoldItalic", n["TimesNewRoman-Italic"] = "Times-Italic", n.TimesNewRomanPS = "Times-Roman", n["TimesNewRomanPS-Bold"] = "Times-Bold", n["TimesNewRomanPS-BoldItalic"] = "Times-BoldItalic", n["TimesNewRomanPS-BoldItalicMT"] = "Times-BoldItalic", n["TimesNewRomanPS-BoldMT"] = "Times-Bold", n["TimesNewRomanPS-Italic"] = "Times-Italic", n["TimesNewRomanPS-ItalicMT"] = "Times-Italic", n.TimesNewRomanPSMT = "Times-Roman", n["TimesNewRomanPSMT-Bold"] = "Times-Bold", n["TimesNewRomanPSMT-BoldItalic"] = "Times-BoldItalic", n["TimesNewRomanPSMT-Italic"] = "Times-Italic";
          });
          o.getStdFontMap = v;
          const h = (0, t.getLookupTableFactory)(function(n) {
            n.Courier = "FoxitFixed.pfb", n["Courier-Bold"] = "FoxitFixedBold.pfb", n["Courier-BoldOblique"] = "FoxitFixedBoldItalic.pfb", n["Courier-Oblique"] = "FoxitFixedItalic.pfb", n.Helvetica = "FoxitSans.pfb", n["Helvetica-Bold"] = "FoxitSansBold.pfb", n["Helvetica-BoldOblique"] = "FoxitSansBoldItalic.pfb", n["Helvetica-Oblique"] = "FoxitSansItalic.pfb", n["Times-Roman"] = "FoxitSerif.pfb", n["Times-Bold"] = "FoxitSerifBold.pfb", n["Times-BoldItalic"] = "FoxitSerifBoldItalic.pfb", n["Times-Italic"] = "FoxitSerifItalic.pfb", n.Symbol = "FoxitSymbol.pfb", n.ZapfDingbats = "FoxitDingbats.pfb", n["LiberationSans-Regular"] = "LiberationSans-Regular.ttf", n["LiberationSans-Bold"] = "LiberationSans-Bold.ttf", n["LiberationSans-Italic"] = "LiberationSans-Italic.ttf", n["LiberationSans-BoldItalic"] = "LiberationSans-BoldItalic.ttf";
          });
          o.getFontNameToFileMap = h;
          const e = (0, t.getLookupTableFactory)(function(n) {
            n.Calibri = "Helvetica", n["Calibri-Bold"] = "Helvetica-Bold", n["Calibri-BoldItalic"] = "Helvetica-BoldOblique", n["Calibri-Italic"] = "Helvetica-Oblique", n.CenturyGothic = "Helvetica", n["CenturyGothic-Bold"] = "Helvetica-Bold", n["CenturyGothic-BoldItalic"] = "Helvetica-BoldOblique", n["CenturyGothic-Italic"] = "Helvetica-Oblique", n.ComicSansMS = "Comic Sans MS", n["ComicSansMS-Bold"] = "Comic Sans MS-Bold", n["ComicSansMS-BoldItalic"] = "Comic Sans MS-BoldItalic", n["ComicSansMS-Italic"] = "Comic Sans MS-Italic", n["ItcSymbol-Bold"] = "Helvetica-Bold", n["ItcSymbol-BoldItalic"] = "Helvetica-BoldOblique", n["ItcSymbol-Book"] = "Helvetica", n["ItcSymbol-BookItalic"] = "Helvetica-Oblique", n["ItcSymbol-Medium"] = "Helvetica", n["ItcSymbol-MediumItalic"] = "Helvetica-Oblique", n.LucidaConsole = "Courier", n["LucidaConsole-Bold"] = "Courier-Bold", n["LucidaConsole-BoldItalic"] = "Courier-BoldOblique", n["LucidaConsole-Italic"] = "Courier-Oblique", n["LucidaSans-Demi"] = "Helvetica-Bold", n["MS-Gothic"] = "MS Gothic", n["MS-Gothic-Bold"] = "MS Gothic-Bold", n["MS-Gothic-BoldItalic"] = "MS Gothic-BoldItalic", n["MS-Gothic-Italic"] = "MS Gothic-Italic", n["MS-Mincho"] = "MS Mincho", n["MS-Mincho-Bold"] = "MS Mincho-Bold", n["MS-Mincho-BoldItalic"] = "MS Mincho-BoldItalic", n["MS-Mincho-Italic"] = "MS Mincho-Italic", n["MS-PGothic"] = "MS PGothic", n["MS-PGothic-Bold"] = "MS PGothic-Bold", n["MS-PGothic-BoldItalic"] = "MS PGothic-BoldItalic", n["MS-PGothic-Italic"] = "MS PGothic-Italic", n["MS-PMincho"] = "MS PMincho", n["MS-PMincho-Bold"] = "MS PMincho-Bold", n["MS-PMincho-BoldItalic"] = "MS PMincho-BoldItalic", n["MS-PMincho-Italic"] = "MS PMincho-Italic", n.NuptialScript = "Times-Italic", n.SegoeUISymbol = "Helvetica", n.Wingdings = "ZapfDingbats", n["Wingdings-Regular"] = "ZapfDingbats";
          });
          o.getNonStdFontMap = e;
          const y = (0, t.getLookupTableFactory)(function(n) {
            n["Adobe Jenson"] = !0, n["Adobe Text"] = !0, n.Albertus = !0, n.Aldus = !0, n.Alexandria = !0, n.Algerian = !0, n["American Typewriter"] = !0, n.Antiqua = !0, n.Apex = !0, n.Arno = !0, n.Aster = !0, n.Aurora = !0, n.Baskerville = !0, n.Bell = !0, n.Bembo = !0, n["Bembo Schoolbook"] = !0, n.Benguiat = !0, n["Berkeley Old Style"] = !0, n["Bernhard Modern"] = !0, n["Berthold City"] = !0, n.Bodoni = !0, n["Bauer Bodoni"] = !0, n["Book Antiqua"] = !0, n.Bookman = !0, n["Bordeaux Roman"] = !0, n["Californian FB"] = !0, n.Calisto = !0, n.Calvert = !0, n.Capitals = !0, n.Cambria = !0, n.Cartier = !0, n.Caslon = !0, n.Catull = !0, n.Centaur = !0, n["Century Old Style"] = !0, n["Century Schoolbook"] = !0, n.Chaparral = !0, n["Charis SIL"] = !0, n.Cheltenham = !0, n["Cholla Slab"] = !0, n.Clarendon = !0, n.Clearface = !0, n.Cochin = !0, n.Colonna = !0, n["Computer Modern"] = !0, n["Concrete Roman"] = !0, n.Constantia = !0, n["Cooper Black"] = !0, n.Corona = !0, n.Ecotype = !0, n.Egyptienne = !0, n.Elephant = !0, n.Excelsior = !0, n.Fairfield = !0, n["FF Scala"] = !0, n.Folkard = !0, n.Footlight = !0, n.FreeSerif = !0, n["Friz Quadrata"] = !0, n.Garamond = !0, n.Gentium = !0, n.Georgia = !0, n.Gloucester = !0, n["Goudy Old Style"] = !0, n["Goudy Schoolbook"] = !0, n["Goudy Pro Font"] = !0, n.Granjon = !0, n["Guardian Egyptian"] = !0, n.Heather = !0, n.Hercules = !0, n["High Tower Text"] = !0, n.Hiroshige = !0, n["Hoefler Text"] = !0, n["Humana Serif"] = !0, n.Imprint = !0, n["Ionic No. 5"] = !0, n.Janson = !0, n.Joanna = !0, n.Korinna = !0, n.Lexicon = !0, n.LiberationSerif = !0, n["Liberation Serif"] = !0, n["Linux Libertine"] = !0, n.Literaturnaya = !0, n.Lucida = !0, n["Lucida Bright"] = !0, n.Melior = !0, n.Memphis = !0, n.Miller = !0, n.Minion = !0, n.Modern = !0, n["Mona Lisa"] = !0, n["Mrs Eaves"] = !0, n["MS Serif"] = !0, n["Museo Slab"] = !0, n["New York"] = !0, n["Nimbus Roman"] = !0, n["NPS Rawlinson Roadway"] = !0, n.NuptialScript = !0, n.Palatino = !0, n.Perpetua = !0, n.Plantin = !0, n["Plantin Schoolbook"] = !0, n.Playbill = !0, n["Poor Richard"] = !0, n["Rawlinson Roadway"] = !0, n.Renault = !0, n.Requiem = !0, n.Rockwell = !0, n.Roman = !0, n["Rotis Serif"] = !0, n.Sabon = !0, n.Scala = !0, n.Seagull = !0, n.Sistina = !0, n.Souvenir = !0, n.STIX = !0, n["Stone Informal"] = !0, n["Stone Serif"] = !0, n.Sylfaen = !0, n.Times = !0, n.Trajan = !0, n.Trinité = !0, n["Trump Mediaeval"] = !0, n.Utopia = !0, n["Vale Type"] = !0, n["Bitstream Vera"] = !0, n["Vera Serif"] = !0, n.Versailles = !0, n.Wanted = !0, n.Weiss = !0, n["Wide Latin"] = !0, n.Windsor = !0, n.XITS = !0;
          });
          o.getSerifFonts = y;
          const c = (0, t.getLookupTableFactory)(function(n) {
            n.Dingbats = !0, n.Symbol = !0, n.ZapfDingbats = !0;
          });
          o.getSymbolsFonts = c;
          const d = (0, t.getLookupTableFactory)(function(n) {
            n[2] = 10, n[3] = 32, n[4] = 33, n[5] = 34, n[6] = 35, n[7] = 36, n[8] = 37, n[9] = 38, n[10] = 39, n[11] = 40, n[12] = 41, n[13] = 42, n[14] = 43, n[15] = 44, n[16] = 45, n[17] = 46, n[18] = 47, n[19] = 48, n[20] = 49, n[21] = 50, n[22] = 51, n[23] = 52, n[24] = 53, n[25] = 54, n[26] = 55, n[27] = 56, n[28] = 57, n[29] = 58, n[30] = 894, n[31] = 60, n[32] = 61, n[33] = 62, n[34] = 63, n[35] = 64, n[36] = 65, n[37] = 66, n[38] = 67, n[39] = 68, n[40] = 69, n[41] = 70, n[42] = 71, n[43] = 72, n[44] = 73, n[45] = 74, n[46] = 75, n[47] = 76, n[48] = 77, n[49] = 78, n[50] = 79, n[51] = 80, n[52] = 81, n[53] = 82, n[54] = 83, n[55] = 84, n[56] = 85, n[57] = 86, n[58] = 87, n[59] = 88, n[60] = 89, n[61] = 90, n[62] = 91, n[63] = 92, n[64] = 93, n[65] = 94, n[66] = 95, n[67] = 96, n[68] = 97, n[69] = 98, n[70] = 99, n[71] = 100, n[72] = 101, n[73] = 102, n[74] = 103, n[75] = 104, n[76] = 105, n[77] = 106, n[78] = 107, n[79] = 108, n[80] = 109, n[81] = 110, n[82] = 111, n[83] = 112, n[84] = 113, n[85] = 114, n[86] = 115, n[87] = 116, n[88] = 117, n[89] = 118, n[90] = 119, n[91] = 120, n[92] = 121, n[93] = 122, n[94] = 123, n[95] = 124, n[96] = 125, n[97] = 126, n[98] = 196, n[99] = 197, n[100] = 199, n[101] = 201, n[102] = 209, n[103] = 214, n[104] = 220, n[105] = 225, n[106] = 224, n[107] = 226, n[108] = 228, n[109] = 227, n[110] = 229, n[111] = 231, n[112] = 233, n[113] = 232, n[114] = 234, n[115] = 235, n[116] = 237, n[117] = 236, n[118] = 238, n[119] = 239, n[120] = 241, n[121] = 243, n[122] = 242, n[123] = 244, n[124] = 246, n[125] = 245, n[126] = 250, n[127] = 249, n[128] = 251, n[129] = 252, n[130] = 8224, n[131] = 176, n[132] = 162, n[133] = 163, n[134] = 167, n[135] = 8226, n[136] = 182, n[137] = 223, n[138] = 174, n[139] = 169, n[140] = 8482, n[141] = 180, n[142] = 168, n[143] = 8800, n[144] = 198, n[145] = 216, n[146] = 8734, n[147] = 177, n[148] = 8804, n[149] = 8805, n[150] = 165, n[151] = 181, n[152] = 8706, n[153] = 8721, n[154] = 8719, n[156] = 8747, n[157] = 170, n[158] = 186, n[159] = 8486, n[160] = 230, n[161] = 248, n[162] = 191, n[163] = 161, n[164] = 172, n[165] = 8730, n[166] = 402, n[167] = 8776, n[168] = 8710, n[169] = 171, n[170] = 187, n[171] = 8230, n[200] = 193, n[203] = 205, n[210] = 218, n[223] = 711, n[224] = 321, n[225] = 322, n[226] = 352, n[227] = 353, n[228] = 381, n[229] = 382, n[233] = 221, n[234] = 253, n[252] = 263, n[253] = 268, n[254] = 269, n[258] = 258, n[260] = 260, n[261] = 261, n[265] = 280, n[266] = 281, n[267] = 282, n[268] = 283, n[269] = 313, n[275] = 323, n[276] = 324, n[278] = 328, n[283] = 344, n[284] = 345, n[285] = 346, n[286] = 347, n[292] = 367, n[295] = 377, n[296] = 378, n[298] = 380, n[305] = 963, n[306] = 964, n[307] = 966, n[308] = 8215, n[309] = 8252, n[310] = 8319, n[311] = 8359, n[312] = 8592, n[313] = 8593, n[337] = 9552, n[493] = 1039, n[494] = 1040, n[672] = 1488, n[673] = 1489, n[674] = 1490, n[675] = 1491, n[676] = 1492, n[677] = 1493, n[678] = 1494, n[679] = 1495, n[680] = 1496, n[681] = 1497, n[682] = 1498, n[683] = 1499, n[684] = 1500, n[685] = 1501, n[686] = 1502, n[687] = 1503, n[688] = 1504, n[689] = 1505, n[690] = 1506, n[691] = 1507, n[692] = 1508, n[693] = 1509, n[694] = 1510, n[695] = 1511, n[696] = 1512, n[697] = 1513, n[698] = 1514, n[705] = 1524, n[706] = 8362, n[710] = 64288, n[711] = 64298, n[759] = 1617, n[761] = 1776, n[763] = 1778, n[775] = 1652, n[777] = 1764, n[778] = 1780, n[779] = 1781, n[780] = 1782, n[782] = 771, n[783] = 64726, n[786] = 8363, n[788] = 8532, n[790] = 768, n[791] = 769, n[792] = 768, n[795] = 803, n[797] = 64336, n[798] = 64337, n[799] = 64342, n[800] = 64343, n[801] = 64344, n[802] = 64345, n[803] = 64362, n[804] = 64363, n[805] = 64364, n[2424] = 7821, n[2425] = 7822, n[2426] = 7823, n[2427] = 7824, n[2428] = 7825, n[2429] = 7826, n[2430] = 7827, n[2433] = 7682, n[2678] = 8045, n[2679] = 8046, n[2830] = 1552, n[2838] = 686, n[2840] = 751, n[2842] = 753, n[2843] = 754, n[2844] = 755, n[2846] = 757, n[2856] = 767, n[2857] = 848, n[2858] = 849, n[2862] = 853, n[2863] = 854, n[2864] = 855, n[2865] = 861, n[2866] = 862, n[2906] = 7460, n[2908] = 7462, n[2909] = 7463, n[2910] = 7464, n[2912] = 7466, n[2913] = 7467, n[2914] = 7468, n[2916] = 7470, n[2917] = 7471, n[2918] = 7472, n[2920] = 7474, n[2921] = 7475, n[2922] = 7476, n[2924] = 7478, n[2925] = 7479, n[2926] = 7480, n[2928] = 7482, n[2929] = 7483, n[2930] = 7484, n[2932] = 7486, n[2933] = 7487, n[2934] = 7488, n[2936] = 7490, n[2937] = 7491, n[2938] = 7492, n[2940] = 7494, n[2941] = 7495, n[2942] = 7496, n[2944] = 7498, n[2946] = 7500, n[2948] = 7502, n[2950] = 7504, n[2951] = 7505, n[2952] = 7506, n[2954] = 7508, n[2955] = 7509, n[2956] = 7510, n[2958] = 7512, n[2959] = 7513, n[2960] = 7514, n[2962] = 7516, n[2963] = 7517, n[2964] = 7518, n[2966] = 7520, n[2967] = 7521, n[2968] = 7522, n[2970] = 7524, n[2971] = 7525, n[2972] = 7526, n[2974] = 7528, n[2975] = 7529, n[2976] = 7530, n[2978] = 1537, n[2979] = 1538, n[2980] = 1539, n[2982] = 1549, n[2983] = 1551, n[2984] = 1552, n[2986] = 1554, n[2987] = 1555, n[2988] = 1556, n[2990] = 1623, n[2991] = 1624, n[2995] = 1775, n[2999] = 1791, n[3002] = 64290, n[3003] = 64291, n[3004] = 64292, n[3006] = 64294, n[3007] = 64295, n[3008] = 64296, n[3011] = 1900, n[3014] = 8223, n[3015] = 8244, n[3017] = 7532, n[3018] = 7533, n[3019] = 7534, n[3075] = 7590, n[3076] = 7591, n[3079] = 7594, n[3080] = 7595, n[3083] = 7598, n[3084] = 7599, n[3087] = 7602, n[3088] = 7603, n[3091] = 7606, n[3092] = 7607, n[3095] = 7610, n[3096] = 7611, n[3099] = 7614, n[3100] = 7615, n[3103] = 7618, n[3104] = 7619, n[3107] = 8337, n[3108] = 8338, n[3116] = 1884, n[3119] = 1885, n[3120] = 1885, n[3123] = 1886, n[3124] = 1886, n[3127] = 1887, n[3128] = 1887, n[3131] = 1888, n[3132] = 1888, n[3135] = 1889, n[3136] = 1889, n[3139] = 1890, n[3140] = 1890, n[3143] = 1891, n[3144] = 1891, n[3147] = 1892, n[3148] = 1892, n[3153] = 580, n[3154] = 581, n[3157] = 584, n[3158] = 585, n[3161] = 588, n[3162] = 589, n[3165] = 891, n[3166] = 892, n[3169] = 1274, n[3170] = 1275, n[3173] = 1278, n[3174] = 1279, n[3181] = 7622, n[3182] = 7623, n[3282] = 11799, n[3316] = 578, n[3379] = 42785, n[3393] = 1159, n[3416] = 8377;
          });
          o.getGlyphMapForStandardFonts = d;
          const m = (0, t.getLookupTableFactory)(function(n) {
            n[227] = 322, n[264] = 261, n[291] = 346;
          });
          o.getSupplementalGlyphMapForArialBlack = m;
          const p = (0, t.getLookupTableFactory)(function(n) {
            n[1] = 32, n[4] = 65, n[6] = 193, n[17] = 66, n[18] = 67, n[21] = 268, n[24] = 68, n[28] = 69, n[30] = 201, n[32] = 282, n[38] = 70, n[39] = 71, n[44] = 72, n[47] = 73, n[49] = 205, n[58] = 74, n[60] = 75, n[62] = 76, n[68] = 77, n[69] = 78, n[75] = 79, n[87] = 80, n[89] = 81, n[90] = 82, n[92] = 344, n[94] = 83, n[97] = 352, n[100] = 84, n[104] = 85, n[115] = 86, n[116] = 87, n[121] = 88, n[122] = 89, n[124] = 221, n[127] = 90, n[129] = 381, n[258] = 97, n[260] = 225, n[268] = 261, n[271] = 98, n[272] = 99, n[273] = 263, n[275] = 269, n[282] = 100, n[286] = 101, n[288] = 233, n[290] = 283, n[295] = 281, n[296] = 102, n[336] = 103, n[346] = 104, n[349] = 105, n[351] = 237, n[361] = 106, n[364] = 107, n[367] = 108, n[371] = 322, n[373] = 109, n[374] = 110, n[381] = 111, n[383] = 243, n[393] = 112, n[395] = 113, n[396] = 114, n[398] = 345, n[400] = 115, n[401] = 347, n[403] = 353, n[410] = 116, n[437] = 117, n[448] = 118, n[449] = 119, n[454] = 120, n[455] = 121, n[457] = 253, n[460] = 122, n[462] = 382, n[463] = 380, n[853] = 44, n[855] = 58, n[856] = 46, n[876] = 47, n[878] = 45, n[882] = 45, n[894] = 40, n[895] = 41, n[896] = 91, n[897] = 93, n[923] = 64, n[1004] = 48, n[1005] = 49, n[1006] = 50, n[1007] = 51, n[1008] = 52, n[1009] = 53, n[1010] = 54, n[1011] = 55, n[1012] = 56, n[1013] = 57, n[1081] = 37, n[1085] = 43, n[1086] = 45;
          });
          o.getSupplementalGlyphMapForCalibri = p;
          function g(n) {
            const i = (0, a.normalizeFontName)(n);
            return v()[i];
          }
        },
        /* 42 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.ToUnicodeMap = o.IdentityToUnicodeMap = void 0;
          var t = F(2);
          class a {
            constructor(e = []) {
              this._map = e;
            }
            get length() {
              return this._map.length;
            }
            forEach(e) {
              for (const y in this._map)
                e(y, this._map[y].charCodeAt(0));
            }
            has(e) {
              return this._map[e] !== void 0;
            }
            get(e) {
              return this._map[e];
            }
            charCodeOf(e) {
              const y = this._map;
              if (y.length <= 65536)
                return y.indexOf(e);
              for (const c in y)
                if (y[c] === e)
                  return c | 0;
              return -1;
            }
            amend(e) {
              for (const y in e)
                this._map[y] = e[y];
            }
          }
          o.ToUnicodeMap = a;
          class v {
            constructor(e, y) {
              this.firstChar = e, this.lastChar = y;
            }
            get length() {
              return this.lastChar + 1 - this.firstChar;
            }
            forEach(e) {
              for (let y = this.firstChar, c = this.lastChar; y <= c; y++)
                e(y, y);
            }
            has(e) {
              return this.firstChar <= e && e <= this.lastChar;
            }
            get(e) {
              if (this.firstChar <= e && e <= this.lastChar)
                return String.fromCharCode(e);
            }
            charCodeOf(e) {
              return Number.isInteger(e) && e >= this.firstChar && e <= this.lastChar ? e : -1;
            }
            amend(e) {
              (0, t.unreachable)("Should not call amend()");
            }
          }
          o.IdentityToUnicodeMap = v;
        },
        /* 43 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.CFFFont = void 0;
          var t = F(35), a = F(38), v = F(2);
          class h {
            constructor(y, c) {
              this.properties = c;
              const d = new t.CFFParser(y, c, a.SEAC_ANALYSIS_ENABLED);
              this.cff = d.parse(), this.cff.duplicateFirstGlyph();
              const m = new t.CFFCompiler(this.cff);
              this.seacs = this.cff.seacs;
              try {
                this.data = m.compile();
              } catch {
                (0, v.warn)("Failed to compile font " + c.loadedName), this.data = y;
              }
              this._createBuiltInEncoding();
            }
            get numGlyphs() {
              return this.cff.charStrings.count;
            }
            getCharset() {
              return this.cff.charset.charset;
            }
            getGlyphMapping() {
              const y = this.cff, c = this.properties, d = y.charset.charset;
              let m, p;
              if (c.composite) {
                m = /* @__PURE__ */ Object.create(null);
                let n;
                if (y.isCIDFont)
                  for (p = 0; p < d.length; p++) {
                    const i = d[p];
                    n = c.cMap.charCodeOf(i), m[n] = p;
                  }
                else
                  for (p = 0; p < y.charStrings.count; p++)
                    n = c.cMap.charCodeOf(p), m[n] = p;
                return m;
              }
              let g = y.encoding ? y.encoding.encoding : null;
              return c.isInternalFont && (g = c.defaultEncoding), m = (0, a.type1FontGlyphMapping)(c, g, d), m;
            }
            hasGlyphId(y) {
              return this.cff.hasGlyphId(y);
            }
            _createBuiltInEncoding() {
              const {
                charset: y,
                encoding: c
              } = this.cff;
              if (!y || !c)
                return;
              const d = y.charset, m = c.encoding, p = [];
              for (const g in m) {
                const n = m[g];
                if (n >= 0) {
                  const i = d[n];
                  i && (p[g] = i);
                }
              }
              p.length > 0 && (this.properties.builtInEncoding = p);
            }
          }
          o.CFFFont = h;
        },
        /* 44 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.FontRendererFactory = void 0;
          var t = F(2), a = F(35), v = F(39), h = F(37), e = F(10);
          function y(B, U) {
            return (B[U] << 24 | B[U + 1] << 16 | B[U + 2] << 8 | B[U + 3]) >>> 0;
          }
          function c(B, U) {
            return B[U] << 8 | B[U + 1];
          }
          function d(B, U) {
            return (B[U] << 24 | B[U + 1] << 16) >> 16;
          }
          function m(B, U) {
            return B[U] << 24 >> 24;
          }
          function p(B, U) {
            return d(B, U) / 16384;
          }
          function g(B) {
            const U = B.length;
            let k = 32768;
            return U < 1240 ? k = 107 : U < 33900 && (k = 1131), k;
          }
          function n(B, U, k) {
            const x = c(B, U + 2) === 1 ? y(B, U + 8) : y(B, U + 16), f = c(B, U + x);
            let D, _, S;
            if (f === 4) {
              c(B, U + x + 2);
              const C = c(B, U + x + 6) >> 1;
              for (_ = U + x + 14, D = [], S = 0; S < C; S++, _ += 2)
                D[S] = {
                  end: c(B, _)
                };
              for (_ += 2, S = 0; S < C; S++, _ += 2)
                D[S].start = c(B, _);
              for (S = 0; S < C; S++, _ += 2)
                D[S].idDelta = c(B, _);
              for (S = 0; S < C; S++, _ += 2) {
                let T = c(B, _);
                if (T !== 0) {
                  D[S].ids = [];
                  for (let P = 0, M = D[S].end - D[S].start + 1; P < M; P++)
                    D[S].ids[P] = c(B, _ + T), T += 2;
                }
              }
              return D;
            } else if (f === 12) {
              const C = y(B, U + x + 12);
              for (_ = U + x + 16, D = [], S = 0; S < C; S++)
                U = y(B, _), D.push({
                  start: U,
                  end: y(B, _ + 4),
                  idDelta: y(B, _ + 8) - U
                }), _ += 12;
              return D;
            }
            throw new t.FormatError(`unsupported cmap: ${f}`);
          }
          function i(B, U, k, x) {
            const f = {}, _ = new a.CFFParser(new e.Stream(B, U, k - U), f, x).parse();
            return {
              glyphs: _.charStrings.objects,
              subrs: _.topDict.privateDict && _.topDict.privateDict.subrsIndex && _.topDict.privateDict.subrsIndex.objects,
              gsubrs: _.globalSubrIndex && _.globalSubrIndex.objects,
              isCFFCIDFont: _.isCIDFont,
              fdSelect: _.fdSelect,
              fdArray: _.fdArray
            };
          }
          function l(B, U, k) {
            let x, f;
            k ? (x = 4, f = y) : (x = 2, f = (S, C) => 2 * c(S, C));
            const D = [];
            let _ = f(U, 0);
            for (let S = x; S < U.length; S += x) {
              const C = f(U, S);
              D.push(B.subarray(_, C)), _ = C;
            }
            return D;
          }
          function u(B, U) {
            const k = U.codePointAt(0);
            let x = 0, f = 0, D = B.length - 1;
            for (; f < D; ) {
              const _ = f + D + 1 >> 1;
              k < B[_].start ? D = _ - 1 : f = _;
            }
            return B[f].start <= k && k <= B[f].end && (x = B[f].idDelta + (B[f].ids ? B[f].ids[k - B[f].start] : k) & 65535), {
              charCode: k,
              glyphId: x
            };
          }
          function w(B, U, k) {
            function x(M, G) {
              U.push({
                cmd: "moveTo",
                args: [M, G]
              });
            }
            function f(M, G) {
              U.push({
                cmd: "lineTo",
                args: [M, G]
              });
            }
            function D(M, G, Z, $) {
              U.push({
                cmd: "quadraticCurveTo",
                args: [M, G, Z, $]
              });
            }
            let _ = 0;
            const S = d(B, _);
            let C, T = 0, P = 0;
            if (_ += 10, S < 0)
              do {
                C = c(B, _);
                const M = c(B, _ + 2);
                _ += 4;
                let G, Z;
                C & 1 ? (C & 2 ? (G = d(B, _), Z = d(B, _ + 2)) : (G = c(B, _), Z = c(B, _ + 2)), _ += 4) : C & 2 ? (G = m(B, _++), Z = m(B, _++)) : (G = B[_++], Z = B[_++]), C & 2 ? (T = G, P = Z) : (T = 0, P = 0);
                let $ = 1, z = 1, V = 0, L = 0;
                C & 8 ? ($ = z = p(B, _), _ += 2) : C & 64 ? ($ = p(B, _), z = p(B, _ + 2), _ += 4) : C & 128 && ($ = p(B, _), V = p(B, _ + 2), L = p(B, _ + 4), z = p(B, _ + 6), _ += 8);
                const K = k.glyphs[M];
                K && (U.push({
                  cmd: "save"
                }, {
                  cmd: "transform",
                  args: [$, V, L, z, T, P]
                }), w(K, U, k), U.push({
                  cmd: "restore"
                }));
              } while (C & 32);
            else {
              const M = [];
              let G, Z;
              for (G = 0; G < S; G++)
                M.push(c(B, _)), _ += 2;
              const $ = c(B, _);
              _ += 2 + $;
              const z = M.at(-1) + 1, V = [];
              for (; V.length < z; ) {
                C = B[_++];
                let K = 1;
                for (C & 8 && (K += B[_++]); K-- > 0; )
                  V.push({
                    flags: C
                  });
              }
              for (G = 0; G < z; G++) {
                switch (V[G].flags & 18) {
                  case 0:
                    T += d(B, _), _ += 2;
                    break;
                  case 2:
                    T -= B[_++];
                    break;
                  case 18:
                    T += B[_++];
                    break;
                }
                V[G].x = T;
              }
              for (G = 0; G < z; G++) {
                switch (V[G].flags & 36) {
                  case 0:
                    P += d(B, _), _ += 2;
                    break;
                  case 4:
                    P -= B[_++];
                    break;
                  case 36:
                    P += B[_++];
                    break;
                }
                V[G].y = P;
              }
              let L = 0;
              for (_ = 0; _ < S; _++) {
                const K = M[_], ne = V.slice(L, K + 1);
                if (ne[0].flags & 1)
                  ne.push(ne[0]);
                else if (ne.at(-1).flags & 1)
                  ne.unshift(ne.at(-1));
                else {
                  const se = {
                    flags: 1,
                    x: (ne[0].x + ne.at(-1).x) / 2,
                    y: (ne[0].y + ne.at(-1).y) / 2
                  };
                  ne.unshift(se), ne.push(se);
                }
                for (x(ne[0].x, ne[0].y), G = 1, Z = ne.length; G < Z; G++)
                  ne[G].flags & 1 ? f(ne[G].x, ne[G].y) : ne[G + 1].flags & 1 ? (D(ne[G].x, ne[G].y, ne[G + 1].x, ne[G + 1].y), G++) : D(ne[G].x, ne[G].y, (ne[G].x + ne[G + 1].x) / 2, (ne[G].y + ne[G + 1].y) / 2);
                L = K + 1;
              }
            }
          }
          function O(B, U, k, x) {
            function f(G, Z) {
              U.push({
                cmd: "moveTo",
                args: [G, Z]
              });
            }
            function D(G, Z) {
              U.push({
                cmd: "lineTo",
                args: [G, Z]
              });
            }
            function _(G, Z, $, z, V, L) {
              U.push({
                cmd: "bezierCurveTo",
                args: [G, Z, $, z, V, L]
              });
            }
            const S = [];
            let C = 0, T = 0, P = 0;
            function M(G) {
              let Z = 0;
              for (; Z < G.length; ) {
                let $ = !1, z = G[Z++], V, L, K, ne, se, q, N, Q, E;
                switch (z) {
                  case 1:
                    P += S.length >> 1, $ = !0;
                    break;
                  case 3:
                    P += S.length >> 1, $ = !0;
                    break;
                  case 4:
                    T += S.pop(), f(C, T), $ = !0;
                    break;
                  case 5:
                    for (; S.length > 0; )
                      C += S.shift(), T += S.shift(), D(C, T);
                    break;
                  case 6:
                    for (; S.length > 0 && (C += S.shift(), D(C, T), S.length !== 0); )
                      T += S.shift(), D(C, T);
                    break;
                  case 7:
                    for (; S.length > 0 && (T += S.shift(), D(C, T), S.length !== 0); )
                      C += S.shift(), D(C, T);
                    break;
                  case 8:
                    for (; S.length > 0; )
                      V = C + S.shift(), K = T + S.shift(), L = V + S.shift(), ne = K + S.shift(), C = L + S.shift(), T = ne + S.shift(), _(V, K, L, ne, C, T);
                    break;
                  case 10:
                    if (Q = S.pop(), E = null, k.isCFFCIDFont) {
                      const te = k.fdSelect.getFDIndex(x);
                      if (te >= 0 && te < k.fdArray.length) {
                        const oe = k.fdArray[te];
                        let ee;
                        oe.privateDict && oe.privateDict.subrsIndex && (ee = oe.privateDict.subrsIndex.objects), ee && (Q += g(ee), E = ee[Q]);
                      } else
                        (0, t.warn)("Invalid fd index for glyph index.");
                    } else
                      E = k.subrs[Q + k.subrsBias];
                    E && M(E);
                    break;
                  case 11:
                    return;
                  case 12:
                    switch (z = G[Z++], z) {
                      case 34:
                        V = C + S.shift(), L = V + S.shift(), se = T + S.shift(), C = L + S.shift(), _(V, T, L, se, C, se), V = C + S.shift(), L = V + S.shift(), C = L + S.shift(), _(V, se, L, T, C, T);
                        break;
                      case 35:
                        V = C + S.shift(), K = T + S.shift(), L = V + S.shift(), ne = K + S.shift(), C = L + S.shift(), T = ne + S.shift(), _(V, K, L, ne, C, T), V = C + S.shift(), K = T + S.shift(), L = V + S.shift(), ne = K + S.shift(), C = L + S.shift(), T = ne + S.shift(), _(V, K, L, ne, C, T), S.pop();
                        break;
                      case 36:
                        V = C + S.shift(), se = T + S.shift(), L = V + S.shift(), q = se + S.shift(), C = L + S.shift(), _(V, se, L, q, C, q), V = C + S.shift(), L = V + S.shift(), N = q + S.shift(), C = L + S.shift(), _(V, q, L, N, C, T);
                        break;
                      case 37:
                        const te = C, oe = T;
                        V = C + S.shift(), K = T + S.shift(), L = V + S.shift(), ne = K + S.shift(), C = L + S.shift(), T = ne + S.shift(), _(V, K, L, ne, C, T), V = C + S.shift(), K = T + S.shift(), L = V + S.shift(), ne = K + S.shift(), C = L, T = ne, Math.abs(C - te) > Math.abs(T - oe) ? C += S.shift() : T += S.shift(), _(V, K, L, ne, C, T);
                        break;
                      default:
                        throw new t.FormatError(`unknown operator: 12 ${z}`);
                    }
                    break;
                  case 14:
                    if (S.length >= 4) {
                      const te = S.pop(), oe = S.pop();
                      T = S.pop(), C = S.pop(), U.push({
                        cmd: "save"
                      }, {
                        cmd: "translate",
                        args: [C, T]
                      });
                      let ee = u(k.cmap, String.fromCharCode(k.glyphNameMap[h.StandardEncoding[te]]));
                      O(k.glyphs[ee.glyphId], U, k, ee.glyphId), U.push({
                        cmd: "restore"
                      }), ee = u(k.cmap, String.fromCharCode(k.glyphNameMap[h.StandardEncoding[oe]])), O(k.glyphs[ee.glyphId], U, k, ee.glyphId);
                    }
                    return;
                  case 18:
                    P += S.length >> 1, $ = !0;
                    break;
                  case 19:
                    P += S.length >> 1, Z += P + 7 >> 3, $ = !0;
                    break;
                  case 20:
                    P += S.length >> 1, Z += P + 7 >> 3, $ = !0;
                    break;
                  case 21:
                    T += S.pop(), C += S.pop(), f(C, T), $ = !0;
                    break;
                  case 22:
                    C += S.pop(), f(C, T), $ = !0;
                    break;
                  case 23:
                    P += S.length >> 1, $ = !0;
                    break;
                  case 24:
                    for (; S.length > 2; )
                      V = C + S.shift(), K = T + S.shift(), L = V + S.shift(), ne = K + S.shift(), C = L + S.shift(), T = ne + S.shift(), _(V, K, L, ne, C, T);
                    C += S.shift(), T += S.shift(), D(C, T);
                    break;
                  case 25:
                    for (; S.length > 6; )
                      C += S.shift(), T += S.shift(), D(C, T);
                    V = C + S.shift(), K = T + S.shift(), L = V + S.shift(), ne = K + S.shift(), C = L + S.shift(), T = ne + S.shift(), _(V, K, L, ne, C, T);
                    break;
                  case 26:
                    for (S.length % 2 && (C += S.shift()); S.length > 0; )
                      V = C, K = T + S.shift(), L = V + S.shift(), ne = K + S.shift(), C = L, T = ne + S.shift(), _(V, K, L, ne, C, T);
                    break;
                  case 27:
                    for (S.length % 2 && (T += S.shift()); S.length > 0; )
                      V = C + S.shift(), K = T, L = V + S.shift(), ne = K + S.shift(), C = L + S.shift(), T = ne, _(V, K, L, ne, C, T);
                    break;
                  case 28:
                    S.push((G[Z] << 24 | G[Z + 1] << 16) >> 16), Z += 2;
                    break;
                  case 29:
                    Q = S.pop() + k.gsubrsBias, E = k.gsubrs[Q], E && M(E);
                    break;
                  case 30:
                    for (; S.length > 0 && (V = C, K = T + S.shift(), L = V + S.shift(), ne = K + S.shift(), C = L + S.shift(), T = ne + (S.length === 1 ? S.shift() : 0), _(V, K, L, ne, C, T), S.length !== 0); )
                      V = C + S.shift(), K = T, L = V + S.shift(), ne = K + S.shift(), T = ne + S.shift(), C = L + (S.length === 1 ? S.shift() : 0), _(V, K, L, ne, C, T);
                    break;
                  case 31:
                    for (; S.length > 0 && (V = C + S.shift(), K = T, L = V + S.shift(), ne = K + S.shift(), T = ne + S.shift(), C = L + (S.length === 1 ? S.shift() : 0), _(V, K, L, ne, C, T), S.length !== 0); )
                      V = C, K = T + S.shift(), L = V + S.shift(), ne = K + S.shift(), C = L + S.shift(), T = ne + (S.length === 1 ? S.shift() : 0), _(V, K, L, ne, C, T);
                    break;
                  default:
                    if (z < 32)
                      throw new t.FormatError(`unknown operator: ${z}`);
                    z < 247 ? S.push(z - 139) : z < 251 ? S.push((z - 247) * 256 + G[Z++] + 108) : z < 255 ? S.push(-(z - 251) * 256 - G[Z++] - 108) : (S.push((G[Z] << 24 | G[Z + 1] << 16 | G[Z + 2] << 8 | G[Z + 3]) / 65536), Z += 4);
                    break;
                }
                $ && (S.length = 0);
              }
            }
            M(B);
          }
          const b = [];
          class A {
            constructor(U) {
              this.constructor === A && (0, t.unreachable)("Cannot initialize CompiledFont."), this.fontMatrix = U, this.compiledGlyphs = /* @__PURE__ */ Object.create(null), this.compiledCharCodeToGlyphId = /* @__PURE__ */ Object.create(null);
            }
            getPathJs(U) {
              const {
                charCode: k,
                glyphId: x
              } = u(this.cmap, U);
              let f = this.compiledGlyphs[x];
              if (!f)
                try {
                  f = this.compileGlyph(this.glyphs[x], x), this.compiledGlyphs[x] = f;
                } catch (D) {
                  throw this.compiledGlyphs[x] = b, this.compiledCharCodeToGlyphId[k] === void 0 && (this.compiledCharCodeToGlyphId[k] = x), D;
                }
              return this.compiledCharCodeToGlyphId[k] === void 0 && (this.compiledCharCodeToGlyphId[k] = x), f;
            }
            compileGlyph(U, k) {
              if (!U || U.length === 0 || U[0] === 14)
                return b;
              let x = this.fontMatrix;
              if (this.isCFFCIDFont) {
                const D = this.fdSelect.getFDIndex(k);
                D >= 0 && D < this.fdArray.length ? x = this.fdArray[D].getByName("FontMatrix") || t.FONT_IDENTITY_MATRIX : (0, t.warn)("Invalid fd index for glyph index.");
              }
              const f = [{
                cmd: "save"
              }, {
                cmd: "transform",
                args: x.slice()
              }, {
                cmd: "scale",
                args: ["size", "-size"]
              }];
              return this.compileGlyphImpl(U, f, k), f.push({
                cmd: "restore"
              }), f;
            }
            compileGlyphImpl() {
              (0, t.unreachable)("Children classes should implement this.");
            }
            hasBuiltPath(U) {
              const {
                charCode: k,
                glyphId: x
              } = u(this.cmap, U);
              return this.compiledGlyphs[x] !== void 0 && this.compiledCharCodeToGlyphId[k] !== void 0;
            }
          }
          class Y extends A {
            constructor(U, k, x) {
              super(x || [488e-6, 0, 0, 488e-6, 0, 0]), this.glyphs = U, this.cmap = k;
            }
            compileGlyphImpl(U, k) {
              w(U, k, this);
            }
          }
          class j extends A {
            constructor(U, k, x, f) {
              super(x || [1e-3, 0, 0, 1e-3, 0, 0]), this.glyphs = U.glyphs, this.gsubrs = U.gsubrs || [], this.subrs = U.subrs || [], this.cmap = k, this.glyphNameMap = f || (0, v.getGlyphsUnicode)(), this.gsubrsBias = g(this.gsubrs), this.subrsBias = g(this.subrs), this.isCFFCIDFont = U.isCFFCIDFont, this.fdSelect = U.fdSelect, this.fdArray = U.fdArray;
            }
            compileGlyphImpl(U, k, x) {
              O(U, k, this, x);
            }
          }
          class X {
            static create(U, k) {
              const x = new Uint8Array(U.data);
              let f, D, _, S, C, T;
              const P = c(x, 4);
              for (let M = 0, G = 12; M < P; M++, G += 16) {
                const Z = (0, t.bytesToString)(x.subarray(G, G + 4)), $ = y(x, G + 8), z = y(x, G + 12);
                switch (Z) {
                  case "cmap":
                    f = n(x, $);
                    break;
                  case "glyf":
                    D = x.subarray($, $ + z);
                    break;
                  case "loca":
                    _ = x.subarray($, $ + z);
                    break;
                  case "head":
                    T = c(x, $ + 18), C = c(x, $ + 50);
                    break;
                  case "CFF ":
                    S = i(x, $, $ + z, k);
                    break;
                }
              }
              if (D) {
                const M = T ? [1 / T, 0, 0, 1 / T, 0, 0] : U.fontMatrix;
                return new Y(l(D, _, C), f, M);
              }
              return new j(S, f, U.fontMatrix, U.glyphNameMap);
            }
          }
          o.FontRendererFactory = X;
        },
        /* 45 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.getMetrics = o.getFontBasicMetrics = void 0;
          var t = F(6);
          const a = (0, t.getLookupTableFactory)(function(h) {
            h.Courier = 600, h["Courier-Bold"] = 600, h["Courier-BoldOblique"] = 600, h["Courier-Oblique"] = 600, h.Helvetica = (0, t.getLookupTableFactory)(function(e) {
              e.space = 278, e.exclam = 278, e.quotedbl = 355, e.numbersign = 556, e.dollar = 556, e.percent = 889, e.ampersand = 667, e.quoteright = 222, e.parenleft = 333, e.parenright = 333, e.asterisk = 389, e.plus = 584, e.comma = 278, e.hyphen = 333, e.period = 278, e.slash = 278, e.zero = 556, e.one = 556, e.two = 556, e.three = 556, e.four = 556, e.five = 556, e.six = 556, e.seven = 556, e.eight = 556, e.nine = 556, e.colon = 278, e.semicolon = 278, e.less = 584, e.equal = 584, e.greater = 584, e.question = 556, e.at = 1015, e.A = 667, e.B = 667, e.C = 722, e.D = 722, e.E = 667, e.F = 611, e.G = 778, e.H = 722, e.I = 278, e.J = 500, e.K = 667, e.L = 556, e.M = 833, e.N = 722, e.O = 778, e.P = 667, e.Q = 778, e.R = 722, e.S = 667, e.T = 611, e.U = 722, e.V = 667, e.W = 944, e.X = 667, e.Y = 667, e.Z = 611, e.bracketleft = 278, e.backslash = 278, e.bracketright = 278, e.asciicircum = 469, e.underscore = 556, e.quoteleft = 222, e.a = 556, e.b = 556, e.c = 500, e.d = 556, e.e = 556, e.f = 278, e.g = 556, e.h = 556, e.i = 222, e.j = 222, e.k = 500, e.l = 222, e.m = 833, e.n = 556, e.o = 556, e.p = 556, e.q = 556, e.r = 333, e.s = 500, e.t = 278, e.u = 556, e.v = 500, e.w = 722, e.x = 500, e.y = 500, e.z = 500, e.braceleft = 334, e.bar = 260, e.braceright = 334, e.asciitilde = 584, e.exclamdown = 333, e.cent = 556, e.sterling = 556, e.fraction = 167, e.yen = 556, e.florin = 556, e.section = 556, e.currency = 556, e.quotesingle = 191, e.quotedblleft = 333, e.guillemotleft = 556, e.guilsinglleft = 333, e.guilsinglright = 333, e.fi = 500, e.fl = 500, e.endash = 556, e.dagger = 556, e.daggerdbl = 556, e.periodcentered = 278, e.paragraph = 537, e.bullet = 350, e.quotesinglbase = 222, e.quotedblbase = 333, e.quotedblright = 333, e.guillemotright = 556, e.ellipsis = 1e3, e.perthousand = 1e3, e.questiondown = 611, e.grave = 333, e.acute = 333, e.circumflex = 333, e.tilde = 333, e.macron = 333, e.breve = 333, e.dotaccent = 333, e.dieresis = 333, e.ring = 333, e.cedilla = 333, e.hungarumlaut = 333, e.ogonek = 333, e.caron = 333, e.emdash = 1e3, e.AE = 1e3, e.ordfeminine = 370, e.Lslash = 556, e.Oslash = 778, e.OE = 1e3, e.ordmasculine = 365, e.ae = 889, e.dotlessi = 278, e.lslash = 222, e.oslash = 611, e.oe = 944, e.germandbls = 611, e.Idieresis = 278, e.eacute = 556, e.abreve = 556, e.uhungarumlaut = 556, e.ecaron = 556, e.Ydieresis = 667, e.divide = 584, e.Yacute = 667, e.Acircumflex = 667, e.aacute = 556, e.Ucircumflex = 722, e.yacute = 500, e.scommaaccent = 500, e.ecircumflex = 556, e.Uring = 722, e.Udieresis = 722, e.aogonek = 556, e.Uacute = 722, e.uogonek = 556, e.Edieresis = 667, e.Dcroat = 722, e.commaaccent = 250, e.copyright = 737, e.Emacron = 667, e.ccaron = 500, e.aring = 556, e.Ncommaaccent = 722, e.lacute = 222, e.agrave = 556, e.Tcommaaccent = 611, e.Cacute = 722, e.atilde = 556, e.Edotaccent = 667, e.scaron = 500, e.scedilla = 500, e.iacute = 278, e.lozenge = 471, e.Rcaron = 722, e.Gcommaaccent = 778, e.ucircumflex = 556, e.acircumflex = 556, e.Amacron = 667, e.rcaron = 333, e.ccedilla = 500, e.Zdotaccent = 611, e.Thorn = 667, e.Omacron = 778, e.Racute = 722, e.Sacute = 667, e.dcaron = 643, e.Umacron = 722, e.uring = 556, e.threesuperior = 333, e.Ograve = 778, e.Agrave = 667, e.Abreve = 667, e.multiply = 584, e.uacute = 556, e.Tcaron = 611, e.partialdiff = 476, e.ydieresis = 500, e.Nacute = 722, e.icircumflex = 278, e.Ecircumflex = 667, e.adieresis = 556, e.edieresis = 556, e.cacute = 500, e.nacute = 556, e.umacron = 556, e.Ncaron = 722, e.Iacute = 278, e.plusminus = 584, e.brokenbar = 260, e.registered = 737, e.Gbreve = 778, e.Idotaccent = 278, e.summation = 600, e.Egrave = 667, e.racute = 333, e.omacron = 556, e.Zacute = 611, e.Zcaron = 611, e.greaterequal = 549, e.Eth = 722, e.Ccedilla = 722, e.lcommaaccent = 222, e.tcaron = 317, e.eogonek = 556, e.Uogonek = 722, e.Aacute = 667, e.Adieresis = 667, e.egrave = 556, e.zacute = 500, e.iogonek = 222, e.Oacute = 778, e.oacute = 556, e.amacron = 556, e.sacute = 500, e.idieresis = 278, e.Ocircumflex = 778, e.Ugrave = 722, e.Delta = 612, e.thorn = 556, e.twosuperior = 333, e.Odieresis = 778, e.mu = 556, e.igrave = 278, e.ohungarumlaut = 556, e.Eogonek = 667, e.dcroat = 556, e.threequarters = 834, e.Scedilla = 667, e.lcaron = 299, e.Kcommaaccent = 667, e.Lacute = 556, e.trademark = 1e3, e.edotaccent = 556, e.Igrave = 278, e.Imacron = 278, e.Lcaron = 556, e.onehalf = 834, e.lessequal = 549, e.ocircumflex = 556, e.ntilde = 556, e.Uhungarumlaut = 722, e.Eacute = 667, e.emacron = 556, e.gbreve = 556, e.onequarter = 834, e.Scaron = 667, e.Scommaaccent = 667, e.Ohungarumlaut = 778, e.degree = 400, e.ograve = 556, e.Ccaron = 722, e.ugrave = 556, e.radical = 453, e.Dcaron = 722, e.rcommaaccent = 333, e.Ntilde = 722, e.otilde = 556, e.Rcommaaccent = 722, e.Lcommaaccent = 556, e.Atilde = 667, e.Aogonek = 667, e.Aring = 667, e.Otilde = 778, e.zdotaccent = 500, e.Ecaron = 667, e.Iogonek = 278, e.kcommaaccent = 500, e.minus = 584, e.Icircumflex = 278, e.ncaron = 556, e.tcommaaccent = 278, e.logicalnot = 584, e.odieresis = 556, e.udieresis = 556, e.notequal = 549, e.gcommaaccent = 556, e.eth = 556, e.zcaron = 500, e.ncommaaccent = 556, e.onesuperior = 333, e.imacron = 278, e.Euro = 556;
            }), h["Helvetica-Bold"] = (0, t.getLookupTableFactory)(function(e) {
              e.space = 278, e.exclam = 333, e.quotedbl = 474, e.numbersign = 556, e.dollar = 556, e.percent = 889, e.ampersand = 722, e.quoteright = 278, e.parenleft = 333, e.parenright = 333, e.asterisk = 389, e.plus = 584, e.comma = 278, e.hyphen = 333, e.period = 278, e.slash = 278, e.zero = 556, e.one = 556, e.two = 556, e.three = 556, e.four = 556, e.five = 556, e.six = 556, e.seven = 556, e.eight = 556, e.nine = 556, e.colon = 333, e.semicolon = 333, e.less = 584, e.equal = 584, e.greater = 584, e.question = 611, e.at = 975, e.A = 722, e.B = 722, e.C = 722, e.D = 722, e.E = 667, e.F = 611, e.G = 778, e.H = 722, e.I = 278, e.J = 556, e.K = 722, e.L = 611, e.M = 833, e.N = 722, e.O = 778, e.P = 667, e.Q = 778, e.R = 722, e.S = 667, e.T = 611, e.U = 722, e.V = 667, e.W = 944, e.X = 667, e.Y = 667, e.Z = 611, e.bracketleft = 333, e.backslash = 278, e.bracketright = 333, e.asciicircum = 584, e.underscore = 556, e.quoteleft = 278, e.a = 556, e.b = 611, e.c = 556, e.d = 611, e.e = 556, e.f = 333, e.g = 611, e.h = 611, e.i = 278, e.j = 278, e.k = 556, e.l = 278, e.m = 889, e.n = 611, e.o = 611, e.p = 611, e.q = 611, e.r = 389, e.s = 556, e.t = 333, e.u = 611, e.v = 556, e.w = 778, e.x = 556, e.y = 556, e.z = 500, e.braceleft = 389, e.bar = 280, e.braceright = 389, e.asciitilde = 584, e.exclamdown = 333, e.cent = 556, e.sterling = 556, e.fraction = 167, e.yen = 556, e.florin = 556, e.section = 556, e.currency = 556, e.quotesingle = 238, e.quotedblleft = 500, e.guillemotleft = 556, e.guilsinglleft = 333, e.guilsinglright = 333, e.fi = 611, e.fl = 611, e.endash = 556, e.dagger = 556, e.daggerdbl = 556, e.periodcentered = 278, e.paragraph = 556, e.bullet = 350, e.quotesinglbase = 278, e.quotedblbase = 500, e.quotedblright = 500, e.guillemotright = 556, e.ellipsis = 1e3, e.perthousand = 1e3, e.questiondown = 611, e.grave = 333, e.acute = 333, e.circumflex = 333, e.tilde = 333, e.macron = 333, e.breve = 333, e.dotaccent = 333, e.dieresis = 333, e.ring = 333, e.cedilla = 333, e.hungarumlaut = 333, e.ogonek = 333, e.caron = 333, e.emdash = 1e3, e.AE = 1e3, e.ordfeminine = 370, e.Lslash = 611, e.Oslash = 778, e.OE = 1e3, e.ordmasculine = 365, e.ae = 889, e.dotlessi = 278, e.lslash = 278, e.oslash = 611, e.oe = 944, e.germandbls = 611, e.Idieresis = 278, e.eacute = 556, e.abreve = 556, e.uhungarumlaut = 611, e.ecaron = 556, e.Ydieresis = 667, e.divide = 584, e.Yacute = 667, e.Acircumflex = 722, e.aacute = 556, e.Ucircumflex = 722, e.yacute = 556, e.scommaaccent = 556, e.ecircumflex = 556, e.Uring = 722, e.Udieresis = 722, e.aogonek = 556, e.Uacute = 722, e.uogonek = 611, e.Edieresis = 667, e.Dcroat = 722, e.commaaccent = 250, e.copyright = 737, e.Emacron = 667, e.ccaron = 556, e.aring = 556, e.Ncommaaccent = 722, e.lacute = 278, e.agrave = 556, e.Tcommaaccent = 611, e.Cacute = 722, e.atilde = 556, e.Edotaccent = 667, e.scaron = 556, e.scedilla = 556, e.iacute = 278, e.lozenge = 494, e.Rcaron = 722, e.Gcommaaccent = 778, e.ucircumflex = 611, e.acircumflex = 556, e.Amacron = 722, e.rcaron = 389, e.ccedilla = 556, e.Zdotaccent = 611, e.Thorn = 667, e.Omacron = 778, e.Racute = 722, e.Sacute = 667, e.dcaron = 743, e.Umacron = 722, e.uring = 611, e.threesuperior = 333, e.Ograve = 778, e.Agrave = 722, e.Abreve = 722, e.multiply = 584, e.uacute = 611, e.Tcaron = 611, e.partialdiff = 494, e.ydieresis = 556, e.Nacute = 722, e.icircumflex = 278, e.Ecircumflex = 667, e.adieresis = 556, e.edieresis = 556, e.cacute = 556, e.nacute = 611, e.umacron = 611, e.Ncaron = 722, e.Iacute = 278, e.plusminus = 584, e.brokenbar = 280, e.registered = 737, e.Gbreve = 778, e.Idotaccent = 278, e.summation = 600, e.Egrave = 667, e.racute = 389, e.omacron = 611, e.Zacute = 611, e.Zcaron = 611, e.greaterequal = 549, e.Eth = 722, e.Ccedilla = 722, e.lcommaaccent = 278, e.tcaron = 389, e.eogonek = 556, e.Uogonek = 722, e.Aacute = 722, e.Adieresis = 722, e.egrave = 556, e.zacute = 500, e.iogonek = 278, e.Oacute = 778, e.oacute = 611, e.amacron = 556, e.sacute = 556, e.idieresis = 278, e.Ocircumflex = 778, e.Ugrave = 722, e.Delta = 612, e.thorn = 611, e.twosuperior = 333, e.Odieresis = 778, e.mu = 611, e.igrave = 278, e.ohungarumlaut = 611, e.Eogonek = 667, e.dcroat = 611, e.threequarters = 834, e.Scedilla = 667, e.lcaron = 400, e.Kcommaaccent = 722, e.Lacute = 611, e.trademark = 1e3, e.edotaccent = 556, e.Igrave = 278, e.Imacron = 278, e.Lcaron = 611, e.onehalf = 834, e.lessequal = 549, e.ocircumflex = 611, e.ntilde = 611, e.Uhungarumlaut = 722, e.Eacute = 667, e.emacron = 556, e.gbreve = 611, e.onequarter = 834, e.Scaron = 667, e.Scommaaccent = 667, e.Ohungarumlaut = 778, e.degree = 400, e.ograve = 611, e.Ccaron = 722, e.ugrave = 611, e.radical = 549, e.Dcaron = 722, e.rcommaaccent = 389, e.Ntilde = 722, e.otilde = 611, e.Rcommaaccent = 722, e.Lcommaaccent = 611, e.Atilde = 722, e.Aogonek = 722, e.Aring = 722, e.Otilde = 778, e.zdotaccent = 500, e.Ecaron = 667, e.Iogonek = 278, e.kcommaaccent = 556, e.minus = 584, e.Icircumflex = 278, e.ncaron = 611, e.tcommaaccent = 333, e.logicalnot = 584, e.odieresis = 611, e.udieresis = 611, e.notequal = 549, e.gcommaaccent = 611, e.eth = 611, e.zcaron = 500, e.ncommaaccent = 611, e.onesuperior = 333, e.imacron = 278, e.Euro = 556;
            }), h["Helvetica-BoldOblique"] = (0, t.getLookupTableFactory)(function(e) {
              e.space = 278, e.exclam = 333, e.quotedbl = 474, e.numbersign = 556, e.dollar = 556, e.percent = 889, e.ampersand = 722, e.quoteright = 278, e.parenleft = 333, e.parenright = 333, e.asterisk = 389, e.plus = 584, e.comma = 278, e.hyphen = 333, e.period = 278, e.slash = 278, e.zero = 556, e.one = 556, e.two = 556, e.three = 556, e.four = 556, e.five = 556, e.six = 556, e.seven = 556, e.eight = 556, e.nine = 556, e.colon = 333, e.semicolon = 333, e.less = 584, e.equal = 584, e.greater = 584, e.question = 611, e.at = 975, e.A = 722, e.B = 722, e.C = 722, e.D = 722, e.E = 667, e.F = 611, e.G = 778, e.H = 722, e.I = 278, e.J = 556, e.K = 722, e.L = 611, e.M = 833, e.N = 722, e.O = 778, e.P = 667, e.Q = 778, e.R = 722, e.S = 667, e.T = 611, e.U = 722, e.V = 667, e.W = 944, e.X = 667, e.Y = 667, e.Z = 611, e.bracketleft = 333, e.backslash = 278, e.bracketright = 333, e.asciicircum = 584, e.underscore = 556, e.quoteleft = 278, e.a = 556, e.b = 611, e.c = 556, e.d = 611, e.e = 556, e.f = 333, e.g = 611, e.h = 611, e.i = 278, e.j = 278, e.k = 556, e.l = 278, e.m = 889, e.n = 611, e.o = 611, e.p = 611, e.q = 611, e.r = 389, e.s = 556, e.t = 333, e.u = 611, e.v = 556, e.w = 778, e.x = 556, e.y = 556, e.z = 500, e.braceleft = 389, e.bar = 280, e.braceright = 389, e.asciitilde = 584, e.exclamdown = 333, e.cent = 556, e.sterling = 556, e.fraction = 167, e.yen = 556, e.florin = 556, e.section = 556, e.currency = 556, e.quotesingle = 238, e.quotedblleft = 500, e.guillemotleft = 556, e.guilsinglleft = 333, e.guilsinglright = 333, e.fi = 611, e.fl = 611, e.endash = 556, e.dagger = 556, e.daggerdbl = 556, e.periodcentered = 278, e.paragraph = 556, e.bullet = 350, e.quotesinglbase = 278, e.quotedblbase = 500, e.quotedblright = 500, e.guillemotright = 556, e.ellipsis = 1e3, e.perthousand = 1e3, e.questiondown = 611, e.grave = 333, e.acute = 333, e.circumflex = 333, e.tilde = 333, e.macron = 333, e.breve = 333, e.dotaccent = 333, e.dieresis = 333, e.ring = 333, e.cedilla = 333, e.hungarumlaut = 333, e.ogonek = 333, e.caron = 333, e.emdash = 1e3, e.AE = 1e3, e.ordfeminine = 370, e.Lslash = 611, e.Oslash = 778, e.OE = 1e3, e.ordmasculine = 365, e.ae = 889, e.dotlessi = 278, e.lslash = 278, e.oslash = 611, e.oe = 944, e.germandbls = 611, e.Idieresis = 278, e.eacute = 556, e.abreve = 556, e.uhungarumlaut = 611, e.ecaron = 556, e.Ydieresis = 667, e.divide = 584, e.Yacute = 667, e.Acircumflex = 722, e.aacute = 556, e.Ucircumflex = 722, e.yacute = 556, e.scommaaccent = 556, e.ecircumflex = 556, e.Uring = 722, e.Udieresis = 722, e.aogonek = 556, e.Uacute = 722, e.uogonek = 611, e.Edieresis = 667, e.Dcroat = 722, e.commaaccent = 250, e.copyright = 737, e.Emacron = 667, e.ccaron = 556, e.aring = 556, e.Ncommaaccent = 722, e.lacute = 278, e.agrave = 556, e.Tcommaaccent = 611, e.Cacute = 722, e.atilde = 556, e.Edotaccent = 667, e.scaron = 556, e.scedilla = 556, e.iacute = 278, e.lozenge = 494, e.Rcaron = 722, e.Gcommaaccent = 778, e.ucircumflex = 611, e.acircumflex = 556, e.Amacron = 722, e.rcaron = 389, e.ccedilla = 556, e.Zdotaccent = 611, e.Thorn = 667, e.Omacron = 778, e.Racute = 722, e.Sacute = 667, e.dcaron = 743, e.Umacron = 722, e.uring = 611, e.threesuperior = 333, e.Ograve = 778, e.Agrave = 722, e.Abreve = 722, e.multiply = 584, e.uacute = 611, e.Tcaron = 611, e.partialdiff = 494, e.ydieresis = 556, e.Nacute = 722, e.icircumflex = 278, e.Ecircumflex = 667, e.adieresis = 556, e.edieresis = 556, e.cacute = 556, e.nacute = 611, e.umacron = 611, e.Ncaron = 722, e.Iacute = 278, e.plusminus = 584, e.brokenbar = 280, e.registered = 737, e.Gbreve = 778, e.Idotaccent = 278, e.summation = 600, e.Egrave = 667, e.racute = 389, e.omacron = 611, e.Zacute = 611, e.Zcaron = 611, e.greaterequal = 549, e.Eth = 722, e.Ccedilla = 722, e.lcommaaccent = 278, e.tcaron = 389, e.eogonek = 556, e.Uogonek = 722, e.Aacute = 722, e.Adieresis = 722, e.egrave = 556, e.zacute = 500, e.iogonek = 278, e.Oacute = 778, e.oacute = 611, e.amacron = 556, e.sacute = 556, e.idieresis = 278, e.Ocircumflex = 778, e.Ugrave = 722, e.Delta = 612, e.thorn = 611, e.twosuperior = 333, e.Odieresis = 778, e.mu = 611, e.igrave = 278, e.ohungarumlaut = 611, e.Eogonek = 667, e.dcroat = 611, e.threequarters = 834, e.Scedilla = 667, e.lcaron = 400, e.Kcommaaccent = 722, e.Lacute = 611, e.trademark = 1e3, e.edotaccent = 556, e.Igrave = 278, e.Imacron = 278, e.Lcaron = 611, e.onehalf = 834, e.lessequal = 549, e.ocircumflex = 611, e.ntilde = 611, e.Uhungarumlaut = 722, e.Eacute = 667, e.emacron = 556, e.gbreve = 611, e.onequarter = 834, e.Scaron = 667, e.Scommaaccent = 667, e.Ohungarumlaut = 778, e.degree = 400, e.ograve = 611, e.Ccaron = 722, e.ugrave = 611, e.radical = 549, e.Dcaron = 722, e.rcommaaccent = 389, e.Ntilde = 722, e.otilde = 611, e.Rcommaaccent = 722, e.Lcommaaccent = 611, e.Atilde = 722, e.Aogonek = 722, e.Aring = 722, e.Otilde = 778, e.zdotaccent = 500, e.Ecaron = 667, e.Iogonek = 278, e.kcommaaccent = 556, e.minus = 584, e.Icircumflex = 278, e.ncaron = 611, e.tcommaaccent = 333, e.logicalnot = 584, e.odieresis = 611, e.udieresis = 611, e.notequal = 549, e.gcommaaccent = 611, e.eth = 611, e.zcaron = 500, e.ncommaaccent = 611, e.onesuperior = 333, e.imacron = 278, e.Euro = 556;
            }), h["Helvetica-Oblique"] = (0, t.getLookupTableFactory)(function(e) {
              e.space = 278, e.exclam = 278, e.quotedbl = 355, e.numbersign = 556, e.dollar = 556, e.percent = 889, e.ampersand = 667, e.quoteright = 222, e.parenleft = 333, e.parenright = 333, e.asterisk = 389, e.plus = 584, e.comma = 278, e.hyphen = 333, e.period = 278, e.slash = 278, e.zero = 556, e.one = 556, e.two = 556, e.three = 556, e.four = 556, e.five = 556, e.six = 556, e.seven = 556, e.eight = 556, e.nine = 556, e.colon = 278, e.semicolon = 278, e.less = 584, e.equal = 584, e.greater = 584, e.question = 556, e.at = 1015, e.A = 667, e.B = 667, e.C = 722, e.D = 722, e.E = 667, e.F = 611, e.G = 778, e.H = 722, e.I = 278, e.J = 500, e.K = 667, e.L = 556, e.M = 833, e.N = 722, e.O = 778, e.P = 667, e.Q = 778, e.R = 722, e.S = 667, e.T = 611, e.U = 722, e.V = 667, e.W = 944, e.X = 667, e.Y = 667, e.Z = 611, e.bracketleft = 278, e.backslash = 278, e.bracketright = 278, e.asciicircum = 469, e.underscore = 556, e.quoteleft = 222, e.a = 556, e.b = 556, e.c = 500, e.d = 556, e.e = 556, e.f = 278, e.g = 556, e.h = 556, e.i = 222, e.j = 222, e.k = 500, e.l = 222, e.m = 833, e.n = 556, e.o = 556, e.p = 556, e.q = 556, e.r = 333, e.s = 500, e.t = 278, e.u = 556, e.v = 500, e.w = 722, e.x = 500, e.y = 500, e.z = 500, e.braceleft = 334, e.bar = 260, e.braceright = 334, e.asciitilde = 584, e.exclamdown = 333, e.cent = 556, e.sterling = 556, e.fraction = 167, e.yen = 556, e.florin = 556, e.section = 556, e.currency = 556, e.quotesingle = 191, e.quotedblleft = 333, e.guillemotleft = 556, e.guilsinglleft = 333, e.guilsinglright = 333, e.fi = 500, e.fl = 500, e.endash = 556, e.dagger = 556, e.daggerdbl = 556, e.periodcentered = 278, e.paragraph = 537, e.bullet = 350, e.quotesinglbase = 222, e.quotedblbase = 333, e.quotedblright = 333, e.guillemotright = 556, e.ellipsis = 1e3, e.perthousand = 1e3, e.questiondown = 611, e.grave = 333, e.acute = 333, e.circumflex = 333, e.tilde = 333, e.macron = 333, e.breve = 333, e.dotaccent = 333, e.dieresis = 333, e.ring = 333, e.cedilla = 333, e.hungarumlaut = 333, e.ogonek = 333, e.caron = 333, e.emdash = 1e3, e.AE = 1e3, e.ordfeminine = 370, e.Lslash = 556, e.Oslash = 778, e.OE = 1e3, e.ordmasculine = 365, e.ae = 889, e.dotlessi = 278, e.lslash = 222, e.oslash = 611, e.oe = 944, e.germandbls = 611, e.Idieresis = 278, e.eacute = 556, e.abreve = 556, e.uhungarumlaut = 556, e.ecaron = 556, e.Ydieresis = 667, e.divide = 584, e.Yacute = 667, e.Acircumflex = 667, e.aacute = 556, e.Ucircumflex = 722, e.yacute = 500, e.scommaaccent = 500, e.ecircumflex = 556, e.Uring = 722, e.Udieresis = 722, e.aogonek = 556, e.Uacute = 722, e.uogonek = 556, e.Edieresis = 667, e.Dcroat = 722, e.commaaccent = 250, e.copyright = 737, e.Emacron = 667, e.ccaron = 500, e.aring = 556, e.Ncommaaccent = 722, e.lacute = 222, e.agrave = 556, e.Tcommaaccent = 611, e.Cacute = 722, e.atilde = 556, e.Edotaccent = 667, e.scaron = 500, e.scedilla = 500, e.iacute = 278, e.lozenge = 471, e.Rcaron = 722, e.Gcommaaccent = 778, e.ucircumflex = 556, e.acircumflex = 556, e.Amacron = 667, e.rcaron = 333, e.ccedilla = 500, e.Zdotaccent = 611, e.Thorn = 667, e.Omacron = 778, e.Racute = 722, e.Sacute = 667, e.dcaron = 643, e.Umacron = 722, e.uring = 556, e.threesuperior = 333, e.Ograve = 778, e.Agrave = 667, e.Abreve = 667, e.multiply = 584, e.uacute = 556, e.Tcaron = 611, e.partialdiff = 476, e.ydieresis = 500, e.Nacute = 722, e.icircumflex = 278, e.Ecircumflex = 667, e.adieresis = 556, e.edieresis = 556, e.cacute = 500, e.nacute = 556, e.umacron = 556, e.Ncaron = 722, e.Iacute = 278, e.plusminus = 584, e.brokenbar = 260, e.registered = 737, e.Gbreve = 778, e.Idotaccent = 278, e.summation = 600, e.Egrave = 667, e.racute = 333, e.omacron = 556, e.Zacute = 611, e.Zcaron = 611, e.greaterequal = 549, e.Eth = 722, e.Ccedilla = 722, e.lcommaaccent = 222, e.tcaron = 317, e.eogonek = 556, e.Uogonek = 722, e.Aacute = 667, e.Adieresis = 667, e.egrave = 556, e.zacute = 500, e.iogonek = 222, e.Oacute = 778, e.oacute = 556, e.amacron = 556, e.sacute = 500, e.idieresis = 278, e.Ocircumflex = 778, e.Ugrave = 722, e.Delta = 612, e.thorn = 556, e.twosuperior = 333, e.Odieresis = 778, e.mu = 556, e.igrave = 278, e.ohungarumlaut = 556, e.Eogonek = 667, e.dcroat = 556, e.threequarters = 834, e.Scedilla = 667, e.lcaron = 299, e.Kcommaaccent = 667, e.Lacute = 556, e.trademark = 1e3, e.edotaccent = 556, e.Igrave = 278, e.Imacron = 278, e.Lcaron = 556, e.onehalf = 834, e.lessequal = 549, e.ocircumflex = 556, e.ntilde = 556, e.Uhungarumlaut = 722, e.Eacute = 667, e.emacron = 556, e.gbreve = 556, e.onequarter = 834, e.Scaron = 667, e.Scommaaccent = 667, e.Ohungarumlaut = 778, e.degree = 400, e.ograve = 556, e.Ccaron = 722, e.ugrave = 556, e.radical = 453, e.Dcaron = 722, e.rcommaaccent = 333, e.Ntilde = 722, e.otilde = 556, e.Rcommaaccent = 722, e.Lcommaaccent = 556, e.Atilde = 667, e.Aogonek = 667, e.Aring = 667, e.Otilde = 778, e.zdotaccent = 500, e.Ecaron = 667, e.Iogonek = 278, e.kcommaaccent = 500, e.minus = 584, e.Icircumflex = 278, e.ncaron = 556, e.tcommaaccent = 278, e.logicalnot = 584, e.odieresis = 556, e.udieresis = 556, e.notequal = 549, e.gcommaaccent = 556, e.eth = 556, e.zcaron = 500, e.ncommaaccent = 556, e.onesuperior = 333, e.imacron = 278, e.Euro = 556;
            }), h.Symbol = (0, t.getLookupTableFactory)(function(e) {
              e.space = 250, e.exclam = 333, e.universal = 713, e.numbersign = 500, e.existential = 549, e.percent = 833, e.ampersand = 778, e.suchthat = 439, e.parenleft = 333, e.parenright = 333, e.asteriskmath = 500, e.plus = 549, e.comma = 250, e.minus = 549, e.period = 250, e.slash = 278, e.zero = 500, e.one = 500, e.two = 500, e.three = 500, e.four = 500, e.five = 500, e.six = 500, e.seven = 500, e.eight = 500, e.nine = 500, e.colon = 278, e.semicolon = 278, e.less = 549, e.equal = 549, e.greater = 549, e.question = 444, e.congruent = 549, e.Alpha = 722, e.Beta = 667, e.Chi = 722, e.Delta = 612, e.Epsilon = 611, e.Phi = 763, e.Gamma = 603, e.Eta = 722, e.Iota = 333, e.theta1 = 631, e.Kappa = 722, e.Lambda = 686, e.Mu = 889, e.Nu = 722, e.Omicron = 722, e.Pi = 768, e.Theta = 741, e.Rho = 556, e.Sigma = 592, e.Tau = 611, e.Upsilon = 690, e.sigma1 = 439, e.Omega = 768, e.Xi = 645, e.Psi = 795, e.Zeta = 611, e.bracketleft = 333, e.therefore = 863, e.bracketright = 333, e.perpendicular = 658, e.underscore = 500, e.radicalex = 500, e.alpha = 631, e.beta = 549, e.chi = 549, e.delta = 494, e.epsilon = 439, e.phi = 521, e.gamma = 411, e.eta = 603, e.iota = 329, e.phi1 = 603, e.kappa = 549, e.lambda = 549, e.mu = 576, e.nu = 521, e.omicron = 549, e.pi = 549, e.theta = 521, e.rho = 549, e.sigma = 603, e.tau = 439, e.upsilon = 576, e.omega1 = 713, e.omega = 686, e.xi = 493, e.psi = 686, e.zeta = 494, e.braceleft = 480, e.bar = 200, e.braceright = 480, e.similar = 549, e.Euro = 750, e.Upsilon1 = 620, e.minute = 247, e.lessequal = 549, e.fraction = 167, e.infinity = 713, e.florin = 500, e.club = 753, e.diamond = 753, e.heart = 753, e.spade = 753, e.arrowboth = 1042, e.arrowleft = 987, e.arrowup = 603, e.arrowright = 987, e.arrowdown = 603, e.degree = 400, e.plusminus = 549, e.second = 411, e.greaterequal = 549, e.multiply = 549, e.proportional = 713, e.partialdiff = 494, e.bullet = 460, e.divide = 549, e.notequal = 549, e.equivalence = 549, e.approxequal = 549, e.ellipsis = 1e3, e.arrowvertex = 603, e.arrowhorizex = 1e3, e.carriagereturn = 658, e.aleph = 823, e.Ifraktur = 686, e.Rfraktur = 795, e.weierstrass = 987, e.circlemultiply = 768, e.circleplus = 768, e.emptyset = 823, e.intersection = 768, e.union = 768, e.propersuperset = 713, e.reflexsuperset = 713, e.notsubset = 713, e.propersubset = 713, e.reflexsubset = 713, e.element = 713, e.notelement = 713, e.angle = 768, e.gradient = 713, e.registerserif = 790, e.copyrightserif = 790, e.trademarkserif = 890, e.product = 823, e.radical = 549, e.dotmath = 250, e.logicalnot = 713, e.logicaland = 603, e.logicalor = 603, e.arrowdblboth = 1042, e.arrowdblleft = 987, e.arrowdblup = 603, e.arrowdblright = 987, e.arrowdbldown = 603, e.lozenge = 494, e.angleleft = 329, e.registersans = 790, e.copyrightsans = 790, e.trademarksans = 786, e.summation = 713, e.parenlefttp = 384, e.parenleftex = 384, e.parenleftbt = 384, e.bracketlefttp = 384, e.bracketleftex = 384, e.bracketleftbt = 384, e.bracelefttp = 494, e.braceleftmid = 494, e.braceleftbt = 494, e.braceex = 494, e.angleright = 329, e.integral = 274, e.integraltp = 686, e.integralex = 686, e.integralbt = 686, e.parenrighttp = 384, e.parenrightex = 384, e.parenrightbt = 384, e.bracketrighttp = 384, e.bracketrightex = 384, e.bracketrightbt = 384, e.bracerighttp = 494, e.bracerightmid = 494, e.bracerightbt = 494, e.apple = 790;
            }), h["Times-Roman"] = (0, t.getLookupTableFactory)(function(e) {
              e.space = 250, e.exclam = 333, e.quotedbl = 408, e.numbersign = 500, e.dollar = 500, e.percent = 833, e.ampersand = 778, e.quoteright = 333, e.parenleft = 333, e.parenright = 333, e.asterisk = 500, e.plus = 564, e.comma = 250, e.hyphen = 333, e.period = 250, e.slash = 278, e.zero = 500, e.one = 500, e.two = 500, e.three = 500, e.four = 500, e.five = 500, e.six = 500, e.seven = 500, e.eight = 500, e.nine = 500, e.colon = 278, e.semicolon = 278, e.less = 564, e.equal = 564, e.greater = 564, e.question = 444, e.at = 921, e.A = 722, e.B = 667, e.C = 667, e.D = 722, e.E = 611, e.F = 556, e.G = 722, e.H = 722, e.I = 333, e.J = 389, e.K = 722, e.L = 611, e.M = 889, e.N = 722, e.O = 722, e.P = 556, e.Q = 722, e.R = 667, e.S = 556, e.T = 611, e.U = 722, e.V = 722, e.W = 944, e.X = 722, e.Y = 722, e.Z = 611, e.bracketleft = 333, e.backslash = 278, e.bracketright = 333, e.asciicircum = 469, e.underscore = 500, e.quoteleft = 333, e.a = 444, e.b = 500, e.c = 444, e.d = 500, e.e = 444, e.f = 333, e.g = 500, e.h = 500, e.i = 278, e.j = 278, e.k = 500, e.l = 278, e.m = 778, e.n = 500, e.o = 500, e.p = 500, e.q = 500, e.r = 333, e.s = 389, e.t = 278, e.u = 500, e.v = 500, e.w = 722, e.x = 500, e.y = 500, e.z = 444, e.braceleft = 480, e.bar = 200, e.braceright = 480, e.asciitilde = 541, e.exclamdown = 333, e.cent = 500, e.sterling = 500, e.fraction = 167, e.yen = 500, e.florin = 500, e.section = 500, e.currency = 500, e.quotesingle = 180, e.quotedblleft = 444, e.guillemotleft = 500, e.guilsinglleft = 333, e.guilsinglright = 333, e.fi = 556, e.fl = 556, e.endash = 500, e.dagger = 500, e.daggerdbl = 500, e.periodcentered = 250, e.paragraph = 453, e.bullet = 350, e.quotesinglbase = 333, e.quotedblbase = 444, e.quotedblright = 444, e.guillemotright = 500, e.ellipsis = 1e3, e.perthousand = 1e3, e.questiondown = 444, e.grave = 333, e.acute = 333, e.circumflex = 333, e.tilde = 333, e.macron = 333, e.breve = 333, e.dotaccent = 333, e.dieresis = 333, e.ring = 333, e.cedilla = 333, e.hungarumlaut = 333, e.ogonek = 333, e.caron = 333, e.emdash = 1e3, e.AE = 889, e.ordfeminine = 276, e.Lslash = 611, e.Oslash = 722, e.OE = 889, e.ordmasculine = 310, e.ae = 667, e.dotlessi = 278, e.lslash = 278, e.oslash = 500, e.oe = 722, e.germandbls = 500, e.Idieresis = 333, e.eacute = 444, e.abreve = 444, e.uhungarumlaut = 500, e.ecaron = 444, e.Ydieresis = 722, e.divide = 564, e.Yacute = 722, e.Acircumflex = 722, e.aacute = 444, e.Ucircumflex = 722, e.yacute = 500, e.scommaaccent = 389, e.ecircumflex = 444, e.Uring = 722, e.Udieresis = 722, e.aogonek = 444, e.Uacute = 722, e.uogonek = 500, e.Edieresis = 611, e.Dcroat = 722, e.commaaccent = 250, e.copyright = 760, e.Emacron = 611, e.ccaron = 444, e.aring = 444, e.Ncommaaccent = 722, e.lacute = 278, e.agrave = 444, e.Tcommaaccent = 611, e.Cacute = 667, e.atilde = 444, e.Edotaccent = 611, e.scaron = 389, e.scedilla = 389, e.iacute = 278, e.lozenge = 471, e.Rcaron = 667, e.Gcommaaccent = 722, e.ucircumflex = 500, e.acircumflex = 444, e.Amacron = 722, e.rcaron = 333, e.ccedilla = 444, e.Zdotaccent = 611, e.Thorn = 556, e.Omacron = 722, e.Racute = 667, e.Sacute = 556, e.dcaron = 588, e.Umacron = 722, e.uring = 500, e.threesuperior = 300, e.Ograve = 722, e.Agrave = 722, e.Abreve = 722, e.multiply = 564, e.uacute = 500, e.Tcaron = 611, e.partialdiff = 476, e.ydieresis = 500, e.Nacute = 722, e.icircumflex = 278, e.Ecircumflex = 611, e.adieresis = 444, e.edieresis = 444, e.cacute = 444, e.nacute = 500, e.umacron = 500, e.Ncaron = 722, e.Iacute = 333, e.plusminus = 564, e.brokenbar = 200, e.registered = 760, e.Gbreve = 722, e.Idotaccent = 333, e.summation = 600, e.Egrave = 611, e.racute = 333, e.omacron = 500, e.Zacute = 611, e.Zcaron = 611, e.greaterequal = 549, e.Eth = 722, e.Ccedilla = 667, e.lcommaaccent = 278, e.tcaron = 326, e.eogonek = 444, e.Uogonek = 722, e.Aacute = 722, e.Adieresis = 722, e.egrave = 444, e.zacute = 444, e.iogonek = 278, e.Oacute = 722, e.oacute = 500, e.amacron = 444, e.sacute = 389, e.idieresis = 278, e.Ocircumflex = 722, e.Ugrave = 722, e.Delta = 612, e.thorn = 500, e.twosuperior = 300, e.Odieresis = 722, e.mu = 500, e.igrave = 278, e.ohungarumlaut = 500, e.Eogonek = 611, e.dcroat = 500, e.threequarters = 750, e.Scedilla = 556, e.lcaron = 344, e.Kcommaaccent = 722, e.Lacute = 611, e.trademark = 980, e.edotaccent = 444, e.Igrave = 333, e.Imacron = 333, e.Lcaron = 611, e.onehalf = 750, e.lessequal = 549, e.ocircumflex = 500, e.ntilde = 500, e.Uhungarumlaut = 722, e.Eacute = 611, e.emacron = 444, e.gbreve = 500, e.onequarter = 750, e.Scaron = 556, e.Scommaaccent = 556, e.Ohungarumlaut = 722, e.degree = 400, e.ograve = 500, e.Ccaron = 667, e.ugrave = 500, e.radical = 453, e.Dcaron = 722, e.rcommaaccent = 333, e.Ntilde = 722, e.otilde = 500, e.Rcommaaccent = 667, e.Lcommaaccent = 611, e.Atilde = 722, e.Aogonek = 722, e.Aring = 722, e.Otilde = 722, e.zdotaccent = 444, e.Ecaron = 611, e.Iogonek = 333, e.kcommaaccent = 500, e.minus = 564, e.Icircumflex = 333, e.ncaron = 500, e.tcommaaccent = 278, e.logicalnot = 564, e.odieresis = 500, e.udieresis = 500, e.notequal = 549, e.gcommaaccent = 500, e.eth = 500, e.zcaron = 444, e.ncommaaccent = 500, e.onesuperior = 300, e.imacron = 278, e.Euro = 500;
            }), h["Times-Bold"] = (0, t.getLookupTableFactory)(function(e) {
              e.space = 250, e.exclam = 333, e.quotedbl = 555, e.numbersign = 500, e.dollar = 500, e.percent = 1e3, e.ampersand = 833, e.quoteright = 333, e.parenleft = 333, e.parenright = 333, e.asterisk = 500, e.plus = 570, e.comma = 250, e.hyphen = 333, e.period = 250, e.slash = 278, e.zero = 500, e.one = 500, e.two = 500, e.three = 500, e.four = 500, e.five = 500, e.six = 500, e.seven = 500, e.eight = 500, e.nine = 500, e.colon = 333, e.semicolon = 333, e.less = 570, e.equal = 570, e.greater = 570, e.question = 500, e.at = 930, e.A = 722, e.B = 667, e.C = 722, e.D = 722, e.E = 667, e.F = 611, e.G = 778, e.H = 778, e.I = 389, e.J = 500, e.K = 778, e.L = 667, e.M = 944, e.N = 722, e.O = 778, e.P = 611, e.Q = 778, e.R = 722, e.S = 556, e.T = 667, e.U = 722, e.V = 722, e.W = 1e3, e.X = 722, e.Y = 722, e.Z = 667, e.bracketleft = 333, e.backslash = 278, e.bracketright = 333, e.asciicircum = 581, e.underscore = 500, e.quoteleft = 333, e.a = 500, e.b = 556, e.c = 444, e.d = 556, e.e = 444, e.f = 333, e.g = 500, e.h = 556, e.i = 278, e.j = 333, e.k = 556, e.l = 278, e.m = 833, e.n = 556, e.o = 500, e.p = 556, e.q = 556, e.r = 444, e.s = 389, e.t = 333, e.u = 556, e.v = 500, e.w = 722, e.x = 500, e.y = 500, e.z = 444, e.braceleft = 394, e.bar = 220, e.braceright = 394, e.asciitilde = 520, e.exclamdown = 333, e.cent = 500, e.sterling = 500, e.fraction = 167, e.yen = 500, e.florin = 500, e.section = 500, e.currency = 500, e.quotesingle = 278, e.quotedblleft = 500, e.guillemotleft = 500, e.guilsinglleft = 333, e.guilsinglright = 333, e.fi = 556, e.fl = 556, e.endash = 500, e.dagger = 500, e.daggerdbl = 500, e.periodcentered = 250, e.paragraph = 540, e.bullet = 350, e.quotesinglbase = 333, e.quotedblbase = 500, e.quotedblright = 500, e.guillemotright = 500, e.ellipsis = 1e3, e.perthousand = 1e3, e.questiondown = 500, e.grave = 333, e.acute = 333, e.circumflex = 333, e.tilde = 333, e.macron = 333, e.breve = 333, e.dotaccent = 333, e.dieresis = 333, e.ring = 333, e.cedilla = 333, e.hungarumlaut = 333, e.ogonek = 333, e.caron = 333, e.emdash = 1e3, e.AE = 1e3, e.ordfeminine = 300, e.Lslash = 667, e.Oslash = 778, e.OE = 1e3, e.ordmasculine = 330, e.ae = 722, e.dotlessi = 278, e.lslash = 278, e.oslash = 500, e.oe = 722, e.germandbls = 556, e.Idieresis = 389, e.eacute = 444, e.abreve = 500, e.uhungarumlaut = 556, e.ecaron = 444, e.Ydieresis = 722, e.divide = 570, e.Yacute = 722, e.Acircumflex = 722, e.aacute = 500, e.Ucircumflex = 722, e.yacute = 500, e.scommaaccent = 389, e.ecircumflex = 444, e.Uring = 722, e.Udieresis = 722, e.aogonek = 500, e.Uacute = 722, e.uogonek = 556, e.Edieresis = 667, e.Dcroat = 722, e.commaaccent = 250, e.copyright = 747, e.Emacron = 667, e.ccaron = 444, e.aring = 500, e.Ncommaaccent = 722, e.lacute = 278, e.agrave = 500, e.Tcommaaccent = 667, e.Cacute = 722, e.atilde = 500, e.Edotaccent = 667, e.scaron = 389, e.scedilla = 389, e.iacute = 278, e.lozenge = 494, e.Rcaron = 722, e.Gcommaaccent = 778, e.ucircumflex = 556, e.acircumflex = 500, e.Amacron = 722, e.rcaron = 444, e.ccedilla = 444, e.Zdotaccent = 667, e.Thorn = 611, e.Omacron = 778, e.Racute = 722, e.Sacute = 556, e.dcaron = 672, e.Umacron = 722, e.uring = 556, e.threesuperior = 300, e.Ograve = 778, e.Agrave = 722, e.Abreve = 722, e.multiply = 570, e.uacute = 556, e.Tcaron = 667, e.partialdiff = 494, e.ydieresis = 500, e.Nacute = 722, e.icircumflex = 278, e.Ecircumflex = 667, e.adieresis = 500, e.edieresis = 444, e.cacute = 444, e.nacute = 556, e.umacron = 556, e.Ncaron = 722, e.Iacute = 389, e.plusminus = 570, e.brokenbar = 220, e.registered = 747, e.Gbreve = 778, e.Idotaccent = 389, e.summation = 600, e.Egrave = 667, e.racute = 444, e.omacron = 500, e.Zacute = 667, e.Zcaron = 667, e.greaterequal = 549, e.Eth = 722, e.Ccedilla = 722, e.lcommaaccent = 278, e.tcaron = 416, e.eogonek = 444, e.Uogonek = 722, e.Aacute = 722, e.Adieresis = 722, e.egrave = 444, e.zacute = 444, e.iogonek = 278, e.Oacute = 778, e.oacute = 500, e.amacron = 500, e.sacute = 389, e.idieresis = 278, e.Ocircumflex = 778, e.Ugrave = 722, e.Delta = 612, e.thorn = 556, e.twosuperior = 300, e.Odieresis = 778, e.mu = 556, e.igrave = 278, e.ohungarumlaut = 500, e.Eogonek = 667, e.dcroat = 556, e.threequarters = 750, e.Scedilla = 556, e.lcaron = 394, e.Kcommaaccent = 778, e.Lacute = 667, e.trademark = 1e3, e.edotaccent = 444, e.Igrave = 389, e.Imacron = 389, e.Lcaron = 667, e.onehalf = 750, e.lessequal = 549, e.ocircumflex = 500, e.ntilde = 556, e.Uhungarumlaut = 722, e.Eacute = 667, e.emacron = 444, e.gbreve = 500, e.onequarter = 750, e.Scaron = 556, e.Scommaaccent = 556, e.Ohungarumlaut = 778, e.degree = 400, e.ograve = 500, e.Ccaron = 722, e.ugrave = 556, e.radical = 549, e.Dcaron = 722, e.rcommaaccent = 444, e.Ntilde = 722, e.otilde = 500, e.Rcommaaccent = 722, e.Lcommaaccent = 667, e.Atilde = 722, e.Aogonek = 722, e.Aring = 722, e.Otilde = 778, e.zdotaccent = 444, e.Ecaron = 667, e.Iogonek = 389, e.kcommaaccent = 556, e.minus = 570, e.Icircumflex = 389, e.ncaron = 556, e.tcommaaccent = 333, e.logicalnot = 570, e.odieresis = 500, e.udieresis = 556, e.notequal = 549, e.gcommaaccent = 500, e.eth = 500, e.zcaron = 444, e.ncommaaccent = 556, e.onesuperior = 300, e.imacron = 278, e.Euro = 500;
            }), h["Times-BoldItalic"] = (0, t.getLookupTableFactory)(function(e) {
              e.space = 250, e.exclam = 389, e.quotedbl = 555, e.numbersign = 500, e.dollar = 500, e.percent = 833, e.ampersand = 778, e.quoteright = 333, e.parenleft = 333, e.parenright = 333, e.asterisk = 500, e.plus = 570, e.comma = 250, e.hyphen = 333, e.period = 250, e.slash = 278, e.zero = 500, e.one = 500, e.two = 500, e.three = 500, e.four = 500, e.five = 500, e.six = 500, e.seven = 500, e.eight = 500, e.nine = 500, e.colon = 333, e.semicolon = 333, e.less = 570, e.equal = 570, e.greater = 570, e.question = 500, e.at = 832, e.A = 667, e.B = 667, e.C = 667, e.D = 722, e.E = 667, e.F = 667, e.G = 722, e.H = 778, e.I = 389, e.J = 500, e.K = 667, e.L = 611, e.M = 889, e.N = 722, e.O = 722, e.P = 611, e.Q = 722, e.R = 667, e.S = 556, e.T = 611, e.U = 722, e.V = 667, e.W = 889, e.X = 667, e.Y = 611, e.Z = 611, e.bracketleft = 333, e.backslash = 278, e.bracketright = 333, e.asciicircum = 570, e.underscore = 500, e.quoteleft = 333, e.a = 500, e.b = 500, e.c = 444, e.d = 500, e.e = 444, e.f = 333, e.g = 500, e.h = 556, e.i = 278, e.j = 278, e.k = 500, e.l = 278, e.m = 778, e.n = 556, e.o = 500, e.p = 500, e.q = 500, e.r = 389, e.s = 389, e.t = 278, e.u = 556, e.v = 444, e.w = 667, e.x = 500, e.y = 444, e.z = 389, e.braceleft = 348, e.bar = 220, e.braceright = 348, e.asciitilde = 570, e.exclamdown = 389, e.cent = 500, e.sterling = 500, e.fraction = 167, e.yen = 500, e.florin = 500, e.section = 500, e.currency = 500, e.quotesingle = 278, e.quotedblleft = 500, e.guillemotleft = 500, e.guilsinglleft = 333, e.guilsinglright = 333, e.fi = 556, e.fl = 556, e.endash = 500, e.dagger = 500, e.daggerdbl = 500, e.periodcentered = 250, e.paragraph = 500, e.bullet = 350, e.quotesinglbase = 333, e.quotedblbase = 500, e.quotedblright = 500, e.guillemotright = 500, e.ellipsis = 1e3, e.perthousand = 1e3, e.questiondown = 500, e.grave = 333, e.acute = 333, e.circumflex = 333, e.tilde = 333, e.macron = 333, e.breve = 333, e.dotaccent = 333, e.dieresis = 333, e.ring = 333, e.cedilla = 333, e.hungarumlaut = 333, e.ogonek = 333, e.caron = 333, e.emdash = 1e3, e.AE = 944, e.ordfeminine = 266, e.Lslash = 611, e.Oslash = 722, e.OE = 944, e.ordmasculine = 300, e.ae = 722, e.dotlessi = 278, e.lslash = 278, e.oslash = 500, e.oe = 722, e.germandbls = 500, e.Idieresis = 389, e.eacute = 444, e.abreve = 500, e.uhungarumlaut = 556, e.ecaron = 444, e.Ydieresis = 611, e.divide = 570, e.Yacute = 611, e.Acircumflex = 667, e.aacute = 500, e.Ucircumflex = 722, e.yacute = 444, e.scommaaccent = 389, e.ecircumflex = 444, e.Uring = 722, e.Udieresis = 722, e.aogonek = 500, e.Uacute = 722, e.uogonek = 556, e.Edieresis = 667, e.Dcroat = 722, e.commaaccent = 250, e.copyright = 747, e.Emacron = 667, e.ccaron = 444, e.aring = 500, e.Ncommaaccent = 722, e.lacute = 278, e.agrave = 500, e.Tcommaaccent = 611, e.Cacute = 667, e.atilde = 500, e.Edotaccent = 667, e.scaron = 389, e.scedilla = 389, e.iacute = 278, e.lozenge = 494, e.Rcaron = 667, e.Gcommaaccent = 722, e.ucircumflex = 556, e.acircumflex = 500, e.Amacron = 667, e.rcaron = 389, e.ccedilla = 444, e.Zdotaccent = 611, e.Thorn = 611, e.Omacron = 722, e.Racute = 667, e.Sacute = 556, e.dcaron = 608, e.Umacron = 722, e.uring = 556, e.threesuperior = 300, e.Ograve = 722, e.Agrave = 667, e.Abreve = 667, e.multiply = 570, e.uacute = 556, e.Tcaron = 611, e.partialdiff = 494, e.ydieresis = 444, e.Nacute = 722, e.icircumflex = 278, e.Ecircumflex = 667, e.adieresis = 500, e.edieresis = 444, e.cacute = 444, e.nacute = 556, e.umacron = 556, e.Ncaron = 722, e.Iacute = 389, e.plusminus = 570, e.brokenbar = 220, e.registered = 747, e.Gbreve = 722, e.Idotaccent = 389, e.summation = 600, e.Egrave = 667, e.racute = 389, e.omacron = 500, e.Zacute = 611, e.Zcaron = 611, e.greaterequal = 549, e.Eth = 722, e.Ccedilla = 667, e.lcommaaccent = 278, e.tcaron = 366, e.eogonek = 444, e.Uogonek = 722, e.Aacute = 667, e.Adieresis = 667, e.egrave = 444, e.zacute = 389, e.iogonek = 278, e.Oacute = 722, e.oacute = 500, e.amacron = 500, e.sacute = 389, e.idieresis = 278, e.Ocircumflex = 722, e.Ugrave = 722, e.Delta = 612, e.thorn = 500, e.twosuperior = 300, e.Odieresis = 722, e.mu = 576, e.igrave = 278, e.ohungarumlaut = 500, e.Eogonek = 667, e.dcroat = 500, e.threequarters = 750, e.Scedilla = 556, e.lcaron = 382, e.Kcommaaccent = 667, e.Lacute = 611, e.trademark = 1e3, e.edotaccent = 444, e.Igrave = 389, e.Imacron = 389, e.Lcaron = 611, e.onehalf = 750, e.lessequal = 549, e.ocircumflex = 500, e.ntilde = 556, e.Uhungarumlaut = 722, e.Eacute = 667, e.emacron = 444, e.gbreve = 500, e.onequarter = 750, e.Scaron = 556, e.Scommaaccent = 556, e.Ohungarumlaut = 722, e.degree = 400, e.ograve = 500, e.Ccaron = 667, e.ugrave = 556, e.radical = 549, e.Dcaron = 722, e.rcommaaccent = 389, e.Ntilde = 722, e.otilde = 500, e.Rcommaaccent = 667, e.Lcommaaccent = 611, e.Atilde = 667, e.Aogonek = 667, e.Aring = 667, e.Otilde = 722, e.zdotaccent = 389, e.Ecaron = 667, e.Iogonek = 389, e.kcommaaccent = 500, e.minus = 606, e.Icircumflex = 389, e.ncaron = 556, e.tcommaaccent = 278, e.logicalnot = 606, e.odieresis = 500, e.udieresis = 556, e.notequal = 549, e.gcommaaccent = 500, e.eth = 500, e.zcaron = 389, e.ncommaaccent = 556, e.onesuperior = 300, e.imacron = 278, e.Euro = 500;
            }), h["Times-Italic"] = (0, t.getLookupTableFactory)(function(e) {
              e.space = 250, e.exclam = 333, e.quotedbl = 420, e.numbersign = 500, e.dollar = 500, e.percent = 833, e.ampersand = 778, e.quoteright = 333, e.parenleft = 333, e.parenright = 333, e.asterisk = 500, e.plus = 675, e.comma = 250, e.hyphen = 333, e.period = 250, e.slash = 278, e.zero = 500, e.one = 500, e.two = 500, e.three = 500, e.four = 500, e.five = 500, e.six = 500, e.seven = 500, e.eight = 500, e.nine = 500, e.colon = 333, e.semicolon = 333, e.less = 675, e.equal = 675, e.greater = 675, e.question = 500, e.at = 920, e.A = 611, e.B = 611, e.C = 667, e.D = 722, e.E = 611, e.F = 611, e.G = 722, e.H = 722, e.I = 333, e.J = 444, e.K = 667, e.L = 556, e.M = 833, e.N = 667, e.O = 722, e.P = 611, e.Q = 722, e.R = 611, e.S = 500, e.T = 556, e.U = 722, e.V = 611, e.W = 833, e.X = 611, e.Y = 556, e.Z = 556, e.bracketleft = 389, e.backslash = 278, e.bracketright = 389, e.asciicircum = 422, e.underscore = 500, e.quoteleft = 333, e.a = 500, e.b = 500, e.c = 444, e.d = 500, e.e = 444, e.f = 278, e.g = 500, e.h = 500, e.i = 278, e.j = 278, e.k = 444, e.l = 278, e.m = 722, e.n = 500, e.o = 500, e.p = 500, e.q = 500, e.r = 389, e.s = 389, e.t = 278, e.u = 500, e.v = 444, e.w = 667, e.x = 444, e.y = 444, e.z = 389, e.braceleft = 400, e.bar = 275, e.braceright = 400, e.asciitilde = 541, e.exclamdown = 389, e.cent = 500, e.sterling = 500, e.fraction = 167, e.yen = 500, e.florin = 500, e.section = 500, e.currency = 500, e.quotesingle = 214, e.quotedblleft = 556, e.guillemotleft = 500, e.guilsinglleft = 333, e.guilsinglright = 333, e.fi = 500, e.fl = 500, e.endash = 500, e.dagger = 500, e.daggerdbl = 500, e.periodcentered = 250, e.paragraph = 523, e.bullet = 350, e.quotesinglbase = 333, e.quotedblbase = 556, e.quotedblright = 556, e.guillemotright = 500, e.ellipsis = 889, e.perthousand = 1e3, e.questiondown = 500, e.grave = 333, e.acute = 333, e.circumflex = 333, e.tilde = 333, e.macron = 333, e.breve = 333, e.dotaccent = 333, e.dieresis = 333, e.ring = 333, e.cedilla = 333, e.hungarumlaut = 333, e.ogonek = 333, e.caron = 333, e.emdash = 889, e.AE = 889, e.ordfeminine = 276, e.Lslash = 556, e.Oslash = 722, e.OE = 944, e.ordmasculine = 310, e.ae = 667, e.dotlessi = 278, e.lslash = 278, e.oslash = 500, e.oe = 667, e.germandbls = 500, e.Idieresis = 333, e.eacute = 444, e.abreve = 500, e.uhungarumlaut = 500, e.ecaron = 444, e.Ydieresis = 556, e.divide = 675, e.Yacute = 556, e.Acircumflex = 611, e.aacute = 500, e.Ucircumflex = 722, e.yacute = 444, e.scommaaccent = 389, e.ecircumflex = 444, e.Uring = 722, e.Udieresis = 722, e.aogonek = 500, e.Uacute = 722, e.uogonek = 500, e.Edieresis = 611, e.Dcroat = 722, e.commaaccent = 250, e.copyright = 760, e.Emacron = 611, e.ccaron = 444, e.aring = 500, e.Ncommaaccent = 667, e.lacute = 278, e.agrave = 500, e.Tcommaaccent = 556, e.Cacute = 667, e.atilde = 500, e.Edotaccent = 611, e.scaron = 389, e.scedilla = 389, e.iacute = 278, e.lozenge = 471, e.Rcaron = 611, e.Gcommaaccent = 722, e.ucircumflex = 500, e.acircumflex = 500, e.Amacron = 611, e.rcaron = 389, e.ccedilla = 444, e.Zdotaccent = 556, e.Thorn = 611, e.Omacron = 722, e.Racute = 611, e.Sacute = 500, e.dcaron = 544, e.Umacron = 722, e.uring = 500, e.threesuperior = 300, e.Ograve = 722, e.Agrave = 611, e.Abreve = 611, e.multiply = 675, e.uacute = 500, e.Tcaron = 556, e.partialdiff = 476, e.ydieresis = 444, e.Nacute = 667, e.icircumflex = 278, e.Ecircumflex = 611, e.adieresis = 500, e.edieresis = 444, e.cacute = 444, e.nacute = 500, e.umacron = 500, e.Ncaron = 667, e.Iacute = 333, e.plusminus = 675, e.brokenbar = 275, e.registered = 760, e.Gbreve = 722, e.Idotaccent = 333, e.summation = 600, e.Egrave = 611, e.racute = 389, e.omacron = 500, e.Zacute = 556, e.Zcaron = 556, e.greaterequal = 549, e.Eth = 722, e.Ccedilla = 667, e.lcommaaccent = 278, e.tcaron = 300, e.eogonek = 444, e.Uogonek = 722, e.Aacute = 611, e.Adieresis = 611, e.egrave = 444, e.zacute = 389, e.iogonek = 278, e.Oacute = 722, e.oacute = 500, e.amacron = 500, e.sacute = 389, e.idieresis = 278, e.Ocircumflex = 722, e.Ugrave = 722, e.Delta = 612, e.thorn = 500, e.twosuperior = 300, e.Odieresis = 722, e.mu = 500, e.igrave = 278, e.ohungarumlaut = 500, e.Eogonek = 611, e.dcroat = 500, e.threequarters = 750, e.Scedilla = 500, e.lcaron = 300, e.Kcommaaccent = 667, e.Lacute = 556, e.trademark = 980, e.edotaccent = 444, e.Igrave = 333, e.Imacron = 333, e.Lcaron = 611, e.onehalf = 750, e.lessequal = 549, e.ocircumflex = 500, e.ntilde = 500, e.Uhungarumlaut = 722, e.Eacute = 611, e.emacron = 444, e.gbreve = 500, e.onequarter = 750, e.Scaron = 500, e.Scommaaccent = 500, e.Ohungarumlaut = 722, e.degree = 400, e.ograve = 500, e.Ccaron = 667, e.ugrave = 500, e.radical = 453, e.Dcaron = 722, e.rcommaaccent = 389, e.Ntilde = 667, e.otilde = 500, e.Rcommaaccent = 611, e.Lcommaaccent = 556, e.Atilde = 611, e.Aogonek = 611, e.Aring = 611, e.Otilde = 722, e.zdotaccent = 389, e.Ecaron = 611, e.Iogonek = 333, e.kcommaaccent = 444, e.minus = 675, e.Icircumflex = 333, e.ncaron = 500, e.tcommaaccent = 278, e.logicalnot = 675, e.odieresis = 500, e.udieresis = 500, e.notequal = 549, e.gcommaaccent = 500, e.eth = 500, e.zcaron = 389, e.ncommaaccent = 500, e.onesuperior = 300, e.imacron = 278, e.Euro = 500;
            }), h.ZapfDingbats = (0, t.getLookupTableFactory)(function(e) {
              e.space = 278, e.a1 = 974, e.a2 = 961, e.a202 = 974, e.a3 = 980, e.a4 = 719, e.a5 = 789, e.a119 = 790, e.a118 = 791, e.a117 = 690, e.a11 = 960, e.a12 = 939, e.a13 = 549, e.a14 = 855, e.a15 = 911, e.a16 = 933, e.a105 = 911, e.a17 = 945, e.a18 = 974, e.a19 = 755, e.a20 = 846, e.a21 = 762, e.a22 = 761, e.a23 = 571, e.a24 = 677, e.a25 = 763, e.a26 = 760, e.a27 = 759, e.a28 = 754, e.a6 = 494, e.a7 = 552, e.a8 = 537, e.a9 = 577, e.a10 = 692, e.a29 = 786, e.a30 = 788, e.a31 = 788, e.a32 = 790, e.a33 = 793, e.a34 = 794, e.a35 = 816, e.a36 = 823, e.a37 = 789, e.a38 = 841, e.a39 = 823, e.a40 = 833, e.a41 = 816, e.a42 = 831, e.a43 = 923, e.a44 = 744, e.a45 = 723, e.a46 = 749, e.a47 = 790, e.a48 = 792, e.a49 = 695, e.a50 = 776, e.a51 = 768, e.a52 = 792, e.a53 = 759, e.a54 = 707, e.a55 = 708, e.a56 = 682, e.a57 = 701, e.a58 = 826, e.a59 = 815, e.a60 = 789, e.a61 = 789, e.a62 = 707, e.a63 = 687, e.a64 = 696, e.a65 = 689, e.a66 = 786, e.a67 = 787, e.a68 = 713, e.a69 = 791, e.a70 = 785, e.a71 = 791, e.a72 = 873, e.a73 = 761, e.a74 = 762, e.a203 = 762, e.a75 = 759, e.a204 = 759, e.a76 = 892, e.a77 = 892, e.a78 = 788, e.a79 = 784, e.a81 = 438, e.a82 = 138, e.a83 = 277, e.a84 = 415, e.a97 = 392, e.a98 = 392, e.a99 = 668, e.a100 = 668, e.a89 = 390, e.a90 = 390, e.a93 = 317, e.a94 = 317, e.a91 = 276, e.a92 = 276, e.a205 = 509, e.a85 = 509, e.a206 = 410, e.a86 = 410, e.a87 = 234, e.a88 = 234, e.a95 = 334, e.a96 = 334, e.a101 = 732, e.a102 = 544, e.a103 = 544, e.a104 = 910, e.a106 = 667, e.a107 = 760, e.a108 = 760, e.a112 = 776, e.a111 = 595, e.a110 = 694, e.a109 = 626, e.a120 = 788, e.a121 = 788, e.a122 = 788, e.a123 = 788, e.a124 = 788, e.a125 = 788, e.a126 = 788, e.a127 = 788, e.a128 = 788, e.a129 = 788, e.a130 = 788, e.a131 = 788, e.a132 = 788, e.a133 = 788, e.a134 = 788, e.a135 = 788, e.a136 = 788, e.a137 = 788, e.a138 = 788, e.a139 = 788, e.a140 = 788, e.a141 = 788, e.a142 = 788, e.a143 = 788, e.a144 = 788, e.a145 = 788, e.a146 = 788, e.a147 = 788, e.a148 = 788, e.a149 = 788, e.a150 = 788, e.a151 = 788, e.a152 = 788, e.a153 = 788, e.a154 = 788, e.a155 = 788, e.a156 = 788, e.a157 = 788, e.a158 = 788, e.a159 = 788, e.a160 = 894, e.a161 = 838, e.a163 = 1016, e.a164 = 458, e.a196 = 748, e.a165 = 924, e.a192 = 748, e.a166 = 918, e.a167 = 927, e.a168 = 928, e.a169 = 928, e.a170 = 834, e.a171 = 873, e.a172 = 828, e.a173 = 924, e.a162 = 924, e.a174 = 917, e.a175 = 930, e.a176 = 931, e.a177 = 463, e.a178 = 883, e.a179 = 836, e.a193 = 836, e.a180 = 867, e.a199 = 867, e.a181 = 696, e.a200 = 696, e.a182 = 874, e.a201 = 874, e.a183 = 760, e.a184 = 946, e.a197 = 771, e.a185 = 865, e.a194 = 771, e.a198 = 888, e.a186 = 967, e.a195 = 888, e.a187 = 831, e.a188 = 873, e.a189 = 927, e.a190 = 970, e.a191 = 918;
            });
          });
          o.getMetrics = a;
          const v = (0, t.getLookupTableFactory)(function(h) {
            h.Courier = {
              ascent: 629,
              descent: -157,
              capHeight: 562,
              xHeight: -426
            }, h["Courier-Bold"] = {
              ascent: 629,
              descent: -157,
              capHeight: 562,
              xHeight: 439
            }, h["Courier-Oblique"] = {
              ascent: 629,
              descent: -157,
              capHeight: 562,
              xHeight: 426
            }, h["Courier-BoldOblique"] = {
              ascent: 629,
              descent: -157,
              capHeight: 562,
              xHeight: 426
            }, h.Helvetica = {
              ascent: 718,
              descent: -207,
              capHeight: 718,
              xHeight: 523
            }, h["Helvetica-Bold"] = {
              ascent: 718,
              descent: -207,
              capHeight: 718,
              xHeight: 532
            }, h["Helvetica-Oblique"] = {
              ascent: 718,
              descent: -207,
              capHeight: 718,
              xHeight: 523
            }, h["Helvetica-BoldOblique"] = {
              ascent: 718,
              descent: -207,
              capHeight: 718,
              xHeight: 532
            }, h["Times-Roman"] = {
              ascent: 683,
              descent: -217,
              capHeight: 662,
              xHeight: 450
            }, h["Times-Bold"] = {
              ascent: 683,
              descent: -217,
              capHeight: 676,
              xHeight: 461
            }, h["Times-Italic"] = {
              ascent: 683,
              descent: -217,
              capHeight: 653,
              xHeight: 441
            }, h["Times-BoldItalic"] = {
              ascent: 683,
              descent: -217,
              capHeight: 669,
              xHeight: 462
            }, h.Symbol = {
              ascent: Math.NaN,
              descent: Math.NaN,
              capHeight: Math.NaN,
              xHeight: Math.NaN
            }, h.ZapfDingbats = {
              ascent: Math.NaN,
              descent: Math.NaN,
              capHeight: Math.NaN,
              xHeight: Math.NaN
            };
          });
          o.getFontBasicMetrics = v;
        },
        /* 46 */
        /***/
        (J, o) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.GlyfTable = void 0;
          const F = 1 << 0, t = 1 << 1, a = 1 << 2, v = 1 << 3, h = 1 << 4, e = 1 << 5, y = 1 << 6, c = 1 << 0, d = 1 << 1, m = 1 << 3, p = 1 << 5, g = 1 << 6, n = 1 << 7, i = 1 << 8;
          class l {
            constructor({
              glyfTable: j,
              isGlyphLocationsLong: X,
              locaTable: B,
              numGlyphs: U
            }) {
              this.glyphs = [];
              const k = new DataView(B.buffer, B.byteOffset, B.byteLength), x = new DataView(j.buffer, j.byteOffset, j.byteLength), f = X ? 4 : 2;
              let D = X ? k.getUint32(0) : 2 * k.getUint16(0), _ = 0;
              for (let S = 0; S < U; S++) {
                _ += f;
                const C = X ? k.getUint32(_) : 2 * k.getUint16(_);
                if (C === D) {
                  this.glyphs.push(new u({}));
                  continue;
                }
                const T = u.parse(D, x);
                this.glyphs.push(T), D = C;
              }
            }
            getSize() {
              return this.glyphs.reduce((j, X) => {
                const B = X.getSize();
                return j + (B + 3 & -4);
              }, 0);
            }
            write() {
              const j = this.getSize(), X = new DataView(new ArrayBuffer(j)), B = j > 131070, U = B ? 4 : 2, k = new DataView(new ArrayBuffer((this.glyphs.length + 1) * U));
              B ? k.setUint32(0, 0) : k.setUint16(0, 0);
              let x = 0, f = 0;
              for (const D of this.glyphs)
                x += D.write(x, X), x = x + 3 & -4, f += U, B ? k.setUint32(f, x) : k.setUint16(f, x >> 1);
              return {
                isLocationLong: B,
                loca: new Uint8Array(k.buffer),
                glyf: new Uint8Array(X.buffer)
              };
            }
            scale(j) {
              for (let X = 0, B = this.glyphs.length; X < B; X++)
                this.glyphs[X].scale(j[X]);
            }
          }
          o.GlyfTable = l;
          class u {
            constructor({
              header: j = null,
              simple: X = null,
              composites: B = null
            }) {
              this.header = j, this.simple = X, this.composites = B;
            }
            static parse(j, X) {
              const [B, U] = w.parse(j, X);
              if (j += B, U.numberOfContours < 0) {
                const x = [];
                for (; ; ) {
                  const [f, D] = A.parse(j, X);
                  if (j += f, x.push(D), !(D.flags & p))
                    break;
                }
                return new u({
                  header: U,
                  composites: x
                });
              }
              const k = b.parse(j, X, U.numberOfContours);
              return new u({
                header: U,
                simple: k
              });
            }
            getSize() {
              if (!this.header)
                return 0;
              const j = this.simple ? this.simple.getSize() : this.composites.reduce((X, B) => X + B.getSize(), 0);
              return this.header.getSize() + j;
            }
            write(j, X) {
              if (!this.header)
                return 0;
              const B = j;
              if (j += this.header.write(j, X), this.simple)
                j += this.simple.write(j, X);
              else
                for (const U of this.composites)
                  j += U.write(j, X);
              return j - B;
            }
            scale(j) {
              if (!this.header)
                return;
              const X = (this.header.xMin + this.header.xMax) / 2;
              if (this.header.scale(X, j), this.simple)
                this.simple.scale(X, j);
              else
                for (const B of this.composites)
                  B.scale(X, j);
            }
          }
          class w {
            constructor({
              numberOfContours: j,
              xMin: X,
              yMin: B,
              xMax: U,
              yMax: k
            }) {
              this.numberOfContours = j, this.xMin = X, this.yMin = B, this.xMax = U, this.yMax = k;
            }
            static parse(j, X) {
              return [10, new w({
                numberOfContours: X.getInt16(j),
                xMin: X.getInt16(j + 2),
                yMin: X.getInt16(j + 4),
                xMax: X.getInt16(j + 6),
                yMax: X.getInt16(j + 8)
              })];
            }
            getSize() {
              return 10;
            }
            write(j, X) {
              return X.setInt16(j, this.numberOfContours), X.setInt16(j + 2, this.xMin), X.setInt16(j + 4, this.yMin), X.setInt16(j + 6, this.xMax), X.setInt16(j + 8, this.yMax), 10;
            }
            scale(j, X) {
              this.xMin = Math.round(j + (this.xMin - j) * X), this.xMax = Math.round(j + (this.xMax - j) * X);
            }
          }
          class O {
            constructor({
              flags: j,
              xCoordinates: X,
              yCoordinates: B
            }) {
              this.xCoordinates = X, this.yCoordinates = B, this.flags = j;
            }
          }
          class b {
            constructor({
              contours: j,
              instructions: X
            }) {
              this.contours = j, this.instructions = X;
            }
            static parse(j, X, B) {
              const U = [];
              for (let Z = 0; Z < B; Z++) {
                const $ = X.getUint16(j);
                j += 2, U.push($);
              }
              const k = U[B - 1] + 1, x = X.getUint16(j);
              j += 2;
              const f = new Uint8Array(X).slice(j, j + x);
              j += x;
              const D = [];
              for (let Z = 0; Z < k; j++, Z++) {
                let $ = X.getUint8(j);
                if (D.push($), $ & v) {
                  const z = X.getUint8(++j);
                  $ ^= v;
                  for (let V = 0; V < z; V++)
                    D.push($);
                  Z += z;
                }
              }
              const _ = [];
              let S = [], C = [], T = [];
              const P = [];
              let M = 0, G = 0;
              for (let Z = 0; Z < k; Z++) {
                const $ = D[Z];
                if ($ & t) {
                  const z = X.getUint8(j++);
                  G += $ & h ? z : -z, S.push(G);
                } else
                  $ & h || (G += X.getInt16(j), j += 2), S.push(G);
                U[M] === Z && (M++, _.push(S), S = []);
              }
              G = 0, M = 0;
              for (let Z = 0; Z < k; Z++) {
                const $ = D[Z];
                if ($ & a) {
                  const z = X.getUint8(j++);
                  G += $ & e ? z : -z, C.push(G);
                } else
                  $ & e || (G += X.getInt16(j), j += 2), C.push(G);
                T.push($ & F | $ & y), U[M] === Z && (S = _[M], M++, P.push(new O({
                  flags: T,
                  xCoordinates: S,
                  yCoordinates: C
                })), C = [], T = []);
              }
              return new b({
                contours: P,
                instructions: f
              });
            }
            getSize() {
              let j = this.contours.length * 2 + 2 + this.instructions.length, X = 0, B = 0;
              for (const U of this.contours) {
                j += U.flags.length;
                for (let k = 0, x = U.xCoordinates.length; k < x; k++) {
                  const f = U.xCoordinates[k], D = U.yCoordinates[k];
                  let _ = Math.abs(f - X);
                  _ > 255 ? j += 2 : _ > 0 && (j += 1), X = f, _ = Math.abs(D - B), _ > 255 ? j += 2 : _ > 0 && (j += 1), B = D;
                }
              }
              return j;
            }
            write(j, X) {
              const B = j, U = [], k = [], x = [];
              let f = 0, D = 0;
              for (const _ of this.contours) {
                for (let S = 0, C = _.xCoordinates.length; S < C; S++) {
                  let T = _.flags[S];
                  const P = _.xCoordinates[S];
                  let M = P - f;
                  if (M === 0)
                    T |= h, U.push(0);
                  else {
                    const Z = Math.abs(M);
                    Z <= 255 ? (T |= M >= 0 ? t | h : t, U.push(Z)) : U.push(M);
                  }
                  f = P;
                  const G = _.yCoordinates[S];
                  if (M = G - D, M === 0)
                    T |= e, k.push(0);
                  else {
                    const Z = Math.abs(M);
                    Z <= 255 ? (T |= M >= 0 ? a | e : a, k.push(Z)) : k.push(M);
                  }
                  D = G, x.push(T);
                }
                X.setUint16(j, U.length - 1), j += 2;
              }
              X.setUint16(j, this.instructions.length), j += 2, this.instructions.length && (new Uint8Array(X.buffer, 0, X.buffer.byteLength).set(this.instructions, j), j += this.instructions.length);
              for (const _ of x)
                X.setUint8(j++, _);
              for (let _ = 0, S = U.length; _ < S; _++) {
                const C = U[_], T = x[_];
                T & t ? X.setUint8(j++, C) : T & h || (X.setInt16(j, C), j += 2);
              }
              for (let _ = 0, S = k.length; _ < S; _++) {
                const C = k[_], T = x[_];
                T & a ? X.setUint8(j++, C) : T & e || (X.setInt16(j, C), j += 2);
              }
              return j - B;
            }
            scale(j, X) {
              for (const B of this.contours)
                if (B.xCoordinates.length !== 0)
                  for (let U = 0, k = B.xCoordinates.length; U < k; U++)
                    B.xCoordinates[U] = Math.round(j + (B.xCoordinates[U] - j) * X);
            }
          }
          class A {
            constructor({
              flags: j,
              glyphIndex: X,
              argument1: B,
              argument2: U,
              transf: k,
              instructions: x
            }) {
              this.flags = j, this.glyphIndex = X, this.argument1 = B, this.argument2 = U, this.transf = k, this.instructions = x;
            }
            static parse(j, X) {
              const B = j, U = [];
              let k = X.getUint16(j);
              const x = X.getUint16(j + 2);
              j += 4;
              let f, D;
              k & c ? (k & d ? (f = X.getInt16(j), D = X.getInt16(j + 2)) : (f = X.getUint16(j), D = X.getUint16(j + 2)), j += 4, k ^= c) : (k & d ? (f = X.getInt8(j), D = X.getInt8(j + 1)) : (f = X.getUint8(j), D = X.getUint8(j + 1)), j += 2), k & m ? (U.push(X.getUint16(j)), j += 2) : k & g ? (U.push(X.getUint16(j), X.getUint16(j + 2)), j += 4) : k & n && (U.push(X.getUint16(j), X.getUint16(j + 2), X.getUint16(j + 4), X.getUint16(j + 6)), j += 8);
              let _ = null;
              if (k & i) {
                const S = X.getUint16(j);
                j += 2, _ = new Uint8Array(X).slice(j, j + S), j += S;
              }
              return [j - B, new A({
                flags: k,
                glyphIndex: x,
                argument1: f,
                argument2: D,
                transf: U,
                instructions: _
              })];
            }
            getSize() {
              let j = 4 + this.transf.length * 2;
              return this.flags & i && (j += 2 + this.instructions.length), j += 2, this.flags & 2 ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (j += 2) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (j += 2), j;
            }
            write(j, X) {
              const B = j;
              return this.flags & d ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (this.flags |= c) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (this.flags |= c), X.setUint16(j, this.flags), X.setUint16(j + 2, this.glyphIndex), j += 4, this.flags & c ? (this.flags & d ? (X.setInt16(j, this.argument1), X.setInt16(j + 2, this.argument2)) : (X.setUint16(j, this.argument1), X.setUint16(j + 2, this.argument2)), j += 4) : (X.setUint8(j, this.argument1), X.setUint8(j + 1, this.argument2), j += 2), this.flags & i && (X.setUint16(j, this.instructions.length), j += 2, this.instructions.length && (new Uint8Array(X.buffer, 0, X.buffer.byteLength).set(this.instructions, j), j += this.instructions.length)), j - B;
            }
            scale(j, X) {
            }
          }
        },
        /* 47 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.OpenTypeFileBuilder = void 0;
          var t = F(6), a = F(2);
          function v(m, p, g) {
            m[p] = g >> 8 & 255, m[p + 1] = g & 255;
          }
          function h(m, p, g) {
            m[p] = g >> 24 & 255, m[p + 1] = g >> 16 & 255, m[p + 2] = g >> 8 & 255, m[p + 3] = g & 255;
          }
          function e(m, p, g) {
            if (g instanceof Uint8Array)
              m.set(g, p);
            else if (typeof g == "string")
              for (let n = 0, i = g.length; n < i; n++)
                m[p++] = g.charCodeAt(n) & 255;
            else
              for (let n = 0, i = g.length; n < i; n++)
                m[p++] = g[n] & 255;
          }
          const y = 12, c = 16;
          class d {
            constructor(p) {
              this.sfnt = p, this.tables = /* @__PURE__ */ Object.create(null);
            }
            static getSearchParams(p, g) {
              let n = 1, i = 0;
              for (; (n ^ p) > n; )
                n <<= 1, i++;
              const l = n * g;
              return {
                range: l,
                entry: i,
                rangeShift: g * p - l
              };
            }
            toArray() {
              let p = this.sfnt;
              const g = this.tables, n = Object.keys(g);
              n.sort();
              const i = n.length;
              let l, u, w, O, b, A = y + i * c;
              const Y = [A];
              for (l = 0; l < i; l++) {
                O = g[n[l]];
                const B = (O.length + 3 & -4) >>> 0;
                A += B, Y.push(A);
              }
              const j = new Uint8Array(A);
              for (l = 0; l < i; l++)
                O = g[n[l]], e(j, Y[l], O);
              p === "true" && (p = (0, a.string32)(65536)), j[0] = p.charCodeAt(0) & 255, j[1] = p.charCodeAt(1) & 255, j[2] = p.charCodeAt(2) & 255, j[3] = p.charCodeAt(3) & 255, v(j, 4, i);
              const X = d.getSearchParams(i, 16);
              for (v(j, 6, X.range), v(j, 8, X.entry), v(j, 10, X.rangeShift), A = y, l = 0; l < i; l++) {
                b = n[l], j[A] = b.charCodeAt(0) & 255, j[A + 1] = b.charCodeAt(1) & 255, j[A + 2] = b.charCodeAt(2) & 255, j[A + 3] = b.charCodeAt(3) & 255;
                let B = 0;
                for (u = Y[l], w = Y[l + 1]; u < w; u += 4) {
                  const U = (0, t.readUint32)(j, u);
                  B = B + U >>> 0;
                }
                h(j, A + 4, B), h(j, A + 8, Y[l]), h(j, A + 12, g[b].length), A += c;
              }
              return j;
            }
            addTable(p, g) {
              if (p in this.tables)
                throw new Error("Table " + p + " already exists");
              this.tables[p] = g;
            }
          }
          o.OpenTypeFileBuilder = d;
        },
        /* 48 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.Type1Font = void 0;
          var t = F(35), a = F(38), v = F(6), h = F(10), e = F(49), y = F(2);
          function c(g, n, i) {
            const l = g.length, u = n.length, w = l - u;
            let O = i, b = !1;
            for (; O < w; ) {
              let A = 0;
              for (; A < u && g[O + A] === n[A]; )
                A++;
              if (A >= u) {
                for (O += A; O < l && (0, v.isWhiteSpace)(g[O]); )
                  O++;
                b = !0;
                break;
              }
              O++;
            }
            return {
              found: b,
              length: O
            };
          }
          function d(g, n) {
            const i = [101, 101, 120, 101, 99], l = g.pos;
            let u, w, O;
            try {
              u = g.getBytes(n), w = u.length;
            } catch {
            }
            if (w === n && (O = c(u, i, n - 2 * i.length), O.found && O.length === n))
              return {
                stream: new h.Stream(u),
                length: n
              };
            (0, y.warn)('Invalid "Length1" property in Type1 font -- trying to recover.'), g.pos = l;
            const b = 2048;
            let A;
            for (; ; ) {
              const Y = g.peekBytes(b);
              if (O = c(Y, i, 0), O.length === 0)
                break;
              if (g.pos += O.length, O.found) {
                A = g.pos - l;
                break;
              }
            }
            return g.pos = l, A ? {
              stream: new h.Stream(g.getBytes(A)),
              length: A
            } : ((0, y.warn)('Unable to recover "Length1" property in Type1 font -- using as is.'), {
              stream: new h.Stream(g.getBytes(n)),
              length: n
            });
          }
          function m(g, n) {
            const i = g.getBytes();
            return {
              stream: new h.Stream(i),
              length: i.length
            };
          }
          class p {
            constructor(n, i, l) {
              let w = l.length1;
              l.length2;
              let O = i.peekBytes(6);
              const b = O[0] === 128 && O[1] === 1;
              b && (i.skip(6), w = O[5] << 24 | O[4] << 16 | O[3] << 8 | O[2]);
              const A = d(i, w);
              new e.Type1Parser(A.stream, !1, a.SEAC_ANALYSIS_ENABLED).extractFontHeader(l), b && (O = i.getBytes(6), O[5] << 24 | O[4] << 16 | O[3] << 8 | O[2]);
              const j = m(i), B = new e.Type1Parser(j.stream, !0, a.SEAC_ANALYSIS_ENABLED).extractFontProgram(l);
              for (const f in B.properties)
                l[f] = B.properties[f];
              const U = B.charstrings, k = this.getType2Charstrings(U), x = this.getType2Subrs(B.subrs);
              this.charstrings = U, this.data = this.wrap(n, k, this.charstrings, x, l), this.seacs = this.getSeacs(B.charstrings);
            }
            get numGlyphs() {
              return this.charstrings.length + 1;
            }
            getCharset() {
              const n = [".notdef"];
              for (const {
                glyphName: i
              } of this.charstrings)
                n.push(i);
              return n;
            }
            getGlyphMapping(n) {
              const i = this.charstrings;
              if (n.composite) {
                const b = /* @__PURE__ */ Object.create(null);
                for (let A = 0, Y = i.length; A < Y; A++) {
                  const j = n.cMap.charCodeOf(A);
                  b[j] = A + 1;
                }
                return b;
              }
              const l = [".notdef"];
              let u, w;
              for (w = 0; w < i.length; w++)
                l.push(i[w].glyphName);
              const O = n.builtInEncoding;
              if (O) {
                u = /* @__PURE__ */ Object.create(null);
                for (const b in O)
                  w = l.indexOf(O[b]), w >= 0 && (u[b] = w);
              }
              return (0, a.type1FontGlyphMapping)(n, u, l);
            }
            hasGlyphId(n) {
              return n < 0 || n >= this.numGlyphs ? !1 : n === 0 ? !0 : this.charstrings[n - 1].charstring.length > 0;
            }
            getSeacs(n) {
              const i = [];
              for (let l = 0, u = n.length; l < u; l++) {
                const w = n[l];
                w.seac && (i[l + 1] = w.seac);
              }
              return i;
            }
            getType2Charstrings(n) {
              const i = [];
              for (let l = 0, u = n.length; l < u; l++)
                i.push(n[l].charstring);
              return i;
            }
            getType2Subrs(n) {
              let i = 0;
              const l = n.length;
              l < 1133 ? i = 107 : l < 33769 ? i = 1131 : i = 32768;
              const u = [];
              let w;
              for (w = 0; w < i; w++)
                u.push([11]);
              for (w = 0; w < l; w++)
                u.push(n[w]);
              return u;
            }
            wrap(n, i, l, u, w) {
              const O = new t.CFF();
              O.header = new t.CFFHeader(1, 0, 4, 4), O.names = [n];
              const b = new t.CFFTopDict();
              b.setByName("version", 391), b.setByName("Notice", 392), b.setByName("FullName", 393), b.setByName("FamilyName", 394), b.setByName("Weight", 395), b.setByName("Encoding", null), b.setByName("FontMatrix", w.fontMatrix), b.setByName("FontBBox", w.bbox), b.setByName("charset", null), b.setByName("CharStrings", null), b.setByName("Private", null), O.topDict = b;
              const A = new t.CFFStrings();
              A.add("Version 0.11"), A.add("See original notice"), A.add(n), A.add(n), A.add("Medium"), O.strings = A, O.globalSubrIndex = new t.CFFIndex();
              const Y = i.length, j = [".notdef"];
              let X, B;
              for (X = 0; X < Y; X++) {
                const _ = l[X].glyphName;
                t.CFFStandardStrings.indexOf(_) === -1 && A.add(_), j.push(_);
              }
              O.charset = new t.CFFCharset(!1, 0, j);
              const U = new t.CFFIndex();
              for (U.add([139, 14]), X = 0; X < Y; X++)
                U.add(i[X]);
              O.charStrings = U;
              const k = new t.CFFPrivateDict();
              k.setByName("Subrs", null);
              const x = ["BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StemSnapH", "StemSnapV", "BlueShift", "BlueFuzz", "BlueScale", "LanguageGroup", "ExpansionFactor", "ForceBold", "StdHW", "StdVW"];
              for (X = 0, B = x.length; X < B; X++) {
                const _ = x[X];
                if (!(_ in w.privateData))
                  continue;
                const S = w.privateData[_];
                if (Array.isArray(S))
                  for (let C = S.length - 1; C > 0; C--)
                    S[C] -= S[C - 1];
                k.setByName(_, S);
              }
              O.topDict.privateDict = k;
              const f = new t.CFFIndex();
              for (X = 0, B = u.length; X < B; X++)
                f.add(u[X]);
              return k.subrsIndex = f, new t.CFFCompiler(O).compile();
            }
          }
          o.Type1Font = p;
        },
        /* 49 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.Type1Parser = void 0;
          var t = F(37), a = F(6), v = F(10), h = F(2);
          const e = !1, y = {
            hstem: [1],
            vstem: [3],
            vmoveto: [4],
            rlineto: [5],
            hlineto: [6],
            vlineto: [7],
            rrcurveto: [8],
            callsubr: [10],
            flex: [12, 35],
            drop: [12, 18],
            endchar: [14],
            rmoveto: [21],
            hmoveto: [22],
            vhcurveto: [30],
            hvcurveto: [31]
          };
          class c {
            constructor() {
              this.width = 0, this.lsb = 0, this.flexing = !1, this.output = [], this.stack = [];
            }
            convert(w, O, b) {
              const A = w.length;
              let Y = !1, j, X, B;
              for (let U = 0; U < A; U++) {
                let k = w[U];
                if (k < 32) {
                  switch (k === 12 && (k = (k << 8) + w[++U]), k) {
                    case 1: {
                      this.stack = [];
                      break;
                    }
                    case 3: {
                      this.stack = [];
                      break;
                    }
                    case 4:
                      if (this.flexing) {
                        if (this.stack.length < 1) {
                          Y = !0;
                          break;
                        }
                        const S = this.stack.pop();
                        this.stack.push(0, S);
                        break;
                      }
                      Y = this.executeCommand(1, y.vmoveto);
                      break;
                    case 5:
                      Y = this.executeCommand(2, y.rlineto);
                      break;
                    case 6:
                      Y = this.executeCommand(1, y.hlineto);
                      break;
                    case 7:
                      Y = this.executeCommand(1, y.vlineto);
                      break;
                    case 8:
                      Y = this.executeCommand(6, y.rrcurveto);
                      break;
                    case 9:
                      this.stack = [];
                      break;
                    case 10:
                      if (this.stack.length < 1) {
                        Y = !0;
                        break;
                      }
                      if (B = this.stack.pop(), !O[B]) {
                        Y = !0;
                        break;
                      }
                      Y = this.convert(O[B], O, b);
                      break;
                    case 11:
                      return Y;
                    case 13:
                      if (this.stack.length < 2) {
                        Y = !0;
                        break;
                      }
                      j = this.stack.pop(), X = this.stack.pop(), this.lsb = X, this.width = j, this.stack.push(j, X), Y = this.executeCommand(2, y.hmoveto);
                      break;
                    case 14:
                      this.output.push(y.endchar[0]);
                      break;
                    case 21:
                      if (this.flexing)
                        break;
                      Y = this.executeCommand(2, y.rmoveto);
                      break;
                    case 22:
                      if (this.flexing) {
                        this.stack.push(0);
                        break;
                      }
                      Y = this.executeCommand(1, y.hmoveto);
                      break;
                    case 30:
                      Y = this.executeCommand(4, y.vhcurveto);
                      break;
                    case 31:
                      Y = this.executeCommand(4, y.hvcurveto);
                      break;
                    case 3072:
                      this.stack = [];
                      break;
                    case 3073: {
                      this.stack = [];
                      break;
                    }
                    case 3074: {
                      this.stack = [];
                      break;
                    }
                    case 3078:
                      if (b) {
                        const S = this.stack.at(-5);
                        this.seac = this.stack.splice(-4, 4), this.seac[0] += this.lsb - S, Y = this.executeCommand(0, y.endchar);
                      } else
                        Y = this.executeCommand(4, y.endchar);
                      break;
                    case 3079:
                      if (this.stack.length < 4) {
                        Y = !0;
                        break;
                      }
                      this.stack.pop(), j = this.stack.pop();
                      const x = this.stack.pop();
                      X = this.stack.pop(), this.lsb = X, this.width = j, this.stack.push(j, X, x), Y = this.executeCommand(3, y.rmoveto);
                      break;
                    case 3084:
                      if (this.stack.length < 2) {
                        Y = !0;
                        break;
                      }
                      const f = this.stack.pop(), D = this.stack.pop();
                      this.stack.push(D / f);
                      break;
                    case 3088:
                      if (this.stack.length < 2) {
                        Y = !0;
                        break;
                      }
                      B = this.stack.pop();
                      const _ = this.stack.pop();
                      if (B === 0 && _ === 3) {
                        const S = this.stack.splice(this.stack.length - 17, 17);
                        this.stack.push(S[2] + S[0], S[3] + S[1], S[4], S[5], S[6], S[7], S[8], S[9], S[10], S[11], S[12], S[13], S[14]), Y = this.executeCommand(13, y.flex, !0), this.flexing = !1, this.stack.push(S[15], S[16]);
                      } else
                        B === 1 && _ === 0 && (this.flexing = !0);
                      break;
                    case 3089:
                      break;
                    case 3105:
                      this.stack = [];
                      break;
                    default:
                      (0, h.warn)('Unknown type 1 charstring command of "' + k + '"');
                      break;
                  }
                  if (Y)
                    break;
                  continue;
                } else
                  k <= 246 ? k -= 139 : k <= 250 ? k = (k - 247) * 256 + w[++U] + 108 : k <= 254 ? k = -((k - 251) * 256) - w[++U] - 108 : k = (w[++U] & 255) << 24 | (w[++U] & 255) << 16 | (w[++U] & 255) << 8 | (w[++U] & 255) << 0;
                this.stack.push(k);
              }
              return Y;
            }
            executeCommand(w, O, b) {
              const A = this.stack.length;
              if (w > A)
                return !0;
              const Y = A - w;
              for (let j = Y; j < A; j++) {
                let X = this.stack[j];
                Number.isInteger(X) ? this.output.push(28, X >> 8 & 255, X & 255) : (X = 65536 * X | 0, this.output.push(255, X >> 24 & 255, X >> 16 & 255, X >> 8 & 255, X & 255));
              }
              return this.output.push(...O), b ? this.stack.splice(Y, w) : this.stack.length = 0, !1;
            }
          }
          const d = 55665, m = 4330;
          function p(u) {
            return u >= 48 && u <= 57 || u >= 65 && u <= 70 || u >= 97 && u <= 102;
          }
          function g(u, w, O) {
            if (O >= u.length)
              return new Uint8Array(0);
            const b = 52845, A = 22719;
            let Y = w | 0, j, X;
            for (j = 0; j < O; j++)
              Y = (u[j] + Y) * b + A & 65535;
            const B = u.length - O, U = new Uint8Array(B);
            for (j = O, X = 0; X < B; j++, X++) {
              const k = u[j];
              U[X] = k ^ Y >> 8, Y = (k + Y) * b + A & 65535;
            }
            return U;
          }
          function n(u, w, O) {
            let Y = w | 0;
            const j = u.length, X = j >>> 1, B = new Uint8Array(X);
            let U, k;
            for (U = 0, k = 0; U < j; U++) {
              const x = u[U];
              if (!p(x))
                continue;
              U++;
              let f;
              for (; U < j && !p(f = u[U]); )
                U++;
              if (U < j) {
                const D = parseInt(String.fromCharCode(x, f), 16);
                B[k++] = D ^ Y >> 8, Y = (D + Y) * 52845 + 22719 & 65535;
              }
            }
            return B.slice(O, k);
          }
          function i(u) {
            return u === 47 || u === 91 || u === 93 || u === 123 || u === 125 || u === 40 || u === 41;
          }
          class l {
            constructor(w, O, b) {
              if (O) {
                const A = w.getBytes(), Y = !((p(A[0]) || (0, a.isWhiteSpace)(A[0])) && p(A[1]) && p(A[2]) && p(A[3]) && p(A[4]) && p(A[5]) && p(A[6]) && p(A[7]));
                w = new v.Stream(Y ? g(A, d, 4) : n(A, d, 4));
              }
              this.seacAnalysisEnabled = !!b, this.stream = w, this.nextChar();
            }
            readNumberArray() {
              this.getToken();
              const w = [];
              for (; ; ) {
                const O = this.getToken();
                if (O === null || O === "]" || O === "}")
                  break;
                w.push(parseFloat(O || 0));
              }
              return w;
            }
            readNumber() {
              const w = this.getToken();
              return parseFloat(w || 0);
            }
            readInt() {
              const w = this.getToken();
              return parseInt(w || 0, 10) | 0;
            }
            readBoolean() {
              return this.getToken() === "true" ? 1 : 0;
            }
            nextChar() {
              return this.currentChar = this.stream.getByte();
            }
            prevChar() {
              return this.stream.skip(-2), this.currentChar = this.stream.getByte();
            }
            getToken() {
              let w = !1, O = this.currentChar;
              for (; ; ) {
                if (O === -1)
                  return null;
                if (w)
                  (O === 10 || O === 13) && (w = !1);
                else if (O === 37)
                  w = !0;
                else if (!(0, a.isWhiteSpace)(O))
                  break;
                O = this.nextChar();
              }
              if (i(O))
                return this.nextChar(), String.fromCharCode(O);
              let b = "";
              do
                b += String.fromCharCode(O), O = this.nextChar();
              while (O >= 0 && !(0, a.isWhiteSpace)(O) && !i(O));
              return b;
            }
            readCharStrings(w, O) {
              return O === -1 ? w : g(w, m, O);
            }
            extractFontProgram(w) {
              const O = this.stream, b = [], A = [], Y = /* @__PURE__ */ Object.create(null);
              Y.lenIV = 4;
              const j = {
                subrs: [],
                charstrings: [],
                properties: {
                  privateData: Y
                }
              };
              let X, B, U, k;
              for (; (X = this.getToken()) !== null; )
                if (X === "/")
                  switch (X = this.getToken(), X) {
                    case "CharStrings":
                      for (this.getToken(), this.getToken(), this.getToken(), this.getToken(); X = this.getToken(), !(X === null || X === "end"); ) {
                        if (X !== "/")
                          continue;
                        const f = this.getToken();
                        B = this.readInt(), this.getToken(), U = B > 0 ? O.getBytes(B) : new Uint8Array(0), k = j.properties.privateData.lenIV;
                        const D = this.readCharStrings(U, k);
                        this.nextChar(), X = this.getToken(), X === "noaccess" ? this.getToken() : X === "/" && this.prevChar(), A.push({
                          glyph: f,
                          encoded: D
                        });
                      }
                      break;
                    case "Subrs":
                      for (this.readInt(), this.getToken(); this.getToken() === "dup"; ) {
                        const f = this.readInt();
                        B = this.readInt(), this.getToken(), U = B > 0 ? O.getBytes(B) : new Uint8Array(0), k = j.properties.privateData.lenIV;
                        const D = this.readCharStrings(U, k);
                        this.nextChar(), X = this.getToken(), X === "noaccess" && this.getToken(), b[f] = D;
                      }
                      break;
                    case "BlueValues":
                    case "OtherBlues":
                    case "FamilyBlues":
                    case "FamilyOtherBlues":
                      const x = this.readNumberArray();
                      x.length > 0 && x.length % 2 === 0 && e && (j.properties.privateData[X] = x);
                      break;
                    case "StemSnapH":
                    case "StemSnapV":
                      j.properties.privateData[X] = this.readNumberArray();
                      break;
                    case "StdHW":
                    case "StdVW":
                      j.properties.privateData[X] = this.readNumberArray()[0];
                      break;
                    case "BlueShift":
                    case "lenIV":
                    case "BlueFuzz":
                    case "BlueScale":
                    case "LanguageGroup":
                    case "ExpansionFactor":
                      j.properties.privateData[X] = this.readNumber();
                      break;
                    case "ForceBold":
                      j.properties.privateData[X] = this.readBoolean();
                      break;
                  }
              for (const {
                encoded: x,
                glyph: f
              } of A) {
                const D = new c(), _ = D.convert(x, b, this.seacAnalysisEnabled);
                let S = D.output;
                _ && (S = [14]);
                const C = {
                  glyphName: f,
                  charstring: S,
                  width: D.width,
                  lsb: D.lsb,
                  seac: D.seac
                };
                if (f === ".notdef" ? j.charstrings.unshift(C) : j.charstrings.push(C), w.builtInEncoding) {
                  const T = w.builtInEncoding.indexOf(f);
                  T > -1 && w.widths[T] === void 0 && T >= w.firstChar && T <= w.lastChar && (w.widths[T] = D.width);
                }
              }
              return j;
            }
            extractFontHeader(w) {
              let O;
              for (; (O = this.getToken()) !== null; )
                if (O === "/")
                  switch (O = this.getToken(), O) {
                    case "FontMatrix":
                      const b = this.readNumberArray();
                      w.fontMatrix = b;
                      break;
                    case "Encoding":
                      const A = this.getToken();
                      let Y;
                      if (!/^\d+$/.test(A))
                        Y = (0, t.getEncoding)(A);
                      else {
                        Y = [];
                        const X = parseInt(A, 10) | 0;
                        this.getToken();
                        for (let B = 0; B < X; B++) {
                          for (O = this.getToken(); O !== "dup" && O !== "def"; )
                            if (O = this.getToken(), O === null)
                              return;
                          if (O === "def")
                            break;
                          const U = this.readInt();
                          this.getToken();
                          const k = this.getToken();
                          Y[U] = k, this.getToken();
                        }
                      }
                      w.builtInEncoding = Y;
                      break;
                    case "FontBBox":
                      const j = this.readNumberArray();
                      w.ascent = Math.max(j[3], j[1]), w.descent = Math.min(j[1], j[3]), w.ascentScaled = !0;
                      break;
                  }
            }
          }
          o.Type1Parser = l;
        },
        /* 50 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.Pattern = void 0, o.getTilingPatternIR = i;
          var t = F(2), a = F(7), v = F(14), h = F(6);
          const e = {
            FUNCTION_BASED: 1,
            AXIAL: 2,
            RADIAL: 3,
            FREE_FORM_MESH: 4,
            LATTICE_FORM_MESH: 5,
            COONS_PATCH_MESH: 6,
            TENSOR_PATCH_MESH: 7
          };
          class y {
            constructor() {
              (0, t.unreachable)("Cannot initialize Pattern.");
            }
            static parseShading(u, w, O, b, A, Y) {
              const j = u instanceof a.BaseStream ? u.dict : u, X = j.get("ShadingType");
              try {
                switch (X) {
                  case e.AXIAL:
                  case e.RADIAL:
                    return new d(j, w, O, A, Y);
                  case e.FREE_FORM_MESH:
                  case e.LATTICE_FORM_MESH:
                  case e.COONS_PATCH_MESH:
                  case e.TENSOR_PATCH_MESH:
                    return new g(u, w, O, A, Y);
                  default:
                    throw new t.FormatError("Unsupported ShadingType: " + X);
                }
              } catch (B) {
                if (B instanceof h.MissingDataException)
                  throw B;
                return b.send("UnsupportedFeature", {
                  featureId: t.UNSUPPORTED_FEATURES.shadingPattern
                }), (0, t.warn)(B), new n();
              }
            }
          }
          o.Pattern = y;
          class c {
            static get SMALL_NUMBER() {
              return (0, t.shadow)(this, "SMALL_NUMBER", 1e-6);
            }
            constructor() {
              this.constructor === c && (0, t.unreachable)("Cannot initialize BaseShading.");
            }
            getIR() {
              (0, t.unreachable)("Abstract method `getIR` called.");
            }
          }
          class d extends c {
            constructor(u, w, O, b, A) {
              super(), this.coordsArr = u.getArray("Coords"), this.shadingType = u.get("ShadingType");
              const Y = v.ColorSpace.parse({
                cs: u.getRaw("CS") || u.getRaw("ColorSpace"),
                xref: w,
                resources: O,
                pdfFunctionFactory: b,
                localColorSpaceCache: A
              }), j = u.getArray("BBox");
              Array.isArray(j) && j.length === 4 ? this.bbox = t.Util.normalizeRect(j) : this.bbox = null;
              let X = 0, B = 1;
              if (u.has("Domain")) {
                const G = u.getArray("Domain");
                X = G[0], B = G[1];
              }
              let U = !1, k = !1;
              if (u.has("Extend")) {
                const G = u.getArray("Extend");
                U = G[0], k = G[1];
              }
              if (this.shadingType === e.RADIAL && (!U || !k)) {
                const [G, Z, $, z, V, L] = this.coordsArr, K = Math.hypot(G - z, Z - V);
                $ <= L + K && L <= $ + K && (0, t.warn)("Unsupported radial gradient.");
              }
              this.extendStart = U, this.extendEnd = k;
              const x = u.getRaw("Function"), f = b.createFromArray(x), D = 10, _ = (B - X) / D, S = this.colorStops = [];
              if (X >= B || _ <= 0) {
                (0, t.info)("Bad shading domain.");
                return;
              }
              const C = new Float32Array(Y.numComps), T = new Float32Array(1);
              let P;
              for (let G = 0; G <= D; G++) {
                T[0] = X + G * _, f(T, 0, C, 0), P = Y.getRgb(C, 0);
                const Z = t.Util.makeHexColor(P[0], P[1], P[2]);
                S.push([G / D, Z]);
              }
              let M = "transparent";
              u.has("Background") && (P = Y.getRgb(u.get("Background"), 0), M = t.Util.makeHexColor(P[0], P[1], P[2])), U || (S.unshift([0, M]), S[1][0] += c.SMALL_NUMBER), k || (S.at(-1)[0] -= c.SMALL_NUMBER, S.push([1, M])), this.colorStops = S;
            }
            getIR() {
              const u = this.coordsArr, w = this.shadingType;
              let O, b, A, Y, j;
              return w === e.AXIAL ? (b = [u[0], u[1]], A = [u[2], u[3]], Y = null, j = null, O = "axial") : w === e.RADIAL ? (b = [u[0], u[1]], A = [u[3], u[4]], Y = u[2], j = u[5], O = "radial") : (0, t.unreachable)(`getPattern type unknown: ${w}`), ["RadialAxial", O, this.bbox, this.colorStops, b, A, Y, j];
            }
          }
          class m {
            constructor(u, w) {
              this.stream = u, this.context = w, this.buffer = 0, this.bufferLength = 0;
              const O = w.numComps;
              this.tmpCompsBuf = new Float32Array(O);
              const b = w.colorSpace.numComps;
              this.tmpCsCompsBuf = w.colorFn ? new Float32Array(b) : this.tmpCompsBuf;
            }
            get hasData() {
              if (this.stream.end)
                return this.stream.pos < this.stream.end;
              if (this.bufferLength > 0)
                return !0;
              const u = this.stream.getByte();
              return u < 0 ? !1 : (this.buffer = u, this.bufferLength = 8, !0);
            }
            readBits(u) {
              let w = this.buffer, O = this.bufferLength;
              if (u === 32) {
                if (O === 0)
                  return (this.stream.getByte() << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte()) >>> 0;
                w = w << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte();
                const b = this.stream.getByte();
                return this.buffer = b & (1 << O) - 1, (w << 8 - O | (b & 255) >> O) >>> 0;
              }
              if (u === 8 && O === 0)
                return this.stream.getByte();
              for (; O < u; )
                w = w << 8 | this.stream.getByte(), O += 8;
              return O -= u, this.bufferLength = O, this.buffer = w & (1 << O) - 1, w >> O;
            }
            align() {
              this.buffer = 0, this.bufferLength = 0;
            }
            readFlag() {
              return this.readBits(this.context.bitsPerFlag);
            }
            readCoordinate() {
              const u = this.context.bitsPerCoordinate, w = this.readBits(u), O = this.readBits(u), b = this.context.decode, A = u < 32 ? 1 / ((1 << u) - 1) : 23283064365386963e-26;
              return [w * A * (b[1] - b[0]) + b[0], O * A * (b[3] - b[2]) + b[2]];
            }
            readComponents() {
              const u = this.context.numComps, w = this.context.bitsPerComponent, O = w < 32 ? 1 / ((1 << w) - 1) : 23283064365386963e-26, b = this.context.decode, A = this.tmpCompsBuf;
              for (let j = 0, X = 4; j < u; j++, X += 2) {
                const B = this.readBits(w);
                A[j] = B * O * (b[X + 1] - b[X]) + b[X];
              }
              const Y = this.tmpCsCompsBuf;
              return this.context.colorFn && this.context.colorFn(A, 0, Y, 0), this.context.colorSpace.getRgb(Y, 0);
            }
          }
          const p = function() {
            function u(O) {
              const b = [];
              for (let A = 0; A <= O; A++) {
                const Y = A / O, j = 1 - Y;
                b.push(new Float32Array([j * j * j, 3 * Y * j * j, 3 * Y * Y * j, Y * Y * Y]));
              }
              return b;
            }
            const w = [];
            return function(O) {
              return w[O] || (w[O] = u(O)), w[O];
            };
          }();
          class g extends c {
            static get MIN_SPLIT_PATCH_CHUNKS_AMOUNT() {
              return (0, t.shadow)(this, "MIN_SPLIT_PATCH_CHUNKS_AMOUNT", 3);
            }
            static get MAX_SPLIT_PATCH_CHUNKS_AMOUNT() {
              return (0, t.shadow)(this, "MAX_SPLIT_PATCH_CHUNKS_AMOUNT", 20);
            }
            static get TRIANGLE_DENSITY() {
              return (0, t.shadow)(this, "TRIANGLE_DENSITY", 20);
            }
            constructor(u, w, O, b, A) {
              if (super(), !(u instanceof a.BaseStream))
                throw new t.FormatError("Mesh data is not a stream");
              const Y = u.dict;
              this.shadingType = Y.get("ShadingType");
              const j = Y.getArray("BBox");
              Array.isArray(j) && j.length === 4 ? this.bbox = t.Util.normalizeRect(j) : this.bbox = null;
              const X = v.ColorSpace.parse({
                cs: Y.getRaw("CS") || Y.getRaw("ColorSpace"),
                xref: w,
                resources: O,
                pdfFunctionFactory: b,
                localColorSpaceCache: A
              });
              this.background = Y.has("Background") ? X.getRgb(Y.get("Background"), 0) : null;
              const B = Y.getRaw("Function"), U = B ? b.createFromArray(B) : null;
              this.coords = [], this.colors = [], this.figures = [];
              const k = {
                bitsPerCoordinate: Y.get("BitsPerCoordinate"),
                bitsPerComponent: Y.get("BitsPerComponent"),
                bitsPerFlag: Y.get("BitsPerFlag"),
                decode: Y.getArray("Decode"),
                colorFn: U,
                colorSpace: X,
                numComps: U ? 1 : X.numComps
              }, x = new m(u, k);
              let f = !1;
              switch (this.shadingType) {
                case e.FREE_FORM_MESH:
                  this._decodeType4Shading(x);
                  break;
                case e.LATTICE_FORM_MESH:
                  const D = Y.get("VerticesPerRow") | 0;
                  if (D < 2)
                    throw new t.FormatError("Invalid VerticesPerRow");
                  this._decodeType5Shading(x, D);
                  break;
                case e.COONS_PATCH_MESH:
                  this._decodeType6Shading(x), f = !0;
                  break;
                case e.TENSOR_PATCH_MESH:
                  this._decodeType7Shading(x), f = !0;
                  break;
                default:
                  (0, t.unreachable)("Unsupported mesh type.");
                  break;
              }
              if (f) {
                this._updateBounds();
                for (let D = 0, _ = this.figures.length; D < _; D++)
                  this._buildFigureFromPatch(D);
              }
              this._updateBounds(), this._packData();
            }
            _decodeType4Shading(u) {
              const w = this.coords, O = this.colors, b = [];
              let A = 0;
              for (; u.hasData; ) {
                const Y = u.readFlag(), j = u.readCoordinate(), X = u.readComponents();
                if (A === 0) {
                  if (!(0 <= Y && Y <= 2))
                    throw new t.FormatError("Unknown type4 flag");
                  switch (Y) {
                    case 0:
                      A = 3;
                      break;
                    case 1:
                      b.push(b.at(-2), b.at(-1)), A = 1;
                      break;
                    case 2:
                      b.push(b.at(-3), b.at(-1)), A = 1;
                      break;
                  }
                }
                b.push(w.length), w.push(j), O.push(X), A--, u.align();
              }
              this.figures.push({
                type: "triangles",
                coords: new Int32Array(b),
                colors: new Int32Array(b)
              });
            }
            _decodeType5Shading(u, w) {
              const O = this.coords, b = this.colors, A = [];
              for (; u.hasData; ) {
                const Y = u.readCoordinate(), j = u.readComponents();
                A.push(O.length), O.push(Y), b.push(j);
              }
              this.figures.push({
                type: "lattice",
                coords: new Int32Array(A),
                colors: new Int32Array(A),
                verticesPerRow: w
              });
            }
            _decodeType6Shading(u) {
              const w = this.coords, O = this.colors, b = new Int32Array(16), A = new Int32Array(4);
              for (; u.hasData; ) {
                const Y = u.readFlag();
                if (!(0 <= Y && Y <= 3))
                  throw new t.FormatError("Unknown type6 flag");
                const j = w.length;
                for (let f = 0, D = Y !== 0 ? 8 : 12; f < D; f++)
                  w.push(u.readCoordinate());
                const X = O.length;
                for (let f = 0, D = Y !== 0 ? 2 : 4; f < D; f++)
                  O.push(u.readComponents());
                let B, U, k, x;
                switch (Y) {
                  case 0:
                    b[12] = j + 3, b[13] = j + 4, b[14] = j + 5, b[15] = j + 6, b[8] = j + 2, b[11] = j + 7, b[4] = j + 1, b[7] = j + 8, b[0] = j, b[1] = j + 11, b[2] = j + 10, b[3] = j + 9, A[2] = X + 1, A[3] = X + 2, A[0] = X, A[1] = X + 3;
                    break;
                  case 1:
                    B = b[12], U = b[13], k = b[14], x = b[15], b[12] = x, b[13] = j + 0, b[14] = j + 1, b[15] = j + 2, b[8] = k, b[11] = j + 3, b[4] = U, b[7] = j + 4, b[0] = B, b[1] = j + 7, b[2] = j + 6, b[3] = j + 5, B = A[2], U = A[3], A[2] = U, A[3] = X, A[0] = B, A[1] = X + 1;
                    break;
                  case 2:
                    B = b[15], U = b[11], b[12] = b[3], b[13] = j + 0, b[14] = j + 1, b[15] = j + 2, b[8] = b[7], b[11] = j + 3, b[4] = U, b[7] = j + 4, b[0] = B, b[1] = j + 7, b[2] = j + 6, b[3] = j + 5, B = A[3], A[2] = A[1], A[3] = X, A[0] = B, A[1] = X + 1;
                    break;
                  case 3:
                    b[12] = b[0], b[13] = j + 0, b[14] = j + 1, b[15] = j + 2, b[8] = b[1], b[11] = j + 3, b[4] = b[2], b[7] = j + 4, b[0] = b[3], b[1] = j + 7, b[2] = j + 6, b[3] = j + 5, A[2] = A[0], A[3] = X, A[0] = A[1], A[1] = X + 1;
                    break;
                }
                b[5] = w.length, w.push([(-4 * w[b[0]][0] - w[b[15]][0] + 6 * (w[b[4]][0] + w[b[1]][0]) - 2 * (w[b[12]][0] + w[b[3]][0]) + 3 * (w[b[13]][0] + w[b[7]][0])) / 9, (-4 * w[b[0]][1] - w[b[15]][1] + 6 * (w[b[4]][1] + w[b[1]][1]) - 2 * (w[b[12]][1] + w[b[3]][1]) + 3 * (w[b[13]][1] + w[b[7]][1])) / 9]), b[6] = w.length, w.push([(-4 * w[b[3]][0] - w[b[12]][0] + 6 * (w[b[2]][0] + w[b[7]][0]) - 2 * (w[b[0]][0] + w[b[15]][0]) + 3 * (w[b[4]][0] + w[b[14]][0])) / 9, (-4 * w[b[3]][1] - w[b[12]][1] + 6 * (w[b[2]][1] + w[b[7]][1]) - 2 * (w[b[0]][1] + w[b[15]][1]) + 3 * (w[b[4]][1] + w[b[14]][1])) / 9]), b[9] = w.length, w.push([(-4 * w[b[12]][0] - w[b[3]][0] + 6 * (w[b[8]][0] + w[b[13]][0]) - 2 * (w[b[0]][0] + w[b[15]][0]) + 3 * (w[b[11]][0] + w[b[1]][0])) / 9, (-4 * w[b[12]][1] - w[b[3]][1] + 6 * (w[b[8]][1] + w[b[13]][1]) - 2 * (w[b[0]][1] + w[b[15]][1]) + 3 * (w[b[11]][1] + w[b[1]][1])) / 9]), b[10] = w.length, w.push([(-4 * w[b[15]][0] - w[b[0]][0] + 6 * (w[b[11]][0] + w[b[14]][0]) - 2 * (w[b[12]][0] + w[b[3]][0]) + 3 * (w[b[2]][0] + w[b[8]][0])) / 9, (-4 * w[b[15]][1] - w[b[0]][1] + 6 * (w[b[11]][1] + w[b[14]][1]) - 2 * (w[b[12]][1] + w[b[3]][1]) + 3 * (w[b[2]][1] + w[b[8]][1])) / 9]), this.figures.push({
                  type: "patch",
                  coords: new Int32Array(b),
                  colors: new Int32Array(A)
                });
              }
            }
            _decodeType7Shading(u) {
              const w = this.coords, O = this.colors, b = new Int32Array(16), A = new Int32Array(4);
              for (; u.hasData; ) {
                const Y = u.readFlag();
                if (!(0 <= Y && Y <= 3))
                  throw new t.FormatError("Unknown type7 flag");
                const j = w.length;
                for (let f = 0, D = Y !== 0 ? 12 : 16; f < D; f++)
                  w.push(u.readCoordinate());
                const X = O.length;
                for (let f = 0, D = Y !== 0 ? 2 : 4; f < D; f++)
                  O.push(u.readComponents());
                let B, U, k, x;
                switch (Y) {
                  case 0:
                    b[12] = j + 3, b[13] = j + 4, b[14] = j + 5, b[15] = j + 6, b[8] = j + 2, b[9] = j + 13, b[10] = j + 14, b[11] = j + 7, b[4] = j + 1, b[5] = j + 12, b[6] = j + 15, b[7] = j + 8, b[0] = j, b[1] = j + 11, b[2] = j + 10, b[3] = j + 9, A[2] = X + 1, A[3] = X + 2, A[0] = X, A[1] = X + 3;
                    break;
                  case 1:
                    B = b[12], U = b[13], k = b[14], x = b[15], b[12] = x, b[13] = j + 0, b[14] = j + 1, b[15] = j + 2, b[8] = k, b[9] = j + 9, b[10] = j + 10, b[11] = j + 3, b[4] = U, b[5] = j + 8, b[6] = j + 11, b[7] = j + 4, b[0] = B, b[1] = j + 7, b[2] = j + 6, b[3] = j + 5, B = A[2], U = A[3], A[2] = U, A[3] = X, A[0] = B, A[1] = X + 1;
                    break;
                  case 2:
                    B = b[15], U = b[11], b[12] = b[3], b[13] = j + 0, b[14] = j + 1, b[15] = j + 2, b[8] = b[7], b[9] = j + 9, b[10] = j + 10, b[11] = j + 3, b[4] = U, b[5] = j + 8, b[6] = j + 11, b[7] = j + 4, b[0] = B, b[1] = j + 7, b[2] = j + 6, b[3] = j + 5, B = A[3], A[2] = A[1], A[3] = X, A[0] = B, A[1] = X + 1;
                    break;
                  case 3:
                    b[12] = b[0], b[13] = j + 0, b[14] = j + 1, b[15] = j + 2, b[8] = b[1], b[9] = j + 9, b[10] = j + 10, b[11] = j + 3, b[4] = b[2], b[5] = j + 8, b[6] = j + 11, b[7] = j + 4, b[0] = b[3], b[1] = j + 7, b[2] = j + 6, b[3] = j + 5, A[2] = A[0], A[3] = X, A[0] = A[1], A[1] = X + 1;
                    break;
                }
                this.figures.push({
                  type: "patch",
                  coords: new Int32Array(b),
                  colors: new Int32Array(A)
                });
              }
            }
            _buildFigureFromPatch(u) {
              const w = this.figures[u];
              (0, t.assert)(w.type === "patch", "Unexpected patch mesh figure");
              const O = this.coords, b = this.colors, A = w.coords, Y = w.colors, j = Math.min(O[A[0]][0], O[A[3]][0], O[A[12]][0], O[A[15]][0]), X = Math.min(O[A[0]][1], O[A[3]][1], O[A[12]][1], O[A[15]][1]), B = Math.max(O[A[0]][0], O[A[3]][0], O[A[12]][0], O[A[15]][0]), U = Math.max(O[A[0]][1], O[A[3]][1], O[A[12]][1], O[A[15]][1]);
              let k = Math.ceil((B - j) * g.TRIANGLE_DENSITY / (this.bounds[2] - this.bounds[0]));
              k = Math.max(g.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(g.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, k));
              let x = Math.ceil((U - X) * g.TRIANGLE_DENSITY / (this.bounds[3] - this.bounds[1]));
              x = Math.max(g.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(g.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, x));
              const f = k + 1, D = new Int32Array((x + 1) * f), _ = new Int32Array((x + 1) * f);
              let S = 0;
              const C = new Uint8Array(3), T = new Uint8Array(3), P = b[Y[0]], M = b[Y[1]], G = b[Y[2]], Z = b[Y[3]], $ = p(x), z = p(k);
              for (let V = 0; V <= x; V++) {
                C[0] = (P[0] * (x - V) + G[0] * V) / x | 0, C[1] = (P[1] * (x - V) + G[1] * V) / x | 0, C[2] = (P[2] * (x - V) + G[2] * V) / x | 0, T[0] = (M[0] * (x - V) + Z[0] * V) / x | 0, T[1] = (M[1] * (x - V) + Z[1] * V) / x | 0, T[2] = (M[2] * (x - V) + Z[2] * V) / x | 0;
                for (let L = 0; L <= k; L++, S++) {
                  if ((V === 0 || V === x) && (L === 0 || L === k))
                    continue;
                  let K = 0, ne = 0, se = 0;
                  for (let N = 0; N <= 3; N++)
                    for (let Q = 0; Q <= 3; Q++, se++) {
                      const E = $[V][N] * z[L][Q];
                      K += O[A[se]][0] * E, ne += O[A[se]][1] * E;
                    }
                  D[S] = O.length, O.push([K, ne]), _[S] = b.length;
                  const q = new Uint8Array(3);
                  q[0] = (C[0] * (k - L) + T[0] * L) / k | 0, q[1] = (C[1] * (k - L) + T[1] * L) / k | 0, q[2] = (C[2] * (k - L) + T[2] * L) / k | 0, b.push(q);
                }
              }
              D[0] = A[0], _[0] = Y[0], D[k] = A[3], _[k] = Y[1], D[f * x] = A[12], _[f * x] = Y[2], D[f * x + k] = A[15], _[f * x + k] = Y[3], this.figures[u] = {
                type: "lattice",
                coords: D,
                colors: _,
                verticesPerRow: f
              };
            }
            _updateBounds() {
              let u = this.coords[0][0], w = this.coords[0][1], O = u, b = w;
              for (let A = 1, Y = this.coords.length; A < Y; A++) {
                const j = this.coords[A][0], X = this.coords[A][1];
                u = u > j ? j : u, w = w > X ? X : w, O = O < j ? j : O, b = b < X ? X : b;
              }
              this.bounds = [u, w, O, b];
            }
            _packData() {
              let u, w, O, b;
              const A = this.coords, Y = new Float32Array(A.length * 2);
              for (u = 0, O = 0, w = A.length; u < w; u++) {
                const U = A[u];
                Y[O++] = U[0], Y[O++] = U[1];
              }
              this.coords = Y;
              const j = this.colors, X = new Uint8Array(j.length * 3);
              for (u = 0, O = 0, w = j.length; u < w; u++) {
                const U = j[u];
                X[O++] = U[0], X[O++] = U[1], X[O++] = U[2];
              }
              this.colors = X;
              const B = this.figures;
              for (u = 0, w = B.length; u < w; u++) {
                const U = B[u], k = U.coords, x = U.colors;
                for (O = 0, b = k.length; O < b; O++)
                  k[O] *= 2, x[O] *= 3;
              }
            }
            getIR() {
              return ["Mesh", this.shadingType, this.coords, this.colors, this.figures, this.bounds, this.bbox, this.background];
            }
          }
          class n extends c {
            getIR() {
              return ["Dummy"];
            }
          }
          function i(l, u, w) {
            const O = u.getArray("Matrix"), b = t.Util.normalizeRect(u.getArray("BBox")), A = u.get("XStep"), Y = u.get("YStep"), j = u.get("PaintType"), X = u.get("TilingType");
            if (b[2] - b[0] === 0 || b[3] - b[1] === 0)
              throw new t.FormatError(`Invalid getTilingPatternIR /BBox array: [${b}].`);
            return ["TilingPattern", w, l, O, b, A, Y, j, X];
          }
        },
        /* 51 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.getXfaFontDict = n, o.getXfaFontName = p;
          var t = F(52), a = F(5), v = F(53), h = F(54), e = F(55), y = F(56), c = F(6), d = F(38);
          const m = (0, c.getLookupTableFactory)(function(i) {
            i["MyriadPro-Regular"] = i["PdfJS-Fallback-Regular"] = {
              name: "LiberationSans-Regular",
              factors: e.MyriadProRegularFactors,
              baseWidths: h.LiberationSansRegularWidths,
              baseMapping: h.LiberationSansRegularMapping,
              metrics: e.MyriadProRegularMetrics
            }, i["MyriadPro-Bold"] = i["PdfJS-Fallback-Bold"] = {
              name: "LiberationSans-Bold",
              factors: e.MyriadProBoldFactors,
              baseWidths: h.LiberationSansBoldWidths,
              baseMapping: h.LiberationSansBoldMapping,
              metrics: e.MyriadProBoldMetrics
            }, i["MyriadPro-It"] = i["MyriadPro-Italic"] = i["PdfJS-Fallback-Italic"] = {
              name: "LiberationSans-Italic",
              factors: e.MyriadProItalicFactors,
              baseWidths: h.LiberationSansItalicWidths,
              baseMapping: h.LiberationSansItalicMapping,
              metrics: e.MyriadProItalicMetrics
            }, i["MyriadPro-BoldIt"] = i["MyriadPro-BoldItalic"] = i["PdfJS-Fallback-BoldItalic"] = {
              name: "LiberationSans-BoldItalic",
              factors: e.MyriadProBoldItalicFactors,
              baseWidths: h.LiberationSansBoldItalicWidths,
              baseMapping: h.LiberationSansBoldItalicMapping,
              metrics: e.MyriadProBoldItalicMetrics
            }, i.ArialMT = i.Arial = i["Arial-Regular"] = {
              name: "LiberationSans-Regular",
              baseWidths: h.LiberationSansRegularWidths,
              baseMapping: h.LiberationSansRegularMapping
            }, i["Arial-BoldMT"] = i["Arial-Bold"] = {
              name: "LiberationSans-Bold",
              baseWidths: h.LiberationSansBoldWidths,
              baseMapping: h.LiberationSansBoldMapping
            }, i["Arial-ItalicMT"] = i["Arial-Italic"] = {
              name: "LiberationSans-Italic",
              baseWidths: h.LiberationSansItalicWidths,
              baseMapping: h.LiberationSansItalicMapping
            }, i["Arial-BoldItalicMT"] = i["Arial-BoldItalic"] = {
              name: "LiberationSans-BoldItalic",
              baseWidths: h.LiberationSansBoldItalicWidths,
              baseMapping: h.LiberationSansBoldItalicMapping
            }, i["Calibri-Regular"] = {
              name: "LiberationSans-Regular",
              factors: t.CalibriRegularFactors,
              baseWidths: h.LiberationSansRegularWidths,
              baseMapping: h.LiberationSansRegularMapping,
              metrics: t.CalibriRegularMetrics
            }, i["Calibri-Bold"] = {
              name: "LiberationSans-Bold",
              factors: t.CalibriBoldFactors,
              baseWidths: h.LiberationSansBoldWidths,
              baseMapping: h.LiberationSansBoldMapping,
              metrics: t.CalibriBoldMetrics
            }, i["Calibri-Italic"] = {
              name: "LiberationSans-Italic",
              factors: t.CalibriItalicFactors,
              baseWidths: h.LiberationSansItalicWidths,
              baseMapping: h.LiberationSansItalicMapping,
              metrics: t.CalibriItalicMetrics
            }, i["Calibri-BoldItalic"] = {
              name: "LiberationSans-BoldItalic",
              factors: t.CalibriBoldItalicFactors,
              baseWidths: h.LiberationSansBoldItalicWidths,
              baseMapping: h.LiberationSansBoldItalicMapping,
              metrics: t.CalibriBoldItalicMetrics
            }, i["Segoeui-Regular"] = {
              name: "LiberationSans-Regular",
              factors: y.SegoeuiRegularFactors,
              baseWidths: h.LiberationSansRegularWidths,
              baseMapping: h.LiberationSansRegularMapping,
              metrics: y.SegoeuiRegularMetrics
            }, i["Segoeui-Bold"] = {
              name: "LiberationSans-Bold",
              factors: y.SegoeuiBoldFactors,
              baseWidths: h.LiberationSansBoldWidths,
              baseMapping: h.LiberationSansBoldMapping,
              metrics: y.SegoeuiBoldMetrics
            }, i["Segoeui-Italic"] = {
              name: "LiberationSans-Italic",
              factors: y.SegoeuiItalicFactors,
              baseWidths: h.LiberationSansItalicWidths,
              baseMapping: h.LiberationSansItalicMapping,
              metrics: y.SegoeuiItalicMetrics
            }, i["Segoeui-BoldItalic"] = {
              name: "LiberationSans-BoldItalic",
              factors: y.SegoeuiBoldItalicFactors,
              baseWidths: h.LiberationSansBoldItalicWidths,
              baseMapping: h.LiberationSansBoldItalicMapping,
              metrics: y.SegoeuiBoldItalicMetrics
            }, i["Helvetica-Regular"] = i.Helvetica = {
              name: "LiberationSans-Regular",
              factors: v.HelveticaRegularFactors,
              baseWidths: h.LiberationSansRegularWidths,
              baseMapping: h.LiberationSansRegularMapping,
              metrics: v.HelveticaRegularMetrics
            }, i["Helvetica-Bold"] = {
              name: "LiberationSans-Bold",
              factors: v.HelveticaBoldFactors,
              baseWidths: h.LiberationSansBoldWidths,
              baseMapping: h.LiberationSansBoldMapping,
              metrics: v.HelveticaBoldMetrics
            }, i["Helvetica-Italic"] = {
              name: "LiberationSans-Italic",
              factors: v.HelveticaItalicFactors,
              baseWidths: h.LiberationSansItalicWidths,
              baseMapping: h.LiberationSansItalicMapping,
              metrics: v.HelveticaItalicMetrics
            }, i["Helvetica-BoldItalic"] = {
              name: "LiberationSans-BoldItalic",
              factors: v.HelveticaBoldItalicFactors,
              baseWidths: h.LiberationSansBoldItalicWidths,
              baseMapping: h.LiberationSansBoldItalicMapping,
              metrics: v.HelveticaBoldItalicMetrics
            };
          });
          function p(i) {
            const l = (0, d.normalizeFontName)(i);
            return m()[l];
          }
          function g(i) {
            const l = p(i);
            if (!l)
              return null;
            const {
              baseWidths: u,
              baseMapping: w,
              factors: O
            } = l;
            let b;
            O ? b = u.map((X, B) => X * O[B]) : b = u;
            let A = -2, Y;
            const j = [];
            for (const [X, B] of w.map((U, k) => [U, k]).sort(([U], [k]) => U - k))
              X !== -1 && (X === A + 1 ? (Y.push(b[B]), A += 1) : (A = X, Y = [b[B]], j.push(X, Y)));
            return j;
          }
          function n(i) {
            const l = g(i), u = new a.Dict(null);
            u.set("BaseFont", a.Name.get(i)), u.set("Type", a.Name.get("Font")), u.set("Subtype", a.Name.get("CIDFontType2")), u.set("Encoding", a.Name.get("Identity-H")), u.set("CIDToGIDMap", a.Name.get("Identity")), u.set("W", l), u.set("FirstChar", l[0]), u.set("LastChar", l.at(-2) + l.at(-1).length - 1);
            const w = new a.Dict(null);
            u.set("FontDescriptor", w);
            const O = new a.Dict(null);
            return O.set("Ordering", "Identity"), O.set("Registry", "Adobe"), O.set("Supplement", 0), u.set("CIDSystemInfo", O), u;
          }
        },
        /* 52 */
        /***/
        (J, o) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.CalibriRegularMetrics = o.CalibriRegularFactors = o.CalibriItalicMetrics = o.CalibriItalicFactors = o.CalibriBoldMetrics = o.CalibriBoldItalicMetrics = o.CalibriBoldItalicFactors = o.CalibriBoldFactors = void 0;
          const F = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.54657, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.73293, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.9121, 0.86943, 0.79795, 0.88198, 0.77958, 0.70864, 0.81055, 0.90399, 0.88653, 0.96017, 0.82577, 0.77892, 0.78257, 0.97507, 1.54657, 0.97507, 0.85284, 0.89552, 0.90176, 0.88762, 0.8785, 0.75241, 0.8785, 0.90518, 0.95015, 0.77618, 0.8785, 0.88401, 0.91916, 0.86304, 0.88401, 0.91488, 0.8785, 0.8801, 0.8785, 0.8785, 0.91343, 0.7173, 1.04106, 0.8785, 0.85075, 0.95794, 0.82616, 0.85162, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.12401, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.73293, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.9121, 0.86943, 0.86943, 0.86943, 0.86943, 0.86943, 0.85284, 0.87508, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.8715, 0.75241, 0.90518, 0.90518, 0.90518, 0.90518, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.8785, 0.8801, 0.8801, 0.8801, 0.8801, 0.8801, 0.90747, 0.89049, 0.8785, 0.8785, 0.8785, 0.8785, 0.85162, 0.8785, 0.85162, 0.83908, 0.88762, 0.83908, 0.88762, 0.83908, 0.88762, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.87289, 0.83016, 0.88506, 0.93125, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.81921, 0.77618, 0.81921, 0.77618, 0.81921, 0.77618, 1, 1, 0.87356, 0.8785, 0.91075, 0.89608, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76229, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.79468, 0.91926, 0.88175, 0.70823, 0.94903, 0.9121, 0.8785, 1, 1, 0.9121, 0.8785, 0.87802, 0.88656, 0.8785, 0.86943, 0.8801, 0.86943, 0.8801, 0.86943, 0.8801, 0.87402, 0.89291, 0.77958, 0.91343, 1, 1, 0.77958, 0.91343, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.96017, 0.95794, 0.77892, 0.85162, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.88762, 0.77539, 0.8715, 0.87508, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70674, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.06303, 0.83908, 0.80352, 0.57184, 0.6965, 0.56289, 0.82001, 0.56029, 0.81235, 1.02988, 0.83908, 0.7762, 0.68156, 0.80367, 0.73133, 0.78257, 0.87356, 0.86943, 0.95958, 0.75727, 0.89019, 1.04924, 0.9121, 0.7648, 0.86943, 0.87356, 0.79795, 0.78275, 0.81055, 0.77892, 0.9762, 0.82577, 0.99819, 0.84896, 0.95958, 0.77892, 0.96108, 1.01407, 0.89049, 1.02988, 0.94211, 0.96108, 0.8936, 0.84021, 0.87842, 0.96399, 0.79109, 0.89049, 1.00813, 1.02988, 0.86077, 0.87445, 0.92099, 0.84723, 0.86513, 0.8801, 0.75638, 0.85714, 0.78216, 0.79586, 0.87965, 0.94211, 0.97747, 0.78287, 0.97926, 0.84971, 1.02988, 0.94211, 0.8801, 0.94211, 0.84971, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90264, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90518, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90548, 1, 1, 1, 1, 1, 1, 0.96017, 0.95794, 0.96017, 0.95794, 0.96017, 0.95794, 0.77892, 0.85162, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.92794, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71143, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.93835, 0.83406, 0.91133, 0.84107, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90527, 1.81055, 0.90527, 1.81055, 1.31006, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          o.CalibriBoldFactors = F;
          const t = {
            lineHeight: 1.2207,
            lineGap: 0.2207
          };
          o.CalibriBoldMetrics = t;
          const a = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.56239, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.71805, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.90872, 0.85938, 0.79795, 0.87068, 0.77958, 0.69766, 0.81055, 0.90399, 0.88653, 0.96068, 0.82577, 0.77892, 0.78257, 0.97507, 1.529, 0.97507, 0.85284, 0.89552, 0.90176, 0.94908, 0.86411, 0.74012, 0.86411, 0.88323, 0.95015, 0.86411, 0.86331, 0.88401, 0.91916, 0.86304, 0.88401, 0.9039, 0.86331, 0.86331, 0.86411, 0.86411, 0.90464, 0.70852, 1.04106, 0.86331, 0.84372, 0.95794, 0.82616, 0.84548, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.19129, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.71805, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.90872, 0.85938, 0.85938, 0.85938, 0.85938, 0.85938, 0.85284, 0.87068, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.85887, 0.74012, 0.88323, 0.88323, 0.88323, 0.88323, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.90747, 0.89049, 0.86331, 0.86331, 0.86331, 0.86331, 0.84548, 0.86411, 0.84548, 0.83908, 0.94908, 0.83908, 0.94908, 0.83908, 0.94908, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.87289, 0.79538, 0.88506, 0.92726, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.81921, 0.86411, 0.81921, 0.86411, 0.81921, 0.86411, 1, 1, 0.87356, 0.86331, 0.91075, 0.8777, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76467, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.77312, 0.91926, 0.88175, 0.70823, 0.94903, 0.90872, 0.86331, 1, 1, 0.90872, 0.86331, 0.86906, 0.88116, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.87402, 0.86549, 0.77958, 0.90464, 1, 1, 0.77958, 0.90464, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.96068, 0.95794, 0.77892, 0.84548, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.94908, 0.77539, 0.85887, 0.87068, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70088, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.48387, 0.83908, 0.80352, 0.57118, 0.6965, 0.56347, 0.79179, 0.55853, 0.80346, 1.02988, 0.83908, 0.7762, 0.67174, 0.86036, 0.73133, 0.78257, 0.87356, 0.86441, 0.95958, 0.75727, 0.89019, 1.04924, 0.90872, 0.74889, 0.85938, 0.87891, 0.79795, 0.7957, 0.81055, 0.77892, 0.97447, 0.82577, 0.97466, 0.87179, 0.95958, 0.77892, 0.94252, 0.95612, 0.8753, 1.02988, 0.92733, 0.94252, 0.87411, 0.84021, 0.8728, 0.95612, 0.74081, 0.8753, 1.02189, 1.02988, 0.84814, 0.87445, 0.91822, 0.84723, 0.85668, 0.86331, 0.81344, 0.87581, 0.76422, 0.82046, 0.96057, 0.92733, 0.99375, 0.78022, 0.95452, 0.86015, 1.02988, 0.92733, 0.86331, 0.92733, 0.86015, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90631, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88323, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85174, 1, 1, 1, 1, 1, 1, 0.96068, 0.95794, 0.96068, 0.95794, 0.96068, 0.95794, 0.77892, 0.84548, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.89807, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71094, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.92972, 0.83406, 0.91133, 0.83326, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90616, 1.81055, 0.90527, 1.81055, 1.3107, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          o.CalibriBoldItalicFactors = a;
          const v = {
            lineHeight: 1.2207,
            lineGap: 0.2207
          };
          o.CalibriBoldItalicMetrics = v;
          const h = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39543, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.72346, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89249, 0.84118, 0.77452, 0.85374, 0.75186, 0.67789, 0.79776, 0.88844, 0.85066, 0.94309, 0.77818, 0.7306, 0.76659, 1.10369, 1.38313, 1.10369, 1.06139, 0.89552, 0.8739, 0.9245, 0.9245, 0.83203, 0.9245, 0.85865, 1.09842, 0.9245, 0.9245, 1.03297, 1.07692, 0.90918, 1.03297, 0.94959, 0.9245, 0.92274, 0.9245, 0.9245, 1.02933, 0.77832, 1.20562, 0.9245, 0.8916, 0.98986, 0.86621, 0.89453, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.16359, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.72346, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89249, 0.84118, 0.84118, 0.84118, 0.84118, 0.84118, 0.85284, 0.84557, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.84843, 0.83203, 0.85865, 0.85865, 0.85865, 0.85865, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.9245, 0.92274, 0.92274, 0.92274, 0.92274, 0.92274, 0.90747, 0.86651, 0.9245, 0.9245, 0.9245, 0.9245, 0.89453, 0.9245, 0.89453, 0.8675, 0.9245, 0.8675, 0.9245, 0.8675, 0.9245, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.85193, 0.8875, 0.86477, 0.99034, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.81105, 0.9245, 0.81105, 0.9245, 0.81105, 0.9245, 1, 1, 0.86275, 0.9245, 0.90872, 0.93591, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77896, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.9375, 0.98156, 0.93407, 0.77261, 1.11429, 0.89249, 0.9245, 1, 1, 0.89249, 0.9245, 0.92534, 0.86698, 0.9245, 0.84118, 0.92274, 0.84118, 0.92274, 0.84118, 0.92274, 0.8667, 0.86291, 0.75186, 1.02933, 1, 1, 0.75186, 1.02933, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 1, 1, 0.79776, 0.97655, 0.79776, 1.23023, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.94309, 0.98986, 0.7306, 0.89453, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.9245, 0.76318, 0.84843, 0.84557, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67009, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.8675, 0.90861, 0.6192, 0.7363, 0.64824, 0.82411, 0.56321, 0.85696, 1.23516, 0.8675, 0.81552, 0.7286, 0.84134, 0.73206, 0.76659, 0.86275, 0.84369, 0.90685, 0.77892, 0.85871, 1.02638, 0.89249, 0.75828, 0.84118, 0.85984, 0.77452, 0.76466, 0.79776, 0.7306, 0.90782, 0.77818, 0.903, 0.87291, 0.90685, 0.7306, 0.99058, 1.03667, 0.94635, 1.23516, 0.9849, 0.99058, 0.92393, 0.8916, 0.942, 1.03667, 0.75026, 0.94635, 1.0297, 1.23516, 0.90918, 0.94048, 0.98217, 0.89746, 0.84153, 0.92274, 0.82507, 0.88832, 0.84438, 0.88178, 1.03525, 0.9849, 1.00225, 0.78086, 0.97248, 0.89404, 1.23516, 0.9849, 0.92274, 0.9849, 0.89404, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89693, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85865, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90933, 1, 1, 1, 1, 1, 1, 0.94309, 0.98986, 0.94309, 0.98986, 0.94309, 0.98986, 0.7306, 0.89453, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.68994, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.97858, 0.82616, 0.91133, 0.83437, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90572, 1.81055, 0.90749, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85284, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          o.CalibriItalicFactors = h;
          const e = {
            lineHeight: 1.2207,
            lineGap: 0.2207
          };
          o.CalibriItalicMetrics = e;
          const y = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39016, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.73834, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89385, 0.85122, 0.77452, 0.86503, 0.75186, 0.68887, 0.79776, 0.88844, 0.85066, 0.94258, 0.77818, 0.7306, 0.76659, 1.10369, 1.39016, 1.10369, 1.06139, 0.89552, 0.8739, 0.86128, 0.94469, 0.8457, 0.94469, 0.89464, 1.09842, 0.84636, 0.94469, 1.03297, 1.07692, 0.90918, 1.03297, 0.95897, 0.94469, 0.9482, 0.94469, 0.94469, 1.04692, 0.78223, 1.20562, 0.94469, 0.90332, 0.98986, 0.86621, 0.90527, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.08707, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.73834, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89385, 0.85122, 0.85122, 0.85122, 0.85122, 0.85122, 0.85284, 0.85311, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.8693, 0.8457, 0.89464, 0.89464, 0.89464, 0.89464, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.94469, 0.9482, 0.9482, 0.9482, 0.9482, 0.9482, 0.90747, 0.86651, 0.94469, 0.94469, 0.94469, 0.94469, 0.90527, 0.94469, 0.90527, 0.8675, 0.86128, 0.8675, 0.86128, 0.8675, 0.86128, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.85193, 0.92454, 0.86477, 0.9921, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.81105, 0.84636, 0.81105, 0.84636, 0.81105, 0.84636, 1, 1, 0.86275, 0.94469, 0.90872, 0.95786, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77741, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.90452, 0.98156, 1.11842, 0.77261, 1.11429, 0.89385, 0.94469, 1, 1, 0.89385, 0.94469, 0.95877, 0.86901, 0.94469, 0.85122, 0.9482, 0.85122, 0.9482, 0.85122, 0.9482, 0.8667, 0.90016, 0.75186, 1.04692, 1, 1, 0.75186, 1.04692, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 1, 1, 0.79776, 0.92188, 0.79776, 1.23023, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.94258, 0.98986, 0.7306, 0.90527, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.86128, 0.76318, 0.8693, 0.85311, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67742, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.86686, 0.90861, 0.62267, 0.74359, 0.65649, 0.85498, 0.56963, 0.88254, 1.23516, 0.8675, 0.81552, 0.75443, 0.84503, 0.73206, 0.76659, 0.86275, 0.85122, 0.90685, 0.77892, 0.85746, 1.02638, 0.89385, 0.75657, 0.85122, 0.86275, 0.77452, 0.74171, 0.79776, 0.7306, 0.95165, 0.77818, 0.89772, 0.88831, 0.90685, 0.7306, 0.98142, 1.02191, 0.96576, 1.23516, 0.99018, 0.98142, 0.9236, 0.89258, 0.94035, 1.02191, 0.78848, 0.96576, 0.9561, 1.23516, 0.90918, 0.92578, 0.95424, 0.89746, 0.83969, 0.9482, 0.80113, 0.89442, 0.85208, 0.86155, 0.98022, 0.99018, 1.00452, 0.81209, 0.99247, 0.89181, 1.23516, 0.99018, 0.9482, 0.99018, 0.89181, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88844, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89464, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96766, 1, 1, 1, 1, 1, 1, 0.94258, 0.98986, 0.94258, 0.98986, 0.94258, 0.98986, 0.7306, 0.90527, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.69043, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.99331, 0.82616, 0.91133, 0.84286, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90527, 1.81055, 0.90527, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1.07185, 0.99413, 0.96334, 1.08065, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          o.CalibriRegularFactors = y;
          const c = {
            lineHeight: 1.2207,
            lineGap: 0.2207
          };
          o.CalibriRegularMetrics = c;
        },
        /* 53 */
        /***/
        (J, o) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.HelveticaRegularMetrics = o.HelveticaRegularFactors = o.HelveticaItalicMetrics = o.HelveticaItalicFactors = o.HelveticaBoldMetrics = o.HelveticaBoldItalicMetrics = o.HelveticaBoldItalicFactors = o.HelveticaBoldFactors = void 0;
          const F = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.03374, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.00042, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.03828, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00034, 0.99977, 1, 0.99997, 1.00026, 1.00078, 1.00036, 0.99973, 1.00013, 1.0006, 0.99977, 0.99977, 0.99988, 0.85148, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 1.00069, 1.00022, 0.99977, 1.00001, 0.99984, 1.00026, 1.00001, 1.00024, 1.00001, 0.9999, 1, 1.0006, 1.00001, 1.00041, 0.99962, 1.00026, 1.0006, 0.99995, 1.00041, 0.99942, 0.99973, 0.99927, 1.00082, 0.99902, 1.00026, 1.00087, 1.0006, 1.00069, 0.99973, 0.99867, 0.99973, 0.9993, 1.00026, 1.00049, 1.00056, 1, 0.99988, 0.99935, 0.99995, 0.99954, 1.00055, 0.99945, 1.00032, 1.0006, 0.99995, 1.00026, 0.99995, 1.00032, 1.00001, 1.00008, 0.99971, 1.00019, 0.9994, 1.00001, 1.0006, 1.00044, 0.99973, 1.00023, 1.00047, 1, 0.99942, 0.99561, 0.99989, 1.00035, 0.99977, 1.00035, 0.99977, 1.00019, 0.99944, 1.00001, 1.00021, 0.99926, 1.00035, 1.00035, 0.99942, 1.00048, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.99989, 1.00057, 1.00001, 0.99936, 1.00052, 1.00012, 0.99996, 1.00043, 1, 1.00035, 0.9994, 0.99976, 1.00035, 0.99973, 1.00052, 1.00041, 1.00119, 1.00037, 0.99973, 1.00002, 0.99986, 1.00041, 1.00041, 0.99902, 0.9996, 1.00034, 0.99999, 1.00026, 0.99999, 1.00026, 0.99973, 1.00052, 0.99973, 1, 0.99973, 1.00041, 1.00075, 0.9994, 1.0003, 0.99999, 1, 1.00041, 0.99955, 1, 0.99915, 0.99973, 0.99973, 1.00026, 1.00119, 0.99955, 0.99973, 1.0006, 0.99911, 1.0006, 1.00026, 0.99972, 1.00026, 0.99902, 1.00041, 0.99973, 0.99999, 1, 1, 1.00038, 1.0005, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 1.00047, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          o.HelveticaBoldFactors = F;
          const t = {
            lineHeight: 1.2,
            lineGap: 0.2
          };
          o.HelveticaBoldMetrics = t;
          const a = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.0044, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99971, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.01011, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99977, 1, 1, 1.00026, 0.99969, 0.99972, 0.99981, 0.9998, 1.0006, 0.99977, 0.99977, 1.00022, 0.91155, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 0.99966, 1.00022, 1.00032, 1.00001, 0.99944, 1.00026, 1.00001, 0.99968, 1.00001, 1.00047, 1, 1.0006, 1.00001, 0.99981, 1.00101, 1.00026, 1.0006, 0.99948, 0.99981, 1.00064, 0.99973, 0.99942, 1.00101, 1.00061, 1.00026, 1.00069, 1.0006, 1.00014, 0.99973, 1.01322, 0.99973, 1.00065, 1.00026, 1.00012, 0.99923, 1, 1.00064, 1.00076, 0.99948, 1.00055, 1.00063, 1.00007, 0.99943, 1.0006, 0.99948, 1.00026, 0.99948, 0.99943, 1.00001, 1.00001, 1.00029, 1.00038, 1.00035, 1.00001, 1.0006, 1.0006, 0.99973, 0.99978, 1.00001, 1.00057, 0.99989, 0.99967, 0.99964, 0.99967, 0.99977, 0.99999, 0.99977, 1.00038, 0.99977, 1.00001, 0.99973, 1.00066, 0.99967, 0.99967, 1.00041, 0.99998, 0.99999, 0.99977, 1.00022, 0.99967, 1.00001, 0.99977, 1.00026, 0.99964, 1.00031, 1.00001, 0.99999, 0.99999, 1, 1.00023, 1, 1, 0.99999, 1.00035, 1.00001, 0.99999, 0.99973, 0.99977, 0.99999, 1.00058, 0.99973, 0.99973, 0.99955, 0.9995, 1.00026, 1.00026, 1.00032, 0.99989, 1.00034, 0.99999, 1.00026, 1.00026, 1.00026, 0.99973, 0.45998, 0.99973, 1.00026, 0.99973, 1.00001, 0.99999, 0.99982, 0.99994, 0.99996, 1, 1.00042, 1.00044, 1.00029, 1.00023, 0.99973, 0.99973, 1.00026, 0.99949, 1.00002, 0.99973, 1.0006, 1.0006, 1.0006, 0.99975, 1.00026, 1.00026, 1.00032, 0.98685, 0.99973, 1.00026, 1, 1, 0.99966, 1.00044, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1, 0.99973, 0.99971, 0.99978, 1, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00098, 1, 1, 1, 1.00049, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          o.HelveticaBoldItalicFactors = a;
          const v = {
            lineHeight: 1.35,
            lineGap: 0.2
          };
          o.HelveticaBoldItalicMetrics = v;
          const h = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.0288, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 0.99946, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.06311, 0.99973, 1.00024, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00041, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.89547, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00001, 1, 1.00054, 0.99977, 1.00084, 1.00007, 0.99973, 1.00013, 0.99924, 1.00001, 1.00001, 0.99945, 0.91221, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00001, 0.99999, 0.99977, 0.99933, 1.00022, 1.00054, 1.00001, 1.00065, 1.00026, 1.00001, 1.0001, 1.00001, 1.00052, 1, 1.0006, 1.00001, 0.99945, 0.99897, 0.99968, 0.99924, 1.00036, 0.99945, 0.99949, 1, 1.0006, 0.99897, 0.99918, 0.99968, 0.99911, 0.99924, 1, 0.99962, 1.01487, 1, 1.0005, 0.99973, 1.00012, 1.00043, 1, 0.99995, 0.99994, 1.00036, 0.99947, 1.00019, 1.00063, 1.00025, 0.99924, 1.00036, 0.99973, 1.00036, 1.00025, 1.00001, 1.00001, 1.00027, 1.0001, 1.00068, 1.00001, 1.0006, 1.0006, 1, 1.00008, 0.99957, 0.99972, 0.9994, 0.99954, 0.99975, 1.00051, 1.00001, 1.00019, 1.00001, 1.0001, 0.99986, 1.00001, 1.00001, 1.00038, 0.99954, 0.99954, 0.9994, 1.00066, 0.99999, 0.99977, 1.00022, 1.00054, 1.00001, 0.99977, 1.00026, 0.99975, 1.0001, 1.00001, 0.99993, 0.9995, 0.99955, 1.00016, 0.99978, 0.99974, 1.00019, 1.00022, 0.99955, 1.00053, 0.99973, 1.00089, 1.00005, 0.99967, 1.00048, 0.99973, 1.00002, 1.00034, 0.99973, 0.99973, 0.99964, 1.00006, 1.00066, 0.99947, 0.99973, 0.98894, 0.99973, 1, 0.44898, 1, 0.99946, 1, 1.00039, 1.00082, 0.99991, 0.99991, 0.99985, 1.00022, 1.00023, 1.00061, 1.00006, 0.99966, 0.99973, 0.99973, 0.99973, 1.00019, 1.0008, 1, 0.99924, 0.99924, 0.99924, 0.99983, 1.00044, 0.99973, 0.99964, 0.98332, 1, 0.99973, 1, 1, 0.99962, 0.99895, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 1.00423, 0.99925, 0.99999, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00049, 1, 1.00245, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 1.00003, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          o.HelveticaItalicFactors = h;
          const e = {
            lineHeight: 1.35,
            lineGap: 0.2
          };
          o.HelveticaItalicMetrics = e;
          const y = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.04596, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 1.00019, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.02572, 0.99973, 1.00005, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99999, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.84533, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99928, 1, 0.99977, 1.00013, 1.00055, 0.99947, 0.99945, 0.99941, 0.99924, 1.00001, 1.00001, 1.0004, 0.91621, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00005, 0.99999, 0.99977, 1.00015, 1.00022, 0.99977, 1.00001, 0.99973, 1.00026, 1.00001, 1.00019, 1.00001, 0.99946, 1, 1.0006, 1.00001, 0.99978, 1.00045, 0.99973, 0.99924, 1.00023, 0.99978, 0.99966, 1, 1.00065, 1.00045, 1.00019, 0.99973, 0.99973, 0.99924, 1, 1, 0.96499, 1, 1.00055, 0.99973, 1.00008, 1.00027, 1, 0.9997, 0.99995, 1.00023, 0.99933, 1.00019, 1.00015, 1.00031, 0.99924, 1.00023, 0.99973, 1.00023, 1.00031, 1.00001, 0.99928, 1.00029, 1.00092, 1.00035, 1.00001, 1.0006, 1.0006, 1, 0.99988, 0.99975, 1, 1.00082, 0.99561, 0.9996, 1.00035, 1.00001, 0.99962, 1.00001, 1.00092, 0.99964, 1.00001, 0.99963, 0.99999, 1.00035, 1.00035, 1.00082, 0.99962, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.9996, 0.99967, 1.00001, 1.00034, 1.00074, 1.00054, 1.00053, 1.00063, 0.99971, 0.99962, 1.00035, 0.99975, 0.99977, 0.99973, 1.00043, 0.99953, 1.0007, 0.99915, 0.99973, 1.00008, 0.99892, 1.00073, 1.00073, 1.00114, 0.99915, 1.00073, 0.99955, 0.99973, 1.00092, 0.99973, 1, 0.99998, 1, 1.0003, 1, 1.00043, 1.00001, 0.99969, 1.0003, 1, 1.00035, 1.00001, 0.9995, 1, 1.00092, 0.99973, 0.99973, 0.99973, 1.0007, 0.9995, 1, 0.99924, 1.0006, 0.99924, 0.99972, 1.00062, 0.99973, 1.00114, 1.00073, 1, 0.99955, 1, 1, 1.00047, 0.99968, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 0.99925, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          o.HelveticaRegularFactors = y;
          const c = {
            lineHeight: 1.2,
            lineGap: 0.2
          };
          o.HelveticaRegularMetrics = c;
        },
        /* 54 */
        /***/
        (J, o) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.LiberationSansRegularWidths = o.LiberationSansRegularMapping = o.LiberationSansItalicWidths = o.LiberationSansItalicMapping = o.LiberationSansBoldWidths = o.LiberationSansBoldMapping = o.LiberationSansBoldItalicWidths = o.LiberationSansBoldItalicMapping = void 0;
          const F = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 719, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 785, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 385, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 465, 722, 333, 853, 906, 474, 825, 927, 838, 278, 722, 722, 601, 719, 667, 611, 722, 778, 278, 722, 667, 833, 722, 644, 778, 722, 667, 600, 611, 667, 821, 667, 809, 802, 278, 667, 615, 451, 611, 278, 582, 615, 610, 556, 606, 475, 460, 611, 541, 278, 558, 556, 612, 556, 445, 611, 766, 619, 520, 684, 446, 582, 715, 576, 753, 845, 278, 582, 611, 582, 845, 667, 669, 885, 567, 711, 667, 278, 276, 556, 1094, 1062, 875, 610, 722, 622, 719, 722, 719, 722, 567, 712, 667, 904, 626, 719, 719, 610, 702, 833, 722, 778, 719, 667, 722, 611, 622, 854, 667, 730, 703, 1005, 1019, 870, 979, 719, 711, 1031, 719, 556, 618, 615, 417, 635, 556, 709, 497, 615, 615, 500, 635, 740, 604, 611, 604, 611, 556, 490, 556, 875, 556, 615, 581, 833, 844, 729, 854, 615, 552, 854, 583, 556, 556, 611, 417, 552, 556, 278, 281, 278, 969, 906, 611, 500, 615, 556, 604, 778, 611, 487, 447, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1094, 556, 885, 489, 1115, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333];
          o.LiberationSansBoldWidths = F;
          const t = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
          o.LiberationSansBoldMapping = t;
          const a = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 740, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 782, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 396, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 722, 333, 854, 906, 473, 844, 930, 847, 278, 722, 722, 610, 671, 667, 611, 722, 778, 278, 722, 667, 833, 722, 657, 778, 718, 667, 590, 611, 667, 822, 667, 829, 781, 278, 667, 620, 479, 611, 278, 591, 620, 621, 556, 610, 479, 492, 611, 558, 278, 566, 556, 603, 556, 450, 611, 712, 605, 532, 664, 409, 591, 704, 578, 773, 834, 278, 591, 611, 591, 834, 667, 667, 886, 614, 719, 667, 278, 278, 556, 1094, 1042, 854, 622, 719, 677, 719, 722, 708, 722, 614, 722, 667, 927, 643, 719, 719, 615, 687, 833, 722, 778, 719, 667, 722, 611, 677, 781, 667, 729, 708, 979, 989, 854, 1e3, 708, 719, 1042, 729, 556, 619, 604, 534, 618, 556, 736, 510, 611, 611, 507, 622, 740, 604, 611, 611, 611, 556, 889, 556, 885, 556, 646, 583, 889, 935, 707, 854, 594, 552, 865, 589, 556, 556, 611, 469, 563, 556, 278, 278, 278, 969, 906, 611, 507, 619, 556, 611, 778, 611, 575, 467, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1104, 556, 885, 516, 1146, 1e3, 768, 600, 834, 834, 834, 834, 999, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333];
          o.LiberationSansBoldItalicWidths = a;
          const v = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
          o.LiberationSansBoldItalicMapping = v;
          const h = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 625, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 733, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 281, 556, 400, 556, 222, 722, 556, 722, 556, 722, 556, 615, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 354, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 789, 846, 389, 794, 865, 775, 222, 667, 667, 570, 671, 667, 611, 722, 778, 278, 667, 667, 833, 722, 648, 778, 725, 667, 600, 611, 667, 837, 667, 831, 761, 278, 667, 570, 439, 555, 222, 550, 570, 571, 500, 556, 439, 463, 555, 542, 222, 500, 492, 548, 500, 447, 556, 670, 573, 486, 603, 374, 550, 652, 546, 728, 779, 222, 550, 556, 550, 779, 667, 667, 843, 544, 708, 667, 278, 278, 500, 1066, 982, 844, 589, 715, 639, 724, 667, 651, 667, 544, 704, 667, 917, 614, 715, 715, 589, 686, 833, 722, 778, 725, 667, 722, 611, 639, 795, 667, 727, 673, 920, 923, 805, 886, 651, 694, 1022, 682, 556, 562, 522, 493, 553, 556, 688, 465, 556, 556, 472, 564, 686, 550, 556, 556, 556, 500, 833, 500, 835, 500, 572, 518, 830, 851, 621, 736, 526, 492, 752, 534, 556, 556, 556, 378, 496, 500, 222, 222, 222, 910, 828, 556, 472, 565, 500, 556, 778, 556, 492, 339, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1083, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 998, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 584, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285];
          o.LiberationSansItalicWidths = h;
          const e = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
          o.LiberationSansItalicMapping = e;
          const y = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 615, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 735, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 292, 556, 334, 556, 222, 722, 556, 722, 556, 722, 556, 604, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 375, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 784, 838, 384, 774, 855, 752, 222, 667, 667, 551, 668, 667, 611, 722, 778, 278, 667, 668, 833, 722, 650, 778, 722, 667, 618, 611, 667, 798, 667, 835, 748, 278, 667, 578, 446, 556, 222, 547, 578, 575, 500, 557, 446, 441, 556, 556, 222, 500, 500, 576, 500, 448, 556, 690, 569, 482, 617, 395, 547, 648, 525, 713, 781, 222, 547, 556, 547, 781, 667, 667, 865, 542, 719, 667, 278, 278, 500, 1057, 1010, 854, 583, 722, 635, 719, 667, 656, 667, 542, 677, 667, 923, 604, 719, 719, 583, 656, 833, 722, 778, 719, 667, 722, 611, 635, 760, 667, 740, 667, 917, 938, 792, 885, 656, 719, 1010, 722, 556, 573, 531, 365, 583, 556, 669, 458, 559, 559, 438, 583, 688, 552, 556, 542, 556, 500, 458, 500, 823, 500, 573, 521, 802, 823, 625, 719, 521, 510, 750, 542, 556, 556, 556, 365, 510, 500, 222, 278, 222, 906, 812, 556, 438, 559, 500, 552, 778, 556, 489, 411, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1073, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285];
          o.LiberationSansRegularWidths = y;
          const c = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
          o.LiberationSansRegularMapping = c;
        },
        /* 55 */
        /***/
        (J, o) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.MyriadProRegularMetrics = o.MyriadProRegularFactors = o.MyriadProItalicMetrics = o.MyriadProItalicFactors = o.MyriadProBoldMetrics = o.MyriadProBoldItalicMetrics = o.MyriadProBoldItalicFactors = o.MyriadProBoldFactors = void 0;
          const F = [1.36898, 1, 1, 0.72706, 0.80479, 0.83734, 0.98894, 0.99793, 0.9897, 0.93884, 0.86209, 0.94292, 0.94292, 1.16661, 1.02058, 0.93582, 0.96694, 0.93582, 1.19137, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.72851, 0.78966, 0.90838, 0.83637, 0.82391, 0.96376, 0.80061, 0.86275, 0.8768, 0.95407, 1.0258, 0.73901, 0.85022, 0.83655, 1.0156, 0.95546, 0.92179, 0.87107, 0.92179, 0.82114, 0.8096, 0.89713, 0.94438, 0.95353, 0.94083, 0.91905, 0.90406, 0.9446, 0.94292, 1.18777, 0.94292, 1.02058, 0.89903, 0.90088, 0.94938, 0.97898, 0.81093, 0.97571, 0.94938, 1.024, 0.9577, 0.95933, 0.98621, 1.0474, 0.97455, 0.98981, 0.9672, 0.95933, 0.9446, 0.97898, 0.97407, 0.97646, 0.78036, 1.10208, 0.95442, 0.95298, 0.97579, 0.9332, 0.94039, 0.938, 0.80687, 1.01149, 0.80687, 1.02058, 0.80479, 0.99793, 0.99793, 0.99793, 0.99793, 1.01149, 1.00872, 0.90088, 0.91882, 1.0213, 0.8361, 1.02058, 0.62295, 0.54324, 0.89022, 1.08595, 1, 1, 0.90088, 1, 0.97455, 0.93582, 0.90088, 1, 1.05686, 0.8361, 0.99642, 0.99642, 0.99642, 0.72851, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.868, 0.82391, 0.80061, 0.80061, 0.80061, 0.80061, 1.0258, 1.0258, 1.0258, 1.0258, 0.97484, 0.95546, 0.92179, 0.92179, 0.92179, 0.92179, 0.92179, 1.02058, 0.92179, 0.94438, 0.94438, 0.94438, 0.94438, 0.90406, 0.86958, 0.98225, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.9031, 0.81093, 0.94938, 0.94938, 0.94938, 0.94938, 0.98621, 0.98621, 0.98621, 0.98621, 0.93969, 0.95933, 0.9446, 0.9446, 0.9446, 0.9446, 0.9446, 1.08595, 0.9446, 0.95442, 0.95442, 0.95442, 0.95442, 0.94039, 0.97898, 0.94039, 0.90838, 0.94938, 0.90838, 0.94938, 0.90838, 0.94938, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.96376, 0.84313, 0.97484, 0.97571, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.8768, 0.9577, 0.8768, 0.9577, 0.8768, 0.9577, 1, 1, 0.95407, 0.95933, 0.97069, 0.95933, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 0.887, 1.01591, 0.73901, 1.0474, 1, 1, 0.97455, 0.83655, 0.98981, 1, 1, 0.83655, 0.73977, 0.83655, 0.73903, 0.84638, 1.033, 0.95546, 0.95933, 1, 1, 0.95546, 0.95933, 0.8271, 0.95417, 0.95933, 0.92179, 0.9446, 0.92179, 0.9446, 0.92179, 0.9446, 0.936, 0.91964, 0.82114, 0.97646, 1, 1, 0.82114, 0.97646, 0.8096, 0.78036, 0.8096, 0.78036, 1, 1, 0.8096, 0.78036, 1, 1, 0.89713, 0.77452, 0.89713, 1.10208, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94083, 0.97579, 0.90406, 0.94039, 0.90406, 0.9446, 0.938, 0.9446, 0.938, 0.9446, 0.938, 1, 0.99793, 0.90838, 0.94938, 0.868, 0.9031, 0.92179, 0.9446, 1, 1, 0.89713, 1.10208, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90989, 0.9358, 0.91945, 0.83181, 0.75261, 0.87992, 0.82976, 0.96034, 0.83689, 0.97268, 1.0078, 0.90838, 0.83637, 0.8019, 0.90157, 0.80061, 0.9446, 0.95407, 0.92436, 1.0258, 0.85022, 0.97153, 1.0156, 0.95546, 0.89192, 0.92179, 0.92361, 0.87107, 0.96318, 0.89713, 0.93704, 0.95638, 0.91905, 0.91709, 0.92796, 1.0258, 0.93704, 0.94836, 1.0373, 0.95933, 1.0078, 0.95871, 0.94836, 0.96174, 0.92601, 0.9498, 0.98607, 0.95776, 0.95933, 1.05453, 1.0078, 0.98275, 0.9314, 0.95617, 0.91701, 1.05993, 0.9446, 0.78367, 0.9553, 1, 0.86832, 1.0128, 0.95871, 0.99394, 0.87548, 0.96361, 0.86774, 1.0078, 0.95871, 0.9446, 0.95871, 0.86774, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.94083, 0.97579, 0.94083, 0.97579, 0.94083, 0.97579, 0.90406, 0.94039, 0.96694, 1, 0.89903, 1, 1, 1, 0.93582, 0.93582, 0.93582, 1, 0.908, 0.908, 0.918, 0.94219, 0.94219, 0.96544, 1, 1.285, 1, 1, 0.81079, 0.81079, 1, 1, 0.74854, 1, 1, 1, 1, 0.99793, 1, 1, 1, 0.65, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.17173, 1, 0.80535, 0.76169, 1.02058, 1.0732, 1.05486, 1, 1, 1.30692, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.16161, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          o.MyriadProBoldFactors = F;
          const t = {
            lineHeight: 1.2,
            lineGap: 0.2
          };
          o.MyriadProBoldMetrics = t;
          const a = [1.36898, 1, 1, 0.66227, 0.80779, 0.81625, 0.97276, 0.97276, 0.97733, 0.92222, 0.83266, 0.94292, 0.94292, 1.16148, 1.02058, 0.93582, 0.96694, 0.93582, 1.17337, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.71541, 0.76813, 0.85576, 0.80591, 0.80729, 0.94299, 0.77512, 0.83655, 0.86523, 0.92222, 0.98621, 0.71743, 0.81698, 0.79726, 0.98558, 0.92222, 0.90637, 0.83809, 0.90637, 0.80729, 0.76463, 0.86275, 0.90699, 0.91605, 0.9154, 0.85308, 0.85458, 0.90531, 0.94292, 1.21296, 0.94292, 1.02058, 0.89903, 1.18616, 0.99613, 0.91677, 0.78216, 0.91677, 0.90083, 0.98796, 0.9135, 0.92168, 0.95381, 0.98981, 0.95298, 0.95381, 0.93459, 0.92168, 0.91513, 0.92004, 0.91677, 0.95077, 0.748, 1.04502, 0.91677, 0.92061, 0.94236, 0.89544, 0.89364, 0.9, 0.80687, 0.8578, 0.80687, 1.02058, 0.80779, 0.97276, 0.97276, 0.97276, 0.97276, 0.8578, 0.99973, 1.18616, 0.91339, 1.08074, 0.82891, 1.02058, 0.55509, 0.71526, 0.89022, 1.08595, 1, 1, 1.18616, 1, 0.96736, 0.93582, 1.18616, 1, 1.04864, 0.82711, 0.99043, 0.99043, 0.99043, 0.71541, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.845, 0.80729, 0.77512, 0.77512, 0.77512, 0.77512, 0.98621, 0.98621, 0.98621, 0.98621, 0.95961, 0.92222, 0.90637, 0.90637, 0.90637, 0.90637, 0.90637, 1.02058, 0.90251, 0.90699, 0.90699, 0.90699, 0.90699, 0.85458, 0.83659, 0.94951, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.85811, 0.78216, 0.90083, 0.90083, 0.90083, 0.90083, 0.95381, 0.95381, 0.95381, 0.95381, 0.9135, 0.92168, 0.91513, 0.91513, 0.91513, 0.91513, 0.91513, 1.08595, 0.91677, 0.91677, 0.91677, 0.91677, 0.91677, 0.89364, 0.92332, 0.89364, 0.85576, 0.99613, 0.85576, 0.99613, 0.85576, 0.99613, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.94299, 0.76783, 0.95961, 0.91677, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.86523, 0.9135, 0.86523, 0.9135, 0.86523, 0.9135, 1, 1, 0.92222, 0.92168, 0.92222, 0.92168, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.86036, 0.97096, 0.71743, 0.98981, 1, 1, 0.95298, 0.79726, 0.95381, 1, 1, 0.79726, 0.6894, 0.79726, 0.74321, 0.81691, 1.0006, 0.92222, 0.92168, 1, 1, 0.92222, 0.92168, 0.79464, 0.92098, 0.92168, 0.90637, 0.91513, 0.90637, 0.91513, 0.90637, 0.91513, 0.909, 0.87514, 0.80729, 0.95077, 1, 1, 0.80729, 0.95077, 0.76463, 0.748, 0.76463, 0.748, 1, 1, 0.76463, 0.748, 1, 1, 0.86275, 0.72651, 0.86275, 1.04502, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.9154, 0.94236, 0.85458, 0.89364, 0.85458, 0.90531, 0.9, 0.90531, 0.9, 0.90531, 0.9, 1, 0.97276, 0.85576, 0.99613, 0.845, 0.85811, 0.90251, 0.91677, 1, 1, 0.86275, 1.04502, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.00899, 1.30628, 0.85576, 0.80178, 0.66862, 0.7927, 0.69323, 0.88127, 0.72459, 0.89711, 0.95381, 0.85576, 0.80591, 0.7805, 0.94729, 0.77512, 0.90531, 0.92222, 0.90637, 0.98621, 0.81698, 0.92655, 0.98558, 0.92222, 0.85359, 0.90637, 0.90976, 0.83809, 0.94523, 0.86275, 0.83509, 0.93157, 0.85308, 0.83392, 0.92346, 0.98621, 0.83509, 0.92886, 0.91324, 0.92168, 0.95381, 0.90646, 0.92886, 0.90557, 0.86847, 0.90276, 0.91324, 0.86842, 0.92168, 0.99531, 0.95381, 0.9224, 0.85408, 0.92699, 0.86847, 1.0051, 0.91513, 0.80487, 0.93481, 1, 0.88159, 1.05214, 0.90646, 0.97355, 0.81539, 0.89398, 0.85923, 0.95381, 0.90646, 0.91513, 0.90646, 0.85923, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9154, 0.94236, 0.9154, 0.94236, 0.9154, 0.94236, 0.85458, 0.89364, 0.96694, 1, 0.89903, 1, 1, 1, 0.91782, 0.91782, 0.91782, 1, 0.896, 0.896, 0.896, 0.9332, 0.9332, 0.95973, 1, 1.26, 1, 1, 0.80479, 0.80178, 1, 1, 0.85633, 1, 1, 1, 1, 0.97276, 1, 1, 1, 0.698, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.14542, 1, 0.79199, 0.78694, 1.02058, 1.03493, 1.05486, 1, 1, 1.23026, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.20006, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          o.MyriadProBoldItalicFactors = a;
          const v = {
            lineHeight: 1.2,
            lineGap: 0.2
          };
          o.MyriadProBoldItalicMetrics = v;
          const h = [1.36898, 1, 1, 0.65507, 0.84943, 0.85639, 0.88465, 0.88465, 0.86936, 0.88307, 0.86948, 0.85283, 0.85283, 1.06383, 1.02058, 0.75945, 0.9219, 0.75945, 1.17337, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.75945, 0.75945, 1.02058, 1.02058, 1.02058, 0.69046, 0.70926, 0.85158, 0.77812, 0.76852, 0.89591, 0.70466, 0.76125, 0.80094, 0.86822, 0.83864, 0.728, 0.77212, 0.79475, 0.93637, 0.87514, 0.8588, 0.76013, 0.8588, 0.72421, 0.69866, 0.77598, 0.85991, 0.80811, 0.87832, 0.78112, 0.77512, 0.8562, 1.0222, 1.18417, 1.0222, 1.27014, 0.89903, 1.15012, 0.93859, 0.94399, 0.846, 0.94399, 0.81453, 1.0186, 0.94219, 0.96017, 1.03075, 1.02175, 0.912, 1.03075, 0.96998, 0.96017, 0.93859, 0.94399, 0.94399, 0.95493, 0.746, 1.12658, 0.94578, 0.91, 0.979, 0.882, 0.882, 0.83, 0.85034, 0.83537, 0.85034, 1.02058, 0.70869, 0.88465, 0.88465, 0.88465, 0.88465, 0.83537, 0.90083, 1.15012, 0.9161, 0.94565, 0.73541, 1.02058, 0.53609, 0.69353, 0.79519, 1.08595, 1, 1, 1.15012, 1, 0.91974, 0.75945, 1.15012, 1, 0.9446, 0.73361, 0.9005, 0.9005, 0.9005, 0.62864, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.773, 0.76852, 0.70466, 0.70466, 0.70466, 0.70466, 0.83864, 0.83864, 0.83864, 0.83864, 0.90561, 0.87514, 0.8588, 0.8588, 0.8588, 0.8588, 0.8588, 1.02058, 0.85751, 0.85991, 0.85991, 0.85991, 0.85991, 0.77512, 0.76013, 0.88075, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.8075, 0.846, 0.81453, 0.81453, 0.81453, 0.81453, 0.82424, 0.82424, 0.82424, 0.82424, 0.9278, 0.96017, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 1.08595, 0.8562, 0.94578, 0.94578, 0.94578, 0.94578, 0.882, 0.94578, 0.882, 0.85158, 0.93859, 0.85158, 0.93859, 0.85158, 0.93859, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.89591, 0.8544, 0.90561, 0.94399, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.80094, 0.94219, 0.80094, 0.94219, 0.80094, 0.94219, 1, 1, 0.86822, 0.96017, 0.86822, 0.96017, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 1.03075, 0.83864, 0.82424, 0.81402, 1.02738, 0.728, 1.02175, 1, 1, 0.912, 0.79475, 1.03075, 1, 1, 0.79475, 0.83911, 0.79475, 0.66266, 0.80553, 1.06676, 0.87514, 0.96017, 1, 1, 0.87514, 0.96017, 0.86865, 0.87396, 0.96017, 0.8588, 0.93859, 0.8588, 0.93859, 0.8588, 0.93859, 0.867, 0.84759, 0.72421, 0.95493, 1, 1, 0.72421, 0.95493, 0.69866, 0.746, 0.69866, 0.746, 1, 1, 0.69866, 0.746, 1, 1, 0.77598, 0.88417, 0.77598, 1.12658, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.87832, 0.979, 0.77512, 0.882, 0.77512, 0.8562, 0.83, 0.8562, 0.83, 0.8562, 0.83, 1, 0.88465, 0.85158, 0.93859, 0.773, 0.8075, 0.85751, 0.8562, 1, 1, 0.77598, 1.12658, 1.15012, 1.15012, 1.15012, 1.15012, 1.15012, 1.15313, 1.15012, 1.15012, 1.15012, 1.08106, 1.03901, 0.85158, 0.77025, 0.62264, 0.7646, 0.65351, 0.86026, 0.69461, 0.89947, 1.03075, 0.85158, 0.77812, 0.76449, 0.88836, 0.70466, 0.8562, 0.86822, 0.8588, 0.83864, 0.77212, 0.85308, 0.93637, 0.87514, 0.82352, 0.8588, 0.85701, 0.76013, 0.89058, 0.77598, 0.8156, 0.82565, 0.78112, 0.77899, 0.89386, 0.83864, 0.8156, 0.9486, 0.92388, 0.96186, 1.03075, 0.91123, 0.9486, 0.93298, 0.878, 0.93942, 0.92388, 0.84596, 0.96186, 0.95119, 1.03075, 0.922, 0.88787, 0.95829, 0.88, 0.93559, 0.93859, 0.78815, 0.93758, 1, 0.89217, 1.03737, 0.91123, 0.93969, 0.77487, 0.85769, 0.86799, 1.03075, 0.91123, 0.93859, 0.91123, 0.86799, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87832, 0.979, 0.87832, 0.979, 0.87832, 0.979, 0.77512, 0.882, 0.9219, 1, 0.89903, 1, 1, 1, 0.87321, 0.87321, 0.87321, 1, 1.027, 1.027, 1.027, 0.86847, 0.86847, 0.79121, 1, 1.124, 1, 1, 0.73572, 0.73572, 1, 1, 0.85034, 1, 1, 1, 1, 0.88465, 1, 1, 1, 0.669, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04828, 1, 0.74948, 0.75187, 1.02058, 0.98391, 1.02119, 1, 1, 1.06233, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05233, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          o.MyriadProItalicFactors = h;
          const e = {
            lineHeight: 1.2,
            lineGap: 0.2
          };
          o.MyriadProItalicMetrics = e;
          const y = [1.36898, 1, 1, 0.76305, 0.82784, 0.94935, 0.89364, 0.92241, 0.89073, 0.90706, 0.98472, 0.85283, 0.85283, 1.0664, 1.02058, 0.74505, 0.9219, 0.74505, 1.23456, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.74505, 0.74505, 1.02058, 1.02058, 1.02058, 0.73002, 0.72601, 0.91755, 0.8126, 0.80314, 0.92222, 0.73764, 0.79726, 0.83051, 0.90284, 0.86023, 0.74, 0.8126, 0.84869, 0.96518, 0.91115, 0.8858, 0.79761, 0.8858, 0.74498, 0.73914, 0.81363, 0.89591, 0.83659, 0.89633, 0.85608, 0.8111, 0.90531, 1.0222, 1.22736, 1.0222, 1.27014, 0.89903, 0.90088, 0.86667, 1.0231, 0.896, 1.01411, 0.90083, 1.05099, 1.00512, 0.99793, 1.05326, 1.09377, 0.938, 1.06226, 1.00119, 0.99793, 0.98714, 1.0231, 1.01231, 0.98196, 0.792, 1.19137, 0.99074, 0.962, 1.01915, 0.926, 0.942, 0.856, 0.85034, 0.92006, 0.85034, 1.02058, 0.69067, 0.92241, 0.92241, 0.92241, 0.92241, 0.92006, 0.9332, 0.90088, 0.91882, 0.93484, 0.75339, 1.02058, 0.56866, 0.54324, 0.79519, 1.08595, 1, 1, 0.90088, 1, 0.95325, 0.74505, 0.90088, 1, 0.97198, 0.75339, 0.91009, 0.91009, 0.91009, 0.66466, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.788, 0.80314, 0.73764, 0.73764, 0.73764, 0.73764, 0.86023, 0.86023, 0.86023, 0.86023, 0.92915, 0.91115, 0.8858, 0.8858, 0.8858, 0.8858, 0.8858, 1.02058, 0.8858, 0.89591, 0.89591, 0.89591, 0.89591, 0.8111, 0.79611, 0.89713, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86936, 0.896, 0.90083, 0.90083, 0.90083, 0.90083, 0.84224, 0.84224, 0.84224, 0.84224, 0.97276, 0.99793, 0.98714, 0.98714, 0.98714, 0.98714, 0.98714, 1.08595, 0.89876, 0.99074, 0.99074, 0.99074, 0.99074, 0.942, 1.0231, 0.942, 0.91755, 0.86667, 0.91755, 0.86667, 0.91755, 0.86667, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.92222, 0.93372, 0.92915, 1.01411, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.83051, 1.00512, 0.83051, 1.00512, 0.83051, 1.00512, 1, 1, 0.90284, 0.99793, 0.90976, 0.99793, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 1.05326, 0.86023, 0.84224, 0.82873, 1.07469, 0.74, 1.09377, 1, 1, 0.938, 0.84869, 1.06226, 1, 1, 0.84869, 0.83704, 0.84869, 0.81441, 0.85588, 1.08927, 0.91115, 0.99793, 1, 1, 0.91115, 0.99793, 0.91887, 0.90991, 0.99793, 0.8858, 0.98714, 0.8858, 0.98714, 0.8858, 0.98714, 0.894, 0.91434, 0.74498, 0.98196, 1, 1, 0.74498, 0.98196, 0.73914, 0.792, 0.73914, 0.792, 1, 1, 0.73914, 0.792, 1, 1, 0.81363, 0.904, 0.81363, 1.19137, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89633, 1.01915, 0.8111, 0.942, 0.8111, 0.90531, 0.856, 0.90531, 0.856, 0.90531, 0.856, 1, 0.92241, 0.91755, 0.86667, 0.788, 0.86936, 0.8858, 0.89876, 1, 1, 0.81363, 1.19137, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90388, 1.03901, 0.92138, 0.78105, 0.7154, 0.86169, 0.80513, 0.94007, 0.82528, 0.98612, 1.06226, 0.91755, 0.8126, 0.81884, 0.92819, 0.73764, 0.90531, 0.90284, 0.8858, 0.86023, 0.8126, 0.91172, 0.96518, 0.91115, 0.83089, 0.8858, 0.87791, 0.79761, 0.89297, 0.81363, 0.88157, 0.89992, 0.85608, 0.81992, 0.94307, 0.86023, 0.88157, 0.95308, 0.98699, 0.99793, 1.06226, 0.95817, 0.95308, 0.97358, 0.928, 0.98088, 0.98699, 0.92761, 0.99793, 0.96017, 1.06226, 0.986, 0.944, 0.95978, 0.938, 0.96705, 0.98714, 0.80442, 0.98972, 1, 0.89762, 1.04552, 0.95817, 0.99007, 0.87064, 0.91879, 0.88888, 1.06226, 0.95817, 0.98714, 0.95817, 0.88888, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89633, 1.01915, 0.89633, 1.01915, 0.89633, 1.01915, 0.8111, 0.942, 0.9219, 1, 0.89903, 1, 1, 1, 0.93173, 0.93173, 0.93173, 1, 1.06304, 1.06304, 1.06904, 0.89903, 0.89903, 0.80549, 1, 1.156, 1, 1, 0.76575, 0.76575, 1, 1, 0.72458, 1, 1, 1, 1, 0.92241, 1, 1, 1, 0.619, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.07257, 1, 0.74705, 0.71119, 1.02058, 1.024, 1.02119, 1, 1, 1.1536, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05638, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          o.MyriadProRegularFactors = y;
          const c = {
            lineHeight: 1.2,
            lineGap: 0.2
          };
          o.MyriadProRegularMetrics = c;
        },
        /* 56 */
        /***/
        (J, o) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.SegoeuiRegularMetrics = o.SegoeuiRegularFactors = o.SegoeuiItalicMetrics = o.SegoeuiItalicFactors = o.SegoeuiBoldMetrics = o.SegoeuiBoldItalicMetrics = o.SegoeuiBoldItalicFactors = o.SegoeuiBoldFactors = void 0;
          const F = [1.76738, 1, 1, 0.99297, 0.9824, 1.04016, 1.06497, 1.03424, 0.97529, 1.17647, 1.23203, 1.1085, 1.1085, 1.16939, 1.2107, 0.9754, 1.21408, 0.9754, 1.59578, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 0.81378, 0.81378, 1.2107, 1.2107, 1.2107, 0.71703, 0.97847, 0.97363, 0.88776, 0.8641, 1.02096, 0.79795, 0.85132, 0.914, 1.06085, 1.1406, 0.8007, 0.89858, 0.83693, 1.14889, 1.09398, 0.97489, 0.92094, 0.97489, 0.90399, 0.84041, 0.95923, 1.00135, 1, 1.06467, 0.98243, 0.90996, 0.99361, 1.1085, 1.56942, 1.1085, 1.2107, 0.74627, 0.94282, 0.96752, 1.01519, 0.86304, 1.01359, 0.97278, 1.15103, 1.01359, 0.98561, 1.02285, 1.02285, 1.00527, 1.02285, 1.0302, 0.99041, 1.0008, 1.01519, 1.01359, 1.02258, 0.79104, 1.16862, 0.99041, 0.97454, 1.02511, 0.99298, 0.96752, 0.95801, 0.94856, 1.16579, 0.94856, 1.2107, 0.9824, 1.03424, 1.03424, 1, 1.03424, 1.16579, 0.8727, 1.3871, 1.18622, 1.10818, 1.04478, 1.2107, 1.18622, 0.75155, 0.94994, 1.28826, 1.21408, 1.21408, 0.91056, 1, 0.91572, 0.9754, 0.64663, 1.18328, 1.24866, 1.04478, 1.14169, 1.15749, 1.17389, 0.71703, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.93506, 0.8641, 0.79795, 0.79795, 0.79795, 0.79795, 1.1406, 1.1406, 1.1406, 1.1406, 1.02096, 1.09398, 0.97426, 0.97426, 0.97426, 0.97426, 0.97426, 1.2107, 0.97489, 1.00135, 1.00135, 1.00135, 1.00135, 0.90996, 0.92094, 1.02798, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.93136, 0.86304, 0.97278, 0.97278, 0.97278, 0.97278, 1.02285, 1.02285, 1.02285, 1.02285, 0.97122, 0.99041, 1, 1, 1, 1, 1, 1.28826, 1.0008, 0.99041, 0.99041, 0.99041, 0.99041, 0.96752, 1.01519, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 1.02096, 1.03057, 1.02096, 1.03517, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.914, 1.01359, 0.914, 1.01359, 0.914, 1.01359, 1, 1, 1.06085, 0.98561, 1.06085, 1.00879, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 0.97138, 1.08692, 0.8007, 1.02285, 1, 1, 1.00527, 0.83693, 1.02285, 1, 1, 0.83693, 0.9455, 0.83693, 0.90418, 0.83693, 1.13005, 1.09398, 0.99041, 1, 1, 1.09398, 0.99041, 0.96692, 1.09251, 0.99041, 0.97489, 1.0008, 0.97489, 1.0008, 0.97489, 1.0008, 0.93994, 0.97931, 0.90399, 1.02258, 1, 1, 0.90399, 1.02258, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 1, 1, 0.95923, 1.07034, 0.95923, 1.16862, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.06467, 1.02511, 0.90996, 0.96752, 0.90996, 0.99361, 0.95801, 0.99361, 0.95801, 0.99361, 0.95801, 1.07733, 1.03424, 0.97363, 0.96752, 0.93506, 0.93136, 0.97489, 1.0008, 1, 1, 0.95923, 1.16862, 1.15103, 1.15103, 1.01173, 1.03959, 0.75953, 0.81378, 0.79912, 1.15103, 1.21994, 0.95161, 0.87815, 1.01149, 0.81525, 0.7676, 0.98167, 1.01134, 1.02546, 0.84097, 1.03089, 1.18102, 0.97363, 0.88776, 0.85134, 0.97826, 0.79795, 0.99361, 1.06085, 0.97489, 1.1406, 0.89858, 1.0388, 1.14889, 1.09398, 0.86039, 0.97489, 1.0595, 0.92094, 0.94793, 0.95923, 0.90996, 0.99346, 0.98243, 1.02112, 0.95493, 1.1406, 0.90996, 1.03574, 1.02597, 1.0008, 1.18102, 1.06628, 1.03574, 1.0192, 1.01932, 1.00886, 0.97531, 1.0106, 1.0008, 1.13189, 1.18102, 1.02277, 0.98683, 1.0016, 0.99561, 1.07237, 1.0008, 0.90434, 0.99921, 0.93803, 0.8965, 1.23085, 1.06628, 1.04983, 0.96268, 1.0499, 0.98439, 1.18102, 1.06628, 1.0008, 1.06628, 0.98439, 0.79795, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09466, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.97278, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.02065, 1, 1, 1, 1, 1, 1, 1.06467, 1.02511, 1.06467, 1.02511, 1.06467, 1.02511, 0.90996, 0.96752, 1, 1.21408, 0.89903, 1, 1, 0.75155, 1.04394, 1.04394, 1.04394, 1.04394, 0.98633, 0.98633, 0.98633, 0.73047, 0.73047, 1.20642, 0.91211, 1.25635, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.12454, 0.93503, 1.03424, 1.19687, 1.03424, 1, 1, 1, 0.771, 1, 1, 1.15749, 1.15749, 1.15749, 1.10948, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.16897, 1, 0.96085, 0.90137, 1.2107, 1.18416, 1.13973, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21172, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18874, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.09193, 1.09193, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          o.SegoeuiBoldFactors = F;
          const t = {
            lineHeight: 1.33008,
            lineGap: 0
          };
          o.SegoeuiBoldMetrics = t;
          const a = [1.76738, 1, 1, 0.98946, 1.03959, 1.04016, 1.02809, 1.036, 0.97639, 1.10953, 1.23203, 1.11144, 1.11144, 1.16939, 1.21237, 0.9754, 1.21261, 0.9754, 1.59754, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 0.81378, 0.81378, 1.21237, 1.21237, 1.21237, 0.73541, 0.97847, 0.97363, 0.89723, 0.87897, 1.0426, 0.79429, 0.85292, 0.91149, 1.05815, 1.1406, 0.79631, 0.90128, 0.83853, 1.04396, 1.10615, 0.97552, 0.94436, 0.97552, 0.88641, 0.80527, 0.96083, 1.00135, 1, 1.06777, 0.9817, 0.91142, 0.99361, 1.11144, 1.57293, 1.11144, 1.21237, 0.74627, 1.31818, 1.06585, 0.97042, 0.83055, 0.97042, 0.93503, 1.1261, 0.97042, 0.97922, 1.14236, 0.94552, 1.01054, 1.14236, 1.02471, 0.97922, 0.94165, 0.97042, 0.97042, 1.0276, 0.78929, 1.1261, 0.97922, 0.95874, 1.02197, 0.98507, 0.96752, 0.97168, 0.95107, 1.16579, 0.95107, 1.21237, 1.03959, 1.036, 1.036, 1, 1.036, 1.16579, 0.87357, 1.31818, 1.18754, 1.26781, 1.05356, 1.21237, 1.18622, 0.79487, 0.94994, 1.29004, 1.24047, 1.24047, 1.31818, 1, 0.91484, 0.9754, 1.31818, 1.1349, 1.24866, 1.05356, 1.13934, 1.15574, 1.17389, 0.73541, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.94385, 0.87897, 0.79429, 0.79429, 0.79429, 0.79429, 1.1406, 1.1406, 1.1406, 1.1406, 1.0426, 1.10615, 0.97552, 0.97552, 0.97552, 0.97552, 0.97552, 1.21237, 0.97552, 1.00135, 1.00135, 1.00135, 1.00135, 0.91142, 0.94436, 0.98721, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 0.96705, 0.83055, 0.93503, 0.93503, 0.93503, 0.93503, 1.14236, 1.14236, 1.14236, 1.14236, 0.93125, 0.97922, 0.94165, 0.94165, 0.94165, 0.94165, 0.94165, 1.29004, 0.94165, 0.97922, 0.97922, 0.97922, 0.97922, 0.96752, 0.97042, 0.96752, 0.97363, 1.06585, 0.97363, 1.06585, 0.97363, 1.06585, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 1.0426, 1.0033, 1.0426, 0.97042, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.91149, 0.97042, 0.91149, 0.97042, 0.91149, 0.97042, 1, 1, 1.05815, 0.97922, 1.05815, 0.97922, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 0.97441, 1.04302, 0.79631, 1.01582, 1, 1, 1.01054, 0.83853, 1.14236, 1, 1, 0.83853, 1.09125, 0.83853, 0.90418, 0.83853, 1.19508, 1.10615, 0.97922, 1, 1, 1.10615, 0.97922, 1.01034, 1.10466, 0.97922, 0.97552, 0.94165, 0.97552, 0.94165, 0.97552, 0.94165, 0.91602, 0.91981, 0.88641, 1.0276, 1, 1, 0.88641, 1.0276, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 1, 1, 0.96083, 1.05403, 0.95923, 1.16862, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.06777, 1.02197, 0.91142, 0.96752, 0.91142, 0.99361, 0.97168, 0.99361, 0.97168, 0.99361, 0.97168, 1.23199, 1.036, 0.97363, 1.06585, 0.94385, 0.96705, 0.97552, 0.94165, 1, 1, 0.96083, 1.1261, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 0.95161, 1.27126, 1.00811, 0.83284, 0.77702, 0.99137, 0.95253, 1.0347, 0.86142, 1.07205, 1.14236, 0.97363, 0.89723, 0.86869, 1.09818, 0.79429, 0.99361, 1.05815, 0.97552, 1.1406, 0.90128, 1.06662, 1.04396, 1.10615, 0.84918, 0.97552, 1.04694, 0.94436, 0.98015, 0.96083, 0.91142, 1.00356, 0.9817, 1.01945, 0.98999, 1.1406, 0.91142, 1.04961, 0.9898, 1.00639, 1.14236, 1.07514, 1.04961, 0.99607, 1.02897, 1.008, 0.9898, 0.95134, 1.00639, 1.11121, 1.14236, 1.00518, 0.97981, 1.02186, 1, 1.08578, 0.94165, 0.99314, 0.98387, 0.93028, 0.93377, 1.35125, 1.07514, 1.10687, 0.93491, 1.04232, 1.00351, 1.14236, 1.07514, 0.94165, 1.07514, 1.00351, 0.79429, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09097, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.93503, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96609, 1, 1, 1, 1, 1, 1, 1.06777, 1.02197, 1.06777, 1.02197, 1.06777, 1.02197, 0.91142, 0.96752, 1, 1.21261, 0.89903, 1, 1, 0.75155, 1.04745, 1.04745, 1.04745, 1.04394, 0.98633, 0.98633, 0.98633, 0.72959, 0.72959, 1.20502, 0.91406, 1.26514, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.09125, 0.93327, 1.03336, 1.16541, 1.036, 1, 1, 1, 0.771, 1, 1, 1.15574, 1.15574, 1.15574, 1.15574, 0.86364, 0.94434, 0.86279, 0.94434, 0.86224, 1, 1, 1.16798, 1, 0.96085, 0.90068, 1.21237, 1.18416, 1.13904, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21339, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18775, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.13269, 1.13269, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          o.SegoeuiBoldItalicFactors = a;
          const v = {
            lineHeight: 1.33008,
            lineGap: 0
          };
          o.SegoeuiBoldItalicMetrics = v;
          const h = [1.76738, 1, 1, 0.98946, 1.14763, 1.05365, 1.06234, 0.96927, 0.92586, 1.15373, 1.18414, 0.91349, 0.91349, 1.07403, 1.17308, 0.78383, 1.20088, 0.78383, 1.42531, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78383, 0.78383, 1.17308, 1.17308, 1.17308, 0.77349, 0.94565, 0.94729, 0.85944, 0.88506, 0.9858, 0.74817, 0.80016, 0.88449, 0.98039, 0.95782, 0.69238, 0.89898, 0.83231, 0.98183, 1.03989, 0.96924, 0.86237, 0.96924, 0.80595, 0.74524, 0.86091, 0.95402, 0.94143, 0.98448, 0.8858, 0.83089, 0.93285, 1.0949, 1.39016, 1.0949, 1.45994, 0.74627, 1.04839, 0.97454, 0.97454, 0.87207, 0.97454, 0.87533, 1.06151, 0.97454, 1.00176, 1.16484, 1.08132, 0.98047, 1.16484, 1.02989, 1.01054, 0.96225, 0.97454, 0.97454, 1.06598, 0.79004, 1.16344, 1.00351, 0.94629, 0.9973, 0.91016, 0.96777, 0.9043, 0.91082, 0.92481, 0.91082, 1.17308, 0.95748, 0.96927, 0.96927, 1, 0.96927, 0.92481, 0.80597, 1.04839, 1.23393, 1.1781, 0.9245, 1.17308, 1.20808, 0.63218, 0.94261, 1.24822, 1.09971, 1.09971, 1.04839, 1, 0.85273, 0.78032, 1.04839, 1.09971, 1.22326, 0.9245, 1.09836, 1.13525, 1.15222, 0.70424, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.85498, 0.88506, 0.74817, 0.74817, 0.74817, 0.74817, 0.95782, 0.95782, 0.95782, 0.95782, 0.9858, 1.03989, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.17308, 0.96924, 0.95402, 0.95402, 0.95402, 0.95402, 0.83089, 0.86237, 0.88409, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.92916, 0.87207, 0.87533, 0.87533, 0.87533, 0.87533, 0.93146, 0.93146, 0.93146, 0.93146, 0.93854, 1.01054, 0.96225, 0.96225, 0.96225, 0.96225, 0.96225, 1.24822, 0.8761, 1.00351, 1.00351, 1.00351, 1.00351, 0.96777, 0.97454, 0.96777, 0.94729, 0.97454, 0.94729, 0.97454, 0.94729, 0.97454, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.9858, 0.95391, 0.9858, 0.97454, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.88449, 0.97454, 0.88449, 0.97454, 0.88449, 0.97454, 1, 1, 0.98039, 1.00176, 0.98039, 1.00176, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 1.16484, 0.95782, 0.93146, 0.84421, 1.12761, 0.69238, 1.08132, 1, 1, 0.98047, 0.83231, 1.16484, 1, 1, 0.84723, 1.04861, 0.84723, 0.78755, 0.83231, 1.23736, 1.03989, 1.01054, 1, 1, 1.03989, 1.01054, 0.9857, 1.03849, 1.01054, 0.96924, 0.96225, 0.96924, 0.96225, 0.96924, 0.96225, 0.92383, 0.90171, 0.80595, 1.06598, 1, 1, 0.80595, 1.06598, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 1, 1, 0.86091, 1.02759, 0.85771, 1.16344, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.98448, 0.9973, 0.83089, 0.96777, 0.83089, 0.93285, 0.9043, 0.93285, 0.9043, 0.93285, 0.9043, 1.31868, 0.96927, 0.94729, 0.97454, 0.85498, 0.92916, 0.96924, 0.8761, 1, 1, 0.86091, 1.16344, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 0.81965, 0.81965, 0.94729, 0.78032, 0.71022, 0.90883, 0.84171, 0.99877, 0.77596, 1.05734, 1.2, 0.94729, 0.85944, 0.82791, 0.9607, 0.74817, 0.93285, 0.98039, 0.96924, 0.95782, 0.89898, 0.98316, 0.98183, 1.03989, 0.78614, 0.96924, 0.97642, 0.86237, 0.86075, 0.86091, 0.83089, 0.90082, 0.8858, 0.97296, 1.01284, 0.95782, 0.83089, 1.0976, 1.04, 1.03342, 1.2, 1.0675, 1.0976, 0.98205, 1.03809, 1.05097, 1.04, 0.95364, 1.03342, 1.05401, 1.2, 1.02148, 1.0119, 1.04724, 1.0127, 1.02732, 0.96225, 0.8965, 0.97783, 0.93574, 0.94818, 1.30679, 1.0675, 1.11826, 0.99821, 1.0557, 1.0326, 1.2, 1.0675, 0.96225, 1.0675, 1.0326, 0.74817, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03754, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87533, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.98705, 1, 1, 1, 1, 1, 1, 0.98448, 0.9973, 0.98448, 0.9973, 0.98448, 0.9973, 0.83089, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 0.94945, 0.94945, 0.94945, 0.94945, 1.12317, 1.12317, 1.12317, 0.67603, 0.67603, 1.15621, 0.73584, 1.21191, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87709, 0.96927, 1.01473, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.09836, 1.09836, 1.09836, 1.01522, 0.86321, 0.94434, 0.8649, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86438, 1.17308, 1.18416, 1.14589, 0.69825, 0.97622, 1.96791, 1.24822, 1.24822, 1.17308, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.17984, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10742, 1.10742, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          o.SegoeuiItalicFactors = h;
          const e = {
            lineHeight: 1.33008,
            lineGap: 0
          };
          o.SegoeuiItalicMetrics = e;
          const y = [1.76738, 1, 1, 0.98594, 1.02285, 1.10454, 1.06234, 0.96927, 0.92037, 1.19985, 1.2046, 0.90616, 0.90616, 1.07152, 1.1714, 0.78032, 1.20088, 0.78032, 1.40246, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78032, 0.78032, 1.1714, 1.1714, 1.1714, 0.80597, 0.94084, 0.96706, 0.85944, 0.85734, 0.97093, 0.75842, 0.79936, 0.88198, 0.9831, 0.95782, 0.71387, 0.86969, 0.84636, 1.07796, 1.03584, 0.96924, 0.83968, 0.96924, 0.82826, 0.79649, 0.85771, 0.95132, 0.93119, 0.98965, 0.88433, 0.8287, 0.93365, 1.08612, 1.3638, 1.08612, 1.45786, 0.74627, 0.80499, 0.91484, 1.05707, 0.92383, 1.05882, 0.9403, 1.12654, 1.05882, 1.01756, 1.09011, 1.09011, 0.99414, 1.09011, 1.034, 1.01756, 1.05356, 1.05707, 1.05882, 1.04399, 0.84863, 1.21968, 1.01756, 0.95801, 1.00068, 0.91797, 0.96777, 0.9043, 0.90351, 0.92105, 0.90351, 1.1714, 0.85337, 0.96927, 0.96927, 0.99912, 0.96927, 0.92105, 0.80597, 1.2434, 1.20808, 1.05937, 0.90957, 1.1714, 1.20808, 0.75155, 0.94261, 1.24644, 1.09971, 1.09971, 0.84751, 1, 0.85273, 0.78032, 0.61584, 1.05425, 1.17914, 0.90957, 1.08665, 1.11593, 1.14169, 0.73381, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.86035, 0.85734, 0.75842, 0.75842, 0.75842, 0.75842, 0.95782, 0.95782, 0.95782, 0.95782, 0.97093, 1.03584, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.1714, 0.96924, 0.95132, 0.95132, 0.95132, 0.95132, 0.8287, 0.83968, 0.89049, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.93575, 0.92383, 0.9403, 0.9403, 0.9403, 0.9403, 0.8717, 0.8717, 0.8717, 0.8717, 1.00527, 1.01756, 1.05356, 1.05356, 1.05356, 1.05356, 1.05356, 1.24644, 0.95923, 1.01756, 1.01756, 1.01756, 1.01756, 0.96777, 1.05707, 0.96777, 0.96706, 0.91484, 0.96706, 0.91484, 0.96706, 0.91484, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.97093, 1.0969, 0.97093, 1.05882, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.88198, 1.05882, 0.88198, 1.05882, 0.88198, 1.05882, 1, 1, 0.9831, 1.01756, 0.9831, 1.01756, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 1.09011, 0.95782, 0.8717, 0.84784, 1.11551, 0.71387, 1.09011, 1, 1, 0.99414, 0.84636, 1.09011, 1, 1, 0.84636, 1.0536, 0.84636, 0.94298, 0.84636, 1.23297, 1.03584, 1.01756, 1, 1, 1.03584, 1.01756, 1.00323, 1.03444, 1.01756, 0.96924, 1.05356, 0.96924, 1.05356, 0.96924, 1.05356, 0.93066, 0.98293, 0.82826, 1.04399, 1, 1, 0.82826, 1.04399, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 1, 1, 0.85771, 1.17318, 0.85771, 1.21968, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.98965, 1.00068, 0.8287, 0.96777, 0.8287, 0.93365, 0.9043, 0.93365, 0.9043, 0.93365, 0.9043, 1.08571, 0.96927, 0.96706, 0.91484, 0.86035, 0.93575, 0.96924, 0.95923, 1, 1, 0.85771, 1.21968, 1.11437, 1.11437, 0.93109, 0.91202, 0.60411, 0.84164, 0.55572, 1.01173, 0.97361, 0.81818, 0.81818, 0.96635, 0.78032, 0.72727, 0.92366, 0.98601, 1.03405, 0.77968, 1.09799, 1.2, 0.96706, 0.85944, 0.85638, 0.96491, 0.75842, 0.93365, 0.9831, 0.96924, 0.95782, 0.86969, 0.94152, 1.07796, 1.03584, 0.78437, 0.96924, 0.98715, 0.83968, 0.83491, 0.85771, 0.8287, 0.94492, 0.88433, 0.9287, 1.0098, 0.95782, 0.8287, 1.0625, 0.98248, 1.03424, 1.2, 1.01071, 1.0625, 0.95246, 1.03809, 1.04912, 0.98248, 1.00221, 1.03424, 1.05443, 1.2, 1.04785, 0.99609, 1.00169, 1.05176, 0.99346, 1.05356, 0.9087, 1.03004, 0.95542, 0.93117, 1.23362, 1.01071, 1.07831, 1.02512, 1.05205, 1.03502, 1.2, 1.01071, 1.05356, 1.01071, 1.03502, 0.75842, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03719, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9403, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04021, 1, 1, 1, 1, 1, 1, 0.98965, 1.00068, 0.98965, 1.00068, 0.98965, 1.00068, 0.8287, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 1.03077, 1.03077, 1.03077, 1.03077, 1.13196, 1.13196, 1.13196, 0.67428, 0.67428, 1.16039, 0.73291, 1.20996, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87796, 0.96927, 1.01518, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.10539, 1.10539, 1.11358, 1.06967, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86507, 1.1714, 1.18416, 1.14589, 0.69825, 0.97622, 1.9697, 1.24822, 1.24822, 1.17238, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18083, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10938, 1.10938, 1, 1, 1, 1.05425, 1.09971, 1.09971, 1.09971, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          o.SegoeuiRegularFactors = y;
          const c = {
            lineHeight: 1.33008,
            lineGap: 0
          };
          o.SegoeuiRegularMetrics = c;
        },
        /* 57 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.PostScriptEvaluator = o.PostScriptCompiler = o.PDFFunctionFactory = void 0, o.isPDFFunction = m;
          var t = F(5), a = F(2), v = F(58), h = F(7), e = F(59);
          class y {
            constructor({
              xref: x,
              isEvalSupported: f = !0
            }) {
              this.xref = x, this.isEvalSupported = f !== !1;
            }
            create(x) {
              const f = this.getCached(x);
              if (f)
                return f;
              const D = d.parse({
                xref: this.xref,
                isEvalSupported: this.isEvalSupported,
                fn: x instanceof t.Ref ? this.xref.fetch(x) : x
              });
              return this._cache(x, D), D;
            }
            createFromArray(x) {
              const f = this.getCached(x);
              if (f)
                return f;
              const D = d.parseArray({
                xref: this.xref,
                isEvalSupported: this.isEvalSupported,
                fnObj: x instanceof t.Ref ? this.xref.fetch(x) : x
              });
              return this._cache(x, D), D;
            }
            getCached(x) {
              let f;
              if (x instanceof t.Ref ? f = x : x instanceof t.Dict ? f = x.objId : x instanceof h.BaseStream && (f = x.dict && x.dict.objId), f) {
                const D = this._localFunctionCache.getByRef(f);
                if (D)
                  return D;
              }
              return null;
            }
            _cache(x, f) {
              if (!f)
                throw new Error('PDFFunctionFactory._cache - expected "parsedFunction" argument.');
              let D;
              x instanceof t.Ref ? D = x : x instanceof t.Dict ? D = x.objId : x instanceof h.BaseStream && (D = x.dict && x.dict.objId), D && this._localFunctionCache.set(null, D, f);
            }
            get _localFunctionCache() {
              return (0, a.shadow)(this, "_localFunctionCache", new e.LocalFunctionCache());
            }
          }
          o.PDFFunctionFactory = y;
          function c(k) {
            if (!Array.isArray(k))
              return null;
            const x = k.length;
            for (let f = 0; f < x; f++)
              if (typeof k[f] != "number") {
                const D = new Array(x);
                for (let _ = 0; _ < x; _++)
                  D[_] = +k[_];
                return D;
              }
            return k;
          }
          class d {
            static getSampleArray(x, f, D, _) {
              let S, C, T = 1;
              for (S = 0, C = x.length; S < C; S++)
                T *= x[S];
              T *= f;
              const P = new Array(T);
              let M = 0, G = 0;
              const Z = 1 / (2 ** D - 1), $ = _.getBytes((T * D + 7) / 8);
              let z = 0;
              for (S = 0; S < T; S++) {
                for (; M < D; )
                  G <<= 8, G |= $[z++], M += 8;
                M -= D, P[S] = (G >> M) * Z, G &= (1 << M) - 1;
              }
              return P;
            }
            static parse({
              xref: x,
              isEvalSupported: f,
              fn: D
            }) {
              const _ = D.dict || D;
              switch (_.get("FunctionType")) {
                case 0:
                  return this.constructSampled({
                    xref: x,
                    isEvalSupported: f,
                    fn: D,
                    dict: _
                  });
                case 1:
                  break;
                case 2:
                  return this.constructInterpolated({
                    xref: x,
                    isEvalSupported: f,
                    dict: _
                  });
                case 3:
                  return this.constructStiched({
                    xref: x,
                    isEvalSupported: f,
                    dict: _
                  });
                case 4:
                  return this.constructPostScript({
                    xref: x,
                    isEvalSupported: f,
                    fn: D,
                    dict: _
                  });
              }
              throw new a.FormatError("Unknown type of function");
            }
            static parseArray({
              xref: x,
              isEvalSupported: f,
              fnObj: D
            }) {
              if (!Array.isArray(D))
                return this.parse({
                  xref: x,
                  isEvalSupported: f,
                  fn: D
                });
              const _ = [];
              for (let S = 0, C = D.length; S < C; S++)
                _.push(this.parse({
                  xref: x,
                  isEvalSupported: f,
                  fn: x.fetchIfRef(D[S])
                }));
              return function(S, C, T, P) {
                for (let M = 0, G = _.length; M < G; M++)
                  _[M](S, C, T, P + M);
              };
            }
            static constructSampled({
              xref: x,
              isEvalSupported: f,
              fn: D,
              dict: _
            }) {
              function S(ne) {
                const se = ne.length, q = [];
                let N = 0;
                for (let Q = 0; Q < se; Q += 2)
                  q[N++] = [ne[Q], ne[Q + 1]];
                return q;
              }
              function C(ne, se, q, N, Q) {
                return N + (ne - se) * ((Q - N) / (q - se));
              }
              let T = c(_.getArray("Domain")), P = c(_.getArray("Range"));
              if (!T || !P)
                throw new a.FormatError("No domain or range");
              const M = T.length / 2, G = P.length / 2;
              T = S(T), P = S(P);
              const Z = c(_.getArray("Size")), $ = _.get("BitsPerSample"), z = _.get("Order") || 1;
              z !== 1 && (0, a.info)("No support for cubic spline interpolation: " + z);
              let V = c(_.getArray("Encode"));
              if (V)
                V = S(V);
              else {
                V = [];
                for (let ne = 0; ne < M; ++ne)
                  V.push([0, Z[ne] - 1]);
              }
              let L = c(_.getArray("Decode"));
              L ? L = S(L) : L = P;
              const K = this.getSampleArray(Z, G, $, D);
              return function(se, q, N, Q) {
                const E = 1 << M, te = new Float64Array(E), oe = new Uint32Array(E);
                let ee, W;
                for (W = 0; W < E; W++)
                  te[W] = 1;
                let I = G, H = 1;
                for (ee = 0; ee < M; ++ee) {
                  const ie = T[ee][0], ue = T[ee][1], fe = Math.min(Math.max(se[q + ee], ie), ue);
                  let de = C(fe, ie, ue, V[ee][0], V[ee][1]);
                  const pe = Z[ee];
                  de = Math.min(Math.max(de, 0), pe - 1);
                  const xe = de < pe - 1 ? Math.floor(de) : de - 1, Fe = xe + 1 - de, Se = de - xe, Ce = xe * I, ke = Ce + I;
                  for (W = 0; W < E; W++)
                    W & H ? (te[W] *= Se, oe[W] += ke) : (te[W] *= Fe, oe[W] += Ce);
                  I *= pe, H <<= 1;
                }
                for (W = 0; W < G; ++W) {
                  let ie = 0;
                  for (ee = 0; ee < E; ee++)
                    ie += K[oe[ee] + W] * te[ee];
                  ie = C(ie, 0, 1, L[W][0], L[W][1]), N[Q + W] = Math.min(Math.max(ie, P[W][0]), P[W][1]);
                }
              };
            }
            static constructInterpolated({
              xref: x,
              isEvalSupported: f,
              dict: D
            }) {
              const _ = c(D.getArray("C0")) || [0], S = c(D.getArray("C1")) || [1], C = D.get("N"), T = [];
              for (let M = 0, G = _.length; M < G; ++M)
                T.push(S[M] - _[M]);
              const P = T.length;
              return function(G, Z, $, z) {
                const V = C === 1 ? G[Z] : G[Z] ** C;
                for (let L = 0; L < P; ++L)
                  $[z + L] = _[L] + V * T[L];
              };
            }
            static constructStiched({
              xref: x,
              isEvalSupported: f,
              dict: D
            }) {
              const _ = c(D.getArray("Domain"));
              if (!_)
                throw new a.FormatError("No domain");
              if (_.length / 2 !== 1)
                throw new a.FormatError("Bad domain for stiched function");
              const C = D.get("Functions"), T = [];
              for (let Z = 0, $ = C.length; Z < $; ++Z)
                T.push(this.parse({
                  xref: x,
                  isEvalSupported: f,
                  fn: x.fetchIfRef(C[Z])
                }));
              const P = c(D.getArray("Bounds")), M = c(D.getArray("Encode")), G = new Float32Array(1);
              return function($, z, V, L) {
                const ne = function(ee, W, I) {
                  return ee > I ? ee = I : ee < W && (ee = W), ee;
                }($[z], _[0], _[1]), se = P.length;
                let q;
                for (q = 0; q < se && !(ne < P[q]); ++q)
                  ;
                let N = _[0];
                q > 0 && (N = P[q - 1]);
                let Q = _[1];
                q < P.length && (Q = P[q]);
                const E = M[2 * q], te = M[2 * q + 1];
                G[0] = N === Q ? E : E + (ne - N) * (te - E) / (Q - N), T[q](G, 0, V, L);
              };
            }
            static constructPostScript({
              xref: x,
              isEvalSupported: f,
              fn: D,
              dict: _
            }) {
              const S = c(_.getArray("Domain")), C = c(_.getArray("Range"));
              if (!S)
                throw new a.FormatError("No domain.");
              if (!C)
                throw new a.FormatError("No range.");
              const T = new v.PostScriptLexer(D), M = new v.PostScriptParser(T).parse();
              if (f && a.FeatureTest.isEvalSupported) {
                const ne = new U().compile(M, S, C);
                if (ne)
                  return new Function("src", "srcOffset", "dest", "destOffset", ne);
              }
              (0, a.info)("Unable to compile PS function");
              const G = C.length >> 1, Z = S.length >> 1, $ = new g(M), z = /* @__PURE__ */ Object.create(null);
              let L = 2048 * 4;
              const K = new Float32Array(Z);
              return function(se, q, N, Q) {
                let E, te, oe = "";
                const ee = K;
                for (E = 0; E < Z; E++)
                  te = se[q + E], ee[E] = te, oe += te + "_";
                const W = z[oe];
                if (W !== void 0) {
                  N.set(W, Q);
                  return;
                }
                const I = new Float32Array(G), H = $.execute(ee), ie = H.length - G;
                for (E = 0; E < G; E++) {
                  te = H[ie + E];
                  let ue = C[E * 2];
                  te < ue ? te = ue : (ue = C[E * 2 + 1], te > ue && (te = ue)), I[E] = te;
                }
                L > 0 && (L--, z[oe] = I), N.set(I, Q);
              };
            }
          }
          function m(k) {
            let x;
            if (typeof k != "object")
              return !1;
            if (k instanceof t.Dict)
              x = k;
            else if (k instanceof h.BaseStream)
              x = k.dict;
            else
              return !1;
            return x.has("FunctionType");
          }
          class p {
            static get MAX_STACK_SIZE() {
              return (0, a.shadow)(this, "MAX_STACK_SIZE", 100);
            }
            constructor(x) {
              this.stack = x ? Array.prototype.slice.call(x, 0) : [];
            }
            push(x) {
              if (this.stack.length >= p.MAX_STACK_SIZE)
                throw new Error("PostScript function stack overflow.");
              this.stack.push(x);
            }
            pop() {
              if (this.stack.length <= 0)
                throw new Error("PostScript function stack underflow.");
              return this.stack.pop();
            }
            copy(x) {
              if (this.stack.length + x >= p.MAX_STACK_SIZE)
                throw new Error("PostScript function stack overflow.");
              const f = this.stack;
              for (let D = f.length - x, _ = x - 1; _ >= 0; _--, D++)
                f.push(f[D]);
            }
            index(x) {
              this.push(this.stack[this.stack.length - x - 1]);
            }
            roll(x, f) {
              const D = this.stack, _ = D.length - x, S = D.length - 1, C = _ + (f - Math.floor(f / x) * x);
              for (let T = _, P = S; T < P; T++, P--) {
                const M = D[T];
                D[T] = D[P], D[P] = M;
              }
              for (let T = _, P = C - 1; T < P; T++, P--) {
                const M = D[T];
                D[T] = D[P], D[P] = M;
              }
              for (let T = C, P = S; T < P; T++, P--) {
                const M = D[T];
                D[T] = D[P], D[P] = M;
              }
            }
          }
          class g {
            constructor(x) {
              this.operators = x;
            }
            execute(x) {
              const f = new p(x);
              let D = 0;
              const _ = this.operators, S = _.length;
              let C, T, P;
              for (; D < S; ) {
                if (C = _[D++], typeof C == "number") {
                  f.push(C);
                  continue;
                }
                switch (C) {
                  case "jz":
                    P = f.pop(), T = f.pop(), T || (D = P);
                    break;
                  case "j":
                    T = f.pop(), D = T;
                    break;
                  case "abs":
                    T = f.pop(), f.push(Math.abs(T));
                    break;
                  case "add":
                    P = f.pop(), T = f.pop(), f.push(T + P);
                    break;
                  case "and":
                    P = f.pop(), T = f.pop(), typeof T == "boolean" && typeof P == "boolean" ? f.push(T && P) : f.push(T & P);
                    break;
                  case "atan":
                    T = f.pop(), f.push(Math.atan(T));
                    break;
                  case "bitshift":
                    P = f.pop(), T = f.pop(), T > 0 ? f.push(T << P) : f.push(T >> P);
                    break;
                  case "ceiling":
                    T = f.pop(), f.push(Math.ceil(T));
                    break;
                  case "copy":
                    T = f.pop(), f.copy(T);
                    break;
                  case "cos":
                    T = f.pop(), f.push(Math.cos(T));
                    break;
                  case "cvi":
                    T = f.pop() | 0, f.push(T);
                    break;
                  case "cvr":
                    break;
                  case "div":
                    P = f.pop(), T = f.pop(), f.push(T / P);
                    break;
                  case "dup":
                    f.copy(1);
                    break;
                  case "eq":
                    P = f.pop(), T = f.pop(), f.push(T === P);
                    break;
                  case "exch":
                    f.roll(2, 1);
                    break;
                  case "exp":
                    P = f.pop(), T = f.pop(), f.push(T ** P);
                    break;
                  case "false":
                    f.push(!1);
                    break;
                  case "floor":
                    T = f.pop(), f.push(Math.floor(T));
                    break;
                  case "ge":
                    P = f.pop(), T = f.pop(), f.push(T >= P);
                    break;
                  case "gt":
                    P = f.pop(), T = f.pop(), f.push(T > P);
                    break;
                  case "idiv":
                    P = f.pop(), T = f.pop(), f.push(T / P | 0);
                    break;
                  case "index":
                    T = f.pop(), f.index(T);
                    break;
                  case "le":
                    P = f.pop(), T = f.pop(), f.push(T <= P);
                    break;
                  case "ln":
                    T = f.pop(), f.push(Math.log(T));
                    break;
                  case "log":
                    T = f.pop(), f.push(Math.log(T) / Math.LN10);
                    break;
                  case "lt":
                    P = f.pop(), T = f.pop(), f.push(T < P);
                    break;
                  case "mod":
                    P = f.pop(), T = f.pop(), f.push(T % P);
                    break;
                  case "mul":
                    P = f.pop(), T = f.pop(), f.push(T * P);
                    break;
                  case "ne":
                    P = f.pop(), T = f.pop(), f.push(T !== P);
                    break;
                  case "neg":
                    T = f.pop(), f.push(-T);
                    break;
                  case "not":
                    T = f.pop(), typeof T == "boolean" ? f.push(!T) : f.push(~T);
                    break;
                  case "or":
                    P = f.pop(), T = f.pop(), typeof T == "boolean" && typeof P == "boolean" ? f.push(T || P) : f.push(T | P);
                    break;
                  case "pop":
                    f.pop();
                    break;
                  case "roll":
                    P = f.pop(), T = f.pop(), f.roll(T, P);
                    break;
                  case "round":
                    T = f.pop(), f.push(Math.round(T));
                    break;
                  case "sin":
                    T = f.pop(), f.push(Math.sin(T));
                    break;
                  case "sqrt":
                    T = f.pop(), f.push(Math.sqrt(T));
                    break;
                  case "sub":
                    P = f.pop(), T = f.pop(), f.push(T - P);
                    break;
                  case "true":
                    f.push(!0);
                    break;
                  case "truncate":
                    T = f.pop(), T = T < 0 ? Math.ceil(T) : Math.floor(T), f.push(T);
                    break;
                  case "xor":
                    P = f.pop(), T = f.pop(), typeof T == "boolean" && typeof P == "boolean" ? f.push(T !== P) : f.push(T ^ P);
                    break;
                  default:
                    throw new a.FormatError(`Unknown operator ${C}`);
                }
              }
              return f.stack;
            }
          }
          o.PostScriptEvaluator = g;
          class n {
            constructor(x) {
              this.type = x;
            }
            visit(x) {
              (0, a.unreachable)("abstract method");
            }
          }
          class i extends n {
            constructor(x, f, D) {
              super("args"), this.index = x, this.min = f, this.max = D;
            }
            visit(x) {
              x.visitArgument(this);
            }
          }
          class l extends n {
            constructor(x) {
              super("literal"), this.number = x, this.min = x, this.max = x;
            }
            visit(x) {
              x.visitLiteral(this);
            }
          }
          class u extends n {
            constructor(x, f, D, _, S) {
              super("binary"), this.op = x, this.arg1 = f, this.arg2 = D, this.min = _, this.max = S;
            }
            visit(x) {
              x.visitBinaryOperation(this);
            }
          }
          class w extends n {
            constructor(x, f) {
              super("max"), this.arg = x, this.min = x.min, this.max = f;
            }
            visit(x) {
              x.visitMin(this);
            }
          }
          class O extends n {
            constructor(x, f, D) {
              super("var"), this.index = x, this.min = f, this.max = D;
            }
            visit(x) {
              x.visitVariable(this);
            }
          }
          class b extends n {
            constructor(x, f) {
              super("definition"), this.variable = x, this.arg = f;
            }
            visit(x) {
              x.visitVariableDefinition(this);
            }
          }
          class A {
            constructor() {
              this.parts = [];
            }
            visitArgument(x) {
              this.parts.push("Math.max(", x.min, ", Math.min(", x.max, ", src[srcOffset + ", x.index, "]))");
            }
            visitVariable(x) {
              this.parts.push("v", x.index);
            }
            visitLiteral(x) {
              this.parts.push(x.number);
            }
            visitBinaryOperation(x) {
              this.parts.push("("), x.arg1.visit(this), this.parts.push(" ", x.op, " "), x.arg2.visit(this), this.parts.push(")");
            }
            visitVariableDefinition(x) {
              this.parts.push("var "), x.variable.visit(this), this.parts.push(" = "), x.arg.visit(this), this.parts.push(";");
            }
            visitMin(x) {
              this.parts.push("Math.min("), x.arg.visit(this), this.parts.push(", ", x.max, ")");
            }
            toString() {
              return this.parts.join("");
            }
          }
          function Y(k, x) {
            return x.type === "literal" && x.number === 0 ? k : k.type === "literal" && k.number === 0 ? x : x.type === "literal" && k.type === "literal" ? new l(k.number + x.number) : new u("+", k, x, k.min + x.min, k.max + x.max);
          }
          function j(k, x) {
            if (x.type === "literal") {
              if (x.number === 0)
                return new l(0);
              if (x.number === 1)
                return k;
              if (k.type === "literal")
                return new l(k.number * x.number);
            }
            if (k.type === "literal") {
              if (k.number === 0)
                return new l(0);
              if (k.number === 1)
                return x;
            }
            const f = Math.min(k.min * x.min, k.min * x.max, k.max * x.min, k.max * x.max), D = Math.max(k.min * x.min, k.min * x.max, k.max * x.min, k.max * x.max);
            return new u("*", k, x, f, D);
          }
          function X(k, x) {
            if (x.type === "literal") {
              if (x.number === 0)
                return k;
              if (k.type === "literal")
                return new l(k.number - x.number);
            }
            return x.type === "binary" && x.op === "-" && k.type === "literal" && k.number === 1 && x.arg1.type === "literal" && x.arg1.number === 1 ? x.arg2 : new u("-", k, x, k.min - x.max, k.max - x.min);
          }
          function B(k, x) {
            return k.min >= x ? new l(x) : k.max <= x ? k : new w(k, x);
          }
          class U {
            compile(x, f, D) {
              const _ = [], S = [], C = f.length >> 1, T = D.length >> 1;
              let P = 0, M, G, Z, $, z, V, L, K;
              for (let se = 0; se < C; se++)
                _.push(new i(se, f[se * 2], f[se * 2 + 1]));
              for (let se = 0, q = x.length; se < q; se++) {
                if (K = x[se], typeof K == "number") {
                  _.push(new l(K));
                  continue;
                }
                switch (K) {
                  case "add":
                    if (_.length < 2)
                      return null;
                    $ = _.pop(), Z = _.pop(), _.push(Y(Z, $));
                    break;
                  case "cvr":
                    if (_.length < 1)
                      return null;
                    break;
                  case "mul":
                    if (_.length < 2)
                      return null;
                    $ = _.pop(), Z = _.pop(), _.push(j(Z, $));
                    break;
                  case "sub":
                    if (_.length < 2)
                      return null;
                    $ = _.pop(), Z = _.pop(), _.push(X(Z, $));
                    break;
                  case "exch":
                    if (_.length < 2)
                      return null;
                    z = _.pop(), V = _.pop(), _.push(z, V);
                    break;
                  case "pop":
                    if (_.length < 1)
                      return null;
                    _.pop();
                    break;
                  case "index":
                    if (_.length < 1 || (Z = _.pop(), Z.type !== "literal") || (M = Z.number, M < 0 || !Number.isInteger(M) || _.length < M))
                      return null;
                    if (z = _[_.length - M - 1], z.type === "literal" || z.type === "var") {
                      _.push(z);
                      break;
                    }
                    L = new O(P++, z.min, z.max), _[_.length - M - 1] = L, _.push(L), S.push(new b(L, z));
                    break;
                  case "dup":
                    if (_.length < 1)
                      return null;
                    if (typeof x[se + 1] == "number" && x[se + 2] === "gt" && x[se + 3] === se + 7 && x[se + 4] === "jz" && x[se + 5] === "pop" && x[se + 6] === x[se + 1]) {
                      Z = _.pop(), _.push(B(Z, x[se + 1])), se += 6;
                      break;
                    }
                    if (z = _.at(-1), z.type === "literal" || z.type === "var") {
                      _.push(z);
                      break;
                    }
                    L = new O(P++, z.min, z.max), _[_.length - 1] = L, _.push(L), S.push(new b(L, z));
                    break;
                  case "roll":
                    if (_.length < 2 || ($ = _.pop(), Z = _.pop(), $.type !== "literal" || Z.type !== "literal") || (G = $.number, M = Z.number, M <= 0 || !Number.isInteger(M) || !Number.isInteger(G) || _.length < M))
                      return null;
                    if (G = (G % M + M) % M, G === 0)
                      break;
                    Array.prototype.push.apply(_, _.splice(_.length - M, M - G));
                    break;
                  default:
                    return null;
                }
              }
              if (_.length !== T)
                return null;
              const ne = [];
              for (const se of S) {
                const q = new A();
                se.visit(q), ne.push(q.toString());
              }
              for (let se = 0, q = _.length; se < q; se++) {
                const N = _[se], Q = new A();
                N.visit(Q);
                const E = D[se * 2], te = D[se * 2 + 1], oe = [Q.toString()];
                E > N.min && (oe.unshift("Math.max(", E, ", "), oe.push(")")), te < N.max && (oe.unshift("Math.min(", te, ", "), oe.push(")")), oe.unshift("dest[destOffset + ", se, "] = "), oe.push(";"), ne.push(oe.join(""));
              }
              return ne.join(`
`);
            }
          }
          o.PostScriptCompiler = U;
        },
        /* 58 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.PostScriptParser = o.PostScriptLexer = void 0;
          var t = F(2), a = F(5), v = F(6);
          class h {
            constructor(m) {
              this.lexer = m, this.operators = [], this.token = null, this.prev = null;
            }
            nextToken() {
              this.prev = this.token, this.token = this.lexer.getToken();
            }
            accept(m) {
              return this.token.type === m ? (this.nextToken(), !0) : !1;
            }
            expect(m) {
              if (this.accept(m))
                return !0;
              throw new t.FormatError(`Unexpected symbol: found ${this.token.type} expected ${m}.`);
            }
            parse() {
              return this.nextToken(), this.expect(e.LBRACE), this.parseBlock(), this.expect(e.RBRACE), this.operators;
            }
            parseBlock() {
              for (; ; )
                if (this.accept(e.NUMBER))
                  this.operators.push(this.prev.value);
                else if (this.accept(e.OPERATOR))
                  this.operators.push(this.prev.value);
                else if (this.accept(e.LBRACE))
                  this.parseCondition();
                else
                  return;
            }
            parseCondition() {
              const m = this.operators.length;
              if (this.operators.push(null, null), this.parseBlock(), this.expect(e.RBRACE), this.accept(e.IF))
                this.operators[m] = this.operators.length, this.operators[m + 1] = "jz";
              else if (this.accept(e.LBRACE)) {
                const p = this.operators.length;
                this.operators.push(null, null);
                const g = this.operators.length;
                this.parseBlock(), this.expect(e.RBRACE), this.expect(e.IFELSE), this.operators[p] = this.operators.length, this.operators[p + 1] = "j", this.operators[m] = g, this.operators[m + 1] = "jz";
              } else
                throw new t.FormatError("PS Function: error parsing conditional.");
            }
          }
          o.PostScriptParser = h;
          const e = {
            LBRACE: 0,
            RBRACE: 1,
            NUMBER: 2,
            OPERATOR: 3,
            IF: 4,
            IFELSE: 5
          };
          class y {
            static get opCache() {
              return (0, t.shadow)(this, "opCache", /* @__PURE__ */ Object.create(null));
            }
            constructor(m, p) {
              this.type = m, this.value = p;
            }
            static getOperator(m) {
              const p = y.opCache[m];
              return p || (y.opCache[m] = new y(e.OPERATOR, m));
            }
            static get LBRACE() {
              return (0, t.shadow)(this, "LBRACE", new y(e.LBRACE, "{"));
            }
            static get RBRACE() {
              return (0, t.shadow)(this, "RBRACE", new y(e.RBRACE, "}"));
            }
            static get IF() {
              return (0, t.shadow)(this, "IF", new y(e.IF, "IF"));
            }
            static get IFELSE() {
              return (0, t.shadow)(this, "IFELSE", new y(e.IFELSE, "IFELSE"));
            }
          }
          class c {
            constructor(m) {
              this.stream = m, this.nextChar(), this.strBuf = [];
            }
            nextChar() {
              return this.currentChar = this.stream.getByte();
            }
            getToken() {
              let m = !1, p = this.currentChar;
              for (; ; ) {
                if (p < 0)
                  return a.EOF;
                if (m)
                  (p === 10 || p === 13) && (m = !1);
                else if (p === 37)
                  m = !0;
                else if (!(0, v.isWhiteSpace)(p))
                  break;
                p = this.nextChar();
              }
              switch (p | 0) {
                case 48:
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                case 43:
                case 45:
                case 46:
                  return new y(e.NUMBER, this.getNumber());
                case 123:
                  return this.nextChar(), y.LBRACE;
                case 125:
                  return this.nextChar(), y.RBRACE;
              }
              const g = this.strBuf;
              for (g.length = 0, g[0] = String.fromCharCode(p); (p = this.nextChar()) >= 0 && (p >= 65 && p <= 90 || p >= 97 && p <= 122); )
                g.push(String.fromCharCode(p));
              const n = g.join("");
              switch (n.toLowerCase()) {
                case "if":
                  return y.IF;
                case "ifelse":
                  return y.IFELSE;
                default:
                  return y.getOperator(n);
              }
            }
            getNumber() {
              let m = this.currentChar;
              const p = this.strBuf;
              for (p.length = 0, p[0] = String.fromCharCode(m); (m = this.nextChar()) >= 0 && (m >= 48 && m <= 57 || m === 45 || m === 46); )
                p.push(String.fromCharCode(m));
              const g = parseFloat(p.join(""));
              if (isNaN(g))
                throw new t.FormatError(`Invalid floating point number: ${g}`);
              return g;
            }
          }
          o.PostScriptLexer = c;
        },
        /* 59 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.LocalTilingPatternCache = o.LocalImageCache = o.LocalGStateCache = o.LocalFunctionCache = o.LocalColorSpaceCache = o.GlobalImageCache = void 0;
          var t = F(2), a = F(5);
          class v {
            constructor(g) {
              this.constructor === v && (0, t.unreachable)("Cannot initialize BaseLocalCache."), this._onlyRefs = (g && g.onlyRefs) === !0, this._onlyRefs || (this._nameRefMap = /* @__PURE__ */ new Map(), this._imageMap = /* @__PURE__ */ new Map()), this._imageCache = new a.RefSetCache();
            }
            getByName(g) {
              this._onlyRefs && (0, t.unreachable)("Should not call `getByName` method.");
              const n = this._nameRefMap.get(g);
              return n ? this.getByRef(n) : this._imageMap.get(g) || null;
            }
            getByRef(g) {
              return this._imageCache.get(g) || null;
            }
            set(g, n, i) {
              (0, t.unreachable)("Abstract method `set` called.");
            }
          }
          class h extends v {
            set(g, n = null, i) {
              if (typeof g != "string")
                throw new Error('LocalImageCache.set - expected "name" argument.');
              if (n) {
                if (this._imageCache.has(n))
                  return;
                this._nameRefMap.set(g, n), this._imageCache.put(n, i);
                return;
              }
              this._imageMap.has(g) || this._imageMap.set(g, i);
            }
          }
          o.LocalImageCache = h;
          class e extends v {
            set(g = null, n = null, i) {
              if (typeof g != "string" && !n)
                throw new Error('LocalColorSpaceCache.set - expected "name" and/or "ref" argument.');
              if (n) {
                if (this._imageCache.has(n))
                  return;
                g !== null && this._nameRefMap.set(g, n), this._imageCache.put(n, i);
                return;
              }
              this._imageMap.has(g) || this._imageMap.set(g, i);
            }
          }
          o.LocalColorSpaceCache = e;
          class y extends v {
            constructor(g) {
              super({
                onlyRefs: !0
              });
            }
            set(g = null, n, i) {
              if (!n)
                throw new Error('LocalFunctionCache.set - expected "ref" argument.');
              this._imageCache.has(n) || this._imageCache.put(n, i);
            }
          }
          o.LocalFunctionCache = y;
          class c extends v {
            set(g, n = null, i) {
              if (typeof g != "string")
                throw new Error('LocalGStateCache.set - expected "name" argument.');
              if (n) {
                if (this._imageCache.has(n))
                  return;
                this._nameRefMap.set(g, n), this._imageCache.put(n, i);
                return;
              }
              this._imageMap.has(g) || this._imageMap.set(g, i);
            }
          }
          o.LocalGStateCache = c;
          class d extends v {
            constructor(g) {
              super({
                onlyRefs: !0
              });
            }
            set(g = null, n, i) {
              if (!n)
                throw new Error('LocalTilingPatternCache.set - expected "ref" argument.');
              this._imageCache.has(n) || this._imageCache.put(n, i);
            }
          }
          o.LocalTilingPatternCache = d;
          class m {
            static get NUM_PAGES_THRESHOLD() {
              return (0, t.shadow)(this, "NUM_PAGES_THRESHOLD", 2);
            }
            static get MIN_IMAGES_TO_CACHE() {
              return (0, t.shadow)(this, "MIN_IMAGES_TO_CACHE", 10);
            }
            static get MAX_BYTE_SIZE() {
              return (0, t.shadow)(this, "MAX_BYTE_SIZE", 4e7);
            }
            constructor() {
              this._refCache = new a.RefSetCache(), this._imageCache = new a.RefSetCache();
            }
            get _byteSize() {
              let g = 0;
              for (const n of this._imageCache)
                g += n.byteSize;
              return g;
            }
            get _cacheLimitReached() {
              return !(this._imageCache.size < m.MIN_IMAGES_TO_CACHE || this._byteSize < m.MAX_BYTE_SIZE);
            }
            shouldCache(g, n) {
              const i = this._refCache.get(g);
              return !((i ? i.size + (i.has(n) ? 0 : 1) : 1) < m.NUM_PAGES_THRESHOLD || !this._imageCache.has(g) && this._cacheLimitReached);
            }
            addPageIndex(g, n) {
              let i = this._refCache.get(g);
              i || (i = /* @__PURE__ */ new Set(), this._refCache.put(g, i)), i.add(n);
            }
            addByteSize(g, n) {
              const i = this._imageCache.get(g);
              i && (i.byteSize || (i.byteSize = n));
            }
            getData(g, n) {
              const i = this._refCache.get(g);
              if (!i || i.size < m.NUM_PAGES_THRESHOLD)
                return null;
              const l = this._imageCache.get(g);
              return l ? (i.add(n), l) : null;
            }
            setData(g, n) {
              if (!this._refCache.has(g))
                throw new Error('GlobalImageCache.setData - expected "addPageIndex" to have been called.');
              if (!this._imageCache.has(g)) {
                if (this._cacheLimitReached) {
                  (0, t.warn)("GlobalImageCache.setData - cache limit reached.");
                  return;
                }
                this._imageCache.put(g, n);
              }
            }
            clear(g = !1) {
              g || this._refCache.clear(), this._imageCache.clear();
            }
          }
          o.GlobalImageCache = m;
        },
        /* 60 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.bidi = n;
          var t = F(2);
          const a = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "ON", "ON", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "ON", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "ON", "ET", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "L", "ON", "ON", "BN", "ON", "ON", "ET", "ET", "EN", "EN", "ON", "L", "ON", "ON", "ON", "EN", "L", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L"], v = ["AN", "AN", "AN", "AN", "AN", "AN", "ON", "ON", "AL", "ET", "ET", "AL", "CS", "AL", "ON", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "ON", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL"];
          function h(i) {
            return (i & 1) !== 0;
          }
          function e(i) {
            return (i & 1) === 0;
          }
          function y(i, l, u) {
            let w, O;
            for (w = l, O = i.length; w < O; ++w)
              if (i[w] !== u)
                return w;
            return w;
          }
          function c(i, l, u, w) {
            for (let O = l; O < u; ++O)
              i[O] = w;
          }
          function d(i, l, u) {
            for (let w = l, O = u - 1; w < O; ++w, --O) {
              const b = i[w];
              i[w] = i[O], i[O] = b;
            }
          }
          function m(i, l, u = !1) {
            let w = "ltr";
            return u ? w = "ttb" : l || (w = "rtl"), {
              str: i,
              dir: w
            };
          }
          const p = [], g = [];
          function n(i, l = -1, u = !1) {
            let w = !0;
            const O = i.length;
            if (O === 0 || u)
              return m(i, w, u);
            p.length = O, g.length = O;
            let b = 0, A, Y;
            for (A = 0; A < O; ++A) {
              p[A] = i.charAt(A);
              const S = i.charCodeAt(A);
              let C = "L";
              S <= 255 ? C = a[S] : 1424 <= S && S <= 1524 ? C = "R" : 1536 <= S && S <= 1791 ? (C = v[S & 255], C || (0, t.warn)("Bidi: invalid Unicode character " + S.toString(16))) : 1792 <= S && S <= 2220 && (C = "AL"), (C === "R" || C === "AL" || C === "AN") && b++, g[A] = C;
            }
            if (b === 0)
              return w = !0, m(i, w);
            l === -1 && (b / O < 0.3 && O > 4 ? (w = !0, l = 0) : (w = !1, l = 1));
            const j = [];
            for (A = 0; A < O; ++A)
              j[A] = l;
            const X = h(l) ? "R" : "L", B = X, U = B;
            let k = B;
            for (A = 0; A < O; ++A)
              g[A] === "NSM" ? g[A] = k : k = g[A];
            k = B;
            let x;
            for (A = 0; A < O; ++A)
              x = g[A], x === "EN" ? g[A] = k === "AL" ? "AN" : "EN" : (x === "R" || x === "L" || x === "AL") && (k = x);
            for (A = 0; A < O; ++A)
              x = g[A], x === "AL" && (g[A] = "R");
            for (A = 1; A < O - 1; ++A)
              g[A] === "ES" && g[A - 1] === "EN" && g[A + 1] === "EN" && (g[A] = "EN"), g[A] === "CS" && (g[A - 1] === "EN" || g[A - 1] === "AN") && g[A + 1] === g[A - 1] && (g[A] = g[A - 1]);
            for (A = 0; A < O; ++A)
              if (g[A] === "EN") {
                for (let S = A - 1; S >= 0 && g[S] === "ET"; --S)
                  g[S] = "EN";
                for (let S = A + 1; S < O && g[S] === "ET"; ++S)
                  g[S] = "EN";
              }
            for (A = 0; A < O; ++A)
              x = g[A], (x === "WS" || x === "ES" || x === "ET" || x === "CS") && (g[A] = "ON");
            for (k = B, A = 0; A < O; ++A)
              x = g[A], x === "EN" ? g[A] = k === "L" ? "L" : "EN" : (x === "R" || x === "L") && (k = x);
            for (A = 0; A < O; ++A)
              if (g[A] === "ON") {
                const S = y(g, A + 1, "ON");
                let C = B;
                A > 0 && (C = g[A - 1]);
                let T = U;
                S + 1 < O && (T = g[S + 1]), C !== "L" && (C = "R"), T !== "L" && (T = "R"), C === T && c(g, A, S, C), A = S - 1;
              }
            for (A = 0; A < O; ++A)
              g[A] === "ON" && (g[A] = X);
            for (A = 0; A < O; ++A)
              x = g[A], e(j[A]) ? x === "R" ? j[A] += 1 : (x === "AN" || x === "EN") && (j[A] += 2) : (x === "L" || x === "AN" || x === "EN") && (j[A] += 1);
            let f = -1, D = 99, _;
            for (A = 0, Y = j.length; A < Y; ++A)
              _ = j[A], f < _ && (f = _), D > _ && h(_) && (D = _);
            for (_ = f; _ >= D; --_) {
              let S = -1;
              for (A = 0, Y = j.length; A < Y; ++A)
                j[A] < _ ? S >= 0 && (d(p, S, A), S = -1) : S < 0 && (S = A);
              S >= 0 && d(p, S, j.length);
            }
            for (A = 0, Y = p.length; A < Y; ++A) {
              const S = p[A];
              (S === "<" || S === ">") && (p[A] = "");
            }
            return m(p.join(""), w);
          }
        },
        /* 61 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.MurmurHash3_64 = void 0;
          var t = F(2);
          const a = 3285377520, v = 4294901760, h = 65535;
          class e {
            constructor(c) {
              this.h1 = c ? c & 4294967295 : a, this.h2 = c ? c & 4294967295 : a;
            }
            update(c) {
              let d, m;
              if (typeof c == "string") {
                d = new Uint8Array(c.length * 2), m = 0;
                for (let j = 0, X = c.length; j < X; j++) {
                  const B = c.charCodeAt(j);
                  B <= 255 ? d[m++] = B : (d[m++] = B >>> 8, d[m++] = B & 255);
                }
              } else if ((0, t.isArrayBuffer)(c))
                d = c.slice(), m = d.byteLength;
              else
                throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");
              const p = m >> 2, g = m - p * 4, n = new Uint32Array(d.buffer, 0, p);
              let i = 0, l = 0, u = this.h1, w = this.h2;
              const O = 3432918353, b = 461845907, A = O & h, Y = b & h;
              for (let j = 0; j < p; j++)
                j & 1 ? (i = n[j], i = i * O & v | i * A & h, i = i << 15 | i >>> 17, i = i * b & v | i * Y & h, u ^= i, u = u << 13 | u >>> 19, u = u * 5 + 3864292196) : (l = n[j], l = l * O & v | l * A & h, l = l << 15 | l >>> 17, l = l * b & v | l * Y & h, w ^= l, w = w << 13 | w >>> 19, w = w * 5 + 3864292196);
              switch (i = 0, g) {
                case 3:
                  i ^= d[p * 4 + 2] << 16;
                case 2:
                  i ^= d[p * 4 + 1] << 8;
                case 1:
                  i ^= d[p * 4], i = i * O & v | i * A & h, i = i << 15 | i >>> 17, i = i * b & v | i * Y & h, p & 1 ? u ^= i : w ^= i;
              }
              this.h1 = u, this.h2 = w;
            }
            hexdigest() {
              let c = this.h1, d = this.h2;
              c ^= d >>> 1, c = c * 3981806797 & v | c * 36045 & h, d = d * 4283543511 & v | ((d << 16 | c >>> 16) * 2950163797 & v) >>> 16, c ^= d >>> 1, c = c * 444984403 & v | c * 60499 & h, d = d * 3301882366 & v | ((d << 16 | c >>> 16) * 3120437893 & v) >>> 16, c ^= d >>> 1;
              const m = (c >>> 0).toString(16), p = (d >>> 0).toString(16);
              return m.padStart(8, "0") + p.padStart(8, "0");
            }
          }
          o.MurmurHash3_64 = e;
        },
        /* 62 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.OperatorList = void 0;
          var t = F(2);
          function a(c, d, m, p, g) {
            let n = c;
            for (let i = 0, l = d.length - 1; i < l; i++) {
              const u = d[i];
              n = n[u] || (n[u] = []);
            }
            n[d.at(-1)] = {
              checkFn: m,
              iterateFn: p,
              processFn: g
            };
          }
          const v = [];
          a(v, [t.OPS.save, t.OPS.transform, t.OPS.paintInlineImageXObject, t.OPS.restore], null, function(d, m) {
            const p = d.fnArray, g = d.iCurr - 3, n = (m - g) % 4;
            switch (n) {
              case 0:
                return p[m] === t.OPS.save;
              case 1:
                return p[m] === t.OPS.transform;
              case 2:
                return p[m] === t.OPS.paintInlineImageXObject;
              case 3:
                return p[m] === t.OPS.restore;
            }
            throw new Error(`iterateInlineImageGroup - invalid pos: ${n}`);
          }, function(d, m) {
            const l = d.fnArray, u = d.argsArray, w = d.iCurr, O = w - 3, b = w - 2, A = w - 1, Y = Math.min(Math.floor((m - O) / 4), 200);
            if (Y < 10)
              return m - (m - O) % 4;
            let j = 0;
            const X = [];
            let B = 0, U = 1, k = 1;
            for (let S = 0; S < Y; S++) {
              const C = u[b + (S << 2)], T = u[A + (S << 2)][0];
              U + T.width > 1e3 && (j = Math.max(j, U), k += B + 2, U = 0, B = 0), X.push({
                transform: C,
                x: U,
                y: k,
                w: T.width,
                h: T.height
              }), U += T.width + 2, B = Math.max(B, T.height);
            }
            const x = Math.max(j, U) + 1, f = k + B + 1, D = new Uint8Array(x * f * 4), _ = x << 2;
            for (let S = 0; S < Y; S++) {
              const C = u[A + (S << 2)][0].data, T = X[S].w << 2;
              let P = 0, M = X[S].x + X[S].y * x << 2;
              D.set(C.subarray(0, T), M - _);
              for (let G = 0, Z = X[S].h; G < Z; G++)
                D.set(C.subarray(P, P + T), M), P += T, M += _;
              for (D.set(C.subarray(P - T, P), M); M >= 0; )
                C[M - 4] = C[M], C[M - 3] = C[M + 1], C[M - 2] = C[M + 2], C[M - 1] = C[M + 3], C[M + T] = C[M + T - 4], C[M + T + 1] = C[M + T - 3], C[M + T + 2] = C[M + T - 2], C[M + T + 3] = C[M + T - 1], M -= _;
            }
            return l.splice(O, Y * 4, t.OPS.paintInlineImageXObjectGroup), u.splice(O, Y * 4, [{
              width: x,
              height: f,
              kind: t.ImageKind.RGBA_32BPP,
              data: D
            }, X]), O + 1;
          }), a(v, [t.OPS.save, t.OPS.transform, t.OPS.paintImageMaskXObject, t.OPS.restore], null, function(d, m) {
            const p = d.fnArray, g = d.iCurr - 3, n = (m - g) % 4;
            switch (n) {
              case 0:
                return p[m] === t.OPS.save;
              case 1:
                return p[m] === t.OPS.transform;
              case 2:
                return p[m] === t.OPS.paintImageMaskXObject;
              case 3:
                return p[m] === t.OPS.restore;
            }
            throw new Error(`iterateImageMaskGroup - invalid pos: ${n}`);
          }, function(d, m) {
            const i = d.fnArray, l = d.argsArray, u = d.iCurr, w = u - 3, O = u - 2, b = u - 1;
            let A = Math.floor((m - w) / 4);
            if (A < 10)
              return m - (m - w) % 4;
            let Y = !1, j, X;
            const B = l[b][0], U = l[O][0], k = l[O][1], x = l[O][2], f = l[O][3];
            if (k === x) {
              Y = !0, j = O + 4;
              let D = b + 4;
              for (let _ = 1; _ < A; _++, j += 4, D += 4)
                if (X = l[j], l[D][0] !== B || X[0] !== U || X[1] !== k || X[2] !== x || X[3] !== f) {
                  _ < 10 ? Y = !1 : A = _;
                  break;
                }
            }
            if (Y) {
              A = Math.min(A, 1e3);
              const D = new Float32Array(A * 2);
              j = O;
              for (let _ = 0; _ < A; _++, j += 4)
                X = l[j], D[_ << 1] = X[4], D[(_ << 1) + 1] = X[5];
              i.splice(w, A * 4, t.OPS.paintImageMaskXObjectRepeat), l.splice(w, A * 4, [B, U, k, x, f, D]);
            } else {
              A = Math.min(A, 100);
              const D = [];
              for (let _ = 0; _ < A; _++) {
                X = l[O + (_ << 2)];
                const S = l[b + (_ << 2)][0];
                D.push({
                  data: S.data,
                  width: S.width,
                  height: S.height,
                  interpolate: S.interpolate,
                  count: S.count,
                  transform: X
                });
              }
              i.splice(w, A * 4, t.OPS.paintImageMaskXObjectGroup), l.splice(w, A * 4, [D]);
            }
            return w + 1;
          }), a(v, [t.OPS.save, t.OPS.transform, t.OPS.paintImageXObject, t.OPS.restore], function(c) {
            const d = c.argsArray, m = c.iCurr - 2;
            return d[m][1] === 0 && d[m][2] === 0;
          }, function(d, m) {
            const p = d.fnArray, g = d.argsArray, n = d.iCurr - 3, i = (m - n) % 4;
            switch (i) {
              case 0:
                return p[m] === t.OPS.save;
              case 1:
                if (p[m] !== t.OPS.transform)
                  return !1;
                const l = d.iCurr - 2, u = g[l][0], w = g[l][3];
                return !(g[m][0] !== u || g[m][1] !== 0 || g[m][2] !== 0 || g[m][3] !== w);
              case 2:
                if (p[m] !== t.OPS.paintImageXObject)
                  return !1;
                const O = d.iCurr - 1, b = g[O][0];
                return g[m][0] === b;
              case 3:
                return p[m] === t.OPS.restore;
            }
            throw new Error(`iterateImageGroup - invalid pos: ${i}`);
          }, function(c, d) {
            const g = c.fnArray, n = c.argsArray, i = c.iCurr, l = i - 3, u = i - 2, w = i - 1, O = n[w][0], b = n[u][0], A = n[u][3], Y = Math.min(Math.floor((d - l) / 4), 1e3);
            if (Y < 3)
              return d - (d - l) % 4;
            const j = new Float32Array(Y * 2);
            let X = u;
            for (let U = 0; U < Y; U++, X += 4) {
              const k = n[X];
              j[U << 1] = k[4], j[(U << 1) + 1] = k[5];
            }
            const B = [O, b, A, j];
            return g.splice(l, Y * 4, t.OPS.paintImageXObjectRepeat), n.splice(l, Y * 4, B), l + 1;
          }), a(v, [t.OPS.beginText, t.OPS.setFont, t.OPS.setTextMatrix, t.OPS.showText, t.OPS.endText], null, function(d, m) {
            const p = d.fnArray, g = d.argsArray, n = d.iCurr - 4, i = (m - n) % 5;
            switch (i) {
              case 0:
                return p[m] === t.OPS.beginText;
              case 1:
                return p[m] === t.OPS.setFont;
              case 2:
                return p[m] === t.OPS.setTextMatrix;
              case 3:
                if (p[m] !== t.OPS.showText)
                  return !1;
                const l = d.iCurr - 3, u = g[l][0], w = g[l][1];
                return !(g[m][0] !== u || g[m][1] !== w);
              case 4:
                return p[m] === t.OPS.endText;
            }
            throw new Error(`iterateShowTextGroup - invalid pos: ${i}`);
          }, function(c, d) {
            const g = c.fnArray, n = c.argsArray, i = c.iCurr, l = i - 4, u = i - 3, w = i - 2, O = i - 1, b = i, A = n[u][0], Y = n[u][1];
            let j = Math.min(Math.floor((d - l) / 5), 1e3);
            if (j < 3)
              return d - (d - l) % 5;
            let X = l;
            l >= 4 && g[l - 4] === g[u] && g[l - 3] === g[w] && g[l - 2] === g[O] && g[l - 1] === g[b] && n[l - 4][0] === A && n[l - 4][1] === Y && (j++, X -= 5);
            let B = X + 4;
            for (let U = 1; U < j; U++)
              g.splice(B, 3), n.splice(B, 3), B += 2;
            return B + 1;
          });
          class h {
            constructor(d) {
              this.queue = d;
            }
            _optimize() {
            }
            push(d, m) {
              this.queue.fnArray.push(d), this.queue.argsArray.push(m), this._optimize();
            }
            flush() {
            }
            reset() {
            }
          }
          class e extends h {
            constructor(d) {
              super(d), this.state = null, this.context = {
                iCurr: 0,
                fnArray: d.fnArray,
                argsArray: d.argsArray
              }, this.match = null, this.lastProcessed = 0;
            }
            _optimize() {
              const d = this.queue.fnArray;
              let m = this.lastProcessed, p = d.length, g = this.state, n = this.match;
              if (!g && !n && m + 1 === p && !v[d[m]]) {
                this.lastProcessed = p;
                return;
              }
              const i = this.context;
              for (; m < p; ) {
                if (n) {
                  if ((0, n.iterateFn)(i, m)) {
                    m++;
                    continue;
                  }
                  if (m = (0, n.processFn)(i, m + 1), p = d.length, n = null, g = null, m >= p)
                    break;
                }
                if (g = (g || v)[d[m]], !g || Array.isArray(g)) {
                  m++;
                  continue;
                }
                if (i.iCurr = m, m++, g.checkFn && !(0, g.checkFn)(i)) {
                  g = null;
                  continue;
                }
                n = g, g = null;
              }
              this.state = g, this.match = n, this.lastProcessed = m;
            }
            flush() {
              for (; this.match; ) {
                const d = this.queue.fnArray.length;
                this.lastProcessed = (0, this.match.processFn)(this.context, d), this.match = null, this.state = null, this._optimize();
              }
            }
            reset() {
              this.state = null, this.match = null, this.lastProcessed = 0;
            }
          }
          class y {
            static get CHUNK_SIZE() {
              return (0, t.shadow)(this, "CHUNK_SIZE", 1e3);
            }
            static get CHUNK_SIZE_ABOUT() {
              return (0, t.shadow)(this, "CHUNK_SIZE_ABOUT", this.CHUNK_SIZE - 5);
            }
            constructor(d = 0, m) {
              this._streamSink = m, this.fnArray = [], this.argsArray = [], m && !(d & t.RenderingIntentFlag.OPLIST) ? this.optimizer = new e(this) : this.optimizer = new h(this), this.dependencies = /* @__PURE__ */ new Set(), this._totalLength = 0, this.weight = 0, this._resolved = m ? null : Promise.resolve();
            }
            get length() {
              return this.argsArray.length;
            }
            get ready() {
              return this._resolved || this._streamSink.ready;
            }
            get totalLength() {
              return this._totalLength + this.length;
            }
            addOp(d, m) {
              this.optimizer.push(d, m), this.weight++, this._streamSink && (this.weight >= y.CHUNK_SIZE ? this.flush() : this.weight >= y.CHUNK_SIZE_ABOUT && (d === t.OPS.restore || d === t.OPS.endText) && this.flush());
            }
            addImageOps(d, m, p) {
              p !== void 0 && this.addOp(t.OPS.beginMarkedContentProps, ["OC", p]), this.addOp(d, m), p !== void 0 && this.addOp(t.OPS.endMarkedContent, []);
            }
            addDependency(d) {
              this.dependencies.has(d) || (this.dependencies.add(d), this.addOp(t.OPS.dependency, [d]));
            }
            addDependencies(d) {
              for (const m of d)
                this.addDependency(m);
            }
            addOpList(d) {
              if (!(d instanceof y)) {
                (0, t.warn)('addOpList - ignoring invalid "opList" parameter.');
                return;
              }
              for (const m of d.dependencies)
                this.dependencies.add(m);
              for (let m = 0, p = d.length; m < p; m++)
                this.addOp(d.fnArray[m], d.argsArray[m]);
            }
            getIR() {
              return {
                fnArray: this.fnArray,
                argsArray: this.argsArray,
                length: this.length
              };
            }
            get _transfers() {
              const d = [], {
                fnArray: m,
                argsArray: p,
                length: g
              } = this;
              for (let n = 0; n < g; n++)
                switch (m[n]) {
                  case t.OPS.paintInlineImageXObject:
                  case t.OPS.paintInlineImageXObjectGroup:
                  case t.OPS.paintImageMaskXObject:
                    const i = p[n][0];
                    !i.cached && i.data && i.data.buffer instanceof ArrayBuffer && d.push(i.data.buffer);
                    break;
                }
              return d;
            }
            flush(d = !1, m = null) {
              this.optimizer.flush();
              const p = this.length;
              this._totalLength += p, this._streamSink.enqueue({
                fnArray: this.fnArray,
                argsArray: this.argsArray,
                lastChunk: d,
                separateAnnots: m,
                length: p
              }, 1, this._transfers), this.dependencies.clear(), this.fnArray.length = 0, this.argsArray.length = 0, this.weight = 0, this.optimizer.reset();
            }
          }
          o.OperatorList = y;
        },
        /* 63 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.PDFImage = void 0;
          var t = F(2), a = F(64), v = F(7), h = F(14), e = F(19), y = F(27), c = F(30), d = F(5);
          function m(n, i, l, u) {
            return n = i + n * l, n < 0 ? n = 0 : n > u && (n = u), n;
          }
          function p(n, i, l, u, w, O) {
            const b = w * O;
            let A;
            i <= 8 ? A = new Uint8Array(b) : i <= 16 ? A = new Uint16Array(b) : A = new Uint32Array(b);
            const Y = l / w, j = u / O;
            let X, B, U, k = 0, x;
            const f = new Uint16Array(w), D = l;
            for (X = 0; X < w; X++)
              f[X] = Math.floor(X * Y);
            for (X = 0; X < O; X++)
              for (U = Math.floor(X * j) * D, B = 0; B < w; B++)
                x = U + f[B], A[k++] = n[x];
            return A;
          }
          class g {
            constructor({
              xref: i,
              res: l,
              image: u,
              isInline: w = !1,
              smask: O = null,
              mask: b = null,
              isMask: A = !1,
              pdfFunctionFactory: Y,
              localColorSpaceCache: j
            }) {
              this.image = u;
              const X = u.dict, B = X.get("F", "Filter");
              let U;
              if (B instanceof d.Name)
                U = B.name;
              else if (Array.isArray(B)) {
                const D = i.fetchIfRef(B[0]);
                D instanceof d.Name && (U = D.name);
              }
              switch (U) {
                case "JPXDecode":
                  const D = new c.JpxImage();
                  D.parseImageProperties(u.stream), u.stream.reset(), u.width = D.width, u.height = D.height, u.bitsPerComponent = D.bitsPerComponent, u.numComps = D.componentsCount;
                  break;
                case "JBIG2Decode":
                  u.bitsPerComponent = 1, u.numComps = 1;
                  break;
              }
              let k = X.get("W", "Width"), x = X.get("H", "Height");
              if (Number.isInteger(u.width) && u.width > 0 && Number.isInteger(u.height) && u.height > 0 && (u.width !== k || u.height !== x) && ((0, t.warn)("PDFImage - using the Width/Height of the image data, rather than the image dictionary."), k = u.width, x = u.height), k < 1 || x < 1)
                throw new t.FormatError(`Invalid image width: ${k} or height: ${x}`);
              this.width = k, this.height = x, this.interpolate = X.get("I", "Interpolate"), this.imageMask = X.get("IM", "ImageMask") || !1, this.matte = X.get("Matte") || !1;
              let f = u.bitsPerComponent;
              if (!f && (f = X.get("BPC", "BitsPerComponent"), !f))
                if (this.imageMask)
                  f = 1;
                else
                  throw new t.FormatError(`Bits per component missing in image: ${this.imageMask}`);
              if (this.bpc = f, !this.imageMask) {
                let D = X.getRaw("CS") || X.getRaw("ColorSpace");
                if (!D)
                  switch ((0, t.info)("JPX images (which do not require color spaces)"), u.numComps) {
                    case 1:
                      D = d.Name.get("DeviceGray");
                      break;
                    case 3:
                      D = d.Name.get("DeviceRGB");
                      break;
                    case 4:
                      D = d.Name.get("DeviceCMYK");
                      break;
                    default:
                      throw new Error(`JPX images with ${u.numComps} color components not supported.`);
                  }
                this.colorSpace = h.ColorSpace.parse({
                  cs: D,
                  xref: i,
                  resources: w ? l : null,
                  pdfFunctionFactory: Y,
                  localColorSpaceCache: j
                }), this.numComps = this.colorSpace.numComps;
              }
              if (this.decode = X.getArray("D", "Decode"), this.needsDecode = !1, this.decode && (this.colorSpace && !this.colorSpace.isDefaultDecode(this.decode, f) || A && !h.ColorSpace.isDefaultDecode(this.decode, 1))) {
                this.needsDecode = !0;
                const D = (1 << f) - 1;
                this.decodeCoefficients = [], this.decodeAddends = [];
                const _ = this.colorSpace && this.colorSpace.name === "Indexed";
                for (let S = 0, C = 0; S < this.decode.length; S += 2, ++C) {
                  const T = this.decode[S], P = this.decode[S + 1];
                  this.decodeCoefficients[C] = _ ? (P - T) / D : P - T, this.decodeAddends[C] = _ ? T : D * T;
                }
              }
              O ? this.smask = new g({
                xref: i,
                res: l,
                image: O,
                isInline: w,
                pdfFunctionFactory: Y,
                localColorSpaceCache: j
              }) : b && (b instanceof v.BaseStream ? b.dict.get("IM", "ImageMask") ? this.mask = new g({
                xref: i,
                res: l,
                image: b,
                isInline: w,
                isMask: !0,
                pdfFunctionFactory: Y,
                localColorSpaceCache: j
              }) : (0, t.warn)("Ignoring /Mask in image without /ImageMask.") : this.mask = b);
            }
            static async buildImage({
              xref: i,
              res: l,
              image: u,
              isInline: w = !1,
              pdfFunctionFactory: O,
              localColorSpaceCache: b
            }) {
              const A = u;
              let Y = null, j = null;
              const X = u.dict.get("SMask"), B = u.dict.get("Mask");
              return X ? X instanceof v.BaseStream ? Y = X : (0, t.warn)("Unsupported /SMask format.") : B && (B instanceof v.BaseStream || Array.isArray(B) ? j = B : (0, t.warn)("Unsupported /Mask format.")), new g({
                xref: i,
                res: l,
                image: A,
                isInline: w,
                smask: Y,
                mask: j,
                pdfFunctionFactory: O,
                localColorSpaceCache: b
              });
            }
            static createRawMask({
              imgArray: i,
              width: l,
              height: u,
              imageIsFromDecodeStream: w,
              inverseDecode: O,
              interpolate: b
            }) {
              const A = (l + 7 >> 3) * u, Y = i.byteLength, j = A === Y;
              let X, B;
              if (w && (!O || j) ? X = i : O ? (X = new Uint8Array(A), X.set(i), X.fill(255, Y)) : X = new Uint8Array(i), O)
                for (B = 0; B < Y; B++)
                  X[B] ^= 255;
              return {
                data: X,
                width: l,
                height: u,
                interpolate: b
              };
            }
            static createMask({
              imgArray: i,
              width: l,
              height: u,
              imageIsFromDecodeStream: w,
              inverseDecode: O,
              interpolate: b
            }) {
              const A = l === 1 && u === 1 && O === (i.length === 0 || !!(i[0] & 128));
              if (A)
                return {
                  isSingleOpaquePixel: A
                };
              if (t.FeatureTest.isOffscreenCanvasSupported) {
                const Y = new OffscreenCanvas(l, u), j = Y.getContext("2d"), X = j.createImageData(l, u);
                (0, a.applyMaskImageData)({
                  src: i,
                  dest: X.data,
                  width: l,
                  height: u,
                  inverseDecode: O
                }), j.putImageData(X, 0, 0);
                const B = Y.transferToImageBitmap();
                return {
                  data: null,
                  width: l,
                  height: u,
                  interpolate: b,
                  bitmap: B
                };
              }
              return this.createRawMask({
                imgArray: i,
                width: l,
                height: u,
                inverseDecode: O,
                imageIsFromDecodeStream: w,
                interpolate: b
              });
            }
            get drawWidth() {
              return Math.max(this.width, this.smask && this.smask.width || 0, this.mask && this.mask.width || 0);
            }
            get drawHeight() {
              return Math.max(this.height, this.smask && this.smask.height || 0, this.mask && this.mask.height || 0);
            }
            decodeBuffer(i) {
              const l = this.bpc, u = this.numComps, w = this.decodeAddends, O = this.decodeCoefficients, b = (1 << l) - 1;
              let A, Y;
              if (l === 1) {
                for (A = 0, Y = i.length; A < Y; A++)
                  i[A] = +!i[A];
                return;
              }
              let j = 0;
              for (A = 0, Y = this.width * this.height; A < Y; A++)
                for (let X = 0; X < u; X++)
                  i[j] = m(i[j], w[X], O[X], b), j++;
            }
            getComponents(i) {
              const l = this.bpc;
              if (l === 8)
                return i;
              const u = this.width, w = this.height, O = this.numComps, b = u * w * O;
              let A = 0, Y;
              l <= 8 ? Y = new Uint8Array(b) : l <= 16 ? Y = new Uint16Array(b) : Y = new Uint32Array(b);
              const j = u * O, X = (1 << l) - 1;
              let B = 0, U, k;
              if (l === 1) {
                let x, f, D;
                for (let _ = 0; _ < w; _++) {
                  for (f = B + (j & -8), D = B + j; B < f; )
                    k = i[A++], Y[B] = k >> 7 & 1, Y[B + 1] = k >> 6 & 1, Y[B + 2] = k >> 5 & 1, Y[B + 3] = k >> 4 & 1, Y[B + 4] = k >> 3 & 1, Y[B + 5] = k >> 2 & 1, Y[B + 6] = k >> 1 & 1, Y[B + 7] = k & 1, B += 8;
                  if (B < D)
                    for (k = i[A++], x = 128; B < D; )
                      Y[B++] = +!!(k & x), x >>= 1;
                }
              } else {
                let x = 0;
                for (k = 0, B = 0, U = b; B < U; ++B) {
                  for (B % j === 0 && (k = 0, x = 0); x < l; )
                    k = k << 8 | i[A++], x += 8;
                  const f = x - l;
                  let D = k >> f;
                  D < 0 ? D = 0 : D > X && (D = X), Y[B] = D, k &= (1 << f) - 1, x = f;
                }
              }
              return Y;
            }
            fillOpacity(i, l, u, w, O) {
              const b = this.smask, A = this.mask;
              let Y, j, X, B, U, k;
              if (b)
                j = b.width, X = b.height, Y = new Uint8ClampedArray(j * X), b.fillGrayBuffer(Y), (j !== l || X !== u) && (Y = p(Y, b.bpc, j, X, l, u));
              else if (A)
                if (A instanceof g) {
                  for (j = A.width, X = A.height, Y = new Uint8ClampedArray(j * X), A.numComps = 1, A.fillGrayBuffer(Y), B = 0, U = j * X; B < U; ++B)
                    Y[B] = 255 - Y[B];
                  (j !== l || X !== u) && (Y = p(Y, A.bpc, j, X, l, u));
                } else if (Array.isArray(A)) {
                  Y = new Uint8ClampedArray(l * u);
                  const x = this.numComps;
                  for (B = 0, U = l * u; B < U; ++B) {
                    let f = 0;
                    const D = B * x;
                    for (k = 0; k < x; ++k) {
                      const _ = O[D + k], S = k * 2;
                      if (_ < A[S] || _ > A[S + 1]) {
                        f = 255;
                        break;
                      }
                    }
                    Y[B] = f;
                  }
                } else
                  throw new t.FormatError("Unknown mask format.");
              if (Y)
                for (B = 0, k = 3, U = l * w; B < U; ++B, k += 4)
                  i[k] = Y[B];
              else
                for (B = 0, k = 3, U = l * w; B < U; ++B, k += 4)
                  i[k] = 255;
            }
            undoPreblend(i, l, u) {
              const w = this.smask && this.smask.matte;
              if (!w)
                return;
              const O = this.colorSpace.getRgb(w, 0), b = O[0], A = O[1], Y = O[2], j = l * u * 4;
              for (let X = 0; X < j; X += 4) {
                const B = i[X + 3];
                if (B === 0) {
                  i[X] = 255, i[X + 1] = 255, i[X + 2] = 255;
                  continue;
                }
                const U = 255 / B;
                i[X] = (i[X] - b) * U + b, i[X + 1] = (i[X + 1] - A) * U + A, i[X + 2] = (i[X + 2] - Y) * U + Y;
              }
            }
            createImageData(i = !1) {
              const l = this.drawWidth, u = this.drawHeight, w = {
                width: l,
                height: u,
                interpolate: this.interpolate,
                kind: 0,
                data: null
              }, O = this.numComps, b = this.width, A = this.height, Y = this.bpc, j = b * O * Y + 7 >> 3;
              if (!i) {
                let f;
                if (this.colorSpace.name === "DeviceGray" && Y === 1 ? f = t.ImageKind.GRAYSCALE_1BPP : this.colorSpace.name === "DeviceRGB" && Y === 8 && !this.needsDecode && (f = t.ImageKind.RGB_24BPP), f && !this.smask && !this.mask && l === b && u === A) {
                  if (w.kind = f, w.data = this.getImageBytes(A * j, {}), this.needsDecode) {
                    (0, t.assert)(f === t.ImageKind.GRAYSCALE_1BPP, "PDFImage.createImageData: The image must be grayscale.");
                    const D = w.data;
                    for (let _ = 0, S = D.length; _ < S; _++)
                      D[_] ^= 255;
                  }
                  return w;
                }
                if (this.image instanceof y.JpegStream && !this.smask && !this.mask) {
                  let D = A * j;
                  switch (this.colorSpace.name) {
                    case "DeviceGray":
                      D *= 3;
                    case "DeviceRGB":
                    case "DeviceCMYK":
                      return w.kind = t.ImageKind.RGB_24BPP, w.data = this.getImageBytes(D, {
                        drawWidth: l,
                        drawHeight: u,
                        forceRGB: !0
                      }), w;
                  }
                }
              }
              const X = this.getImageBytes(A * j, {
                internal: !0
              }), B = 0 | X.length / j * u / A, U = this.getComponents(X);
              let k, x;
              return !i && !this.smask && !this.mask ? (w.kind = t.ImageKind.RGB_24BPP, w.data = new Uint8ClampedArray(l * u * 3), k = 0, x = !1) : (w.kind = t.ImageKind.RGBA_32BPP, w.data = new Uint8ClampedArray(l * u * 4), k = 1, x = !0, this.fillOpacity(w.data, l, u, B, U)), this.needsDecode && this.decodeBuffer(U), this.colorSpace.fillRgb(w.data, b, A, l, u, B, Y, U, k), x && this.undoPreblend(w.data, l, B), w;
            }
            fillGrayBuffer(i) {
              const l = this.numComps;
              if (l !== 1)
                throw new t.FormatError(`Reading gray scale from a color image: ${l}`);
              const u = this.width, w = this.height, O = this.bpc, b = u * l * O + 7 >> 3, A = this.getImageBytes(w * b, {
                internal: !0
              }), Y = this.getComponents(A);
              let j, X;
              if (O === 1) {
                if (X = u * w, this.needsDecode)
                  for (j = 0; j < X; ++j)
                    i[j] = Y[j] - 1 & 255;
                else
                  for (j = 0; j < X; ++j)
                    i[j] = -Y[j] & 255;
                return;
              }
              this.needsDecode && this.decodeBuffer(Y), X = u * w;
              const B = 255 / ((1 << O) - 1);
              for (j = 0; j < X; ++j)
                i[j] = B * Y[j];
            }
            getImageBytes(i, {
              drawWidth: l,
              drawHeight: u,
              forceRGB: w = !1,
              internal: O = !1
            }) {
              this.image.reset(), this.image.drawWidth = l || this.width, this.image.drawHeight = u || this.height, this.image.forceRGB = !!w;
              const b = this.image.getBytes(i);
              return O || this.image instanceof e.DecodeStream ? b : ((0, t.assert)(b instanceof Uint8Array, 'PDFImage.getImageBytes: Unsupported "imageBytes" type.'), new Uint8Array(b));
            }
          }
          o.PDFImage = g;
        },
        /* 64 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.applyMaskImageData = a;
          var t = F(2);
          function a({
            src: v,
            srcPos: h = 0,
            dest: e,
            destPos: y = 0,
            width: c,
            height: d,
            inverseDecode: m = !1
          }) {
            const p = t.FeatureTest.isLittleEndian ? 4278190080 : 255, [g, n] = m ? [0, p] : [p, 0], i = c >> 3, l = c & 7, u = v.length;
            e = new Uint32Array(e.buffer);
            for (let w = 0; w < d; w++) {
              for (const b = h + i; h < b; h++) {
                const A = h < u ? v[h] : 255;
                e[y++] = A & 128 ? n : g, e[y++] = A & 64 ? n : g, e[y++] = A & 32 ? n : g, e[y++] = A & 16 ? n : g, e[y++] = A & 8 ? n : g, e[y++] = A & 4 ? n : g, e[y++] = A & 2 ? n : g, e[y++] = A & 1 ? n : g;
              }
              if (l === 0)
                continue;
              const O = h < u ? v[h++] : 255;
              for (let b = 0; b < l; b++)
                e[y++] = O & 1 << 7 - b ? n : g;
            }
            return {
              srcPos: h,
              destPos: y
            };
          }
        },
        /* 65 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.incrementalUpdate = O, o.writeDict = d, o.writeObject = c;
          var t = F(2), a = F(5), v = F(6), h = F(66), e = F(7), y = F(67);
          function c(b, A, Y, j) {
            Y.push(`${b.num} ${b.gen} obj
`), A instanceof a.Dict ? d(A, Y, j) : A instanceof e.BaseStream && m(A, Y, j), Y.push(`
endobj
`);
          }
          function d(b, A, Y) {
            A.push("<<");
            for (const j of b.getKeys())
              A.push(` /${(0, v.escapePDFName)(j)} `), g(b.getRaw(j), A, Y);
            A.push(">>");
          }
          function m(b, A, Y) {
            d(b.dict, A, Y), A.push(` stream
`);
            let j = b.getString();
            Y !== null && (j = Y.encryptString(j)), A.push(j, `
endstream
`);
          }
          function p(b, A, Y) {
            A.push("[");
            let j = !0;
            for (const X of b)
              j ? j = !1 : A.push(" "), g(X, A, Y);
            A.push("]");
          }
          function g(b, A, Y) {
            b instanceof a.Name ? A.push(`/${(0, v.escapePDFName)(b.name)}`) : b instanceof a.Ref ? A.push(`${b.num} ${b.gen} R`) : Array.isArray(b) ? p(b, A, Y) : typeof b == "string" ? (Y !== null && (b = Y.encryptString(b)), A.push(`(${(0, t.escapeString)(b)})`)) : typeof b == "number" ? A.push((0, v.numberToString)(b)) : typeof b == "boolean" ? A.push(b.toString()) : b instanceof a.Dict ? d(b, A, Y) : b instanceof e.BaseStream ? m(b, A, Y) : b === null ? A.push("null") : (0, t.warn)(`Unhandled value in writer: ${typeof b}, please file a bug.`);
          }
          function n(b, A, Y, j) {
            for (let X = A + Y - 1; X > Y - 1; X--)
              j[X] = b & 255, b >>= 8;
            return Y + A;
          }
          function i(b, A, Y) {
            for (let j = 0, X = b.length; j < X; j++)
              Y[A + j] = b.charCodeAt(j) & 255;
          }
          function l(b, A) {
            const Y = Math.floor(Date.now() / 1e3), j = A.filename || "", X = [Y.toString(), j, b.toString()];
            let B = X.reduce((x, f) => x + f.length, 0);
            for (const x of Object.values(A.info))
              X.push(x), B += x.length;
            const U = new Uint8Array(B);
            let k = 0;
            for (const x of X)
              i(x, k, U), k += x.length;
            return (0, t.bytesToString)((0, y.calculateMD5)(U));
          }
          function u(b, A) {
            const Y = new h.SimpleXMLParser({
              hasAttributes: !0
            }).parseFromString(b);
            for (const {
              xfa: X
            } of A) {
              if (!X)
                continue;
              const {
                path: B,
                value: U
              } = X;
              if (!B)
                continue;
              const k = Y.documentElement.searchNode((0, v.parseXFAPath)(B), 0);
              k ? Array.isArray(U) ? k.childNodes = U.map((x) => new h.SimpleDOMNode("value", x)) : k.childNodes = [new h.SimpleDOMNode("#text", U)] : (0, t.warn)(`Node not found for path: ${B}`);
            }
            const j = [];
            return Y.documentElement.dump(j), j.join("");
          }
          function w({
            xfaData: b,
            xfaDatasetsRef: A,
            hasXfaDatasetsEntry: Y,
            acroFormRef: j,
            acroForm: X,
            newRefs: B,
            xref: U,
            xrefInfo: k
          }) {
            if (U === null)
              return;
            if (!Y) {
              if (!j) {
                (0, t.warn)("XFA - Cannot save it");
                return;
              }
              const D = X.get("XFA"), _ = D.slice();
              _.splice(2, 0, "datasets"), _.splice(3, 0, A), X.set("XFA", _);
              const S = U.encrypt;
              let C = null;
              S && (C = S.createCipherTransform(j.num, j.gen));
              const T = [`${j.num} ${j.gen} obj
`];
              d(X, T, C), T.push(`
`), X.set("XFA", D), B.push({
                ref: j,
                data: T.join("")
              });
            }
            if (b === null) {
              const D = U.fetchIfRef(A);
              b = u(D.getString(), B);
            }
            const x = U.encrypt;
            x && (b = x.createCipherTransform(A.num, A.gen).encryptString(b));
            const f = `${A.num} ${A.gen} obj
<< /Type /EmbeddedFile /Length ${b.length}>>
stream
` + b + `
endstream
endobj
`;
            B.push({
              ref: A,
              data: f
            });
          }
          function O({
            originalData: b,
            xrefInfo: A,
            newRefs: Y,
            xref: j = null,
            hasXfa: X = !1,
            xfaDatasetsRef: B = null,
            hasXfaDatasetsEntry: U = !1,
            acroFormRef: k = null,
            acroForm: x = null,
            xfaData: f = null
          }) {
            X && w({
              xfaData: f,
              xfaDatasetsRef: B,
              hasXfaDatasetsEntry: U,
              acroFormRef: k,
              acroForm: x,
              newRefs: Y,
              xref: j,
              xrefInfo: A
            });
            const D = new a.Dict(null), _ = A.newRef;
            let S, C;
            const T = b.at(-1);
            T === 10 || T === 13 ? (S = [], C = b.length) : (S = [`
`], C = b.length + 1), D.set("Size", _.num + 1), D.set("Prev", A.startXRef), D.set("Type", a.Name.get("XRef")), A.rootRef !== null && D.set("Root", A.rootRef), A.infoRef !== null && D.set("Info", A.infoRef), A.encryptRef !== null && D.set("Encrypt", A.encryptRef), Y.push({
              ref: _,
              data: ""
            }), Y = Y.sort((q, N) => q.ref.num - N.ref.num);
            const P = [[0, 1, 65535]], M = [0, 1];
            let G = 0;
            for (const {
              ref: q,
              data: N
            } of Y)
              G = Math.max(G, C), P.push([1, C, Math.min(q.gen, 65535)]), C += N.length, M.push(q.num, 1), S.push(N);
            if (D.set("Index", M), Array.isArray(A.fileIds) && A.fileIds.length > 0) {
              const q = l(C, A);
              D.set("ID", [A.fileIds[0], q]);
            }
            const $ = [1, Math.ceil(Math.log2(G) / 8), 2], V = ($[0] + $[1] + $[2]) * P.length;
            D.set("W", $), D.set("Length", V), S.push(`${_.num} ${_.gen} obj
`), d(D, S, null), S.push(` stream
`);
            const L = S.reduce((q, N) => q + N.length, 0), K = `
endstream
endobj
startxref
${C}
%%EOF
`, ne = new Uint8Array(b.length + L + V + K.length);
            ne.set(b);
            let se = b.length;
            for (const q of S)
              i(q, se, ne), se += q.length;
            for (const [q, N, Q] of P)
              se = n(q, $[0], se, ne), se = n(N, $[1], se, ne), se = n(Q, $[2], se, ne);
            return i(K, se, ne), ne;
          }
        },
        /* 66 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.XMLParserErrorCode = o.XMLParserBase = o.SimpleXMLParser = o.SimpleDOMNode = void 0;
          var t = F(6);
          const a = {
            NoError: 0,
            EndOfDocument: -1,
            UnterminatedCdat: -2,
            UnterminatedXmlDeclaration: -3,
            UnterminatedDoctypeDeclaration: -4,
            UnterminatedComment: -5,
            MalformedElement: -6,
            OutOfMemory: -7,
            UnterminatedAttributeValue: -8,
            UnterminatedElement: -9,
            ElementNeverBegun: -10
          };
          o.XMLParserErrorCode = a;
          function v(d, m) {
            const p = d[m];
            return p === " " || p === `
` || p === "\r" || p === "	";
          }
          function h(d) {
            for (let m = 0, p = d.length; m < p; m++)
              if (!v(d, m))
                return !1;
            return !0;
          }
          class e {
            _resolveEntities(m) {
              return m.replace(/&([^;]+);/g, (p, g) => {
                if (g.substring(0, 2) === "#x")
                  return String.fromCodePoint(parseInt(g.substring(2), 16));
                if (g.substring(0, 1) === "#")
                  return String.fromCodePoint(parseInt(g.substring(1), 10));
                switch (g) {
                  case "lt":
                    return "<";
                  case "gt":
                    return ">";
                  case "amp":
                    return "&";
                  case "quot":
                    return '"';
                  case "apos":
                    return "'";
                }
                return this.onResolveEntity(g);
              });
            }
            _parseContent(m, p) {
              const g = [];
              let n = p;
              function i() {
                for (; n < m.length && v(m, n); )
                  ++n;
              }
              for (; n < m.length && !v(m, n) && m[n] !== ">" && m[n] !== "/"; )
                ++n;
              const l = m.substring(p, n);
              for (i(); n < m.length && m[n] !== ">" && m[n] !== "/" && m[n] !== "?"; ) {
                i();
                let u = "", w = "";
                for (; n < m.length && !v(m, n) && m[n] !== "="; )
                  u += m[n], ++n;
                if (i(), m[n] !== "=")
                  return null;
                ++n, i();
                const O = m[n];
                if (O !== '"' && O !== "'")
                  return null;
                const b = m.indexOf(O, ++n);
                if (b < 0)
                  return null;
                w = m.substring(n, b), g.push({
                  name: u,
                  value: this._resolveEntities(w)
                }), n = b + 1, i();
              }
              return {
                name: l,
                attributes: g,
                parsed: n - p
              };
            }
            _parseProcessingInstruction(m, p) {
              let g = p;
              function n() {
                for (; g < m.length && v(m, g); )
                  ++g;
              }
              for (; g < m.length && !v(m, g) && m[g] !== ">" && m[g] !== "?" && m[g] !== "/"; )
                ++g;
              const i = m.substring(p, g);
              n();
              const l = g;
              for (; g < m.length && (m[g] !== "?" || m[g + 1] !== ">"); )
                ++g;
              const u = m.substring(l, g);
              return {
                name: i,
                value: u,
                parsed: g - p
              };
            }
            parseXml(m) {
              let p = 0;
              for (; p < m.length; ) {
                const g = m[p];
                let n = p;
                if (g === "<") {
                  ++n;
                  const i = m[n];
                  let l;
                  switch (i) {
                    case "/":
                      if (++n, l = m.indexOf(">", n), l < 0) {
                        this.onError(a.UnterminatedElement);
                        return;
                      }
                      this.onEndElement(m.substring(n, l)), n = l + 1;
                      break;
                    case "?":
                      ++n;
                      const u = this._parseProcessingInstruction(m, n);
                      if (m.substring(n + u.parsed, n + u.parsed + 2) !== "?>") {
                        this.onError(a.UnterminatedXmlDeclaration);
                        return;
                      }
                      this.onPi(u.name, u.value), n += u.parsed + 2;
                      break;
                    case "!":
                      if (m.substring(n + 1, n + 3) === "--") {
                        if (l = m.indexOf("-->", n + 3), l < 0) {
                          this.onError(a.UnterminatedComment);
                          return;
                        }
                        this.onComment(m.substring(n + 3, l)), n = l + 3;
                      } else if (m.substring(n + 1, n + 8) === "[CDATA[") {
                        if (l = m.indexOf("]]>", n + 8), l < 0) {
                          this.onError(a.UnterminatedCdat);
                          return;
                        }
                        this.onCdata(m.substring(n + 8, l)), n = l + 3;
                      } else if (m.substring(n + 1, n + 8) === "DOCTYPE") {
                        const b = m.indexOf("[", n + 8);
                        let A = !1;
                        if (l = m.indexOf(">", n + 8), l < 0) {
                          this.onError(a.UnterminatedDoctypeDeclaration);
                          return;
                        }
                        if (b > 0 && l > b) {
                          if (l = m.indexOf("]>", n + 8), l < 0) {
                            this.onError(a.UnterminatedDoctypeDeclaration);
                            return;
                          }
                          A = !0;
                        }
                        const Y = m.substring(n + 8, l + (A ? 1 : 0));
                        this.onDoctype(Y), n = l + (A ? 2 : 1);
                      } else {
                        this.onError(a.MalformedElement);
                        return;
                      }
                      break;
                    default:
                      const w = this._parseContent(m, n);
                      if (w === null) {
                        this.onError(a.MalformedElement);
                        return;
                      }
                      let O = !1;
                      if (m.substring(n + w.parsed, n + w.parsed + 2) === "/>")
                        O = !0;
                      else if (m.substring(n + w.parsed, n + w.parsed + 1) !== ">") {
                        this.onError(a.UnterminatedElement);
                        return;
                      }
                      this.onBeginElement(w.name, w.attributes, O), n += w.parsed + (O ? 2 : 1);
                      break;
                  }
                } else {
                  for (; n < m.length && m[n] !== "<"; )
                    n++;
                  const i = m.substring(p, n);
                  this.onText(this._resolveEntities(i));
                }
                p = n;
              }
            }
            onResolveEntity(m) {
              return `&${m};`;
            }
            onPi(m, p) {
            }
            onComment(m) {
            }
            onCdata(m) {
            }
            onDoctype(m) {
            }
            onText(m) {
            }
            onBeginElement(m, p, g) {
            }
            onEndElement(m) {
            }
            onError(m) {
            }
          }
          o.XMLParserBase = e;
          class y {
            constructor(m, p) {
              this.nodeName = m, this.nodeValue = p, Object.defineProperty(this, "parentNode", {
                value: null,
                writable: !0
              });
            }
            get firstChild() {
              return this.childNodes && this.childNodes[0];
            }
            get nextSibling() {
              const m = this.parentNode.childNodes;
              if (!m)
                return;
              const p = m.indexOf(this);
              if (p !== -1)
                return m[p + 1];
            }
            get textContent() {
              return this.childNodes ? this.childNodes.map(function(m) {
                return m.textContent;
              }).join("") : this.nodeValue || "";
            }
            get children() {
              return this.childNodes || [];
            }
            hasChildNodes() {
              return this.childNodes && this.childNodes.length > 0;
            }
            searchNode(m, p) {
              if (p >= m.length)
                return this;
              const g = m[p], n = [];
              let i = this;
              for (; ; ) {
                if (g.name === i.nodeName)
                  if (g.pos === 0) {
                    const l = i.searchNode(m, p + 1);
                    if (l !== null)
                      return l;
                  } else {
                    if (n.length === 0)
                      return null;
                    {
                      const [l] = n.pop();
                      let u = 0;
                      for (const w of l.childNodes)
                        if (g.name === w.nodeName) {
                          if (u === g.pos)
                            return w.searchNode(m, p + 1);
                          u++;
                        }
                      return i.searchNode(m, p + 1);
                    }
                  }
                if (i.childNodes && i.childNodes.length !== 0)
                  n.push([i, 0]), i = i.childNodes[0];
                else {
                  if (n.length === 0)
                    return null;
                  for (; n.length !== 0; ) {
                    const [l, u] = n.pop(), w = u + 1;
                    if (w < l.childNodes.length) {
                      n.push([l, w]), i = l.childNodes[w];
                      break;
                    }
                  }
                  if (n.length === 0)
                    return null;
                }
              }
            }
            dump(m) {
              if (this.nodeName === "#text") {
                m.push((0, t.encodeToXmlString)(this.nodeValue));
                return;
              }
              if (m.push(`<${this.nodeName}`), this.attributes)
                for (const p of this.attributes)
                  m.push(` ${p.name}="${(0, t.encodeToXmlString)(p.value)}"`);
              if (this.hasChildNodes()) {
                m.push(">");
                for (const p of this.childNodes)
                  p.dump(m);
                m.push(`</${this.nodeName}>`);
              } else
                this.nodeValue ? m.push(`>${(0, t.encodeToXmlString)(this.nodeValue)}</${this.nodeName}>`) : m.push("/>");
            }
          }
          o.SimpleDOMNode = y;
          class c extends e {
            constructor({
              hasAttributes: m = !1,
              lowerCaseName: p = !1
            }) {
              super(), this._currentFragment = null, this._stack = null, this._errorCode = a.NoError, this._hasAttributes = m, this._lowerCaseName = p;
            }
            parseFromString(m) {
              if (this._currentFragment = [], this._stack = [], this._errorCode = a.NoError, this.parseXml(m), this._errorCode !== a.NoError)
                return;
              const [p] = this._currentFragment;
              if (p)
                return {
                  documentElement: p
                };
            }
            onText(m) {
              if (h(m))
                return;
              const p = new y("#text", m);
              this._currentFragment.push(p);
            }
            onCdata(m) {
              const p = new y("#text", m);
              this._currentFragment.push(p);
            }
            onBeginElement(m, p, g) {
              this._lowerCaseName && (m = m.toLowerCase());
              const n = new y(m);
              n.childNodes = [], this._hasAttributes && (n.attributes = p), this._currentFragment.push(n), !g && (this._stack.push(this._currentFragment), this._currentFragment = n.childNodes);
            }
            onEndElement(m) {
              this._currentFragment = this._stack.pop() || [];
              const p = this._currentFragment.at(-1);
              if (!p)
                return null;
              for (let g = 0, n = p.childNodes.length; g < n; g++)
                p.childNodes[g].parentNode = p;
              return p;
            }
            onError(m) {
              this._errorCode = m;
            }
          }
          o.SimpleXMLParser = c;
        },
        /* 67 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.calculateSHA256 = o.calculateMD5 = o.PDF20 = o.PDF17 = o.CipherTransformFactory = o.ARCFourCipher = o.AES256Cipher = o.AES128Cipher = void 0, o.calculateSHA384 = m, o.calculateSHA512 = void 0;
          var t = F(2), a = F(5), v = F(68);
          class h {
            constructor(A) {
              this.a = 0, this.b = 0;
              const Y = new Uint8Array(256), j = A.length;
              for (let X = 0; X < 256; ++X)
                Y[X] = X;
              for (let X = 0, B = 0; X < 256; ++X) {
                const U = Y[X];
                B = B + U + A[X % j] & 255, Y[X] = Y[B], Y[B] = U;
              }
              this.s = Y;
            }
            encryptBlock(A) {
              let Y = this.a, j = this.b;
              const X = this.s, B = A.length, U = new Uint8Array(B);
              for (let k = 0; k < B; ++k) {
                Y = Y + 1 & 255;
                const x = X[Y];
                j = j + x & 255;
                const f = X[j];
                X[Y] = f, X[j] = x, U[k] = A[k] ^ X[x + f & 255];
              }
              return this.a = Y, this.b = j, U;
            }
            decryptBlock(A) {
              return this.encryptBlock(A);
            }
            encrypt(A) {
              return this.encryptBlock(A);
            }
          }
          o.ARCFourCipher = h;
          const e = function() {
            const A = new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]), Y = new Int32Array([-680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341, -45705983, 1770035416, -1958414417, -42063, -1990404162, 1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632, 643717713, -373897302, -701558691, 38016083, -660478335, -405537848, 568446438, -1019803690, -187363961, 1163531501, -1444681467, -51403784, 1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556, -1530992060, 1272893353, -155497632, -1094730640, 681279174, -358537222, -722521979, 76029189, -640364487, -421815835, 530742520, -995338651, -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606, -1051523, -2054922799, 1873313359, -30611744, -1560198380, 1309151649, -145523070, -1120210379, 718787259, -343485551]);
            function j(X, B, U) {
              let k = 1732584193, x = -271733879, f = -1732584194, D = 271733878;
              const _ = U + 72 & -64, S = new Uint8Array(_);
              let C, T;
              for (C = 0; C < U; ++C)
                S[C] = X[B++];
              S[C++] = 128;
              const P = _ - 8;
              for (; C < P; )
                S[C++] = 0;
              S[C++] = U << 3 & 255, S[C++] = U >> 5 & 255, S[C++] = U >> 13 & 255, S[C++] = U >> 21 & 255, S[C++] = U >>> 29 & 255, S[C++] = 0, S[C++] = 0, S[C++] = 0;
              const M = new Int32Array(16);
              for (C = 0; C < _; ) {
                for (T = 0; T < 16; ++T, C += 4)
                  M[T] = S[C] | S[C + 1] << 8 | S[C + 2] << 16 | S[C + 3] << 24;
                let G = k, Z = x, $ = f, z = D, V, L;
                for (T = 0; T < 64; ++T) {
                  T < 16 ? (V = Z & $ | ~Z & z, L = T) : T < 32 ? (V = z & Z | ~z & $, L = 5 * T + 1 & 15) : T < 48 ? (V = Z ^ $ ^ z, L = 3 * T + 5 & 15) : (V = $ ^ (Z | ~z), L = 7 * T & 15);
                  const K = z, ne = G + V + Y[T] + M[L] | 0, se = A[T];
                  z = $, $ = Z, Z = Z + (ne << se | ne >>> 32 - se) | 0, G = K;
                }
                k = k + G | 0, x = x + Z | 0, f = f + $ | 0, D = D + z | 0;
              }
              return new Uint8Array([k & 255, k >> 8 & 255, k >> 16 & 255, k >>> 24 & 255, x & 255, x >> 8 & 255, x >> 16 & 255, x >>> 24 & 255, f & 255, f >> 8 & 255, f >> 16 & 255, f >>> 24 & 255, D & 255, D >> 8 & 255, D >> 16 & 255, D >>> 24 & 255]);
            }
            return j;
          }();
          o.calculateMD5 = e;
          class y {
            constructor(A, Y) {
              this.high = A | 0, this.low = Y | 0;
            }
            and(A) {
              this.high &= A.high, this.low &= A.low;
            }
            xor(A) {
              this.high ^= A.high, this.low ^= A.low;
            }
            or(A) {
              this.high |= A.high, this.low |= A.low;
            }
            shiftRight(A) {
              A >= 32 ? (this.low = this.high >>> A - 32 | 0, this.high = 0) : (this.low = this.low >>> A | this.high << 32 - A, this.high = this.high >>> A | 0);
            }
            shiftLeft(A) {
              A >= 32 ? (this.high = this.low << A - 32, this.low = 0) : (this.high = this.high << A | this.low >>> 32 - A, this.low <<= A);
            }
            rotateRight(A) {
              let Y, j;
              A & 32 ? (j = this.low, Y = this.high) : (Y = this.low, j = this.high), A &= 31, this.low = Y >>> A | j << 32 - A, this.high = j >>> A | Y << 32 - A;
            }
            not() {
              this.high = ~this.high, this.low = ~this.low;
            }
            add(A) {
              const Y = (this.low >>> 0) + (A.low >>> 0);
              let j = (this.high >>> 0) + (A.high >>> 0);
              Y > 4294967295 && (j += 1), this.low = Y | 0, this.high = j | 0;
            }
            copyTo(A, Y) {
              A[Y] = this.high >>> 24 & 255, A[Y + 1] = this.high >> 16 & 255, A[Y + 2] = this.high >> 8 & 255, A[Y + 3] = this.high & 255, A[Y + 4] = this.low >>> 24 & 255, A[Y + 5] = this.low >> 16 & 255, A[Y + 6] = this.low >> 8 & 255, A[Y + 7] = this.low & 255;
            }
            assign(A) {
              this.high = A.high, this.low = A.low;
            }
          }
          const c = function() {
            function A(D, _) {
              return D >>> _ | D << 32 - _;
            }
            function Y(D, _, S) {
              return D & _ ^ ~D & S;
            }
            function j(D, _, S) {
              return D & _ ^ D & S ^ _ & S;
            }
            function X(D) {
              return A(D, 2) ^ A(D, 13) ^ A(D, 22);
            }
            function B(D) {
              return A(D, 6) ^ A(D, 11) ^ A(D, 25);
            }
            function U(D) {
              return A(D, 7) ^ A(D, 18) ^ D >>> 3;
            }
            function k(D) {
              return A(D, 17) ^ A(D, 19) ^ D >>> 10;
            }
            const x = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
            function f(D, _, S) {
              let C = 1779033703, T = 3144134277, P = 1013904242, M = 2773480762, G = 1359893119, Z = 2600822924, $ = 528734635, z = 1541459225;
              const V = Math.ceil((S + 9) / 64) * 64, L = new Uint8Array(V);
              let K, ne;
              for (K = 0; K < S; ++K)
                L[K] = D[_++];
              L[K++] = 128;
              const se = V - 8;
              for (; K < se; )
                L[K++] = 0;
              L[K++] = 0, L[K++] = 0, L[K++] = 0, L[K++] = S >>> 29 & 255, L[K++] = S >> 21 & 255, L[K++] = S >> 13 & 255, L[K++] = S >> 5 & 255, L[K++] = S << 3 & 255;
              const q = new Uint32Array(64);
              for (K = 0; K < V; ) {
                for (ne = 0; ne < 16; ++ne)
                  q[ne] = L[K] << 24 | L[K + 1] << 16 | L[K + 2] << 8 | L[K + 3], K += 4;
                for (ne = 16; ne < 64; ++ne)
                  q[ne] = k(q[ne - 2]) + q[ne - 7] + U(q[ne - 15]) + q[ne - 16] | 0;
                let N = C, Q = T, E = P, te = M, oe = G, ee = Z, W = $, I = z, H, ie;
                for (ne = 0; ne < 64; ++ne)
                  H = I + B(oe) + Y(oe, ee, W) + x[ne] + q[ne], ie = X(N) + j(N, Q, E), I = W, W = ee, ee = oe, oe = te + H | 0, te = E, E = Q, Q = N, N = H + ie | 0;
                C = C + N | 0, T = T + Q | 0, P = P + E | 0, M = M + te | 0, G = G + oe | 0, Z = Z + ee | 0, $ = $ + W | 0, z = z + I | 0;
              }
              return new Uint8Array([C >> 24 & 255, C >> 16 & 255, C >> 8 & 255, C & 255, T >> 24 & 255, T >> 16 & 255, T >> 8 & 255, T & 255, P >> 24 & 255, P >> 16 & 255, P >> 8 & 255, P & 255, M >> 24 & 255, M >> 16 & 255, M >> 8 & 255, M & 255, G >> 24 & 255, G >> 16 & 255, G >> 8 & 255, G & 255, Z >> 24 & 255, Z >> 16 & 255, Z >> 8 & 255, Z & 255, $ >> 24 & 255, $ >> 16 & 255, $ >> 8 & 255, $ & 255, z >> 24 & 255, z >> 16 & 255, z >> 8 & 255, z & 255]);
            }
            return f;
          }();
          o.calculateSHA256 = c;
          const d = function() {
            function A(f, D, _, S, C) {
              f.assign(D), f.and(_), C.assign(D), C.not(), C.and(S), f.xor(C);
            }
            function Y(f, D, _, S, C) {
              f.assign(D), f.and(_), C.assign(D), C.and(S), f.xor(C), C.assign(_), C.and(S), f.xor(C);
            }
            function j(f, D, _) {
              f.assign(D), f.rotateRight(28), _.assign(D), _.rotateRight(34), f.xor(_), _.assign(D), _.rotateRight(39), f.xor(_);
            }
            function X(f, D, _) {
              f.assign(D), f.rotateRight(14), _.assign(D), _.rotateRight(18), f.xor(_), _.assign(D), _.rotateRight(41), f.xor(_);
            }
            function B(f, D, _) {
              f.assign(D), f.rotateRight(1), _.assign(D), _.rotateRight(8), f.xor(_), _.assign(D), _.shiftRight(7), f.xor(_);
            }
            function U(f, D, _) {
              f.assign(D), f.rotateRight(19), _.assign(D), _.rotateRight(61), f.xor(_), _.assign(D), _.shiftRight(6), f.xor(_);
            }
            const k = [new y(1116352408, 3609767458), new y(1899447441, 602891725), new y(3049323471, 3964484399), new y(3921009573, 2173295548), new y(961987163, 4081628472), new y(1508970993, 3053834265), new y(2453635748, 2937671579), new y(2870763221, 3664609560), new y(3624381080, 2734883394), new y(310598401, 1164996542), new y(607225278, 1323610764), new y(1426881987, 3590304994), new y(1925078388, 4068182383), new y(2162078206, 991336113), new y(2614888103, 633803317), new y(3248222580, 3479774868), new y(3835390401, 2666613458), new y(4022224774, 944711139), new y(264347078, 2341262773), new y(604807628, 2007800933), new y(770255983, 1495990901), new y(1249150122, 1856431235), new y(1555081692, 3175218132), new y(1996064986, 2198950837), new y(2554220882, 3999719339), new y(2821834349, 766784016), new y(2952996808, 2566594879), new y(3210313671, 3203337956), new y(3336571891, 1034457026), new y(3584528711, 2466948901), new y(113926993, 3758326383), new y(338241895, 168717936), new y(666307205, 1188179964), new y(773529912, 1546045734), new y(1294757372, 1522805485), new y(1396182291, 2643833823), new y(1695183700, 2343527390), new y(1986661051, 1014477480), new y(2177026350, 1206759142), new y(2456956037, 344077627), new y(2730485921, 1290863460), new y(2820302411, 3158454273), new y(3259730800, 3505952657), new y(3345764771, 106217008), new y(3516065817, 3606008344), new y(3600352804, 1432725776), new y(4094571909, 1467031594), new y(275423344, 851169720), new y(430227734, 3100823752), new y(506948616, 1363258195), new y(659060556, 3750685593), new y(883997877, 3785050280), new y(958139571, 3318307427), new y(1322822218, 3812723403), new y(1537002063, 2003034995), new y(1747873779, 3602036899), new y(1955562222, 1575990012), new y(2024104815, 1125592928), new y(2227730452, 2716904306), new y(2361852424, 442776044), new y(2428436474, 593698344), new y(2756734187, 3733110249), new y(3204031479, 2999351573), new y(3329325298, 3815920427), new y(3391569614, 3928383900), new y(3515267271, 566280711), new y(3940187606, 3454069534), new y(4118630271, 4000239992), new y(116418474, 1914138554), new y(174292421, 2731055270), new y(289380356, 3203993006), new y(460393269, 320620315), new y(685471733, 587496836), new y(852142971, 1086792851), new y(1017036298, 365543100), new y(1126000580, 2618297676), new y(1288033470, 3409855158), new y(1501505948, 4234509866), new y(1607167915, 987167468), new y(1816402316, 1246189591)];
            function x(f, D, _, S = !1) {
              let C, T, P, M, G, Z, $, z;
              S ? (C = new y(3418070365, 3238371032), T = new y(1654270250, 914150663), P = new y(2438529370, 812702999), M = new y(355462360, 4144912697), G = new y(1731405415, 4290775857), Z = new y(2394180231, 1750603025), $ = new y(3675008525, 1694076839), z = new y(1203062813, 3204075428)) : (C = new y(1779033703, 4089235720), T = new y(3144134277, 2227873595), P = new y(1013904242, 4271175723), M = new y(2773480762, 1595750129), G = new y(1359893119, 2917565137), Z = new y(2600822924, 725511199), $ = new y(528734635, 4215389547), z = new y(1541459225, 327033209));
              const V = Math.ceil((_ + 17) / 128) * 128, L = new Uint8Array(V);
              let K, ne;
              for (K = 0; K < _; ++K)
                L[K] = f[D++];
              L[K++] = 128;
              const se = V - 16;
              for (; K < se; )
                L[K++] = 0;
              L[K++] = 0, L[K++] = 0, L[K++] = 0, L[K++] = 0, L[K++] = 0, L[K++] = 0, L[K++] = 0, L[K++] = 0, L[K++] = 0, L[K++] = 0, L[K++] = 0, L[K++] = _ >>> 29 & 255, L[K++] = _ >> 21 & 255, L[K++] = _ >> 13 & 255, L[K++] = _ >> 5 & 255, L[K++] = _ << 3 & 255;
              const q = new Array(80);
              for (K = 0; K < 80; K++)
                q[K] = new y(0, 0);
              let N = new y(0, 0), Q = new y(0, 0), E = new y(0, 0), te = new y(0, 0), oe = new y(0, 0), ee = new y(0, 0), W = new y(0, 0), I = new y(0, 0);
              const H = new y(0, 0), ie = new y(0, 0), ue = new y(0, 0), fe = new y(0, 0);
              let de;
              for (K = 0; K < V; ) {
                for (ne = 0; ne < 16; ++ne)
                  q[ne].high = L[K] << 24 | L[K + 1] << 16 | L[K + 2] << 8 | L[K + 3], q[ne].low = L[K + 4] << 24 | L[K + 5] << 16 | L[K + 6] << 8 | L[K + 7], K += 8;
                for (ne = 16; ne < 80; ++ne)
                  de = q[ne], U(de, q[ne - 2], fe), de.add(q[ne - 7]), B(ue, q[ne - 15], fe), de.add(ue), de.add(q[ne - 16]);
                for (N.assign(C), Q.assign(T), E.assign(P), te.assign(M), oe.assign(G), ee.assign(Z), W.assign($), I.assign(z), ne = 0; ne < 80; ++ne)
                  H.assign(I), X(ue, oe, fe), H.add(ue), A(ue, oe, ee, W, fe), H.add(ue), H.add(k[ne]), H.add(q[ne]), j(ie, N, fe), Y(ue, N, Q, E, fe), ie.add(ue), de = I, I = W, W = ee, ee = oe, te.add(H), oe = te, te = E, E = Q, Q = N, de.assign(H), de.add(ie), N = de;
                C.add(N), T.add(Q), P.add(E), M.add(te), G.add(oe), Z.add(ee), $.add(W), z.add(I);
              }
              let pe;
              return S ? (pe = new Uint8Array(48), C.copyTo(pe, 0), T.copyTo(pe, 8), P.copyTo(pe, 16), M.copyTo(pe, 24), G.copyTo(pe, 32), Z.copyTo(pe, 40)) : (pe = new Uint8Array(64), C.copyTo(pe, 0), T.copyTo(pe, 8), P.copyTo(pe, 16), M.copyTo(pe, 24), G.copyTo(pe, 32), Z.copyTo(pe, 40), $.copyTo(pe, 48), z.copyTo(pe, 56)), pe;
            }
            return x;
          }();
          o.calculateSHA512 = d;
          function m(b, A, Y) {
            return d(b, A, Y, !0);
          }
          class p {
            decryptBlock(A) {
              return A;
            }
            encrypt(A) {
              return A;
            }
          }
          class g {
            constructor() {
              this.constructor === g && (0, t.unreachable)("Cannot initialize AESBaseCipher."), this._s = new Uint8Array([99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22]), this._inv_s = new Uint8Array([82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125]), this._mix = new Uint32Array([0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795]), this._mixCol = new Uint8Array(256);
              for (let A = 0; A < 256; A++)
                A < 128 ? this._mixCol[A] = A << 1 : this._mixCol[A] = A << 1 ^ 27;
              this.buffer = new Uint8Array(16), this.bufferPosition = 0;
            }
            _expandKey(A) {
              (0, t.unreachable)("Cannot call `_expandKey` on the base class");
            }
            _decrypt(A, Y) {
              let j, X, B;
              const U = new Uint8Array(16);
              U.set(A);
              for (let k = 0, x = this._keySize; k < 16; ++k, ++x)
                U[k] ^= Y[x];
              for (let k = this._cyclesOfRepetition - 1; k >= 1; --k) {
                j = U[13], U[13] = U[9], U[9] = U[5], U[5] = U[1], U[1] = j, j = U[14], X = U[10], U[14] = U[6], U[10] = U[2], U[6] = j, U[2] = X, j = U[15], X = U[11], B = U[7], U[15] = U[3], U[11] = j, U[7] = X, U[3] = B;
                for (let x = 0; x < 16; ++x)
                  U[x] = this._inv_s[U[x]];
                for (let x = 0, f = k * 16; x < 16; ++x, ++f)
                  U[x] ^= Y[f];
                for (let x = 0; x < 16; x += 4) {
                  const f = this._mix[U[x]], D = this._mix[U[x + 1]], _ = this._mix[U[x + 2]], S = this._mix[U[x + 3]];
                  j = f ^ D >>> 8 ^ D << 24 ^ _ >>> 16 ^ _ << 16 ^ S >>> 24 ^ S << 8, U[x] = j >>> 24 & 255, U[x + 1] = j >> 16 & 255, U[x + 2] = j >> 8 & 255, U[x + 3] = j & 255;
                }
              }
              j = U[13], U[13] = U[9], U[9] = U[5], U[5] = U[1], U[1] = j, j = U[14], X = U[10], U[14] = U[6], U[10] = U[2], U[6] = j, U[2] = X, j = U[15], X = U[11], B = U[7], U[15] = U[3], U[11] = j, U[7] = X, U[3] = B;
              for (let k = 0; k < 16; ++k)
                U[k] = this._inv_s[U[k]], U[k] ^= Y[k];
              return U;
            }
            _encrypt(A, Y) {
              const j = this._s;
              let X, B, U;
              const k = new Uint8Array(16);
              k.set(A);
              for (let x = 0; x < 16; ++x)
                k[x] ^= Y[x];
              for (let x = 1; x < this._cyclesOfRepetition; x++) {
                for (let f = 0; f < 16; ++f)
                  k[f] = j[k[f]];
                U = k[1], k[1] = k[5], k[5] = k[9], k[9] = k[13], k[13] = U, U = k[2], B = k[6], k[2] = k[10], k[6] = k[14], k[10] = U, k[14] = B, U = k[3], B = k[7], X = k[11], k[3] = k[15], k[7] = U, k[11] = B, k[15] = X;
                for (let f = 0; f < 16; f += 4) {
                  const D = k[f + 0], _ = k[f + 1], S = k[f + 2], C = k[f + 3];
                  X = D ^ _ ^ S ^ C, k[f + 0] ^= X ^ this._mixCol[D ^ _], k[f + 1] ^= X ^ this._mixCol[_ ^ S], k[f + 2] ^= X ^ this._mixCol[S ^ C], k[f + 3] ^= X ^ this._mixCol[C ^ D];
                }
                for (let f = 0, D = x * 16; f < 16; ++f, ++D)
                  k[f] ^= Y[D];
              }
              for (let x = 0; x < 16; ++x)
                k[x] = j[k[x]];
              U = k[1], k[1] = k[5], k[5] = k[9], k[9] = k[13], k[13] = U, U = k[2], B = k[6], k[2] = k[10], k[6] = k[14], k[10] = U, k[14] = B, U = k[3], B = k[7], X = k[11], k[3] = k[15], k[7] = U, k[11] = B, k[15] = X;
              for (let x = 0, f = this._keySize; x < 16; ++x, ++f)
                k[x] ^= Y[f];
              return k;
            }
            _decryptBlock2(A, Y) {
              const j = A.length;
              let X = this.buffer, B = this.bufferPosition;
              const U = [];
              let k = this.iv;
              for (let D = 0; D < j; ++D) {
                if (X[B] = A[D], ++B, B < 16)
                  continue;
                const _ = this._decrypt(X, this._key);
                for (let S = 0; S < 16; ++S)
                  _[S] ^= k[S];
                k = X, U.push(_), X = new Uint8Array(16), B = 0;
              }
              if (this.buffer = X, this.bufferLength = B, this.iv = k, U.length === 0)
                return new Uint8Array(0);
              let x = 16 * U.length;
              if (Y) {
                const D = U.at(-1);
                let _ = D[15];
                if (_ <= 16) {
                  for (let S = 15, C = 16 - _; S >= C; --S)
                    if (D[S] !== _) {
                      _ = 0;
                      break;
                    }
                  x -= _, U[U.length - 1] = D.subarray(0, 16 - _);
                }
              }
              const f = new Uint8Array(x);
              for (let D = 0, _ = 0, S = U.length; D < S; ++D, _ += 16)
                f.set(U[D], _);
              return f;
            }
            decryptBlock(A, Y, j = null) {
              const X = A.length, B = this.buffer;
              let U = this.bufferPosition;
              if (j)
                this.iv = j;
              else {
                for (let k = 0; U < 16 && k < X; ++k, ++U)
                  B[U] = A[k];
                if (U < 16)
                  return this.bufferLength = U, new Uint8Array(0);
                this.iv = B, A = A.subarray(16);
              }
              return this.buffer = new Uint8Array(16), this.bufferLength = 0, this.decryptBlock = this._decryptBlock2, this.decryptBlock(A, Y);
            }
            encrypt(A, Y) {
              const j = A.length;
              let X = this.buffer, B = this.bufferPosition;
              const U = [];
              Y || (Y = new Uint8Array(16));
              for (let f = 0; f < j; ++f) {
                if (X[B] = A[f], ++B, B < 16)
                  continue;
                for (let _ = 0; _ < 16; ++_)
                  X[_] ^= Y[_];
                const D = this._encrypt(X, this._key);
                Y = D, U.push(D), X = new Uint8Array(16), B = 0;
              }
              if (this.buffer = X, this.bufferLength = B, this.iv = Y, U.length === 0)
                return new Uint8Array(0);
              const k = 16 * U.length, x = new Uint8Array(k);
              for (let f = 0, D = 0, _ = U.length; f < _; ++f, D += 16)
                x.set(U[f], D);
              return x;
            }
          }
          class n extends g {
            constructor(A) {
              super(), this._cyclesOfRepetition = 10, this._keySize = 160, this._rcon = new Uint8Array([141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141]), this._key = this._expandKey(A);
            }
            _expandKey(A) {
              const j = this._s, X = this._rcon, B = new Uint8Array(176);
              B.set(A);
              for (let U = 16, k = 1; U < 176; ++k) {
                let x = B[U - 3], f = B[U - 2], D = B[U - 1], _ = B[U - 4];
                x = j[x], f = j[f], D = j[D], _ = j[_], x ^= X[k];
                for (let S = 0; S < 4; ++S)
                  B[U] = x ^= B[U - 16], U++, B[U] = f ^= B[U - 16], U++, B[U] = D ^= B[U - 16], U++, B[U] = _ ^= B[U - 16], U++;
              }
              return B;
            }
          }
          o.AES128Cipher = n;
          class i extends g {
            constructor(A) {
              super(), this._cyclesOfRepetition = 14, this._keySize = 224, this._key = this._expandKey(A);
            }
            _expandKey(A) {
              const j = this._s, X = new Uint8Array(240);
              X.set(A);
              let B = 1, U, k, x, f;
              for (let D = 32, _ = 1; D < 240; ++_) {
                D % 32 === 16 ? (U = j[U], k = j[k], x = j[x], f = j[f]) : D % 32 === 0 && (U = X[D - 3], k = X[D - 2], x = X[D - 1], f = X[D - 4], U = j[U], k = j[k], x = j[x], f = j[f], U ^= B, (B <<= 1) >= 256 && (B = (B ^ 27) & 255));
                for (let S = 0; S < 4; ++S)
                  X[D] = U ^= X[D - 32], D++, X[D] = k ^= X[D - 32], D++, X[D] = x ^= X[D - 32], D++, X[D] = f ^= X[D - 32], D++;
              }
              return X;
            }
          }
          o.AES256Cipher = i;
          class l {
            checkOwnerPassword(A, Y, j, X) {
              const B = new Uint8Array(A.length + 56);
              B.set(A, 0), B.set(Y, A.length), B.set(j, A.length + Y.length);
              const U = c(B, 0, B.length);
              return (0, t.isArrayEqual)(U, X);
            }
            checkUserPassword(A, Y, j) {
              const X = new Uint8Array(A.length + 8);
              X.set(A, 0), X.set(Y, A.length);
              const B = c(X, 0, X.length);
              return (0, t.isArrayEqual)(B, j);
            }
            getOwnerKey(A, Y, j, X) {
              const B = new Uint8Array(A.length + 56);
              B.set(A, 0), B.set(Y, A.length), B.set(j, A.length + Y.length);
              const U = c(B, 0, B.length);
              return new i(U).decryptBlock(X, !1, new Uint8Array(16));
            }
            getUserKey(A, Y, j) {
              const X = new Uint8Array(A.length + 8);
              X.set(A, 0), X.set(Y, A.length);
              const B = c(X, 0, X.length);
              return new i(B).decryptBlock(j, !1, new Uint8Array(16));
            }
          }
          o.PDF17 = l;
          const u = function() {
            function A(j, X, B) {
              let U = c(X, 0, X.length).subarray(0, 32), k = [0], x = 0;
              for (; x < 64 || k.at(-1) > x - 32; ) {
                const f = j.length + U.length + B.length, D = new Uint8Array(f);
                let _ = 0;
                D.set(j, _), _ += j.length, D.set(U, _), _ += U.length, D.set(B, _);
                const S = new Uint8Array(f * 64);
                for (let P = 0, M = 0; P < 64; P++, M += f)
                  S.set(D, M);
                k = new n(U.subarray(0, 16)).encrypt(S, U.subarray(16, 32));
                let T = 0;
                for (let P = 0; P < 16; P++)
                  T *= 256 % 3, T %= 3, T += (k[P] >>> 0) % 3, T %= 3;
                T === 0 ? U = c(k, 0, k.length) : T === 1 ? U = m(k, 0, k.length) : T === 2 && (U = d(k, 0, k.length)), x++;
              }
              return U.subarray(0, 32);
            }
            class Y {
              hash(X, B, U) {
                return A(X, B, U);
              }
              checkOwnerPassword(X, B, U, k) {
                const x = new Uint8Array(X.length + 56);
                x.set(X, 0), x.set(B, X.length), x.set(U, X.length + B.length);
                const f = A(X, x, U);
                return (0, t.isArrayEqual)(f, k);
              }
              checkUserPassword(X, B, U) {
                const k = new Uint8Array(X.length + 8);
                k.set(X, 0), k.set(B, X.length);
                const x = A(X, k, []);
                return (0, t.isArrayEqual)(x, U);
              }
              getOwnerKey(X, B, U, k) {
                const x = new Uint8Array(X.length + 56);
                x.set(X, 0), x.set(B, X.length), x.set(U, X.length + B.length);
                const f = A(X, x, U);
                return new i(f).decryptBlock(k, !1, new Uint8Array(16));
              }
              getUserKey(X, B, U) {
                const k = new Uint8Array(X.length + 8);
                k.set(X, 0), k.set(B, X.length);
                const x = A(X, k, []);
                return new i(x).decryptBlock(U, !1, new Uint8Array(16));
              }
            }
            return Y;
          }();
          o.PDF20 = u;
          class w {
            constructor(A, Y) {
              this.StringCipherConstructor = A, this.StreamCipherConstructor = Y;
            }
            createStream(A, Y) {
              const j = new this.StreamCipherConstructor();
              return new v.DecryptStream(A, Y, function(B, U) {
                return j.decryptBlock(B, U);
              });
            }
            decryptString(A) {
              const Y = new this.StringCipherConstructor();
              let j = (0, t.stringToBytes)(A);
              return j = Y.decryptBlock(j, !0), (0, t.bytesToString)(j);
            }
            encryptString(A) {
              const Y = new this.StringCipherConstructor();
              if (Y instanceof g) {
                const B = 16 - A.length % 16;
                A += String.fromCharCode(B).repeat(B);
                const U = new Uint8Array(16);
                if (typeof crypto < "u")
                  crypto.getRandomValues(U);
                else
                  for (let f = 0; f < 16; f++)
                    U[f] = Math.floor(256 * Math.random());
                let k = (0, t.stringToBytes)(A);
                k = Y.encrypt(k, U);
                const x = new Uint8Array(16 + k.length);
                return x.set(U), x.set(k, 16), (0, t.bytesToString)(x);
              }
              let j = (0, t.stringToBytes)(A);
              return j = Y.encrypt(j), (0, t.bytesToString)(j);
            }
          }
          const O = function() {
            const A = new Uint8Array([40, 191, 78, 94, 78, 117, 138, 65, 100, 0, 78, 86, 255, 250, 1, 8, 46, 46, 0, 182, 208, 104, 62, 128, 47, 12, 169, 254, 100, 83, 105, 122]);
            function Y(f, D, _, S, C, T, P, M, G, Z, $, z) {
              if (D) {
                const L = Math.min(127, D.length);
                D = D.subarray(0, L);
              } else
                D = [];
              let V;
              return f === 6 ? V = new u() : V = new l(), V.checkUserPassword(D, M, P) ? V.getUserKey(D, G, $) : D.length && V.checkOwnerPassword(D, S, T, _) ? V.getOwnerKey(D, C, T, Z) : null;
            }
            function j(f, D, _, S, C, T, P, M) {
              const G = 40 + _.length + f.length, Z = new Uint8Array(G);
              let $ = 0, z, V;
              if (D)
                for (V = Math.min(32, D.length); $ < V; ++$)
                  Z[$] = D[$];
              for (z = 0; $ < 32; )
                Z[$++] = A[z++];
              for (z = 0, V = _.length; z < V; ++z)
                Z[$++] = _[z];
              for (Z[$++] = C & 255, Z[$++] = C >> 8 & 255, Z[$++] = C >> 16 & 255, Z[$++] = C >>> 24 & 255, z = 0, V = f.length; z < V; ++z)
                Z[$++] = f[z];
              T >= 4 && !M && (Z[$++] = 255, Z[$++] = 255, Z[$++] = 255, Z[$++] = 255);
              let L = e(Z, 0, $);
              const K = P >> 3;
              if (T >= 3)
                for (z = 0; z < 50; ++z)
                  L = e(L, 0, K);
              const ne = L.subarray(0, K);
              let se, q;
              if (T >= 3) {
                for ($ = 0; $ < 32; ++$)
                  Z[$] = A[$];
                for (z = 0, V = f.length; z < V; ++z)
                  Z[$++] = f[z];
                se = new h(ne), q = se.encryptBlock(e(Z, 0, $)), V = ne.length;
                const N = new Uint8Array(V);
                for (z = 1; z <= 19; ++z) {
                  for (let Q = 0; Q < V; ++Q)
                    N[Q] = ne[Q] ^ z;
                  se = new h(N), q = se.encryptBlock(q);
                }
                for (z = 0, V = q.length; z < V; ++z)
                  if (S[z] !== q[z])
                    return null;
              } else
                for (se = new h(ne), q = se.encryptBlock(A), z = 0, V = q.length; z < V; ++z)
                  if (S[z] !== q[z])
                    return null;
              return ne;
            }
            function X(f, D, _, S) {
              const C = new Uint8Array(32);
              let T = 0;
              const P = Math.min(32, f.length);
              for (; T < P; ++T)
                C[T] = f[T];
              let M = 0;
              for (; T < 32; )
                C[T++] = A[M++];
              let G = e(C, 0, T);
              const Z = S >> 3;
              if (_ >= 3)
                for (M = 0; M < 50; ++M)
                  G = e(G, 0, G.length);
              let $, z;
              if (_ >= 3) {
                z = D;
                const V = new Uint8Array(Z);
                for (M = 19; M >= 0; M--) {
                  for (let L = 0; L < Z; ++L)
                    V[L] = G[L] ^ M;
                  $ = new h(V), z = $.encryptBlock(z);
                }
              } else
                $ = new h(G.subarray(0, Z)), z = $.encryptBlock(D);
              return z;
            }
            const B = a.Name.get("Identity");
            function U(f, D, _, S = !1) {
              const C = new Uint8Array(_.length + 9), T = _.length;
              let P;
              for (P = 0; P < T; ++P)
                C[P] = _[P];
              return C[P++] = f & 255, C[P++] = f >> 8 & 255, C[P++] = f >> 16 & 255, C[P++] = D & 255, C[P++] = D >> 8 & 255, S && (C[P++] = 115, C[P++] = 65, C[P++] = 108, C[P++] = 84), e(C, 0, P).subarray(0, Math.min(_.length + 5, 16));
            }
            function k(f, D, _, S, C) {
              if (!(D instanceof a.Name))
                throw new t.FormatError("Invalid crypt filter name.");
              const T = f.get(D.name);
              let P;
              if (T != null && (P = T.get("CFM")), !P || P.name === "None")
                return function() {
                  return new p();
                };
              if (P.name === "V2")
                return function() {
                  return new h(U(_, S, C, !1));
                };
              if (P.name === "AESV2")
                return function() {
                  return new n(U(_, S, C, !0));
                };
              if (P.name === "AESV3")
                return function() {
                  return new i(C);
                };
              throw new t.FormatError("Unknown crypto method");
            }
            class x {
              constructor(D, _, S) {
                const C = D.get("Filter");
                if (!(0, a.isName)(C, "Standard"))
                  throw new t.FormatError("unknown encryption method");
                this.filterName = C.name, this.dict = D;
                const T = D.get("V");
                if (!Number.isInteger(T) || T !== 1 && T !== 2 && T !== 4 && T !== 5)
                  throw new t.FormatError("unsupported encryption algorithm");
                this.algorithm = T;
                let P = D.get("Length");
                if (!P)
                  if (T <= 3)
                    P = 40;
                  else {
                    const ne = D.get("CF"), se = D.get("StmF");
                    if (ne instanceof a.Dict && se instanceof a.Name) {
                      ne.suppressEncryption = !0;
                      const q = ne.get(se.name);
                      P = q && q.get("Length") || 128, P < 40 && (P <<= 3);
                    }
                  }
                if (!Number.isInteger(P) || P < 40 || P % 8 !== 0)
                  throw new t.FormatError("invalid key length");
                const M = (0, t.stringToBytes)(D.get("O")).subarray(0, 32), G = (0, t.stringToBytes)(D.get("U")).subarray(0, 32), Z = D.get("P"), $ = D.get("R"), z = (T === 4 || T === 5) && D.get("EncryptMetadata") !== !1;
                this.encryptMetadata = z;
                const V = (0, t.stringToBytes)(_);
                let L;
                if (S) {
                  if ($ === 6)
                    try {
                      S = (0, t.utf8StringToString)(S);
                    } catch {
                      (0, t.warn)("CipherTransformFactory: Unable to convert UTF8 encoded password.");
                    }
                  L = (0, t.stringToBytes)(S);
                }
                let K;
                if (T !== 5)
                  K = j(V, L, M, G, Z, $, P, z);
                else {
                  const ne = (0, t.stringToBytes)(D.get("O")).subarray(32, 40), se = (0, t.stringToBytes)(D.get("O")).subarray(40, 48), q = (0, t.stringToBytes)(D.get("U")).subarray(0, 48), N = (0, t.stringToBytes)(D.get("U")).subarray(32, 40), Q = (0, t.stringToBytes)(D.get("U")).subarray(40, 48), E = (0, t.stringToBytes)(D.get("OE")), te = (0, t.stringToBytes)(D.get("UE"));
                  (0, t.stringToBytes)(D.get("Perms")), K = Y($, L, M, ne, se, q, G, N, Q, E, te);
                }
                if (!K && !S)
                  throw new t.PasswordException("No password given", t.PasswordResponses.NEED_PASSWORD);
                if (!K && S) {
                  const ne = X(L, M, $, P);
                  K = j(V, ne, M, G, Z, $, P, z);
                }
                if (!K)
                  throw new t.PasswordException("Incorrect Password", t.PasswordResponses.INCORRECT_PASSWORD);
                if (this.encryptionKey = K, T >= 4) {
                  const ne = D.get("CF");
                  ne instanceof a.Dict && (ne.suppressEncryption = !0), this.cf = ne, this.stmf = D.get("StmF") || B, this.strf = D.get("StrF") || B, this.eff = D.get("EFF") || this.stmf;
                }
              }
              createCipherTransform(D, _) {
                if (this.algorithm === 4 || this.algorithm === 5)
                  return new w(k(this.cf, this.strf, D, _, this.encryptionKey), k(this.cf, this.stmf, D, _, this.encryptionKey));
                const S = U(D, _, this.encryptionKey, !1), C = function() {
                  return new h(S);
                };
                return new w(C, C);
              }
            }
            return x;
          }();
          o.CipherTransformFactory = O;
        },
        /* 68 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.DecryptStream = void 0;
          var t = F(19);
          const a = 512;
          class v extends t.DecodeStream {
            constructor(e, y, c) {
              super(y), this.str = e, this.dict = e.dict, this.decrypt = c, this.nextChunk = null, this.initialized = !1;
            }
            readBlock() {
              let e;
              if (this.initialized ? e = this.nextChunk : (e = this.str.getBytes(a), this.initialized = !0), !e || e.length === 0) {
                this.eof = !0;
                return;
              }
              this.nextChunk = this.str.getBytes(a);
              const y = this.nextChunk && this.nextChunk.length > 0, c = this.decrypt;
              e = c(e, !y);
              let d = this.bufferLength;
              const m = e.length, p = this.ensureBuffer(d + m);
              for (let g = 0; g < m; g++)
                p[d++] = e[g];
              this.bufferLength = d;
            }
          }
          o.DecryptStream = v;
        },
        /* 69 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.Catalog = void 0;
          var t = F(6), a = F(2), v = F(5), h = F(70), e = F(7), y = F(71), c = F(14), d = F(72), m = F(59), p = F(73), g = F(74);
          function n(l) {
            return l instanceof v.Dict && (l = l.get("D")), Array.isArray(l) ? l : null;
          }
          class i {
            constructor(u, w) {
              if (this.pdfManager = u, this.xref = w, this._catDict = w.getCatalogObj(), !(this._catDict instanceof v.Dict))
                throw new a.FormatError("Catalog object is not a dictionary.");
              this.toplevelPagesDict, this._actualNumPages = null, this.fontCache = new v.RefSetCache(), this.builtInCMapCache = /* @__PURE__ */ new Map(), this.standardFontDataCache = /* @__PURE__ */ new Map(), this.globalImageCache = new m.GlobalImageCache(), this.pageKidsCountCache = new v.RefSetCache(), this.pageIndexCache = new v.RefSetCache(), this.nonBlendModesSet = new v.RefSet();
            }
            get version() {
              const u = this._catDict.get("Version");
              return (0, a.shadow)(this, "version", u instanceof v.Name ? u.name : null);
            }
            get lang() {
              const u = this._catDict.get("Lang");
              return (0, a.shadow)(this, "lang", typeof u == "string" ? (0, a.stringToPDFString)(u) : null);
            }
            get needsRendering() {
              const u = this._catDict.get("NeedsRendering");
              return (0, a.shadow)(this, "needsRendering", typeof u == "boolean" ? u : !1);
            }
            get collection() {
              let u = null;
              try {
                const w = this._catDict.get("Collection");
                w instanceof v.Dict && w.size > 0 && (u = w);
              } catch (w) {
                if (w instanceof t.MissingDataException)
                  throw w;
                (0, a.info)("Cannot fetch Collection entry; assuming no collection is present.");
              }
              return (0, a.shadow)(this, "collection", u);
            }
            get acroForm() {
              let u = null;
              try {
                const w = this._catDict.get("AcroForm");
                w instanceof v.Dict && w.size > 0 && (u = w);
              } catch (w) {
                if (w instanceof t.MissingDataException)
                  throw w;
                (0, a.info)("Cannot fetch AcroForm entry; assuming no forms are present.");
              }
              return (0, a.shadow)(this, "acroForm", u);
            }
            get acroFormRef() {
              const u = this._catDict.getRaw("AcroForm");
              return (0, a.shadow)(this, "acroFormRef", u instanceof v.Ref ? u : null);
            }
            get metadata() {
              const u = this._catDict.getRaw("Metadata");
              if (!(u instanceof v.Ref))
                return (0, a.shadow)(this, "metadata", null);
              let w = null;
              try {
                const O = !(this.xref.encrypt && this.xref.encrypt.encryptMetadata), b = this.xref.fetch(u, O);
                if (b instanceof e.BaseStream && b.dict instanceof v.Dict) {
                  const A = b.dict.get("Type"), Y = b.dict.get("Subtype");
                  if ((0, v.isName)(A, "Metadata") && (0, v.isName)(Y, "XML")) {
                    const j = (0, a.stringToUTF8String)(b.getString());
                    j && (w = new p.MetadataParser(j).serializable);
                  }
                }
              } catch (O) {
                if (O instanceof t.MissingDataException)
                  throw O;
                (0, a.info)(`Skipping invalid Metadata: "${O}".`);
              }
              return (0, a.shadow)(this, "metadata", w);
            }
            get markInfo() {
              let u = null;
              try {
                u = this._readMarkInfo();
              } catch (w) {
                if (w instanceof t.MissingDataException)
                  throw w;
                (0, a.warn)("Unable to read mark info.");
              }
              return (0, a.shadow)(this, "markInfo", u);
            }
            _readMarkInfo() {
              const u = this._catDict.get("MarkInfo");
              if (!(u instanceof v.Dict))
                return null;
              const w = {
                Marked: !1,
                UserProperties: !1,
                Suspects: !1
              };
              for (const O in w) {
                const b = u.get(O);
                typeof b == "boolean" && (w[O] = b);
              }
              return w;
            }
            get structTreeRoot() {
              let u = null;
              try {
                u = this._readStructTreeRoot();
              } catch (w) {
                if (w instanceof t.MissingDataException)
                  throw w;
                (0, a.warn)("Unable read to structTreeRoot info.");
              }
              return (0, a.shadow)(this, "structTreeRoot", u);
            }
            _readStructTreeRoot() {
              const u = this._catDict.get("StructTreeRoot");
              if (!(u instanceof v.Dict))
                return null;
              const w = new g.StructTreeRoot(u);
              return w.init(), w;
            }
            get toplevelPagesDict() {
              const u = this._catDict.get("Pages");
              if (!(u instanceof v.Dict))
                throw new a.FormatError("Invalid top-level pages dictionary.");
              return (0, a.shadow)(this, "toplevelPagesDict", u);
            }
            get documentOutline() {
              let u = null;
              try {
                u = this._readDocumentOutline();
              } catch (w) {
                if (w instanceof t.MissingDataException)
                  throw w;
                (0, a.warn)("Unable to read document outline.");
              }
              return (0, a.shadow)(this, "documentOutline", u);
            }
            _readDocumentOutline() {
              let u = this._catDict.get("Outlines");
              if (!(u instanceof v.Dict) || (u = u.getRaw("First"), !(u instanceof v.Ref)))
                return null;
              const w = {
                items: []
              }, O = [{
                obj: u,
                parent: w
              }], b = new v.RefSet();
              b.put(u);
              const A = this.xref, Y = new Uint8ClampedArray(3);
              for (; O.length > 0; ) {
                const j = O.shift(), X = A.fetchIfRef(j.obj);
                if (X === null)
                  continue;
                if (!X.has("Title"))
                  throw new a.FormatError("Invalid outline item encountered.");
                const B = {
                  url: null,
                  dest: null
                };
                i.parseDestDictionary({
                  destDict: X,
                  resultObj: B,
                  docBaseUrl: this.pdfManager.docBaseUrl
                });
                const U = X.get("Title"), k = X.get("F") || 0, x = X.getArray("C"), f = X.get("Count");
                let D = Y;
                Array.isArray(x) && x.length === 3 && (x[0] !== 0 || x[1] !== 0 || x[2] !== 0) && (D = c.ColorSpace.singletons.rgb.getRgb(x, 0));
                const _ = {
                  dest: B.dest,
                  url: B.url,
                  unsafeUrl: B.unsafeUrl,
                  newWindow: B.newWindow,
                  title: (0, a.stringToPDFString)(U),
                  color: D,
                  count: Number.isInteger(f) ? f : void 0,
                  bold: !!(k & 2),
                  italic: !!(k & 1),
                  items: []
                };
                j.parent.items.push(_), u = X.getRaw("First"), u instanceof v.Ref && !b.has(u) && (O.push({
                  obj: u,
                  parent: _
                }), b.put(u)), u = X.getRaw("Next"), u instanceof v.Ref && !b.has(u) && (O.push({
                  obj: u,
                  parent: j.parent
                }), b.put(u));
              }
              return w.items.length > 0 ? w.items : null;
            }
            get permissions() {
              let u = null;
              try {
                u = this._readPermissions();
              } catch (w) {
                if (w instanceof t.MissingDataException)
                  throw w;
                (0, a.warn)("Unable to read permissions.");
              }
              return (0, a.shadow)(this, "permissions", u);
            }
            _readPermissions() {
              const u = this.xref.trailer.get("Encrypt");
              if (!(u instanceof v.Dict))
                return null;
              let w = u.get("P");
              if (typeof w != "number")
                return null;
              w += 4294967296;
              const O = [];
              for (const b in a.PermissionFlag) {
                const A = a.PermissionFlag[b];
                w & A && O.push(A);
              }
              return O;
            }
            get optionalContentConfig() {
              let u = null;
              try {
                const w = this._catDict.get("OCProperties");
                if (!w)
                  return (0, a.shadow)(this, "optionalContentConfig", null);
                const O = w.get("D");
                if (!O)
                  return (0, a.shadow)(this, "optionalContentConfig", null);
                const b = w.get("OCGs");
                if (!Array.isArray(b))
                  return (0, a.shadow)(this, "optionalContentConfig", null);
                const A = [], Y = [];
                for (const j of b) {
                  if (!(j instanceof v.Ref))
                    continue;
                  Y.push(j);
                  const X = this.xref.fetchIfRef(j);
                  A.push({
                    id: j.toString(),
                    name: typeof X.get("Name") == "string" ? (0, a.stringToPDFString)(X.get("Name")) : null,
                    intent: typeof X.get("Intent") == "string" ? (0, a.stringToPDFString)(X.get("Intent")) : null
                  });
                }
                u = this._readOptionalContentConfig(O, Y), u.groups = A;
              } catch (w) {
                if (w instanceof t.MissingDataException)
                  throw w;
                (0, a.warn)(`Unable to read optional content config: ${w}`);
              }
              return (0, a.shadow)(this, "optionalContentConfig", u);
            }
            _readOptionalContentConfig(u, w) {
              function O(B) {
                const U = [];
                if (Array.isArray(B))
                  for (const k of B)
                    k instanceof v.Ref && w.includes(k) && U.push(k.toString());
                return U;
              }
              function b(B, U = 0) {
                if (!Array.isArray(B))
                  return null;
                const k = [];
                for (const f of B) {
                  if (f instanceof v.Ref && w.includes(f)) {
                    j.put(f), k.push(f.toString());
                    continue;
                  }
                  const D = A(f, U);
                  D && k.push(D);
                }
                if (U > 0)
                  return k;
                const x = [];
                for (const f of w)
                  j.has(f) || x.push(f.toString());
                return x.length && k.push({
                  name: null,
                  order: x
                }), k;
              }
              function A(B, U) {
                if (++U > X)
                  return (0, a.warn)("parseNestedOrder - reached MAX_NESTED_LEVELS."), null;
                const k = Y.fetchIfRef(B);
                if (!Array.isArray(k))
                  return null;
                const x = Y.fetchIfRef(k[0]);
                if (typeof x != "string")
                  return null;
                const f = b(k.slice(1), U);
                return !f || !f.length ? null : {
                  name: (0, a.stringToPDFString)(x),
                  order: f
                };
              }
              const Y = this.xref, j = new v.RefSet(), X = 10;
              return {
                name: typeof u.get("Name") == "string" ? (0, a.stringToPDFString)(u.get("Name")) : null,
                creator: typeof u.get("Creator") == "string" ? (0, a.stringToPDFString)(u.get("Creator")) : null,
                baseState: u.get("BaseState") instanceof v.Name ? u.get("BaseState").name : null,
                on: O(u.get("ON")),
                off: O(u.get("OFF")),
                order: b(u.get("Order")),
                groups: null
              };
            }
            setActualNumPages(u = null) {
              this._actualNumPages = u;
            }
            get hasActualNumPages() {
              return this._actualNumPages !== null;
            }
            get _pagesCount() {
              const u = this.toplevelPagesDict.get("Count");
              if (!Number.isInteger(u))
                throw new a.FormatError("Page count in top-level pages dictionary is not an integer.");
              return (0, a.shadow)(this, "_pagesCount", u);
            }
            get numPages() {
              return this.hasActualNumPages ? this._actualNumPages : this._pagesCount;
            }
            get destinations() {
              const u = this._readDests(), w = /* @__PURE__ */ Object.create(null);
              if (u instanceof h.NameTree)
                for (const [O, b] of u.getAll()) {
                  const A = n(b);
                  A && (w[(0, a.stringToPDFString)(O)] = A);
                }
              else
                u instanceof v.Dict && u.forEach(function(O, b) {
                  const A = n(b);
                  A && (w[O] = A);
                });
              return (0, a.shadow)(this, "destinations", w);
            }
            getDestination(u) {
              const w = this._readDests();
              if (w instanceof h.NameTree) {
                const O = n(w.get(u));
                if (O)
                  return O;
                const b = this.destinations[u];
                if (b)
                  return (0, a.warn)(`Found "${u}" at an incorrect position in the NameTree.`), b;
              } else if (w instanceof v.Dict) {
                const O = n(w.get(u));
                if (O)
                  return O;
              }
              return null;
            }
            _readDests() {
              const u = this._catDict.get("Names");
              if (u && u.has("Dests"))
                return new h.NameTree(u.getRaw("Dests"), this.xref);
              if (this._catDict.has("Dests"))
                return this._catDict.get("Dests");
            }
            get pageLabels() {
              let u = null;
              try {
                u = this._readPageLabels();
              } catch (w) {
                if (w instanceof t.MissingDataException)
                  throw w;
                (0, a.warn)("Unable to read page labels.");
              }
              return (0, a.shadow)(this, "pageLabels", u);
            }
            _readPageLabels() {
              const u = this._catDict.getRaw("PageLabels");
              if (!u)
                return null;
              const w = new Array(this.numPages);
              let O = null, b = "";
              const Y = new h.NumberTree(u, this.xref).getAll();
              let j = "", X = 1;
              for (let B = 0, U = this.numPages; B < U; B++) {
                const k = Y.get(B);
                if (k !== void 0) {
                  if (!(k instanceof v.Dict))
                    throw new a.FormatError("PageLabel is not a dictionary.");
                  if (k.has("Type") && !(0, v.isName)(k.get("Type"), "PageLabel"))
                    throw new a.FormatError("Invalid type in PageLabel dictionary.");
                  if (k.has("S")) {
                    const x = k.get("S");
                    if (!(x instanceof v.Name))
                      throw new a.FormatError("Invalid style in PageLabel dictionary.");
                    O = x.name;
                  } else
                    O = null;
                  if (k.has("P")) {
                    const x = k.get("P");
                    if (typeof x != "string")
                      throw new a.FormatError("Invalid prefix in PageLabel dictionary.");
                    b = (0, a.stringToPDFString)(x);
                  } else
                    b = "";
                  if (k.has("St")) {
                    const x = k.get("St");
                    if (!(Number.isInteger(x) && x >= 1))
                      throw new a.FormatError("Invalid start in PageLabel dictionary.");
                    X = x;
                  } else
                    X = 1;
                }
                switch (O) {
                  case "D":
                    j = X;
                    break;
                  case "R":
                  case "r":
                    j = (0, t.toRomanNumerals)(X, O === "r");
                    break;
                  case "A":
                  case "a":
                    const x = 26, _ = O === "a" ? 97 : 65, S = X - 1;
                    j = String.fromCharCode(_ + S % x).repeat(Math.floor(S / x) + 1);
                    break;
                  default:
                    if (O)
                      throw new a.FormatError(`Invalid style "${O}" in PageLabel dictionary.`);
                    j = "";
                }
                w[B] = b + j, X++;
              }
              return w;
            }
            get pageLayout() {
              const u = this._catDict.get("PageLayout");
              let w = "";
              if (u instanceof v.Name)
                switch (u.name) {
                  case "SinglePage":
                  case "OneColumn":
                  case "TwoColumnLeft":
                  case "TwoColumnRight":
                  case "TwoPageLeft":
                  case "TwoPageRight":
                    w = u.name;
                }
              return (0, a.shadow)(this, "pageLayout", w);
            }
            get pageMode() {
              const u = this._catDict.get("PageMode");
              let w = "UseNone";
              if (u instanceof v.Name)
                switch (u.name) {
                  case "UseNone":
                  case "UseOutlines":
                  case "UseThumbs":
                  case "FullScreen":
                  case "UseOC":
                  case "UseAttachments":
                    w = u.name;
                }
              return (0, a.shadow)(this, "pageMode", w);
            }
            get viewerPreferences() {
              const u = this._catDict.get("ViewerPreferences");
              if (!(u instanceof v.Dict))
                return (0, a.shadow)(this, "viewerPreferences", null);
              let w = null;
              for (const O of u.getKeys()) {
                const b = u.get(O);
                let A;
                switch (O) {
                  case "HideToolbar":
                  case "HideMenubar":
                  case "HideWindowUI":
                  case "FitWindow":
                  case "CenterWindow":
                  case "DisplayDocTitle":
                  case "PickTrayByPDFSize":
                    typeof b == "boolean" && (A = b);
                    break;
                  case "NonFullScreenPageMode":
                    if (b instanceof v.Name)
                      switch (b.name) {
                        case "UseNone":
                        case "UseOutlines":
                        case "UseThumbs":
                        case "UseOC":
                          A = b.name;
                          break;
                        default:
                          A = "UseNone";
                      }
                    break;
                  case "Direction":
                    if (b instanceof v.Name)
                      switch (b.name) {
                        case "L2R":
                        case "R2L":
                          A = b.name;
                          break;
                        default:
                          A = "L2R";
                      }
                    break;
                  case "ViewArea":
                  case "ViewClip":
                  case "PrintArea":
                  case "PrintClip":
                    if (b instanceof v.Name)
                      switch (b.name) {
                        case "MediaBox":
                        case "CropBox":
                        case "BleedBox":
                        case "TrimBox":
                        case "ArtBox":
                          A = b.name;
                          break;
                        default:
                          A = "CropBox";
                      }
                    break;
                  case "PrintScaling":
                    if (b instanceof v.Name)
                      switch (b.name) {
                        case "None":
                        case "AppDefault":
                          A = b.name;
                          break;
                        default:
                          A = "AppDefault";
                      }
                    break;
                  case "Duplex":
                    if (b instanceof v.Name)
                      switch (b.name) {
                        case "Simplex":
                        case "DuplexFlipShortEdge":
                        case "DuplexFlipLongEdge":
                          A = b.name;
                          break;
                        default:
                          A = "None";
                      }
                    break;
                  case "PrintPageRange":
                    Array.isArray(b) && b.length % 2 === 0 && b.every((j, X, B) => Number.isInteger(j) && j > 0 && (X === 0 || j >= B[X - 1]) && j <= this.numPages) && (A = b);
                    break;
                  case "NumCopies":
                    Number.isInteger(b) && b > 0 && (A = b);
                    break;
                  default:
                    (0, a.warn)(`Ignoring non-standard key in ViewerPreferences: ${O}.`);
                    continue;
                }
                if (A === void 0) {
                  (0, a.warn)(`Bad value, for key "${O}", in ViewerPreferences: ${b}.`);
                  continue;
                }
                w || (w = /* @__PURE__ */ Object.create(null)), w[O] = A;
              }
              return (0, a.shadow)(this, "viewerPreferences", w);
            }
            get openAction() {
              const u = this._catDict.get("OpenAction"), w = /* @__PURE__ */ Object.create(null);
              if (u instanceof v.Dict) {
                const O = new v.Dict(this.xref);
                O.set("A", u);
                const b = {
                  url: null,
                  dest: null,
                  action: null
                };
                i.parseDestDictionary({
                  destDict: O,
                  resultObj: b
                }), Array.isArray(b.dest) ? w.dest = b.dest : b.action && (w.action = b.action);
              } else
                Array.isArray(u) && (w.dest = u);
              return (0, a.shadow)(this, "openAction", (0, a.objectSize)(w) > 0 ? w : null);
            }
            get attachments() {
              const u = this._catDict.get("Names");
              let w = null;
              if (u instanceof v.Dict && u.has("EmbeddedFiles")) {
                const O = new h.NameTree(u.getRaw("EmbeddedFiles"), this.xref);
                for (const [b, A] of O.getAll()) {
                  const Y = new d.FileSpec(A, this.xref);
                  w || (w = /* @__PURE__ */ Object.create(null)), w[(0, a.stringToPDFString)(b)] = Y.serializable;
                }
              }
              return (0, a.shadow)(this, "attachments", w);
            }
            get xfaImages() {
              const u = this._catDict.get("Names");
              let w = null;
              if (u instanceof v.Dict && u.has("XFAImages")) {
                const O = new h.NameTree(u.getRaw("XFAImages"), this.xref);
                for (const [b, A] of O.getAll())
                  w || (w = new v.Dict(this.xref)), w.set((0, a.stringToPDFString)(b), A);
              }
              return (0, a.shadow)(this, "xfaImages", w);
            }
            _collectJavaScript() {
              const u = this._catDict.get("Names");
              let w = null;
              function O(A, Y) {
                if (!(Y instanceof v.Dict) || !(0, v.isName)(Y.get("S"), "JavaScript"))
                  return;
                let j = Y.get("JS");
                if (j instanceof e.BaseStream)
                  j = j.getString();
                else if (typeof j != "string")
                  return;
                w === null && (w = /* @__PURE__ */ new Map()), j = (0, a.stringToPDFString)(j).replace(/\u0000/g, ""), w.set(A, j);
              }
              if (u instanceof v.Dict && u.has("JavaScript")) {
                const A = new h.NameTree(u.getRaw("JavaScript"), this.xref);
                for (const [Y, j] of A.getAll())
                  O((0, a.stringToPDFString)(Y), j);
              }
              const b = this._catDict.get("OpenAction");
              return b && O("OpenAction", b), w;
            }
            get javaScript() {
              const u = this._collectJavaScript();
              return (0, a.shadow)(this, "javaScript", u ? [...u.values()] : null);
            }
            get jsActions() {
              const u = this._collectJavaScript();
              let w = (0, t.collectActions)(this.xref, this._catDict, a.DocumentActionEventType);
              if (u) {
                w || (w = /* @__PURE__ */ Object.create(null));
                for (const [O, b] of u)
                  O in w ? w[O].push(b) : w[O] = [b];
              }
              return (0, a.shadow)(this, "jsActions", w);
            }
            async fontFallback(u, w) {
              const O = await Promise.all(this.fontCache);
              for (const b of O)
                if (b.loadedName === u) {
                  b.fallback(w);
                  return;
                }
            }
            async cleanup(u = !1) {
              (0, y.clearGlobalCaches)(), this.globalImageCache.clear(u), this.pageKidsCountCache.clear(), this.pageIndexCache.clear(), this.nonBlendModesSet.clear();
              const w = await Promise.all(this.fontCache);
              for (const {
                dict: O
              } of w)
                delete O.cacheKey;
              this.fontCache.clear(), this.builtInCMapCache.clear(), this.standardFontDataCache.clear();
            }
            async getPageDict(u) {
              const w = [this.toplevelPagesDict], O = new v.RefSet(), b = this._catDict.getRaw("Pages");
              b instanceof v.Ref && O.put(b);
              const A = this.xref, Y = this.pageKidsCountCache, j = this.pageIndexCache;
              let X = 0;
              for (; w.length; ) {
                const B = w.pop();
                if (B instanceof v.Ref) {
                  const f = Y.get(B);
                  if (f >= 0 && X + f <= u) {
                    X += f;
                    continue;
                  }
                  if (O.has(B))
                    throw new a.FormatError("Pages tree contains circular reference.");
                  O.put(B);
                  const D = await A.fetchAsync(B);
                  if (D instanceof v.Dict) {
                    let _ = D.getRaw("Type");
                    if (_ instanceof v.Ref && (_ = await A.fetchAsync(_)), (0, v.isName)(_, "Page") || !D.has("Kids")) {
                      if (Y.has(B) || Y.put(B, 1), j.has(B) || j.put(B, X), X === u)
                        return [D, B];
                      X++;
                      continue;
                    }
                  }
                  w.push(D);
                  continue;
                }
                if (!(B instanceof v.Dict))
                  throw new a.FormatError("Page dictionary kid reference points to wrong type of object.");
                const {
                  objId: U
                } = B;
                let k = B.getRaw("Count");
                if (k instanceof v.Ref && (k = await A.fetchAsync(k)), Number.isInteger(k) && k >= 0 && (U && !Y.has(U) && Y.put(U, k), X + k <= u)) {
                  X += k;
                  continue;
                }
                let x = B.getRaw("Kids");
                if (x instanceof v.Ref && (x = await A.fetchAsync(x)), !Array.isArray(x)) {
                  let f = B.getRaw("Type");
                  if (f instanceof v.Ref && (f = await A.fetchAsync(f)), (0, v.isName)(f, "Page") || !B.has("Kids")) {
                    if (X === u)
                      return [B, null];
                    X++;
                    continue;
                  }
                  throw new a.FormatError("Page dictionary kids object is not an array.");
                }
                for (let f = x.length - 1; f >= 0; f--)
                  w.push(x[f]);
              }
              throw new Error(`Page index ${u} not found.`);
            }
            async getAllPageDicts(u = !1) {
              const w = [{
                currentNode: this.toplevelPagesDict,
                posInKids: 0
              }], O = new v.RefSet(), b = this._catDict.getRaw("Pages");
              b instanceof v.Ref && O.put(b);
              const A = /* @__PURE__ */ new Map(), Y = this.xref, j = this.pageIndexCache;
              let X = 0;
              function B(k, x) {
                x && !j.has(x) && j.put(x, X), A.set(X++, [k, x]);
              }
              function U(k) {
                if (k instanceof t.XRefEntryException && !u)
                  throw k;
                A.set(X++, [k, null]);
              }
              for (; w.length > 0; ) {
                const k = w.at(-1), {
                  currentNode: x,
                  posInKids: f
                } = k;
                let D = x.getRaw("Kids");
                if (D instanceof v.Ref)
                  try {
                    D = await Y.fetchAsync(D);
                  } catch (T) {
                    U(T);
                    break;
                  }
                if (!Array.isArray(D)) {
                  U(new a.FormatError("Page dictionary kids object is not an array."));
                  break;
                }
                if (f >= D.length) {
                  w.pop();
                  continue;
                }
                const _ = D[f];
                let S;
                if (_ instanceof v.Ref) {
                  if (O.has(_)) {
                    U(new a.FormatError("Pages tree contains circular reference."));
                    break;
                  }
                  O.put(_);
                  try {
                    S = await Y.fetchAsync(_);
                  } catch (T) {
                    U(T);
                    break;
                  }
                } else
                  S = _;
                if (!(S instanceof v.Dict)) {
                  U(new a.FormatError("Page dictionary kid reference points to wrong type of object."));
                  break;
                }
                let C = S.getRaw("Type");
                if (C instanceof v.Ref)
                  try {
                    C = await Y.fetchAsync(C);
                  } catch (T) {
                    U(T);
                    break;
                  }
                (0, v.isName)(C, "Page") || !S.has("Kids") ? B(S, _ instanceof v.Ref ? _ : null) : w.push({
                  currentNode: S,
                  posInKids: 0
                }), k.posInKids++;
              }
              return A;
            }
            getPageIndex(u) {
              const w = this.pageIndexCache.get(u);
              if (w !== void 0)
                return Promise.resolve(w);
              const O = this.xref;
              function b(j) {
                let X = 0, B;
                return O.fetchAsync(j).then(function(U) {
                  if ((0, v.isRefsEqual)(j, u) && !(0, v.isDict)(U, "Page") && !(U instanceof v.Dict && !U.has("Type") && U.has("Contents")))
                    throw new a.FormatError("The reference does not point to a /Page dictionary.");
                  if (!U)
                    return null;
                  if (!(U instanceof v.Dict))
                    throw new a.FormatError("Node must be a dictionary.");
                  return B = U.getRaw("Parent"), U.getAsync("Parent");
                }).then(function(U) {
                  if (!U)
                    return null;
                  if (!(U instanceof v.Dict))
                    throw new a.FormatError("Parent must be a dictionary.");
                  return U.getAsync("Kids");
                }).then(function(U) {
                  if (!U)
                    return null;
                  const k = [];
                  let x = !1;
                  for (let f = 0, D = U.length; f < D; f++) {
                    const _ = U[f];
                    if (!(_ instanceof v.Ref))
                      throw new a.FormatError("Kid must be a reference.");
                    if ((0, v.isRefsEqual)(_, j)) {
                      x = !0;
                      break;
                    }
                    k.push(O.fetchAsync(_).then(function(S) {
                      if (!(S instanceof v.Dict))
                        throw new a.FormatError("Kid node must be a dictionary.");
                      S.has("Count") ? X += S.get("Count") : X++;
                    }));
                  }
                  if (!x)
                    throw new a.FormatError("Kid reference not found in parent's kids.");
                  return Promise.all(k).then(function() {
                    return [X, B];
                  });
                });
              }
              let A = 0;
              const Y = (j) => b(j).then((X) => {
                if (!X)
                  return this.pageIndexCache.put(u, A), A;
                const [B, U] = X;
                return A += B, Y(U);
              });
              return Y(u);
            }
            get baseUrl() {
              const u = this._catDict.get("URI");
              if (u instanceof v.Dict) {
                const w = u.get("Base");
                if (typeof w == "string") {
                  const O = (0, a.createValidAbsoluteUrl)(w, null, {
                    tryConvertEncoding: !0
                  });
                  if (O)
                    return (0, a.shadow)(this, "baseUrl", O.href);
                }
              }
              return (0, a.shadow)(this, "baseUrl", null);
            }
            static parseDestDictionary(u) {
              const w = u.destDict;
              if (!(w instanceof v.Dict)) {
                (0, a.warn)("parseDestDictionary: `destDict` must be a dictionary.");
                return;
              }
              const O = u.resultObj;
              if (typeof O != "object") {
                (0, a.warn)("parseDestDictionary: `resultObj` must be an object.");
                return;
              }
              const b = u.docBaseUrl || null;
              let A = w.get("A"), Y, j;
              if (A instanceof v.Dict || (w.has("Dest") ? A = w.get("Dest") : (A = w.get("AA"), A instanceof v.Dict && (A.has("D") ? A = A.get("D") : A.has("U") && (A = A.get("U"))))), A instanceof v.Dict) {
                const X = A.get("S");
                if (!(X instanceof v.Name)) {
                  (0, a.warn)("parseDestDictionary: Invalid type in Action dictionary.");
                  return;
                }
                const B = X.name;
                switch (B) {
                  case "ResetForm":
                    const U = A.get("Flags"), k = ((typeof U == "number" ? U : 0) & 1) === 0, x = [], f = [];
                    for (const G of A.get("Fields") || [])
                      G instanceof v.Ref ? f.push(G.toString()) : typeof G == "string" && x.push((0, a.stringToPDFString)(G));
                    O.resetForm = {
                      fields: x,
                      refs: f,
                      include: k
                    };
                    break;
                  case "URI":
                    Y = A.get("URI"), Y instanceof v.Name && (Y = "/" + Y.name);
                    break;
                  case "GoTo":
                    j = A.get("D");
                    break;
                  case "Launch":
                  case "GoToR":
                    const D = A.get("F");
                    D instanceof v.Dict ? Y = D.get("F") || null : typeof D == "string" && (Y = D);
                    let _ = A.get("D");
                    if (_ && (_ instanceof v.Name && (_ = _.name), typeof Y == "string")) {
                      const G = Y.split("#")[0];
                      typeof _ == "string" ? Y = G + "#" + _ : Array.isArray(_) && (Y = G + "#" + JSON.stringify(_));
                    }
                    const S = A.get("NewWindow");
                    typeof S == "boolean" && (O.newWindow = S);
                    break;
                  case "Named":
                    const C = A.get("N");
                    C instanceof v.Name && (O.action = C.name);
                    break;
                  case "JavaScript":
                    const T = A.get("JS");
                    let P;
                    T instanceof e.BaseStream ? P = T.getString() : typeof T == "string" && (P = T);
                    const M = P && (0, t.recoverJsURL)((0, a.stringToPDFString)(P));
                    if (M) {
                      Y = M.url, O.newWindow = M.newWindow;
                      break;
                    }
                  default:
                    if (B === "JavaScript" || B === "SubmitForm")
                      break;
                    (0, a.warn)(`parseDestDictionary - unsupported action: "${B}".`);
                    break;
                }
              } else
                w.has("Dest") && (j = w.get("Dest"));
              if (typeof Y == "string") {
                const X = (0, a.createValidAbsoluteUrl)(Y, b, {
                  addDefaultProtocol: !0,
                  tryConvertEncoding: !0
                });
                X && (O.url = X.href), O.unsafeUrl = Y;
              }
              j && (j instanceof v.Name && (j = j.name), typeof j == "string" ? O.dest = (0, a.stringToPDFString)(j) : Array.isArray(j) && (O.dest = j));
            }
          }
          o.Catalog = i;
        },
        /* 70 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.NumberTree = o.NameTree = void 0;
          var t = F(5), a = F(2);
          class v {
            constructor(c, d, m) {
              this.constructor === v && (0, a.unreachable)("Cannot initialize NameOrNumberTree."), this.root = c, this.xref = d, this._type = m;
            }
            getAll() {
              const c = /* @__PURE__ */ new Map();
              if (!this.root)
                return c;
              const d = this.xref, m = new t.RefSet();
              m.put(this.root);
              const p = [this.root];
              for (; p.length > 0; ) {
                const g = d.fetchIfRef(p.shift());
                if (!(g instanceof t.Dict))
                  continue;
                if (g.has("Kids")) {
                  const i = g.get("Kids");
                  if (!Array.isArray(i))
                    continue;
                  for (const l of i) {
                    if (m.has(l))
                      throw new a.FormatError(`Duplicate entry in "${this._type}" tree.`);
                    p.push(l), m.put(l);
                  }
                  continue;
                }
                const n = g.get(this._type);
                if (Array.isArray(n))
                  for (let i = 0, l = n.length; i < l; i += 2)
                    c.set(d.fetchIfRef(n[i]), d.fetchIfRef(n[i + 1]));
              }
              return c;
            }
            get(c) {
              if (!this.root)
                return null;
              const d = this.xref;
              let m = d.fetchIfRef(this.root), p = 0;
              const g = 10;
              for (; m.has("Kids"); ) {
                if (++p > g)
                  return (0, a.warn)(`Search depth limit reached for "${this._type}" tree.`), null;
                const i = m.get("Kids");
                if (!Array.isArray(i))
                  return null;
                let l = 0, u = i.length - 1;
                for (; l <= u; ) {
                  const w = l + u >> 1, O = d.fetchIfRef(i[w]), b = O.get("Limits");
                  if (c < d.fetchIfRef(b[0]))
                    u = w - 1;
                  else if (c > d.fetchIfRef(b[1]))
                    l = w + 1;
                  else {
                    m = O;
                    break;
                  }
                }
                if (l > u)
                  return null;
              }
              const n = m.get(this._type);
              if (Array.isArray(n)) {
                let i = 0, l = n.length - 2;
                for (; i <= l; ) {
                  const u = i + l >> 1, w = u + (u & 1), O = d.fetchIfRef(n[w]);
                  if (c < O)
                    l = w - 2;
                  else if (c > O)
                    i = w + 2;
                  else
                    return d.fetchIfRef(n[w + 1]);
                }
              }
              return null;
            }
          }
          class h extends v {
            constructor(c, d) {
              super(c, d, "Names");
            }
          }
          o.NameTree = h;
          class e extends v {
            constructor(c, d) {
              super(c, d, "Nums");
            }
          }
          o.NumberTree = e;
        },
        /* 71 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.clearGlobalCaches = v;
          var t = F(5), a = F(40);
          function v() {
            (0, t.clearPrimitiveCaches)(), (0, a.clearUnicodeCaches)();
          }
        },
        /* 72 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.FileSpec = void 0;
          var t = F(2), a = F(7), v = F(5);
          function h(y) {
            return y.has("UF") ? y.get("UF") : y.has("F") ? y.get("F") : y.has("Unix") ? y.get("Unix") : y.has("Mac") ? y.get("Mac") : y.has("DOS") ? y.get("DOS") : null;
          }
          class e {
            constructor(c, d) {
              c instanceof v.Dict && (this.xref = d, this.root = c, c.has("FS") && (this.fs = c.get("FS")), this.description = c.has("Desc") ? (0, t.stringToPDFString)(c.get("Desc")) : "", c.has("RF") && (0, t.warn)("Related file specifications are not supported"), this.contentAvailable = !0, c.has("EF") || (this.contentAvailable = !1, (0, t.warn)("Non-embedded file specifications are not supported")));
            }
            get filename() {
              if (!this._filename && this.root) {
                const c = h(this.root) || "unnamed";
                this._filename = (0, t.stringToPDFString)(c).replace(/\\\\/g, "\\").replace(/\\\//g, "/").replace(/\\/g, "/");
              }
              return this._filename;
            }
            get content() {
              if (!this.contentAvailable)
                return null;
              !this.contentRef && this.root && (this.contentRef = h(this.root.get("EF")));
              let c = null;
              if (this.contentRef) {
                const d = this.xref.fetchIfRef(this.contentRef);
                d instanceof a.BaseStream ? c = d.getBytes() : (0, t.warn)("Embedded file specification points to non-existing/invalid content");
              } else
                (0, t.warn)("Embedded file specification does not have a content");
              return c;
            }
            get serializable() {
              return {
                filename: this.filename,
                content: this.content
              };
            }
          }
          o.FileSpec = e;
        },
        /* 73 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.MetadataParser = void 0;
          var t = F(66);
          class a {
            constructor(h) {
              h = this._repair(h);
              const y = new t.SimpleXMLParser({
                lowerCaseName: !0
              }).parseFromString(h);
              this._metadataMap = /* @__PURE__ */ new Map(), this._data = h, y && this._parse(y);
            }
            _repair(h) {
              return h.replace(/^[^<]+/, "").replace(/>\\376\\377([^<]+)/g, function(e, y) {
                const c = y.replace(/\\([0-3])([0-7])([0-7])/g, function(m, p, g, n) {
                  return String.fromCharCode(p * 64 + g * 8 + n * 1);
                }).replace(/&(amp|apos|gt|lt|quot);/g, function(m, p) {
                  switch (p) {
                    case "amp":
                      return "&";
                    case "apos":
                      return "'";
                    case "gt":
                      return ">";
                    case "lt":
                      return "<";
                    case "quot":
                      return '"';
                  }
                  throw new Error(`_repair: ${p} isn't defined.`);
                }), d = [];
                for (let m = 0, p = c.length; m < p; m += 2) {
                  const g = c.charCodeAt(m) * 256 + c.charCodeAt(m + 1);
                  g >= 32 && g < 127 && g !== 60 && g !== 62 && g !== 38 ? d.push(String.fromCharCode(g)) : d.push("&#x" + (65536 + g).toString(16).substring(1) + ";");
                }
                return ">" + d.join("");
              });
            }
            _getSequence(h) {
              const e = h.nodeName;
              return e !== "rdf:bag" && e !== "rdf:seq" && e !== "rdf:alt" ? null : h.childNodes.filter((y) => y.nodeName === "rdf:li");
            }
            _parseArray(h) {
              if (!h.hasChildNodes())
                return;
              const [e] = h.childNodes, y = this._getSequence(e) || [];
              this._metadataMap.set(h.nodeName, y.map((c) => c.textContent.trim()));
            }
            _parse(h) {
              let e = h.documentElement;
              if (e.nodeName !== "rdf:rdf")
                for (e = e.firstChild; e && e.nodeName !== "rdf:rdf"; )
                  e = e.nextSibling;
              if (!(!e || e.nodeName !== "rdf:rdf" || !e.hasChildNodes())) {
                for (const y of e.childNodes)
                  if (y.nodeName === "rdf:description")
                    for (const c of y.childNodes) {
                      const d = c.nodeName;
                      switch (d) {
                        case "#text":
                          continue;
                        case "dc:creator":
                        case "dc:subject":
                          this._parseArray(c);
                          continue;
                      }
                      this._metadataMap.set(d, c.textContent.trim());
                    }
              }
            }
            get serializable() {
              return {
                parsedData: this._metadataMap,
                rawData: this._data
              };
            }
          }
          o.MetadataParser = a;
        },
        /* 74 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.StructTreeRoot = o.StructTreePage = void 0;
          var t = F(5), a = F(2), v = F(70);
          const h = 40, e = {
            PAGE_CONTENT: "PAGE_CONTENT",
            STREAM_CONTENT: "STREAM_CONTENT",
            OBJECT: "OBJECT",
            ELEMENT: "ELEMENT"
          };
          class y {
            constructor(g) {
              this.dict = g, this.roleMap = /* @__PURE__ */ new Map();
            }
            init() {
              this.readRoleMap();
            }
            readRoleMap() {
              const g = this.dict.get("RoleMap");
              g instanceof t.Dict && g.forEach((n, i) => {
                i instanceof t.Name && this.roleMap.set(n, i.name);
              });
            }
          }
          o.StructTreeRoot = y;
          class c {
            constructor(g, n) {
              this.tree = g, this.dict = n, this.kids = [], this.parseKids();
            }
            get role() {
              const g = this.dict.get("S"), n = g instanceof t.Name ? g.name : "", {
                root: i
              } = this.tree;
              return i.roleMap.has(n) ? i.roleMap.get(n) : n;
            }
            parseKids() {
              let g = null;
              const n = this.dict.getRaw("Pg");
              n instanceof t.Ref && (g = n.toString());
              const i = this.dict.get("K");
              if (Array.isArray(i))
                for (const l of i) {
                  const u = this.parseKid(g, l);
                  u && this.kids.push(u);
                }
              else {
                const l = this.parseKid(g, i);
                l && this.kids.push(l);
              }
            }
            parseKid(g, n) {
              if (Number.isInteger(n))
                return this.tree.pageDict.objId !== g ? null : new d({
                  type: e.PAGE_CONTENT,
                  mcid: n,
                  pageObjId: g
                });
              let i = null;
              if (n instanceof t.Ref ? i = this.dict.xref.fetch(n) : n instanceof t.Dict && (i = n), !i)
                return null;
              const l = i.getRaw("Pg");
              l instanceof t.Ref && (g = l.toString());
              const u = i.get("Type") instanceof t.Name ? i.get("Type").name : null;
              return u === "MCR" ? this.tree.pageDict.objId !== g ? null : new d({
                type: e.STREAM_CONTENT,
                refObjId: i.getRaw("Stm") instanceof t.Ref ? i.getRaw("Stm").toString() : null,
                pageObjId: g,
                mcid: i.get("MCID")
              }) : u === "OBJR" ? this.tree.pageDict.objId !== g ? null : new d({
                type: e.OBJECT,
                refObjId: i.getRaw("Obj") instanceof t.Ref ? i.getRaw("Obj").toString() : null,
                pageObjId: g
              }) : new d({
                type: e.ELEMENT,
                dict: i
              });
            }
          }
          class d {
            constructor({
              type: g,
              dict: n = null,
              mcid: i = null,
              pageObjId: l = null,
              refObjId: u = null
            }) {
              this.type = g, this.dict = n, this.mcid = i, this.pageObjId = l, this.refObjId = u, this.parentNode = null;
            }
          }
          class m {
            constructor(g, n) {
              this.root = g, this.rootDict = g ? g.dict : null, this.pageDict = n, this.nodes = [];
            }
            parse() {
              if (!this.root || !this.rootDict)
                return;
              const g = this.rootDict.get("ParentTree");
              if (!g)
                return;
              const n = this.pageDict.get("StructParents");
              if (!Number.isInteger(n))
                return;
              const l = new v.NumberTree(g, this.rootDict.xref).get(n);
              if (!Array.isArray(l))
                return;
              const u = /* @__PURE__ */ new Map();
              for (const w of l)
                w instanceof t.Ref && this.addNode(this.rootDict.xref.fetch(w), u);
            }
            addNode(g, n, i = 0) {
              if (i > h)
                return (0, a.warn)("StructTree MAX_DEPTH reached."), null;
              if (n.has(g))
                return n.get(g);
              const l = new c(this, g);
              n.set(g, l);
              const u = g.get("P");
              if (!u || (0, t.isName)(u.get("Type"), "StructTreeRoot"))
                return this.addTopLevelNode(g, l) || n.delete(g), l;
              const w = this.addNode(u, n, i + 1);
              if (!w)
                return l;
              let O = !1;
              for (const b of w.kids)
                b.type === e.ELEMENT && b.dict === g && (b.parentNode = l, O = !0);
              return O || n.delete(g), l;
            }
            addTopLevelNode(g, n) {
              const i = this.rootDict.get("K");
              if (!i)
                return !1;
              if (i instanceof t.Dict)
                return i.objId !== g.objId ? !1 : (this.nodes[0] = n, !0);
              if (!Array.isArray(i))
                return !0;
              let l = !1;
              for (let u = 0; u < i.length; u++) {
                const w = i[u];
                w && w.toString() === g.objId && (this.nodes[u] = n, l = !0);
              }
              return l;
            }
            get serializable() {
              function g(i, l, u = 0) {
                if (u > h) {
                  (0, a.warn)("StructTree too deep to be fully serialized.");
                  return;
                }
                const w = /* @__PURE__ */ Object.create(null);
                w.role = i.role, w.children = [], l.children.push(w);
                const O = i.dict.get("Alt");
                typeof O == "string" && (w.alt = (0, a.stringToPDFString)(O));
                const b = i.dict.get("Lang");
                typeof b == "string" && (w.lang = (0, a.stringToPDFString)(b));
                for (const A of i.kids) {
                  const Y = A.type === e.ELEMENT ? A.parentNode : null;
                  if (Y) {
                    g(Y, w, u + 1);
                    continue;
                  } else
                    A.type === e.PAGE_CONTENT || A.type === e.STREAM_CONTENT ? w.children.push({
                      type: "content",
                      id: `page${A.pageObjId}_mcid${A.mcid}`
                    }) : A.type === e.OBJECT && w.children.push({
                      type: "object",
                      id: A.refObjId
                    });
                }
              }
              const n = /* @__PURE__ */ Object.create(null);
              n.children = [], n.role = "Root";
              for (const i of this.nodes)
                i && g(i, n);
              return n;
            }
          }
          o.StructTreePage = m;
        },
        /* 75 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.ObjectLoader = void 0;
          var t = F(5), a = F(7), v = F(6), h = F(2);
          function e(d) {
            return d instanceof t.Ref || d instanceof t.Dict || d instanceof a.BaseStream || Array.isArray(d);
          }
          function y(d, m) {
            if (d instanceof t.Dict)
              d = d.getRawValues();
            else if (d instanceof a.BaseStream)
              d = d.dict.getRawValues();
            else if (!Array.isArray(d))
              return;
            for (const p of d)
              e(p) && m.push(p);
          }
          class c {
            constructor(m, p, g) {
              this.dict = m, this.keys = p, this.xref = g, this.refSet = null;
            }
            async load() {
              if (this.xref.stream.isDataLoaded)
                return;
              const {
                keys: m,
                dict: p
              } = this;
              this.refSet = new t.RefSet();
              const g = [];
              for (let n = 0, i = m.length; n < i; n++) {
                const l = p.getRaw(m[n]);
                l !== void 0 && g.push(l);
              }
              return this._walk(g);
            }
            async _walk(m) {
              const p = [], g = [];
              for (; m.length; ) {
                let n = m.pop();
                if (n instanceof t.Ref) {
                  if (this.refSet.has(n))
                    continue;
                  try {
                    this.refSet.put(n), n = this.xref.fetch(n);
                  } catch (i) {
                    if (!(i instanceof v.MissingDataException)) {
                      (0, h.warn)(`ObjectLoader._walk - requesting all data: "${i}".`), this.refSet = null;
                      const {
                        manager: l
                      } = this.xref.stream;
                      return l.requestAllChunks();
                    }
                    p.push(n), g.push({
                      begin: i.begin,
                      end: i.end
                    });
                  }
                }
                if (n instanceof a.BaseStream) {
                  const i = n.getBaseStreams();
                  if (i) {
                    let l = !1;
                    for (const u of i)
                      u.isDataLoaded || (l = !0, g.push({
                        begin: u.start,
                        end: u.end
                      }));
                    l && p.push(n);
                  }
                }
                y(n, m);
              }
              if (g.length) {
                await this.xref.stream.manager.requestRanges(g);
                for (const n of p)
                  n instanceof t.Ref && this.refSet.remove(n);
                return this._walk(p);
              }
              this.refSet = null;
            }
          }
          o.ObjectLoader = c;
        },
        /* 76 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.XFAFactory = void 0;
          var t = F(77), a = F(81), v = F(87), h = F(85), e = F(78), y = F(2), c = F(88), d = F(98);
          class m {
            constructor(g) {
              try {
                this.root = new c.XFAParser().parse(m._createDocument(g));
                const n = new a.Binder(this.root);
                this.form = n.bind(), this.dataHandler = new v.DataHandler(this.root, n.getData()), this.form[t.$globalData].template = this.form;
              } catch (n) {
                (0, y.warn)(`XFA - an error occurred during parsing and binding: ${n}`);
              }
            }
            isValid() {
              return this.root && this.form;
            }
            _createPagesHelper() {
              const g = this.form[t.$toPages]();
              return new Promise((n, i) => {
                const l = () => {
                  try {
                    const u = g.next();
                    u.done ? n(u.value) : setTimeout(l, 0);
                  } catch (u) {
                    i(u);
                  }
                };
                setTimeout(l, 0);
              });
            }
            async _createPages() {
              try {
                this.pages = await this._createPagesHelper(), this.dims = this.pages.children.map((g) => {
                  const {
                    width: n,
                    height: i
                  } = g.attributes.style;
                  return [0, 0, parseInt(n), parseInt(i)];
                });
              } catch (g) {
                (0, y.warn)(`XFA - an error occurred during layout: ${g}`);
              }
            }
            getBoundingBox(g) {
              return this.dims[g];
            }
            async getNumPages() {
              return this.pages || await this._createPages(), this.dims.length;
            }
            setImages(g) {
              this.form[t.$globalData].images = g;
            }
            setFonts(g) {
              this.form[t.$globalData].fontFinder = new h.FontFinder(g);
              const n = [];
              for (let i of this.form[t.$globalData].usedTypefaces)
                i = (0, e.stripQuotes)(i), this.form[t.$globalData].fontFinder.find(i) || n.push(i);
              return n.length > 0 ? n : null;
            }
            appendFonts(g, n) {
              this.form[t.$globalData].fontFinder.add(g, n);
            }
            async getPages() {
              this.pages || await this._createPages();
              const g = this.pages;
              return this.pages = null, g;
            }
            serializeData(g) {
              return this.dataHandler.serialize(g);
            }
            static _createDocument(g) {
              return g["/xdp:xdp"] ? Object.values(g).join("") : g["xdp:xdp"];
            }
            static getRichTextAsHtml(g) {
              if (!g || typeof g != "string")
                return null;
              try {
                let n = new c.XFAParser(d.XhtmlNamespace, !0).parse(g);
                if (!["body", "xhtml"].includes(n[t.$nodeName])) {
                  const w = d.XhtmlNamespace.body({});
                  w[t.$appendChild](n), n = w;
                }
                const i = n[t.$toHTML]();
                if (!i.success)
                  return null;
                const {
                  html: l
                } = i, {
                  attributes: u
                } = l;
                return u && (u.class && (u.class = u.class.filter((w) => !w.startsWith("xfa"))), u.dir = "auto"), {
                  html: l,
                  str: n[t.$text]()
                };
              } catch (n) {
                (0, y.warn)(`XFA - an error occurred during parsing of rich text: ${n}`);
              }
              return null;
            }
          }
          o.XFAFactory = m;
        },
        /* 77 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.XmlObject = o.XFAObjectArray = o.XFAObject = o.XFAAttribute = o.StringObject = o.OptionObject = o.Option10 = o.Option01 = o.IntegerObject = o.ContentObject = o.$uid = o.$toStyle = o.$toString = o.$toPages = o.$toHTML = o.$text = o.$tabIndex = o.$setValue = o.$setSetAttributes = o.$setId = o.$searchNode = o.$root = o.$resolvePrototypes = o.$removeChild = o.$pushPara = o.$pushGlyphs = o.$popPara = o.$onText = o.$onChildCheck = o.$onChild = o.$nsAttributes = o.$nodeName = o.$namespaceId = o.$isUsable = o.$isTransparent = o.$isThereMoreWidth = o.$isSplittable = o.$isNsAgnostic = o.$isDescendent = o.$isDataValue = o.$isCDATAXml = o.$isBindable = o.$insertAt = o.$indexOf = o.$ids = o.$hasSettableValue = o.$globalData = o.$getTemplateRoot = o.$getSubformParent = o.$getRealChildrenByNameIt = o.$getParent = o.$getNextPage = o.$getExtra = o.$getDataValue = o.$getContainedChildren = o.$getChildrenByNameIt = o.$getChildrenByName = o.$getChildrenByClass = o.$getChildren = o.$getAvailableSpace = o.$getAttributes = o.$getAttributeIt = o.$flushHTML = o.$finalize = o.$extra = o.$dump = o.$data = o.$content = o.$consumed = o.$clone = o.$cleanup = o.$cleanPage = o.$clean = o.$childrenToHTML = o.$appendChild = o.$addHTML = o.$acceptWhitespace = void 0;
          var t = F(78), a = F(2), v = F(6), h = F(79), e = F(80);
          const y = Symbol();
          o.$acceptWhitespace = y;
          const c = Symbol();
          o.$addHTML = c;
          const d = Symbol();
          o.$appendChild = d;
          const m = Symbol();
          o.$childrenToHTML = m;
          const p = Symbol();
          o.$clean = p;
          const g = Symbol();
          o.$cleanPage = g;
          const n = Symbol();
          o.$cleanup = n;
          const i = Symbol();
          o.$clone = i;
          const l = Symbol();
          o.$consumed = l;
          const u = Symbol("content");
          o.$content = u;
          const w = Symbol("data");
          o.$data = w;
          const O = Symbol();
          o.$dump = O;
          const b = Symbol("extra");
          o.$extra = b;
          const A = Symbol();
          o.$finalize = A;
          const Y = Symbol();
          o.$flushHTML = Y;
          const j = Symbol();
          o.$getAttributeIt = j;
          const X = Symbol();
          o.$getAttributes = X;
          const B = Symbol();
          o.$getAvailableSpace = B;
          const U = Symbol();
          o.$getChildrenByClass = U;
          const k = Symbol();
          o.$getChildrenByName = k;
          const x = Symbol();
          o.$getChildrenByNameIt = x;
          const f = Symbol();
          o.$getDataValue = f;
          const D = Symbol();
          o.$getExtra = D;
          const _ = Symbol();
          o.$getRealChildrenByNameIt = _;
          const S = Symbol();
          o.$getChildren = S;
          const C = Symbol();
          o.$getContainedChildren = C;
          const T = Symbol();
          o.$getNextPage = T;
          const P = Symbol();
          o.$getSubformParent = P;
          const M = Symbol();
          o.$getParent = M;
          const G = Symbol();
          o.$getTemplateRoot = G;
          const Z = Symbol();
          o.$globalData = Z;
          const $ = Symbol();
          o.$hasSettableValue = $;
          const z = Symbol();
          o.$ids = z;
          const V = Symbol();
          o.$indexOf = V;
          const L = Symbol();
          o.$insertAt = L;
          const K = Symbol();
          o.$isCDATAXml = K;
          const ne = Symbol();
          o.$isBindable = ne;
          const se = Symbol();
          o.$isDataValue = se;
          const q = Symbol();
          o.$isDescendent = q;
          const N = Symbol();
          o.$isNsAgnostic = N;
          const Q = Symbol();
          o.$isSplittable = Q;
          const E = Symbol();
          o.$isThereMoreWidth = E;
          const te = Symbol();
          o.$isTransparent = te;
          const oe = Symbol();
          o.$isUsable = oe;
          const ee = Symbol(), W = Symbol("namespaceId");
          o.$namespaceId = W;
          const I = Symbol("nodeName");
          o.$nodeName = I;
          const H = Symbol();
          o.$nsAttributes = H;
          const ie = Symbol();
          o.$onChild = ie;
          const ue = Symbol();
          o.$onChildCheck = ue;
          const fe = Symbol();
          o.$onText = fe;
          const de = Symbol();
          o.$pushGlyphs = de;
          const pe = Symbol();
          o.$popPara = pe;
          const xe = Symbol();
          o.$pushPara = xe;
          const Fe = Symbol();
          o.$removeChild = Fe;
          const Se = Symbol("root");
          o.$root = Se;
          const Ce = Symbol();
          o.$resolvePrototypes = Ce;
          const ke = Symbol();
          o.$searchNode = ke;
          const ye = Symbol();
          o.$setId = ye;
          const De = Symbol();
          o.$setSetAttributes = De;
          const Ae = Symbol();
          o.$setValue = Ae;
          const Te = Symbol();
          o.$tabIndex = Te;
          const ve = Symbol();
          o.$text = ve;
          const Ne = Symbol();
          o.$toPages = Ne;
          const Ge = Symbol();
          o.$toHTML = Ge;
          const it = Symbol();
          o.$toString = it;
          const Me = Symbol();
          o.$toStyle = Me;
          const Ie = Symbol("uid");
          o.$uid = Ie;
          const Ee = Symbol(), st = Symbol(), Qe = Symbol(), ct = Symbol("_children"), xt = Symbol(), Je = Symbol(), mt = Symbol(), _t = Symbol(), Xe = Symbol(), Ct = Symbol(), bt = Symbol(), Pe = Symbol(), qe = Symbol(), ot = Symbol("parent"), lt = Symbol(), Ut = Symbol(), Nt = Symbol();
          let Ve = 0;
          const je = h.NamespaceIds.datasets.id;
          class at {
            constructor(Ue, We, rt = !1) {
              this[W] = Ue, this[I] = We, this[bt] = rt, this[ot] = null, this[ct] = [], this[Ie] = `${We}${Ve++}`, this[Z] = null;
            }
            [ie](Ue) {
              if (!this[bt] || !this[ue](Ue))
                return !1;
              const We = Ue[I], rt = this[We];
              if (rt instanceof nt) {
                if (rt.push(Ue))
                  return this[d](Ue), !0;
              } else
                return rt !== null && this[Fe](rt), this[We] = Ue, this[d](Ue), !0;
              let tt = "";
              return this.id ? tt = ` (id: ${this.id})` : this.name && (tt = ` (name: ${this.name} ${this.h.value})`), (0, a.warn)(`XFA - node "${this[I]}"${tt} has already enough "${We}"!`), !1;
            }
            [ue](Ue) {
              return this.hasOwnProperty(Ue[I]) && Ue[W] === this[W];
            }
            [N]() {
              return !1;
            }
            [y]() {
              return !1;
            }
            [K]() {
              return !1;
            }
            [ne]() {
              return !1;
            }
            [pe]() {
              this.para && this[G]()[b].paraStack.pop();
            }
            [xe]() {
              this[G]()[b].paraStack.push(this.para);
            }
            [ye](Ue) {
              this.id && this[W] === h.NamespaceIds.template.id && Ue.set(this.id, this);
            }
            [G]() {
              return this[Z].template;
            }
            [Q]() {
              return !1;
            }
            [E]() {
              return !1;
            }
            [d](Ue) {
              Ue[ot] = this, this[ct].push(Ue), !Ue[Z] && this[Z] && (Ue[Z] = this[Z]);
            }
            [Fe](Ue) {
              const We = this[ct].indexOf(Ue);
              this[ct].splice(We, 1);
            }
            [$]() {
              return this.hasOwnProperty("value");
            }
            [Ae](Ue) {
            }
            [fe](Ue) {
            }
            [A]() {
            }
            [p](Ue) {
              delete this[bt], this[n] && (Ue.clean(this[n]), delete this[n]);
            }
            [V](Ue) {
              return this[ct].indexOf(Ue);
            }
            [L](Ue, We) {
              We[ot] = this, this[ct].splice(Ue, 0, We), !We[Z] && this[Z] && (We[Z] = this[Z]);
            }
            [te]() {
              return !this.name;
            }
            [ee]() {
              return "";
            }
            [ve]() {
              return this[ct].length === 0 ? this[u] : this[ct].map((Ue) => Ue[ve]()).join("");
            }
            get [Qe]() {
              const Ue = Object.getPrototypeOf(this);
              if (!Ue._attributes) {
                const We = Ue._attributes = /* @__PURE__ */ new Set();
                for (const rt of Object.getOwnPropertyNames(this)) {
                  if (this[rt] === null || this[rt] instanceof at || this[rt] instanceof nt)
                    break;
                  We.add(rt);
                }
              }
              return (0, a.shadow)(this, Qe, Ue._attributes);
            }
            [q](Ue) {
              let We = this;
              for (; We; ) {
                if (We === Ue)
                  return !0;
                We = We[M]();
              }
              return !1;
            }
            [M]() {
              return this[ot];
            }
            [P]() {
              return this[M]();
            }
            [S](Ue = null) {
              return Ue ? this[Ue] : this[ct];
            }
            [O]() {
              const Ue = /* @__PURE__ */ Object.create(null);
              this[u] && (Ue.$content = this[u]);
              for (const We of Object.getOwnPropertyNames(this)) {
                const rt = this[We];
                rt !== null && (rt instanceof at ? Ue[We] = rt[O]() : rt instanceof nt ? rt.isEmpty() || (Ue[We] = rt.dump()) : Ue[We] = rt);
              }
              return Ue;
            }
            [Me]() {
              return null;
            }
            [Ge]() {
              return t.HTMLResult.EMPTY;
            }
            *[C]() {
              for (const Ue of this[S]())
                yield Ue;
            }
            *[_t](Ue, We) {
              for (const rt of this[C]())
                if (!Ue || We === Ue.has(rt[I])) {
                  const tt = this[B](), St = rt[Ge](tt);
                  St.success || (this[b].failingNode = rt), yield St;
                }
            }
            [Y]() {
              return null;
            }
            [c](Ue, We) {
              this[b].children.push(Ue);
            }
            [B]() {
            }
            [m]({
              filter: Ue = null,
              include: We = !0
            }) {
              if (!this[b].generator)
                this[b].generator = this[_t](Ue, We);
              else {
                const rt = this[B](), tt = this[b].failingNode[Ge](rt);
                if (!tt.success)
                  return tt;
                tt.html && this[c](tt.html, tt.bbox), delete this[b].failingNode;
              }
              for (; ; ) {
                const rt = this[b].generator.next();
                if (rt.done)
                  break;
                const tt = rt.value;
                if (!tt.success)
                  return tt;
                tt.html && this[c](tt.html, tt.bbox);
              }
              return this[b].generator = null, t.HTMLResult.EMPTY;
            }
            [De](Ue) {
              this[Ut] = new Set(Object.keys(Ue));
            }
            [Ct](Ue) {
              const We = this[Qe], rt = this[Ut];
              return [...Ue].filter((tt) => We.has(tt) && !rt.has(tt));
            }
            [Ce](Ue, We = /* @__PURE__ */ new Set()) {
              for (const rt of this[ct])
                rt[lt](Ue, We);
            }
            [lt](Ue, We) {
              const rt = this[Xe](Ue, We);
              rt ? this[Ee](rt, Ue, We) : this[Ce](Ue, We);
            }
            [Xe](Ue, We) {
              const {
                use: rt,
                usehref: tt
              } = this;
              if (!rt && !tt)
                return null;
              let St = null, Pt = null, qt = null, Mt = rt;
              if (tt ? (Mt = tt, tt.startsWith("#som(") && tt.endsWith(")") ? Pt = tt.slice(5, tt.length - 1) : tt.startsWith(".#som(") && tt.endsWith(")") ? Pt = tt.slice(6, tt.length - 1) : tt.startsWith("#") ? qt = tt.slice(1) : tt.startsWith(".#") && (qt = tt.slice(2))) : rt.startsWith("#") ? qt = rt.slice(1) : Pt = rt, this.use = this.usehref = "", qt ? St = Ue.get(qt) : (St = (0, e.searchNode)(Ue.get(Se), this, Pt, !0, !1), St && (St = St[0])), !St)
                return (0, a.warn)(`XFA - Invalid prototype reference: ${Mt}.`), null;
              if (St[I] !== this[I])
                return (0, a.warn)(`XFA - Incompatible prototype: ${St[I]} !== ${this[I]}.`), null;
              if (We.has(St))
                return (0, a.warn)("XFA - Cycle detected in prototypes use."), null;
              We.add(St);
              const Wt = St[Xe](Ue, We);
              return Wt && St[Ee](Wt, Ue, We), St[Ce](Ue, We), We.delete(St), St;
            }
            [Ee](Ue, We, rt) {
              if (rt.has(Ue)) {
                (0, a.warn)("XFA - Cycle detected in prototypes use.");
                return;
              }
              !this[u] && Ue[u] && (this[u] = Ue[u]), new Set(rt).add(Ue);
              for (const St of this[Ct](Ue[Ut]))
                this[St] = Ue[St], this[Ut] && this[Ut].add(St);
              for (const St of Object.getOwnPropertyNames(this)) {
                if (this[Qe].has(St))
                  continue;
                const Pt = this[St], qt = Ue[St];
                if (Pt instanceof nt) {
                  for (const Mt of Pt[ct])
                    Mt[lt](We, rt);
                  for (let Mt = Pt[ct].length, Wt = qt[ct].length; Mt < Wt; Mt++) {
                    const Zt = Ue[ct][Mt][i]();
                    if (Pt.push(Zt))
                      Zt[ot] = this, this[ct].push(Zt), Zt[lt](We, rt);
                    else
                      break;
                  }
                  continue;
                }
                if (Pt !== null) {
                  Pt[Ce](We, rt), qt && Pt[Ee](qt, We, rt);
                  continue;
                }
                if (qt !== null) {
                  const Mt = qt[i]();
                  Mt[ot] = this, this[St] = Mt, this[ct].push(Mt), Mt[lt](We, rt);
                }
              }
            }
            static [xt](Ue) {
              return Array.isArray(Ue) ? Ue.map((We) => at[xt](We)) : typeof Ue == "object" && Ue !== null ? Object.assign({}, Ue) : Ue;
            }
            [i]() {
              const Ue = Object.create(Object.getPrototypeOf(this));
              for (const We of Object.getOwnPropertySymbols(this))
                try {
                  Ue[We] = this[We];
                } catch {
                  (0, a.shadow)(Ue, We, this[We]);
                }
              Ue[Ie] = `${Ue[I]}${Ve++}`, Ue[ct] = [];
              for (const We of Object.getOwnPropertyNames(this)) {
                if (this[Qe].has(We)) {
                  Ue[We] = at[xt](this[We]);
                  continue;
                }
                const rt = this[We];
                rt instanceof nt ? Ue[We] = new nt(rt[Pe]) : Ue[We] = null;
              }
              for (const We of this[ct]) {
                const rt = We[I], tt = We[i]();
                Ue[ct].push(tt), tt[ot] = Ue, Ue[rt] === null ? Ue[rt] = tt : Ue[rt][ct].push(tt);
              }
              return Ue;
            }
            [S](Ue = null) {
              return Ue ? this[ct].filter((We) => We[I] === Ue) : this[ct];
            }
            [U](Ue) {
              return this[Ue];
            }
            [k](Ue, We, rt = !0) {
              return Array.from(this[x](Ue, We, rt));
            }
            *[x](Ue, We, rt = !0) {
              if (Ue === "parent") {
                yield this[ot];
                return;
              }
              for (const tt of this[ct])
                tt[I] === Ue && (yield tt), tt.name === Ue && (yield tt), (We || tt[te]()) && (yield* tt[x](Ue, We, !1));
              rt && this[Qe].has(Ue) && (yield new ft(this, Ue, this[Ue]));
            }
          }
          o.XFAObject = at;
          class nt {
            constructor(Ue = 1 / 0) {
              this[Pe] = Ue, this[ct] = [];
            }
            push(Ue) {
              return this[ct].length <= this[Pe] ? (this[ct].push(Ue), !0) : ((0, a.warn)(`XFA - node "${Ue[I]}" accepts no more than ${this[Pe]} children`), !1);
            }
            isEmpty() {
              return this[ct].length === 0;
            }
            dump() {
              return this[ct].length === 1 ? this[ct][0][O]() : this[ct].map((Ue) => Ue[O]());
            }
            [i]() {
              const Ue = new nt(this[Pe]);
              return Ue[ct] = this[ct].map((We) => We[i]()), Ue;
            }
            get children() {
              return this[ct];
            }
            clear() {
              this[ct].length = 0;
            }
          }
          o.XFAObjectArray = nt;
          class ft {
            constructor(Ue, We, rt) {
              this[ot] = Ue, this[I] = We, this[u] = rt, this[l] = !1, this[Ie] = `attribute${Ve++}`;
            }
            [M]() {
              return this[ot];
            }
            [se]() {
              return !0;
            }
            [f]() {
              return this[u].trim();
            }
            [Ae](Ue) {
              Ue = Ue.value || "", this[u] = Ue.toString();
            }
            [ve]() {
              return this[u];
            }
            [q](Ue) {
              return this[ot] === Ue || this[ot][q](Ue);
            }
          }
          o.XFAAttribute = ft;
          class Tt extends at {
            constructor(Ue, We, rt = {}) {
              if (super(Ue, We), this[u] = "", this[Je] = null, We !== "#text") {
                const tt = /* @__PURE__ */ new Map();
                this[st] = tt;
                for (const [St, Pt] of Object.entries(rt))
                  tt.set(St, new ft(this, St, Pt));
                if (rt.hasOwnProperty(H)) {
                  const St = rt[H].xfa.dataNode;
                  St !== void 0 && (St === "dataGroup" ? this[Je] = !1 : St === "dataValue" && (this[Je] = !0));
                }
              }
              this[l] = !1;
            }
            [it](Ue) {
              const We = this[I];
              if (We === "#text") {
                Ue.push((0, v.encodeToXmlString)(this[u]));
                return;
              }
              const rt = (0, a.utf8StringToString)(We), tt = this[W] === je ? "xfa:" : "";
              Ue.push(`<${tt}${rt}`);
              for (const [St, Pt] of this[st].entries()) {
                const qt = (0, a.utf8StringToString)(St);
                Ue.push(` ${qt}="${(0, v.encodeToXmlString)(Pt[u])}"`);
              }
              if (this[Je] !== null && (this[Je] ? Ue.push(' xfa:dataNode="dataValue"') : Ue.push(' xfa:dataNode="dataGroup"')), !this[u] && this[ct].length === 0) {
                Ue.push("/>");
                return;
              }
              if (Ue.push(">"), this[u])
                typeof this[u] == "string" ? Ue.push((0, v.encodeToXmlString)(this[u])) : this[u][it](Ue);
              else
                for (const St of this[ct])
                  St[it](Ue);
              Ue.push(`</${tt}${rt}>`);
            }
            [ie](Ue) {
              if (this[u]) {
                const We = new Tt(this[W], "#text");
                this[d](We), We[u] = this[u], this[u] = "";
              }
              return this[d](Ue), !0;
            }
            [fe](Ue) {
              this[u] += Ue;
            }
            [A]() {
              if (this[u] && this[ct].length > 0) {
                const Ue = new Tt(this[W], "#text");
                this[d](Ue), Ue[u] = this[u], delete this[u];
              }
            }
            [Ge]() {
              return this[I] === "#text" ? t.HTMLResult.success({
                name: "#text",
                value: this[u]
              }) : t.HTMLResult.EMPTY;
            }
            [S](Ue = null) {
              return Ue ? this[ct].filter((We) => We[I] === Ue) : this[ct];
            }
            [X]() {
              return this[st];
            }
            [U](Ue) {
              const We = this[st].get(Ue);
              return We !== void 0 ? We : this[S](Ue);
            }
            *[x](Ue, We) {
              const rt = this[st].get(Ue);
              rt && (yield rt);
              for (const tt of this[ct])
                tt[I] === Ue && (yield tt), We && (yield* tt[x](Ue, We));
            }
            *[j](Ue, We) {
              const rt = this[st].get(Ue);
              rt && (!We || !rt[l]) && (yield rt);
              for (const tt of this[ct])
                yield* tt[j](Ue, We);
            }
            *[_](Ue, We, rt) {
              for (const tt of this[ct])
                tt[I] === Ue && (!rt || !tt[l]) && (yield tt), We && (yield* tt[_](Ue, We, rt));
            }
            [se]() {
              return this[Je] === null ? this[ct].length === 0 || this[ct][0][W] === h.NamespaceIds.xhtml.id : this[Je];
            }
            [f]() {
              return this[Je] === null ? this[ct].length === 0 ? this[u].trim() : this[ct][0][W] === h.NamespaceIds.xhtml.id ? this[ct][0][ve]().trim() : null : this[u].trim();
            }
            [Ae](Ue) {
              Ue = Ue.value || "", this[u] = Ue.toString();
            }
            [O](Ue = !1) {
              const We = /* @__PURE__ */ Object.create(null);
              Ue && (We.$ns = this[W]), this[u] && (We.$content = this[u]), We.$name = this[I], We.children = [];
              for (const rt of this[ct])
                We.children.push(rt[O](Ue));
              We.attributes = /* @__PURE__ */ Object.create(null);
              for (const [rt, tt] of this[st])
                We.attributes[rt] = tt[u];
              return We;
            }
          }
          o.XmlObject = Tt;
          class yt extends at {
            constructor(Ue, We) {
              super(Ue, We), this[u] = "";
            }
            [fe](Ue) {
              this[u] += Ue;
            }
            [A]() {
            }
          }
          o.ContentObject = yt;
          class dt extends yt {
            constructor(Ue, We, rt) {
              super(Ue, We), this[qe] = rt;
            }
            [A]() {
              this[u] = (0, t.getKeyword)({
                data: this[u],
                defaultValue: this[qe][0],
                validate: (Ue) => this[qe].includes(Ue)
              });
            }
            [p](Ue) {
              super[p](Ue), delete this[qe];
            }
          }
          o.OptionObject = dt;
          class wt extends yt {
            [A]() {
              this[u] = this[u].trim();
            }
          }
          o.StringObject = wt;
          class Dt extends yt {
            constructor(Ue, We, rt, tt) {
              super(Ue, We), this[mt] = rt, this[Nt] = tt;
            }
            [A]() {
              this[u] = (0, t.getInteger)({
                data: this[u],
                defaultValue: this[mt],
                validate: this[Nt]
              });
            }
            [p](Ue) {
              super[p](Ue), delete this[mt], delete this[Nt];
            }
          }
          o.IntegerObject = Dt;
          class jt extends Dt {
            constructor(Ue, We) {
              super(Ue, We, 0, (rt) => rt === 1);
            }
          }
          o.Option01 = jt;
          class Bt extends Dt {
            constructor(Ue, We) {
              super(Ue, We, 1, (rt) => rt === 0);
            }
          }
          o.Option10 = Bt;
        },
        /* 78 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.HTMLResult = void 0, o.getBBox = i, o.getColor = n, o.getFloat = y, o.getInteger = e, o.getKeyword = c, o.getMeasurement = m, o.getRatio = p, o.getRelevant = g, o.getStringOption = d, o.stripQuotes = h;
          var t = F(2);
          const a = {
            pt: (u) => u,
            cm: (u) => u / 2.54 * 72,
            mm: (u) => u / (10 * 2.54) * 72,
            in: (u) => u * 72,
            px: (u) => u
          }, v = /([+-]?\d+\.?\d*)(.*)/;
          function h(u) {
            return u.startsWith("'") || u.startsWith('"') ? u.slice(1, u.length - 1) : u;
          }
          function e({
            data: u,
            defaultValue: w,
            validate: O
          }) {
            if (!u)
              return w;
            u = u.trim();
            const b = parseInt(u, 10);
            return !isNaN(b) && O(b) ? b : w;
          }
          function y({
            data: u,
            defaultValue: w,
            validate: O
          }) {
            if (!u)
              return w;
            u = u.trim();
            const b = parseFloat(u);
            return !isNaN(b) && O(b) ? b : w;
          }
          function c({
            data: u,
            defaultValue: w,
            validate: O
          }) {
            return u ? (u = u.trim(), O(u) ? u : w) : w;
          }
          function d(u, w) {
            return c({
              data: u,
              defaultValue: w[0],
              validate: (O) => w.includes(O)
            });
          }
          function m(u, w = "0") {
            if (w = w || "0", !u)
              return m(w);
            const O = u.trim().match(v);
            if (!O)
              return m(w);
            const [, b, A] = O, Y = parseFloat(b);
            if (isNaN(Y))
              return m(w);
            if (Y === 0)
              return 0;
            const j = a[A];
            return j ? j(Y) : Y;
          }
          function p(u) {
            if (!u)
              return {
                num: 1,
                den: 1
              };
            const w = u.trim().split(/\s*:\s*/).map((A) => parseFloat(A)).filter((A) => !isNaN(A));
            if (w.length === 1 && w.push(1), w.length === 0)
              return {
                num: 1,
                den: 1
              };
            const [O, b] = w;
            return {
              num: O,
              den: b
            };
          }
          function g(u) {
            return u ? u.trim().split(/\s+/).map((w) => ({
              excluded: w[0] === "-",
              viewname: w.substring(1)
            })) : [];
          }
          function n(u, w = [0, 0, 0]) {
            let [O, b, A] = w;
            if (!u)
              return {
                r: O,
                g: b,
                b: A
              };
            const Y = u.trim().split(/\s*,\s*/).map((j) => Math.min(Math.max(0, parseInt(j.trim(), 10)), 255)).map((j) => isNaN(j) ? 0 : j);
            return Y.length < 3 ? {
              r: O,
              g: b,
              b: A
            } : ([O, b, A] = Y, {
              r: O,
              g: b,
              b: A
            });
          }
          function i(u) {
            if (!u)
              return {
                x: -1,
                y: -1,
                width: -1,
                height: -1
              };
            const O = u.trim().split(/\s*,\s*/).map((X) => m(X, "-1"));
            if (O.length < 4 || O[2] < 0 || O[3] < 0)
              return {
                x: -1,
                y: -1,
                width: -1,
                height: -1
              };
            const [b, A, Y, j] = O;
            return {
              x: b,
              y: A,
              width: Y,
              height: j
            };
          }
          class l {
            static get FAILURE() {
              return (0, t.shadow)(this, "FAILURE", new l(!1, null, null, null));
            }
            static get EMPTY() {
              return (0, t.shadow)(this, "EMPTY", new l(!0, null, null, null));
            }
            constructor(w, O, b, A) {
              this.success = w, this.html = O, this.bbox = b, this.breakNode = A;
            }
            isBreak() {
              return !!this.breakNode;
            }
            static breakNode(w) {
              return new l(!1, null, null, w);
            }
            static success(w, O = null) {
              return new l(!0, w, O, null);
            }
          }
          o.HTMLResult = l;
        },
        /* 79 */
        /***/
        (J, o) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.NamespaceIds = o.$buildXFAObject = void 0;
          const F = Symbol();
          o.$buildXFAObject = F;
          const t = {
            config: {
              id: 0,
              check: (a) => a.startsWith("http://www.xfa.org/schema/xci/")
            },
            connectionSet: {
              id: 1,
              check: (a) => a.startsWith("http://www.xfa.org/schema/xfa-connection-set/")
            },
            datasets: {
              id: 2,
              check: (a) => a.startsWith("http://www.xfa.org/schema/xfa-data/")
            },
            form: {
              id: 3,
              check: (a) => a.startsWith("http://www.xfa.org/schema/xfa-form/")
            },
            localeSet: {
              id: 4,
              check: (a) => a.startsWith("http://www.xfa.org/schema/xfa-locale-set/")
            },
            pdf: {
              id: 5,
              check: (a) => a === "http://ns.adobe.com/xdp/pdf/"
            },
            signature: {
              id: 6,
              check: (a) => a === "http://www.w3.org/2000/09/xmldsig#"
            },
            sourceSet: {
              id: 7,
              check: (a) => a.startsWith("http://www.xfa.org/schema/xfa-source-set/")
            },
            stylesheet: {
              id: 8,
              check: (a) => a === "http://www.w3.org/1999/XSL/Transform"
            },
            template: {
              id: 9,
              check: (a) => a.startsWith("http://www.xfa.org/schema/xfa-template/")
            },
            xdc: {
              id: 10,
              check: (a) => a.startsWith("http://www.xfa.org/schema/xdc/")
            },
            xdp: {
              id: 11,
              check: (a) => a === "http://ns.adobe.com/xdp/"
            },
            xfdf: {
              id: 12,
              check: (a) => a === "http://ns.adobe.com/xfdf/"
            },
            xhtml: {
              id: 13,
              check: (a) => a === "http://www.w3.org/1999/xhtml"
            },
            xmpmeta: {
              id: 14,
              check: (a) => a === "http://ns.adobe.com/xmpmeta/"
            }
          };
          o.NamespaceIds = t;
        },
        /* 80 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.createDataNode = l, o.searchNode = n;
          var t = F(77), a = F(79), v = F(2);
          const h = /^[^.[]+/, e = /^[^\]]+/, y = {
            dot: 0,
            dotDot: 1,
            dotHash: 2,
            dotBracket: 3,
            dotParen: 4
          }, c = /* @__PURE__ */ new Map([["$data", (u, w) => u.datasets ? u.datasets.data : u], ["$record", (u, w) => (u.datasets ? u.datasets.data : u)[t.$getChildren]()[0]], ["$template", (u, w) => u.template], ["$connectionSet", (u, w) => u.connectionSet], ["$form", (u, w) => u.form], ["$layout", (u, w) => u.layout], ["$host", (u, w) => u.host], ["$dataWindow", (u, w) => u.dataWindow], ["$event", (u, w) => u.event], ["!", (u, w) => u.datasets], ["$xfa", (u, w) => u], ["xfa", (u, w) => u], ["$", (u, w) => w]]), d = /* @__PURE__ */ new WeakMap(), m = a.NamespaceIds.datasets.id;
          function p(u) {
            return u = u.trim(), u === "*" ? 1 / 0 : parseInt(u, 10) || 0;
          }
          function g(u, w, O = !0) {
            let b = u.match(h);
            if (!b)
              return null;
            let [A] = b;
            const Y = [{
              name: A,
              cacheName: "." + A,
              index: 0,
              js: null,
              formCalc: null,
              operator: y.dot
            }];
            let j = A.length;
            for (; j < u.length; ) {
              const X = j;
              if (u.charAt(j++) === "[") {
                if (b = u.slice(j).match(e), !b)
                  return (0, v.warn)("XFA - Invalid index in SOM expression"), null;
                Y.at(-1).index = p(b[0]), j += b[0].length + 1;
                continue;
              }
              let U;
              switch (u.charAt(j)) {
                case ".":
                  if (!w)
                    return null;
                  j++, U = y.dotDot;
                  break;
                case "#":
                  j++, U = y.dotHash;
                  break;
                case "[":
                  if (O)
                    return (0, v.warn)("XFA - SOM expression contains a FormCalc subexpression which is not supported for now."), null;
                  U = y.dotBracket;
                  break;
                case "(":
                  if (O)
                    return (0, v.warn)("XFA - SOM expression contains a JavaScript subexpression which is not supported for now."), null;
                  U = y.dotParen;
                  break;
                default:
                  U = y.dot;
                  break;
              }
              if (b = u.slice(j).match(h), !b)
                break;
              [A] = b, j += A.length, Y.push({
                name: A,
                cacheName: u.slice(X, j),
                operator: U,
                index: 0,
                js: null,
                formCalc: null
              });
            }
            return Y;
          }
          function n(u, w, O, b = !0, A = !0) {
            const Y = g(O, b);
            if (!Y)
              return null;
            const j = c.get(Y[0].name);
            let X = 0, B;
            j ? (B = !0, u = [j(u, w)], X = 1) : (B = w === null, u = [w || u]);
            for (let U = Y.length; X < U; X++) {
              const {
                name: k,
                cacheName: x,
                operator: f,
                index: D
              } = Y[X], _ = [];
              for (const S of u) {
                if (!(S instanceof t.XFAObject))
                  continue;
                let C, T;
                if (A && (T = d.get(S), T || (T = /* @__PURE__ */ new Map(), d.set(S, T)), C = T.get(x)), !C) {
                  switch (f) {
                    case y.dot:
                      C = S[t.$getChildrenByName](k, !1);
                      break;
                    case y.dotDot:
                      C = S[t.$getChildrenByName](k, !0);
                      break;
                    case y.dotHash:
                      C = S[t.$getChildrenByClass](k), C instanceof t.XFAObjectArray ? C = C.children : C = [C];
                      break;
                  }
                  A && T.set(x, C);
                }
                C.length > 0 && _.push(C);
              }
              if (_.length === 0 && !B && X === 0) {
                if (w = w[t.$getParent](), !w)
                  return null;
                X = -1, u = [w];
                continue;
              }
              isFinite(D) ? u = _.filter((S) => D < S.length).map((S) => S[D]) : u = _.flat();
            }
            return u.length === 0 ? null : u;
          }
          function i(u, w) {
            let O = null;
            for (const {
              name: b,
              index: A
            } of w) {
              for (let Y = 0, j = isFinite(A) ? A : 0; Y <= j; Y++) {
                const X = u[t.$namespaceId] === m ? -1 : u[t.$namespaceId];
                O = new t.XmlObject(X, b), u[t.$appendChild](O);
              }
              u = O;
            }
            return O;
          }
          function l(u, w, O) {
            const b = g(O);
            if (!b || b.some((j) => j.operator === y.dotDot))
              return null;
            const A = c.get(b[0].name);
            let Y = 0;
            A ? (u = A(u, w), Y = 1) : u = w || u;
            for (let j = b.length; Y < j; Y++) {
              const {
                name: X,
                operator: B,
                index: U
              } = b[Y];
              if (!isFinite(U))
                return b[Y].index = 0, i(u, b.slice(Y));
              let k;
              switch (B) {
                case y.dot:
                  k = u[t.$getChildrenByName](X, !1);
                  break;
                case y.dotDot:
                  k = u[t.$getChildrenByName](X, !0);
                  break;
                case y.dotHash:
                  k = u[t.$getChildrenByClass](X), k instanceof t.XFAObjectArray ? k = k.children : k = [k];
                  break;
              }
              if (k.length === 0)
                return i(u, b.slice(Y));
              if (U < k.length) {
                const x = k[U];
                if (!(x instanceof t.XFAObject))
                  return (0, v.warn)("XFA - Cannot create a node."), null;
                u = x;
              } else
                return b[Y].index = U - k.length, i(u, b.slice(Y));
            }
            return null;
          }
        },
        /* 81 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.Binder = void 0;
          var t = F(77), a = F(82), v = F(80), h = F(79), e = F(2);
          const y = h.NamespaceIds.datasets.id;
          function c(m) {
            const p = new a.Text({});
            return p[t.$content] = m, p;
          }
          class d {
            constructor(p) {
              this.root = p, this.datasets = p.datasets, p.datasets && p.datasets.data ? this.data = p.datasets.data : this.data = new t.XmlObject(h.NamespaceIds.datasets.id, "data"), this.emptyMerge = this.data[t.$getChildren]().length === 0, this.root.form = this.form = p.template[t.$clone]();
            }
            _isConsumeData() {
              return !this.emptyMerge && this._mergeMode;
            }
            _isMatchTemplate() {
              return !this._isConsumeData();
            }
            bind() {
              return this._bindElement(this.form, this.data), this.form;
            }
            getData() {
              return this.data;
            }
            _bindValue(p, g, n) {
              if (p[t.$data] = g, p[t.$hasSettableValue]())
                if (g[t.$isDataValue]()) {
                  const i = g[t.$getDataValue]();
                  p[t.$setValue](c(i));
                } else if (p instanceof a.Field && p.ui && p.ui.choiceList && p.ui.choiceList.open === "multiSelect") {
                  const i = g[t.$getChildren]().map((l) => l[t.$content].trim()).join(`
`);
                  p[t.$setValue](c(i));
                } else
                  this._isConsumeData() && (0, e.warn)("XFA - Nodes haven't the same type.");
              else
                !g[t.$isDataValue]() || this._isMatchTemplate() ? this._bindElement(p, g) : (0, e.warn)("XFA - Nodes haven't the same type.");
            }
            _findDataByNameToConsume(p, g, n, i) {
              if (!p)
                return null;
              let l, u;
              for (let w = 0; w < 3; w++) {
                for (l = n[t.$getRealChildrenByNameIt](p, !1, !0); u = l.next().value, !!u; )
                  if (g === u[t.$isDataValue]())
                    return u;
                if (n[t.$namespaceId] === h.NamespaceIds.datasets.id && n[t.$nodeName] === "data")
                  break;
                n = n[t.$getParent]();
              }
              return i ? (l = this.data[t.$getRealChildrenByNameIt](p, !0, !1), u = l.next().value, u || (l = this.data[t.$getAttributeIt](p, !0), u = l.next().value, u && u[t.$isDataValue]()) ? u : null) : null;
            }
            _setProperties(p, g) {
              if (p.hasOwnProperty("setProperty"))
                for (const {
                  ref: n,
                  target: i,
                  connection: l
                } of p.setProperty.children) {
                  if (l || !n)
                    continue;
                  const u = (0, v.searchNode)(this.root, g, n, !1, !1);
                  if (!u) {
                    (0, e.warn)(`XFA - Invalid reference: ${n}.`);
                    continue;
                  }
                  const [w] = u;
                  if (!w[t.$isDescendent](this.data)) {
                    (0, e.warn)("XFA - Invalid node: must be a data node.");
                    continue;
                  }
                  const O = (0, v.searchNode)(this.root, p, i, !1, !1);
                  if (!O) {
                    (0, e.warn)(`XFA - Invalid target: ${i}.`);
                    continue;
                  }
                  const [b] = O;
                  if (!b[t.$isDescendent](p)) {
                    (0, e.warn)("XFA - Invalid target: must be a property or subproperty.");
                    continue;
                  }
                  const A = b[t.$getParent]();
                  if (b instanceof a.SetProperty || A instanceof a.SetProperty) {
                    (0, e.warn)("XFA - Invalid target: cannot be a setProperty or one of its properties.");
                    continue;
                  }
                  if (b instanceof a.BindItems || A instanceof a.BindItems) {
                    (0, e.warn)("XFA - Invalid target: cannot be a bindItems or one of its properties.");
                    continue;
                  }
                  const Y = w[t.$text](), j = b[t.$nodeName];
                  if (b instanceof t.XFAAttribute) {
                    const X = /* @__PURE__ */ Object.create(null);
                    X[j] = Y;
                    const B = Reflect.construct(Object.getPrototypeOf(A).constructor, [X]);
                    A[j] = B[j];
                    continue;
                  }
                  if (!b.hasOwnProperty(t.$content)) {
                    (0, e.warn)("XFA - Invalid node to use in setProperty");
                    continue;
                  }
                  b[t.$data] = w, b[t.$content] = Y, b[t.$finalize]();
                }
            }
            _bindItems(p, g) {
              if (!p.hasOwnProperty("items") || !p.hasOwnProperty("bindItems") || p.bindItems.isEmpty())
                return;
              for (const l of p.items.children)
                p[t.$removeChild](l);
              p.items.clear();
              const n = new a.Items({}), i = new a.Items({});
              p[t.$appendChild](n), p.items.push(n), p[t.$appendChild](i), p.items.push(i);
              for (const {
                ref: l,
                labelRef: u,
                valueRef: w,
                connection: O
              } of p.bindItems.children) {
                if (O || !l)
                  continue;
                const b = (0, v.searchNode)(this.root, g, l, !1, !1);
                if (!b) {
                  (0, e.warn)(`XFA - Invalid reference: ${l}.`);
                  continue;
                }
                for (const A of b) {
                  if (!A[t.$isDescendent](this.datasets)) {
                    (0, e.warn)(`XFA - Invalid ref (${l}): must be a datasets child.`);
                    continue;
                  }
                  const Y = (0, v.searchNode)(this.root, A, u, !0, !1);
                  if (!Y) {
                    (0, e.warn)(`XFA - Invalid label: ${u}.`);
                    continue;
                  }
                  const [j] = Y;
                  if (!j[t.$isDescendent](this.datasets)) {
                    (0, e.warn)("XFA - Invalid label: must be a datasets child.");
                    continue;
                  }
                  const X = (0, v.searchNode)(this.root, A, w, !0, !1);
                  if (!X) {
                    (0, e.warn)(`XFA - Invalid value: ${w}.`);
                    continue;
                  }
                  const [B] = X;
                  if (!B[t.$isDescendent](this.datasets)) {
                    (0, e.warn)("XFA - Invalid value: must be a datasets child.");
                    continue;
                  }
                  const U = c(j[t.$text]()), k = c(B[t.$text]());
                  n[t.$appendChild](U), n.text.push(U), i[t.$appendChild](k), i.text.push(k);
                }
              }
            }
            _bindOccurrences(p, g, n) {
              let i;
              if (g.length > 1 && (i = p[t.$clone](), i[t.$removeChild](i.occur), i.occur = null), this._bindValue(p, g[0], n), this._setProperties(p, g[0]), this._bindItems(p, g[0]), g.length === 1)
                return;
              const l = p[t.$getParent](), u = p[t.$nodeName], w = l[t.$indexOf](p);
              for (let O = 1, b = g.length; O < b; O++) {
                const A = g[O], Y = i[t.$clone]();
                l[u].push(Y), l[t.$insertAt](w + O, Y), this._bindValue(Y, A, n), this._setProperties(Y, A), this._bindItems(Y, A);
              }
            }
            _createOccurrences(p) {
              if (!this.emptyMerge)
                return;
              const {
                occur: g
              } = p;
              if (!g || g.initial <= 1)
                return;
              const n = p[t.$getParent](), i = p[t.$nodeName];
              if (!(n[i] instanceof t.XFAObjectArray))
                return;
              let l;
              p.name ? l = n[i].children.filter((O) => O.name === p.name).length : l = n[i].children.length;
              const u = n[t.$indexOf](p) + 1, w = g.initial - l;
              if (w) {
                const O = p[t.$clone]();
                O[t.$removeChild](O.occur), O.occur = null, n[i].push(O), n[t.$insertAt](u, O);
                for (let b = 1; b < w; b++) {
                  const A = O[t.$clone]();
                  n[i].push(A), n[t.$insertAt](u + b, A);
                }
              }
            }
            _getOccurInfo(p) {
              const {
                name: g,
                occur: n
              } = p;
              if (!n || !g)
                return [1, 1];
              const i = n.max === -1 ? 1 / 0 : n.max;
              return [n.min, i];
            }
            _setAndBind(p, g) {
              this._setProperties(p, g), this._bindItems(p, g), this._bindElement(p, g);
            }
            _bindElement(p, g) {
              const n = [];
              this._createOccurrences(p);
              for (const i of p[t.$getChildren]()) {
                if (i[t.$data])
                  continue;
                if (this._mergeMode === void 0 && i[t.$nodeName] === "subform") {
                  this._mergeMode = i.mergeMode === "consumeData";
                  const Y = g[t.$getChildren]();
                  if (Y.length > 0)
                    this._bindOccurrences(i, [Y[0]], null);
                  else if (this.emptyMerge) {
                    const j = g[t.$namespaceId] === y ? -1 : g[t.$namespaceId], X = i[t.$data] = new t.XmlObject(j, i.name || "root");
                    g[t.$appendChild](X), this._bindElement(i, X);
                  }
                  continue;
                }
                if (!i[t.$isBindable]())
                  continue;
                let l = !1, u = null, w = null, O = null;
                if (i.bind) {
                  switch (i.bind.match) {
                    case "none":
                      this._setAndBind(i, g);
                      continue;
                    case "global":
                      l = !0;
                      break;
                    case "dataRef":
                      if (!i.bind.ref) {
                        (0, e.warn)(`XFA - ref is empty in node ${i[t.$nodeName]}.`), this._setAndBind(i, g);
                        continue;
                      }
                      w = i.bind.ref;
                      break;
                  }
                  i.bind.picture && (u = i.bind.picture[t.$content]);
                }
                const [b, A] = this._getOccurInfo(i);
                if (w)
                  if (O = (0, v.searchNode)(this.root, g, w, !0, !1), O === null) {
                    if (O = (0, v.createDataNode)(this.data, g, w), !O)
                      continue;
                    this._isConsumeData() && (O[t.$consumed] = !0), this._setAndBind(i, O);
                    continue;
                  } else
                    this._isConsumeData() && (O = O.filter((Y) => !Y[t.$consumed])), O.length > A ? O = O.slice(0, A) : O.length === 0 && (O = null), O && this._isConsumeData() && O.forEach((Y) => {
                      Y[t.$consumed] = !0;
                    });
                else {
                  if (!i.name) {
                    this._setAndBind(i, g);
                    continue;
                  }
                  if (this._isConsumeData()) {
                    const Y = [];
                    for (; Y.length < A; ) {
                      const j = this._findDataByNameToConsume(i.name, i[t.$hasSettableValue](), g, l);
                      if (!j)
                        break;
                      j[t.$consumed] = !0, Y.push(j);
                    }
                    O = Y.length > 0 ? Y : null;
                  } else {
                    if (O = g[t.$getRealChildrenByNameIt](i.name, !1, this.emptyMerge).next().value, !O) {
                      if (b === 0) {
                        n.push(i);
                        continue;
                      }
                      const Y = g[t.$namespaceId] === y ? -1 : g[t.$namespaceId];
                      O = i[t.$data] = new t.XmlObject(Y, i.name), this.emptyMerge && (O[t.$consumed] = !0), g[t.$appendChild](O), this._setAndBind(i, O);
                      continue;
                    }
                    this.emptyMerge && (O[t.$consumed] = !0), O = [O];
                  }
                }
                O ? this._bindOccurrences(i, O, u) : b > 0 ? this._setAndBind(i, g) : n.push(i);
              }
              n.forEach((i) => i[t.$getParent]()[t.$removeChild](i));
            }
          }
          o.Binder = d;
        },
        /* 82 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.Value = o.Text = o.TemplateNamespace = o.Template = o.SetProperty = o.Items = o.Field = o.BindItems = void 0;
          var t = F(77), a = F(79), v = F(83), h = F(84), e = F(78), y = F(2), c = F(85), d = F(6), m = F(80);
          const p = a.NamespaceIds.template.id, g = "http://www.w3.org/2000/svg", n = 2, i = 3, l = 5e3, u = /^H(\d+)$/, w = /* @__PURE__ */ new Set(["image/gif", "image/jpeg", "image/jpg", "image/pjpeg", "image/png", "image/apng", "image/x-png", "image/bmp", "image/x-ms-bmp", "image/tiff", "image/tif", "application/octet-stream"]), O = [[[66, 77], "image/bmp"], [[255, 216, 255], "image/jpeg"], [[73, 73, 42, 0], "image/tiff"], [[77, 77, 0, 42], "image/tiff"], [[71, 73, 70, 56, 57, 97], "image/gif"], [[137, 80, 78, 71, 13, 10, 26, 10], "image/png"]];
          function b(He) {
            if (!He || !He.border)
              return {
                w: 0,
                h: 0
              };
            const R = He.border[t.$getExtra]();
            return R ? {
              w: R.widths[0] + R.widths[2] + R.insets[0] + R.insets[2],
              h: R.widths[1] + R.widths[3] + R.insets[1] + R.insets[3]
            } : {
              w: 0,
              h: 0
            };
          }
          function A(He) {
            return He.margin && (He.margin.topInset || He.margin.rightInset || He.margin.bottomInset || He.margin.leftInset);
          }
          function Y(He, R) {
            if (!He.value) {
              const he = new bn({});
              He[t.$appendChild](he), He.value = he;
            }
            He.value[t.$setValue](R);
          }
          function* j(He) {
            for (const R of He[t.$getChildren]()) {
              if (R instanceof dn) {
                yield* R[t.$getContainedChildren]();
                continue;
              }
              yield R;
            }
          }
          function X(He) {
            return He.validate && He.validate.nullTest === "error";
          }
          function B(He) {
            for (; He; ) {
              if (!He.traversal) {
                He[t.$tabIndex] = He[t.$getParent]()[t.$tabIndex];
                return;
              }
              if (He[t.$tabIndex])
                return;
              let R = null;
              for (const Ze of He.traversal[t.$getChildren]())
                if (Ze.operation === "next") {
                  R = Ze;
                  break;
                }
              if (!R || !R.ref) {
                He[t.$tabIndex] = He[t.$getParent]()[t.$tabIndex];
                return;
              }
              const he = He[t.$getTemplateRoot]();
              He[t.$tabIndex] = ++he[t.$tabIndex];
              const $e = he[t.$searchNode](R.ref, He);
              if (!$e)
                return;
              He = $e[0];
            }
          }
          function U(He, R) {
            const he = He.assist;
            if (he) {
              const $e = he[t.$toHTML]();
              $e && (R.title = $e);
              const ht = he.role.match(u);
              if (ht) {
                const It = "heading", Et = ht[1];
                R.role = It, R["aria-level"] = Et;
              }
            }
            if (He.layout === "table")
              R.role = "table";
            else if (He.layout === "row")
              R.role = "row";
            else {
              const $e = He[t.$getParent]();
              $e.layout === "row" && ($e.assist && $e.assist.role === "TH" ? R.role = "columnheader" : R.role = "cell");
            }
          }
          function k(He) {
            if (!He.assist)
              return null;
            const R = He.assist;
            return R.speak && R.speak[t.$content] !== "" ? R.speak[t.$content] : R.toolTip ? R.toolTip[t.$content] : null;
          }
          function x(He) {
            return e.HTMLResult.success({
              name: "div",
              attributes: {
                class: ["xfaRich"],
                style: /* @__PURE__ */ Object.create(null)
              },
              children: [{
                name: "span",
                attributes: {
                  style: /* @__PURE__ */ Object.create(null)
                },
                value: He
              }]
            });
          }
          function f(He) {
            const R = He[t.$getTemplateRoot]();
            R[t.$extra].firstUnsplittable === null && (R[t.$extra].firstUnsplittable = He, R[t.$extra].noLayoutFailure = !0);
          }
          function D(He) {
            const R = He[t.$getTemplateRoot]();
            R[t.$extra].firstUnsplittable === He && (R[t.$extra].noLayoutFailure = !1);
          }
          function _(He) {
            if (He[t.$extra] || (He[t.$extra] = /* @__PURE__ */ Object.create(null), He.targetType === "auto"))
              return !1;
            const R = He[t.$getTemplateRoot]();
            let he = null;
            if (He.target) {
              if (he = R[t.$searchNode](He.target, He[t.$getParent]()), !he)
                return !1;
              he = he[0];
            }
            const {
              currentPageArea: $e,
              currentContentArea: Ze
            } = R[t.$extra];
            if (He.targetType === "pageArea")
              return he instanceof tt || (he = null), He.startNew ? (He[t.$extra].target = he || $e, !0) : he && he !== $e ? (He[t.$extra].target = he, !0) : !1;
            he instanceof ie || (he = null);
            const ht = he && he[t.$getParent]();
            let It, Et = ht;
            if (He.startNew)
              if (he) {
                const Rt = ht.contentArea.children, $t = Rt.indexOf(Ze), Ht = Rt.indexOf(he);
                $t !== -1 && $t < Ht && (Et = null), It = Ht - 1;
              } else
                It = $e.contentArea.children.indexOf(Ze);
            else if (he && he !== Ze)
              It = ht.contentArea.children.indexOf(he) - 1, Et = ht === $e ? null : ht;
            else
              return !1;
            return He[t.$extra].target = Et, He[t.$extra].index = It, !0;
          }
          function S(He, R, he) {
            const $e = He[t.$getTemplateRoot](), Ze = $e[t.$extra].noLayoutFailure, ht = R[t.$getSubformParent];
            R[t.$getSubformParent] = () => He, $e[t.$extra].noLayoutFailure = !0;
            const It = R[t.$toHTML](he);
            He[t.$addHTML](It.html, It.bbox), $e[t.$extra].noLayoutFailure = Ze, R[t.$getSubformParent] = ht;
          }
          class C extends t.StringObject {
            constructor(R) {
              super(p, "appearanceFilter"), this.id = R.id || "", this.type = (0, e.getStringOption)(R.type, ["optional", "required"]), this.use = R.use || "", this.usehref = R.usehref || "";
            }
          }
          class T extends t.XFAObject {
            constructor(R) {
              super(p, "arc", !0), this.circular = (0, e.getInteger)({
                data: R.circular,
                defaultValue: 0,
                validate: (he) => he === 1
              }), this.hand = (0, e.getStringOption)(R.hand, ["even", "left", "right"]), this.id = R.id || "", this.startAngle = (0, e.getFloat)({
                data: R.startAngle,
                defaultValue: 0,
                validate: (he) => !0
              }), this.sweepAngle = (0, e.getFloat)({
                data: R.sweepAngle,
                defaultValue: 360,
                validate: (he) => !0
              }), this.use = R.use || "", this.usehref = R.usehref || "", this.edge = null, this.fill = null;
            }
            [t.$toHTML]() {
              const R = this.edge || new De({}), he = R[t.$toStyle](), $e = /* @__PURE__ */ Object.create(null);
              this.fill && this.fill.presence === "visible" ? Object.assign($e, this.fill[t.$toStyle]()) : $e.fill = "transparent", $e.strokeWidth = (0, h.measureToString)(R.presence === "visible" ? R.thickness : 0), $e.stroke = he.color;
              let Ze;
              const ht = {
                xmlns: g,
                style: {
                  width: "100%",
                  height: "100%",
                  overflow: "visible"
                }
              };
              if (this.sweepAngle === 360)
                Ze = {
                  name: "ellipse",
                  attributes: {
                    xmlns: g,
                    cx: "50%",
                    cy: "50%",
                    rx: "50%",
                    ry: "50%",
                    style: $e
                  }
                };
              else {
                const Rt = this.startAngle * Math.PI / 180, $t = this.sweepAngle * Math.PI / 180, Ht = this.sweepAngle > 180 ? 1 : 0, [Jt, Kt, tn, we] = [50 * (1 + Math.cos(Rt)), 50 * (1 - Math.sin(Rt)), 50 * (1 + Math.cos(Rt + $t)), 50 * (1 - Math.sin(Rt + $t))];
                Ze = {
                  name: "path",
                  attributes: {
                    xmlns: g,
                    d: `M ${Jt} ${Kt} A 50 50 0 ${Ht} 0 ${tn} ${we}`,
                    vectorEffect: "non-scaling-stroke",
                    style: $e
                  }
                }, Object.assign(ht, {
                  viewBox: "0 0 100 100",
                  preserveAspectRatio: "none"
                });
              }
              const It = {
                name: "svg",
                children: [Ze],
                attributes: ht
              }, Et = this[t.$getParent]()[t.$getParent]();
              return A(Et) ? e.HTMLResult.success({
                name: "div",
                attributes: {
                  style: {
                    display: "inline",
                    width: "100%",
                    height: "100%"
                  }
                },
                children: [It]
              }) : (It.attributes.style.position = "absolute", e.HTMLResult.success(It));
            }
          }
          class P extends t.XFAObject {
            constructor(R) {
              super(p, "area", !0), this.colSpan = (0, e.getInteger)({
                data: R.colSpan,
                defaultValue: 1,
                validate: (he) => he >= 1 || he === -1
              }), this.id = R.id || "", this.name = R.name || "", this.relevant = (0, e.getRelevant)(R.relevant), this.use = R.use || "", this.usehref = R.usehref || "", this.x = (0, e.getMeasurement)(R.x, "0pt"), this.y = (0, e.getMeasurement)(R.y, "0pt"), this.desc = null, this.extras = null, this.area = new t.XFAObjectArray(), this.draw = new t.XFAObjectArray(), this.exObject = new t.XFAObjectArray(), this.exclGroup = new t.XFAObjectArray(), this.field = new t.XFAObjectArray(), this.subform = new t.XFAObjectArray(), this.subformSet = new t.XFAObjectArray();
            }
            *[t.$getContainedChildren]() {
              yield* j(this);
            }
            [t.$isTransparent]() {
              return !0;
            }
            [t.$isBindable]() {
              return !0;
            }
            [t.$addHTML](R, he) {
              const [$e, Ze, ht, It] = he;
              this[t.$extra].width = Math.max(this[t.$extra].width, $e + ht), this[t.$extra].height = Math.max(this[t.$extra].height, Ze + It), this[t.$extra].children.push(R);
            }
            [t.$getAvailableSpace]() {
              return this[t.$extra].availableSpace;
            }
            [t.$toHTML](R) {
              const he = (0, h.toStyle)(this, "position"), $e = {
                style: he,
                id: this[t.$uid],
                class: ["xfaArea"]
              };
              (0, h.isPrintOnly)(this) && $e.class.push("xfaPrintOnly"), this.name && ($e.xfaName = this.name);
              const Ze = [];
              this[t.$extra] = {
                children: Ze,
                width: 0,
                height: 0,
                availableSpace: R
              };
              const ht = this[t.$childrenToHTML]({
                filter: /* @__PURE__ */ new Set(["area", "draw", "field", "exclGroup", "subform", "subformSet"]),
                include: !0
              });
              if (!ht.success)
                return ht.isBreak() ? ht : (delete this[t.$extra], e.HTMLResult.FAILURE);
              he.width = (0, h.measureToString)(this[t.$extra].width), he.height = (0, h.measureToString)(this[t.$extra].height);
              const It = {
                name: "div",
                attributes: $e,
                children: Ze
              }, Et = [this.x, this.y, this[t.$extra].width, this[t.$extra].height];
              return delete this[t.$extra], e.HTMLResult.success(It, Et);
            }
          }
          class M extends t.XFAObject {
            constructor(R) {
              super(p, "assist", !0), this.id = R.id || "", this.role = R.role || "", this.use = R.use || "", this.usehref = R.usehref || "", this.speak = null, this.toolTip = null;
            }
            [t.$toHTML]() {
              return this.toolTip && this.toolTip[t.$content] ? this.toolTip[t.$content] : null;
            }
          }
          class G extends t.XFAObject {
            constructor(R) {
              super(p, "barcode", !0), this.charEncoding = (0, e.getKeyword)({
                data: R.charEncoding ? R.charEncoding.toLowerCase() : "",
                defaultValue: "",
                validate: (he) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(he) || he.match(/iso-8859-\d{2}/)
              }), this.checksum = (0, e.getStringOption)(R.checksum, ["none", "1mod10", "1mod10_1mod11", "2mod10", "auto"]), this.dataColumnCount = (0, e.getInteger)({
                data: R.dataColumnCount,
                defaultValue: -1,
                validate: (he) => he >= 0
              }), this.dataLength = (0, e.getInteger)({
                data: R.dataLength,
                defaultValue: -1,
                validate: (he) => he >= 0
              }), this.dataPrep = (0, e.getStringOption)(R.dataPrep, ["none", "flateCompress"]), this.dataRowCount = (0, e.getInteger)({
                data: R.dataRowCount,
                defaultValue: -1,
                validate: (he) => he >= 0
              }), this.endChar = R.endChar || "", this.errorCorrectionLevel = (0, e.getInteger)({
                data: R.errorCorrectionLevel,
                defaultValue: -1,
                validate: (he) => he >= 0 && he <= 8
              }), this.id = R.id || "", this.moduleHeight = (0, e.getMeasurement)(R.moduleHeight, "5mm"), this.moduleWidth = (0, e.getMeasurement)(R.moduleWidth, "0.25mm"), this.printCheckDigit = (0, e.getInteger)({
                data: R.printCheckDigit,
                defaultValue: 0,
                validate: (he) => he === 1
              }), this.rowColumnRatio = (0, e.getRatio)(R.rowColumnRatio), this.startChar = R.startChar || "", this.textLocation = (0, e.getStringOption)(R.textLocation, ["below", "above", "aboveEmbedded", "belowEmbedded", "none"]), this.truncate = (0, e.getInteger)({
                data: R.truncate,
                defaultValue: 0,
                validate: (he) => he === 1
              }), this.type = (0, e.getStringOption)(R.type ? R.type.toLowerCase() : "", ["aztec", "codabar", "code2of5industrial", "code2of5interleaved", "code2of5matrix", "code2of5standard", "code3of9", "code3of9extended", "code11", "code49", "code93", "code128", "code128a", "code128b", "code128c", "code128sscc", "datamatrix", "ean8", "ean8add2", "ean8add5", "ean13", "ean13add2", "ean13add5", "ean13pwcd", "fim", "logmars", "maxicode", "msi", "pdf417", "pdf417macro", "plessey", "postauscust2", "postauscust3", "postausreplypaid", "postausstandard", "postukrm4scc", "postusdpbc", "postusimb", "postusstandard", "postus5zip", "qrcode", "rfid", "rss14", "rss14expanded", "rss14limited", "rss14stacked", "rss14stackedomni", "rss14truncated", "telepen", "ucc128", "ucc128random", "ucc128sscc", "upca", "upcaadd2", "upcaadd5", "upcapwcd", "upce", "upceadd2", "upceadd5", "upcean2", "upcean5", "upsmaxicode"]), this.upsMode = (0, e.getStringOption)(R.upsMode, ["usCarrier", "internationalCarrier", "secureSymbol", "standardSymbol"]), this.use = R.use || "", this.usehref = R.usehref || "", this.wideNarrowRatio = (0, e.getRatio)(R.wideNarrowRatio), this.encrypt = null, this.extras = null;
            }
          }
          class Z extends t.XFAObject {
            constructor(R) {
              super(p, "bind", !0), this.match = (0, e.getStringOption)(R.match, ["once", "dataRef", "global", "none"]), this.ref = R.ref || "", this.picture = null;
            }
          }
          class $ extends t.XFAObject {
            constructor(R) {
              super(p, "bindItems"), this.connection = R.connection || "", this.labelRef = R.labelRef || "", this.ref = R.ref || "", this.valueRef = R.valueRef || "";
            }
          }
          o.BindItems = $;
          class z extends t.XFAObject {
            constructor(R) {
              super(p, "bookend"), this.id = R.id || "", this.leader = R.leader || "", this.trailer = R.trailer || "", this.use = R.use || "", this.usehref = R.usehref || "";
            }
          }
          class V extends t.Option01 {
            constructor(R) {
              super(p, "boolean"), this.id = R.id || "", this.name = R.name || "", this.use = R.use || "", this.usehref = R.usehref || "";
            }
            [t.$toHTML](R) {
              return x(this[t.$content] === 1 ? "1" : "0");
            }
          }
          class L extends t.XFAObject {
            constructor(R) {
              super(p, "border", !0), this.break = (0, e.getStringOption)(R.break, ["close", "open"]), this.hand = (0, e.getStringOption)(R.hand, ["even", "left", "right"]), this.id = R.id || "", this.presence = (0, e.getStringOption)(R.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = (0, e.getRelevant)(R.relevant), this.use = R.use || "", this.usehref = R.usehref || "", this.corner = new t.XFAObjectArray(4), this.edge = new t.XFAObjectArray(4), this.extras = null, this.fill = null, this.margin = null;
            }
            [t.$getExtra]() {
              if (!this[t.$extra]) {
                const R = this.edge.children.slice();
                if (R.length < 4) {
                  const Ze = R.at(-1) || new De({});
                  for (let ht = R.length; ht < 4; ht++)
                    R.push(Ze);
                }
                const he = R.map((Ze) => Ze.thickness), $e = [0, 0, 0, 0];
                this.margin && ($e[0] = this.margin.topInset, $e[1] = this.margin.rightInset, $e[2] = this.margin.bottomInset, $e[3] = this.margin.leftInset), this[t.$extra] = {
                  widths: he,
                  insets: $e,
                  edges: R
                };
              }
              return this[t.$extra];
            }
            [t.$toStyle]() {
              const {
                edges: R
              } = this[t.$getExtra](), he = R.map((Ze) => {
                const ht = Ze[t.$toStyle]();
                return ht.color = ht.color || "#000000", ht;
              }), $e = /* @__PURE__ */ Object.create(null);
              if (this.margin && Object.assign($e, this.margin[t.$toStyle]()), this.fill && this.fill.presence === "visible" && Object.assign($e, this.fill[t.$toStyle]()), this.corner.children.some((Ze) => Ze.radius !== 0)) {
                const Ze = this.corner.children.map((ht) => ht[t.$toStyle]());
                if (Ze.length === 2 || Ze.length === 3) {
                  const ht = Ze.at(-1);
                  for (let It = Ze.length; It < 4; It++)
                    Ze.push(ht);
                }
                $e.borderRadius = Ze.map((ht) => ht.radius).join(" ");
              }
              switch (this.presence) {
                case "invisible":
                case "hidden":
                  $e.borderStyle = "";
                  break;
                case "inactive":
                  $e.borderStyle = "none";
                  break;
                default:
                  $e.borderStyle = he.map((Ze) => Ze.style).join(" ");
                  break;
              }
              return $e.borderWidth = he.map((Ze) => Ze.width).join(" "), $e.borderColor = he.map((Ze) => Ze.color).join(" "), $e;
            }
          }
          class K extends t.XFAObject {
            constructor(R) {
              super(p, "break", !0), this.after = (0, e.getStringOption)(R.after, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]), this.afterTarget = R.afterTarget || "", this.before = (0, e.getStringOption)(R.before, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]), this.beforeTarget = R.beforeTarget || "", this.bookendLeader = R.bookendLeader || "", this.bookendTrailer = R.bookendTrailer || "", this.id = R.id || "", this.overflowLeader = R.overflowLeader || "", this.overflowTarget = R.overflowTarget || "", this.overflowTrailer = R.overflowTrailer || "", this.startNew = (0, e.getInteger)({
                data: R.startNew,
                defaultValue: 0,
                validate: (he) => he === 1
              }), this.use = R.use || "", this.usehref = R.usehref || "", this.extras = null;
            }
          }
          class ne extends t.XFAObject {
            constructor(R) {
              super(p, "breakAfter", !0), this.id = R.id || "", this.leader = R.leader || "", this.startNew = (0, e.getInteger)({
                data: R.startNew,
                defaultValue: 0,
                validate: (he) => he === 1
              }), this.target = R.target || "", this.targetType = (0, e.getStringOption)(R.targetType, ["auto", "contentArea", "pageArea"]), this.trailer = R.trailer || "", this.use = R.use || "", this.usehref = R.usehref || "", this.script = null;
            }
          }
          class se extends t.XFAObject {
            constructor(R) {
              super(p, "breakBefore", !0), this.id = R.id || "", this.leader = R.leader || "", this.startNew = (0, e.getInteger)({
                data: R.startNew,
                defaultValue: 0,
                validate: (he) => he === 1
              }), this.target = R.target || "", this.targetType = (0, e.getStringOption)(R.targetType, ["auto", "contentArea", "pageArea"]), this.trailer = R.trailer || "", this.use = R.use || "", this.usehref = R.usehref || "", this.script = null;
            }
            [t.$toHTML](R) {
              return this[t.$extra] = {}, e.HTMLResult.FAILURE;
            }
          }
          class q extends t.XFAObject {
            constructor(R) {
              super(p, "button", !0), this.highlight = (0, e.getStringOption)(R.highlight, ["inverted", "none", "outline", "push"]), this.id = R.id || "", this.use = R.use || "", this.usehref = R.usehref || "", this.extras = null;
            }
            [t.$toHTML](R) {
              const $e = this[t.$getParent]()[t.$getParent](), Ze = {
                name: "button",
                attributes: {
                  id: this[t.$uid],
                  class: ["xfaButton"],
                  style: {}
                },
                children: []
              };
              for (const ht of $e.event.children) {
                if (ht.activity !== "click" || !ht.script)
                  continue;
                const It = (0, d.recoverJsURL)(ht.script[t.$content]);
                if (!It)
                  continue;
                const Et = (0, h.fixURL)(It.url);
                Et && Ze.children.push({
                  name: "a",
                  attributes: {
                    id: "link" + this[t.$uid],
                    href: Et,
                    newWindow: It.newWindow,
                    class: ["xfaLink"],
                    style: {}
                  },
                  children: []
                });
              }
              return e.HTMLResult.success(Ze);
            }
          }
          class N extends t.XFAObject {
            constructor(R) {
              super(p, "calculate", !0), this.id = R.id || "", this.override = (0, e.getStringOption)(R.override, ["disabled", "error", "ignore", "warning"]), this.use = R.use || "", this.usehref = R.usehref || "", this.extras = null, this.message = null, this.script = null;
            }
          }
          class Q extends t.XFAObject {
            constructor(R) {
              super(p, "caption", !0), this.id = R.id || "", this.placement = (0, e.getStringOption)(R.placement, ["left", "bottom", "inline", "right", "top"]), this.presence = (0, e.getStringOption)(R.presence, ["visible", "hidden", "inactive", "invisible"]), this.reserve = Math.ceil((0, e.getMeasurement)(R.reserve)), this.use = R.use || "", this.usehref = R.usehref || "", this.extras = null, this.font = null, this.margin = null, this.para = null, this.value = null;
            }
            [t.$setValue](R) {
              Y(this, R);
            }
            [t.$getExtra](R) {
              if (!this[t.$extra]) {
                let {
                  width: he,
                  height: $e
                } = R;
                switch (this.placement) {
                  case "left":
                  case "right":
                  case "inline":
                    he = this.reserve <= 0 ? he : this.reserve;
                    break;
                  case "top":
                  case "bottom":
                    $e = this.reserve <= 0 ? $e : this.reserve;
                    break;
                }
                this[t.$extra] = (0, h.layoutNode)(this, {
                  width: he,
                  height: $e
                });
              }
              return this[t.$extra];
            }
            [t.$toHTML](R) {
              if (!this.value)
                return e.HTMLResult.EMPTY;
              this[t.$pushPara]();
              const he = this.value[t.$toHTML](R).html;
              if (!he)
                return this[t.$popPara](), e.HTMLResult.EMPTY;
              const $e = this.reserve;
              if (this.reserve <= 0) {
                const {
                  w: It,
                  h: Et
                } = this[t.$getExtra](R);
                switch (this.placement) {
                  case "left":
                  case "right":
                  case "inline":
                    this.reserve = It;
                    break;
                  case "top":
                  case "bottom":
                    this.reserve = Et;
                    break;
                }
              }
              const Ze = [];
              typeof he == "string" ? Ze.push({
                name: "#text",
                value: he
              }) : Ze.push(he);
              const ht = (0, h.toStyle)(this, "font", "margin", "visibility");
              switch (this.placement) {
                case "left":
                case "right":
                  this.reserve > 0 && (ht.width = (0, h.measureToString)(this.reserve));
                  break;
                case "top":
                case "bottom":
                  this.reserve > 0 && (ht.height = (0, h.measureToString)(this.reserve));
                  break;
              }
              return (0, h.setPara)(this, null, he), this[t.$popPara](), this.reserve = $e, e.HTMLResult.success({
                name: "div",
                attributes: {
                  style: ht,
                  class: ["xfaCaption"]
                },
                children: Ze
              });
            }
          }
          class E extends t.StringObject {
            constructor(R) {
              super(p, "certificate"), this.id = R.id || "", this.name = R.name || "", this.use = R.use || "", this.usehref = R.usehref || "";
            }
          }
          class te extends t.XFAObject {
            constructor(R) {
              super(p, "certificates", !0), this.credentialServerPolicy = (0, e.getStringOption)(R.credentialServerPolicy, ["optional", "required"]), this.id = R.id || "", this.url = R.url || "", this.urlPolicy = R.urlPolicy || "", this.use = R.use || "", this.usehref = R.usehref || "", this.encryption = null, this.issuers = null, this.keyUsage = null, this.oids = null, this.signing = null, this.subjectDNs = null;
            }
          }
          class oe extends t.XFAObject {
            constructor(R) {
              super(p, "checkButton", !0), this.id = R.id || "", this.mark = (0, e.getStringOption)(R.mark, ["default", "check", "circle", "cross", "diamond", "square", "star"]), this.shape = (0, e.getStringOption)(R.shape, ["square", "round"]), this.size = (0, e.getMeasurement)(R.size, "10pt"), this.use = R.use || "", this.usehref = R.usehref || "", this.border = null, this.extras = null, this.margin = null;
            }
            [t.$toHTML](R) {
              const he = (0, h.toStyle)("margin"), $e = (0, h.measureToString)(this.size);
              he.width = he.height = $e;
              let Ze, ht, It;
              const Et = this[t.$getParent]()[t.$getParent](), Rt = Et.items.children.length && Et.items.children[0][t.$toHTML]().html || [], $t = {
                on: (Rt[0] !== void 0 ? Rt[0] : "on").toString(),
                off: (Rt[1] !== void 0 ? Rt[1] : "off").toString()
              }, Jt = (Et.value && Et.value[t.$text]() || "off") === $t.on || void 0, Kt = Et[t.$getSubformParent](), tn = Et[t.$uid];
              let we;
              Kt instanceof Qe ? (It = Kt[t.$uid], Ze = "radio", ht = "xfaRadio", we = Kt[t.$data] && Kt[t.$data][t.$uid] || Kt[t.$uid]) : (Ze = "checkbox", ht = "xfaCheckbox", we = Et[t.$data] && Et[t.$data][t.$uid] || Et[t.$uid]);
              const Re = {
                name: "input",
                attributes: {
                  class: [ht],
                  style: he,
                  fieldId: tn,
                  dataId: we,
                  type: Ze,
                  checked: Jt,
                  xfaOn: $t.on,
                  xfaOff: $t.off,
                  "aria-label": k(Et),
                  "aria-required": !1
                }
              };
              return It && (Re.attributes.name = It), X(Et) && (Re.attributes["aria-required"] = !0, Re.attributes.required = !0), e.HTMLResult.success({
                name: "label",
                attributes: {
                  class: ["xfaLabel"]
                },
                children: [Re]
              });
            }
          }
          class ee extends t.XFAObject {
            constructor(R) {
              super(p, "choiceList", !0), this.commitOn = (0, e.getStringOption)(R.commitOn, ["select", "exit"]), this.id = R.id || "", this.open = (0, e.getStringOption)(R.open, ["userControl", "always", "multiSelect", "onEntry"]), this.textEntry = (0, e.getInteger)({
                data: R.textEntry,
                defaultValue: 0,
                validate: (he) => he === 1
              }), this.use = R.use || "", this.usehref = R.usehref || "", this.border = null, this.extras = null, this.margin = null;
            }
            [t.$toHTML](R) {
              const he = (0, h.toStyle)(this, "border", "margin"), Ze = this[t.$getParent]()[t.$getParent](), It = {
                fontSize: `calc(${Ze.font && Ze.font.size || 10}px * var(--scale-factor))`
              }, Et = [];
              if (Ze.items.children.length > 0) {
                const $t = Ze.items;
                let Ht = 0, Jt = 0;
                $t.children.length === 2 && (Ht = $t.children[0].save, Jt = 1 - Ht);
                const Kt = $t.children[Ht][t.$toHTML]().html, tn = $t.children[Jt][t.$toHTML]().html;
                let we = !1;
                const Re = Ze.value && Ze.value[t.$text]() || "";
                for (let et = 0, Ke = Kt.length; et < Ke; et++) {
                  const ut = {
                    name: "option",
                    attributes: {
                      value: tn[et] || Kt[et],
                      style: It
                    },
                    value: Kt[et]
                  };
                  tn[et] === Re && (ut.attributes.selected = we = !0), Et.push(ut);
                }
                we || Et.splice(0, 0, {
                  name: "option",
                  attributes: {
                    hidden: !0,
                    selected: !0
                  },
                  value: " "
                });
              }
              const Rt = {
                class: ["xfaSelect"],
                fieldId: Ze[t.$uid],
                dataId: Ze[t.$data] && Ze[t.$data][t.$uid] || Ze[t.$uid],
                style: he,
                "aria-label": k(Ze),
                "aria-required": !1
              };
              return X(Ze) && (Rt["aria-required"] = !0, Rt.required = !0), this.open === "multiSelect" && (Rt.multiple = !0), e.HTMLResult.success({
                name: "label",
                attributes: {
                  class: ["xfaLabel"]
                },
                children: [{
                  name: "select",
                  children: Et,
                  attributes: Rt
                }]
              });
            }
          }
          class W extends t.XFAObject {
            constructor(R) {
              super(p, "color", !0), this.cSpace = (0, e.getStringOption)(R.cSpace, ["SRGB"]), this.id = R.id || "", this.use = R.use || "", this.usehref = R.usehref || "", this.value = R.value ? (0, e.getColor)(R.value) : "", this.extras = null;
            }
            [t.$hasSettableValue]() {
              return !1;
            }
            [t.$toStyle]() {
              return this.value ? y.Util.makeHexColor(this.value.r, this.value.g, this.value.b) : null;
            }
          }
          class I extends t.XFAObject {
            constructor(R) {
              super(p, "comb"), this.id = R.id || "", this.numberOfCells = (0, e.getInteger)({
                data: R.numberOfCells,
                defaultValue: 0,
                validate: (he) => he >= 0
              }), this.use = R.use || "", this.usehref = R.usehref || "";
            }
          }
          class H extends t.XFAObject {
            constructor(R) {
              super(p, "connect", !0), this.connection = R.connection || "", this.id = R.id || "", this.ref = R.ref || "", this.usage = (0, e.getStringOption)(R.usage, ["exportAndImport", "exportOnly", "importOnly"]), this.use = R.use || "", this.usehref = R.usehref || "", this.picture = null;
            }
          }
          class ie extends t.XFAObject {
            constructor(R) {
              super(p, "contentArea", !0), this.h = (0, e.getMeasurement)(R.h), this.id = R.id || "", this.name = R.name || "", this.relevant = (0, e.getRelevant)(R.relevant), this.use = R.use || "", this.usehref = R.usehref || "", this.w = (0, e.getMeasurement)(R.w), this.x = (0, e.getMeasurement)(R.x, "0pt"), this.y = (0, e.getMeasurement)(R.y, "0pt"), this.desc = null, this.extras = null;
            }
            [t.$toHTML](R) {
              const he = (0, h.measureToString)(this.x), $e = (0, h.measureToString)(this.y), Ze = {
                left: he,
                top: $e,
                width: (0, h.measureToString)(this.w),
                height: (0, h.measureToString)(this.h)
              }, ht = ["xfaContentarea"];
              return (0, h.isPrintOnly)(this) && ht.push("xfaPrintOnly"), e.HTMLResult.success({
                name: "div",
                children: [],
                attributes: {
                  style: Ze,
                  class: ht,
                  id: this[t.$uid]
                }
              });
            }
          }
          class ue extends t.XFAObject {
            constructor(R) {
              super(p, "corner", !0), this.id = R.id || "", this.inverted = (0, e.getInteger)({
                data: R.inverted,
                defaultValue: 0,
                validate: (he) => he === 1
              }), this.join = (0, e.getStringOption)(R.join, ["square", "round"]), this.presence = (0, e.getStringOption)(R.presence, ["visible", "hidden", "inactive", "invisible"]), this.radius = (0, e.getMeasurement)(R.radius), this.stroke = (0, e.getStringOption)(R.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]), this.thickness = (0, e.getMeasurement)(R.thickness, "0.5pt"), this.use = R.use || "", this.usehref = R.usehref || "", this.color = null, this.extras = null;
            }
            [t.$toStyle]() {
              const R = (0, h.toStyle)(this, "visibility");
              return R.radius = (0, h.measureToString)(this.join === "square" ? 0 : this.radius), R;
            }
          }
          class fe extends t.ContentObject {
            constructor(R) {
              super(p, "date"), this.id = R.id || "", this.name = R.name || "", this.use = R.use || "", this.usehref = R.usehref || "";
            }
            [t.$finalize]() {
              const R = this[t.$content].trim();
              this[t.$content] = R ? new Date(R) : null;
            }
            [t.$toHTML](R) {
              return x(this[t.$content] ? this[t.$content].toString() : "");
            }
          }
          class de extends t.ContentObject {
            constructor(R) {
              super(p, "dateTime"), this.id = R.id || "", this.name = R.name || "", this.use = R.use || "", this.usehref = R.usehref || "";
            }
            [t.$finalize]() {
              const R = this[t.$content].trim();
              this[t.$content] = R ? new Date(R) : null;
            }
            [t.$toHTML](R) {
              return x(this[t.$content] ? this[t.$content].toString() : "");
            }
          }
          class pe extends t.XFAObject {
            constructor(R) {
              super(p, "dateTimeEdit", !0), this.hScrollPolicy = (0, e.getStringOption)(R.hScrollPolicy, ["auto", "off", "on"]), this.id = R.id || "", this.picker = (0, e.getStringOption)(R.picker, ["host", "none"]), this.use = R.use || "", this.usehref = R.usehref || "", this.border = null, this.comb = null, this.extras = null, this.margin = null;
            }
            [t.$toHTML](R) {
              const he = (0, h.toStyle)(this, "border", "font", "margin"), $e = this[t.$getParent]()[t.$getParent](), Ze = {
                name: "input",
                attributes: {
                  type: "text",
                  fieldId: $e[t.$uid],
                  dataId: $e[t.$data] && $e[t.$data][t.$uid] || $e[t.$uid],
                  class: ["xfaTextfield"],
                  style: he,
                  "aria-label": k($e),
                  "aria-required": !1
                }
              };
              return X($e) && (Ze.attributes["aria-required"] = !0, Ze.attributes.required = !0), e.HTMLResult.success({
                name: "label",
                attributes: {
                  class: ["xfaLabel"]
                },
                children: [Ze]
              });
            }
          }
          class xe extends t.ContentObject {
            constructor(R) {
              super(p, "decimal"), this.fracDigits = (0, e.getInteger)({
                data: R.fracDigits,
                defaultValue: 2,
                validate: (he) => !0
              }), this.id = R.id || "", this.leadDigits = (0, e.getInteger)({
                data: R.leadDigits,
                defaultValue: -1,
                validate: (he) => !0
              }), this.name = R.name || "", this.use = R.use || "", this.usehref = R.usehref || "";
            }
            [t.$finalize]() {
              const R = parseFloat(this[t.$content].trim());
              this[t.$content] = isNaN(R) ? null : R;
            }
            [t.$toHTML](R) {
              return x(this[t.$content] !== null ? this[t.$content].toString() : "");
            }
          }
          class Fe extends t.XFAObject {
            constructor(R) {
              super(p, "defaultUi", !0), this.id = R.id || "", this.use = R.use || "", this.usehref = R.usehref || "", this.extras = null;
            }
          }
          class Se extends t.XFAObject {
            constructor(R) {
              super(p, "desc", !0), this.id = R.id || "", this.use = R.use || "", this.usehref = R.usehref || "", this.boolean = new t.XFAObjectArray(), this.date = new t.XFAObjectArray(), this.dateTime = new t.XFAObjectArray(), this.decimal = new t.XFAObjectArray(), this.exData = new t.XFAObjectArray(), this.float = new t.XFAObjectArray(), this.image = new t.XFAObjectArray(), this.integer = new t.XFAObjectArray(), this.text = new t.XFAObjectArray(), this.time = new t.XFAObjectArray();
            }
          }
          class Ce extends t.OptionObject {
            constructor(R) {
              super(p, "digestMethod", ["", "SHA1", "SHA256", "SHA512", "RIPEMD160"]), this.id = R.id || "", this.use = R.use || "", this.usehref = R.usehref || "";
            }
          }
          class ke extends t.XFAObject {
            constructor(R) {
              super(p, "digestMethods", !0), this.id = R.id || "", this.type = (0, e.getStringOption)(R.type, ["optional", "required"]), this.use = R.use || "", this.usehref = R.usehref || "", this.digestMethod = new t.XFAObjectArray();
            }
          }
          class ye extends t.XFAObject {
            constructor(R) {
              super(p, "draw", !0), this.anchorType = (0, e.getStringOption)(R.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = (0, e.getInteger)({
                data: R.colSpan,
                defaultValue: 1,
                validate: (he) => he >= 1 || he === -1
              }), this.h = R.h ? (0, e.getMeasurement)(R.h) : "", this.hAlign = (0, e.getStringOption)(R.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = R.id || "", this.locale = R.locale || "", this.maxH = (0, e.getMeasurement)(R.maxH, "0pt"), this.maxW = (0, e.getMeasurement)(R.maxW, "0pt"), this.minH = (0, e.getMeasurement)(R.minH, "0pt"), this.minW = (0, e.getMeasurement)(R.minW, "0pt"), this.name = R.name || "", this.presence = (0, e.getStringOption)(R.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = (0, e.getRelevant)(R.relevant), this.rotate = (0, e.getInteger)({
                data: R.rotate,
                defaultValue: 0,
                validate: (he) => he % 90 === 0
              }), this.use = R.use || "", this.usehref = R.usehref || "", this.w = R.w ? (0, e.getMeasurement)(R.w) : "", this.x = (0, e.getMeasurement)(R.x, "0pt"), this.y = (0, e.getMeasurement)(R.y, "0pt"), this.assist = null, this.border = null, this.caption = null, this.desc = null, this.extras = null, this.font = null, this.keep = null, this.margin = null, this.para = null, this.traversal = null, this.ui = null, this.value = null, this.setProperty = new t.XFAObjectArray();
            }
            [t.$setValue](R) {
              Y(this, R);
            }
            [t.$toHTML](R) {
              if (B(this), this.presence === "hidden" || this.presence === "inactive")
                return e.HTMLResult.EMPTY;
              (0, h.fixDimensions)(this), this[t.$pushPara]();
              const he = this.w, $e = this.h, {
                w: Ze,
                h: ht,
                isBroken: It
              } = (0, h.layoutNode)(this, R);
              if (Ze && this.w === "") {
                if (It && this[t.$getSubformParent]()[t.$isThereMoreWidth]())
                  return this[t.$popPara](), e.HTMLResult.FAILURE;
                this.w = Ze;
              }
              if (ht && this.h === "" && (this.h = ht), f(this), !(0, v.checkDimensions)(this, R))
                return this.w = he, this.h = $e, this[t.$popPara](), e.HTMLResult.FAILURE;
              D(this);
              const Et = (0, h.toStyle)(this, "font", "hAlign", "dimensions", "position", "presence", "rotate", "anchorType", "border", "margin");
              (0, h.setMinMaxDimensions)(this, Et), Et.margin && (Et.padding = Et.margin, delete Et.margin);
              const Rt = ["xfaDraw"];
              this.font && Rt.push("xfaFont"), (0, h.isPrintOnly)(this) && Rt.push("xfaPrintOnly");
              const $t = {
                style: Et,
                id: this[t.$uid],
                class: Rt
              };
              this.name && ($t.xfaName = this.name);
              const Ht = {
                name: "div",
                attributes: $t,
                children: []
              };
              U(this, $t);
              const Jt = (0, h.computeBbox)(this, Ht, R), Kt = this.value ? this.value[t.$toHTML](R).html : null;
              return Kt === null ? (this.w = he, this.h = $e, this[t.$popPara](), e.HTMLResult.success((0, h.createWrapper)(this, Ht), Jt)) : (Ht.children.push(Kt), (0, h.setPara)(this, Et, Kt), this.w = he, this.h = $e, this[t.$popPara](), e.HTMLResult.success((0, h.createWrapper)(this, Ht), Jt));
            }
          }
          class De extends t.XFAObject {
            constructor(R) {
              super(p, "edge", !0), this.cap = (0, e.getStringOption)(R.cap, ["square", "butt", "round"]), this.id = R.id || "", this.presence = (0, e.getStringOption)(R.presence, ["visible", "hidden", "inactive", "invisible"]), this.stroke = (0, e.getStringOption)(R.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]), this.thickness = (0, e.getMeasurement)(R.thickness, "0.5pt"), this.use = R.use || "", this.usehref = R.usehref || "", this.color = null, this.extras = null;
            }
            [t.$toStyle]() {
              const R = (0, h.toStyle)(this, "visibility");
              if (Object.assign(R, {
                linecap: this.cap,
                width: (0, h.measureToString)(this.thickness),
                color: this.color ? this.color[t.$toStyle]() : "#000000",
                style: ""
              }), this.presence !== "visible")
                R.style = "none";
              else
                switch (this.stroke) {
                  case "solid":
                    R.style = "solid";
                    break;
                  case "dashDot":
                    R.style = "dashed";
                    break;
                  case "dashDotDot":
                    R.style = "dashed";
                    break;
                  case "dashed":
                    R.style = "dashed";
                    break;
                  case "dotted":
                    R.style = "dotted";
                    break;
                  case "embossed":
                    R.style = "ridge";
                    break;
                  case "etched":
                    R.style = "groove";
                    break;
                  case "lowered":
                    R.style = "inset";
                    break;
                  case "raised":
                    R.style = "outset";
                    break;
                }
              return R;
            }
          }
          class Ae extends t.OptionObject {
            constructor(R) {
              super(p, "encoding", ["adbe.x509.rsa_sha1", "adbe.pkcs7.detached", "adbe.pkcs7.sha1"]), this.id = R.id || "", this.use = R.use || "", this.usehref = R.usehref || "";
            }
          }
          class Te extends t.XFAObject {
            constructor(R) {
              super(p, "encodings", !0), this.id = R.id || "", this.type = (0, e.getStringOption)(R.type, ["optional", "required"]), this.use = R.use || "", this.usehref = R.usehref || "", this.encoding = new t.XFAObjectArray();
            }
          }
          class ve extends t.XFAObject {
            constructor(R) {
              super(p, "encrypt", !0), this.id = R.id || "", this.use = R.use || "", this.usehref = R.usehref || "", this.certificate = null;
            }
          }
          class Ne extends t.XFAObject {
            constructor(R) {
              super(p, "encryptData", !0), this.id = R.id || "", this.operation = (0, e.getStringOption)(R.operation, ["encrypt", "decrypt"]), this.target = R.target || "", this.use = R.use || "", this.usehref = R.usehref || "", this.filter = null, this.manifest = null;
            }
          }
          class Ge extends t.XFAObject {
            constructor(R) {
              super(p, "encryption", !0), this.id = R.id || "", this.type = (0, e.getStringOption)(R.type, ["optional", "required"]), this.use = R.use || "", this.usehref = R.usehref || "", this.certificate = new t.XFAObjectArray();
            }
          }
          class it extends t.OptionObject {
            constructor(R) {
              super(p, "encryptionMethod", ["", "AES256-CBC", "TRIPLEDES-CBC", "AES128-CBC", "AES192-CBC"]), this.id = R.id || "", this.use = R.use || "", this.usehref = R.usehref || "";
            }
          }
          class Me extends t.XFAObject {
            constructor(R) {
              super(p, "encryptionMethods", !0), this.id = R.id || "", this.type = (0, e.getStringOption)(R.type, ["optional", "required"]), this.use = R.use || "", this.usehref = R.usehref || "", this.encryptionMethod = new t.XFAObjectArray();
            }
          }
          class Ie extends t.XFAObject {
            constructor(R) {
              super(p, "event", !0), this.activity = (0, e.getStringOption)(R.activity, ["click", "change", "docClose", "docReady", "enter", "exit", "full", "indexChange", "initialize", "mouseDown", "mouseEnter", "mouseExit", "mouseUp", "postExecute", "postOpen", "postPrint", "postSave", "postSign", "postSubmit", "preExecute", "preOpen", "prePrint", "preSave", "preSign", "preSubmit", "ready", "validationState"]), this.id = R.id || "", this.listen = (0, e.getStringOption)(R.listen, ["refOnly", "refAndDescendents"]), this.name = R.name || "", this.ref = R.ref || "", this.use = R.use || "", this.usehref = R.usehref || "", this.extras = null, this.encryptData = null, this.execute = null, this.script = null, this.signData = null, this.submit = null;
            }
          }
          class Ee extends t.ContentObject {
            constructor(R) {
              super(p, "exData"), this.contentType = R.contentType || "", this.href = R.href || "", this.id = R.id || "", this.maxLength = (0, e.getInteger)({
                data: R.maxLength,
                defaultValue: -1,
                validate: (he) => he >= -1
              }), this.name = R.name || "", this.rid = R.rid || "", this.transferEncoding = (0, e.getStringOption)(R.transferEncoding, ["none", "base64", "package"]), this.use = R.use || "", this.usehref = R.usehref || "";
            }
            [t.$isCDATAXml]() {
              return this.contentType === "text/html";
            }
            [t.$onChild](R) {
              return this.contentType === "text/html" && R[t.$namespaceId] === a.NamespaceIds.xhtml.id ? (this[t.$content] = R, !0) : this.contentType === "text/xml" ? (this[t.$content] = R, !0) : !1;
            }
            [t.$toHTML](R) {
              return this.contentType !== "text/html" || !this[t.$content] ? e.HTMLResult.EMPTY : this[t.$content][t.$toHTML](R);
            }
          }
          class st extends t.XFAObject {
            constructor(R) {
              super(p, "exObject", !0), this.archive = R.archive || "", this.classId = R.classId || "", this.codeBase = R.codeBase || "", this.codeType = R.codeType || "", this.id = R.id || "", this.name = R.name || "", this.use = R.use || "", this.usehref = R.usehref || "", this.extras = null, this.boolean = new t.XFAObjectArray(), this.date = new t.XFAObjectArray(), this.dateTime = new t.XFAObjectArray(), this.decimal = new t.XFAObjectArray(), this.exData = new t.XFAObjectArray(), this.exObject = new t.XFAObjectArray(), this.float = new t.XFAObjectArray(), this.image = new t.XFAObjectArray(), this.integer = new t.XFAObjectArray(), this.text = new t.XFAObjectArray(), this.time = new t.XFAObjectArray();
            }
          }
          class Qe extends t.XFAObject {
            constructor(R) {
              super(p, "exclGroup", !0), this.access = (0, e.getStringOption)(R.access, ["open", "nonInteractive", "protected", "readOnly"]), this.accessKey = R.accessKey || "", this.anchorType = (0, e.getStringOption)(R.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = (0, e.getInteger)({
                data: R.colSpan,
                defaultValue: 1,
                validate: (he) => he >= 1 || he === -1
              }), this.h = R.h ? (0, e.getMeasurement)(R.h) : "", this.hAlign = (0, e.getStringOption)(R.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = R.id || "", this.layout = (0, e.getStringOption)(R.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]), this.maxH = (0, e.getMeasurement)(R.maxH, "0pt"), this.maxW = (0, e.getMeasurement)(R.maxW, "0pt"), this.minH = (0, e.getMeasurement)(R.minH, "0pt"), this.minW = (0, e.getMeasurement)(R.minW, "0pt"), this.name = R.name || "", this.presence = (0, e.getStringOption)(R.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = (0, e.getRelevant)(R.relevant), this.use = R.use || "", this.usehref = R.usehref || "", this.w = R.w ? (0, e.getMeasurement)(R.w) : "", this.x = (0, e.getMeasurement)(R.x, "0pt"), this.y = (0, e.getMeasurement)(R.y, "0pt"), this.assist = null, this.bind = null, this.border = null, this.calculate = null, this.caption = null, this.desc = null, this.extras = null, this.margin = null, this.para = null, this.traversal = null, this.validate = null, this.connect = new t.XFAObjectArray(), this.event = new t.XFAObjectArray(), this.field = new t.XFAObjectArray(), this.setProperty = new t.XFAObjectArray();
            }
            [t.$isBindable]() {
              return !0;
            }
            [t.$hasSettableValue]() {
              return !0;
            }
            [t.$setValue](R) {
              for (const he of this.field.children) {
                if (!he.value) {
                  const $e = new bn({});
                  he[t.$appendChild]($e), he.value = $e;
                }
                he.value[t.$setValue](R);
              }
            }
            [t.$isThereMoreWidth]() {
              return this.layout.endsWith("-tb") && this[t.$extra].attempt === 0 && this[t.$extra].numberInLine > 0 || this[t.$getParent]()[t.$isThereMoreWidth]();
            }
            [t.$isSplittable]() {
              const R = this[t.$getSubformParent]();
              return R[t.$isSplittable]() ? this[t.$extra]._isSplittable !== void 0 ? this[t.$extra]._isSplittable : this.layout === "position" || this.layout.includes("row") ? (this[t.$extra]._isSplittable = !1, !1) : R.layout && R.layout.endsWith("-tb") && R[t.$extra].numberInLine !== 0 ? !1 : (this[t.$extra]._isSplittable = !0, !0) : !1;
            }
            [t.$flushHTML]() {
              return (0, v.flushHTML)(this);
            }
            [t.$addHTML](R, he) {
              (0, v.addHTML)(this, R, he);
            }
            [t.$getAvailableSpace]() {
              return (0, v.getAvailableSpace)(this);
            }
            [t.$toHTML](R) {
              if (B(this), this.presence === "hidden" || this.presence === "inactive" || this.h === 0 || this.w === 0)
                return e.HTMLResult.EMPTY;
              (0, h.fixDimensions)(this);
              const he = [], $e = {
                id: this[t.$uid],
                class: []
              };
              (0, h.setAccess)(this, $e.class), this[t.$extra] || (this[t.$extra] = /* @__PURE__ */ Object.create(null)), Object.assign(this[t.$extra], {
                children: he,
                attributes: $e,
                attempt: 0,
                line: null,
                numberInLine: 0,
                availableSpace: {
                  width: Math.min(this.w || 1 / 0, R.width),
                  height: Math.min(this.h || 1 / 0, R.height)
                },
                width: 0,
                height: 0,
                prevHeight: 0,
                currentWidth: 0
              });
              const Ze = this[t.$isSplittable]();
              if (Ze || f(this), !(0, v.checkDimensions)(this, R))
                return e.HTMLResult.FAILURE;
              const ht = /* @__PURE__ */ new Set(["field"]);
              if (this.layout.includes("row")) {
                const Ke = this[t.$getSubformParent]().columnWidths;
                Array.isArray(Ke) && Ke.length > 0 && (this[t.$extra].columnWidths = Ke, this[t.$extra].currentColumn = 0);
              }
              const It = (0, h.toStyle)(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), Et = ["xfaExclgroup"], Rt = (0, h.layoutClass)(this);
              Rt && Et.push(Rt), (0, h.isPrintOnly)(this) && Et.push("xfaPrintOnly"), $e.style = It, $e.class = Et, this.name && ($e.xfaName = this.name), this[t.$pushPara]();
              const $t = this.layout === "lr-tb" || this.layout === "rl-tb", Ht = $t ? n : 1;
              for (; this[t.$extra].attempt < Ht; this[t.$extra].attempt++) {
                $t && this[t.$extra].attempt === n - 1 && (this[t.$extra].numberInLine = 0);
                const Ke = this[t.$childrenToHTML]({
                  filter: ht,
                  include: !0
                });
                if (Ke.success)
                  break;
                if (Ke.isBreak())
                  return this[t.$popPara](), Ke;
                if ($t && this[t.$extra].attempt === 0 && this[t.$extra].numberInLine === 0 && !this[t.$getTemplateRoot]()[t.$extra].noLayoutFailure) {
                  this[t.$extra].attempt = Ht;
                  break;
                }
              }
              if (this[t.$popPara](), Ze || D(this), this[t.$extra].attempt === Ht)
                return Ze || delete this[t.$extra], e.HTMLResult.FAILURE;
              let Jt = 0, Kt = 0;
              this.margin && (Jt = this.margin.leftInset + this.margin.rightInset, Kt = this.margin.topInset + this.margin.bottomInset);
              const tn = Math.max(this[t.$extra].width + Jt, this.w || 0), we = Math.max(this[t.$extra].height + Kt, this.h || 0), Re = [this.x, this.y, tn, we];
              this.w === "" && (It.width = (0, h.measureToString)(tn)), this.h === "" && (It.height = (0, h.measureToString)(we));
              const et = {
                name: "div",
                attributes: $e,
                children: he
              };
              return U(this, $e), delete this[t.$extra], e.HTMLResult.success((0, h.createWrapper)(this, et), Re);
            }
          }
          class ct extends t.XFAObject {
            constructor(R) {
              super(p, "execute"), this.connection = R.connection || "", this.executeType = (0, e.getStringOption)(R.executeType, ["import", "remerge"]), this.id = R.id || "", this.runAt = (0, e.getStringOption)(R.runAt, ["client", "both", "server"]), this.use = R.use || "", this.usehref = R.usehref || "";
            }
          }
          class xt extends t.XFAObject {
            constructor(R) {
              super(p, "extras", !0), this.id = R.id || "", this.name = R.name || "", this.use = R.use || "", this.usehref = R.usehref || "", this.boolean = new t.XFAObjectArray(), this.date = new t.XFAObjectArray(), this.dateTime = new t.XFAObjectArray(), this.decimal = new t.XFAObjectArray(), this.exData = new t.XFAObjectArray(), this.extras = new t.XFAObjectArray(), this.float = new t.XFAObjectArray(), this.image = new t.XFAObjectArray(), this.integer = new t.XFAObjectArray(), this.text = new t.XFAObjectArray(), this.time = new t.XFAObjectArray();
            }
          }
          class Je extends t.XFAObject {
            constructor(R) {
              super(p, "field", !0), this.access = (0, e.getStringOption)(R.access, ["open", "nonInteractive", "protected", "readOnly"]), this.accessKey = R.accessKey || "", this.anchorType = (0, e.getStringOption)(R.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = (0, e.getInteger)({
                data: R.colSpan,
                defaultValue: 1,
                validate: (he) => he >= 1 || he === -1
              }), this.h = R.h ? (0, e.getMeasurement)(R.h) : "", this.hAlign = (0, e.getStringOption)(R.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = R.id || "", this.locale = R.locale || "", this.maxH = (0, e.getMeasurement)(R.maxH, "0pt"), this.maxW = (0, e.getMeasurement)(R.maxW, "0pt"), this.minH = (0, e.getMeasurement)(R.minH, "0pt"), this.minW = (0, e.getMeasurement)(R.minW, "0pt"), this.name = R.name || "", this.presence = (0, e.getStringOption)(R.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = (0, e.getRelevant)(R.relevant), this.rotate = (0, e.getInteger)({
                data: R.rotate,
                defaultValue: 0,
                validate: (he) => he % 90 === 0
              }), this.use = R.use || "", this.usehref = R.usehref || "", this.w = R.w ? (0, e.getMeasurement)(R.w) : "", this.x = (0, e.getMeasurement)(R.x, "0pt"), this.y = (0, e.getMeasurement)(R.y, "0pt"), this.assist = null, this.bind = null, this.border = null, this.calculate = null, this.caption = null, this.desc = null, this.extras = null, this.font = null, this.format = null, this.items = new t.XFAObjectArray(2), this.keep = null, this.margin = null, this.para = null, this.traversal = null, this.ui = null, this.validate = null, this.value = null, this.bindItems = new t.XFAObjectArray(), this.connect = new t.XFAObjectArray(), this.event = new t.XFAObjectArray(), this.setProperty = new t.XFAObjectArray();
            }
            [t.$isBindable]() {
              return !0;
            }
            [t.$setValue](R) {
              Y(this, R);
            }
            [t.$toHTML](R) {
              if (B(this), !this.ui) {
                this.ui = new Sn({}), this.ui[t.$globalData] = this[t.$globalData], this[t.$appendChild](this.ui);
                let Ke;
                switch (this.items.children.length) {
                  case 0:
                    Ke = new An({}), this.ui.textEdit = Ke;
                    break;
                  case 1:
                    Ke = new oe({}), this.ui.checkButton = Ke;
                    break;
                  case 2:
                    Ke = new ee({}), this.ui.choiceList = Ke;
                    break;
                }
                this.ui[t.$appendChild](Ke);
              }
              if (!this.ui || this.presence === "hidden" || this.presence === "inactive" || this.h === 0 || this.w === 0)
                return e.HTMLResult.EMPTY;
              this.caption && delete this.caption[t.$extra], this[t.$pushPara]();
              const he = this.caption ? this.caption[t.$toHTML](R).html : null, $e = this.w, Ze = this.h;
              let ht = 0, It = 0;
              this.margin && (ht = this.margin.leftInset + this.margin.rightInset, It = this.margin.topInset + this.margin.bottomInset);
              let Et = null;
              if (this.w === "" || this.h === "") {
                let Ke = null, ut = null, Lt = 0, vt = 0;
                if (this.ui.checkButton)
                  Lt = vt = this.ui.checkButton.size;
                else {
                  const {
                    w: Xt,
                    h: zt
                  } = (0, h.layoutNode)(this, R);
                  Xt !== null ? (Lt = Xt, vt = zt) : vt = (0, c.getMetrics)(this.font, !0).lineNoGap;
                }
                if (Et = b(this.ui[t.$getExtra]()), Lt += Et.w, vt += Et.h, this.caption) {
                  const {
                    w: Xt,
                    h: zt,
                    isBroken: Gt
                  } = this.caption[t.$getExtra](R);
                  if (Gt && this[t.$getSubformParent]()[t.$isThereMoreWidth]())
                    return this[t.$popPara](), e.HTMLResult.FAILURE;
                  switch (Ke = Xt, ut = zt, this.caption.placement) {
                    case "left":
                    case "right":
                    case "inline":
                      Ke += Lt;
                      break;
                    case "top":
                    case "bottom":
                      ut += vt;
                      break;
                  }
                } else
                  Ke = Lt, ut = vt;
                Ke && this.w === "" && (Ke += ht, this.w = Math.min(this.maxW <= 0 ? 1 / 0 : this.maxW, this.minW + 1 < Ke ? Ke : this.minW)), ut && this.h === "" && (ut += It, this.h = Math.min(this.maxH <= 0 ? 1 / 0 : this.maxH, this.minH + 1 < ut ? ut : this.minH));
              }
              if (this[t.$popPara](), (0, h.fixDimensions)(this), f(this), !(0, v.checkDimensions)(this, R))
                return this.w = $e, this.h = Ze, this[t.$popPara](), e.HTMLResult.FAILURE;
              D(this);
              const Rt = (0, h.toStyle)(this, "font", "dimensions", "position", "rotate", "anchorType", "presence", "margin", "hAlign");
              (0, h.setMinMaxDimensions)(this, Rt);
              const $t = ["xfaField"];
              this.font && $t.push("xfaFont"), (0, h.isPrintOnly)(this) && $t.push("xfaPrintOnly");
              const Ht = {
                style: Rt,
                id: this[t.$uid],
                class: $t
              };
              Rt.margin && (Rt.padding = Rt.margin, delete Rt.margin), (0, h.setAccess)(this, $t), this.name && (Ht.xfaName = this.name);
              const Jt = [], Kt = {
                name: "div",
                attributes: Ht,
                children: Jt
              };
              U(this, Ht);
              const tn = this.border ? this.border[t.$toStyle]() : null, we = (0, h.computeBbox)(this, Kt, R), Re = this.ui[t.$toHTML]().html;
              if (!Re)
                return Object.assign(Rt, tn), e.HTMLResult.success((0, h.createWrapper)(this, Kt), we);
              this[t.$tabIndex] && (Re.children && Re.children[0] ? Re.children[0].attributes.tabindex = this[t.$tabIndex] : Re.attributes.tabindex = this[t.$tabIndex]), Re.attributes.style || (Re.attributes.style = /* @__PURE__ */ Object.create(null));
              let et = null;
              if (this.ui.button ? (Re.children.length === 1 && ([et] = Re.children.splice(0, 1)), Object.assign(Re.attributes.style, tn)) : Object.assign(Rt, tn), Jt.push(Re), this.value) {
                if (this.ui.imageEdit)
                  Re.children.push(this.value[t.$toHTML]().html);
                else if (!this.ui.button) {
                  let Ke = "";
                  if (this.value.exData)
                    Ke = this.value.exData[t.$text]();
                  else if (this.value.text)
                    Ke = this.value.text[t.$getExtra]();
                  else {
                    const ut = this.value[t.$toHTML]().html;
                    ut !== null && (Ke = ut.children[0].value);
                  }
                  this.ui.textEdit && this.value.text && this.value.text.maxChars && (Re.children[0].attributes.maxLength = this.value.text.maxChars), Ke && (this.ui.numericEdit && (Ke = parseFloat(Ke), Ke = isNaN(Ke) ? "" : Ke.toString()), Re.children[0].name === "textarea" ? Re.children[0].attributes.textContent = Ke : Re.children[0].attributes.value = Ke);
                }
              }
              if (!this.ui.imageEdit && Re.children && Re.children[0] && this.h) {
                Et = Et || b(this.ui[t.$getExtra]());
                let Ke = 0;
                if (this.caption && ["top", "bottom"].includes(this.caption.placement)) {
                  Ke = this.caption.reserve, Ke <= 0 && (Ke = this.caption[t.$getExtra](R).h);
                  const ut = this.h - Ke - It - Et.h;
                  Re.children[0].attributes.style.height = (0, h.measureToString)(ut);
                } else
                  Re.children[0].attributes.style.height = "100%";
              }
              if (et && Re.children.push(et), !he)
                return Re.attributes.class && Re.attributes.class.push("xfaLeft"), this.w = $e, this.h = Ze, e.HTMLResult.success((0, h.createWrapper)(this, Kt), we);
              if (this.ui.button)
                return Rt.padding && delete Rt.padding, he.name === "div" && (he.name = "span"), Re.children.push(he), e.HTMLResult.success(Kt, we);
              switch (this.ui.checkButton && (he.attributes.class[0] = "xfaCaptionForCheckButton"), Re.attributes.class || (Re.attributes.class = []), Re.children.splice(0, 0, he), this.caption.placement) {
                case "left":
                  Re.attributes.class.push("xfaLeft");
                  break;
                case "right":
                  Re.attributes.class.push("xfaRight");
                  break;
                case "top":
                  Re.attributes.class.push("xfaTop");
                  break;
                case "bottom":
                  Re.attributes.class.push("xfaBottom");
                  break;
                case "inline":
                  Re.attributes.class.push("xfaLeft");
                  break;
              }
              return this.w = $e, this.h = Ze, e.HTMLResult.success((0, h.createWrapper)(this, Kt), we);
            }
          }
          o.Field = Je;
          class mt extends t.XFAObject {
            constructor(R) {
              super(p, "fill", !0), this.id = R.id || "", this.presence = (0, e.getStringOption)(R.presence, ["visible", "hidden", "inactive", "invisible"]), this.use = R.use || "", this.usehref = R.usehref || "", this.color = null, this.extras = null, this.linear = null, this.pattern = null, this.radial = null, this.solid = null, this.stipple = null;
            }
            [t.$toStyle]() {
              const R = this[t.$getParent](), $e = R[t.$getParent]()[t.$getParent](), Ze = /* @__PURE__ */ Object.create(null);
              let ht = "color", It = ht;
              R instanceof L && (ht = "background-color", It = "background", $e instanceof Sn && (Ze.backgroundColor = "white")), (R instanceof gn || R instanceof T) && (ht = It = "fill", Ze.fill = "white");
              for (const Et of Object.getOwnPropertyNames(this)) {
                if (Et === "extras" || Et === "color")
                  continue;
                const Rt = this[Et];
                if (!(Rt instanceof t.XFAObject))
                  continue;
                const $t = Rt[t.$toStyle](this.color);
                return $t && (Ze[$t.startsWith("#") ? ht : It] = $t), Ze;
              }
              if (this.color && this.color.value) {
                const Et = this.color[t.$toStyle]();
                Ze[Et.startsWith("#") ? ht : It] = Et;
              }
              return Ze;
            }
          }
          class _t extends t.XFAObject {
            constructor(R) {
              super(p, "filter", !0), this.addRevocationInfo = (0, e.getStringOption)(R.addRevocationInfo, ["", "required", "optional", "none"]), this.id = R.id || "", this.name = R.name || "", this.use = R.use || "", this.usehref = R.usehref || "", this.version = (0, e.getInteger)({
                data: this.version,
                defaultValue: 5,
                validate: (he) => he >= 1 && he <= 5
              }), this.appearanceFilter = null, this.certificates = null, this.digestMethods = null, this.encodings = null, this.encryptionMethods = null, this.handler = null, this.lockDocument = null, this.mdp = null, this.reasons = null, this.timeStamp = null;
            }
          }
          class Xe extends t.ContentObject {
            constructor(R) {
              super(p, "float"), this.id = R.id || "", this.name = R.name || "", this.use = R.use || "", this.usehref = R.usehref || "";
            }
            [t.$finalize]() {
              const R = parseFloat(this[t.$content].trim());
              this[t.$content] = isNaN(R) ? null : R;
            }
            [t.$toHTML](R) {
              return x(this[t.$content] !== null ? this[t.$content].toString() : "");
            }
          }
          class Ct extends t.XFAObject {
            constructor(R) {
              super(p, "font", !0), this.baselineShift = (0, e.getMeasurement)(R.baselineShift), this.fontHorizontalScale = (0, e.getFloat)({
                data: R.fontHorizontalScale,
                defaultValue: 100,
                validate: (he) => he >= 0
              }), this.fontVerticalScale = (0, e.getFloat)({
                data: R.fontVerticalScale,
                defaultValue: 100,
                validate: (he) => he >= 0
              }), this.id = R.id || "", this.kerningMode = (0, e.getStringOption)(R.kerningMode, ["none", "pair"]), this.letterSpacing = (0, e.getMeasurement)(R.letterSpacing, "0"), this.lineThrough = (0, e.getInteger)({
                data: R.lineThrough,
                defaultValue: 0,
                validate: (he) => he === 1 || he === 2
              }), this.lineThroughPeriod = (0, e.getStringOption)(R.lineThroughPeriod, ["all", "word"]), this.overline = (0, e.getInteger)({
                data: R.overline,
                defaultValue: 0,
                validate: (he) => he === 1 || he === 2
              }), this.overlinePeriod = (0, e.getStringOption)(R.overlinePeriod, ["all", "word"]), this.posture = (0, e.getStringOption)(R.posture, ["normal", "italic"]), this.size = (0, e.getMeasurement)(R.size, "10pt"), this.typeface = R.typeface || "Courier", this.underline = (0, e.getInteger)({
                data: R.underline,
                defaultValue: 0,
                validate: (he) => he === 1 || he === 2
              }), this.underlinePeriod = (0, e.getStringOption)(R.underlinePeriod, ["all", "word"]), this.use = R.use || "", this.usehref = R.usehref || "", this.weight = (0, e.getStringOption)(R.weight, ["normal", "bold"]), this.extras = null, this.fill = null;
            }
            [t.$clean](R) {
              super[t.$clean](R), this[t.$globalData].usedTypefaces.add(this.typeface);
            }
            [t.$toStyle]() {
              const R = (0, h.toStyle)(this, "fill"), he = R.color;
              return he && (he === "#000000" ? delete R.color : he.startsWith("#") || (R.background = he, R.backgroundClip = "text", R.color = "transparent")), this.baselineShift && (R.verticalAlign = (0, h.measureToString)(this.baselineShift)), R.fontKerning = this.kerningMode === "none" ? "none" : "normal", R.letterSpacing = (0, h.measureToString)(this.letterSpacing), this.lineThrough !== 0 && (R.textDecoration = "line-through", this.lineThrough === 2 && (R.textDecorationStyle = "double")), this.overline !== 0 && (R.textDecoration = "overline", this.overline === 2 && (R.textDecorationStyle = "double")), R.fontStyle = this.posture, R.fontSize = (0, h.measureToString)(0.99 * this.size), (0, h.setFontFamily)(this, this, this[t.$globalData].fontFinder, R), this.underline !== 0 && (R.textDecoration = "underline", this.underline === 2 && (R.textDecorationStyle = "double")), R.fontWeight = this.weight, R;
            }
          }
          class bt extends t.XFAObject {
            constructor(R) {
              super(p, "format", !0), this.id = R.id || "", this.use = R.use || "", this.usehref = R.usehref || "", this.extras = null, this.picture = null;
            }
          }
          class Pe extends t.StringObject {
            constructor(R) {
              super(p, "handler"), this.id = R.id || "", this.type = (0, e.getStringOption)(R.type, ["optional", "required"]), this.use = R.use || "", this.usehref = R.usehref || "";
            }
          }
          class qe extends t.XFAObject {
            constructor(R) {
              super(p, "hyphenation"), this.excludeAllCaps = (0, e.getInteger)({
                data: R.excludeAllCaps,
                defaultValue: 0,
                validate: (he) => he === 1
              }), this.excludeInitialCap = (0, e.getInteger)({
                data: R.excludeInitialCap,
                defaultValue: 0,
                validate: (he) => he === 1
              }), this.hyphenate = (0, e.getInteger)({
                data: R.hyphenate,
                defaultValue: 0,
                validate: (he) => he === 1
              }), this.id = R.id || "", this.pushCharacterCount = (0, e.getInteger)({
                data: R.pushCharacterCount,
                defaultValue: 3,
                validate: (he) => he >= 0
              }), this.remainCharacterCount = (0, e.getInteger)({
                data: R.remainCharacterCount,
                defaultValue: 3,
                validate: (he) => he >= 0
              }), this.use = R.use || "", this.usehref = R.usehref || "", this.wordCharacterCount = (0, e.getInteger)({
                data: R.wordCharacterCount,
                defaultValue: 7,
                validate: (he) => he >= 0
              });
            }
          }
          class ot extends t.StringObject {
            constructor(R) {
              super(p, "image"), this.aspect = (0, e.getStringOption)(R.aspect, ["fit", "actual", "height", "none", "width"]), this.contentType = R.contentType || "", this.href = R.href || "", this.id = R.id || "", this.name = R.name || "", this.transferEncoding = (0, e.getStringOption)(R.transferEncoding, ["base64", "none", "package"]), this.use = R.use || "", this.usehref = R.usehref || "";
            }
            [t.$toHTML]() {
              if (this.contentType && !w.has(this.contentType.toLowerCase()))
                return e.HTMLResult.EMPTY;
              let R = this[t.$globalData].images && this[t.$globalData].images.get(this.href);
              if (!R && (this.href || !this[t.$content]) || (!R && this.transferEncoding === "base64" && (R = (0, y.stringToBytes)(atob(this[t.$content]))), !R))
                return e.HTMLResult.EMPTY;
              if (!this.contentType) {
                for (const [ht, It] of O)
                  if (R.length > ht.length && ht.every((Et, Rt) => Et === R[Rt])) {
                    this.contentType = It;
                    break;
                  }
                if (!this.contentType)
                  return e.HTMLResult.EMPTY;
              }
              const he = new Blob([R], {
                type: this.contentType
              });
              let $e;
              switch (this.aspect) {
                case "fit":
                case "actual":
                  break;
                case "height":
                  $e = {
                    height: "100%",
                    objectFit: "fill"
                  };
                  break;
                case "none":
                  $e = {
                    width: "100%",
                    height: "100%",
                    objectFit: "fill"
                  };
                  break;
                case "width":
                  $e = {
                    width: "100%",
                    objectFit: "fill"
                  };
                  break;
              }
              const Ze = this[t.$getParent]();
              return e.HTMLResult.success({
                name: "img",
                attributes: {
                  class: ["xfaImage"],
                  style: $e,
                  src: URL.createObjectURL(he),
                  alt: Ze ? k(Ze[t.$getParent]()) : null
                }
              });
            }
          }
          class lt extends t.XFAObject {
            constructor(R) {
              super(p, "imageEdit", !0), this.data = (0, e.getStringOption)(R.data, ["link", "embed"]), this.id = R.id || "", this.use = R.use || "", this.usehref = R.usehref || "", this.border = null, this.extras = null, this.margin = null;
            }
            [t.$toHTML](R) {
              return this.data === "embed" ? e.HTMLResult.success({
                name: "div",
                children: [],
                attributes: {}
              }) : e.HTMLResult.EMPTY;
            }
          }
          class Ut extends t.ContentObject {
            constructor(R) {
              super(p, "integer"), this.id = R.id || "", this.name = R.name || "", this.use = R.use || "", this.usehref = R.usehref || "";
            }
            [t.$finalize]() {
              const R = parseInt(this[t.$content].trim(), 10);
              this[t.$content] = isNaN(R) ? null : R;
            }
            [t.$toHTML](R) {
              return x(this[t.$content] !== null ? this[t.$content].toString() : "");
            }
          }
          class Nt extends t.XFAObject {
            constructor(R) {
              super(p, "issuers", !0), this.id = R.id || "", this.type = (0, e.getStringOption)(R.type, ["optional", "required"]), this.use = R.use || "", this.usehref = R.usehref || "", this.certificate = new t.XFAObjectArray();
            }
          }
          class Ve extends t.XFAObject {
            constructor(R) {
              super(p, "items", !0), this.id = R.id || "", this.name = R.name || "", this.presence = (0, e.getStringOption)(R.presence, ["visible", "hidden", "inactive", "invisible"]), this.ref = R.ref || "", this.save = (0, e.getInteger)({
                data: R.save,
                defaultValue: 0,
                validate: (he) => he === 1
              }), this.use = R.use || "", this.usehref = R.usehref || "", this.boolean = new t.XFAObjectArray(), this.date = new t.XFAObjectArray(), this.dateTime = new t.XFAObjectArray(), this.decimal = new t.XFAObjectArray(), this.exData = new t.XFAObjectArray(), this.float = new t.XFAObjectArray(), this.image = new t.XFAObjectArray(), this.integer = new t.XFAObjectArray(), this.text = new t.XFAObjectArray(), this.time = new t.XFAObjectArray();
            }
            [t.$toHTML]() {
              const R = [];
              for (const he of this[t.$getChildren]())
                R.push(he[t.$text]());
              return e.HTMLResult.success(R);
            }
          }
          o.Items = Ve;
          class je extends t.XFAObject {
            constructor(R) {
              super(p, "keep", !0), this.id = R.id || "";
              const he = ["none", "contentArea", "pageArea"];
              this.intact = (0, e.getStringOption)(R.intact, he), this.next = (0, e.getStringOption)(R.next, he), this.previous = (0, e.getStringOption)(R.previous, he), this.use = R.use || "", this.usehref = R.usehref || "", this.extras = null;
            }
          }
          class at extends t.XFAObject {
            constructor(R) {
              super(p, "keyUsage");
              const he = ["", "yes", "no"];
              this.crlSign = (0, e.getStringOption)(R.crlSign, he), this.dataEncipherment = (0, e.getStringOption)(R.dataEncipherment, he), this.decipherOnly = (0, e.getStringOption)(R.decipherOnly, he), this.digitalSignature = (0, e.getStringOption)(R.digitalSignature, he), this.encipherOnly = (0, e.getStringOption)(R.encipherOnly, he), this.id = R.id || "", this.keyAgreement = (0, e.getStringOption)(R.keyAgreement, he), this.keyCertSign = (0, e.getStringOption)(R.keyCertSign, he), this.keyEncipherment = (0, e.getStringOption)(R.keyEncipherment, he), this.nonRepudiation = (0, e.getStringOption)(R.nonRepudiation, he), this.type = (0, e.getStringOption)(R.type, ["optional", "required"]), this.use = R.use || "", this.usehref = R.usehref || "";
            }
          }
          class nt extends t.XFAObject {
            constructor(R) {
              super(p, "line", !0), this.hand = (0, e.getStringOption)(R.hand, ["even", "left", "right"]), this.id = R.id || "", this.slope = (0, e.getStringOption)(R.slope, ["\\", "/"]), this.use = R.use || "", this.usehref = R.usehref || "", this.edge = null;
            }
            [t.$toHTML]() {
              const R = this[t.$getParent]()[t.$getParent](), he = this.edge || new De({}), $e = he[t.$toStyle](), Ze = /* @__PURE__ */ Object.create(null), ht = he.presence === "visible" ? he.thickness : 0;
              Ze.strokeWidth = (0, h.measureToString)(ht), Ze.stroke = $e.color;
              let It, Et, Rt, $t, Ht = "100%", Jt = "100%";
              R.w <= ht ? ([It, Et, Rt, $t] = ["50%", 0, "50%", "100%"], Ht = Ze.strokeWidth) : R.h <= ht ? ([It, Et, Rt, $t] = [0, "50%", "100%", "50%"], Jt = Ze.strokeWidth) : this.slope === "\\" ? [It, Et, Rt, $t] = [0, 0, "100%", "100%"] : [It, Et, Rt, $t] = [0, "100%", "100%", 0];
              const tn = {
                name: "svg",
                children: [{
                  name: "line",
                  attributes: {
                    xmlns: g,
                    x1: It,
                    y1: Et,
                    x2: Rt,
                    y2: $t,
                    style: Ze
                  }
                }],
                attributes: {
                  xmlns: g,
                  width: Ht,
                  height: Jt,
                  style: {
                    overflow: "visible"
                  }
                }
              };
              return A(R) ? e.HTMLResult.success({
                name: "div",
                attributes: {
                  style: {
                    display: "inline",
                    width: "100%",
                    height: "100%"
                  }
                },
                children: [tn]
              }) : (tn.attributes.style.position = "absolute", e.HTMLResult.success(tn));
            }
          }
          class ft extends t.XFAObject {
            constructor(R) {
              super(p, "linear", !0), this.id = R.id || "", this.type = (0, e.getStringOption)(R.type, ["toRight", "toBottom", "toLeft", "toTop"]), this.use = R.use || "", this.usehref = R.usehref || "", this.color = null, this.extras = null;
            }
            [t.$toStyle](R) {
              R = R ? R[t.$toStyle]() : "#FFFFFF";
              const he = this.type.replace(/([RBLT])/, " $1").toLowerCase(), $e = this.color ? this.color[t.$toStyle]() : "#000000";
              return `linear-gradient(${he}, ${R}, ${$e})`;
            }
          }
          class Tt extends t.ContentObject {
            constructor(R) {
              super(p, "lockDocument"), this.id = R.id || "", this.type = (0, e.getStringOption)(R.type, ["optional", "required"]), this.use = R.use || "", this.usehref = R.usehref || "";
            }
            [t.$finalize]() {
              this[t.$content] = (0, e.getStringOption)(this[t.$content], ["auto", "0", "1"]);
            }
          }
          class yt extends t.XFAObject {
            constructor(R) {
              super(p, "manifest", !0), this.action = (0, e.getStringOption)(R.action, ["include", "all", "exclude"]), this.id = R.id || "", this.name = R.name || "", this.use = R.use || "", this.usehref = R.usehref || "", this.extras = null, this.ref = new t.XFAObjectArray();
            }
          }
          class dt extends t.XFAObject {
            constructor(R) {
              super(p, "margin", !0), this.bottomInset = (0, e.getMeasurement)(R.bottomInset, "0"), this.id = R.id || "", this.leftInset = (0, e.getMeasurement)(R.leftInset, "0"), this.rightInset = (0, e.getMeasurement)(R.rightInset, "0"), this.topInset = (0, e.getMeasurement)(R.topInset, "0"), this.use = R.use || "", this.usehref = R.usehref || "", this.extras = null;
            }
            [t.$toStyle]() {
              return {
                margin: (0, h.measureToString)(this.topInset) + " " + (0, h.measureToString)(this.rightInset) + " " + (0, h.measureToString)(this.bottomInset) + " " + (0, h.measureToString)(this.leftInset)
              };
            }
          }
          class wt extends t.XFAObject {
            constructor(R) {
              super(p, "mdp"), this.id = R.id || "", this.permissions = (0, e.getInteger)({
                data: R.permissions,
                defaultValue: 2,
                validate: (he) => he === 1 || he === 3
              }), this.signatureType = (0, e.getStringOption)(R.signatureType, ["filler", "author"]), this.use = R.use || "", this.usehref = R.usehref || "";
            }
          }
          class Dt extends t.XFAObject {
            constructor(R) {
              super(p, "medium"), this.id = R.id || "", this.imagingBBox = (0, e.getBBox)(R.imagingBBox), this.long = (0, e.getMeasurement)(R.long), this.orientation = (0, e.getStringOption)(R.orientation, ["portrait", "landscape"]), this.short = (0, e.getMeasurement)(R.short), this.stock = R.stock || "", this.trayIn = (0, e.getStringOption)(R.trayIn, ["auto", "delegate", "pageFront"]), this.trayOut = (0, e.getStringOption)(R.trayOut, ["auto", "delegate"]), this.use = R.use || "", this.usehref = R.usehref || "";
            }
          }
          class jt extends t.XFAObject {
            constructor(R) {
              super(p, "message", !0), this.id = R.id || "", this.use = R.use || "", this.usehref = R.usehref || "", this.text = new t.XFAObjectArray();
            }
          }
          class Bt extends t.XFAObject {
            constructor(R) {
              super(p, "numericEdit", !0), this.hScrollPolicy = (0, e.getStringOption)(R.hScrollPolicy, ["auto", "off", "on"]), this.id = R.id || "", this.use = R.use || "", this.usehref = R.usehref || "", this.border = null, this.comb = null, this.extras = null, this.margin = null;
            }
            [t.$toHTML](R) {
              const he = (0, h.toStyle)(this, "border", "font", "margin"), $e = this[t.$getParent]()[t.$getParent](), Ze = {
                name: "input",
                attributes: {
                  type: "text",
                  fieldId: $e[t.$uid],
                  dataId: $e[t.$data] && $e[t.$data][t.$uid] || $e[t.$uid],
                  class: ["xfaTextfield"],
                  style: he,
                  "aria-label": k($e),
                  "aria-required": !1
                }
              };
              return X($e) && (Ze.attributes["aria-required"] = !0, Ze.attributes.required = !0), e.HTMLResult.success({
                name: "label",
                attributes: {
                  class: ["xfaLabel"]
                },
                children: [Ze]
              });
            }
          }
          class kt extends t.XFAObject {
            constructor(R) {
              super(p, "occur", !0), this.id = R.id || "", this.initial = R.initial !== "" ? (0, e.getInteger)({
                data: R.initial,
                defaultValue: "",
                validate: (he) => !0
              }) : "", this.max = R.max !== "" ? (0, e.getInteger)({
                data: R.max,
                defaultValue: 1,
                validate: (he) => !0
              }) : "", this.min = R.min !== "" ? (0, e.getInteger)({
                data: R.min,
                defaultValue: 1,
                validate: (he) => !0
              }) : "", this.use = R.use || "", this.usehref = R.usehref || "", this.extras = null;
            }
            [t.$clean]() {
              const R = this[t.$getParent](), he = this.min;
              this.min === "" && (this.min = R instanceof tt || R instanceof St ? 0 : 1), this.max === "" && (he === "" ? this.max = R instanceof tt || R instanceof St ? -1 : 1 : this.max = this.min), this.max !== -1 && this.max < this.min && (this.max = this.min), this.initial === "" && (this.initial = R instanceof Fn ? 1 : this.min);
            }
          }
          class Ue extends t.StringObject {
            constructor(R) {
              super(p, "oid"), this.id = R.id || "", this.name = R.name || "", this.use = R.use || "", this.usehref = R.usehref || "";
            }
          }
          class We extends t.XFAObject {
            constructor(R) {
              super(p, "oids", !0), this.id = R.id || "", this.type = (0, e.getStringOption)(R.type, ["optional", "required"]), this.use = R.use || "", this.usehref = R.usehref || "", this.oid = new t.XFAObjectArray();
            }
          }
          class rt extends t.XFAObject {
            constructor(R) {
              super(p, "overflow"), this.id = R.id || "", this.leader = R.leader || "", this.target = R.target || "", this.trailer = R.trailer || "", this.use = R.use || "", this.usehref = R.usehref || "";
            }
            [t.$getExtra]() {
              if (!this[t.$extra]) {
                const R = this[t.$getParent](), he = this[t.$getTemplateRoot](), $e = he[t.$searchNode](this.target, R), Ze = he[t.$searchNode](this.leader, R), ht = he[t.$searchNode](this.trailer, R);
                this[t.$extra] = {
                  target: $e && $e[0] || null,
                  leader: Ze && Ze[0] || null,
                  trailer: ht && ht[0] || null,
                  addLeader: !1,
                  addTrailer: !1
                };
              }
              return this[t.$extra];
            }
          }
          class tt extends t.XFAObject {
            constructor(R) {
              super(p, "pageArea", !0), this.blankOrNotBlank = (0, e.getStringOption)(R.blankOrNotBlank, ["any", "blank", "notBlank"]), this.id = R.id || "", this.initialNumber = (0, e.getInteger)({
                data: R.initialNumber,
                defaultValue: 1,
                validate: (he) => !0
              }), this.name = R.name || "", this.numbered = (0, e.getInteger)({
                data: R.numbered,
                defaultValue: 1,
                validate: (he) => !0
              }), this.oddOrEven = (0, e.getStringOption)(R.oddOrEven, ["any", "even", "odd"]), this.pagePosition = (0, e.getStringOption)(R.pagePosition, ["any", "first", "last", "only", "rest"]), this.relevant = (0, e.getRelevant)(R.relevant), this.use = R.use || "", this.usehref = R.usehref || "", this.desc = null, this.extras = null, this.medium = null, this.occur = null, this.area = new t.XFAObjectArray(), this.contentArea = new t.XFAObjectArray(), this.draw = new t.XFAObjectArray(), this.exclGroup = new t.XFAObjectArray(), this.field = new t.XFAObjectArray(), this.subform = new t.XFAObjectArray();
            }
            [t.$isUsable]() {
              return this[t.$extra] ? !this.occur || this.occur.max === -1 || this[t.$extra].numberOfUse < this.occur.max : (this[t.$extra] = {
                numberOfUse: 0
              }, !0);
            }
            [t.$cleanPage]() {
              delete this[t.$extra];
            }
            [t.$getNextPage]() {
              this[t.$extra] || (this[t.$extra] = {
                numberOfUse: 0
              });
              const R = this[t.$getParent]();
              return R.relation === "orderedOccurrence" && this[t.$isUsable]() ? (this[t.$extra].numberOfUse += 1, this) : R[t.$getNextPage]();
            }
            [t.$getAvailableSpace]() {
              return this[t.$extra].space || {
                width: 0,
                height: 0
              };
            }
            [t.$toHTML]() {
              this[t.$extra] || (this[t.$extra] = {
                numberOfUse: 1
              });
              const R = [];
              this[t.$extra].children = R;
              const he = /* @__PURE__ */ Object.create(null);
              if (this.medium && this.medium.short && this.medium.long) {
                if (he.width = (0, h.measureToString)(this.medium.short), he.height = (0, h.measureToString)(this.medium.long), this[t.$extra].space = {
                  width: this.medium.short,
                  height: this.medium.long
                }, this.medium.orientation === "landscape") {
                  const $e = he.width;
                  he.width = he.height, he.height = $e, this[t.$extra].space = {
                    width: this.medium.long,
                    height: this.medium.short
                  };
                }
              } else
                (0, y.warn)("XFA - No medium specified in pageArea: please file a bug.");
              return this[t.$childrenToHTML]({
                filter: /* @__PURE__ */ new Set(["area", "draw", "field", "subform"]),
                include: !0
              }), this[t.$childrenToHTML]({
                filter: /* @__PURE__ */ new Set(["contentArea"]),
                include: !0
              }), e.HTMLResult.success({
                name: "div",
                children: R,
                attributes: {
                  class: ["xfaPage"],
                  id: this[t.$uid],
                  style: he,
                  xfaName: this.name
                }
              });
            }
          }
          class St extends t.XFAObject {
            constructor(R) {
              super(p, "pageSet", !0), this.duplexImposition = (0, e.getStringOption)(R.duplexImposition, ["longEdge", "shortEdge"]), this.id = R.id || "", this.name = R.name || "", this.relation = (0, e.getStringOption)(R.relation, ["orderedOccurrence", "duplexPaginated", "simplexPaginated"]), this.relevant = (0, e.getRelevant)(R.relevant), this.use = R.use || "", this.usehref = R.usehref || "", this.extras = null, this.occur = null, this.pageArea = new t.XFAObjectArray(), this.pageSet = new t.XFAObjectArray();
            }
            [t.$cleanPage]() {
              for (const R of this.pageArea.children)
                R[t.$cleanPage]();
              for (const R of this.pageSet.children)
                R[t.$cleanPage]();
            }
            [t.$isUsable]() {
              return !this.occur || this.occur.max === -1 || this[t.$extra].numberOfUse < this.occur.max;
            }
            [t.$getNextPage]() {
              if (this[t.$extra] || (this[t.$extra] = {
                numberOfUse: 1,
                pageIndex: -1,
                pageSetIndex: -1
              }), this.relation === "orderedOccurrence") {
                if (this[t.$extra].pageIndex + 1 < this.pageArea.children.length)
                  return this[t.$extra].pageIndex += 1, this.pageArea.children[this[t.$extra].pageIndex][t.$getNextPage]();
                if (this[t.$extra].pageSetIndex + 1 < this.pageSet.children.length)
                  return this[t.$extra].pageSetIndex += 1, this.pageSet.children[this[t.$extra].pageSetIndex][t.$getNextPage]();
                if (this[t.$isUsable]())
                  return this[t.$extra].numberOfUse += 1, this[t.$extra].pageIndex = -1, this[t.$extra].pageSetIndex = -1, this[t.$getNextPage]();
                const ht = this[t.$getParent]();
                return ht instanceof St ? ht[t.$getNextPage]() : (this[t.$cleanPage](), this[t.$getNextPage]());
              }
              const R = this[t.$getTemplateRoot]()[t.$extra].pageNumber, he = R % 2 === 0 ? "even" : "odd", $e = R === 0 ? "first" : "rest";
              let Ze = this.pageArea.children.find((ht) => ht.oddOrEven === he && ht.pagePosition === $e);
              return Ze || (Ze = this.pageArea.children.find((ht) => ht.oddOrEven === "any" && ht.pagePosition === $e), Ze) || (Ze = this.pageArea.children.find((ht) => ht.oddOrEven === "any" && ht.pagePosition === "any"), Ze) ? Ze : this.pageArea.children[0];
            }
          }
          class Pt extends t.XFAObject {
            constructor(R) {
              super(p, "para", !0), this.hAlign = (0, e.getStringOption)(R.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = R.id || "", this.lineHeight = R.lineHeight ? (0, e.getMeasurement)(R.lineHeight, "0pt") : "", this.marginLeft = R.marginLeft ? (0, e.getMeasurement)(R.marginLeft, "0pt") : "", this.marginRight = R.marginRight ? (0, e.getMeasurement)(R.marginRight, "0pt") : "", this.orphans = (0, e.getInteger)({
                data: R.orphans,
                defaultValue: 0,
                validate: (he) => he >= 0
              }), this.preserve = R.preserve || "", this.radixOffset = R.radixOffset ? (0, e.getMeasurement)(R.radixOffset, "0pt") : "", this.spaceAbove = R.spaceAbove ? (0, e.getMeasurement)(R.spaceAbove, "0pt") : "", this.spaceBelow = R.spaceBelow ? (0, e.getMeasurement)(R.spaceBelow, "0pt") : "", this.tabDefault = R.tabDefault ? (0, e.getMeasurement)(this.tabDefault) : "", this.tabStops = (R.tabStops || "").trim().split(/\s+/).map((he, $e) => $e % 2 === 1 ? (0, e.getMeasurement)(he) : he), this.textIndent = R.textIndent ? (0, e.getMeasurement)(R.textIndent, "0pt") : "", this.use = R.use || "", this.usehref = R.usehref || "", this.vAlign = (0, e.getStringOption)(R.vAlign, ["top", "bottom", "middle"]), this.widows = (0, e.getInteger)({
                data: R.widows,
                defaultValue: 0,
                validate: (he) => he >= 0
              }), this.hyphenation = null;
            }
            [t.$toStyle]() {
              const R = (0, h.toStyle)(this, "hAlign");
              return this.marginLeft !== "" && (R.paddingLeft = (0, h.measureToString)(this.marginLeft)), this.marginRight !== "" && (R.paddingight = (0, h.measureToString)(this.marginRight)), this.spaceAbove !== "" && (R.paddingTop = (0, h.measureToString)(this.spaceAbove)), this.spaceBelow !== "" && (R.paddingBottom = (0, h.measureToString)(this.spaceBelow)), this.textIndent !== "" && (R.textIndent = (0, h.measureToString)(this.textIndent), (0, h.fixTextIndent)(R)), this.lineHeight > 0 && (R.lineHeight = (0, h.measureToString)(this.lineHeight)), this.tabDefault !== "" && (R.tabSize = (0, h.measureToString)(this.tabDefault)), this.tabStops.length > 0, this.hyphenatation && Object.assign(R, this.hyphenatation[t.$toStyle]()), R;
            }
          }
          class qt extends t.XFAObject {
            constructor(R) {
              super(p, "passwordEdit", !0), this.hScrollPolicy = (0, e.getStringOption)(R.hScrollPolicy, ["auto", "off", "on"]), this.id = R.id || "", this.passwordChar = R.passwordChar || "*", this.use = R.use || "", this.usehref = R.usehref || "", this.border = null, this.extras = null, this.margin = null;
            }
          }
          class Mt extends t.XFAObject {
            constructor(R) {
              super(p, "pattern", !0), this.id = R.id || "", this.type = (0, e.getStringOption)(R.type, ["crossHatch", "crossDiagonal", "diagonalLeft", "diagonalRight", "horizontal", "vertical"]), this.use = R.use || "", this.usehref = R.usehref || "", this.color = null, this.extras = null;
            }
            [t.$toStyle](R) {
              R = R ? R[t.$toStyle]() : "#FFFFFF";
              const he = this.color ? this.color[t.$toStyle]() : "#000000", $e = 5, Ze = "repeating-linear-gradient", ht = `${R},${R} ${$e}px,${he} ${$e}px,${he} ${2 * $e}px`;
              switch (this.type) {
                case "crossHatch":
                  return `${Ze}(to top,${ht}) ${Ze}(to right,${ht})`;
                case "crossDiagonal":
                  return `${Ze}(45deg,${ht}) ${Ze}(-45deg,${ht})`;
                case "diagonalLeft":
                  return `${Ze}(45deg,${ht})`;
                case "diagonalRight":
                  return `${Ze}(-45deg,${ht})`;
                case "horizontal":
                  return `${Ze}(to top,${ht})`;
                case "vertical":
                  return `${Ze}(to right,${ht})`;
              }
              return "";
            }
          }
          class Wt extends t.StringObject {
            constructor(R) {
              super(p, "picture"), this.id = R.id || "", this.use = R.use || "", this.usehref = R.usehref || "";
            }
          }
          class Zt extends t.XFAObject {
            constructor(R) {
              super(p, "proto", !0), this.appearanceFilter = new t.XFAObjectArray(), this.arc = new t.XFAObjectArray(), this.area = new t.XFAObjectArray(), this.assist = new t.XFAObjectArray(), this.barcode = new t.XFAObjectArray(), this.bindItems = new t.XFAObjectArray(), this.bookend = new t.XFAObjectArray(), this.boolean = new t.XFAObjectArray(), this.border = new t.XFAObjectArray(), this.break = new t.XFAObjectArray(), this.breakAfter = new t.XFAObjectArray(), this.breakBefore = new t.XFAObjectArray(), this.button = new t.XFAObjectArray(), this.calculate = new t.XFAObjectArray(), this.caption = new t.XFAObjectArray(), this.certificate = new t.XFAObjectArray(), this.certificates = new t.XFAObjectArray(), this.checkButton = new t.XFAObjectArray(), this.choiceList = new t.XFAObjectArray(), this.color = new t.XFAObjectArray(), this.comb = new t.XFAObjectArray(), this.connect = new t.XFAObjectArray(), this.contentArea = new t.XFAObjectArray(), this.corner = new t.XFAObjectArray(), this.date = new t.XFAObjectArray(), this.dateTime = new t.XFAObjectArray(), this.dateTimeEdit = new t.XFAObjectArray(), this.decimal = new t.XFAObjectArray(), this.defaultUi = new t.XFAObjectArray(), this.desc = new t.XFAObjectArray(), this.digestMethod = new t.XFAObjectArray(), this.digestMethods = new t.XFAObjectArray(), this.draw = new t.XFAObjectArray(), this.edge = new t.XFAObjectArray(), this.encoding = new t.XFAObjectArray(), this.encodings = new t.XFAObjectArray(), this.encrypt = new t.XFAObjectArray(), this.encryptData = new t.XFAObjectArray(), this.encryption = new t.XFAObjectArray(), this.encryptionMethod = new t.XFAObjectArray(), this.encryptionMethods = new t.XFAObjectArray(), this.event = new t.XFAObjectArray(), this.exData = new t.XFAObjectArray(), this.exObject = new t.XFAObjectArray(), this.exclGroup = new t.XFAObjectArray(), this.execute = new t.XFAObjectArray(), this.extras = new t.XFAObjectArray(), this.field = new t.XFAObjectArray(), this.fill = new t.XFAObjectArray(), this.filter = new t.XFAObjectArray(), this.float = new t.XFAObjectArray(), this.font = new t.XFAObjectArray(), this.format = new t.XFAObjectArray(), this.handler = new t.XFAObjectArray(), this.hyphenation = new t.XFAObjectArray(), this.image = new t.XFAObjectArray(), this.imageEdit = new t.XFAObjectArray(), this.integer = new t.XFAObjectArray(), this.issuers = new t.XFAObjectArray(), this.items = new t.XFAObjectArray(), this.keep = new t.XFAObjectArray(), this.keyUsage = new t.XFAObjectArray(), this.line = new t.XFAObjectArray(), this.linear = new t.XFAObjectArray(), this.lockDocument = new t.XFAObjectArray(), this.manifest = new t.XFAObjectArray(), this.margin = new t.XFAObjectArray(), this.mdp = new t.XFAObjectArray(), this.medium = new t.XFAObjectArray(), this.message = new t.XFAObjectArray(), this.numericEdit = new t.XFAObjectArray(), this.occur = new t.XFAObjectArray(), this.oid = new t.XFAObjectArray(), this.oids = new t.XFAObjectArray(), this.overflow = new t.XFAObjectArray(), this.pageArea = new t.XFAObjectArray(), this.pageSet = new t.XFAObjectArray(), this.para = new t.XFAObjectArray(), this.passwordEdit = new t.XFAObjectArray(), this.pattern = new t.XFAObjectArray(), this.picture = new t.XFAObjectArray(), this.radial = new t.XFAObjectArray(), this.reason = new t.XFAObjectArray(), this.reasons = new t.XFAObjectArray(), this.rectangle = new t.XFAObjectArray(), this.ref = new t.XFAObjectArray(), this.script = new t.XFAObjectArray(), this.setProperty = new t.XFAObjectArray(), this.signData = new t.XFAObjectArray(), this.signature = new t.XFAObjectArray(), this.signing = new t.XFAObjectArray(), this.solid = new t.XFAObjectArray(), this.speak = new t.XFAObjectArray(), this.stipple = new t.XFAObjectArray(), this.subform = new t.XFAObjectArray(), this.subformSet = new t.XFAObjectArray(), this.subjectDN = new t.XFAObjectArray(), this.subjectDNs = new t.XFAObjectArray(), this.submit = new t.XFAObjectArray(), this.text = new t.XFAObjectArray(), this.textEdit = new t.XFAObjectArray(), this.time = new t.XFAObjectArray(), this.timeStamp = new t.XFAObjectArray(), this.toolTip = new t.XFAObjectArray(), this.traversal = new t.XFAObjectArray(), this.traverse = new t.XFAObjectArray(), this.ui = new t.XFAObjectArray(), this.validate = new t.XFAObjectArray(), this.value = new t.XFAObjectArray(), this.variables = new t.XFAObjectArray();
            }
          }
          class an extends t.XFAObject {
            constructor(R) {
              super(p, "radial", !0), this.id = R.id || "", this.type = (0, e.getStringOption)(R.type, ["toEdge", "toCenter"]), this.use = R.use || "", this.usehref = R.usehref || "", this.color = null, this.extras = null;
            }
            [t.$toStyle](R) {
              R = R ? R[t.$toStyle]() : "#FFFFFF";
              const he = this.color ? this.color[t.$toStyle]() : "#000000";
              return `radial-gradient(circle at center, ${this.type === "toEdge" ? `${R},${he}` : `${he},${R}`})`;
            }
          }
          class un extends t.StringObject {
            constructor(R) {
              super(p, "reason"), this.id = R.id || "", this.name = R.name || "", this.use = R.use || "", this.usehref = R.usehref || "";
            }
          }
          class Tn extends t.XFAObject {
            constructor(R) {
              super(p, "reasons", !0), this.id = R.id || "", this.type = (0, e.getStringOption)(R.type, ["optional", "required"]), this.use = R.use || "", this.usehref = R.usehref || "", this.reason = new t.XFAObjectArray();
            }
          }
          class gn extends t.XFAObject {
            constructor(R) {
              super(p, "rectangle", !0), this.hand = (0, e.getStringOption)(R.hand, ["even", "left", "right"]), this.id = R.id || "", this.use = R.use || "", this.usehref = R.usehref || "", this.corner = new t.XFAObjectArray(4), this.edge = new t.XFAObjectArray(4), this.fill = null;
            }
            [t.$toHTML]() {
              const R = this.edge.children.length ? this.edge.children[0] : new De({}), he = R[t.$toStyle](), $e = /* @__PURE__ */ Object.create(null);
              this.fill && this.fill.presence === "visible" ? Object.assign($e, this.fill[t.$toStyle]()) : $e.fill = "transparent", $e.strokeWidth = (0, h.measureToString)(R.presence === "visible" ? R.thickness : 0), $e.stroke = he.color;
              const ht = (this.corner.children.length ? this.corner.children[0] : new ue({}))[t.$toStyle](), Et = {
                name: "svg",
                children: [{
                  name: "rect",
                  attributes: {
                    xmlns: g,
                    width: "100%",
                    height: "100%",
                    x: 0,
                    y: 0,
                    rx: ht.radius,
                    ry: ht.radius,
                    style: $e
                  }
                }],
                attributes: {
                  xmlns: g,
                  style: {
                    overflow: "visible"
                  },
                  width: "100%",
                  height: "100%"
                }
              }, Rt = this[t.$getParent]()[t.$getParent]();
              return A(Rt) ? e.HTMLResult.success({
                name: "div",
                attributes: {
                  style: {
                    display: "inline",
                    width: "100%",
                    height: "100%"
                  }
                },
                children: [Et]
              }) : (Et.attributes.style.position = "absolute", e.HTMLResult.success(Et));
            }
          }
          class _n extends t.StringObject {
            constructor(R) {
              super(p, "ref"), this.id = R.id || "", this.use = R.use || "", this.usehref = R.usehref || "";
            }
          }
          class vn extends t.StringObject {
            constructor(R) {
              super(p, "script"), this.binding = R.binding || "", this.contentType = R.contentType || "", this.id = R.id || "", this.name = R.name || "", this.runAt = (0, e.getStringOption)(R.runAt, ["client", "both", "server"]), this.use = R.use || "", this.usehref = R.usehref || "";
            }
          }
          class En extends t.XFAObject {
            constructor(R) {
              super(p, "setProperty"), this.connection = R.connection || "", this.ref = R.ref || "", this.target = R.target || "";
            }
          }
          o.SetProperty = En;
          class kn extends t.XFAObject {
            constructor(R) {
              super(p, "signData", !0), this.id = R.id || "", this.operation = (0, e.getStringOption)(R.operation, ["sign", "clear", "verify"]), this.ref = R.ref || "", this.target = R.target || "", this.use = R.use || "", this.usehref = R.usehref || "", this.filter = null, this.manifest = null;
            }
          }
          class Ln extends t.XFAObject {
            constructor(R) {
              super(p, "signature", !0), this.id = R.id || "", this.type = (0, e.getStringOption)(R.type, ["PDF1.3", "PDF1.6"]), this.use = R.use || "", this.usehref = R.usehref || "", this.border = null, this.extras = null, this.filter = null, this.manifest = null, this.margin = null;
            }
          }
          class Nn extends t.XFAObject {
            constructor(R) {
              super(p, "signing", !0), this.id = R.id || "", this.type = (0, e.getStringOption)(R.type, ["optional", "required"]), this.use = R.use || "", this.usehref = R.usehref || "", this.certificate = new t.XFAObjectArray();
            }
          }
          class wn extends t.XFAObject {
            constructor(R) {
              super(p, "solid", !0), this.id = R.id || "", this.use = R.use || "", this.usehref = R.usehref || "", this.extras = null;
            }
            [t.$toStyle](R) {
              return R ? R[t.$toStyle]() : "#FFFFFF";
            }
          }
          class On extends t.StringObject {
            constructor(R) {
              super(p, "speak"), this.disable = (0, e.getInteger)({
                data: R.disable,
                defaultValue: 0,
                validate: (he) => he === 1
              }), this.id = R.id || "", this.priority = (0, e.getStringOption)(R.priority, ["custom", "caption", "name", "toolTip"]), this.rid = R.rid || "", this.use = R.use || "", this.usehref = R.usehref || "";
            }
          }
          class In extends t.XFAObject {
            constructor(R) {
              super(p, "stipple", !0), this.id = R.id || "", this.rate = (0, e.getInteger)({
                data: R.rate,
                defaultValue: 50,
                validate: (he) => he >= 0 && he <= 100
              }), this.use = R.use || "", this.usehref = R.usehref || "", this.color = null, this.extras = null;
            }
            [t.$toStyle](R) {
              const he = this.rate / 100;
              return y.Util.makeHexColor(Math.round(R.value.r * (1 - he) + this.value.r * he), Math.round(R.value.g * (1 - he) + this.value.g * he), Math.round(R.value.b * (1 - he) + this.value.b * he));
            }
          }
          class xn extends t.XFAObject {
            constructor(R) {
              super(p, "subform", !0), this.access = (0, e.getStringOption)(R.access, ["open", "nonInteractive", "protected", "readOnly"]), this.allowMacro = (0, e.getInteger)({
                data: R.allowMacro,
                defaultValue: 0,
                validate: (he) => he === 1
              }), this.anchorType = (0, e.getStringOption)(R.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = (0, e.getInteger)({
                data: R.colSpan,
                defaultValue: 1,
                validate: (he) => he >= 1 || he === -1
              }), this.columnWidths = (R.columnWidths || "").trim().split(/\s+/).map((he) => he === "-1" ? -1 : (0, e.getMeasurement)(he)), this.h = R.h ? (0, e.getMeasurement)(R.h) : "", this.hAlign = (0, e.getStringOption)(R.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = R.id || "", this.layout = (0, e.getStringOption)(R.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]), this.locale = R.locale || "", this.maxH = (0, e.getMeasurement)(R.maxH, "0pt"), this.maxW = (0, e.getMeasurement)(R.maxW, "0pt"), this.mergeMode = (0, e.getStringOption)(R.mergeMode, ["consumeData", "matchTemplate"]), this.minH = (0, e.getMeasurement)(R.minH, "0pt"), this.minW = (0, e.getMeasurement)(R.minW, "0pt"), this.name = R.name || "", this.presence = (0, e.getStringOption)(R.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = (0, e.getRelevant)(R.relevant), this.restoreState = (0, e.getStringOption)(R.restoreState, ["manual", "auto"]), this.scope = (0, e.getStringOption)(R.scope, ["name", "none"]), this.use = R.use || "", this.usehref = R.usehref || "", this.w = R.w ? (0, e.getMeasurement)(R.w) : "", this.x = (0, e.getMeasurement)(R.x, "0pt"), this.y = (0, e.getMeasurement)(R.y, "0pt"), this.assist = null, this.bind = null, this.bookend = null, this.border = null, this.break = null, this.calculate = null, this.desc = null, this.extras = null, this.keep = null, this.margin = null, this.occur = null, this.overflow = null, this.pageSet = null, this.para = null, this.traversal = null, this.validate = null, this.variables = null, this.area = new t.XFAObjectArray(), this.breakAfter = new t.XFAObjectArray(), this.breakBefore = new t.XFAObjectArray(), this.connect = new t.XFAObjectArray(), this.draw = new t.XFAObjectArray(), this.event = new t.XFAObjectArray(), this.exObject = new t.XFAObjectArray(), this.exclGroup = new t.XFAObjectArray(), this.field = new t.XFAObjectArray(), this.proto = new t.XFAObjectArray(), this.setProperty = new t.XFAObjectArray(), this.subform = new t.XFAObjectArray(), this.subformSet = new t.XFAObjectArray();
            }
            [t.$getSubformParent]() {
              const R = this[t.$getParent]();
              return R instanceof dn ? R[t.$getSubformParent]() : R;
            }
            [t.$isBindable]() {
              return !0;
            }
            [t.$isThereMoreWidth]() {
              return this.layout.endsWith("-tb") && this[t.$extra].attempt === 0 && this[t.$extra].numberInLine > 0 || this[t.$getParent]()[t.$isThereMoreWidth]();
            }
            *[t.$getContainedChildren]() {
              yield* j(this);
            }
            [t.$flushHTML]() {
              return (0, v.flushHTML)(this);
            }
            [t.$addHTML](R, he) {
              (0, v.addHTML)(this, R, he);
            }
            [t.$getAvailableSpace]() {
              return (0, v.getAvailableSpace)(this);
            }
            [t.$isSplittable]() {
              const R = this[t.$getSubformParent]();
              return R[t.$isSplittable]() ? this[t.$extra]._isSplittable !== void 0 ? this[t.$extra]._isSplittable : this.layout === "position" || this.layout.includes("row") ? (this[t.$extra]._isSplittable = !1, !1) : this.keep && this.keep.intact !== "none" ? (this[t.$extra]._isSplittable = !1, !1) : R.layout && R.layout.endsWith("-tb") && R[t.$extra].numberInLine !== 0 ? !1 : (this[t.$extra]._isSplittable = !0, !0) : !1;
            }
            [t.$toHTML](R) {
              if (B(this), this.break) {
                if (this.break.after !== "auto" || this.break.afterTarget !== "") {
                  const vt = new ne({
                    targetType: this.break.after,
                    target: this.break.afterTarget,
                    startNew: this.break.startNew.toString()
                  });
                  vt[t.$globalData] = this[t.$globalData], this[t.$appendChild](vt), this.breakAfter.push(vt);
                }
                if (this.break.before !== "auto" || this.break.beforeTarget !== "") {
                  const vt = new se({
                    targetType: this.break.before,
                    target: this.break.beforeTarget,
                    startNew: this.break.startNew.toString()
                  });
                  vt[t.$globalData] = this[t.$globalData], this[t.$appendChild](vt), this.breakBefore.push(vt);
                }
                if (this.break.overflowTarget !== "") {
                  const vt = new rt({
                    target: this.break.overflowTarget,
                    leader: this.break.overflowLeader,
                    trailer: this.break.overflowTrailer
                  });
                  vt[t.$globalData] = this[t.$globalData], this[t.$appendChild](vt), this.overflow.push(vt);
                }
                this[t.$removeChild](this.break), this.break = null;
              }
              if (this.presence === "hidden" || this.presence === "inactive")
                return e.HTMLResult.EMPTY;
              if ((this.breakBefore.children.length > 1 || this.breakAfter.children.length > 1) && (0, y.warn)("XFA - Several breakBefore or breakAfter in subforms: please file a bug."), this.breakBefore.children.length >= 1) {
                const vt = this.breakBefore.children[0];
                if (_(vt))
                  return e.HTMLResult.breakNode(vt);
              }
              if (this[t.$extra] && this[t.$extra].afterBreakAfter)
                return e.HTMLResult.EMPTY;
              (0, h.fixDimensions)(this);
              const he = [], $e = {
                id: this[t.$uid],
                class: []
              };
              (0, h.setAccess)(this, $e.class), this[t.$extra] || (this[t.$extra] = /* @__PURE__ */ Object.create(null)), Object.assign(this[t.$extra], {
                children: he,
                line: null,
                attributes: $e,
                attempt: 0,
                numberInLine: 0,
                availableSpace: {
                  width: Math.min(this.w || 1 / 0, R.width),
                  height: Math.min(this.h || 1 / 0, R.height)
                },
                width: 0,
                height: 0,
                prevHeight: 0,
                currentWidth: 0
              });
              const Ze = this[t.$getTemplateRoot](), ht = Ze[t.$extra].noLayoutFailure, It = this[t.$isSplittable]();
              if (It || f(this), !(0, v.checkDimensions)(this, R))
                return e.HTMLResult.FAILURE;
              const Et = /* @__PURE__ */ new Set(["area", "draw", "exclGroup", "field", "subform", "subformSet"]);
              if (this.layout.includes("row")) {
                const vt = this[t.$getSubformParent]().columnWidths;
                Array.isArray(vt) && vt.length > 0 && (this[t.$extra].columnWidths = vt, this[t.$extra].currentColumn = 0);
              }
              const Rt = (0, h.toStyle)(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), $t = ["xfaSubform"], Ht = (0, h.layoutClass)(this);
              if (Ht && $t.push(Ht), $e.style = Rt, $e.class = $t, this.name && ($e.xfaName = this.name), this.overflow) {
                const vt = this.overflow[t.$getExtra]();
                vt.addLeader && (vt.addLeader = !1, S(this, vt.leader, R));
              }
              this[t.$pushPara]();
              const Jt = this.layout === "lr-tb" || this.layout === "rl-tb", Kt = Jt ? n : 1;
              for (; this[t.$extra].attempt < Kt; this[t.$extra].attempt++) {
                Jt && this[t.$extra].attempt === n - 1 && (this[t.$extra].numberInLine = 0);
                const vt = this[t.$childrenToHTML]({
                  filter: Et,
                  include: !0
                });
                if (vt.success)
                  break;
                if (vt.isBreak())
                  return this[t.$popPara](), vt;
                if (Jt && this[t.$extra].attempt === 0 && this[t.$extra].numberInLine === 0 && !Ze[t.$extra].noLayoutFailure) {
                  this[t.$extra].attempt = Kt;
                  break;
                }
              }
              if (this[t.$popPara](), It || D(this), Ze[t.$extra].noLayoutFailure = ht, this[t.$extra].attempt === Kt)
                return this.overflow && (this[t.$getTemplateRoot]()[t.$extra].overflowNode = this.overflow), It || delete this[t.$extra], e.HTMLResult.FAILURE;
              if (this.overflow) {
                const vt = this.overflow[t.$getExtra]();
                vt.addTrailer && (vt.addTrailer = !1, S(this, vt.trailer, R));
              }
              let tn = 0, we = 0;
              this.margin && (tn = this.margin.leftInset + this.margin.rightInset, we = this.margin.topInset + this.margin.bottomInset);
              const Re = Math.max(this[t.$extra].width + tn, this.w || 0), et = Math.max(this[t.$extra].height + we, this.h || 0), Ke = [this.x, this.y, Re, et];
              if (this.w === "" && (Rt.width = (0, h.measureToString)(Re)), this.h === "" && (Rt.height = (0, h.measureToString)(et)), (Rt.width === "0px" || Rt.height === "0px") && he.length === 0)
                return e.HTMLResult.EMPTY;
              const ut = {
                name: "div",
                attributes: $e,
                children: he
              };
              U(this, $e);
              const Lt = e.HTMLResult.success((0, h.createWrapper)(this, ut), Ke);
              if (this.breakAfter.children.length >= 1) {
                const vt = this.breakAfter.children[0];
                if (_(vt))
                  return this[t.$extra].afterBreakAfter = Lt, e.HTMLResult.breakNode(vt);
              }
              return delete this[t.$extra], Lt;
            }
          }
          class dn extends t.XFAObject {
            constructor(R) {
              super(p, "subformSet", !0), this.id = R.id || "", this.name = R.name || "", this.relation = (0, e.getStringOption)(R.relation, ["ordered", "choice", "unordered"]), this.relevant = (0, e.getRelevant)(R.relevant), this.use = R.use || "", this.usehref = R.usehref || "", this.bookend = null, this.break = null, this.desc = null, this.extras = null, this.occur = null, this.overflow = null, this.breakAfter = new t.XFAObjectArray(), this.breakBefore = new t.XFAObjectArray(), this.subform = new t.XFAObjectArray(), this.subformSet = new t.XFAObjectArray();
            }
            *[t.$getContainedChildren]() {
              yield* j(this);
            }
            [t.$getSubformParent]() {
              let R = this[t.$getParent]();
              for (; !(R instanceof xn); )
                R = R[t.$getParent]();
              return R;
            }
            [t.$isBindable]() {
              return !0;
            }
          }
          class pn extends t.ContentObject {
            constructor(R) {
              super(p, "subjectDN"), this.delimiter = R.delimiter || ",", this.id = R.id || "", this.name = R.name || "", this.use = R.use || "", this.usehref = R.usehref || "";
            }
            [t.$finalize]() {
              this[t.$content] = new Map(this[t.$content].split(this.delimiter).map((R) => (R = R.split("=", 2), R[0] = R[0].trim(), R)));
            }
          }
          class sn extends t.XFAObject {
            constructor(R) {
              super(p, "subjectDNs", !0), this.id = R.id || "", this.type = (0, e.getStringOption)(R.type, ["optional", "required"]), this.use = R.use || "", this.usehref = R.usehref || "", this.subjectDN = new t.XFAObjectArray();
            }
          }
          class fn extends t.XFAObject {
            constructor(R) {
              super(p, "submit", !0), this.embedPDF = (0, e.getInteger)({
                data: R.embedPDF,
                defaultValue: 0,
                validate: (he) => he === 1
              }), this.format = (0, e.getStringOption)(R.format, ["xdp", "formdata", "pdf", "urlencoded", "xfd", "xml"]), this.id = R.id || "", this.target = R.target || "", this.textEncoding = (0, e.getKeyword)({
                data: R.textEncoding ? R.textEncoding.toLowerCase() : "",
                defaultValue: "",
                validate: (he) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(he) || he.match(/iso-8859-\d{2}/)
              }), this.use = R.use || "", this.usehref = R.usehref || "", this.xdpContent = R.xdpContent || "", this.encrypt = null, this.encryptData = new t.XFAObjectArray(), this.signData = new t.XFAObjectArray();
            }
          }
          class Fn extends t.XFAObject {
            constructor(R) {
              super(p, "template", !0), this.baseProfile = (0, e.getStringOption)(R.baseProfile, ["full", "interactiveForms"]), this.extras = null, this.subform = new t.XFAObjectArray();
            }
            [t.$finalize]() {
              this.subform.children.length === 0 && (0, y.warn)("XFA - No subforms in template node."), this.subform.children.length >= 2 && (0, y.warn)("XFA - Several subforms in template node: please file a bug."), this[t.$tabIndex] = l;
            }
            [t.$isSplittable]() {
              return !0;
            }
            [t.$searchNode](R, he) {
              return R.startsWith("#") ? [this[t.$ids].get(R.slice(1))] : (0, m.searchNode)(this, he, R, !0, !0);
            }
            *[t.$toPages]() {
              if (!this.subform.children.length)
                return e.HTMLResult.success({
                  name: "div",
                  children: []
                });
              this[t.$extra] = {
                overflowNode: null,
                firstUnsplittable: null,
                currentContentArea: null,
                currentPageArea: null,
                noLayoutFailure: !1,
                pageNumber: 1,
                pagePosition: "first",
                oddOrEven: "odd",
                blankOrNotBlank: "nonBlank",
                paraStack: []
              };
              const R = this.subform.children[0];
              R.pageSet[t.$cleanPage]();
              const he = R.pageSet.pageArea.children, $e = {
                name: "div",
                children: []
              };
              let Ze = null, ht = null, It = null;
              if (R.breakBefore.children.length >= 1 ? (ht = R.breakBefore.children[0], It = ht.target) : R.subform.children.length >= 1 && R.subform.children[0].breakBefore.children.length >= 1 ? (ht = R.subform.children[0].breakBefore.children[0], It = ht.target) : R.break && R.break.beforeTarget ? (ht = R.break, It = ht.beforeTarget) : R.subform.children.length >= 1 && R.subform.children[0].break && R.subform.children[0].break.beforeTarget && (ht = R.subform.children[0].break, It = ht.beforeTarget), ht) {
                const we = this[t.$searchNode](It, ht[t.$getParent]());
                we instanceof tt && (Ze = we, ht[t.$extra] = {});
              }
              Ze || (Ze = he[0]), Ze[t.$extra] = {
                numberOfUse: 1
              };
              const Et = Ze[t.$getParent]();
              Et[t.$extra] = {
                numberOfUse: 1,
                pageIndex: Et.pageArea.children.indexOf(Ze),
                pageSetIndex: 0
              };
              let Rt, $t = null, Ht = null, Jt = !0, Kt = 0, tn = 0;
              for (; ; ) {
                if (Jt)
                  Kt = 0;
                else if ($e.children.pop(), ++Kt === i)
                  return (0, y.warn)("XFA - Something goes wrong: please file a bug."), $e;
                Rt = null, this[t.$extra].currentPageArea = Ze;
                const we = Ze[t.$toHTML]().html;
                $e.children.push(we), $t && (this[t.$extra].noLayoutFailure = !0, we.children.push($t[t.$toHTML](Ze[t.$extra].space).html), $t = null), Ht && (this[t.$extra].noLayoutFailure = !0, we.children.push(Ht[t.$toHTML](Ze[t.$extra].space).html), Ht = null);
                const Re = Ze.contentArea.children, et = we.children.filter((ut) => ut.attributes.class.includes("xfaContentarea"));
                Jt = !1, this[t.$extra].firstUnsplittable = null, this[t.$extra].noLayoutFailure = !1;
                const Ke = (ut) => {
                  const Lt = R[t.$flushHTML]();
                  Lt && (Jt = Jt || Lt.children && Lt.children.length !== 0, et[ut].children.push(Lt));
                };
                for (let ut = tn, Lt = Re.length; ut < Lt; ut++) {
                  const vt = this[t.$extra].currentContentArea = Re[ut], Xt = {
                    width: vt.w,
                    height: vt.h
                  };
                  tn = 0, $t && (et[ut].children.push($t[t.$toHTML](Xt).html), $t = null), Ht && (et[ut].children.push(Ht[t.$toHTML](Xt).html), Ht = null);
                  const zt = R[t.$toHTML](Xt);
                  if (zt.success)
                    return zt.html ? (Jt = Jt || zt.html.children && zt.html.children.length !== 0, et[ut].children.push(zt.html)) : !Jt && $e.children.length > 1 && $e.children.pop(), $e;
                  if (zt.isBreak()) {
                    const Gt = zt.breakNode;
                    if (Ke(ut), Gt.targetType === "auto")
                      continue;
                    Gt.leader && ($t = this[t.$searchNode](Gt.leader, Gt[t.$getParent]()), $t = $t ? $t[0] : null), Gt.trailer && (Ht = this[t.$searchNode](Gt.trailer, Gt[t.$getParent]()), Ht = Ht ? Ht[0] : null), Gt.targetType === "pageArea" ? (Rt = Gt[t.$extra].target, ut = 1 / 0) : Gt[t.$extra].target ? (Rt = Gt[t.$extra].target, tn = Gt[t.$extra].index + 1, ut = 1 / 0) : ut = Gt[t.$extra].index;
                    continue;
                  }
                  if (this[t.$extra].overflowNode) {
                    const Gt = this[t.$extra].overflowNode;
                    this[t.$extra].overflowNode = null;
                    const Qt = Gt[t.$getExtra](), en = Qt.target;
                    Qt.addLeader = Qt.leader !== null, Qt.addTrailer = Qt.trailer !== null, Ke(ut);
                    const rn = ut;
                    if (ut = 1 / 0, en instanceof tt)
                      Rt = en;
                    else if (en instanceof ie) {
                      const nn = Re.indexOf(en);
                      nn !== -1 ? nn > rn ? ut = nn - 1 : tn = nn : (Rt = en[t.$getParent](), tn = Rt.contentArea.children.indexOf(en));
                    }
                    continue;
                  }
                  Ke(ut);
                }
                this[t.$extra].pageNumber += 1, Rt && (Rt[t.$isUsable]() ? Rt[t.$extra].numberOfUse += 1 : Rt = null), Ze = Rt || Ze[t.$getNextPage](), yield null;
              }
            }
          }
          o.Template = Fn;
          class Pn extends t.ContentObject {
            constructor(R) {
              super(p, "text"), this.id = R.id || "", this.maxChars = (0, e.getInteger)({
                data: R.maxChars,
                defaultValue: 0,
                validate: (he) => he >= 0
              }), this.name = R.name || "", this.rid = R.rid || "", this.use = R.use || "", this.usehref = R.usehref || "";
            }
            [t.$acceptWhitespace]() {
              return !0;
            }
            [t.$onChild](R) {
              return R[t.$namespaceId] === a.NamespaceIds.xhtml.id ? (this[t.$content] = R, !0) : ((0, y.warn)(`XFA - Invalid content in Text: ${R[t.$nodeName]}.`), !1);
            }
            [t.$onText](R) {
              this[t.$content] instanceof t.XFAObject || super[t.$onText](R);
            }
            [t.$finalize]() {
              typeof this[t.$content] == "string" && (this[t.$content] = this[t.$content].replace(/\r\n/g, `
`));
            }
            [t.$getExtra]() {
              return typeof this[t.$content] == "string" ? this[t.$content].split(/[\u2029\u2028\n]/).reduce((R, he) => (he && R.push(he), R), []).join(`
`) : this[t.$content][t.$text]();
            }
            [t.$toHTML](R) {
              if (typeof this[t.$content] == "string") {
                const he = x(this[t.$content]).html;
                return this[t.$content].includes("\u2029") ? (he.name = "div", he.children = [], this[t.$content].split("\u2029").map(($e) => $e.split(/[\u2028\n]/).reduce((Ze, ht) => (Ze.push({
                  name: "span",
                  value: ht
                }, {
                  name: "br"
                }), Ze), [])).forEach(($e) => {
                  he.children.push({
                    name: "p",
                    children: $e
                  });
                })) : /[\u2028\n]/.test(this[t.$content]) && (he.name = "div", he.children = [], this[t.$content].split(/[\u2028\n]/).forEach(($e) => {
                  he.children.push({
                    name: "span",
                    value: $e
                  }, {
                    name: "br"
                  });
                })), e.HTMLResult.success(he);
              }
              return this[t.$content][t.$toHTML](R);
            }
          }
          o.Text = Pn;
          class An extends t.XFAObject {
            constructor(R) {
              super(p, "textEdit", !0), this.allowRichText = (0, e.getInteger)({
                data: R.allowRichText,
                defaultValue: 0,
                validate: (he) => he === 1
              }), this.hScrollPolicy = (0, e.getStringOption)(R.hScrollPolicy, ["auto", "off", "on"]), this.id = R.id || "", this.multiLine = (0, e.getInteger)({
                data: R.multiLine,
                defaultValue: "",
                validate: (he) => he === 0 || he === 1
              }), this.use = R.use || "", this.usehref = R.usehref || "", this.vScrollPolicy = (0, e.getStringOption)(R.vScrollPolicy, ["auto", "off", "on"]), this.border = null, this.comb = null, this.extras = null, this.margin = null;
            }
            [t.$toHTML](R) {
              const he = (0, h.toStyle)(this, "border", "font", "margin");
              let $e;
              const Ze = this[t.$getParent]()[t.$getParent]();
              return this.multiLine === "" && (this.multiLine = Ze instanceof ye ? 1 : 0), this.multiLine === 1 ? $e = {
                name: "textarea",
                attributes: {
                  dataId: Ze[t.$data] && Ze[t.$data][t.$uid] || Ze[t.$uid],
                  fieldId: Ze[t.$uid],
                  class: ["xfaTextfield"],
                  style: he,
                  "aria-label": k(Ze),
                  "aria-required": !1
                }
              } : $e = {
                name: "input",
                attributes: {
                  type: "text",
                  dataId: Ze[t.$data] && Ze[t.$data][t.$uid] || Ze[t.$uid],
                  fieldId: Ze[t.$uid],
                  class: ["xfaTextfield"],
                  style: he,
                  "aria-label": k(Ze),
                  "aria-required": !1
                }
              }, X(Ze) && ($e.attributes["aria-required"] = !0, $e.attributes.required = !0), e.HTMLResult.success({
                name: "label",
                attributes: {
                  class: ["xfaLabel"]
                },
                children: [$e]
              });
            }
          }
          class jn extends t.StringObject {
            constructor(R) {
              super(p, "time"), this.id = R.id || "", this.name = R.name || "", this.use = R.use || "", this.usehref = R.usehref || "";
            }
            [t.$finalize]() {
              const R = this[t.$content].trim();
              this[t.$content] = R ? new Date(R) : null;
            }
            [t.$toHTML](R) {
              return x(this[t.$content] ? this[t.$content].toString() : "");
            }
          }
          class Rn extends t.XFAObject {
            constructor(R) {
              super(p, "timeStamp"), this.id = R.id || "", this.server = R.server || "", this.type = (0, e.getStringOption)(R.type, ["optional", "required"]), this.use = R.use || "", this.usehref = R.usehref || "";
            }
          }
          class Un extends t.StringObject {
            constructor(R) {
              super(p, "toolTip"), this.id = R.id || "", this.rid = R.rid || "", this.use = R.use || "", this.usehref = R.usehref || "";
            }
          }
          class Mn extends t.XFAObject {
            constructor(R) {
              super(p, "traversal", !0), this.id = R.id || "", this.use = R.use || "", this.usehref = R.usehref || "", this.extras = null, this.traverse = new t.XFAObjectArray();
            }
          }
          class Dn extends t.XFAObject {
            constructor(R) {
              super(p, "traverse", !0), this.id = R.id || "", this.operation = (0, e.getStringOption)(R.operation, ["next", "back", "down", "first", "left", "right", "up"]), this.ref = R.ref || "", this.use = R.use || "", this.usehref = R.usehref || "", this.extras = null, this.script = null;
            }
            get name() {
              return this.operation;
            }
            [t.$isTransparent]() {
              return !1;
            }
          }
          class Sn extends t.XFAObject {
            constructor(R) {
              super(p, "ui", !0), this.id = R.id || "", this.use = R.use || "", this.usehref = R.usehref || "", this.extras = null, this.picture = null, this.barcode = null, this.button = null, this.checkButton = null, this.choiceList = null, this.dateTimeEdit = null, this.defaultUi = null, this.imageEdit = null, this.numericEdit = null, this.passwordEdit = null, this.signature = null, this.textEdit = null;
            }
            [t.$getExtra]() {
              if (this[t.$extra] === void 0) {
                for (const R of Object.getOwnPropertyNames(this)) {
                  if (R === "extras" || R === "picture")
                    continue;
                  const he = this[R];
                  if (he instanceof t.XFAObject)
                    return this[t.$extra] = he, he;
                }
                this[t.$extra] = null;
              }
              return this[t.$extra];
            }
            [t.$toHTML](R) {
              const he = this[t.$getExtra]();
              return he ? he[t.$toHTML](R) : e.HTMLResult.EMPTY;
            }
          }
          class Bn extends t.XFAObject {
            constructor(R) {
              super(p, "validate", !0), this.formatTest = (0, e.getStringOption)(R.formatTest, ["warning", "disabled", "error"]), this.id = R.id || "", this.nullTest = (0, e.getStringOption)(R.nullTest, ["disabled", "error", "warning"]), this.scriptTest = (0, e.getStringOption)(R.scriptTest, ["error", "disabled", "warning"]), this.use = R.use || "", this.usehref = R.usehref || "", this.extras = null, this.message = null, this.picture = null, this.script = null;
            }
          }
          class bn extends t.XFAObject {
            constructor(R) {
              super(p, "value", !0), this.id = R.id || "", this.override = (0, e.getInteger)({
                data: R.override,
                defaultValue: 0,
                validate: (he) => he === 1
              }), this.relevant = (0, e.getRelevant)(R.relevant), this.use = R.use || "", this.usehref = R.usehref || "", this.arc = null, this.boolean = null, this.date = null, this.dateTime = null, this.decimal = null, this.exData = null, this.float = null, this.image = null, this.integer = null, this.line = null, this.rectangle = null, this.text = null, this.time = null;
            }
            [t.$setValue](R) {
              const he = this[t.$getParent]();
              if (he instanceof Je && he.ui && he.ui.imageEdit) {
                this.image || (this.image = new ot({}), this[t.$appendChild](this.image)), this.image[t.$content] = R[t.$content];
                return;
              }
              const $e = R[t.$nodeName];
              if (this[$e] !== null) {
                this[$e][t.$content] = R[t.$content];
                return;
              }
              for (const Ze of Object.getOwnPropertyNames(this)) {
                const ht = this[Ze];
                ht instanceof t.XFAObject && (this[Ze] = null, this[t.$removeChild](ht));
              }
              this[R[t.$nodeName]] = R, this[t.$appendChild](R);
            }
            [t.$text]() {
              if (this.exData)
                return typeof this.exData[t.$content] == "string" ? this.exData[t.$content].trim() : this.exData[t.$content][t.$text]().trim();
              for (const R of Object.getOwnPropertyNames(this)) {
                if (R === "image")
                  continue;
                const he = this[R];
                if (he instanceof t.XFAObject)
                  return (he[t.$content] || "").toString().trim();
              }
              return null;
            }
            [t.$toHTML](R) {
              for (const he of Object.getOwnPropertyNames(this)) {
                const $e = this[he];
                if ($e instanceof t.XFAObject)
                  return $e[t.$toHTML](R);
              }
              return e.HTMLResult.EMPTY;
            }
          }
          o.Value = bn;
          class $n extends t.XFAObject {
            constructor(R) {
              super(p, "variables", !0), this.id = R.id || "", this.use = R.use || "", this.usehref = R.usehref || "", this.boolean = new t.XFAObjectArray(), this.date = new t.XFAObjectArray(), this.dateTime = new t.XFAObjectArray(), this.decimal = new t.XFAObjectArray(), this.exData = new t.XFAObjectArray(), this.float = new t.XFAObjectArray(), this.image = new t.XFAObjectArray(), this.integer = new t.XFAObjectArray(), this.manifest = new t.XFAObjectArray(), this.script = new t.XFAObjectArray(), this.text = new t.XFAObjectArray(), this.time = new t.XFAObjectArray();
            }
            [t.$isTransparent]() {
              return !0;
            }
          }
          class yn {
            static [a.$buildXFAObject](R, he) {
              if (yn.hasOwnProperty(R)) {
                const $e = yn[R](he);
                return $e[t.$setSetAttributes](he), $e;
              }
            }
            static appearanceFilter(R) {
              return new C(R);
            }
            static arc(R) {
              return new T(R);
            }
            static area(R) {
              return new P(R);
            }
            static assist(R) {
              return new M(R);
            }
            static barcode(R) {
              return new G(R);
            }
            static bind(R) {
              return new Z(R);
            }
            static bindItems(R) {
              return new $(R);
            }
            static bookend(R) {
              return new z(R);
            }
            static boolean(R) {
              return new V(R);
            }
            static border(R) {
              return new L(R);
            }
            static break(R) {
              return new K(R);
            }
            static breakAfter(R) {
              return new ne(R);
            }
            static breakBefore(R) {
              return new se(R);
            }
            static button(R) {
              return new q(R);
            }
            static calculate(R) {
              return new N(R);
            }
            static caption(R) {
              return new Q(R);
            }
            static certificate(R) {
              return new E(R);
            }
            static certificates(R) {
              return new te(R);
            }
            static checkButton(R) {
              return new oe(R);
            }
            static choiceList(R) {
              return new ee(R);
            }
            static color(R) {
              return new W(R);
            }
            static comb(R) {
              return new I(R);
            }
            static connect(R) {
              return new H(R);
            }
            static contentArea(R) {
              return new ie(R);
            }
            static corner(R) {
              return new ue(R);
            }
            static date(R) {
              return new fe(R);
            }
            static dateTime(R) {
              return new de(R);
            }
            static dateTimeEdit(R) {
              return new pe(R);
            }
            static decimal(R) {
              return new xe(R);
            }
            static defaultUi(R) {
              return new Fe(R);
            }
            static desc(R) {
              return new Se(R);
            }
            static digestMethod(R) {
              return new Ce(R);
            }
            static digestMethods(R) {
              return new ke(R);
            }
            static draw(R) {
              return new ye(R);
            }
            static edge(R) {
              return new De(R);
            }
            static encoding(R) {
              return new Ae(R);
            }
            static encodings(R) {
              return new Te(R);
            }
            static encrypt(R) {
              return new ve(R);
            }
            static encryptData(R) {
              return new Ne(R);
            }
            static encryption(R) {
              return new Ge(R);
            }
            static encryptionMethod(R) {
              return new it(R);
            }
            static encryptionMethods(R) {
              return new Me(R);
            }
            static event(R) {
              return new Ie(R);
            }
            static exData(R) {
              return new Ee(R);
            }
            static exObject(R) {
              return new st(R);
            }
            static exclGroup(R) {
              return new Qe(R);
            }
            static execute(R) {
              return new ct(R);
            }
            static extras(R) {
              return new xt(R);
            }
            static field(R) {
              return new Je(R);
            }
            static fill(R) {
              return new mt(R);
            }
            static filter(R) {
              return new _t(R);
            }
            static float(R) {
              return new Xe(R);
            }
            static font(R) {
              return new Ct(R);
            }
            static format(R) {
              return new bt(R);
            }
            static handler(R) {
              return new Pe(R);
            }
            static hyphenation(R) {
              return new qe(R);
            }
            static image(R) {
              return new ot(R);
            }
            static imageEdit(R) {
              return new lt(R);
            }
            static integer(R) {
              return new Ut(R);
            }
            static issuers(R) {
              return new Nt(R);
            }
            static items(R) {
              return new Ve(R);
            }
            static keep(R) {
              return new je(R);
            }
            static keyUsage(R) {
              return new at(R);
            }
            static line(R) {
              return new nt(R);
            }
            static linear(R) {
              return new ft(R);
            }
            static lockDocument(R) {
              return new Tt(R);
            }
            static manifest(R) {
              return new yt(R);
            }
            static margin(R) {
              return new dt(R);
            }
            static mdp(R) {
              return new wt(R);
            }
            static medium(R) {
              return new Dt(R);
            }
            static message(R) {
              return new jt(R);
            }
            static numericEdit(R) {
              return new Bt(R);
            }
            static occur(R) {
              return new kt(R);
            }
            static oid(R) {
              return new Ue(R);
            }
            static oids(R) {
              return new We(R);
            }
            static overflow(R) {
              return new rt(R);
            }
            static pageArea(R) {
              return new tt(R);
            }
            static pageSet(R) {
              return new St(R);
            }
            static para(R) {
              return new Pt(R);
            }
            static passwordEdit(R) {
              return new qt(R);
            }
            static pattern(R) {
              return new Mt(R);
            }
            static picture(R) {
              return new Wt(R);
            }
            static proto(R) {
              return new Zt(R);
            }
            static radial(R) {
              return new an(R);
            }
            static reason(R) {
              return new un(R);
            }
            static reasons(R) {
              return new Tn(R);
            }
            static rectangle(R) {
              return new gn(R);
            }
            static ref(R) {
              return new _n(R);
            }
            static script(R) {
              return new vn(R);
            }
            static setProperty(R) {
              return new En(R);
            }
            static signData(R) {
              return new kn(R);
            }
            static signature(R) {
              return new Ln(R);
            }
            static signing(R) {
              return new Nn(R);
            }
            static solid(R) {
              return new wn(R);
            }
            static speak(R) {
              return new On(R);
            }
            static stipple(R) {
              return new In(R);
            }
            static subform(R) {
              return new xn(R);
            }
            static subformSet(R) {
              return new dn(R);
            }
            static subjectDN(R) {
              return new pn(R);
            }
            static subjectDNs(R) {
              return new sn(R);
            }
            static submit(R) {
              return new fn(R);
            }
            static template(R) {
              return new Fn(R);
            }
            static text(R) {
              return new Pn(R);
            }
            static textEdit(R) {
              return new An(R);
            }
            static time(R) {
              return new jn(R);
            }
            static timeStamp(R) {
              return new Rn(R);
            }
            static toolTip(R) {
              return new Un(R);
            }
            static traversal(R) {
              return new Mn(R);
            }
            static traverse(R) {
              return new Dn(R);
            }
            static ui(R) {
              return new Sn(R);
            }
            static validate(R) {
              return new Bn(R);
            }
            static value(R) {
              return new bn(R);
            }
            static variables(R) {
              return new $n(R);
            }
          }
          o.TemplateNamespace = yn;
        },
        /* 83 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.addHTML = e, o.checkDimensions = d, o.flushHTML = h, o.getAvailableSpace = y;
          var t = F(77), a = F(84);
          function v(m, p) {
            return {
              name: "div",
              attributes: {
                class: [m.layout === "lr-tb" ? "xfaLr" : "xfaRl"]
              },
              children: p
            };
          }
          function h(m) {
            if (!m[t.$extra])
              return null;
            const g = {
              name: "div",
              attributes: m[t.$extra].attributes,
              children: m[t.$extra].children
            };
            if (m[t.$extra].failingNode) {
              const n = m[t.$extra].failingNode[t.$flushHTML]();
              n && (m.layout.endsWith("-tb") ? g.children.push(v(m, [n])) : g.children.push(n));
            }
            return g.children.length === 0 ? null : g;
          }
          function e(m, p, g) {
            const n = m[t.$extra], i = n.availableSpace, [l, u, w, O] = g;
            switch (m.layout) {
              case "position": {
                n.width = Math.max(n.width, l + w), n.height = Math.max(n.height, u + O), n.children.push(p);
                break;
              }
              case "lr-tb":
              case "rl-tb":
                (!n.line || n.attempt === 1) && (n.line = v(m, []), n.children.push(n.line), n.numberInLine = 0), n.numberInLine += 1, n.line.children.push(p), n.attempt === 0 ? (n.currentWidth += w, n.height = Math.max(n.height, n.prevHeight + O)) : (n.currentWidth = w, n.prevHeight = n.height, n.height += O, n.attempt = 0), n.width = Math.max(n.width, n.currentWidth);
                break;
              case "rl-row":
              case "row": {
                n.children.push(p), n.width += w, n.height = Math.max(n.height, O);
                const b = (0, a.measureToString)(n.height);
                for (const A of n.children)
                  A.attributes.style.height = b;
                break;
              }
              case "table": {
                n.width = Math.min(i.width, Math.max(n.width, w)), n.height += O, n.children.push(p);
                break;
              }
              case "tb": {
                n.width = Math.min(i.width, Math.max(n.width, w)), n.height += O, n.children.push(p);
                break;
              }
            }
          }
          function y(m) {
            const p = m[t.$extra].availableSpace, g = m.margin ? m.margin.topInset + m.margin.bottomInset : 0, n = m.margin ? m.margin.leftInset + m.margin.rightInset : 0;
            switch (m.layout) {
              case "lr-tb":
              case "rl-tb":
                return m[t.$extra].attempt === 0 ? {
                  width: p.width - n - m[t.$extra].currentWidth,
                  height: p.height - g - m[t.$extra].prevHeight
                } : {
                  width: p.width - n,
                  height: p.height - g - m[t.$extra].height
                };
              case "rl-row":
              case "row":
                return {
                  width: m[t.$extra].columnWidths.slice(m[t.$extra].currentColumn).reduce((l, u) => l + u),
                  height: p.height - n
                };
              case "table":
              case "tb":
                return {
                  width: p.width - n,
                  height: p.height - g - m[t.$extra].height
                };
              case "position":
              default:
                return p;
            }
          }
          function c(m) {
            let p = m.w === "" ? NaN : m.w, g = m.h === "" ? NaN : m.h, [n, i] = [0, 0];
            switch (m.anchorType || "") {
              case "bottomCenter":
                [n, i] = [p / 2, g];
                break;
              case "bottomLeft":
                [n, i] = [0, g];
                break;
              case "bottomRight":
                [n, i] = [p, g];
                break;
              case "middleCenter":
                [n, i] = [p / 2, g / 2];
                break;
              case "middleLeft":
                [n, i] = [0, g / 2];
                break;
              case "middleRight":
                [n, i] = [p, g / 2];
                break;
              case "topCenter":
                [n, i] = [p / 2, 0];
                break;
              case "topRight":
                [n, i] = [p, 0];
                break;
            }
            let l, u;
            switch (m.rotate || 0) {
              case 0:
                [l, u] = [-n, -i];
                break;
              case 90:
                [l, u] = [-i, n], [p, g] = [g, -p];
                break;
              case 180:
                [l, u] = [n, i], [p, g] = [-p, -g];
                break;
              case 270:
                [l, u] = [i, -n], [p, g] = [-g, p];
                break;
            }
            return [m.x + l + Math.min(0, p), m.y + u + Math.min(0, g), Math.abs(p), Math.abs(g)];
          }
          function d(m, p) {
            if (m[t.$getTemplateRoot]()[t.$extra].firstUnsplittable === null || m.w === 0 || m.h === 0)
              return !0;
            const g = 2, n = m[t.$getSubformParent](), i = n[t.$extra] && n[t.$extra].attempt || 0, [, l, u, w] = c(m);
            switch (n.layout) {
              case "lr-tb":
              case "rl-tb":
                return i === 0 ? m[t.$getTemplateRoot]()[t.$extra].noLayoutFailure ? m.w !== "" ? Math.round(u - p.width) <= g : p.width > g : m.h !== "" && Math.round(w - p.height) > g ? !1 : m.w !== "" ? Math.round(u - p.width) <= g ? !0 : n[t.$extra].numberInLine === 0 ? p.height > g : !1 : p.width > g : m[t.$getTemplateRoot]()[t.$extra].noLayoutFailure ? !0 : m.h !== "" && Math.round(w - p.height) > g ? !1 : m.w === "" || Math.round(u - p.width) <= g ? p.height > g : n[t.$isThereMoreWidth]() ? !1 : p.height > g;
              case "table":
              case "tb":
                return m[t.$getTemplateRoot]()[t.$extra].noLayoutFailure ? !0 : m.h !== "" && !m[t.$isSplittable]() ? Math.round(w - p.height) <= g : m.w === "" || Math.round(u - p.width) <= g ? p.height > g : n[t.$isThereMoreWidth]() ? !1 : p.height > g;
              case "position":
                if (m[t.$getTemplateRoot]()[t.$extra].noLayoutFailure || m.h === "" || Math.round(w + l - p.height) <= g)
                  return !0;
                const O = m[t.$getTemplateRoot]()[t.$extra].currentContentArea;
                return w + l > O.h;
              case "rl-row":
              case "row":
                return m[t.$getTemplateRoot]()[t.$extra].noLayoutFailure ? !0 : m.h !== "" ? Math.round(w - p.height) <= g : !0;
              default:
                return !0;
            }
          }
        },
        /* 84 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.computeBbox = g, o.createWrapper = u, o.fixDimensions = n, o.fixTextIndent = w, o.fixURL = X, o.isPrintOnly = b, o.layoutClass = i, o.layoutNode = p, o.measureToString = y, o.setAccess = O, o.setFontFamily = j, o.setMinMaxDimensions = d, o.setPara = Y, o.toStyle = l;
          var t = F(77), a = F(2), v = F(78), h = F(85), e = F(86);
          function y(B) {
            return typeof B == "string" ? "0px" : Number.isInteger(B) ? `${B}px` : `${B.toFixed(2)}px`;
          }
          const c = {
            anchorType(B, U) {
              const k = B[t.$getSubformParent]();
              if (!(!k || k.layout && k.layout !== "position"))
                switch ("transform" in U || (U.transform = ""), B.anchorType) {
                  case "bottomCenter":
                    U.transform += "translate(-50%, -100%)";
                    break;
                  case "bottomLeft":
                    U.transform += "translate(0,-100%)";
                    break;
                  case "bottomRight":
                    U.transform += "translate(-100%,-100%)";
                    break;
                  case "middleCenter":
                    U.transform += "translate(-50%,-50%)";
                    break;
                  case "middleLeft":
                    U.transform += "translate(0,-50%)";
                    break;
                  case "middleRight":
                    U.transform += "translate(-100%,-50%)";
                    break;
                  case "topCenter":
                    U.transform += "translate(-50%,0)";
                    break;
                  case "topRight":
                    U.transform += "translate(-100%,0)";
                    break;
                }
            },
            dimensions(B, U) {
              const k = B[t.$getSubformParent]();
              let x = B.w;
              const f = B.h;
              if (k.layout && k.layout.includes("row")) {
                const D = k[t.$extra], _ = B.colSpan;
                let S;
                _ === -1 ? (S = D.columnWidths.slice(D.currentColumn).reduce((C, T) => C + T, 0), D.currentColumn = 0) : (S = D.columnWidths.slice(D.currentColumn, D.currentColumn + _).reduce((C, T) => C + T, 0), D.currentColumn = (D.currentColumn + B.colSpan) % D.columnWidths.length), isNaN(S) || (x = B.w = S);
              }
              x !== "" ? U.width = y(x) : U.width = "auto", f !== "" ? U.height = y(f) : U.height = "auto";
            },
            position(B, U) {
              const k = B[t.$getSubformParent]();
              k && k.layout && k.layout !== "position" || (U.position = "absolute", U.left = y(B.x), U.top = y(B.y));
            },
            rotate(B, U) {
              B.rotate && ("transform" in U || (U.transform = ""), U.transform += `rotate(-${B.rotate}deg)`, U.transformOrigin = "top left");
            },
            presence(B, U) {
              switch (B.presence) {
                case "invisible":
                  U.visibility = "hidden";
                  break;
                case "hidden":
                case "inactive":
                  U.display = "none";
                  break;
              }
            },
            hAlign(B, U) {
              if (B[t.$nodeName] === "para")
                switch (B.hAlign) {
                  case "justifyAll":
                    U.textAlign = "justify-all";
                    break;
                  case "radix":
                    U.textAlign = "left";
                    break;
                  default:
                    U.textAlign = B.hAlign;
                }
              else
                switch (B.hAlign) {
                  case "left":
                    U.alignSelf = "start";
                    break;
                  case "center":
                    U.alignSelf = "center";
                    break;
                  case "right":
                    U.alignSelf = "end";
                    break;
                }
            },
            margin(B, U) {
              B.margin && (U.margin = B.margin[t.$toStyle]().margin);
            }
          };
          function d(B, U) {
            B[t.$getSubformParent]().layout === "position" && (B.minW > 0 && (U.minWidth = y(B.minW)), B.maxW > 0 && (U.maxWidth = y(B.maxW)), B.minH > 0 && (U.minHeight = y(B.minH)), B.maxH > 0 && (U.maxHeight = y(B.maxH)));
          }
          function m(B, U, k, x, f, D) {
            const _ = new e.TextMeasure(U, k, x, f);
            return typeof B == "string" ? _.addString(B) : B[t.$pushGlyphs](_), _.compute(D);
          }
          function p(B, U) {
            let k = null, x = null, f = !1;
            if ((!B.w || !B.h) && B.value) {
              let D = 0, _ = 0;
              B.margin && (D = B.margin.leftInset + B.margin.rightInset, _ = B.margin.topInset + B.margin.bottomInset);
              let S = null, C = null;
              B.para && (C = /* @__PURE__ */ Object.create(null), S = B.para.lineHeight === "" ? null : B.para.lineHeight, C.top = B.para.spaceAbove === "" ? 0 : B.para.spaceAbove, C.bottom = B.para.spaceBelow === "" ? 0 : B.para.spaceBelow, C.left = B.para.marginLeft === "" ? 0 : B.para.marginLeft, C.right = B.para.marginRight === "" ? 0 : B.para.marginRight);
              let T = B.font;
              if (!T) {
                const G = B[t.$getTemplateRoot]();
                let Z = B[t.$getParent]();
                for (; Z && Z !== G; ) {
                  if (Z.font) {
                    T = Z.font;
                    break;
                  }
                  Z = Z[t.$getParent]();
                }
              }
              const P = (B.w || U.width) - D, M = B[t.$globalData].fontFinder;
              if (B.value.exData && B.value.exData[t.$content] && B.value.exData.contentType === "text/html") {
                const G = m(B.value.exData[t.$content], T, C, S, M, P);
                x = G.width, k = G.height, f = G.isBroken;
              } else {
                const G = B.value[t.$text]();
                if (G) {
                  const Z = m(G, T, C, S, M, P);
                  x = Z.width, k = Z.height, f = Z.isBroken;
                }
              }
              x !== null && !B.w && (x += D), k !== null && !B.h && (k += _);
            }
            return {
              w: x,
              h: k,
              isBroken: f
            };
          }
          function g(B, U, k) {
            let x;
            if (B.w !== "" && B.h !== "")
              x = [B.x, B.y, B.w, B.h];
            else {
              if (!k)
                return null;
              let f = B.w;
              if (f === "") {
                if (B.maxW === 0) {
                  const _ = B[t.$getSubformParent]();
                  _.layout === "position" && _.w !== "" ? f = 0 : f = B.minW;
                } else
                  f = Math.min(B.maxW, k.width);
                U.attributes.style.width = y(f);
              }
              let D = B.h;
              if (D === "") {
                if (B.maxH === 0) {
                  const _ = B[t.$getSubformParent]();
                  _.layout === "position" && _.h !== "" ? D = 0 : D = B.minH;
                } else
                  D = Math.min(B.maxH, k.height);
                U.attributes.style.height = y(D);
              }
              x = [B.x, B.y, f, D];
            }
            return x;
          }
          function n(B) {
            const U = B[t.$getSubformParent]();
            if (U.layout && U.layout.includes("row")) {
              const k = U[t.$extra], x = B.colSpan;
              let f;
              x === -1 ? f = k.columnWidths.slice(k.currentColumn).reduce((D, _) => D + _, 0) : f = k.columnWidths.slice(k.currentColumn, k.currentColumn + x).reduce((D, _) => D + _, 0), isNaN(f) || (B.w = f);
            }
            U.layout && U.layout !== "position" && (B.x = B.y = 0), B.layout === "table" && B.w === "" && Array.isArray(B.columnWidths) && (B.w = B.columnWidths.reduce((k, x) => k + x, 0));
          }
          function i(B) {
            switch (B.layout) {
              case "position":
                return "xfaPosition";
              case "lr-tb":
                return "xfaLrTb";
              case "rl-row":
                return "xfaRlRow";
              case "rl-tb":
                return "xfaRlTb";
              case "row":
                return "xfaRow";
              case "table":
                return "xfaTable";
              case "tb":
                return "xfaTb";
              default:
                return "xfaPosition";
            }
          }
          function l(B, ...U) {
            const k = /* @__PURE__ */ Object.create(null);
            for (const x of U) {
              const f = B[x];
              if (f !== null) {
                if (c.hasOwnProperty(x)) {
                  c[x](B, k);
                  continue;
                }
                if (f instanceof t.XFAObject) {
                  const D = f[t.$toStyle]();
                  D ? Object.assign(k, D) : (0, a.warn)(`(DEBUG) - XFA - style for ${x} not implemented yet`);
                }
              }
            }
            return k;
          }
          function u(B, U) {
            const {
              attributes: k
            } = U, {
              style: x
            } = k, f = {
              name: "div",
              attributes: {
                class: ["xfaWrapper"],
                style: /* @__PURE__ */ Object.create(null)
              },
              children: []
            };
            if (k.class.push("xfaWrapped"), B.border) {
              const {
                widths: D,
                insets: _
              } = B.border[t.$extra];
              let S, C, T = _[0], P = _[3];
              const M = _[0] + _[2], G = _[1] + _[3];
              switch (B.border.hand) {
                case "even":
                  T -= D[0] / 2, P -= D[3] / 2, S = `calc(100% + ${(D[1] + D[3]) / 2 - G}px)`, C = `calc(100% + ${(D[0] + D[2]) / 2 - M}px)`;
                  break;
                case "left":
                  T -= D[0], P -= D[3], S = `calc(100% + ${D[1] + D[3] - G}px)`, C = `calc(100% + ${D[0] + D[2] - M}px)`;
                  break;
                case "right":
                  S = G ? `calc(100% - ${G}px)` : "100%", C = M ? `calc(100% - ${M}px)` : "100%";
                  break;
              }
              const Z = ["xfaBorder"];
              b(B.border) && Z.push("xfaPrintOnly");
              const $ = {
                name: "div",
                attributes: {
                  class: Z,
                  style: {
                    top: `${T}px`,
                    left: `${P}px`,
                    width: S,
                    height: C
                  }
                },
                children: []
              };
              for (const z of ["border", "borderWidth", "borderColor", "borderRadius", "borderStyle"])
                x[z] !== void 0 && ($.attributes.style[z] = x[z], delete x[z]);
              f.children.push($, U);
            } else
              f.children.push(U);
            for (const D of ["background", "backgroundClip", "top", "left", "width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "transform", "transformOrigin", "visibility"])
              x[D] !== void 0 && (f.attributes.style[D] = x[D], delete x[D]);
            return x.position === "absolute" ? f.attributes.style.position = "absolute" : f.attributes.style.position = "relative", delete x.position, x.alignSelf && (f.attributes.style.alignSelf = x.alignSelf, delete x.alignSelf), f;
          }
          function w(B) {
            const U = (0, v.getMeasurement)(B.textIndent, "0px");
            if (U >= 0)
              return;
            const x = "padding" + ((B.textAlign === "right" ? "right" : "left") === "left" ? "Left" : "Right"), f = (0, v.getMeasurement)(B[x], "0px");
            B[x] = `${f - U}px`;
          }
          function O(B, U) {
            switch (B.access) {
              case "nonInteractive":
                U.push("xfaNonInteractive");
                break;
              case "readOnly":
                U.push("xfaReadOnly");
                break;
              case "protected":
                U.push("xfaDisabled");
                break;
            }
          }
          function b(B) {
            return B.relevant.length > 0 && !B.relevant[0].excluded && B.relevant[0].viewname === "print";
          }
          function A(B) {
            const U = B[t.$getTemplateRoot]()[t.$extra].paraStack;
            return U.length ? U.at(-1) : null;
          }
          function Y(B, U, k) {
            if (k.attributes.class && k.attributes.class.includes("xfaRich")) {
              U && (B.h === "" && (U.height = "auto"), B.w === "" && (U.width = "auto"));
              const x = A(B);
              if (x) {
                const f = k.attributes.style;
                switch (f.display = "flex", f.flexDirection = "column", x.vAlign) {
                  case "top":
                    f.justifyContent = "start";
                    break;
                  case "bottom":
                    f.justifyContent = "end";
                    break;
                  case "middle":
                    f.justifyContent = "center";
                    break;
                }
                const D = x[t.$toStyle]();
                for (const [_, S] of Object.entries(D))
                  _ in f || (f[_] = S);
              }
            }
          }
          function j(B, U, k, x) {
            if (!k) {
              delete x.fontFamily;
              return;
            }
            const f = (0, v.stripQuotes)(B.typeface);
            x.fontFamily = `"${f}"`;
            const D = k.find(f);
            if (D) {
              const {
                fontFamily: _
              } = D.regular.cssFontInfo;
              _ !== f && (x.fontFamily = `"${_}"`);
              const S = A(U);
              if (S && S.lineHeight !== "" || x.lineHeight)
                return;
              const C = (0, h.selectFont)(B, D);
              C && (x.lineHeight = Math.max(1.2, C.lineHeight));
            }
          }
          function X(B) {
            const U = (0, a.createValidAbsoluteUrl)(B, null, {
              addDefaultProtocol: !0,
              tryConvertEncoding: !0
            });
            return U ? U.href : null;
          }
        },
        /* 85 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.FontFinder = void 0, o.getMetrics = y, o.selectFont = e;
          var t = F(77), a = F(78), v = F(2);
          class h {
            constructor(d) {
              this.fonts = /* @__PURE__ */ new Map(), this.cache = /* @__PURE__ */ new Map(), this.warned = /* @__PURE__ */ new Set(), this.defaultFont = null, this.add(d);
            }
            add(d, m = null) {
              for (const g of d)
                this.addPdfFont(g);
              for (const g of this.fonts.values())
                g.regular || (g.regular = g.italic || g.bold || g.bolditalic);
              if (!m || m.size === 0)
                return;
              const p = this.fonts.get("PdfJS-Fallback-PdfJS-XFA");
              for (const g of m)
                this.fonts.set(g, p);
            }
            addPdfFont(d) {
              const m = d.cssFontInfo, p = m.fontFamily;
              let g = this.fonts.get(p);
              g || (g = /* @__PURE__ */ Object.create(null), this.fonts.set(p, g), this.defaultFont || (this.defaultFont = g));
              let n = "";
              const i = parseFloat(m.fontWeight);
              parseFloat(m.italicAngle) !== 0 ? n = i >= 700 ? "bolditalic" : "italic" : i >= 700 && (n = "bold"), n || ((d.name.includes("Bold") || d.psName && d.psName.includes("Bold")) && (n = "bold"), (d.name.includes("Italic") || d.name.endsWith("It") || d.psName && (d.psName.includes("Italic") || d.psName.endsWith("It"))) && (n += "italic")), n || (n = "regular"), g[n] = d;
            }
            getDefault() {
              return this.defaultFont;
            }
            find(d, m = !0) {
              let p = this.fonts.get(d) || this.cache.get(d);
              if (p)
                return p;
              const g = /,|-|_| |bolditalic|bold|italic|regular|it/gi;
              let n = d.replace(g, "");
              if (p = this.fonts.get(n), p)
                return this.cache.set(d, p), p;
              n = n.toLowerCase();
              const i = [];
              for (const [l, u] of this.fonts.entries())
                l.replace(g, "").toLowerCase().startsWith(n) && i.push(u);
              if (i.length === 0)
                for (const [, l] of this.fonts.entries())
                  l.regular.name && l.regular.name.replace(g, "").toLowerCase().startsWith(n) && i.push(l);
              if (i.length === 0) {
                n = n.replace(/psmt|mt/gi, "");
                for (const [l, u] of this.fonts.entries())
                  l.replace(g, "").toLowerCase().startsWith(n) && i.push(u);
              }
              if (i.length === 0)
                for (const l of this.fonts.values())
                  l.regular.name && l.regular.name.replace(g, "").toLowerCase().startsWith(n) && i.push(l);
              return i.length >= 1 ? (i.length !== 1 && m && (0, v.warn)(`XFA - Too many choices to guess the correct font: ${d}`), this.cache.set(d, i[0]), i[0]) : (m && !this.warned.has(d) && (this.warned.add(d), (0, v.warn)(`XFA - Cannot find the font: ${d}`)), null);
            }
          }
          o.FontFinder = h;
          function e(c, d) {
            return c.posture === "italic" ? c.weight === "bold" ? d.bolditalic : d.italic : c.weight === "bold" ? d.bold : d.regular;
          }
          function y(c, d = !1) {
            let m = null;
            if (c) {
              const i = (0, a.stripQuotes)(c.typeface), l = c[t.$globalData].fontFinder.find(i);
              m = e(c, l);
            }
            if (!m)
              return {
                lineHeight: 12,
                lineGap: 2,
                lineNoGap: 10
              };
            const p = c.size || 10, g = m.lineHeight ? Math.max(d ? 0 : 1.2, m.lineHeight) : 1.2, n = m.lineGap === void 0 ? 0.2 : m.lineGap;
            return {
              lineHeight: g * p,
              lineGap: n * p,
              lineNoGap: Math.max(1, g - n) * p
            };
          }
        },
        /* 86 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.TextMeasure = void 0;
          var t = F(85);
          const a = 1.02;
          class v {
            constructor(c, d, m, p) {
              if (this.lineHeight = m, this.paraMargin = d || {
                top: 0,
                bottom: 0,
                left: 0,
                right: 0
              }, !c) {
                [this.pdfFont, this.xfaFont] = this.defaultFont(p);
                return;
              }
              this.xfaFont = {
                typeface: c.typeface,
                posture: c.posture,
                weight: c.weight,
                size: c.size,
                letterSpacing: c.letterSpacing
              };
              const g = p.find(c.typeface);
              if (!g) {
                [this.pdfFont, this.xfaFont] = this.defaultFont(p);
                return;
              }
              this.pdfFont = (0, t.selectFont)(c, g), this.pdfFont || ([this.pdfFont, this.xfaFont] = this.defaultFont(p));
            }
            defaultFont(c) {
              const d = c.find("Helvetica", !1) || c.find("Myriad Pro", !1) || c.find("Arial", !1) || c.getDefault();
              if (d && d.regular) {
                const p = d.regular, n = {
                  typeface: p.cssFontInfo.fontFamily,
                  posture: "normal",
                  weight: "normal",
                  size: 10,
                  letterSpacing: 0
                };
                return [p, n];
              }
              return [null, {
                typeface: "Courier",
                posture: "normal",
                weight: "normal",
                size: 10,
                letterSpacing: 0
              }];
            }
          }
          class h {
            constructor(c, d, m, p) {
              this.fontFinder = p, this.stack = [new v(c, d, m, p)];
            }
            pushData(c, d, m) {
              const p = this.stack.at(-1);
              for (const n of ["typeface", "posture", "weight", "size", "letterSpacing"])
                c[n] || (c[n] = p.xfaFont[n]);
              for (const n of ["top", "bottom", "left", "right"])
                isNaN(d[n]) && (d[n] = p.paraMargin[n]);
              const g = new v(c, d, m || p.lineHeight, this.fontFinder);
              g.pdfFont || (g.pdfFont = p.pdfFont), this.stack.push(g);
            }
            popFont() {
              this.stack.pop();
            }
            topFont() {
              return this.stack.at(-1);
            }
          }
          class e {
            constructor(c, d, m, p) {
              this.glyphs = [], this.fontSelector = new h(c, d, m, p), this.extraHeight = 0;
            }
            pushData(c, d, m) {
              this.fontSelector.pushData(c, d, m);
            }
            popFont(c) {
              return this.fontSelector.popFont();
            }
            addPara() {
              const c = this.fontSelector.topFont();
              this.extraHeight += c.paraMargin.top + c.paraMargin.bottom;
            }
            addString(c) {
              if (!c)
                return;
              const d = this.fontSelector.topFont(), m = d.xfaFont.size;
              if (d.pdfFont) {
                const p = d.xfaFont.letterSpacing, g = d.pdfFont, n = g.lineHeight || 1.2, i = d.lineHeight || Math.max(1.2, n) * m, l = g.lineGap === void 0 ? 0.2 : g.lineGap, u = n - l, w = Math.max(1, u) * m, O = m / 1e3, b = g.defaultWidth || g.charsToGlyphs(" ")[0].width;
                for (const A of c.split(/[\u2029\n]/)) {
                  const Y = g.encodeString(A).join(""), j = g.charsToGlyphs(Y);
                  for (const X of j) {
                    const B = X.width || b;
                    this.glyphs.push([B * O + p, i, w, X.unicode, !1]);
                  }
                  this.glyphs.push([0, 0, 0, `
`, !0]);
                }
                this.glyphs.pop();
                return;
              }
              for (const p of c.split(/[\u2029\n]/)) {
                for (const g of p.split(""))
                  this.glyphs.push([m, 1.2 * m, m, g, !1]);
                this.glyphs.push([0, 0, 0, `
`, !0]);
              }
              this.glyphs.pop();
            }
            compute(c) {
              let d = -1, m = 0, p = 0, g = 0, n = 0, i = 0, l = !1, u = !0;
              for (let w = 0, O = this.glyphs.length; w < O; w++) {
                const [b, A, Y, j, X] = this.glyphs[w], B = j === " ", U = u ? Y : A;
                if (X) {
                  p = Math.max(p, n), n = 0, g += i, i = U, d = -1, m = 0, u = !1;
                  continue;
                }
                if (B) {
                  n + b > c ? (p = Math.max(p, n), n = 0, g += i, i = U, d = -1, m = 0, l = !0, u = !1) : (i = Math.max(U, i), m = n, n += b, d = w);
                  continue;
                }
                if (n + b > c) {
                  g += i, i = U, d !== -1 ? (w = d, p = Math.max(p, m), n = 0, d = -1, m = 0) : (p = Math.max(p, n), n = b), l = !0, u = !1;
                  continue;
                }
                n += b, i = Math.max(U, i);
              }
              return p = Math.max(p, n), g += i + this.extraHeight, {
                width: a * p,
                height: g,
                isBroken: l
              };
            }
          }
          o.TextMeasure = e;
        },
        /* 87 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.DataHandler = void 0;
          var t = F(77);
          class a {
            constructor(h, e) {
              this.data = e, this.dataset = h.datasets || null;
            }
            serialize(h) {
              const e = [[-1, this.data[t.$getChildren]()]];
              for (; e.length > 0; ) {
                const c = e.at(-1), [d, m] = c;
                if (d + 1 === m.length) {
                  e.pop();
                  continue;
                }
                const p = m[++c[0]], g = h.get(p[t.$uid]);
                if (g)
                  p[t.$setValue](g);
                else {
                  const i = p[t.$getAttributes]();
                  for (const l of i.values()) {
                    const u = h.get(l[t.$uid]);
                    if (u) {
                      l[t.$setValue](u);
                      break;
                    }
                  }
                }
                const n = p[t.$getChildren]();
                n.length > 0 && e.push([-1, n]);
              }
              const y = ['<xfa:datasets xmlns:xfa="http://www.xfa.org/schema/xfa-data/1.0/">'];
              if (this.dataset)
                for (const c of this.dataset[t.$getChildren]())
                  c[t.$nodeName] !== "data" && c[t.$toString](y);
              return this.data[t.$toString](y), y.push("</xfa:datasets>"), y.join("");
            }
          }
          o.DataHandler = a;
        },
        /* 88 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.XFAParser = void 0;
          var t = F(77), a = F(66), v = F(89), h = F(2);
          class e extends a.XMLParserBase {
            constructor(c = null, d = !1) {
              super(), this._builder = new v.Builder(c), this._stack = [], this._globalData = {
                usedTypefaces: /* @__PURE__ */ new Set()
              }, this._ids = /* @__PURE__ */ new Map(), this._current = this._builder.buildRoot(this._ids), this._errorCode = a.XMLParserErrorCode.NoError, this._whiteRegex = /^\s+$/, this._nbsps = /\xa0+/g, this._richText = d;
            }
            parse(c) {
              if (this.parseXml(c), this._errorCode === a.XMLParserErrorCode.NoError)
                return this._current[t.$finalize](), this._current.element;
            }
            onText(c) {
              if (c = c.replace(this._nbsps, (d) => d.slice(1) + " "), this._richText || this._current[t.$acceptWhitespace]()) {
                this._current[t.$onText](c, this._richText);
                return;
              }
              this._whiteRegex.test(c) || this._current[t.$onText](c.trim());
            }
            onCdata(c) {
              this._current[t.$onText](c);
            }
            _mkAttributes(c, d) {
              let m = null, p = null;
              const g = /* @__PURE__ */ Object.create({});
              for (const {
                name: n,
                value: i
              } of c)
                if (n === "xmlns")
                  m ? (0, h.warn)(`XFA - multiple namespace definition in <${d}>`) : m = i;
                else if (n.startsWith("xmlns:")) {
                  const l = n.substring(6);
                  p || (p = []), p.push({
                    prefix: l,
                    value: i
                  });
                } else {
                  const l = n.indexOf(":");
                  if (l === -1)
                    g[n] = i;
                  else {
                    let u = g[t.$nsAttributes];
                    u || (u = g[t.$nsAttributes] = /* @__PURE__ */ Object.create(null));
                    const [w, O] = [n.slice(0, l), n.slice(l + 1)];
                    let b = u[w];
                    b || (b = u[w] = /* @__PURE__ */ Object.create(null)), b[O] = i;
                  }
                }
              return [m, p, g];
            }
            _getNameAndPrefix(c, d) {
              const m = c.indexOf(":");
              return m === -1 ? [c, null] : [c.substring(m + 1), d ? "" : c.substring(0, m)];
            }
            onBeginElement(c, d, m) {
              const [p, g, n] = this._mkAttributes(d, c), [i, l] = this._getNameAndPrefix(c, this._builder.isNsAgnostic()), u = this._builder.build({
                nsPrefix: l,
                name: i,
                attributes: n,
                namespace: p,
                prefixes: g
              });
              if (u[t.$globalData] = this._globalData, m) {
                u[t.$finalize](), this._current[t.$onChild](u) && u[t.$setId](this._ids), u[t.$clean](this._builder);
                return;
              }
              this._stack.push(this._current), this._current = u;
            }
            onEndElement(c) {
              const d = this._current;
              if (d[t.$isCDATAXml]() && typeof d[t.$content] == "string") {
                const m = new e();
                m._globalData = this._globalData;
                const p = m.parse(d[t.$content]);
                d[t.$content] = null, d[t.$onChild](p);
              }
              d[t.$finalize](), this._current = this._stack.pop(), this._current[t.$onChild](d) && d[t.$setId](this._ids), d[t.$clean](this._builder);
            }
            onError(c) {
              this._errorCode = c;
            }
          }
          o.XFAParser = e;
        },
        /* 89 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.Builder = void 0;
          var t = F(79), a = F(77), v = F(90), h = F(82), e = F(99), y = F(2);
          class c extends a.XFAObject {
            constructor(g) {
              super(-1, "root", /* @__PURE__ */ Object.create(null)), this.element = null, this[a.$ids] = g;
            }
            [a.$onChild](g) {
              return this.element = g, !0;
            }
            [a.$finalize]() {
              super[a.$finalize](), this.element.template instanceof h.Template && (this[a.$ids].set(a.$root, this.element), this.element.template[a.$resolvePrototypes](this[a.$ids]), this.element.template[a.$ids] = this[a.$ids]);
            }
          }
          class d extends a.XFAObject {
            constructor() {
              super(-1, "", /* @__PURE__ */ Object.create(null));
            }
            [a.$onChild](g) {
              return !1;
            }
          }
          class m {
            constructor(g = null) {
              this._namespaceStack = [], this._nsAgnosticLevel = 0, this._namespacePrefixes = /* @__PURE__ */ new Map(), this._namespaces = /* @__PURE__ */ new Map(), this._nextNsId = Math.max(...Object.values(t.NamespaceIds).map(({
                id: n
              }) => n)), this._currentNamespace = g || new e.UnknownNamespace(++this._nextNsId);
            }
            buildRoot(g) {
              return new c(g);
            }
            build({
              nsPrefix: g,
              name: n,
              attributes: i,
              namespace: l,
              prefixes: u
            }) {
              const w = l !== null;
              if (w && (this._namespaceStack.push(this._currentNamespace), this._currentNamespace = this._searchNamespace(l)), u && this._addNamespacePrefix(u), i.hasOwnProperty(a.$nsAttributes)) {
                const A = v.NamespaceSetUp.datasets, Y = i[a.$nsAttributes];
                let j = null;
                for (const [X, B] of Object.entries(Y))
                  if (this._getNamespaceToUse(X) === A) {
                    j = {
                      xfa: B
                    };
                    break;
                  }
                j ? i[a.$nsAttributes] = j : delete i[a.$nsAttributes];
              }
              const O = this._getNamespaceToUse(g), b = O && O[t.$buildXFAObject](n, i) || new d();
              return b[a.$isNsAgnostic]() && this._nsAgnosticLevel++, (w || u || b[a.$isNsAgnostic]()) && (b[a.$cleanup] = {
                hasNamespace: w,
                prefixes: u,
                nsAgnostic: b[a.$isNsAgnostic]()
              }), b;
            }
            isNsAgnostic() {
              return this._nsAgnosticLevel > 0;
            }
            _searchNamespace(g) {
              let n = this._namespaces.get(g);
              if (n)
                return n;
              for (const [i, {
                check: l
              }] of Object.entries(t.NamespaceIds))
                if (l(g)) {
                  if (n = v.NamespaceSetUp[i], n)
                    return this._namespaces.set(g, n), n;
                  break;
                }
              return n = new e.UnknownNamespace(++this._nextNsId), this._namespaces.set(g, n), n;
            }
            _addNamespacePrefix(g) {
              for (const {
                prefix: n,
                value: i
              } of g) {
                const l = this._searchNamespace(i);
                let u = this._namespacePrefixes.get(n);
                u || (u = [], this._namespacePrefixes.set(n, u)), u.push(l);
              }
            }
            _getNamespaceToUse(g) {
              if (!g)
                return this._currentNamespace;
              const n = this._namespacePrefixes.get(g);
              return n && n.length > 0 ? n.at(-1) : ((0, y.warn)(`Unknown namespace prefix: ${g}.`), null);
            }
            clean(g) {
              const {
                hasNamespace: n,
                prefixes: i,
                nsAgnostic: l
              } = g;
              n && (this._currentNamespace = this._namespaceStack.pop()), i && i.forEach(({
                prefix: u
              }) => {
                this._namespacePrefixes.get(u).pop();
              }), l && this._nsAgnosticLevel--;
            }
          }
          o.Builder = m;
        },
        /* 90 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.NamespaceSetUp = void 0;
          var t = F(91), a = F(92), v = F(93), h = F(94), e = F(95), y = F(96), c = F(82), d = F(97), m = F(98);
          const p = {
            config: t.ConfigNamespace,
            connection: a.ConnectionSetNamespace,
            datasets: v.DatasetsNamespace,
            localeSet: h.LocaleSetNamespace,
            signature: e.SignatureNamespace,
            stylesheet: y.StylesheetNamespace,
            template: c.TemplateNamespace,
            xdp: d.XdpNamespace,
            xhtml: m.XhtmlNamespace
          };
          o.NamespaceSetUp = p;
        },
        /* 91 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.ConfigNamespace = void 0;
          var t = F(79), a = F(77), v = F(78), h = F(2);
          const e = t.NamespaceIds.config.id;
          class y extends a.XFAObject {
            constructor(he) {
              super(e, "acrobat", !0), this.acrobat7 = null, this.autoSave = null, this.common = null, this.validate = null, this.validateApprovalSignatures = null, this.submitUrl = new a.XFAObjectArray();
            }
          }
          class c extends a.XFAObject {
            constructor(he) {
              super(e, "acrobat7", !0), this.dynamicRender = null;
            }
          }
          class d extends a.OptionObject {
            constructor(he) {
              super(e, "ADBE_JSConsole", ["delegate", "Enable", "Disable"]);
            }
          }
          class m extends a.OptionObject {
            constructor(he) {
              super(e, "ADBE_JSDebugger", ["delegate", "Enable", "Disable"]);
            }
          }
          class p extends a.Option01 {
            constructor(he) {
              super(e, "addSilentPrint");
            }
          }
          class g extends a.Option01 {
            constructor(he) {
              super(e, "addViewerPreferences");
            }
          }
          class n extends a.Option10 {
            constructor(he) {
              super(e, "adjustData");
            }
          }
          class i extends a.IntegerObject {
            constructor(he) {
              super(e, "adobeExtensionLevel", 0, ($e) => $e >= 1 && $e <= 8);
            }
          }
          class l extends a.XFAObject {
            constructor(he) {
              super(e, "agent", !0), this.name = he.name ? he.name.trim() : "", this.common = new a.XFAObjectArray();
            }
          }
          class u extends a.ContentObject {
            constructor(he) {
              super(e, "alwaysEmbed");
            }
          }
          class w extends a.StringObject {
            constructor(he) {
              super(e, "amd");
            }
          }
          class O extends a.XFAObject {
            constructor(he) {
              super(e, "area"), this.level = (0, v.getInteger)({
                data: he.level,
                defaultValue: 0,
                validate: ($e) => $e >= 1 && $e <= 3
              }), this.name = (0, v.getStringOption)(he.name, ["", "barcode", "coreinit", "deviceDriver", "font", "general", "layout", "merge", "script", "signature", "sourceSet", "templateCache"]);
            }
          }
          class b extends a.OptionObject {
            constructor(he) {
              super(e, "attributes", ["preserve", "delegate", "ignore"]);
            }
          }
          class A extends a.OptionObject {
            constructor(he) {
              super(e, "autoSave", ["disabled", "enabled"]);
            }
          }
          class Y extends a.StringObject {
            constructor(he) {
              super(e, "base");
            }
          }
          class j extends a.XFAObject {
            constructor(he) {
              super(e, "batchOutput"), this.format = (0, v.getStringOption)(he.format, ["none", "concat", "zip", "zipCompress"]);
            }
          }
          class X extends a.ContentObject {
            constructor(he) {
              super(e, "behaviorOverride");
            }
            [a.$finalize]() {
              this[a.$content] = new Map(this[a.$content].trim().split(/\s+/).filter((he) => he.includes(":")).map((he) => he.split(":", 2)));
            }
          }
          class B extends a.XFAObject {
            constructor(he) {
              super(e, "cache", !0), this.templateCache = null;
            }
          }
          class U extends a.Option01 {
            constructor(he) {
              super(e, "change");
            }
          }
          class k extends a.XFAObject {
            constructor(he) {
              super(e, "common", !0), this.data = null, this.locale = null, this.localeSet = null, this.messaging = null, this.suppressBanner = null, this.template = null, this.validationMessaging = null, this.versionControl = null, this.log = new a.XFAObjectArray();
            }
          }
          class x extends a.XFAObject {
            constructor(he) {
              super(e, "compress"), this.scope = (0, v.getStringOption)(he.scope, ["imageOnly", "document"]);
            }
          }
          class f extends a.Option01 {
            constructor(he) {
              super(e, "compressLogicalStructure");
            }
          }
          class D extends a.Option10 {
            constructor(he) {
              super(e, "compressObjectStream");
            }
          }
          class _ extends a.XFAObject {
            constructor(he) {
              super(e, "compression", !0), this.compressLogicalStructure = null, this.compressObjectStream = null, this.level = null, this.type = null;
            }
          }
          class S extends a.XFAObject {
            constructor(he) {
              super(e, "config", !0), this.acrobat = null, this.present = null, this.trace = null, this.agent = new a.XFAObjectArray();
            }
          }
          class C extends a.OptionObject {
            constructor(he) {
              super(e, "conformance", ["A", "B"]);
            }
          }
          class T extends a.Option01 {
            constructor(he) {
              super(e, "contentCopy");
            }
          }
          class P extends a.IntegerObject {
            constructor(he) {
              super(e, "copies", 1, ($e) => $e >= 1);
            }
          }
          class M extends a.StringObject {
            constructor(he) {
              super(e, "creator");
            }
          }
          class G extends a.IntegerObject {
            constructor(he) {
              super(e, "currentPage", 0, ($e) => $e >= 0);
            }
          }
          class Z extends a.XFAObject {
            constructor(he) {
              super(e, "data", !0), this.adjustData = null, this.attributes = null, this.incrementalLoad = null, this.outputXSL = null, this.range = null, this.record = null, this.startNode = null, this.uri = null, this.window = null, this.xsl = null, this.excludeNS = new a.XFAObjectArray(), this.transform = new a.XFAObjectArray();
            }
          }
          class $ extends a.XFAObject {
            constructor(he) {
              super(e, "debug", !0), this.uri = null;
            }
          }
          class z extends a.ContentObject {
            constructor(he) {
              super(e, "defaultTypeface"), this.writingScript = (0, v.getStringOption)(he.writingScript, ["*", "Arabic", "Cyrillic", "EastEuropeanRoman", "Greek", "Hebrew", "Japanese", "Korean", "Roman", "SimplifiedChinese", "Thai", "TraditionalChinese", "Vietnamese"]);
            }
          }
          class V extends a.OptionObject {
            constructor(he) {
              super(e, "destination", ["pdf", "pcl", "ps", "webClient", "zpl"]);
            }
          }
          class L extends a.Option01 {
            constructor(he) {
              super(e, "documentAssembly");
            }
          }
          class K extends a.XFAObject {
            constructor(he) {
              super(e, "driver", !0), this.name = he.name ? he.name.trim() : "", this.fontInfo = null, this.xdc = null;
            }
          }
          class ne extends a.OptionObject {
            constructor(he) {
              super(e, "duplexOption", ["simplex", "duplexFlipLongEdge", "duplexFlipShortEdge"]);
            }
          }
          class se extends a.OptionObject {
            constructor(he) {
              super(e, "dynamicRender", ["forbidden", "required"]);
            }
          }
          class q extends a.Option01 {
            constructor(he) {
              super(e, "embed");
            }
          }
          class N extends a.Option01 {
            constructor(he) {
              super(e, "encrypt");
            }
          }
          class Q extends a.XFAObject {
            constructor(he) {
              super(e, "encryption", !0), this.encrypt = null, this.encryptionLevel = null, this.permissions = null;
            }
          }
          class E extends a.OptionObject {
            constructor(he) {
              super(e, "encryptionLevel", ["40bit", "128bit"]);
            }
          }
          class te extends a.StringObject {
            constructor(he) {
              super(e, "enforce");
            }
          }
          class oe extends a.XFAObject {
            constructor(he) {
              super(e, "equate"), this.force = (0, v.getInteger)({
                data: he.force,
                defaultValue: 1,
                validate: ($e) => $e === 0
              }), this.from = he.from || "", this.to = he.to || "";
            }
          }
          class ee extends a.XFAObject {
            constructor(he) {
              super(e, "equateRange"), this.from = he.from || "", this.to = he.to || "", this._unicodeRange = he.unicodeRange || "";
            }
            get unicodeRange() {
              const he = [], $e = /U\+([0-9a-fA-F]+)/, Ze = this._unicodeRange;
              for (let ht of Ze.split(",").map((It) => It.trim()).filter((It) => !!It))
                ht = ht.split("-", 2).map((It) => {
                  const Et = It.match($e);
                  return Et ? parseInt(Et[1], 16) : 0;
                }), ht.length === 1 && ht.push(ht[0]), he.push(ht);
              return (0, h.shadow)(this, "unicodeRange", he);
            }
          }
          class W extends a.ContentObject {
            constructor(he) {
              super(e, "exclude");
            }
            [a.$finalize]() {
              this[a.$content] = this[a.$content].trim().split(/\s+/).filter((he) => he && ["calculate", "close", "enter", "exit", "initialize", "ready", "validate"].includes(he));
            }
          }
          class I extends a.StringObject {
            constructor(he) {
              super(e, "excludeNS");
            }
          }
          class H extends a.OptionObject {
            constructor(he) {
              super(e, "flipLabel", ["usePrinterSetting", "on", "off"]);
            }
          }
          class ie extends a.XFAObject {
            constructor(he) {
              super(e, "fontInfo", !0), this.embed = null, this.map = null, this.subsetBelow = null, this.alwaysEmbed = new a.XFAObjectArray(), this.defaultTypeface = new a.XFAObjectArray(), this.neverEmbed = new a.XFAObjectArray();
            }
          }
          class ue extends a.Option01 {
            constructor(he) {
              super(e, "formFieldFilling");
            }
          }
          class fe extends a.StringObject {
            constructor(he) {
              super(e, "groupParent");
            }
          }
          class de extends a.OptionObject {
            constructor(he) {
              super(e, "ifEmpty", ["dataValue", "dataGroup", "ignore", "remove"]);
            }
          }
          class pe extends a.StringObject {
            constructor(he) {
              super(e, "includeXDPContent");
            }
          }
          class xe extends a.OptionObject {
            constructor(he) {
              super(e, "incrementalLoad", ["none", "forwardOnly"]);
            }
          }
          class Fe extends a.Option01 {
            constructor(he) {
              super(e, "incrementalMerge");
            }
          }
          class Se extends a.Option01 {
            constructor(he) {
              super(e, "interactive");
            }
          }
          class Ce extends a.OptionObject {
            constructor(he) {
              super(e, "jog", ["usePrinterSetting", "none", "pageSet"]);
            }
          }
          class ke extends a.XFAObject {
            constructor(he) {
              super(e, "labelPrinter", !0), this.name = (0, v.getStringOption)(he.name, ["zpl", "dpl", "ipl", "tcpl"]), this.batchOutput = null, this.flipLabel = null, this.fontInfo = null, this.xdc = null;
            }
          }
          class ye extends a.OptionObject {
            constructor(he) {
              super(e, "layout", ["paginate", "panel"]);
            }
          }
          class De extends a.IntegerObject {
            constructor(he) {
              super(e, "level", 0, ($e) => $e > 0);
            }
          }
          class Ae extends a.Option01 {
            constructor(he) {
              super(e, "linearized");
            }
          }
          class Te extends a.StringObject {
            constructor(he) {
              super(e, "locale");
            }
          }
          class ve extends a.StringObject {
            constructor(he) {
              super(e, "localeSet");
            }
          }
          class Ne extends a.XFAObject {
            constructor(he) {
              super(e, "log", !0), this.mode = null, this.threshold = null, this.to = null, this.uri = null;
            }
          }
          class Ge extends a.XFAObject {
            constructor(he) {
              super(e, "map", !0), this.equate = new a.XFAObjectArray(), this.equateRange = new a.XFAObjectArray();
            }
          }
          class it extends a.XFAObject {
            constructor(he) {
              super(e, "mediumInfo", !0), this.map = null;
            }
          }
          class Me extends a.XFAObject {
            constructor(he) {
              super(e, "message", !0), this.msgId = null, this.severity = null;
            }
          }
          class Ie extends a.XFAObject {
            constructor(he) {
              super(e, "messaging", !0), this.message = new a.XFAObjectArray();
            }
          }
          class Ee extends a.OptionObject {
            constructor(he) {
              super(e, "mode", ["append", "overwrite"]);
            }
          }
          class st extends a.Option01 {
            constructor(he) {
              super(e, "modifyAnnots");
            }
          }
          class Qe extends a.IntegerObject {
            constructor(he) {
              super(e, "msgId", 1, ($e) => $e >= 1);
            }
          }
          class ct extends a.StringObject {
            constructor(he) {
              super(e, "nameAttr");
            }
          }
          class xt extends a.ContentObject {
            constructor(he) {
              super(e, "neverEmbed");
            }
          }
          class Je extends a.IntegerObject {
            constructor(he) {
              super(e, "numberOfCopies", null, ($e) => $e >= 2 && $e <= 5);
            }
          }
          class mt extends a.XFAObject {
            constructor(he) {
              super(e, "openAction", !0), this.destination = null;
            }
          }
          class _t extends a.XFAObject {
            constructor(he) {
              super(e, "output", !0), this.to = null, this.type = null, this.uri = null;
            }
          }
          class Xe extends a.StringObject {
            constructor(he) {
              super(e, "outputBin");
            }
          }
          class Ct extends a.XFAObject {
            constructor(he) {
              super(e, "outputXSL", !0), this.uri = null;
            }
          }
          class bt extends a.OptionObject {
            constructor(he) {
              super(e, "overprint", ["none", "both", "draw", "field"]);
            }
          }
          class Pe extends a.StringObject {
            constructor(he) {
              super(e, "packets");
            }
            [a.$finalize]() {
              this[a.$content] !== "*" && (this[a.$content] = this[a.$content].trim().split(/\s+/).filter((he) => ["config", "datasets", "template", "xfdf", "xslt"].includes(he)));
            }
          }
          class qe extends a.XFAObject {
            constructor(he) {
              super(e, "pageOffset"), this.x = (0, v.getInteger)({
                data: he.x,
                defaultValue: "useXDCSetting",
                validate: ($e) => !0
              }), this.y = (0, v.getInteger)({
                data: he.y,
                defaultValue: "useXDCSetting",
                validate: ($e) => !0
              });
            }
          }
          class ot extends a.StringObject {
            constructor(he) {
              super(e, "pageRange");
            }
            [a.$finalize]() {
              const he = this[a.$content].trim().split(/\s+/).map((Ze) => parseInt(Ze, 10)), $e = [];
              for (let Ze = 0, ht = he.length; Ze < ht; Ze += 2)
                $e.push(he.slice(Ze, Ze + 2));
              this[a.$content] = $e;
            }
          }
          class lt extends a.OptionObject {
            constructor(he) {
              super(e, "pagination", ["simplex", "duplexShortEdge", "duplexLongEdge"]);
            }
          }
          class Ut extends a.OptionObject {
            constructor(he) {
              super(e, "paginationOverride", ["none", "forceDuplex", "forceDuplexLongEdge", "forceDuplexShortEdge", "forceSimplex"]);
            }
          }
          class Nt extends a.IntegerObject {
            constructor(he) {
              super(e, "part", 1, ($e) => !1);
            }
          }
          class Ve extends a.XFAObject {
            constructor(he) {
              super(e, "pcl", !0), this.name = he.name || "", this.batchOutput = null, this.fontInfo = null, this.jog = null, this.mediumInfo = null, this.outputBin = null, this.pageOffset = null, this.staple = null, this.xdc = null;
            }
          }
          class je extends a.XFAObject {
            constructor(he) {
              super(e, "pdf", !0), this.name = he.name || "", this.adobeExtensionLevel = null, this.batchOutput = null, this.compression = null, this.creator = null, this.encryption = null, this.fontInfo = null, this.interactive = null, this.linearized = null, this.openAction = null, this.pdfa = null, this.producer = null, this.renderPolicy = null, this.scriptModel = null, this.silentPrint = null, this.submitFormat = null, this.tagged = null, this.version = null, this.viewerPreferences = null, this.xdc = null;
            }
          }
          class at extends a.XFAObject {
            constructor(he) {
              super(e, "pdfa", !0), this.amd = null, this.conformance = null, this.includeXDPContent = null, this.part = null;
            }
          }
          class nt extends a.XFAObject {
            constructor(he) {
              super(e, "permissions", !0), this.accessibleContent = null, this.change = null, this.contentCopy = null, this.documentAssembly = null, this.formFieldFilling = null, this.modifyAnnots = null, this.plaintextMetadata = null, this.print = null, this.printHighQuality = null;
            }
          }
          class ft extends a.Option01 {
            constructor(he) {
              super(e, "pickTrayByPDFSize");
            }
          }
          class Tt extends a.StringObject {
            constructor(he) {
              super(e, "picture");
            }
          }
          class yt extends a.Option01 {
            constructor(he) {
              super(e, "plaintextMetadata");
            }
          }
          class dt extends a.OptionObject {
            constructor(he) {
              super(e, "presence", ["preserve", "dissolve", "dissolveStructure", "ignore", "remove"]);
            }
          }
          class wt extends a.XFAObject {
            constructor(he) {
              super(e, "present", !0), this.behaviorOverride = null, this.cache = null, this.common = null, this.copies = null, this.destination = null, this.incrementalMerge = null, this.layout = null, this.output = null, this.overprint = null, this.pagination = null, this.paginationOverride = null, this.script = null, this.validate = null, this.xdp = null, this.driver = new a.XFAObjectArray(), this.labelPrinter = new a.XFAObjectArray(), this.pcl = new a.XFAObjectArray(), this.pdf = new a.XFAObjectArray(), this.ps = new a.XFAObjectArray(), this.submitUrl = new a.XFAObjectArray(), this.webClient = new a.XFAObjectArray(), this.zpl = new a.XFAObjectArray();
            }
          }
          class Dt extends a.Option01 {
            constructor(he) {
              super(e, "print");
            }
          }
          class jt extends a.Option01 {
            constructor(he) {
              super(e, "printHighQuality");
            }
          }
          class Bt extends a.OptionObject {
            constructor(he) {
              super(e, "printScaling", ["appdefault", "noScaling"]);
            }
          }
          class kt extends a.StringObject {
            constructor(he) {
              super(e, "printerName");
            }
          }
          class Ue extends a.StringObject {
            constructor(he) {
              super(e, "producer");
            }
          }
          class We extends a.XFAObject {
            constructor(he) {
              super(e, "ps", !0), this.name = he.name || "", this.batchOutput = null, this.fontInfo = null, this.jog = null, this.mediumInfo = null, this.outputBin = null, this.staple = null, this.xdc = null;
            }
          }
          class rt extends a.ContentObject {
            constructor(he) {
              super(e, "range");
            }
            [a.$finalize]() {
              this[a.$content] = this[a.$content].trim().split(/\s*,\s*/, 2).map((he) => he.split("-").map(($e) => parseInt($e.trim(), 10))).filter((he) => he.every(($e) => !isNaN($e))).map((he) => (he.length === 1 && he.push(he[0]), he));
            }
          }
          class tt extends a.ContentObject {
            constructor(he) {
              super(e, "record");
            }
            [a.$finalize]() {
              this[a.$content] = this[a.$content].trim();
              const he = parseInt(this[a.$content], 10);
              !isNaN(he) && he >= 0 && (this[a.$content] = he);
            }
          }
          class St extends a.ContentObject {
            constructor(he) {
              super(e, "relevant");
            }
            [a.$finalize]() {
              this[a.$content] = this[a.$content].trim().split(/\s+/);
            }
          }
          class Pt extends a.ContentObject {
            constructor(he) {
              super(e, "rename");
            }
            [a.$finalize]() {
              this[a.$content] = this[a.$content].trim(), (this[a.$content].toLowerCase().startsWith("xml") || this[a.$content].match(new RegExp("[\\p{L}_][\\p{L}\\d._\\p{M}-]*", "u"))) && (0, h.warn)("XFA - Rename: invalid XFA name");
            }
          }
          class qt extends a.OptionObject {
            constructor(he) {
              super(e, "renderPolicy", ["server", "client"]);
            }
          }
          class Mt extends a.OptionObject {
            constructor(he) {
              super(e, "runScripts", ["both", "client", "none", "server"]);
            }
          }
          class Wt extends a.XFAObject {
            constructor(he) {
              super(e, "script", !0), this.currentPage = null, this.exclude = null, this.runScripts = null;
            }
          }
          class Zt extends a.OptionObject {
            constructor(he) {
              super(e, "scriptModel", ["XFA", "none"]);
            }
          }
          class an extends a.OptionObject {
            constructor(he) {
              super(e, "severity", ["ignore", "error", "information", "trace", "warning"]);
            }
          }
          class un extends a.XFAObject {
            constructor(he) {
              super(e, "silentPrint", !0), this.addSilentPrint = null, this.printerName = null;
            }
          }
          class Tn extends a.XFAObject {
            constructor(he) {
              super(e, "staple"), this.mode = (0, v.getStringOption)(he.mode, ["usePrinterSetting", "on", "off"]);
            }
          }
          class gn extends a.StringObject {
            constructor(he) {
              super(e, "startNode");
            }
          }
          class _n extends a.IntegerObject {
            constructor(he) {
              super(e, "startPage", 0, ($e) => !0);
            }
          }
          class vn extends a.OptionObject {
            constructor(he) {
              super(e, "submitFormat", ["html", "delegate", "fdf", "xml", "pdf"]);
            }
          }
          class En extends a.StringObject {
            constructor(he) {
              super(e, "submitUrl");
            }
          }
          class kn extends a.IntegerObject {
            constructor(he) {
              super(e, "subsetBelow", 100, ($e) => $e >= 0 && $e <= 100);
            }
          }
          class Ln extends a.Option01 {
            constructor(he) {
              super(e, "suppressBanner");
            }
          }
          class Nn extends a.Option01 {
            constructor(he) {
              super(e, "tagged");
            }
          }
          class wn extends a.XFAObject {
            constructor(he) {
              super(e, "template", !0), this.base = null, this.relevant = null, this.startPage = null, this.uri = null, this.xsl = null;
            }
          }
          class On extends a.OptionObject {
            constructor(he) {
              super(e, "threshold", ["trace", "error", "information", "warning"]);
            }
          }
          class In extends a.OptionObject {
            constructor(he) {
              super(e, "to", ["null", "memory", "stderr", "stdout", "system", "uri"]);
            }
          }
          class xn extends a.XFAObject {
            constructor(he) {
              super(e, "templateCache"), this.maxEntries = (0, v.getInteger)({
                data: he.maxEntries,
                defaultValue: 5,
                validate: ($e) => $e >= 0
              });
            }
          }
          class dn extends a.XFAObject {
            constructor(he) {
              super(e, "trace", !0), this.area = new a.XFAObjectArray();
            }
          }
          class pn extends a.XFAObject {
            constructor(he) {
              super(e, "transform", !0), this.groupParent = null, this.ifEmpty = null, this.nameAttr = null, this.picture = null, this.presence = null, this.rename = null, this.whitespace = null;
            }
          }
          class sn extends a.OptionObject {
            constructor(he) {
              super(e, "type", ["none", "ascii85", "asciiHex", "ccittfax", "flate", "lzw", "runLength", "native", "xdp", "mergedXDP"]);
            }
          }
          class fn extends a.StringObject {
            constructor(he) {
              super(e, "uri");
            }
          }
          class Fn extends a.OptionObject {
            constructor(he) {
              super(e, "validate", ["preSubmit", "prePrint", "preExecute", "preSave"]);
            }
          }
          class Pn extends a.ContentObject {
            constructor(he) {
              super(e, "validateApprovalSignatures");
            }
            [a.$finalize]() {
              this[a.$content] = this[a.$content].trim().split(/\s+/).filter((he) => ["docReady", "postSign"].includes(he));
            }
          }
          class An extends a.OptionObject {
            constructor(he) {
              super(e, "validationMessaging", ["allMessagesIndividually", "allMessagesTogether", "firstMessageOnly", "noMessages"]);
            }
          }
          class jn extends a.OptionObject {
            constructor(he) {
              super(e, "version", ["1.7", "1.6", "1.5", "1.4", "1.3", "1.2"]);
            }
          }
          class Rn extends a.XFAObject {
            constructor(he) {
              super(e, "VersionControl"), this.outputBelow = (0, v.getStringOption)(he.outputBelow, ["warn", "error", "update"]), this.sourceAbove = (0, v.getStringOption)(he.sourceAbove, ["warn", "error"]), this.sourceBelow = (0, v.getStringOption)(he.sourceBelow, ["update", "maintain"]);
            }
          }
          class Un extends a.XFAObject {
            constructor(he) {
              super(e, "viewerPreferences", !0), this.ADBE_JSConsole = null, this.ADBE_JSDebugger = null, this.addViewerPreferences = null, this.duplexOption = null, this.enforce = null, this.numberOfCopies = null, this.pageRange = null, this.pickTrayByPDFSize = null, this.printScaling = null;
            }
          }
          class Mn extends a.XFAObject {
            constructor(he) {
              super(e, "webClient", !0), this.name = he.name ? he.name.trim() : "", this.fontInfo = null, this.xdc = null;
            }
          }
          class Dn extends a.OptionObject {
            constructor(he) {
              super(e, "whitespace", ["preserve", "ltrim", "normalize", "rtrim", "trim"]);
            }
          }
          class Sn extends a.ContentObject {
            constructor(he) {
              super(e, "window");
            }
            [a.$finalize]() {
              const he = this[a.$content].trim().split(/\s*,\s*/, 2).map(($e) => parseInt($e, 10));
              if (he.some(($e) => isNaN($e))) {
                this[a.$content] = [0, 0];
                return;
              }
              he.length === 1 && he.push(he[0]), this[a.$content] = he;
            }
          }
          class Bn extends a.XFAObject {
            constructor(he) {
              super(e, "xdc", !0), this.uri = new a.XFAObjectArray(), this.xsl = new a.XFAObjectArray();
            }
          }
          class bn extends a.XFAObject {
            constructor(he) {
              super(e, "xdp", !0), this.packets = null;
            }
          }
          class $n extends a.XFAObject {
            constructor(he) {
              super(e, "xsl", !0), this.debug = null, this.uri = null;
            }
          }
          class yn extends a.XFAObject {
            constructor(he) {
              super(e, "zpl", !0), this.name = he.name ? he.name.trim() : "", this.batchOutput = null, this.flipLabel = null, this.fontInfo = null, this.xdc = null;
            }
          }
          class He {
            static [t.$buildXFAObject](he, $e) {
              if (He.hasOwnProperty(he))
                return He[he]($e);
            }
            static acrobat(he) {
              return new y(he);
            }
            static acrobat7(he) {
              return new c(he);
            }
            static ADBE_JSConsole(he) {
              return new d(he);
            }
            static ADBE_JSDebugger(he) {
              return new m(he);
            }
            static addSilentPrint(he) {
              return new p(he);
            }
            static addViewerPreferences(he) {
              return new g(he);
            }
            static adjustData(he) {
              return new n(he);
            }
            static adobeExtensionLevel(he) {
              return new i(he);
            }
            static agent(he) {
              return new l(he);
            }
            static alwaysEmbed(he) {
              return new u(he);
            }
            static amd(he) {
              return new w(he);
            }
            static area(he) {
              return new O(he);
            }
            static attributes(he) {
              return new b(he);
            }
            static autoSave(he) {
              return new A(he);
            }
            static base(he) {
              return new Y(he);
            }
            static batchOutput(he) {
              return new j(he);
            }
            static behaviorOverride(he) {
              return new X(he);
            }
            static cache(he) {
              return new B(he);
            }
            static change(he) {
              return new U(he);
            }
            static common(he) {
              return new k(he);
            }
            static compress(he) {
              return new x(he);
            }
            static compressLogicalStructure(he) {
              return new f(he);
            }
            static compressObjectStream(he) {
              return new D(he);
            }
            static compression(he) {
              return new _(he);
            }
            static config(he) {
              return new S(he);
            }
            static conformance(he) {
              return new C(he);
            }
            static contentCopy(he) {
              return new T(he);
            }
            static copies(he) {
              return new P(he);
            }
            static creator(he) {
              return new M(he);
            }
            static currentPage(he) {
              return new G(he);
            }
            static data(he) {
              return new Z(he);
            }
            static debug(he) {
              return new $(he);
            }
            static defaultTypeface(he) {
              return new z(he);
            }
            static destination(he) {
              return new V(he);
            }
            static documentAssembly(he) {
              return new L(he);
            }
            static driver(he) {
              return new K(he);
            }
            static duplexOption(he) {
              return new ne(he);
            }
            static dynamicRender(he) {
              return new se(he);
            }
            static embed(he) {
              return new q(he);
            }
            static encrypt(he) {
              return new N(he);
            }
            static encryption(he) {
              return new Q(he);
            }
            static encryptionLevel(he) {
              return new E(he);
            }
            static enforce(he) {
              return new te(he);
            }
            static equate(he) {
              return new oe(he);
            }
            static equateRange(he) {
              return new ee(he);
            }
            static exclude(he) {
              return new W(he);
            }
            static excludeNS(he) {
              return new I(he);
            }
            static flipLabel(he) {
              return new H(he);
            }
            static fontInfo(he) {
              return new ie(he);
            }
            static formFieldFilling(he) {
              return new ue(he);
            }
            static groupParent(he) {
              return new fe(he);
            }
            static ifEmpty(he) {
              return new de(he);
            }
            static includeXDPContent(he) {
              return new pe(he);
            }
            static incrementalLoad(he) {
              return new xe(he);
            }
            static incrementalMerge(he) {
              return new Fe(he);
            }
            static interactive(he) {
              return new Se(he);
            }
            static jog(he) {
              return new Ce(he);
            }
            static labelPrinter(he) {
              return new ke(he);
            }
            static layout(he) {
              return new ye(he);
            }
            static level(he) {
              return new De(he);
            }
            static linearized(he) {
              return new Ae(he);
            }
            static locale(he) {
              return new Te(he);
            }
            static localeSet(he) {
              return new ve(he);
            }
            static log(he) {
              return new Ne(he);
            }
            static map(he) {
              return new Ge(he);
            }
            static mediumInfo(he) {
              return new it(he);
            }
            static message(he) {
              return new Me(he);
            }
            static messaging(he) {
              return new Ie(he);
            }
            static mode(he) {
              return new Ee(he);
            }
            static modifyAnnots(he) {
              return new st(he);
            }
            static msgId(he) {
              return new Qe(he);
            }
            static nameAttr(he) {
              return new ct(he);
            }
            static neverEmbed(he) {
              return new xt(he);
            }
            static numberOfCopies(he) {
              return new Je(he);
            }
            static openAction(he) {
              return new mt(he);
            }
            static output(he) {
              return new _t(he);
            }
            static outputBin(he) {
              return new Xe(he);
            }
            static outputXSL(he) {
              return new Ct(he);
            }
            static overprint(he) {
              return new bt(he);
            }
            static packets(he) {
              return new Pe(he);
            }
            static pageOffset(he) {
              return new qe(he);
            }
            static pageRange(he) {
              return new ot(he);
            }
            static pagination(he) {
              return new lt(he);
            }
            static paginationOverride(he) {
              return new Ut(he);
            }
            static part(he) {
              return new Nt(he);
            }
            static pcl(he) {
              return new Ve(he);
            }
            static pdf(he) {
              return new je(he);
            }
            static pdfa(he) {
              return new at(he);
            }
            static permissions(he) {
              return new nt(he);
            }
            static pickTrayByPDFSize(he) {
              return new ft(he);
            }
            static picture(he) {
              return new Tt(he);
            }
            static plaintextMetadata(he) {
              return new yt(he);
            }
            static presence(he) {
              return new dt(he);
            }
            static present(he) {
              return new wt(he);
            }
            static print(he) {
              return new Dt(he);
            }
            static printHighQuality(he) {
              return new jt(he);
            }
            static printScaling(he) {
              return new Bt(he);
            }
            static printerName(he) {
              return new kt(he);
            }
            static producer(he) {
              return new Ue(he);
            }
            static ps(he) {
              return new We(he);
            }
            static range(he) {
              return new rt(he);
            }
            static record(he) {
              return new tt(he);
            }
            static relevant(he) {
              return new St(he);
            }
            static rename(he) {
              return new Pt(he);
            }
            static renderPolicy(he) {
              return new qt(he);
            }
            static runScripts(he) {
              return new Mt(he);
            }
            static script(he) {
              return new Wt(he);
            }
            static scriptModel(he) {
              return new Zt(he);
            }
            static severity(he) {
              return new an(he);
            }
            static silentPrint(he) {
              return new un(he);
            }
            static staple(he) {
              return new Tn(he);
            }
            static startNode(he) {
              return new gn(he);
            }
            static startPage(he) {
              return new _n(he);
            }
            static submitFormat(he) {
              return new vn(he);
            }
            static submitUrl(he) {
              return new En(he);
            }
            static subsetBelow(he) {
              return new kn(he);
            }
            static suppressBanner(he) {
              return new Ln(he);
            }
            static tagged(he) {
              return new Nn(he);
            }
            static template(he) {
              return new wn(he);
            }
            static templateCache(he) {
              return new xn(he);
            }
            static threshold(he) {
              return new On(he);
            }
            static to(he) {
              return new In(he);
            }
            static trace(he) {
              return new dn(he);
            }
            static transform(he) {
              return new pn(he);
            }
            static type(he) {
              return new sn(he);
            }
            static uri(he) {
              return new fn(he);
            }
            static validate(he) {
              return new Fn(he);
            }
            static validateApprovalSignatures(he) {
              return new Pn(he);
            }
            static validationMessaging(he) {
              return new An(he);
            }
            static version(he) {
              return new jn(he);
            }
            static versionControl(he) {
              return new Rn(he);
            }
            static viewerPreferences(he) {
              return new Un(he);
            }
            static webClient(he) {
              return new Mn(he);
            }
            static whitespace(he) {
              return new Dn(he);
            }
            static window(he) {
              return new Sn(he);
            }
            static xdc(he) {
              return new Bn(he);
            }
            static xdp(he) {
              return new bn(he);
            }
            static xsl(he) {
              return new $n(he);
            }
            static zpl(he) {
              return new yn(he);
            }
          }
          o.ConfigNamespace = He;
        },
        /* 92 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.ConnectionSetNamespace = void 0;
          var t = F(79), a = F(77);
          const v = t.NamespaceIds.connectionSet.id;
          class h extends a.XFAObject {
            constructor(b) {
              super(v, "connectionSet", !0), this.wsdlConnection = new a.XFAObjectArray(), this.xmlConnection = new a.XFAObjectArray(), this.xsdConnection = new a.XFAObjectArray();
            }
          }
          class e extends a.XFAObject {
            constructor(b) {
              super(v, "effectiveInputPolicy"), this.id = b.id || "", this.name = b.name || "", this.use = b.use || "", this.usehref = b.usehref || "";
            }
          }
          class y extends a.XFAObject {
            constructor(b) {
              super(v, "effectiveOutputPolicy"), this.id = b.id || "", this.name = b.name || "", this.use = b.use || "", this.usehref = b.usehref || "";
            }
          }
          class c extends a.StringObject {
            constructor(b) {
              super(v, "operation"), this.id = b.id || "", this.input = b.input || "", this.name = b.name || "", this.output = b.output || "", this.use = b.use || "", this.usehref = b.usehref || "";
            }
          }
          class d extends a.StringObject {
            constructor(b) {
              super(v, "rootElement"), this.id = b.id || "", this.name = b.name || "", this.use = b.use || "", this.usehref = b.usehref || "";
            }
          }
          class m extends a.StringObject {
            constructor(b) {
              super(v, "soapAction"), this.id = b.id || "", this.name = b.name || "", this.use = b.use || "", this.usehref = b.usehref || "";
            }
          }
          class p extends a.StringObject {
            constructor(b) {
              super(v, "soapAddress"), this.id = b.id || "", this.name = b.name || "", this.use = b.use || "", this.usehref = b.usehref || "";
            }
          }
          class g extends a.StringObject {
            constructor(b) {
              super(v, "uri"), this.id = b.id || "", this.name = b.name || "", this.use = b.use || "", this.usehref = b.usehref || "";
            }
          }
          class n extends a.StringObject {
            constructor(b) {
              super(v, "wsdlAddress"), this.id = b.id || "", this.name = b.name || "", this.use = b.use || "", this.usehref = b.usehref || "";
            }
          }
          class i extends a.XFAObject {
            constructor(b) {
              super(v, "wsdlConnection", !0), this.dataDescription = b.dataDescription || "", this.name = b.name || "", this.effectiveInputPolicy = null, this.effectiveOutputPolicy = null, this.operation = null, this.soapAction = null, this.soapAddress = null, this.wsdlAddress = null;
            }
          }
          class l extends a.XFAObject {
            constructor(b) {
              super(v, "xmlConnection", !0), this.dataDescription = b.dataDescription || "", this.name = b.name || "", this.uri = null;
            }
          }
          class u extends a.XFAObject {
            constructor(b) {
              super(v, "xsdConnection", !0), this.dataDescription = b.dataDescription || "", this.name = b.name || "", this.rootElement = null, this.uri = null;
            }
          }
          class w {
            static [t.$buildXFAObject](b, A) {
              if (w.hasOwnProperty(b))
                return w[b](A);
            }
            static connectionSet(b) {
              return new h(b);
            }
            static effectiveInputPolicy(b) {
              return new e(b);
            }
            static effectiveOutputPolicy(b) {
              return new y(b);
            }
            static operation(b) {
              return new c(b);
            }
            static rootElement(b) {
              return new d(b);
            }
            static soapAction(b) {
              return new m(b);
            }
            static soapAddress(b) {
              return new p(b);
            }
            static uri(b) {
              return new g(b);
            }
            static wsdlAddress(b) {
              return new n(b);
            }
            static wsdlConnection(b) {
              return new i(b);
            }
            static xmlConnection(b) {
              return new l(b);
            }
            static xsdConnection(b) {
              return new u(b);
            }
          }
          o.ConnectionSetNamespace = w;
        },
        /* 93 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.DatasetsNamespace = void 0;
          var t = F(77), a = F(79);
          const v = a.NamespaceIds.datasets.id;
          class h extends t.XmlObject {
            constructor(d) {
              super(v, "data", d);
            }
            [t.$isNsAgnostic]() {
              return !0;
            }
          }
          class e extends t.XFAObject {
            constructor(d) {
              super(v, "datasets", !0), this.data = null, this.Signature = null;
            }
            [t.$onChild](d) {
              const m = d[t.$nodeName];
              (m === "data" && d[t.$namespaceId] === v || m === "Signature" && d[t.$namespaceId] === a.NamespaceIds.signature.id) && (this[m] = d), this[t.$appendChild](d);
            }
          }
          class y {
            static [a.$buildXFAObject](d, m) {
              if (y.hasOwnProperty(d))
                return y[d](m);
            }
            static datasets(d) {
              return new e(d);
            }
            static data(d) {
              return new h(d);
            }
          }
          o.DatasetsNamespace = y;
        },
        /* 94 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.LocaleSetNamespace = void 0;
          var t = F(79), a = F(77), v = F(78);
          const h = t.NamespaceIds.localeSet.id;
          class e extends a.XFAObject {
            constructor(C) {
              super(h, "calendarSymbols", !0), this.name = "gregorian", this.dayNames = new a.XFAObjectArray(2), this.eraNames = null, this.meridiemNames = null, this.monthNames = new a.XFAObjectArray(2);
            }
          }
          class y extends a.StringObject {
            constructor(C) {
              super(h, "currencySymbol"), this.name = (0, v.getStringOption)(C.name, ["symbol", "isoname", "decimal"]);
            }
          }
          class c extends a.XFAObject {
            constructor(C) {
              super(h, "currencySymbols", !0), this.currencySymbol = new a.XFAObjectArray(3);
            }
          }
          class d extends a.StringObject {
            constructor(C) {
              super(h, "datePattern"), this.name = (0, v.getStringOption)(C.name, ["full", "long", "med", "short"]);
            }
          }
          class m extends a.XFAObject {
            constructor(C) {
              super(h, "datePatterns", !0), this.datePattern = new a.XFAObjectArray(4);
            }
          }
          class p extends a.ContentObject {
            constructor(C) {
              super(h, "dateTimeSymbols");
            }
          }
          class g extends a.StringObject {
            constructor(C) {
              super(h, "day");
            }
          }
          class n extends a.XFAObject {
            constructor(C) {
              super(h, "dayNames", !0), this.abbr = (0, v.getInteger)({
                data: C.abbr,
                defaultValue: 0,
                validate: (T) => T === 1
              }), this.day = new a.XFAObjectArray(7);
            }
          }
          class i extends a.StringObject {
            constructor(C) {
              super(h, "era");
            }
          }
          class l extends a.XFAObject {
            constructor(C) {
              super(h, "eraNames", !0), this.era = new a.XFAObjectArray(2);
            }
          }
          class u extends a.XFAObject {
            constructor(C) {
              super(h, "locale", !0), this.desc = C.desc || "", this.name = "isoname", this.calendarSymbols = null, this.currencySymbols = null, this.datePatterns = null, this.dateTimeSymbols = null, this.numberPatterns = null, this.numberSymbols = null, this.timePatterns = null, this.typeFaces = null;
            }
          }
          class w extends a.XFAObject {
            constructor(C) {
              super(h, "localeSet", !0), this.locale = new a.XFAObjectArray();
            }
          }
          class O extends a.StringObject {
            constructor(C) {
              super(h, "meridiem");
            }
          }
          class b extends a.XFAObject {
            constructor(C) {
              super(h, "meridiemNames", !0), this.meridiem = new a.XFAObjectArray(2);
            }
          }
          class A extends a.StringObject {
            constructor(C) {
              super(h, "month");
            }
          }
          class Y extends a.XFAObject {
            constructor(C) {
              super(h, "monthNames", !0), this.abbr = (0, v.getInteger)({
                data: C.abbr,
                defaultValue: 0,
                validate: (T) => T === 1
              }), this.month = new a.XFAObjectArray(12);
            }
          }
          class j extends a.StringObject {
            constructor(C) {
              super(h, "numberPattern"), this.name = (0, v.getStringOption)(C.name, ["full", "long", "med", "short"]);
            }
          }
          class X extends a.XFAObject {
            constructor(C) {
              super(h, "numberPatterns", !0), this.numberPattern = new a.XFAObjectArray(4);
            }
          }
          class B extends a.StringObject {
            constructor(C) {
              super(h, "numberSymbol"), this.name = (0, v.getStringOption)(C.name, ["decimal", "grouping", "percent", "minus", "zero"]);
            }
          }
          class U extends a.XFAObject {
            constructor(C) {
              super(h, "numberSymbols", !0), this.numberSymbol = new a.XFAObjectArray(5);
            }
          }
          class k extends a.StringObject {
            constructor(C) {
              super(h, "timePattern"), this.name = (0, v.getStringOption)(C.name, ["full", "long", "med", "short"]);
            }
          }
          class x extends a.XFAObject {
            constructor(C) {
              super(h, "timePatterns", !0), this.timePattern = new a.XFAObjectArray(4);
            }
          }
          class f extends a.XFAObject {
            constructor(C) {
              super(h, "typeFace", !0), this.name = C.name | "";
            }
          }
          class D extends a.XFAObject {
            constructor(C) {
              super(h, "typeFaces", !0), this.typeFace = new a.XFAObjectArray();
            }
          }
          class _ {
            static [t.$buildXFAObject](C, T) {
              if (_.hasOwnProperty(C))
                return _[C](T);
            }
            static calendarSymbols(C) {
              return new e(C);
            }
            static currencySymbol(C) {
              return new y(C);
            }
            static currencySymbols(C) {
              return new c(C);
            }
            static datePattern(C) {
              return new d(C);
            }
            static datePatterns(C) {
              return new m(C);
            }
            static dateTimeSymbols(C) {
              return new p(C);
            }
            static day(C) {
              return new g(C);
            }
            static dayNames(C) {
              return new n(C);
            }
            static era(C) {
              return new i(C);
            }
            static eraNames(C) {
              return new l(C);
            }
            static locale(C) {
              return new u(C);
            }
            static localeSet(C) {
              return new w(C);
            }
            static meridiem(C) {
              return new O(C);
            }
            static meridiemNames(C) {
              return new b(C);
            }
            static month(C) {
              return new A(C);
            }
            static monthNames(C) {
              return new Y(C);
            }
            static numberPattern(C) {
              return new j(C);
            }
            static numberPatterns(C) {
              return new X(C);
            }
            static numberSymbol(C) {
              return new B(C);
            }
            static numberSymbols(C) {
              return new U(C);
            }
            static timePattern(C) {
              return new k(C);
            }
            static timePatterns(C) {
              return new x(C);
            }
            static typeFace(C) {
              return new f(C);
            }
            static typeFaces(C) {
              return new D(C);
            }
          }
          o.LocaleSetNamespace = _;
        },
        /* 95 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.SignatureNamespace = void 0;
          var t = F(79), a = F(77);
          const v = t.NamespaceIds.signature.id;
          class h extends a.XFAObject {
            constructor(c) {
              super(v, "signature", !0);
            }
          }
          class e {
            static [t.$buildXFAObject](c, d) {
              if (e.hasOwnProperty(c))
                return e[c](d);
            }
            static signature(c) {
              return new h(c);
            }
          }
          o.SignatureNamespace = e;
        },
        /* 96 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.StylesheetNamespace = void 0;
          var t = F(79), a = F(77);
          const v = t.NamespaceIds.stylesheet.id;
          class h extends a.XFAObject {
            constructor(c) {
              super(v, "stylesheet", !0);
            }
          }
          class e {
            static [t.$buildXFAObject](c, d) {
              if (e.hasOwnProperty(c))
                return e[c](d);
            }
            static stylesheet(c) {
              return new h(c);
            }
          }
          o.StylesheetNamespace = e;
        },
        /* 97 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.XdpNamespace = void 0;
          var t = F(79), a = F(77);
          const v = t.NamespaceIds.xdp.id;
          class h extends a.XFAObject {
            constructor(c) {
              super(v, "xdp", !0), this.uuid = c.uuid || "", this.timeStamp = c.timeStamp || "", this.config = null, this.connectionSet = null, this.datasets = null, this.localeSet = null, this.stylesheet = new a.XFAObjectArray(), this.template = null;
            }
            [a.$onChildCheck](c) {
              const d = t.NamespaceIds[c[a.$nodeName]];
              return d && c[a.$namespaceId] === d.id;
            }
          }
          class e {
            static [t.$buildXFAObject](c, d) {
              if (e.hasOwnProperty(c))
                return e[c](d);
            }
            static xdp(c) {
              return new h(c);
            }
          }
          o.XdpNamespace = e;
        },
        /* 98 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.XhtmlNamespace = void 0;
          var t = F(77), a = F(79), v = F(84), h = F(78);
          const e = a.NamespaceIds.xhtml.id, y = Symbol(), c = /* @__PURE__ */ new Set(["color", "font", "font-family", "font-size", "font-stretch", "font-style", "font-weight", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "letter-spacing", "line-height", "orphans", "page-break-after", "page-break-before", "page-break-inside", "tab-interval", "tab-stop", "text-align", "text-decoration", "text-indent", "vertical-align", "widows", "kerning-mode", "xfa-font-horizontal-scale", "xfa-font-vertical-scale", "xfa-spacerun", "xfa-tab-stops"]), d = /* @__PURE__ */ new Map([["page-break-after", "breakAfter"], ["page-break-before", "breakBefore"], ["page-break-inside", "breakInside"], ["kerning-mode", (S) => S === "none" ? "none" : "normal"], ["xfa-font-horizontal-scale", (S) => `scaleX(${Math.max(0, Math.min(parseInt(S) / 100)).toFixed(2)})`], ["xfa-font-vertical-scale", (S) => `scaleY(${Math.max(0, Math.min(parseInt(S) / 100)).toFixed(2)})`], ["xfa-spacerun", ""], ["xfa-tab-stops", ""], ["font-size", (S, C) => (S = C.fontSize = (0, h.getMeasurement)(S), (0, v.measureToString)(0.99 * S))], ["letter-spacing", (S) => (0, v.measureToString)((0, h.getMeasurement)(S))], ["line-height", (S) => (0, v.measureToString)((0, h.getMeasurement)(S))], ["margin", (S) => (0, v.measureToString)((0, h.getMeasurement)(S))], ["margin-bottom", (S) => (0, v.measureToString)((0, h.getMeasurement)(S))], ["margin-left", (S) => (0, v.measureToString)((0, h.getMeasurement)(S))], ["margin-right", (S) => (0, v.measureToString)((0, h.getMeasurement)(S))], ["margin-top", (S) => (0, v.measureToString)((0, h.getMeasurement)(S))], ["text-indent", (S) => (0, v.measureToString)((0, h.getMeasurement)(S))], ["font-family", (S) => S], ["vertical-align", (S) => (0, v.measureToString)((0, h.getMeasurement)(S))]]), m = /\s+/g, p = /[\r\n]+/g, g = /\r\n?/g;
          function n(S, C, T) {
            const P = /* @__PURE__ */ Object.create(null);
            if (!S)
              return P;
            const M = /* @__PURE__ */ Object.create(null);
            for (const [G, Z] of S.split(";").map(($) => $.split(":", 2))) {
              const $ = d.get(G);
              if ($ === "")
                continue;
              let z = Z;
              $ && (typeof $ == "string" ? z = $ : z = $(Z, M)), G.endsWith("scale") ? P.transform ? P.transform = `${P[G]} ${z}` : P.transform = z : P[G.replaceAll(/-([a-zA-Z])/g, (V, L) => L.toUpperCase())] = z;
            }
            if (P.fontFamily && (0, v.setFontFamily)({
              typeface: P.fontFamily,
              weight: P.fontWeight || "normal",
              posture: P.fontStyle || "normal",
              size: M.fontSize || 0
            }, C, C[t.$globalData].fontFinder, P), T && P.verticalAlign && P.verticalAlign !== "0px" && P.fontSize) {
              const $ = (0, h.getMeasurement)(P.fontSize);
              P.fontSize = (0, v.measureToString)($ * 0.583), P.verticalAlign = (0, v.measureToString)(Math.sign((0, h.getMeasurement)(P.verticalAlign)) * $ * 0.333);
            }
            return T && P.fontSize && (P.fontSize = `calc(${P.fontSize} * var(--scale-factor))`), (0, v.fixTextIndent)(P), P;
          }
          function i(S) {
            return S.style ? S.style.trim().split(/\s*;\s*/).filter((C) => !!C).map((C) => C.split(/\s*:\s*/, 2)).filter(([C, T]) => (C === "font-family" && S[t.$globalData].usedTypefaces.add(T), c.has(C))).map((C) => C.join(":")).join(";") : "";
          }
          const l = /* @__PURE__ */ new Set(["body", "html"]);
          class u extends t.XmlObject {
            constructor(C, T) {
              super(e, T), this[y] = !1, this.style = C.style || "";
            }
            [t.$clean](C) {
              super[t.$clean](C), this.style = i(this);
            }
            [t.$acceptWhitespace]() {
              return !l.has(this[t.$nodeName]);
            }
            [t.$onText](C, T = !1) {
              T ? this[y] = !0 : (C = C.replace(p, ""), this.style.includes("xfa-spacerun:yes") || (C = C.replace(m, " "))), C && (this[t.$content] += C);
            }
            [t.$pushGlyphs](C, T = !0) {
              const P = /* @__PURE__ */ Object.create(null), M = {
                top: NaN,
                bottom: NaN,
                left: NaN,
                right: NaN
              };
              let G = null;
              for (const [Z, $] of this.style.split(";").map((z) => z.split(":", 2)))
                switch (Z) {
                  case "font-family":
                    P.typeface = (0, h.stripQuotes)($);
                    break;
                  case "font-size":
                    P.size = (0, h.getMeasurement)($);
                    break;
                  case "font-weight":
                    P.weight = $;
                    break;
                  case "font-style":
                    P.posture = $;
                    break;
                  case "letter-spacing":
                    P.letterSpacing = (0, h.getMeasurement)($);
                    break;
                  case "margin":
                    const z = $.split(/ \t/).map((V) => (0, h.getMeasurement)(V));
                    switch (z.length) {
                      case 1:
                        M.top = M.bottom = M.left = M.right = z[0];
                        break;
                      case 2:
                        M.top = M.bottom = z[0], M.left = M.right = z[1];
                        break;
                      case 3:
                        M.top = z[0], M.bottom = z[2], M.left = M.right = z[1];
                        break;
                      case 4:
                        M.top = z[0], M.left = z[1], M.bottom = z[2], M.right = z[3];
                        break;
                    }
                    break;
                  case "margin-top":
                    M.top = (0, h.getMeasurement)($);
                    break;
                  case "margin-bottom":
                    M.bottom = (0, h.getMeasurement)($);
                    break;
                  case "margin-left":
                    M.left = (0, h.getMeasurement)($);
                    break;
                  case "margin-right":
                    M.right = (0, h.getMeasurement)($);
                    break;
                  case "line-height":
                    G = (0, h.getMeasurement)($);
                    break;
                }
              if (C.pushData(P, M, G), this[t.$content])
                C.addString(this[t.$content]);
              else
                for (const Z of this[t.$getChildren]()) {
                  if (Z[t.$nodeName] === "#text") {
                    C.addString(Z[t.$content]);
                    continue;
                  }
                  Z[t.$pushGlyphs](C);
                }
              T && C.popFont();
            }
            [t.$toHTML](C) {
              const T = [];
              if (this[t.$extra] = {
                children: T
              }, this[t.$childrenToHTML]({}), T.length === 0 && !this[t.$content])
                return h.HTMLResult.EMPTY;
              let P;
              return this[y] ? P = this[t.$content] ? this[t.$content].replace(g, `
`) : void 0 : P = this[t.$content] || void 0, h.HTMLResult.success({
                name: this[t.$nodeName],
                attributes: {
                  href: this.href,
                  style: n(this.style, this, this[y])
                },
                children: T,
                value: P
              });
            }
          }
          class w extends u {
            constructor(C) {
              super(C, "a"), this.href = (0, v.fixURL)(C.href) || "";
            }
          }
          class O extends u {
            constructor(C) {
              super(C, "b");
            }
            [t.$pushGlyphs](C) {
              C.pushFont({
                weight: "bold"
              }), super[t.$pushGlyphs](C), C.popFont();
            }
          }
          class b extends u {
            constructor(C) {
              super(C, "body");
            }
            [t.$toHTML](C) {
              const T = super[t.$toHTML](C), {
                html: P
              } = T;
              return P ? (P.name = "div", P.attributes.class = ["xfaRich"], T) : h.HTMLResult.EMPTY;
            }
          }
          class A extends u {
            constructor(C) {
              super(C, "br");
            }
            [t.$text]() {
              return `
`;
            }
            [t.$pushGlyphs](C) {
              C.addString(`
`);
            }
            [t.$toHTML](C) {
              return h.HTMLResult.success({
                name: "br"
              });
            }
          }
          class Y extends u {
            constructor(C) {
              super(C, "html");
            }
            [t.$toHTML](C) {
              const T = [];
              if (this[t.$extra] = {
                children: T
              }, this[t.$childrenToHTML]({}), T.length === 0)
                return h.HTMLResult.success({
                  name: "div",
                  attributes: {
                    class: ["xfaRich"],
                    style: {}
                  },
                  value: this[t.$content] || ""
                });
              if (T.length === 1) {
                const P = T[0];
                if (P.attributes && P.attributes.class.includes("xfaRich"))
                  return h.HTMLResult.success(P);
              }
              return h.HTMLResult.success({
                name: "div",
                attributes: {
                  class: ["xfaRich"],
                  style: {}
                },
                children: T
              });
            }
          }
          class j extends u {
            constructor(C) {
              super(C, "i");
            }
            [t.$pushGlyphs](C) {
              C.pushFont({
                posture: "italic"
              }), super[t.$pushGlyphs](C), C.popFont();
            }
          }
          class X extends u {
            constructor(C) {
              super(C, "li");
            }
          }
          class B extends u {
            constructor(C) {
              super(C, "ol");
            }
          }
          class U extends u {
            constructor(C) {
              super(C, "p");
            }
            [t.$pushGlyphs](C) {
              super[t.$pushGlyphs](C, !1), C.addString(`
`), C.addPara(), C.popFont();
            }
            [t.$text]() {
              return this[t.$getParent]()[t.$getChildren]().at(-1) === this ? super[t.$text]() : super[t.$text]() + `
`;
            }
          }
          class k extends u {
            constructor(C) {
              super(C, "span");
            }
          }
          class x extends u {
            constructor(C) {
              super(C, "sub");
            }
          }
          class f extends u {
            constructor(C) {
              super(C, "sup");
            }
          }
          class D extends u {
            constructor(C) {
              super(C, "ul");
            }
          }
          class _ {
            static [a.$buildXFAObject](C, T) {
              if (_.hasOwnProperty(C))
                return _[C](T);
            }
            static a(C) {
              return new w(C);
            }
            static b(C) {
              return new O(C);
            }
            static body(C) {
              return new b(C);
            }
            static br(C) {
              return new A(C);
            }
            static html(C) {
              return new Y(C);
            }
            static i(C) {
              return new j(C);
            }
            static li(C) {
              return new X(C);
            }
            static ol(C) {
              return new B(C);
            }
            static p(C) {
              return new U(C);
            }
            static span(C) {
              return new k(C);
            }
            static sub(C) {
              return new x(C);
            }
            static sup(C) {
              return new f(C);
            }
            static ul(C) {
              return new D(C);
            }
          }
          o.XhtmlNamespace = _;
        },
        /* 99 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.UnknownNamespace = void 0;
          var t = F(79), a = F(77);
          class v {
            constructor(e) {
              this.namespaceId = e;
            }
            [t.$buildXFAObject](e, y) {
              return new a.XmlObject(this.namespaceId, e, y);
            }
          }
          o.UnknownNamespace = v;
        },
        /* 100 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.DatasetReader = void 0;
          var t = F(2), a = F(6), v = F(66);
          function h(c) {
            try {
              return (0, t.stringToUTF8String)(c);
            } catch (d) {
              return (0, t.warn)(`UTF-8 decoding failed: "${d}".`), c;
            }
          }
          class e extends v.SimpleXMLParser {
            constructor(d) {
              super(d), this.node = null;
            }
            onEndElement(d) {
              const m = super.onEndElement(d);
              if (m && d === "xfa:datasets")
                throw this.node = m, new Error("Aborting DatasetXMLParser.");
            }
          }
          class y {
            constructor(d) {
              if (d.datasets)
                this.node = new v.SimpleXMLParser({
                  hasAttributes: !0
                }).parseFromString(d.datasets).documentElement;
              else {
                const m = new e({
                  hasAttributes: !0
                });
                try {
                  m.parseFromString(d["xdp:xdp"]);
                } catch {
                }
                this.node = m.node;
              }
            }
            getValue(d) {
              if (!this.node || !d)
                return "";
              const m = this.node.searchNode((0, a.parseXFAPath)(d), 0);
              if (!m)
                return "";
              const p = m.firstChild;
              return p && p.nodeName === "value" ? m.children.map((g) => h(g.textContent)) : h(m.textContent);
            }
          }
          o.DatasetReader = y;
        },
        /* 101 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.XRef = void 0;
          var t = F(2), a = F(5), v = F(6), h = F(17), e = F(7), y = F(67);
          class c {
            constructor(m, p) {
              this.stream = m, this.pdfManager = p, this.entries = [], this.xrefstms = /* @__PURE__ */ Object.create(null), this._cacheMap = /* @__PURE__ */ new Map(), this._pendingRefs = new a.RefSet(), this.stats = new v.DocStats(p.msgHandler), this._newRefNum = null;
            }
            getNewRef() {
              return this._newRefNum === null && (this._newRefNum = this.entries.length || 1), a.Ref.get(this._newRefNum++, 0);
            }
            resetNewRef() {
              this._newRefNum = null;
            }
            setStartXRef(m) {
              this.startXRefQueue = [m];
            }
            parse(m = !1) {
              let p;
              m ? ((0, t.warn)("Indexing all PDF objects"), p = this.indexObjects()) : p = this.readXRef(), p.assignXref(this), this.trailer = p;
              let g;
              try {
                g = p.get("Encrypt");
              } catch (i) {
                if (i instanceof v.MissingDataException)
                  throw i;
                (0, t.warn)(`XRef.parse - Invalid "Encrypt" reference: "${i}".`);
              }
              if (g instanceof a.Dict) {
                const i = p.get("ID"), l = i && i.length ? i[0] : "";
                g.suppressEncryption = !0, this.encrypt = new y.CipherTransformFactory(g, l, this.pdfManager.password);
              }
              let n;
              try {
                n = p.get("Root");
              } catch (i) {
                if (i instanceof v.MissingDataException)
                  throw i;
                (0, t.warn)(`XRef.parse - Invalid "Root" reference: "${i}".`);
              }
              if (n instanceof a.Dict)
                try {
                  if (n.get("Pages") instanceof a.Dict) {
                    this.root = n;
                    return;
                  }
                } catch (i) {
                  if (i instanceof v.MissingDataException)
                    throw i;
                  (0, t.warn)(`XRef.parse - Invalid "Pages" reference: "${i}".`);
                }
              throw m ? new t.InvalidPDFException("Invalid Root reference.") : new v.XRefParseException();
            }
            processXRefTable(m) {
              "tableState" in this || (this.tableState = {
                entryNum: 0,
                streamPos: m.lexer.stream.pos,
                parserBuf1: m.buf1,
                parserBuf2: m.buf2
              });
              const p = this.readXRefTable(m);
              if (!(0, a.isCmd)(p, "trailer"))
                throw new t.FormatError("Invalid XRef table: could not find trailer dictionary");
              let g = m.getObj();
              if (!(g instanceof a.Dict) && g.dict && (g = g.dict), !(g instanceof a.Dict))
                throw new t.FormatError("Invalid XRef table: could not parse trailer dictionary");
              return delete this.tableState, g;
            }
            readXRefTable(m) {
              const p = m.lexer.stream, g = this.tableState;
              p.pos = g.streamPos, m.buf1 = g.parserBuf1, m.buf2 = g.parserBuf2;
              let n;
              for (; ; ) {
                if (!("firstEntryNum" in g) || !("entryCount" in g)) {
                  if ((0, a.isCmd)(n = m.getObj(), "trailer"))
                    break;
                  g.firstEntryNum = n, g.entryCount = m.getObj();
                }
                let i = g.firstEntryNum;
                const l = g.entryCount;
                if (!Number.isInteger(i) || !Number.isInteger(l))
                  throw new t.FormatError("Invalid XRef table: wrong types in subsection header");
                for (let u = g.entryNum; u < l; u++) {
                  g.streamPos = p.pos, g.entryNum = u, g.parserBuf1 = m.buf1, g.parserBuf2 = m.buf2;
                  const w = {};
                  w.offset = m.getObj(), w.gen = m.getObj();
                  const O = m.getObj();
                  if (O instanceof a.Cmd)
                    switch (O.cmd) {
                      case "f":
                        w.free = !0;
                        break;
                      case "n":
                        w.uncompressed = !0;
                        break;
                    }
                  if (!Number.isInteger(w.offset) || !Number.isInteger(w.gen) || !(w.free || w.uncompressed))
                    throw new t.FormatError(`Invalid entry in XRef subsection: ${i}, ${l}`);
                  u === 0 && w.free && i === 1 && (i = 0), this.entries[u + i] || (this.entries[u + i] = w);
                }
                g.entryNum = 0, g.streamPos = p.pos, g.parserBuf1 = m.buf1, g.parserBuf2 = m.buf2, delete g.firstEntryNum, delete g.entryCount;
              }
              if (this.entries[0] && !this.entries[0].free)
                throw new t.FormatError("Invalid XRef table: unexpected first object");
              return n;
            }
            processXRefStream(m) {
              if (!("streamState" in this)) {
                const p = m.dict, g = p.get("W");
                let n = p.get("Index");
                n || (n = [0, p.get("Size")]), this.streamState = {
                  entryRanges: n,
                  byteWidths: g,
                  entryNum: 0,
                  streamPos: m.pos
                };
              }
              return this.readXRefStream(m), delete this.streamState, m.dict;
            }
            readXRefStream(m) {
              const p = this.streamState;
              m.pos = p.streamPos;
              const [g, n, i] = p.byteWidths, l = p.entryRanges;
              for (; l.length > 0; ) {
                const [u, w] = l;
                if (!Number.isInteger(u) || !Number.isInteger(w))
                  throw new t.FormatError(`Invalid XRef range fields: ${u}, ${w}`);
                if (!Number.isInteger(g) || !Number.isInteger(n) || !Number.isInteger(i))
                  throw new t.FormatError(`Invalid XRef entry fields length: ${u}, ${w}`);
                for (let O = p.entryNum; O < w; ++O) {
                  p.entryNum = O, p.streamPos = m.pos;
                  let b = 0, A = 0, Y = 0;
                  for (let X = 0; X < g; ++X) {
                    const B = m.getByte();
                    if (B === -1)
                      throw new t.FormatError("Invalid XRef byteWidths 'type'.");
                    b = b << 8 | B;
                  }
                  g === 0 && (b = 1);
                  for (let X = 0; X < n; ++X) {
                    const B = m.getByte();
                    if (B === -1)
                      throw new t.FormatError("Invalid XRef byteWidths 'offset'.");
                    A = A << 8 | B;
                  }
                  for (let X = 0; X < i; ++X) {
                    const B = m.getByte();
                    if (B === -1)
                      throw new t.FormatError("Invalid XRef byteWidths 'generation'.");
                    Y = Y << 8 | B;
                  }
                  const j = {};
                  switch (j.offset = A, j.gen = Y, b) {
                    case 0:
                      j.free = !0;
                      break;
                    case 1:
                      j.uncompressed = !0;
                      break;
                    case 2:
                      break;
                    default:
                      throw new t.FormatError(`Invalid XRef entry type: ${b}`);
                  }
                  this.entries[u + O] || (this.entries[u + O] = j);
                }
                p.entryNum = 0, p.streamPos = m.pos, l.splice(0, 2);
              }
            }
            indexObjects() {
              function u(T, P) {
                let M = "", G = T[P];
                for (; G !== 10 && G !== 13 && G !== 60 && !(++P >= T.length); )
                  M += String.fromCharCode(G), G = T[P];
                return M;
              }
              function w(T, P, M) {
                const G = M.length, Z = T.length;
                let $ = 0;
                for (; P < Z; ) {
                  let z = 0;
                  for (; z < G && T[P + z] === M[z]; )
                    ++z;
                  if (z >= G)
                    break;
                  P++, $++;
                }
                return $;
              }
              const O = /^(\d+)\s+(\d+)\s+obj\b/, b = /\bendobj[\b\s]$/, A = /\s+(\d+\s+\d+\s+obj[\b\s<])$/, Y = 25, j = new Uint8Array([116, 114, 97, 105, 108, 101, 114]), X = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]), B = new Uint8Array([111, 98, 106]), U = new Uint8Array([47, 88, 82, 101, 102]);
              this.entries.length = 0, this._cacheMap.clear();
              const k = this.stream;
              k.pos = 0;
              const x = k.getBytes(), f = x.length;
              let D = k.start;
              const _ = [], S = [];
              for (; D < f; ) {
                let T = x[D];
                if (T === 9 || T === 10 || T === 13 || T === 32) {
                  ++D;
                  continue;
                }
                if (T === 37) {
                  do {
                    if (++D, D >= f)
                      break;
                    T = x[D];
                  } while (T !== 10 && T !== 13);
                  continue;
                }
                const P = u(x, D);
                let M;
                if (P.startsWith("xref") && (P.length === 4 || /\s/.test(P[4])))
                  D += w(x, D, j), _.push(D), D += w(x, D, X);
                else if (M = O.exec(P)) {
                  const G = M[1] | 0, Z = M[2] | 0;
                  let $, z = D + P.length, V = !1;
                  if (!this.entries[G])
                    V = !0;
                  else if (this.entries[G].gen === Z)
                    try {
                      new h.Parser({
                        lexer: new h.Lexer(k.makeSubStream(z))
                      }).getObj(), V = !0;
                    } catch (ne) {
                      ne instanceof v.ParserEOFException ? (0, t.warn)(`indexObjects -- checking object (${P}): "${ne}".`) : V = !0;
                    }
                  for (V && (this.entries[G] = {
                    offset: D - k.start,
                    gen: Z,
                    uncompressed: !0
                  }); z < x.length; ) {
                    const ne = z + w(x, z, B) + 4;
                    $ = ne - D;
                    const se = Math.max(ne - Y, z), q = (0, t.bytesToString)(x.subarray(se, ne));
                    if (b.test(q))
                      break;
                    {
                      const N = A.exec(q);
                      if (N && N[1]) {
                        (0, t.warn)('indexObjects: Found new "obj" inside of another "obj", caused by missing "endobj" -- trying to recover.'), $ -= N[1].length;
                        break;
                      }
                    }
                    z = ne;
                  }
                  const L = x.subarray(D, D + $), K = w(L, 0, U);
                  K < $ && L[K + 5] < 64 && (S.push(D - k.start), this.xrefstms[D - k.start] = 1), D += $;
                } else
                  P.startsWith("trailer") && (P.length === 7 || /\s/.test(P[7])) ? (_.push(D), D += w(x, D, X)) : D += P.length + 1;
              }
              for (let T = 0, P = S.length; T < P; ++T)
                this.startXRefQueue.push(S[T]), this.readXRef(!0);
              let C;
              for (let T = 0, P = _.length; T < P; ++T) {
                k.pos = _[T];
                const M = new h.Parser({
                  lexer: new h.Lexer(k),
                  xref: this,
                  allowStreams: !0,
                  recoveryMode: !0
                }), G = M.getObj();
                if (!(0, a.isCmd)(G, "trailer"))
                  continue;
                const Z = M.getObj();
                if (Z instanceof a.Dict) {
                  try {
                    const $ = Z.get("Root");
                    if (!($ instanceof a.Dict))
                      continue;
                    const z = $.get("Pages");
                    if (!(z instanceof a.Dict))
                      continue;
                    const V = z.get("Count");
                    if (!Number.isInteger(V))
                      continue;
                  } catch {
                    continue;
                  }
                  if (Z.has("ID"))
                    return Z;
                  C = Z;
                }
              }
              if (C)
                return C;
              if (this.topDict)
                return this.topDict;
              throw new t.InvalidPDFException("Invalid PDF structure.");
            }
            readXRef(m = !1) {
              const p = this.stream, g = /* @__PURE__ */ new Set();
              try {
                for (; this.startXRefQueue.length; ) {
                  const n = this.startXRefQueue[0];
                  if (g.has(n)) {
                    (0, t.warn)("readXRef - skipping XRef table since it was already parsed."), this.startXRefQueue.shift();
                    continue;
                  }
                  g.add(n), p.pos = n + p.start;
                  const i = new h.Parser({
                    lexer: new h.Lexer(p),
                    xref: this,
                    allowStreams: !0
                  });
                  let l = i.getObj(), u;
                  if ((0, a.isCmd)(l, "xref")) {
                    if (u = this.processXRefTable(i), this.topDict || (this.topDict = u), l = u.get("XRefStm"), Number.isInteger(l)) {
                      const w = l;
                      w in this.xrefstms || (this.xrefstms[w] = 1, this.startXRefQueue.push(w));
                    }
                  } else if (Number.isInteger(l)) {
                    if (!Number.isInteger(i.getObj()) || !(0, a.isCmd)(i.getObj(), "obj") || !((l = i.getObj()) instanceof e.BaseStream))
                      throw new t.FormatError("Invalid XRef stream");
                    if (u = this.processXRefStream(l), this.topDict || (this.topDict = u), !u)
                      throw new t.FormatError("Failed to read XRef stream");
                  } else
                    throw new t.FormatError("Invalid XRef stream header");
                  l = u.get("Prev"), Number.isInteger(l) ? this.startXRefQueue.push(l) : l instanceof a.Ref && this.startXRefQueue.push(l.num), this.startXRefQueue.shift();
                }
                return this.topDict;
              } catch (n) {
                if (n instanceof v.MissingDataException)
                  throw n;
                (0, t.info)("(while reading XRef): " + n), this.startXRefQueue.shift();
              }
              if (!m)
                throw new v.XRefParseException();
            }
            getEntry(m) {
              const p = this.entries[m];
              return p && !p.free && p.offset ? p : null;
            }
            fetchIfRef(m, p = !1) {
              return m instanceof a.Ref ? this.fetch(m, p) : m;
            }
            fetch(m, p = !1) {
              if (!(m instanceof a.Ref))
                throw new Error("ref object is not a reference");
              const g = m.num, n = this._cacheMap.get(g);
              if (n !== void 0)
                return n instanceof a.Dict && !n.objId && (n.objId = m.toString()), n;
              let i = this.getEntry(g);
              if (i === null)
                return this._cacheMap.set(g, i), i;
              if (this._pendingRefs.has(m))
                return this._pendingRefs.remove(m), (0, t.warn)(`Ignoring circular reference: ${m}.`), a.CIRCULAR_REF;
              this._pendingRefs.put(m);
              try {
                i.uncompressed ? i = this.fetchUncompressed(m, i, p) : i = this.fetchCompressed(m, i, p), this._pendingRefs.remove(m);
              } catch (l) {
                throw this._pendingRefs.remove(m), l;
              }
              return i instanceof a.Dict ? i.objId = m.toString() : i instanceof e.BaseStream && (i.dict.objId = m.toString()), i;
            }
            fetchUncompressed(m, p, g = !1) {
              const n = m.gen;
              let i = m.num;
              if (p.gen !== n)
                throw new v.XRefEntryException(`Inconsistent generation in XRef: ${m}`);
              const l = this.stream.makeSubStream(p.offset + this.stream.start), u = new h.Parser({
                lexer: new h.Lexer(l),
                xref: this,
                allowStreams: !0
              }), w = u.getObj(), O = u.getObj(), b = u.getObj();
              if (w !== i || O !== n || !(b instanceof a.Cmd))
                throw new v.XRefEntryException(`Bad (uncompressed) XRef entry: ${m}`);
              if (b.cmd !== "obj") {
                if (b.cmd.startsWith("obj") && (i = parseInt(b.cmd.substring(3), 10), !Number.isNaN(i)))
                  return i;
                throw new v.XRefEntryException(`Bad (uncompressed) XRef entry: ${m}`);
              }
              return this.encrypt && !g ? p = u.getObj(this.encrypt.createCipherTransform(i, n)) : p = u.getObj(), p instanceof e.BaseStream || this._cacheMap.set(i, p), p;
            }
            fetchCompressed(m, p, g = !1) {
              const n = p.offset, i = this.fetch(a.Ref.get(n, 0));
              if (!(i instanceof e.BaseStream))
                throw new t.FormatError("bad ObjStm stream");
              const l = i.dict.get("First"), u = i.dict.get("N");
              if (!Number.isInteger(l) || !Number.isInteger(u))
                throw new t.FormatError("invalid first and n parameters for ObjStm stream");
              let w = new h.Parser({
                lexer: new h.Lexer(i),
                xref: this,
                allowStreams: !0
              });
              const O = new Array(u), b = new Array(u);
              for (let j = 0; j < u; ++j) {
                const X = w.getObj();
                if (!Number.isInteger(X))
                  throw new t.FormatError(`invalid object number in the ObjStm stream: ${X}`);
                const B = w.getObj();
                if (!Number.isInteger(B))
                  throw new t.FormatError(`invalid object offset in the ObjStm stream: ${B}`);
                O[j] = X, b[j] = B;
              }
              const A = (i.start || 0) + l, Y = new Array(u);
              for (let j = 0; j < u; ++j) {
                const X = j < u - 1 ? b[j + 1] - b[j] : void 0;
                if (X < 0)
                  throw new t.FormatError("Invalid offset in the ObjStm stream.");
                w = new h.Parser({
                  lexer: new h.Lexer(i.makeSubStream(A + b[j], X, i.dict)),
                  xref: this,
                  allowStreams: !0
                });
                const B = w.getObj();
                if (Y[j] = B, B instanceof e.BaseStream)
                  continue;
                const U = O[j], k = this.entries[U];
                k && k.offset === n && k.gen === j && this._cacheMap.set(U, B);
              }
              if (p = Y[p.gen], p === void 0)
                throw new v.XRefEntryException(`Bad (compressed) XRef entry: ${m}`);
              return p;
            }
            async fetchIfRefAsync(m, p) {
              return m instanceof a.Ref ? this.fetchAsync(m, p) : m;
            }
            async fetchAsync(m, p) {
              try {
                return this.fetch(m, p);
              } catch (g) {
                if (!(g instanceof v.MissingDataException))
                  throw g;
                return await this.pdfManager.requestRange(g.begin, g.end), this.fetchAsync(m, p);
              }
            }
            getCatalogObj() {
              return this.root;
            }
          }
          o.XRef = c;
        },
        /* 102 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.MessageHandler = void 0;
          var t = F(2);
          const a = {
            UNKNOWN: 0,
            DATA: 1,
            ERROR: 2
          }, v = {
            UNKNOWN: 0,
            CANCEL: 1,
            CANCEL_COMPLETE: 2,
            CLOSE: 3,
            ENQUEUE: 4,
            ERROR: 5,
            PULL: 6,
            PULL_COMPLETE: 7,
            START_COMPLETE: 8
          };
          function h(y) {
            switch (y instanceof Error || typeof y == "object" && y !== null || (0, t.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), y.name) {
              case "AbortException":
                return new t.AbortException(y.message);
              case "MissingPDFException":
                return new t.MissingPDFException(y.message);
              case "PasswordException":
                return new t.PasswordException(y.message, y.code);
              case "UnexpectedResponseException":
                return new t.UnexpectedResponseException(y.message, y.status);
              case "UnknownErrorException":
                return new t.UnknownErrorException(y.message, y.details);
              default:
                return new t.UnknownErrorException(y.message, y.toString());
            }
          }
          class e {
            constructor(c, d, m) {
              this.sourceName = c, this.targetName = d, this.comObj = m, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), this._onComObjOnMessage = (p) => {
                const g = p.data;
                if (g.targetName !== this.sourceName)
                  return;
                if (g.stream) {
                  this._processStreamMessage(g);
                  return;
                }
                if (g.callback) {
                  const i = g.callbackId, l = this.callbackCapabilities[i];
                  if (!l)
                    throw new Error(`Cannot resolve callback ${i}`);
                  if (delete this.callbackCapabilities[i], g.callback === a.DATA)
                    l.resolve(g.data);
                  else if (g.callback === a.ERROR)
                    l.reject(h(g.reason));
                  else
                    throw new Error("Unexpected callback case");
                  return;
                }
                const n = this.actionHandler[g.action];
                if (!n)
                  throw new Error(`Unknown action from worker: ${g.action}`);
                if (g.callbackId) {
                  const i = this.sourceName, l = g.sourceName;
                  new Promise(function(u) {
                    u(n(g.data));
                  }).then(function(u) {
                    m.postMessage({
                      sourceName: i,
                      targetName: l,
                      callback: a.DATA,
                      callbackId: g.callbackId,
                      data: u
                    });
                  }, function(u) {
                    m.postMessage({
                      sourceName: i,
                      targetName: l,
                      callback: a.ERROR,
                      callbackId: g.callbackId,
                      reason: h(u)
                    });
                  });
                  return;
                }
                if (g.streamId) {
                  this._createStreamSink(g);
                  return;
                }
                n(g.data);
              }, m.addEventListener("message", this._onComObjOnMessage);
            }
            on(c, d) {
              const m = this.actionHandler;
              if (m[c])
                throw new Error(`There is already an actionName called "${c}"`);
              m[c] = d;
            }
            send(c, d, m) {
              this.comObj.postMessage({
                sourceName: this.sourceName,
                targetName: this.targetName,
                action: c,
                data: d
              }, m);
            }
            sendWithPromise(c, d, m) {
              const p = this.callbackId++, g = (0, t.createPromiseCapability)();
              this.callbackCapabilities[p] = g;
              try {
                this.comObj.postMessage({
                  sourceName: this.sourceName,
                  targetName: this.targetName,
                  action: c,
                  callbackId: p,
                  data: d
                }, m);
              } catch (n) {
                g.reject(n);
              }
              return g.promise;
            }
            sendWithStream(c, d, m, p) {
              const g = this.streamId++, n = this.sourceName, i = this.targetName, l = this.comObj;
              return new ReadableStream({
                start: (u) => {
                  const w = (0, t.createPromiseCapability)();
                  return this.streamControllers[g] = {
                    controller: u,
                    startCall: w,
                    pullCall: null,
                    cancelCall: null,
                    isClosed: !1
                  }, l.postMessage({
                    sourceName: n,
                    targetName: i,
                    action: c,
                    streamId: g,
                    data: d,
                    desiredSize: u.desiredSize
                  }, p), w.promise;
                },
                pull: (u) => {
                  const w = (0, t.createPromiseCapability)();
                  return this.streamControllers[g].pullCall = w, l.postMessage({
                    sourceName: n,
                    targetName: i,
                    stream: v.PULL,
                    streamId: g,
                    desiredSize: u.desiredSize
                  }), w.promise;
                },
                cancel: (u) => {
                  (0, t.assert)(u instanceof Error, "cancel must have a valid reason");
                  const w = (0, t.createPromiseCapability)();
                  return this.streamControllers[g].cancelCall = w, this.streamControllers[g].isClosed = !0, l.postMessage({
                    sourceName: n,
                    targetName: i,
                    stream: v.CANCEL,
                    streamId: g,
                    reason: h(u)
                  }), w.promise;
                }
              }, m);
            }
            _createStreamSink(c) {
              const d = c.streamId, m = this.sourceName, p = c.sourceName, g = this.comObj, n = this, i = this.actionHandler[c.action], l = {
                enqueue(u, w = 1, O) {
                  if (this.isCancelled)
                    return;
                  const b = this.desiredSize;
                  this.desiredSize -= w, b > 0 && this.desiredSize <= 0 && (this.sinkCapability = (0, t.createPromiseCapability)(), this.ready = this.sinkCapability.promise), g.postMessage({
                    sourceName: m,
                    targetName: p,
                    stream: v.ENQUEUE,
                    streamId: d,
                    chunk: u
                  }, O);
                },
                close() {
                  this.isCancelled || (this.isCancelled = !0, g.postMessage({
                    sourceName: m,
                    targetName: p,
                    stream: v.CLOSE,
                    streamId: d
                  }), delete n.streamSinks[d]);
                },
                error(u) {
                  (0, t.assert)(u instanceof Error, "error must have a valid reason"), !this.isCancelled && (this.isCancelled = !0, g.postMessage({
                    sourceName: m,
                    targetName: p,
                    stream: v.ERROR,
                    streamId: d,
                    reason: h(u)
                  }));
                },
                sinkCapability: (0, t.createPromiseCapability)(),
                onPull: null,
                onCancel: null,
                isCancelled: !1,
                desiredSize: c.desiredSize,
                ready: null
              };
              l.sinkCapability.resolve(), l.ready = l.sinkCapability.promise, this.streamSinks[d] = l, new Promise(function(u) {
                u(i(c.data, l));
              }).then(function() {
                g.postMessage({
                  sourceName: m,
                  targetName: p,
                  stream: v.START_COMPLETE,
                  streamId: d,
                  success: !0
                });
              }, function(u) {
                g.postMessage({
                  sourceName: m,
                  targetName: p,
                  stream: v.START_COMPLETE,
                  streamId: d,
                  reason: h(u)
                });
              });
            }
            _processStreamMessage(c) {
              const d = c.streamId, m = this.sourceName, p = c.sourceName, g = this.comObj, n = this.streamControllers[d], i = this.streamSinks[d];
              switch (c.stream) {
                case v.START_COMPLETE:
                  c.success ? n.startCall.resolve() : n.startCall.reject(h(c.reason));
                  break;
                case v.PULL_COMPLETE:
                  c.success ? n.pullCall.resolve() : n.pullCall.reject(h(c.reason));
                  break;
                case v.PULL:
                  if (!i) {
                    g.postMessage({
                      sourceName: m,
                      targetName: p,
                      stream: v.PULL_COMPLETE,
                      streamId: d,
                      success: !0
                    });
                    break;
                  }
                  i.desiredSize <= 0 && c.desiredSize > 0 && i.sinkCapability.resolve(), i.desiredSize = c.desiredSize, new Promise(function(l) {
                    l(i.onPull && i.onPull());
                  }).then(function() {
                    g.postMessage({
                      sourceName: m,
                      targetName: p,
                      stream: v.PULL_COMPLETE,
                      streamId: d,
                      success: !0
                    });
                  }, function(l) {
                    g.postMessage({
                      sourceName: m,
                      targetName: p,
                      stream: v.PULL_COMPLETE,
                      streamId: d,
                      reason: h(l)
                    });
                  });
                  break;
                case v.ENQUEUE:
                  if ((0, t.assert)(n, "enqueue should have stream controller"), n.isClosed)
                    break;
                  n.controller.enqueue(c.chunk);
                  break;
                case v.CLOSE:
                  if ((0, t.assert)(n, "close should have stream controller"), n.isClosed)
                    break;
                  n.isClosed = !0, n.controller.close(), this._deleteStreamController(n, d);
                  break;
                case v.ERROR:
                  (0, t.assert)(n, "error should have stream controller"), n.controller.error(h(c.reason)), this._deleteStreamController(n, d);
                  break;
                case v.CANCEL_COMPLETE:
                  c.success ? n.cancelCall.resolve() : n.cancelCall.reject(h(c.reason)), this._deleteStreamController(n, d);
                  break;
                case v.CANCEL:
                  if (!i)
                    break;
                  new Promise(function(l) {
                    l(i.onCancel && i.onCancel(h(c.reason)));
                  }).then(function() {
                    g.postMessage({
                      sourceName: m,
                      targetName: p,
                      stream: v.CANCEL_COMPLETE,
                      streamId: d,
                      success: !0
                    });
                  }, function(l) {
                    g.postMessage({
                      sourceName: m,
                      targetName: p,
                      stream: v.CANCEL_COMPLETE,
                      streamId: d,
                      reason: h(l)
                    });
                  }), i.sinkCapability.reject(h(c.reason)), i.isCancelled = !0, delete this.streamSinks[d];
                  break;
                default:
                  throw new Error("Unexpected stream case");
              }
            }
            async _deleteStreamController(c, d) {
              await Promise.allSettled([c.startCall && c.startCall.promise, c.pullCall && c.pullCall.promise, c.cancelCall && c.cancelCall.promise]), delete this.streamControllers[d];
            }
            destroy() {
              this.comObj.removeEventListener("message", this._onComObjOnMessage);
            }
          }
          o.MessageHandler = e;
        },
        /* 103 */
        /***/
        (J, o, F) => {
          Object.defineProperty(o, "__esModule", {
            value: !0
          }), o.PDFWorkerStream = void 0;
          var t = F(2);
          class a {
            constructor(y) {
              this._msgHandler = y, this._contentLength = null, this._fullRequestReader = null, this._rangeRequestReaders = [];
            }
            getFullReader() {
              return (0, t.assert)(!this._fullRequestReader, "PDFWorkerStream.getFullReader can only be called once."), this._fullRequestReader = new v(this._msgHandler), this._fullRequestReader;
            }
            getRangeReader(y, c) {
              const d = new h(y, c, this._msgHandler);
              return this._rangeRequestReaders.push(d), d;
            }
            cancelAllRequests(y) {
              this._fullRequestReader && this._fullRequestReader.cancel(y);
              for (const c of this._rangeRequestReaders.slice(0))
                c.cancel(y);
            }
          }
          o.PDFWorkerStream = a;
          class v {
            constructor(y) {
              this._msgHandler = y, this.onProgress = null, this._contentLength = null, this._isRangeSupported = !1, this._isStreamingSupported = !1;
              const c = this._msgHandler.sendWithStream("GetReader");
              this._reader = c.getReader(), this._headersReady = this._msgHandler.sendWithPromise("ReaderHeadersReady").then((d) => {
                this._isStreamingSupported = d.isStreamingSupported, this._isRangeSupported = d.isRangeSupported, this._contentLength = d.contentLength;
              });
            }
            get headersReady() {
              return this._headersReady;
            }
            get contentLength() {
              return this._contentLength;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            get isRangeSupported() {
              return this._isRangeSupported;
            }
            async read() {
              const {
                value: y,
                done: c
              } = await this._reader.read();
              return c ? {
                value: void 0,
                done: !0
              } : {
                value: y.buffer,
                done: !1
              };
            }
            cancel(y) {
              this._reader.cancel(y);
            }
          }
          class h {
            constructor(y, c, d) {
              this._msgHandler = d, this.onProgress = null;
              const m = this._msgHandler.sendWithStream("GetRangeReader", {
                begin: y,
                end: c
              });
              this._reader = m.getReader();
            }
            get isStreamingSupported() {
              return !1;
            }
            async read() {
              const {
                value: y,
                done: c
              } = await this._reader.read();
              return c ? {
                value: void 0,
                done: !0
              } : {
                value: y.buffer,
                done: !1
              };
            }
            cancel(y) {
              this._reader.cancel(y);
            }
          }
        }
        /******/
      ], ce = {};
      function re(J) {
        var o = ce[J];
        if (o !== void 0)
          return o.exports;
        var F = ce[J] = {
          /******/
          // no module.id needed
          /******/
          // no module.loaded needed
          /******/
          exports: {}
          /******/
        };
        return le[J](F, F.exports, re), F.exports;
      }
      re.d = (J, o) => {
        for (var F in o)
          re.o(o, F) && !re.o(J, F) && Object.defineProperty(J, F, { enumerable: !0, get: o[F] });
      }, re.o = (J, o) => Object.prototype.hasOwnProperty.call(J, o), re.r = (J) => {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(J, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(J, "__esModule", { value: !0 });
      };
      var ae = {};
      return (() => {
        var J = ae;
        Object.defineProperty(J, "__esModule", {
          value: !0
        }), Object.defineProperty(J, "WorkerMessageHandler", {
          enumerable: !0,
          get: function() {
            return o.WorkerMessageHandler;
          }
        });
        var o = re(1);
      })(), ae;
    })()
  ));
})(pdf_worker);
(typeof window < "u" ? window : {}).pdfjsWorker = pdf_workerExports;
const wrapper$3 = "_wrapper_118zq_1", header = "_header_118zq_6", document$1 = "_document_118zq_10", button = "_button_118zq_16", thumbnail$1 = "_thumbnail_118zq_33", s$3 = {
  wrapper: wrapper$3,
  header,
  document: document$1,
  button,
  thumbnail: thumbnail$1
};
pdfExports.GlobalWorkerOptions.workerSrc = pdf_worker_entry.workerSrc;
const PDFViewer = ({ filePath: be, isThumbnail: ge }) => {
  const [le, ce] = reactExports.useState(1), [re, ae] = reactExports.useState(1), J = le > 1 && !ge;
  return /* @__PURE__ */ jsxs("div", { className: s$3.wrapper, children: [
    J && /* @__PURE__ */ jsxs("div", { children: [
      "Page ",
      re,
      " of ",
      le
    ] }),
    /* @__PURE__ */ jsxs(
      Document,
      {
        className: s$3.document,
        file: be,
        onLoadSuccess: ({ numPages: o }) => ce(o),
        children: [
          J && /* @__PURE__ */ jsx(
            "button",
            {
              className: s$3.button,
              onClick: () => ae(re - 1),
              disabled: re === 1,
              children: "Previous"
            }
          ),
          /* @__PURE__ */ jsx(
            Page$1,
            {
              className: `${ge ? s$3.thumbnail : ""}`,
              pageNumber: re,
              renderAnnotationLayer: !1,
              renderTextLayer: !1
            }
          ),
          J && /* @__PURE__ */ jsx(
            "button",
            {
              className: s$3.button,
              onClick: () => ae(re + 1),
              disabled: re === le,
              children: "Next"
            }
          )
        ]
      }
    )
  ] });
};
var mammoth_browserExports = {}, mammoth_browser = {
  get exports() {
    return mammoth_browserExports;
  },
  set exports(be) {
    mammoth_browserExports = be;
  }
};
(function(be, ge) {
  (function(le) {
    be.exports = le();
  })(function() {
    return function le(ce, re, ae) {
      function J(t, a) {
        if (!re[t]) {
          if (!ce[t]) {
            var v = typeof commonjsRequire == "function" && commonjsRequire;
            if (!a && v)
              return v(t, !0);
            if (o)
              return o(t, !0);
            var h = new Error("Cannot find module '" + t + "'");
            throw h.code = "MODULE_NOT_FOUND", h;
          }
          var e = re[t] = { exports: {} };
          ce[t][0].call(e.exports, function(y) {
            var c = ce[t][1][y];
            return J(c || y);
          }, e, e.exports, le, ce, re, ae);
        }
        return re[t].exports;
      }
      for (var o = typeof commonjsRequire == "function" && commonjsRequire, F = 0; F < ae.length; F++)
        J(ae[F]);
      return J;
    }({ 1: [function(le, ce, re) {
      var ae = le("../../lib/promises");
      re.Files = J;
      function J() {
        function o(F) {
          return ae.reject(new Error("could not open external image: '" + F + `'
cannot open linked files from a web browser`));
        }
        return {
          read: o
        };
      }
    }, { "../../lib/promises": 23 }], 2: [function(le, ce, re) {
      var ae = le("../lib/promises"), J = le("../lib/zipfile");
      re.openZip = o;
      function o(F) {
        return F.arrayBuffer ? ae.resolve(J.openArrayBuffer(F.arrayBuffer)) : ae.reject(new Error("Could not find file in options"));
      }
    }, { "../lib/promises": 23, "../lib/zipfile": 39 }], 3: [function(le, ce, re) {
      var ae = le("underscore"), J = le("./promises"), o = le("./documents"), F = le("./styles/html-paths"), t = le("./results"), a = le("./images"), v = le("./html"), h = le("./writers");
      re.DocumentConverter = e;
      function e(i) {
        return {
          convertToHtml: function(l) {
            var u = ae.indexBy(
              l.type === o.types.document ? l.comments : [],
              "commentId"
            ), w = new y(i, u);
            return w.convertToHtml(l);
          }
        };
      }
      function y(i, l) {
        var u = 1, w = [], O = [];
        i = ae.extend({ ignoreEmptyParagraphs: !0 }, i);
        var b = i.idPrefix === void 0 ? "" : i.idPrefix, A = i.ignoreEmptyParagraphs, Y = F.topLevelElement("p"), j = i.styleMap || [];
        function X(E) {
          var te = [], oe = U(E, te, {}), ee = [];
          g(oe, function(I) {
            I.type === "deferred" && ee.push(I);
          });
          var W = {};
          return J.mapSeries(ee, function(I) {
            return I.value().then(function(H) {
              W[I.id] = H;
            });
          }).then(function() {
            function I(ie) {
              return p(ie, function(ue) {
                return ue.type === "deferred" ? W[ue.id] : ue.children ? [
                  ae.extend({}, ue, {
                    children: I(ue.children)
                  })
                ] : [ue];
              });
            }
            var H = h.writer({
              prettyPrint: i.prettyPrint,
              outputFormat: i.outputFormat
            });
            return v.write(H, v.simplify(I(oe))), new t.Result(H.asString(), te);
          });
        }
        function B(E, te, oe) {
          return p(E, function(ee) {
            return U(ee, te, oe);
          });
        }
        function U(E, te, oe) {
          if (!oe)
            throw new Error("options not set");
          var ee = Q[E.type];
          return ee ? ee(E, te, oe) : [];
        }
        function k(E, te, oe) {
          return x(E, te).wrap(function() {
            var ee = B(E.children, te, oe);
            return A ? ee : [v.forceWrite].concat(ee);
          });
        }
        function x(E, te) {
          var oe = S(E);
          return oe ? oe.to : (E.styleId && te.push(m("paragraph", E)), Y);
        }
        function f(E, te, oe) {
          var ee = function() {
            return B(E.children, te, oe);
          }, W = [];
          E.isSmallCaps && W.push(D("smallCaps")), E.isAllCaps && W.push(D("allCaps")), E.isStrikethrough && W.push(D("strikethrough", "s")), E.isUnderline && W.push(D("underline")), E.verticalAlignment === o.verticalAlignment.subscript && W.push(F.element("sub", {}, { fresh: !1 })), E.verticalAlignment === o.verticalAlignment.superscript && W.push(F.element("sup", {}, { fresh: !1 })), E.isItalic && W.push(D("italic", "em")), E.isBold && W.push(D("bold", "strong"));
          var I = F.empty, H = S(E);
          return H ? I = H.to : E.styleId && te.push(m("run", E)), W.push(I), W.forEach(function(ie) {
            ee = ie.wrap.bind(ie, ee);
          }), ee();
        }
        function D(E, te) {
          var oe = _({ type: E });
          return oe || (te ? F.element(te, {}, { fresh: !1 }) : F.empty);
        }
        function _(E, te) {
          var oe = S(E);
          return oe ? oe.to : te;
        }
        function S(E) {
          for (var te = 0; te < j.length; te++)
            if (j[te].from.matches(E))
              return j[te];
        }
        function C(E) {
          return function(te, oe) {
            return J.attempt(function() {
              return E(te, oe);
            }).caught(function(ee) {
              return oe.push(t.error(ee)), [];
            });
          };
        }
        function T(E) {
          return M(E.noteType, E.noteId);
        }
        function P(E) {
          return G(E.noteType, E.noteId);
        }
        function M(E, te) {
          return Z(E + "-" + te);
        }
        function G(E, te) {
          return Z(E + "-ref-" + te);
        }
        function Z(E) {
          return b + E;
        }
        var $ = F.elements([
          F.element("table", {}, { fresh: !0 })
        ]);
        function z(E, te, oe) {
          return _(E, $).wrap(function() {
            return V(E, te, oe);
          });
        }
        function V(E, te, oe) {
          var ee = ae.findIndex(E.children, function(ie) {
            return !ie.type === o.types.tableRow || !ie.isHeader;
          });
          ee === -1 && (ee = E.children.length);
          var W;
          if (ee === 0)
            W = B(
              E.children,
              te,
              ae.extend({}, oe, { isTableHeader: !1 })
            );
          else {
            var I = B(
              E.children.slice(0, ee),
              te,
              ae.extend({}, oe, { isTableHeader: !0 })
            ), H = B(
              E.children.slice(ee),
              te,
              ae.extend({}, oe, { isTableHeader: !1 })
            );
            W = [
              v.freshElement("thead", {}, I),
              v.freshElement("tbody", {}, H)
            ];
          }
          return [v.forceWrite].concat(W);
        }
        function L(E, te, oe) {
          var ee = B(E.children, te, oe);
          return [
            v.freshElement("tr", {}, [v.forceWrite].concat(ee))
          ];
        }
        function K(E, te, oe) {
          var ee = oe.isTableHeader ? "th" : "td", W = B(E.children, te, oe), I = {};
          return E.colSpan !== 1 && (I.colspan = E.colSpan.toString()), E.rowSpan !== 1 && (I.rowspan = E.rowSpan.toString()), [
            v.freshElement(ee, I, [v.forceWrite].concat(W))
          ];
        }
        function ne(E, te, oe) {
          return _(E, F.ignore).wrap(function() {
            var ee = l[E.commentId], W = O.length + 1, I = "[" + n(ee) + W + "]";
            return O.push({ label: I, comment: ee }), [
              v.freshElement("a", {
                href: "#" + M("comment", E.commentId),
                id: G("comment", E.commentId)
              }, [v.text(I)])
            ];
          });
        }
        function se(E, te, oe) {
          var ee = E.label, W = E.comment, I = B(W.body, te, oe).concat([
            v.nonFreshElement("p", {}, [
              v.text(" "),
              v.freshElement("a", { href: "#" + G("comment", W.commentId) }, [
                v.text("↑")
              ])
            ])
          ]);
          return [
            v.freshElement(
              "dt",
              { id: M("comment", W.commentId) },
              [v.text("Comment " + ee)]
            ),
            v.freshElement("dd", {}, I)
          ];
        }
        function q(E, te, oe) {
          return N(E).wrap(function() {
            return [];
          });
        }
        function N(E) {
          var te = S(E);
          return te ? te.to : E.breakType === "line" ? F.topLevelElement("br") : F.empty;
        }
        var Q = {
          document: function(E, te, oe) {
            var ee = B(E.children, te, oe), W = w.map(function(H) {
              return E.notes.resolve(H);
            }), I = B(W, te, oe);
            return ee.concat([
              v.freshElement("ol", {}, I),
              v.freshElement("dl", {}, p(O, function(H) {
                return se(H, te, oe);
              }))
            ]);
          },
          paragraph: k,
          run: f,
          text: function(E, te, oe) {
            return [v.text(E.value)];
          },
          tab: function(E, te, oe) {
            return [v.text("	")];
          },
          hyperlink: function(E, te, oe) {
            var ee = E.anchor ? "#" + Z(E.anchor) : E.href, W = { href: ee };
            E.targetFrame != null && (W.target = E.targetFrame);
            var I = B(E.children, te, oe);
            return [v.nonFreshElement("a", W, I)];
          },
          bookmarkStart: function(E, te, oe) {
            var ee = v.freshElement("a", {
              id: Z(E.name)
            }, [v.forceWrite]);
            return [ee];
          },
          noteReference: function(E, te, oe) {
            w.push(E);
            var ee = v.freshElement("a", {
              href: "#" + T(E),
              id: P(E)
            }, [v.text("[" + u++ + "]")]);
            return [v.freshElement("sup", {}, [ee])];
          },
          note: function(E, te, oe) {
            var ee = B(E.body, te, oe), W = v.elementWithTag(F.element("p", {}, { fresh: !1 }), [
              v.text(" "),
              v.freshElement("a", { href: "#" + P(E) }, [v.text("↑")])
            ]), I = ee.concat([W]);
            return v.freshElement("li", { id: T(E) }, I);
          },
          commentReference: ne,
          comment: se,
          image: d(C(i.convertImage || a.dataUri)),
          table: z,
          tableRow: L,
          tableCell: K,
          break: q
        };
        return {
          convertToHtml: X
        };
      }
      var c = 1;
      function d(i) {
        return function(l, u, w) {
          return [
            {
              type: "deferred",
              id: c++,
              value: function() {
                return i(l, u, w);
              }
            }
          ];
        };
      }
      function m(i, l) {
        return t.warning(
          "Unrecognised " + i + " style: '" + l.styleName + "' (Style ID: " + l.styleId + ")"
        );
      }
      function p(i, l) {
        return ae.flatten(i.map(l), !0);
      }
      function g(i, l) {
        i.forEach(function(u) {
          l(u), u.children && g(u.children, l);
        });
      }
      var n = re.commentAuthorLabel = function(l) {
        return l.authorInitials || "";
      };
    }, { "./documents": 4, "./html": 18, "./images": 20, "./promises": 23, "./results": 25, "./styles/html-paths": 28, "./writers": 33, underscore: 117 }], 4: [function(le, ce, re) {
      var ae = le("underscore"), J = re.types = {
        document: "document",
        paragraph: "paragraph",
        run: "run",
        text: "text",
        tab: "tab",
        hyperlink: "hyperlink",
        noteReference: "noteReference",
        image: "image",
        note: "note",
        commentReference: "commentReference",
        comment: "comment",
        table: "table",
        tableRow: "tableRow",
        tableCell: "tableCell",
        break: "break",
        bookmarkStart: "bookmarkStart"
      };
      function o(b, A) {
        return A = A || {}, {
          type: J.document,
          children: b,
          notes: A.notes || new c({}),
          comments: A.comments || []
        };
      }
      function F(b, A) {
        A = A || {};
        var Y = A.indent || {};
        return {
          type: J.paragraph,
          children: b,
          styleId: A.styleId || null,
          styleName: A.styleName || null,
          numbering: A.numbering || null,
          alignment: A.alignment || null,
          indent: {
            start: Y.start || null,
            end: Y.end || null,
            firstLine: Y.firstLine || null,
            hanging: Y.hanging || null
          }
        };
      }
      function t(b, A) {
        return A = A || {}, {
          type: J.run,
          children: b,
          styleId: A.styleId || null,
          styleName: A.styleName || null,
          isBold: A.isBold,
          isUnderline: A.isUnderline,
          isItalic: A.isItalic,
          isStrikethrough: A.isStrikethrough,
          isAllCaps: A.isAllCaps,
          isSmallCaps: A.isSmallCaps,
          verticalAlignment: A.verticalAlignment || a.baseline,
          font: A.font || null,
          fontSize: A.fontSize || null
        };
      }
      var a = {
        baseline: "baseline",
        superscript: "superscript",
        subscript: "subscript"
      };
      function v(b) {
        return {
          type: J.text,
          value: b
        };
      }
      function h() {
        return {
          type: J.tab
        };
      }
      function e(b, A) {
        return {
          type: J.hyperlink,
          children: b,
          href: A.href,
          anchor: A.anchor,
          targetFrame: A.targetFrame
        };
      }
      function y(b) {
        return {
          type: J.noteReference,
          noteType: b.noteType,
          noteId: b.noteId
        };
      }
      function c(b) {
        this._notes = ae.indexBy(b, function(A) {
          return g(A.noteType, A.noteId);
        });
      }
      c.prototype.resolve = function(b) {
        return this.findNoteByKey(g(b.noteType, b.noteId));
      }, c.prototype.findNoteByKey = function(b) {
        return this._notes[b] || null;
      };
      function d(b) {
        return {
          type: J.note,
          noteType: b.noteType,
          noteId: b.noteId,
          body: b.body
        };
      }
      function m(b) {
        return {
          type: J.commentReference,
          commentId: b.commentId
        };
      }
      function p(b) {
        return {
          type: J.comment,
          commentId: b.commentId,
          body: b.body,
          authorName: b.authorName,
          authorInitials: b.authorInitials
        };
      }
      function g(b, A) {
        return b + "-" + A;
      }
      function n(b) {
        return {
          type: J.image,
          read: b.readImage,
          altText: b.altText,
          contentType: b.contentType
        };
      }
      function i(b, A) {
        return A = A || {}, {
          type: J.table,
          children: b,
          styleId: A.styleId || null,
          styleName: A.styleName || null
        };
      }
      function l(b, A) {
        return A = A || {}, {
          type: J.tableRow,
          children: b,
          isHeader: A.isHeader || !1
        };
      }
      function u(b, A) {
        return A = A || {}, {
          type: J.tableCell,
          children: b,
          colSpan: A.colSpan == null ? 1 : A.colSpan,
          rowSpan: A.rowSpan == null ? 1 : A.rowSpan
        };
      }
      function w(b) {
        return {
          type: J.break,
          breakType: b
        };
      }
      function O(b) {
        return {
          type: J.bookmarkStart,
          name: b.name
        };
      }
      re.document = re.Document = o, re.paragraph = re.Paragraph = F, re.run = re.Run = t, re.Text = v, re.tab = re.Tab = h, re.Hyperlink = e, re.noteReference = re.NoteReference = y, re.Notes = c, re.Note = d, re.commentReference = m, re.comment = p, re.Image = n, re.Table = i, re.TableRow = l, re.TableCell = u, re.lineBreak = w("line"), re.pageBreak = w("page"), re.columnBreak = w("column"), re.BookmarkStart = O, re.verticalAlignment = a;
    }, { underscore: 117 }], 5: [function(le, ce, re) {
      re.createBodyReader = v, re._readNumberingProperties = e;
      var ae = le("dingbat-to-unicode"), J = le("underscore"), o = le("../documents"), F = le("../results").Result, t = le("../results").warning, a = le("./uris");
      function v(A) {
        return {
          readXmlElement: function(Y) {
            return new h(A).readXmlElement(Y);
          },
          readXmlElements: function(Y) {
            return new h(A).readXmlElements(Y);
          }
        };
      }
      function h(A) {
        var Y = [], j = [], X = A.relationships, B = A.contentTypes, U = A.docxFile, k = A.files, x = A.numbering, f = A.styles;
        function D(Ce) {
          var ke = Ce.map(_);
          return w(ke);
        }
        function _(Ce) {
          if (Ce.type === "element") {
            var ke = E[Ce.name];
            if (ke)
              return ke(Ce);
            if (!Object.prototype.hasOwnProperty.call(c, Ce.name)) {
              var ye = t("An unrecognised element was ignored: " + Ce.name);
              return g([ye]);
            }
          }
          return n();
        }
        function S(Ce) {
          return {
            start: Ce.attributes["w:start"] || Ce.attributes["w:left"],
            end: Ce.attributes["w:end"] || Ce.attributes["w:right"],
            firstLine: Ce.attributes["w:firstLine"],
            hanging: Ce.attributes["w:hanging"]
          };
        }
        function C(Ce) {
          return G(Ce).map(function(ke) {
            var ye = Ce.firstOrEmpty("w:sz").attributes["w:val"], De = /^[0-9]+$/.test(ye) ? parseInt(ye, 10) / 2 : null;
            return {
              type: "runProperties",
              styleId: ke.styleId,
              styleName: ke.name,
              verticalAlignment: Ce.firstOrEmpty("w:vertAlign").attributes["w:val"],
              font: Ce.firstOrEmpty("w:rFonts").attributes["w:ascii"],
              fontSize: De,
              isBold: P(Ce.first("w:b")),
              isUnderline: T(Ce.first("w:u")),
              isItalic: P(Ce.first("w:i")),
              isStrikethrough: P(Ce.first("w:strike")),
              isAllCaps: P(Ce.first("w:caps")),
              isSmallCaps: P(Ce.first("w:smallCaps"))
            };
          });
        }
        function T(Ce) {
          if (Ce) {
            var ke = Ce.attributes["w:val"];
            return ke !== void 0 && ke !== "false" && ke !== "0" && ke !== "none";
          } else
            return !1;
        }
        function P(Ce) {
          if (Ce) {
            var ke = Ce.attributes["w:val"];
            return ke !== "false" && ke !== "0";
          } else
            return !1;
        }
        function M(Ce) {
          return $(Ce, "w:pStyle", "Paragraph", f.findParagraphStyleById);
        }
        function G(Ce) {
          return $(Ce, "w:rStyle", "Run", f.findCharacterStyleById);
        }
        function Z(Ce) {
          return $(Ce, "w:tblStyle", "Table", f.findTableStyleById);
        }
        function $(Ce, ke, ye, De) {
          var Ae = [], Te = Ce.first(ke), ve = null, Ne = null;
          if (Te && (ve = Te.attributes["w:val"], ve)) {
            var Ge = De(ve);
            Ge ? Ne = Ge.name : Ae.push(Se(ye, ve));
          }
          return l({ styleId: ve, name: Ne }, Ae);
        }
        var z = { type: "unknown" };
        function V(Ce) {
          var ke = Ce.attributes["w:fldCharType"];
          if (ke === "begin")
            Y.push(z), j = [];
          else if (ke === "end")
            Y.pop();
          else if (ke === "separate") {
            var ye = K(j.join("")), De = ye === null ? z : { type: "hyperlink", options: ye };
            Y.pop(), Y.push(De);
          }
          return n();
        }
        function L() {
          var Ce = J.last(Y.filter(function(ke) {
            return ke.type === "hyperlink";
          }));
          return Ce ? Ce.options : null;
        }
        function K(Ce) {
          var ke = /\s*HYPERLINK "(.*)"/.exec(Ce);
          if (ke)
            return { href: ke[1] };
          var ye = /\s*HYPERLINK\s+\\l\s+"(.*)"/.exec(Ce);
          return ye ? { anchor: ye[1] } : null;
        }
        function ne(Ce) {
          return j.push(Ce.text()), n();
        }
        function se(Ce) {
          var ke = Ce.attributes["w:font"], ye = Ce.attributes["w:char"], De = ae.hex(ke, ye);
          return De == null && /^F0..$/.test(ye) && (De = ae.hex(ke, ye.substring(2))), De == null ? g([t(
            "A w:sym element with an unsupported character was ignored: char " + ye + " in font " + ke
          )]) : i(new o.Text(De.string));
        }
        function q(Ce) {
          return function(ke) {
            var ye = ke.attributes["w:id"];
            return i(new o.NoteReference({
              noteType: Ce,
              noteId: ye
            }));
          };
        }
        function N(Ce) {
          return i(o.commentReference({
            commentId: Ce.attributes["w:id"]
          }));
        }
        function Q(Ce) {
          return D(Ce.children);
        }
        var E = {
          "w:p": function(Ce) {
            return D(Ce.children).map(function(ke) {
              var ye = J.find(ke, d);
              return new o.Paragraph(
                ke.filter(p(d)),
                ye
              );
            }).insertExtra();
          },
          "w:pPr": function(Ce) {
            return M(Ce).map(function(ke) {
              return {
                type: "paragraphProperties",
                styleId: ke.styleId,
                styleName: ke.name,
                alignment: Ce.firstOrEmpty("w:jc").attributes["w:val"],
                numbering: e(ke.styleId, Ce.firstOrEmpty("w:numPr"), x),
                indent: S(Ce.firstOrEmpty("w:ind"))
              };
            });
          },
          "w:r": function(Ce) {
            return D(Ce.children).map(function(ke) {
              var ye = J.find(ke, m);
              ke = ke.filter(p(m));
              var De = L();
              return De !== null && (ke = [new o.Hyperlink(ke, De)]), new o.Run(ke, ye);
            });
          },
          "w:rPr": C,
          "w:fldChar": V,
          "w:instrText": ne,
          "w:t": function(Ce) {
            return i(new o.Text(Ce.text()));
          },
          "w:tab": function(Ce) {
            return i(new o.Tab());
          },
          "w:noBreakHyphen": function() {
            return i(new o.Text("‑"));
          },
          "w:softHyphen": function(Ce) {
            return i(new o.Text("­"));
          },
          "w:sym": se,
          "w:hyperlink": function(Ce) {
            var ke = Ce.attributes["r:id"], ye = Ce.attributes["w:anchor"];
            return D(Ce.children).map(function(De) {
              function Ae(ve) {
                var Ne = Ce.attributes["w:tgtFrame"] || null;
                return new o.Hyperlink(
                  De,
                  J.extend({ targetFrame: Ne }, ve)
                );
              }
              if (ke) {
                var Te = X.findTargetByRelationshipId(ke);
                return ye && (Te = a.replaceFragment(Te, ye)), Ae({ href: Te });
              } else
                return ye ? Ae({ anchor: ye }) : De;
            });
          },
          "w:tbl": te,
          "w:tr": ee,
          "w:tc": W,
          "w:footnoteReference": q("footnote"),
          "w:endnoteReference": q("endnote"),
          "w:commentReference": N,
          "w:br": function(Ce) {
            var ke = Ce.attributes["w:type"];
            return ke == null || ke === "textWrapping" ? i(o.lineBreak) : ke === "page" ? i(o.pageBreak) : ke === "column" ? i(o.columnBreak) : g([t("Unsupported break type: " + ke)]);
          },
          "w:bookmarkStart": function(Ce) {
            var ke = Ce.attributes["w:name"];
            return ke === "_GoBack" ? n() : i(new o.BookmarkStart({ name: ke }));
          },
          "mc:AlternateContent": function(Ce) {
            return Q(Ce.first("mc:Fallback"));
          },
          "w:sdt": function(Ce) {
            return D(Ce.firstOrEmpty("w:sdtContent").children);
          },
          "w:ins": Q,
          "w:object": Q,
          "w:smartTag": Q,
          "w:drawing": Q,
          "w:pict": function(Ce) {
            return Q(Ce).toExtra();
          },
          "v:roundrect": Q,
          "v:shape": Q,
          "v:textbox": Q,
          "w:txbxContent": Q,
          "wp:inline": ie,
          "wp:anchor": ie,
          "v:imagedata": pe,
          "v:group": Q,
          "v:rect": Q
        };
        return {
          readXmlElement: _,
          readXmlElements: D
        };
        function te(Ce) {
          var ke = oe(Ce.firstOrEmpty("w:tblPr"));
          return D(Ce.children).flatMap(H).flatMap(function(ye) {
            return ke.map(function(De) {
              return o.Table(ye, De);
            });
          });
        }
        function oe(Ce) {
          return Z(Ce).map(function(ke) {
            return {
              styleId: ke.styleId,
              styleName: ke.name
            };
          });
        }
        function ee(Ce) {
          var ke = Ce.firstOrEmpty("w:trPr"), ye = !!ke.first("w:tblHeader");
          return D(Ce.children).map(function(De) {
            return o.TableRow(De, { isHeader: ye });
          });
        }
        function W(Ce) {
          return D(Ce.children).map(function(ke) {
            var ye = Ce.firstOrEmpty("w:tcPr"), De = ye.firstOrEmpty("w:gridSpan").attributes["w:val"], Ae = De ? parseInt(De, 10) : 1, Te = o.TableCell(ke, { colSpan: Ae });
            return Te._vMerge = I(ye), Te;
          });
        }
        function I(Ce) {
          var ke = Ce.first("w:vMerge");
          if (ke) {
            var ye = ke.attributes["w:val"];
            return ye === "continue" || !ye;
          } else
            return null;
        }
        function H(Ce) {
          var ke = J.any(Ce, function(Ae) {
            return Ae.type !== o.types.tableRow;
          });
          if (ke)
            return l(Ce, [t(
              "unexpected non-row element in table, cell merging may be incorrect"
            )]);
          var ye = J.any(Ce, function(Ae) {
            return J.any(Ae.children, function(Te) {
              return Te.type !== o.types.tableCell;
            });
          });
          if (ye)
            return l(Ce, [t(
              "unexpected non-cell element in table row, cell merging may be incorrect"
            )]);
          var De = {};
          return Ce.forEach(function(Ae) {
            var Te = 0;
            Ae.children.forEach(function(ve) {
              ve._vMerge && De[Te] ? De[Te].rowSpan++ : (De[Te] = ve, ve._vMerge = !1), Te += ve.colSpan;
            });
          }), Ce.forEach(function(Ae) {
            Ae.children = Ae.children.filter(function(Te) {
              return !Te._vMerge;
            }), Ae.children.forEach(function(Te) {
              delete Te._vMerge;
            });
          }), i(Ce);
        }
        function ie(Ce) {
          var ke = Ce.getElementsByTagName("a:graphic").getElementsByTagName("a:graphicData").getElementsByTagName("pic:pic").getElementsByTagName("pic:blipFill").getElementsByTagName("a:blip");
          return w(ke.map(ue.bind(null, Ce)));
        }
        function ue(Ce, ke) {
          var ye = Ce.first("wp:docPr").attributes, De = fe(ye.descr) ? ye.title : ye.descr, Ae = de(ke);
          return Ae === null ? g([t("Could not find image file for a:blip element")]) : Fe(Ae, De);
        }
        function fe(Ce) {
          return Ce == null || /^\s*$/.test(Ce);
        }
        function de(Ce) {
          var ke = Ce.attributes["r:embed"], ye = Ce.attributes["r:link"];
          if (ke)
            return xe(ke);
          if (ye) {
            var De = X.findTargetByRelationshipId(ye);
            return {
              path: De,
              read: k.read.bind(k, De)
            };
          } else
            return null;
        }
        function pe(Ce) {
          var ke = Ce.attributes["r:id"];
          return ke ? Fe(
            xe(ke),
            Ce.attributes["o:title"]
          ) : g([t("A v:imagedata element without a relationship ID was ignored")]);
        }
        function xe(Ce) {
          var ke = a.uriToZipEntryName("word", X.findTargetByRelationshipId(Ce));
          return {
            path: ke,
            read: U.read.bind(U, ke)
          };
        }
        function Fe(Ce, ke) {
          var ye = B.findContentType(Ce.path), De = o.Image({
            readImage: Ce.read,
            altText: ke,
            contentType: ye
          }), Ae = y[ye] ? [] : t("Image of type " + ye + " is unlikely to display in web browsers");
          return l(De, Ae);
        }
        function Se(Ce, ke) {
          return t(
            Ce + " style with ID " + ke + " was referenced but not defined in the document"
          );
        }
      }
      function e(A, Y, j) {
        if (A != null) {
          var X = j.findLevelByParagraphStyleId(A);
          if (X != null)
            return X;
        }
        var B = Y.firstOrEmpty("w:ilvl").attributes["w:val"], U = Y.firstOrEmpty("w:numId").attributes["w:val"];
        return B === void 0 || U === void 0 ? null : j.findLevel(U, B);
      }
      var y = {
        "image/png": !0,
        "image/gif": !0,
        "image/jpeg": !0,
        "image/svg+xml": !0,
        "image/tiff": !0
      }, c = {
        "office-word:wrap": !0,
        "v:shadow": !0,
        "v:shapetype": !0,
        "w:annotationRef": !0,
        "w:bookmarkEnd": !0,
        "w:sectPr": !0,
        "w:proofErr": !0,
        "w:lastRenderedPageBreak": !0,
        "w:commentRangeStart": !0,
        "w:commentRangeEnd": !0,
        "w:del": !0,
        "w:footnoteRef": !0,
        "w:endnoteRef": !0,
        "w:tblPr": !0,
        "w:tblGrid": !0,
        "w:trPr": !0,
        "w:tcPr": !0
      };
      function d(A) {
        return A.type === "paragraphProperties";
      }
      function m(A) {
        return A.type === "runProperties";
      }
      function p(A) {
        return function(Y) {
          return !A(Y);
        };
      }
      function g(A) {
        return new u(null, null, A);
      }
      function n() {
        return new u(null);
      }
      function i(A) {
        return new u(A);
      }
      function l(A, Y) {
        return new u(A, null, Y);
      }
      function u(A, Y, j) {
        this.value = A || [], this.extra = Y, this._result = new F({
          element: this.value,
          extra: Y
        }, j), this.messages = this._result.messages;
      }
      u.prototype.toExtra = function() {
        return new u(null, O(this.extra, this.value), this.messages);
      }, u.prototype.insertExtra = function() {
        var A = this.extra;
        return A && A.length ? new u(O(this.value, A), null, this.messages) : this;
      }, u.prototype.map = function(A) {
        var Y = this._result.map(function(j) {
          return A(j.element);
        });
        return new u(Y.value, this.extra, Y.messages);
      }, u.prototype.flatMap = function(A) {
        var Y = this._result.flatMap(function(j) {
          return A(j.element)._result;
        });
        return new u(Y.value.element, O(this.extra, Y.value.extra), Y.messages);
      };
      function w(A) {
        var Y = F.combine(J.pluck(A, "_result"));
        return new u(
          J.flatten(J.pluck(Y.value, "element")),
          J.filter(J.flatten(J.pluck(Y.value, "extra")), b),
          Y.messages
        );
      }
      function O(A, Y) {
        return J.flatten([A, Y]);
      }
      function b(A) {
        return A;
      }
    }, { "../documents": 4, "../results": 25, "./uris": 16, "dingbat-to-unicode": 81, underscore: 117 }], 6: [function(le, ce, re) {
      var ae = le("../documents"), J = le("../results").Result;
      function o(F) {
        function t(v) {
          return J.combine(v.getElementsByTagName("w:comment").map(a));
        }
        function a(v) {
          var h = v.attributes["w:id"];
          function e(y) {
            return (v.attributes[y] || "").trim() || null;
          }
          return F.readXmlElements(v.children).map(function(y) {
            return ae.comment({
              commentId: h,
              body: y,
              authorName: e("w:author"),
              authorInitials: e("w:initials")
            });
          });
        }
        return t;
      }
      re.createCommentsReader = o;
    }, { "../documents": 4, "../results": 25 }], 7: [function(le, ce, re) {
      re.readContentTypesFromXml = J;
      var ae = {
        png: "png",
        gif: "gif",
        jpeg: "jpeg",
        jpg: "jpeg",
        tif: "tiff",
        tiff: "tiff",
        bmp: "bmp"
      };
      re.defaultContentTypes = o({}, {});
      function J(F) {
        var t = {}, a = {};
        return F.children.forEach(function(v) {
          if (v.name === "content-types:Default" && (t[v.attributes.Extension] = v.attributes.ContentType), v.name === "content-types:Override") {
            var h = v.attributes.PartName;
            h.charAt(0) === "/" && (h = h.substring(1)), a[h] = v.attributes.ContentType;
          }
        }), o(a, t);
      }
      function o(F, t) {
        return {
          findContentType: function(a) {
            var v = F[a];
            if (v)
              return v;
            var h = a.split("."), e = h[h.length - 1];
            if (t.hasOwnProperty(e))
              return t[e];
            var y = ae[e.toLowerCase()];
            return y ? "image/" + y : null;
          }
        };
      }
    }, {}], 8: [function(le, ce, re) {
      re.DocumentXmlReader = o;
      var ae = le("../documents"), J = le("../results").Result;
      function o(F) {
        var t = F.bodyReader;
        function a(v) {
          var h = v.first("w:body"), e = t.readXmlElements(h.children).map(function(y) {
            return new ae.Document(y, {
              notes: F.notes,
              comments: F.comments
            });
          });
          return new J(e.value, e.messages);
        }
        return {
          convertXmlToDocument: a
        };
      }
    }, { "../documents": 4, "../results": 25 }], 9: [function(le, ce, re) {
      re.read = n, re._findPartPaths = i;
      var ae = le("path"), J = le("../promises"), o = le("../documents"), F = le("../results").Result, t = le("../zipfile"), a = le("./office-xml-reader").readXmlFromZipFile, v = le("./body-reader").createBodyReader, h = le("./document-xml-reader").DocumentXmlReader, e = le("./relationships-reader"), y = le("./content-types-reader"), c = le("./numbering-xml"), d = le("./styles-reader"), m = le("./notes-reader"), p = le("./comments-reader"), g = le("./files").Files;
      function n(B, U) {
        return U = U || {}, J.props({
          contentTypes: A(B),
          partPaths: i(B),
          docxFile: B,
          files: new g(U.path ? ae.dirname(U.path) : null)
        }).also(function(k) {
          return {
            styles: j(B, k.partPaths.styles)
          };
        }).also(function(k) {
          return {
            numbering: Y(B, k.partPaths.numbering, k.styles)
          };
        }).also(function(k) {
          return {
            footnotes: O(k.partPaths.footnotes, k, function(x, f) {
              return f ? m.createFootnotesReader(x)(f) : new F([]);
            }),
            endnotes: O(k.partPaths.endnotes, k, function(x, f) {
              return f ? m.createEndnotesReader(x)(f) : new F([]);
            }),
            comments: O(k.partPaths.comments, k, function(x, f) {
              return f ? p.createCommentsReader(x)(f) : new F([]);
            })
          };
        }).also(function(k) {
          return {
            notes: k.footnotes.flatMap(function(x) {
              return k.endnotes.map(function(f) {
                return new o.Notes(x.concat(f));
              });
            })
          };
        }).then(function(k) {
          return O(k.partPaths.mainDocument, k, function(x, f) {
            return k.notes.flatMap(function(D) {
              return k.comments.flatMap(function(_) {
                var S = new h({
                  bodyReader: x,
                  notes: D,
                  comments: _
                });
                return S.convertXmlToDocument(f);
              });
            });
          });
        });
      }
      function i(B) {
        return X(B).then(function(U) {
          var k = l({
            docxFile: B,
            relationships: U,
            relationshipType: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
            basePath: "",
            fallbackPath: "word/document.xml"
          });
          if (!B.exists(k))
            throw new Error("Could not find main document part. Are you sure this is a valid .docx file?");
          return w({
            filename: b(k),
            readElement: e.readRelationships,
            defaultValue: e.defaultValue
          })(B).then(function(x) {
            function f(D) {
              return l({
                docxFile: B,
                relationships: x,
                relationshipType: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/" + D,
                basePath: t.splitPath(k).dirname,
                fallbackPath: "word/" + D + ".xml"
              });
            }
            return {
              mainDocument: k,
              comments: f("comments"),
              endnotes: f("endnotes"),
              footnotes: f("footnotes"),
              numbering: f("numbering"),
              styles: f("styles")
            };
          });
        });
      }
      function l(B) {
        var U = B.docxFile, k = B.relationships, x = B.relationshipType, f = B.basePath, D = B.fallbackPath, _ = k.findTargetsByType(x), S = _.map(function(T) {
          return u(t.joinPath(f, T), "/");
        }), C = S.filter(function(T) {
          return U.exists(T);
        });
        return C.length === 0 ? D : C[0];
      }
      function u(B, U) {
        return B.substring(0, U.length) === U ? B.substring(U.length) : B;
      }
      function w(B) {
        return function(U) {
          return a(U, B.filename).then(function(k) {
            return k ? B.readElement(k) : B.defaultValue;
          });
        };
      }
      function O(B, U, k) {
        var x = w({
          filename: b(B),
          readElement: e.readRelationships,
          defaultValue: e.defaultValue
        });
        return x(U.docxFile).then(function(f) {
          var D = new v({
            relationships: f,
            contentTypes: U.contentTypes,
            docxFile: U.docxFile,
            numbering: U.numbering,
            styles: U.styles,
            files: U.files
          });
          return a(U.docxFile, B).then(function(_) {
            return k(D, _);
          });
        });
      }
      function b(B) {
        var U = t.splitPath(B);
        return t.joinPath(U.dirname, "_rels", U.basename + ".rels");
      }
      var A = w({
        filename: "[Content_Types].xml",
        readElement: y.readContentTypesFromXml,
        defaultValue: y.defaultContentTypes
      });
      function Y(B, U, k) {
        return w({
          filename: U,
          readElement: function(x) {
            return c.readNumberingXml(x, { styles: k });
          },
          defaultValue: c.defaultNumbering
        })(B);
      }
      function j(B, U) {
        return w({
          filename: U,
          readElement: d.readStylesXml,
          defaultValue: d.defaultStyles
        })(B);
      }
      var X = w({
        filename: "_rels/.rels",
        readElement: e.readRelationships,
        defaultValue: e.defaultValue
      });
    }, { "../documents": 4, "../promises": 23, "../results": 25, "../zipfile": 39, "./body-reader": 5, "./comments-reader": 6, "./content-types-reader": 7, "./document-xml-reader": 8, "./files": 1, "./notes-reader": 10, "./numbering-xml": 11, "./office-xml-reader": 12, "./relationships-reader": 13, "./styles-reader": 15, path: 100 }], 10: [function(le, ce, re) {
      var ae = le("../documents"), J = le("../results").Result;
      re.createFootnotesReader = o.bind(this, "footnote"), re.createEndnotesReader = o.bind(this, "endnote");
      function o(F, t) {
        function a(e) {
          return J.combine(e.getElementsByTagName("w:" + F).filter(v).map(h));
        }
        function v(e) {
          var y = e.attributes["w:type"];
          return y !== "continuationSeparator" && y !== "separator";
        }
        function h(e) {
          var y = e.attributes["w:id"];
          return t.readXmlElements(e.children).map(function(c) {
            return ae.Note({ noteType: F, noteId: y, body: c });
          });
        }
        return a;
      }
    }, { "../documents": 4, "../results": 25 }], 11: [function(le, ce, re) {
      var ae = le("underscore");
      re.readNumberingXml = o, re.Numbering = J, re.defaultNumbering = new J({}, {});
      function J(v, h, e) {
        var y = ae.flatten(ae.values(h).map(function(p) {
          return ae.values(p.levels);
        })), c = ae.indexBy(
          y.filter(function(p) {
            return p.paragraphStyleId != null;
          }),
          "paragraphStyleId"
        );
        function d(p, g) {
          var n = v[p];
          if (n) {
            var i = h[n.abstractNumId];
            if (i) {
              if (i.numStyleLink == null)
                return h[n.abstractNumId].levels[g];
              var l = e.findNumberingStyleById(i.numStyleLink);
              return d(l.numId, g);
            } else
              return null;
          } else
            return null;
        }
        function m(p) {
          return c[p] || null;
        }
        return {
          findLevel: d,
          findLevelByParagraphStyleId: m
        };
      }
      function o(v, h) {
        if (!h || !h.styles)
          throw new Error("styles is missing");
        var e = F(v), y = a(v);
        return new J(y, e, h.styles);
      }
      function F(v) {
        var h = {};
        return v.getElementsByTagName("w:abstractNum").forEach(function(e) {
          var y = e.attributes["w:abstractNumId"];
          h[y] = t(e);
        }), h;
      }
      function t(v) {
        var h = {};
        v.getElementsByTagName("w:lvl").forEach(function(y) {
          var c = y.attributes["w:ilvl"], d = y.first("w:numFmt").attributes["w:val"], m = y.firstOrEmpty("w:pStyle").attributes["w:val"];
          h[c] = {
            isOrdered: d !== "bullet",
            level: c,
            paragraphStyleId: m
          };
        });
        var e = v.firstOrEmpty("w:numStyleLink").attributes["w:val"];
        return { levels: h, numStyleLink: e };
      }
      function a(v) {
        var h = {};
        return v.getElementsByTagName("w:num").forEach(function(e) {
          var y = e.attributes["w:numId"], c = e.first("w:abstractNumId").attributes["w:val"];
          h[y] = { abstractNumId: c };
        }), h;
      }
    }, { underscore: 117 }], 12: [function(le, ce, re) {
      var ae = le("underscore"), J = le("../promises"), o = le("../xml");
      re.read = t, re.readXmlFromZipFile = a;
      var F = {
        "http://schemas.openxmlformats.org/wordprocessingml/2006/main": "w",
        "http://schemas.openxmlformats.org/officeDocument/2006/relationships": "r",
        "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing": "wp",
        "http://schemas.openxmlformats.org/drawingml/2006/main": "a",
        "http://schemas.openxmlformats.org/drawingml/2006/picture": "pic",
        "http://schemas.openxmlformats.org/package/2006/content-types": "content-types",
        "urn:schemas-microsoft-com:vml": "v",
        "http://schemas.openxmlformats.org/markup-compatibility/2006": "mc",
        "urn:schemas-microsoft-com:office:word": "office-word"
      };
      function t(e) {
        return o.readString(e, F).then(function(y) {
          return h(y)[0];
        });
      }
      function a(e, y) {
        return e.exists(y) ? e.read(y, "utf-8").then(v).then(t) : J.resolve(null);
      }
      function v(e) {
        return e.replace(/^\uFEFF/g, "");
      }
      function h(e) {
        return e.type === "element" ? e.name === "mc:AlternateContent" ? e.first("mc:Fallback").children : (e.children = ae.flatten(e.children.map(h, !0)), [e]) : [e];
      }
    }, { "../promises": 23, "../xml": 35, underscore: 117 }], 13: [function(le, ce, re) {
      re.readRelationships = ae, re.defaultValue = new J([]), re.Relationships = J;
      function ae(o) {
        var F = [];
        return o.children.forEach(function(t) {
          if (t.name === "{http://schemas.openxmlformats.org/package/2006/relationships}Relationship") {
            var a = {
              relationshipId: t.attributes.Id,
              target: t.attributes.Target,
              type: t.attributes.Type
            };
            F.push(a);
          }
        }), new J(F);
      }
      function J(o) {
        var F = {};
        o.forEach(function(a) {
          F[a.relationshipId] = a.target;
        });
        var t = {};
        return o.forEach(function(a) {
          t[a.type] || (t[a.type] = []), t[a.type].push(a.target);
        }), {
          findTargetByRelationshipId: function(a) {
            return F[a];
          },
          findTargetsByType: function(a) {
            return t[a] || [];
          }
        };
      }
    }, {}], 14: [function(le, ce, re) {
      var ae = le("underscore"), J = le("../promises"), o = le("../xml");
      re.writeStyleMap = v, re.readStyleMap = c;
      var F = "http://schemas.zwobble.org/mammoth/style-map", t = "mammoth/style-map", a = "/" + t;
      function v(d, m) {
        return d.write(t, m), h(d).then(function() {
          return e(d);
        });
      }
      function h(d) {
        var m = "word/_rels/document.xml.rels", p = "http://schemas.openxmlformats.org/package/2006/relationships", g = "{" + p + "}Relationship";
        return d.read(m, "utf8").then(o.readString).then(function(n) {
          var i = n.children;
          y(i, g, "Id", {
            Id: "rMammothStyleMap",
            Type: F,
            Target: a
          });
          var l = { "": p };
          return d.write(m, o.writeString(n, l));
        });
      }
      function e(d) {
        var m = "[Content_Types].xml", p = "http://schemas.openxmlformats.org/package/2006/content-types", g = "{" + p + "}Override";
        return d.read(m, "utf8").then(o.readString).then(function(n) {
          var i = n.children;
          y(i, g, "PartName", {
            PartName: a,
            ContentType: "text/prs.mammoth.style-map"
          });
          var l = { "": p };
          return d.write(m, o.writeString(n, l));
        });
      }
      function y(d, m, p, g) {
        var n = ae.find(d, function(i) {
          return i.name === m && i.attributes[p] === g[p];
        });
        n ? n.attributes = g : d.push(o.element(m, g));
      }
      function c(d) {
        return d.exists(t) ? d.read(t, "utf8") : J.resolve(null);
      }
    }, { "../promises": 23, "../xml": 35, underscore: 117 }], 15: [function(le, ce, re) {
      re.readStylesXml = J, re.Styles = ae, re.defaultStyles = new ae({}, {});
      function ae(a, v, h, e) {
        return {
          findParagraphStyleById: function(y) {
            return a[y];
          },
          findCharacterStyleById: function(y) {
            return v[y];
          },
          findTableStyleById: function(y) {
            return h[y];
          },
          findNumberingStyleById: function(y) {
            return e[y];
          }
        };
      }
      ae.EMPTY = new ae({}, {}, {}, {});
      function J(a) {
        var v = {}, h = {}, e = {}, y = {}, c = {
          paragraph: v,
          character: h,
          table: e
        };
        return a.getElementsByTagName("w:style").forEach(function(d) {
          var m = o(d);
          if (m.type === "numbering")
            y[m.styleId] = t(d);
          else {
            var p = c[m.type];
            p && (p[m.styleId] = m);
          }
        }), new ae(v, h, e, y);
      }
      function o(a) {
        var v = a.attributes["w:type"], h = a.attributes["w:styleId"], e = F(a);
        return { type: v, styleId: h, name: e };
      }
      function F(a) {
        var v = a.first("w:name");
        return v ? v.attributes["w:val"] : null;
      }
      function t(a) {
        var v = a.firstOrEmpty("w:pPr").firstOrEmpty("w:numPr").firstOrEmpty("w:numId").attributes["w:val"];
        return { numId: v };
      }
    }, {}], 16: [function(le, ce, re) {
      re.uriToZipEntryName = ae, re.replaceFragment = J;
      function ae(o, F) {
        return F.charAt(0) === "/" ? F.substr(1) : o + "/" + F;
      }
      function J(o, F) {
        var t = o.indexOf("#");
        return t !== -1 && (o = o.substring(0, t)), o + "#" + F;
      }
    }, {}], 17: [function(le, ce, re) {
      var ae = le("../styles/html-paths");
      function J(e, y, c) {
        return F(
          ae.element(e, y, { fresh: !1 }),
          c
        );
      }
      function o(e, y, c) {
        var d = ae.element(e, y, { fresh: !0 });
        return F(d, c);
      }
      function F(e, y) {
        return {
          type: "element",
          tag: e,
          children: y || []
        };
      }
      function t(e) {
        return {
          type: "text",
          value: e
        };
      }
      var a = {
        type: "forceWrite"
      };
      re.freshElement = o, re.nonFreshElement = J, re.elementWithTag = F, re.text = t, re.forceWrite = a;
      var v = {
        br: !0,
        hr: !0,
        img: !0
      };
      function h(e) {
        return e.children.length === 0 && v[e.tag.tagName];
      }
      re.isVoidElement = h;
    }, { "../styles/html-paths": 28 }], 18: [function(le, ce, re) {
      var ae = le("./ast");
      re.freshElement = ae.freshElement, re.nonFreshElement = ae.nonFreshElement, re.elementWithTag = ae.elementWithTag, re.text = ae.text, re.forceWrite = ae.forceWrite, re.simplify = le("./simplify");
      function J(v, h) {
        h.forEach(function(e) {
          o(v, e);
        });
      }
      function o(v, h) {
        F[h.type](v, h);
      }
      var F = {
        element: t,
        text: a,
        forceWrite: function() {
        }
      };
      function t(v, h) {
        ae.isVoidElement(h) ? v.selfClosing(h.tag.tagName, h.tag.attributes) : (v.open(h.tag.tagName, h.tag.attributes), J(v, h.children), v.close(h.tag.tagName));
      }
      function a(v, h) {
        v.text(h.value);
      }
      re.write = J;
    }, { "./ast": 17, "./simplify": 19 }], 19: [function(le, ce, re) {
      var ae = le("underscore"), J = le("./ast");
      function o(n) {
        return F(y(n));
      }
      function F(n) {
        var i = [];
        return n.map(t).forEach(function(l) {
          e(i, l);
        }), i;
      }
      function t(n) {
        return a[n.type](n);
      }
      var a = {
        element: v,
        text: h,
        forceWrite: h
      };
      function v(n) {
        return J.elementWithTag(n.tag, F(n.children));
      }
      function h(n) {
        return n;
      }
      function e(n, i) {
        var l = n[n.length - 1];
        i.type === "element" && !i.tag.fresh && l && l.type === "element" && i.tag.matchesElement(l.tag) ? (i.tag.separator && e(l.children, J.text(i.tag.separator)), i.children.forEach(function(u) {
          e(l.children, u);
        })) : n.push(i);
      }
      function y(n) {
        return c(n, function(i) {
          return d[i.type](i);
        });
      }
      function c(n, i) {
        return ae.flatten(ae.map(n, i), !0);
      }
      var d = {
        element: p,
        text: g,
        forceWrite: m
      };
      function m(n) {
        return [n];
      }
      function p(n) {
        var i = y(n.children);
        return i.length === 0 && !J.isVoidElement(n) ? [] : [J.elementWithTag(n.tag, i)];
      }
      function g(n) {
        return n.value.length === 0 ? [] : [n];
      }
      ce.exports = o;
    }, { "./ast": 17, underscore: 117 }], 20: [function(le, ce, re) {
      var ae = le("underscore"), J = le("./promises"), o = le("./html");
      re.imgElement = F;
      function F(t) {
        return function(a, v) {
          return J.when(t(a)).then(function(h) {
            var e = {};
            return a.altText && (e.alt = a.altText), ae.extend(e, h), [o.freshElement("img", e)];
          });
        };
      }
      re.inline = re.imgElement, re.dataUri = F(function(t) {
        return t.read("base64").then(function(a) {
          return {
            src: "data:" + t.contentType + ";base64," + a
          };
        });
      });
    }, { "./html": 18, "./promises": 23, underscore: 117 }], 21: [function(le, ce, re) {
      var ae = le("underscore"), J = le("./docx/docx-reader"), o = le("./docx/style-map"), F = le("./document-to-html").DocumentConverter, t = le("./raw-text").convertElementToRawText, a = le("./style-reader").readStyle, v = le("./options-reader").readOptions, h = le("./unzip"), e = le("./results").Result;
      re.convertToHtml = y, re.convertToMarkdown = c, re.convert = d, re.extractRawText = n, re.images = le("./images"), re.transforms = le("./transforms"), re.underline = le("./underline"), re.embedStyleMap = i, re.readEmbeddedStyleMap = m;
      function y(l, u) {
        return d(l, u);
      }
      function c(l, u) {
        var w = Object.create(u || {});
        return w.outputFormat = "markdown", d(l, w);
      }
      function d(l, u) {
        return u = v(u), h.openZip(l).tap(function(w) {
          return o.readStyleMap(w).then(function(O) {
            u.embeddedStyleMap = O;
          });
        }).then(function(w) {
          return J.read(w, l).then(function(O) {
            return O.map(u.transformDocument);
          }).then(function(O) {
            return p(O, u);
          });
        });
      }
      function m(l) {
        return h.openZip(l).then(o.readStyleMap);
      }
      function p(l, u) {
        var w = g(u.readStyleMap()), O = ae.extend({}, u, {
          styleMap: w.value
        }), b = new F(O);
        return l.flatMapThen(function(A) {
          return w.flatMapThen(function(Y) {
            return b.convertToHtml(A);
          });
        });
      }
      function g(l) {
        return e.combine((l || []).map(a)).map(function(u) {
          return u.filter(function(w) {
            return !!w;
          });
        });
      }
      function n(l) {
        return h.openZip(l).then(J.read).then(function(u) {
          return u.map(t);
        });
      }
      function i(l, u) {
        return h.openZip(l).tap(function(w) {
          return o.writeStyleMap(w, u);
        }).then(function(w) {
          return w.toBuffer();
        }).then(function(w) {
          return {
            toBuffer: function() {
              return w;
            }
          };
        });
      }
      re.styleMapping = function() {
        throw new Error(`Use a raw string instead of mammoth.styleMapping e.g. "p[style-name='Title'] => h1" instead of mammoth.styleMapping("p[style-name='Title'] => h1")`);
      };
    }, { "./document-to-html": 3, "./docx/docx-reader": 9, "./docx/style-map": 14, "./images": 20, "./options-reader": 22, "./raw-text": 24, "./results": 25, "./style-reader": 26, "./transforms": 30, "./underline": 31, "./unzip": 2, underscore: 117 }], 22: [function(le, ce, re) {
      re.readOptions = F;
      var ae = le("underscore"), J = re._defaultStyleMap = [
        "p.Heading1 => h1:fresh",
        "p.Heading2 => h2:fresh",
        "p.Heading3 => h3:fresh",
        "p.Heading4 => h4:fresh",
        "p.Heading5 => h5:fresh",
        "p.Heading6 => h6:fresh",
        "p[style-name='Heading 1'] => h1:fresh",
        "p[style-name='Heading 2'] => h2:fresh",
        "p[style-name='Heading 3'] => h3:fresh",
        "p[style-name='Heading 4'] => h4:fresh",
        "p[style-name='Heading 5'] => h5:fresh",
        "p[style-name='Heading 6'] => h6:fresh",
        "p[style-name='heading 1'] => h1:fresh",
        "p[style-name='heading 2'] => h2:fresh",
        "p[style-name='heading 3'] => h3:fresh",
        "p[style-name='heading 4'] => h4:fresh",
        "p[style-name='heading 5'] => h5:fresh",
        "p[style-name='heading 6'] => h6:fresh",
        "r[style-name='Strong'] => strong",
        "p[style-name='footnote text'] => p:fresh",
        "r[style-name='footnote reference'] =>",
        "p[style-name='endnote text'] => p:fresh",
        "r[style-name='endnote reference'] =>",
        "p[style-name='annotation text'] => p:fresh",
        "r[style-name='annotation reference'] =>",
        // LibreOffice
        "p[style-name='Footnote'] => p:fresh",
        "r[style-name='Footnote anchor'] =>",
        "p[style-name='Endnote'] => p:fresh",
        "r[style-name='Endnote anchor'] =>",
        "p:unordered-list(1) => ul > li:fresh",
        "p:unordered-list(2) => ul|ol > li > ul > li:fresh",
        "p:unordered-list(3) => ul|ol > li > ul|ol > li > ul > li:fresh",
        "p:unordered-list(4) => ul|ol > li > ul|ol > li > ul|ol > li > ul > li:fresh",
        "p:unordered-list(5) => ul|ol > li > ul|ol > li > ul|ol > li > ul|ol > li > ul > li:fresh",
        "p:ordered-list(1) => ol > li:fresh",
        "p:ordered-list(2) => ul|ol > li > ol > li:fresh",
        "p:ordered-list(3) => ul|ol > li > ul|ol > li > ol > li:fresh",
        "p:ordered-list(4) => ul|ol > li > ul|ol > li > ul|ol > li > ol > li:fresh",
        "p:ordered-list(5) => ul|ol > li > ul|ol > li > ul|ol > li > ul|ol > li > ol > li:fresh",
        "r[style-name='Hyperlink'] =>",
        "p[style-name='Normal'] => p:fresh"
      ], o = re._standardOptions = {
        transformDocument: a,
        includeDefaultStyleMap: !0,
        includeEmbeddedStyleMap: !0
      };
      function F(v) {
        return v = v || {}, ae.extend({}, o, v, {
          customStyleMap: t(v.styleMap),
          readStyleMap: function() {
            var h = this.customStyleMap;
            return this.includeEmbeddedStyleMap && (h = h.concat(t(this.embeddedStyleMap))), this.includeDefaultStyleMap && (h = h.concat(J)), h;
          }
        });
      }
      function t(v) {
        return v ? ae.isString(v) ? v.split(`
`).map(function(h) {
          return h.trim();
        }).filter(function(h) {
          return h !== "" && h.charAt(0) !== "#";
        }) : v : [];
      }
      function a(v) {
        return v;
      }
    }, { underscore: 117 }], 23: [function(le, ce, re) {
      var ae = le("underscore"), J = le("bluebird/js/release/promise")();
      re.defer = o, re.when = J.resolve, re.resolve = J.resolve, re.all = J.all, re.props = J.props, re.reject = J.reject, re.promisify = J.promisify, re.mapSeries = J.mapSeries, re.attempt = J.attempt, re.nfcall = function(F) {
        var t = Array.prototype.slice.call(arguments, 1), a = J.promisify(F);
        return a.apply(null, t);
      }, J.prototype.fail = J.prototype.caught, J.prototype.also = function(F) {
        return this.then(function(t) {
          var a = ae.extend({}, t, F(t));
          return J.props(a);
        });
      };
      function o() {
        var F, t, a = new J.Promise(function(v, h) {
          F = v, t = h;
        });
        return {
          resolve: F,
          reject: t,
          promise: a
        };
      }
    }, { "bluebird/js/release/promise": 61, underscore: 117 }], 24: [function(le, ce, re) {
      var ae = le("./documents");
      function J(o) {
        if (o.type === "text")
          return o.value;
        if (o.type === ae.types.tab)
          return "	";
        var F = o.type === "paragraph" ? `

` : "";
        return (o.children || []).map(J).join("") + F;
      }
      re.convertElementToRawText = J;
    }, { "./documents": 4 }], 25: [function(le, ce, re) {
      var ae = le("underscore");
      re.Result = J, re.success = o, re.warning = F, re.error = t;
      function J(e, y) {
        this.value = e, this.messages = y || [];
      }
      J.prototype.map = function(e) {
        return new J(e(this.value), this.messages);
      }, J.prototype.flatMap = function(e) {
        var y = e(this.value);
        return new J(y.value, a([this, y]));
      }, J.prototype.flatMapThen = function(e) {
        var y = this;
        return e(this.value).then(function(c) {
          return new J(c.value, a([y, c]));
        });
      }, J.combine = function(e) {
        var y = ae.flatten(ae.pluck(e, "value")), c = a(e);
        return new J(y, c);
      };
      function o(e) {
        return new J(e, []);
      }
      function F(e) {
        return {
          type: "warning",
          message: e
        };
      }
      function t(e) {
        return {
          type: "error",
          message: e.message,
          error: e
        };
      }
      function a(e) {
        var y = [];
        return ae.flatten(ae.pluck(e, "messages"), !0).forEach(function(c) {
          v(y, c) || y.push(c);
        }), y;
      }
      function v(e, y) {
        return ae.find(e, h.bind(null, y)) !== void 0;
      }
      function h(e, y) {
        return e.type === y.type && e.message === y.message;
      }
    }, { underscore: 117 }], 26: [function(le, ce, re) {
      var ae = le("underscore"), J = le("lop"), o = le("./styles/document-matchers"), F = le("./styles/html-paths"), t = le("./styles/parser/tokeniser").tokenise, a = le("./results");
      re.readHtmlPath = c, re.readDocumentMatcher = e, re.readStyle = v;
      function v(A) {
        return u(b, A);
      }
      function h() {
        return J.rules.sequence(
          J.rules.sequence.capture(y()),
          J.rules.tokenOfType("whitespace"),
          J.rules.tokenOfType("arrow"),
          J.rules.sequence.capture(J.rules.optional(J.rules.sequence(
            J.rules.tokenOfType("whitespace"),
            J.rules.sequence.capture(d())
          ).head())),
          J.rules.tokenOfType("end")
        ).map(function(A, Y) {
          return {
            from: A,
            to: Y.valueOrElse(F.empty)
          };
        });
      }
      function e(A) {
        return u(y(), A);
      }
      function y() {
        var A = J.rules.sequence, Y = function(L, K) {
          return J.rules.then(
            J.rules.token("identifier", L),
            function() {
              return K;
            }
          );
        }, j = Y("p", o.paragraph), X = Y("r", o.run), B = J.rules.firstOf(
          "p or r or table",
          j,
          X
        ), U = J.rules.then(
          l,
          function(L) {
            return { styleId: L };
          }
        ), k = J.rules.firstOf(
          "style name matcher",
          J.rules.then(
            J.rules.sequence(
              J.rules.tokenOfType("equals"),
              J.rules.sequence.cut(),
              J.rules.sequence.capture(g)
            ).head(),
            function(L) {
              return { styleName: o.equalTo(L) };
            }
          ),
          J.rules.then(
            J.rules.sequence(
              J.rules.tokenOfType("startsWith"),
              J.rules.sequence.cut(),
              J.rules.sequence.capture(g)
            ).head(),
            function(L) {
              return { styleName: o.startsWith(L) };
            }
          )
        ), x = J.rules.sequence(
          J.rules.tokenOfType("open-square-bracket"),
          J.rules.sequence.cut(),
          J.rules.token("identifier", "style-name"),
          J.rules.sequence.capture(k),
          J.rules.tokenOfType("close-square-bracket")
        ).head(), f = J.rules.firstOf(
          "list type",
          Y("ordered-list", { isOrdered: !0 }),
          Y("unordered-list", { isOrdered: !1 })
        ), D = A(
          J.rules.tokenOfType("colon"),
          A.capture(f),
          A.cut(),
          J.rules.tokenOfType("open-paren"),
          A.capture(p),
          J.rules.tokenOfType("close-paren")
        ).map(function(L, K) {
          return {
            list: {
              isOrdered: L.isOrdered,
              levelIndex: K - 1
            }
          };
        });
        function _(L) {
          var K = J.rules.firstOf.apply(
            J.rules.firstOf,
            ["matcher suffix"].concat(L)
          ), ne = J.rules.zeroOrMore(K);
          return J.rules.then(ne, function(se) {
            var q = {};
            return se.forEach(function(N) {
              ae.extend(q, N);
            }), q;
          });
        }
        var S = A(
          A.capture(B),
          A.capture(_([
            U,
            x,
            D
          ]))
        ).map(function(L, K) {
          return L(K);
        }), C = A(
          J.rules.token("identifier", "table"),
          A.capture(_([
            U,
            x
          ]))
        ).map(function(L) {
          return o.table(L);
        }), T = Y("b", o.bold), P = Y("i", o.italic), M = Y("u", o.underline), G = Y("strike", o.strikethrough), Z = Y("all-caps", o.allCaps), $ = Y("small-caps", o.smallCaps), z = Y("comment-reference", o.commentReference), V = A(
          J.rules.token("identifier", "br"),
          A.cut(),
          J.rules.tokenOfType("open-square-bracket"),
          J.rules.token("identifier", "type"),
          J.rules.tokenOfType("equals"),
          A.capture(g),
          J.rules.tokenOfType("close-square-bracket")
        ).map(function(L) {
          switch (L) {
            case "line":
              return o.lineBreak;
            case "page":
              return o.pageBreak;
            case "column":
              return o.columnBreak;
          }
        });
        return J.rules.firstOf(
          "element type",
          S,
          C,
          T,
          P,
          M,
          G,
          Z,
          $,
          z,
          V
        );
      }
      function c(A) {
        return u(d(), A);
      }
      function d() {
        var A = J.rules.sequence.capture, Y = J.rules.tokenOfType("whitespace"), j = J.rules.then(
          J.rules.optional(J.rules.sequence(
            J.rules.tokenOfType("colon"),
            J.rules.token("identifier", "fresh")
          )),
          function(k) {
            return k.map(function() {
              return !0;
            }).valueOrElse(!1);
          }
        ), X = J.rules.then(
          J.rules.optional(J.rules.sequence(
            J.rules.tokenOfType("colon"),
            J.rules.token("identifier", "separator"),
            J.rules.tokenOfType("open-paren"),
            A(g),
            J.rules.tokenOfType("close-paren")
          ).head()),
          function(k) {
            return k.valueOrElse("");
          }
        ), B = J.rules.oneOrMoreWithSeparator(
          m,
          J.rules.tokenOfType("choice")
        ), U = J.rules.sequence(
          A(B),
          A(J.rules.zeroOrMore(l)),
          A(j),
          A(X)
        ).map(function(k, x, f, D) {
          var _ = {}, S = {};
          return x.length > 0 && (_.class = x.join(" ")), f && (S.fresh = !0), D && (S.separator = D), F.element(k, _, S);
        });
        return J.rules.firstOf(
          "html path",
          J.rules.then(J.rules.tokenOfType("bang"), function() {
            return F.ignore;
          }),
          J.rules.then(
            J.rules.zeroOrMoreWithSeparator(
              U,
              J.rules.sequence(
                Y,
                J.rules.tokenOfType("gt"),
                Y
              )
            ),
            F.elements
          )
        );
      }
      var m = J.rules.then(
        J.rules.tokenOfType("identifier"),
        i
      ), p = J.rules.tokenOfType("integer"), g = J.rules.then(
        J.rules.tokenOfType("string"),
        i
      ), n = {
        n: `
`,
        r: "\r",
        t: "	"
      };
      function i(A) {
        return A.replace(/\\(.)/g, function(Y, j) {
          return n[j] || j;
        });
      }
      var l = J.rules.sequence(
        J.rules.tokenOfType("dot"),
        J.rules.sequence.cut(),
        J.rules.sequence.capture(m)
      ).head();
      function u(A, Y) {
        var j = t(Y), X = J.Parser(), B = X.parseTokens(A, j);
        return B.isSuccess() ? a.success(B.value()) : new a.Result(null, [a.warning(w(Y, B))]);
      }
      function w(A, Y) {
        return "Did not understand this style mapping, so ignored it: " + A + `
` + Y.errors().map(O).join(`
`);
      }
      function O(A) {
        return "Error was at character number " + A.characterNumber() + ": Expected " + A.expected + " but got " + A.actual;
      }
      var b = h();
    }, { "./results": 25, "./styles/document-matchers": 27, "./styles/html-paths": 28, "./styles/parser/tokeniser": 29, lop: 88, underscore: 117 }], 27: [function(le, ce, re) {
      re.paragraph = ae, re.run = J, re.table = o, re.bold = new F("bold"), re.italic = new F("italic"), re.underline = new F("underline"), re.strikethrough = new F("strikethrough"), re.allCaps = new F("allCaps"), re.smallCaps = new F("smallCaps"), re.commentReference = new F("commentReference"), re.lineBreak = new F("break", { breakType: "line" }), re.pageBreak = new F("break", { breakType: "page" }), re.columnBreak = new F("break", { breakType: "column" }), re.equalTo = a, re.startsWith = v;
      function ae(y) {
        return new F("paragraph", y);
      }
      function J(y) {
        return new F("run", y);
      }
      function o(y) {
        return new F("table", y);
      }
      function F(y, c) {
        c = c || {}, this._elementType = y, this._styleId = c.styleId, this._styleName = c.styleName, c.list && (this._listIndex = c.list.levelIndex, this._listIsOrdered = c.list.isOrdered);
      }
      F.prototype.matches = function(y) {
        return y.type === this._elementType && (this._styleId === void 0 || y.styleId === this._styleId) && (this._styleName === void 0 || y.styleName && this._styleName.operator(this._styleName.operand, y.styleName)) && (this._listIndex === void 0 || t(y, this._listIndex, this._listIsOrdered)) && (this._breakType === void 0 || this._breakType === y.breakType);
      };
      function t(y, c, d) {
        return y.numbering && y.numbering.level == c && y.numbering.isOrdered == d;
      }
      function a(y) {
        return {
          operator: h,
          operand: y
        };
      }
      function v(y) {
        return {
          operator: e,
          operand: y
        };
      }
      function h(y, c) {
        return y.toUpperCase() === c.toUpperCase();
      }
      function e(y, c) {
        return c.toUpperCase().indexOf(y.toUpperCase()) === 0;
      }
    }, {}], 28: [function(le, ce, re) {
      var ae = le("underscore"), J = le("../html");
      re.topLevelElement = o, re.elements = F, re.element = a;
      function o(h, e) {
        return F([a(h, e, { fresh: !0 })]);
      }
      function F(h) {
        return new t(h.map(function(e) {
          return ae.isString(e) ? a(e) : e;
        }));
      }
      function t(h) {
        this._elements = h;
      }
      t.prototype.wrap = function(e) {
        for (var y = e(), c = this._elements.length - 1; c >= 0; c--)
          y = this._elements[c].wrapNodes(y);
        return y;
      };
      function a(h, e, y) {
        return y = y || {}, new v(h, e, y);
      }
      function v(h, e, y) {
        var c = {};
        ae.isArray(h) ? (h.forEach(function(d) {
          c[d] = !0;
        }), h = h[0]) : c[h] = !0, this.tagName = h, this.tagNames = c, this.attributes = e || {}, this.fresh = y.fresh, this.separator = y.separator;
      }
      v.prototype.matchesElement = function(h) {
        return this.tagNames[h.tagName] && ae.isEqual(this.attributes || {}, h.attributes || {});
      }, v.prototype.wrap = function(e) {
        return this.wrapNodes(e());
      }, v.prototype.wrapNodes = function(e) {
        return [J.elementWithTag(this, e)];
      }, re.empty = F([]), re.ignore = {
        wrap: function() {
          return [];
        }
      };
    }, { "../html": 18, underscore: 117 }], 29: [function(le, ce, re) {
      var ae = le("lop"), J = ae.RegexTokeniser;
      re.tokenise = F;
      var o = "'((?:\\\\.|[^'])*)";
      function F(t) {
        var a = "(?:[a-zA-Z\\-_]|\\\\.)", v = new J([
          { name: "identifier", regex: new RegExp("(" + a + "(?:" + a + "|[0-9])*)") },
          { name: "dot", regex: /\./ },
          { name: "colon", regex: /:/ },
          { name: "gt", regex: />/ },
          { name: "whitespace", regex: /\s+/ },
          { name: "arrow", regex: /=>/ },
          { name: "equals", regex: /=/ },
          { name: "startsWith", regex: /\^=/ },
          { name: "open-paren", regex: /\(/ },
          { name: "close-paren", regex: /\)/ },
          { name: "open-square-bracket", regex: /\[/ },
          { name: "close-square-bracket", regex: /\]/ },
          { name: "string", regex: new RegExp(o + "'") },
          { name: "unterminated-string", regex: new RegExp(o) },
          { name: "integer", regex: /([0-9]+)/ },
          { name: "choice", regex: /\|/ },
          { name: "bang", regex: /(!)/ }
        ]);
        return v.tokenise(t);
      }
    }, { lop: 88 }], 30: [function(le, ce, re) {
      var ae = le("underscore");
      re.paragraph = J, re.run = o, re._elements = t, re.getDescendantsOfType = a, re.getDescendants = v;
      function J(e) {
        return F("paragraph", e);
      }
      function o(e) {
        return F("run", e);
      }
      function F(e, y) {
        return t(function(c) {
          return c.type === e ? y(c) : c;
        });
      }
      function t(e) {
        return function y(c) {
          if (c.children) {
            var d = ae.map(c.children, y);
            c = ae.extend(c, { children: d });
          }
          return e(c);
        };
      }
      function a(e, y) {
        return v(e).filter(function(c) {
          return c.type === y;
        });
      }
      function v(e) {
        var y = [];
        return h(e, function(c) {
          y.push(c);
        }), y;
      }
      function h(e, y) {
        e.children && e.children.forEach(function(c) {
          h(c, y), y(c);
        });
      }
    }, { underscore: 117 }], 31: [function(le, ce, re) {
      var ae = le("./styles/html-paths"), J = le("./html");
      re.element = o;
      function o(F) {
        return function(t) {
          return J.elementWithTag(ae.element(F), [t]);
        };
      }
    }, { "./html": 18, "./styles/html-paths": 28 }], 32: [function(le, ce, re) {
      var ae = le("util"), J = le("underscore");
      re.writer = o;
      function o(e) {
        return e = e || {}, e.prettyPrint ? t() : a();
      }
      var F = {
        div: !0,
        p: !0,
        ul: !0,
        li: !0
      };
      function t() {
        var e = 0, y = "  ", c = [], d = !0, m = !1, p = a();
        function g(A, Y) {
          F[A] && O(), c.push(A), p.open(A, Y), F[A] && e++, d = !1;
        }
        function n(A) {
          F[A] && (e--, O()), c.pop(), p.close(A);
        }
        function i(A) {
          w();
          var Y = b() ? A : A.replace(`
`, `
` + y);
          p.text(Y);
        }
        function l(A, Y) {
          O(), p.selfClosing(A, Y);
        }
        function u() {
          return c.length === 0 || F[c[c.length - 1]];
        }
        function w() {
          m || (O(), m = !0);
        }
        function O() {
          if (m = !1, !d && u() && !b()) {
            p._append(`
`);
            for (var A = 0; A < e; A++)
              p._append(y);
          }
        }
        function b() {
          return J.some(c, function(A) {
            return A === "pre";
          });
        }
        return {
          asString: p.asString,
          open: g,
          close: n,
          text: i,
          selfClosing: l
        };
      }
      function a() {
        var e = [];
        function y(i, l) {
          var u = m(l);
          e.push(ae.format("<%s%s>", i, u));
        }
        function c(i) {
          e.push(ae.format("</%s>", i));
        }
        function d(i, l) {
          var u = m(l);
          e.push(ae.format("<%s%s />", i, u));
        }
        function m(i) {
          return J.map(i, function(l, u) {
            return ae.format(' %s="%s"', u, h(l));
          }).join("");
        }
        function p(i) {
          e.push(v(i));
        }
        function g(i) {
          e.push(i);
        }
        function n() {
          return e.join("");
        }
        return {
          asString: n,
          open: y,
          close: c,
          text: p,
          selfClosing: d,
          _append: g
        };
      }
      function v(e) {
        return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
      }
      function h(e) {
        return e.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
      }
    }, { underscore: 117, util: 121 }], 33: [function(le, ce, re) {
      var ae = le("./html-writer"), J = le("./markdown-writer");
      re.writer = o;
      function o(F) {
        return F = F || {}, F.outputFormat === "markdown" ? J.writer() : ae.writer(F);
      }
    }, { "./html-writer": 32, "./markdown-writer": 34 }], 34: [function(le, ce, re) {
      var ae = le("underscore");
      function J(d) {
        return o(d, d);
      }
      function o(d, m) {
        return function() {
          return { start: d, end: m };
        };
      }
      function F(d) {
        var m = d.href || "";
        return m ? {
          start: "[",
          end: "](" + m + ")",
          anchorPosition: "before"
        } : {};
      }
      function t(d) {
        var m = d.src || "", p = d.alt || "";
        return m || p ? { start: "![" + p + "](" + m + ")" } : {};
      }
      function a(d) {
        return function(m, p) {
          return {
            start: p ? `
` : "",
            end: p ? "" : `
`,
            list: {
              isOrdered: d.isOrdered,
              indent: p ? p.indent + 1 : 0,
              count: 0
            }
          };
        };
      }
      function v(d, m, p) {
        m = m || { indent: 0, isOrdered: !1, count: 0 }, m.count++, p.hasClosed = !1;
        var g = m.isOrdered ? m.count + "." : "-", n = e("	", m.indent) + g + " ";
        return {
          start: n,
          end: function() {
            if (!p.hasClosed)
              return p.hasClosed = !0, `
`;
          }
        };
      }
      var h = {
        p: o("", `

`),
        br: o("", `  
`),
        ul: a({ isOrdered: !1 }),
        ol: a({ isOrdered: !0 }),
        li: v,
        strong: J("__"),
        em: J("*"),
        a: F,
        img: t
      };
      (function() {
        for (var d = 1; d <= 6; d++)
          h["h" + d] = o(e("#", d) + " ", `

`);
      })();
      function e(d, m) {
        return new Array(m + 1).join(d);
      }
      function y() {
        var d = [], m = [], p = null, g = {};
        function n(b, A) {
          A = A || {};
          var Y = h[b] || function() {
            return {};
          }, j = Y(A, p, g);
          m.push({ end: j.end, list: p }), j.list && (p = j.list);
          var X = j.anchorPosition === "before";
          X && i(A), d.push(j.start || ""), X || i(A);
        }
        function i(b) {
          b.id && d.push('<a id="' + b.id + '"></a>');
        }
        function l(b) {
          var A = m.pop();
          p = A.list;
          var Y = ae.isFunction(A.end) ? A.end() : A.end;
          d.push(Y || "");
        }
        function u(b, A) {
          n(b, A), l();
        }
        function w(b) {
          d.push(c(b));
        }
        function O() {
          return d.join("");
        }
        return {
          asString: O,
          open: n,
          close: l,
          text: w,
          selfClosing: u
        };
      }
      re.writer = y;
      function c(d) {
        return d.replace(/\\/g, "\\\\").replace(/([\`\*_\{\}\[\]\(\)\#\+\-\.\!])/g, "\\$1");
      }
    }, { underscore: 117 }], 35: [function(le, ce, re) {
      var ae = le("./nodes");
      re.Element = ae.Element, re.element = ae.element, re.text = ae.text, re.readString = le("./reader").readString, re.writeString = le("./writer").writeString;
    }, { "./nodes": 36, "./reader": 37, "./writer": 38 }], 36: [function(le, ce, re) {
      var ae = le("underscore");
      re.Element = o, re.element = function(a, v, h) {
        return new o(a, v, h);
      }, re.text = function(a) {
        return {
          type: "text",
          value: a
        };
      };
      var J = {
        first: function() {
          return null;
        },
        firstOrEmpty: function() {
          return J;
        },
        attributes: {}
      };
      function o(a, v, h) {
        this.type = "element", this.name = a, this.attributes = v || {}, this.children = h || [];
      }
      o.prototype.first = function(a) {
        return ae.find(this.children, function(v) {
          return v.name === a;
        });
      }, o.prototype.firstOrEmpty = function(a) {
        return this.first(a) || J;
      }, o.prototype.getElementsByTagName = function(a) {
        var v = ae.filter(this.children, function(h) {
          return h.name === a;
        });
        return t(v);
      }, o.prototype.text = function() {
        if (this.children.length === 0)
          return "";
        if (this.children.length !== 1 || this.children[0].type !== "text")
          throw new Error("Not implemented");
        return this.children[0].value;
      };
      var F = {
        getElementsByTagName: function(a) {
          return t(ae.flatten(this.map(function(v) {
            return v.getElementsByTagName(a);
          }, !0)));
        }
      };
      function t(a) {
        return ae.extend(a, F);
      }
    }, { underscore: 117 }], 37: [function(le, ce, re) {
      var ae = le("../promises"), J = le("sax"), o = le("underscore"), F = le("./nodes"), t = F.Element;
      re.readString = a;
      function a(h, e) {
        e = e || {};
        var y = !1, c = J.parser(!0, { xmlns: !0, position: !1 }), d = { children: [] }, m = d, p = [], g = ae.defer();
        c.onopentag = function(i) {
          var l = v(i.attributes, function(w) {
            return w.value;
          }, n), u = new t(n(i), l);
          m.children.push(u), p.push(m), m = u;
        };
        function n(i) {
          if (i.uri) {
            var l = e[i.uri], u;
            return l ? u = l + ":" : u = "{" + i.uri + "}", u + i.local;
          } else
            return i.local;
        }
        return c.onclosetag = function(i) {
          m = p.pop();
        }, c.ontext = function(i) {
          m !== d && m.children.push(F.text(i));
        }, c.onend = function() {
          y || (y = !0, g.resolve(d.children[0]));
        }, c.onerror = function(i) {
          y || (y = !0, g.reject(i));
        }, c.write(h).close(), g.promise;
      }
      function v(h, e, y) {
        return o.reduce(h, function(c, d, m) {
          var p = y(d, m, h);
          return c[p] = e(d, m, h), c;
        }, {});
      }
    }, { "../promises": 23, "./nodes": 36, sax: 114, underscore: 117 }], 38: [function(le, ce, re) {
      var ae = le("underscore"), J = le("xmlbuilder");
      re.writeString = o;
      function o(t, a) {
        var v = ae.invert(a), h = {
          element: y,
          text: F
        };
        function e(m, p) {
          return h[p.type](m, p);
        }
        function y(m, p) {
          var g = m.element(c(p.name), p.attributes);
          p.children.forEach(function(n) {
            e(g, n);
          });
        }
        function c(m) {
          var p = /^\{(.*)\}(.*)$/.exec(m);
          if (p) {
            var g = v[p[1]];
            return g + (g === "" ? "" : ":") + p[2];
          } else
            return m;
        }
        function d(m) {
          var p = J.create(c(m.name), {
            version: "1.0",
            encoding: "UTF-8",
            standalone: !0
          });
          return ae.forEach(a, function(g, n) {
            var i = "xmlns" + (n === "" ? "" : ":" + n);
            p.attribute(i, g);
          }), m.children.forEach(function(g) {
            e(p, g);
          }), p.end();
        }
        return d(t);
      }
      function F(t, a) {
        t.text(a.value);
      }
    }, { underscore: 117, xmlbuilder: 143 }], 39: [function(le, ce, re) {
      (function(ae) {
        var J = le("jszip");
        re.openArrayBuffer = o, re.splitPath = t, re.joinPath = a;
        function o(v) {
          return J.loadAsync(v).then(function(h) {
            function e(m) {
              return h.file(m) !== null;
            }
            function y(m, p) {
              return h.file(m).async("uint8array").then(function(g) {
                var n = F(g);
                return p ? n.toString(p) : n;
              });
            }
            function c(m, p) {
              h.file(m, p);
            }
            function d() {
              return h.generateAsync({ type: "nodebuffer" });
            }
            return {
              exists: e,
              read: y,
              write: c,
              toBuffer: d
            };
          });
        }
        function F(v) {
          return ae.from && ae.from !== Uint8Array.from ? ae.from(v) : new ae(v);
        }
        function t(v) {
          var h = v.lastIndexOf("/");
          return h === -1 ? { dirname: "", basename: v } : {
            dirname: v.substring(0, h),
            basename: v.substring(h + 1)
          };
        }
        function a() {
          var v = Array.prototype.filter.call(arguments, function(e) {
            return e;
          }), h = [];
          return v.forEach(function(e) {
            /^\//.test(e) ? h = [e] : h.push(e);
          }), h.join("/");
        }
      }).call(this, le("buffer").Buffer);
    }, { buffer: 78, jszip: 87 }], 40: [function(le, ce, re) {
      re.byteLength = h, re.toByteArray = e, re.fromByteArray = d;
      for (var ae = [], J = [], o = typeof Uint8Array < "u" ? Uint8Array : Array, F = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t = 0, a = F.length; t < a; ++t)
        ae[t] = F[t], J[F.charCodeAt(t)] = t;
      J["-".charCodeAt(0)] = 62, J["_".charCodeAt(0)] = 63;
      function v(m) {
        var p = m.length;
        if (p % 4 > 0)
          throw new Error("Invalid string. Length must be a multiple of 4");
        return m[p - 2] === "=" ? 2 : m[p - 1] === "=" ? 1 : 0;
      }
      function h(m) {
        return m.length * 3 / 4 - v(m);
      }
      function e(m) {
        var p, g, n, i, l, u, w = m.length;
        l = v(m), u = new o(w * 3 / 4 - l), n = l > 0 ? w - 4 : w;
        var O = 0;
        for (p = 0, g = 0; p < n; p += 4, g += 3)
          i = J[m.charCodeAt(p)] << 18 | J[m.charCodeAt(p + 1)] << 12 | J[m.charCodeAt(p + 2)] << 6 | J[m.charCodeAt(p + 3)], u[O++] = i >> 16 & 255, u[O++] = i >> 8 & 255, u[O++] = i & 255;
        return l === 2 ? (i = J[m.charCodeAt(p)] << 2 | J[m.charCodeAt(p + 1)] >> 4, u[O++] = i & 255) : l === 1 && (i = J[m.charCodeAt(p)] << 10 | J[m.charCodeAt(p + 1)] << 4 | J[m.charCodeAt(p + 2)] >> 2, u[O++] = i >> 8 & 255, u[O++] = i & 255), u;
      }
      function y(m) {
        return ae[m >> 18 & 63] + ae[m >> 12 & 63] + ae[m >> 6 & 63] + ae[m & 63];
      }
      function c(m, p, g) {
        for (var n, i = [], l = p; l < g; l += 3)
          n = (m[l] << 16) + (m[l + 1] << 8) + m[l + 2], i.push(y(n));
        return i.join("");
      }
      function d(m) {
        for (var p, g = m.length, n = g % 3, i = "", l = [], u = 16383, w = 0, O = g - n; w < O; w += u)
          l.push(c(m, w, w + u > O ? O : w + u));
        return n === 1 ? (p = m[g - 1], i += ae[p >> 2], i += ae[p << 4 & 63], i += "==") : n === 2 && (p = (m[g - 2] << 8) + m[g - 1], i += ae[p >> 10], i += ae[p >> 4 & 63], i += ae[p << 2 & 63], i += "="), l.push(i), l.join("");
      }
    }, {}], 41: [function(le, ce, re) {
      ce.exports = function(ae) {
        var J = ae._SomePromiseArray;
        function o(F) {
          var t = new J(F), a = t.promise();
          return t.setHowMany(1), t.setUnwrap(), t.init(), a;
        }
        ae.any = function(F) {
          return o(F);
        }, ae.prototype.any = function() {
          return o(this);
        };
      };
    }, {}], 42: [function(le, ce, re) {
      (function(ae) {
        var J;
        try {
          throw new Error();
        } catch (y) {
          J = y;
        }
        var o = le("./schedule"), F = le("./queue"), t = le("./util");
        function a() {
          this._customScheduler = !1, this._isTickUsed = !1, this._lateQueue = new F(16), this._normalQueue = new F(16), this._haveDrainedQueues = !1, this._trampolineEnabled = !0;
          var y = this;
          this.drainQueues = function() {
            y._drainQueues();
          }, this._schedule = o;
        }
        a.prototype.setScheduler = function(y) {
          var c = this._schedule;
          return this._schedule = y, this._customScheduler = !0, c;
        }, a.prototype.hasCustomScheduler = function() {
          return this._customScheduler;
        }, a.prototype.enableTrampoline = function() {
          this._trampolineEnabled = !0;
        }, a.prototype.disableTrampolineIfNecessary = function() {
          t.hasDevTools && (this._trampolineEnabled = !1);
        }, a.prototype.haveItemsQueued = function() {
          return this._isTickUsed || this._haveDrainedQueues;
        }, a.prototype.fatalError = function(y, c) {
          c ? (ae.stderr.write("Fatal " + (y instanceof Error ? y.stack : y) + `
`), ae.exit(2)) : this.throwLater(y);
        }, a.prototype.throwLater = function(y, c) {
          if (arguments.length === 1 && (c = y, y = function() {
            throw c;
          }), typeof setTimeout < "u")
            setTimeout(function() {
              y(c);
            }, 0);
          else
            try {
              this._schedule(function() {
                y(c);
              });
            } catch {
              throw new Error(`No async scheduler available

    See http://goo.gl/MqrFmX
`);
            }
        };
        function v(y, c, d) {
          this._lateQueue.push(y, c, d), this._queueTick();
        }
        function h(y, c, d) {
          this._normalQueue.push(y, c, d), this._queueTick();
        }
        function e(y) {
          this._normalQueue._pushOne(y), this._queueTick();
        }
        t.hasDevTools ? (a.prototype.invokeLater = function(y, c, d) {
          this._trampolineEnabled ? v.call(this, y, c, d) : this._schedule(function() {
            setTimeout(function() {
              y.call(c, d);
            }, 100);
          });
        }, a.prototype.invoke = function(y, c, d) {
          this._trampolineEnabled ? h.call(this, y, c, d) : this._schedule(function() {
            y.call(c, d);
          });
        }, a.prototype.settlePromises = function(y) {
          this._trampolineEnabled ? e.call(this, y) : this._schedule(function() {
            y._settlePromises();
          });
        }) : (a.prototype.invokeLater = v, a.prototype.invoke = h, a.prototype.settlePromises = e), a.prototype._drainQueue = function(y) {
          for (; y.length() > 0; ) {
            var c = y.shift();
            if (typeof c != "function") {
              c._settlePromises();
              continue;
            }
            var d = y.shift(), m = y.shift();
            c.call(d, m);
          }
        }, a.prototype._drainQueues = function() {
          this._drainQueue(this._normalQueue), this._reset(), this._haveDrainedQueues = !0, this._drainQueue(this._lateQueue);
        }, a.prototype._queueTick = function() {
          this._isTickUsed || (this._isTickUsed = !0, this._schedule(this.drainQueues));
        }, a.prototype._reset = function() {
          this._isTickUsed = !1;
        }, ce.exports = a, ce.exports.firstLineError = J;
      }).call(this, le("_process"));
    }, { "./queue": 65, "./schedule": 68, "./util": 75, _process: 102 }], 43: [function(le, ce, re) {
      ce.exports = function(ae, J, o, F) {
        var t = !1, a = function(y, c) {
          this._reject(c);
        }, v = function(y, c) {
          c.promiseRejectionQueued = !0, c.bindingPromise._then(a, a, null, this, y);
        }, h = function(y, c) {
          this._bitField & 50397184 || this._resolveCallback(c.target);
        }, e = function(y, c) {
          c.promiseRejectionQueued || this._reject(y);
        };
        ae.prototype.bind = function(y) {
          t || (t = !0, ae.prototype._propagateFrom = F.propagateFromFunction(), ae.prototype._boundValue = F.boundValueFunction());
          var c = o(y), d = new ae(J);
          d._propagateFrom(this, 1);
          var m = this._target();
          if (d._setBoundTo(c), c instanceof ae) {
            var p = {
              promiseRejectionQueued: !1,
              promise: d,
              target: m,
              bindingPromise: c
            };
            m._then(J, v, void 0, d, p), c._then(
              h,
              e,
              void 0,
              d,
              p
            ), d._setOnCancel(c);
          } else
            d._resolveCallback(m);
          return d;
        }, ae.prototype._setBoundTo = function(y) {
          y !== void 0 ? (this._bitField = this._bitField | 2097152, this._boundTo = y) : this._bitField = this._bitField & -2097153;
        }, ae.prototype._isBound = function() {
          return (this._bitField & 2097152) === 2097152;
        }, ae.bind = function(y, c) {
          return ae.resolve(c).bind(y);
        };
      };
    }, {}], 44: [function(le, ce, re) {
      var ae = Object.create;
      if (ae) {
        var J = ae(null), o = ae(null);
        J[" size"] = o[" size"] = 0;
      }
      ce.exports = function(F) {
        var t = le("./util"), a = t.canEvaluate, v = t.isIdentifier, h, e;
        {
          var y = function(i) {
            return new Function("ensureMethod", `                                    
	        return function(obj) {                                               
	            'use strict'                                                     
	            var len = this.length;                                           
	            ensureMethod(obj, 'methodName');                                 
	            switch(len) {                                                    
	                case 1: return obj.methodName(this[0]);                      
	                case 2: return obj.methodName(this[0], this[1]);             
	                case 3: return obj.methodName(this[0], this[1], this[2]);    
	                case 0: return obj.methodName();                             
	                default:                                                     
	                    return obj.methodName.apply(obj, this);                  
	            }                                                                
	        };                                                                   
	        `.replace(/methodName/g, i))(m);
          }, c = function(i) {
            return new Function("obj", `                                             
	        'use strict';                                                        
	        return obj.propertyName;                                             
	        `.replace("propertyName", i));
          }, d = function(i, l, u) {
            var w = u[i];
            if (typeof w != "function") {
              if (!v(i))
                return null;
              if (w = l(i), u[i] = w, u[" size"]++, u[" size"] > 512) {
                for (var O = Object.keys(u), b = 0; b < 256; ++b)
                  delete u[O[b]];
                u[" size"] = O.length - 256;
              }
            }
            return w;
          };
          h = function(i) {
            return d(i, y, J);
          }, e = function(i) {
            return d(i, c, o);
          };
        }
        function m(i, l) {
          var u;
          if (i != null && (u = i[l]), typeof u != "function") {
            var w = "Object " + t.classString(i) + " has no method '" + t.toString(l) + "'";
            throw new F.TypeError(w);
          }
          return u;
        }
        function p(i) {
          var l = this.pop(), u = m(i, l);
          return u.apply(i, this);
        }
        F.prototype.call = function(i) {
          for (var l = arguments.length, u = new Array(Math.max(l - 1, 0)), w = 1; w < l; ++w)
            u[w - 1] = arguments[w];
          if (a) {
            var O = h(i);
            if (O !== null)
              return this._then(
                O,
                void 0,
                void 0,
                u,
                void 0
              );
          }
          return u.push(i), this._then(p, void 0, void 0, u, void 0);
        };
        function g(i) {
          return i[this];
        }
        function n(i) {
          var l = +this;
          return l < 0 && (l = Math.max(0, l + i.length)), i[l];
        }
        F.prototype.get = function(i) {
          var l = typeof i == "number", u;
          if (l)
            u = n;
          else if (a) {
            var w = e(i);
            u = w !== null ? w : g;
          } else
            u = g;
          return this._then(u, void 0, void 0, i, void 0);
        };
      };
    }, { "./util": 75 }], 45: [function(le, ce, re) {
      ce.exports = function(ae, J, o, F) {
        var t = le("./util"), a = t.tryCatch, v = t.errorObj, h = ae._async;
        ae.prototype.break = ae.prototype.cancel = function() {
          if (!F.cancellation())
            return this._warn("cancellation is disabled");
          for (var e = this, y = e; e._isCancellable(); ) {
            if (!e._cancelBy(y)) {
              y._isFollowing() ? y._followee().cancel() : y._cancelBranched();
              break;
            }
            var c = e._cancellationParent;
            if (c == null || !c._isCancellable()) {
              e._isFollowing() ? e._followee().cancel() : e._cancelBranched();
              break;
            } else
              e._isFollowing() && e._followee().cancel(), e._setWillBeCancelled(), y = e, e = c;
          }
        }, ae.prototype._branchHasCancelled = function() {
          this._branchesRemainingToCancel--;
        }, ae.prototype._enoughBranchesHaveCancelled = function() {
          return this._branchesRemainingToCancel === void 0 || this._branchesRemainingToCancel <= 0;
        }, ae.prototype._cancelBy = function(e) {
          return e === this ? (this._branchesRemainingToCancel = 0, this._invokeOnCancel(), !0) : (this._branchHasCancelled(), this._enoughBranchesHaveCancelled() ? (this._invokeOnCancel(), !0) : !1);
        }, ae.prototype._cancelBranched = function() {
          this._enoughBranchesHaveCancelled() && this._cancel();
        }, ae.prototype._cancel = function() {
          this._isCancellable() && (this._setCancelled(), h.invoke(this._cancelPromises, this, void 0));
        }, ae.prototype._cancelPromises = function() {
          this._length() > 0 && this._settlePromises();
        }, ae.prototype._unsetOnCancel = function() {
          this._onCancelField = void 0;
        }, ae.prototype._isCancellable = function() {
          return this.isPending() && !this._isCancelled();
        }, ae.prototype.isCancellable = function() {
          return this.isPending() && !this.isCancelled();
        }, ae.prototype._doInvokeOnCancel = function(e, y) {
          if (t.isArray(e))
            for (var c = 0; c < e.length; ++c)
              this._doInvokeOnCancel(e[c], y);
          else if (e !== void 0)
            if (typeof e == "function") {
              if (!y) {
                var d = a(e).call(this._boundValue());
                d === v && (this._attachExtraTrace(d.e), h.throwLater(d.e));
              }
            } else
              e._resultCancelled(this);
        }, ae.prototype._invokeOnCancel = function() {
          var e = this._onCancel();
          this._unsetOnCancel(), h.invoke(this._doInvokeOnCancel, this, e);
        }, ae.prototype._invokeInternalOnCancel = function() {
          this._isCancellable() && (this._doInvokeOnCancel(this._onCancel(), !0), this._unsetOnCancel());
        }, ae.prototype._resultCancelled = function() {
          this.cancel();
        };
      };
    }, { "./util": 75 }], 46: [function(le, ce, re) {
      ce.exports = function(ae) {
        var J = le("./util"), o = le("./es5").keys, F = J.tryCatch, t = J.errorObj;
        function a(v, h, e) {
          return function(y) {
            var c = e._boundValue();
            e:
              for (var d = 0; d < v.length; ++d) {
                var m = v[d];
                if (m === Error || m != null && m.prototype instanceof Error) {
                  if (y instanceof m)
                    return F(h).call(c, y);
                } else if (typeof m == "function") {
                  var p = F(m).call(c, y);
                  if (p === t)
                    return p;
                  if (p)
                    return F(h).call(c, y);
                } else if (J.isObject(y)) {
                  for (var g = o(m), n = 0; n < g.length; ++n) {
                    var i = g[n];
                    if (m[i] != y[i])
                      continue e;
                  }
                  return F(h).call(c, y);
                }
              }
            return ae;
          };
        }
        return a;
      };
    }, { "./es5": 52, "./util": 75 }], 47: [function(le, ce, re) {
      ce.exports = function(ae) {
        var J = !1, o = [];
        ae.prototype._promiseCreated = function() {
        }, ae.prototype._pushContext = function() {
        }, ae.prototype._popContext = function() {
          return null;
        }, ae._peekContext = ae.prototype._peekContext = function() {
        };
        function F() {
          this._trace = new F.CapturedTrace(a());
        }
        F.prototype._pushContext = function() {
          this._trace !== void 0 && (this._trace._promiseCreated = null, o.push(this._trace));
        }, F.prototype._popContext = function() {
          if (this._trace !== void 0) {
            var v = o.pop(), h = v._promiseCreated;
            return v._promiseCreated = null, h;
          }
          return null;
        };
        function t() {
          if (J)
            return new F();
        }
        function a() {
          var v = o.length - 1;
          if (v >= 0)
            return o[v];
        }
        return F.CapturedTrace = null, F.create = t, F.deactivateLongStackTraces = function() {
        }, F.activateLongStackTraces = function() {
          var v = ae.prototype._pushContext, h = ae.prototype._popContext, e = ae._peekContext, y = ae.prototype._peekContext, c = ae.prototype._promiseCreated;
          F.deactivateLongStackTraces = function() {
            ae.prototype._pushContext = v, ae.prototype._popContext = h, ae._peekContext = e, ae.prototype._peekContext = y, ae.prototype._promiseCreated = c, J = !1;
          }, J = !0, ae.prototype._pushContext = F.prototype._pushContext, ae.prototype._popContext = F.prototype._popContext, ae._peekContext = ae.prototype._peekContext = a, ae.prototype._promiseCreated = function() {
            var d = this._peekContext();
            d && d._promiseCreated == null && (d._promiseCreated = this);
          };
        }, F;
      };
    }, {}], 48: [function(le, ce, re) {
      (function(ae) {
        ce.exports = function(J, o) {
          var F = J._getDomain, t = J._async, a = le("./errors").Warning, v = le("./util"), h = v.canAttachTrace, e, y, c = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/, d = /\((?:timers\.js):\d+:\d+\)/, m = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/, p = null, g = null, n = !1, i, l = !!(v.env("BLUEBIRD_DEBUG") != 0 && (v.env("BLUEBIRD_DEBUG") || v.env("NODE_ENV") === "development")), u = !!(v.env("BLUEBIRD_WARNINGS") != 0 && (l || v.env("BLUEBIRD_WARNINGS"))), w = !!(v.env("BLUEBIRD_LONG_STACK_TRACES") != 0 && (l || v.env("BLUEBIRD_LONG_STACK_TRACES"))), O = v.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (u || !!v.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
          J.prototype.suppressUnhandledRejections = function() {
            var de = this._target();
            de._bitField = de._bitField & -1048577 | 524288;
          }, J.prototype._ensurePossibleRejectionHandled = function() {
            this._bitField & 524288 || (this._setRejectionIsUnhandled(), t.invokeLater(this._notifyUnhandledRejection, this, void 0));
          }, J.prototype._notifyUnhandledRejectionIsHandled = function() {
            Q(
              "rejectionHandled",
              e,
              void 0,
              this
            );
          }, J.prototype._setReturnedNonUndefined = function() {
            this._bitField = this._bitField | 268435456;
          }, J.prototype._returnedNonUndefined = function() {
            return (this._bitField & 268435456) !== 0;
          }, J.prototype._notifyUnhandledRejection = function() {
            if (this._isRejectionUnhandled()) {
              var de = this._settledValue();
              this._setUnhandledRejectionIsNotified(), Q(
                "unhandledRejection",
                y,
                de,
                this
              );
            }
          }, J.prototype._setUnhandledRejectionIsNotified = function() {
            this._bitField = this._bitField | 262144;
          }, J.prototype._unsetUnhandledRejectionIsNotified = function() {
            this._bitField = this._bitField & -262145;
          }, J.prototype._isUnhandledRejectionNotified = function() {
            return (this._bitField & 262144) > 0;
          }, J.prototype._setRejectionIsUnhandled = function() {
            this._bitField = this._bitField | 1048576;
          }, J.prototype._unsetRejectionIsUnhandled = function() {
            this._bitField = this._bitField & -1048577, this._isUnhandledRejectionNotified() && (this._unsetUnhandledRejectionIsNotified(), this._notifyUnhandledRejectionIsHandled());
          }, J.prototype._isRejectionUnhandled = function() {
            return (this._bitField & 1048576) > 0;
          }, J.prototype._warn = function(de, pe, xe) {
            return z(de, pe, xe || this);
          }, J.onPossiblyUnhandledRejection = function(de) {
            var pe = F();
            y = typeof de == "function" ? pe === null ? de : v.domainBind(pe, de) : void 0;
          }, J.onUnhandledRejectionHandled = function(de) {
            var pe = F();
            e = typeof de == "function" ? pe === null ? de : v.domainBind(pe, de) : void 0;
          };
          var b = function() {
          };
          J.longStackTraces = function() {
            if (t.haveItemsQueued() && !fe.longStackTraces)
              throw new Error(`cannot enable long stack traces after promises have been created

    See http://goo.gl/MqrFmX
`);
            if (!fe.longStackTraces && oe()) {
              var de = J.prototype._captureStackTrace, pe = J.prototype._attachExtraTrace;
              fe.longStackTraces = !0, b = function() {
                if (t.haveItemsQueued() && !fe.longStackTraces)
                  throw new Error(`cannot enable long stack traces after promises have been created

    See http://goo.gl/MqrFmX
`);
                J.prototype._captureStackTrace = de, J.prototype._attachExtraTrace = pe, o.deactivateLongStackTraces(), t.enableTrampoline(), fe.longStackTraces = !1;
              }, J.prototype._captureStackTrace = M, J.prototype._attachExtraTrace = G, o.activateLongStackTraces(), t.disableTrampolineIfNecessary();
            }
          }, J.hasLongStackTraces = function() {
            return fe.longStackTraces && oe();
          };
          var A = function() {
            try {
              if (typeof CustomEvent == "function") {
                var de = new CustomEvent("CustomEvent");
                return v.global.dispatchEvent(de), function(pe, xe) {
                  var Fe = new CustomEvent(pe.toLowerCase(), {
                    detail: xe,
                    cancelable: !0
                  });
                  return !v.global.dispatchEvent(Fe);
                };
              } else if (typeof Event == "function") {
                var de = new Event("CustomEvent");
                return v.global.dispatchEvent(de), function(xe, Fe) {
                  var Se = new Event(xe.toLowerCase(), {
                    cancelable: !0
                  });
                  return Se.detail = Fe, !v.global.dispatchEvent(Se);
                };
              } else {
                var de = document.createEvent("CustomEvent");
                return de.initCustomEvent("testingtheevent", !1, !0, {}), v.global.dispatchEvent(de), function(xe, Fe) {
                  var Se = document.createEvent("CustomEvent");
                  return Se.initCustomEvent(
                    xe.toLowerCase(),
                    !1,
                    !0,
                    Fe
                  ), !v.global.dispatchEvent(Se);
                };
              }
            } catch {
            }
            return function() {
              return !1;
            };
          }(), Y = function() {
            return v.isNode ? function() {
              return ae.emit.apply(ae, arguments);
            } : v.global ? function(de) {
              var pe = "on" + de.toLowerCase(), xe = v.global[pe];
              return xe ? (xe.apply(v.global, [].slice.call(arguments, 1)), !0) : !1;
            } : function() {
              return !1;
            };
          }();
          function j(de, pe) {
            return { promise: pe };
          }
          var X = {
            promiseCreated: j,
            promiseFulfilled: j,
            promiseRejected: j,
            promiseResolved: j,
            promiseCancelled: j,
            promiseChained: function(de, pe, xe) {
              return { promise: pe, child: xe };
            },
            warning: function(de, pe) {
              return { warning: pe };
            },
            unhandledRejection: function(de, pe, xe) {
              return { reason: pe, promise: xe };
            },
            rejectionHandled: j
          }, B = function(de) {
            var pe = !1;
            try {
              pe = Y.apply(null, arguments);
            } catch (Fe) {
              t.throwLater(Fe), pe = !0;
            }
            var xe = !1;
            try {
              xe = A(
                de,
                X[de].apply(null, arguments)
              );
            } catch (Fe) {
              t.throwLater(Fe), xe = !0;
            }
            return xe || pe;
          };
          J.config = function(de) {
            if (de = Object(de), "longStackTraces" in de && (de.longStackTraces ? J.longStackTraces() : !de.longStackTraces && J.hasLongStackTraces() && b()), "warnings" in de) {
              var pe = de.warnings;
              fe.warnings = !!pe, O = fe.warnings, v.isObject(pe) && "wForgottenReturn" in pe && (O = !!pe.wForgottenReturn);
            }
            if ("cancellation" in de && de.cancellation && !fe.cancellation) {
              if (t.haveItemsQueued())
                throw new Error(
                  "cannot enable cancellation after promises are in use"
                );
              J.prototype._clearCancellationData = _, J.prototype._propagateFrom = S, J.prototype._onCancel = f, J.prototype._setOnCancel = D, J.prototype._attachCancellationCallback = x, J.prototype._execute = k, T = S, fe.cancellation = !0;
            }
            return "monitoring" in de && (de.monitoring && !fe.monitoring ? (fe.monitoring = !0, J.prototype._fireEvent = B) : !de.monitoring && fe.monitoring && (fe.monitoring = !1, J.prototype._fireEvent = U)), J;
          };
          function U() {
            return !1;
          }
          J.prototype._fireEvent = U, J.prototype._execute = function(de, pe, xe) {
            try {
              de(pe, xe);
            } catch (Fe) {
              return Fe;
            }
          }, J.prototype._onCancel = function() {
          }, J.prototype._setOnCancel = function(de) {
          }, J.prototype._attachCancellationCallback = function(de) {
          }, J.prototype._captureStackTrace = function() {
          }, J.prototype._attachExtraTrace = function() {
          }, J.prototype._clearCancellationData = function() {
          }, J.prototype._propagateFrom = function(de, pe) {
          };
          function k(de, pe, xe) {
            var Fe = this;
            try {
              de(pe, xe, function(Se) {
                if (typeof Se != "function")
                  throw new TypeError("onCancel must be a function, got: " + v.toString(Se));
                Fe._attachCancellationCallback(Se);
              });
            } catch (Se) {
              return Se;
            }
          }
          function x(de) {
            if (!this._isCancellable())
              return this;
            var pe = this._onCancel();
            pe !== void 0 ? v.isArray(pe) ? pe.push(de) : this._setOnCancel([pe, de]) : this._setOnCancel(de);
          }
          function f() {
            return this._onCancelField;
          }
          function D(de) {
            this._onCancelField = de;
          }
          function _() {
            this._cancellationParent = void 0, this._onCancelField = void 0;
          }
          function S(de, pe) {
            if (pe & 1) {
              this._cancellationParent = de;
              var xe = de._branchesRemainingToCancel;
              xe === void 0 && (xe = 0), de._branchesRemainingToCancel = xe + 1;
            }
            pe & 2 && de._isBound() && this._setBoundTo(de._boundTo);
          }
          function C(de, pe) {
            pe & 2 && de._isBound() && this._setBoundTo(de._boundTo);
          }
          var T = C;
          function P() {
            var de = this._boundTo;
            return de !== void 0 && de instanceof J ? de.isFulfilled() ? de.value() : void 0 : de;
          }
          function M() {
            this._trace = new ie(this._peekContext());
          }
          function G(de, pe) {
            if (h(de)) {
              var xe = this._trace;
              if (xe !== void 0 && pe && (xe = xe._parent), xe !== void 0)
                xe.attachExtraTrace(de);
              else if (!de.__stackCleaned__) {
                var Fe = q(de);
                v.notEnumerableProp(
                  de,
                  "stack",
                  Fe.message + `
` + Fe.stack.join(`
`)
                ), v.notEnumerableProp(de, "__stackCleaned__", !0);
              }
            }
          }
          function Z(de, pe, xe, Fe, Se) {
            if (de === void 0 && pe !== null && O) {
              if (Se !== void 0 && Se._returnedNonUndefined() || !(Fe._bitField & 65535))
                return;
              xe && (xe = xe + " ");
              var Ce = "", ke = "";
              if (pe._trace) {
                for (var ye = pe._trace.stack.split(`
`), De = ne(ye), Ae = De.length - 1; Ae >= 0; --Ae) {
                  var Te = De[Ae];
                  if (!d.test(Te)) {
                    var ve = Te.match(m);
                    ve && (Ce = "at " + ve[1] + ":" + ve[2] + ":" + ve[3] + " ");
                    break;
                  }
                }
                if (De.length > 0) {
                  for (var Ne = De[0], Ae = 0; Ae < ye.length; ++Ae)
                    if (ye[Ae] === Ne) {
                      Ae > 0 && (ke = `
` + ye[Ae - 1]);
                      break;
                    }
                }
              }
              var Ge = "a promise was created in a " + xe + "handler " + Ce + "but was not returned from it, see http://goo.gl/rRqMUw" + ke;
              Fe._warn(Ge, !0, pe);
            }
          }
          function $(de, pe) {
            var xe = de + " is deprecated and will be removed in a future version.";
            return pe && (xe += " Use " + pe + " instead."), z(xe);
          }
          function z(de, pe, xe) {
            if (fe.warnings) {
              var Fe = new a(de), Se;
              if (pe)
                xe._attachExtraTrace(Fe);
              else if (fe.longStackTraces && (Se = J._peekContext()))
                Se.attachExtraTrace(Fe);
              else {
                var Ce = q(Fe);
                Fe.stack = Ce.message + `
` + Ce.stack.join(`
`);
              }
              B("warning", Fe) || N(Fe, "", !0);
            }
          }
          function V(de, pe) {
            for (var xe = 0; xe < pe.length - 1; ++xe)
              pe[xe].push("From previous event:"), pe[xe] = pe[xe].join(`
`);
            return xe < pe.length && (pe[xe] = pe[xe].join(`
`)), de + `
` + pe.join(`
`);
          }
          function L(de) {
            for (var pe = 0; pe < de.length; ++pe)
              (de[pe].length === 0 || pe + 1 < de.length && de[pe][0] === de[pe + 1][0]) && (de.splice(pe, 1), pe--);
          }
          function K(de) {
            for (var pe = de[0], xe = 1; xe < de.length; ++xe) {
              for (var Fe = de[xe], Se = pe.length - 1, Ce = pe[Se], ke = -1, ye = Fe.length - 1; ye >= 0; --ye)
                if (Fe[ye] === Ce) {
                  ke = ye;
                  break;
                }
              for (var ye = ke; ye >= 0; --ye) {
                var De = Fe[ye];
                if (pe[Se] === De)
                  pe.pop(), Se--;
                else
                  break;
              }
              pe = Fe;
            }
          }
          function ne(de) {
            for (var pe = [], xe = 0; xe < de.length; ++xe) {
              var Fe = de[xe], Se = Fe === "    (No stack trace)" || p.test(Fe), Ce = Se && ee(Fe);
              Se && !Ce && (n && Fe.charAt(0) !== " " && (Fe = "    " + Fe), pe.push(Fe));
            }
            return pe;
          }
          function se(de) {
            for (var pe = de.stack.replace(/\s+$/g, "").split(`
`), xe = 0; xe < pe.length; ++xe) {
              var Fe = pe[xe];
              if (Fe === "    (No stack trace)" || p.test(Fe))
                break;
            }
            return xe > 0 && de.name != "SyntaxError" && (pe = pe.slice(xe)), pe;
          }
          function q(de) {
            var pe = de.stack, xe = de.toString();
            return pe = typeof pe == "string" && pe.length > 0 ? se(de) : ["    (No stack trace)"], {
              message: xe,
              stack: de.name == "SyntaxError" ? pe : ne(pe)
            };
          }
          function N(de, pe, xe) {
            if (typeof console < "u") {
              var Fe;
              if (v.isObject(de)) {
                var Se = de.stack;
                Fe = pe + g(Se, de);
              } else
                Fe = pe + String(de);
              typeof i == "function" ? i(Fe, xe) : (typeof console.log == "function" || typeof console.log == "object") && console.log(Fe);
            }
          }
          function Q(de, pe, xe, Fe) {
            var Se = !1;
            try {
              typeof pe == "function" && (Se = !0, de === "rejectionHandled" ? pe(Fe) : pe(xe, Fe));
            } catch (Ce) {
              t.throwLater(Ce);
            }
            de === "unhandledRejection" ? !B(de, xe, Fe) && !Se && N(xe, "Unhandled rejection ") : B(de, Fe);
          }
          function E(de) {
            var pe;
            if (typeof de == "function")
              pe = "[function " + (de.name || "anonymous") + "]";
            else {
              pe = de && typeof de.toString == "function" ? de.toString() : v.toString(de);
              var xe = /\[object [a-zA-Z0-9$_]+\]/;
              if (xe.test(pe))
                try {
                  var Fe = JSON.stringify(de);
                  pe = Fe;
                } catch {
                }
              pe.length === 0 && (pe = "(empty array)");
            }
            return "(<" + te(pe) + ">, no stack trace)";
          }
          function te(de) {
            var pe = 41;
            return de.length < pe ? de : de.substr(0, pe - 3) + "...";
          }
          function oe() {
            return typeof ue == "function";
          }
          var ee = function() {
            return !1;
          }, W = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
          function I(de) {
            var pe = de.match(W);
            if (pe)
              return {
                fileName: pe[1],
                line: parseInt(pe[2], 10)
              };
          }
          function H(de, pe) {
            if (oe()) {
              for (var xe = de.stack.split(`
`), Fe = pe.stack.split(`
`), Se = -1, Ce = -1, ke, ye, De = 0; De < xe.length; ++De) {
                var Ae = I(xe[De]);
                if (Ae) {
                  ke = Ae.fileName, Se = Ae.line;
                  break;
                }
              }
              for (var De = 0; De < Fe.length; ++De) {
                var Ae = I(Fe[De]);
                if (Ae) {
                  ye = Ae.fileName, Ce = Ae.line;
                  break;
                }
              }
              Se < 0 || Ce < 0 || !ke || !ye || ke !== ye || Se >= Ce || (ee = function(Te) {
                if (c.test(Te))
                  return !0;
                var ve = I(Te);
                return !!(ve && ve.fileName === ke && Se <= ve.line && ve.line <= Ce);
              });
            }
          }
          function ie(de) {
            this._parent = de, this._promisesCreated = 0;
            var pe = this._length = 1 + (de === void 0 ? 0 : de._length);
            ue(this, ie), pe > 32 && this.uncycle();
          }
          v.inherits(ie, Error), o.CapturedTrace = ie, ie.prototype.uncycle = function() {
            var de = this._length;
            if (!(de < 2)) {
              for (var pe = [], xe = {}, Fe = 0, Se = this; Se !== void 0; ++Fe)
                pe.push(Se), Se = Se._parent;
              de = this._length = Fe;
              for (var Fe = de - 1; Fe >= 0; --Fe) {
                var Ce = pe[Fe].stack;
                xe[Ce] === void 0 && (xe[Ce] = Fe);
              }
              for (var Fe = 0; Fe < de; ++Fe) {
                var ke = pe[Fe].stack, ye = xe[ke];
                if (ye !== void 0 && ye !== Fe) {
                  ye > 0 && (pe[ye - 1]._parent = void 0, pe[ye - 1]._length = 1), pe[Fe]._parent = void 0, pe[Fe]._length = 1;
                  var De = Fe > 0 ? pe[Fe - 1] : this;
                  ye < de - 1 ? (De._parent = pe[ye + 1], De._parent.uncycle(), De._length = De._parent._length + 1) : (De._parent = void 0, De._length = 1);
                  for (var Ae = De._length + 1, Te = Fe - 2; Te >= 0; --Te)
                    pe[Te]._length = Ae, Ae++;
                  return;
                }
              }
            }
          }, ie.prototype.attachExtraTrace = function(de) {
            if (!de.__stackCleaned__) {
              this.uncycle();
              for (var pe = q(de), xe = pe.message, Fe = [pe.stack], Se = this; Se !== void 0; )
                Fe.push(ne(Se.stack.split(`
`))), Se = Se._parent;
              K(Fe), L(Fe), v.notEnumerableProp(de, "stack", V(xe, Fe)), v.notEnumerableProp(de, "__stackCleaned__", !0);
            }
          };
          var ue = function() {
            var pe = /^\s*at\s*/, xe = function(ke, ye) {
              return typeof ke == "string" ? ke : ye.name !== void 0 && ye.message !== void 0 ? ye.toString() : E(ye);
            };
            if (typeof Error.stackTraceLimit == "number" && typeof Error.captureStackTrace == "function") {
              Error.stackTraceLimit += 6, p = pe, g = xe;
              var Fe = Error.captureStackTrace;
              return ee = function(ke) {
                return c.test(ke);
              }, function(ke, ye) {
                Error.stackTraceLimit += 6, Fe(ke, ye), Error.stackTraceLimit -= 6;
              };
            }
            var Se = new Error();
            if (typeof Se.stack == "string" && Se.stack.split(`
`)[0].indexOf("stackDetection@") >= 0)
              return p = /@/, g = xe, n = !0, function(ye) {
                ye.stack = new Error().stack;
              };
            var Ce;
            try {
              throw new Error();
            } catch (ke) {
              Ce = "stack" in ke;
            }
            return !("stack" in Se) && Ce && typeof Error.stackTraceLimit == "number" ? (p = pe, g = xe, function(ye) {
              Error.stackTraceLimit += 6;
              try {
                throw new Error();
              } catch (De) {
                ye.stack = De.stack;
              }
              Error.stackTraceLimit -= 6;
            }) : (g = function(ke, ye) {
              return typeof ke == "string" ? ke : (typeof ye == "object" || typeof ye == "function") && ye.name !== void 0 && ye.message !== void 0 ? ye.toString() : E(ye);
            }, null);
          }();
          typeof console < "u" && typeof console.warn < "u" && (i = function(de) {
            console.warn(de);
          }, v.isNode && ae.stderr.isTTY ? i = function(de, pe) {
            var xe = pe ? "\x1B[33m" : "\x1B[31m";
            console.warn(xe + de + `\x1B[0m
`);
          } : !v.isNode && typeof new Error().stack == "string" && (i = function(de, pe) {
            console.warn(
              "%c" + de,
              pe ? "color: darkorange" : "color: red"
            );
          }));
          var fe = {
            warnings: u,
            longStackTraces: !1,
            cancellation: !1,
            monitoring: !1
          };
          return w && J.longStackTraces(), {
            longStackTraces: function() {
              return fe.longStackTraces;
            },
            warnings: function() {
              return fe.warnings;
            },
            cancellation: function() {
              return fe.cancellation;
            },
            monitoring: function() {
              return fe.monitoring;
            },
            propagateFromFunction: function() {
              return T;
            },
            boundValueFunction: function() {
              return P;
            },
            checkForgottenReturns: Z,
            setBounds: H,
            warn: z,
            deprecated: $,
            CapturedTrace: ie,
            fireDomEvent: A,
            fireGlobalEvent: Y
          };
        };
      }).call(this, le("_process"));
    }, { "./errors": 51, "./util": 75, _process: 102 }], 49: [function(le, ce, re) {
      ce.exports = function(ae) {
        function J() {
          return this.value;
        }
        function o() {
          throw this.reason;
        }
        ae.prototype.return = ae.prototype.thenReturn = function(F) {
          return F instanceof ae && F.suppressUnhandledRejections(), this._then(
            J,
            void 0,
            void 0,
            { value: F },
            void 0
          );
        }, ae.prototype.throw = ae.prototype.thenThrow = function(F) {
          return this._then(
            o,
            void 0,
            void 0,
            { reason: F },
            void 0
          );
        }, ae.prototype.catchThrow = function(F) {
          if (arguments.length <= 1)
            return this._then(
              void 0,
              o,
              void 0,
              { reason: F },
              void 0
            );
          var t = arguments[1], a = function() {
            throw t;
          };
          return this.caught(F, a);
        }, ae.prototype.catchReturn = function(F) {
          if (arguments.length <= 1)
            return F instanceof ae && F.suppressUnhandledRejections(), this._then(
              void 0,
              J,
              void 0,
              { value: F },
              void 0
            );
          var t = arguments[1];
          t instanceof ae && t.suppressUnhandledRejections();
          var a = function() {
            return t;
          };
          return this.caught(F, a);
        };
      };
    }, {}], 50: [function(le, ce, re) {
      ce.exports = function(ae, J) {
        var o = ae.reduce, F = ae.all;
        function t() {
          return F(this);
        }
        function a(v, h) {
          return o(v, h, J, J);
        }
        ae.prototype.each = function(v) {
          return o(this, v, J, 0)._then(t, void 0, void 0, this, void 0);
        }, ae.prototype.mapSeries = function(v) {
          return o(this, v, J, J);
        }, ae.each = function(v, h) {
          return o(v, h, J, 0)._then(t, void 0, void 0, v, void 0);
        }, ae.mapSeries = a;
      };
    }, {}], 51: [function(le, ce, re) {
      var ae = le("./es5"), J = ae.freeze, o = le("./util"), F = o.inherits, t = o.notEnumerableProp;
      function a(l, u) {
        function w(O) {
          if (!(this instanceof w))
            return new w(O);
          t(
            this,
            "message",
            typeof O == "string" ? O : u
          ), t(this, "name", l), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : Error.call(this);
        }
        return F(w, Error), w;
      }
      var v, h, e = a("Warning", "warning"), y = a("CancellationError", "cancellation error"), c = a("TimeoutError", "timeout error"), d = a("AggregateError", "aggregate error");
      try {
        v = TypeError, h = RangeError;
      } catch {
        v = a("TypeError", "type error"), h = a("RangeError", "range error");
      }
      for (var m = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" "), p = 0; p < m.length; ++p)
        typeof Array.prototype[m[p]] == "function" && (d.prototype[m[p]] = Array.prototype[m[p]]);
      ae.defineProperty(d.prototype, "length", {
        value: 0,
        configurable: !1,
        writable: !0,
        enumerable: !0
      }), d.prototype.isOperational = !0;
      var g = 0;
      d.prototype.toString = function() {
        var l = Array(g * 4 + 1).join(" "), u = `
` + l + `AggregateError of:
`;
        g++, l = Array(g * 4 + 1).join(" ");
        for (var w = 0; w < this.length; ++w) {
          for (var O = this[w] === this ? "[Circular AggregateError]" : this[w] + "", b = O.split(`
`), A = 0; A < b.length; ++A)
            b[A] = l + b[A];
          O = b.join(`
`), u += O + `
`;
        }
        return g--, u;
      };
      function n(l) {
        if (!(this instanceof n))
          return new n(l);
        t(this, "name", "OperationalError"), t(this, "message", l), this.cause = l, this.isOperational = !0, l instanceof Error ? (t(this, "message", l.message), t(this, "stack", l.stack)) : Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
      }
      F(n, Error);
      var i = Error.__BluebirdErrorTypes__;
      i || (i = J({
        CancellationError: y,
        TimeoutError: c,
        OperationalError: n,
        RejectionError: n,
        AggregateError: d
      }), ae.defineProperty(Error, "__BluebirdErrorTypes__", {
        value: i,
        writable: !1,
        enumerable: !1,
        configurable: !1
      })), ce.exports = {
        Error,
        TypeError: v,
        RangeError: h,
        CancellationError: i.CancellationError,
        OperationalError: i.OperationalError,
        TimeoutError: i.TimeoutError,
        AggregateError: i.AggregateError,
        Warning: e
      };
    }, { "./es5": 52, "./util": 75 }], 52: [function(le, ce, re) {
      var ae = function() {
        return this === void 0;
      }();
      if (ae)
        ce.exports = {
          freeze: Object.freeze,
          defineProperty: Object.defineProperty,
          getDescriptor: Object.getOwnPropertyDescriptor,
          keys: Object.keys,
          names: Object.getOwnPropertyNames,
          getPrototypeOf: Object.getPrototypeOf,
          isArray: Array.isArray,
          isES5: ae,
          propertyIsWritable: function(c, d) {
            var m = Object.getOwnPropertyDescriptor(c, d);
            return !!(!m || m.writable || m.set);
          }
        };
      else {
        var J = {}.hasOwnProperty, o = {}.toString, F = {}.constructor.prototype, t = function(c) {
          var d = [];
          for (var m in c)
            J.call(c, m) && d.push(m);
          return d;
        }, a = function(c, d) {
          return { value: c[d] };
        }, v = function(c, d, m) {
          return c[d] = m.value, c;
        }, h = function(c) {
          return c;
        }, e = function(c) {
          try {
            return Object(c).constructor.prototype;
          } catch {
            return F;
          }
        }, y = function(c) {
          try {
            return o.call(c) === "[object Array]";
          } catch {
            return !1;
          }
        };
        ce.exports = {
          isArray: y,
          keys: t,
          names: t,
          defineProperty: v,
          getDescriptor: a,
          freeze: h,
          getPrototypeOf: e,
          isES5: ae,
          propertyIsWritable: function() {
            return !0;
          }
        };
      }
    }, {}], 53: [function(le, ce, re) {
      ce.exports = function(ae, J) {
        var o = ae.map;
        ae.prototype.filter = function(F, t) {
          return o(this, F, t, J);
        }, ae.filter = function(F, t, a) {
          return o(F, t, a, J);
        };
      };
    }, {}], 54: [function(le, ce, re) {
      ce.exports = function(ae, J) {
        var o = le("./util"), F = ae.CancellationError, t = o.errorObj;
        function a(d, m, p) {
          this.promise = d, this.type = m, this.handler = p, this.called = !1, this.cancelPromise = null;
        }
        a.prototype.isFinallyHandler = function() {
          return this.type === 0;
        };
        function v(d) {
          this.finallyHandler = d;
        }
        v.prototype._resultCancelled = function() {
          h(this.finallyHandler);
        };
        function h(d, m) {
          return d.cancelPromise != null ? (arguments.length > 1 ? d.cancelPromise._reject(m) : d.cancelPromise._cancel(), d.cancelPromise = null, !0) : !1;
        }
        function e() {
          return c.call(this, this.promise._target()._settledValue());
        }
        function y(d) {
          if (!h(this, d))
            return t.e = d, t;
        }
        function c(d) {
          var m = this.promise, p = this.handler;
          if (!this.called) {
            this.called = !0;
            var g = this.isFinallyHandler() ? p.call(m._boundValue()) : p.call(m._boundValue(), d);
            if (g !== void 0) {
              m._setReturnedNonUndefined();
              var n = J(g, m);
              if (n instanceof ae) {
                if (this.cancelPromise != null)
                  if (n._isCancelled()) {
                    var i = new F("late cancellation observer");
                    return m._attachExtraTrace(i), t.e = i, t;
                  } else
                    n.isPending() && n._attachCancellationCallback(
                      new v(this)
                    );
                return n._then(
                  e,
                  y,
                  void 0,
                  this,
                  void 0
                );
              }
            }
          }
          return m.isRejected() ? (h(this), t.e = d, t) : (h(this), d);
        }
        return ae.prototype._passThrough = function(d, m, p, g) {
          return typeof d != "function" ? this.then() : this._then(
            p,
            g,
            void 0,
            new a(this, m, d),
            void 0
          );
        }, ae.prototype.lastly = ae.prototype.finally = function(d) {
          return this._passThrough(
            d,
            0,
            c,
            c
          );
        }, ae.prototype.tap = function(d) {
          return this._passThrough(d, 1, c);
        }, a;
      };
    }, { "./util": 75 }], 55: [function(le, ce, re) {
      ce.exports = function(ae, J, o, F, t, a) {
        var v = le("./errors"), h = v.TypeError, e = le("./util"), y = e.errorObj, c = e.tryCatch, d = [];
        function m(g, n, i) {
          for (var l = 0; l < n.length; ++l) {
            i._pushContext();
            var u = c(n[l])(g);
            if (i._popContext(), u === y) {
              i._pushContext();
              var w = ae.reject(y.e);
              return i._popContext(), w;
            }
            var O = F(u, i);
            if (O instanceof ae)
              return O;
          }
          return null;
        }
        function p(g, n, i, l) {
          if (a.cancellation()) {
            var u = new ae(o), w = this._finallyPromise = new ae(o);
            this._promise = u.lastly(function() {
              return w;
            }), u._captureStackTrace(), u._setOnCancel(this);
          } else {
            var O = this._promise = new ae(o);
            O._captureStackTrace();
          }
          this._stack = l, this._generatorFunction = g, this._receiver = n, this._generator = void 0, this._yieldHandlers = typeof i == "function" ? [i].concat(d) : d, this._yieldedPromise = null, this._cancellationPhase = !1;
        }
        e.inherits(p, t), p.prototype._isResolved = function() {
          return this._promise === null;
        }, p.prototype._cleanup = function() {
          this._promise = this._generator = null, a.cancellation() && this._finallyPromise !== null && (this._finallyPromise._fulfill(), this._finallyPromise = null);
        }, p.prototype._promiseCancelled = function() {
          if (!this._isResolved()) {
            var g = typeof this._generator.return < "u", n;
            if (g)
              this._promise._pushContext(), n = c(this._generator.return).call(
                this._generator,
                void 0
              ), this._promise._popContext();
            else {
              var i = new ae.CancellationError(
                "generator .return() sentinel"
              );
              ae.coroutine.returnSentinel = i, this._promise._attachExtraTrace(i), this._promise._pushContext(), n = c(this._generator.throw).call(
                this._generator,
                i
              ), this._promise._popContext();
            }
            this._cancellationPhase = !0, this._yieldedPromise = null, this._continue(n);
          }
        }, p.prototype._promiseFulfilled = function(g) {
          this._yieldedPromise = null, this._promise._pushContext();
          var n = c(this._generator.next).call(this._generator, g);
          this._promise._popContext(), this._continue(n);
        }, p.prototype._promiseRejected = function(g) {
          this._yieldedPromise = null, this._promise._attachExtraTrace(g), this._promise._pushContext();
          var n = c(this._generator.throw).call(this._generator, g);
          this._promise._popContext(), this._continue(n);
        }, p.prototype._resultCancelled = function() {
          if (this._yieldedPromise instanceof ae) {
            var g = this._yieldedPromise;
            this._yieldedPromise = null, g.cancel();
          }
        }, p.prototype.promise = function() {
          return this._promise;
        }, p.prototype._run = function() {
          this._generator = this._generatorFunction.call(this._receiver), this._receiver = this._generatorFunction = void 0, this._promiseFulfilled(void 0);
        }, p.prototype._continue = function(g) {
          var n = this._promise;
          if (g === y)
            return this._cleanup(), this._cancellationPhase ? n.cancel() : n._rejectCallback(g.e, !1);
          var i = g.value;
          if (g.done === !0)
            return this._cleanup(), this._cancellationPhase ? n.cancel() : n._resolveCallback(i);
          var l = F(i, this._promise);
          if (!(l instanceof ae) && (l = m(
            l,
            this._yieldHandlers,
            this._promise
          ), l === null)) {
            this._promiseRejected(
              new h(
                `A value %s was yielded that could not be treated as a promise

    See http://goo.gl/MqrFmX

`.replace("%s", i) + `From coroutine:
` + this._stack.split(`
`).slice(1, -7).join(`
`)
              )
            );
            return;
          }
          l = l._target();
          var u = l._bitField;
          u & 50397184 ? u & 33554432 ? ae._async.invoke(
            this._promiseFulfilled,
            this,
            l._value()
          ) : u & 16777216 ? ae._async.invoke(
            this._promiseRejected,
            this,
            l._reason()
          ) : this._promiseCancelled() : (this._yieldedPromise = l, l._proxy(this, null));
        }, ae.coroutine = function(g, n) {
          if (typeof g != "function")
            throw new h(`generatorFunction must be a function

    See http://goo.gl/MqrFmX
`);
          var i = Object(n).yieldHandler, l = p, u = new Error().stack;
          return function() {
            var w = g.apply(this, arguments), O = new l(
              void 0,
              void 0,
              i,
              u
            ), b = O.promise();
            return O._generator = w, O._promiseFulfilled(void 0), b;
          };
        }, ae.coroutine.addYieldHandler = function(g) {
          if (typeof g != "function")
            throw new h("expecting a function but got " + e.classString(g));
          d.push(g);
        }, ae.spawn = function(g) {
          if (a.deprecated("Promise.spawn()", "Promise.coroutine()"), typeof g != "function")
            return J(`generatorFunction must be a function

    See http://goo.gl/MqrFmX
`);
          var n = new p(g, this), i = n.promise();
          return n._run(ae.spawn), i;
        };
      };
    }, { "./errors": 51, "./util": 75 }], 56: [function(le, ce, re) {
      ce.exports = function(ae, J, o, F, t, a) {
        var v = le("./util"), h = v.canEvaluate, e = v.tryCatch, y = v.errorObj, c;
        if (h) {
          for (var d = function(u) {
            return new Function("value", "holder", `                             
	            'use strict';                                                    
	            holder.pIndex = value;                                           
	            holder.checkFulfillment(this);                                   
	            `.replace(/Index/g, u));
          }, m = function(u) {
            return new Function("promise", "holder", `                           
	            'use strict';                                                    
	            holder.pIndex = promise;                                         
	            `.replace(/Index/g, u));
          }, p = function(u) {
            for (var w = new Array(u), O = 0; O < w.length; ++O)
              w[O] = "this.p" + (O + 1);
            var b = w.join(" = ") + " = null;", A = `var promise;
` + w.map(function(B) {
              return `                                                         
	                promise = ` + B + `;                                      
	                if (promise instanceof Promise) {                            
	                    promise.cancel();                                        
	                }                                                            
	            `;
            }).join(`
`), Y = w.join(", "), j = "Holder$" + u, X = `return function(tryCatch, errorObj, Promise, async) {    
	            'use strict';                                                    
	            function [TheName](fn) {                                         
	                [TheProperties]                                              
	                this.fn = fn;                                                
	                this.asyncNeeded = true;                                     
	                this.now = 0;                                                
	            }                                                                
	                                                                             
	            [TheName].prototype._callFunction = function(promise) {          
	                promise._pushContext();                                      
	                var ret = tryCatch(this.fn)([ThePassedArguments]);           
	                promise._popContext();                                       
	                if (ret === errorObj) {                                      
	                    promise._rejectCallback(ret.e, false);                   
	                } else {                                                     
	                    promise._resolveCallback(ret);                           
	                }                                                            
	            };                                                               
	                                                                             
	            [TheName].prototype.checkFulfillment = function(promise) {       
	                var now = ++this.now;                                        
	                if (now === [TheTotal]) {                                    
	                    if (this.asyncNeeded) {                                  
	                        async.invoke(this._callFunction, this, promise);     
	                    } else {                                                 
	                        this._callFunction(promise);                         
	                    }                                                        
	                                                                             
	                }                                                            
	            };                                                               
	                                                                             
	            [TheName].prototype._resultCancelled = function() {              
	                [CancellationCode]                                           
	            };                                                               
	                                                                             
	            return [TheName];                                                
	        }(tryCatch, errorObj, Promise, async);                               
	        `;
            return X = X.replace(/\[TheName\]/g, j).replace(/\[TheTotal\]/g, u).replace(/\[ThePassedArguments\]/g, Y).replace(/\[TheProperties\]/g, b).replace(/\[CancellationCode\]/g, A), new Function("tryCatch", "errorObj", "Promise", "async", X)(e, y, ae, t);
          }, g = [], n = [], i = [], l = 0; l < 8; ++l)
            g.push(p(l + 1)), n.push(d(l + 1)), i.push(m(l + 1));
          c = function(u) {
            this._reject(u);
          };
        }
        ae.join = function() {
          var u = arguments.length - 1, w;
          if (u > 0 && typeof arguments[u] == "function" && (w = arguments[u], u <= 8 && h)) {
            var f = new ae(F);
            f._captureStackTrace();
            for (var O = g[u - 1], b = new O(w), A = n, Y = 0; Y < u; ++Y) {
              var j = o(arguments[Y], f);
              if (j instanceof ae) {
                j = j._target();
                var X = j._bitField;
                X & 50397184 ? X & 33554432 ? A[Y].call(
                  f,
                  j._value(),
                  b
                ) : X & 16777216 ? f._reject(j._reason()) : f._cancel() : (j._then(
                  A[Y],
                  c,
                  void 0,
                  f,
                  b
                ), i[Y](j, b), b.asyncNeeded = !1);
              } else
                A[Y].call(f, j, b);
            }
            if (!f._isFateSealed()) {
              if (b.asyncNeeded) {
                var B = a();
                B !== null && (b.fn = v.domainBind(B, b.fn));
              }
              f._setAsyncGuaranteed(), f._setOnCancel(b);
            }
            return f;
          }
          for (var U = arguments.length, k = new Array(U), x = 0; x < U; ++x)
            k[x] = arguments[x];
          w && k.pop();
          var f = new J(k).promise();
          return w !== void 0 ? f.spread(w) : f;
        };
      };
    }, { "./util": 75 }], 57: [function(le, ce, re) {
      ce.exports = function(ae, J, o, F, t, a) {
        var v = ae._getDomain, h = le("./util"), e = h.tryCatch, y = h.errorObj, c = ae._async;
        function d(p, g, n, i) {
          this.constructor$(p), this._promise._captureStackTrace();
          var l = v();
          this._callback = l === null ? g : h.domainBind(l, g), this._preservedValues = i === t ? new Array(this.length()) : null, this._limit = n, this._inFlight = 0, this._queue = [], c.invoke(this._asyncInit, this, void 0);
        }
        h.inherits(d, J), d.prototype._asyncInit = function() {
          this._init$(void 0, -2);
        }, d.prototype._init = function() {
        }, d.prototype._promiseFulfilled = function(p, g) {
          var n = this._values, i = this.length(), l = this._preservedValues, u = this._limit;
          if (g < 0) {
            if (g = g * -1 - 1, n[g] = p, u >= 1 && (this._inFlight--, this._drainQueue(), this._isResolved()))
              return !0;
          } else {
            if (u >= 1 && this._inFlight >= u)
              return n[g] = p, this._queue.push(g), !1;
            l !== null && (l[g] = p);
            var w = this._promise, O = this._callback, b = w._boundValue();
            w._pushContext();
            var A = e(O).call(b, p, g, i), Y = w._popContext();
            if (a.checkForgottenReturns(
              A,
              Y,
              l !== null ? "Promise.filter" : "Promise.map",
              w
            ), A === y)
              return this._reject(A.e), !0;
            var j = F(A, this._promise);
            if (j instanceof ae) {
              j = j._target();
              var X = j._bitField;
              if (X & 50397184)
                if (X & 33554432)
                  A = j._value();
                else
                  return X & 16777216 ? (this._reject(j._reason()), !0) : (this._cancel(), !0);
              else
                return u >= 1 && this._inFlight++, n[g] = j, j._proxy(this, (g + 1) * -1), !1;
            }
            n[g] = A;
          }
          var B = ++this._totalResolved;
          return B >= i ? (l !== null ? this._filter(n, l) : this._resolve(n), !0) : !1;
        }, d.prototype._drainQueue = function() {
          for (var p = this._queue, g = this._limit, n = this._values; p.length > 0 && this._inFlight < g; ) {
            if (this._isResolved())
              return;
            var i = p.pop();
            this._promiseFulfilled(n[i], i);
          }
        }, d.prototype._filter = function(p, g) {
          for (var n = g.length, i = new Array(n), l = 0, u = 0; u < n; ++u)
            p[u] && (i[l++] = g[u]);
          i.length = l, this._resolve(i);
        }, d.prototype.preservedValues = function() {
          return this._preservedValues;
        };
        function m(p, g, n, i) {
          if (typeof g != "function")
            return o("expecting a function but got " + h.classString(g));
          var l = 0;
          if (n !== void 0)
            if (typeof n == "object" && n !== null) {
              if (typeof n.concurrency != "number")
                return ae.reject(
                  new TypeError("'concurrency' must be a number but it is " + h.classString(n.concurrency))
                );
              l = n.concurrency;
            } else
              return ae.reject(new TypeError(
                "options argument must be an object but it is " + h.classString(n)
              ));
          return l = typeof l == "number" && isFinite(l) && l >= 1 ? l : 0, new d(p, g, l, i).promise();
        }
        ae.prototype.map = function(p, g) {
          return m(this, p, g, null);
        }, ae.map = function(p, g, n, i) {
          return m(p, g, n, i);
        };
      };
    }, { "./util": 75 }], 58: [function(le, ce, re) {
      ce.exports = function(ae, J, o, F, t) {
        var a = le("./util"), v = a.tryCatch;
        ae.method = function(h) {
          if (typeof h != "function")
            throw new ae.TypeError("expecting a function but got " + a.classString(h));
          return function() {
            var e = new ae(J);
            e._captureStackTrace(), e._pushContext();
            var y = v(h).apply(this, arguments), c = e._popContext();
            return t.checkForgottenReturns(
              y,
              c,
              "Promise.method",
              e
            ), e._resolveFromSyncValue(y), e;
          };
        }, ae.attempt = ae.try = function(h) {
          if (typeof h != "function")
            return F("expecting a function but got " + a.classString(h));
          var e = new ae(J);
          e._captureStackTrace(), e._pushContext();
          var y;
          if (arguments.length > 1) {
            t.deprecated("calling Promise.try with more than 1 argument");
            var c = arguments[1], d = arguments[2];
            y = a.isArray(c) ? v(h).apply(d, c) : v(h).call(d, c);
          } else
            y = v(h)();
          var m = e._popContext();
          return t.checkForgottenReturns(
            y,
            m,
            "Promise.try",
            e
          ), e._resolveFromSyncValue(y), e;
        }, ae.prototype._resolveFromSyncValue = function(h) {
          h === a.errorObj ? this._rejectCallback(h.e, !1) : this._resolveCallback(h, !0);
        };
      };
    }, { "./util": 75 }], 59: [function(le, ce, re) {
      var ae = le("./util"), J = ae.maybeWrapAsError, o = le("./errors"), F = o.OperationalError, t = le("./es5");
      function a(y) {
        return y instanceof Error && t.getPrototypeOf(y) === Error.prototype;
      }
      var v = /^(?:name|message|stack|cause)$/;
      function h(y) {
        var c;
        if (a(y)) {
          c = new F(y), c.name = y.name, c.message = y.message, c.stack = y.stack;
          for (var d = t.keys(y), m = 0; m < d.length; ++m) {
            var p = d[m];
            v.test(p) || (c[p] = y[p]);
          }
          return c;
        }
        return ae.markAsOriginatingFromRejection(y), y;
      }
      function e(y, c) {
        return function(d, m) {
          if (y !== null) {
            if (d) {
              var p = h(J(d));
              y._attachExtraTrace(p), y._reject(p);
            } else if (!c)
              y._fulfill(m);
            else {
              for (var g = arguments.length, n = new Array(Math.max(g - 1, 0)), i = 1; i < g; ++i)
                n[i - 1] = arguments[i];
              y._fulfill(n);
            }
            y = null;
          }
        };
      }
      ce.exports = e;
    }, { "./errors": 51, "./es5": 52, "./util": 75 }], 60: [function(le, ce, re) {
      ce.exports = function(ae) {
        var J = le("./util"), o = ae._async, F = J.tryCatch, t = J.errorObj;
        function a(e, y) {
          var c = this;
          if (!J.isArray(e))
            return v.call(c, e, y);
          var d = F(y).apply(c._boundValue(), [null].concat(e));
          d === t && o.throwLater(d.e);
        }
        function v(e, y) {
          var c = this, d = c._boundValue(), m = e === void 0 ? F(y).call(d, null) : F(y).call(d, null, e);
          m === t && o.throwLater(m.e);
        }
        function h(e, y) {
          var c = this;
          if (!e) {
            var d = new Error(e + "");
            d.cause = e, e = d;
          }
          var m = F(y).call(c._boundValue(), e);
          m === t && o.throwLater(m.e);
        }
        ae.prototype.asCallback = ae.prototype.nodeify = function(e, y) {
          if (typeof e == "function") {
            var c = v;
            y !== void 0 && Object(y).spread && (c = a), this._then(
              c,
              h,
              void 0,
              this,
              e
            );
          }
          return this;
        };
      };
    }, { "./util": 75 }], 61: [function(le, ce, re) {
      (function(ae) {
        ce.exports = function() {
          var J = function() {
            return new m(`circular promise resolution chain

    See http://goo.gl/MqrFmX
`);
          }, o = function() {
            return new k.PromiseInspection(this._target());
          }, F = function(_) {
            return k.reject(new m(_));
          };
          function t() {
          }
          var a = {}, v = le("./util"), h;
          v.isNode ? h = function() {
            var _ = ae.domain;
            return _ === void 0 && (_ = null), _;
          } : h = function() {
            return null;
          }, v.notEnumerableProp(k, "_getDomain", h);
          var e = le("./es5"), y = le("./async"), c = new y();
          e.defineProperty(k, "_async", { value: c });
          var d = le("./errors"), m = k.TypeError = d.TypeError;
          k.RangeError = d.RangeError;
          var p = k.CancellationError = d.CancellationError;
          k.TimeoutError = d.TimeoutError, k.OperationalError = d.OperationalError, k.RejectionError = d.OperationalError, k.AggregateError = d.AggregateError;
          var g = function() {
          }, n = {}, i = {}, l = le("./thenables")(k, g), u = le("./promise_array")(
            k,
            g,
            l,
            F,
            t
          ), w = le("./context")(k), O = w.create, b = le("./debuggability")(k, w);
          b.CapturedTrace;
          var A = le("./finally")(k, l), Y = le("./catch_filter")(i), j = le("./nodeback"), X = v.errorObj, B = v.tryCatch;
          function U(_, S) {
            if (typeof S != "function")
              throw new m("expecting a function but got " + v.classString(S));
            if (_.constructor !== k)
              throw new m(`the promise constructor cannot be invoked directly

    See http://goo.gl/MqrFmX
`);
          }
          function k(_) {
            this._bitField = 0, this._fulfillmentHandler0 = void 0, this._rejectionHandler0 = void 0, this._promise0 = void 0, this._receiver0 = void 0, _ !== g && (U(this, _), this._resolveFromExecutor(_)), this._promiseCreated(), this._fireEvent("promiseCreated", this);
          }
          k.prototype.toString = function() {
            return "[object Promise]";
          }, k.prototype.caught = k.prototype.catch = function(_) {
            var S = arguments.length;
            if (S > 1) {
              var C = new Array(S - 1), T = 0, P;
              for (P = 0; P < S - 1; ++P) {
                var M = arguments[P];
                if (v.isObject(M))
                  C[T++] = M;
                else
                  return F("expecting an object but got A catch statement predicate " + v.classString(M));
              }
              return C.length = T, _ = arguments[P], this.then(void 0, Y(C, _, this));
            }
            return this.then(void 0, _);
          }, k.prototype.reflect = function() {
            return this._then(
              o,
              o,
              void 0,
              this,
              void 0
            );
          }, k.prototype.then = function(_, S) {
            if (b.warnings() && arguments.length > 0 && typeof _ != "function" && typeof S != "function") {
              var C = ".then() only accepts functions but was passed: " + v.classString(_);
              arguments.length > 1 && (C += ", " + v.classString(S)), this._warn(C);
            }
            return this._then(_, S, void 0, void 0, void 0);
          }, k.prototype.done = function(_, S) {
            var C = this._then(_, S, void 0, void 0, void 0);
            C._setIsFinal();
          }, k.prototype.spread = function(_) {
            return typeof _ != "function" ? F("expecting a function but got " + v.classString(_)) : this.all()._then(_, void 0, void 0, n, void 0);
          }, k.prototype.toJSON = function() {
            var _ = {
              isFulfilled: !1,
              isRejected: !1,
              fulfillmentValue: void 0,
              rejectionReason: void 0
            };
            return this.isFulfilled() ? (_.fulfillmentValue = this.value(), _.isFulfilled = !0) : this.isRejected() && (_.rejectionReason = this.reason(), _.isRejected = !0), _;
          }, k.prototype.all = function() {
            return arguments.length > 0 && this._warn(".all() was passed arguments but it does not take any"), new u(this).promise();
          }, k.prototype.error = function(_) {
            return this.caught(v.originatesFromRejection, _);
          }, k.getNewLibraryCopy = ce.exports, k.is = function(_) {
            return _ instanceof k;
          }, k.fromNode = k.fromCallback = function(_) {
            var S = new k(g);
            S._captureStackTrace();
            var C = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : !1, T = B(_)(j(S, C));
            return T === X && S._rejectCallback(T.e, !0), S._isFateSealed() || S._setAsyncGuaranteed(), S;
          }, k.all = function(_) {
            return new u(_).promise();
          }, k.cast = function(_) {
            var S = l(_);
            return S instanceof k || (S = new k(g), S._captureStackTrace(), S._setFulfilled(), S._rejectionHandler0 = _), S;
          }, k.resolve = k.fulfilled = k.cast, k.reject = k.rejected = function(_) {
            var S = new k(g);
            return S._captureStackTrace(), S._rejectCallback(_, !0), S;
          }, k.setScheduler = function(_) {
            if (typeof _ != "function")
              throw new m("expecting a function but got " + v.classString(_));
            return c.setScheduler(_);
          }, k.prototype._then = function(_, S, C, T, P) {
            var M = P !== void 0, G = M ? P : new k(g), Z = this._target(), $ = Z._bitField;
            M || (G._propagateFrom(this, 3), G._captureStackTrace(), T === void 0 && this._bitField & 2097152 && ($ & 50397184 ? T = this._boundValue() : T = Z === this ? void 0 : this._boundTo), this._fireEvent("promiseChained", this, G));
            var z = h();
            if ($ & 50397184) {
              var V, L, K = Z._settlePromiseCtx;
              $ & 33554432 ? (L = Z._rejectionHandler0, V = _) : $ & 16777216 ? (L = Z._fulfillmentHandler0, V = S, Z._unsetRejectionIsUnhandled()) : (K = Z._settlePromiseLateCancellationObserver, L = new p("late cancellation observer"), Z._attachExtraTrace(L), V = S), c.invoke(K, Z, {
                handler: z === null ? V : typeof V == "function" && v.domainBind(z, V),
                promise: G,
                receiver: T,
                value: L
              });
            } else
              Z._addCallbacks(_, S, G, T, z);
            return G;
          }, k.prototype._length = function() {
            return this._bitField & 65535;
          }, k.prototype._isFateSealed = function() {
            return (this._bitField & 117506048) !== 0;
          }, k.prototype._isFollowing = function() {
            return (this._bitField & 67108864) === 67108864;
          }, k.prototype._setLength = function(_) {
            this._bitField = this._bitField & -65536 | _ & 65535;
          }, k.prototype._setFulfilled = function() {
            this._bitField = this._bitField | 33554432, this._fireEvent("promiseFulfilled", this);
          }, k.prototype._setRejected = function() {
            this._bitField = this._bitField | 16777216, this._fireEvent("promiseRejected", this);
          }, k.prototype._setFollowing = function() {
            this._bitField = this._bitField | 67108864, this._fireEvent("promiseResolved", this);
          }, k.prototype._setIsFinal = function() {
            this._bitField = this._bitField | 4194304;
          }, k.prototype._isFinal = function() {
            return (this._bitField & 4194304) > 0;
          }, k.prototype._unsetCancelled = function() {
            this._bitField = this._bitField & -65537;
          }, k.prototype._setCancelled = function() {
            this._bitField = this._bitField | 65536, this._fireEvent("promiseCancelled", this);
          }, k.prototype._setWillBeCancelled = function() {
            this._bitField = this._bitField | 8388608;
          }, k.prototype._setAsyncGuaranteed = function() {
            c.hasCustomScheduler() || (this._bitField = this._bitField | 134217728);
          }, k.prototype._receiverAt = function(_) {
            var S = _ === 0 ? this._receiver0 : this[_ * 4 - 4 + 3];
            if (S !== a)
              return S === void 0 && this._isBound() ? this._boundValue() : S;
          }, k.prototype._promiseAt = function(_) {
            return this[_ * 4 - 4 + 2];
          }, k.prototype._fulfillmentHandlerAt = function(_) {
            return this[_ * 4 - 4 + 0];
          }, k.prototype._rejectionHandlerAt = function(_) {
            return this[_ * 4 - 4 + 1];
          }, k.prototype._boundValue = function() {
          }, k.prototype._migrateCallback0 = function(_) {
            _._bitField;
            var S = _._fulfillmentHandler0, C = _._rejectionHandler0, T = _._promise0, P = _._receiverAt(0);
            P === void 0 && (P = a), this._addCallbacks(S, C, T, P, null);
          }, k.prototype._migrateCallbackAt = function(_, S) {
            var C = _._fulfillmentHandlerAt(S), T = _._rejectionHandlerAt(S), P = _._promiseAt(S), M = _._receiverAt(S);
            M === void 0 && (M = a), this._addCallbacks(C, T, P, M, null);
          }, k.prototype._addCallbacks = function(_, S, C, T, P) {
            var M = this._length();
            if (M >= 65535 - 4 && (M = 0, this._setLength(0)), M === 0)
              this._promise0 = C, this._receiver0 = T, typeof _ == "function" && (this._fulfillmentHandler0 = P === null ? _ : v.domainBind(P, _)), typeof S == "function" && (this._rejectionHandler0 = P === null ? S : v.domainBind(P, S));
            else {
              var G = M * 4 - 4;
              this[G + 2] = C, this[G + 3] = T, typeof _ == "function" && (this[G + 0] = P === null ? _ : v.domainBind(P, _)), typeof S == "function" && (this[G + 1] = P === null ? S : v.domainBind(P, S));
            }
            return this._setLength(M + 1), M;
          }, k.prototype._proxy = function(_, S) {
            this._addCallbacks(void 0, void 0, S, _, null);
          }, k.prototype._resolveCallback = function(_, S) {
            if (!(this._bitField & 117506048)) {
              if (_ === this)
                return this._rejectCallback(J(), !1);
              var C = l(_, this);
              if (!(C instanceof k))
                return this._fulfill(_);
              S && this._propagateFrom(C, 2);
              var T = C._target();
              if (T === this) {
                this._reject(J());
                return;
              }
              var P = T._bitField;
              if (P & 50397184)
                if (P & 33554432)
                  this._fulfill(T._value());
                else if (P & 16777216)
                  this._reject(T._reason());
                else {
                  var Z = new p("late cancellation observer");
                  T._attachExtraTrace(Z), this._reject(Z);
                }
              else {
                var M = this._length();
                M > 0 && T._migrateCallback0(this);
                for (var G = 1; G < M; ++G)
                  T._migrateCallbackAt(this, G);
                this._setFollowing(), this._setLength(0), this._setFollowee(T);
              }
            }
          }, k.prototype._rejectCallback = function(_, S, C) {
            var T = v.ensureErrorObject(_), P = T === _;
            if (!P && !C && b.warnings()) {
              var M = "a promise was rejected with a non-error: " + v.classString(_);
              this._warn(M, !0);
            }
            this._attachExtraTrace(T, S ? P : !1), this._reject(_);
          }, k.prototype._resolveFromExecutor = function(_) {
            var S = this;
            this._captureStackTrace(), this._pushContext();
            var C = !0, T = this._execute(_, function(P) {
              S._resolveCallback(P);
            }, function(P) {
              S._rejectCallback(P, C);
            });
            C = !1, this._popContext(), T !== void 0 && S._rejectCallback(T, !0);
          }, k.prototype._settlePromiseFromHandler = function(_, S, C, T) {
            var P = T._bitField;
            if (!(P & 65536)) {
              T._pushContext();
              var M;
              S === n ? !C || typeof C.length != "number" ? (M = X, M.e = new m("cannot .spread() a non-array: " + v.classString(C))) : M = B(_).apply(this._boundValue(), C) : M = B(_).call(S, C);
              var G = T._popContext();
              P = T._bitField, !(P & 65536) && (M === i ? T._reject(C) : M === X ? T._rejectCallback(M.e, !1) : (b.checkForgottenReturns(M, G, "", T, this), T._resolveCallback(M)));
            }
          }, k.prototype._target = function() {
            for (var _ = this; _._isFollowing(); )
              _ = _._followee();
            return _;
          }, k.prototype._followee = function() {
            return this._rejectionHandler0;
          }, k.prototype._setFollowee = function(_) {
            this._rejectionHandler0 = _;
          }, k.prototype._settlePromise = function(_, S, C, T) {
            var P = _ instanceof k, M = this._bitField, G = (M & 134217728) !== 0;
            M & 65536 ? (P && _._invokeInternalOnCancel(), C instanceof A && C.isFinallyHandler() ? (C.cancelPromise = _, B(S).call(C, T) === X && _._reject(X.e)) : S === o ? _._fulfill(o.call(C)) : C instanceof t ? C._promiseCancelled(_) : P || _ instanceof u ? _._cancel() : C.cancel()) : typeof S == "function" ? P ? (G && _._setAsyncGuaranteed(), this._settlePromiseFromHandler(S, C, T, _)) : S.call(C, T, _) : C instanceof t ? C._isResolved() || (M & 33554432 ? C._promiseFulfilled(T, _) : C._promiseRejected(T, _)) : P && (G && _._setAsyncGuaranteed(), M & 33554432 ? _._fulfill(T) : _._reject(T));
          }, k.prototype._settlePromiseLateCancellationObserver = function(_) {
            var S = _.handler, C = _.promise, T = _.receiver, P = _.value;
            typeof S == "function" ? C instanceof k ? this._settlePromiseFromHandler(S, T, P, C) : S.call(T, P, C) : C instanceof k && C._reject(P);
          }, k.prototype._settlePromiseCtx = function(_) {
            this._settlePromise(_.promise, _.handler, _.receiver, _.value);
          }, k.prototype._settlePromise0 = function(_, S, C) {
            var T = this._promise0, P = this._receiverAt(0);
            this._promise0 = void 0, this._receiver0 = void 0, this._settlePromise(T, _, P, S);
          }, k.prototype._clearCallbackDataAtIndex = function(_) {
            var S = _ * 4 - 4;
            this[S + 2] = this[S + 3] = this[S + 0] = this[S + 1] = void 0;
          }, k.prototype._fulfill = function(_) {
            var S = this._bitField;
            if (!((S & 117506048) >>> 16)) {
              if (_ === this) {
                var C = J();
                return this._attachExtraTrace(C), this._reject(C);
              }
              this._setFulfilled(), this._rejectionHandler0 = _, (S & 65535) > 0 && (S & 134217728 ? this._settlePromises() : c.settlePromises(this));
            }
          }, k.prototype._reject = function(_) {
            var S = this._bitField;
            if (!((S & 117506048) >>> 16)) {
              if (this._setRejected(), this._fulfillmentHandler0 = _, this._isFinal())
                return c.fatalError(_, v.isNode);
              (S & 65535) > 0 ? c.settlePromises(this) : this._ensurePossibleRejectionHandled();
            }
          }, k.prototype._fulfillPromises = function(_, S) {
            for (var C = 1; C < _; C++) {
              var T = this._fulfillmentHandlerAt(C), P = this._promiseAt(C), M = this._receiverAt(C);
              this._clearCallbackDataAtIndex(C), this._settlePromise(P, T, M, S);
            }
          }, k.prototype._rejectPromises = function(_, S) {
            for (var C = 1; C < _; C++) {
              var T = this._rejectionHandlerAt(C), P = this._promiseAt(C), M = this._receiverAt(C);
              this._clearCallbackDataAtIndex(C), this._settlePromise(P, T, M, S);
            }
          }, k.prototype._settlePromises = function() {
            var _ = this._bitField, S = _ & 65535;
            if (S > 0) {
              if (_ & 16842752) {
                var C = this._fulfillmentHandler0;
                this._settlePromise0(this._rejectionHandler0, C, _), this._rejectPromises(S, C);
              } else {
                var T = this._rejectionHandler0;
                this._settlePromise0(this._fulfillmentHandler0, T, _), this._fulfillPromises(S, T);
              }
              this._setLength(0);
            }
            this._clearCancellationData();
          }, k.prototype._settledValue = function() {
            var _ = this._bitField;
            if (_ & 33554432)
              return this._rejectionHandler0;
            if (_ & 16777216)
              return this._fulfillmentHandler0;
          };
          function x(_) {
            this.promise._resolveCallback(_);
          }
          function f(_) {
            this.promise._rejectCallback(_, !1);
          }
          k.defer = k.pending = function() {
            b.deprecated("Promise.defer", "new Promise");
            var _ = new k(g);
            return {
              promise: _,
              resolve: x,
              reject: f
            };
          }, v.notEnumerableProp(
            k,
            "_makeSelfResolutionError",
            J
          ), le("./method")(
            k,
            g,
            l,
            F,
            b
          ), le("./bind")(k, g, l, b), le("./cancel")(k, u, F, b), le("./direct_resolve")(k), le("./synchronous_inspection")(k), le("./join")(
            k,
            u,
            l,
            g,
            c,
            h
          ), k.Promise = k, k.version = "3.4.7", le("./map.js")(k, u, F, l, g, b), le("./call_get.js")(k), le("./using.js")(k, F, l, O, g, b), le("./timers.js")(k, g, b), le("./generators.js")(k, F, g, l, t, b), le("./nodeify.js")(k), le("./promisify.js")(k, g), le("./props.js")(k, u, l, F), le("./race.js")(k, g, l, F), le("./reduce.js")(k, u, F, l, g, b), le("./settle.js")(k, u, b), le("./some.js")(k, u, F), le("./filter.js")(k, g), le("./each.js")(k, g), le("./any.js")(k), v.toFastProperties(k), v.toFastProperties(k.prototype);
          function D(_) {
            var S = new k(g);
            S._fulfillmentHandler0 = _, S._rejectionHandler0 = _, S._promise0 = _, S._receiver0 = _;
          }
          return D({ a: 1 }), D({ b: 2 }), D({ c: 3 }), D(1), D(function() {
          }), D(void 0), D(!1), D(new k(g)), b.setBounds(y.firstLineError, v.lastLineError), k;
        };
      }).call(this, le("_process"));
    }, { "./any.js": 41, "./async": 42, "./bind": 43, "./call_get.js": 44, "./cancel": 45, "./catch_filter": 46, "./context": 47, "./debuggability": 48, "./direct_resolve": 49, "./each.js": 50, "./errors": 51, "./es5": 52, "./filter.js": 53, "./finally": 54, "./generators.js": 55, "./join": 56, "./map.js": 57, "./method": 58, "./nodeback": 59, "./nodeify.js": 60, "./promise_array": 62, "./promisify.js": 63, "./props.js": 64, "./race.js": 66, "./reduce.js": 67, "./settle.js": 69, "./some.js": 70, "./synchronous_inspection": 71, "./thenables": 72, "./timers.js": 73, "./using.js": 74, "./util": 75, _process: 102 }], 62: [function(le, ce, re) {
      ce.exports = function(ae, J, o, F, t) {
        var a = le("./util");
        a.isArray;
        function v(e) {
          switch (e) {
            case -2:
              return [];
            case -3:
              return {};
          }
        }
        function h(e) {
          var y = this._promise = new ae(J);
          e instanceof ae && y._propagateFrom(e, 3), y._setOnCancel(this), this._values = e, this._length = 0, this._totalResolved = 0, this._init(void 0, -2);
        }
        return a.inherits(h, t), h.prototype.length = function() {
          return this._length;
        }, h.prototype.promise = function() {
          return this._promise;
        }, h.prototype._init = function e(y, c) {
          var d = o(this._values, this._promise);
          if (d instanceof ae) {
            d = d._target();
            var m = d._bitField;
            if (this._values = d, m & 50397184)
              if (m & 33554432)
                d = d._value();
              else
                return m & 16777216 ? this._reject(d._reason()) : this._cancel();
            else
              return this._promise._setAsyncGuaranteed(), d._then(
                e,
                this._reject,
                void 0,
                this,
                c
              );
          }
          if (d = a.asArray(d), d === null) {
            var p = F(
              "expecting an array or an iterable object but got " + a.classString(d)
            ).reason();
            this._promise._rejectCallback(p, !1);
            return;
          }
          if (d.length === 0) {
            c === -5 ? this._resolveEmptyArray() : this._resolve(v(c));
            return;
          }
          this._iterate(d);
        }, h.prototype._iterate = function(e) {
          var y = this.getActualLength(e.length);
          this._length = y, this._values = this.shouldCopyValues() ? new Array(y) : this._values;
          for (var c = this._promise, d = !1, m = null, p = 0; p < y; ++p) {
            var g = o(e[p], c);
            g instanceof ae ? (g = g._target(), m = g._bitField) : m = null, d ? m !== null && g.suppressUnhandledRejections() : m !== null ? m & 50397184 ? m & 33554432 ? d = this._promiseFulfilled(g._value(), p) : m & 16777216 ? d = this._promiseRejected(g._reason(), p) : d = this._promiseCancelled(p) : (g._proxy(this, p), this._values[p] = g) : d = this._promiseFulfilled(g, p);
          }
          d || c._setAsyncGuaranteed();
        }, h.prototype._isResolved = function() {
          return this._values === null;
        }, h.prototype._resolve = function(e) {
          this._values = null, this._promise._fulfill(e);
        }, h.prototype._cancel = function() {
          this._isResolved() || !this._promise._isCancellable() || (this._values = null, this._promise._cancel());
        }, h.prototype._reject = function(e) {
          this._values = null, this._promise._rejectCallback(e, !1);
        }, h.prototype._promiseFulfilled = function(e, y) {
          this._values[y] = e;
          var c = ++this._totalResolved;
          return c >= this._length ? (this._resolve(this._values), !0) : !1;
        }, h.prototype._promiseCancelled = function() {
          return this._cancel(), !0;
        }, h.prototype._promiseRejected = function(e) {
          return this._totalResolved++, this._reject(e), !0;
        }, h.prototype._resultCancelled = function() {
          if (!this._isResolved()) {
            var e = this._values;
            if (this._cancel(), e instanceof ae)
              e.cancel();
            else
              for (var y = 0; y < e.length; ++y)
                e[y] instanceof ae && e[y].cancel();
          }
        }, h.prototype.shouldCopyValues = function() {
          return !0;
        }, h.prototype.getActualLength = function(e) {
          return e;
        }, h;
      };
    }, { "./util": 75 }], 63: [function(le, ce, re) {
      ce.exports = function(ae, J) {
        var o = {}, F = le("./util"), t = le("./nodeback"), a = F.withAppended, v = F.maybeWrapAsError, h = F.canEvaluate, e = le("./errors").TypeError, y = "Async", c = { __isPromisified__: !0 }, d = [
          "arity",
          "length",
          "name",
          "arguments",
          "caller",
          "callee",
          "prototype",
          "__isPromisified__"
        ], m = new RegExp("^(?:" + d.join("|") + ")$"), p = function(x) {
          return F.isIdentifier(x) && x.charAt(0) !== "_" && x !== "constructor";
        };
        function g(x) {
          return !m.test(x);
        }
        function n(x) {
          try {
            return x.__isPromisified__ === !0;
          } catch {
            return !1;
          }
        }
        function i(x, f, D) {
          var _ = F.getDataPropertyOrDefault(
            x,
            f + D,
            c
          );
          return _ ? n(_) : !1;
        }
        function l(x, f, D) {
          for (var _ = 0; _ < x.length; _ += 2) {
            var S = x[_];
            if (D.test(S)) {
              for (var C = S.replace(D, ""), T = 0; T < x.length; T += 2)
                if (x[T] === C)
                  throw new e(`Cannot promisify an API that has normal methods with '%s'-suffix

    See http://goo.gl/MqrFmX
`.replace("%s", f));
            }
          }
        }
        function u(x, f, D, _) {
          for (var S = F.inheritedDataKeys(x), C = [], T = 0; T < S.length; ++T) {
            var P = S[T], M = x[P], G = _ === p ? !0 : p(P);
            typeof M == "function" && !n(M) && !i(x, P, f) && _(P, M, x, G) && C.push(P, M);
          }
          return l(C, f, D), C;
        }
        var w = function(x) {
          return x.replace(/([$])/, "\\$");
        }, O;
        {
          var b = function(x) {
            for (var f = [x], D = Math.max(0, x - 1 - 3), _ = x - 1; _ >= D; --_)
              f.push(_);
            for (var _ = x + 1; _ <= 3; ++_)
              f.push(_);
            return f;
          }, A = function(x) {
            return F.filledRange(x, "_arg", "");
          }, Y = function(x) {
            return F.filledRange(
              Math.max(x, 3),
              "_arg",
              ""
            );
          }, j = function(x) {
            return typeof x.length == "number" ? Math.max(Math.min(x.length, 1024), 0) : 0;
          };
          O = function(x, f, D, _, S, C) {
            var T = Math.max(0, j(_) - 1), P = b(T), M = typeof x == "string" || f === o;
            function G(V) {
              var L = A(V).join(", "), K = V > 0 ? ", " : "", ne;
              return M ? ne = `ret = callback.call(this, {{args}}, nodeback); break;
` : ne = f === void 0 ? `ret = callback({{args}}, nodeback); break;
` : `ret = callback.call(receiver, {{args}}, nodeback); break;
`, ne.replace("{{args}}", L).replace(", ", K);
            }
            function Z() {
              for (var V = "", L = 0; L < P.length; ++L)
                V += "case " + P[L] + ":" + G(P[L]);
              return V += `                                                             
	        default:                                                             
	            var args = new Array(len + 1);                                   
	            var i = 0;                                                       
	            for (var i = 0; i < len; ++i) {                                  
	               args[i] = arguments[i];                                       
	            }                                                                
	            args[i] = nodeback;                                              
	            [CodeForCall]                                                    
	            break;                                                           
	        `.replace("[CodeForCall]", M ? `ret = callback.apply(this, args);
` : `ret = callback.apply(receiver, args);
`), V;
            }
            var $ = typeof x == "string" ? "this != null ? this['" + x + "'] : fn" : "fn", z = `'use strict';                                                
	        var ret = function (Parameters) {                                    
	            'use strict';                                                    
	            var len = arguments.length;                                      
	            var promise = new Promise(INTERNAL);                             
	            promise._captureStackTrace();                                    
	            var nodeback = nodebackForPromise(promise, ` + C + `);   
	            var ret;                                                         
	            var callback = tryCatch([GetFunctionCode]);                      
	            switch(len) {                                                    
	                [CodeForSwitchCase]                                          
	            }                                                                
	            if (ret === errorObj) {                                          
	                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
	            }                                                                
	            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     
	            return promise;                                                  
	        };                                                                   
	        notEnumerableProp(ret, '__isPromisified__', true);                   
	        return ret;                                                          
	    `.replace("[CodeForSwitchCase]", Z()).replace("[GetFunctionCode]", $);
            return z = z.replace("Parameters", Y(T)), new Function(
              "Promise",
              "fn",
              "receiver",
              "withAppended",
              "maybeWrapAsError",
              "nodebackForPromise",
              "tryCatch",
              "errorObj",
              "notEnumerableProp",
              "INTERNAL",
              z
            )(
              ae,
              _,
              f,
              a,
              v,
              t,
              F.tryCatch,
              F.errorObj,
              F.notEnumerableProp,
              J
            );
          };
        }
        function X(x, f, D, _, S, C) {
          var T = function() {
            return this;
          }(), P = x;
          typeof P == "string" && (x = _);
          function M() {
            var G = f;
            f === o && (G = this);
            var Z = new ae(J);
            Z._captureStackTrace();
            var $ = typeof P == "string" && this !== T ? this[P] : x, z = t(Z, C);
            try {
              $.apply(G, a(arguments, z));
            } catch (V) {
              Z._rejectCallback(v(V), !0, !0);
            }
            return Z._isFateSealed() || Z._setAsyncGuaranteed(), Z;
          }
          return F.notEnumerableProp(M, "__isPromisified__", !0), M;
        }
        var B = h ? O : X;
        function U(x, f, D, _, S) {
          for (var C = new RegExp(w(f) + "$"), T = u(x, f, C, D), P = 0, M = T.length; P < M; P += 2) {
            var G = T[P], Z = T[P + 1], $ = G + f;
            if (_ === B)
              x[$] = B(G, o, G, Z, f, S);
            else {
              var z = _(Z, function() {
                return B(
                  G,
                  o,
                  G,
                  Z,
                  f,
                  S
                );
              });
              F.notEnumerableProp(z, "__isPromisified__", !0), x[$] = z;
            }
          }
          return F.toFastProperties(x), x;
        }
        function k(x, f, D) {
          return B(
            x,
            f,
            void 0,
            x,
            null,
            D
          );
        }
        ae.promisify = function(x, f) {
          if (typeof x != "function")
            throw new e("expecting a function but got " + F.classString(x));
          if (n(x))
            return x;
          f = Object(f);
          var D = f.context === void 0 ? o : f.context, _ = !!f.multiArgs, S = k(x, D, _);
          return F.copyDescriptors(x, S, g), S;
        }, ae.promisifyAll = function(x, f) {
          if (typeof x != "function" && typeof x != "object")
            throw new e(`the target of promisifyAll must be an object or a function

    See http://goo.gl/MqrFmX
`);
          f = Object(f);
          var D = !!f.multiArgs, _ = f.suffix;
          typeof _ != "string" && (_ = y);
          var S = f.filter;
          typeof S != "function" && (S = p);
          var C = f.promisifier;
          if (typeof C != "function" && (C = B), !F.isIdentifier(_))
            throw new RangeError(`suffix must be a valid identifier

    See http://goo.gl/MqrFmX
`);
          for (var T = F.inheritedDataKeys(x), P = 0; P < T.length; ++P) {
            var M = x[T[P]];
            T[P] !== "constructor" && F.isClass(M) && (U(
              M.prototype,
              _,
              S,
              C,
              D
            ), U(M, _, S, C, D));
          }
          return U(x, _, S, C, D);
        };
      };
    }, { "./errors": 51, "./nodeback": 59, "./util": 75 }], 64: [function(le, ce, re) {
      ce.exports = function(ae, J, o, F) {
        var t = le("./util"), a = t.isObject, v = le("./es5"), h;
        typeof Map == "function" && (h = Map);
        var e = function() {
          var m = 0, p = 0;
          function g(n, i) {
            this[m] = n, this[m + p] = i, m++;
          }
          return function(i) {
            p = i.size, m = 0;
            var l = new Array(i.size * 2);
            return i.forEach(g, l), l;
          };
        }(), y = function(m) {
          for (var p = new h(), g = m.length / 2 | 0, n = 0; n < g; ++n) {
            var i = m[g + n], l = m[n];
            p.set(i, l);
          }
          return p;
        };
        function c(m) {
          var p = !1, g;
          if (h !== void 0 && m instanceof h)
            g = e(m), p = !0;
          else {
            var n = v.keys(m), i = n.length;
            g = new Array(i * 2);
            for (var l = 0; l < i; ++l) {
              var u = n[l];
              g[l] = m[u], g[l + i] = u;
            }
          }
          this.constructor$(g), this._isMap = p, this._init$(void 0, -3);
        }
        t.inherits(c, J), c.prototype._init = function() {
        }, c.prototype._promiseFulfilled = function(m, p) {
          this._values[p] = m;
          var g = ++this._totalResolved;
          if (g >= this._length) {
            var n;
            if (this._isMap)
              n = y(this._values);
            else {
              n = {};
              for (var i = this.length(), l = 0, u = this.length(); l < u; ++l)
                n[this._values[l + i]] = this._values[l];
            }
            return this._resolve(n), !0;
          }
          return !1;
        }, c.prototype.shouldCopyValues = function() {
          return !1;
        }, c.prototype.getActualLength = function(m) {
          return m >> 1;
        };
        function d(m) {
          var p, g = o(m);
          if (a(g))
            g instanceof ae ? p = g._then(
              ae.props,
              void 0,
              void 0,
              void 0,
              void 0
            ) : p = new c(g).promise();
          else
            return F(`cannot await properties of a non-object

    See http://goo.gl/MqrFmX
`);
          return g instanceof ae && p._propagateFrom(g, 2), p;
        }
        ae.prototype.props = function() {
          return d(this);
        }, ae.props = function(m) {
          return d(m);
        };
      };
    }, { "./es5": 52, "./util": 75 }], 65: [function(le, ce, re) {
      function ae(o, F, t, a, v) {
        for (var h = 0; h < v; ++h)
          t[h + a] = o[h + F], o[h + F] = void 0;
      }
      function J(o) {
        this._capacity = o, this._length = 0, this._front = 0;
      }
      J.prototype._willBeOverCapacity = function(o) {
        return this._capacity < o;
      }, J.prototype._pushOne = function(o) {
        var F = this.length();
        this._checkCapacity(F + 1);
        var t = this._front + F & this._capacity - 1;
        this[t] = o, this._length = F + 1;
      }, J.prototype.push = function(o, F, t) {
        var a = this.length() + 3;
        if (this._willBeOverCapacity(a)) {
          this._pushOne(o), this._pushOne(F), this._pushOne(t);
          return;
        }
        var v = this._front + a - 3;
        this._checkCapacity(a);
        var h = this._capacity - 1;
        this[v + 0 & h] = o, this[v + 1 & h] = F, this[v + 2 & h] = t, this._length = a;
      }, J.prototype.shift = function() {
        var o = this._front, F = this[o];
        return this[o] = void 0, this._front = o + 1 & this._capacity - 1, this._length--, F;
      }, J.prototype.length = function() {
        return this._length;
      }, J.prototype._checkCapacity = function(o) {
        this._capacity < o && this._resizeTo(this._capacity << 1);
      }, J.prototype._resizeTo = function(o) {
        var F = this._capacity;
        this._capacity = o;
        var t = this._front, a = this._length, v = t + a & F - 1;
        ae(this, 0, this, F, v);
      }, ce.exports = J;
    }, {}], 66: [function(le, ce, re) {
      ce.exports = function(ae, J, o, F) {
        var t = le("./util"), a = function(h) {
          return h.then(function(e) {
            return v(e, h);
          });
        };
        function v(h, e) {
          var y = o(h);
          if (y instanceof ae)
            return a(y);
          if (h = t.asArray(h), h === null)
            return F("expecting an array or an iterable object but got " + t.classString(h));
          var c = new ae(J);
          e !== void 0 && c._propagateFrom(e, 3);
          for (var d = c._fulfill, m = c._reject, p = 0, g = h.length; p < g; ++p) {
            var n = h[p];
            n === void 0 && !(p in h) || ae.cast(n)._then(d, m, void 0, c, null);
          }
          return c;
        }
        ae.race = function(h) {
          return v(h, void 0);
        }, ae.prototype.race = function() {
          return v(this, void 0);
        };
      };
    }, { "./util": 75 }], 67: [function(le, ce, re) {
      ce.exports = function(ae, J, o, F, t, a) {
        var v = ae._getDomain, h = le("./util"), e = h.tryCatch;
        function y(g, n, i, l) {
          this.constructor$(g);
          var u = v();
          this._fn = u === null ? n : h.domainBind(u, n), i !== void 0 && (i = ae.resolve(i), i._attachCancellationCallback(this)), this._initialValue = i, this._currentCancellable = null, l === t ? this._eachValues = Array(this._length) : l === 0 ? this._eachValues = null : this._eachValues = void 0, this._promise._captureStackTrace(), this._init$(void 0, -5);
        }
        h.inherits(y, J), y.prototype._gotAccum = function(g) {
          this._eachValues !== void 0 && this._eachValues !== null && g !== t && this._eachValues.push(g);
        }, y.prototype._eachComplete = function(g) {
          return this._eachValues !== null && this._eachValues.push(g), this._eachValues;
        }, y.prototype._init = function() {
        }, y.prototype._resolveEmptyArray = function() {
          this._resolve(this._eachValues !== void 0 ? this._eachValues : this._initialValue);
        }, y.prototype.shouldCopyValues = function() {
          return !1;
        }, y.prototype._resolve = function(g) {
          this._promise._resolveCallback(g), this._values = null;
        }, y.prototype._resultCancelled = function(g) {
          if (g === this._initialValue)
            return this._cancel();
          this._isResolved() || (this._resultCancelled$(), this._currentCancellable instanceof ae && this._currentCancellable.cancel(), this._initialValue instanceof ae && this._initialValue.cancel());
        }, y.prototype._iterate = function(g) {
          this._values = g;
          var n, i, l = g.length;
          if (this._initialValue !== void 0 ? (n = this._initialValue, i = 0) : (n = ae.resolve(g[0]), i = 1), this._currentCancellable = n, !n.isRejected())
            for (; i < l; ++i) {
              var u = {
                accum: null,
                value: g[i],
                index: i,
                length: l,
                array: this
              };
              n = n._then(m, void 0, void 0, u, void 0);
            }
          this._eachValues !== void 0 && (n = n._then(this._eachComplete, void 0, void 0, this, void 0)), n._then(c, c, void 0, n, this);
        }, ae.prototype.reduce = function(g, n) {
          return d(this, g, n, null);
        }, ae.reduce = function(g, n, i, l) {
          return d(g, n, i, l);
        };
        function c(g, n) {
          this.isFulfilled() ? n._resolve(g) : n._reject(g);
        }
        function d(g, n, i, l) {
          if (typeof n != "function")
            return o("expecting a function but got " + h.classString(n));
          var u = new y(g, n, i, l);
          return u.promise();
        }
        function m(g) {
          this.accum = g, this.array._gotAccum(g);
          var n = F(this.value, this.array._promise);
          return n instanceof ae ? (this.array._currentCancellable = n, n._then(p, void 0, void 0, this, void 0)) : p.call(this, n);
        }
        function p(g) {
          var n = this.array, i = n._promise, l = e(n._fn);
          i._pushContext();
          var u;
          n._eachValues !== void 0 ? u = l.call(i._boundValue(), g, this.index, this.length) : u = l.call(
            i._boundValue(),
            this.accum,
            g,
            this.index,
            this.length
          ), u instanceof ae && (n._currentCancellable = u);
          var w = i._popContext();
          return a.checkForgottenReturns(
            u,
            w,
            n._eachValues !== void 0 ? "Promise.each" : "Promise.reduce",
            i
          ), u;
        }
      };
    }, { "./util": 75 }], 68: [function(le, ce, re) {
      (function(ae, J) {
        var o = le("./util"), F, t = function() {
          throw new Error(`No async scheduler available

    See http://goo.gl/MqrFmX
`);
        }, a = o.getNativePromise();
        if (o.isNode && typeof MutationObserver > "u") {
          var v = J.setImmediate, h = ae.nextTick;
          F = o.isRecentNode ? function(y) {
            v.call(J, y);
          } : function(y) {
            h.call(ae, y);
          };
        } else if (typeof a == "function" && typeof a.resolve == "function") {
          var e = a.resolve();
          F = function(y) {
            e.then(y);
          };
        } else
          typeof MutationObserver < "u" && !(typeof window < "u" && window.navigator && (window.navigator.standalone || window.cordova)) ? F = function() {
            var y = document.createElement("div"), c = { attributes: !0 }, d = !1, m = document.createElement("div"), p = new MutationObserver(function() {
              y.classList.toggle("foo"), d = !1;
            });
            p.observe(m, c);
            var g = function() {
              d || (d = !0, m.classList.toggle("foo"));
            };
            return function(i) {
              var l = new MutationObserver(function() {
                l.disconnect(), i();
              });
              l.observe(y, c), g();
            };
          }() : typeof setImmediate < "u" ? F = function(y) {
            setImmediate(y);
          } : typeof setTimeout < "u" ? F = function(y) {
            setTimeout(y, 0);
          } : F = t;
        ce.exports = F;
      }).call(this, le("_process"), typeof commonjsGlobal < "u" ? commonjsGlobal : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "./util": 75, _process: 102 }], 69: [function(le, ce, re) {
      ce.exports = function(ae, J, o) {
        var F = ae.PromiseInspection, t = le("./util");
        function a(v) {
          this.constructor$(v);
        }
        t.inherits(a, J), a.prototype._promiseResolved = function(v, h) {
          this._values[v] = h;
          var e = ++this._totalResolved;
          return e >= this._length ? (this._resolve(this._values), !0) : !1;
        }, a.prototype._promiseFulfilled = function(v, h) {
          var e = new F();
          return e._bitField = 33554432, e._settledValueField = v, this._promiseResolved(h, e);
        }, a.prototype._promiseRejected = function(v, h) {
          var e = new F();
          return e._bitField = 16777216, e._settledValueField = v, this._promiseResolved(h, e);
        }, ae.settle = function(v) {
          return o.deprecated(".settle()", ".reflect()"), new a(v).promise();
        }, ae.prototype.settle = function() {
          return ae.settle(this);
        };
      };
    }, { "./util": 75 }], 70: [function(le, ce, re) {
      ce.exports = function(ae, J, o) {
        var F = le("./util"), t = le("./errors").RangeError, a = le("./errors").AggregateError, v = F.isArray, h = {};
        function e(c) {
          this.constructor$(c), this._howMany = 0, this._unwrap = !1, this._initialized = !1;
        }
        F.inherits(e, J), e.prototype._init = function() {
          if (this._initialized) {
            if (this._howMany === 0) {
              this._resolve([]);
              return;
            }
            this._init$(void 0, -5);
            var c = v(this._values);
            !this._isResolved() && c && this._howMany > this._canPossiblyFulfill() && this._reject(this._getRangeError(this.length()));
          }
        }, e.prototype.init = function() {
          this._initialized = !0, this._init();
        }, e.prototype.setUnwrap = function() {
          this._unwrap = !0;
        }, e.prototype.howMany = function() {
          return this._howMany;
        }, e.prototype.setHowMany = function(c) {
          this._howMany = c;
        }, e.prototype._promiseFulfilled = function(c) {
          return this._addFulfilled(c), this._fulfilled() === this.howMany() ? (this._values.length = this.howMany(), this.howMany() === 1 && this._unwrap ? this._resolve(this._values[0]) : this._resolve(this._values), !0) : !1;
        }, e.prototype._promiseRejected = function(c) {
          return this._addRejected(c), this._checkOutcome();
        }, e.prototype._promiseCancelled = function() {
          return this._values instanceof ae || this._values == null ? this._cancel() : (this._addRejected(h), this._checkOutcome());
        }, e.prototype._checkOutcome = function() {
          if (this.howMany() > this._canPossiblyFulfill()) {
            for (var c = new a(), d = this.length(); d < this._values.length; ++d)
              this._values[d] !== h && c.push(this._values[d]);
            return c.length > 0 ? this._reject(c) : this._cancel(), !0;
          }
          return !1;
        }, e.prototype._fulfilled = function() {
          return this._totalResolved;
        }, e.prototype._rejected = function() {
          return this._values.length - this.length();
        }, e.prototype._addRejected = function(c) {
          this._values.push(c);
        }, e.prototype._addFulfilled = function(c) {
          this._values[this._totalResolved++] = c;
        }, e.prototype._canPossiblyFulfill = function() {
          return this.length() - this._rejected();
        }, e.prototype._getRangeError = function(c) {
          var d = "Input array must contain at least " + this._howMany + " items but contains only " + c + " items";
          return new t(d);
        }, e.prototype._resolveEmptyArray = function() {
          this._reject(this._getRangeError(0));
        };
        function y(c, d) {
          if ((d | 0) !== d || d < 0)
            return o(`expecting a positive integer

    See http://goo.gl/MqrFmX
`);
          var m = new e(c), p = m.promise();
          return m.setHowMany(d), m.init(), p;
        }
        ae.some = function(c, d) {
          return y(c, d);
        }, ae.prototype.some = function(c) {
          return y(this, c);
        }, ae._SomePromiseArray = e;
      };
    }, { "./errors": 51, "./util": 75 }], 71: [function(le, ce, re) {
      ce.exports = function(ae) {
        function J(e) {
          e !== void 0 ? (e = e._target(), this._bitField = e._bitField, this._settledValueField = e._isFateSealed() ? e._settledValue() : void 0) : (this._bitField = 0, this._settledValueField = void 0);
        }
        J.prototype._settledValue = function() {
          return this._settledValueField;
        };
        var o = J.prototype.value = function() {
          if (!this.isFulfilled())
            throw new TypeError(`cannot get fulfillment value of a non-fulfilled promise

    See http://goo.gl/MqrFmX
`);
          return this._settledValue();
        }, F = J.prototype.error = J.prototype.reason = function() {
          if (!this.isRejected())
            throw new TypeError(`cannot get rejection reason of a non-rejected promise

    See http://goo.gl/MqrFmX
`);
          return this._settledValue();
        }, t = J.prototype.isFulfilled = function() {
          return (this._bitField & 33554432) !== 0;
        }, a = J.prototype.isRejected = function() {
          return (this._bitField & 16777216) !== 0;
        }, v = J.prototype.isPending = function() {
          return (this._bitField & 50397184) === 0;
        }, h = J.prototype.isResolved = function() {
          return (this._bitField & 50331648) !== 0;
        };
        J.prototype.isCancelled = function() {
          return (this._bitField & 8454144) !== 0;
        }, ae.prototype.__isCancelled = function() {
          return (this._bitField & 65536) === 65536;
        }, ae.prototype._isCancelled = function() {
          return this._target().__isCancelled();
        }, ae.prototype.isCancelled = function() {
          return (this._target()._bitField & 8454144) !== 0;
        }, ae.prototype.isPending = function() {
          return v.call(this._target());
        }, ae.prototype.isRejected = function() {
          return a.call(this._target());
        }, ae.prototype.isFulfilled = function() {
          return t.call(this._target());
        }, ae.prototype.isResolved = function() {
          return h.call(this._target());
        }, ae.prototype.value = function() {
          return o.call(this._target());
        }, ae.prototype.reason = function() {
          var e = this._target();
          return e._unsetRejectionIsUnhandled(), F.call(e);
        }, ae.prototype._value = function() {
          return this._settledValue();
        }, ae.prototype._reason = function() {
          return this._unsetRejectionIsUnhandled(), this._settledValue();
        }, ae.PromiseInspection = J;
      };
    }, {}], 72: [function(le, ce, re) {
      ce.exports = function(ae, J) {
        var o = le("./util"), F = o.errorObj, t = o.isObject;
        function a(d, m) {
          if (t(d)) {
            if (d instanceof ae)
              return d;
            var p = h(d);
            if (p === F) {
              m && m._pushContext();
              var g = ae.reject(p.e);
              return m && m._popContext(), g;
            } else if (typeof p == "function") {
              if (y(d)) {
                var g = new ae(J);
                return d._then(
                  g._fulfill,
                  g._reject,
                  void 0,
                  g,
                  null
                ), g;
              }
              return c(d, p, m);
            }
          }
          return d;
        }
        function v(d) {
          return d.then;
        }
        function h(d) {
          try {
            return v(d);
          } catch (m) {
            return F.e = m, F;
          }
        }
        var e = {}.hasOwnProperty;
        function y(d) {
          try {
            return e.call(d, "_promise0");
          } catch {
            return !1;
          }
        }
        function c(d, m, p) {
          var g = new ae(J), n = g;
          p && p._pushContext(), g._captureStackTrace(), p && p._popContext();
          var i = !0, l = o.tryCatch(m).call(d, u, w);
          i = !1, g && l === F && (g._rejectCallback(l.e, !0, !0), g = null);
          function u(O) {
            g && (g._resolveCallback(O), g = null);
          }
          function w(O) {
            g && (g._rejectCallback(O, i, !0), g = null);
          }
          return n;
        }
        return a;
      };
    }, { "./util": 75 }], 73: [function(le, ce, re) {
      ce.exports = function(ae, J, o) {
        var F = le("./util"), t = ae.TimeoutError;
        function a(d) {
          this.handle = d;
        }
        a.prototype._resultCancelled = function() {
          clearTimeout(this.handle);
        };
        var v = function(d) {
          return h(+this).thenReturn(d);
        }, h = ae.delay = function(d, m) {
          var p, g;
          return m !== void 0 ? (p = ae.resolve(m)._then(v, null, null, d, void 0), o.cancellation() && m instanceof ae && p._setOnCancel(m)) : (p = new ae(J), g = setTimeout(function() {
            p._fulfill();
          }, +d), o.cancellation() && p._setOnCancel(new a(g)), p._captureStackTrace()), p._setAsyncGuaranteed(), p;
        };
        ae.prototype.delay = function(d) {
          return h(d, this);
        };
        var e = function(d, m, p) {
          var g;
          typeof m != "string" ? m instanceof Error ? g = m : g = new t("operation timed out") : g = new t(m), F.markAsOriginatingFromRejection(g), d._attachExtraTrace(g), d._reject(g), p != null && p.cancel();
        };
        function y(d) {
          return clearTimeout(this.handle), d;
        }
        function c(d) {
          throw clearTimeout(this.handle), d;
        }
        ae.prototype.timeout = function(d, m) {
          d = +d;
          var p, g, n = new a(setTimeout(function() {
            p.isPending() && e(p, m, g);
          }, d));
          return o.cancellation() ? (g = this.then(), p = g._then(
            y,
            c,
            void 0,
            n,
            void 0
          ), p._setOnCancel(n)) : p = this._then(
            y,
            c,
            void 0,
            n,
            void 0
          ), p;
        };
      };
    }, { "./util": 75 }], 74: [function(le, ce, re) {
      ce.exports = function(ae, J, o, F, t, a) {
        var v = le("./util"), h = le("./errors").TypeError, e = le("./util").inherits, y = v.errorObj, c = v.tryCatch, d = {};
        function m(w) {
          setTimeout(function() {
            throw w;
          }, 0);
        }
        function p(w) {
          var O = o(w);
          return O !== w && typeof w._isDisposable == "function" && typeof w._getDisposer == "function" && w._isDisposable() && O._setDisposable(w._getDisposer()), O;
        }
        function g(w, O) {
          var b = 0, A = w.length, Y = new ae(t);
          function j() {
            if (b >= A)
              return Y._fulfill();
            var X = p(w[b++]);
            if (X instanceof ae && X._isDisposable()) {
              try {
                X = o(
                  X._getDisposer().tryDispose(O),
                  w.promise
                );
              } catch (B) {
                return m(B);
              }
              if (X instanceof ae)
                return X._then(
                  j,
                  m,
                  null,
                  null,
                  null
                );
            }
            j();
          }
          return j(), Y;
        }
        function n(w, O, b) {
          this._data = w, this._promise = O, this._context = b;
        }
        n.prototype.data = function() {
          return this._data;
        }, n.prototype.promise = function() {
          return this._promise;
        }, n.prototype.resource = function() {
          return this.promise().isFulfilled() ? this.promise().value() : d;
        }, n.prototype.tryDispose = function(w) {
          var O = this.resource(), b = this._context;
          b !== void 0 && b._pushContext();
          var A = O !== d ? this.doDispose(O, w) : null;
          return b !== void 0 && b._popContext(), this._promise._unsetDisposable(), this._data = null, A;
        }, n.isDisposer = function(w) {
          return w != null && typeof w.resource == "function" && typeof w.tryDispose == "function";
        };
        function i(w, O, b) {
          this.constructor$(w, O, b);
        }
        e(i, n), i.prototype.doDispose = function(w, O) {
          var b = this.data();
          return b.call(w, w, O);
        };
        function l(w) {
          return n.isDisposer(w) ? (this.resources[this.index]._setDisposable(w), w.promise()) : w;
        }
        function u(w) {
          this.length = w, this.promise = null, this[w - 1] = null;
        }
        u.prototype._resultCancelled = function() {
          for (var w = this.length, O = 0; O < w; ++O) {
            var b = this[O];
            b instanceof ae && b.cancel();
          }
        }, ae.using = function() {
          var w = arguments.length;
          if (w < 2)
            return J(
              "you must pass at least 2 arguments to Promise.using"
            );
          var O = arguments[w - 1];
          if (typeof O != "function")
            return J("expecting a function but got " + v.classString(O));
          var b, A = !0;
          w === 2 && Array.isArray(arguments[0]) ? (b = arguments[0], w = b.length, A = !1) : (b = arguments, w--);
          for (var Y = new u(w), j = 0; j < w; ++j) {
            var X = b[j];
            if (n.isDisposer(X)) {
              var B = X;
              X = X.promise(), X._setDisposable(B);
            } else {
              var U = o(X);
              U instanceof ae && (X = U._then(l, null, null, {
                resources: Y,
                index: j
              }, void 0));
            }
            Y[j] = X;
          }
          for (var k = new Array(Y.length), j = 0; j < k.length; ++j)
            k[j] = ae.resolve(Y[j]).reflect();
          var x = ae.all(k).then(function(D) {
            for (var _ = 0; _ < D.length; ++_) {
              var S = D[_];
              if (S.isRejected())
                return y.e = S.error(), y;
              if (!S.isFulfilled()) {
                x.cancel();
                return;
              }
              D[_] = S.value();
            }
            f._pushContext(), O = c(O);
            var C = A ? O.apply(void 0, D) : O(D), T = f._popContext();
            return a.checkForgottenReturns(
              C,
              T,
              "Promise.using",
              f
            ), C;
          }), f = x.lastly(function() {
            var D = new ae.PromiseInspection(x);
            return g(Y, D);
          });
          return Y.promise = f, f._setOnCancel(Y), f;
        }, ae.prototype._setDisposable = function(w) {
          this._bitField = this._bitField | 131072, this._disposer = w;
        }, ae.prototype._isDisposable = function() {
          return (this._bitField & 131072) > 0;
        }, ae.prototype._getDisposer = function() {
          return this._disposer;
        }, ae.prototype._unsetDisposable = function() {
          this._bitField = this._bitField & -131073, this._disposer = void 0;
        }, ae.prototype.disposer = function(w) {
          if (typeof w == "function")
            return new i(w, this, F());
          throw new h();
        };
      };
    }, { "./errors": 51, "./util": 75 }], 75: [function(le, ce, re) {
      (function(ae, J) {
        var o = le("./es5"), F = typeof navigator > "u", t = { e: {} }, a, v = typeof self < "u" ? self : typeof window < "u" ? window : typeof J < "u" ? J : this !== void 0 ? this : null;
        function h() {
          try {
            var $ = a;
            return a = null, $.apply(this, arguments);
          } catch (z) {
            return t.e = z, t;
          }
        }
        function e($) {
          return a = $, h;
        }
        var y = function($, z) {
          var V = {}.hasOwnProperty;
          function L() {
            this.constructor = $, this.constructor$ = z;
            for (var K in z.prototype)
              V.call(z.prototype, K) && K.charAt(K.length - 1) !== "$" && (this[K + "$"] = z.prototype[K]);
          }
          return L.prototype = z.prototype, $.prototype = new L(), $.prototype;
        };
        function c($) {
          return $ == null || $ === !0 || $ === !1 || typeof $ == "string" || typeof $ == "number";
        }
        function d($) {
          return typeof $ == "function" || typeof $ == "object" && $ !== null;
        }
        function m($) {
          return c($) ? new Error(j($)) : $;
        }
        function p($, z) {
          var V = $.length, L = new Array(V + 1), K;
          for (K = 0; K < V; ++K)
            L[K] = $[K];
          return L[K] = z, L;
        }
        function g($, z, V) {
          if (o.isES5) {
            var L = Object.getOwnPropertyDescriptor($, z);
            if (L != null)
              return L.get == null && L.set == null ? L.value : V;
          } else
            return {}.hasOwnProperty.call($, z) ? $[z] : void 0;
        }
        function n($, z, V) {
          if (c($))
            return $;
          var L = {
            value: V,
            configurable: !0,
            enumerable: !1,
            writable: !0
          };
          return o.defineProperty($, z, L), $;
        }
        function i($) {
          throw $;
        }
        var l = function() {
          var $ = [
            Array.prototype,
            Object.prototype,
            Function.prototype
          ], z = function(K) {
            for (var ne = 0; ne < $.length; ++ne)
              if ($[ne] === K)
                return !0;
            return !1;
          };
          if (o.isES5) {
            var V = Object.getOwnPropertyNames;
            return function(K) {
              for (var ne = [], se = /* @__PURE__ */ Object.create(null); K != null && !z(K); ) {
                var q;
                try {
                  q = V(K);
                } catch {
                  return ne;
                }
                for (var N = 0; N < q.length; ++N) {
                  var Q = q[N];
                  if (!se[Q]) {
                    se[Q] = !0;
                    var E = Object.getOwnPropertyDescriptor(K, Q);
                    E != null && E.get == null && E.set == null && ne.push(Q);
                  }
                }
                K = o.getPrototypeOf(K);
              }
              return ne;
            };
          } else {
            var L = {}.hasOwnProperty;
            return function(K) {
              if (z(K))
                return [];
              var ne = [];
              e:
                for (var se in K)
                  if (L.call(K, se))
                    ne.push(se);
                  else {
                    for (var q = 0; q < $.length; ++q)
                      if (L.call($[q], se))
                        continue e;
                    ne.push(se);
                  }
              return ne;
            };
          }
        }(), u = /this\s*\.\s*\S+\s*=/;
        function w($) {
          try {
            if (typeof $ == "function") {
              var z = o.names($.prototype), V = o.isES5 && z.length > 1, L = z.length > 0 && !(z.length === 1 && z[0] === "constructor"), K = u.test($ + "") && o.names($).length > 0;
              if (V || L || K)
                return !0;
            }
            return !1;
          } catch {
            return !1;
          }
        }
        function O($) {
          return $;
        }
        var b = /^[a-z$_][a-z$_0-9]*$/i;
        function A($) {
          return b.test($);
        }
        function Y($, z, V) {
          for (var L = new Array($), K = 0; K < $; ++K)
            L[K] = z + K + V;
          return L;
        }
        function j($) {
          try {
            return $ + "";
          } catch {
            return "[no string representation]";
          }
        }
        function X($) {
          return $ !== null && typeof $ == "object" && typeof $.message == "string" && typeof $.name == "string";
        }
        function B($) {
          try {
            n($, "isOperational", !0);
          } catch {
          }
        }
        function U($) {
          return $ == null ? !1 : $ instanceof Error.__BluebirdErrorTypes__.OperationalError || $.isOperational === !0;
        }
        function k($) {
          return X($) && o.propertyIsWritable($, "stack");
        }
        var x = function() {
          return "stack" in new Error() ? function($) {
            return k($) ? $ : new Error(j($));
          } : function($) {
            if (k($))
              return $;
            try {
              throw new Error(j($));
            } catch (z) {
              return z;
            }
          };
        }();
        function f($) {
          return {}.toString.call($);
        }
        function D($, z, V) {
          for (var L = o.names($), K = 0; K < L.length; ++K) {
            var ne = L[K];
            if (V(ne))
              try {
                o.defineProperty(z, ne, o.getDescriptor($, ne));
              } catch {
              }
          }
        }
        var _ = function($) {
          return o.isArray($) ? $ : null;
        };
        if (typeof Symbol < "u" && Symbol.iterator) {
          var S = typeof Array.from == "function" ? function($) {
            return Array.from($);
          } : function($) {
            for (var z = [], V = $[Symbol.iterator](), L; !(L = V.next()).done; )
              z.push(L.value);
            return z;
          };
          _ = function($) {
            return o.isArray($) ? $ : $ != null && typeof $[Symbol.iterator] == "function" ? S($) : null;
          };
        }
        var C = typeof ae < "u" && f(ae).toLowerCase() === "[object process]", T = typeof ae < "u" && typeof ae.env < "u";
        function P($) {
          return T ? ae.env[$] : void 0;
        }
        function M() {
          if (typeof Promise == "function")
            try {
              var $ = new Promise(function() {
              });
              if ({}.toString.call($) === "[object Promise]")
                return Promise;
            } catch {
            }
        }
        function G($, z) {
          return $.bind(z);
        }
        var Z = {
          isClass: w,
          isIdentifier: A,
          inheritedDataKeys: l,
          getDataPropertyOrDefault: g,
          thrower: i,
          isArray: o.isArray,
          asArray: _,
          notEnumerableProp: n,
          isPrimitive: c,
          isObject: d,
          isError: X,
          canEvaluate: F,
          errorObj: t,
          tryCatch: e,
          inherits: y,
          withAppended: p,
          maybeWrapAsError: m,
          toFastProperties: O,
          filledRange: Y,
          toString: j,
          canAttachTrace: k,
          ensureErrorObject: x,
          originatesFromRejection: U,
          markAsOriginatingFromRejection: B,
          classString: f,
          copyDescriptors: D,
          hasDevTools: typeof chrome < "u" && chrome && typeof chrome.loadTimes == "function",
          isNode: C,
          hasEnvVariables: T,
          env: P,
          global: v,
          getNativePromise: M,
          domainBind: G
        };
        Z.isRecentNode = Z.isNode && function() {
          var $ = ae.versions.node.split(".").map(Number);
          return $[0] === 0 && $[1] > 10 || $[0] > 0;
        }(), Z.isNode && Z.toFastProperties(ae);
        try {
          throw new Error();
        } catch ($) {
          Z.lastLineError = $;
        }
        ce.exports = Z;
      }).call(this, le("_process"), typeof commonjsGlobal < "u" ? commonjsGlobal : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "./es5": 52, _process: 102 }], 76: [function(le, ce, re) {
    }, {}], 77: [function(le, ce, re) {
      (function(ae) {
        var J = le("buffer"), o = J.Buffer, F = J.SlowBuffer, t = J.kMaxLength || 2147483647;
        re.alloc = function(v, h, e) {
          if (typeof o.alloc == "function")
            return o.alloc(v, h, e);
          if (typeof e == "number")
            throw new TypeError("encoding must not be number");
          if (typeof v != "number")
            throw new TypeError("size must be a number");
          if (v > t)
            throw new RangeError("size is too large");
          var y = e, c = h;
          c === void 0 && (y = void 0, c = 0);
          var d = new o(v);
          if (typeof c == "string")
            for (var m = new o(c, y), p = m.length, g = -1; ++g < v; )
              d[g] = m[g % p];
          else
            d.fill(c);
          return d;
        }, re.allocUnsafe = function(v) {
          if (typeof o.allocUnsafe == "function")
            return o.allocUnsafe(v);
          if (typeof v != "number")
            throw new TypeError("size must be a number");
          if (v > t)
            throw new RangeError("size is too large");
          return new o(v);
        }, re.from = function(v, h, e) {
          if (typeof o.from == "function" && (!ae.Uint8Array || Uint8Array.from !== o.from))
            return o.from(v, h, e);
          if (typeof v == "number")
            throw new TypeError('"value" argument must not be a number');
          if (typeof v == "string")
            return new o(v, h);
          if (typeof ArrayBuffer < "u" && v instanceof ArrayBuffer) {
            var y = h;
            if (arguments.length === 1)
              return new o(v);
            typeof y > "u" && (y = 0);
            var c = e;
            if (typeof c > "u" && (c = v.byteLength - y), y >= v.byteLength)
              throw new RangeError("'offset' is out of bounds");
            if (c > v.byteLength - y)
              throw new RangeError("'length' is out of bounds");
            return new o(v.slice(y, y + c));
          }
          if (o.isBuffer(v)) {
            var d = new o(v.length);
            return v.copy(d, 0, 0, v.length), d;
          }
          if (v) {
            if (Array.isArray(v) || typeof ArrayBuffer < "u" && v.buffer instanceof ArrayBuffer || "length" in v)
              return new o(v);
            if (v.type === "Buffer" && Array.isArray(v.data))
              return new o(v.data);
          }
          throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
        }, re.allocUnsafeSlow = function(v) {
          if (typeof o.allocUnsafeSlow == "function")
            return o.allocUnsafeSlow(v);
          if (typeof v != "number")
            throw new TypeError("size must be a number");
          if (v >= t)
            throw new RangeError("size is too large");
          return new F(v);
        };
      }).call(this, typeof commonjsGlobal < "u" ? commonjsGlobal : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { buffer: 78 }], 78: [function(le, ce, re) {
      (function(ae) {
        var J = le("base64-js"), o = le("ieee754"), F = le("isarray");
        re.Buffer = h, re.SlowBuffer = l, re.INSPECT_MAX_BYTES = 50, h.TYPED_ARRAY_SUPPORT = ae.TYPED_ARRAY_SUPPORT !== void 0 ? ae.TYPED_ARRAY_SUPPORT : t(), re.kMaxLength = a();
        function t() {
          try {
            var W = new Uint8Array(1);
            return W.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
              return 42;
            } }, W.foo() === 42 && // typed array instances can be augmented
            typeof W.subarray == "function" && // chrome 9-10 lack `subarray`
            W.subarray(1, 1).byteLength === 0;
          } catch {
            return !1;
          }
        }
        function a() {
          return h.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
        }
        function v(W, I) {
          if (a() < I)
            throw new RangeError("Invalid typed array length");
          return h.TYPED_ARRAY_SUPPORT ? (W = new Uint8Array(I), W.__proto__ = h.prototype) : (W === null && (W = new h(I)), W.length = I), W;
        }
        function h(W, I, H) {
          if (!h.TYPED_ARRAY_SUPPORT && !(this instanceof h))
            return new h(W, I, H);
          if (typeof W == "number") {
            if (typeof I == "string")
              throw new Error(
                "If encoding is specified then the first argument must be a string"
              );
            return d(this, W);
          }
          return e(this, W, I, H);
        }
        h.poolSize = 8192, h._augment = function(W) {
          return W.__proto__ = h.prototype, W;
        };
        function e(W, I, H, ie) {
          if (typeof I == "number")
            throw new TypeError('"value" argument must not be a number');
          return typeof ArrayBuffer < "u" && I instanceof ArrayBuffer ? g(W, I, H, ie) : typeof I == "string" ? m(W, I, H) : n(W, I);
        }
        h.from = function(W, I, H) {
          return e(null, W, I, H);
        }, h.TYPED_ARRAY_SUPPORT && (h.prototype.__proto__ = Uint8Array.prototype, h.__proto__ = Uint8Array, typeof Symbol < "u" && Symbol.species && h[Symbol.species] === h && Object.defineProperty(h, Symbol.species, {
          value: null,
          configurable: !0
        }));
        function y(W) {
          if (typeof W != "number")
            throw new TypeError('"size" argument must be a number');
          if (W < 0)
            throw new RangeError('"size" argument must not be negative');
        }
        function c(W, I, H, ie) {
          return y(I), I <= 0 ? v(W, I) : H !== void 0 ? typeof ie == "string" ? v(W, I).fill(H, ie) : v(W, I).fill(H) : v(W, I);
        }
        h.alloc = function(W, I, H) {
          return c(null, W, I, H);
        };
        function d(W, I) {
          if (y(I), W = v(W, I < 0 ? 0 : i(I) | 0), !h.TYPED_ARRAY_SUPPORT)
            for (var H = 0; H < I; ++H)
              W[H] = 0;
          return W;
        }
        h.allocUnsafe = function(W) {
          return d(null, W);
        }, h.allocUnsafeSlow = function(W) {
          return d(null, W);
        };
        function m(W, I, H) {
          if ((typeof H != "string" || H === "") && (H = "utf8"), !h.isEncoding(H))
            throw new TypeError('"encoding" must be a valid string encoding');
          var ie = u(I, H) | 0;
          W = v(W, ie);
          var ue = W.write(I, H);
          return ue !== ie && (W = W.slice(0, ue)), W;
        }
        function p(W, I) {
          var H = I.length < 0 ? 0 : i(I.length) | 0;
          W = v(W, H);
          for (var ie = 0; ie < H; ie += 1)
            W[ie] = I[ie] & 255;
          return W;
        }
        function g(W, I, H, ie) {
          if (I.byteLength, H < 0 || I.byteLength < H)
            throw new RangeError("'offset' is out of bounds");
          if (I.byteLength < H + (ie || 0))
            throw new RangeError("'length' is out of bounds");
          return H === void 0 && ie === void 0 ? I = new Uint8Array(I) : ie === void 0 ? I = new Uint8Array(I, H) : I = new Uint8Array(I, H, ie), h.TYPED_ARRAY_SUPPORT ? (W = I, W.__proto__ = h.prototype) : W = p(W, I), W;
        }
        function n(W, I) {
          if (h.isBuffer(I)) {
            var H = i(I.length) | 0;
            return W = v(W, H), W.length === 0 || I.copy(W, 0, 0, H), W;
          }
          if (I) {
            if (typeof ArrayBuffer < "u" && I.buffer instanceof ArrayBuffer || "length" in I)
              return typeof I.length != "number" || ee(I.length) ? v(W, 0) : p(W, I);
            if (I.type === "Buffer" && F(I.data))
              return p(W, I.data);
          }
          throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
        }
        function i(W) {
          if (W >= a())
            throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + a().toString(16) + " bytes");
          return W | 0;
        }
        function l(W) {
          return +W != W && (W = 0), h.alloc(+W);
        }
        h.isBuffer = function(I) {
          return !!(I != null && I._isBuffer);
        }, h.compare = function(I, H) {
          if (!h.isBuffer(I) || !h.isBuffer(H))
            throw new TypeError("Arguments must be Buffers");
          if (I === H)
            return 0;
          for (var ie = I.length, ue = H.length, fe = 0, de = Math.min(ie, ue); fe < de; ++fe)
            if (I[fe] !== H[fe]) {
              ie = I[fe], ue = H[fe];
              break;
            }
          return ie < ue ? -1 : ue < ie ? 1 : 0;
        }, h.isEncoding = function(I) {
          switch (String(I).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return !0;
            default:
              return !1;
          }
        }, h.concat = function(I, H) {
          if (!F(I))
            throw new TypeError('"list" argument must be an Array of Buffers');
          if (I.length === 0)
            return h.alloc(0);
          var ie;
          if (H === void 0)
            for (H = 0, ie = 0; ie < I.length; ++ie)
              H += I[ie].length;
          var ue = h.allocUnsafe(H), fe = 0;
          for (ie = 0; ie < I.length; ++ie) {
            var de = I[ie];
            if (!h.isBuffer(de))
              throw new TypeError('"list" argument must be an Array of Buffers');
            de.copy(ue, fe), fe += de.length;
          }
          return ue;
        };
        function u(W, I) {
          if (h.isBuffer(W))
            return W.length;
          if (typeof ArrayBuffer < "u" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(W) || W instanceof ArrayBuffer))
            return W.byteLength;
          typeof W != "string" && (W = "" + W);
          var H = W.length;
          if (H === 0)
            return 0;
          for (var ie = !1; ; )
            switch (I) {
              case "ascii":
              case "latin1":
              case "binary":
                return H;
              case "utf8":
              case "utf-8":
              case void 0:
                return N(W).length;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return H * 2;
              case "hex":
                return H >>> 1;
              case "base64":
                return te(W).length;
              default:
                if (ie)
                  return N(W).length;
                I = ("" + I).toLowerCase(), ie = !0;
            }
        }
        h.byteLength = u;
        function w(W, I, H) {
          var ie = !1;
          if ((I === void 0 || I < 0) && (I = 0), I > this.length || ((H === void 0 || H > this.length) && (H = this.length), H <= 0) || (H >>>= 0, I >>>= 0, H <= I))
            return "";
          for (W || (W = "utf8"); ; )
            switch (W) {
              case "hex":
                return T(this, I, H);
              case "utf8":
              case "utf-8":
                return f(this, I, H);
              case "ascii":
                return S(this, I, H);
              case "latin1":
              case "binary":
                return C(this, I, H);
              case "base64":
                return x(this, I, H);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return P(this, I, H);
              default:
                if (ie)
                  throw new TypeError("Unknown encoding: " + W);
                W = (W + "").toLowerCase(), ie = !0;
            }
        }
        h.prototype._isBuffer = !0;
        function O(W, I, H) {
          var ie = W[I];
          W[I] = W[H], W[H] = ie;
        }
        h.prototype.swap16 = function() {
          var I = this.length;
          if (I % 2 !== 0)
            throw new RangeError("Buffer size must be a multiple of 16-bits");
          for (var H = 0; H < I; H += 2)
            O(this, H, H + 1);
          return this;
        }, h.prototype.swap32 = function() {
          var I = this.length;
          if (I % 4 !== 0)
            throw new RangeError("Buffer size must be a multiple of 32-bits");
          for (var H = 0; H < I; H += 4)
            O(this, H, H + 3), O(this, H + 1, H + 2);
          return this;
        }, h.prototype.swap64 = function() {
          var I = this.length;
          if (I % 8 !== 0)
            throw new RangeError("Buffer size must be a multiple of 64-bits");
          for (var H = 0; H < I; H += 8)
            O(this, H, H + 7), O(this, H + 1, H + 6), O(this, H + 2, H + 5), O(this, H + 3, H + 4);
          return this;
        }, h.prototype.toString = function() {
          var I = this.length | 0;
          return I === 0 ? "" : arguments.length === 0 ? f(this, 0, I) : w.apply(this, arguments);
        }, h.prototype.equals = function(I) {
          if (!h.isBuffer(I))
            throw new TypeError("Argument must be a Buffer");
          return this === I ? !0 : h.compare(this, I) === 0;
        }, h.prototype.inspect = function() {
          var I = "", H = re.INSPECT_MAX_BYTES;
          return this.length > 0 && (I = this.toString("hex", 0, H).match(/.{2}/g).join(" "), this.length > H && (I += " ... ")), "<Buffer " + I + ">";
        }, h.prototype.compare = function(I, H, ie, ue, fe) {
          if (!h.isBuffer(I))
            throw new TypeError("Argument must be a Buffer");
          if (H === void 0 && (H = 0), ie === void 0 && (ie = I ? I.length : 0), ue === void 0 && (ue = 0), fe === void 0 && (fe = this.length), H < 0 || ie > I.length || ue < 0 || fe > this.length)
            throw new RangeError("out of range index");
          if (ue >= fe && H >= ie)
            return 0;
          if (ue >= fe)
            return -1;
          if (H >= ie)
            return 1;
          if (H >>>= 0, ie >>>= 0, ue >>>= 0, fe >>>= 0, this === I)
            return 0;
          for (var de = fe - ue, pe = ie - H, xe = Math.min(de, pe), Fe = this.slice(ue, fe), Se = I.slice(H, ie), Ce = 0; Ce < xe; ++Ce)
            if (Fe[Ce] !== Se[Ce]) {
              de = Fe[Ce], pe = Se[Ce];
              break;
            }
          return de < pe ? -1 : pe < de ? 1 : 0;
        };
        function b(W, I, H, ie, ue) {
          if (W.length === 0)
            return -1;
          if (typeof H == "string" ? (ie = H, H = 0) : H > 2147483647 ? H = 2147483647 : H < -2147483648 && (H = -2147483648), H = +H, isNaN(H) && (H = ue ? 0 : W.length - 1), H < 0 && (H = W.length + H), H >= W.length) {
            if (ue)
              return -1;
            H = W.length - 1;
          } else if (H < 0)
            if (ue)
              H = 0;
            else
              return -1;
          if (typeof I == "string" && (I = h.from(I, ie)), h.isBuffer(I))
            return I.length === 0 ? -1 : A(W, I, H, ie, ue);
          if (typeof I == "number")
            return I = I & 255, h.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? ue ? Uint8Array.prototype.indexOf.call(W, I, H) : Uint8Array.prototype.lastIndexOf.call(W, I, H) : A(W, [I], H, ie, ue);
          throw new TypeError("val must be string, number or Buffer");
        }
        function A(W, I, H, ie, ue) {
          var fe = 1, de = W.length, pe = I.length;
          if (ie !== void 0 && (ie = String(ie).toLowerCase(), ie === "ucs2" || ie === "ucs-2" || ie === "utf16le" || ie === "utf-16le")) {
            if (W.length < 2 || I.length < 2)
              return -1;
            fe = 2, de /= 2, pe /= 2, H /= 2;
          }
          function xe(ye, De) {
            return fe === 1 ? ye[De] : ye.readUInt16BE(De * fe);
          }
          var Fe;
          if (ue) {
            var Se = -1;
            for (Fe = H; Fe < de; Fe++)
              if (xe(W, Fe) === xe(I, Se === -1 ? 0 : Fe - Se)) {
                if (Se === -1 && (Se = Fe), Fe - Se + 1 === pe)
                  return Se * fe;
              } else
                Se !== -1 && (Fe -= Fe - Se), Se = -1;
          } else
            for (H + pe > de && (H = de - pe), Fe = H; Fe >= 0; Fe--) {
              for (var Ce = !0, ke = 0; ke < pe; ke++)
                if (xe(W, Fe + ke) !== xe(I, ke)) {
                  Ce = !1;
                  break;
                }
              if (Ce)
                return Fe;
            }
          return -1;
        }
        h.prototype.includes = function(I, H, ie) {
          return this.indexOf(I, H, ie) !== -1;
        }, h.prototype.indexOf = function(I, H, ie) {
          return b(this, I, H, ie, !0);
        }, h.prototype.lastIndexOf = function(I, H, ie) {
          return b(this, I, H, ie, !1);
        };
        function Y(W, I, H, ie) {
          H = Number(H) || 0;
          var ue = W.length - H;
          ie ? (ie = Number(ie), ie > ue && (ie = ue)) : ie = ue;
          var fe = I.length;
          if (fe % 2 !== 0)
            throw new TypeError("Invalid hex string");
          ie > fe / 2 && (ie = fe / 2);
          for (var de = 0; de < ie; ++de) {
            var pe = parseInt(I.substr(de * 2, 2), 16);
            if (isNaN(pe))
              return de;
            W[H + de] = pe;
          }
          return de;
        }
        function j(W, I, H, ie) {
          return oe(N(I, W.length - H), W, H, ie);
        }
        function X(W, I, H, ie) {
          return oe(Q(I), W, H, ie);
        }
        function B(W, I, H, ie) {
          return X(W, I, H, ie);
        }
        function U(W, I, H, ie) {
          return oe(te(I), W, H, ie);
        }
        function k(W, I, H, ie) {
          return oe(E(I, W.length - H), W, H, ie);
        }
        h.prototype.write = function(I, H, ie, ue) {
          if (H === void 0)
            ue = "utf8", ie = this.length, H = 0;
          else if (ie === void 0 && typeof H == "string")
            ue = H, ie = this.length, H = 0;
          else if (isFinite(H))
            H = H | 0, isFinite(ie) ? (ie = ie | 0, ue === void 0 && (ue = "utf8")) : (ue = ie, ie = void 0);
          else
            throw new Error(
              "Buffer.write(string, encoding, offset[, length]) is no longer supported"
            );
          var fe = this.length - H;
          if ((ie === void 0 || ie > fe) && (ie = fe), I.length > 0 && (ie < 0 || H < 0) || H > this.length)
            throw new RangeError("Attempt to write outside buffer bounds");
          ue || (ue = "utf8");
          for (var de = !1; ; )
            switch (ue) {
              case "hex":
                return Y(this, I, H, ie);
              case "utf8":
              case "utf-8":
                return j(this, I, H, ie);
              case "ascii":
                return X(this, I, H, ie);
              case "latin1":
              case "binary":
                return B(this, I, H, ie);
              case "base64":
                return U(this, I, H, ie);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return k(this, I, H, ie);
              default:
                if (de)
                  throw new TypeError("Unknown encoding: " + ue);
                ue = ("" + ue).toLowerCase(), de = !0;
            }
        }, h.prototype.toJSON = function() {
          return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
          };
        };
        function x(W, I, H) {
          return I === 0 && H === W.length ? J.fromByteArray(W) : J.fromByteArray(W.slice(I, H));
        }
        function f(W, I, H) {
          H = Math.min(W.length, H);
          for (var ie = [], ue = I; ue < H; ) {
            var fe = W[ue], de = null, pe = fe > 239 ? 4 : fe > 223 ? 3 : fe > 191 ? 2 : 1;
            if (ue + pe <= H) {
              var xe, Fe, Se, Ce;
              switch (pe) {
                case 1:
                  fe < 128 && (de = fe);
                  break;
                case 2:
                  xe = W[ue + 1], (xe & 192) === 128 && (Ce = (fe & 31) << 6 | xe & 63, Ce > 127 && (de = Ce));
                  break;
                case 3:
                  xe = W[ue + 1], Fe = W[ue + 2], (xe & 192) === 128 && (Fe & 192) === 128 && (Ce = (fe & 15) << 12 | (xe & 63) << 6 | Fe & 63, Ce > 2047 && (Ce < 55296 || Ce > 57343) && (de = Ce));
                  break;
                case 4:
                  xe = W[ue + 1], Fe = W[ue + 2], Se = W[ue + 3], (xe & 192) === 128 && (Fe & 192) === 128 && (Se & 192) === 128 && (Ce = (fe & 15) << 18 | (xe & 63) << 12 | (Fe & 63) << 6 | Se & 63, Ce > 65535 && Ce < 1114112 && (de = Ce));
              }
            }
            de === null ? (de = 65533, pe = 1) : de > 65535 && (de -= 65536, ie.push(de >>> 10 & 1023 | 55296), de = 56320 | de & 1023), ie.push(de), ue += pe;
          }
          return _(ie);
        }
        var D = 4096;
        function _(W) {
          var I = W.length;
          if (I <= D)
            return String.fromCharCode.apply(String, W);
          for (var H = "", ie = 0; ie < I; )
            H += String.fromCharCode.apply(
              String,
              W.slice(ie, ie += D)
            );
          return H;
        }
        function S(W, I, H) {
          var ie = "";
          H = Math.min(W.length, H);
          for (var ue = I; ue < H; ++ue)
            ie += String.fromCharCode(W[ue] & 127);
          return ie;
        }
        function C(W, I, H) {
          var ie = "";
          H = Math.min(W.length, H);
          for (var ue = I; ue < H; ++ue)
            ie += String.fromCharCode(W[ue]);
          return ie;
        }
        function T(W, I, H) {
          var ie = W.length;
          (!I || I < 0) && (I = 0), (!H || H < 0 || H > ie) && (H = ie);
          for (var ue = "", fe = I; fe < H; ++fe)
            ue += q(W[fe]);
          return ue;
        }
        function P(W, I, H) {
          for (var ie = W.slice(I, H), ue = "", fe = 0; fe < ie.length; fe += 2)
            ue += String.fromCharCode(ie[fe] + ie[fe + 1] * 256);
          return ue;
        }
        h.prototype.slice = function(I, H) {
          var ie = this.length;
          I = ~~I, H = H === void 0 ? ie : ~~H, I < 0 ? (I += ie, I < 0 && (I = 0)) : I > ie && (I = ie), H < 0 ? (H += ie, H < 0 && (H = 0)) : H > ie && (H = ie), H < I && (H = I);
          var ue;
          if (h.TYPED_ARRAY_SUPPORT)
            ue = this.subarray(I, H), ue.__proto__ = h.prototype;
          else {
            var fe = H - I;
            ue = new h(fe, void 0);
            for (var de = 0; de < fe; ++de)
              ue[de] = this[de + I];
          }
          return ue;
        };
        function M(W, I, H) {
          if (W % 1 !== 0 || W < 0)
            throw new RangeError("offset is not uint");
          if (W + I > H)
            throw new RangeError("Trying to access beyond buffer length");
        }
        h.prototype.readUIntLE = function(I, H, ie) {
          I = I | 0, H = H | 0, ie || M(I, H, this.length);
          for (var ue = this[I], fe = 1, de = 0; ++de < H && (fe *= 256); )
            ue += this[I + de] * fe;
          return ue;
        }, h.prototype.readUIntBE = function(I, H, ie) {
          I = I | 0, H = H | 0, ie || M(I, H, this.length);
          for (var ue = this[I + --H], fe = 1; H > 0 && (fe *= 256); )
            ue += this[I + --H] * fe;
          return ue;
        }, h.prototype.readUInt8 = function(I, H) {
          return H || M(I, 1, this.length), this[I];
        }, h.prototype.readUInt16LE = function(I, H) {
          return H || M(I, 2, this.length), this[I] | this[I + 1] << 8;
        }, h.prototype.readUInt16BE = function(I, H) {
          return H || M(I, 2, this.length), this[I] << 8 | this[I + 1];
        }, h.prototype.readUInt32LE = function(I, H) {
          return H || M(I, 4, this.length), (this[I] | this[I + 1] << 8 | this[I + 2] << 16) + this[I + 3] * 16777216;
        }, h.prototype.readUInt32BE = function(I, H) {
          return H || M(I, 4, this.length), this[I] * 16777216 + (this[I + 1] << 16 | this[I + 2] << 8 | this[I + 3]);
        }, h.prototype.readIntLE = function(I, H, ie) {
          I = I | 0, H = H | 0, ie || M(I, H, this.length);
          for (var ue = this[I], fe = 1, de = 0; ++de < H && (fe *= 256); )
            ue += this[I + de] * fe;
          return fe *= 128, ue >= fe && (ue -= Math.pow(2, 8 * H)), ue;
        }, h.prototype.readIntBE = function(I, H, ie) {
          I = I | 0, H = H | 0, ie || M(I, H, this.length);
          for (var ue = H, fe = 1, de = this[I + --ue]; ue > 0 && (fe *= 256); )
            de += this[I + --ue] * fe;
          return fe *= 128, de >= fe && (de -= Math.pow(2, 8 * H)), de;
        }, h.prototype.readInt8 = function(I, H) {
          return H || M(I, 1, this.length), this[I] & 128 ? (255 - this[I] + 1) * -1 : this[I];
        }, h.prototype.readInt16LE = function(I, H) {
          H || M(I, 2, this.length);
          var ie = this[I] | this[I + 1] << 8;
          return ie & 32768 ? ie | 4294901760 : ie;
        }, h.prototype.readInt16BE = function(I, H) {
          H || M(I, 2, this.length);
          var ie = this[I + 1] | this[I] << 8;
          return ie & 32768 ? ie | 4294901760 : ie;
        }, h.prototype.readInt32LE = function(I, H) {
          return H || M(I, 4, this.length), this[I] | this[I + 1] << 8 | this[I + 2] << 16 | this[I + 3] << 24;
        }, h.prototype.readInt32BE = function(I, H) {
          return H || M(I, 4, this.length), this[I] << 24 | this[I + 1] << 16 | this[I + 2] << 8 | this[I + 3];
        }, h.prototype.readFloatLE = function(I, H) {
          return H || M(I, 4, this.length), o.read(this, I, !0, 23, 4);
        }, h.prototype.readFloatBE = function(I, H) {
          return H || M(I, 4, this.length), o.read(this, I, !1, 23, 4);
        }, h.prototype.readDoubleLE = function(I, H) {
          return H || M(I, 8, this.length), o.read(this, I, !0, 52, 8);
        }, h.prototype.readDoubleBE = function(I, H) {
          return H || M(I, 8, this.length), o.read(this, I, !1, 52, 8);
        };
        function G(W, I, H, ie, ue, fe) {
          if (!h.isBuffer(W))
            throw new TypeError('"buffer" argument must be a Buffer instance');
          if (I > ue || I < fe)
            throw new RangeError('"value" argument is out of bounds');
          if (H + ie > W.length)
            throw new RangeError("Index out of range");
        }
        h.prototype.writeUIntLE = function(I, H, ie, ue) {
          if (I = +I, H = H | 0, ie = ie | 0, !ue) {
            var fe = Math.pow(2, 8 * ie) - 1;
            G(this, I, H, ie, fe, 0);
          }
          var de = 1, pe = 0;
          for (this[H] = I & 255; ++pe < ie && (de *= 256); )
            this[H + pe] = I / de & 255;
          return H + ie;
        }, h.prototype.writeUIntBE = function(I, H, ie, ue) {
          if (I = +I, H = H | 0, ie = ie | 0, !ue) {
            var fe = Math.pow(2, 8 * ie) - 1;
            G(this, I, H, ie, fe, 0);
          }
          var de = ie - 1, pe = 1;
          for (this[H + de] = I & 255; --de >= 0 && (pe *= 256); )
            this[H + de] = I / pe & 255;
          return H + ie;
        }, h.prototype.writeUInt8 = function(I, H, ie) {
          return I = +I, H = H | 0, ie || G(this, I, H, 1, 255, 0), h.TYPED_ARRAY_SUPPORT || (I = Math.floor(I)), this[H] = I & 255, H + 1;
        };
        function Z(W, I, H, ie) {
          I < 0 && (I = 65535 + I + 1);
          for (var ue = 0, fe = Math.min(W.length - H, 2); ue < fe; ++ue)
            W[H + ue] = (I & 255 << 8 * (ie ? ue : 1 - ue)) >>> (ie ? ue : 1 - ue) * 8;
        }
        h.prototype.writeUInt16LE = function(I, H, ie) {
          return I = +I, H = H | 0, ie || G(this, I, H, 2, 65535, 0), h.TYPED_ARRAY_SUPPORT ? (this[H] = I & 255, this[H + 1] = I >>> 8) : Z(this, I, H, !0), H + 2;
        }, h.prototype.writeUInt16BE = function(I, H, ie) {
          return I = +I, H = H | 0, ie || G(this, I, H, 2, 65535, 0), h.TYPED_ARRAY_SUPPORT ? (this[H] = I >>> 8, this[H + 1] = I & 255) : Z(this, I, H, !1), H + 2;
        };
        function $(W, I, H, ie) {
          I < 0 && (I = 4294967295 + I + 1);
          for (var ue = 0, fe = Math.min(W.length - H, 4); ue < fe; ++ue)
            W[H + ue] = I >>> (ie ? ue : 3 - ue) * 8 & 255;
        }
        h.prototype.writeUInt32LE = function(I, H, ie) {
          return I = +I, H = H | 0, ie || G(this, I, H, 4, 4294967295, 0), h.TYPED_ARRAY_SUPPORT ? (this[H + 3] = I >>> 24, this[H + 2] = I >>> 16, this[H + 1] = I >>> 8, this[H] = I & 255) : $(this, I, H, !0), H + 4;
        }, h.prototype.writeUInt32BE = function(I, H, ie) {
          return I = +I, H = H | 0, ie || G(this, I, H, 4, 4294967295, 0), h.TYPED_ARRAY_SUPPORT ? (this[H] = I >>> 24, this[H + 1] = I >>> 16, this[H + 2] = I >>> 8, this[H + 3] = I & 255) : $(this, I, H, !1), H + 4;
        }, h.prototype.writeIntLE = function(I, H, ie, ue) {
          if (I = +I, H = H | 0, !ue) {
            var fe = Math.pow(2, 8 * ie - 1);
            G(this, I, H, ie, fe - 1, -fe);
          }
          var de = 0, pe = 1, xe = 0;
          for (this[H] = I & 255; ++de < ie && (pe *= 256); )
            I < 0 && xe === 0 && this[H + de - 1] !== 0 && (xe = 1), this[H + de] = (I / pe >> 0) - xe & 255;
          return H + ie;
        }, h.prototype.writeIntBE = function(I, H, ie, ue) {
          if (I = +I, H = H | 0, !ue) {
            var fe = Math.pow(2, 8 * ie - 1);
            G(this, I, H, ie, fe - 1, -fe);
          }
          var de = ie - 1, pe = 1, xe = 0;
          for (this[H + de] = I & 255; --de >= 0 && (pe *= 256); )
            I < 0 && xe === 0 && this[H + de + 1] !== 0 && (xe = 1), this[H + de] = (I / pe >> 0) - xe & 255;
          return H + ie;
        }, h.prototype.writeInt8 = function(I, H, ie) {
          return I = +I, H = H | 0, ie || G(this, I, H, 1, 127, -128), h.TYPED_ARRAY_SUPPORT || (I = Math.floor(I)), I < 0 && (I = 255 + I + 1), this[H] = I & 255, H + 1;
        }, h.prototype.writeInt16LE = function(I, H, ie) {
          return I = +I, H = H | 0, ie || G(this, I, H, 2, 32767, -32768), h.TYPED_ARRAY_SUPPORT ? (this[H] = I & 255, this[H + 1] = I >>> 8) : Z(this, I, H, !0), H + 2;
        }, h.prototype.writeInt16BE = function(I, H, ie) {
          return I = +I, H = H | 0, ie || G(this, I, H, 2, 32767, -32768), h.TYPED_ARRAY_SUPPORT ? (this[H] = I >>> 8, this[H + 1] = I & 255) : Z(this, I, H, !1), H + 2;
        }, h.prototype.writeInt32LE = function(I, H, ie) {
          return I = +I, H = H | 0, ie || G(this, I, H, 4, 2147483647, -2147483648), h.TYPED_ARRAY_SUPPORT ? (this[H] = I & 255, this[H + 1] = I >>> 8, this[H + 2] = I >>> 16, this[H + 3] = I >>> 24) : $(this, I, H, !0), H + 4;
        }, h.prototype.writeInt32BE = function(I, H, ie) {
          return I = +I, H = H | 0, ie || G(this, I, H, 4, 2147483647, -2147483648), I < 0 && (I = 4294967295 + I + 1), h.TYPED_ARRAY_SUPPORT ? (this[H] = I >>> 24, this[H + 1] = I >>> 16, this[H + 2] = I >>> 8, this[H + 3] = I & 255) : $(this, I, H, !1), H + 4;
        };
        function z(W, I, H, ie, ue, fe) {
          if (H + ie > W.length)
            throw new RangeError("Index out of range");
          if (H < 0)
            throw new RangeError("Index out of range");
        }
        function V(W, I, H, ie, ue) {
          return ue || z(W, I, H, 4), o.write(W, I, H, ie, 23, 4), H + 4;
        }
        h.prototype.writeFloatLE = function(I, H, ie) {
          return V(this, I, H, !0, ie);
        }, h.prototype.writeFloatBE = function(I, H, ie) {
          return V(this, I, H, !1, ie);
        };
        function L(W, I, H, ie, ue) {
          return ue || z(W, I, H, 8), o.write(W, I, H, ie, 52, 8), H + 8;
        }
        h.prototype.writeDoubleLE = function(I, H, ie) {
          return L(this, I, H, !0, ie);
        }, h.prototype.writeDoubleBE = function(I, H, ie) {
          return L(this, I, H, !1, ie);
        }, h.prototype.copy = function(I, H, ie, ue) {
          if (ie || (ie = 0), !ue && ue !== 0 && (ue = this.length), H >= I.length && (H = I.length), H || (H = 0), ue > 0 && ue < ie && (ue = ie), ue === ie || I.length === 0 || this.length === 0)
            return 0;
          if (H < 0)
            throw new RangeError("targetStart out of bounds");
          if (ie < 0 || ie >= this.length)
            throw new RangeError("sourceStart out of bounds");
          if (ue < 0)
            throw new RangeError("sourceEnd out of bounds");
          ue > this.length && (ue = this.length), I.length - H < ue - ie && (ue = I.length - H + ie);
          var fe = ue - ie, de;
          if (this === I && ie < H && H < ue)
            for (de = fe - 1; de >= 0; --de)
              I[de + H] = this[de + ie];
          else if (fe < 1e3 || !h.TYPED_ARRAY_SUPPORT)
            for (de = 0; de < fe; ++de)
              I[de + H] = this[de + ie];
          else
            Uint8Array.prototype.set.call(
              I,
              this.subarray(ie, ie + fe),
              H
            );
          return fe;
        }, h.prototype.fill = function(I, H, ie, ue) {
          if (typeof I == "string") {
            if (typeof H == "string" ? (ue = H, H = 0, ie = this.length) : typeof ie == "string" && (ue = ie, ie = this.length), I.length === 1) {
              var fe = I.charCodeAt(0);
              fe < 256 && (I = fe);
            }
            if (ue !== void 0 && typeof ue != "string")
              throw new TypeError("encoding must be a string");
            if (typeof ue == "string" && !h.isEncoding(ue))
              throw new TypeError("Unknown encoding: " + ue);
          } else
            typeof I == "number" && (I = I & 255);
          if (H < 0 || this.length < H || this.length < ie)
            throw new RangeError("Out of range index");
          if (ie <= H)
            return this;
          H = H >>> 0, ie = ie === void 0 ? this.length : ie >>> 0, I || (I = 0);
          var de;
          if (typeof I == "number")
            for (de = H; de < ie; ++de)
              this[de] = I;
          else {
            var pe = h.isBuffer(I) ? I : N(new h(I, ue).toString()), xe = pe.length;
            for (de = 0; de < ie - H; ++de)
              this[de + H] = pe[de % xe];
          }
          return this;
        };
        var K = /[^+\/0-9A-Za-z-_]/g;
        function ne(W) {
          if (W = se(W).replace(K, ""), W.length < 2)
            return "";
          for (; W.length % 4 !== 0; )
            W = W + "=";
          return W;
        }
        function se(W) {
          return W.trim ? W.trim() : W.replace(/^\s+|\s+$/g, "");
        }
        function q(W) {
          return W < 16 ? "0" + W.toString(16) : W.toString(16);
        }
        function N(W, I) {
          I = I || 1 / 0;
          for (var H, ie = W.length, ue = null, fe = [], de = 0; de < ie; ++de) {
            if (H = W.charCodeAt(de), H > 55295 && H < 57344) {
              if (!ue) {
                if (H > 56319) {
                  (I -= 3) > -1 && fe.push(239, 191, 189);
                  continue;
                } else if (de + 1 === ie) {
                  (I -= 3) > -1 && fe.push(239, 191, 189);
                  continue;
                }
                ue = H;
                continue;
              }
              if (H < 56320) {
                (I -= 3) > -1 && fe.push(239, 191, 189), ue = H;
                continue;
              }
              H = (ue - 55296 << 10 | H - 56320) + 65536;
            } else
              ue && (I -= 3) > -1 && fe.push(239, 191, 189);
            if (ue = null, H < 128) {
              if ((I -= 1) < 0)
                break;
              fe.push(H);
            } else if (H < 2048) {
              if ((I -= 2) < 0)
                break;
              fe.push(
                H >> 6 | 192,
                H & 63 | 128
              );
            } else if (H < 65536) {
              if ((I -= 3) < 0)
                break;
              fe.push(
                H >> 12 | 224,
                H >> 6 & 63 | 128,
                H & 63 | 128
              );
            } else if (H < 1114112) {
              if ((I -= 4) < 0)
                break;
              fe.push(
                H >> 18 | 240,
                H >> 12 & 63 | 128,
                H >> 6 & 63 | 128,
                H & 63 | 128
              );
            } else
              throw new Error("Invalid code point");
          }
          return fe;
        }
        function Q(W) {
          for (var I = [], H = 0; H < W.length; ++H)
            I.push(W.charCodeAt(H) & 255);
          return I;
        }
        function E(W, I) {
          for (var H, ie, ue, fe = [], de = 0; de < W.length && !((I -= 2) < 0); ++de)
            H = W.charCodeAt(de), ie = H >> 8, ue = H % 256, fe.push(ue), fe.push(ie);
          return fe;
        }
        function te(W) {
          return J.toByteArray(ne(W));
        }
        function oe(W, I, H, ie) {
          for (var ue = 0; ue < ie && !(ue + H >= I.length || ue >= W.length); ++ue)
            I[ue + H] = W[ue];
          return ue;
        }
        function ee(W) {
          return W !== W;
        }
      }).call(this, typeof commonjsGlobal < "u" ? commonjsGlobal : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "base64-js": 40, ieee754: 83, isarray: 86 }], 79: [function(le, ce, re) {
      (function(ae) {
        function J(i) {
          return Array.isArray ? Array.isArray(i) : n(i) === "[object Array]";
        }
        re.isArray = J;
        function o(i) {
          return typeof i == "boolean";
        }
        re.isBoolean = o;
        function F(i) {
          return i === null;
        }
        re.isNull = F;
        function t(i) {
          return i == null;
        }
        re.isNullOrUndefined = t;
        function a(i) {
          return typeof i == "number";
        }
        re.isNumber = a;
        function v(i) {
          return typeof i == "string";
        }
        re.isString = v;
        function h(i) {
          return typeof i == "symbol";
        }
        re.isSymbol = h;
        function e(i) {
          return i === void 0;
        }
        re.isUndefined = e;
        function y(i) {
          return n(i) === "[object RegExp]";
        }
        re.isRegExp = y;
        function c(i) {
          return typeof i == "object" && i !== null;
        }
        re.isObject = c;
        function d(i) {
          return n(i) === "[object Date]";
        }
        re.isDate = d;
        function m(i) {
          return n(i) === "[object Error]" || i instanceof Error;
        }
        re.isError = m;
        function p(i) {
          return typeof i == "function";
        }
        re.isFunction = p;
        function g(i) {
          return i === null || typeof i == "boolean" || typeof i == "number" || typeof i == "string" || typeof i == "symbol" || // ES6 symbol
          typeof i > "u";
        }
        re.isPrimitive = g, re.isBuffer = ae.isBuffer;
        function n(i) {
          return Object.prototype.toString.call(i);
        }
      }).call(this, { isBuffer: le("../../is-buffer/index.js") });
    }, { "../../is-buffer/index.js": 85 }], 80: [function(le, ce, re) {
      Object.defineProperty(re, "__esModule", { value: !0 });
      var ae = [
        { "Typeface name": "Symbol", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
        { "Typeface name": "Symbol", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "33", "Unicode hex": "21" },
        { "Typeface name": "Symbol", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "8704", "Unicode hex": "2200" },
        { "Typeface name": "Symbol", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "35", "Unicode hex": "23" },
        { "Typeface name": "Symbol", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "8707", "Unicode hex": "2203" },
        { "Typeface name": "Symbol", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "37", "Unicode hex": "25" },
        { "Typeface name": "Symbol", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "38", "Unicode hex": "26" },
        { "Typeface name": "Symbol", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "8717", "Unicode hex": "220D" },
        { "Typeface name": "Symbol", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "40", "Unicode hex": "28" },
        { "Typeface name": "Symbol", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "41", "Unicode hex": "29" },
        { "Typeface name": "Symbol", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "42", "Unicode hex": "2A" },
        { "Typeface name": "Symbol", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "43", "Unicode hex": "2B" },
        { "Typeface name": "Symbol", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "44", "Unicode hex": "2C" },
        { "Typeface name": "Symbol", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "8722", "Unicode hex": "2212" },
        { "Typeface name": "Symbol", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "46", "Unicode hex": "2E" },
        { "Typeface name": "Symbol", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "47", "Unicode hex": "2F" },
        { "Typeface name": "Symbol", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "48", "Unicode hex": "30" },
        { "Typeface name": "Symbol", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "49", "Unicode hex": "31" },
        { "Typeface name": "Symbol", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "50", "Unicode hex": "32" },
        { "Typeface name": "Symbol", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "51", "Unicode hex": "33" },
        { "Typeface name": "Symbol", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "52", "Unicode hex": "34" },
        { "Typeface name": "Symbol", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "53", "Unicode hex": "35" },
        { "Typeface name": "Symbol", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "54", "Unicode hex": "36" },
        { "Typeface name": "Symbol", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "55", "Unicode hex": "37" },
        { "Typeface name": "Symbol", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "56", "Unicode hex": "38" },
        { "Typeface name": "Symbol", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "57", "Unicode hex": "39" },
        { "Typeface name": "Symbol", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "58", "Unicode hex": "3A" },
        { "Typeface name": "Symbol", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "59", "Unicode hex": "3B" },
        { "Typeface name": "Symbol", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "60", "Unicode hex": "3C" },
        { "Typeface name": "Symbol", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "61", "Unicode hex": "3D" },
        { "Typeface name": "Symbol", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "62", "Unicode hex": "3E" },
        { "Typeface name": "Symbol", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "63", "Unicode hex": "3F" },
        { "Typeface name": "Symbol", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "8773", "Unicode hex": "2245" },
        { "Typeface name": "Symbol", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "913", "Unicode hex": "391" },
        { "Typeface name": "Symbol", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "914", "Unicode hex": "392" },
        { "Typeface name": "Symbol", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "935", "Unicode hex": "3A7" },
        { "Typeface name": "Symbol", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "916", "Unicode hex": "394" },
        { "Typeface name": "Symbol", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "917", "Unicode hex": "395" },
        { "Typeface name": "Symbol", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "934", "Unicode hex": "3A6" },
        { "Typeface name": "Symbol", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "915", "Unicode hex": "393" },
        { "Typeface name": "Symbol", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "919", "Unicode hex": "397" },
        { "Typeface name": "Symbol", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "921", "Unicode hex": "399" },
        { "Typeface name": "Symbol", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "977", "Unicode hex": "3D1" },
        { "Typeface name": "Symbol", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "922", "Unicode hex": "39A" },
        { "Typeface name": "Symbol", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "923", "Unicode hex": "39B" },
        { "Typeface name": "Symbol", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "924", "Unicode hex": "39C" },
        { "Typeface name": "Symbol", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "925", "Unicode hex": "39D" },
        { "Typeface name": "Symbol", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "927", "Unicode hex": "39F" },
        { "Typeface name": "Symbol", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "928", "Unicode hex": "3A0" },
        { "Typeface name": "Symbol", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "920", "Unicode hex": "398" },
        { "Typeface name": "Symbol", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "929", "Unicode hex": "3A1" },
        { "Typeface name": "Symbol", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "931", "Unicode hex": "3A3" },
        { "Typeface name": "Symbol", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "932", "Unicode hex": "3A4" },
        { "Typeface name": "Symbol", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "933", "Unicode hex": "3A5" },
        { "Typeface name": "Symbol", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "962", "Unicode hex": "3C2" },
        { "Typeface name": "Symbol", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "937", "Unicode hex": "3A9" },
        { "Typeface name": "Symbol", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "926", "Unicode hex": "39E" },
        { "Typeface name": "Symbol", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "936", "Unicode hex": "3A8" },
        { "Typeface name": "Symbol", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "918", "Unicode hex": "396" },
        { "Typeface name": "Symbol", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "91", "Unicode hex": "5B" },
        { "Typeface name": "Symbol", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "8756", "Unicode hex": "2234" },
        { "Typeface name": "Symbol", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "93", "Unicode hex": "5D" },
        { "Typeface name": "Symbol", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "8869", "Unicode hex": "22A5" },
        { "Typeface name": "Symbol", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "95", "Unicode hex": "5F" },
        { "Typeface name": "Symbol", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "8254", "Unicode hex": "203E" },
        { "Typeface name": "Symbol", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "945", "Unicode hex": "3B1" },
        { "Typeface name": "Symbol", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "946", "Unicode hex": "3B2" },
        { "Typeface name": "Symbol", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "967", "Unicode hex": "3C7" },
        { "Typeface name": "Symbol", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "948", "Unicode hex": "3B4" },
        { "Typeface name": "Symbol", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "949", "Unicode hex": "3B5" },
        { "Typeface name": "Symbol", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "966", "Unicode hex": "3C6" },
        { "Typeface name": "Symbol", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "947", "Unicode hex": "3B3" },
        { "Typeface name": "Symbol", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "951", "Unicode hex": "3B7" },
        { "Typeface name": "Symbol", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "953", "Unicode hex": "3B9" },
        { "Typeface name": "Symbol", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "981", "Unicode hex": "3D5" },
        { "Typeface name": "Symbol", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "954", "Unicode hex": "3BA" },
        { "Typeface name": "Symbol", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "955", "Unicode hex": "3BB" },
        { "Typeface name": "Symbol", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "956", "Unicode hex": "3BC" },
        { "Typeface name": "Symbol", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "957", "Unicode hex": "3BD" },
        { "Typeface name": "Symbol", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "959", "Unicode hex": "3BF" },
        { "Typeface name": "Symbol", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "960", "Unicode hex": "3C0" },
        { "Typeface name": "Symbol", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "952", "Unicode hex": "3B8" },
        { "Typeface name": "Symbol", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "961", "Unicode hex": "3C1" },
        { "Typeface name": "Symbol", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "963", "Unicode hex": "3C3" },
        { "Typeface name": "Symbol", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "964", "Unicode hex": "3C4" },
        { "Typeface name": "Symbol", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "965", "Unicode hex": "3C5" },
        { "Typeface name": "Symbol", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "982", "Unicode hex": "3D6" },
        { "Typeface name": "Symbol", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "969", "Unicode hex": "3C9" },
        { "Typeface name": "Symbol", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "958", "Unicode hex": "3BE" },
        { "Typeface name": "Symbol", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "968", "Unicode hex": "3C8" },
        { "Typeface name": "Symbol", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "950", "Unicode hex": "3B6" },
        { "Typeface name": "Symbol", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "123", "Unicode hex": "7B" },
        { "Typeface name": "Symbol", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "124", "Unicode hex": "7C" },
        { "Typeface name": "Symbol", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "125", "Unicode hex": "7D" },
        { "Typeface name": "Symbol", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "126", "Unicode hex": "7E" },
        { "Typeface name": "Symbol", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "8364", "Unicode hex": "20AC" },
        { "Typeface name": "Symbol", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "978", "Unicode hex": "3D2" },
        { "Typeface name": "Symbol", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "8242", "Unicode hex": "2032" },
        { "Typeface name": "Symbol", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "8804", "Unicode hex": "2264" },
        { "Typeface name": "Symbol", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "8260", "Unicode hex": "2044" },
        { "Typeface name": "Symbol", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "8734", "Unicode hex": "221E" },
        { "Typeface name": "Symbol", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "402", "Unicode hex": "192" },
        { "Typeface name": "Symbol", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "9827", "Unicode hex": "2663" },
        { "Typeface name": "Symbol", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "9830", "Unicode hex": "2666" },
        { "Typeface name": "Symbol", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "9829", "Unicode hex": "2665" },
        { "Typeface name": "Symbol", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "9824", "Unicode hex": "2660" },
        { "Typeface name": "Symbol", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "8596", "Unicode hex": "2194" },
        { "Typeface name": "Symbol", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "8592", "Unicode hex": "2190" },
        { "Typeface name": "Symbol", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "8593", "Unicode hex": "2191" },
        { "Typeface name": "Symbol", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "8594", "Unicode hex": "2192" },
        { "Typeface name": "Symbol", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "8595", "Unicode hex": "2193" },
        { "Typeface name": "Symbol", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "176", "Unicode hex": "B0" },
        { "Typeface name": "Symbol", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "177", "Unicode hex": "B1" },
        { "Typeface name": "Symbol", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "8243", "Unicode hex": "2033" },
        { "Typeface name": "Symbol", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "8805", "Unicode hex": "2265" },
        { "Typeface name": "Symbol", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "215", "Unicode hex": "D7" },
        { "Typeface name": "Symbol", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "8733", "Unicode hex": "221D" },
        { "Typeface name": "Symbol", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "8706", "Unicode hex": "2202" },
        { "Typeface name": "Symbol", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "8226", "Unicode hex": "2022" },
        { "Typeface name": "Symbol", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "247", "Unicode hex": "F7" },
        { "Typeface name": "Symbol", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "8800", "Unicode hex": "2260" },
        { "Typeface name": "Symbol", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "8801", "Unicode hex": "2261" },
        { "Typeface name": "Symbol", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "8776", "Unicode hex": "2248" },
        { "Typeface name": "Symbol", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "8230", "Unicode hex": "2026" },
        { "Typeface name": "Symbol", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "9168", "Unicode hex": "23D0" },
        { "Typeface name": "Symbol", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "9135", "Unicode hex": "23AF" },
        { "Typeface name": "Symbol", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "8629", "Unicode hex": "21B5" },
        { "Typeface name": "Symbol", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "8501", "Unicode hex": "2135" },
        { "Typeface name": "Symbol", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "8465", "Unicode hex": "2111" },
        { "Typeface name": "Symbol", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "8476", "Unicode hex": "211C" },
        { "Typeface name": "Symbol", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "8472", "Unicode hex": "2118" },
        { "Typeface name": "Symbol", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "8855", "Unicode hex": "2297" },
        { "Typeface name": "Symbol", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "8853", "Unicode hex": "2295" },
        { "Typeface name": "Symbol", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "8709", "Unicode hex": "2205" },
        { "Typeface name": "Symbol", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "8745", "Unicode hex": "2229" },
        { "Typeface name": "Symbol", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "8746", "Unicode hex": "222A" },
        { "Typeface name": "Symbol", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "8835", "Unicode hex": "2283" },
        { "Typeface name": "Symbol", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "8839", "Unicode hex": "2287" },
        { "Typeface name": "Symbol", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "8836", "Unicode hex": "2284" },
        { "Typeface name": "Symbol", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "8834", "Unicode hex": "2282" },
        { "Typeface name": "Symbol", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "8838", "Unicode hex": "2286" },
        { "Typeface name": "Symbol", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "8712", "Unicode hex": "2208" },
        { "Typeface name": "Symbol", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "8713", "Unicode hex": "2209" },
        { "Typeface name": "Symbol", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "8736", "Unicode hex": "2220" },
        { "Typeface name": "Symbol", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "8711", "Unicode hex": "2207" },
        { "Typeface name": "Symbol", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "174", "Unicode hex": "AE" },
        { "Typeface name": "Symbol", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "169", "Unicode hex": "A9" },
        { "Typeface name": "Symbol", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "8482", "Unicode hex": "2122" },
        { "Typeface name": "Symbol", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "8719", "Unicode hex": "220F" },
        { "Typeface name": "Symbol", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "8730", "Unicode hex": "221A" },
        { "Typeface name": "Symbol", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "8901", "Unicode hex": "22C5" },
        { "Typeface name": "Symbol", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "172", "Unicode hex": "AC" },
        { "Typeface name": "Symbol", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "8743", "Unicode hex": "2227" },
        { "Typeface name": "Symbol", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "8744", "Unicode hex": "2228" },
        { "Typeface name": "Symbol", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "8660", "Unicode hex": "21D4" },
        { "Typeface name": "Symbol", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "8656", "Unicode hex": "21D0" },
        { "Typeface name": "Symbol", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "8657", "Unicode hex": "21D1" },
        { "Typeface name": "Symbol", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "8658", "Unicode hex": "21D2" },
        { "Typeface name": "Symbol", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "8659", "Unicode hex": "21D3" },
        { "Typeface name": "Symbol", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "9674", "Unicode hex": "25CA" },
        { "Typeface name": "Symbol", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "12296", "Unicode hex": "3008" },
        { "Typeface name": "Symbol", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "174", "Unicode hex": "AE" },
        { "Typeface name": "Symbol", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "169", "Unicode hex": "A9" },
        { "Typeface name": "Symbol", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "8482", "Unicode hex": "2122" },
        { "Typeface name": "Symbol", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "8721", "Unicode hex": "2211" },
        { "Typeface name": "Symbol", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "9115", "Unicode hex": "239B" },
        { "Typeface name": "Symbol", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "9116", "Unicode hex": "239C" },
        { "Typeface name": "Symbol", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "9117", "Unicode hex": "239D" },
        { "Typeface name": "Symbol", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "9121", "Unicode hex": "23A1" },
        { "Typeface name": "Symbol", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "9122", "Unicode hex": "23A2" },
        { "Typeface name": "Symbol", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "9123", "Unicode hex": "23A3" },
        { "Typeface name": "Symbol", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "9127", "Unicode hex": "23A7" },
        { "Typeface name": "Symbol", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "9128", "Unicode hex": "23A8" },
        { "Typeface name": "Symbol", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "9129", "Unicode hex": "23A9" },
        { "Typeface name": "Symbol", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "9130", "Unicode hex": "23AA" },
        { "Typeface name": "Symbol", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "63743", "Unicode hex": "F8FF" },
        { "Typeface name": "Symbol", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "12297", "Unicode hex": "3009" },
        { "Typeface name": "Symbol", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "8747", "Unicode hex": "222B" },
        { "Typeface name": "Symbol", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "8992", "Unicode hex": "2320" },
        { "Typeface name": "Symbol", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "9134", "Unicode hex": "23AE" },
        { "Typeface name": "Symbol", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "8993", "Unicode hex": "2321" },
        { "Typeface name": "Symbol", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "9118", "Unicode hex": "239E" },
        { "Typeface name": "Symbol", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "9119", "Unicode hex": "239F" },
        { "Typeface name": "Symbol", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "9120", "Unicode hex": "23A0" },
        { "Typeface name": "Symbol", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "9124", "Unicode hex": "23A4" },
        { "Typeface name": "Symbol", "Dingbat dec": "250", "Dingbat hex": "FA", "Unicode dec": "9125", "Unicode hex": "23A5" },
        { "Typeface name": "Symbol", "Dingbat dec": "251", "Dingbat hex": "FB", "Unicode dec": "9126", "Unicode hex": "23A6" },
        { "Typeface name": "Symbol", "Dingbat dec": "252", "Dingbat hex": "FC", "Unicode dec": "9131", "Unicode hex": "23AB" },
        { "Typeface name": "Symbol", "Dingbat dec": "253", "Dingbat hex": "FD", "Unicode dec": "9132", "Unicode hex": "23AC" },
        { "Typeface name": "Symbol", "Dingbat dec": "254", "Dingbat hex": "FE", "Unicode dec": "9133", "Unicode hex": "23AD" },
        { "Typeface name": "Webdings", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
        { "Typeface name": "Webdings", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "128375", "Unicode hex": "1F577" },
        { "Typeface name": "Webdings", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "128376", "Unicode hex": "1F578" },
        { "Typeface name": "Webdings", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "128370", "Unicode hex": "1F572" },
        { "Typeface name": "Webdings", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "128374", "Unicode hex": "1F576" },
        { "Typeface name": "Webdings", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "127942", "Unicode hex": "1F3C6" },
        { "Typeface name": "Webdings", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "127894", "Unicode hex": "1F396" },
        { "Typeface name": "Webdings", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "128391", "Unicode hex": "1F587" },
        { "Typeface name": "Webdings", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "128488", "Unicode hex": "1F5E8" },
        { "Typeface name": "Webdings", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "128489", "Unicode hex": "1F5E9" },
        { "Typeface name": "Webdings", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "128496", "Unicode hex": "1F5F0" },
        { "Typeface name": "Webdings", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "128497", "Unicode hex": "1F5F1" },
        { "Typeface name": "Webdings", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "127798", "Unicode hex": "1F336" },
        { "Typeface name": "Webdings", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "127895", "Unicode hex": "1F397" },
        { "Typeface name": "Webdings", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "128638", "Unicode hex": "1F67E" },
        { "Typeface name": "Webdings", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "128636", "Unicode hex": "1F67C" },
        { "Typeface name": "Webdings", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "128469", "Unicode hex": "1F5D5" },
        { "Typeface name": "Webdings", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "128470", "Unicode hex": "1F5D6" },
        { "Typeface name": "Webdings", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "128471", "Unicode hex": "1F5D7" },
        { "Typeface name": "Webdings", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "9204", "Unicode hex": "23F4" },
        { "Typeface name": "Webdings", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "9205", "Unicode hex": "23F5" },
        { "Typeface name": "Webdings", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "9206", "Unicode hex": "23F6" },
        { "Typeface name": "Webdings", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "9207", "Unicode hex": "23F7" },
        { "Typeface name": "Webdings", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "9194", "Unicode hex": "23EA" },
        { "Typeface name": "Webdings", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "9193", "Unicode hex": "23E9" },
        { "Typeface name": "Webdings", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "9198", "Unicode hex": "23EE" },
        { "Typeface name": "Webdings", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "9197", "Unicode hex": "23ED" },
        { "Typeface name": "Webdings", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "9208", "Unicode hex": "23F8" },
        { "Typeface name": "Webdings", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "9209", "Unicode hex": "23F9" },
        { "Typeface name": "Webdings", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "9210", "Unicode hex": "23FA" },
        { "Typeface name": "Webdings", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "128474", "Unicode hex": "1F5DA" },
        { "Typeface name": "Webdings", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "128499", "Unicode hex": "1F5F3" },
        { "Typeface name": "Webdings", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "128736", "Unicode hex": "1F6E0" },
        { "Typeface name": "Webdings", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "127959", "Unicode hex": "1F3D7" },
        { "Typeface name": "Webdings", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "127960", "Unicode hex": "1F3D8" },
        { "Typeface name": "Webdings", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "127961", "Unicode hex": "1F3D9" },
        { "Typeface name": "Webdings", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "127962", "Unicode hex": "1F3DA" },
        { "Typeface name": "Webdings", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "127964", "Unicode hex": "1F3DC" },
        { "Typeface name": "Webdings", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "127981", "Unicode hex": "1F3ED" },
        { "Typeface name": "Webdings", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "127963", "Unicode hex": "1F3DB" },
        { "Typeface name": "Webdings", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "127968", "Unicode hex": "1F3E0" },
        { "Typeface name": "Webdings", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "127958", "Unicode hex": "1F3D6" },
        { "Typeface name": "Webdings", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "127965", "Unicode hex": "1F3DD" },
        { "Typeface name": "Webdings", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "128739", "Unicode hex": "1F6E3" },
        { "Typeface name": "Webdings", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "128269", "Unicode hex": "1F50D" },
        { "Typeface name": "Webdings", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "127956", "Unicode hex": "1F3D4" },
        { "Typeface name": "Webdings", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "128065", "Unicode hex": "1F441" },
        { "Typeface name": "Webdings", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "128066", "Unicode hex": "1F442" },
        { "Typeface name": "Webdings", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "127966", "Unicode hex": "1F3DE" },
        { "Typeface name": "Webdings", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "127957", "Unicode hex": "1F3D5" },
        { "Typeface name": "Webdings", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "128740", "Unicode hex": "1F6E4" },
        { "Typeface name": "Webdings", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "127967", "Unicode hex": "1F3DF" },
        { "Typeface name": "Webdings", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "128755", "Unicode hex": "1F6F3" },
        { "Typeface name": "Webdings", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "128364", "Unicode hex": "1F56C" },
        { "Typeface name": "Webdings", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "128363", "Unicode hex": "1F56B" },
        { "Typeface name": "Webdings", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "128360", "Unicode hex": "1F568" },
        { "Typeface name": "Webdings", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "128264", "Unicode hex": "1F508" },
        { "Typeface name": "Webdings", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "127892", "Unicode hex": "1F394" },
        { "Typeface name": "Webdings", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "127893", "Unicode hex": "1F395" },
        { "Typeface name": "Webdings", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "128492", "Unicode hex": "1F5EC" },
        { "Typeface name": "Webdings", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "128637", "Unicode hex": "1F67D" },
        { "Typeface name": "Webdings", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "128493", "Unicode hex": "1F5ED" },
        { "Typeface name": "Webdings", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "128490", "Unicode hex": "1F5EA" },
        { "Typeface name": "Webdings", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "128491", "Unicode hex": "1F5EB" },
        { "Typeface name": "Webdings", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "11156", "Unicode hex": "2B94" },
        { "Typeface name": "Webdings", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "10004", "Unicode hex": "2714" },
        { "Typeface name": "Webdings", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "128690", "Unicode hex": "1F6B2" },
        { "Typeface name": "Webdings", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "11036", "Unicode hex": "2B1C" },
        { "Typeface name": "Webdings", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "128737", "Unicode hex": "1F6E1" },
        { "Typeface name": "Webdings", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "128230", "Unicode hex": "1F4E6" },
        { "Typeface name": "Webdings", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "128753", "Unicode hex": "1F6F1" },
        { "Typeface name": "Webdings", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "11035", "Unicode hex": "2B1B" },
        { "Typeface name": "Webdings", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "128657", "Unicode hex": "1F691" },
        { "Typeface name": "Webdings", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "128712", "Unicode hex": "1F6C8" },
        { "Typeface name": "Webdings", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "128745", "Unicode hex": "1F6E9" },
        { "Typeface name": "Webdings", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "128752", "Unicode hex": "1F6F0" },
        { "Typeface name": "Webdings", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "128968", "Unicode hex": "1F7C8" },
        { "Typeface name": "Webdings", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "128372", "Unicode hex": "1F574" },
        { "Typeface name": "Webdings", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "11044", "Unicode hex": "2B24" },
        { "Typeface name": "Webdings", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "128741", "Unicode hex": "1F6E5" },
        { "Typeface name": "Webdings", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "128660", "Unicode hex": "1F694" },
        { "Typeface name": "Webdings", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "128472", "Unicode hex": "1F5D8" },
        { "Typeface name": "Webdings", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "128473", "Unicode hex": "1F5D9" },
        { "Typeface name": "Webdings", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "10067", "Unicode hex": "2753" },
        { "Typeface name": "Webdings", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "128754", "Unicode hex": "1F6F2" },
        { "Typeface name": "Webdings", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "128647", "Unicode hex": "1F687" },
        { "Typeface name": "Webdings", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "128653", "Unicode hex": "1F68D" },
        { "Typeface name": "Webdings", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "9971", "Unicode hex": "26F3" },
        { "Typeface name": "Webdings", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "10680", "Unicode hex": "29B8" },
        { "Typeface name": "Webdings", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "8854", "Unicode hex": "2296" },
        { "Typeface name": "Webdings", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "128685", "Unicode hex": "1F6AD" },
        { "Typeface name": "Webdings", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "128494", "Unicode hex": "1F5EE" },
        { "Typeface name": "Webdings", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "9168", "Unicode hex": "23D0" },
        { "Typeface name": "Webdings", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "128495", "Unicode hex": "1F5EF" },
        { "Typeface name": "Webdings", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "128498", "Unicode hex": "1F5F2" },
        { "Typeface name": "Webdings", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "128697", "Unicode hex": "1F6B9" },
        { "Typeface name": "Webdings", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "128698", "Unicode hex": "1F6BA" },
        { "Typeface name": "Webdings", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "128713", "Unicode hex": "1F6C9" },
        { "Typeface name": "Webdings", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "128714", "Unicode hex": "1F6CA" },
        { "Typeface name": "Webdings", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "128700", "Unicode hex": "1F6BC" },
        { "Typeface name": "Webdings", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "128125", "Unicode hex": "1F47D" },
        { "Typeface name": "Webdings", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "127947", "Unicode hex": "1F3CB" },
        { "Typeface name": "Webdings", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "9975", "Unicode hex": "26F7" },
        { "Typeface name": "Webdings", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "127938", "Unicode hex": "1F3C2" },
        { "Typeface name": "Webdings", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "127948", "Unicode hex": "1F3CC" },
        { "Typeface name": "Webdings", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "127946", "Unicode hex": "1F3CA" },
        { "Typeface name": "Webdings", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "127940", "Unicode hex": "1F3C4" },
        { "Typeface name": "Webdings", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "127949", "Unicode hex": "1F3CD" },
        { "Typeface name": "Webdings", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "127950", "Unicode hex": "1F3CE" },
        { "Typeface name": "Webdings", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "128664", "Unicode hex": "1F698" },
        { "Typeface name": "Webdings", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "128480", "Unicode hex": "1F5E0" },
        { "Typeface name": "Webdings", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "128738", "Unicode hex": "1F6E2" },
        { "Typeface name": "Webdings", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "128176", "Unicode hex": "1F4B0" },
        { "Typeface name": "Webdings", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "127991", "Unicode hex": "1F3F7" },
        { "Typeface name": "Webdings", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "128179", "Unicode hex": "1F4B3" },
        { "Typeface name": "Webdings", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "128106", "Unicode hex": "1F46A" },
        { "Typeface name": "Webdings", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "128481", "Unicode hex": "1F5E1" },
        { "Typeface name": "Webdings", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "128482", "Unicode hex": "1F5E2" },
        { "Typeface name": "Webdings", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "128483", "Unicode hex": "1F5E3" },
        { "Typeface name": "Webdings", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "10031", "Unicode hex": "272F" },
        { "Typeface name": "Webdings", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "128388", "Unicode hex": "1F584" },
        { "Typeface name": "Webdings", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "128389", "Unicode hex": "1F585" },
        { "Typeface name": "Webdings", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "128387", "Unicode hex": "1F583" },
        { "Typeface name": "Webdings", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "128390", "Unicode hex": "1F586" },
        { "Typeface name": "Webdings", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "128441", "Unicode hex": "1F5B9" },
        { "Typeface name": "Webdings", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "128442", "Unicode hex": "1F5BA" },
        { "Typeface name": "Webdings", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "128443", "Unicode hex": "1F5BB" },
        { "Typeface name": "Webdings", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "128373", "Unicode hex": "1F575" },
        { "Typeface name": "Webdings", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "128368", "Unicode hex": "1F570" },
        { "Typeface name": "Webdings", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "128445", "Unicode hex": "1F5BD" },
        { "Typeface name": "Webdings", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "128446", "Unicode hex": "1F5BE" },
        { "Typeface name": "Webdings", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "128203", "Unicode hex": "1F4CB" },
        { "Typeface name": "Webdings", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "128466", "Unicode hex": "1F5D2" },
        { "Typeface name": "Webdings", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "128467", "Unicode hex": "1F5D3" },
        { "Typeface name": "Webdings", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "128366", "Unicode hex": "1F56E" },
        { "Typeface name": "Webdings", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "128218", "Unicode hex": "1F4DA" },
        { "Typeface name": "Webdings", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "128478", "Unicode hex": "1F5DE" },
        { "Typeface name": "Webdings", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "128479", "Unicode hex": "1F5DF" },
        { "Typeface name": "Webdings", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "128451", "Unicode hex": "1F5C3" },
        { "Typeface name": "Webdings", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "128450", "Unicode hex": "1F5C2" },
        { "Typeface name": "Webdings", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "128444", "Unicode hex": "1F5BC" },
        { "Typeface name": "Webdings", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "127917", "Unicode hex": "1F3AD" },
        { "Typeface name": "Webdings", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "127900", "Unicode hex": "1F39C" },
        { "Typeface name": "Webdings", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "127896", "Unicode hex": "1F398" },
        { "Typeface name": "Webdings", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "127897", "Unicode hex": "1F399" },
        { "Typeface name": "Webdings", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "127911", "Unicode hex": "1F3A7" },
        { "Typeface name": "Webdings", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "128191", "Unicode hex": "1F4BF" },
        { "Typeface name": "Webdings", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "127902", "Unicode hex": "1F39E" },
        { "Typeface name": "Webdings", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "128247", "Unicode hex": "1F4F7" },
        { "Typeface name": "Webdings", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "127903", "Unicode hex": "1F39F" },
        { "Typeface name": "Webdings", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "127916", "Unicode hex": "1F3AC" },
        { "Typeface name": "Webdings", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "128253", "Unicode hex": "1F4FD" },
        { "Typeface name": "Webdings", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "128249", "Unicode hex": "1F4F9" },
        { "Typeface name": "Webdings", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "128254", "Unicode hex": "1F4FE" },
        { "Typeface name": "Webdings", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "128251", "Unicode hex": "1F4FB" },
        { "Typeface name": "Webdings", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "127898", "Unicode hex": "1F39A" },
        { "Typeface name": "Webdings", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "127899", "Unicode hex": "1F39B" },
        { "Typeface name": "Webdings", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "128250", "Unicode hex": "1F4FA" },
        { "Typeface name": "Webdings", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "128187", "Unicode hex": "1F4BB" },
        { "Typeface name": "Webdings", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "128421", "Unicode hex": "1F5A5" },
        { "Typeface name": "Webdings", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "128422", "Unicode hex": "1F5A6" },
        { "Typeface name": "Webdings", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "128423", "Unicode hex": "1F5A7" },
        { "Typeface name": "Webdings", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "128377", "Unicode hex": "1F579" },
        { "Typeface name": "Webdings", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "127918", "Unicode hex": "1F3AE" },
        { "Typeface name": "Webdings", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "128379", "Unicode hex": "1F57B" },
        { "Typeface name": "Webdings", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "128380", "Unicode hex": "1F57C" },
        { "Typeface name": "Webdings", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "128223", "Unicode hex": "1F4DF" },
        { "Typeface name": "Webdings", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "128385", "Unicode hex": "1F581" },
        { "Typeface name": "Webdings", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "128384", "Unicode hex": "1F580" },
        { "Typeface name": "Webdings", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "128424", "Unicode hex": "1F5A8" },
        { "Typeface name": "Webdings", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "128425", "Unicode hex": "1F5A9" },
        { "Typeface name": "Webdings", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "128447", "Unicode hex": "1F5BF" },
        { "Typeface name": "Webdings", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "128426", "Unicode hex": "1F5AA" },
        { "Typeface name": "Webdings", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "128476", "Unicode hex": "1F5DC" },
        { "Typeface name": "Webdings", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "128274", "Unicode hex": "1F512" },
        { "Typeface name": "Webdings", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "128275", "Unicode hex": "1F513" },
        { "Typeface name": "Webdings", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "128477", "Unicode hex": "1F5DD" },
        { "Typeface name": "Webdings", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "128229", "Unicode hex": "1F4E5" },
        { "Typeface name": "Webdings", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "128228", "Unicode hex": "1F4E4" },
        { "Typeface name": "Webdings", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "128371", "Unicode hex": "1F573" },
        { "Typeface name": "Webdings", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "127779", "Unicode hex": "1F323" },
        { "Typeface name": "Webdings", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "127780", "Unicode hex": "1F324" },
        { "Typeface name": "Webdings", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "127781", "Unicode hex": "1F325" },
        { "Typeface name": "Webdings", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "127782", "Unicode hex": "1F326" },
        { "Typeface name": "Webdings", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "9729", "Unicode hex": "2601" },
        { "Typeface name": "Webdings", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "127784", "Unicode hex": "1F328" },
        { "Typeface name": "Webdings", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "127783", "Unicode hex": "1F327" },
        { "Typeface name": "Webdings", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "127785", "Unicode hex": "1F329" },
        { "Typeface name": "Webdings", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "127786", "Unicode hex": "1F32A" },
        { "Typeface name": "Webdings", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "127788", "Unicode hex": "1F32C" },
        { "Typeface name": "Webdings", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "127787", "Unicode hex": "1F32B" },
        { "Typeface name": "Webdings", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "127772", "Unicode hex": "1F31C" },
        { "Typeface name": "Webdings", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "127777", "Unicode hex": "1F321" },
        { "Typeface name": "Webdings", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "128715", "Unicode hex": "1F6CB" },
        { "Typeface name": "Webdings", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "128719", "Unicode hex": "1F6CF" },
        { "Typeface name": "Webdings", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "127869", "Unicode hex": "1F37D" },
        { "Typeface name": "Webdings", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "127864", "Unicode hex": "1F378" },
        { "Typeface name": "Webdings", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "128718", "Unicode hex": "1F6CE" },
        { "Typeface name": "Webdings", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "128717", "Unicode hex": "1F6CD" },
        { "Typeface name": "Webdings", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "9413", "Unicode hex": "24C5" },
        { "Typeface name": "Webdings", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "9855", "Unicode hex": "267F" },
        { "Typeface name": "Webdings", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "128710", "Unicode hex": "1F6C6" },
        { "Typeface name": "Webdings", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "128392", "Unicode hex": "1F588" },
        { "Typeface name": "Webdings", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "127891", "Unicode hex": "1F393" },
        { "Typeface name": "Webdings", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "128484", "Unicode hex": "1F5E4" },
        { "Typeface name": "Webdings", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "128485", "Unicode hex": "1F5E5" },
        { "Typeface name": "Webdings", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "128486", "Unicode hex": "1F5E6" },
        { "Typeface name": "Webdings", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "128487", "Unicode hex": "1F5E7" },
        { "Typeface name": "Webdings", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "128746", "Unicode hex": "1F6EA" },
        { "Typeface name": "Webdings", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "128063", "Unicode hex": "1F43F" },
        { "Typeface name": "Webdings", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "128038", "Unicode hex": "1F426" },
        { "Typeface name": "Webdings", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "128031", "Unicode hex": "1F41F" },
        { "Typeface name": "Webdings", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "128021", "Unicode hex": "1F415" },
        { "Typeface name": "Webdings", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "128008", "Unicode hex": "1F408" },
        { "Typeface name": "Webdings", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "128620", "Unicode hex": "1F66C" },
        { "Typeface name": "Webdings", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "128622", "Unicode hex": "1F66E" },
        { "Typeface name": "Webdings", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "128621", "Unicode hex": "1F66D" },
        { "Typeface name": "Webdings", "Dingbat dec": "250", "Dingbat hex": "FA", "Unicode dec": "128623", "Unicode hex": "1F66F" },
        { "Typeface name": "Webdings", "Dingbat dec": "251", "Dingbat hex": "FB", "Unicode dec": "128506", "Unicode hex": "1F5FA" },
        { "Typeface name": "Webdings", "Dingbat dec": "252", "Dingbat hex": "FC", "Unicode dec": "127757", "Unicode hex": "1F30D" },
        { "Typeface name": "Webdings", "Dingbat dec": "253", "Dingbat hex": "FD", "Unicode dec": "127759", "Unicode hex": "1F30F" },
        { "Typeface name": "Webdings", "Dingbat dec": "254", "Dingbat hex": "FE", "Unicode dec": "127758", "Unicode hex": "1F30E" },
        { "Typeface name": "Webdings", "Dingbat dec": "255", "Dingbat hex": "FF", "Unicode dec": "128330", "Unicode hex": "1F54A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
        { "Typeface name": "Wingdings", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "128393", "Unicode hex": "1F589" },
        { "Typeface name": "Wingdings", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "9986", "Unicode hex": "2702" },
        { "Typeface name": "Wingdings", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "9985", "Unicode hex": "2701" },
        { "Typeface name": "Wingdings", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "128083", "Unicode hex": "1F453" },
        { "Typeface name": "Wingdings", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "128365", "Unicode hex": "1F56D" },
        { "Typeface name": "Wingdings", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "128366", "Unicode hex": "1F56E" },
        { "Typeface name": "Wingdings", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "128367", "Unicode hex": "1F56F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "128383", "Unicode hex": "1F57F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "9990", "Unicode hex": "2706" },
        { "Typeface name": "Wingdings", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "128386", "Unicode hex": "1F582" },
        { "Typeface name": "Wingdings", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "128387", "Unicode hex": "1F583" },
        { "Typeface name": "Wingdings", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "128234", "Unicode hex": "1F4EA" },
        { "Typeface name": "Wingdings", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "128235", "Unicode hex": "1F4EB" },
        { "Typeface name": "Wingdings", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "128236", "Unicode hex": "1F4EC" },
        { "Typeface name": "Wingdings", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "128237", "Unicode hex": "1F4ED" },
        { "Typeface name": "Wingdings", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "128448", "Unicode hex": "1F5C0" },
        { "Typeface name": "Wingdings", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "128449", "Unicode hex": "1F5C1" },
        { "Typeface name": "Wingdings", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "128462", "Unicode hex": "1F5CE" },
        { "Typeface name": "Wingdings", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "128463", "Unicode hex": "1F5CF" },
        { "Typeface name": "Wingdings", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "128464", "Unicode hex": "1F5D0" },
        { "Typeface name": "Wingdings", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "128452", "Unicode hex": "1F5C4" },
        { "Typeface name": "Wingdings", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "8987", "Unicode hex": "231B" },
        { "Typeface name": "Wingdings", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "128430", "Unicode hex": "1F5AE" },
        { "Typeface name": "Wingdings", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "128432", "Unicode hex": "1F5B0" },
        { "Typeface name": "Wingdings", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "128434", "Unicode hex": "1F5B2" },
        { "Typeface name": "Wingdings", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "128435", "Unicode hex": "1F5B3" },
        { "Typeface name": "Wingdings", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "128436", "Unicode hex": "1F5B4" },
        { "Typeface name": "Wingdings", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "128427", "Unicode hex": "1F5AB" },
        { "Typeface name": "Wingdings", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "128428", "Unicode hex": "1F5AC" },
        { "Typeface name": "Wingdings", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "9991", "Unicode hex": "2707" },
        { "Typeface name": "Wingdings", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "9997", "Unicode hex": "270D" },
        { "Typeface name": "Wingdings", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "128398", "Unicode hex": "1F58E" },
        { "Typeface name": "Wingdings", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "9996", "Unicode hex": "270C" },
        { "Typeface name": "Wingdings", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "128399", "Unicode hex": "1F58F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "128077", "Unicode hex": "1F44D" },
        { "Typeface name": "Wingdings", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "128078", "Unicode hex": "1F44E" },
        { "Typeface name": "Wingdings", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "9756", "Unicode hex": "261C" },
        { "Typeface name": "Wingdings", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "9758", "Unicode hex": "261E" },
        { "Typeface name": "Wingdings", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "9757", "Unicode hex": "261D" },
        { "Typeface name": "Wingdings", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "9759", "Unicode hex": "261F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "128400", "Unicode hex": "1F590" },
        { "Typeface name": "Wingdings", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "9786", "Unicode hex": "263A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "128528", "Unicode hex": "1F610" },
        { "Typeface name": "Wingdings", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "9785", "Unicode hex": "2639" },
        { "Typeface name": "Wingdings", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "128163", "Unicode hex": "1F4A3" },
        { "Typeface name": "Wingdings", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "128369", "Unicode hex": "1F571" },
        { "Typeface name": "Wingdings", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "127987", "Unicode hex": "1F3F3" },
        { "Typeface name": "Wingdings", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "127985", "Unicode hex": "1F3F1" },
        { "Typeface name": "Wingdings", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "9992", "Unicode hex": "2708" },
        { "Typeface name": "Wingdings", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "9788", "Unicode hex": "263C" },
        { "Typeface name": "Wingdings", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "127778", "Unicode hex": "1F322" },
        { "Typeface name": "Wingdings", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "10052", "Unicode hex": "2744" },
        { "Typeface name": "Wingdings", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "128326", "Unicode hex": "1F546" },
        { "Typeface name": "Wingdings", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "10014", "Unicode hex": "271E" },
        { "Typeface name": "Wingdings", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "128328", "Unicode hex": "1F548" },
        { "Typeface name": "Wingdings", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "10016", "Unicode hex": "2720" },
        { "Typeface name": "Wingdings", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "10017", "Unicode hex": "2721" },
        { "Typeface name": "Wingdings", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "9770", "Unicode hex": "262A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "9775", "Unicode hex": "262F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "128329", "Unicode hex": "1F549" },
        { "Typeface name": "Wingdings", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "9784", "Unicode hex": "2638" },
        { "Typeface name": "Wingdings", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "9800", "Unicode hex": "2648" },
        { "Typeface name": "Wingdings", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "9801", "Unicode hex": "2649" },
        { "Typeface name": "Wingdings", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "9802", "Unicode hex": "264A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "9803", "Unicode hex": "264B" },
        { "Typeface name": "Wingdings", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "9804", "Unicode hex": "264C" },
        { "Typeface name": "Wingdings", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "9805", "Unicode hex": "264D" },
        { "Typeface name": "Wingdings", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "9806", "Unicode hex": "264E" },
        { "Typeface name": "Wingdings", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "9807", "Unicode hex": "264F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "9808", "Unicode hex": "2650" },
        { "Typeface name": "Wingdings", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "9809", "Unicode hex": "2651" },
        { "Typeface name": "Wingdings", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "9810", "Unicode hex": "2652" },
        { "Typeface name": "Wingdings", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "9811", "Unicode hex": "2653" },
        { "Typeface name": "Wingdings", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "128624", "Unicode hex": "1F670" },
        { "Typeface name": "Wingdings", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "128629", "Unicode hex": "1F675" },
        { "Typeface name": "Wingdings", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "9899", "Unicode hex": "26AB" },
        { "Typeface name": "Wingdings", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "128318", "Unicode hex": "1F53E" },
        { "Typeface name": "Wingdings", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "9724", "Unicode hex": "25FC" },
        { "Typeface name": "Wingdings", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "128911", "Unicode hex": "1F78F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "128912", "Unicode hex": "1F790" },
        { "Typeface name": "Wingdings", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "10065", "Unicode hex": "2751" },
        { "Typeface name": "Wingdings", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "10066", "Unicode hex": "2752" },
        { "Typeface name": "Wingdings", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "128927", "Unicode hex": "1F79F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "10731", "Unicode hex": "29EB" },
        { "Typeface name": "Wingdings", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "9670", "Unicode hex": "25C6" },
        { "Typeface name": "Wingdings", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "10070", "Unicode hex": "2756" },
        { "Typeface name": "Wingdings", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "11049", "Unicode hex": "2B29" },
        { "Typeface name": "Wingdings", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "8999", "Unicode hex": "2327" },
        { "Typeface name": "Wingdings", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "11193", "Unicode hex": "2BB9" },
        { "Typeface name": "Wingdings", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "8984", "Unicode hex": "2318" },
        { "Typeface name": "Wingdings", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "127989", "Unicode hex": "1F3F5" },
        { "Typeface name": "Wingdings", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "127990", "Unicode hex": "1F3F6" },
        { "Typeface name": "Wingdings", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "128630", "Unicode hex": "1F676" },
        { "Typeface name": "Wingdings", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "128631", "Unicode hex": "1F677" },
        { "Typeface name": "Wingdings", "Dingbat dec": "127", "Dingbat hex": "7F", "Unicode dec": "9647", "Unicode hex": "25AF" },
        { "Typeface name": "Wingdings", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "127243", "Unicode hex": "1F10B" },
        { "Typeface name": "Wingdings", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "10112", "Unicode hex": "2780" },
        { "Typeface name": "Wingdings", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "10113", "Unicode hex": "2781" },
        { "Typeface name": "Wingdings", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "10114", "Unicode hex": "2782" },
        { "Typeface name": "Wingdings", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "10115", "Unicode hex": "2783" },
        { "Typeface name": "Wingdings", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "10116", "Unicode hex": "2784" },
        { "Typeface name": "Wingdings", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "10117", "Unicode hex": "2785" },
        { "Typeface name": "Wingdings", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "10118", "Unicode hex": "2786" },
        { "Typeface name": "Wingdings", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "10119", "Unicode hex": "2787" },
        { "Typeface name": "Wingdings", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "10120", "Unicode hex": "2788" },
        { "Typeface name": "Wingdings", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "10121", "Unicode hex": "2789" },
        { "Typeface name": "Wingdings", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "127244", "Unicode hex": "1F10C" },
        { "Typeface name": "Wingdings", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "10122", "Unicode hex": "278A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "10123", "Unicode hex": "278B" },
        { "Typeface name": "Wingdings", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "10124", "Unicode hex": "278C" },
        { "Typeface name": "Wingdings", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "10125", "Unicode hex": "278D" },
        { "Typeface name": "Wingdings", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "10126", "Unicode hex": "278E" },
        { "Typeface name": "Wingdings", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "10127", "Unicode hex": "278F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "10128", "Unicode hex": "2790" },
        { "Typeface name": "Wingdings", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "10129", "Unicode hex": "2791" },
        { "Typeface name": "Wingdings", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "10130", "Unicode hex": "2792" },
        { "Typeface name": "Wingdings", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "10131", "Unicode hex": "2793" },
        { "Typeface name": "Wingdings", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "128610", "Unicode hex": "1F662" },
        { "Typeface name": "Wingdings", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "128608", "Unicode hex": "1F660" },
        { "Typeface name": "Wingdings", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "128609", "Unicode hex": "1F661" },
        { "Typeface name": "Wingdings", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "128611", "Unicode hex": "1F663" },
        { "Typeface name": "Wingdings", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "128606", "Unicode hex": "1F65E" },
        { "Typeface name": "Wingdings", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "128604", "Unicode hex": "1F65C" },
        { "Typeface name": "Wingdings", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "128605", "Unicode hex": "1F65D" },
        { "Typeface name": "Wingdings", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "128607", "Unicode hex": "1F65F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "8729", "Unicode hex": "2219" },
        { "Typeface name": "Wingdings", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "8226", "Unicode hex": "2022" },
        { "Typeface name": "Wingdings", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "11037", "Unicode hex": "2B1D" },
        { "Typeface name": "Wingdings", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "11096", "Unicode hex": "2B58" },
        { "Typeface name": "Wingdings", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "128902", "Unicode hex": "1F786" },
        { "Typeface name": "Wingdings", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "128904", "Unicode hex": "1F788" },
        { "Typeface name": "Wingdings", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "128906", "Unicode hex": "1F78A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "128907", "Unicode hex": "1F78B" },
        { "Typeface name": "Wingdings", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "128319", "Unicode hex": "1F53F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "9642", "Unicode hex": "25AA" },
        { "Typeface name": "Wingdings", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "128910", "Unicode hex": "1F78E" },
        { "Typeface name": "Wingdings", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "128961", "Unicode hex": "1F7C1" },
        { "Typeface name": "Wingdings", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "128965", "Unicode hex": "1F7C5" },
        { "Typeface name": "Wingdings", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "9733", "Unicode hex": "2605" },
        { "Typeface name": "Wingdings", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "128971", "Unicode hex": "1F7CB" },
        { "Typeface name": "Wingdings", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "128975", "Unicode hex": "1F7CF" },
        { "Typeface name": "Wingdings", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "128979", "Unicode hex": "1F7D3" },
        { "Typeface name": "Wingdings", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "128977", "Unicode hex": "1F7D1" },
        { "Typeface name": "Wingdings", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "11216", "Unicode hex": "2BD0" },
        { "Typeface name": "Wingdings", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "8982", "Unicode hex": "2316" },
        { "Typeface name": "Wingdings", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "11214", "Unicode hex": "2BCE" },
        { "Typeface name": "Wingdings", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "11215", "Unicode hex": "2BCF" },
        { "Typeface name": "Wingdings", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "11217", "Unicode hex": "2BD1" },
        { "Typeface name": "Wingdings", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "10026", "Unicode hex": "272A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "10032", "Unicode hex": "2730" },
        { "Typeface name": "Wingdings", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "128336", "Unicode hex": "1F550" },
        { "Typeface name": "Wingdings", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "128337", "Unicode hex": "1F551" },
        { "Typeface name": "Wingdings", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "128338", "Unicode hex": "1F552" },
        { "Typeface name": "Wingdings", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "128339", "Unicode hex": "1F553" },
        { "Typeface name": "Wingdings", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "128340", "Unicode hex": "1F554" },
        { "Typeface name": "Wingdings", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "128341", "Unicode hex": "1F555" },
        { "Typeface name": "Wingdings", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "128342", "Unicode hex": "1F556" },
        { "Typeface name": "Wingdings", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "128343", "Unicode hex": "1F557" },
        { "Typeface name": "Wingdings", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "128344", "Unicode hex": "1F558" },
        { "Typeface name": "Wingdings", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "128345", "Unicode hex": "1F559" },
        { "Typeface name": "Wingdings", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "128346", "Unicode hex": "1F55A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "128347", "Unicode hex": "1F55B" },
        { "Typeface name": "Wingdings", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "11184", "Unicode hex": "2BB0" },
        { "Typeface name": "Wingdings", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "11185", "Unicode hex": "2BB1" },
        { "Typeface name": "Wingdings", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "11186", "Unicode hex": "2BB2" },
        { "Typeface name": "Wingdings", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "11187", "Unicode hex": "2BB3" },
        { "Typeface name": "Wingdings", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "11188", "Unicode hex": "2BB4" },
        { "Typeface name": "Wingdings", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "11189", "Unicode hex": "2BB5" },
        { "Typeface name": "Wingdings", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "11190", "Unicode hex": "2BB6" },
        { "Typeface name": "Wingdings", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "11191", "Unicode hex": "2BB7" },
        { "Typeface name": "Wingdings", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "128618", "Unicode hex": "1F66A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "128619", "Unicode hex": "1F66B" },
        { "Typeface name": "Wingdings", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "128597", "Unicode hex": "1F655" },
        { "Typeface name": "Wingdings", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "128596", "Unicode hex": "1F654" },
        { "Typeface name": "Wingdings", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "128599", "Unicode hex": "1F657" },
        { "Typeface name": "Wingdings", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "128598", "Unicode hex": "1F656" },
        { "Typeface name": "Wingdings", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "128592", "Unicode hex": "1F650" },
        { "Typeface name": "Wingdings", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "128593", "Unicode hex": "1F651" },
        { "Typeface name": "Wingdings", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "128594", "Unicode hex": "1F652" },
        { "Typeface name": "Wingdings", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "128595", "Unicode hex": "1F653" },
        { "Typeface name": "Wingdings", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "9003", "Unicode hex": "232B" },
        { "Typeface name": "Wingdings", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "8998", "Unicode hex": "2326" },
        { "Typeface name": "Wingdings", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "11160", "Unicode hex": "2B98" },
        { "Typeface name": "Wingdings", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "11162", "Unicode hex": "2B9A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "11161", "Unicode hex": "2B99" },
        { "Typeface name": "Wingdings", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "11163", "Unicode hex": "2B9B" },
        { "Typeface name": "Wingdings", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "11144", "Unicode hex": "2B88" },
        { "Typeface name": "Wingdings", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "11146", "Unicode hex": "2B8A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "11145", "Unicode hex": "2B89" },
        { "Typeface name": "Wingdings", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "11147", "Unicode hex": "2B8B" },
        { "Typeface name": "Wingdings", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "129128", "Unicode hex": "1F868" },
        { "Typeface name": "Wingdings", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "129130", "Unicode hex": "1F86A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "129129", "Unicode hex": "1F869" },
        { "Typeface name": "Wingdings", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "129131", "Unicode hex": "1F86B" },
        { "Typeface name": "Wingdings", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "129132", "Unicode hex": "1F86C" },
        { "Typeface name": "Wingdings", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "129133", "Unicode hex": "1F86D" },
        { "Typeface name": "Wingdings", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "129135", "Unicode hex": "1F86F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "129134", "Unicode hex": "1F86E" },
        { "Typeface name": "Wingdings", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "129144", "Unicode hex": "1F878" },
        { "Typeface name": "Wingdings", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "129146", "Unicode hex": "1F87A" },
        { "Typeface name": "Wingdings", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "129145", "Unicode hex": "1F879" },
        { "Typeface name": "Wingdings", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "129147", "Unicode hex": "1F87B" },
        { "Typeface name": "Wingdings", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "129148", "Unicode hex": "1F87C" },
        { "Typeface name": "Wingdings", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "129149", "Unicode hex": "1F87D" },
        { "Typeface name": "Wingdings", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "129151", "Unicode hex": "1F87F" },
        { "Typeface name": "Wingdings", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "129150", "Unicode hex": "1F87E" },
        { "Typeface name": "Wingdings", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "8678", "Unicode hex": "21E6" },
        { "Typeface name": "Wingdings", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "8680", "Unicode hex": "21E8" },
        { "Typeface name": "Wingdings", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "8679", "Unicode hex": "21E7" },
        { "Typeface name": "Wingdings", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "8681", "Unicode hex": "21E9" },
        { "Typeface name": "Wingdings", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "11012", "Unicode hex": "2B04" },
        { "Typeface name": "Wingdings", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "8691", "Unicode hex": "21F3" },
        { "Typeface name": "Wingdings", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "11009", "Unicode hex": "2B01" },
        { "Typeface name": "Wingdings", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "11008", "Unicode hex": "2B00" },
        { "Typeface name": "Wingdings", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "11011", "Unicode hex": "2B03" },
        { "Typeface name": "Wingdings", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "11010", "Unicode hex": "2B02" },
        { "Typeface name": "Wingdings", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "129196", "Unicode hex": "1F8AC" },
        { "Typeface name": "Wingdings", "Dingbat dec": "250", "Dingbat hex": "FA", "Unicode dec": "129197", "Unicode hex": "1F8AD" },
        { "Typeface name": "Wingdings", "Dingbat dec": "251", "Dingbat hex": "FB", "Unicode dec": "128502", "Unicode hex": "1F5F6" },
        { "Typeface name": "Wingdings", "Dingbat dec": "252", "Dingbat hex": "FC", "Unicode dec": "10003", "Unicode hex": "2713" },
        { "Typeface name": "Wingdings", "Dingbat dec": "253", "Dingbat hex": "FD", "Unicode dec": "128503", "Unicode hex": "1F5F7" },
        { "Typeface name": "Wingdings", "Dingbat dec": "254", "Dingbat hex": "FE", "Unicode dec": "128505", "Unicode hex": "1F5F9" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "128394", "Unicode hex": "1F58A" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "128395", "Unicode hex": "1F58B" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "128396", "Unicode hex": "1F58C" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "128397", "Unicode hex": "1F58D" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "9988", "Unicode hex": "2704" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "9984", "Unicode hex": "2700" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "128382", "Unicode hex": "1F57E" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "128381", "Unicode hex": "1F57D" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "128453", "Unicode hex": "1F5C5" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "128454", "Unicode hex": "1F5C6" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "128455", "Unicode hex": "1F5C7" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "128456", "Unicode hex": "1F5C8" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "128457", "Unicode hex": "1F5C9" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "128458", "Unicode hex": "1F5CA" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "128459", "Unicode hex": "1F5CB" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "128460", "Unicode hex": "1F5CC" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "128461", "Unicode hex": "1F5CD" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "128203", "Unicode hex": "1F4CB" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "128465", "Unicode hex": "1F5D1" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "128468", "Unicode hex": "1F5D4" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "128437", "Unicode hex": "1F5B5" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "128438", "Unicode hex": "1F5B6" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "128439", "Unicode hex": "1F5B7" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "128440", "Unicode hex": "1F5B8" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "128429", "Unicode hex": "1F5AD" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "128431", "Unicode hex": "1F5AF" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "128433", "Unicode hex": "1F5B1" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "128402", "Unicode hex": "1F592" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "128403", "Unicode hex": "1F593" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "128408", "Unicode hex": "1F598" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "128409", "Unicode hex": "1F599" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "128410", "Unicode hex": "1F59A" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "128411", "Unicode hex": "1F59B" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "128072", "Unicode hex": "1F448" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "128073", "Unicode hex": "1F449" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "128412", "Unicode hex": "1F59C" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "128413", "Unicode hex": "1F59D" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "128414", "Unicode hex": "1F59E" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "128415", "Unicode hex": "1F59F" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "128416", "Unicode hex": "1F5A0" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "128417", "Unicode hex": "1F5A1" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "128070", "Unicode hex": "1F446" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "128071", "Unicode hex": "1F447" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "128418", "Unicode hex": "1F5A2" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "128419", "Unicode hex": "1F5A3" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "128401", "Unicode hex": "1F591" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "128500", "Unicode hex": "1F5F4" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "128504", "Unicode hex": "1F5F8" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "128501", "Unicode hex": "1F5F5" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "9745", "Unicode hex": "2611" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "11197", "Unicode hex": "2BBD" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "9746", "Unicode hex": "2612" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "11198", "Unicode hex": "2BBE" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "11199", "Unicode hex": "2BBF" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "128711", "Unicode hex": "1F6C7" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "10680", "Unicode hex": "29B8" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "128625", "Unicode hex": "1F671" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "128628", "Unicode hex": "1F674" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "128626", "Unicode hex": "1F672" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "128627", "Unicode hex": "1F673" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "8253", "Unicode hex": "203D" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "128633", "Unicode hex": "1F679" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "128634", "Unicode hex": "1F67A" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "128635", "Unicode hex": "1F67B" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "128614", "Unicode hex": "1F666" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "128612", "Unicode hex": "1F664" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "128613", "Unicode hex": "1F665" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "128615", "Unicode hex": "1F667" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "128602", "Unicode hex": "1F65A" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "128600", "Unicode hex": "1F658" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "128601", "Unicode hex": "1F659" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "128603", "Unicode hex": "1F65B" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "9450", "Unicode hex": "24EA" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "9312", "Unicode hex": "2460" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "9313", "Unicode hex": "2461" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "9314", "Unicode hex": "2462" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "9315", "Unicode hex": "2463" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "9316", "Unicode hex": "2464" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "9317", "Unicode hex": "2465" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "9318", "Unicode hex": "2466" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "9319", "Unicode hex": "2467" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "9320", "Unicode hex": "2468" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "9321", "Unicode hex": "2469" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "9471", "Unicode hex": "24FF" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "10102", "Unicode hex": "2776" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "10103", "Unicode hex": "2777" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "10104", "Unicode hex": "2778" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "10105", "Unicode hex": "2779" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "10106", "Unicode hex": "277A" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "10107", "Unicode hex": "277B" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "10108", "Unicode hex": "277C" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "10109", "Unicode hex": "277D" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "10110", "Unicode hex": "277E" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "10111", "Unicode hex": "277F" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "9737", "Unicode hex": "2609" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "127765", "Unicode hex": "1F315" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "9789", "Unicode hex": "263D" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "9790", "Unicode hex": "263E" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "11839", "Unicode hex": "2E3F" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "10013", "Unicode hex": "271D" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "128327", "Unicode hex": "1F547" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "128348", "Unicode hex": "1F55C" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "128349", "Unicode hex": "1F55D" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "128350", "Unicode hex": "1F55E" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "128351", "Unicode hex": "1F55F" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "128352", "Unicode hex": "1F560" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "128353", "Unicode hex": "1F561" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "128354", "Unicode hex": "1F562" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "128355", "Unicode hex": "1F563" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "128356", "Unicode hex": "1F564" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "128357", "Unicode hex": "1F565" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "128358", "Unicode hex": "1F566" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "128359", "Unicode hex": "1F567" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "128616", "Unicode hex": "1F668" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "128617", "Unicode hex": "1F669" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "8901", "Unicode hex": "22C5" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "128900", "Unicode hex": "1F784" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "10625", "Unicode hex": "2981" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "9679", "Unicode hex": "25CF" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "9675", "Unicode hex": "25CB" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "128901", "Unicode hex": "1F785" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "128903", "Unicode hex": "1F787" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "128905", "Unicode hex": "1F789" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "8857", "Unicode hex": "2299" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "10687", "Unicode hex": "29BF" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "128908", "Unicode hex": "1F78C" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "128909", "Unicode hex": "1F78D" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "9726", "Unicode hex": "25FE" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "9632", "Unicode hex": "25A0" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "9633", "Unicode hex": "25A1" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "128913", "Unicode hex": "1F791" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "128914", "Unicode hex": "1F792" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "128915", "Unicode hex": "1F793" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "128916", "Unicode hex": "1F794" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "9635", "Unicode hex": "25A3" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "128917", "Unicode hex": "1F795" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "128918", "Unicode hex": "1F796" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "128919", "Unicode hex": "1F797" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "128920", "Unicode hex": "1F798" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "11049", "Unicode hex": "2B29" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "11045", "Unicode hex": "2B25" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "9671", "Unicode hex": "25C7" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "128922", "Unicode hex": "1F79A" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "9672", "Unicode hex": "25C8" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "128923", "Unicode hex": "1F79B" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "128924", "Unicode hex": "1F79C" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "128925", "Unicode hex": "1F79D" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "128926", "Unicode hex": "1F79E" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "11050", "Unicode hex": "2B2A" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "11047", "Unicode hex": "2B27" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "9674", "Unicode hex": "25CA" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "128928", "Unicode hex": "1F7A0" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "9686", "Unicode hex": "25D6" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "9687", "Unicode hex": "25D7" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "11210", "Unicode hex": "2BCA" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "11211", "Unicode hex": "2BCB" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "11200", "Unicode hex": "2BC0" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "11201", "Unicode hex": "2BC1" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "11039", "Unicode hex": "2B1F" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "11202", "Unicode hex": "2BC2" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "11043", "Unicode hex": "2B23" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "11042", "Unicode hex": "2B22" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "11203", "Unicode hex": "2BC3" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "11204", "Unicode hex": "2BC4" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "128929", "Unicode hex": "1F7A1" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "128930", "Unicode hex": "1F7A2" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "128931", "Unicode hex": "1F7A3" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "128932", "Unicode hex": "1F7A4" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "128933", "Unicode hex": "1F7A5" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "128934", "Unicode hex": "1F7A6" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "128935", "Unicode hex": "1F7A7" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "128936", "Unicode hex": "1F7A8" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "128937", "Unicode hex": "1F7A9" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "128938", "Unicode hex": "1F7AA" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "128939", "Unicode hex": "1F7AB" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "128940", "Unicode hex": "1F7AC" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "128941", "Unicode hex": "1F7AD" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "128942", "Unicode hex": "1F7AE" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "128943", "Unicode hex": "1F7AF" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "128944", "Unicode hex": "1F7B0" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "128945", "Unicode hex": "1F7B1" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "128946", "Unicode hex": "1F7B2" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "128947", "Unicode hex": "1F7B3" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "128948", "Unicode hex": "1F7B4" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "128949", "Unicode hex": "1F7B5" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "128950", "Unicode hex": "1F7B6" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "128951", "Unicode hex": "1F7B7" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "128952", "Unicode hex": "1F7B8" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "128953", "Unicode hex": "1F7B9" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "128954", "Unicode hex": "1F7BA" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "128955", "Unicode hex": "1F7BB" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "128956", "Unicode hex": "1F7BC" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "128957", "Unicode hex": "1F7BD" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "128958", "Unicode hex": "1F7BE" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "128959", "Unicode hex": "1F7BF" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "128960", "Unicode hex": "1F7C0" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "128962", "Unicode hex": "1F7C2" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "128964", "Unicode hex": "1F7C4" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "128966", "Unicode hex": "1F7C6" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "128969", "Unicode hex": "1F7C9" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "128970", "Unicode hex": "1F7CA" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "10038", "Unicode hex": "2736" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "128972", "Unicode hex": "1F7CC" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "128974", "Unicode hex": "1F7CE" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "128976", "Unicode hex": "1F7D0" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "128978", "Unicode hex": "1F7D2" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "10041", "Unicode hex": "2739" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "128963", "Unicode hex": "1F7C3" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "128967", "Unicode hex": "1F7C7" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "10031", "Unicode hex": "272F" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "128973", "Unicode hex": "1F7CD" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "128980", "Unicode hex": "1F7D4" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "11212", "Unicode hex": "2BCC" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "11213", "Unicode hex": "2BCD" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "8251", "Unicode hex": "203B" },
        { "Typeface name": "Wingdings 2", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "8258", "Unicode hex": "2042" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "11104", "Unicode hex": "2B60" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "11106", "Unicode hex": "2B62" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "11105", "Unicode hex": "2B61" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "11107", "Unicode hex": "2B63" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "11110", "Unicode hex": "2B66" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "11111", "Unicode hex": "2B67" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "11113", "Unicode hex": "2B69" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "11112", "Unicode hex": "2B68" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "11120", "Unicode hex": "2B70" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "11122", "Unicode hex": "2B72" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "11121", "Unicode hex": "2B71" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "11123", "Unicode hex": "2B73" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "11126", "Unicode hex": "2B76" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "11128", "Unicode hex": "2B78" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "11131", "Unicode hex": "2B7B" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "11133", "Unicode hex": "2B7D" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "11108", "Unicode hex": "2B64" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "11109", "Unicode hex": "2B65" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "11114", "Unicode hex": "2B6A" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "11116", "Unicode hex": "2B6C" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "11115", "Unicode hex": "2B6B" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "11117", "Unicode hex": "2B6D" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "11085", "Unicode hex": "2B4D" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "11168", "Unicode hex": "2BA0" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "11169", "Unicode hex": "2BA1" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "11170", "Unicode hex": "2BA2" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "11171", "Unicode hex": "2BA3" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "11172", "Unicode hex": "2BA4" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "11173", "Unicode hex": "2BA5" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "11174", "Unicode hex": "2BA6" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "11175", "Unicode hex": "2BA7" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "11152", "Unicode hex": "2B90" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "11153", "Unicode hex": "2B91" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "11154", "Unicode hex": "2B92" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "11155", "Unicode hex": "2B93" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "11136", "Unicode hex": "2B80" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "11139", "Unicode hex": "2B83" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "11134", "Unicode hex": "2B7E" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "11135", "Unicode hex": "2B7F" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "11140", "Unicode hex": "2B84" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "11142", "Unicode hex": "2B86" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "11141", "Unicode hex": "2B85" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "11143", "Unicode hex": "2B87" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "11151", "Unicode hex": "2B8F" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "11149", "Unicode hex": "2B8D" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "11150", "Unicode hex": "2B8E" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "11148", "Unicode hex": "2B8C" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "11118", "Unicode hex": "2B6E" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "11119", "Unicode hex": "2B6F" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "9099", "Unicode hex": "238B" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "8996", "Unicode hex": "2324" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "8963", "Unicode hex": "2303" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "8997", "Unicode hex": "2325" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "9251", "Unicode hex": "2423" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "9085", "Unicode hex": "237D" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "8682", "Unicode hex": "21EA" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "11192", "Unicode hex": "2BB8" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "129184", "Unicode hex": "1F8A0" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "129185", "Unicode hex": "1F8A1" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "129186", "Unicode hex": "1F8A2" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "129187", "Unicode hex": "1F8A3" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "129188", "Unicode hex": "1F8A4" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "129189", "Unicode hex": "1F8A5" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "129190", "Unicode hex": "1F8A6" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "129191", "Unicode hex": "1F8A7" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "129192", "Unicode hex": "1F8A8" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "129193", "Unicode hex": "1F8A9" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "129194", "Unicode hex": "1F8AA" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "129195", "Unicode hex": "1F8AB" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "129104", "Unicode hex": "1F850" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "129106", "Unicode hex": "1F852" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "129105", "Unicode hex": "1F851" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "129107", "Unicode hex": "1F853" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "129108", "Unicode hex": "1F854" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "129109", "Unicode hex": "1F855" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "129111", "Unicode hex": "1F857" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "129110", "Unicode hex": "1F856" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "129112", "Unicode hex": "1F858" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "129113", "Unicode hex": "1F859" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "9650", "Unicode hex": "25B2" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "9660", "Unicode hex": "25BC" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "9651", "Unicode hex": "25B3" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "9661", "Unicode hex": "25BD" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "9664", "Unicode hex": "25C0" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "9654", "Unicode hex": "25B6" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "9665", "Unicode hex": "25C1" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "9655", "Unicode hex": "25B7" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "9699", "Unicode hex": "25E3" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "9698", "Unicode hex": "25E2" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "9700", "Unicode hex": "25E4" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "9701", "Unicode hex": "25E5" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "128896", "Unicode hex": "1F780" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "128898", "Unicode hex": "1F782" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "128897", "Unicode hex": "1F781" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "128899", "Unicode hex": "1F783" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "11205", "Unicode hex": "2BC5" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "11206", "Unicode hex": "2BC6" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "11207", "Unicode hex": "2BC7" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "11208", "Unicode hex": "2BC8" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "11164", "Unicode hex": "2B9C" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "11166", "Unicode hex": "2B9E" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "11165", "Unicode hex": "2B9D" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "11167", "Unicode hex": "2B9F" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "129040", "Unicode hex": "1F810" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "129042", "Unicode hex": "1F812" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "129041", "Unicode hex": "1F811" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "129043", "Unicode hex": "1F813" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "129044", "Unicode hex": "1F814" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "129046", "Unicode hex": "1F816" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "129045", "Unicode hex": "1F815" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "129047", "Unicode hex": "1F817" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "129048", "Unicode hex": "1F818" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "129050", "Unicode hex": "1F81A" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "129049", "Unicode hex": "1F819" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "129051", "Unicode hex": "1F81B" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "129052", "Unicode hex": "1F81C" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "129054", "Unicode hex": "1F81E" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "129053", "Unicode hex": "1F81D" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "129055", "Unicode hex": "1F81F" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "129024", "Unicode hex": "1F800" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "129026", "Unicode hex": "1F802" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "129025", "Unicode hex": "1F801" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "129027", "Unicode hex": "1F803" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "129028", "Unicode hex": "1F804" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "129030", "Unicode hex": "1F806" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "129029", "Unicode hex": "1F805" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "129031", "Unicode hex": "1F807" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "129032", "Unicode hex": "1F808" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "129034", "Unicode hex": "1F80A" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "129033", "Unicode hex": "1F809" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "129035", "Unicode hex": "1F80B" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "129056", "Unicode hex": "1F820" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "129058", "Unicode hex": "1F822" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "129060", "Unicode hex": "1F824" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "129062", "Unicode hex": "1F826" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "129064", "Unicode hex": "1F828" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "129066", "Unicode hex": "1F82A" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "129068", "Unicode hex": "1F82C" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "129180", "Unicode hex": "1F89C" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "129181", "Unicode hex": "1F89D" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "129182", "Unicode hex": "1F89E" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "129183", "Unicode hex": "1F89F" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "129070", "Unicode hex": "1F82E" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "129072", "Unicode hex": "1F830" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "129074", "Unicode hex": "1F832" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "129076", "Unicode hex": "1F834" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "129078", "Unicode hex": "1F836" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "129080", "Unicode hex": "1F838" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "129082", "Unicode hex": "1F83A" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "129081", "Unicode hex": "1F839" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "129083", "Unicode hex": "1F83B" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "129176", "Unicode hex": "1F898" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "129178", "Unicode hex": "1F89A" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "129177", "Unicode hex": "1F899" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "129179", "Unicode hex": "1F89B" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "129084", "Unicode hex": "1F83C" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "129086", "Unicode hex": "1F83E" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "129085", "Unicode hex": "1F83D" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "129087", "Unicode hex": "1F83F" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "129088", "Unicode hex": "1F840" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "129090", "Unicode hex": "1F842" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "129089", "Unicode hex": "1F841" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "129091", "Unicode hex": "1F843" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "129092", "Unicode hex": "1F844" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "129094", "Unicode hex": "1F846" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "129093", "Unicode hex": "1F845" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "129095", "Unicode hex": "1F847" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "11176", "Unicode hex": "2BA8" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "11177", "Unicode hex": "2BA9" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "11178", "Unicode hex": "2BAA" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "11179", "Unicode hex": "2BAB" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "11180", "Unicode hex": "2BAC" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "11181", "Unicode hex": "2BAD" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "11182", "Unicode hex": "2BAE" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "11183", "Unicode hex": "2BAF" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "129120", "Unicode hex": "1F860" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "129122", "Unicode hex": "1F862" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "129121", "Unicode hex": "1F861" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "129123", "Unicode hex": "1F863" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "129124", "Unicode hex": "1F864" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "129125", "Unicode hex": "1F865" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "129127", "Unicode hex": "1F867" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "129126", "Unicode hex": "1F866" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "129136", "Unicode hex": "1F870" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "129138", "Unicode hex": "1F872" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "129137", "Unicode hex": "1F871" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "129139", "Unicode hex": "1F873" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "129140", "Unicode hex": "1F874" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "129141", "Unicode hex": "1F875" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "129143", "Unicode hex": "1F877" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "129142", "Unicode hex": "1F876" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "129152", "Unicode hex": "1F880" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "129154", "Unicode hex": "1F882" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "129153", "Unicode hex": "1F881" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "129155", "Unicode hex": "1F883" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "129156", "Unicode hex": "1F884" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "129157", "Unicode hex": "1F885" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "129159", "Unicode hex": "1F887" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "129158", "Unicode hex": "1F886" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "129168", "Unicode hex": "1F890" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "129170", "Unicode hex": "1F892" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "129169", "Unicode hex": "1F891" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "129171", "Unicode hex": "1F893" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "129172", "Unicode hex": "1F894" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "129174", "Unicode hex": "1F896" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "129173", "Unicode hex": "1F895" },
        { "Typeface name": "Wingdings 3", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "129175", "Unicode hex": "1F897" }
      ];
      re.default = ae;
    }, {}], 81: [function(le, ce, re) {
      var ae = this && this.__importDefault || function(p) {
        return p && p.__esModule ? p : { default: p };
      };
      Object.defineProperty(re, "__esModule", { value: !0 }), re.hex = re.dec = re.codePoint = void 0;
      for (var J = ae(le("./dingbats")), o = {}, F = String.fromCodePoint ? String.fromCodePoint : m, t = 0, a = J.default; t < a.length; t++) {
        var v = a[t], h = parseInt(v["Unicode dec"], 10), e = {
          codePoint: h,
          string: F(h)
        };
        o[v["Typeface name"].toUpperCase() + "_" + v["Dingbat dec"]] = e;
      }
      function y(p, g) {
        return o[p.toUpperCase() + "_" + g];
      }
      re.codePoint = y;
      function c(p, g) {
        return y(p, parseInt(g, 10));
      }
      re.dec = c;
      function d(p, g) {
        return y(p, parseInt(g, 16));
      }
      re.hex = d;
      function m(p) {
        if (p <= 65535)
          return String.fromCharCode(p);
        var g = Math.floor((p - 65536) / 1024) + 55296, n = (p - 65536) % 1024 + 56320;
        return String.fromCharCode(g, n);
      }
    }, { "./dingbats": 80 }], 82: [function(le, ce, re) {
      function ae() {
        this._events = this._events || {}, this._maxListeners = this._maxListeners || void 0;
      }
      ce.exports = ae, ae.EventEmitter = ae, ae.prototype._events = void 0, ae.prototype._maxListeners = void 0, ae.defaultMaxListeners = 10, ae.prototype.setMaxListeners = function(a) {
        if (!o(a) || a < 0 || isNaN(a))
          throw TypeError("n must be a positive number");
        return this._maxListeners = a, this;
      }, ae.prototype.emit = function(a) {
        var v, h, e, y, c, d;
        if (this._events || (this._events = {}), a === "error" && (!this._events.error || F(this._events.error) && !this._events.error.length)) {
          if (v = arguments[1], v instanceof Error)
            throw v;
          var m = new Error('Uncaught, unspecified "error" event. (' + v + ")");
          throw m.context = v, m;
        }
        if (h = this._events[a], t(h))
          return !1;
        if (J(h))
          switch (arguments.length) {
            case 1:
              h.call(this);
              break;
            case 2:
              h.call(this, arguments[1]);
              break;
            case 3:
              h.call(this, arguments[1], arguments[2]);
              break;
            default:
              y = Array.prototype.slice.call(arguments, 1), h.apply(this, y);
          }
        else if (F(h))
          for (y = Array.prototype.slice.call(arguments, 1), d = h.slice(), e = d.length, c = 0; c < e; c++)
            d[c].apply(this, y);
        return !0;
      }, ae.prototype.addListener = function(a, v) {
        var h;
        if (!J(v))
          throw TypeError("listener must be a function");
        return this._events || (this._events = {}), this._events.newListener && this.emit(
          "newListener",
          a,
          J(v.listener) ? v.listener : v
        ), this._events[a] ? F(this._events[a]) ? this._events[a].push(v) : this._events[a] = [this._events[a], v] : this._events[a] = v, F(this._events[a]) && !this._events[a].warned && (t(this._maxListeners) ? h = ae.defaultMaxListeners : h = this._maxListeners, h && h > 0 && this._events[a].length > h && (this._events[a].warned = !0, console.error(
          "(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",
          this._events[a].length
        ), typeof console.trace == "function" && console.trace())), this;
      }, ae.prototype.on = ae.prototype.addListener, ae.prototype.once = function(a, v) {
        if (!J(v))
          throw TypeError("listener must be a function");
        var h = !1;
        function e() {
          this.removeListener(a, e), h || (h = !0, v.apply(this, arguments));
        }
        return e.listener = v, this.on(a, e), this;
      }, ae.prototype.removeListener = function(a, v) {
        var h, e, y, c;
        if (!J(v))
          throw TypeError("listener must be a function");
        if (!this._events || !this._events[a])
          return this;
        if (h = this._events[a], y = h.length, e = -1, h === v || J(h.listener) && h.listener === v)
          delete this._events[a], this._events.removeListener && this.emit("removeListener", a, v);
        else if (F(h)) {
          for (c = y; c-- > 0; )
            if (h[c] === v || h[c].listener && h[c].listener === v) {
              e = c;
              break;
            }
          if (e < 0)
            return this;
          h.length === 1 ? (h.length = 0, delete this._events[a]) : h.splice(e, 1), this._events.removeListener && this.emit("removeListener", a, v);
        }
        return this;
      }, ae.prototype.removeAllListeners = function(a) {
        var v, h;
        if (!this._events)
          return this;
        if (!this._events.removeListener)
          return arguments.length === 0 ? this._events = {} : this._events[a] && delete this._events[a], this;
        if (arguments.length === 0) {
          for (v in this._events)
            v !== "removeListener" && this.removeAllListeners(v);
          return this.removeAllListeners("removeListener"), this._events = {}, this;
        }
        if (h = this._events[a], J(h))
          this.removeListener(a, h);
        else if (h)
          for (; h.length; )
            this.removeListener(a, h[h.length - 1]);
        return delete this._events[a], this;
      }, ae.prototype.listeners = function(a) {
        var v;
        return !this._events || !this._events[a] ? v = [] : J(this._events[a]) ? v = [this._events[a]] : v = this._events[a].slice(), v;
      }, ae.prototype.listenerCount = function(a) {
        if (this._events) {
          var v = this._events[a];
          if (J(v))
            return 1;
          if (v)
            return v.length;
        }
        return 0;
      }, ae.listenerCount = function(a, v) {
        return a.listenerCount(v);
      };
      function J(a) {
        return typeof a == "function";
      }
      function o(a) {
        return typeof a == "number";
      }
      function F(a) {
        return typeof a == "object" && a !== null;
      }
      function t(a) {
        return a === void 0;
      }
    }, {}], 83: [function(le, ce, re) {
      re.read = function(ae, J, o, F, t) {
        var a, v, h = t * 8 - F - 1, e = (1 << h) - 1, y = e >> 1, c = -7, d = o ? t - 1 : 0, m = o ? -1 : 1, p = ae[J + d];
        for (d += m, a = p & (1 << -c) - 1, p >>= -c, c += h; c > 0; a = a * 256 + ae[J + d], d += m, c -= 8)
          ;
        for (v = a & (1 << -c) - 1, a >>= -c, c += F; c > 0; v = v * 256 + ae[J + d], d += m, c -= 8)
          ;
        if (a === 0)
          a = 1 - y;
        else {
          if (a === e)
            return v ? NaN : (p ? -1 : 1) * (1 / 0);
          v = v + Math.pow(2, F), a = a - y;
        }
        return (p ? -1 : 1) * v * Math.pow(2, a - F);
      }, re.write = function(ae, J, o, F, t, a) {
        var v, h, e, y = a * 8 - t - 1, c = (1 << y) - 1, d = c >> 1, m = t === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p = F ? 0 : a - 1, g = F ? 1 : -1, n = J < 0 || J === 0 && 1 / J < 0 ? 1 : 0;
        for (J = Math.abs(J), isNaN(J) || J === 1 / 0 ? (h = isNaN(J) ? 1 : 0, v = c) : (v = Math.floor(Math.log(J) / Math.LN2), J * (e = Math.pow(2, -v)) < 1 && (v--, e *= 2), v + d >= 1 ? J += m / e : J += m * Math.pow(2, 1 - d), J * e >= 2 && (v++, e /= 2), v + d >= c ? (h = 0, v = c) : v + d >= 1 ? (h = (J * e - 1) * Math.pow(2, t), v = v + d) : (h = J * Math.pow(2, d - 1) * Math.pow(2, t), v = 0)); t >= 8; ae[o + p] = h & 255, p += g, h /= 256, t -= 8)
          ;
        for (v = v << t | h, y += t; y > 0; ae[o + p] = v & 255, p += g, v /= 256, y -= 8)
          ;
        ae[o + p - g] |= n * 128;
      };
    }, {}], 84: [function(le, ce, re) {
      typeof Object.create == "function" ? ce.exports = function(J, o) {
        J.super_ = o, J.prototype = Object.create(o.prototype, {
          constructor: {
            value: J,
            enumerable: !1,
            writable: !0,
            configurable: !0
          }
        });
      } : ce.exports = function(J, o) {
        J.super_ = o;
        var F = function() {
        };
        F.prototype = o.prototype, J.prototype = new F(), J.prototype.constructor = J;
      };
    }, {}], 85: [function(le, ce, re) {
      /*!
       * Determine if an object is a Buffer
       *
       * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
       * @license  MIT
       */
      ce.exports = function(o) {
        return o != null && (ae(o) || J(o) || !!o._isBuffer);
      };
      function ae(o) {
        return !!o.constructor && typeof o.constructor.isBuffer == "function" && o.constructor.isBuffer(o);
      }
      function J(o) {
        return typeof o.readFloatLE == "function" && typeof o.slice == "function" && ae(o.slice(0, 0));
      }
    }, {}], 86: [function(le, ce, re) {
      var ae = {}.toString;
      ce.exports = Array.isArray || function(J) {
        return ae.call(J) == "[object Array]";
      };
    }, {}], 87: [function(le, ce, re) {
      (function(ae, J) {
        /*!
        
        	JSZip v3.7.1 - A JavaScript class for generating and reading zip files
        	<http://stuartk.com/jszip>
        
        	(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
        	Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.
        
        	JSZip uses the library pako released under the MIT license :
        	https://github.com/nodeca/pako/blob/master/LICENSE
        	*/
        (function(o) {
          typeof re == "object" && typeof ce < "u" ? ce.exports = o() : (typeof window < "u" ? window : typeof ae < "u" ? ae : typeof self < "u" ? self : this).JSZip = o();
        })(function() {
          return function o(F, t, a) {
            function v(y, c) {
              if (!t[y]) {
                if (!F[y]) {
                  var d = typeof le == "function" && le;
                  if (!c && d)
                    return d(y, !0);
                  if (h)
                    return h(y, !0);
                  var m = new Error("Cannot find module '" + y + "'");
                  throw m.code = "MODULE_NOT_FOUND", m;
                }
                var p = t[y] = { exports: {} };
                F[y][0].call(p.exports, function(g) {
                  var n = F[y][1][g];
                  return v(n || g);
                }, p, p.exports, o, F, t, a);
              }
              return t[y].exports;
            }
            for (var h = typeof le == "function" && le, e = 0; e < a.length; e++)
              v(a[e]);
            return v;
          }({ 1: [function(o, F, t) {
            var a = o("./utils"), v = o("./support"), h = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            t.encode = function(e) {
              for (var y, c, d, m, p, g, n, i = [], l = 0, u = e.length, w = u, O = a.getTypeOf(e) !== "string"; l < e.length; )
                w = u - l, d = O ? (y = e[l++], c = l < u ? e[l++] : 0, l < u ? e[l++] : 0) : (y = e.charCodeAt(l++), c = l < u ? e.charCodeAt(l++) : 0, l < u ? e.charCodeAt(l++) : 0), m = y >> 2, p = (3 & y) << 4 | c >> 4, g = 1 < w ? (15 & c) << 2 | d >> 6 : 64, n = 2 < w ? 63 & d : 64, i.push(h.charAt(m) + h.charAt(p) + h.charAt(g) + h.charAt(n));
              return i.join("");
            }, t.decode = function(e) {
              var y, c, d, m, p, g, n = 0, i = 0, l = "data:";
              if (e.substr(0, l.length) === l)
                throw new Error("Invalid base64 input, it looks like a data url.");
              var u, w = 3 * (e = e.replace(/[^A-Za-z0-9\+\/\=]/g, "")).length / 4;
              if (e.charAt(e.length - 1) === h.charAt(64) && w--, e.charAt(e.length - 2) === h.charAt(64) && w--, w % 1 != 0)
                throw new Error("Invalid base64 input, bad content length.");
              for (u = v.uint8array ? new Uint8Array(0 | w) : new Array(0 | w); n < e.length; )
                y = h.indexOf(e.charAt(n++)) << 2 | (m = h.indexOf(e.charAt(n++))) >> 4, c = (15 & m) << 4 | (p = h.indexOf(e.charAt(n++))) >> 2, d = (3 & p) << 6 | (g = h.indexOf(e.charAt(n++))), u[i++] = y, p !== 64 && (u[i++] = c), g !== 64 && (u[i++] = d);
              return u;
            };
          }, { "./support": 30, "./utils": 32 }], 2: [function(o, F, t) {
            var a = o("./external"), v = o("./stream/DataWorker"), h = o("./stream/Crc32Probe"), e = o("./stream/DataLengthProbe");
            function y(c, d, m, p, g) {
              this.compressedSize = c, this.uncompressedSize = d, this.crc32 = m, this.compression = p, this.compressedContent = g;
            }
            y.prototype = { getContentWorker: function() {
              var c = new v(a.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new e("data_length")), d = this;
              return c.on("end", function() {
                if (this.streamInfo.data_length !== d.uncompressedSize)
                  throw new Error("Bug : uncompressed data size mismatch");
              }), c;
            }, getCompressedWorker: function() {
              return new v(a.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
            } }, y.createWorkerFrom = function(c, d, m) {
              return c.pipe(new h()).pipe(new e("uncompressedSize")).pipe(d.compressWorker(m)).pipe(new e("compressedSize")).withStreamInfo("compression", d);
            }, F.exports = y;
          }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(o, F, t) {
            var a = o("./stream/GenericWorker");
            t.STORE = { magic: "\0\0", compressWorker: function(v) {
              return new a("STORE compression");
            }, uncompressWorker: function() {
              return new a("STORE decompression");
            } }, t.DEFLATE = o("./flate");
          }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(o, F, t) {
            var a = o("./utils"), v = function() {
              for (var h, e = [], y = 0; y < 256; y++) {
                h = y;
                for (var c = 0; c < 8; c++)
                  h = 1 & h ? 3988292384 ^ h >>> 1 : h >>> 1;
                e[y] = h;
              }
              return e;
            }();
            F.exports = function(h, e) {
              return h !== void 0 && h.length ? a.getTypeOf(h) !== "string" ? function(y, c, d, m) {
                var p = v, g = m + d;
                y ^= -1;
                for (var n = m; n < g; n++)
                  y = y >>> 8 ^ p[255 & (y ^ c[n])];
                return -1 ^ y;
              }(0 | e, h, h.length, 0) : function(y, c, d, m) {
                var p = v, g = m + d;
                y ^= -1;
                for (var n = m; n < g; n++)
                  y = y >>> 8 ^ p[255 & (y ^ c.charCodeAt(n))];
                return -1 ^ y;
              }(0 | e, h, h.length, 0) : 0;
            };
          }, { "./utils": 32 }], 5: [function(o, F, t) {
            t.base64 = !1, t.binary = !1, t.dir = !1, t.createFolders = !0, t.date = null, t.compression = null, t.compressionOptions = null, t.comment = null, t.unixPermissions = null, t.dosPermissions = null;
          }, {}], 6: [function(o, F, t) {
            var a = null;
            a = typeof Promise < "u" ? Promise : o("lie"), F.exports = { Promise: a };
          }, { lie: 37 }], 7: [function(o, F, t) {
            var a = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", v = o("pako"), h = o("./utils"), e = o("./stream/GenericWorker"), y = a ? "uint8array" : "array";
            function c(d, m) {
              e.call(this, "FlateWorker/" + d), this._pako = null, this._pakoAction = d, this._pakoOptions = m, this.meta = {};
            }
            t.magic = "\b\0", h.inherits(c, e), c.prototype.processChunk = function(d) {
              this.meta = d.meta, this._pako === null && this._createPako(), this._pako.push(h.transformTo(y, d.data), !1);
            }, c.prototype.flush = function() {
              e.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
            }, c.prototype.cleanUp = function() {
              e.prototype.cleanUp.call(this), this._pako = null;
            }, c.prototype._createPako = function() {
              this._pako = new v[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
              var d = this;
              this._pako.onData = function(m) {
                d.push({ data: m, meta: d.meta });
              };
            }, t.compressWorker = function(d) {
              return new c("Deflate", d);
            }, t.uncompressWorker = function() {
              return new c("Inflate", {});
            };
          }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(o, F, t) {
            function a(p, g) {
              var n, i = "";
              for (n = 0; n < g; n++)
                i += String.fromCharCode(255 & p), p >>>= 8;
              return i;
            }
            function v(p, g, n, i, l, u) {
              var w, O, b = p.file, A = p.compression, Y = u !== y.utf8encode, j = h.transformTo("string", u(b.name)), X = h.transformTo("string", y.utf8encode(b.name)), B = b.comment, U = h.transformTo("string", u(B)), k = h.transformTo("string", y.utf8encode(B)), x = X.length !== b.name.length, f = k.length !== B.length, D = "", _ = "", S = "", C = b.dir, T = b.date, P = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
              g && !n || (P.crc32 = p.crc32, P.compressedSize = p.compressedSize, P.uncompressedSize = p.uncompressedSize);
              var M = 0;
              g && (M |= 8), Y || !x && !f || (M |= 2048);
              var G = 0, Z = 0;
              C && (G |= 16), l === "UNIX" ? (Z = 798, G |= function(z, V) {
                var L = z;
                return z || (L = V ? 16893 : 33204), (65535 & L) << 16;
              }(b.unixPermissions, C)) : (Z = 20, G |= function(z) {
                return 63 & (z || 0);
              }(b.dosPermissions)), w = T.getUTCHours(), w <<= 6, w |= T.getUTCMinutes(), w <<= 5, w |= T.getUTCSeconds() / 2, O = T.getUTCFullYear() - 1980, O <<= 4, O |= T.getUTCMonth() + 1, O <<= 5, O |= T.getUTCDate(), x && (_ = a(1, 1) + a(c(j), 4) + X, D += "up" + a(_.length, 2) + _), f && (S = a(1, 1) + a(c(U), 4) + k, D += "uc" + a(S.length, 2) + S);
              var $ = "";
              return $ += `
\0`, $ += a(M, 2), $ += A.magic, $ += a(w, 2), $ += a(O, 2), $ += a(P.crc32, 4), $ += a(P.compressedSize, 4), $ += a(P.uncompressedSize, 4), $ += a(j.length, 2), $ += a(D.length, 2), { fileRecord: d.LOCAL_FILE_HEADER + $ + j + D, dirRecord: d.CENTRAL_FILE_HEADER + a(Z, 2) + $ + a(U.length, 2) + "\0\0\0\0" + a(G, 4) + a(i, 4) + j + D + U };
            }
            var h = o("../utils"), e = o("../stream/GenericWorker"), y = o("../utf8"), c = o("../crc32"), d = o("../signature");
            function m(p, g, n, i) {
              e.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = g, this.zipPlatform = n, this.encodeFileName = i, this.streamFiles = p, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
            }
            h.inherits(m, e), m.prototype.push = function(p) {
              var g = p.meta.percent || 0, n = this.entriesCount, i = this._sources.length;
              this.accumulate ? this.contentBuffer.push(p) : (this.bytesWritten += p.data.length, e.prototype.push.call(this, { data: p.data, meta: { currentFile: this.currentFile, percent: n ? (g + 100 * (n - i - 1)) / n : 100 } }));
            }, m.prototype.openedSource = function(p) {
              this.currentSourceOffset = this.bytesWritten, this.currentFile = p.file.name;
              var g = this.streamFiles && !p.file.dir;
              if (g) {
                var n = v(p, g, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
                this.push({ data: n.fileRecord, meta: { percent: 0 } });
              } else
                this.accumulate = !0;
            }, m.prototype.closedSource = function(p) {
              this.accumulate = !1;
              var g = this.streamFiles && !p.file.dir, n = v(p, g, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
              if (this.dirRecords.push(n.dirRecord), g)
                this.push({ data: function(i) {
                  return d.DATA_DESCRIPTOR + a(i.crc32, 4) + a(i.compressedSize, 4) + a(i.uncompressedSize, 4);
                }(p), meta: { percent: 100 } });
              else
                for (this.push({ data: n.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
                  this.push(this.contentBuffer.shift());
              this.currentFile = null;
            }, m.prototype.flush = function() {
              for (var p = this.bytesWritten, g = 0; g < this.dirRecords.length; g++)
                this.push({ data: this.dirRecords[g], meta: { percent: 100 } });
              var n = this.bytesWritten - p, i = function(l, u, w, O, b) {
                var A = h.transformTo("string", b(O));
                return d.CENTRAL_DIRECTORY_END + "\0\0\0\0" + a(l, 2) + a(l, 2) + a(u, 4) + a(w, 4) + a(A.length, 2) + A;
              }(this.dirRecords.length, n, p, this.zipComment, this.encodeFileName);
              this.push({ data: i, meta: { percent: 100 } });
            }, m.prototype.prepareNextSource = function() {
              this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
            }, m.prototype.registerPrevious = function(p) {
              this._sources.push(p);
              var g = this;
              return p.on("data", function(n) {
                g.processChunk(n);
              }), p.on("end", function() {
                g.closedSource(g.previous.streamInfo), g._sources.length ? g.prepareNextSource() : g.end();
              }), p.on("error", function(n) {
                g.error(n);
              }), this;
            }, m.prototype.resume = function() {
              return !!e.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
            }, m.prototype.error = function(p) {
              var g = this._sources;
              if (!e.prototype.error.call(this, p))
                return !1;
              for (var n = 0; n < g.length; n++)
                try {
                  g[n].error(p);
                } catch {
                }
              return !0;
            }, m.prototype.lock = function() {
              e.prototype.lock.call(this);
              for (var p = this._sources, g = 0; g < p.length; g++)
                p[g].lock();
            }, F.exports = m;
          }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(o, F, t) {
            var a = o("../compressions"), v = o("./ZipFileWorker");
            t.generateWorker = function(h, e, y) {
              var c = new v(e.streamFiles, y, e.platform, e.encodeFileName), d = 0;
              try {
                h.forEach(function(m, p) {
                  d++;
                  var g = function(u, w) {
                    var O = u || w, b = a[O];
                    if (!b)
                      throw new Error(O + " is not a valid compression method !");
                    return b;
                  }(p.options.compression, e.compression), n = p.options.compressionOptions || e.compressionOptions || {}, i = p.dir, l = p.date;
                  p._compressWorker(g, n).withStreamInfo("file", { name: m, dir: i, date: l, comment: p.comment || "", unixPermissions: p.unixPermissions, dosPermissions: p.dosPermissions }).pipe(c);
                }), c.entriesCount = d;
              } catch (m) {
                c.error(m);
              }
              return c;
            };
          }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(o, F, t) {
            function a() {
              if (!(this instanceof a))
                return new a();
              if (arguments.length)
                throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
              this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
                var v = new a();
                for (var h in this)
                  typeof this[h] != "function" && (v[h] = this[h]);
                return v;
              };
            }
            (a.prototype = o("./object")).loadAsync = o("./load"), a.support = o("./support"), a.defaults = o("./defaults"), a.version = "3.7.1", a.loadAsync = function(v, h) {
              return new a().loadAsync(v, h);
            }, a.external = o("./external"), F.exports = a;
          }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(o, F, t) {
            var a = o("./utils"), v = o("./external"), h = o("./utf8"), e = o("./zipEntries"), y = o("./stream/Crc32Probe"), c = o("./nodejsUtils");
            function d(m) {
              return new v.Promise(function(p, g) {
                var n = m.decompressed.getContentWorker().pipe(new y());
                n.on("error", function(i) {
                  g(i);
                }).on("end", function() {
                  n.streamInfo.crc32 !== m.decompressed.crc32 ? g(new Error("Corrupted zip : CRC32 mismatch")) : p();
                }).resume();
              });
            }
            F.exports = function(m, p) {
              var g = this;
              return p = a.extend(p || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: h.utf8decode }), c.isNode && c.isStream(m) ? v.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : a.prepareContent("the loaded zip file", m, !0, p.optimizedBinaryString, p.base64).then(function(n) {
                var i = new e(p);
                return i.load(n), i;
              }).then(function(n) {
                var i = [v.Promise.resolve(n)], l = n.files;
                if (p.checkCRC32)
                  for (var u = 0; u < l.length; u++)
                    i.push(d(l[u]));
                return v.Promise.all(i);
              }).then(function(n) {
                for (var i = n.shift(), l = i.files, u = 0; u < l.length; u++) {
                  var w = l[u];
                  g.file(w.fileNameStr, w.decompressed, { binary: !0, optimizedBinaryString: !0, date: w.date, dir: w.dir, comment: w.fileCommentStr.length ? w.fileCommentStr : null, unixPermissions: w.unixPermissions, dosPermissions: w.dosPermissions, createFolders: p.createFolders });
                }
                return i.zipComment.length && (g.comment = i.zipComment), g;
              });
            };
          }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(o, F, t) {
            var a = o("../utils"), v = o("../stream/GenericWorker");
            function h(e, y) {
              v.call(this, "Nodejs stream input adapter for " + e), this._upstreamEnded = !1, this._bindStream(y);
            }
            a.inherits(h, v), h.prototype._bindStream = function(e) {
              var y = this;
              (this._stream = e).pause(), e.on("data", function(c) {
                y.push({ data: c, meta: { percent: 0 } });
              }).on("error", function(c) {
                y.isPaused ? this.generatedError = c : y.error(c);
              }).on("end", function() {
                y.isPaused ? y._upstreamEnded = !0 : y.end();
              });
            }, h.prototype.pause = function() {
              return !!v.prototype.pause.call(this) && (this._stream.pause(), !0);
            }, h.prototype.resume = function() {
              return !!v.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
            }, F.exports = h;
          }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(o, F, t) {
            var a = o("readable-stream").Readable;
            function v(h, e, y) {
              a.call(this, e), this._helper = h;
              var c = this;
              h.on("data", function(d, m) {
                c.push(d) || c._helper.pause(), y && y(m);
              }).on("error", function(d) {
                c.emit("error", d);
              }).on("end", function() {
                c.push(null);
              });
            }
            o("../utils").inherits(v, a), v.prototype._read = function() {
              this._helper.resume();
            }, F.exports = v;
          }, { "../utils": 32, "readable-stream": 16 }], 14: [function(o, F, t) {
            F.exports = { isNode: typeof J < "u", newBufferFrom: function(a, v) {
              if (J.from && J.from !== Uint8Array.from)
                return J.from(a, v);
              if (typeof a == "number")
                throw new Error('The "data" argument must not be a number');
              return new J(a, v);
            }, allocBuffer: function(a) {
              if (J.alloc)
                return J.alloc(a);
              var v = new J(a);
              return v.fill(0), v;
            }, isBuffer: function(a) {
              return J.isBuffer(a);
            }, isStream: function(a) {
              return a && typeof a.on == "function" && typeof a.pause == "function" && typeof a.resume == "function";
            } };
          }, {}], 15: [function(o, F, t) {
            function a(b, A, Y) {
              var j, X = h.getTypeOf(A), B = h.extend(Y || {}, c);
              B.date = B.date || new Date(), B.compression !== null && (B.compression = B.compression.toUpperCase()), typeof B.unixPermissions == "string" && (B.unixPermissions = parseInt(B.unixPermissions, 8)), B.unixPermissions && 16384 & B.unixPermissions && (B.dir = !0), B.dosPermissions && 16 & B.dosPermissions && (B.dir = !0), B.dir && (b = l(b)), B.createFolders && (j = i(b)) && u.call(this, j, !0);
              var U = X === "string" && B.binary === !1 && B.base64 === !1;
              Y && Y.binary !== void 0 || (B.binary = !U), (A instanceof d && A.uncompressedSize === 0 || B.dir || !A || A.length === 0) && (B.base64 = !1, B.binary = !0, A = "", B.compression = "STORE", X = "string");
              var k = null;
              k = A instanceof d || A instanceof e ? A : g.isNode && g.isStream(A) ? new n(b, A) : h.prepareContent(b, A, B.binary, B.optimizedBinaryString, B.base64);
              var x = new m(b, k, B);
              this.files[b] = x;
            }
            var v = o("./utf8"), h = o("./utils"), e = o("./stream/GenericWorker"), y = o("./stream/StreamHelper"), c = o("./defaults"), d = o("./compressedObject"), m = o("./zipObject"), p = o("./generate"), g = o("./nodejsUtils"), n = o("./nodejs/NodejsStreamInputAdapter"), i = function(b) {
              b.slice(-1) === "/" && (b = b.substring(0, b.length - 1));
              var A = b.lastIndexOf("/");
              return 0 < A ? b.substring(0, A) : "";
            }, l = function(b) {
              return b.slice(-1) !== "/" && (b += "/"), b;
            }, u = function(b, A) {
              return A = A !== void 0 ? A : c.createFolders, b = l(b), this.files[b] || a.call(this, b, null, { dir: !0, createFolders: A }), this.files[b];
            };
            function w(b) {
              return Object.prototype.toString.call(b) === "[object RegExp]";
            }
            var O = { load: function() {
              throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
            }, forEach: function(b) {
              var A, Y, j;
              for (A in this.files)
                j = this.files[A], (Y = A.slice(this.root.length, A.length)) && A.slice(0, this.root.length) === this.root && b(Y, j);
            }, filter: function(b) {
              var A = [];
              return this.forEach(function(Y, j) {
                b(Y, j) && A.push(j);
              }), A;
            }, file: function(b, A, Y) {
              if (arguments.length !== 1)
                return b = this.root + b, a.call(this, b, A, Y), this;
              if (w(b)) {
                var j = b;
                return this.filter(function(B, U) {
                  return !U.dir && j.test(B);
                });
              }
              var X = this.files[this.root + b];
              return X && !X.dir ? X : null;
            }, folder: function(b) {
              if (!b)
                return this;
              if (w(b))
                return this.filter(function(X, B) {
                  return B.dir && b.test(X);
                });
              var A = this.root + b, Y = u.call(this, A), j = this.clone();
              return j.root = Y.name, j;
            }, remove: function(b) {
              b = this.root + b;
              var A = this.files[b];
              if (A || (b.slice(-1) !== "/" && (b += "/"), A = this.files[b]), A && !A.dir)
                delete this.files[b];
              else
                for (var Y = this.filter(function(X, B) {
                  return B.name.slice(0, b.length) === b;
                }), j = 0; j < Y.length; j++)
                  delete this.files[Y[j].name];
              return this;
            }, generate: function(b) {
              throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
            }, generateInternalStream: function(b) {
              var A, Y = {};
              try {
                if ((Y = h.extend(b || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: v.utf8encode })).type = Y.type.toLowerCase(), Y.compression = Y.compression.toUpperCase(), Y.type === "binarystring" && (Y.type = "string"), !Y.type)
                  throw new Error("No output type specified.");
                h.checkSupport(Y.type), Y.platform !== "darwin" && Y.platform !== "freebsd" && Y.platform !== "linux" && Y.platform !== "sunos" || (Y.platform = "UNIX"), Y.platform === "win32" && (Y.platform = "DOS");
                var j = Y.comment || this.comment || "";
                A = p.generateWorker(this, Y, j);
              } catch (X) {
                (A = new e("error")).error(X);
              }
              return new y(A, Y.type || "string", Y.mimeType);
            }, generateAsync: function(b, A) {
              return this.generateInternalStream(b).accumulate(A);
            }, generateNodeStream: function(b, A) {
              return (b = b || {}).type || (b.type = "nodebuffer"), this.generateInternalStream(b).toNodejsStream(A);
            } };
            F.exports = O;
          }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(o, F, t) {
            F.exports = o("stream");
          }, { stream: void 0 }], 17: [function(o, F, t) {
            var a = o("./DataReader");
            function v(h) {
              a.call(this, h);
              for (var e = 0; e < this.data.length; e++)
                h[e] = 255 & h[e];
            }
            o("../utils").inherits(v, a), v.prototype.byteAt = function(h) {
              return this.data[this.zero + h];
            }, v.prototype.lastIndexOfSignature = function(h) {
              for (var e = h.charCodeAt(0), y = h.charCodeAt(1), c = h.charCodeAt(2), d = h.charCodeAt(3), m = this.length - 4; 0 <= m; --m)
                if (this.data[m] === e && this.data[m + 1] === y && this.data[m + 2] === c && this.data[m + 3] === d)
                  return m - this.zero;
              return -1;
            }, v.prototype.readAndCheckSignature = function(h) {
              var e = h.charCodeAt(0), y = h.charCodeAt(1), c = h.charCodeAt(2), d = h.charCodeAt(3), m = this.readData(4);
              return e === m[0] && y === m[1] && c === m[2] && d === m[3];
            }, v.prototype.readData = function(h) {
              if (this.checkOffset(h), h === 0)
                return [];
              var e = this.data.slice(this.zero + this.index, this.zero + this.index + h);
              return this.index += h, e;
            }, F.exports = v;
          }, { "../utils": 32, "./DataReader": 18 }], 18: [function(o, F, t) {
            var a = o("../utils");
            function v(h) {
              this.data = h, this.length = h.length, this.index = 0, this.zero = 0;
            }
            v.prototype = { checkOffset: function(h) {
              this.checkIndex(this.index + h);
            }, checkIndex: function(h) {
              if (this.length < this.zero + h || h < 0)
                throw new Error("End of data reached (data length = " + this.length + ", asked index = " + h + "). Corrupted zip ?");
            }, setIndex: function(h) {
              this.checkIndex(h), this.index = h;
            }, skip: function(h) {
              this.setIndex(this.index + h);
            }, byteAt: function(h) {
            }, readInt: function(h) {
              var e, y = 0;
              for (this.checkOffset(h), e = this.index + h - 1; e >= this.index; e--)
                y = (y << 8) + this.byteAt(e);
              return this.index += h, y;
            }, readString: function(h) {
              return a.transformTo("string", this.readData(h));
            }, readData: function(h) {
            }, lastIndexOfSignature: function(h) {
            }, readAndCheckSignature: function(h) {
            }, readDate: function() {
              var h = this.readInt(4);
              return new Date(Date.UTC(1980 + (h >> 25 & 127), (h >> 21 & 15) - 1, h >> 16 & 31, h >> 11 & 31, h >> 5 & 63, (31 & h) << 1));
            } }, F.exports = v;
          }, { "../utils": 32 }], 19: [function(o, F, t) {
            var a = o("./Uint8ArrayReader");
            function v(h) {
              a.call(this, h);
            }
            o("../utils").inherits(v, a), v.prototype.readData = function(h) {
              this.checkOffset(h);
              var e = this.data.slice(this.zero + this.index, this.zero + this.index + h);
              return this.index += h, e;
            }, F.exports = v;
          }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(o, F, t) {
            var a = o("./DataReader");
            function v(h) {
              a.call(this, h);
            }
            o("../utils").inherits(v, a), v.prototype.byteAt = function(h) {
              return this.data.charCodeAt(this.zero + h);
            }, v.prototype.lastIndexOfSignature = function(h) {
              return this.data.lastIndexOf(h) - this.zero;
            }, v.prototype.readAndCheckSignature = function(h) {
              return h === this.readData(4);
            }, v.prototype.readData = function(h) {
              this.checkOffset(h);
              var e = this.data.slice(this.zero + this.index, this.zero + this.index + h);
              return this.index += h, e;
            }, F.exports = v;
          }, { "../utils": 32, "./DataReader": 18 }], 21: [function(o, F, t) {
            var a = o("./ArrayReader");
            function v(h) {
              a.call(this, h);
            }
            o("../utils").inherits(v, a), v.prototype.readData = function(h) {
              if (this.checkOffset(h), h === 0)
                return new Uint8Array(0);
              var e = this.data.subarray(this.zero + this.index, this.zero + this.index + h);
              return this.index += h, e;
            }, F.exports = v;
          }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(o, F, t) {
            var a = o("../utils"), v = o("../support"), h = o("./ArrayReader"), e = o("./StringReader"), y = o("./NodeBufferReader"), c = o("./Uint8ArrayReader");
            F.exports = function(d) {
              var m = a.getTypeOf(d);
              return a.checkSupport(m), m !== "string" || v.uint8array ? m === "nodebuffer" ? new y(d) : v.uint8array ? new c(a.transformTo("uint8array", d)) : new h(a.transformTo("array", d)) : new e(d);
            };
          }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(o, F, t) {
            t.LOCAL_FILE_HEADER = "PK", t.CENTRAL_FILE_HEADER = "PK", t.CENTRAL_DIRECTORY_END = "PK", t.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", t.ZIP64_CENTRAL_DIRECTORY_END = "PK", t.DATA_DESCRIPTOR = "PK\x07\b";
          }, {}], 24: [function(o, F, t) {
            var a = o("./GenericWorker"), v = o("../utils");
            function h(e) {
              a.call(this, "ConvertWorker to " + e), this.destType = e;
            }
            v.inherits(h, a), h.prototype.processChunk = function(e) {
              this.push({ data: v.transformTo(this.destType, e.data), meta: e.meta });
            }, F.exports = h;
          }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(o, F, t) {
            var a = o("./GenericWorker"), v = o("../crc32");
            function h() {
              a.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
            }
            o("../utils").inherits(h, a), h.prototype.processChunk = function(e) {
              this.streamInfo.crc32 = v(e.data, this.streamInfo.crc32 || 0), this.push(e);
            }, F.exports = h;
          }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(o, F, t) {
            var a = o("../utils"), v = o("./GenericWorker");
            function h(e) {
              v.call(this, "DataLengthProbe for " + e), this.propName = e, this.withStreamInfo(e, 0);
            }
            a.inherits(h, v), h.prototype.processChunk = function(e) {
              if (e) {
                var y = this.streamInfo[this.propName] || 0;
                this.streamInfo[this.propName] = y + e.data.length;
              }
              v.prototype.processChunk.call(this, e);
            }, F.exports = h;
          }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(o, F, t) {
            var a = o("../utils"), v = o("./GenericWorker");
            function h(e) {
              v.call(this, "DataWorker");
              var y = this;
              this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, e.then(function(c) {
                y.dataIsReady = !0, y.data = c, y.max = c && c.length || 0, y.type = a.getTypeOf(c), y.isPaused || y._tickAndRepeat();
              }, function(c) {
                y.error(c);
              });
            }
            a.inherits(h, v), h.prototype.cleanUp = function() {
              v.prototype.cleanUp.call(this), this.data = null;
            }, h.prototype.resume = function() {
              return !!v.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, a.delay(this._tickAndRepeat, [], this)), !0);
            }, h.prototype._tickAndRepeat = function() {
              this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (a.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
            }, h.prototype._tick = function() {
              if (this.isPaused || this.isFinished)
                return !1;
              var e = null, y = Math.min(this.max, this.index + 16384);
              if (this.index >= this.max)
                return this.end();
              switch (this.type) {
                case "string":
                  e = this.data.substring(this.index, y);
                  break;
                case "uint8array":
                  e = this.data.subarray(this.index, y);
                  break;
                case "array":
                case "nodebuffer":
                  e = this.data.slice(this.index, y);
              }
              return this.index = y, this.push({ data: e, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
            }, F.exports = h;
          }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(o, F, t) {
            function a(v) {
              this.name = v || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
            }
            a.prototype = { push: function(v) {
              this.emit("data", v);
            }, end: function() {
              if (this.isFinished)
                return !1;
              this.flush();
              try {
                this.emit("end"), this.cleanUp(), this.isFinished = !0;
              } catch (v) {
                this.emit("error", v);
              }
              return !0;
            }, error: function(v) {
              return !this.isFinished && (this.isPaused ? this.generatedError = v : (this.isFinished = !0, this.emit("error", v), this.previous && this.previous.error(v), this.cleanUp()), !0);
            }, on: function(v, h) {
              return this._listeners[v].push(h), this;
            }, cleanUp: function() {
              this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
            }, emit: function(v, h) {
              if (this._listeners[v])
                for (var e = 0; e < this._listeners[v].length; e++)
                  this._listeners[v][e].call(this, h);
            }, pipe: function(v) {
              return v.registerPrevious(this);
            }, registerPrevious: function(v) {
              if (this.isLocked)
                throw new Error("The stream '" + this + "' has already been used.");
              this.streamInfo = v.streamInfo, this.mergeStreamInfo(), this.previous = v;
              var h = this;
              return v.on("data", function(e) {
                h.processChunk(e);
              }), v.on("end", function() {
                h.end();
              }), v.on("error", function(e) {
                h.error(e);
              }), this;
            }, pause: function() {
              return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
            }, resume: function() {
              if (!this.isPaused || this.isFinished)
                return !1;
              var v = this.isPaused = !1;
              return this.generatedError && (this.error(this.generatedError), v = !0), this.previous && this.previous.resume(), !v;
            }, flush: function() {
            }, processChunk: function(v) {
              this.push(v);
            }, withStreamInfo: function(v, h) {
              return this.extraStreamInfo[v] = h, this.mergeStreamInfo(), this;
            }, mergeStreamInfo: function() {
              for (var v in this.extraStreamInfo)
                this.extraStreamInfo.hasOwnProperty(v) && (this.streamInfo[v] = this.extraStreamInfo[v]);
            }, lock: function() {
              if (this.isLocked)
                throw new Error("The stream '" + this + "' has already been used.");
              this.isLocked = !0, this.previous && this.previous.lock();
            }, toString: function() {
              var v = "Worker " + this.name;
              return this.previous ? this.previous + " -> " + v : v;
            } }, F.exports = a;
          }, {}], 29: [function(o, F, t) {
            var a = o("../utils"), v = o("./ConvertWorker"), h = o("./GenericWorker"), e = o("../base64"), y = o("../support"), c = o("../external"), d = null;
            if (y.nodestream)
              try {
                d = o("../nodejs/NodejsStreamOutputAdapter");
              } catch {
              }
            function m(g, n) {
              return new c.Promise(function(i, l) {
                var u = [], w = g._internalType, O = g._outputType, b = g._mimeType;
                g.on("data", function(A, Y) {
                  u.push(A), n && n(Y);
                }).on("error", function(A) {
                  u = [], l(A);
                }).on("end", function() {
                  try {
                    var A = function(Y, j, X) {
                      switch (Y) {
                        case "blob":
                          return a.newBlob(a.transformTo("arraybuffer", j), X);
                        case "base64":
                          return e.encode(j);
                        default:
                          return a.transformTo(Y, j);
                      }
                    }(O, function(Y, j) {
                      var X, B = 0, U = null, k = 0;
                      for (X = 0; X < j.length; X++)
                        k += j[X].length;
                      switch (Y) {
                        case "string":
                          return j.join("");
                        case "array":
                          return Array.prototype.concat.apply([], j);
                        case "uint8array":
                          for (U = new Uint8Array(k), X = 0; X < j.length; X++)
                            U.set(j[X], B), B += j[X].length;
                          return U;
                        case "nodebuffer":
                          return J.concat(j);
                        default:
                          throw new Error("concat : unsupported type '" + Y + "'");
                      }
                    }(w, u), b);
                    i(A);
                  } catch (Y) {
                    l(Y);
                  }
                  u = [];
                }).resume();
              });
            }
            function p(g, n, i) {
              var l = n;
              switch (n) {
                case "blob":
                case "arraybuffer":
                  l = "uint8array";
                  break;
                case "base64":
                  l = "string";
              }
              try {
                this._internalType = l, this._outputType = n, this._mimeType = i, a.checkSupport(l), this._worker = g.pipe(new v(l)), g.lock();
              } catch (u) {
                this._worker = new h("error"), this._worker.error(u);
              }
            }
            p.prototype = { accumulate: function(g) {
              return m(this, g);
            }, on: function(g, n) {
              var i = this;
              return g === "data" ? this._worker.on(g, function(l) {
                n.call(i, l.data, l.meta);
              }) : this._worker.on(g, function() {
                a.delay(n, arguments, i);
              }), this;
            }, resume: function() {
              return a.delay(this._worker.resume, [], this._worker), this;
            }, pause: function() {
              return this._worker.pause(), this;
            }, toNodejsStream: function(g) {
              if (a.checkSupport("nodestream"), this._outputType !== "nodebuffer")
                throw new Error(this._outputType + " is not supported by this method");
              return new d(this, { objectMode: this._outputType !== "nodebuffer" }, g);
            } }, F.exports = p;
          }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(o, F, t) {
            if (t.base64 = !0, t.array = !0, t.string = !0, t.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", t.nodebuffer = typeof J < "u", t.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u")
              t.blob = !1;
            else {
              var a = new ArrayBuffer(0);
              try {
                t.blob = new Blob([a], { type: "application/zip" }).size === 0;
              } catch {
                try {
                  var v = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
                  v.append(a), t.blob = v.getBlob("application/zip").size === 0;
                } catch {
                  t.blob = !1;
                }
              }
            }
            try {
              t.nodestream = !!o("readable-stream").Readable;
            } catch {
              t.nodestream = !1;
            }
          }, { "readable-stream": 16 }], 31: [function(o, F, t) {
            for (var a = o("./utils"), v = o("./support"), h = o("./nodejsUtils"), e = o("./stream/GenericWorker"), y = new Array(256), c = 0; c < 256; c++)
              y[c] = 252 <= c ? 6 : 248 <= c ? 5 : 240 <= c ? 4 : 224 <= c ? 3 : 192 <= c ? 2 : 1;
            y[254] = y[254] = 1;
            function d() {
              e.call(this, "utf-8 decode"), this.leftOver = null;
            }
            function m() {
              e.call(this, "utf-8 encode");
            }
            t.utf8encode = function(p) {
              return v.nodebuffer ? h.newBufferFrom(p, "utf-8") : function(g) {
                var n, i, l, u, w, O = g.length, b = 0;
                for (u = 0; u < O; u++)
                  (64512 & (i = g.charCodeAt(u))) == 55296 && u + 1 < O && (64512 & (l = g.charCodeAt(u + 1))) == 56320 && (i = 65536 + (i - 55296 << 10) + (l - 56320), u++), b += i < 128 ? 1 : i < 2048 ? 2 : i < 65536 ? 3 : 4;
                for (n = v.uint8array ? new Uint8Array(b) : new Array(b), u = w = 0; w < b; u++)
                  (64512 & (i = g.charCodeAt(u))) == 55296 && u + 1 < O && (64512 & (l = g.charCodeAt(u + 1))) == 56320 && (i = 65536 + (i - 55296 << 10) + (l - 56320), u++), i < 128 ? n[w++] = i : (i < 2048 ? n[w++] = 192 | i >>> 6 : (i < 65536 ? n[w++] = 224 | i >>> 12 : (n[w++] = 240 | i >>> 18, n[w++] = 128 | i >>> 12 & 63), n[w++] = 128 | i >>> 6 & 63), n[w++] = 128 | 63 & i);
                return n;
              }(p);
            }, t.utf8decode = function(p) {
              return v.nodebuffer ? a.transformTo("nodebuffer", p).toString("utf-8") : function(g) {
                var n, i, l, u, w = g.length, O = new Array(2 * w);
                for (n = i = 0; n < w; )
                  if ((l = g[n++]) < 128)
                    O[i++] = l;
                  else if (4 < (u = y[l]))
                    O[i++] = 65533, n += u - 1;
                  else {
                    for (l &= u === 2 ? 31 : u === 3 ? 15 : 7; 1 < u && n < w; )
                      l = l << 6 | 63 & g[n++], u--;
                    1 < u ? O[i++] = 65533 : l < 65536 ? O[i++] = l : (l -= 65536, O[i++] = 55296 | l >> 10 & 1023, O[i++] = 56320 | 1023 & l);
                  }
                return O.length !== i && (O.subarray ? O = O.subarray(0, i) : O.length = i), a.applyFromCharCode(O);
              }(p = a.transformTo(v.uint8array ? "uint8array" : "array", p));
            }, a.inherits(d, e), d.prototype.processChunk = function(p) {
              var g = a.transformTo(v.uint8array ? "uint8array" : "array", p.data);
              if (this.leftOver && this.leftOver.length) {
                if (v.uint8array) {
                  var n = g;
                  (g = new Uint8Array(n.length + this.leftOver.length)).set(this.leftOver, 0), g.set(n, this.leftOver.length);
                } else
                  g = this.leftOver.concat(g);
                this.leftOver = null;
              }
              var i = function(u, w) {
                var O;
                for ((w = w || u.length) > u.length && (w = u.length), O = w - 1; 0 <= O && (192 & u[O]) == 128; )
                  O--;
                return O < 0 || O === 0 ? w : O + y[u[O]] > w ? O : w;
              }(g), l = g;
              i !== g.length && (v.uint8array ? (l = g.subarray(0, i), this.leftOver = g.subarray(i, g.length)) : (l = g.slice(0, i), this.leftOver = g.slice(i, g.length))), this.push({ data: t.utf8decode(l), meta: p.meta });
            }, d.prototype.flush = function() {
              this.leftOver && this.leftOver.length && (this.push({ data: t.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
            }, t.Utf8DecodeWorker = d, a.inherits(m, e), m.prototype.processChunk = function(p) {
              this.push({ data: t.utf8encode(p.data), meta: p.meta });
            }, t.Utf8EncodeWorker = m;
          }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(o, F, t) {
            var a = o("./support"), v = o("./base64"), h = o("./nodejsUtils"), e = o("set-immediate-shim"), y = o("./external");
            function c(i) {
              return i;
            }
            function d(i, l) {
              for (var u = 0; u < i.length; ++u)
                l[u] = 255 & i.charCodeAt(u);
              return l;
            }
            t.newBlob = function(i, l) {
              t.checkSupport("blob");
              try {
                return new Blob([i], { type: l });
              } catch {
                try {
                  var u = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
                  return u.append(i), u.getBlob(l);
                } catch {
                  throw new Error("Bug : can't construct the Blob.");
                }
              }
            };
            var m = { stringifyByChunk: function(i, l, u) {
              var w = [], O = 0, b = i.length;
              if (b <= u)
                return String.fromCharCode.apply(null, i);
              for (; O < b; )
                l === "array" || l === "nodebuffer" ? w.push(String.fromCharCode.apply(null, i.slice(O, Math.min(O + u, b)))) : w.push(String.fromCharCode.apply(null, i.subarray(O, Math.min(O + u, b)))), O += u;
              return w.join("");
            }, stringifyByChar: function(i) {
              for (var l = "", u = 0; u < i.length; u++)
                l += String.fromCharCode(i[u]);
              return l;
            }, applyCanBeUsed: { uint8array: function() {
              try {
                return a.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
              } catch {
                return !1;
              }
            }(), nodebuffer: function() {
              try {
                return a.nodebuffer && String.fromCharCode.apply(null, h.allocBuffer(1)).length === 1;
              } catch {
                return !1;
              }
            }() } };
            function p(i) {
              var l = 65536, u = t.getTypeOf(i), w = !0;
              if (u === "uint8array" ? w = m.applyCanBeUsed.uint8array : u === "nodebuffer" && (w = m.applyCanBeUsed.nodebuffer), w)
                for (; 1 < l; )
                  try {
                    return m.stringifyByChunk(i, u, l);
                  } catch {
                    l = Math.floor(l / 2);
                  }
              return m.stringifyByChar(i);
            }
            function g(i, l) {
              for (var u = 0; u < i.length; u++)
                l[u] = i[u];
              return l;
            }
            t.applyFromCharCode = p;
            var n = {};
            n.string = { string: c, array: function(i) {
              return d(i, new Array(i.length));
            }, arraybuffer: function(i) {
              return n.string.uint8array(i).buffer;
            }, uint8array: function(i) {
              return d(i, new Uint8Array(i.length));
            }, nodebuffer: function(i) {
              return d(i, h.allocBuffer(i.length));
            } }, n.array = { string: p, array: c, arraybuffer: function(i) {
              return new Uint8Array(i).buffer;
            }, uint8array: function(i) {
              return new Uint8Array(i);
            }, nodebuffer: function(i) {
              return h.newBufferFrom(i);
            } }, n.arraybuffer = { string: function(i) {
              return p(new Uint8Array(i));
            }, array: function(i) {
              return g(new Uint8Array(i), new Array(i.byteLength));
            }, arraybuffer: c, uint8array: function(i) {
              return new Uint8Array(i);
            }, nodebuffer: function(i) {
              return h.newBufferFrom(new Uint8Array(i));
            } }, n.uint8array = { string: p, array: function(i) {
              return g(i, new Array(i.length));
            }, arraybuffer: function(i) {
              return i.buffer;
            }, uint8array: c, nodebuffer: function(i) {
              return h.newBufferFrom(i);
            } }, n.nodebuffer = { string: p, array: function(i) {
              return g(i, new Array(i.length));
            }, arraybuffer: function(i) {
              return n.nodebuffer.uint8array(i).buffer;
            }, uint8array: function(i) {
              return g(i, new Uint8Array(i.length));
            }, nodebuffer: c }, t.transformTo = function(i, l) {
              if (l = l || "", !i)
                return l;
              t.checkSupport(i);
              var u = t.getTypeOf(l);
              return n[u][i](l);
            }, t.getTypeOf = function(i) {
              return typeof i == "string" ? "string" : Object.prototype.toString.call(i) === "[object Array]" ? "array" : a.nodebuffer && h.isBuffer(i) ? "nodebuffer" : a.uint8array && i instanceof Uint8Array ? "uint8array" : a.arraybuffer && i instanceof ArrayBuffer ? "arraybuffer" : void 0;
            }, t.checkSupport = function(i) {
              if (!a[i.toLowerCase()])
                throw new Error(i + " is not supported by this platform");
            }, t.MAX_VALUE_16BITS = 65535, t.MAX_VALUE_32BITS = -1, t.pretty = function(i) {
              var l, u, w = "";
              for (u = 0; u < (i || "").length; u++)
                w += "\\x" + ((l = i.charCodeAt(u)) < 16 ? "0" : "") + l.toString(16).toUpperCase();
              return w;
            }, t.delay = function(i, l, u) {
              e(function() {
                i.apply(u || null, l || []);
              });
            }, t.inherits = function(i, l) {
              function u() {
              }
              u.prototype = l.prototype, i.prototype = new u();
            }, t.extend = function() {
              var i, l, u = {};
              for (i = 0; i < arguments.length; i++)
                for (l in arguments[i])
                  arguments[i].hasOwnProperty(l) && u[l] === void 0 && (u[l] = arguments[i][l]);
              return u;
            }, t.prepareContent = function(i, l, u, w, O) {
              return y.Promise.resolve(l).then(function(b) {
                return a.blob && (b instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(b)) !== -1) && typeof FileReader < "u" ? new y.Promise(function(A, Y) {
                  var j = new FileReader();
                  j.onload = function(X) {
                    A(X.target.result);
                  }, j.onerror = function(X) {
                    Y(X.target.error);
                  }, j.readAsArrayBuffer(b);
                }) : b;
              }).then(function(b) {
                var A = t.getTypeOf(b);
                return A ? (A === "arraybuffer" ? b = t.transformTo("uint8array", b) : A === "string" && (O ? b = v.decode(b) : u && w !== !0 && (b = function(Y) {
                  return d(Y, a.uint8array ? new Uint8Array(Y.length) : new Array(Y.length));
                }(b))), b) : y.Promise.reject(new Error("Can't read the data of '" + i + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
              });
            };
          }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, "set-immediate-shim": 54 }], 33: [function(o, F, t) {
            var a = o("./reader/readerFor"), v = o("./utils"), h = o("./signature"), e = o("./zipEntry"), y = (o("./utf8"), o("./support"));
            function c(d) {
              this.files = [], this.loadOptions = d;
            }
            c.prototype = { checkSignature: function(d) {
              if (!this.reader.readAndCheckSignature(d)) {
                this.reader.index -= 4;
                var m = this.reader.readString(4);
                throw new Error("Corrupted zip or bug: unexpected signature (" + v.pretty(m) + ", expected " + v.pretty(d) + ")");
              }
            }, isSignature: function(d, m) {
              var p = this.reader.index;
              this.reader.setIndex(d);
              var g = this.reader.readString(4) === m;
              return this.reader.setIndex(p), g;
            }, readBlockEndOfCentral: function() {
              this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
              var d = this.reader.readData(this.zipCommentLength), m = y.uint8array ? "uint8array" : "array", p = v.transformTo(m, d);
              this.zipComment = this.loadOptions.decodeFileName(p);
            }, readBlockZip64EndOfCentral: function() {
              this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
              for (var d, m, p, g = this.zip64EndOfCentralSize - 44; 0 < g; )
                d = this.reader.readInt(2), m = this.reader.readInt(4), p = this.reader.readData(m), this.zip64ExtensibleData[d] = { id: d, length: m, value: p };
            }, readBlockZip64EndOfCentralLocator: function() {
              if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
                throw new Error("Multi-volumes zip are not supported");
            }, readLocalFiles: function() {
              var d, m;
              for (d = 0; d < this.files.length; d++)
                m = this.files[d], this.reader.setIndex(m.localHeaderOffset), this.checkSignature(h.LOCAL_FILE_HEADER), m.readLocalPart(this.reader), m.handleUTF8(), m.processAttributes();
            }, readCentralDir: function() {
              var d;
              for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(h.CENTRAL_FILE_HEADER); )
                (d = new e({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(d);
              if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0)
                throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
            }, readEndOfCentral: function() {
              var d = this.reader.lastIndexOfSignature(h.CENTRAL_DIRECTORY_END);
              if (d < 0)
                throw this.isSignature(0, h.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
              this.reader.setIndex(d);
              var m = d;
              if (this.checkSignature(h.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === v.MAX_VALUE_16BITS || this.diskWithCentralDirStart === v.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === v.MAX_VALUE_16BITS || this.centralDirRecords === v.MAX_VALUE_16BITS || this.centralDirSize === v.MAX_VALUE_32BITS || this.centralDirOffset === v.MAX_VALUE_32BITS) {
                if (this.zip64 = !0, (d = this.reader.lastIndexOfSignature(h.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
                  throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
                if (this.reader.setIndex(d), this.checkSignature(h.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, h.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(h.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
                  throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
                this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(h.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
              }
              var p = this.centralDirOffset + this.centralDirSize;
              this.zip64 && (p += 20, p += 12 + this.zip64EndOfCentralSize);
              var g = m - p;
              if (0 < g)
                this.isSignature(m, h.CENTRAL_FILE_HEADER) || (this.reader.zero = g);
              else if (g < 0)
                throw new Error("Corrupted zip: missing " + Math.abs(g) + " bytes.");
            }, prepareReader: function(d) {
              this.reader = a(d);
            }, load: function(d) {
              this.prepareReader(d), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
            } }, F.exports = c;
          }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utf8": 31, "./utils": 32, "./zipEntry": 34 }], 34: [function(o, F, t) {
            var a = o("./reader/readerFor"), v = o("./utils"), h = o("./compressedObject"), e = o("./crc32"), y = o("./utf8"), c = o("./compressions"), d = o("./support");
            function m(p, g) {
              this.options = p, this.loadOptions = g;
            }
            m.prototype = { isEncrypted: function() {
              return (1 & this.bitFlag) == 1;
            }, useUTF8: function() {
              return (2048 & this.bitFlag) == 2048;
            }, readLocalPart: function(p) {
              var g, n;
              if (p.skip(22), this.fileNameLength = p.readInt(2), n = p.readInt(2), this.fileName = p.readData(this.fileNameLength), p.skip(n), this.compressedSize === -1 || this.uncompressedSize === -1)
                throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
              if ((g = function(i) {
                for (var l in c)
                  if (c.hasOwnProperty(l) && c[l].magic === i)
                    return c[l];
                return null;
              }(this.compressionMethod)) === null)
                throw new Error("Corrupted zip : compression " + v.pretty(this.compressionMethod) + " unknown (inner file : " + v.transformTo("string", this.fileName) + ")");
              this.decompressed = new h(this.compressedSize, this.uncompressedSize, this.crc32, g, p.readData(this.compressedSize));
            }, readCentralPart: function(p) {
              this.versionMadeBy = p.readInt(2), p.skip(2), this.bitFlag = p.readInt(2), this.compressionMethod = p.readString(2), this.date = p.readDate(), this.crc32 = p.readInt(4), this.compressedSize = p.readInt(4), this.uncompressedSize = p.readInt(4);
              var g = p.readInt(2);
              if (this.extraFieldsLength = p.readInt(2), this.fileCommentLength = p.readInt(2), this.diskNumberStart = p.readInt(2), this.internalFileAttributes = p.readInt(2), this.externalFileAttributes = p.readInt(4), this.localHeaderOffset = p.readInt(4), this.isEncrypted())
                throw new Error("Encrypted zip are not supported");
              p.skip(g), this.readExtraFields(p), this.parseZIP64ExtraField(p), this.fileComment = p.readData(this.fileCommentLength);
            }, processAttributes: function() {
              this.unixPermissions = null, this.dosPermissions = null;
              var p = this.versionMadeBy >> 8;
              this.dir = !!(16 & this.externalFileAttributes), p == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), p == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
            }, parseZIP64ExtraField: function(p) {
              if (this.extraFields[1]) {
                var g = a(this.extraFields[1].value);
                this.uncompressedSize === v.MAX_VALUE_32BITS && (this.uncompressedSize = g.readInt(8)), this.compressedSize === v.MAX_VALUE_32BITS && (this.compressedSize = g.readInt(8)), this.localHeaderOffset === v.MAX_VALUE_32BITS && (this.localHeaderOffset = g.readInt(8)), this.diskNumberStart === v.MAX_VALUE_32BITS && (this.diskNumberStart = g.readInt(4));
              }
            }, readExtraFields: function(p) {
              var g, n, i, l = p.index + this.extraFieldsLength;
              for (this.extraFields || (this.extraFields = {}); p.index + 4 < l; )
                g = p.readInt(2), n = p.readInt(2), i = p.readData(n), this.extraFields[g] = { id: g, length: n, value: i };
              p.setIndex(l);
            }, handleUTF8: function() {
              var p = d.uint8array ? "uint8array" : "array";
              if (this.useUTF8())
                this.fileNameStr = y.utf8decode(this.fileName), this.fileCommentStr = y.utf8decode(this.fileComment);
              else {
                var g = this.findExtraFieldUnicodePath();
                if (g !== null)
                  this.fileNameStr = g;
                else {
                  var n = v.transformTo(p, this.fileName);
                  this.fileNameStr = this.loadOptions.decodeFileName(n);
                }
                var i = this.findExtraFieldUnicodeComment();
                if (i !== null)
                  this.fileCommentStr = i;
                else {
                  var l = v.transformTo(p, this.fileComment);
                  this.fileCommentStr = this.loadOptions.decodeFileName(l);
                }
              }
            }, findExtraFieldUnicodePath: function() {
              var p = this.extraFields[28789];
              if (p) {
                var g = a(p.value);
                return g.readInt(1) !== 1 || e(this.fileName) !== g.readInt(4) ? null : y.utf8decode(g.readData(p.length - 5));
              }
              return null;
            }, findExtraFieldUnicodeComment: function() {
              var p = this.extraFields[25461];
              if (p) {
                var g = a(p.value);
                return g.readInt(1) !== 1 || e(this.fileComment) !== g.readInt(4) ? null : y.utf8decode(g.readData(p.length - 5));
              }
              return null;
            } }, F.exports = m;
          }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(o, F, t) {
            function a(g, n, i) {
              this.name = g, this.dir = i.dir, this.date = i.date, this.comment = i.comment, this.unixPermissions = i.unixPermissions, this.dosPermissions = i.dosPermissions, this._data = n, this._dataBinary = i.binary, this.options = { compression: i.compression, compressionOptions: i.compressionOptions };
            }
            var v = o("./stream/StreamHelper"), h = o("./stream/DataWorker"), e = o("./utf8"), y = o("./compressedObject"), c = o("./stream/GenericWorker");
            a.prototype = { internalStream: function(g) {
              var n = null, i = "string";
              try {
                if (!g)
                  throw new Error("No output type specified.");
                var l = (i = g.toLowerCase()) === "string" || i === "text";
                i !== "binarystring" && i !== "text" || (i = "string"), n = this._decompressWorker();
                var u = !this._dataBinary;
                u && !l && (n = n.pipe(new e.Utf8EncodeWorker())), !u && l && (n = n.pipe(new e.Utf8DecodeWorker()));
              } catch (w) {
                (n = new c("error")).error(w);
              }
              return new v(n, i, "");
            }, async: function(g, n) {
              return this.internalStream(g).accumulate(n);
            }, nodeStream: function(g, n) {
              return this.internalStream(g || "nodebuffer").toNodejsStream(n);
            }, _compressWorker: function(g, n) {
              if (this._data instanceof y && this._data.compression.magic === g.magic)
                return this._data.getCompressedWorker();
              var i = this._decompressWorker();
              return this._dataBinary || (i = i.pipe(new e.Utf8EncodeWorker())), y.createWorkerFrom(i, g, n);
            }, _decompressWorker: function() {
              return this._data instanceof y ? this._data.getContentWorker() : this._data instanceof c ? this._data : new h(this._data);
            } };
            for (var d = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], m = function() {
              throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
            }, p = 0; p < d.length; p++)
              a.prototype[d[p]] = m;
            F.exports = a;
          }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(o, F, t) {
            (function(a) {
              var v, h, e = a.MutationObserver || a.WebKitMutationObserver;
              if (e) {
                var y = 0, c = new e(g), d = a.document.createTextNode("");
                c.observe(d, { characterData: !0 }), v = function() {
                  d.data = y = ++y % 2;
                };
              } else if (a.setImmediate || a.MessageChannel === void 0)
                v = "document" in a && "onreadystatechange" in a.document.createElement("script") ? function() {
                  var n = a.document.createElement("script");
                  n.onreadystatechange = function() {
                    g(), n.onreadystatechange = null, n.parentNode.removeChild(n), n = null;
                  }, a.document.documentElement.appendChild(n);
                } : function() {
                  setTimeout(g, 0);
                };
              else {
                var m = new a.MessageChannel();
                m.port1.onmessage = g, v = function() {
                  m.port2.postMessage(0);
                };
              }
              var p = [];
              function g() {
                var n, i;
                h = !0;
                for (var l = p.length; l; ) {
                  for (i = p, p = [], n = -1; ++n < l; )
                    i[n]();
                  l = p.length;
                }
                h = !1;
              }
              F.exports = function(n) {
                p.push(n) !== 1 || h || v();
              };
            }).call(this, typeof ae < "u" ? ae : typeof self < "u" ? self : typeof window < "u" ? window : {});
          }, {}], 37: [function(o, F, t) {
            var a = o("immediate");
            function v() {
            }
            var h = {}, e = ["REJECTED"], y = ["FULFILLED"], c = ["PENDING"];
            function d(l) {
              if (typeof l != "function")
                throw new TypeError("resolver must be a function");
              this.state = c, this.queue = [], this.outcome = void 0, l !== v && n(this, l);
            }
            function m(l, u, w) {
              this.promise = l, typeof u == "function" && (this.onFulfilled = u, this.callFulfilled = this.otherCallFulfilled), typeof w == "function" && (this.onRejected = w, this.callRejected = this.otherCallRejected);
            }
            function p(l, u, w) {
              a(function() {
                var O;
                try {
                  O = u(w);
                } catch (b) {
                  return h.reject(l, b);
                }
                O === l ? h.reject(l, new TypeError("Cannot resolve promise with itself")) : h.resolve(l, O);
              });
            }
            function g(l) {
              var u = l && l.then;
              if (l && (typeof l == "object" || typeof l == "function") && typeof u == "function")
                return function() {
                  u.apply(l, arguments);
                };
            }
            function n(l, u) {
              var w = !1;
              function O(Y) {
                w || (w = !0, h.reject(l, Y));
              }
              function b(Y) {
                w || (w = !0, h.resolve(l, Y));
              }
              var A = i(function() {
                u(b, O);
              });
              A.status === "error" && O(A.value);
            }
            function i(l, u) {
              var w = {};
              try {
                w.value = l(u), w.status = "success";
              } catch (O) {
                w.status = "error", w.value = O;
              }
              return w;
            }
            (F.exports = d).prototype.finally = function(l) {
              if (typeof l != "function")
                return this;
              var u = this.constructor;
              return this.then(function(w) {
                return u.resolve(l()).then(function() {
                  return w;
                });
              }, function(w) {
                return u.resolve(l()).then(function() {
                  throw w;
                });
              });
            }, d.prototype.catch = function(l) {
              return this.then(null, l);
            }, d.prototype.then = function(l, u) {
              if (typeof l != "function" && this.state === y || typeof u != "function" && this.state === e)
                return this;
              var w = new this.constructor(v);
              return this.state !== c ? p(w, this.state === y ? l : u, this.outcome) : this.queue.push(new m(w, l, u)), w;
            }, m.prototype.callFulfilled = function(l) {
              h.resolve(this.promise, l);
            }, m.prototype.otherCallFulfilled = function(l) {
              p(this.promise, this.onFulfilled, l);
            }, m.prototype.callRejected = function(l) {
              h.reject(this.promise, l);
            }, m.prototype.otherCallRejected = function(l) {
              p(this.promise, this.onRejected, l);
            }, h.resolve = function(l, u) {
              var w = i(g, u);
              if (w.status === "error")
                return h.reject(l, w.value);
              var O = w.value;
              if (O)
                n(l, O);
              else {
                l.state = y, l.outcome = u;
                for (var b = -1, A = l.queue.length; ++b < A; )
                  l.queue[b].callFulfilled(u);
              }
              return l;
            }, h.reject = function(l, u) {
              l.state = e, l.outcome = u;
              for (var w = -1, O = l.queue.length; ++w < O; )
                l.queue[w].callRejected(u);
              return l;
            }, d.resolve = function(l) {
              return l instanceof this ? l : h.resolve(new this(v), l);
            }, d.reject = function(l) {
              var u = new this(v);
              return h.reject(u, l);
            }, d.all = function(l) {
              var u = this;
              if (Object.prototype.toString.call(l) !== "[object Array]")
                return this.reject(new TypeError("must be an array"));
              var w = l.length, O = !1;
              if (!w)
                return this.resolve([]);
              for (var b = new Array(w), A = 0, Y = -1, j = new this(v); ++Y < w; )
                X(l[Y], Y);
              return j;
              function X(B, U) {
                u.resolve(B).then(function(k) {
                  b[U] = k, ++A !== w || O || (O = !0, h.resolve(j, b));
                }, function(k) {
                  O || (O = !0, h.reject(j, k));
                });
              }
            }, d.race = function(l) {
              var u = this;
              if (Object.prototype.toString.call(l) !== "[object Array]")
                return this.reject(new TypeError("must be an array"));
              var w = l.length, O = !1;
              if (!w)
                return this.resolve([]);
              for (var b = -1, A = new this(v); ++b < w; )
                Y = l[b], u.resolve(Y).then(function(j) {
                  O || (O = !0, h.resolve(A, j));
                }, function(j) {
                  O || (O = !0, h.reject(A, j));
                });
              var Y;
              return A;
            };
          }, { immediate: 36 }], 38: [function(o, F, t) {
            var a = {};
            (0, o("./lib/utils/common").assign)(a, o("./lib/deflate"), o("./lib/inflate"), o("./lib/zlib/constants")), F.exports = a;
          }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(o, F, t) {
            var a = o("./zlib/deflate"), v = o("./utils/common"), h = o("./utils/strings"), e = o("./zlib/messages"), y = o("./zlib/zstream"), c = Object.prototype.toString, d = 0, m = -1, p = 0, g = 8;
            function n(l) {
              if (!(this instanceof n))
                return new n(l);
              this.options = v.assign({ level: m, method: g, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: p, to: "" }, l || {});
              var u = this.options;
              u.raw && 0 < u.windowBits ? u.windowBits = -u.windowBits : u.gzip && 0 < u.windowBits && u.windowBits < 16 && (u.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new y(), this.strm.avail_out = 0;
              var w = a.deflateInit2(this.strm, u.level, u.method, u.windowBits, u.memLevel, u.strategy);
              if (w !== d)
                throw new Error(e[w]);
              if (u.header && a.deflateSetHeader(this.strm, u.header), u.dictionary) {
                var O;
                if (O = typeof u.dictionary == "string" ? h.string2buf(u.dictionary) : c.call(u.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(u.dictionary) : u.dictionary, (w = a.deflateSetDictionary(this.strm, O)) !== d)
                  throw new Error(e[w]);
                this._dict_set = !0;
              }
            }
            function i(l, u) {
              var w = new n(u);
              if (w.push(l, !0), w.err)
                throw w.msg || e[w.err];
              return w.result;
            }
            n.prototype.push = function(l, u) {
              var w, O, b = this.strm, A = this.options.chunkSize;
              if (this.ended)
                return !1;
              O = u === ~~u ? u : u === !0 ? 4 : 0, typeof l == "string" ? b.input = h.string2buf(l) : c.call(l) === "[object ArrayBuffer]" ? b.input = new Uint8Array(l) : b.input = l, b.next_in = 0, b.avail_in = b.input.length;
              do {
                if (b.avail_out === 0 && (b.output = new v.Buf8(A), b.next_out = 0, b.avail_out = A), (w = a.deflate(b, O)) !== 1 && w !== d)
                  return this.onEnd(w), !(this.ended = !0);
                b.avail_out !== 0 && (b.avail_in !== 0 || O !== 4 && O !== 2) || (this.options.to === "string" ? this.onData(h.buf2binstring(v.shrinkBuf(b.output, b.next_out))) : this.onData(v.shrinkBuf(b.output, b.next_out)));
              } while ((0 < b.avail_in || b.avail_out === 0) && w !== 1);
              return O === 4 ? (w = a.deflateEnd(this.strm), this.onEnd(w), this.ended = !0, w === d) : O !== 2 || (this.onEnd(d), !(b.avail_out = 0));
            }, n.prototype.onData = function(l) {
              this.chunks.push(l);
            }, n.prototype.onEnd = function(l) {
              l === d && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = v.flattenChunks(this.chunks)), this.chunks = [], this.err = l, this.msg = this.strm.msg;
            }, t.Deflate = n, t.deflate = i, t.deflateRaw = function(l, u) {
              return (u = u || {}).raw = !0, i(l, u);
            }, t.gzip = function(l, u) {
              return (u = u || {}).gzip = !0, i(l, u);
            };
          }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(o, F, t) {
            var a = o("./zlib/inflate"), v = o("./utils/common"), h = o("./utils/strings"), e = o("./zlib/constants"), y = o("./zlib/messages"), c = o("./zlib/zstream"), d = o("./zlib/gzheader"), m = Object.prototype.toString;
            function p(n) {
              if (!(this instanceof p))
                return new p(n);
              this.options = v.assign({ chunkSize: 16384, windowBits: 0, to: "" }, n || {});
              var i = this.options;
              i.raw && 0 <= i.windowBits && i.windowBits < 16 && (i.windowBits = -i.windowBits, i.windowBits === 0 && (i.windowBits = -15)), !(0 <= i.windowBits && i.windowBits < 16) || n && n.windowBits || (i.windowBits += 32), 15 < i.windowBits && i.windowBits < 48 && !(15 & i.windowBits) && (i.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new c(), this.strm.avail_out = 0;
              var l = a.inflateInit2(this.strm, i.windowBits);
              if (l !== e.Z_OK)
                throw new Error(y[l]);
              this.header = new d(), a.inflateGetHeader(this.strm, this.header);
            }
            function g(n, i) {
              var l = new p(i);
              if (l.push(n, !0), l.err)
                throw l.msg || y[l.err];
              return l.result;
            }
            p.prototype.push = function(n, i) {
              var l, u, w, O, b, A, Y = this.strm, j = this.options.chunkSize, X = this.options.dictionary, B = !1;
              if (this.ended)
                return !1;
              u = i === ~~i ? i : i === !0 ? e.Z_FINISH : e.Z_NO_FLUSH, typeof n == "string" ? Y.input = h.binstring2buf(n) : m.call(n) === "[object ArrayBuffer]" ? Y.input = new Uint8Array(n) : Y.input = n, Y.next_in = 0, Y.avail_in = Y.input.length;
              do {
                if (Y.avail_out === 0 && (Y.output = new v.Buf8(j), Y.next_out = 0, Y.avail_out = j), (l = a.inflate(Y, e.Z_NO_FLUSH)) === e.Z_NEED_DICT && X && (A = typeof X == "string" ? h.string2buf(X) : m.call(X) === "[object ArrayBuffer]" ? new Uint8Array(X) : X, l = a.inflateSetDictionary(this.strm, A)), l === e.Z_BUF_ERROR && B === !0 && (l = e.Z_OK, B = !1), l !== e.Z_STREAM_END && l !== e.Z_OK)
                  return this.onEnd(l), !(this.ended = !0);
                Y.next_out && (Y.avail_out !== 0 && l !== e.Z_STREAM_END && (Y.avail_in !== 0 || u !== e.Z_FINISH && u !== e.Z_SYNC_FLUSH) || (this.options.to === "string" ? (w = h.utf8border(Y.output, Y.next_out), O = Y.next_out - w, b = h.buf2string(Y.output, w), Y.next_out = O, Y.avail_out = j - O, O && v.arraySet(Y.output, Y.output, w, O, 0), this.onData(b)) : this.onData(v.shrinkBuf(Y.output, Y.next_out)))), Y.avail_in === 0 && Y.avail_out === 0 && (B = !0);
              } while ((0 < Y.avail_in || Y.avail_out === 0) && l !== e.Z_STREAM_END);
              return l === e.Z_STREAM_END && (u = e.Z_FINISH), u === e.Z_FINISH ? (l = a.inflateEnd(this.strm), this.onEnd(l), this.ended = !0, l === e.Z_OK) : u !== e.Z_SYNC_FLUSH || (this.onEnd(e.Z_OK), !(Y.avail_out = 0));
            }, p.prototype.onData = function(n) {
              this.chunks.push(n);
            }, p.prototype.onEnd = function(n) {
              n === e.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = v.flattenChunks(this.chunks)), this.chunks = [], this.err = n, this.msg = this.strm.msg;
            }, t.Inflate = p, t.inflate = g, t.inflateRaw = function(n, i) {
              return (i = i || {}).raw = !0, g(n, i);
            }, t.ungzip = g;
          }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(o, F, t) {
            var a = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
            t.assign = function(e) {
              for (var y = Array.prototype.slice.call(arguments, 1); y.length; ) {
                var c = y.shift();
                if (c) {
                  if (typeof c != "object")
                    throw new TypeError(c + "must be non-object");
                  for (var d in c)
                    c.hasOwnProperty(d) && (e[d] = c[d]);
                }
              }
              return e;
            }, t.shrinkBuf = function(e, y) {
              return e.length === y ? e : e.subarray ? e.subarray(0, y) : (e.length = y, e);
            };
            var v = { arraySet: function(e, y, c, d, m) {
              if (y.subarray && e.subarray)
                e.set(y.subarray(c, c + d), m);
              else
                for (var p = 0; p < d; p++)
                  e[m + p] = y[c + p];
            }, flattenChunks: function(e) {
              var y, c, d, m, p, g;
              for (y = d = 0, c = e.length; y < c; y++)
                d += e[y].length;
              for (g = new Uint8Array(d), y = m = 0, c = e.length; y < c; y++)
                p = e[y], g.set(p, m), m += p.length;
              return g;
            } }, h = { arraySet: function(e, y, c, d, m) {
              for (var p = 0; p < d; p++)
                e[m + p] = y[c + p];
            }, flattenChunks: function(e) {
              return [].concat.apply([], e);
            } };
            t.setTyped = function(e) {
              e ? (t.Buf8 = Uint8Array, t.Buf16 = Uint16Array, t.Buf32 = Int32Array, t.assign(t, v)) : (t.Buf8 = Array, t.Buf16 = Array, t.Buf32 = Array, t.assign(t, h));
            }, t.setTyped(a);
          }, {}], 42: [function(o, F, t) {
            var a = o("./common"), v = !0, h = !0;
            try {
              String.fromCharCode.apply(null, [0]);
            } catch {
              v = !1;
            }
            try {
              String.fromCharCode.apply(null, new Uint8Array(1));
            } catch {
              h = !1;
            }
            for (var e = new a.Buf8(256), y = 0; y < 256; y++)
              e[y] = 252 <= y ? 6 : 248 <= y ? 5 : 240 <= y ? 4 : 224 <= y ? 3 : 192 <= y ? 2 : 1;
            function c(d, m) {
              if (m < 65537 && (d.subarray && h || !d.subarray && v))
                return String.fromCharCode.apply(null, a.shrinkBuf(d, m));
              for (var p = "", g = 0; g < m; g++)
                p += String.fromCharCode(d[g]);
              return p;
            }
            e[254] = e[254] = 1, t.string2buf = function(d) {
              var m, p, g, n, i, l = d.length, u = 0;
              for (n = 0; n < l; n++)
                (64512 & (p = d.charCodeAt(n))) == 55296 && n + 1 < l && (64512 & (g = d.charCodeAt(n + 1))) == 56320 && (p = 65536 + (p - 55296 << 10) + (g - 56320), n++), u += p < 128 ? 1 : p < 2048 ? 2 : p < 65536 ? 3 : 4;
              for (m = new a.Buf8(u), n = i = 0; i < u; n++)
                (64512 & (p = d.charCodeAt(n))) == 55296 && n + 1 < l && (64512 & (g = d.charCodeAt(n + 1))) == 56320 && (p = 65536 + (p - 55296 << 10) + (g - 56320), n++), p < 128 ? m[i++] = p : (p < 2048 ? m[i++] = 192 | p >>> 6 : (p < 65536 ? m[i++] = 224 | p >>> 12 : (m[i++] = 240 | p >>> 18, m[i++] = 128 | p >>> 12 & 63), m[i++] = 128 | p >>> 6 & 63), m[i++] = 128 | 63 & p);
              return m;
            }, t.buf2binstring = function(d) {
              return c(d, d.length);
            }, t.binstring2buf = function(d) {
              for (var m = new a.Buf8(d.length), p = 0, g = m.length; p < g; p++)
                m[p] = d.charCodeAt(p);
              return m;
            }, t.buf2string = function(d, m) {
              var p, g, n, i, l = m || d.length, u = new Array(2 * l);
              for (p = g = 0; p < l; )
                if ((n = d[p++]) < 128)
                  u[g++] = n;
                else if (4 < (i = e[n]))
                  u[g++] = 65533, p += i - 1;
                else {
                  for (n &= i === 2 ? 31 : i === 3 ? 15 : 7; 1 < i && p < l; )
                    n = n << 6 | 63 & d[p++], i--;
                  1 < i ? u[g++] = 65533 : n < 65536 ? u[g++] = n : (n -= 65536, u[g++] = 55296 | n >> 10 & 1023, u[g++] = 56320 | 1023 & n);
                }
              return c(u, g);
            }, t.utf8border = function(d, m) {
              var p;
              for ((m = m || d.length) > d.length && (m = d.length), p = m - 1; 0 <= p && (192 & d[p]) == 128; )
                p--;
              return p < 0 || p === 0 ? m : p + e[d[p]] > m ? p : m;
            };
          }, { "./common": 41 }], 43: [function(o, F, t) {
            F.exports = function(a, v, h, e) {
              for (var y = 65535 & a | 0, c = a >>> 16 & 65535 | 0, d = 0; h !== 0; ) {
                for (h -= d = 2e3 < h ? 2e3 : h; c = c + (y = y + v[e++] | 0) | 0, --d; )
                  ;
                y %= 65521, c %= 65521;
              }
              return y | c << 16 | 0;
            };
          }, {}], 44: [function(o, F, t) {
            F.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
          }, {}], 45: [function(o, F, t) {
            var a = function() {
              for (var v, h = [], e = 0; e < 256; e++) {
                v = e;
                for (var y = 0; y < 8; y++)
                  v = 1 & v ? 3988292384 ^ v >>> 1 : v >>> 1;
                h[e] = v;
              }
              return h;
            }();
            F.exports = function(v, h, e, y) {
              var c = a, d = y + e;
              v ^= -1;
              for (var m = y; m < d; m++)
                v = v >>> 8 ^ c[255 & (v ^ h[m])];
              return -1 ^ v;
            };
          }, {}], 46: [function(o, F, t) {
            var a, v = o("../utils/common"), h = o("./trees"), e = o("./adler32"), y = o("./crc32"), c = o("./messages"), d = 0, m = 4, p = 0, g = -2, n = -1, i = 4, l = 2, u = 8, w = 9, O = 286, b = 30, A = 19, Y = 2 * O + 1, j = 15, X = 3, B = 258, U = B + X + 1, k = 42, x = 113, f = 1, D = 2, _ = 3, S = 4;
            function C(E, te) {
              return E.msg = c[te], te;
            }
            function T(E) {
              return (E << 1) - (4 < E ? 9 : 0);
            }
            function P(E) {
              for (var te = E.length; 0 <= --te; )
                E[te] = 0;
            }
            function M(E) {
              var te = E.state, oe = te.pending;
              oe > E.avail_out && (oe = E.avail_out), oe !== 0 && (v.arraySet(E.output, te.pending_buf, te.pending_out, oe, E.next_out), E.next_out += oe, te.pending_out += oe, E.total_out += oe, E.avail_out -= oe, te.pending -= oe, te.pending === 0 && (te.pending_out = 0));
            }
            function G(E, te) {
              h._tr_flush_block(E, 0 <= E.block_start ? E.block_start : -1, E.strstart - E.block_start, te), E.block_start = E.strstart, M(E.strm);
            }
            function Z(E, te) {
              E.pending_buf[E.pending++] = te;
            }
            function $(E, te) {
              E.pending_buf[E.pending++] = te >>> 8 & 255, E.pending_buf[E.pending++] = 255 & te;
            }
            function z(E, te) {
              var oe, ee, W = E.max_chain_length, I = E.strstart, H = E.prev_length, ie = E.nice_match, ue = E.strstart > E.w_size - U ? E.strstart - (E.w_size - U) : 0, fe = E.window, de = E.w_mask, pe = E.prev, xe = E.strstart + B, Fe = fe[I + H - 1], Se = fe[I + H];
              E.prev_length >= E.good_match && (W >>= 2), ie > E.lookahead && (ie = E.lookahead);
              do
                if (fe[(oe = te) + H] === Se && fe[oe + H - 1] === Fe && fe[oe] === fe[I] && fe[++oe] === fe[I + 1]) {
                  I += 2, oe++;
                  do
                    ;
                  while (fe[++I] === fe[++oe] && fe[++I] === fe[++oe] && fe[++I] === fe[++oe] && fe[++I] === fe[++oe] && fe[++I] === fe[++oe] && fe[++I] === fe[++oe] && fe[++I] === fe[++oe] && fe[++I] === fe[++oe] && I < xe);
                  if (ee = B - (xe - I), I = xe - B, H < ee) {
                    if (E.match_start = te, ie <= (H = ee))
                      break;
                    Fe = fe[I + H - 1], Se = fe[I + H];
                  }
                }
              while ((te = pe[te & de]) > ue && --W != 0);
              return H <= E.lookahead ? H : E.lookahead;
            }
            function V(E) {
              var te, oe, ee, W, I, H, ie, ue, fe, de, pe = E.w_size;
              do {
                if (W = E.window_size - E.lookahead - E.strstart, E.strstart >= pe + (pe - U)) {
                  for (v.arraySet(E.window, E.window, pe, pe, 0), E.match_start -= pe, E.strstart -= pe, E.block_start -= pe, te = oe = E.hash_size; ee = E.head[--te], E.head[te] = pe <= ee ? ee - pe : 0, --oe; )
                    ;
                  for (te = oe = pe; ee = E.prev[--te], E.prev[te] = pe <= ee ? ee - pe : 0, --oe; )
                    ;
                  W += pe;
                }
                if (E.strm.avail_in === 0)
                  break;
                if (H = E.strm, ie = E.window, ue = E.strstart + E.lookahead, fe = W, de = void 0, de = H.avail_in, fe < de && (de = fe), oe = de === 0 ? 0 : (H.avail_in -= de, v.arraySet(ie, H.input, H.next_in, de, ue), H.state.wrap === 1 ? H.adler = e(H.adler, ie, de, ue) : H.state.wrap === 2 && (H.adler = y(H.adler, ie, de, ue)), H.next_in += de, H.total_in += de, de), E.lookahead += oe, E.lookahead + E.insert >= X)
                  for (I = E.strstart - E.insert, E.ins_h = E.window[I], E.ins_h = (E.ins_h << E.hash_shift ^ E.window[I + 1]) & E.hash_mask; E.insert && (E.ins_h = (E.ins_h << E.hash_shift ^ E.window[I + X - 1]) & E.hash_mask, E.prev[I & E.w_mask] = E.head[E.ins_h], E.head[E.ins_h] = I, I++, E.insert--, !(E.lookahead + E.insert < X)); )
                    ;
              } while (E.lookahead < U && E.strm.avail_in !== 0);
            }
            function L(E, te) {
              for (var oe, ee; ; ) {
                if (E.lookahead < U) {
                  if (V(E), E.lookahead < U && te === d)
                    return f;
                  if (E.lookahead === 0)
                    break;
                }
                if (oe = 0, E.lookahead >= X && (E.ins_h = (E.ins_h << E.hash_shift ^ E.window[E.strstart + X - 1]) & E.hash_mask, oe = E.prev[E.strstart & E.w_mask] = E.head[E.ins_h], E.head[E.ins_h] = E.strstart), oe !== 0 && E.strstart - oe <= E.w_size - U && (E.match_length = z(E, oe)), E.match_length >= X)
                  if (ee = h._tr_tally(E, E.strstart - E.match_start, E.match_length - X), E.lookahead -= E.match_length, E.match_length <= E.max_lazy_match && E.lookahead >= X) {
                    for (E.match_length--; E.strstart++, E.ins_h = (E.ins_h << E.hash_shift ^ E.window[E.strstart + X - 1]) & E.hash_mask, oe = E.prev[E.strstart & E.w_mask] = E.head[E.ins_h], E.head[E.ins_h] = E.strstart, --E.match_length != 0; )
                      ;
                    E.strstart++;
                  } else
                    E.strstart += E.match_length, E.match_length = 0, E.ins_h = E.window[E.strstart], E.ins_h = (E.ins_h << E.hash_shift ^ E.window[E.strstart + 1]) & E.hash_mask;
                else
                  ee = h._tr_tally(E, 0, E.window[E.strstart]), E.lookahead--, E.strstart++;
                if (ee && (G(E, !1), E.strm.avail_out === 0))
                  return f;
              }
              return E.insert = E.strstart < X - 1 ? E.strstart : X - 1, te === m ? (G(E, !0), E.strm.avail_out === 0 ? _ : S) : E.last_lit && (G(E, !1), E.strm.avail_out === 0) ? f : D;
            }
            function K(E, te) {
              for (var oe, ee, W; ; ) {
                if (E.lookahead < U) {
                  if (V(E), E.lookahead < U && te === d)
                    return f;
                  if (E.lookahead === 0)
                    break;
                }
                if (oe = 0, E.lookahead >= X && (E.ins_h = (E.ins_h << E.hash_shift ^ E.window[E.strstart + X - 1]) & E.hash_mask, oe = E.prev[E.strstart & E.w_mask] = E.head[E.ins_h], E.head[E.ins_h] = E.strstart), E.prev_length = E.match_length, E.prev_match = E.match_start, E.match_length = X - 1, oe !== 0 && E.prev_length < E.max_lazy_match && E.strstart - oe <= E.w_size - U && (E.match_length = z(E, oe), E.match_length <= 5 && (E.strategy === 1 || E.match_length === X && 4096 < E.strstart - E.match_start) && (E.match_length = X - 1)), E.prev_length >= X && E.match_length <= E.prev_length) {
                  for (W = E.strstart + E.lookahead - X, ee = h._tr_tally(E, E.strstart - 1 - E.prev_match, E.prev_length - X), E.lookahead -= E.prev_length - 1, E.prev_length -= 2; ++E.strstart <= W && (E.ins_h = (E.ins_h << E.hash_shift ^ E.window[E.strstart + X - 1]) & E.hash_mask, oe = E.prev[E.strstart & E.w_mask] = E.head[E.ins_h], E.head[E.ins_h] = E.strstart), --E.prev_length != 0; )
                    ;
                  if (E.match_available = 0, E.match_length = X - 1, E.strstart++, ee && (G(E, !1), E.strm.avail_out === 0))
                    return f;
                } else if (E.match_available) {
                  if ((ee = h._tr_tally(E, 0, E.window[E.strstart - 1])) && G(E, !1), E.strstart++, E.lookahead--, E.strm.avail_out === 0)
                    return f;
                } else
                  E.match_available = 1, E.strstart++, E.lookahead--;
              }
              return E.match_available && (ee = h._tr_tally(E, 0, E.window[E.strstart - 1]), E.match_available = 0), E.insert = E.strstart < X - 1 ? E.strstart : X - 1, te === m ? (G(E, !0), E.strm.avail_out === 0 ? _ : S) : E.last_lit && (G(E, !1), E.strm.avail_out === 0) ? f : D;
            }
            function ne(E, te, oe, ee, W) {
              this.good_length = E, this.max_lazy = te, this.nice_length = oe, this.max_chain = ee, this.func = W;
            }
            function se() {
              this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = u, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new v.Buf16(2 * Y), this.dyn_dtree = new v.Buf16(2 * (2 * b + 1)), this.bl_tree = new v.Buf16(2 * (2 * A + 1)), P(this.dyn_ltree), P(this.dyn_dtree), P(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new v.Buf16(j + 1), this.heap = new v.Buf16(2 * O + 1), P(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new v.Buf16(2 * O + 1), P(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
            }
            function q(E) {
              var te;
              return E && E.state ? (E.total_in = E.total_out = 0, E.data_type = l, (te = E.state).pending = 0, te.pending_out = 0, te.wrap < 0 && (te.wrap = -te.wrap), te.status = te.wrap ? k : x, E.adler = te.wrap === 2 ? 0 : 1, te.last_flush = d, h._tr_init(te), p) : C(E, g);
            }
            function N(E) {
              var te = q(E);
              return te === p && function(oe) {
                oe.window_size = 2 * oe.w_size, P(oe.head), oe.max_lazy_match = a[oe.level].max_lazy, oe.good_match = a[oe.level].good_length, oe.nice_match = a[oe.level].nice_length, oe.max_chain_length = a[oe.level].max_chain, oe.strstart = 0, oe.block_start = 0, oe.lookahead = 0, oe.insert = 0, oe.match_length = oe.prev_length = X - 1, oe.match_available = 0, oe.ins_h = 0;
              }(E.state), te;
            }
            function Q(E, te, oe, ee, W, I) {
              if (!E)
                return g;
              var H = 1;
              if (te === n && (te = 6), ee < 0 ? (H = 0, ee = -ee) : 15 < ee && (H = 2, ee -= 16), W < 1 || w < W || oe !== u || ee < 8 || 15 < ee || te < 0 || 9 < te || I < 0 || i < I)
                return C(E, g);
              ee === 8 && (ee = 9);
              var ie = new se();
              return (E.state = ie).strm = E, ie.wrap = H, ie.gzhead = null, ie.w_bits = ee, ie.w_size = 1 << ie.w_bits, ie.w_mask = ie.w_size - 1, ie.hash_bits = W + 7, ie.hash_size = 1 << ie.hash_bits, ie.hash_mask = ie.hash_size - 1, ie.hash_shift = ~~((ie.hash_bits + X - 1) / X), ie.window = new v.Buf8(2 * ie.w_size), ie.head = new v.Buf16(ie.hash_size), ie.prev = new v.Buf16(ie.w_size), ie.lit_bufsize = 1 << W + 6, ie.pending_buf_size = 4 * ie.lit_bufsize, ie.pending_buf = new v.Buf8(ie.pending_buf_size), ie.d_buf = 1 * ie.lit_bufsize, ie.l_buf = 3 * ie.lit_bufsize, ie.level = te, ie.strategy = I, ie.method = oe, N(E);
            }
            a = [new ne(0, 0, 0, 0, function(E, te) {
              var oe = 65535;
              for (oe > E.pending_buf_size - 5 && (oe = E.pending_buf_size - 5); ; ) {
                if (E.lookahead <= 1) {
                  if (V(E), E.lookahead === 0 && te === d)
                    return f;
                  if (E.lookahead === 0)
                    break;
                }
                E.strstart += E.lookahead, E.lookahead = 0;
                var ee = E.block_start + oe;
                if ((E.strstart === 0 || E.strstart >= ee) && (E.lookahead = E.strstart - ee, E.strstart = ee, G(E, !1), E.strm.avail_out === 0) || E.strstart - E.block_start >= E.w_size - U && (G(E, !1), E.strm.avail_out === 0))
                  return f;
              }
              return E.insert = 0, te === m ? (G(E, !0), E.strm.avail_out === 0 ? _ : S) : (E.strstart > E.block_start && (G(E, !1), E.strm.avail_out), f);
            }), new ne(4, 4, 8, 4, L), new ne(4, 5, 16, 8, L), new ne(4, 6, 32, 32, L), new ne(4, 4, 16, 16, K), new ne(8, 16, 32, 32, K), new ne(8, 16, 128, 128, K), new ne(8, 32, 128, 256, K), new ne(32, 128, 258, 1024, K), new ne(32, 258, 258, 4096, K)], t.deflateInit = function(E, te) {
              return Q(E, te, u, 15, 8, 0);
            }, t.deflateInit2 = Q, t.deflateReset = N, t.deflateResetKeep = q, t.deflateSetHeader = function(E, te) {
              return E && E.state ? E.state.wrap !== 2 ? g : (E.state.gzhead = te, p) : g;
            }, t.deflate = function(E, te) {
              var oe, ee, W, I;
              if (!E || !E.state || 5 < te || te < 0)
                return E ? C(E, g) : g;
              if (ee = E.state, !E.output || !E.input && E.avail_in !== 0 || ee.status === 666 && te !== m)
                return C(E, E.avail_out === 0 ? -5 : g);
              if (ee.strm = E, oe = ee.last_flush, ee.last_flush = te, ee.status === k)
                if (ee.wrap === 2)
                  E.adler = 0, Z(ee, 31), Z(ee, 139), Z(ee, 8), ee.gzhead ? (Z(ee, (ee.gzhead.text ? 1 : 0) + (ee.gzhead.hcrc ? 2 : 0) + (ee.gzhead.extra ? 4 : 0) + (ee.gzhead.name ? 8 : 0) + (ee.gzhead.comment ? 16 : 0)), Z(ee, 255 & ee.gzhead.time), Z(ee, ee.gzhead.time >> 8 & 255), Z(ee, ee.gzhead.time >> 16 & 255), Z(ee, ee.gzhead.time >> 24 & 255), Z(ee, ee.level === 9 ? 2 : 2 <= ee.strategy || ee.level < 2 ? 4 : 0), Z(ee, 255 & ee.gzhead.os), ee.gzhead.extra && ee.gzhead.extra.length && (Z(ee, 255 & ee.gzhead.extra.length), Z(ee, ee.gzhead.extra.length >> 8 & 255)), ee.gzhead.hcrc && (E.adler = y(E.adler, ee.pending_buf, ee.pending, 0)), ee.gzindex = 0, ee.status = 69) : (Z(ee, 0), Z(ee, 0), Z(ee, 0), Z(ee, 0), Z(ee, 0), Z(ee, ee.level === 9 ? 2 : 2 <= ee.strategy || ee.level < 2 ? 4 : 0), Z(ee, 3), ee.status = x);
                else {
                  var H = u + (ee.w_bits - 8 << 4) << 8;
                  H |= (2 <= ee.strategy || ee.level < 2 ? 0 : ee.level < 6 ? 1 : ee.level === 6 ? 2 : 3) << 6, ee.strstart !== 0 && (H |= 32), H += 31 - H % 31, ee.status = x, $(ee, H), ee.strstart !== 0 && ($(ee, E.adler >>> 16), $(ee, 65535 & E.adler)), E.adler = 1;
                }
              if (ee.status === 69)
                if (ee.gzhead.extra) {
                  for (W = ee.pending; ee.gzindex < (65535 & ee.gzhead.extra.length) && (ee.pending !== ee.pending_buf_size || (ee.gzhead.hcrc && ee.pending > W && (E.adler = y(E.adler, ee.pending_buf, ee.pending - W, W)), M(E), W = ee.pending, ee.pending !== ee.pending_buf_size)); )
                    Z(ee, 255 & ee.gzhead.extra[ee.gzindex]), ee.gzindex++;
                  ee.gzhead.hcrc && ee.pending > W && (E.adler = y(E.adler, ee.pending_buf, ee.pending - W, W)), ee.gzindex === ee.gzhead.extra.length && (ee.gzindex = 0, ee.status = 73);
                } else
                  ee.status = 73;
              if (ee.status === 73)
                if (ee.gzhead.name) {
                  W = ee.pending;
                  do {
                    if (ee.pending === ee.pending_buf_size && (ee.gzhead.hcrc && ee.pending > W && (E.adler = y(E.adler, ee.pending_buf, ee.pending - W, W)), M(E), W = ee.pending, ee.pending === ee.pending_buf_size)) {
                      I = 1;
                      break;
                    }
                    I = ee.gzindex < ee.gzhead.name.length ? 255 & ee.gzhead.name.charCodeAt(ee.gzindex++) : 0, Z(ee, I);
                  } while (I !== 0);
                  ee.gzhead.hcrc && ee.pending > W && (E.adler = y(E.adler, ee.pending_buf, ee.pending - W, W)), I === 0 && (ee.gzindex = 0, ee.status = 91);
                } else
                  ee.status = 91;
              if (ee.status === 91)
                if (ee.gzhead.comment) {
                  W = ee.pending;
                  do {
                    if (ee.pending === ee.pending_buf_size && (ee.gzhead.hcrc && ee.pending > W && (E.adler = y(E.adler, ee.pending_buf, ee.pending - W, W)), M(E), W = ee.pending, ee.pending === ee.pending_buf_size)) {
                      I = 1;
                      break;
                    }
                    I = ee.gzindex < ee.gzhead.comment.length ? 255 & ee.gzhead.comment.charCodeAt(ee.gzindex++) : 0, Z(ee, I);
                  } while (I !== 0);
                  ee.gzhead.hcrc && ee.pending > W && (E.adler = y(E.adler, ee.pending_buf, ee.pending - W, W)), I === 0 && (ee.status = 103);
                } else
                  ee.status = 103;
              if (ee.status === 103 && (ee.gzhead.hcrc ? (ee.pending + 2 > ee.pending_buf_size && M(E), ee.pending + 2 <= ee.pending_buf_size && (Z(ee, 255 & E.adler), Z(ee, E.adler >> 8 & 255), E.adler = 0, ee.status = x)) : ee.status = x), ee.pending !== 0) {
                if (M(E), E.avail_out === 0)
                  return ee.last_flush = -1, p;
              } else if (E.avail_in === 0 && T(te) <= T(oe) && te !== m)
                return C(E, -5);
              if (ee.status === 666 && E.avail_in !== 0)
                return C(E, -5);
              if (E.avail_in !== 0 || ee.lookahead !== 0 || te !== d && ee.status !== 666) {
                var ie = ee.strategy === 2 ? function(ue, fe) {
                  for (var de; ; ) {
                    if (ue.lookahead === 0 && (V(ue), ue.lookahead === 0)) {
                      if (fe === d)
                        return f;
                      break;
                    }
                    if (ue.match_length = 0, de = h._tr_tally(ue, 0, ue.window[ue.strstart]), ue.lookahead--, ue.strstart++, de && (G(ue, !1), ue.strm.avail_out === 0))
                      return f;
                  }
                  return ue.insert = 0, fe === m ? (G(ue, !0), ue.strm.avail_out === 0 ? _ : S) : ue.last_lit && (G(ue, !1), ue.strm.avail_out === 0) ? f : D;
                }(ee, te) : ee.strategy === 3 ? function(ue, fe) {
                  for (var de, pe, xe, Fe, Se = ue.window; ; ) {
                    if (ue.lookahead <= B) {
                      if (V(ue), ue.lookahead <= B && fe === d)
                        return f;
                      if (ue.lookahead === 0)
                        break;
                    }
                    if (ue.match_length = 0, ue.lookahead >= X && 0 < ue.strstart && (pe = Se[xe = ue.strstart - 1]) === Se[++xe] && pe === Se[++xe] && pe === Se[++xe]) {
                      Fe = ue.strstart + B;
                      do
                        ;
                      while (pe === Se[++xe] && pe === Se[++xe] && pe === Se[++xe] && pe === Se[++xe] && pe === Se[++xe] && pe === Se[++xe] && pe === Se[++xe] && pe === Se[++xe] && xe < Fe);
                      ue.match_length = B - (Fe - xe), ue.match_length > ue.lookahead && (ue.match_length = ue.lookahead);
                    }
                    if (ue.match_length >= X ? (de = h._tr_tally(ue, 1, ue.match_length - X), ue.lookahead -= ue.match_length, ue.strstart += ue.match_length, ue.match_length = 0) : (de = h._tr_tally(ue, 0, ue.window[ue.strstart]), ue.lookahead--, ue.strstart++), de && (G(ue, !1), ue.strm.avail_out === 0))
                      return f;
                  }
                  return ue.insert = 0, fe === m ? (G(ue, !0), ue.strm.avail_out === 0 ? _ : S) : ue.last_lit && (G(ue, !1), ue.strm.avail_out === 0) ? f : D;
                }(ee, te) : a[ee.level].func(ee, te);
                if (ie !== _ && ie !== S || (ee.status = 666), ie === f || ie === _)
                  return E.avail_out === 0 && (ee.last_flush = -1), p;
                if (ie === D && (te === 1 ? h._tr_align(ee) : te !== 5 && (h._tr_stored_block(ee, 0, 0, !1), te === 3 && (P(ee.head), ee.lookahead === 0 && (ee.strstart = 0, ee.block_start = 0, ee.insert = 0))), M(E), E.avail_out === 0))
                  return ee.last_flush = -1, p;
              }
              return te !== m ? p : ee.wrap <= 0 ? 1 : (ee.wrap === 2 ? (Z(ee, 255 & E.adler), Z(ee, E.adler >> 8 & 255), Z(ee, E.adler >> 16 & 255), Z(ee, E.adler >> 24 & 255), Z(ee, 255 & E.total_in), Z(ee, E.total_in >> 8 & 255), Z(ee, E.total_in >> 16 & 255), Z(ee, E.total_in >> 24 & 255)) : ($(ee, E.adler >>> 16), $(ee, 65535 & E.adler)), M(E), 0 < ee.wrap && (ee.wrap = -ee.wrap), ee.pending !== 0 ? p : 1);
            }, t.deflateEnd = function(E) {
              var te;
              return E && E.state ? (te = E.state.status) !== k && te !== 69 && te !== 73 && te !== 91 && te !== 103 && te !== x && te !== 666 ? C(E, g) : (E.state = null, te === x ? C(E, -3) : p) : g;
            }, t.deflateSetDictionary = function(E, te) {
              var oe, ee, W, I, H, ie, ue, fe, de = te.length;
              if (!E || !E.state || (I = (oe = E.state).wrap) === 2 || I === 1 && oe.status !== k || oe.lookahead)
                return g;
              for (I === 1 && (E.adler = e(E.adler, te, de, 0)), oe.wrap = 0, de >= oe.w_size && (I === 0 && (P(oe.head), oe.strstart = 0, oe.block_start = 0, oe.insert = 0), fe = new v.Buf8(oe.w_size), v.arraySet(fe, te, de - oe.w_size, oe.w_size, 0), te = fe, de = oe.w_size), H = E.avail_in, ie = E.next_in, ue = E.input, E.avail_in = de, E.next_in = 0, E.input = te, V(oe); oe.lookahead >= X; ) {
                for (ee = oe.strstart, W = oe.lookahead - (X - 1); oe.ins_h = (oe.ins_h << oe.hash_shift ^ oe.window[ee + X - 1]) & oe.hash_mask, oe.prev[ee & oe.w_mask] = oe.head[oe.ins_h], oe.head[oe.ins_h] = ee, ee++, --W; )
                  ;
                oe.strstart = ee, oe.lookahead = X - 1, V(oe);
              }
              return oe.strstart += oe.lookahead, oe.block_start = oe.strstart, oe.insert = oe.lookahead, oe.lookahead = 0, oe.match_length = oe.prev_length = X - 1, oe.match_available = 0, E.next_in = ie, E.input = ue, E.avail_in = H, oe.wrap = I, p;
            }, t.deflateInfo = "pako deflate (from Nodeca project)";
          }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(o, F, t) {
            F.exports = function() {
              this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
            };
          }, {}], 48: [function(o, F, t) {
            F.exports = function(a, v) {
              var h, e, y, c, d, m, p, g, n, i, l, u, w, O, b, A, Y, j, X, B, U, k, x, f, D;
              h = a.state, e = a.next_in, f = a.input, y = e + (a.avail_in - 5), c = a.next_out, D = a.output, d = c - (v - a.avail_out), m = c + (a.avail_out - 257), p = h.dmax, g = h.wsize, n = h.whave, i = h.wnext, l = h.window, u = h.hold, w = h.bits, O = h.lencode, b = h.distcode, A = (1 << h.lenbits) - 1, Y = (1 << h.distbits) - 1;
              e:
                do {
                  w < 15 && (u += f[e++] << w, w += 8, u += f[e++] << w, w += 8), j = O[u & A];
                  t:
                    for (; ; ) {
                      if (u >>>= X = j >>> 24, w -= X, (X = j >>> 16 & 255) === 0)
                        D[c++] = 65535 & j;
                      else {
                        if (!(16 & X)) {
                          if (!(64 & X)) {
                            j = O[(65535 & j) + (u & (1 << X) - 1)];
                            continue t;
                          }
                          if (32 & X) {
                            h.mode = 12;
                            break e;
                          }
                          a.msg = "invalid literal/length code", h.mode = 30;
                          break e;
                        }
                        B = 65535 & j, (X &= 15) && (w < X && (u += f[e++] << w, w += 8), B += u & (1 << X) - 1, u >>>= X, w -= X), w < 15 && (u += f[e++] << w, w += 8, u += f[e++] << w, w += 8), j = b[u & Y];
                        n:
                          for (; ; ) {
                            if (u >>>= X = j >>> 24, w -= X, !(16 & (X = j >>> 16 & 255))) {
                              if (!(64 & X)) {
                                j = b[(65535 & j) + (u & (1 << X) - 1)];
                                continue n;
                              }
                              a.msg = "invalid distance code", h.mode = 30;
                              break e;
                            }
                            if (U = 65535 & j, w < (X &= 15) && (u += f[e++] << w, (w += 8) < X && (u += f[e++] << w, w += 8)), p < (U += u & (1 << X) - 1)) {
                              a.msg = "invalid distance too far back", h.mode = 30;
                              break e;
                            }
                            if (u >>>= X, w -= X, (X = c - d) < U) {
                              if (n < (X = U - X) && h.sane) {
                                a.msg = "invalid distance too far back", h.mode = 30;
                                break e;
                              }
                              if (x = l, (k = 0) === i) {
                                if (k += g - X, X < B) {
                                  for (B -= X; D[c++] = l[k++], --X; )
                                    ;
                                  k = c - U, x = D;
                                }
                              } else if (i < X) {
                                if (k += g + i - X, (X -= i) < B) {
                                  for (B -= X; D[c++] = l[k++], --X; )
                                    ;
                                  if (k = 0, i < B) {
                                    for (B -= X = i; D[c++] = l[k++], --X; )
                                      ;
                                    k = c - U, x = D;
                                  }
                                }
                              } else if (k += i - X, X < B) {
                                for (B -= X; D[c++] = l[k++], --X; )
                                  ;
                                k = c - U, x = D;
                              }
                              for (; 2 < B; )
                                D[c++] = x[k++], D[c++] = x[k++], D[c++] = x[k++], B -= 3;
                              B && (D[c++] = x[k++], 1 < B && (D[c++] = x[k++]));
                            } else {
                              for (k = c - U; D[c++] = D[k++], D[c++] = D[k++], D[c++] = D[k++], 2 < (B -= 3); )
                                ;
                              B && (D[c++] = D[k++], 1 < B && (D[c++] = D[k++]));
                            }
                            break;
                          }
                      }
                      break;
                    }
                } while (e < y && c < m);
              e -= B = w >> 3, u &= (1 << (w -= B << 3)) - 1, a.next_in = e, a.next_out = c, a.avail_in = e < y ? y - e + 5 : 5 - (e - y), a.avail_out = c < m ? m - c + 257 : 257 - (c - m), h.hold = u, h.bits = w;
            };
          }, {}], 49: [function(o, F, t) {
            var a = o("../utils/common"), v = o("./adler32"), h = o("./crc32"), e = o("./inffast"), y = o("./inftrees"), c = 1, d = 2, m = 0, p = -2, g = 1, n = 852, i = 592;
            function l(k) {
              return (k >>> 24 & 255) + (k >>> 8 & 65280) + ((65280 & k) << 8) + ((255 & k) << 24);
            }
            function u() {
              this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new a.Buf16(320), this.work = new a.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
            }
            function w(k) {
              var x;
              return k && k.state ? (x = k.state, k.total_in = k.total_out = x.total = 0, k.msg = "", x.wrap && (k.adler = 1 & x.wrap), x.mode = g, x.last = 0, x.havedict = 0, x.dmax = 32768, x.head = null, x.hold = 0, x.bits = 0, x.lencode = x.lendyn = new a.Buf32(n), x.distcode = x.distdyn = new a.Buf32(i), x.sane = 1, x.back = -1, m) : p;
            }
            function O(k) {
              var x;
              return k && k.state ? ((x = k.state).wsize = 0, x.whave = 0, x.wnext = 0, w(k)) : p;
            }
            function b(k, x) {
              var f, D;
              return k && k.state ? (D = k.state, x < 0 ? (f = 0, x = -x) : (f = 1 + (x >> 4), x < 48 && (x &= 15)), x && (x < 8 || 15 < x) ? p : (D.window !== null && D.wbits !== x && (D.window = null), D.wrap = f, D.wbits = x, O(k))) : p;
            }
            function A(k, x) {
              var f, D;
              return k ? (D = new u(), (k.state = D).window = null, (f = b(k, x)) !== m && (k.state = null), f) : p;
            }
            var Y, j, X = !0;
            function B(k) {
              if (X) {
                var x;
                for (Y = new a.Buf32(512), j = new a.Buf32(32), x = 0; x < 144; )
                  k.lens[x++] = 8;
                for (; x < 256; )
                  k.lens[x++] = 9;
                for (; x < 280; )
                  k.lens[x++] = 7;
                for (; x < 288; )
                  k.lens[x++] = 8;
                for (y(c, k.lens, 0, 288, Y, 0, k.work, { bits: 9 }), x = 0; x < 32; )
                  k.lens[x++] = 5;
                y(d, k.lens, 0, 32, j, 0, k.work, { bits: 5 }), X = !1;
              }
              k.lencode = Y, k.lenbits = 9, k.distcode = j, k.distbits = 5;
            }
            function U(k, x, f, D) {
              var _, S = k.state;
              return S.window === null && (S.wsize = 1 << S.wbits, S.wnext = 0, S.whave = 0, S.window = new a.Buf8(S.wsize)), D >= S.wsize ? (a.arraySet(S.window, x, f - S.wsize, S.wsize, 0), S.wnext = 0, S.whave = S.wsize) : (D < (_ = S.wsize - S.wnext) && (_ = D), a.arraySet(S.window, x, f - D, _, S.wnext), (D -= _) ? (a.arraySet(S.window, x, f - D, D, 0), S.wnext = D, S.whave = S.wsize) : (S.wnext += _, S.wnext === S.wsize && (S.wnext = 0), S.whave < S.wsize && (S.whave += _))), 0;
            }
            t.inflateReset = O, t.inflateReset2 = b, t.inflateResetKeep = w, t.inflateInit = function(k) {
              return A(k, 15);
            }, t.inflateInit2 = A, t.inflate = function(k, x) {
              var f, D, _, S, C, T, P, M, G, Z, $, z, V, L, K, ne, se, q, N, Q, E, te, oe, ee, W = 0, I = new a.Buf8(4), H = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
              if (!k || !k.state || !k.output || !k.input && k.avail_in !== 0)
                return p;
              (f = k.state).mode === 12 && (f.mode = 13), C = k.next_out, _ = k.output, P = k.avail_out, S = k.next_in, D = k.input, T = k.avail_in, M = f.hold, G = f.bits, Z = T, $ = P, te = m;
              e:
                for (; ; )
                  switch (f.mode) {
                    case g:
                      if (f.wrap === 0) {
                        f.mode = 13;
                        break;
                      }
                      for (; G < 16; ) {
                        if (T === 0)
                          break e;
                        T--, M += D[S++] << G, G += 8;
                      }
                      if (2 & f.wrap && M === 35615) {
                        I[f.check = 0] = 255 & M, I[1] = M >>> 8 & 255, f.check = h(f.check, I, 2, 0), G = M = 0, f.mode = 2;
                        break;
                      }
                      if (f.flags = 0, f.head && (f.head.done = !1), !(1 & f.wrap) || (((255 & M) << 8) + (M >> 8)) % 31) {
                        k.msg = "incorrect header check", f.mode = 30;
                        break;
                      }
                      if ((15 & M) != 8) {
                        k.msg = "unknown compression method", f.mode = 30;
                        break;
                      }
                      if (G -= 4, E = 8 + (15 & (M >>>= 4)), f.wbits === 0)
                        f.wbits = E;
                      else if (E > f.wbits) {
                        k.msg = "invalid window size", f.mode = 30;
                        break;
                      }
                      f.dmax = 1 << E, k.adler = f.check = 1, f.mode = 512 & M ? 10 : 12, G = M = 0;
                      break;
                    case 2:
                      for (; G < 16; ) {
                        if (T === 0)
                          break e;
                        T--, M += D[S++] << G, G += 8;
                      }
                      if (f.flags = M, (255 & f.flags) != 8) {
                        k.msg = "unknown compression method", f.mode = 30;
                        break;
                      }
                      if (57344 & f.flags) {
                        k.msg = "unknown header flags set", f.mode = 30;
                        break;
                      }
                      f.head && (f.head.text = M >> 8 & 1), 512 & f.flags && (I[0] = 255 & M, I[1] = M >>> 8 & 255, f.check = h(f.check, I, 2, 0)), G = M = 0, f.mode = 3;
                    case 3:
                      for (; G < 32; ) {
                        if (T === 0)
                          break e;
                        T--, M += D[S++] << G, G += 8;
                      }
                      f.head && (f.head.time = M), 512 & f.flags && (I[0] = 255 & M, I[1] = M >>> 8 & 255, I[2] = M >>> 16 & 255, I[3] = M >>> 24 & 255, f.check = h(f.check, I, 4, 0)), G = M = 0, f.mode = 4;
                    case 4:
                      for (; G < 16; ) {
                        if (T === 0)
                          break e;
                        T--, M += D[S++] << G, G += 8;
                      }
                      f.head && (f.head.xflags = 255 & M, f.head.os = M >> 8), 512 & f.flags && (I[0] = 255 & M, I[1] = M >>> 8 & 255, f.check = h(f.check, I, 2, 0)), G = M = 0, f.mode = 5;
                    case 5:
                      if (1024 & f.flags) {
                        for (; G < 16; ) {
                          if (T === 0)
                            break e;
                          T--, M += D[S++] << G, G += 8;
                        }
                        f.length = M, f.head && (f.head.extra_len = M), 512 & f.flags && (I[0] = 255 & M, I[1] = M >>> 8 & 255, f.check = h(f.check, I, 2, 0)), G = M = 0;
                      } else
                        f.head && (f.head.extra = null);
                      f.mode = 6;
                    case 6:
                      if (1024 & f.flags && (T < (z = f.length) && (z = T), z && (f.head && (E = f.head.extra_len - f.length, f.head.extra || (f.head.extra = new Array(f.head.extra_len)), a.arraySet(f.head.extra, D, S, z, E)), 512 & f.flags && (f.check = h(f.check, D, z, S)), T -= z, S += z, f.length -= z), f.length))
                        break e;
                      f.length = 0, f.mode = 7;
                    case 7:
                      if (2048 & f.flags) {
                        if (T === 0)
                          break e;
                        for (z = 0; E = D[S + z++], f.head && E && f.length < 65536 && (f.head.name += String.fromCharCode(E)), E && z < T; )
                          ;
                        if (512 & f.flags && (f.check = h(f.check, D, z, S)), T -= z, S += z, E)
                          break e;
                      } else
                        f.head && (f.head.name = null);
                      f.length = 0, f.mode = 8;
                    case 8:
                      if (4096 & f.flags) {
                        if (T === 0)
                          break e;
                        for (z = 0; E = D[S + z++], f.head && E && f.length < 65536 && (f.head.comment += String.fromCharCode(E)), E && z < T; )
                          ;
                        if (512 & f.flags && (f.check = h(f.check, D, z, S)), T -= z, S += z, E)
                          break e;
                      } else
                        f.head && (f.head.comment = null);
                      f.mode = 9;
                    case 9:
                      if (512 & f.flags) {
                        for (; G < 16; ) {
                          if (T === 0)
                            break e;
                          T--, M += D[S++] << G, G += 8;
                        }
                        if (M !== (65535 & f.check)) {
                          k.msg = "header crc mismatch", f.mode = 30;
                          break;
                        }
                        G = M = 0;
                      }
                      f.head && (f.head.hcrc = f.flags >> 9 & 1, f.head.done = !0), k.adler = f.check = 0, f.mode = 12;
                      break;
                    case 10:
                      for (; G < 32; ) {
                        if (T === 0)
                          break e;
                        T--, M += D[S++] << G, G += 8;
                      }
                      k.adler = f.check = l(M), G = M = 0, f.mode = 11;
                    case 11:
                      if (f.havedict === 0)
                        return k.next_out = C, k.avail_out = P, k.next_in = S, k.avail_in = T, f.hold = M, f.bits = G, 2;
                      k.adler = f.check = 1, f.mode = 12;
                    case 12:
                      if (x === 5 || x === 6)
                        break e;
                    case 13:
                      if (f.last) {
                        M >>>= 7 & G, G -= 7 & G, f.mode = 27;
                        break;
                      }
                      for (; G < 3; ) {
                        if (T === 0)
                          break e;
                        T--, M += D[S++] << G, G += 8;
                      }
                      switch (f.last = 1 & M, G -= 1, 3 & (M >>>= 1)) {
                        case 0:
                          f.mode = 14;
                          break;
                        case 1:
                          if (B(f), f.mode = 20, x !== 6)
                            break;
                          M >>>= 2, G -= 2;
                          break e;
                        case 2:
                          f.mode = 17;
                          break;
                        case 3:
                          k.msg = "invalid block type", f.mode = 30;
                      }
                      M >>>= 2, G -= 2;
                      break;
                    case 14:
                      for (M >>>= 7 & G, G -= 7 & G; G < 32; ) {
                        if (T === 0)
                          break e;
                        T--, M += D[S++] << G, G += 8;
                      }
                      if ((65535 & M) != (M >>> 16 ^ 65535)) {
                        k.msg = "invalid stored block lengths", f.mode = 30;
                        break;
                      }
                      if (f.length = 65535 & M, G = M = 0, f.mode = 15, x === 6)
                        break e;
                    case 15:
                      f.mode = 16;
                    case 16:
                      if (z = f.length) {
                        if (T < z && (z = T), P < z && (z = P), z === 0)
                          break e;
                        a.arraySet(_, D, S, z, C), T -= z, S += z, P -= z, C += z, f.length -= z;
                        break;
                      }
                      f.mode = 12;
                      break;
                    case 17:
                      for (; G < 14; ) {
                        if (T === 0)
                          break e;
                        T--, M += D[S++] << G, G += 8;
                      }
                      if (f.nlen = 257 + (31 & M), M >>>= 5, G -= 5, f.ndist = 1 + (31 & M), M >>>= 5, G -= 5, f.ncode = 4 + (15 & M), M >>>= 4, G -= 4, 286 < f.nlen || 30 < f.ndist) {
                        k.msg = "too many length or distance symbols", f.mode = 30;
                        break;
                      }
                      f.have = 0, f.mode = 18;
                    case 18:
                      for (; f.have < f.ncode; ) {
                        for (; G < 3; ) {
                          if (T === 0)
                            break e;
                          T--, M += D[S++] << G, G += 8;
                        }
                        f.lens[H[f.have++]] = 7 & M, M >>>= 3, G -= 3;
                      }
                      for (; f.have < 19; )
                        f.lens[H[f.have++]] = 0;
                      if (f.lencode = f.lendyn, f.lenbits = 7, oe = { bits: f.lenbits }, te = y(0, f.lens, 0, 19, f.lencode, 0, f.work, oe), f.lenbits = oe.bits, te) {
                        k.msg = "invalid code lengths set", f.mode = 30;
                        break;
                      }
                      f.have = 0, f.mode = 19;
                    case 19:
                      for (; f.have < f.nlen + f.ndist; ) {
                        for (; ne = (W = f.lencode[M & (1 << f.lenbits) - 1]) >>> 16 & 255, se = 65535 & W, !((K = W >>> 24) <= G); ) {
                          if (T === 0)
                            break e;
                          T--, M += D[S++] << G, G += 8;
                        }
                        if (se < 16)
                          M >>>= K, G -= K, f.lens[f.have++] = se;
                        else {
                          if (se === 16) {
                            for (ee = K + 2; G < ee; ) {
                              if (T === 0)
                                break e;
                              T--, M += D[S++] << G, G += 8;
                            }
                            if (M >>>= K, G -= K, f.have === 0) {
                              k.msg = "invalid bit length repeat", f.mode = 30;
                              break;
                            }
                            E = f.lens[f.have - 1], z = 3 + (3 & M), M >>>= 2, G -= 2;
                          } else if (se === 17) {
                            for (ee = K + 3; G < ee; ) {
                              if (T === 0)
                                break e;
                              T--, M += D[S++] << G, G += 8;
                            }
                            G -= K, E = 0, z = 3 + (7 & (M >>>= K)), M >>>= 3, G -= 3;
                          } else {
                            for (ee = K + 7; G < ee; ) {
                              if (T === 0)
                                break e;
                              T--, M += D[S++] << G, G += 8;
                            }
                            G -= K, E = 0, z = 11 + (127 & (M >>>= K)), M >>>= 7, G -= 7;
                          }
                          if (f.have + z > f.nlen + f.ndist) {
                            k.msg = "invalid bit length repeat", f.mode = 30;
                            break;
                          }
                          for (; z--; )
                            f.lens[f.have++] = E;
                        }
                      }
                      if (f.mode === 30)
                        break;
                      if (f.lens[256] === 0) {
                        k.msg = "invalid code -- missing end-of-block", f.mode = 30;
                        break;
                      }
                      if (f.lenbits = 9, oe = { bits: f.lenbits }, te = y(c, f.lens, 0, f.nlen, f.lencode, 0, f.work, oe), f.lenbits = oe.bits, te) {
                        k.msg = "invalid literal/lengths set", f.mode = 30;
                        break;
                      }
                      if (f.distbits = 6, f.distcode = f.distdyn, oe = { bits: f.distbits }, te = y(d, f.lens, f.nlen, f.ndist, f.distcode, 0, f.work, oe), f.distbits = oe.bits, te) {
                        k.msg = "invalid distances set", f.mode = 30;
                        break;
                      }
                      if (f.mode = 20, x === 6)
                        break e;
                    case 20:
                      f.mode = 21;
                    case 21:
                      if (6 <= T && 258 <= P) {
                        k.next_out = C, k.avail_out = P, k.next_in = S, k.avail_in = T, f.hold = M, f.bits = G, e(k, $), C = k.next_out, _ = k.output, P = k.avail_out, S = k.next_in, D = k.input, T = k.avail_in, M = f.hold, G = f.bits, f.mode === 12 && (f.back = -1);
                        break;
                      }
                      for (f.back = 0; ne = (W = f.lencode[M & (1 << f.lenbits) - 1]) >>> 16 & 255, se = 65535 & W, !((K = W >>> 24) <= G); ) {
                        if (T === 0)
                          break e;
                        T--, M += D[S++] << G, G += 8;
                      }
                      if (ne && !(240 & ne)) {
                        for (q = K, N = ne, Q = se; ne = (W = f.lencode[Q + ((M & (1 << q + N) - 1) >> q)]) >>> 16 & 255, se = 65535 & W, !(q + (K = W >>> 24) <= G); ) {
                          if (T === 0)
                            break e;
                          T--, M += D[S++] << G, G += 8;
                        }
                        M >>>= q, G -= q, f.back += q;
                      }
                      if (M >>>= K, G -= K, f.back += K, f.length = se, ne === 0) {
                        f.mode = 26;
                        break;
                      }
                      if (32 & ne) {
                        f.back = -1, f.mode = 12;
                        break;
                      }
                      if (64 & ne) {
                        k.msg = "invalid literal/length code", f.mode = 30;
                        break;
                      }
                      f.extra = 15 & ne, f.mode = 22;
                    case 22:
                      if (f.extra) {
                        for (ee = f.extra; G < ee; ) {
                          if (T === 0)
                            break e;
                          T--, M += D[S++] << G, G += 8;
                        }
                        f.length += M & (1 << f.extra) - 1, M >>>= f.extra, G -= f.extra, f.back += f.extra;
                      }
                      f.was = f.length, f.mode = 23;
                    case 23:
                      for (; ne = (W = f.distcode[M & (1 << f.distbits) - 1]) >>> 16 & 255, se = 65535 & W, !((K = W >>> 24) <= G); ) {
                        if (T === 0)
                          break e;
                        T--, M += D[S++] << G, G += 8;
                      }
                      if (!(240 & ne)) {
                        for (q = K, N = ne, Q = se; ne = (W = f.distcode[Q + ((M & (1 << q + N) - 1) >> q)]) >>> 16 & 255, se = 65535 & W, !(q + (K = W >>> 24) <= G); ) {
                          if (T === 0)
                            break e;
                          T--, M += D[S++] << G, G += 8;
                        }
                        M >>>= q, G -= q, f.back += q;
                      }
                      if (M >>>= K, G -= K, f.back += K, 64 & ne) {
                        k.msg = "invalid distance code", f.mode = 30;
                        break;
                      }
                      f.offset = se, f.extra = 15 & ne, f.mode = 24;
                    case 24:
                      if (f.extra) {
                        for (ee = f.extra; G < ee; ) {
                          if (T === 0)
                            break e;
                          T--, M += D[S++] << G, G += 8;
                        }
                        f.offset += M & (1 << f.extra) - 1, M >>>= f.extra, G -= f.extra, f.back += f.extra;
                      }
                      if (f.offset > f.dmax) {
                        k.msg = "invalid distance too far back", f.mode = 30;
                        break;
                      }
                      f.mode = 25;
                    case 25:
                      if (P === 0)
                        break e;
                      if (z = $ - P, f.offset > z) {
                        if ((z = f.offset - z) > f.whave && f.sane) {
                          k.msg = "invalid distance too far back", f.mode = 30;
                          break;
                        }
                        V = z > f.wnext ? (z -= f.wnext, f.wsize - z) : f.wnext - z, z > f.length && (z = f.length), L = f.window;
                      } else
                        L = _, V = C - f.offset, z = f.length;
                      for (P < z && (z = P), P -= z, f.length -= z; _[C++] = L[V++], --z; )
                        ;
                      f.length === 0 && (f.mode = 21);
                      break;
                    case 26:
                      if (P === 0)
                        break e;
                      _[C++] = f.length, P--, f.mode = 21;
                      break;
                    case 27:
                      if (f.wrap) {
                        for (; G < 32; ) {
                          if (T === 0)
                            break e;
                          T--, M |= D[S++] << G, G += 8;
                        }
                        if ($ -= P, k.total_out += $, f.total += $, $ && (k.adler = f.check = f.flags ? h(f.check, _, $, C - $) : v(f.check, _, $, C - $)), $ = P, (f.flags ? M : l(M)) !== f.check) {
                          k.msg = "incorrect data check", f.mode = 30;
                          break;
                        }
                        G = M = 0;
                      }
                      f.mode = 28;
                    case 28:
                      if (f.wrap && f.flags) {
                        for (; G < 32; ) {
                          if (T === 0)
                            break e;
                          T--, M += D[S++] << G, G += 8;
                        }
                        if (M !== (4294967295 & f.total)) {
                          k.msg = "incorrect length check", f.mode = 30;
                          break;
                        }
                        G = M = 0;
                      }
                      f.mode = 29;
                    case 29:
                      te = 1;
                      break e;
                    case 30:
                      te = -3;
                      break e;
                    case 31:
                      return -4;
                    case 32:
                    default:
                      return p;
                  }
              return k.next_out = C, k.avail_out = P, k.next_in = S, k.avail_in = T, f.hold = M, f.bits = G, (f.wsize || $ !== k.avail_out && f.mode < 30 && (f.mode < 27 || x !== 4)) && U(k, k.output, k.next_out, $ - k.avail_out) ? (f.mode = 31, -4) : (Z -= k.avail_in, $ -= k.avail_out, k.total_in += Z, k.total_out += $, f.total += $, f.wrap && $ && (k.adler = f.check = f.flags ? h(f.check, _, $, k.next_out - $) : v(f.check, _, $, k.next_out - $)), k.data_type = f.bits + (f.last ? 64 : 0) + (f.mode === 12 ? 128 : 0) + (f.mode === 20 || f.mode === 15 ? 256 : 0), (Z == 0 && $ === 0 || x === 4) && te === m && (te = -5), te);
            }, t.inflateEnd = function(k) {
              if (!k || !k.state)
                return p;
              var x = k.state;
              return x.window && (x.window = null), k.state = null, m;
            }, t.inflateGetHeader = function(k, x) {
              var f;
              return k && k.state && 2 & (f = k.state).wrap ? ((f.head = x).done = !1, m) : p;
            }, t.inflateSetDictionary = function(k, x) {
              var f, D = x.length;
              return k && k.state ? (f = k.state).wrap !== 0 && f.mode !== 11 ? p : f.mode === 11 && v(1, x, D, 0) !== f.check ? -3 : U(k, x, D, D) ? (f.mode = 31, -4) : (f.havedict = 1, m) : p;
            }, t.inflateInfo = "pako inflate (from Nodeca project)";
          }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(o, F, t) {
            var a = o("../utils/common"), v = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], h = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], e = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], y = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
            F.exports = function(c, d, m, p, g, n, i, l) {
              var u, w, O, b, A, Y, j, X, B, U = l.bits, k = 0, x = 0, f = 0, D = 0, _ = 0, S = 0, C = 0, T = 0, P = 0, M = 0, G = null, Z = 0, $ = new a.Buf16(16), z = new a.Buf16(16), V = null, L = 0;
              for (k = 0; k <= 15; k++)
                $[k] = 0;
              for (x = 0; x < p; x++)
                $[d[m + x]]++;
              for (_ = U, D = 15; 1 <= D && $[D] === 0; D--)
                ;
              if (D < _ && (_ = D), D === 0)
                return g[n++] = 20971520, g[n++] = 20971520, l.bits = 1, 0;
              for (f = 1; f < D && $[f] === 0; f++)
                ;
              for (_ < f && (_ = f), k = T = 1; k <= 15; k++)
                if (T <<= 1, (T -= $[k]) < 0)
                  return -1;
              if (0 < T && (c === 0 || D !== 1))
                return -1;
              for (z[1] = 0, k = 1; k < 15; k++)
                z[k + 1] = z[k] + $[k];
              for (x = 0; x < p; x++)
                d[m + x] !== 0 && (i[z[d[m + x]]++] = x);
              if (Y = c === 0 ? (G = V = i, 19) : c === 1 ? (G = v, Z -= 257, V = h, L -= 257, 256) : (G = e, V = y, -1), k = f, A = n, C = x = M = 0, O = -1, b = (P = 1 << (S = _)) - 1, c === 1 && 852 < P || c === 2 && 592 < P)
                return 1;
              for (; ; ) {
                for (j = k - C, B = i[x] < Y ? (X = 0, i[x]) : i[x] > Y ? (X = V[L + i[x]], G[Z + i[x]]) : (X = 96, 0), u = 1 << k - C, f = w = 1 << S; g[A + (M >> C) + (w -= u)] = j << 24 | X << 16 | B | 0, w !== 0; )
                  ;
                for (u = 1 << k - 1; M & u; )
                  u >>= 1;
                if (u !== 0 ? (M &= u - 1, M += u) : M = 0, x++, --$[k] == 0) {
                  if (k === D)
                    break;
                  k = d[m + i[x]];
                }
                if (_ < k && (M & b) !== O) {
                  for (C === 0 && (C = _), A += f, T = 1 << (S = k - C); S + C < D && !((T -= $[S + C]) <= 0); )
                    S++, T <<= 1;
                  if (P += 1 << S, c === 1 && 852 < P || c === 2 && 592 < P)
                    return 1;
                  g[O = M & b] = _ << 24 | S << 16 | A - n | 0;
                }
              }
              return M !== 0 && (g[A + M] = k - C << 24 | 64 << 16 | 0), l.bits = _, 0;
            };
          }, { "../utils/common": 41 }], 51: [function(o, F, t) {
            F.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
          }, {}], 52: [function(o, F, t) {
            var a = o("../utils/common"), v = 0, h = 1;
            function e(W) {
              for (var I = W.length; 0 <= --I; )
                W[I] = 0;
            }
            var y = 0, c = 29, d = 256, m = d + 1 + c, p = 30, g = 19, n = 2 * m + 1, i = 15, l = 16, u = 7, w = 256, O = 16, b = 17, A = 18, Y = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], j = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], X = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], B = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], U = new Array(2 * (m + 2));
            e(U);
            var k = new Array(2 * p);
            e(k);
            var x = new Array(512);
            e(x);
            var f = new Array(256);
            e(f);
            var D = new Array(c);
            e(D);
            var _, S, C, T = new Array(p);
            function P(W, I, H, ie, ue) {
              this.static_tree = W, this.extra_bits = I, this.extra_base = H, this.elems = ie, this.max_length = ue, this.has_stree = W && W.length;
            }
            function M(W, I) {
              this.dyn_tree = W, this.max_code = 0, this.stat_desc = I;
            }
            function G(W) {
              return W < 256 ? x[W] : x[256 + (W >>> 7)];
            }
            function Z(W, I) {
              W.pending_buf[W.pending++] = 255 & I, W.pending_buf[W.pending++] = I >>> 8 & 255;
            }
            function $(W, I, H) {
              W.bi_valid > l - H ? (W.bi_buf |= I << W.bi_valid & 65535, Z(W, W.bi_buf), W.bi_buf = I >> l - W.bi_valid, W.bi_valid += H - l) : (W.bi_buf |= I << W.bi_valid & 65535, W.bi_valid += H);
            }
            function z(W, I, H) {
              $(W, H[2 * I], H[2 * I + 1]);
            }
            function V(W, I) {
              for (var H = 0; H |= 1 & W, W >>>= 1, H <<= 1, 0 < --I; )
                ;
              return H >>> 1;
            }
            function L(W, I, H) {
              var ie, ue, fe = new Array(i + 1), de = 0;
              for (ie = 1; ie <= i; ie++)
                fe[ie] = de = de + H[ie - 1] << 1;
              for (ue = 0; ue <= I; ue++) {
                var pe = W[2 * ue + 1];
                pe !== 0 && (W[2 * ue] = V(fe[pe]++, pe));
              }
            }
            function K(W) {
              var I;
              for (I = 0; I < m; I++)
                W.dyn_ltree[2 * I] = 0;
              for (I = 0; I < p; I++)
                W.dyn_dtree[2 * I] = 0;
              for (I = 0; I < g; I++)
                W.bl_tree[2 * I] = 0;
              W.dyn_ltree[2 * w] = 1, W.opt_len = W.static_len = 0, W.last_lit = W.matches = 0;
            }
            function ne(W) {
              8 < W.bi_valid ? Z(W, W.bi_buf) : 0 < W.bi_valid && (W.pending_buf[W.pending++] = W.bi_buf), W.bi_buf = 0, W.bi_valid = 0;
            }
            function se(W, I, H, ie) {
              var ue = 2 * I, fe = 2 * H;
              return W[ue] < W[fe] || W[ue] === W[fe] && ie[I] <= ie[H];
            }
            function q(W, I, H) {
              for (var ie = W.heap[H], ue = H << 1; ue <= W.heap_len && (ue < W.heap_len && se(I, W.heap[ue + 1], W.heap[ue], W.depth) && ue++, !se(I, ie, W.heap[ue], W.depth)); )
                W.heap[H] = W.heap[ue], H = ue, ue <<= 1;
              W.heap[H] = ie;
            }
            function N(W, I, H) {
              var ie, ue, fe, de, pe = 0;
              if (W.last_lit !== 0)
                for (; ie = W.pending_buf[W.d_buf + 2 * pe] << 8 | W.pending_buf[W.d_buf + 2 * pe + 1], ue = W.pending_buf[W.l_buf + pe], pe++, ie === 0 ? z(W, ue, I) : (z(W, (fe = f[ue]) + d + 1, I), (de = Y[fe]) !== 0 && $(W, ue -= D[fe], de), z(W, fe = G(--ie), H), (de = j[fe]) !== 0 && $(W, ie -= T[fe], de)), pe < W.last_lit; )
                  ;
              z(W, w, I);
            }
            function Q(W, I) {
              var H, ie, ue, fe = I.dyn_tree, de = I.stat_desc.static_tree, pe = I.stat_desc.has_stree, xe = I.stat_desc.elems, Fe = -1;
              for (W.heap_len = 0, W.heap_max = n, H = 0; H < xe; H++)
                fe[2 * H] !== 0 ? (W.heap[++W.heap_len] = Fe = H, W.depth[H] = 0) : fe[2 * H + 1] = 0;
              for (; W.heap_len < 2; )
                fe[2 * (ue = W.heap[++W.heap_len] = Fe < 2 ? ++Fe : 0)] = 1, W.depth[ue] = 0, W.opt_len--, pe && (W.static_len -= de[2 * ue + 1]);
              for (I.max_code = Fe, H = W.heap_len >> 1; 1 <= H; H--)
                q(W, fe, H);
              for (ue = xe; H = W.heap[1], W.heap[1] = W.heap[W.heap_len--], q(W, fe, 1), ie = W.heap[1], W.heap[--W.heap_max] = H, W.heap[--W.heap_max] = ie, fe[2 * ue] = fe[2 * H] + fe[2 * ie], W.depth[ue] = (W.depth[H] >= W.depth[ie] ? W.depth[H] : W.depth[ie]) + 1, fe[2 * H + 1] = fe[2 * ie + 1] = ue, W.heap[1] = ue++, q(W, fe, 1), 2 <= W.heap_len; )
                ;
              W.heap[--W.heap_max] = W.heap[1], function(Se, Ce) {
                var ke, ye, De, Ae, Te, ve, Ne = Ce.dyn_tree, Ge = Ce.max_code, it = Ce.stat_desc.static_tree, Me = Ce.stat_desc.has_stree, Ie = Ce.stat_desc.extra_bits, Ee = Ce.stat_desc.extra_base, st = Ce.stat_desc.max_length, Qe = 0;
                for (Ae = 0; Ae <= i; Ae++)
                  Se.bl_count[Ae] = 0;
                for (Ne[2 * Se.heap[Se.heap_max] + 1] = 0, ke = Se.heap_max + 1; ke < n; ke++)
                  st < (Ae = Ne[2 * Ne[2 * (ye = Se.heap[ke]) + 1] + 1] + 1) && (Ae = st, Qe++), Ne[2 * ye + 1] = Ae, Ge < ye || (Se.bl_count[Ae]++, Te = 0, Ee <= ye && (Te = Ie[ye - Ee]), ve = Ne[2 * ye], Se.opt_len += ve * (Ae + Te), Me && (Se.static_len += ve * (it[2 * ye + 1] + Te)));
                if (Qe !== 0) {
                  do {
                    for (Ae = st - 1; Se.bl_count[Ae] === 0; )
                      Ae--;
                    Se.bl_count[Ae]--, Se.bl_count[Ae + 1] += 2, Se.bl_count[st]--, Qe -= 2;
                  } while (0 < Qe);
                  for (Ae = st; Ae !== 0; Ae--)
                    for (ye = Se.bl_count[Ae]; ye !== 0; )
                      Ge < (De = Se.heap[--ke]) || (Ne[2 * De + 1] !== Ae && (Se.opt_len += (Ae - Ne[2 * De + 1]) * Ne[2 * De], Ne[2 * De + 1] = Ae), ye--);
                }
              }(W, I), L(fe, Fe, W.bl_count);
            }
            function E(W, I, H) {
              var ie, ue, fe = -1, de = I[1], pe = 0, xe = 7, Fe = 4;
              for (de === 0 && (xe = 138, Fe = 3), I[2 * (H + 1) + 1] = 65535, ie = 0; ie <= H; ie++)
                ue = de, de = I[2 * (ie + 1) + 1], ++pe < xe && ue === de || (pe < Fe ? W.bl_tree[2 * ue] += pe : ue !== 0 ? (ue !== fe && W.bl_tree[2 * ue]++, W.bl_tree[2 * O]++) : pe <= 10 ? W.bl_tree[2 * b]++ : W.bl_tree[2 * A]++, fe = ue, Fe = (pe = 0) === de ? (xe = 138, 3) : ue === de ? (xe = 6, 3) : (xe = 7, 4));
            }
            function te(W, I, H) {
              var ie, ue, fe = -1, de = I[1], pe = 0, xe = 7, Fe = 4;
              for (de === 0 && (xe = 138, Fe = 3), ie = 0; ie <= H; ie++)
                if (ue = de, de = I[2 * (ie + 1) + 1], !(++pe < xe && ue === de)) {
                  if (pe < Fe)
                    for (; z(W, ue, W.bl_tree), --pe != 0; )
                      ;
                  else
                    ue !== 0 ? (ue !== fe && (z(W, ue, W.bl_tree), pe--), z(W, O, W.bl_tree), $(W, pe - 3, 2)) : pe <= 10 ? (z(W, b, W.bl_tree), $(W, pe - 3, 3)) : (z(W, A, W.bl_tree), $(W, pe - 11, 7));
                  fe = ue, Fe = (pe = 0) === de ? (xe = 138, 3) : ue === de ? (xe = 6, 3) : (xe = 7, 4);
                }
            }
            e(T);
            var oe = !1;
            function ee(W, I, H, ie) {
              $(W, (y << 1) + (ie ? 1 : 0), 3), function(ue, fe, de, pe) {
                ne(ue), pe && (Z(ue, de), Z(ue, ~de)), a.arraySet(ue.pending_buf, ue.window, fe, de, ue.pending), ue.pending += de;
              }(W, I, H, !0);
            }
            t._tr_init = function(W) {
              oe || (function() {
                var I, H, ie, ue, fe, de = new Array(i + 1);
                for (ue = ie = 0; ue < c - 1; ue++)
                  for (D[ue] = ie, I = 0; I < 1 << Y[ue]; I++)
                    f[ie++] = ue;
                for (f[ie - 1] = ue, ue = fe = 0; ue < 16; ue++)
                  for (T[ue] = fe, I = 0; I < 1 << j[ue]; I++)
                    x[fe++] = ue;
                for (fe >>= 7; ue < p; ue++)
                  for (T[ue] = fe << 7, I = 0; I < 1 << j[ue] - 7; I++)
                    x[256 + fe++] = ue;
                for (H = 0; H <= i; H++)
                  de[H] = 0;
                for (I = 0; I <= 143; )
                  U[2 * I + 1] = 8, I++, de[8]++;
                for (; I <= 255; )
                  U[2 * I + 1] = 9, I++, de[9]++;
                for (; I <= 279; )
                  U[2 * I + 1] = 7, I++, de[7]++;
                for (; I <= 287; )
                  U[2 * I + 1] = 8, I++, de[8]++;
                for (L(U, m + 1, de), I = 0; I < p; I++)
                  k[2 * I + 1] = 5, k[2 * I] = V(I, 5);
                _ = new P(U, Y, d + 1, m, i), S = new P(k, j, 0, p, i), C = new P(new Array(0), X, 0, g, u);
              }(), oe = !0), W.l_desc = new M(W.dyn_ltree, _), W.d_desc = new M(W.dyn_dtree, S), W.bl_desc = new M(W.bl_tree, C), W.bi_buf = 0, W.bi_valid = 0, K(W);
            }, t._tr_stored_block = ee, t._tr_flush_block = function(W, I, H, ie) {
              var ue, fe, de = 0;
              0 < W.level ? (W.strm.data_type === 2 && (W.strm.data_type = function(pe) {
                var xe, Fe = 4093624447;
                for (xe = 0; xe <= 31; xe++, Fe >>>= 1)
                  if (1 & Fe && pe.dyn_ltree[2 * xe] !== 0)
                    return v;
                if (pe.dyn_ltree[18] !== 0 || pe.dyn_ltree[20] !== 0 || pe.dyn_ltree[26] !== 0)
                  return h;
                for (xe = 32; xe < d; xe++)
                  if (pe.dyn_ltree[2 * xe] !== 0)
                    return h;
                return v;
              }(W)), Q(W, W.l_desc), Q(W, W.d_desc), de = function(pe) {
                var xe;
                for (E(pe, pe.dyn_ltree, pe.l_desc.max_code), E(pe, pe.dyn_dtree, pe.d_desc.max_code), Q(pe, pe.bl_desc), xe = g - 1; 3 <= xe && pe.bl_tree[2 * B[xe] + 1] === 0; xe--)
                  ;
                return pe.opt_len += 3 * (xe + 1) + 5 + 5 + 4, xe;
              }(W), ue = W.opt_len + 3 + 7 >>> 3, (fe = W.static_len + 3 + 7 >>> 3) <= ue && (ue = fe)) : ue = fe = H + 5, H + 4 <= ue && I !== -1 ? ee(W, I, H, ie) : W.strategy === 4 || fe === ue ? ($(W, 2 + (ie ? 1 : 0), 3), N(W, U, k)) : ($(W, 4 + (ie ? 1 : 0), 3), function(pe, xe, Fe, Se) {
                var Ce;
                for ($(pe, xe - 257, 5), $(pe, Fe - 1, 5), $(pe, Se - 4, 4), Ce = 0; Ce < Se; Ce++)
                  $(pe, pe.bl_tree[2 * B[Ce] + 1], 3);
                te(pe, pe.dyn_ltree, xe - 1), te(pe, pe.dyn_dtree, Fe - 1);
              }(W, W.l_desc.max_code + 1, W.d_desc.max_code + 1, de + 1), N(W, W.dyn_ltree, W.dyn_dtree)), K(W), ie && ne(W);
            }, t._tr_tally = function(W, I, H) {
              return W.pending_buf[W.d_buf + 2 * W.last_lit] = I >>> 8 & 255, W.pending_buf[W.d_buf + 2 * W.last_lit + 1] = 255 & I, W.pending_buf[W.l_buf + W.last_lit] = 255 & H, W.last_lit++, I === 0 ? W.dyn_ltree[2 * H]++ : (W.matches++, I--, W.dyn_ltree[2 * (f[H] + d + 1)]++, W.dyn_dtree[2 * G(I)]++), W.last_lit === W.lit_bufsize - 1;
            }, t._tr_align = function(W) {
              $(W, 2, 3), z(W, w, U), function(I) {
                I.bi_valid === 16 ? (Z(I, I.bi_buf), I.bi_buf = 0, I.bi_valid = 0) : 8 <= I.bi_valid && (I.pending_buf[I.pending++] = 255 & I.bi_buf, I.bi_buf >>= 8, I.bi_valid -= 8);
              }(W);
            };
          }, { "../utils/common": 41 }], 53: [function(o, F, t) {
            F.exports = function() {
              this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
            };
          }, {}], 54: [function(o, F, t) {
            F.exports = typeof setImmediate == "function" ? setImmediate : function() {
              var a = [].slice.apply(arguments);
              a.splice(1, 0, 0), setTimeout.apply(null, a);
            };
          }, {}] }, {}, [10])(10);
        });
      }).call(this, typeof commonjsGlobal < "u" ? commonjsGlobal : typeof self < "u" ? self : typeof window < "u" ? window : {}, le("buffer").Buffer);
    }, { buffer: 78 }], 88: [function(le, ce, re) {
      re.Parser = le("./lib/parser").Parser, re.rules = le("./lib/rules"), re.errors = le("./lib/errors"), re.results = le("./lib/parsing-results"), re.StringSource = le("./lib/StringSource"), re.Token = le("./lib/Token"), re.bottomUp = le("./lib/bottom-up"), re.RegexTokeniser = le("./lib/regex-tokeniser").RegexTokeniser, re.rule = function(ae) {
        var J;
        return function(o) {
          return J || (J = ae()), J(o);
        };
      };
    }, { "./lib/StringSource": 89, "./lib/Token": 90, "./lib/bottom-up": 92, "./lib/errors": 93, "./lib/parser": 95, "./lib/parsing-results": 96, "./lib/regex-tokeniser": 97, "./lib/rules": 98 }], 89: [function(le, ce, re) {
      var ae = le("util");
      ce.exports = function(o, F) {
        var t = {
          asString: function() {
            return o;
          },
          range: function(a, v) {
            return new J(o, F, a, v);
          }
        };
        return t;
      };
      var J = function(o, F, t, a) {
        this._string = o, this._description = F, this._startIndex = t, this._endIndex = a;
      };
      J.prototype.to = function(o) {
        return new J(this._string, this._description, this._startIndex, o._endIndex);
      }, J.prototype.describe = function() {
        var o = this._position(), F = this._description ? this._description + `
` : "";
        return ae.format(
          `%sLine number: %s
Character number: %s`,
          F,
          o.lineNumber,
          o.characterNumber
        );
      }, J.prototype.lineNumber = function() {
        return this._position().lineNumber;
      }, J.prototype.characterNumber = function() {
        return this._position().characterNumber;
      }, J.prototype._position = function() {
        for (var o = this, F = 0, t = function() {
          return o._string.indexOf(`
`, F);
        }, a = 1; t() !== -1 && t() < this._startIndex; )
          F = t() + 1, a += 1;
        var v = this._startIndex - F + 1;
        return { lineNumber: a, characterNumber: v };
      };
    }, { util: 121 }], 90: [function(le, ce, re) {
      ce.exports = function(ae, J, o) {
        this.name = ae, this.value = J, o && (this.source = o);
      };
    }, {}], 91: [function(le, ce, re) {
      var ae = ce.exports = function(J, o) {
        this._tokens = J, this._startIndex = o || 0;
      };
      ae.prototype.head = function() {
        return this._tokens[this._startIndex];
      }, ae.prototype.tail = function(J) {
        return new ae(this._tokens, this._startIndex + 1);
      }, ae.prototype.toArray = function() {
        return this._tokens.slice(this._startIndex);
      }, ae.prototype.end = function() {
        return this._tokens[this._tokens.length - 1];
      }, ae.prototype.to = function(J) {
        var o = this.head().source, F = J.head() || J.end();
        return o.to(F.source);
      };
    }, {}], 92: [function(le, ce, re) {
      var ae = le("./rules"), J = le("./parsing-results");
      re.parser = function(t, a, v) {
        var h = {
          rule: d,
          leftAssociative: m,
          rightAssociative: p
        }, e = new o(v.map(c)), y = ae.firstOf(t, a);
        function c(i) {
          return {
            name: i.name,
            rule: F(i.ruleBuilder.bind(null, h))
          };
        }
        function d() {
          return g(e);
        }
        function m(i) {
          return g(e.untilExclusive(i));
        }
        function p(i) {
          return g(e.untilInclusive(i));
        }
        function g(i) {
          return n.bind(null, i);
        }
        function n(i, l) {
          var u = y(l);
          return u.isSuccess() ? i.apply(u) : u;
        }
        return h;
      };
      function o(t) {
        function a(c) {
          return new o(t.slice(0, h().indexOf(c)));
        }
        function v(c) {
          return new o(t.slice(0, h().indexOf(c) + 1));
        }
        function h() {
          return t.map(function(c) {
            return c.name;
          });
        }
        function e(c) {
          for (var d, m; ; )
            if (d = y(c.remaining()), d.isSuccess())
              m = c.source().to(d.source()), c = J.success(
                d.value()(c.value(), m),
                d.remaining(),
                m
              );
            else
              return d.isFailure() ? c : d;
        }
        function y(c) {
          return ae.firstOf("infix", t.map(function(d) {
            return d.rule;
          }))(c);
        }
        return {
          apply: e,
          untilExclusive: a,
          untilInclusive: v
        };
      }
      re.infix = function(t, a) {
        function v(h) {
          return re.infix(t, function(e) {
            var y = a(e);
            return function(c) {
              var d = y(c);
              return d.map(function(m) {
                return function(p, g) {
                  return h(p, m, g);
                };
              });
            };
          });
        }
        return {
          name: t,
          ruleBuilder: a,
          map: v
        };
      };
      var F = function(t) {
        var a;
        return function(v) {
          return a || (a = t()), a(v);
        };
      };
    }, { "./parsing-results": 96, "./rules": 98 }], 93: [function(le, ce, re) {
      re.error = function(J) {
        return new ae(J);
      };
      var ae = function(J) {
        this.expected = J.expected, this.actual = J.actual, this._location = J.location;
      };
      ae.prototype.describe = function() {
        var J = this._location ? this._location.describe() + `:
` : "";
        return J + "Expected " + this.expected + `
but got ` + this.actual;
      }, ae.prototype.lineNumber = function() {
        return this._location.lineNumber();
      }, ae.prototype.characterNumber = function() {
        return this._location.characterNumber();
      };
    }, {}], 94: [function(le, ce, re) {
      re.fromArray = function(J) {
        var o = 0, F = function() {
          return o < J.length;
        };
        return new ae({
          hasNext: F,
          next: function() {
            if (F())
              return J[o++];
            throw new Error("No more elements");
          }
        });
      };
      var ae = function(J) {
        this._iterator = J;
      };
      ae.prototype.map = function(J) {
        var o = this._iterator;
        return new ae({
          hasNext: function() {
            return o.hasNext();
          },
          next: function() {
            return J(o.next());
          }
        });
      }, ae.prototype.filter = function(J) {
        var o = this._iterator, F = !1, t = !1, a, v = function() {
          if (!F)
            for (F = !0, t = !1; o.hasNext() && !t; )
              a = o.next(), t = J(a);
        };
        return new ae({
          hasNext: function() {
            return v(), t;
          },
          next: function() {
            v();
            var h = a;
            return F = !1, h;
          }
        });
      }, ae.prototype.first = function() {
        var J = this._iterator;
        return this._iterator.hasNext() ? J.next() : null;
      }, ae.prototype.toArray = function() {
        for (var J = []; this._iterator.hasNext(); )
          J.push(this._iterator.next());
        return J;
      };
    }, {}], 95: [function(le, ce, re) {
      var ae = le("./TokenIterator");
      re.Parser = function(J) {
        var o = function(F, t) {
          return F(new ae(t));
        };
        return {
          parseTokens: o
        };
      };
    }, { "./TokenIterator": 91 }], 96: [function(le, ce, re) {
      ce.exports = {
        failure: function(J, o) {
          if (J.length < 1)
            throw new Error("Failure must have errors");
          return new ae({
            status: "failure",
            remaining: o,
            errors: J
          });
        },
        error: function(J, o) {
          if (J.length < 1)
            throw new Error("Failure must have errors");
          return new ae({
            status: "error",
            remaining: o,
            errors: J
          });
        },
        success: function(J, o, F) {
          return new ae({
            status: "success",
            value: J,
            source: F,
            remaining: o,
            errors: []
          });
        },
        cut: function(J) {
          return new ae({
            status: "cut",
            remaining: J,
            errors: []
          });
        }
      };
      var ae = function(J) {
        this._value = J.value, this._status = J.status, this._hasValue = J.value !== void 0, this._remaining = J.remaining, this._source = J.source, this._errors = J.errors;
      };
      ae.prototype.map = function(J) {
        return this._hasValue ? new ae({
          value: J(this._value, this._source),
          status: this._status,
          remaining: this._remaining,
          source: this._source,
          errors: this._errors
        }) : this;
      }, ae.prototype.changeRemaining = function(J) {
        return new ae({
          value: this._value,
          status: this._status,
          remaining: J,
          source: this._source,
          errors: this._errors
        });
      }, ae.prototype.isSuccess = function() {
        return this._status === "success" || this._status === "cut";
      }, ae.prototype.isFailure = function() {
        return this._status === "failure";
      }, ae.prototype.isError = function() {
        return this._status === "error";
      }, ae.prototype.isCut = function() {
        return this._status === "cut";
      }, ae.prototype.value = function() {
        return this._value;
      }, ae.prototype.remaining = function() {
        return this._remaining;
      }, ae.prototype.source = function() {
        return this._source;
      }, ae.prototype.errors = function() {
        return this._errors;
      };
    }, {}], 97: [function(le, ce, re) {
      var ae = le("./Token"), J = le("./StringSource");
      re.RegexTokeniser = o;
      function o(F) {
        F = F.map(function(h) {
          return {
            name: h.name,
            regex: new RegExp(h.regex.source, "g")
          };
        });
        function t(h, e) {
          for (var y = new J(h, e), c = 0, d = []; c < h.length; ) {
            var m = a(h, c, y);
            c = m.endIndex, d.push(m.token);
          }
          return d.push(v(h, y)), d;
        }
        function a(h, e, y) {
          for (var c = 0; c < F.length; c++) {
            var d = F[c].regex;
            d.lastIndex = e;
            var m = d.exec(h);
            if (m) {
              var g = e + m[0].length;
              if (m.index === e && g > e) {
                var p = m[1], n = new ae(
                  F[c].name,
                  p,
                  y.range(e, g)
                );
                return { token: n, endIndex: g };
              }
            }
          }
          var g = e + 1, n = new ae(
            "unrecognisedCharacter",
            h.substring(e, g),
            y.range(e, g)
          );
          return { token: n, endIndex: g };
        }
        function v(h, e) {
          return new ae(
            "end",
            null,
            e.range(h.length, h.length)
          );
        }
        return {
          tokenise: t
        };
      }
    }, { "./StringSource": 89, "./Token": 90 }], 98: [function(le, ce, re) {
      var ae = le("underscore"), J = le("option"), o = le("./parsing-results"), F = le("./errors"), t = le("./lazy-iterators");
      re.token = function(d, m) {
        var p = m !== void 0;
        return function(g) {
          var n = g.head();
          if (n && n.name === d && (!p || n.value === m))
            return o.success(n.value, g.tail(), n.source);
          var i = y({ name: d, value: m });
          return c(g, i);
        };
      }, re.tokenOfType = function(d) {
        return re.token(d);
      }, re.firstOf = function(d, m) {
        return ae.isArray(m) || (m = Array.prototype.slice.call(arguments, 1)), function(p) {
          return t.fromArray(m).map(function(g) {
            return g(p);
          }).filter(function(g) {
            return g.isSuccess() || g.isError();
          }).first() || c(p, d);
        };
      }, re.then = function(d, m) {
        return function(p) {
          var g = d(p);
          return g.map || console.log(g), g.map(m);
        };
      }, re.sequence = function() {
        var d = Array.prototype.slice.call(arguments, 0), m = function(g) {
          var n = ae.foldl(d, function(l, u) {
            var w = l.result, O = l.hasCut;
            if (!w.isSuccess())
              return { result: w, hasCut: O };
            var b = u(w.remaining());
            if (b.isCut())
              return { result: w, hasCut: !0 };
            if (b.isSuccess()) {
              var A;
              u.isCaptured ? A = w.value().withValue(u, b.value()) : A = w.value();
              var Y = b.remaining(), j = g.to(Y);
              return {
                result: o.success(A, Y, j),
                hasCut: O
              };
            } else
              return O ? { result: o.error(b.errors(), b.remaining()), hasCut: O } : { result: b, hasCut: O };
          }, { result: o.success(new a(), g), hasCut: !1 }).result, i = g.to(n.remaining());
          return n.map(function(l) {
            return l.withValue(re.sequence.source, i);
          });
        };
        m.head = function() {
          var g = ae.find(d, p);
          return re.then(
            m,
            re.sequence.extract(g)
          );
        }, m.map = function(g) {
          return re.then(
            m,
            function(n) {
              return g.apply(this, n.toArray());
            }
          );
        };
        function p(g) {
          return g.isCaptured;
        }
        return m;
      };
      var a = function(d, m) {
        this._values = d || {}, this._valuesArray = m || [];
      };
      a.prototype.withValue = function(d, m) {
        if (d.captureName && d.captureName in this._values)
          throw new Error('Cannot add second value for capture "' + d.captureName + '"');
        var p = ae.clone(this._values);
        p[d.captureName] = m;
        var g = this._valuesArray.concat([m]);
        return new a(p, g);
      }, a.prototype.get = function(d) {
        if (d.captureName in this._values)
          return this._values[d.captureName];
        throw new Error('No value for capture "' + d.captureName + '"');
      }, a.prototype.toArray = function() {
        return this._valuesArray;
      }, re.sequence.capture = function(d, m) {
        var p = function() {
          return d.apply(this, arguments);
        };
        return p.captureName = m, p.isCaptured = !0, p;
      }, re.sequence.extract = function(d) {
        return function(m) {
          return m.get(d);
        };
      }, re.sequence.applyValues = function(d) {
        var m = Array.prototype.slice.call(arguments, 1);
        return function(p) {
          var g = m.map(function(n) {
            return p.get(n);
          });
          return d.apply(this, g);
        };
      }, re.sequence.source = {
        captureName: "☃source☃"
      }, re.sequence.cut = function() {
        return function(d) {
          return o.cut(d);
        };
      }, re.optional = function(d) {
        return function(m) {
          var p = d(m);
          return p.isSuccess() ? p.map(J.some) : p.isFailure() ? o.success(J.none, m) : p;
        };
      }, re.zeroOrMoreWithSeparator = function(d, m) {
        return e(d, m, !1);
      }, re.oneOrMoreWithSeparator = function(d, m) {
        return e(d, m, !0);
      };
      var v = re.zeroOrMore = function(d) {
        return function(m) {
          for (var p = [], g; (g = d(m)) && g.isSuccess(); )
            m = g.remaining(), p.push(g.value());
          return g.isError() ? g : o.success(p, m);
        };
      };
      re.oneOrMore = function(d) {
        return re.oneOrMoreWithSeparator(d, h);
      };
      function h(d) {
        return o.success(null, d);
      }
      var e = function(d, m, p) {
        return function(g) {
          var n = d(g);
          if (n.isSuccess()) {
            var i = re.sequence.capture(d, "main"), l = v(re.then(
              re.sequence(m, i),
              re.sequence.extract(i)
            )), u = l(n.remaining());
            return o.success([n.value()].concat(u.value()), u.remaining());
          } else
            return p || n.isError() ? n : o.success([], g);
        };
      };
      re.leftAssociative = function(d, m, p) {
        var g;
        p ? g = [{ func: p, rule: m }] : g = m, g = g.map(function(i) {
          return re.then(i.rule, function(l) {
            return function(u, w) {
              return i.func(u, l, w);
            };
          });
        });
        var n = re.firstOf.apply(null, ["rules"].concat(g));
        return function(i) {
          var l = i, u = d(i);
          if (!u.isSuccess())
            return u;
          for (var w = n(u.remaining()); w.isSuccess(); ) {
            var O = w.remaining(), b = l.to(w.remaining()), A = w.value();
            u = o.success(
              A(u.value(), b),
              O,
              b
            ), w = n(u.remaining());
          }
          return w.isError() ? w : u;
        };
      }, re.leftAssociative.firstOf = function() {
        return Array.prototype.slice.call(arguments, 0);
      }, re.nonConsuming = function(d) {
        return function(m) {
          return d(m).changeRemaining(m);
        };
      };
      var y = function(d) {
        return d.value ? d.name + ' "' + d.value + '"' : d.name;
      };
      function c(d, m) {
        var p, g = d.head();
        return g ? p = F.error({
          expected: m,
          actual: y(g),
          location: g.source
        }) : p = F.error({
          expected: m,
          actual: "end of tokens"
        }), o.failure([p], d);
      }
    }, { "./errors": 93, "./lazy-iterators": 94, "./parsing-results": 96, option: 99, underscore: 117 }], 99: [function(le, ce, re) {
      re.none = /* @__PURE__ */ Object.create({
        value: function() {
          throw new Error("Called value on none");
        },
        isNone: function() {
          return !0;
        },
        isSome: function() {
          return !1;
        },
        map: function() {
          return re.none;
        },
        flatMap: function() {
          return re.none;
        },
        filter: function() {
          return re.none;
        },
        toArray: function() {
          return [];
        },
        orElse: ae,
        valueOrElse: ae
      });
      function ae(o) {
        return typeof o == "function" ? o() : o;
      }
      re.some = function(o) {
        return new J(o);
      };
      var J = function(o) {
        this._value = o;
      };
      J.prototype.value = function() {
        return this._value;
      }, J.prototype.isNone = function() {
        return !1;
      }, J.prototype.isSome = function() {
        return !0;
      }, J.prototype.map = function(o) {
        return new J(o(this._value));
      }, J.prototype.flatMap = function(o) {
        return o(this._value);
      }, J.prototype.filter = function(o) {
        return o(this._value) ? this : re.none;
      }, J.prototype.toArray = function() {
        return [this._value];
      }, J.prototype.orElse = function(o) {
        return this;
      }, J.prototype.valueOrElse = function(o) {
        return this._value;
      }, re.isOption = function(o) {
        return o === re.none || o instanceof J;
      }, re.fromNullable = function(o) {
        return o == null ? re.none : new J(o);
      };
    }, {}], 100: [function(le, ce, re) {
      (function(ae) {
        function J(v, h) {
          for (var e = 0, y = v.length - 1; y >= 0; y--) {
            var c = v[y];
            c === "." ? v.splice(y, 1) : c === ".." ? (v.splice(y, 1), e++) : e && (v.splice(y, 1), e--);
          }
          if (h)
            for (; e--; e)
              v.unshift("..");
          return v;
        }
        var o = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, F = function(v) {
          return o.exec(v).slice(1);
        };
        re.resolve = function() {
          for (var v = "", h = !1, e = arguments.length - 1; e >= -1 && !h; e--) {
            var y = e >= 0 ? arguments[e] : ae.cwd();
            if (typeof y != "string")
              throw new TypeError("Arguments to path.resolve must be strings");
            if (!y)
              continue;
            v = y + "/" + v, h = y.charAt(0) === "/";
          }
          return v = J(t(v.split("/"), function(c) {
            return !!c;
          }), !h).join("/"), (h ? "/" : "") + v || ".";
        }, re.normalize = function(v) {
          var h = re.isAbsolute(v), e = a(v, -1) === "/";
          return v = J(t(v.split("/"), function(y) {
            return !!y;
          }), !h).join("/"), !v && !h && (v = "."), v && e && (v += "/"), (h ? "/" : "") + v;
        }, re.isAbsolute = function(v) {
          return v.charAt(0) === "/";
        }, re.join = function() {
          var v = Array.prototype.slice.call(arguments, 0);
          return re.normalize(t(v, function(h, e) {
            if (typeof h != "string")
              throw new TypeError("Arguments to path.join must be strings");
            return h;
          }).join("/"));
        }, re.relative = function(v, h) {
          v = re.resolve(v).substr(1), h = re.resolve(h).substr(1);
          function e(n) {
            for (var i = 0; i < n.length && n[i] === ""; i++)
              ;
            for (var l = n.length - 1; l >= 0 && n[l] === ""; l--)
              ;
            return i > l ? [] : n.slice(i, l - i + 1);
          }
          for (var y = e(v.split("/")), c = e(h.split("/")), d = Math.min(y.length, c.length), m = d, p = 0; p < d; p++)
            if (y[p] !== c[p]) {
              m = p;
              break;
            }
          for (var g = [], p = m; p < y.length; p++)
            g.push("..");
          return g = g.concat(c.slice(m)), g.join("/");
        }, re.sep = "/", re.delimiter = ":", re.dirname = function(v) {
          var h = F(v), e = h[0], y = h[1];
          return !e && !y ? "." : (y && (y = y.substr(0, y.length - 1)), e + y);
        }, re.basename = function(v, h) {
          var e = F(v)[2];
          return h && e.substr(-1 * h.length) === h && (e = e.substr(0, e.length - h.length)), e;
        }, re.extname = function(v) {
          return F(v)[3];
        };
        function t(v, h) {
          if (v.filter)
            return v.filter(h);
          for (var e = [], y = 0; y < v.length; y++)
            h(v[y], y, v) && e.push(v[y]);
          return e;
        }
        var a = "ab".substr(-1) === "b" ? function(v, h, e) {
          return v.substr(h, e);
        } : function(v, h, e) {
          return h < 0 && (h = v.length + h), v.substr(h, e);
        };
      }).call(this, le("_process"));
    }, { _process: 102 }], 101: [function(le, ce, re) {
      (function(ae) {
        !ae.version || ae.version.indexOf("v0.") === 0 || ae.version.indexOf("v1.") === 0 && ae.version.indexOf("v1.8.") !== 0 ? ce.exports = J : ce.exports = ae.nextTick;
        function J(o, F, t, a) {
          if (typeof o != "function")
            throw new TypeError('"callback" argument must be a function');
          var v = arguments.length, h, e;
          switch (v) {
            case 0:
            case 1:
              return ae.nextTick(o);
            case 2:
              return ae.nextTick(function() {
                o.call(null, F);
              });
            case 3:
              return ae.nextTick(function() {
                o.call(null, F, t);
              });
            case 4:
              return ae.nextTick(function() {
                o.call(null, F, t, a);
              });
            default:
              for (h = new Array(v - 1), e = 0; e < h.length; )
                h[e++] = arguments[e];
              return ae.nextTick(function() {
                o.apply(null, h);
              });
          }
        }
      }).call(this, le("_process"));
    }, { _process: 102 }], 102: [function(le, ce, re) {
      var ae = ce.exports = {}, J, o;
      function F() {
        throw new Error("setTimeout has not been defined");
      }
      function t() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          typeof setTimeout == "function" ? J = setTimeout : J = F;
        } catch {
          J = F;
        }
        try {
          typeof clearTimeout == "function" ? o = clearTimeout : o = t;
        } catch {
          o = t;
        }
      })();
      function a(n) {
        if (J === setTimeout)
          return setTimeout(n, 0);
        if ((J === F || !J) && setTimeout)
          return J = setTimeout, setTimeout(n, 0);
        try {
          return J(n, 0);
        } catch {
          try {
            return J.call(null, n, 0);
          } catch {
            return J.call(this, n, 0);
          }
        }
      }
      function v(n) {
        if (o === clearTimeout)
          return clearTimeout(n);
        if ((o === t || !o) && clearTimeout)
          return o = clearTimeout, clearTimeout(n);
        try {
          return o(n);
        } catch {
          try {
            return o.call(null, n);
          } catch {
            return o.call(this, n);
          }
        }
      }
      var h = [], e = !1, y, c = -1;
      function d() {
        !e || !y || (e = !1, y.length ? h = y.concat(h) : c = -1, h.length && m());
      }
      function m() {
        if (!e) {
          var n = a(d);
          e = !0;
          for (var i = h.length; i; ) {
            for (y = h, h = []; ++c < i; )
              y && y[c].run();
            c = -1, i = h.length;
          }
          y = null, e = !1, v(n);
        }
      }
      ae.nextTick = function(n) {
        var i = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var l = 1; l < arguments.length; l++)
            i[l - 1] = arguments[l];
        h.push(new p(n, i)), h.length === 1 && !e && a(m);
      };
      function p(n, i) {
        this.fun = n, this.array = i;
      }
      p.prototype.run = function() {
        this.fun.apply(null, this.array);
      }, ae.title = "browser", ae.browser = !0, ae.env = {}, ae.argv = [], ae.version = "", ae.versions = {};
      function g() {
      }
      ae.on = g, ae.addListener = g, ae.once = g, ae.off = g, ae.removeListener = g, ae.removeAllListeners = g, ae.emit = g, ae.binding = function(n) {
        throw new Error("process.binding is not supported");
      }, ae.cwd = function() {
        return "/";
      }, ae.chdir = function(n) {
        throw new Error("process.chdir is not supported");
      }, ae.umask = function() {
        return 0;
      };
    }, {}], 103: [function(le, ce, re) {
      ce.exports = le("./lib/_stream_duplex.js");
    }, { "./lib/_stream_duplex.js": 104 }], 104: [function(le, ce, re) {
      var ae = Object.keys || function(d) {
        var m = [];
        for (var p in d)
          m.push(p);
        return m;
      };
      ce.exports = e;
      var J = le("process-nextick-args"), o = le("core-util-is");
      o.inherits = le("inherits");
      var F = le("./_stream_readable"), t = le("./_stream_writable");
      o.inherits(e, F);
      for (var a = ae(t.prototype), v = 0; v < a.length; v++) {
        var h = a[v];
        e.prototype[h] || (e.prototype[h] = t.prototype[h]);
      }
      function e(d) {
        if (!(this instanceof e))
          return new e(d);
        F.call(this, d), t.call(this, d), d && d.readable === !1 && (this.readable = !1), d && d.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, d && d.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", y);
      }
      function y() {
        this.allowHalfOpen || this._writableState.ended || J(c, this);
      }
      function c(d) {
        d.end();
      }
    }, { "./_stream_readable": 106, "./_stream_writable": 108, "core-util-is": 79, inherits: 84, "process-nextick-args": 101 }], 105: [function(le, ce, re) {
      ce.exports = o;
      var ae = le("./_stream_transform"), J = le("core-util-is");
      J.inherits = le("inherits"), J.inherits(o, ae);
      function o(F) {
        if (!(this instanceof o))
          return new o(F);
        ae.call(this, F);
      }
      o.prototype._transform = function(F, t, a) {
        a(null, F);
      };
    }, { "./_stream_transform": 107, "core-util-is": 79, inherits: 84 }], 106: [function(le, ce, re) {
      (function(ae) {
        ce.exports = n;
        var J = le("process-nextick-args"), o = le("isarray"), F;
        n.ReadableState = g, le("events").EventEmitter;
        var t = function($, z) {
          return $.listeners(z).length;
        }, a;
        (function() {
          try {
            a = le("stream");
          } catch {
          } finally {
            a || (a = le("events").EventEmitter);
          }
        })();
        var v = le("buffer").Buffer, h = le("buffer-shims"), e = le("core-util-is");
        e.inherits = le("inherits");
        var y = le("util"), c = void 0;
        y && y.debuglog ? c = y.debuglog("stream") : c = function() {
        };
        var d = le("./internal/streams/BufferList"), m;
        e.inherits(n, a);
        function p($, z, V) {
          if (typeof $.prependListener == "function")
            return $.prependListener(z, V);
          !$._events || !$._events[z] ? $.on(z, V) : o($._events[z]) ? $._events[z].unshift(V) : $._events[z] = [V, $._events[z]];
        }
        function g($, z) {
          F = F || le("./_stream_duplex"), $ = $ || {}, this.objectMode = !!$.objectMode, z instanceof F && (this.objectMode = this.objectMode || !!$.readableObjectMode);
          var V = $.highWaterMark, L = this.objectMode ? 16 : 16 * 1024;
          this.highWaterMark = V || V === 0 ? V : L, this.highWaterMark = ~~this.highWaterMark, this.buffer = new d(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.defaultEncoding = $.defaultEncoding || "utf8", this.ranOut = !1, this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, $.encoding && (m || (m = le("string_decoder/").StringDecoder), this.decoder = new m($.encoding), this.encoding = $.encoding);
        }
        function n($) {
          if (F = F || le("./_stream_duplex"), !(this instanceof n))
            return new n($);
          this._readableState = new g($, this), this.readable = !0, $ && typeof $.read == "function" && (this._read = $.read), a.call(this);
        }
        n.prototype.push = function($, z) {
          var V = this._readableState;
          return !V.objectMode && typeof $ == "string" && (z = z || V.defaultEncoding, z !== V.encoding && ($ = h.from($, z), z = "")), i(this, V, $, z, !1);
        }, n.prototype.unshift = function($) {
          var z = this._readableState;
          return i(this, z, $, "", !0);
        }, n.prototype.isPaused = function() {
          return this._readableState.flowing === !1;
        };
        function i($, z, V, L, K) {
          var ne = b(z, V);
          if (ne)
            $.emit("error", ne);
          else if (V === null)
            z.reading = !1, A($, z);
          else if (z.objectMode || V && V.length > 0)
            if (z.ended && !K) {
              var se = new Error("stream.push() after EOF");
              $.emit("error", se);
            } else if (z.endEmitted && K) {
              var q = new Error("stream.unshift() after end event");
              $.emit("error", q);
            } else {
              var N;
              z.decoder && !K && !L && (V = z.decoder.write(V), N = !z.objectMode && V.length === 0), K || (z.reading = !1), N || (z.flowing && z.length === 0 && !z.sync ? ($.emit("data", V), $.read(0)) : (z.length += z.objectMode ? 1 : V.length, K ? z.buffer.unshift(V) : z.buffer.push(V), z.needReadable && Y($))), X($, z);
            }
          else
            K || (z.reading = !1);
          return l(z);
        }
        function l($) {
          return !$.ended && ($.needReadable || $.length < $.highWaterMark || $.length === 0);
        }
        n.prototype.setEncoding = function($) {
          return m || (m = le("string_decoder/").StringDecoder), this._readableState.decoder = new m($), this._readableState.encoding = $, this;
        };
        var u = 8388608;
        function w($) {
          return $ >= u ? $ = u : ($--, $ |= $ >>> 1, $ |= $ >>> 2, $ |= $ >>> 4, $ |= $ >>> 8, $ |= $ >>> 16, $++), $;
        }
        function O($, z) {
          return $ <= 0 || z.length === 0 && z.ended ? 0 : z.objectMode ? 1 : $ !== $ ? z.flowing && z.length ? z.buffer.head.data.length : z.length : ($ > z.highWaterMark && (z.highWaterMark = w($)), $ <= z.length ? $ : z.ended ? z.length : (z.needReadable = !0, 0));
        }
        n.prototype.read = function($) {
          c("read", $), $ = parseInt($, 10);
          var z = this._readableState, V = $;
          if ($ !== 0 && (z.emittedReadable = !1), $ === 0 && z.needReadable && (z.length >= z.highWaterMark || z.ended))
            return c("read: emitReadable", z.length, z.ended), z.length === 0 && z.ended ? P(this) : Y(this), null;
          if ($ = O($, z), $ === 0 && z.ended)
            return z.length === 0 && P(this), null;
          var L = z.needReadable;
          c("need readable", L), (z.length === 0 || z.length - $ < z.highWaterMark) && (L = !0, c("length less than watermark", L)), z.ended || z.reading ? (L = !1, c("reading or ended", L)) : L && (c("do read"), z.reading = !0, z.sync = !0, z.length === 0 && (z.needReadable = !0), this._read(z.highWaterMark), z.sync = !1, z.reading || ($ = O(V, z)));
          var K;
          return $ > 0 ? K = _($, z) : K = null, K === null ? (z.needReadable = !0, $ = 0) : z.length -= $, z.length === 0 && (z.ended || (z.needReadable = !0), V !== $ && z.ended && P(this)), K !== null && this.emit("data", K), K;
        };
        function b($, z) {
          var V = null;
          return !v.isBuffer(z) && typeof z != "string" && z !== null && z !== void 0 && !$.objectMode && (V = new TypeError("Invalid non-string/buffer chunk")), V;
        }
        function A($, z) {
          if (!z.ended) {
            if (z.decoder) {
              var V = z.decoder.end();
              V && V.length && (z.buffer.push(V), z.length += z.objectMode ? 1 : V.length);
            }
            z.ended = !0, Y($);
          }
        }
        function Y($) {
          var z = $._readableState;
          z.needReadable = !1, z.emittedReadable || (c("emitReadable", z.flowing), z.emittedReadable = !0, z.sync ? J(j, $) : j($));
        }
        function j($) {
          c("emit readable"), $.emit("readable"), D($);
        }
        function X($, z) {
          z.readingMore || (z.readingMore = !0, J(B, $, z));
        }
        function B($, z) {
          for (var V = z.length; !z.reading && !z.flowing && !z.ended && z.length < z.highWaterMark && (c("maybeReadMore read 0"), $.read(0), V !== z.length); )
            V = z.length;
          z.readingMore = !1;
        }
        n.prototype._read = function($) {
          this.emit("error", new Error("_read() is not implemented"));
        }, n.prototype.pipe = function($, z) {
          var V = this, L = this._readableState;
          switch (L.pipesCount) {
            case 0:
              L.pipes = $;
              break;
            case 1:
              L.pipes = [L.pipes, $];
              break;
            default:
              L.pipes.push($);
              break;
          }
          L.pipesCount += 1, c("pipe count=%d opts=%j", L.pipesCount, z);
          var K = (!z || z.end !== !1) && $ !== ae.stdout && $ !== ae.stderr, ne = K ? q : E;
          L.endEmitted ? J(ne) : V.once("end", ne), $.on("unpipe", se);
          function se(ie) {
            c("onunpipe"), ie === V && E();
          }
          function q() {
            c("onend"), $.end();
          }
          var N = U(V);
          $.on("drain", N);
          var Q = !1;
          function E() {
            c("cleanup"), $.removeListener("close", W), $.removeListener("finish", I), $.removeListener("drain", N), $.removeListener("error", ee), $.removeListener("unpipe", se), V.removeListener("end", q), V.removeListener("end", E), V.removeListener("data", oe), Q = !0, L.awaitDrain && (!$._writableState || $._writableState.needDrain) && N();
          }
          var te = !1;
          V.on("data", oe);
          function oe(ie) {
            c("ondata"), te = !1;
            var ue = $.write(ie);
            ue === !1 && !te && ((L.pipesCount === 1 && L.pipes === $ || L.pipesCount > 1 && Z(L.pipes, $) !== -1) && !Q && (c("false write response, pause", V._readableState.awaitDrain), V._readableState.awaitDrain++, te = !0), V.pause());
          }
          function ee(ie) {
            c("onerror", ie), H(), $.removeListener("error", ee), t($, "error") === 0 && $.emit("error", ie);
          }
          p($, "error", ee);
          function W() {
            $.removeListener("finish", I), H();
          }
          $.once("close", W);
          function I() {
            c("onfinish"), $.removeListener("close", W), H();
          }
          $.once("finish", I);
          function H() {
            c("unpipe"), V.unpipe($);
          }
          return $.emit("pipe", V), L.flowing || (c("pipe resume"), V.resume()), $;
        };
        function U($) {
          return function() {
            var z = $._readableState;
            c("pipeOnDrain", z.awaitDrain), z.awaitDrain && z.awaitDrain--, z.awaitDrain === 0 && t($, "data") && (z.flowing = !0, D($));
          };
        }
        n.prototype.unpipe = function($) {
          var z = this._readableState;
          if (z.pipesCount === 0)
            return this;
          if (z.pipesCount === 1)
            return $ && $ !== z.pipes ? this : ($ || ($ = z.pipes), z.pipes = null, z.pipesCount = 0, z.flowing = !1, $ && $.emit("unpipe", this), this);
          if (!$) {
            var V = z.pipes, L = z.pipesCount;
            z.pipes = null, z.pipesCount = 0, z.flowing = !1;
            for (var K = 0; K < L; K++)
              V[K].emit("unpipe", this);
            return this;
          }
          var ne = Z(z.pipes, $);
          return ne === -1 ? this : (z.pipes.splice(ne, 1), z.pipesCount -= 1, z.pipesCount === 1 && (z.pipes = z.pipes[0]), $.emit("unpipe", this), this);
        }, n.prototype.on = function($, z) {
          var V = a.prototype.on.call(this, $, z);
          if ($ === "data")
            this._readableState.flowing !== !1 && this.resume();
          else if ($ === "readable") {
            var L = this._readableState;
            !L.endEmitted && !L.readableListening && (L.readableListening = L.needReadable = !0, L.emittedReadable = !1, L.reading ? L.length && Y(this) : J(k, this));
          }
          return V;
        }, n.prototype.addListener = n.prototype.on;
        function k($) {
          c("readable nexttick read 0"), $.read(0);
        }
        n.prototype.resume = function() {
          var $ = this._readableState;
          return $.flowing || (c("resume"), $.flowing = !0, x(this, $)), this;
        };
        function x($, z) {
          z.resumeScheduled || (z.resumeScheduled = !0, J(f, $, z));
        }
        function f($, z) {
          z.reading || (c("resume read 0"), $.read(0)), z.resumeScheduled = !1, z.awaitDrain = 0, $.emit("resume"), D($), z.flowing && !z.reading && $.read(0);
        }
        n.prototype.pause = function() {
          return c("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (c("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
        };
        function D($) {
          var z = $._readableState;
          for (c("flow", z.flowing); z.flowing && $.read() !== null; )
            ;
        }
        n.prototype.wrap = function($) {
          var z = this._readableState, V = !1, L = this;
          $.on("end", function() {
            if (c("wrapped end"), z.decoder && !z.ended) {
              var se = z.decoder.end();
              se && se.length && L.push(se);
            }
            L.push(null);
          }), $.on("data", function(se) {
            if (c("wrapped data"), z.decoder && (se = z.decoder.write(se)), !(z.objectMode && se == null) && !(!z.objectMode && (!se || !se.length))) {
              var q = L.push(se);
              q || (V = !0, $.pause());
            }
          });
          for (var K in $)
            this[K] === void 0 && typeof $[K] == "function" && (this[K] = function(se) {
              return function() {
                return $[se].apply($, arguments);
              };
            }(K));
          var ne = ["error", "close", "destroy", "pause", "resume"];
          return G(ne, function(se) {
            $.on(se, L.emit.bind(L, se));
          }), L._read = function(se) {
            c("wrapped _read", se), V && (V = !1, $.resume());
          }, L;
        }, n._fromList = _;
        function _($, z) {
          if (z.length === 0)
            return null;
          var V;
          return z.objectMode ? V = z.buffer.shift() : !$ || $ >= z.length ? (z.decoder ? V = z.buffer.join("") : z.buffer.length === 1 ? V = z.buffer.head.data : V = z.buffer.concat(z.length), z.buffer.clear()) : V = S($, z.buffer, z.decoder), V;
        }
        function S($, z, V) {
          var L;
          return $ < z.head.data.length ? (L = z.head.data.slice(0, $), z.head.data = z.head.data.slice($)) : $ === z.head.data.length ? L = z.shift() : L = V ? C($, z) : T($, z), L;
        }
        function C($, z) {
          var V = z.head, L = 1, K = V.data;
          for ($ -= K.length; V = V.next; ) {
            var ne = V.data, se = $ > ne.length ? ne.length : $;
            if (se === ne.length ? K += ne : K += ne.slice(0, $), $ -= se, $ === 0) {
              se === ne.length ? (++L, V.next ? z.head = V.next : z.head = z.tail = null) : (z.head = V, V.data = ne.slice(se));
              break;
            }
            ++L;
          }
          return z.length -= L, K;
        }
        function T($, z) {
          var V = h.allocUnsafe($), L = z.head, K = 1;
          for (L.data.copy(V), $ -= L.data.length; L = L.next; ) {
            var ne = L.data, se = $ > ne.length ? ne.length : $;
            if (ne.copy(V, V.length - $, 0, se), $ -= se, $ === 0) {
              se === ne.length ? (++K, L.next ? z.head = L.next : z.head = z.tail = null) : (z.head = L, L.data = ne.slice(se));
              break;
            }
            ++K;
          }
          return z.length -= K, V;
        }
        function P($) {
          var z = $._readableState;
          if (z.length > 0)
            throw new Error('"endReadable()" called on non-empty stream');
          z.endEmitted || (z.ended = !0, J(M, z, $));
        }
        function M($, z) {
          !$.endEmitted && $.length === 0 && ($.endEmitted = !0, z.readable = !1, z.emit("end"));
        }
        function G($, z) {
          for (var V = 0, L = $.length; V < L; V++)
            z($[V], V);
        }
        function Z($, z) {
          for (var V = 0, L = $.length; V < L; V++)
            if ($[V] === z)
              return V;
          return -1;
        }
      }).call(this, le("_process"));
    }, { "./_stream_duplex": 104, "./internal/streams/BufferList": 109, _process: 102, buffer: 78, "buffer-shims": 77, "core-util-is": 79, events: 82, inherits: 84, isarray: 86, "process-nextick-args": 101, "string_decoder/": 116, util: 76 }], 107: [function(le, ce, re) {
      ce.exports = t;
      var ae = le("./_stream_duplex"), J = le("core-util-is");
      J.inherits = le("inherits"), J.inherits(t, ae);
      function o(v) {
        this.afterTransform = function(h, e) {
          return F(v, h, e);
        }, this.needTransform = !1, this.transforming = !1, this.writecb = null, this.writechunk = null, this.writeencoding = null;
      }
      function F(v, h, e) {
        var y = v._transformState;
        y.transforming = !1;
        var c = y.writecb;
        if (!c)
          return v.emit("error", new Error("no writecb in Transform class"));
        y.writechunk = null, y.writecb = null, e != null && v.push(e), c(h);
        var d = v._readableState;
        d.reading = !1, (d.needReadable || d.length < d.highWaterMark) && v._read(d.highWaterMark);
      }
      function t(v) {
        if (!(this instanceof t))
          return new t(v);
        ae.call(this, v), this._transformState = new o(this);
        var h = this;
        this._readableState.needReadable = !0, this._readableState.sync = !1, v && (typeof v.transform == "function" && (this._transform = v.transform), typeof v.flush == "function" && (this._flush = v.flush)), this.once("prefinish", function() {
          typeof this._flush == "function" ? this._flush(function(e, y) {
            a(h, e, y);
          }) : a(h);
        });
      }
      t.prototype.push = function(v, h) {
        return this._transformState.needTransform = !1, ae.prototype.push.call(this, v, h);
      }, t.prototype._transform = function(v, h, e) {
        throw new Error("_transform() is not implemented");
      }, t.prototype._write = function(v, h, e) {
        var y = this._transformState;
        if (y.writecb = e, y.writechunk = v, y.writeencoding = h, !y.transforming) {
          var c = this._readableState;
          (y.needTransform || c.needReadable || c.length < c.highWaterMark) && this._read(c.highWaterMark);
        }
      }, t.prototype._read = function(v) {
        var h = this._transformState;
        h.writechunk !== null && h.writecb && !h.transforming ? (h.transforming = !0, this._transform(h.writechunk, h.writeencoding, h.afterTransform)) : h.needTransform = !0;
      };
      function a(v, h, e) {
        if (h)
          return v.emit("error", h);
        e != null && v.push(e);
        var y = v._writableState, c = v._transformState;
        if (y.length)
          throw new Error("Calling transform done when ws.length != 0");
        if (c.transforming)
          throw new Error("Calling transform done when still transforming");
        return v.push(null);
      }
    }, { "./_stream_duplex": 104, "core-util-is": 79, inherits: 84 }], 108: [function(le, ce, re) {
      (function(ae) {
        ce.exports = p;
        var J = le("process-nextick-args"), o = !ae.browser && ["v0.10", "v0.9."].indexOf(ae.version.slice(0, 5)) > -1 ? setImmediate : J, F;
        p.WritableState = d;
        var t = le("core-util-is");
        t.inherits = le("inherits");
        var a = {
          deprecate: le("util-deprecate")
        }, v;
        (function() {
          try {
            v = le("stream");
          } catch {
          } finally {
            v || (v = le("events").EventEmitter);
          }
        })();
        var h = le("buffer").Buffer, e = le("buffer-shims");
        t.inherits(p, v);
        function y() {
        }
        function c(f, D, _) {
          this.chunk = f, this.encoding = D, this.callback = _, this.next = null;
        }
        function d(f, D) {
          F = F || le("./_stream_duplex"), f = f || {}, this.objectMode = !!f.objectMode, D instanceof F && (this.objectMode = this.objectMode || !!f.writableObjectMode);
          var _ = f.highWaterMark, S = this.objectMode ? 16 : 16 * 1024;
          this.highWaterMark = _ || _ === 0 ? _ : S, this.highWaterMark = ~~this.highWaterMark, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1;
          var C = f.decodeStrings === !1;
          this.decodeStrings = !C, this.defaultEncoding = f.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(T) {
            b(D, T);
          }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new x(this);
        }
        d.prototype.getBuffer = function() {
          for (var D = this.bufferedRequest, _ = []; D; )
            _.push(D), D = D.next;
          return _;
        }, function() {
          try {
            Object.defineProperty(d.prototype, "buffer", {
              get: a.deprecate(function() {
                return this.getBuffer();
              }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
            });
          } catch {
          }
        }();
        var m;
        typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (m = Function.prototype[Symbol.hasInstance], Object.defineProperty(p, Symbol.hasInstance, {
          value: function(f) {
            return m.call(this, f) ? !0 : f && f._writableState instanceof d;
          }
        })) : m = function(f) {
          return f instanceof this;
        };
        function p(f) {
          if (F = F || le("./_stream_duplex"), !m.call(p, this) && !(this instanceof F))
            return new p(f);
          this._writableState = new d(f, this), this.writable = !0, f && (typeof f.write == "function" && (this._write = f.write), typeof f.writev == "function" && (this._writev = f.writev)), v.call(this);
        }
        p.prototype.pipe = function() {
          this.emit("error", new Error("Cannot pipe, not readable"));
        };
        function g(f, D) {
          var _ = new Error("write after end");
          f.emit("error", _), J(D, _);
        }
        function n(f, D, _, S) {
          var C = !0, T = !1;
          return _ === null ? T = new TypeError("May not write null values to stream") : typeof _ != "string" && _ !== void 0 && !D.objectMode && (T = new TypeError("Invalid non-string/buffer chunk")), T && (f.emit("error", T), J(S, T), C = !1), C;
        }
        p.prototype.write = function(f, D, _) {
          var S = this._writableState, C = !1, T = h.isBuffer(f);
          return typeof D == "function" && (_ = D, D = null), T ? D = "buffer" : D || (D = S.defaultEncoding), typeof _ != "function" && (_ = y), S.ended ? g(this, _) : (T || n(this, S, f, _)) && (S.pendingcb++, C = l(this, S, T, f, D, _)), C;
        }, p.prototype.cork = function() {
          var f = this._writableState;
          f.corked++;
        }, p.prototype.uncork = function() {
          var f = this._writableState;
          f.corked && (f.corked--, !f.writing && !f.corked && !f.finished && !f.bufferProcessing && f.bufferedRequest && j(this, f));
        }, p.prototype.setDefaultEncoding = function(D) {
          if (typeof D == "string" && (D = D.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((D + "").toLowerCase()) > -1))
            throw new TypeError("Unknown encoding: " + D);
          return this._writableState.defaultEncoding = D, this;
        };
        function i(f, D, _) {
          return !f.objectMode && f.decodeStrings !== !1 && typeof D == "string" && (D = e.from(D, _)), D;
        }
        function l(f, D, _, S, C, T) {
          _ || (S = i(D, S, C), h.isBuffer(S) && (C = "buffer"));
          var P = D.objectMode ? 1 : S.length;
          D.length += P;
          var M = D.length < D.highWaterMark;
          if (M || (D.needDrain = !0), D.writing || D.corked) {
            var G = D.lastBufferedRequest;
            D.lastBufferedRequest = new c(S, C, T), G ? G.next = D.lastBufferedRequest : D.bufferedRequest = D.lastBufferedRequest, D.bufferedRequestCount += 1;
          } else
            u(f, D, !1, P, S, C, T);
          return M;
        }
        function u(f, D, _, S, C, T, P) {
          D.writelen = S, D.writecb = P, D.writing = !0, D.sync = !0, _ ? f._writev(C, D.onwrite) : f._write(C, T, D.onwrite), D.sync = !1;
        }
        function w(f, D, _, S, C) {
          --D.pendingcb, _ ? J(C, S) : C(S), f._writableState.errorEmitted = !0, f.emit("error", S);
        }
        function O(f) {
          f.writing = !1, f.writecb = null, f.length -= f.writelen, f.writelen = 0;
        }
        function b(f, D) {
          var _ = f._writableState, S = _.sync, C = _.writecb;
          if (O(_), D)
            w(f, _, S, D, C);
          else {
            var T = X(_);
            !T && !_.corked && !_.bufferProcessing && _.bufferedRequest && j(f, _), S ? o(A, f, _, T, C) : A(f, _, T, C);
          }
        }
        function A(f, D, _, S) {
          _ || Y(f, D), D.pendingcb--, S(), U(f, D);
        }
        function Y(f, D) {
          D.length === 0 && D.needDrain && (D.needDrain = !1, f.emit("drain"));
        }
        function j(f, D) {
          D.bufferProcessing = !0;
          var _ = D.bufferedRequest;
          if (f._writev && _ && _.next) {
            var S = D.bufferedRequestCount, C = new Array(S), T = D.corkedRequestsFree;
            T.entry = _;
            for (var P = 0; _; )
              C[P] = _, _ = _.next, P += 1;
            u(f, D, !0, D.length, C, "", T.finish), D.pendingcb++, D.lastBufferedRequest = null, T.next ? (D.corkedRequestsFree = T.next, T.next = null) : D.corkedRequestsFree = new x(D);
          } else {
            for (; _; ) {
              var M = _.chunk, G = _.encoding, Z = _.callback, $ = D.objectMode ? 1 : M.length;
              if (u(f, D, !1, $, M, G, Z), _ = _.next, D.writing)
                break;
            }
            _ === null && (D.lastBufferedRequest = null);
          }
          D.bufferedRequestCount = 0, D.bufferedRequest = _, D.bufferProcessing = !1;
        }
        p.prototype._write = function(f, D, _) {
          _(new Error("_write() is not implemented"));
        }, p.prototype._writev = null, p.prototype.end = function(f, D, _) {
          var S = this._writableState;
          typeof f == "function" ? (_ = f, f = null, D = null) : typeof D == "function" && (_ = D, D = null), f != null && this.write(f, D), S.corked && (S.corked = 1, this.uncork()), !S.ending && !S.finished && k(this, S, _);
        };
        function X(f) {
          return f.ending && f.length === 0 && f.bufferedRequest === null && !f.finished && !f.writing;
        }
        function B(f, D) {
          D.prefinished || (D.prefinished = !0, f.emit("prefinish"));
        }
        function U(f, D) {
          var _ = X(D);
          return _ && (D.pendingcb === 0 ? (B(f, D), D.finished = !0, f.emit("finish")) : B(f, D)), _;
        }
        function k(f, D, _) {
          D.ending = !0, U(f, D), _ && (D.finished ? J(_) : f.once("finish", _)), D.ended = !0, f.writable = !1;
        }
        function x(f) {
          var D = this;
          this.next = null, this.entry = null, this.finish = function(_) {
            var S = D.entry;
            for (D.entry = null; S; ) {
              var C = S.callback;
              f.pendingcb--, C(_), S = S.next;
            }
            f.corkedRequestsFree ? f.corkedRequestsFree.next = D : f.corkedRequestsFree = D;
          };
        }
      }).call(this, le("_process"));
    }, { "./_stream_duplex": 104, _process: 102, buffer: 78, "buffer-shims": 77, "core-util-is": 79, events: 82, inherits: 84, "process-nextick-args": 101, "util-deprecate": 118 }], 109: [function(le, ce, re) {
      le("buffer").Buffer;
      var ae = le("buffer-shims");
      ce.exports = J;
      function J() {
        this.head = null, this.tail = null, this.length = 0;
      }
      J.prototype.push = function(o) {
        var F = { data: o, next: null };
        this.length > 0 ? this.tail.next = F : this.head = F, this.tail = F, ++this.length;
      }, J.prototype.unshift = function(o) {
        var F = { data: o, next: this.head };
        this.length === 0 && (this.tail = F), this.head = F, ++this.length;
      }, J.prototype.shift = function() {
        if (this.length !== 0) {
          var o = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, o;
        }
      }, J.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, J.prototype.join = function(o) {
        if (this.length === 0)
          return "";
        for (var F = this.head, t = "" + F.data; F = F.next; )
          t += o + F.data;
        return t;
      }, J.prototype.concat = function(o) {
        if (this.length === 0)
          return ae.alloc(0);
        if (this.length === 1)
          return this.head.data;
        for (var F = ae.allocUnsafe(o >>> 0), t = this.head, a = 0; t; )
          t.data.copy(F, a), a += t.data.length, t = t.next;
        return F;
      };
    }, { buffer: 78, "buffer-shims": 77 }], 110: [function(le, ce, re) {
      ce.exports = le("./lib/_stream_passthrough.js");
    }, { "./lib/_stream_passthrough.js": 105 }], 111: [function(le, ce, re) {
      (function(ae) {
        var J = function() {
          try {
            return le("stream");
          } catch {
          }
        }();
        re = ce.exports = le("./lib/_stream_readable.js"), re.Stream = J || re, re.Readable = re, re.Writable = le("./lib/_stream_writable.js"), re.Duplex = le("./lib/_stream_duplex.js"), re.Transform = le("./lib/_stream_transform.js"), re.PassThrough = le("./lib/_stream_passthrough.js"), !ae.browser && ae.env.READABLE_STREAM === "disable" && J && (ce.exports = J);
      }).call(this, le("_process"));
    }, { "./lib/_stream_duplex.js": 104, "./lib/_stream_passthrough.js": 105, "./lib/_stream_readable.js": 106, "./lib/_stream_transform.js": 107, "./lib/_stream_writable.js": 108, _process: 102 }], 112: [function(le, ce, re) {
      ce.exports = le("./lib/_stream_transform.js");
    }, { "./lib/_stream_transform.js": 107 }], 113: [function(le, ce, re) {
      ce.exports = le("./lib/_stream_writable.js");
    }, { "./lib/_stream_writable.js": 108 }], 114: [function(le, ce, re) {
      (function(ae) {
        (function(J) {
          J.parser = function(q, N) {
            return new F(q, N);
          }, J.SAXParser = F, J.SAXStream = c, J.createStream = y, J.MAX_BUFFER_LENGTH = 64 * 1024;
          var o = [
            "comment",
            "sgmlDecl",
            "textNode",
            "tagName",
            "doctype",
            "procInstName",
            "procInstBody",
            "entity",
            "attribName",
            "attribValue",
            "cdata",
            "script"
          ];
          J.EVENTS = [
            "text",
            "processinginstruction",
            "sgmldeclaration",
            "doctype",
            "comment",
            "attribute",
            "opentag",
            "closetag",
            "opencdata",
            "cdata",
            "closecdata",
            "error",
            "end",
            "ready",
            "script",
            "opennamespace",
            "closenamespace"
          ];
          function F(q, N) {
            if (!(this instanceof F))
              return new F(q, N);
            var Q = this;
            a(Q), Q.q = Q.c = "", Q.bufferCheckPosition = J.MAX_BUFFER_LENGTH, Q.opt = N || {}, Q.opt.lowercase = Q.opt.lowercase || Q.opt.lowercasetags, Q.looseCase = Q.opt.lowercase ? "toLowerCase" : "toUpperCase", Q.tags = [], Q.closed = Q.closedRoot = Q.sawRoot = !1, Q.tag = Q.error = null, Q.strict = !!q, Q.noscript = !!(q || Q.opt.noscript), Q.state = x.BEGIN, Q.strictEntities = Q.opt.strictEntities, Q.ENTITIES = Q.strictEntities ? Object.create(J.XML_ENTITIES) : Object.create(J.ENTITIES), Q.attribList = [], Q.opt.xmlns && (Q.ns = Object.create(O)), Q.trackPosition = Q.opt.position !== !1, Q.trackPosition && (Q.position = Q.line = Q.column = 0), D(Q, "onready");
          }
          Object.create || (Object.create = function(q) {
            function N() {
            }
            N.prototype = q;
            var Q = new N();
            return Q;
          }), Object.keys || (Object.keys = function(q) {
            var N = [];
            for (var Q in q)
              q.hasOwnProperty(Q) && N.push(Q);
            return N;
          });
          function t(q) {
            for (var N = Math.max(J.MAX_BUFFER_LENGTH, 10), Q = 0, E = 0, te = o.length; E < te; E++) {
              var oe = q[o[E]].length;
              if (oe > N)
                switch (o[E]) {
                  case "textNode":
                    S(q);
                    break;
                  case "cdata":
                    _(q, "oncdata", q.cdata), q.cdata = "";
                    break;
                  case "script":
                    _(q, "onscript", q.script), q.script = "";
                    break;
                  default:
                    T(q, "Max buffer length exceeded: " + o[E]);
                }
              Q = Math.max(Q, oe);
            }
            var ee = J.MAX_BUFFER_LENGTH - Q;
            q.bufferCheckPosition = ee + q.position;
          }
          function a(q) {
            for (var N = 0, Q = o.length; N < Q; N++)
              q[o[N]] = "";
          }
          function v(q) {
            S(q), q.cdata !== "" && (_(q, "oncdata", q.cdata), q.cdata = ""), q.script !== "" && (_(q, "onscript", q.script), q.script = "");
          }
          F.prototype = {
            end: function() {
              P(this);
            },
            write: se,
            resume: function() {
              return this.error = null, this;
            },
            close: function() {
              return this.write(null);
            },
            flush: function() {
              v(this);
            }
          };
          var h;
          try {
            h = le("stream").Stream;
          } catch {
            h = function() {
            };
          }
          var e = J.EVENTS.filter(function(q) {
            return q !== "error" && q !== "end";
          });
          function y(q, N) {
            return new c(q, N);
          }
          function c(q, N) {
            if (!(this instanceof c))
              return new c(q, N);
            h.apply(this), this._parser = new F(q, N), this.writable = !0, this.readable = !0;
            var Q = this;
            this._parser.onend = function() {
              Q.emit("end");
            }, this._parser.onerror = function(E) {
              Q.emit("error", E), Q._parser.error = null;
            }, this._decoder = null, e.forEach(function(E) {
              Object.defineProperty(Q, "on" + E, {
                get: function() {
                  return Q._parser["on" + E];
                },
                set: function(te) {
                  if (!te)
                    return Q.removeAllListeners(E), Q._parser["on" + E] = te, te;
                  Q.on(E, te);
                },
                enumerable: !0,
                configurable: !1
              });
            });
          }
          c.prototype = Object.create(h.prototype, {
            constructor: {
              value: c
            }
          }), c.prototype.write = function(q) {
            if (typeof ae == "function" && typeof ae.isBuffer == "function" && ae.isBuffer(q)) {
              if (!this._decoder) {
                var N = le("string_decoder").StringDecoder;
                this._decoder = new N("utf8");
              }
              q = this._decoder.write(q);
            }
            return this._parser.write(q.toString()), this.emit("data", q), !0;
          }, c.prototype.end = function(q) {
            return q && q.length && this.write(q), this._parser.end(), !0;
          }, c.prototype.on = function(q, N) {
            var Q = this;
            return !Q._parser["on" + q] && e.indexOf(q) !== -1 && (Q._parser["on" + q] = function() {
              var E = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
              E.splice(0, 0, q), Q.emit.apply(Q, E);
            }), h.prototype.on.call(Q, q, N);
          };
          var d = `\r
	 `, m = "0124356789", p = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", g = `'"`, n = d + ">", i = "[CDATA[", l = "DOCTYPE", u = "http://www.w3.org/XML/1998/namespace", w = "http://www.w3.org/2000/xmlns/", O = { xml: u, xmlns: w };
          d = X(d), m = X(m), p = X(p);
          var b = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, A = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/, Y = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, j = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/;
          g = X(g), n = X(n);
          function X(q) {
            return q.split("").reduce(function(N, Q) {
              return N[Q] = !0, N;
            }, {});
          }
          function B(q) {
            return Object.prototype.toString.call(q) === "[object RegExp]";
          }
          function U(q, N) {
            return B(q) ? !!N.match(q) : q[N];
          }
          function k(q, N) {
            return !U(q, N);
          }
          var x = 0;
          J.STATE = {
            BEGIN: x++,
            // leading byte order mark or whitespace
            BEGIN_WHITESPACE: x++,
            // leading whitespace
            TEXT: x++,
            // general stuff
            TEXT_ENTITY: x++,
            // &amp and such.
            OPEN_WAKA: x++,
            // <
            SGML_DECL: x++,
            // <!BLARG
            SGML_DECL_QUOTED: x++,
            // <!BLARG foo "bar
            DOCTYPE: x++,
            // <!DOCTYPE
            DOCTYPE_QUOTED: x++,
            // <!DOCTYPE "//blah
            DOCTYPE_DTD: x++,
            // <!DOCTYPE "//blah" [ ...
            DOCTYPE_DTD_QUOTED: x++,
            // <!DOCTYPE "//blah" [ "foo
            COMMENT_STARTING: x++,
            // <!-
            COMMENT: x++,
            // <!--
            COMMENT_ENDING: x++,
            // <!-- blah -
            COMMENT_ENDED: x++,
            // <!-- blah --
            CDATA: x++,
            // <![CDATA[ something
            CDATA_ENDING: x++,
            // ]
            CDATA_ENDING_2: x++,
            // ]]
            PROC_INST: x++,
            // <?hi
            PROC_INST_BODY: x++,
            // <?hi there
            PROC_INST_ENDING: x++,
            // <?hi "there" ?
            OPEN_TAG: x++,
            // <strong
            OPEN_TAG_SLASH: x++,
            // <strong /
            ATTRIB: x++,
            // <a
            ATTRIB_NAME: x++,
            // <a foo
            ATTRIB_NAME_SAW_WHITE: x++,
            // <a foo _
            ATTRIB_VALUE: x++,
            // <a foo=
            ATTRIB_VALUE_QUOTED: x++,
            // <a foo="bar
            ATTRIB_VALUE_CLOSED: x++,
            // <a foo="bar"
            ATTRIB_VALUE_UNQUOTED: x++,
            // <a foo=bar
            ATTRIB_VALUE_ENTITY_Q: x++,
            // <foo bar="&quot;"
            ATTRIB_VALUE_ENTITY_U: x++,
            // <foo bar=&quot
            CLOSE_TAG: x++,
            // </a
            CLOSE_TAG_SAW_WHITE: x++,
            // </a   >
            SCRIPT: x++,
            // <script> ...
            SCRIPT_ENDING: x++
            // <script> ... <
          }, J.XML_ENTITIES = {
            amp: "&",
            gt: ">",
            lt: "<",
            quot: '"',
            apos: "'"
          }, J.ENTITIES = {
            amp: "&",
            gt: ">",
            lt: "<",
            quot: '"',
            apos: "'",
            AElig: 198,
            Aacute: 193,
            Acirc: 194,
            Agrave: 192,
            Aring: 197,
            Atilde: 195,
            Auml: 196,
            Ccedil: 199,
            ETH: 208,
            Eacute: 201,
            Ecirc: 202,
            Egrave: 200,
            Euml: 203,
            Iacute: 205,
            Icirc: 206,
            Igrave: 204,
            Iuml: 207,
            Ntilde: 209,
            Oacute: 211,
            Ocirc: 212,
            Ograve: 210,
            Oslash: 216,
            Otilde: 213,
            Ouml: 214,
            THORN: 222,
            Uacute: 218,
            Ucirc: 219,
            Ugrave: 217,
            Uuml: 220,
            Yacute: 221,
            aacute: 225,
            acirc: 226,
            aelig: 230,
            agrave: 224,
            aring: 229,
            atilde: 227,
            auml: 228,
            ccedil: 231,
            eacute: 233,
            ecirc: 234,
            egrave: 232,
            eth: 240,
            euml: 235,
            iacute: 237,
            icirc: 238,
            igrave: 236,
            iuml: 239,
            ntilde: 241,
            oacute: 243,
            ocirc: 244,
            ograve: 242,
            oslash: 248,
            otilde: 245,
            ouml: 246,
            szlig: 223,
            thorn: 254,
            uacute: 250,
            ucirc: 251,
            ugrave: 249,
            uuml: 252,
            yacute: 253,
            yuml: 255,
            copy: 169,
            reg: 174,
            nbsp: 160,
            iexcl: 161,
            cent: 162,
            pound: 163,
            curren: 164,
            yen: 165,
            brvbar: 166,
            sect: 167,
            uml: 168,
            ordf: 170,
            laquo: 171,
            not: 172,
            shy: 173,
            macr: 175,
            deg: 176,
            plusmn: 177,
            sup1: 185,
            sup2: 178,
            sup3: 179,
            acute: 180,
            micro: 181,
            para: 182,
            middot: 183,
            cedil: 184,
            ordm: 186,
            raquo: 187,
            frac14: 188,
            frac12: 189,
            frac34: 190,
            iquest: 191,
            times: 215,
            divide: 247,
            OElig: 338,
            oelig: 339,
            Scaron: 352,
            scaron: 353,
            Yuml: 376,
            fnof: 402,
            circ: 710,
            tilde: 732,
            Alpha: 913,
            Beta: 914,
            Gamma: 915,
            Delta: 916,
            Epsilon: 917,
            Zeta: 918,
            Eta: 919,
            Theta: 920,
            Iota: 921,
            Kappa: 922,
            Lambda: 923,
            Mu: 924,
            Nu: 925,
            Xi: 926,
            Omicron: 927,
            Pi: 928,
            Rho: 929,
            Sigma: 931,
            Tau: 932,
            Upsilon: 933,
            Phi: 934,
            Chi: 935,
            Psi: 936,
            Omega: 937,
            alpha: 945,
            beta: 946,
            gamma: 947,
            delta: 948,
            epsilon: 949,
            zeta: 950,
            eta: 951,
            theta: 952,
            iota: 953,
            kappa: 954,
            lambda: 955,
            mu: 956,
            nu: 957,
            xi: 958,
            omicron: 959,
            pi: 960,
            rho: 961,
            sigmaf: 962,
            sigma: 963,
            tau: 964,
            upsilon: 965,
            phi: 966,
            chi: 967,
            psi: 968,
            omega: 969,
            thetasym: 977,
            upsih: 978,
            piv: 982,
            ensp: 8194,
            emsp: 8195,
            thinsp: 8201,
            zwnj: 8204,
            zwj: 8205,
            lrm: 8206,
            rlm: 8207,
            ndash: 8211,
            mdash: 8212,
            lsquo: 8216,
            rsquo: 8217,
            sbquo: 8218,
            ldquo: 8220,
            rdquo: 8221,
            bdquo: 8222,
            dagger: 8224,
            Dagger: 8225,
            bull: 8226,
            hellip: 8230,
            permil: 8240,
            prime: 8242,
            Prime: 8243,
            lsaquo: 8249,
            rsaquo: 8250,
            oline: 8254,
            frasl: 8260,
            euro: 8364,
            image: 8465,
            weierp: 8472,
            real: 8476,
            trade: 8482,
            alefsym: 8501,
            larr: 8592,
            uarr: 8593,
            rarr: 8594,
            darr: 8595,
            harr: 8596,
            crarr: 8629,
            lArr: 8656,
            uArr: 8657,
            rArr: 8658,
            dArr: 8659,
            hArr: 8660,
            forall: 8704,
            part: 8706,
            exist: 8707,
            empty: 8709,
            nabla: 8711,
            isin: 8712,
            notin: 8713,
            ni: 8715,
            prod: 8719,
            sum: 8721,
            minus: 8722,
            lowast: 8727,
            radic: 8730,
            prop: 8733,
            infin: 8734,
            ang: 8736,
            and: 8743,
            or: 8744,
            cap: 8745,
            cup: 8746,
            int: 8747,
            there4: 8756,
            sim: 8764,
            cong: 8773,
            asymp: 8776,
            ne: 8800,
            equiv: 8801,
            le: 8804,
            ge: 8805,
            sub: 8834,
            sup: 8835,
            nsub: 8836,
            sube: 8838,
            supe: 8839,
            oplus: 8853,
            otimes: 8855,
            perp: 8869,
            sdot: 8901,
            lceil: 8968,
            rceil: 8969,
            lfloor: 8970,
            rfloor: 8971,
            lang: 9001,
            rang: 9002,
            loz: 9674,
            spades: 9824,
            clubs: 9827,
            hearts: 9829,
            diams: 9830
          }, Object.keys(J.ENTITIES).forEach(function(q) {
            var N = J.ENTITIES[q], Q = typeof N == "number" ? String.fromCharCode(N) : N;
            J.ENTITIES[q] = Q;
          });
          for (var f in J.STATE)
            J.STATE[J.STATE[f]] = f;
          x = J.STATE;
          function D(q, N, Q) {
            q[N] && q[N](Q);
          }
          function _(q, N, Q) {
            q.textNode && S(q), D(q, N, Q);
          }
          function S(q) {
            q.textNode = C(q.opt, q.textNode), q.textNode && D(q, "ontext", q.textNode), q.textNode = "";
          }
          function C(q, N) {
            return q.trim && (N = N.trim()), q.normalize && (N = N.replace(/\s+/g, " ")), N;
          }
          function T(q, N) {
            return S(q), q.trackPosition && (N += `
Line: ` + q.line + `
Column: ` + q.column + `
Char: ` + q.c), N = new Error(N), q.error = N, D(q, "onerror", N), q;
          }
          function P(q) {
            return q.sawRoot && !q.closedRoot && M(q, "Unclosed root tag"), q.state !== x.BEGIN && q.state !== x.BEGIN_WHITESPACE && q.state !== x.TEXT && T(q, "Unexpected end"), S(q), q.c = "", q.closed = !0, D(q, "onend"), F.call(q, q.strict, q.opt), q;
          }
          function M(q, N) {
            if (typeof q != "object" || !(q instanceof F))
              throw new Error("bad call to strictFail");
            q.strict && T(q, N);
          }
          function G(q) {
            q.strict || (q.tagName = q.tagName[q.looseCase]());
            var N = q.tags[q.tags.length - 1] || q, Q = q.tag = { name: q.tagName, attributes: {} };
            q.opt.xmlns && (Q.ns = N.ns), q.attribList.length = 0;
          }
          function Z(q, N) {
            var Q = q.indexOf(":"), E = Q < 0 ? ["", q] : q.split(":"), te = E[0], oe = E[1];
            return N && q === "xmlns" && (te = "xmlns", oe = ""), { prefix: te, local: oe };
          }
          function $(q) {
            if (q.strict || (q.attribName = q.attribName[q.looseCase]()), q.attribList.indexOf(q.attribName) !== -1 || q.tag.attributes.hasOwnProperty(q.attribName)) {
              q.attribName = q.attribValue = "";
              return;
            }
            if (q.opt.xmlns) {
              var N = Z(q.attribName, !0), Q = N.prefix, E = N.local;
              if (Q === "xmlns")
                if (E === "xml" && q.attribValue !== u)
                  M(
                    q,
                    "xml: prefix must be bound to " + u + `
Actual: ` + q.attribValue
                  );
                else if (E === "xmlns" && q.attribValue !== w)
                  M(
                    q,
                    "xmlns: prefix must be bound to " + w + `
Actual: ` + q.attribValue
                  );
                else {
                  var te = q.tag, oe = q.tags[q.tags.length - 1] || q;
                  te.ns === oe.ns && (te.ns = Object.create(oe.ns)), te.ns[E] = q.attribValue;
                }
              q.attribList.push([q.attribName, q.attribValue]);
            } else
              q.tag.attributes[q.attribName] = q.attribValue, _(q, "onattribute", {
                name: q.attribName,
                value: q.attribValue
              });
            q.attribName = q.attribValue = "";
          }
          function z(q, N) {
            if (q.opt.xmlns) {
              var Q = q.tag, E = Z(q.tagName);
              Q.prefix = E.prefix, Q.local = E.local, Q.uri = Q.ns[E.prefix] || "", Q.prefix && !Q.uri && (M(q, "Unbound namespace prefix: " + JSON.stringify(q.tagName)), Q.uri = E.prefix);
              var te = q.tags[q.tags.length - 1] || q;
              Q.ns && te.ns !== Q.ns && Object.keys(Q.ns).forEach(function(xe) {
                _(q, "onopennamespace", {
                  prefix: xe,
                  uri: Q.ns[xe]
                });
              });
              for (var oe = 0, ee = q.attribList.length; oe < ee; oe++) {
                var W = q.attribList[oe], I = W[0], H = W[1], ie = Z(I, !0), ue = ie.prefix, fe = ie.local, de = ue === "" ? "" : Q.ns[ue] || "", pe = {
                  name: I,
                  value: H,
                  prefix: ue,
                  local: fe,
                  uri: de
                };
                ue && ue !== "xmlns" && !de && (M(q, "Unbound namespace prefix: " + JSON.stringify(ue)), pe.uri = ue), q.tag.attributes[I] = pe, _(q, "onattribute", pe);
              }
              q.attribList.length = 0;
            }
            q.tag.isSelfClosing = !!N, q.sawRoot = !0, q.tags.push(q.tag), _(q, "onopentag", q.tag), N || (!q.noscript && q.tagName.toLowerCase() === "script" ? q.state = x.SCRIPT : q.state = x.TEXT, q.tag = null, q.tagName = ""), q.attribName = q.attribValue = "", q.attribList.length = 0;
          }
          function V(q) {
            if (!q.tagName) {
              M(q, "Weird empty close tag."), q.textNode += "</>", q.state = x.TEXT;
              return;
            }
            if (q.script) {
              if (q.tagName !== "script") {
                q.script += "</" + q.tagName + ">", q.tagName = "", q.state = x.SCRIPT;
                return;
              }
              _(q, "onscript", q.script), q.script = "";
            }
            var N = q.tags.length, Q = q.tagName;
            q.strict || (Q = Q[q.looseCase]());
            for (var E = Q; N--; ) {
              var te = q.tags[N];
              if (te.name !== E)
                M(q, "Unexpected close tag");
              else
                break;
            }
            if (N < 0) {
              M(q, "Unmatched closing tag: " + q.tagName), q.textNode += "</" + q.tagName + ">", q.state = x.TEXT;
              return;
            }
            q.tagName = Q;
            for (var oe = q.tags.length; oe-- > N; ) {
              var ee = q.tag = q.tags.pop();
              q.tagName = q.tag.name, _(q, "onclosetag", q.tagName);
              var W = {};
              for (var I in ee.ns)
                W[I] = ee.ns[I];
              var H = q.tags[q.tags.length - 1] || q;
              q.opt.xmlns && ee.ns !== H.ns && Object.keys(ee.ns).forEach(function(ie) {
                var ue = ee.ns[ie];
                _(q, "onclosenamespace", { prefix: ie, uri: ue });
              });
            }
            N === 0 && (q.closedRoot = !0), q.tagName = q.attribValue = q.attribName = "", q.attribList.length = 0, q.state = x.TEXT;
          }
          function L(q) {
            var N = q.entity, Q = N.toLowerCase(), E, te = "";
            return q.ENTITIES[N] ? q.ENTITIES[N] : q.ENTITIES[Q] ? q.ENTITIES[Q] : (N = Q, N.charAt(0) === "#" && (N.charAt(1) === "x" ? (N = N.slice(2), E = parseInt(N, 16), te = E.toString(16)) : (N = N.slice(1), E = parseInt(N, 10), te = E.toString(10))), N = N.replace(/^0+/, ""), te.toLowerCase() !== N ? (M(q, "Invalid character entity"), "&" + q.entity + ";") : String.fromCodePoint(E));
          }
          function K(q, N) {
            N === "<" ? (q.state = x.OPEN_WAKA, q.startTagPosition = q.position) : k(d, N) && (M(q, "Non-whitespace before first tag."), q.textNode = N, q.state = x.TEXT);
          }
          function ne(q, N) {
            var Q = "";
            return N < q.length && (Q = q.charAt(N)), Q;
          }
          function se(q) {
            var N = this;
            if (this.error)
              throw this.error;
            if (N.closed)
              return T(
                N,
                "Cannot write after close. Assign an onready handler."
              );
            if (q === null)
              return P(N);
            typeof q == "object" && (q = q.toString());
            for (var Q = 0, E = ""; E = ne(q, Q++), N.c = E, !!E; )
              switch (N.trackPosition && (N.position++, E === `
` ? (N.line++, N.column = 0) : N.column++), N.state) {
                case x.BEGIN:
                  if (N.state = x.BEGIN_WHITESPACE, E === "\uFEFF")
                    continue;
                  K(N, E);
                  continue;
                case x.BEGIN_WHITESPACE:
                  K(N, E);
                  continue;
                case x.TEXT:
                  if (N.sawRoot && !N.closedRoot) {
                    for (var te = Q - 1; E && E !== "<" && E !== "&"; )
                      E = ne(q, Q++), E && N.trackPosition && (N.position++, E === `
` ? (N.line++, N.column = 0) : N.column++);
                    N.textNode += q.substring(te, Q - 1);
                  }
                  E === "<" && !(N.sawRoot && N.closedRoot && !N.strict) ? (N.state = x.OPEN_WAKA, N.startTagPosition = N.position) : (k(d, E) && (!N.sawRoot || N.closedRoot) && M(N, "Text data outside of root node."), E === "&" ? N.state = x.TEXT_ENTITY : N.textNode += E);
                  continue;
                case x.SCRIPT:
                  E === "<" ? N.state = x.SCRIPT_ENDING : N.script += E;
                  continue;
                case x.SCRIPT_ENDING:
                  E === "/" ? N.state = x.CLOSE_TAG : (N.script += "<" + E, N.state = x.SCRIPT);
                  continue;
                case x.OPEN_WAKA:
                  if (E === "!")
                    N.state = x.SGML_DECL, N.sgmlDecl = "";
                  else if (!U(d, E))
                    if (U(b, E))
                      N.state = x.OPEN_TAG, N.tagName = E;
                    else if (E === "/")
                      N.state = x.CLOSE_TAG, N.tagName = "";
                    else if (E === "?")
                      N.state = x.PROC_INST, N.procInstName = N.procInstBody = "";
                    else {
                      if (M(N, "Unencoded <"), N.startTagPosition + 1 < N.position) {
                        var oe = N.position - N.startTagPosition;
                        E = new Array(oe).join(" ") + E;
                      }
                      N.textNode += "<" + E, N.state = x.TEXT;
                    }
                  continue;
                case x.SGML_DECL:
                  (N.sgmlDecl + E).toUpperCase() === i ? (_(N, "onopencdata"), N.state = x.CDATA, N.sgmlDecl = "", N.cdata = "") : N.sgmlDecl + E === "--" ? (N.state = x.COMMENT, N.comment = "", N.sgmlDecl = "") : (N.sgmlDecl + E).toUpperCase() === l ? (N.state = x.DOCTYPE, (N.doctype || N.sawRoot) && M(
                    N,
                    "Inappropriately located doctype declaration"
                  ), N.doctype = "", N.sgmlDecl = "") : E === ">" ? (_(N, "onsgmldeclaration", N.sgmlDecl), N.sgmlDecl = "", N.state = x.TEXT) : (U(g, E) && (N.state = x.SGML_DECL_QUOTED), N.sgmlDecl += E);
                  continue;
                case x.SGML_DECL_QUOTED:
                  E === N.q && (N.state = x.SGML_DECL, N.q = ""), N.sgmlDecl += E;
                  continue;
                case x.DOCTYPE:
                  E === ">" ? (N.state = x.TEXT, _(N, "ondoctype", N.doctype), N.doctype = !0) : (N.doctype += E, E === "[" ? N.state = x.DOCTYPE_DTD : U(g, E) && (N.state = x.DOCTYPE_QUOTED, N.q = E));
                  continue;
                case x.DOCTYPE_QUOTED:
                  N.doctype += E, E === N.q && (N.q = "", N.state = x.DOCTYPE);
                  continue;
                case x.DOCTYPE_DTD:
                  N.doctype += E, E === "]" ? N.state = x.DOCTYPE : U(g, E) && (N.state = x.DOCTYPE_DTD_QUOTED, N.q = E);
                  continue;
                case x.DOCTYPE_DTD_QUOTED:
                  N.doctype += E, E === N.q && (N.state = x.DOCTYPE_DTD, N.q = "");
                  continue;
                case x.COMMENT:
                  E === "-" ? N.state = x.COMMENT_ENDING : N.comment += E;
                  continue;
                case x.COMMENT_ENDING:
                  E === "-" ? (N.state = x.COMMENT_ENDED, N.comment = C(N.opt, N.comment), N.comment && _(N, "oncomment", N.comment), N.comment = "") : (N.comment += "-" + E, N.state = x.COMMENT);
                  continue;
                case x.COMMENT_ENDED:
                  E !== ">" ? (M(N, "Malformed comment"), N.comment += "--" + E, N.state = x.COMMENT) : N.state = x.TEXT;
                  continue;
                case x.CDATA:
                  E === "]" ? N.state = x.CDATA_ENDING : N.cdata += E;
                  continue;
                case x.CDATA_ENDING:
                  E === "]" ? N.state = x.CDATA_ENDING_2 : (N.cdata += "]" + E, N.state = x.CDATA);
                  continue;
                case x.CDATA_ENDING_2:
                  E === ">" ? (N.cdata && _(N, "oncdata", N.cdata), _(N, "onclosecdata"), N.cdata = "", N.state = x.TEXT) : E === "]" ? N.cdata += "]" : (N.cdata += "]]" + E, N.state = x.CDATA);
                  continue;
                case x.PROC_INST:
                  E === "?" ? N.state = x.PROC_INST_ENDING : U(d, E) ? N.state = x.PROC_INST_BODY : N.procInstName += E;
                  continue;
                case x.PROC_INST_BODY:
                  if (!N.procInstBody && U(d, E))
                    continue;
                  E === "?" ? N.state = x.PROC_INST_ENDING : N.procInstBody += E;
                  continue;
                case x.PROC_INST_ENDING:
                  E === ">" ? (_(N, "onprocessinginstruction", {
                    name: N.procInstName,
                    body: N.procInstBody
                  }), N.procInstName = N.procInstBody = "", N.state = x.TEXT) : (N.procInstBody += "?" + E, N.state = x.PROC_INST_BODY);
                  continue;
                case x.OPEN_TAG:
                  U(A, E) ? N.tagName += E : (G(N), E === ">" ? z(N) : E === "/" ? N.state = x.OPEN_TAG_SLASH : (k(d, E) && M(N, "Invalid character in tag name"), N.state = x.ATTRIB));
                  continue;
                case x.OPEN_TAG_SLASH:
                  E === ">" ? (z(N, !0), V(N)) : (M(N, "Forward-slash in opening tag not followed by >"), N.state = x.ATTRIB);
                  continue;
                case x.ATTRIB:
                  if (U(d, E))
                    continue;
                  E === ">" ? z(N) : E === "/" ? N.state = x.OPEN_TAG_SLASH : U(b, E) ? (N.attribName = E, N.attribValue = "", N.state = x.ATTRIB_NAME) : M(N, "Invalid attribute name");
                  continue;
                case x.ATTRIB_NAME:
                  E === "=" ? N.state = x.ATTRIB_VALUE : E === ">" ? (M(N, "Attribute without value"), N.attribValue = N.attribName, $(N), z(N)) : U(d, E) ? N.state = x.ATTRIB_NAME_SAW_WHITE : U(A, E) ? N.attribName += E : M(N, "Invalid attribute name");
                  continue;
                case x.ATTRIB_NAME_SAW_WHITE:
                  if (E === "=")
                    N.state = x.ATTRIB_VALUE;
                  else {
                    if (U(d, E))
                      continue;
                    M(N, "Attribute without value"), N.tag.attributes[N.attribName] = "", N.attribValue = "", _(N, "onattribute", {
                      name: N.attribName,
                      value: ""
                    }), N.attribName = "", E === ">" ? z(N) : U(b, E) ? (N.attribName = E, N.state = x.ATTRIB_NAME) : (M(N, "Invalid attribute name"), N.state = x.ATTRIB);
                  }
                  continue;
                case x.ATTRIB_VALUE:
                  if (U(d, E))
                    continue;
                  U(g, E) ? (N.q = E, N.state = x.ATTRIB_VALUE_QUOTED) : (M(N, "Unquoted attribute value"), N.state = x.ATTRIB_VALUE_UNQUOTED, N.attribValue = E);
                  continue;
                case x.ATTRIB_VALUE_QUOTED:
                  if (E !== N.q) {
                    E === "&" ? N.state = x.ATTRIB_VALUE_ENTITY_Q : N.attribValue += E;
                    continue;
                  }
                  $(N), N.q = "", N.state = x.ATTRIB_VALUE_CLOSED;
                  continue;
                case x.ATTRIB_VALUE_CLOSED:
                  U(d, E) ? N.state = x.ATTRIB : E === ">" ? z(N) : E === "/" ? N.state = x.OPEN_TAG_SLASH : U(b, E) ? (M(N, "No whitespace between attributes"), N.attribName = E, N.attribValue = "", N.state = x.ATTRIB_NAME) : M(N, "Invalid attribute name");
                  continue;
                case x.ATTRIB_VALUE_UNQUOTED:
                  if (k(n, E)) {
                    E === "&" ? N.state = x.ATTRIB_VALUE_ENTITY_U : N.attribValue += E;
                    continue;
                  }
                  $(N), E === ">" ? z(N) : N.state = x.ATTRIB;
                  continue;
                case x.CLOSE_TAG:
                  if (N.tagName)
                    E === ">" ? V(N) : U(A, E) ? N.tagName += E : N.script ? (N.script += "</" + N.tagName, N.tagName = "", N.state = x.SCRIPT) : (k(d, E) && M(N, "Invalid tagname in closing tag"), N.state = x.CLOSE_TAG_SAW_WHITE);
                  else {
                    if (U(d, E))
                      continue;
                    k(b, E) ? N.script ? (N.script += "</" + E, N.state = x.SCRIPT) : M(N, "Invalid tagname in closing tag.") : N.tagName = E;
                  }
                  continue;
                case x.CLOSE_TAG_SAW_WHITE:
                  if (U(d, E))
                    continue;
                  E === ">" ? V(N) : M(N, "Invalid characters in closing tag");
                  continue;
                case x.TEXT_ENTITY:
                case x.ATTRIB_VALUE_ENTITY_Q:
                case x.ATTRIB_VALUE_ENTITY_U:
                  var ee, W;
                  switch (N.state) {
                    case x.TEXT_ENTITY:
                      ee = x.TEXT, W = "textNode";
                      break;
                    case x.ATTRIB_VALUE_ENTITY_Q:
                      ee = x.ATTRIB_VALUE_QUOTED, W = "attribValue";
                      break;
                    case x.ATTRIB_VALUE_ENTITY_U:
                      ee = x.ATTRIB_VALUE_UNQUOTED, W = "attribValue";
                      break;
                  }
                  E === ";" ? (N[W] += L(N), N.entity = "", N.state = ee) : U(N.entity.length ? j : Y, E) ? N.entity += E : (M(N, "Invalid character in entity name"), N[W] += "&" + N.entity + E, N.entity = "", N.state = ee);
                  continue;
                default:
                  throw new Error(N, "Unknown state: " + N.state);
              }
            return N.position >= N.bufferCheckPosition && t(N), N;
          }
          /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
          String.fromCodePoint || function() {
            var q = String.fromCharCode, N = Math.floor, Q = function() {
              var E = 16384, te = [], oe, ee, W = -1, I = arguments.length;
              if (!I)
                return "";
              for (var H = ""; ++W < I; ) {
                var ie = Number(arguments[W]);
                if (!isFinite(ie) || // `NaN`, `+Infinity`, or `-Infinity`
                ie < 0 || // not a valid Unicode code point
                ie > 1114111 || // not a valid Unicode code point
                N(ie) !== ie)
                  throw RangeError("Invalid code point: " + ie);
                ie <= 65535 ? te.push(ie) : (ie -= 65536, oe = (ie >> 10) + 55296, ee = ie % 1024 + 56320, te.push(oe, ee)), (W + 1 === I || te.length > E) && (H += q.apply(null, te), te.length = 0);
              }
              return H;
            };
            Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
              value: Q,
              configurable: !0,
              writable: !0
            }) : String.fromCodePoint = Q;
          }();
        })(typeof re > "u" ? this.sax = {} : re);
      }).call(this, le("buffer").Buffer);
    }, { buffer: 78, stream: 115, string_decoder: 116 }], 115: [function(le, ce, re) {
      ce.exports = o;
      var ae = le("events").EventEmitter, J = le("inherits");
      J(o, ae), o.Readable = le("readable-stream/readable.js"), o.Writable = le("readable-stream/writable.js"), o.Duplex = le("readable-stream/duplex.js"), o.Transform = le("readable-stream/transform.js"), o.PassThrough = le("readable-stream/passthrough.js"), o.Stream = o;
      function o() {
        ae.call(this);
      }
      o.prototype.pipe = function(F, t) {
        var a = this;
        function v(p) {
          F.writable && F.write(p) === !1 && a.pause && a.pause();
        }
        a.on("data", v);
        function h() {
          a.readable && a.resume && a.resume();
        }
        F.on("drain", h), !F._isStdio && (!t || t.end !== !1) && (a.on("end", y), a.on("close", c));
        var e = !1;
        function y() {
          e || (e = !0, F.end());
        }
        function c() {
          e || (e = !0, typeof F.destroy == "function" && F.destroy());
        }
        function d(p) {
          if (m(), ae.listenerCount(this, "error") === 0)
            throw p;
        }
        a.on("error", d), F.on("error", d);
        function m() {
          a.removeListener("data", v), F.removeListener("drain", h), a.removeListener("end", y), a.removeListener("close", c), a.removeListener("error", d), F.removeListener("error", d), a.removeListener("end", m), a.removeListener("close", m), F.removeListener("close", m);
        }
        return a.on("end", m), a.on("close", m), F.on("close", m), F.emit("pipe", a), F;
      };
    }, { events: 82, inherits: 84, "readable-stream/duplex.js": 103, "readable-stream/passthrough.js": 110, "readable-stream/readable.js": 111, "readable-stream/transform.js": 112, "readable-stream/writable.js": 113 }], 116: [function(le, ce, re) {
      var ae = le("buffer").Buffer, J = ae.isEncoding || function(h) {
        switch (h && h.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return !0;
          default:
            return !1;
        }
      };
      function o(h) {
        if (h && !J(h))
          throw new Error("Unknown encoding: " + h);
      }
      var F = re.StringDecoder = function(h) {
        switch (this.encoding = (h || "utf8").toLowerCase().replace(/[-_]/, ""), o(h), this.encoding) {
          case "utf8":
            this.surrogateSize = 3;
            break;
          case "ucs2":
          case "utf16le":
            this.surrogateSize = 2, this.detectIncompleteChar = a;
            break;
          case "base64":
            this.surrogateSize = 3, this.detectIncompleteChar = v;
            break;
          default:
            this.write = t;
            return;
        }
        this.charBuffer = new ae(6), this.charReceived = 0, this.charLength = 0;
      };
      F.prototype.write = function(h) {
        for (var e = ""; this.charLength; ) {
          var y = h.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : h.length;
          if (h.copy(this.charBuffer, this.charReceived, 0, y), this.charReceived += y, this.charReceived < this.charLength)
            return "";
          h = h.slice(y, h.length), e = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
          var d = e.charCodeAt(e.length - 1);
          if (d >= 55296 && d <= 56319) {
            this.charLength += this.surrogateSize, e = "";
            continue;
          }
          if (this.charReceived = this.charLength = 0, h.length === 0)
            return e;
          break;
        }
        this.detectIncompleteChar(h);
        var c = h.length;
        this.charLength && (h.copy(this.charBuffer, 0, h.length - this.charReceived, c), c -= this.charReceived), e += h.toString(this.encoding, 0, c);
        var c = e.length - 1, d = e.charCodeAt(c);
        if (d >= 55296 && d <= 56319) {
          var m = this.surrogateSize;
          return this.charLength += m, this.charReceived += m, this.charBuffer.copy(this.charBuffer, m, 0, m), h.copy(this.charBuffer, 0, 0, m), e.substring(0, c);
        }
        return e;
      }, F.prototype.detectIncompleteChar = function(h) {
        for (var e = h.length >= 3 ? 3 : h.length; e > 0; e--) {
          var y = h[h.length - e];
          if (e == 1 && y >> 5 == 6) {
            this.charLength = 2;
            break;
          }
          if (e <= 2 && y >> 4 == 14) {
            this.charLength = 3;
            break;
          }
          if (e <= 3 && y >> 3 == 30) {
            this.charLength = 4;
            break;
          }
        }
        this.charReceived = e;
      }, F.prototype.end = function(h) {
        var e = "";
        if (h && h.length && (e = this.write(h)), this.charReceived) {
          var y = this.charReceived, c = this.charBuffer, d = this.encoding;
          e += c.slice(0, y).toString(d);
        }
        return e;
      };
      function t(h) {
        return h.toString(this.encoding);
      }
      function a(h) {
        this.charReceived = h.length % 2, this.charLength = this.charReceived ? 2 : 0;
      }
      function v(h) {
        this.charReceived = h.length % 3, this.charLength = this.charReceived ? 3 : 0;
      }
    }, { buffer: 78 }], 117: [function(le, ce, re) {
      (function(ae) {
        (function(J, o) {
          typeof re == "object" && typeof ce < "u" ? ce.exports = o() : (J = typeof globalThis < "u" ? globalThis : J || self, function() {
            var F = J._, t = J._ = o();
            t.noConflict = function() {
              return J._ = F, t;
            };
          }());
        })(this, function() {
          var J = "1.13.1", o = typeof self == "object" && self.self === self && self || typeof ae == "object" && ae.global === ae && ae || Function("return this")() || {}, F = Array.prototype, t = Object.prototype, a = typeof Symbol < "u" ? Symbol.prototype : null, v = F.push, h = F.slice, e = t.toString, y = t.hasOwnProperty, c = typeof ArrayBuffer < "u", d = typeof DataView < "u", m = Array.isArray, p = Object.keys, g = Object.create, n = c && ArrayBuffer.isView, i = isNaN, l = isFinite, u = !{ toString: null }.propertyIsEnumerable("toString"), w = [
            "valueOf",
            "isPrototypeOf",
            "toString",
            "propertyIsEnumerable",
            "hasOwnProperty",
            "toLocaleString"
          ], O = Math.pow(2, 53) - 1;
          function b(me, _e) {
            return _e = _e == null ? me.length - 1 : +_e, function() {
              for (var Be = Math.max(arguments.length - _e, 0), Le = Array(Be), Ye = 0; Ye < Be; Ye++)
                Le[Ye] = arguments[Ye + _e];
              switch (_e) {
                case 0:
                  return me.call(this, Le);
                case 1:
                  return me.call(this, arguments[0], Le);
                case 2:
                  return me.call(this, arguments[0], arguments[1], Le);
              }
              var ze = Array(_e + 1);
              for (Ye = 0; Ye < _e; Ye++)
                ze[Ye] = arguments[Ye];
              return ze[_e] = Le, me.apply(this, ze);
            };
          }
          function A(me) {
            var _e = typeof me;
            return _e === "function" || _e === "object" && !!me;
          }
          function Y(me) {
            return me === null;
          }
          function j(me) {
            return me === void 0;
          }
          function X(me) {
            return me === !0 || me === !1 || e.call(me) === "[object Boolean]";
          }
          function B(me) {
            return !!(me && me.nodeType === 1);
          }
          function U(me) {
            var _e = "[object " + me + "]";
            return function(Be) {
              return e.call(Be) === _e;
            };
          }
          var k = U("String"), x = U("Number"), f = U("Date"), D = U("RegExp"), _ = U("Error"), S = U("Symbol"), C = U("ArrayBuffer"), T = U("Function"), P = o.document && o.document.childNodes;
          typeof /./ != "function" && typeof Int8Array != "object" && typeof P != "function" && (T = function(me) {
            return typeof me == "function" || !1;
          });
          var M = T, G = U("Object"), Z = d && G(new DataView(new ArrayBuffer(8))), $ = typeof Map < "u" && G(/* @__PURE__ */ new Map()), z = U("DataView");
          function V(me) {
            return me != null && M(me.getInt8) && C(me.buffer);
          }
          var L = Z ? V : z, K = m || U("Array");
          function ne(me, _e) {
            return me != null && y.call(me, _e);
          }
          var se = U("Arguments");
          (function() {
            se(arguments) || (se = function(me) {
              return ne(me, "callee");
            });
          })();
          var q = se;
          function N(me) {
            return !S(me) && l(me) && !isNaN(parseFloat(me));
          }
          function Q(me) {
            return x(me) && i(me);
          }
          function E(me) {
            return function() {
              return me;
            };
          }
          function te(me) {
            return function(_e) {
              var Be = me(_e);
              return typeof Be == "number" && Be >= 0 && Be <= O;
            };
          }
          function oe(me) {
            return function(_e) {
              return _e == null ? void 0 : _e[me];
            };
          }
          var ee = oe("byteLength"), W = te(ee), I = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
          function H(me) {
            return n ? n(me) && !L(me) : W(me) && I.test(e.call(me));
          }
          var ie = c ? H : E(!1), ue = oe("length");
          function fe(me) {
            for (var _e = {}, Be = me.length, Le = 0; Le < Be; ++Le)
              _e[me[Le]] = !0;
            return {
              contains: function(Ye) {
                return _e[Ye];
              },
              push: function(Ye) {
                return _e[Ye] = !0, me.push(Ye);
              }
            };
          }
          function de(me, _e) {
            _e = fe(_e);
            var Be = w.length, Le = me.constructor, Ye = M(Le) && Le.prototype || t, ze = "constructor";
            for (ne(me, ze) && !_e.contains(ze) && _e.push(ze); Be--; )
              ze = w[Be], ze in me && me[ze] !== Ye[ze] && !_e.contains(ze) && _e.push(ze);
          }
          function pe(me) {
            if (!A(me))
              return [];
            if (p)
              return p(me);
            var _e = [];
            for (var Be in me)
              ne(me, Be) && _e.push(Be);
            return u && de(me, _e), _e;
          }
          function xe(me) {
            if (me == null)
              return !0;
            var _e = ue(me);
            return typeof _e == "number" && (K(me) || k(me) || q(me)) ? _e === 0 : ue(pe(me)) === 0;
          }
          function Fe(me, _e) {
            var Be = pe(_e), Le = Be.length;
            if (me == null)
              return !Le;
            for (var Ye = Object(me), ze = 0; ze < Le; ze++) {
              var pt = Be[ze];
              if (_e[pt] !== Ye[pt] || !(pt in Ye))
                return !1;
            }
            return !0;
          }
          function Se(me) {
            if (me instanceof Se)
              return me;
            if (!(this instanceof Se))
              return new Se(me);
            this._wrapped = me;
          }
          Se.VERSION = J, Se.prototype.value = function() {
            return this._wrapped;
          }, Se.prototype.valueOf = Se.prototype.toJSON = Se.prototype.value, Se.prototype.toString = function() {
            return String(this._wrapped);
          };
          function Ce(me) {
            return new Uint8Array(
              me.buffer || me,
              me.byteOffset || 0,
              ee(me)
            );
          }
          var ke = "[object DataView]";
          function ye(me, _e, Be, Le) {
            if (me === _e)
              return me !== 0 || 1 / me === 1 / _e;
            if (me == null || _e == null)
              return !1;
            if (me !== me)
              return _e !== _e;
            var Ye = typeof me;
            return Ye !== "function" && Ye !== "object" && typeof _e != "object" ? !1 : De(me, _e, Be, Le);
          }
          function De(me, _e, Be, Le) {
            me instanceof Se && (me = me._wrapped), _e instanceof Se && (_e = _e._wrapped);
            var Ye = e.call(me);
            if (Ye !== e.call(_e))
              return !1;
            if (Z && Ye == "[object Object]" && L(me)) {
              if (!L(_e))
                return !1;
              Ye = ke;
            }
            switch (Ye) {
              case "[object RegExp]":
              case "[object String]":
                return "" + me == "" + _e;
              case "[object Number]":
                return +me != +me ? +_e != +_e : +me == 0 ? 1 / +me === 1 / _e : +me == +_e;
              case "[object Date]":
              case "[object Boolean]":
                return +me == +_e;
              case "[object Symbol]":
                return a.valueOf.call(me) === a.valueOf.call(_e);
              case "[object ArrayBuffer]":
              case ke:
                return De(Ce(me), Ce(_e), Be, Le);
            }
            var ze = Ye === "[object Array]";
            if (!ze && ie(me)) {
              var pt = ee(me);
              if (pt !== ee(_e))
                return !1;
              if (me.buffer === _e.buffer && me.byteOffset === _e.byteOffset)
                return !0;
              ze = !0;
            }
            if (!ze) {
              if (typeof me != "object" || typeof _e != "object")
                return !1;
              var Ot = me.constructor, Yt = _e.constructor;
              if (Ot !== Yt && !(M(Ot) && Ot instanceof Ot && M(Yt) && Yt instanceof Yt) && "constructor" in me && "constructor" in _e)
                return !1;
            }
            Be = Be || [], Le = Le || [];
            for (var Vt = Be.length; Vt--; )
              if (Be[Vt] === me)
                return Le[Vt] === _e;
            if (Be.push(me), Le.push(_e), ze) {
              if (Vt = me.length, Vt !== _e.length)
                return !1;
              for (; Vt--; )
                if (!ye(me[Vt], _e[Vt], Be, Le))
                  return !1;
            } else {
              var ln = pe(me), hn;
              if (Vt = ln.length, pe(_e).length !== Vt)
                return !1;
              for (; Vt--; )
                if (hn = ln[Vt], !(ne(_e, hn) && ye(me[hn], _e[hn], Be, Le)))
                  return !1;
            }
            return Be.pop(), Le.pop(), !0;
          }
          function Ae(me, _e) {
            return ye(me, _e);
          }
          function Te(me) {
            if (!A(me))
              return [];
            var _e = [];
            for (var Be in me)
              _e.push(Be);
            return u && de(me, _e), _e;
          }
          function ve(me) {
            var _e = ue(me);
            return function(Be) {
              if (Be == null)
                return !1;
              var Le = Te(Be);
              if (ue(Le))
                return !1;
              for (var Ye = 0; Ye < _e; Ye++)
                if (!M(Be[me[Ye]]))
                  return !1;
              return me !== Ee || !M(Be[Ne]);
            };
          }
          var Ne = "forEach", Ge = "has", it = ["clear", "delete"], Me = ["get", Ge, "set"], Ie = it.concat(Ne, Me), Ee = it.concat(Me), st = ["add"].concat(it, Ne, Ge), Qe = $ ? ve(Ie) : U("Map"), ct = $ ? ve(Ee) : U("WeakMap"), xt = $ ? ve(st) : U("Set"), Je = U("WeakSet");
          function mt(me) {
            for (var _e = pe(me), Be = _e.length, Le = Array(Be), Ye = 0; Ye < Be; Ye++)
              Le[Ye] = me[_e[Ye]];
            return Le;
          }
          function _t(me) {
            for (var _e = pe(me), Be = _e.length, Le = Array(Be), Ye = 0; Ye < Be; Ye++)
              Le[Ye] = [_e[Ye], me[_e[Ye]]];
            return Le;
          }
          function Xe(me) {
            for (var _e = {}, Be = pe(me), Le = 0, Ye = Be.length; Le < Ye; Le++)
              _e[me[Be[Le]]] = Be[Le];
            return _e;
          }
          function Ct(me) {
            var _e = [];
            for (var Be in me)
              M(me[Be]) && _e.push(Be);
            return _e.sort();
          }
          function bt(me, _e) {
            return function(Be) {
              var Le = arguments.length;
              if (_e && (Be = Object(Be)), Le < 2 || Be == null)
                return Be;
              for (var Ye = 1; Ye < Le; Ye++)
                for (var ze = arguments[Ye], pt = me(ze), Ot = pt.length, Yt = 0; Yt < Ot; Yt++) {
                  var Vt = pt[Yt];
                  (!_e || Be[Vt] === void 0) && (Be[Vt] = ze[Vt]);
                }
              return Be;
            };
          }
          var Pe = bt(Te), qe = bt(pe), ot = bt(Te, !0);
          function lt() {
            return function() {
            };
          }
          function Ut(me) {
            if (!A(me))
              return {};
            if (g)
              return g(me);
            var _e = lt();
            _e.prototype = me;
            var Be = new _e();
            return _e.prototype = null, Be;
          }
          function Nt(me, _e) {
            var Be = Ut(me);
            return _e && qe(Be, _e), Be;
          }
          function Ve(me) {
            return A(me) ? K(me) ? me.slice() : Pe({}, me) : me;
          }
          function je(me, _e) {
            return _e(me), me;
          }
          function at(me) {
            return K(me) ? me : [me];
          }
          Se.toPath = at;
          function nt(me) {
            return Se.toPath(me);
          }
          function ft(me, _e) {
            for (var Be = _e.length, Le = 0; Le < Be; Le++) {
              if (me == null)
                return;
              me = me[_e[Le]];
            }
            return Be ? me : void 0;
          }
          function Tt(me, _e, Be) {
            var Le = ft(me, nt(_e));
            return j(Le) ? Be : Le;
          }
          function yt(me, _e) {
            _e = nt(_e);
            for (var Be = _e.length, Le = 0; Le < Be; Le++) {
              var Ye = _e[Le];
              if (!ne(me, Ye))
                return !1;
              me = me[Ye];
            }
            return !!Be;
          }
          function dt(me) {
            return me;
          }
          function wt(me) {
            return me = qe({}, me), function(_e) {
              return Fe(_e, me);
            };
          }
          function Dt(me) {
            return me = nt(me), function(_e) {
              return ft(_e, me);
            };
          }
          function jt(me, _e, Be) {
            if (_e === void 0)
              return me;
            switch (Be ?? 3) {
              case 1:
                return function(Le) {
                  return me.call(_e, Le);
                };
              case 3:
                return function(Le, Ye, ze) {
                  return me.call(_e, Le, Ye, ze);
                };
              case 4:
                return function(Le, Ye, ze, pt) {
                  return me.call(_e, Le, Ye, ze, pt);
                };
            }
            return function() {
              return me.apply(_e, arguments);
            };
          }
          function Bt(me, _e, Be) {
            return me == null ? dt : M(me) ? jt(me, _e, Be) : A(me) && !K(me) ? wt(me) : Dt(me);
          }
          function kt(me, _e) {
            return Bt(me, _e, 1 / 0);
          }
          Se.iteratee = kt;
          function Ue(me, _e, Be) {
            return Se.iteratee !== kt ? Se.iteratee(me, _e) : Bt(me, _e, Be);
          }
          function We(me, _e, Be) {
            _e = Ue(_e, Be);
            for (var Le = pe(me), Ye = Le.length, ze = {}, pt = 0; pt < Ye; pt++) {
              var Ot = Le[pt];
              ze[Ot] = _e(me[Ot], Ot, me);
            }
            return ze;
          }
          function rt() {
          }
          function tt(me) {
            return me == null ? rt : function(_e) {
              return Tt(me, _e);
            };
          }
          function St(me, _e, Be) {
            var Le = Array(Math.max(0, me));
            _e = jt(_e, Be, 1);
            for (var Ye = 0; Ye < me; Ye++)
              Le[Ye] = _e(Ye);
            return Le;
          }
          function Pt(me, _e) {
            return _e == null && (_e = me, me = 0), me + Math.floor(Math.random() * (_e - me + 1));
          }
          var qt = Date.now || function() {
            return new Date().getTime();
          };
          function Mt(me) {
            var _e = function(ze) {
              return me[ze];
            }, Be = "(?:" + pe(me).join("|") + ")", Le = RegExp(Be), Ye = RegExp(Be, "g");
            return function(ze) {
              return ze = ze == null ? "" : "" + ze, Le.test(ze) ? ze.replace(Ye, _e) : ze;
            };
          }
          var Wt = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#x27;",
            "`": "&#x60;"
          }, Zt = Mt(Wt), an = Xe(Wt), un = Mt(an), Tn = Se.templateSettings = {
            evaluate: /<%([\s\S]+?)%>/g,
            interpolate: /<%=([\s\S]+?)%>/g,
            escape: /<%-([\s\S]+?)%>/g
          }, gn = /(.)^/, _n = {
            "'": "'",
            "\\": "\\",
            "\r": "r",
            "\n": "n",
            "\u2028": "u2028",
            "\u2029": "u2029"
          }, vn = /\\|'|\r|\n|\u2028|\u2029/g;
          function En(me) {
            return "\\" + _n[me];
          }
          var kn = /^\s*(\w|\$)+\s*$/;
          function Ln(me, _e, Be) {
            !_e && Be && (_e = Be), _e = ot({}, _e, Se.templateSettings);
            var Le = RegExp([
              (_e.escape || gn).source,
              (_e.interpolate || gn).source,
              (_e.evaluate || gn).source
            ].join("|") + "|$", "g"), Ye = 0, ze = "__p+='";
            me.replace(Le, function(Vt, ln, hn, Pi, Ri) {
              return ze += me.slice(Ye, Ri).replace(vn, En), Ye = Ri + Vt.length, ln ? ze += `'+
((__t=(` + ln + `))==null?'':_.escape(__t))+
'` : hn ? ze += `'+
((__t=(` + hn + `))==null?'':__t)+
'` : Pi && (ze += `';
` + Pi + `
__p+='`), Vt;
            }), ze += `';
`;
            var pt = _e.variable;
            if (pt) {
              if (!kn.test(pt))
                throw new Error(
                  "variable is not a bare identifier: " + pt
                );
            } else
              ze = `with(obj||{}){
` + ze + `}
`, pt = "obj";
            ze = `var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
` + ze + `return __p;
`;
            var Ot;
            try {
              Ot = new Function(pt, "_", ze);
            } catch (Vt) {
              throw Vt.source = ze, Vt;
            }
            var Yt = function(Vt) {
              return Ot.call(this, Vt, Se);
            };
            return Yt.source = "function(" + pt + `){
` + ze + "}", Yt;
          }
          function Nn(me, _e, Be) {
            _e = nt(_e);
            var Le = _e.length;
            if (!Le)
              return M(Be) ? Be.call(me) : Be;
            for (var Ye = 0; Ye < Le; Ye++) {
              var ze = me == null ? void 0 : me[_e[Ye]];
              ze === void 0 && (ze = Be, Ye = Le), me = M(ze) ? ze.call(me) : ze;
            }
            return me;
          }
          var wn = 0;
          function On(me) {
            var _e = ++wn + "";
            return me ? me + _e : _e;
          }
          function In(me) {
            var _e = Se(me);
            return _e._chain = !0, _e;
          }
          function xn(me, _e, Be, Le, Ye) {
            if (!(Le instanceof _e))
              return me.apply(Be, Ye);
            var ze = Ut(me.prototype), pt = me.apply(ze, Ye);
            return A(pt) ? pt : ze;
          }
          var dn = b(function(me, _e) {
            var Be = dn.placeholder, Le = function() {
              for (var Ye = 0, ze = _e.length, pt = Array(ze), Ot = 0; Ot < ze; Ot++)
                pt[Ot] = _e[Ot] === Be ? arguments[Ye++] : _e[Ot];
              for (; Ye < arguments.length; )
                pt.push(arguments[Ye++]);
              return xn(me, Le, this, this, pt);
            };
            return Le;
          });
          dn.placeholder = Se;
          var pn = b(function(me, _e, Be) {
            if (!M(me))
              throw new TypeError("Bind must be called on a function");
            var Le = b(function(Ye) {
              return xn(me, Le, _e, this, Be.concat(Ye));
            });
            return Le;
          }), sn = te(ue);
          function fn(me, _e, Be, Le) {
            if (Le = Le || [], !_e && _e !== 0)
              _e = 1 / 0;
            else if (_e <= 0)
              return Le.concat(me);
            for (var Ye = Le.length, ze = 0, pt = ue(me); ze < pt; ze++) {
              var Ot = me[ze];
              if (sn(Ot) && (K(Ot) || q(Ot)))
                if (_e > 1)
                  fn(Ot, _e - 1, Be, Le), Ye = Le.length;
                else
                  for (var Yt = 0, Vt = Ot.length; Yt < Vt; )
                    Le[Ye++] = Ot[Yt++];
              else
                Be || (Le[Ye++] = Ot);
            }
            return Le;
          }
          var Fn = b(function(me, _e) {
            _e = fn(_e, !1, !1);
            var Be = _e.length;
            if (Be < 1)
              throw new Error("bindAll must be passed function names");
            for (; Be--; ) {
              var Le = _e[Be];
              me[Le] = pn(me[Le], me);
            }
            return me;
          });
          function Pn(me, _e) {
            var Be = function(Le) {
              var Ye = Be.cache, ze = "" + (_e ? _e.apply(this, arguments) : Le);
              return ne(Ye, ze) || (Ye[ze] = me.apply(this, arguments)), Ye[ze];
            };
            return Be.cache = {}, Be;
          }
          var An = b(function(me, _e, Be) {
            return setTimeout(function() {
              return me.apply(null, Be);
            }, _e);
          }), jn = dn(An, Se, 1);
          function Rn(me, _e, Be) {
            var Le, Ye, ze, pt, Ot = 0;
            Be || (Be = {});
            var Yt = function() {
              Ot = Be.leading === !1 ? 0 : qt(), Le = null, pt = me.apply(Ye, ze), Le || (Ye = ze = null);
            }, Vt = function() {
              var ln = qt();
              !Ot && Be.leading === !1 && (Ot = ln);
              var hn = _e - (ln - Ot);
              return Ye = this, ze = arguments, hn <= 0 || hn > _e ? (Le && (clearTimeout(Le), Le = null), Ot = ln, pt = me.apply(Ye, ze), Le || (Ye = ze = null)) : !Le && Be.trailing !== !1 && (Le = setTimeout(Yt, hn)), pt;
            };
            return Vt.cancel = function() {
              clearTimeout(Le), Ot = 0, Le = Ye = ze = null;
            }, Vt;
          }
          function Un(me, _e, Be) {
            var Le, Ye, ze, pt, Ot, Yt = function() {
              var ln = qt() - Ye;
              _e > ln ? Le = setTimeout(Yt, _e - ln) : (Le = null, Be || (pt = me.apply(Ot, ze)), Le || (ze = Ot = null));
            }, Vt = b(function(ln) {
              return Ot = this, ze = ln, Ye = qt(), Le || (Le = setTimeout(Yt, _e), Be && (pt = me.apply(Ot, ze))), pt;
            });
            return Vt.cancel = function() {
              clearTimeout(Le), Le = ze = Ot = null;
            }, Vt;
          }
          function Mn(me, _e) {
            return dn(_e, me);
          }
          function Dn(me) {
            return function() {
              return !me.apply(this, arguments);
            };
          }
          function Sn() {
            var me = arguments, _e = me.length - 1;
            return function() {
              for (var Be = _e, Le = me[_e].apply(this, arguments); Be--; )
                Le = me[Be].call(this, Le);
              return Le;
            };
          }
          function Bn(me, _e) {
            return function() {
              if (--me < 1)
                return _e.apply(this, arguments);
            };
          }
          function bn(me, _e) {
            var Be;
            return function() {
              return --me > 0 && (Be = _e.apply(this, arguments)), me <= 1 && (_e = null), Be;
            };
          }
          var $n = dn(bn, 2);
          function yn(me, _e, Be) {
            _e = Ue(_e, Be);
            for (var Le = pe(me), Ye, ze = 0, pt = Le.length; ze < pt; ze++)
              if (Ye = Le[ze], _e(me[Ye], Ye, me))
                return Ye;
          }
          function He(me) {
            return function(_e, Be, Le) {
              Be = Ue(Be, Le);
              for (var Ye = ue(_e), ze = me > 0 ? 0 : Ye - 1; ze >= 0 && ze < Ye; ze += me)
                if (Be(_e[ze], ze, _e))
                  return ze;
              return -1;
            };
          }
          var R = He(1), he = He(-1);
          function $e(me, _e, Be, Le) {
            Be = Ue(Be, Le, 1);
            for (var Ye = Be(_e), ze = 0, pt = ue(me); ze < pt; ) {
              var Ot = Math.floor((ze + pt) / 2);
              Be(me[Ot]) < Ye ? ze = Ot + 1 : pt = Ot;
            }
            return ze;
          }
          function Ze(me, _e, Be) {
            return function(Le, Ye, ze) {
              var pt = 0, Ot = ue(Le);
              if (typeof ze == "number")
                me > 0 ? pt = ze >= 0 ? ze : Math.max(ze + Ot, pt) : Ot = ze >= 0 ? Math.min(ze + 1, Ot) : ze + Ot + 1;
              else if (Be && ze && Ot)
                return ze = Be(Le, Ye), Le[ze] === Ye ? ze : -1;
              if (Ye !== Ye)
                return ze = _e(h.call(Le, pt, Ot), Q), ze >= 0 ? ze + pt : -1;
              for (ze = me > 0 ? pt : Ot - 1; ze >= 0 && ze < Ot; ze += me)
                if (Le[ze] === Ye)
                  return ze;
              return -1;
            };
          }
          var ht = Ze(1, R, $e), It = Ze(-1, he);
          function Et(me, _e, Be) {
            var Le = sn(me) ? R : yn, Ye = Le(me, _e, Be);
            if (Ye !== void 0 && Ye !== -1)
              return me[Ye];
          }
          function Rt(me, _e) {
            return Et(me, wt(_e));
          }
          function $t(me, _e, Be) {
            _e = jt(_e, Be);
            var Le, Ye;
            if (sn(me))
              for (Le = 0, Ye = me.length; Le < Ye; Le++)
                _e(me[Le], Le, me);
            else {
              var ze = pe(me);
              for (Le = 0, Ye = ze.length; Le < Ye; Le++)
                _e(me[ze[Le]], ze[Le], me);
            }
            return me;
          }
          function Ht(me, _e, Be) {
            _e = Ue(_e, Be);
            for (var Le = !sn(me) && pe(me), Ye = (Le || me).length, ze = Array(Ye), pt = 0; pt < Ye; pt++) {
              var Ot = Le ? Le[pt] : pt;
              ze[pt] = _e(me[Ot], Ot, me);
            }
            return ze;
          }
          function Jt(me) {
            var _e = function(Be, Le, Ye, ze) {
              var pt = !sn(Be) && pe(Be), Ot = (pt || Be).length, Yt = me > 0 ? 0 : Ot - 1;
              for (ze || (Ye = Be[pt ? pt[Yt] : Yt], Yt += me); Yt >= 0 && Yt < Ot; Yt += me) {
                var Vt = pt ? pt[Yt] : Yt;
                Ye = Le(Ye, Be[Vt], Vt, Be);
              }
              return Ye;
            };
            return function(Be, Le, Ye, ze) {
              var pt = arguments.length >= 3;
              return _e(Be, jt(Le, ze, 4), Ye, pt);
            };
          }
          var Kt = Jt(1), tn = Jt(-1);
          function we(me, _e, Be) {
            var Le = [];
            return _e = Ue(_e, Be), $t(me, function(Ye, ze, pt) {
              _e(Ye, ze, pt) && Le.push(Ye);
            }), Le;
          }
          function Re(me, _e, Be) {
            return we(me, Dn(Ue(_e)), Be);
          }
          function et(me, _e, Be) {
            _e = Ue(_e, Be);
            for (var Le = !sn(me) && pe(me), Ye = (Le || me).length, ze = 0; ze < Ye; ze++) {
              var pt = Le ? Le[ze] : ze;
              if (!_e(me[pt], pt, me))
                return !1;
            }
            return !0;
          }
          function Ke(me, _e, Be) {
            _e = Ue(_e, Be);
            for (var Le = !sn(me) && pe(me), Ye = (Le || me).length, ze = 0; ze < Ye; ze++) {
              var pt = Le ? Le[ze] : ze;
              if (_e(me[pt], pt, me))
                return !0;
            }
            return !1;
          }
          function ut(me, _e, Be, Le) {
            return sn(me) || (me = mt(me)), (typeof Be != "number" || Le) && (Be = 0), ht(me, _e, Be) >= 0;
          }
          var Lt = b(function(me, _e, Be) {
            var Le, Ye;
            return M(_e) ? Ye = _e : (_e = nt(_e), Le = _e.slice(0, -1), _e = _e[_e.length - 1]), Ht(me, function(ze) {
              var pt = Ye;
              if (!pt) {
                if (Le && Le.length && (ze = ft(ze, Le)), ze == null)
                  return;
                pt = ze[_e];
              }
              return pt == null ? pt : pt.apply(ze, Be);
            });
          });
          function vt(me, _e) {
            return Ht(me, Dt(_e));
          }
          function Xt(me, _e) {
            return we(me, wt(_e));
          }
          function zt(me, _e, Be) {
            var Le = -1 / 0, Ye = -1 / 0, ze, pt;
            if (_e == null || typeof _e == "number" && typeof me[0] != "object" && me != null) {
              me = sn(me) ? me : mt(me);
              for (var Ot = 0, Yt = me.length; Ot < Yt; Ot++)
                ze = me[Ot], ze != null && ze > Le && (Le = ze);
            } else
              _e = Ue(_e, Be), $t(me, function(Vt, ln, hn) {
                pt = _e(Vt, ln, hn), (pt > Ye || pt === -1 / 0 && Le === -1 / 0) && (Le = Vt, Ye = pt);
              });
            return Le;
          }
          function Gt(me, _e, Be) {
            var Le = 1 / 0, Ye = 1 / 0, ze, pt;
            if (_e == null || typeof _e == "number" && typeof me[0] != "object" && me != null) {
              me = sn(me) ? me : mt(me);
              for (var Ot = 0, Yt = me.length; Ot < Yt; Ot++)
                ze = me[Ot], ze != null && ze < Le && (Le = ze);
            } else
              _e = Ue(_e, Be), $t(me, function(Vt, ln, hn) {
                pt = _e(Vt, ln, hn), (pt < Ye || pt === 1 / 0 && Le === 1 / 0) && (Le = Vt, Ye = pt);
              });
            return Le;
          }
          function Qt(me, _e, Be) {
            if (_e == null || Be)
              return sn(me) || (me = mt(me)), me[Pt(me.length - 1)];
            var Le = sn(me) ? Ve(me) : mt(me), Ye = ue(Le);
            _e = Math.max(Math.min(_e, Ye), 0);
            for (var ze = Ye - 1, pt = 0; pt < _e; pt++) {
              var Ot = Pt(pt, ze), Yt = Le[pt];
              Le[pt] = Le[Ot], Le[Ot] = Yt;
            }
            return Le.slice(0, _e);
          }
          function en(me) {
            return Qt(me, 1 / 0);
          }
          function rn(me, _e, Be) {
            var Le = 0;
            return _e = Ue(_e, Be), vt(Ht(me, function(Ye, ze, pt) {
              return {
                value: Ye,
                index: Le++,
                criteria: _e(Ye, ze, pt)
              };
            }).sort(function(Ye, ze) {
              var pt = Ye.criteria, Ot = ze.criteria;
              if (pt !== Ot) {
                if (pt > Ot || pt === void 0)
                  return 1;
                if (pt < Ot || Ot === void 0)
                  return -1;
              }
              return Ye.index - ze.index;
            }), "value");
          }
          function nn(me, _e) {
            return function(Be, Le, Ye) {
              var ze = _e ? [[], []] : {};
              return Le = Ue(Le, Ye), $t(Be, function(pt, Ot) {
                var Yt = Le(pt, Ot, Be);
                me(ze, pt, Yt);
              }), ze;
            };
          }
          var cn = nn(function(me, _e, Be) {
            ne(me, Be) ? me[Be].push(_e) : me[Be] = [_e];
          }), Wn = nn(function(me, _e, Be) {
            me[Be] = _e;
          }), zn = nn(function(me, _e, Be) {
            ne(me, Be) ? me[Be]++ : me[Be] = 1;
          }), qn = nn(function(me, _e, Be) {
            me[Be ? 0 : 1].push(_e);
          }, !0), ri = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
          function Yn(me) {
            return me ? K(me) ? h.call(me) : k(me) ? me.match(ri) : sn(me) ? Ht(me, dt) : mt(me) : [];
          }
          function ai(me) {
            return me == null ? 0 : sn(me) ? me.length : pe(me).length;
          }
          function Kn(me, _e, Be) {
            return _e in Be;
          }
          var Zn = b(function(me, _e) {
            var Be = {}, Le = _e[0];
            if (me == null)
              return Be;
            M(Le) ? (_e.length > 1 && (Le = jt(Le, _e[1])), _e = Te(me)) : (Le = Kn, _e = fn(_e, !1, !1), me = Object(me));
            for (var Ye = 0, ze = _e.length; Ye < ze; Ye++) {
              var pt = _e[Ye], Ot = me[pt];
              Le(Ot, pt, me) && (Be[pt] = Ot);
            }
            return Be;
          }), tr = b(function(me, _e) {
            var Be = _e[0], Le;
            return M(Be) ? (Be = Dn(Be), _e.length > 1 && (Le = _e[1])) : (_e = Ht(fn(_e, !1, !1), String), Be = function(Ye, ze) {
              return !ut(_e, ze);
            }), Zn(me, Be, Le);
          });
          function ki(me, _e, Be) {
            return h.call(me, 0, Math.max(0, me.length - (_e == null || Be ? 1 : _e)));
          }
          function si(me, _e, Be) {
            return me == null || me.length < 1 ? _e == null || Be ? void 0 : [] : _e == null || Be ? me[0] : ki(me, me.length - _e);
          }
          function Jn(me, _e, Be) {
            return h.call(me, _e == null || Be ? 1 : _e);
          }
          function nr(me, _e, Be) {
            return me == null || me.length < 1 ? _e == null || Be ? void 0 : [] : _e == null || Be ? me[me.length - 1] : Jn(me, Math.max(0, me.length - _e));
          }
          function ir(me) {
            return we(me, Boolean);
          }
          function rr(me, _e) {
            return fn(me, _e, !1);
          }
          var Oi = b(function(me, _e) {
            return _e = fn(_e, !0, !0), we(me, function(Be) {
              return !ut(_e, Be);
            });
          }), ar = b(function(me, _e) {
            return Oi(me, _e);
          });
          function oi(me, _e, Be, Le) {
            X(_e) || (Le = Be, Be = _e, _e = !1), Be != null && (Be = Ue(Be, Le));
            for (var Ye = [], ze = [], pt = 0, Ot = ue(me); pt < Ot; pt++) {
              var Yt = me[pt], Vt = Be ? Be(Yt, pt, me) : Yt;
              _e && !Be ? ((!pt || ze !== Vt) && Ye.push(Yt), ze = Vt) : Be ? ut(ze, Vt) || (ze.push(Vt), Ye.push(Yt)) : ut(Ye, Yt) || Ye.push(Yt);
            }
            return Ye;
          }
          var sr = b(function(me) {
            return oi(fn(me, !0, !0));
          });
          function or(me) {
            for (var _e = [], Be = arguments.length, Le = 0, Ye = ue(me); Le < Ye; Le++) {
              var ze = me[Le];
              if (!ut(_e, ze)) {
                var pt;
                for (pt = 1; pt < Be && ut(arguments[pt], ze); pt++)
                  ;
                pt === Be && _e.push(ze);
              }
            }
            return _e;
          }
          function ci(me) {
            for (var _e = me && zt(me, ue).length || 0, Be = Array(_e), Le = 0; Le < _e; Le++)
              Be[Le] = vt(me, Le);
            return Be;
          }
          var cr = b(ci);
          function lr(me, _e) {
            for (var Be = {}, Le = 0, Ye = ue(me); Le < Ye; Le++)
              _e ? Be[me[Le]] = _e[Le] : Be[me[Le][0]] = me[Le][1];
            return Be;
          }
          function ur(me, _e, Be) {
            _e == null && (_e = me || 0, me = 0), Be || (Be = _e < me ? -1 : 1);
            for (var Le = Math.max(Math.ceil((_e - me) / Be), 0), Ye = Array(Le), ze = 0; ze < Le; ze++, me += Be)
              Ye[ze] = me;
            return Ye;
          }
          function hr(me, _e) {
            if (_e == null || _e < 1)
              return [];
            for (var Be = [], Le = 0, Ye = me.length; Le < Ye; )
              Be.push(h.call(me, Le, Le += _e));
            return Be;
          }
          function li(me, _e) {
            return me._chain ? Se(_e).chain() : _e;
          }
          function Ii(me) {
            return $t(Ct(me), function(_e) {
              var Be = Se[_e] = me[_e];
              Se.prototype[_e] = function() {
                var Le = [this._wrapped];
                return v.apply(Le, arguments), li(this, Be.apply(Se, Le));
              };
            }), Se;
          }
          $t(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(me) {
            var _e = F[me];
            Se.prototype[me] = function() {
              var Be = this._wrapped;
              return Be != null && (_e.apply(Be, arguments), (me === "shift" || me === "splice") && Be.length === 0 && delete Be[0]), li(this, Be);
            };
          }), $t(["concat", "join", "slice"], function(me) {
            var _e = F[me];
            Se.prototype[me] = function() {
              var Be = this._wrapped;
              return Be != null && (Be = _e.apply(Be, arguments)), li(this, Be);
            };
          });
          var dr = {
            __proto__: null,
            VERSION: J,
            restArguments: b,
            isObject: A,
            isNull: Y,
            isUndefined: j,
            isBoolean: X,
            isElement: B,
            isString: k,
            isNumber: x,
            isDate: f,
            isRegExp: D,
            isError: _,
            isSymbol: S,
            isArrayBuffer: C,
            isDataView: L,
            isArray: K,
            isFunction: M,
            isArguments: q,
            isFinite: N,
            isNaN: Q,
            isTypedArray: ie,
            isEmpty: xe,
            isMatch: Fe,
            isEqual: Ae,
            isMap: Qe,
            isWeakMap: ct,
            isSet: xt,
            isWeakSet: Je,
            keys: pe,
            allKeys: Te,
            values: mt,
            pairs: _t,
            invert: Xe,
            functions: Ct,
            methods: Ct,
            extend: Pe,
            extendOwn: qe,
            assign: qe,
            defaults: ot,
            create: Nt,
            clone: Ve,
            tap: je,
            get: Tt,
            has: yt,
            mapObject: We,
            identity: dt,
            constant: E,
            noop: rt,
            toPath: at,
            property: Dt,
            propertyOf: tt,
            matcher: wt,
            matches: wt,
            times: St,
            random: Pt,
            now: qt,
            escape: Zt,
            unescape: un,
            templateSettings: Tn,
            template: Ln,
            result: Nn,
            uniqueId: On,
            chain: In,
            iteratee: kt,
            partial: dn,
            bind: pn,
            bindAll: Fn,
            memoize: Pn,
            delay: An,
            defer: jn,
            throttle: Rn,
            debounce: Un,
            wrap: Mn,
            negate: Dn,
            compose: Sn,
            after: Bn,
            before: bn,
            once: $n,
            findKey: yn,
            findIndex: R,
            findLastIndex: he,
            sortedIndex: $e,
            indexOf: ht,
            lastIndexOf: It,
            find: Et,
            detect: Et,
            findWhere: Rt,
            each: $t,
            forEach: $t,
            map: Ht,
            collect: Ht,
            reduce: Kt,
            foldl: Kt,
            inject: Kt,
            reduceRight: tn,
            foldr: tn,
            filter: we,
            select: we,
            reject: Re,
            every: et,
            all: et,
            some: Ke,
            any: Ke,
            contains: ut,
            includes: ut,
            include: ut,
            invoke: Lt,
            pluck: vt,
            where: Xt,
            max: zt,
            min: Gt,
            shuffle: en,
            sample: Qt,
            sortBy: rn,
            groupBy: cn,
            indexBy: Wn,
            countBy: zn,
            partition: qn,
            toArray: Yn,
            size: ai,
            pick: Zn,
            omit: tr,
            first: si,
            head: si,
            take: si,
            initial: ki,
            last: nr,
            rest: Jn,
            tail: Jn,
            drop: Jn,
            compact: ir,
            flatten: rr,
            without: ar,
            uniq: oi,
            unique: oi,
            union: sr,
            intersection: or,
            difference: Oi,
            unzip: ci,
            transpose: ci,
            zip: cr,
            object: lr,
            range: ur,
            chunk: hr,
            mixin: Ii,
            default: Se
          }, ui = Ii(dr);
          return ui._ = ui, ui;
        });
      }).call(this, typeof commonjsGlobal < "u" ? commonjsGlobal : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 118: [function(le, ce, re) {
      (function(ae) {
        ce.exports = J;
        function J(F, t) {
          if (o("noDeprecation"))
            return F;
          var a = !1;
          function v() {
            if (!a) {
              if (o("throwDeprecation"))
                throw new Error(t);
              o("traceDeprecation") ? console.trace(t) : console.warn(t), a = !0;
            }
            return F.apply(this, arguments);
          }
          return v;
        }
        function o(F) {
          try {
            if (!ae.localStorage)
              return !1;
          } catch {
            return !1;
          }
          var t = ae.localStorage[F];
          return t == null ? !1 : String(t).toLowerCase() === "true";
        }
      }).call(this, typeof commonjsGlobal < "u" ? commonjsGlobal : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 119: [function(le, ce, re) {
      arguments[4][84][0].apply(re, arguments);
    }, { dup: 84 }], 120: [function(le, ce, re) {
      ce.exports = function(J) {
        return J && typeof J == "object" && typeof J.copy == "function" && typeof J.fill == "function" && typeof J.readUInt8 == "function";
      };
    }, {}], 121: [function(le, ce, re) {
      (function(ae, J) {
        var o = /%[sdj%]/g;
        re.format = function(C) {
          if (!O(C)) {
            for (var T = [], P = 0; P < arguments.length; P++)
              T.push(a(arguments[P]));
            return T.join(" ");
          }
          for (var P = 1, M = arguments, G = M.length, Z = String(C).replace(o, function(z) {
            if (z === "%%")
              return "%";
            if (P >= G)
              return z;
            switch (z) {
              case "%s":
                return String(M[P++]);
              case "%d":
                return Number(M[P++]);
              case "%j":
                try {
                  return JSON.stringify(M[P++]);
                } catch {
                  return "[Circular]";
                }
              default:
                return z;
            }
          }), $ = M[P]; P < G; $ = M[++P])
            l($) || !j($) ? Z += " " + $ : Z += " " + a($);
          return Z;
        }, re.deprecate = function(C, T) {
          if (A(J.process))
            return function() {
              return re.deprecate(C, T).apply(this, arguments);
            };
          if (ae.noDeprecation === !0)
            return C;
          var P = !1;
          function M() {
            if (!P) {
              if (ae.throwDeprecation)
                throw new Error(T);
              ae.traceDeprecation ? console.trace(T) : console.error(T), P = !0;
            }
            return C.apply(this, arguments);
          }
          return M;
        };
        var F = {}, t;
        re.debuglog = function(C) {
          if (A(t) && (t = ae.env.NODE_DEBUG || ""), C = C.toUpperCase(), !F[C])
            if (new RegExp("\\b" + C + "\\b", "i").test(t)) {
              var T = ae.pid;
              F[C] = function() {
                var P = re.format.apply(re, arguments);
                console.error("%s %d: %s", C, T, P);
              };
            } else
              F[C] = function() {
              };
          return F[C];
        };
        function a(C, T) {
          var P = {
            seen: [],
            stylize: h
          };
          return arguments.length >= 3 && (P.depth = arguments[2]), arguments.length >= 4 && (P.colors = arguments[3]), i(T) ? P.showHidden = T : T && re._extend(P, T), A(P.showHidden) && (P.showHidden = !1), A(P.depth) && (P.depth = 2), A(P.colors) && (P.colors = !1), A(P.customInspect) && (P.customInspect = !0), P.colors && (P.stylize = v), y(P, C, P.depth);
        }
        re.inspect = a, a.colors = {
          bold: [1, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          white: [37, 39],
          grey: [90, 39],
          black: [30, 39],
          blue: [34, 39],
          cyan: [36, 39],
          green: [32, 39],
          magenta: [35, 39],
          red: [31, 39],
          yellow: [33, 39]
        }, a.styles = {
          special: "cyan",
          number: "yellow",
          boolean: "yellow",
          undefined: "grey",
          null: "bold",
          string: "green",
          date: "magenta",
          // "name": intentionally not styling
          regexp: "red"
        };
        function v(C, T) {
          var P = a.styles[T];
          return P ? "\x1B[" + a.colors[P][0] + "m" + C + "\x1B[" + a.colors[P][1] + "m" : C;
        }
        function h(C, T) {
          return C;
        }
        function e(C) {
          var T = {};
          return C.forEach(function(P, M) {
            T[P] = !0;
          }), T;
        }
        function y(C, T, P) {
          if (C.customInspect && T && U(T.inspect) && // Filter out the util module, it's inspect function is special
          T.inspect !== re.inspect && // Also filter out any prototype objects using the circular check.
          !(T.constructor && T.constructor.prototype === T)) {
            var M = T.inspect(P, C);
            return O(M) || (M = y(C, M, P)), M;
          }
          var G = c(C, T);
          if (G)
            return G;
          var Z = Object.keys(T), $ = e(Z);
          if (C.showHidden && (Z = Object.getOwnPropertyNames(T)), B(T) && (Z.indexOf("message") >= 0 || Z.indexOf("description") >= 0))
            return d(T);
          if (Z.length === 0) {
            if (U(T)) {
              var z = T.name ? ": " + T.name : "";
              return C.stylize("[Function" + z + "]", "special");
            }
            if (Y(T))
              return C.stylize(RegExp.prototype.toString.call(T), "regexp");
            if (X(T))
              return C.stylize(Date.prototype.toString.call(T), "date");
            if (B(T))
              return d(T);
          }
          var V = "", L = !1, K = ["{", "}"];
          if (n(T) && (L = !0, K = ["[", "]"]), U(T)) {
            var ne = T.name ? ": " + T.name : "";
            V = " [Function" + ne + "]";
          }
          if (Y(T) && (V = " " + RegExp.prototype.toString.call(T)), X(T) && (V = " " + Date.prototype.toUTCString.call(T)), B(T) && (V = " " + d(T)), Z.length === 0 && (!L || T.length == 0))
            return K[0] + V + K[1];
          if (P < 0)
            return Y(T) ? C.stylize(RegExp.prototype.toString.call(T), "regexp") : C.stylize("[Object]", "special");
          C.seen.push(T);
          var se;
          return L ? se = m(C, T, P, $, Z) : se = Z.map(function(q) {
            return p(C, T, P, $, q, L);
          }), C.seen.pop(), g(se, V, K);
        }
        function c(C, T) {
          if (A(T))
            return C.stylize("undefined", "undefined");
          if (O(T)) {
            var P = "'" + JSON.stringify(T).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
            return C.stylize(P, "string");
          }
          if (w(T))
            return C.stylize("" + T, "number");
          if (i(T))
            return C.stylize("" + T, "boolean");
          if (l(T))
            return C.stylize("null", "null");
        }
        function d(C) {
          return "[" + Error.prototype.toString.call(C) + "]";
        }
        function m(C, T, P, M, G) {
          for (var Z = [], $ = 0, z = T.length; $ < z; ++$)
            S(T, String($)) ? Z.push(p(
              C,
              T,
              P,
              M,
              String($),
              !0
            )) : Z.push("");
          return G.forEach(function(V) {
            V.match(/^\d+$/) || Z.push(p(
              C,
              T,
              P,
              M,
              V,
              !0
            ));
          }), Z;
        }
        function p(C, T, P, M, G, Z) {
          var $, z, V;
          if (V = Object.getOwnPropertyDescriptor(T, G) || { value: T[G] }, V.get ? V.set ? z = C.stylize("[Getter/Setter]", "special") : z = C.stylize("[Getter]", "special") : V.set && (z = C.stylize("[Setter]", "special")), S(M, G) || ($ = "[" + G + "]"), z || (C.seen.indexOf(V.value) < 0 ? (l(P) ? z = y(C, V.value, null) : z = y(C, V.value, P - 1), z.indexOf(`
`) > -1 && (Z ? z = z.split(`
`).map(function(L) {
            return "  " + L;
          }).join(`
`).substr(2) : z = `
` + z.split(`
`).map(function(L) {
            return "   " + L;
          }).join(`
`))) : z = C.stylize("[Circular]", "special")), A($)) {
            if (Z && G.match(/^\d+$/))
              return z;
            $ = JSON.stringify("" + G), $.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? ($ = $.substr(1, $.length - 2), $ = C.stylize($, "name")) : ($ = $.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), $ = C.stylize($, "string"));
          }
          return $ + ": " + z;
        }
        function g(C, T, P) {
          var M = C.reduce(function(G, Z) {
            return Z.indexOf(`
`) >= 0, G + Z.replace(/\u001b\[\d\d?m/g, "").length + 1;
          }, 0);
          return M > 60 ? P[0] + (T === "" ? "" : T + `
 `) + " " + C.join(`,
  `) + " " + P[1] : P[0] + T + " " + C.join(", ") + " " + P[1];
        }
        function n(C) {
          return Array.isArray(C);
        }
        re.isArray = n;
        function i(C) {
          return typeof C == "boolean";
        }
        re.isBoolean = i;
        function l(C) {
          return C === null;
        }
        re.isNull = l;
        function u(C) {
          return C == null;
        }
        re.isNullOrUndefined = u;
        function w(C) {
          return typeof C == "number";
        }
        re.isNumber = w;
        function O(C) {
          return typeof C == "string";
        }
        re.isString = O;
        function b(C) {
          return typeof C == "symbol";
        }
        re.isSymbol = b;
        function A(C) {
          return C === void 0;
        }
        re.isUndefined = A;
        function Y(C) {
          return j(C) && x(C) === "[object RegExp]";
        }
        re.isRegExp = Y;
        function j(C) {
          return typeof C == "object" && C !== null;
        }
        re.isObject = j;
        function X(C) {
          return j(C) && x(C) === "[object Date]";
        }
        re.isDate = X;
        function B(C) {
          return j(C) && (x(C) === "[object Error]" || C instanceof Error);
        }
        re.isError = B;
        function U(C) {
          return typeof C == "function";
        }
        re.isFunction = U;
        function k(C) {
          return C === null || typeof C == "boolean" || typeof C == "number" || typeof C == "string" || typeof C == "symbol" || // ES6 symbol
          typeof C > "u";
        }
        re.isPrimitive = k, re.isBuffer = le("./support/isBuffer");
        function x(C) {
          return Object.prototype.toString.call(C);
        }
        function f(C) {
          return C < 10 ? "0" + C.toString(10) : C.toString(10);
        }
        var D = [
          "Jan",
          "Feb",
          "Mar",
          "Apr",
          "May",
          "Jun",
          "Jul",
          "Aug",
          "Sep",
          "Oct",
          "Nov",
          "Dec"
        ];
        function _() {
          var C = new Date(), T = [
            f(C.getHours()),
            f(C.getMinutes()),
            f(C.getSeconds())
          ].join(":");
          return [C.getDate(), D[C.getMonth()], T].join(" ");
        }
        re.log = function() {
          console.log("%s - %s", _(), re.format.apply(re, arguments));
        }, re.inherits = le("inherits"), re._extend = function(C, T) {
          if (!T || !j(T))
            return C;
          for (var P = Object.keys(T), M = P.length; M--; )
            C[P[M]] = T[P[M]];
          return C;
        };
        function S(C, T) {
          return Object.prototype.hasOwnProperty.call(C, T);
        }
      }).call(this, le("_process"), typeof commonjsGlobal < "u" ? commonjsGlobal : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "./support/isBuffer": 120, _process: 102, inherits: 119 }], 122: [function(le, ce, re) {
      (function() {
        var ae, J, o, F, t, a, v, h = [].slice, e = {}.hasOwnProperty;
        ae = function() {
          var y, c, d, m, p, g;
          if (g = arguments[0], p = 2 <= arguments.length ? h.call(arguments, 1) : [], t(Object.assign))
            Object.assign.apply(null, arguments);
          else
            for (y = 0, d = p.length; y < d; y++)
              if (m = p[y], m != null)
                for (c in m)
                  e.call(m, c) && (g[c] = m[c]);
          return g;
        }, t = function(y) {
          return !!y && Object.prototype.toString.call(y) === "[object Function]";
        }, a = function(y) {
          var c;
          return !!y && ((c = typeof y) == "function" || c === "object");
        }, o = function(y) {
          return t(Array.isArray) ? Array.isArray(y) : Object.prototype.toString.call(y) === "[object Array]";
        }, F = function(y) {
          var c;
          if (o(y))
            return !y.length;
          for (c in y)
            if (e.call(y, c))
              return !1;
          return !0;
        }, v = function(y) {
          var c, d;
          return a(y) && (d = Object.getPrototypeOf(y)) && (c = d.constructor) && typeof c == "function" && c instanceof c && Function.prototype.toString.call(c) === Function.prototype.toString.call(Object);
        }, J = function(y) {
          return t(y.valueOf) ? y.valueOf() : y;
        }, ce.exports.assign = ae, ce.exports.isFunction = t, ce.exports.isObject = a, ce.exports.isArray = o, ce.exports.isEmpty = F, ce.exports.isPlainObject = v, ce.exports.getValue = J;
      }).call(this);
    }, {}], 123: [function(le, ce, re) {
      (function() {
        ce.exports = function() {
          function ae(J, o, F) {
            if (this.options = J.options, this.stringify = J.stringify, this.parent = J, o == null)
              throw new Error("Missing attribute name. " + this.debugInfo(o));
            if (F == null)
              throw new Error("Missing attribute value. " + this.debugInfo(o));
            this.name = this.stringify.attName(o), this.value = this.stringify.attValue(F);
          }
          return ae.prototype.clone = function() {
            return Object.create(this);
          }, ae.prototype.toString = function(J) {
            return this.options.writer.set(J).attribute(this);
          }, ae.prototype.debugInfo = function(J) {
            var o, F;
            return J = J || this.name, J == null && !((o = this.parent) != null && o.name) ? "" : J == null ? "parent: <" + this.parent.name + ">" : (F = this.parent) != null && F.name ? "attribute: {" + J + "}, parent: <" + this.parent.name + ">" : "attribute: {" + J + "}";
          }, ae;
        }();
      }).call(this);
    }, {}], 124: [function(le, ce, re) {
      (function() {
        var ae, J = function(F, t) {
          for (var a in t)
            o.call(t, a) && (F[a] = t[a]);
          function v() {
            this.constructor = F;
          }
          return v.prototype = t.prototype, F.prototype = new v(), F.__super__ = t.prototype, F;
        }, o = {}.hasOwnProperty;
        ae = le("./XMLNode"), ce.exports = function(F) {
          J(t, F);
          function t(a, v) {
            if (t.__super__.constructor.call(this, a), v == null)
              throw new Error("Missing CDATA text. " + this.debugInfo());
            this.text = this.stringify.cdata(v);
          }
          return t.prototype.clone = function() {
            return Object.create(this);
          }, t.prototype.toString = function(a) {
            return this.options.writer.set(a).cdata(this);
          }, t;
        }(ae);
      }).call(this);
    }, { "./XMLNode": 135 }], 125: [function(le, ce, re) {
      (function() {
        var ae, J = function(F, t) {
          for (var a in t)
            o.call(t, a) && (F[a] = t[a]);
          function v() {
            this.constructor = F;
          }
          return v.prototype = t.prototype, F.prototype = new v(), F.__super__ = t.prototype, F;
        }, o = {}.hasOwnProperty;
        ae = le("./XMLNode"), ce.exports = function(F) {
          J(t, F);
          function t(a, v) {
            if (t.__super__.constructor.call(this, a), v == null)
              throw new Error("Missing comment text. " + this.debugInfo());
            this.text = this.stringify.comment(v);
          }
          return t.prototype.clone = function() {
            return Object.create(this);
          }, t.prototype.toString = function(a) {
            return this.options.writer.set(a).comment(this);
          }, t;
        }(ae);
      }).call(this);
    }, { "./XMLNode": 135 }], 126: [function(le, ce, re) {
      (function() {
        var ae, J = function(F, t) {
          for (var a in t)
            o.call(t, a) && (F[a] = t[a]);
          function v() {
            this.constructor = F;
          }
          return v.prototype = t.prototype, F.prototype = new v(), F.__super__ = t.prototype, F;
        }, o = {}.hasOwnProperty;
        ae = le("./XMLNode"), ce.exports = function(F) {
          J(t, F);
          function t(a, v, h, e, y, c) {
            if (t.__super__.constructor.call(this, a), v == null)
              throw new Error("Missing DTD element name. " + this.debugInfo());
            if (h == null)
              throw new Error("Missing DTD attribute name. " + this.debugInfo(v));
            if (!e)
              throw new Error("Missing DTD attribute type. " + this.debugInfo(v));
            if (!y)
              throw new Error("Missing DTD attribute default. " + this.debugInfo(v));
            if (y.indexOf("#") !== 0 && (y = "#" + y), !y.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/))
              throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(v));
            if (c && !y.match(/^(#FIXED|#DEFAULT)$/))
              throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(v));
            this.elementName = this.stringify.eleName(v), this.attributeName = this.stringify.attName(h), this.attributeType = this.stringify.dtdAttType(e), this.defaultValue = this.stringify.dtdAttDefault(c), this.defaultValueType = y;
          }
          return t.prototype.toString = function(a) {
            return this.options.writer.set(a).dtdAttList(this);
          }, t;
        }(ae);
      }).call(this);
    }, { "./XMLNode": 135 }], 127: [function(le, ce, re) {
      (function() {
        var ae, J = function(F, t) {
          for (var a in t)
            o.call(t, a) && (F[a] = t[a]);
          function v() {
            this.constructor = F;
          }
          return v.prototype = t.prototype, F.prototype = new v(), F.__super__ = t.prototype, F;
        }, o = {}.hasOwnProperty;
        ae = le("./XMLNode"), ce.exports = function(F) {
          J(t, F);
          function t(a, v, h) {
            if (t.__super__.constructor.call(this, a), v == null)
              throw new Error("Missing DTD element name. " + this.debugInfo());
            h || (h = "(#PCDATA)"), Array.isArray(h) && (h = "(" + h.join(",") + ")"), this.name = this.stringify.eleName(v), this.value = this.stringify.dtdElementValue(h);
          }
          return t.prototype.toString = function(a) {
            return this.options.writer.set(a).dtdElement(this);
          }, t;
        }(ae);
      }).call(this);
    }, { "./XMLNode": 135 }], 128: [function(le, ce, re) {
      (function() {
        var ae, J, o = function(t, a) {
          for (var v in a)
            F.call(a, v) && (t[v] = a[v]);
          function h() {
            this.constructor = t;
          }
          return h.prototype = a.prototype, t.prototype = new h(), t.__super__ = a.prototype, t;
        }, F = {}.hasOwnProperty;
        J = le("./Utility").isObject, ae = le("./XMLNode"), ce.exports = function(t) {
          o(a, t);
          function a(v, h, e, y) {
            if (a.__super__.constructor.call(this, v), e == null)
              throw new Error("Missing DTD entity name. " + this.debugInfo(e));
            if (y == null)
              throw new Error("Missing DTD entity value. " + this.debugInfo(e));
            if (this.pe = !!h, this.name = this.stringify.eleName(e), !J(y))
              this.value = this.stringify.dtdEntityValue(y);
            else {
              if (!y.pubID && !y.sysID)
                throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(e));
              if (y.pubID && !y.sysID)
                throw new Error("System identifier is required for a public external entity. " + this.debugInfo(e));
              if (y.pubID != null && (this.pubID = this.stringify.dtdPubID(y.pubID)), y.sysID != null && (this.sysID = this.stringify.dtdSysID(y.sysID)), y.nData != null && (this.nData = this.stringify.dtdNData(y.nData)), this.pe && this.nData)
                throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(e));
            }
          }
          return a.prototype.toString = function(v) {
            return this.options.writer.set(v).dtdEntity(this);
          }, a;
        }(ae);
      }).call(this);
    }, { "./Utility": 122, "./XMLNode": 135 }], 129: [function(le, ce, re) {
      (function() {
        var ae, J = function(F, t) {
          for (var a in t)
            o.call(t, a) && (F[a] = t[a]);
          function v() {
            this.constructor = F;
          }
          return v.prototype = t.prototype, F.prototype = new v(), F.__super__ = t.prototype, F;
        }, o = {}.hasOwnProperty;
        ae = le("./XMLNode"), ce.exports = function(F) {
          J(t, F);
          function t(a, v, h) {
            if (t.__super__.constructor.call(this, a), v == null)
              throw new Error("Missing DTD notation name. " + this.debugInfo(v));
            if (!h.pubID && !h.sysID)
              throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(v));
            this.name = this.stringify.eleName(v), h.pubID != null && (this.pubID = this.stringify.dtdPubID(h.pubID)), h.sysID != null && (this.sysID = this.stringify.dtdSysID(h.sysID));
          }
          return t.prototype.toString = function(a) {
            return this.options.writer.set(a).dtdNotation(this);
          }, t;
        }(ae);
      }).call(this);
    }, { "./XMLNode": 135 }], 130: [function(le, ce, re) {
      (function() {
        var ae, J, o = function(t, a) {
          for (var v in a)
            F.call(a, v) && (t[v] = a[v]);
          function h() {
            this.constructor = t;
          }
          return h.prototype = a.prototype, t.prototype = new h(), t.__super__ = a.prototype, t;
        }, F = {}.hasOwnProperty;
        J = le("./Utility").isObject, ae = le("./XMLNode"), ce.exports = function(t) {
          o(a, t);
          function a(v, h, e, y) {
            var c;
            a.__super__.constructor.call(this, v), J(h) && (c = h, h = c.version, e = c.encoding, y = c.standalone), h || (h = "1.0"), this.version = this.stringify.xmlVersion(h), e != null && (this.encoding = this.stringify.xmlEncoding(e)), y != null && (this.standalone = this.stringify.xmlStandalone(y));
          }
          return a.prototype.toString = function(v) {
            return this.options.writer.set(v).declaration(this);
          }, a;
        }(ae);
      }).call(this);
    }, { "./Utility": 122, "./XMLNode": 135 }], 131: [function(le, ce, re) {
      (function() {
        var ae, J, o, F, t, a, v = function(e, y) {
          for (var c in y)
            h.call(y, c) && (e[c] = y[c]);
          function d() {
            this.constructor = e;
          }
          return d.prototype = y.prototype, e.prototype = new d(), e.__super__ = y.prototype, e;
        }, h = {}.hasOwnProperty;
        a = le("./Utility").isObject, t = le("./XMLNode"), ae = le("./XMLDTDAttList"), o = le("./XMLDTDEntity"), J = le("./XMLDTDElement"), F = le("./XMLDTDNotation"), ce.exports = function(e) {
          v(y, e);
          function y(c, d, m) {
            var p, g;
            y.__super__.constructor.call(this, c), this.name = "!DOCTYPE", this.documentObject = c, a(d) && (p = d, d = p.pubID, m = p.sysID), m == null && (g = [d, m], m = g[0], d = g[1]), d != null && (this.pubID = this.stringify.dtdPubID(d)), m != null && (this.sysID = this.stringify.dtdSysID(m));
          }
          return y.prototype.element = function(c, d) {
            var m;
            return m = new J(this, c, d), this.children.push(m), this;
          }, y.prototype.attList = function(c, d, m, p, g) {
            var n;
            return n = new ae(this, c, d, m, p, g), this.children.push(n), this;
          }, y.prototype.entity = function(c, d) {
            var m;
            return m = new o(this, !1, c, d), this.children.push(m), this;
          }, y.prototype.pEntity = function(c, d) {
            var m;
            return m = new o(this, !0, c, d), this.children.push(m), this;
          }, y.prototype.notation = function(c, d) {
            var m;
            return m = new F(this, c, d), this.children.push(m), this;
          }, y.prototype.toString = function(c) {
            return this.options.writer.set(c).docType(this);
          }, y.prototype.ele = function(c, d) {
            return this.element(c, d);
          }, y.prototype.att = function(c, d, m, p, g) {
            return this.attList(c, d, m, p, g);
          }, y.prototype.ent = function(c, d) {
            return this.entity(c, d);
          }, y.prototype.pent = function(c, d) {
            return this.pEntity(c, d);
          }, y.prototype.not = function(c, d) {
            return this.notation(c, d);
          }, y.prototype.up = function() {
            return this.root() || this.documentObject;
          }, y;
        }(t);
      }).call(this);
    }, { "./Utility": 122, "./XMLDTDAttList": 126, "./XMLDTDElement": 127, "./XMLDTDEntity": 128, "./XMLDTDNotation": 129, "./XMLNode": 135 }], 132: [function(le, ce, re) {
      (function() {
        var ae, J, o, F, t = function(v, h) {
          for (var e in h)
            a.call(h, e) && (v[e] = h[e]);
          function y() {
            this.constructor = v;
          }
          return y.prototype = h.prototype, v.prototype = new y(), v.__super__ = h.prototype, v;
        }, a = {}.hasOwnProperty;
        F = le("./Utility").isPlainObject, ae = le("./XMLNode"), o = le("./XMLStringifier"), J = le("./XMLStringWriter"), ce.exports = function(v) {
          t(h, v);
          function h(e) {
            h.__super__.constructor.call(this, null), this.name = "?xml", e || (e = {}), e.writer || (e.writer = new J()), this.options = e, this.stringify = new o(e), this.isDocument = !0;
          }
          return h.prototype.end = function(e) {
            var y;
            return e ? F(e) && (y = e, e = this.options.writer.set(y)) : e = this.options.writer, e.document(this);
          }, h.prototype.toString = function(e) {
            return this.options.writer.set(e).document(this);
          }, h;
        }(ae);
      }).call(this);
    }, { "./Utility": 122, "./XMLNode": 135, "./XMLStringWriter": 139, "./XMLStringifier": 140 }], 133: [function(le, ce, re) {
      (function() {
        var ae, J, o, F, t, a, v, h, e, y, c, d, m, p, g, n, i, l, u, w, O = {}.hasOwnProperty;
        w = le("./Utility"), l = w.isObject, i = w.isFunction, u = w.isPlainObject, n = w.getValue, y = le("./XMLElement"), J = le("./XMLCData"), o = le("./XMLComment"), d = le("./XMLRaw"), g = le("./XMLText"), c = le("./XMLProcessingInstruction"), h = le("./XMLDeclaration"), e = le("./XMLDocType"), F = le("./XMLDTDAttList"), a = le("./XMLDTDEntity"), t = le("./XMLDTDElement"), v = le("./XMLDTDNotation"), ae = le("./XMLAttribute"), p = le("./XMLStringifier"), m = le("./XMLStringWriter"), ce.exports = function() {
          function b(A, Y, j) {
            var X;
            this.name = "?xml", A || (A = {}), A.writer ? u(A.writer) && (X = A.writer, A.writer = new m(X)) : A.writer = new m(A), this.options = A, this.writer = A.writer, this.stringify = new p(A), this.onDataCallback = Y || function() {
            }, this.onEndCallback = j || function() {
            }, this.currentNode = null, this.currentLevel = -1, this.openTags = {}, this.documentStarted = !1, this.documentCompleted = !1, this.root = null;
          }
          return b.prototype.node = function(A, Y, j) {
            var X;
            if (A == null)
              throw new Error("Missing node name.");
            if (this.root && this.currentLevel === -1)
              throw new Error("Document can only have one root node. " + this.debugInfo(A));
            return this.openCurrent(), A = n(A), Y == null && (Y = {}), Y = n(Y), l(Y) || (X = [Y, j], j = X[0], Y = X[1]), this.currentNode = new y(this, A, Y), this.currentNode.children = !1, this.currentLevel++, this.openTags[this.currentLevel] = this.currentNode, j != null && this.text(j), this;
          }, b.prototype.element = function(A, Y, j) {
            return this.currentNode && this.currentNode instanceof e ? this.dtdElement.apply(this, arguments) : this.node(A, Y, j);
          }, b.prototype.attribute = function(A, Y) {
            var j, X;
            if (!this.currentNode || this.currentNode.children)
              throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(A));
            if (A != null && (A = n(A)), l(A))
              for (j in A)
                O.call(A, j) && (X = A[j], this.attribute(j, X));
            else
              i(Y) && (Y = Y.apply()), (!this.options.skipNullAttributes || Y != null) && (this.currentNode.attributes[A] = new ae(this, A, Y));
            return this;
          }, b.prototype.text = function(A) {
            var Y;
            return this.openCurrent(), Y = new g(this, A), this.onData(this.writer.text(Y, this.currentLevel + 1), this.currentLevel + 1), this;
          }, b.prototype.cdata = function(A) {
            var Y;
            return this.openCurrent(), Y = new J(this, A), this.onData(this.writer.cdata(Y, this.currentLevel + 1), this.currentLevel + 1), this;
          }, b.prototype.comment = function(A) {
            var Y;
            return this.openCurrent(), Y = new o(this, A), this.onData(this.writer.comment(Y, this.currentLevel + 1), this.currentLevel + 1), this;
          }, b.prototype.raw = function(A) {
            var Y;
            return this.openCurrent(), Y = new d(this, A), this.onData(this.writer.raw(Y, this.currentLevel + 1), this.currentLevel + 1), this;
          }, b.prototype.instruction = function(A, Y) {
            var j, X, B, U, k;
            if (this.openCurrent(), A != null && (A = n(A)), Y != null && (Y = n(Y)), Array.isArray(A))
              for (j = 0, U = A.length; j < U; j++)
                X = A[j], this.instruction(X);
            else if (l(A))
              for (X in A)
                O.call(A, X) && (B = A[X], this.instruction(X, B));
            else
              i(Y) && (Y = Y.apply()), k = new c(this, A, Y), this.onData(this.writer.processingInstruction(k, this.currentLevel + 1), this.currentLevel + 1);
            return this;
          }, b.prototype.declaration = function(A, Y, j) {
            var X;
            if (this.openCurrent(), this.documentStarted)
              throw new Error("declaration() must be the first node.");
            return X = new h(this, A, Y, j), this.onData(this.writer.declaration(X, this.currentLevel + 1), this.currentLevel + 1), this;
          }, b.prototype.doctype = function(A, Y, j) {
            if (this.openCurrent(), A == null)
              throw new Error("Missing root node name.");
            if (this.root)
              throw new Error("dtd() must come before the root node.");
            return this.currentNode = new e(this, Y, j), this.currentNode.rootNodeName = A, this.currentNode.children = !1, this.currentLevel++, this.openTags[this.currentLevel] = this.currentNode, this;
          }, b.prototype.dtdElement = function(A, Y) {
            var j;
            return this.openCurrent(), j = new t(this, A, Y), this.onData(this.writer.dtdElement(j, this.currentLevel + 1), this.currentLevel + 1), this;
          }, b.prototype.attList = function(A, Y, j, X, B) {
            var U;
            return this.openCurrent(), U = new F(this, A, Y, j, X, B), this.onData(this.writer.dtdAttList(U, this.currentLevel + 1), this.currentLevel + 1), this;
          }, b.prototype.entity = function(A, Y) {
            var j;
            return this.openCurrent(), j = new a(this, !1, A, Y), this.onData(this.writer.dtdEntity(j, this.currentLevel + 1), this.currentLevel + 1), this;
          }, b.prototype.pEntity = function(A, Y) {
            var j;
            return this.openCurrent(), j = new a(this, !0, A, Y), this.onData(this.writer.dtdEntity(j, this.currentLevel + 1), this.currentLevel + 1), this;
          }, b.prototype.notation = function(A, Y) {
            var j;
            return this.openCurrent(), j = new v(this, A, Y), this.onData(this.writer.dtdNotation(j, this.currentLevel + 1), this.currentLevel + 1), this;
          }, b.prototype.up = function() {
            if (this.currentLevel < 0)
              throw new Error("The document node has no parent.");
            return this.currentNode ? (this.currentNode.children ? this.closeNode(this.currentNode) : this.openNode(this.currentNode), this.currentNode = null) : this.closeNode(this.openTags[this.currentLevel]), delete this.openTags[this.currentLevel], this.currentLevel--, this;
          }, b.prototype.end = function() {
            for (; this.currentLevel >= 0; )
              this.up();
            return this.onEnd();
          }, b.prototype.openCurrent = function() {
            if (this.currentNode)
              return this.currentNode.children = !0, this.openNode(this.currentNode);
          }, b.prototype.openNode = function(A) {
            if (!A.isOpen)
              return !this.root && this.currentLevel === 0 && A instanceof y && (this.root = A), this.onData(this.writer.openNode(A, this.currentLevel), this.currentLevel), A.isOpen = !0;
          }, b.prototype.closeNode = function(A) {
            if (!A.isClosed)
              return this.onData(this.writer.closeNode(A, this.currentLevel), this.currentLevel), A.isClosed = !0;
          }, b.prototype.onData = function(A, Y) {
            return this.documentStarted = !0, this.onDataCallback(A, Y + 1);
          }, b.prototype.onEnd = function() {
            return this.documentCompleted = !0, this.onEndCallback();
          }, b.prototype.debugInfo = function(A) {
            return A == null ? "" : "node: <" + A + ">";
          }, b.prototype.ele = function() {
            return this.element.apply(this, arguments);
          }, b.prototype.nod = function(A, Y, j) {
            return this.node(A, Y, j);
          }, b.prototype.txt = function(A) {
            return this.text(A);
          }, b.prototype.dat = function(A) {
            return this.cdata(A);
          }, b.prototype.com = function(A) {
            return this.comment(A);
          }, b.prototype.ins = function(A, Y) {
            return this.instruction(A, Y);
          }, b.prototype.dec = function(A, Y, j) {
            return this.declaration(A, Y, j);
          }, b.prototype.dtd = function(A, Y, j) {
            return this.doctype(A, Y, j);
          }, b.prototype.e = function(A, Y, j) {
            return this.element(A, Y, j);
          }, b.prototype.n = function(A, Y, j) {
            return this.node(A, Y, j);
          }, b.prototype.t = function(A) {
            return this.text(A);
          }, b.prototype.d = function(A) {
            return this.cdata(A);
          }, b.prototype.c = function(A) {
            return this.comment(A);
          }, b.prototype.r = function(A) {
            return this.raw(A);
          }, b.prototype.i = function(A, Y) {
            return this.instruction(A, Y);
          }, b.prototype.att = function() {
            return this.currentNode && this.currentNode instanceof e ? this.attList.apply(this, arguments) : this.attribute.apply(this, arguments);
          }, b.prototype.a = function() {
            return this.currentNode && this.currentNode instanceof e ? this.attList.apply(this, arguments) : this.attribute.apply(this, arguments);
          }, b.prototype.ent = function(A, Y) {
            return this.entity(A, Y);
          }, b.prototype.pent = function(A, Y) {
            return this.pEntity(A, Y);
          }, b.prototype.not = function(A, Y) {
            return this.notation(A, Y);
          }, b;
        }();
      }).call(this);
    }, { "./Utility": 122, "./XMLAttribute": 123, "./XMLCData": 124, "./XMLComment": 125, "./XMLDTDAttList": 126, "./XMLDTDElement": 127, "./XMLDTDEntity": 128, "./XMLDTDNotation": 129, "./XMLDeclaration": 130, "./XMLDocType": 131, "./XMLElement": 134, "./XMLProcessingInstruction": 136, "./XMLRaw": 137, "./XMLStringWriter": 139, "./XMLStringifier": 140, "./XMLText": 141 }], 134: [function(le, ce, re) {
      (function() {
        var ae, J, o, F, t, a, v = function(e, y) {
          for (var c in y)
            h.call(y, c) && (e[c] = y[c]);
          function d() {
            this.constructor = e;
          }
          return d.prototype = y.prototype, e.prototype = new d(), e.__super__ = y.prototype, e;
        }, h = {}.hasOwnProperty;
        a = le("./Utility"), t = a.isObject, F = a.isFunction, o = a.getValue, J = le("./XMLNode"), ae = le("./XMLAttribute"), ce.exports = function(e) {
          v(y, e);
          function y(c, d, m) {
            if (y.__super__.constructor.call(this, c), d == null)
              throw new Error("Missing element name. " + this.debugInfo());
            this.name = this.stringify.eleName(d), this.attributes = {}, m != null && this.attribute(m), c.isDocument && (this.isRoot = !0, this.documentObject = c, c.rootObject = this);
          }
          return y.prototype.clone = function() {
            var c, d, m, p;
            m = Object.create(this), m.isRoot && (m.documentObject = null), m.attributes = {}, p = this.attributes;
            for (d in p)
              h.call(p, d) && (c = p[d], m.attributes[d] = c.clone());
            return m.children = [], this.children.forEach(function(g) {
              var n;
              return n = g.clone(), n.parent = m, m.children.push(n);
            }), m;
          }, y.prototype.attribute = function(c, d) {
            var m, p;
            if (c != null && (c = o(c)), t(c))
              for (m in c)
                h.call(c, m) && (p = c[m], this.attribute(m, p));
            else
              F(d) && (d = d.apply()), (!this.options.skipNullAttributes || d != null) && (this.attributes[c] = new ae(this, c, d));
            return this;
          }, y.prototype.removeAttribute = function(c) {
            var d, m, p;
            if (c == null)
              throw new Error("Missing attribute name. " + this.debugInfo());
            if (c = o(c), Array.isArray(c))
              for (m = 0, p = c.length; m < p; m++)
                d = c[m], delete this.attributes[d];
            else
              delete this.attributes[c];
            return this;
          }, y.prototype.toString = function(c) {
            return this.options.writer.set(c).element(this);
          }, y.prototype.att = function(c, d) {
            return this.attribute(c, d);
          }, y.prototype.a = function(c, d) {
            return this.attribute(c, d);
          }, y;
        }(J);
      }).call(this);
    }, { "./Utility": 122, "./XMLAttribute": 123, "./XMLNode": 135 }], 135: [function(le, ce, re) {
      (function() {
        var ae, J, o, F, t, a, v, h, e, y, c, d, m, p = {}.hasOwnProperty;
        m = le("./Utility"), d = m.isObject, c = m.isFunction, y = m.isEmpty, e = m.getValue, t = null, ae = null, J = null, o = null, F = null, v = null, h = null, a = null, ce.exports = function() {
          function g(n) {
            this.parent = n, this.parent && (this.options = this.parent.options, this.stringify = this.parent.stringify), this.children = [], t || (t = le("./XMLElement"), ae = le("./XMLCData"), J = le("./XMLComment"), o = le("./XMLDeclaration"), F = le("./XMLDocType"), v = le("./XMLRaw"), h = le("./XMLText"), a = le("./XMLProcessingInstruction"));
          }
          return g.prototype.element = function(n, i, l) {
            var u, w, O, b, A, Y, j, X, B, U;
            if (Y = null, i == null && (i = {}), i = e(i), d(i) || (B = [i, l], l = B[0], i = B[1]), n != null && (n = e(n)), Array.isArray(n))
              for (O = 0, j = n.length; O < j; O++)
                w = n[O], Y = this.element(w);
            else if (c(n))
              Y = this.element(n.apply());
            else if (d(n)) {
              for (A in n)
                if (p.call(n, A))
                  if (U = n[A], c(U) && (U = U.apply()), d(U) && y(U) && (U = null), !this.options.ignoreDecorators && this.stringify.convertAttKey && A.indexOf(this.stringify.convertAttKey) === 0)
                    Y = this.attribute(A.substr(this.stringify.convertAttKey.length), U);
                  else if (!this.options.separateArrayItems && Array.isArray(U))
                    for (b = 0, X = U.length; b < X; b++)
                      w = U[b], u = {}, u[A] = w, Y = this.element(u);
                  else
                    d(U) ? (Y = this.element(A), Y.element(U)) : Y = this.element(A, U);
            } else
              !this.options.ignoreDecorators && this.stringify.convertTextKey && n.indexOf(this.stringify.convertTextKey) === 0 ? Y = this.text(l) : !this.options.ignoreDecorators && this.stringify.convertCDataKey && n.indexOf(this.stringify.convertCDataKey) === 0 ? Y = this.cdata(l) : !this.options.ignoreDecorators && this.stringify.convertCommentKey && n.indexOf(this.stringify.convertCommentKey) === 0 ? Y = this.comment(l) : !this.options.ignoreDecorators && this.stringify.convertRawKey && n.indexOf(this.stringify.convertRawKey) === 0 ? Y = this.raw(l) : !this.options.ignoreDecorators && this.stringify.convertPIKey && n.indexOf(this.stringify.convertPIKey) === 0 ? Y = this.instruction(n.substr(this.stringify.convertPIKey.length), l) : Y = this.node(n, i, l);
            if (Y == null)
              throw new Error("Could not create any elements with: " + n + ". " + this.debugInfo());
            return Y;
          }, g.prototype.insertBefore = function(n, i, l) {
            var u, w, O;
            if (this.isRoot)
              throw new Error("Cannot insert elements at root level. " + this.debugInfo(n));
            return w = this.parent.children.indexOf(this), O = this.parent.children.splice(w), u = this.parent.element(n, i, l), Array.prototype.push.apply(this.parent.children, O), u;
          }, g.prototype.insertAfter = function(n, i, l) {
            var u, w, O;
            if (this.isRoot)
              throw new Error("Cannot insert elements at root level. " + this.debugInfo(n));
            return w = this.parent.children.indexOf(this), O = this.parent.children.splice(w + 1), u = this.parent.element(n, i, l), Array.prototype.push.apply(this.parent.children, O), u;
          }, g.prototype.remove = function() {
            var n;
            if (this.isRoot)
              throw new Error("Cannot remove the root element. " + this.debugInfo());
            return n = this.parent.children.indexOf(this), [].splice.apply(this.parent.children, [n, n - n + 1].concat([])), this.parent;
          }, g.prototype.node = function(n, i, l) {
            var u, w;
            return n != null && (n = e(n)), i || (i = {}), i = e(i), d(i) || (w = [i, l], l = w[0], i = w[1]), u = new t(this, n, i), l != null && u.text(l), this.children.push(u), u;
          }, g.prototype.text = function(n) {
            var i;
            return i = new h(this, n), this.children.push(i), this;
          }, g.prototype.cdata = function(n) {
            var i;
            return i = new ae(this, n), this.children.push(i), this;
          }, g.prototype.comment = function(n) {
            var i;
            return i = new J(this, n), this.children.push(i), this;
          }, g.prototype.commentBefore = function(n) {
            var i, l;
            return i = this.parent.children.indexOf(this), l = this.parent.children.splice(i), this.parent.comment(n), Array.prototype.push.apply(this.parent.children, l), this;
          }, g.prototype.commentAfter = function(n) {
            var i, l;
            return i = this.parent.children.indexOf(this), l = this.parent.children.splice(i + 1), this.parent.comment(n), Array.prototype.push.apply(this.parent.children, l), this;
          }, g.prototype.raw = function(n) {
            var i;
            return i = new v(this, n), this.children.push(i), this;
          }, g.prototype.instruction = function(n, i) {
            var l, u, w, O, b;
            if (n != null && (n = e(n)), i != null && (i = e(i)), Array.isArray(n))
              for (O = 0, b = n.length; O < b; O++)
                l = n[O], this.instruction(l);
            else if (d(n))
              for (l in n)
                p.call(n, l) && (u = n[l], this.instruction(l, u));
            else
              c(i) && (i = i.apply()), w = new a(this, n, i), this.children.push(w);
            return this;
          }, g.prototype.instructionBefore = function(n, i) {
            var l, u;
            return l = this.parent.children.indexOf(this), u = this.parent.children.splice(l), this.parent.instruction(n, i), Array.prototype.push.apply(this.parent.children, u), this;
          }, g.prototype.instructionAfter = function(n, i) {
            var l, u;
            return l = this.parent.children.indexOf(this), u = this.parent.children.splice(l + 1), this.parent.instruction(n, i), Array.prototype.push.apply(this.parent.children, u), this;
          }, g.prototype.declaration = function(n, i, l) {
            var u, w;
            return u = this.document(), w = new o(u, n, i, l), u.children[0] instanceof o ? u.children[0] = w : u.children.unshift(w), u.root() || u;
          }, g.prototype.doctype = function(n, i) {
            var l, u, w, O, b, A, Y, j, X, B;
            for (u = this.document(), w = new F(u, n, i), X = u.children, O = b = 0, Y = X.length; b < Y; O = ++b)
              if (l = X[O], l instanceof F)
                return u.children[O] = w, w;
            for (B = u.children, O = A = 0, j = B.length; A < j; O = ++A)
              if (l = B[O], l.isRoot)
                return u.children.splice(O, 0, w), w;
            return u.children.push(w), w;
          }, g.prototype.up = function() {
            if (this.isRoot)
              throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
            return this.parent;
          }, g.prototype.root = function() {
            var n;
            for (n = this; n; ) {
              if (n.isDocument)
                return n.rootObject;
              if (n.isRoot)
                return n;
              n = n.parent;
            }
          }, g.prototype.document = function() {
            var n;
            for (n = this; n; ) {
              if (n.isDocument)
                return n;
              n = n.parent;
            }
          }, g.prototype.end = function(n) {
            return this.document().end(n);
          }, g.prototype.prev = function() {
            var n;
            if (n = this.parent.children.indexOf(this), n < 1)
              throw new Error("Already at the first node. " + this.debugInfo());
            return this.parent.children[n - 1];
          }, g.prototype.next = function() {
            var n;
            if (n = this.parent.children.indexOf(this), n === -1 || n === this.parent.children.length - 1)
              throw new Error("Already at the last node. " + this.debugInfo());
            return this.parent.children[n + 1];
          }, g.prototype.importDocument = function(n) {
            var i;
            return i = n.root().clone(), i.parent = this, i.isRoot = !1, this.children.push(i), this;
          }, g.prototype.debugInfo = function(n) {
            var i, l;
            return n = n || this.name, n == null && !((i = this.parent) != null && i.name) ? "" : n == null ? "parent: <" + this.parent.name + ">" : (l = this.parent) != null && l.name ? "node: <" + n + ">, parent: <" + this.parent.name + ">" : "node: <" + n + ">";
          }, g.prototype.ele = function(n, i, l) {
            return this.element(n, i, l);
          }, g.prototype.nod = function(n, i, l) {
            return this.node(n, i, l);
          }, g.prototype.txt = function(n) {
            return this.text(n);
          }, g.prototype.dat = function(n) {
            return this.cdata(n);
          }, g.prototype.com = function(n) {
            return this.comment(n);
          }, g.prototype.ins = function(n, i) {
            return this.instruction(n, i);
          }, g.prototype.doc = function() {
            return this.document();
          }, g.prototype.dec = function(n, i, l) {
            return this.declaration(n, i, l);
          }, g.prototype.dtd = function(n, i) {
            return this.doctype(n, i);
          }, g.prototype.e = function(n, i, l) {
            return this.element(n, i, l);
          }, g.prototype.n = function(n, i, l) {
            return this.node(n, i, l);
          }, g.prototype.t = function(n) {
            return this.text(n);
          }, g.prototype.d = function(n) {
            return this.cdata(n);
          }, g.prototype.c = function(n) {
            return this.comment(n);
          }, g.prototype.r = function(n) {
            return this.raw(n);
          }, g.prototype.i = function(n, i) {
            return this.instruction(n, i);
          }, g.prototype.u = function() {
            return this.up();
          }, g.prototype.importXMLBuilder = function(n) {
            return this.importDocument(n);
          }, g;
        }();
      }).call(this);
    }, { "./Utility": 122, "./XMLCData": 124, "./XMLComment": 125, "./XMLDeclaration": 130, "./XMLDocType": 131, "./XMLElement": 134, "./XMLProcessingInstruction": 136, "./XMLRaw": 137, "./XMLText": 141 }], 136: [function(le, ce, re) {
      (function() {
        var ae, J = function(F, t) {
          for (var a in t)
            o.call(t, a) && (F[a] = t[a]);
          function v() {
            this.constructor = F;
          }
          return v.prototype = t.prototype, F.prototype = new v(), F.__super__ = t.prototype, F;
        }, o = {}.hasOwnProperty;
        ae = le("./XMLNode"), ce.exports = function(F) {
          J(t, F);
          function t(a, v, h) {
            if (t.__super__.constructor.call(this, a), v == null)
              throw new Error("Missing instruction target. " + this.debugInfo());
            this.target = this.stringify.insTarget(v), h && (this.value = this.stringify.insValue(h));
          }
          return t.prototype.clone = function() {
            return Object.create(this);
          }, t.prototype.toString = function(a) {
            return this.options.writer.set(a).processingInstruction(this);
          }, t;
        }(ae);
      }).call(this);
    }, { "./XMLNode": 135 }], 137: [function(le, ce, re) {
      (function() {
        var ae, J = function(F, t) {
          for (var a in t)
            o.call(t, a) && (F[a] = t[a]);
          function v() {
            this.constructor = F;
          }
          return v.prototype = t.prototype, F.prototype = new v(), F.__super__ = t.prototype, F;
        }, o = {}.hasOwnProperty;
        ae = le("./XMLNode"), ce.exports = function(F) {
          J(t, F);
          function t(a, v) {
            if (t.__super__.constructor.call(this, a), v == null)
              throw new Error("Missing raw text. " + this.debugInfo());
            this.value = this.stringify.raw(v);
          }
          return t.prototype.clone = function() {
            return Object.create(this);
          }, t.prototype.toString = function(a) {
            return this.options.writer.set(a).raw(this);
          }, t;
        }(ae);
      }).call(this);
    }, { "./XMLNode": 135 }], 138: [function(le, ce, re) {
      (function() {
        var ae, J, o, F, t, a, v, h, e, y, c, d, m, p = function(n, i) {
          for (var l in i)
            g.call(i, l) && (n[l] = i[l]);
          function u() {
            this.constructor = n;
          }
          return u.prototype = i.prototype, n.prototype = new u(), n.__super__ = i.prototype, n;
        }, g = {}.hasOwnProperty;
        v = le("./XMLDeclaration"), h = le("./XMLDocType"), ae = le("./XMLCData"), J = le("./XMLComment"), e = le("./XMLElement"), c = le("./XMLRaw"), d = le("./XMLText"), y = le("./XMLProcessingInstruction"), o = le("./XMLDTDAttList"), F = le("./XMLDTDElement"), t = le("./XMLDTDEntity"), a = le("./XMLDTDNotation"), m = le("./XMLWriterBase"), ce.exports = function(n) {
          p(i, n);
          function i(l, u) {
            i.__super__.constructor.call(this, u), this.stream = l;
          }
          return i.prototype.document = function(l) {
            var u, w, O, b, A, Y, j, X;
            for (Y = l.children, w = 0, b = Y.length; w < b; w++)
              u = Y[w], u.isLastRootNode = !1;
            for (l.children[l.children.length - 1].isLastRootNode = !0, j = l.children, X = [], O = 0, A = j.length; O < A; O++)
              switch (u = j[O], !1) {
                case !(u instanceof v):
                  X.push(this.declaration(u));
                  break;
                case !(u instanceof h):
                  X.push(this.docType(u));
                  break;
                case !(u instanceof J):
                  X.push(this.comment(u));
                  break;
                case !(u instanceof y):
                  X.push(this.processingInstruction(u));
                  break;
                default:
                  X.push(this.element(u));
              }
            return X;
          }, i.prototype.attribute = function(l) {
            return this.stream.write(" " + l.name + '="' + l.value + '"');
          }, i.prototype.cdata = function(l, u) {
            return this.stream.write(this.space(u) + "<![CDATA[" + l.text + "]]>" + this.endline(l));
          }, i.prototype.comment = function(l, u) {
            return this.stream.write(this.space(u) + "<!-- " + l.text + " -->" + this.endline(l));
          }, i.prototype.declaration = function(l, u) {
            return this.stream.write(this.space(u)), this.stream.write('<?xml version="' + l.version + '"'), l.encoding != null && this.stream.write(' encoding="' + l.encoding + '"'), l.standalone != null && this.stream.write(' standalone="' + l.standalone + '"'), this.stream.write(this.spacebeforeslash + "?>"), this.stream.write(this.endline(l));
          }, i.prototype.docType = function(l, u) {
            var w, O, b, A;
            if (u || (u = 0), this.stream.write(this.space(u)), this.stream.write("<!DOCTYPE " + l.root().name), l.pubID && l.sysID ? this.stream.write(' PUBLIC "' + l.pubID + '" "' + l.sysID + '"') : l.sysID && this.stream.write(' SYSTEM "' + l.sysID + '"'), l.children.length > 0) {
              for (this.stream.write(" ["), this.stream.write(this.endline(l)), A = l.children, O = 0, b = A.length; O < b; O++)
                switch (w = A[O], !1) {
                  case !(w instanceof o):
                    this.dtdAttList(w, u + 1);
                    break;
                  case !(w instanceof F):
                    this.dtdElement(w, u + 1);
                    break;
                  case !(w instanceof t):
                    this.dtdEntity(w, u + 1);
                    break;
                  case !(w instanceof a):
                    this.dtdNotation(w, u + 1);
                    break;
                  case !(w instanceof ae):
                    this.cdata(w, u + 1);
                    break;
                  case !(w instanceof J):
                    this.comment(w, u + 1);
                    break;
                  case !(w instanceof y):
                    this.processingInstruction(w, u + 1);
                    break;
                  default:
                    throw new Error("Unknown DTD node type: " + w.constructor.name);
                }
              this.stream.write("]");
            }
            return this.stream.write(this.spacebeforeslash + ">"), this.stream.write(this.endline(l));
          }, i.prototype.element = function(l, u) {
            var w, O, b, A, Y, j, X, B;
            u || (u = 0), B = this.space(u), this.stream.write(B + "<" + l.name), j = l.attributes;
            for (Y in j)
              g.call(j, Y) && (w = j[Y], this.attribute(w));
            if (l.children.length === 0 || l.children.every(function(U) {
              return U.value === "";
            }))
              this.allowEmpty ? this.stream.write("></" + l.name + ">") : this.stream.write(this.spacebeforeslash + "/>");
            else if (this.pretty && l.children.length === 1 && l.children[0].value != null)
              this.stream.write(">"), this.stream.write(l.children[0].value), this.stream.write("</" + l.name + ">");
            else {
              for (this.stream.write(">" + this.newline), X = l.children, b = 0, A = X.length; b < A; b++)
                switch (O = X[b], !1) {
                  case !(O instanceof ae):
                    this.cdata(O, u + 1);
                    break;
                  case !(O instanceof J):
                    this.comment(O, u + 1);
                    break;
                  case !(O instanceof e):
                    this.element(O, u + 1);
                    break;
                  case !(O instanceof c):
                    this.raw(O, u + 1);
                    break;
                  case !(O instanceof d):
                    this.text(O, u + 1);
                    break;
                  case !(O instanceof y):
                    this.processingInstruction(O, u + 1);
                    break;
                  default:
                    throw new Error("Unknown XML node type: " + O.constructor.name);
                }
              this.stream.write(B + "</" + l.name + ">");
            }
            return this.stream.write(this.endline(l));
          }, i.prototype.processingInstruction = function(l, u) {
            return this.stream.write(this.space(u) + "<?" + l.target), l.value && this.stream.write(" " + l.value), this.stream.write(this.spacebeforeslash + "?>" + this.endline(l));
          }, i.prototype.raw = function(l, u) {
            return this.stream.write(this.space(u) + l.value + this.endline(l));
          }, i.prototype.text = function(l, u) {
            return this.stream.write(this.space(u) + l.value + this.endline(l));
          }, i.prototype.dtdAttList = function(l, u) {
            return this.stream.write(this.space(u) + "<!ATTLIST " + l.elementName + " " + l.attributeName + " " + l.attributeType), l.defaultValueType !== "#DEFAULT" && this.stream.write(" " + l.defaultValueType), l.defaultValue && this.stream.write(' "' + l.defaultValue + '"'), this.stream.write(this.spacebeforeslash + ">" + this.endline(l));
          }, i.prototype.dtdElement = function(l, u) {
            return this.stream.write(this.space(u) + "<!ELEMENT " + l.name + " " + l.value), this.stream.write(this.spacebeforeslash + ">" + this.endline(l));
          }, i.prototype.dtdEntity = function(l, u) {
            return this.stream.write(this.space(u) + "<!ENTITY"), l.pe && this.stream.write(" %"), this.stream.write(" " + l.name), l.value ? this.stream.write(' "' + l.value + '"') : (l.pubID && l.sysID ? this.stream.write(' PUBLIC "' + l.pubID + '" "' + l.sysID + '"') : l.sysID && this.stream.write(' SYSTEM "' + l.sysID + '"'), l.nData && this.stream.write(" NDATA " + l.nData)), this.stream.write(this.spacebeforeslash + ">" + this.endline(l));
          }, i.prototype.dtdNotation = function(l, u) {
            return this.stream.write(this.space(u) + "<!NOTATION " + l.name), l.pubID && l.sysID ? this.stream.write(' PUBLIC "' + l.pubID + '" "' + l.sysID + '"') : l.pubID ? this.stream.write(' PUBLIC "' + l.pubID + '"') : l.sysID && this.stream.write(' SYSTEM "' + l.sysID + '"'), this.stream.write(this.spacebeforeslash + ">" + this.endline(l));
          }, i.prototype.endline = function(l) {
            return l.isLastRootNode ? "" : this.newline;
          }, i;
        }(m);
      }).call(this);
    }, { "./XMLCData": 124, "./XMLComment": 125, "./XMLDTDAttList": 126, "./XMLDTDElement": 127, "./XMLDTDEntity": 128, "./XMLDTDNotation": 129, "./XMLDeclaration": 130, "./XMLDocType": 131, "./XMLElement": 134, "./XMLProcessingInstruction": 136, "./XMLRaw": 137, "./XMLText": 141, "./XMLWriterBase": 142 }], 139: [function(le, ce, re) {
      (function() {
        var ae, J, o, F, t, a, v, h, e, y, c, d, m, p = function(n, i) {
          for (var l in i)
            g.call(i, l) && (n[l] = i[l]);
          function u() {
            this.constructor = n;
          }
          return u.prototype = i.prototype, n.prototype = new u(), n.__super__ = i.prototype, n;
        }, g = {}.hasOwnProperty;
        v = le("./XMLDeclaration"), h = le("./XMLDocType"), ae = le("./XMLCData"), J = le("./XMLComment"), e = le("./XMLElement"), c = le("./XMLRaw"), d = le("./XMLText"), y = le("./XMLProcessingInstruction"), o = le("./XMLDTDAttList"), F = le("./XMLDTDElement"), t = le("./XMLDTDEntity"), a = le("./XMLDTDNotation"), m = le("./XMLWriterBase"), ce.exports = function(n) {
          p(i, n);
          function i(l) {
            i.__super__.constructor.call(this, l);
          }
          return i.prototype.document = function(l) {
            var u, w, O, b, A;
            for (this.textispresent = !1, b = "", A = l.children, w = 0, O = A.length; w < O; w++)
              u = A[w], b += function() {
                switch (!1) {
                  case !(u instanceof v):
                    return this.declaration(u);
                  case !(u instanceof h):
                    return this.docType(u);
                  case !(u instanceof J):
                    return this.comment(u);
                  case !(u instanceof y):
                    return this.processingInstruction(u);
                  default:
                    return this.element(u, 0);
                }
              }.call(this);
            return this.pretty && b.slice(-this.newline.length) === this.newline && (b = b.slice(0, -this.newline.length)), b;
          }, i.prototype.attribute = function(l) {
            return " " + l.name + '="' + l.value + '"';
          }, i.prototype.cdata = function(l, u) {
            return this.space(u) + "<![CDATA[" + l.text + "]]>" + this.newline;
          }, i.prototype.comment = function(l, u) {
            return this.space(u) + "<!-- " + l.text + " -->" + this.newline;
          }, i.prototype.declaration = function(l, u) {
            var w;
            return w = this.space(u), w += '<?xml version="' + l.version + '"', l.encoding != null && (w += ' encoding="' + l.encoding + '"'), l.standalone != null && (w += ' standalone="' + l.standalone + '"'), w += this.spacebeforeslash + "?>", w += this.newline, w;
          }, i.prototype.docType = function(l, u) {
            var w, O, b, A, Y;
            if (u || (u = 0), A = this.space(u), A += "<!DOCTYPE " + l.root().name, l.pubID && l.sysID ? A += ' PUBLIC "' + l.pubID + '" "' + l.sysID + '"' : l.sysID && (A += ' SYSTEM "' + l.sysID + '"'), l.children.length > 0) {
              for (A += " [", A += this.newline, Y = l.children, O = 0, b = Y.length; O < b; O++)
                w = Y[O], A += function() {
                  switch (!1) {
                    case !(w instanceof o):
                      return this.dtdAttList(w, u + 1);
                    case !(w instanceof F):
                      return this.dtdElement(w, u + 1);
                    case !(w instanceof t):
                      return this.dtdEntity(w, u + 1);
                    case !(w instanceof a):
                      return this.dtdNotation(w, u + 1);
                    case !(w instanceof ae):
                      return this.cdata(w, u + 1);
                    case !(w instanceof J):
                      return this.comment(w, u + 1);
                    case !(w instanceof y):
                      return this.processingInstruction(w, u + 1);
                    default:
                      throw new Error("Unknown DTD node type: " + w.constructor.name);
                  }
                }.call(this);
              A += "]";
            }
            return A += this.spacebeforeslash + ">", A += this.newline, A;
          }, i.prototype.element = function(l, u) {
            var w, O, b, A, Y, j, X, B, U, k, x, f, D;
            u || (u = 0), D = !1, this.textispresent ? (this.newline = "", this.pretty = !1) : (this.newline = this.newlinedefault, this.pretty = this.prettydefault), f = this.space(u), B = "", B += f + "<" + l.name, U = l.attributes;
            for (X in U)
              g.call(U, X) && (w = U[X], B += this.attribute(w));
            if (l.children.length === 0 || l.children.every(function(_) {
              return _.value === "";
            }))
              this.allowEmpty ? B += "></" + l.name + ">" + this.newline : B += this.spacebeforeslash + "/>" + this.newline;
            else if (this.pretty && l.children.length === 1 && l.children[0].value != null)
              B += ">", B += l.children[0].value, B += "</" + l.name + ">" + this.newline;
            else {
              if (this.dontprettytextnodes) {
                for (k = l.children, b = 0, Y = k.length; b < Y; b++)
                  if (O = k[b], O.value != null) {
                    this.textispresent++, D = !0;
                    break;
                  }
              }
              for (this.textispresent && (this.newline = "", this.pretty = !1, f = this.space(u)), B += ">" + this.newline, x = l.children, A = 0, j = x.length; A < j; A++)
                O = x[A], B += function() {
                  switch (!1) {
                    case !(O instanceof ae):
                      return this.cdata(O, u + 1);
                    case !(O instanceof J):
                      return this.comment(O, u + 1);
                    case !(O instanceof e):
                      return this.element(O, u + 1);
                    case !(O instanceof c):
                      return this.raw(O, u + 1);
                    case !(O instanceof d):
                      return this.text(O, u + 1);
                    case !(O instanceof y):
                      return this.processingInstruction(O, u + 1);
                    default:
                      throw new Error("Unknown XML node type: " + O.constructor.name);
                  }
                }.call(this);
              D && this.textispresent--, this.textispresent || (this.newline = this.newlinedefault, this.pretty = this.prettydefault), B += f + "</" + l.name + ">" + this.newline;
            }
            return B;
          }, i.prototype.processingInstruction = function(l, u) {
            var w;
            return w = this.space(u) + "<?" + l.target, l.value && (w += " " + l.value), w += this.spacebeforeslash + "?>" + this.newline, w;
          }, i.prototype.raw = function(l, u) {
            return this.space(u) + l.value + this.newline;
          }, i.prototype.text = function(l, u) {
            return this.space(u) + l.value + this.newline;
          }, i.prototype.dtdAttList = function(l, u) {
            var w;
            return w = this.space(u) + "<!ATTLIST " + l.elementName + " " + l.attributeName + " " + l.attributeType, l.defaultValueType !== "#DEFAULT" && (w += " " + l.defaultValueType), l.defaultValue && (w += ' "' + l.defaultValue + '"'), w += this.spacebeforeslash + ">" + this.newline, w;
          }, i.prototype.dtdElement = function(l, u) {
            return this.space(u) + "<!ELEMENT " + l.name + " " + l.value + this.spacebeforeslash + ">" + this.newline;
          }, i.prototype.dtdEntity = function(l, u) {
            var w;
            return w = this.space(u) + "<!ENTITY", l.pe && (w += " %"), w += " " + l.name, l.value ? w += ' "' + l.value + '"' : (l.pubID && l.sysID ? w += ' PUBLIC "' + l.pubID + '" "' + l.sysID + '"' : l.sysID && (w += ' SYSTEM "' + l.sysID + '"'), l.nData && (w += " NDATA " + l.nData)), w += this.spacebeforeslash + ">" + this.newline, w;
          }, i.prototype.dtdNotation = function(l, u) {
            var w;
            return w = this.space(u) + "<!NOTATION " + l.name, l.pubID && l.sysID ? w += ' PUBLIC "' + l.pubID + '" "' + l.sysID + '"' : l.pubID ? w += ' PUBLIC "' + l.pubID + '"' : l.sysID && (w += ' SYSTEM "' + l.sysID + '"'), w += this.spacebeforeslash + ">" + this.newline, w;
          }, i.prototype.openNode = function(l, u) {
            var w, O, b, A;
            if (u || (u = 0), l instanceof e) {
              b = this.space(u) + "<" + l.name, A = l.attributes;
              for (O in A)
                g.call(A, O) && (w = A[O], b += this.attribute(w));
              return b += (l.children ? ">" : "/>") + this.newline, b;
            } else
              return b = this.space(u) + "<!DOCTYPE " + l.rootNodeName, l.pubID && l.sysID ? b += ' PUBLIC "' + l.pubID + '" "' + l.sysID + '"' : l.sysID && (b += ' SYSTEM "' + l.sysID + '"'), b += (l.children ? " [" : ">") + this.newline, b;
          }, i.prototype.closeNode = function(l, u) {
            switch (u || (u = 0), !1) {
              case !(l instanceof e):
                return this.space(u) + "</" + l.name + ">" + this.newline;
              case !(l instanceof h):
                return this.space(u) + "]>" + this.newline;
            }
          }, i;
        }(m);
      }).call(this);
    }, { "./XMLCData": 124, "./XMLComment": 125, "./XMLDTDAttList": 126, "./XMLDTDElement": 127, "./XMLDTDEntity": 128, "./XMLDTDNotation": 129, "./XMLDeclaration": 130, "./XMLDocType": 131, "./XMLElement": 134, "./XMLProcessingInstruction": 136, "./XMLRaw": 137, "./XMLText": 141, "./XMLWriterBase": 142 }], 140: [function(le, ce, re) {
      (function() {
        var ae = function(o, F) {
          return function() {
            return o.apply(F, arguments);
          };
        }, J = {}.hasOwnProperty;
        ce.exports = function() {
          function o(F) {
            this.assertLegalChar = ae(this.assertLegalChar, this);
            var t, a, v;
            F || (F = {}), this.noDoubleEncoding = F.noDoubleEncoding, a = F.stringify || {};
            for (t in a)
              J.call(a, t) && (v = a[t], this[t] = v);
          }
          return o.prototype.eleName = function(F) {
            return F = "" + F || "", this.assertLegalChar(F);
          }, o.prototype.eleText = function(F) {
            return F = "" + F || "", this.assertLegalChar(this.elEscape(F));
          }, o.prototype.cdata = function(F) {
            return F = "" + F || "", F = F.replace("]]>", "]]]]><![CDATA[>"), this.assertLegalChar(F);
          }, o.prototype.comment = function(F) {
            if (F = "" + F || "", F.match(/--/))
              throw new Error("Comment text cannot contain double-hypen: " + F);
            return this.assertLegalChar(F);
          }, o.prototype.raw = function(F) {
            return "" + F || "";
          }, o.prototype.attName = function(F) {
            return F = "" + F || "";
          }, o.prototype.attValue = function(F) {
            return F = "" + F || "", this.attEscape(F);
          }, o.prototype.insTarget = function(F) {
            return "" + F || "";
          }, o.prototype.insValue = function(F) {
            if (F = "" + F || "", F.match(/\?>/))
              throw new Error("Invalid processing instruction value: " + F);
            return F;
          }, o.prototype.xmlVersion = function(F) {
            if (F = "" + F || "", !F.match(/1\.[0-9]+/))
              throw new Error("Invalid version number: " + F);
            return F;
          }, o.prototype.xmlEncoding = function(F) {
            if (F = "" + F || "", !F.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/))
              throw new Error("Invalid encoding: " + F);
            return F;
          }, o.prototype.xmlStandalone = function(F) {
            return F ? "yes" : "no";
          }, o.prototype.dtdPubID = function(F) {
            return "" + F || "";
          }, o.prototype.dtdSysID = function(F) {
            return "" + F || "";
          }, o.prototype.dtdElementValue = function(F) {
            return "" + F || "";
          }, o.prototype.dtdAttType = function(F) {
            return "" + F || "";
          }, o.prototype.dtdAttDefault = function(F) {
            return F != null ? "" + F || "" : F;
          }, o.prototype.dtdEntityValue = function(F) {
            return "" + F || "";
          }, o.prototype.dtdNData = function(F) {
            return "" + F || "";
          }, o.prototype.convertAttKey = "@", o.prototype.convertPIKey = "?", o.prototype.convertTextKey = "#text", o.prototype.convertCDataKey = "#cdata", o.prototype.convertCommentKey = "#comment", o.prototype.convertRawKey = "#raw", o.prototype.assertLegalChar = function(F) {
            var t;
            if (t = F.match(/[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/), t)
              throw new Error("Invalid character in string: " + F + " at index " + t.index);
            return F;
          }, o.prototype.elEscape = function(F) {
            var t;
            return t = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g, F.replace(t, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;");
          }, o.prototype.attEscape = function(F) {
            var t;
            return t = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g, F.replace(t, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
          }, o;
        }();
      }).call(this);
    }, {}], 141: [function(le, ce, re) {
      (function() {
        var ae, J = function(F, t) {
          for (var a in t)
            o.call(t, a) && (F[a] = t[a]);
          function v() {
            this.constructor = F;
          }
          return v.prototype = t.prototype, F.prototype = new v(), F.__super__ = t.prototype, F;
        }, o = {}.hasOwnProperty;
        ae = le("./XMLNode"), ce.exports = function(F) {
          J(t, F);
          function t(a, v) {
            if (t.__super__.constructor.call(this, a), v == null)
              throw new Error("Missing element text. " + this.debugInfo());
            this.value = this.stringify.eleText(v);
          }
          return t.prototype.clone = function() {
            return Object.create(this);
          }, t.prototype.toString = function(a) {
            return this.options.writer.set(a).text(this);
          }, t;
        }(ae);
      }).call(this);
    }, { "./XMLNode": 135 }], 142: [function(le, ce, re) {
      (function() {
        var ae = {}.hasOwnProperty;
        ce.exports = function() {
          function J(o) {
            var F, t, a, v, h, e, y, c, d;
            o || (o = {}), this.pretty = o.pretty || !1, this.allowEmpty = (t = o.allowEmpty) != null ? t : !1, this.pretty ? (this.indent = (a = o.indent) != null ? a : "  ", this.newline = (v = o.newline) != null ? v : `
`, this.offset = (h = o.offset) != null ? h : 0, this.dontprettytextnodes = (e = o.dontprettytextnodes) != null ? e : 0) : (this.indent = "", this.newline = "", this.offset = 0, this.dontprettytextnodes = 0), this.spacebeforeslash = (y = o.spacebeforeslash) != null ? y : "", this.spacebeforeslash === !0 && (this.spacebeforeslash = " "), this.newlinedefault = this.newline, this.prettydefault = this.pretty, c = o.writer || {};
            for (F in c)
              ae.call(c, F) && (d = c[F], this[F] = d);
          }
          return J.prototype.set = function(o) {
            var F, t, a;
            o || (o = {}), "pretty" in o && (this.pretty = o.pretty), "allowEmpty" in o && (this.allowEmpty = o.allowEmpty), this.pretty ? (this.indent = "indent" in o ? o.indent : "  ", this.newline = "newline" in o ? o.newline : `
`, this.offset = "offset" in o ? o.offset : 0, this.dontprettytextnodes = "dontprettytextnodes" in o ? o.dontprettytextnodes : 0) : (this.indent = "", this.newline = "", this.offset = 0, this.dontprettytextnodes = 0), this.spacebeforeslash = "spacebeforeslash" in o ? o.spacebeforeslash : "", this.spacebeforeslash === !0 && (this.spacebeforeslash = " "), this.newlinedefault = this.newline, this.prettydefault = this.pretty, t = o.writer || {};
            for (F in t)
              ae.call(t, F) && (a = t[F], this[F] = a);
            return this;
          }, J.prototype.space = function(o) {
            var F;
            return this.pretty ? (F = (o || 0) + this.offset + 1, F > 0 ? new Array(F).join(this.indent) : "") : "";
          }, J;
        }();
      }).call(this);
    }, {}], 143: [function(le, ce, re) {
      (function() {
        var ae, J, o, F, t, a, v;
        v = le("./Utility"), t = v.assign, a = v.isFunction, ae = le("./XMLDocument"), J = le("./XMLDocumentCB"), F = le("./XMLStringWriter"), o = le("./XMLStreamWriter"), ce.exports.create = function(h, e, y, c) {
          var d, m;
          if (h == null)
            throw new Error("Root element needs a name.");
          return c = t({}, e, y, c), d = new ae(c), m = d.element(h), c.headless || (d.declaration(c), (c.pubID != null || c.sysID != null) && d.doctype(c)), m;
        }, ce.exports.begin = function(h, e, y) {
          var c;
          return a(h) && (c = [h, e], e = c[0], y = c[1], h = {}), e ? new J(h, e, y) : new ae(h);
        }, ce.exports.stringWriter = function(h) {
          return new F(h);
        }, ce.exports.streamWriter = function(h, e) {
          return new o(h, e);
        };
      }).call(this);
    }, { "./Utility": 122, "./XMLDocument": 132, "./XMLDocumentCB": 133, "./XMLStreamWriter": 138, "./XMLStringWriter": 139 }] }, {}, [21])(21);
  });
})(mammoth_browser);
const mammoth = /* @__PURE__ */ getDefaultExportFromCjs(mammoth_browserExports), wrapper$2 = "_wrapper_1n25d_1", thumbnail = "_thumbnail_1n25d_9", loading = "_loading_1n25d_14", s$2 = {
  wrapper: wrapper$2,
  thumbnail,
  loading
}, DOCXViewer = ({ filePath: be, isThumbnail: ge }) => {
  const le = `${be}${ge ? "-thumb" : ""}`, ce = async (re) => {
    const ae = document.getElementById(le);
    try {
      const J = await mammoth.convertToHtml({
        arrayBuffer: re
      }), o = document.createElement("div");
      o.innerHTML = J.value, ae && (ae.innerHTML = o.outerHTML);
    } catch (J) {
      ae && (ae.innerHTML = J.message);
    }
  };
  return reactExports.useEffect(() => {
    const re = new XMLHttpRequest();
    re.open("GET", be, !0), re.send(), re.responseType = "arraybuffer", re.onreadystatechange = () => {
      re.readyState === 4 && re.status === 200 && ce(re.response);
    };
  }, []), /* @__PURE__ */ jsx("div", { id: le, className: `${s$2.wrapper} ${ge ? s$2.thumbnail : ""}`, children: /* @__PURE__ */ jsx("div", { className: s$2.loading, children: "Loading document..." }) });
}, wrapper$1 = "_wrapper_1awyo_1", s$1 = {
  wrapper: wrapper$1
}, UnsupportedViewer = () => /* @__PURE__ */ jsx("div", { className: s$1.wrapper, children: "Unsupported file format" }), wrapper = "_wrapper_lm3j5_1", viewer = "_viewer_lm3j5_7", s = {
  wrapper,
  viewer
}, FileViewer = ({
  fileType: be,
  filePath: ge,
  isThumbnail: le
}) => {
  const ce = (re) => {
    switch (be) {
      case "jpg":
      case "jpeg":
      case "gif":
      case "bmp":
      case "png":
        return /* @__PURE__ */ jsx(ImageViewer, { ...re });
      case "pdf":
        return /* @__PURE__ */ jsx(PDFViewer, { ...re });
      case "docx":
        return /* @__PURE__ */ jsx(DOCXViewer, { ...re });
      default:
        return /* @__PURE__ */ jsx(UnsupportedViewer, {});
    }
  };
  return /* @__PURE__ */ jsx("div", { className: s.wrapper, children: /* @__PURE__ */ jsx("div", { className: s.viewer, children: ce({ filePath: ge, isThumbnail: le }) }) });
};
export {
  FileViewer
};
